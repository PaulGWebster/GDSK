me kind of authority over Alice.</p>

<p>'Stand up and repeat <i>"'Tis the voice of the sluggard,"'</i>
said the Gryphon.</p>

<p>'How the creatures order one about, and make one repeat
lessons!' thought Alice; 'I might as well be at school at once.'
However, she got up, and began to repeat it, but her head was so
full of the Lobster Quadrille, that she hardly knew what she was
saying, and the words came very queer indeed:--</p>

<p>''Tis the voice of the Lobster; I heard him declare, "You have
baked me too brown, I must sugar my hair." As a duck with its
eyelids, so he with his nose Trims his belt and his buttons, and
turns out his toes.'</p>

<p>[later editions continued as follows When the sands are all
dry, he is gay as a lark, And will talk in contemptuous tones of
the Shark, But, when the tide rises and sharks are around, His
voice has a timid and tremulous sound.]</p>

<p>'That's different from what I used to say when I was a child,'
said the Gryphon.</p>

<p>'Well, I never heard it before,' said the Mock Turtle; 'but it
sounds uncommon nonsense.'</p>

<p>Alice said nothing; she had sat down with her face in her
hands, wondering if anything would <i>ever</i> happen in a
natural way again.</p>

<p>'I should like to have it explained,' said the Mock
Turtle.</p>

<p>'She can't explain it,' said the Gryphon hastily. 'Go on with
the next verse.'</p>

<p>'But about his toes?' the Mock Turtle persisted. 'How
<i>could</i> he turn them out with his nose, you know?'</p>

<p>'It's the first position in dancing.' Alice said; but was
dreadfully puzzled by the whole thing, and longed to change the
subject.</p>

<p>'Go on with the next verse,' the Gryphon repeated impatiently:
'it begins "I passed by his garden."'</p>

<p>Alice did not dare to disobey, though she felt sure it would
all come wrong, and she went on in a trembling voice:--</p>

<p><i>'I passed by his garden, and marked, with one eye, How the
Owl and the Panther were sharing a pie--'</i></p>

<p>[<tt>later editions continued as follows:</tt> <i>The Panther
took pie-crust, and gravy, and meat, While the Owl had the dish
as its share of the treat. When the pie was all finished, the
Owl, as a boon, Was kindly permitted to pocket the spoon: While
the Panther received knife and fork with a growl, And concluded
the banquet--</i>]</p>

<p>'What <i>is</i> the use of repeating all that stuff,' the Mock Turtle
interrupted, 'if you don't explain it as you go on? It's by far
the most confusing thing I ever heard!'</p>

<p>'Yes, I think you'd better leave off,' said the Gryphon: and
Alice was only too glad to do so.</p>

<p>'Shall we try another figure of the Lobster Quadrille?' the
Gryphon went on. 'Or would you like the Mock Turtle to sing you a
song?'</p>

<p>'Oh, a song, please, if the Mock Turtle would be so kind,'
Alice replied, so eagerly that the Gryphon said, in a rather
offended tone, 'Hm! No accounting for tastes! Sing her "Turtle
Soup," will you, old fellow?'</p>

<p>The Mock Turtle sighed deeply, and began, in a voice sometimes
choked with sobs, to sing this:--</p>

<p><i>'Beautiful Soup, so rich and green, Waiting in a hot
tureen! Who for such dainties would not stoop? Soup of the
evening, beautiful Soup! Soup of the evening, beautiful Soup!
Beau--ootiful Soo--oop! Beau--ootiful Soo--oop! Soo--oop of the
e--e--evening, Beautiful, beautiful Soup!</i></p>

<p><i>'Beautiful Soup! Who cares for fish, Game, or any other
dish? Who would not give all else for two pennyworth only of
beautiful Soup? Pennyworth only of beautiful Soup? Beau--ootiful
Soo--oop! Beau--ootiful Soo--oop! Soo--oop of the e--e--evening,
Beautiful, beauti--FUL SOUP!'</i></p>

<p>'Chorus again!' cried the Gryphon, and the Mock Turtle had
just begun to repeat it, when a cry of 'The trial's beginning!'
was heard in the distance.</p>

<p>'Come on!' cried the Gryphon, and, taking Alice by the hand,
it hurried off, without waiting for the end of the song.</p>

<p>'What trial is it?' Alice panted as she ran; but the Gryphon
only answered 'Come on!' and ran the faster, while more and more
faintly came, carried on the breeze that followed them, the
melancholy words:--</p>

<p><i>'Soo--oop of the e--e--evening, Beautiful, beautiful
Soup!'</i></p>

<hr>
<h3 align="Center">CHAPTER XI</h3>

<h3 align="Center">Who Stole the Tarts?</h3>

<p>The King and Queen of Hearts were seated on their throne when
they arrived, with a great crowd assembled about them--all sorts
of little birds and beasts, as well as the whole pack of cards:
the Knave was standing before them, in chains, with a soldier on
each side to guard him; and near the King was the White Rabbit,
with a trumpet in one hand, and a scroll of parchment in the
other. In the very middle of the court was a table, with a large
dish of tarts upon it: they looked so good, that it made Alice
quite hungry to look at them--'I wish they'd get the trial done,'
she thought, 'and hand round the refreshments!' But there seemed
to be no chance of this, so she began looking at everything about
her, to pass away the time.</p>

<p>Alice had never been in a court of justice before, but she had
read about them in books, and she was quite pleased to find that
she knew the name of nearly everything there. 'That's the judge,'
she said to herself, 'because of his great wig.'</p>

<p>The judge, by the way, was the King; and as he wore his crown
over the wig, (look at the frontispiece if you want to see how he
did it,) he did not look at all comfortable, and it was certainly
not becoming.</p>

<p>'And that's the jury-box,' thought Alice, 'and those twelve
creatures,' (she was obliged to say 'creatures,' you see, because
some of them were animals, and some were birds,) 'I suppose they
are the jurors.' She said this last word two or three times over
to herself, being rather proud of it: for she thought, and
rightly too, that very few little girls of her age knew the
meaning of it at all. However, 'jury-men' would have done just as
well.</p>

<p>The twelve jurors were all writing very busily on slates.
'What are they doing?' Alice whispered to the Gryphon. 'They
can't have anything to put down yet, before the trial's
begun.'</p>

<p>'They're putting down their names,' the Gryphon whispered in
reply, 'for fear they should forget them before the end of the
trial.'</p>

<p>'Stupid things!' Alice began in a loud, indignant voice, but
she stopped hastily, for the White Rabbit cried out, 'Silence in
the court!' and the King put on his spectacles and looked
anxiously round, to make out who was talking.</p>

<p>Alice could see, as well as if she were looking over their
shoulders, that all the jurors were writing down 'stupid things!'
on their slates, and she could even make out that one of them
didn't know how to spell 'stupid,' and that he had to ask his
neighbour to tell him. 'A nice muddle their slates'll be in
before the trial's over!' thought Alice.</p>

<p>One of the jurors had a pencil that squeaked. This of course,
Alice could <i>not</i> stand, and she went round the court and
got behind him, and very soon found an opportunity of taking it
away. She did it so quickly that the poor little juror (it was
Bill, the Lizard) could not make out at all what had become of
it; so, after hunting all about for it, he was obliged to write
with one finger for the rest of the day; and this was of very
little use, as it left no mark on the slate.</p>

<p>'Herald, read the accusation!' said the King.</p>

<p>On this the White Rabbit blew three blasts on the trumpet, and
then unrolled the parchment scroll, and read as follows:--</p>

<p><i>'The Queen of Hearts, she made some tarts, All on a summer
day: The Knave of Hearts, he stole those tarts, And took them
quite away!'</i></p>

<p>'Consider your verdict,' the King said to the jury.</p>

<p>'Not yet, not yet!' the Rabbit hastily interrupted. 'There's a
great deal to come before that!'</p>

<p>'Call the first witness,' said the King; and the White Rabbit
blew three blasts on the trumpet, and called out, 'First
witness!'</p>

<p>The first witness was the Hatter. He came in with a teacup in
one hand and a piece of bread-and-butter in the other. 'I beg
pardon, your Majesty,' he began, 'for bringing these in: but I
hadn't quite finished my tea when I was sent for.'</p>

<p>'You ought to have finished,' said the King. 'When did you
begin?'</p>

<p>The Hatter looked at the March Hare, who had followed him into
the court, arm-in-arm with the Dormouse. 'Fourteenth of March, I
<i>think</i> it was,' he said.</p>

<p>'Fifteenth,' said the March Hare.</p>

<p>'Sixteenth,' added the Dormouse.</p>

<p>'Write that down,' the King said to the jury, and the jury
eagerly wrote down all three dates on their slates, and then
added them up, and reduced the answer to shillings and pence.</p>

<p>'Take off your hat,' the King said to the Hatter.</p>

<p>'It isn't mine,' said the Hatter.</p>

<p>'<i>Stolen!</i>' the King exclaimed, turning to the jury, who
instantly made a memorandum of the fact.</p>

<p>'I keep them to sell,' the Hatter added as an explanation;
'I've none of my own. I'm a hatter.'</p>

<p>Here the Queen put on her spectacles, and began staring at the
Hatter, who turned pale and fidgeted.</p>

<p>'Give your evidence,' said the King; 'and don't be nervous, or
I'll have you executed on the spot.'</p>

<p>This did not seem to encourage the witness at all: he kept
shifting from one foot to the other, looking uneasily at the
Queen, and in his confusion he bit a large piece out of his
teacup instead of the bread-and-butter.</p>

<p>Just at this moment Alice felt a very curious sensation, which
puzzled her a good deal until she made out what it was: she was
beginning to grow larger again, and she thought at first she
would get up and leave the court; but on second thoughts she
decided to remain where she was as long as there was room for
her.</p>

<p>'I wish you wouldn't squeeze so.' said the Dormouse, who was
sitting next to her. 'I can hardly breathe.'</p>

<p>'I can't help it,' said Alice very meekly: 'I'm growing.'</p>

<p>'You've no right to grow <i>here</i>,' said the Dormouse.</p>

<p>'Don't talk nonsense,' said Alice more boldly: 'you know
you're growing too.'</p>

<p>'Yes, but <i>I</i> grow at a reasonable pace,' said the
Dormouse: 'not in that ridiculous fashion.' And he got up very
sulkily and crossed over to the other side of the court.</p>

<p>All this time the Queen had never left off staring at the
Hatter, and, just as the Dormouse crossed the court, she said to
one of the officers of the court, 'Bring me the list of the
singers in the last concert!' on which the wretched Hatter
trembled so, that he shook both his shoes off.</p>

<p>'Give your evidence,' the King repeated angrily, 'or I'll have
you executed, whether you're nervous or not.'</p>

<p>'I'm a poor man, your Majesty,' the Hatter began, in a
trembling voice, '--and I hadn't begun my tea--not above a week
or so--and what with the bread-and-butter getting so thin--and
the twinkling of the tea--'</p>

<p>'The twinkling of the <i>what</i>?' said the King.</p>

<p>'It <i>began</i> with the tea,' the Hatter replied.</p>

<p>'Of course twinkling <i>begins</i> with a T!' said the King
sharply. 'Do you take me for a dunce? Go on!'</p>

<p>'I'm a poor man,' the Hatter went on, 'and most things
twinkled after that--only the March Hare said--'</p>

<p>'I didn't!' the March Hare interrupted in a great hurry.</p>

<p>'You did!' said the Hatter.</p>

<p>'I deny it!' said the March Hare.</p>

<p>'He denies it,' said the King: 'leave out that part.'</p>

<p>'Well, at any rate, the Dormouse said--' the Hatter went on,
looking anxiously round to see if he would deny it too: but the
Dormouse denied nothing, being fast asleep.</p>

<p>'After that,' continued the Hatter, 'I cut some more bread-
and-butter--'</p>

<p>'But what did the Dormouse say?' one of the jury asked.</p>

<p>'That I can't remember,' said the Hatter.</p>

<p>'You <i>must</i> remember,' remarked the King, 'or I'll have
you executed.'</p>

<p>The miserable Hatter dropped his teacup and bread-and-butter,
and went down on one knee. 'I'm a poor man, your Majesty,' he
began.</p>

<p>'You're a very poor <i>speaker</i>,' said the King.</p>

<p>Here one of the guinea-pigs cheered, and was immediately
suppressed by the officers of the court. (As that is rather a
hard word, I will just explain to you how it was done. They had a
large canvas bag, which tied up at the mouth with strings: into
this they slipped the guinea-pig, head first, and then sat upon
it.)</p>

<p>'I'm glad I've seen that done,' thought Alice. 'I've so often
read in the newspapers, at the end of trials, "There was some
attempts at applause, which was immediately suppressed by the
officers of the court," and I never understood what it meant till
now.'</p>

<p>'If that's all you know about it, you may stand down,'
continued the King.</p>

<p>'I can't go no lower,' said the Hatter: 'I'm on the floor, as
it is.'</p>

<p>'Then you may <i>sit</i> down,' the King replied.</p>

<p>Here the other guinea-pig cheered, and was suppressed.</p>

<p>'Come, that finished the guinea-pigs!' thought Alice. 'Now we
shall get on better.'</p>

<p>'I'd rather finish my tea,' said the Hatter, with an anxious
look at the Queen, who was reading the list of singers.</p>

<p>'You may go,' said the King, and the Hatter hurriedly left the
court, without even waiting to put his shoes on.</p>

<p>'--and just take his head off outside,' the Queen added to one
of the officers: but the Hatter was out of sight before the
officer could get to the door.</p>

<p>'Call the next witness!' said the King.</p>

<p>The next witness was the Duchess's cook. She carried the
pepper-box in her hand, and Alice guessed who it was, even before
she got into the court, by the way the people near the door began
sneezing all at once.</p>

<p>'Give your evidence,' said the King.</p>

<p>'Shan't,' said the cook.</p>

<p>The King looked anxiously at the White Rabbit, who said in a
low voice, 'Your Majesty must cross-examine <i>this</i> witness.'</p>

<p>'Well, if I must, I must,' the King said, with a melancholy
air, and, after folding his arms and frowning at the cook till
his eyes were nearly out of sight, he said in a deep voice, 'What
are tarts made of?'</p>

<p>'Pepper, mostly,' said the cook.</p>

<p>'Treacle,' said a sleepy voice behind her.</p>

<p>'Collar that Dormouse,' the Queen shrieked out. 'Behead that
Dormouse! Turn that Dormouse out of court! Suppress him! Pinch
him! Off with his whiskers!'</p>

<p>For some minutes the whole court was in confusion, getting the
Dormouse turned out, and, by the time they had settled down
again, the cook had disappeared.</p>

<p>'Never mind!' said the King, with an air of great relief.
'Call the next witness.' And he added in an undertone to the
Queen, 'Really, my dear, <i>you</i> must cross-examine the next
witness. It quite makes my forehead ache!'</p>

<p>Alice watched the White Rabbit as he fumbled over the list,
feeling very curious to see what the next witness would be like,
'--for they haven't got much evidence <i>yet</i>,' she said to
herself. Imagine her surprise, when the White Rabbit read out, at
the top of his shrill little voice, the name 'Alice!'</p>

<hr>
<h3 align="Center">CHAPTER XII</h3>

<h3 align="Center">Alice's Evidence</h3>

<p>'Here!' cried Alice, quite forgetting in the flurry of the
moment how large she had grown in the last few minutes, and she
jumped up in such a hurry that she tipped over the jury-box with
the edge of her skirt, upsetting all the jurymen on to the heads
of the crowd below, and there they lay sprawling about, reminding
her very much of a globe of goldfish she had accidentally upset
the week before.</p>

<p>'Oh, I <i>beg</i> your pardon!' she exclaimed in a tone of
great dismay, and began picking them up again as quickly as she
could, for the accident of the goldfish kept running in her head,
and she had a vague sort of idea that they must be collected at
once and put back into the jury-box, or they would die.</p>

<p>'The trial cannot proceed,' said the King in a very grave
voice, 'until all the jurymen are back in their proper places--
<i>all</i>,' he repeated with great emphasis, looking hard at
Alice as he said do.</p>

<p>Alice looked at the jury-box, and saw that, in her haste, she
had put the Lizard in head downwards, and the poor little thing
was waving its tail about in a melancholy way, being quite unable
to move. She soon got it out again, and put it right; 'not that
it signifies much,' she said to herself; 'I should think it would
be <i>quite</i> as much use in the trial one way up as the
other.'</p>

<p>As soon as the jury had a little recovered from the shock of
being upset, and their slates and pencils had been found and
handed back to them, they set to work very diligently to write
out a history of the accident, all except the Lizard, who seemed
too much overcome to do anything but sit with its mouth open,
gazing up into the roof of the court.</p>

<p>'What do you know about this business?' the King said to
Alice.</p>

<p>'Nothing,' said Alice.</p>

<p>'Nothing <i>whatever?</i>' persisted the King.</p>

<p>'Nothing <i>whatever,</i>' said Alice.</p>

<p>'That's very important,' the King said, turning to the jury.
They were just beginning to write this down on their slates, when
the White Rabbit interrupted: '<i>Un</i>important, your Majesty
means, of course,' he said in a very respectful tone, but
frowning and making faces at him as he spoke.</p>

<p>'<i>Un</i>important, of course, I meant,' the King hastily
said, and went on to himself in an undertone,
'important--unimportant-- unimportant--important--' as if he were
trying which word sounded best.</p>

<p>Some of the jury wrote it down 'important,' and some
'unimportant.' Alice could see this, as she was near enough to
look over their slates; 'but it doesn't matter a bit,' she
thought to herself.</p>

<p>At this moment the King, who had been for some time busily
writing in his note-book, cackled out 'Silence!' and read out
from his book, 'Rule Forty-two. <i>All persons more than a mile
hight to leave the court</i>.'</p>

<p>Everybody looked at Alice.</p>

<p>'<i>I'm</i> not a mile high,' said Alice.</p>

<p>'You are,' said the King.</p>

<p>'Nearly two miles high,' added the Queen.</p>

<p>'Well, I shan't go, at any rate,' said Alice: 'besides, that's
not a regular rule: you invented it just now.'</p>

<p>'It's the oldest rule in the book,' said the King.</p>

<p>'Then it ought to be Number One,' said Alice.</p>

<p>The King turned pale, and shut his note-book hastily.
'Consider your verdict,' he said to the jury, in a low, trembling
voice.</p>

<p>'There's more evidence to come yet, please your Majesty,' said
the White Rabbit, jumping up in a great hurry; 'this paper has
just been picked up.'</p>

<p>'What's in it?' said the Queen.</p>

<p>'I haven't opened it yet,' said the White Rabbit, 'but it
seems to be a letter, written by the prisoner to--to
somebody.'</p>

<p>'It must have been that,' said the King, 'unless it was
written to nobody, which isn't usual, you know.'</p>

<p>'Who is it directed to?' said one of the jurymen.</p>

<p>'It isn't directed at all,' said the White Rabbit; 'in fact,
there's nothing written on the <i>outside</i>.' He unfolded the
paper as he spoke, and added 'It isn't a letter, after all: it's
a set of verses.'</p>

<p>'Are they in the prisoner's handwriting?' asked another of
they jurymen.</p>

<p>'No, they're not,' said the White Rabbit, 'and that's the
queerest thing about it.' (The jury all looked puzzled.)</p>

<p>'He must have imitated somebody else's hand,' said the King.
(The jury all brightened up again.)</p>

<p>'Please your Majesty,' said the Knave, 'I didn't write it, and
they can't prove I did: there's no name signed at the end.'</p>

<p>'If you didn't sign it,' said the King, 'that only makes the
matter worse. You <i>must</i> have meant some mischief, or else
you'd have signed your name like an honest man.'</p>

<p>There was a general clapping of hands at this: it was the
first really clever thing the King had said that day.</p>

<p>'That <i>proves</i> his guilt,' said the Queen.</p>

<p>'It proves nothing of the sort!' said Alice. 'Why, you don't
even know what they're about!'</p>

<p>'Read them,' said the King.</p>

<p>The White Rabbit put on his spectacles. 'Where shall I begin,
please your Majesty?' he asked.</p>

<p>'Begin at the beginning,' the King said gravely, 'and go on
till you come to the end: then stop.'</p>

<p>These were the verses the White Rabbit read:--</p>

<p><i>'They told me you had been to her, And mentioned me to him:
She gave me a good character, But said I could not swim.</i></p>

<p><i>He sent them word I had not gone (We know it to be true):
If she should push the matter on, What would become of
you?</i></p>

<p><i>I gave her one, they gave him two, You gave us three or
more; They all returned from him to you, Though they were mine
before.</i></p>

<p><i>If I or she should chance to be Involved in this affair, He
trusts to you to set them free, Exactly as we were.</i></p>

<p><i>My notion was that you had been (Before she had this fit)
An obstacle that came between Him, and ourselves, and it.</i></p>

<p><i>Don't let him know she liked them best, For this must ever
be A secret, kept from all the rest, Between yourself and
me.'</i></p>

<p>'That's the most important piece of evidence we've heard yet,'
said the King, rubbing his hands; 'so now let the jury--'</p>

<p>'If any one of them can explain it,' said Alice, (she had
grown so large in the last few minutes that she wasn't a bit
afraid of interrupting him,) 'I'll give him sixpence. _I_ don't
believe there's an atom of meaning in it.'</p>

<p>The jury all wrote down on their slates, '<i>She</i> doesn't
believe there's an atom of meaning in it,' but none of them
attempted to explain the paper.</p>

<p>'If there's no meaning in it,' said the King, 'that saves a
world of trouble, you know, as we needn't try to find any. And
yet I don't know,' he went on, spreading out the verses on his
knee, and looking at them with one eye; 'I seem to see some
meaning in them, after all. "<i>-said I could not swim--</i>" you
can't swim, can you?' he added, turning to the Knave.</p>

<p>The Knave shook his head sadly. 'Do I look like it?' he said.
(Which he certainly did <i>not</i>, being made entirely of
cardboard.)</p>

<p>'All right, so far,' said the King, and he went on muttering
over the verses to himself: '"<i>We know it to be true--</i>"
that's the jury, of course-- "<i>I gave her one, they gave him
two--</i>" why, that must be what he did with the tarts, you
know--'</p>

<p>'But, it goes on "<i>they all returned from him to you,</i>"'
said Alice.</p>

<p>'Why, there they are!' said the King triumphantly, pointing to
the tarts on the table. 'Nothing can be clearer than <i>that</i>.
Then again--"<i>before she had this fit-</i>-" you never had
<i>fits</i>, my dear, I think?' he said to the Queen.</p>

<p>'Never!' said the Queen furiously, throwing an inkstand at the
Lizard as she spoke. (The unfortunate little Bill had left off
writing on his slate with one finger, as he found it made no
mark; but he now hastily began again, using the ink, that was
trickling down his face, as long as it lasted.)</p>

<p>'Then the words don't <i>fit</i> you,' said the King, looking
round the court with a smile. There was a dead silence.</p>

<p>'It's a pun!' the King added in an offended tone, and
everybody laughed, 'Let the jury consider their verdict,' the
King said, for about the twentieth time that day.</p>

<p>'No, no!' said the Queen. 'Sentence first--verdict
afterwards.'</p>

<p>'Stuff and nonsense!' said Alice loudly. 'The idea of having
the sentence first!'</p>

<p>'Hold your tongue!' said the Queen, turning purple.</p>

<p>'I won't!' said Alice.</p>

<p>'Off with her head!' the Queen shouted at the top of her
voice. Nobody moved.</p>

<p>'Who cares for you?' said Alice, (she had grown to her full
size by this time.) 'You're nothing but a pack of cards!'</p>

<p>At this the whole pack rose up into the air, and came flying
down upon her: she gave a little scream, half of fright and half
of anger, and tried to beat them off, and found herself lying on
the bank, with her head in the lap of her sister, who was gently
brushing away some dead leaves that had fluttered down from the
trees upon her face.</p>

<p>'Wake up, Alice dear!' said her sister; 'Why, what a long
sleep you've had!'</p>

<p>'Oh, I've had such a curious dream!' said Alice, and she told
her sister, as well as she could remember them, all these strange
Adventures of hers that you have just been reading about; and
when she had finished, her sister kissed her, and said, 'It
<i>was</i> a curious dream, dear, certainly: but now run in to
your tea; it's getting late.' So Alice got up and ran off,
thinking while she ran, as well she might, what a wonderful dream
it had been.</p>

<p>But her sister sat still just as she left her, leaning her
head on her hand, watching the setting sun, and thinking of
little Alice and all her wonderful Adventures, till she too began
dreaming after a fashion, and this was her dream:--</p>

<p>First, she dreamed of little Alice herself, and once again the
tiny hands were clasped upon her knee, and the bright eager eyes
were looking up into hers--she could hear the very tones of her
voice, and see that queer little toss of her head to keep back
the wandering hair that <i>would</i> always get into her
eyes--and still as she listened, or seemed to listen, the whole
place around her became alive the strange creatures of her little
sister's dream.</p>

<p>The long grass rustled at her feet as the White Rabbit hurried
by--the frightened Mouse splashed his way through the
neighbouring pool--she could hear the rattle of the teacups as
the March Hare and his friends shared their never-ending meal,
and the shrill voice of the Queen ordering off her unfortunate
guests to execution--once more the pig-baby was sneezing on the
Duchess's knee, while plates and dishes crashed around it--once
more the shriek of the Gryphon, the squeaking of the Lizard's
slate-pencil, and the choking of the suppressed guinea-pigs,
filled the air, mixed up with the distant sobs of the miserable
Mock Turtle.</p>

<p>So she sat on, with closed eyes, and half believed herself in
Wonderland, though she knew she had but to open them again, and
all would change to dull reality--the grass would be only
rustling in the wind, and the pool rippling to the waving of the
reeds--the rattling teacups would change to tinkling sheep-bells,
and the Queen's shrill cries to the voice of the shepherd
boy--and the sneeze of the baby, the shriek of the Gryphon, and
all the other queer noises, would change (she knew) to the
confused clamour of the busy farm-yard--while the lowing of the
cattle in the distance would take the place of the Mock Turtle's
heavy sobs.</p>

<p>Lastly, she pictured to herself how this same little sister of
hers would, in the after-time, be herself a grown woman; and how
she would keep, through all her riper years, the simple and
loving heart of her childhood: and how she would gather about her
other little children, and make <i>their</i> eyes bright and eager with
many a strange tale, perhaps even with the dream of Wonderland of
long ago: and how she would feel with all their simple sorrows,
and find a pleasure in all their simple joys, remembering her own
child-life, and the happy summer days.</p>

<p>End of the Project Gutenberg Etext of Alice's Adventures in
Wonderland</p>

</body>
</html>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/fixtures/basic-test-runner.js                                                 0000664 0000000 0000000 00000000535 14746647661 0022266 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { test } = require('node:test');

test('should pass', () => {});
test('should fail', () => { throw new Error('fail'); });
test('should skip', { skip: true }, () => {});
test('parent', (t) => {
  t.test('should fail', () => { throw new Error('fail'); });
  t.test('should pass but parent fail', (t, done) => {
    setImmediate(done);
  });
});
                                                                                                                                                                   node-23.7.0/benchmark/fixtures/coverage-many-branches.js                                            0000664 0000000 0000000 00000006333 14746647661 0023243 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Exercise coverage of a class. Note, this logic is silly and exists solely
// to generate branch coverage code paths:
class CoveredClass {
  constructor(x, y, opts) {
    this.x = x;
    this.y = y;
    // Exercise coverage of nullish coalescing:
    this.opts = opts ?? (Math.random() > 0.5 ? {} : undefined);
  }
  add() {
    return this.x + this.y;
  }
  addSpecial() {
    // Exercise coverage of optional chains:
    if (this.opts?.special && this.opts?.special?.x && this.opts?.special?.y) {
      return this.opts.special.x + this.opts.special.y;
    }
    return add();
  }
  mult() {
    return this.x * this.y;
  }
  multSpecial() {
    if (this.opts?.special && this.opts?.special?.x && this.opts?.special?.y) {
      return this.opts.special.x * this.opts.special.y;
    }
    return mult();
  }
}

// Excercise coverage of functions:
function add(x, y) {
  const mt = new CoveredClass(x, y);
  return mt.add();
}

function addSpecial(x, y) {
  let mt;
  if (Math.random() > 0.5) {
    mt = new CoveredClass(x, y);
  } else {
    mt = new CoveredClass(x, y, {
      special: {
        x: Math.random() * x,
        y: Math.random() * y
      }
    });
  }
  return mt.addSpecial();
}

function mult(x, y) {
  const mt = new CoveredClass(x, y);
  return mt.mult();
}

function multSpecial(x, y) {
  let mt;
  if (Math.random() > 0.5) {
    mt = new CoveredClass(x, y);
  } else {
    mt = new CoveredClass(x, y, {
      special: {
        x: Math.random() * x,
        y: Math.random() * y
      }
    });
  }
  return mt.multSpecial();
}

for (let i = 0; i < parseInt(process.env.N); i++) {
  const operations = ['add', 'addSpecial', 'mult', 'multSpecial'];
  for (const operation of operations) {
    // Exercise coverage of switch statements:
    switch (operation) {
      case 'add':
        if (add(Math.random() * 10, Math.random() * 10) > 10) {
          // Exercise coverage of ternary operations:
          let r = addSpecial(Math.random() * 10, Math.random() * 10) > 10 ?
            mult(Math.random() * 10, Math.random() * 10) :
            add(Math.random() * 10, Math.random() * 10);
          // Exercise && and ||
          if (r && Math.random() > 0.5 || Math.random() < 0.5) r++;
        }
        break;
      case 'addSpecial':
        if (addSpecial(Math.random() * 10, Math.random() * 10) > 10 &&
            add(Math.random() * 10, Math.random() * 10) > 10) {
          let r = mult(Math.random() * 10, Math.random() * 10) > 10 ?
            add(Math.random() * 10, Math.random() * 10) > 10 :
            mult(Math.random() * 10, Math.random() * 10);
          if (r && Math.random() > 0.5 || Math.random() < 0.5) r++;
        }
        break;
      case 'mult':
        if (mult(Math.random() * 10, Math.random() * 10) > 10) {
          let r = multSpecial(Math.random() * 10, Math.random() * 10) > 10 ?
            add(Math.random() * 10, Math.random() * 10) :
            mult(Math.random() * 10, Math.random() * 10);
          if (r && Math.random() > 0.5 || Math.random() < 0.5) r++;
        }
        break;
      case 'multSpecial':
        while (multSpecial(Math.random() * 10, Math.random() * 10) < 10) {
          mult(Math.random() * 10, Math.random() * 10);
        }
        break;
      default:
        break;
    }
  }
}
                                                                                                                                                                                                                                                                                                     node-23.7.0/benchmark/fixtures/echo.worker.js                                                       0000664 0000000 0000000 00000000211 14746647661 0021136 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const { parentPort } = require('worker_threads');

parentPort.on('message', (msg) => {
  parentPort.postMessage(msg);
});
                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/benchmark/fixtures/empty-test-reporter.js                                               0000664 0000000 0000000 00000000255 14746647661 0022673 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { PassThrough } = require('node:stream');

module.exports = new PassThrough({
  objectMode: true,
  transform(chunk, encoding, callback) {
    callback(null)
  },
});
                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/benchmark/fixtures/esm-dir-file.mjs                                                     0000664 0000000 0000000 00000000132 14746647661 0021344 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        export const dirname = import.meta.dirname;
export const filename = import.meta.filename;
                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/benchmark/fixtures/node_modules/                                                        0000775 0000000 0000000 00000000000 14746647661 0021035 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/fixtures/node_modules/error-stack/                                            0000775 0000000 0000000 00000000000 14746647661 0023271 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/fixtures/node_modules/error-stack/simple-error-stack.js                       0000664 0000000 0000000 00000002653 14746647661 0027360 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.simpleErrorStack = simpleErrorStack;
// Compile with `tsc --inlineSourceMap benchmark/fixtures/node_modules/error-stack/simple-error-stack.ts`.
var lorem = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';
function simpleErrorStack() {
    [1].map(function () {
        try {
            lorem.BANG();
        }
        catch (e) {
            return e.stack;
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2ltcGxlLWVycm9yLXN0YWNrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2ltcGxlLWVycm9yLXN0YWNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7QUFpQlgsNENBQWdCO0FBZmxCLGlGQUFpRjtBQUVqRixJQUFNLEtBQUssR0FBRywrYkFBK2IsQ0FBQztBQUU5YyxTQUFTLGdCQUFnQjtJQUN2QixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUNOLElBQUksQ0FBQztZQUNGLEtBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN4QixDQUFDO1FBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUNYLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUNqQixDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUE7QUFDSixDQUFDIn0=
                                                                                     node-23.7.0/benchmark/fixtures/node_modules/error-stack/simple-error-stack.ts                       0000664 0000000 0000000 00000001370 14746647661 0027365 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Compile with `tsc --inlineSourceMap benchmark/fixtures/node_modules/error-stack/simple-error-stack.ts`.

const lorem = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';

function simpleErrorStack() {
  [1].map(() => {
    try {
      (lorem as any).BANG();
    } catch (e) {
      return e.stack;
    }
  })
}

export {
  simpleErrorStack,
};
                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/fixtures/require-builtins.js                                                  0000664 0000000 0000000 00000001012 14746647661 0022213 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const list = [
  'async_hooks',
  'assert',
  'buffer',
  'child_process',
  'console',
  'constants',
  'crypto',
  'cluster',
  'dgram',
  'dns',
  'domain',
  'events',
  'fs',
  'http',
  'http2',
  'https',
  'module',
  'net',
  'os',
  'path',
  'perf_hooks',
  'process',
  'querystring',
  'readline',
  'repl',
  'stream',
  'string_decoder',
  'timers',
  'tls',
  'tty',
  'url',
  'util',
  'vm',
  'zlib',
];

for (let i = 0; i < list.length; ++i) {
  const item = list[i];
  require(item);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/benchmark/fixtures/simple-error-stack.js                                                0000664 0000000 0000000 00000002621 14746647661 0022442 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.simpleErrorStack = simpleErrorStack;
// Compile with `tsc --inlineSourceMap benchmark/fixtures/simple-error-stack.ts`.
var lorem = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';
function simpleErrorStack() {
    [1].map(function () {
        try {
            lorem.BANG();
        }
        catch (e) {
            return e.stack;
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2ltcGxlLWVycm9yLXN0YWNrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2ltcGxlLWVycm9yLXN0YWNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7QUFpQlgsNENBQWdCO0FBZmxCLGlGQUFpRjtBQUVqRixJQUFNLEtBQUssR0FBRywrYkFBK2IsQ0FBQztBQUU5YyxTQUFTLGdCQUFnQjtJQUN2QixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUNOLElBQUksQ0FBQztZQUNGLEtBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN4QixDQUFDO1FBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUNYLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUNqQixDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUE7QUFDSixDQUFDIn0=                                                                                                               node-23.7.0/benchmark/fixtures/simple-error-stack.ts                                                0000664 0000000 0000000 00000001337 14746647661 0022457 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Compile with `tsc --inlineSourceMap benchmark/fixtures/simple-error-stack.ts`.

const lorem = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';

function simpleErrorStack() {
  [1].map(() => {
    try {
      (lorem as any).BANG();
    } catch (e) {
      return e.stack;
    }
  })
}

export {
  simpleErrorStack,
};
                                                                                                                                                                                                                                                                                                 node-23.7.0/benchmark/fixtures/simple-http-server.js                                                0000664 0000000 0000000 00000007444 14746647661 0022501 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const http = require('http');

const fixed = 'C'.repeat(20 * 1024);
const storedBytes = Object.create(null);
const storedBuffer = Object.create(null);
const storedUnicode = Object.create(null);

const useDomains = process.env.NODE_USE_DOMAINS;

// Set up one global domain.
let domain;
if (useDomains) {
  domain = require('domain');
  const gdom = domain.create();
  gdom.on('error', (er) => {
    console.error('Error on global domain', er);
    throw er;
  });
  gdom.enter();
}

module.exports = http.createServer((req, res) => {
  if (useDomains) {
    const dom = domain.create();
    dom.add(req);
    dom.add(res);
  }

  // URL format: /<type>/<length>/<chunks>/<responseBehavior>/chunkedEnc
  const params = req.url.split('/');
  const command = params[1];
  let body = '';
  const arg = params[2];
  const n_chunks = parseInt(params[3], 10);
  const resHow = params.length >= 5 ? params[4] : 'normal';
  const chunkedEnc = params.length >= 6 && params[5] === '0' ? false : true;
  let status = 200;

  let n, i;
  if (command === 'bytes') {
    n = ~~arg;
    if (n <= 0)
      throw new Error('bytes called with n <= 0');
    if (storedBytes[n] === undefined) {
      storedBytes[n] = 'C'.repeat(n);
    }
    body = storedBytes[n];
  } else if (command === 'buffer') {
    n = ~~arg;
    if (n <= 0)
      throw new Error('buffer called with n <= 0');
    if (storedBuffer[n] === undefined) {
      storedBuffer[n] = Buffer.allocUnsafe(n);
      for (i = 0; i < n; i++) {
        storedBuffer[n][i] = 'C'.charCodeAt(0);
      }
    }
    body = storedBuffer[n];
  } else if (command === 'unicode') {
    n = ~~arg;
    if (n <= 0)
      throw new Error('unicode called with n <= 0');
    if (storedUnicode[n] === undefined) {
      storedUnicode[n] = '\u263A'.repeat(n);
    }
    body = storedUnicode[n];
  } else if (command === 'quit') {
    res.connection.server.close();
    body = 'quitting';
  } else if (command === 'fixed') {
    body = fixed;
  } else if (command === 'echo') {
    switch (resHow) {
      case 'setHeader':
        res.statusCode = 200;
        res.setHeader('Content-Type', 'text/plain');
        res.setHeader('Transfer-Encoding', 'chunked');
        break;
      case 'setHeaderWH':
        res.setHeader('Content-Type', 'text/plain');
        res.writeHead(200, { 'Transfer-Encoding': 'chunked' });
        break;
      default:
        res.writeHead(200, {
          'Content-Type': 'text/plain',
          'Transfer-Encoding': 'chunked'
        });
    }
    req.pipe(res);
    return;
  } else {
    status = 404;
    body = 'not found\n';
  }

  // example: http://localhost:port/bytes/512/4
  // sends a 512 byte body in 4 chunks of 128 bytes
  const len = body.length;
  switch (resHow) {
    case 'setHeader':
      res.statusCode = status;
      res.setHeader('Content-Type', 'text/plain');
      if (chunkedEnc)
        res.setHeader('Transfer-Encoding', 'chunked');
      else
        res.setHeader('Content-Length', len.toString());
      break;
    case 'setHeaderWH':
      res.setHeader('Content-Type', 'text/plain');
      if (chunkedEnc)
        res.writeHead(status, { 'Transfer-Encoding': 'chunked' });
      else
        res.writeHead(status, { 'Content-Length': len.toString() });
      break;
    default:
      if (chunkedEnc) {
        res.writeHead(status, {
          'Content-Type': 'text/plain',
          'Transfer-Encoding': 'chunked'
        });
      } else {
        res.writeHead(status, {
          'Content-Type': 'text/plain',
          'Content-Length': len.toString()
        });
      }
  }
  // send body in chunks
  if (n_chunks > 1) {
    const step = Math.floor(len / n_chunks) || 1;
    for (i = 0, n = (n_chunks - 1); i < n; ++i)
      res.write(body.slice(i * step, i * step + step));
    res.end(body.slice((n_chunks - 1) * step));
  } else {
    res.end(body);
  }
});
                                                                                                                                                                                                                            node-23.7.0/benchmark/fixtures/simple-https-server.js                                               0000664 0000000 0000000 00000003642 14746647661 0022660 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const fixtures = require('../../test/common/fixtures');
const https = require('https');

const options = {
  key: fixtures.readKey('rsa_private.pem'),
  cert: fixtures.readKey('rsa_cert.crt')
};

const storedBytes = Object.create(null);
const storedBuffer = Object.create(null);

module.exports = https.createServer(options, (req, res) => {
  // URL format: /<type>/<length>/<chunks>/chunkedEnc
  const params = req.url.split('/');
  const command = params[1];
  let body = '';
  const arg = params[2];
  const n_chunks = parseInt(params[3], 10);
  const chunkedEnc = params.length >= 5 && params[4] === '0' ? false : true;
  let status = 200;

  let n, i;
  if (command === 'bytes') {
    n = ~~arg;
    if (n <= 0)
      throw new Error('bytes called with n <= 0');
    if (storedBytes[n] === undefined) {
      storedBytes[n] = 'C'.repeat(n);
    }
    body = storedBytes[n];
  } else if (command === 'buffer') {
    n = ~~arg;
    if (n <= 0)
      throw new Error('buffer called with n <= 0');
    if (storedBuffer[n] === undefined) {
      storedBuffer[n] = Buffer.allocUnsafe(n);
      for (i = 0; i < n; i++) {
        storedBuffer[n][i] = 'C'.charCodeAt(0);
      }
    }
    body = storedBuffer[n];
  } else {
    status = 404;
    body = 'not found\n';
  }

  // example: https://localhost:port/bytes/512/4
  // sends a 512 byte body in 4 chunks of 128 bytes
  const len = body.length;
  if (chunkedEnc) {
    res.writeHead(status, {
      'Content-Type': 'text/plain',
      'Transfer-Encoding': 'chunked'
    });
  } else {
    res.writeHead(status, {
      'Content-Type': 'text/plain',
      'Content-Length': len.toString()
    });
  }
  // send body in chunks
  if (n_chunks > 1) {
    const step = Math.floor(len / n_chunks) || 1;
    for (i = 0, n = (n_chunks - 1); i < n; ++i)
      res.write(body.slice(i * step, i * step + step));
    res.end(body.slice((n_chunks - 1) * step));
  } else {
    res.end(body);
  }
});
                                                                                              node-23.7.0/benchmark/fixtures/strip-types-benchmark.js                                             0000664 0000000 0000000 00000000475 14746647661 0023157 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        function processData(input) {
    return {
        ...input,
        b: input.b + 1
    };
}

const data = {
    a: "test",
    b: 42,
    c: true,
    d: {
        e: ["hello", "world"],
        f: {
            g: 100,
            h: ["str", 123, false]
        }
    }
};

export const result = processData(data);
                                                                                                                                                                                                   node-23.7.0/benchmark/fixtures/strip-types-benchmark.ts                                             0000664 0000000 0000000 00000001051 14746647661 0023160 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        type ComplexType = {
    a: string;
    b: number;
    c: boolean;
    d: {
        e: string[];
        f: {
            g: number;
            h: [string, number, boolean];
        };
    };
};

function processData(input: ComplexType): ComplexType {
    return {
        ...input,
        b: input.b + 1
    };
}

const data: ComplexType = {
    a: "test",
    b: 42,
    c: true,
    d: {
        e: ["hello", "world"],
        f: {
            g: 100,
            h: ["str", 123, false]
        }
    }
};

export const result = processData(data);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/benchmark/fixtures/transform-types-benchmark.js                                         0000664 0000000 0000000 00000001443 14746647661 0024025 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        var Color;
(function (Color) {
    Color[Color["Red"] = 0] = "Red";
    Color[Color["Green"] = 1] = "Green";
    Color[Color["Blue"] = 2] = "Blue";
})(Color || (Color = {}));
var Geometry;
(function (Geometry) {
    class Circle {
        constructor(center, radius) {
            this.center = center;
            this.radius = radius;
        }
        area() {
            return Math.PI * Math.pow(this.radius, 2);
        }
    }
    Geometry.Circle = Circle;
})(Geometry || (Geometry = {}));
function processShape(color, shape) {
    const colorName = Color[color];
    const area = shape.area().toFixed(2);
    return `A ${colorName} circle with area ${area}`;
}

const point = { x: 0, y: 0 };
const circle = new Geometry.Circle(point, 5);
export const result = processShape(Color.Blue, circle);
                                                                                                                                                                                                                             node-23.7.0/benchmark/fixtures/transform-types-benchmark.ts                                         0000664 0000000 0000000 00000001250 14746647661 0024033 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        enum Color {
    Red,
    Green,
    Blue
}

namespace Geometry {
    export interface Point {
        x: number;
        y: number;
    }

    export class Circle {
        constructor(public center: Point, public radius: number) { }

        area(): number {
            return Math.PI * this.radius ** 2;
        }
    }
}

function processShape(color: Color, shape: Geometry.Circle): string {
    const colorName = Color[color];
    const area = shape.area().toFixed(2);
    return `A ${colorName} circle with area ${area}`;
}

const point: Geometry.Point = { x: 0, y: 0 };
const circle = new Geometry.Circle(point, 5);
export const result = processShape(Color.Blue, circle);
                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/fixtures/valid.env                                                            0000664 0000000 0000000 00000004114 14746647661 0020171 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        BASIC=basic

# COMMENTS=work
#BASIC=basic2
#BASIC=basic3

# previous line intentionally left blank
AFTER_LINE=after_line
EMPTY=
EMPTY_SINGLE_QUOTES=''
EMPTY_DOUBLE_QUOTES=""
EMPTY_BACKTICKS=``
SINGLE_QUOTES='single_quotes'
SINGLE_QUOTES_SPACED='    single quotes    '
DOUBLE_QUOTES="double_quotes"
DOUBLE_QUOTES_SPACED="    double quotes    "
DOUBLE_QUOTES_INSIDE_SINGLE='double "quotes" work inside single quotes'
DOUBLE_QUOTES_WITH_NO_SPACE_BRACKET="{ port: $MONGOLAB_PORT}"
SINGLE_QUOTES_INSIDE_DOUBLE="single 'quotes' work inside double quotes"
BACKTICKS_INSIDE_SINGLE='`backticks` work inside single quotes'
BACKTICKS_INSIDE_DOUBLE="`backticks` work inside double quotes"
BACKTICKS=`backticks`
BACKTICKS_SPACED=`    backticks    `
DOUBLE_QUOTES_INSIDE_BACKTICKS=`double "quotes" work inside backticks`
SINGLE_QUOTES_INSIDE_BACKTICKS=`single 'quotes' work inside backticks`
DOUBLE_AND_SINGLE_QUOTES_INSIDE_BACKTICKS=`double "quotes" and single 'quotes' work inside backticks`
EXPAND_NEWLINES="expand\nnew\nlines"
DONT_EXPAND_UNQUOTED=dontexpand\nnewlines
DONT_EXPAND_SQUOTED='dontexpand\nnewlines'
# COMMENTS=work
INLINE_COMMENTS=inline comments # work #very #well
INLINE_COMMENTS_SINGLE_QUOTES='inline comments outside of #singlequotes' # work
INLINE_COMMENTS_DOUBLE_QUOTES="inline comments outside of #doublequotes" # work
INLINE_COMMENTS_BACKTICKS=`inline comments outside of #backticks` # work
INLINE_COMMENTS_SPACE=inline comments start with a#number sign. no space required.
EQUAL_SIGNS=equals==
RETAIN_INNER_QUOTES={"foo": "bar"}
RETAIN_INNER_QUOTES_AS_STRING='{"foo": "bar"}'
RETAIN_INNER_QUOTES_AS_BACKTICKS=`{"foo": "bar's"}`
TRIM_SPACE_FROM_UNQUOTED=    some spaced out string
SPACE_BEFORE_DOUBLE_QUOTES=   "space before double quotes"
EMAIL=therealnerdybeast@example.tld
    SPACED_KEY = parsed
EDGE_CASE_INLINE_COMMENTS="VALUE1" # or "VALUE2" or "VALUE3"

MULTI_DOUBLE_QUOTED="THIS
IS
A
MULTILINE
STRING"

MULTI_SINGLE_QUOTED='THIS
IS
A
MULTILINE
STRING'

MULTI_BACKTICKED=`THIS
IS
A
"MULTILINE'S"
STRING`
export EXPORT_EXAMPLE = ignore export

MULTI_NOT_VALID_QUOTE="
MULTI_NOT_VALID=THIS
IS NOT MULTILINE
                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/benchmark/fs/                                                                           0000775 0000000 0000000 00000000000 14746647661 0015117 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/fs/bench-accessSync.js                                                        0000664 0000000 0000000 00000002565 14746647661 0020640 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const tmpfile = tmpdir.resolve(`.existing-file-${process.pid}`);
fs.writeFileSync(tmpfile, 'this-is-for-a-benchmark', 'utf8');

const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing', 'non-flat-existing'],
  method: ['access', 'accessSync'],
  n: [1e5],
});

function runBench(n, path) {
  for (let i = 0; i < n; i++) {
    try {
      fs.accessSync(path);
    } catch {
      // do nothing
    }
  }
}

function runAsyncBench(n, path) {
  (function r(cntr, path) {
    if (cntr-- <= 0)
      return bench.end(n);
    fs.access(path, () => {
      r(cntr, path);
    });
  })(n, path);
}

function main({ n, type, method }) {
  let path;

  switch (type) {
    case 'existing':
      path = __filename;
      break;
    case 'non-flat-existing':
      path = tmpfile;
      break;
    case 'non-existing':
      path = tmpdir.resolve(`.non-existing-file-${process.pid}`);
      break;
    default:
      new Error('Invalid type');
  }

  if (method === 'access') {
    // Warmup the filesystem - it doesn't need to use the async method
    runBench(n, path);

    bench.start();
    runAsyncBench(n, path);
  } else {
    // warmup
    runBench(n, path);

    bench.start();
    runBench(n, path);
    bench.end(n);
  }
}
                                                                                                                                           node-23.7.0/benchmark/fs/bench-chmodSync.js                                                         0000664 0000000 0000000 00000001656 14746647661 0020471 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing'],
  n: [1e3],
});

function main({ n, type }) {
  switch (type) {
    case 'existing': {
      for (let i = 0; i < n; i++) {
        fs.writeFileSync(tmpdir.resolve(`chmodsync-bench-file-${i}`), 'bench');
      }

      bench.start();
      for (let i = 0; i < n; i++) {
        fs.chmodSync(tmpdir.resolve(`chmodsync-bench-file-${i}`), 0o666);
      }
      bench.end(n);
      break;
    }
    case 'non-existing':
      bench.start();
      for (let i = 0; i < n; i++) {
        try {
          fs.chmodSync(tmpdir.resolve(`chmod-non-existing-file-${i}`), 0o666);
        } catch {
          // do nothing
        }
      }
      bench.end(n);
      break;
    default:
      new Error('Invalid type');
  }
}
                                                                                  node-23.7.0/benchmark/fs/bench-chownSync.js                                                         0000664 0000000 0000000 00000002457 14746647661 0020515 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const assert = require('assert');
const tmpdir = require('../../test/common/tmpdir');

if (process.platform === 'win32') {
  console.log('Skipping: Windows does not have `getuid` or `getgid`');
  process.exit(0);
}

const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing'],
  method: ['chownSync', 'lchownSync'],
  n: [1e4],
});

function main({ n, type, method }) {
  const uid = process.getuid();
  const gid = process.getgid();
  const fsMethod = fs[method];

  switch (type) {
    case 'existing': {
      tmpdir.refresh();
      const tmpfile = tmpdir.resolve(`.existing-file-${process.pid}`);
      fs.writeFileSync(tmpfile, 'this-is-for-a-benchmark', 'utf8');
      bench.start();
      for (let i = 0; i < n; i++) {
        fsMethod(tmpfile, uid, gid);
      }
      bench.end(n);
      break;
    }
    case 'non-existing': {
      const path = tmpdir.resolve(`.non-existing-file-${Date.now()}`);
      let hasError = false;
      bench.start();
      for (let i = 0; i < n; i++) {
        try {
          fs[method](path, uid, gid);
        } catch {
          hasError = true;
        }
      }
      bench.end(n);
      assert.ok(hasError);
      break;
    }
    default:
      new Error('Invalid type');
  }
}
                                                                                                                                                                                                                 node-23.7.0/benchmark/fs/bench-copyFileSync.js                                                      0000664 0000000 0000000 00000001355 14746647661 0021145 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const bench = common.createBenchmark(main, {
  type: ['invalid', 'valid'],
  n: [1e4],
});

function main({ n, type }) {
  tmpdir.refresh();
  const dest = tmpdir.resolve(`copy-file-bench-${process.pid}`);
  let path;

  switch (type) {
    case 'invalid':
      path = tmpdir.resolve(`.existing-file-${process.pid}`);
      break;
    case 'valid':
      path = __filename;
      break;
    default:
      throw new Error('Invalid type');
  }
  bench.start();
  for (let i = 0; i < n; i++) {
    try {
      fs.copyFileSync(path, dest);
    } catch {
      // do nothing
    }
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                   node-23.7.0/benchmark/fs/bench-cpSync.js                                                            0000664 0000000 0000000 00000001110 14746647661 0017762 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const path = require('path');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const bench = common.createBenchmark(main, {
  n: [1, 100, 10_000],
});

function main({ n }) {
  tmpdir.refresh();
  const options = { recursive: true };
  const src = path.join(__dirname, '../../test/fixtures/copy');
  const dest = tmpdir.resolve(`${process.pid}/subdir/cp-bench-${process.pid}`);
  bench.start();
  for (let i = 0; i < n; i++) {
    fs.cpSync(src, dest, options);
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/fs/bench-existsSync.js                                                        0000664 0000000 0000000 00000001501 14746647661 0020703 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const tmpfile = tmpdir.resolve(`.existing-file-${process.pid}`);
fs.writeFileSync(tmpfile, 'this-is-for-a-benchmark', 'utf8');

const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing', 'non-flat-existing'],
  n: [1e6],
});

function main({ n, type }) {
  let path;

  switch (type) {
    case 'existing':
      path = __filename;
      break;
    case 'non-flat-existing':
      path = tmpfile;
      break;
    case 'non-existing':
      path = tmpdir.resolve(`.non-existing-file-${process.pid}`);
      break;
    default:
      new Error('Invalid type');
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    fs.existsSync(path);
  }
  bench.end(n);
}
                                                                                                                                                                                               node-23.7.0/benchmark/fs/bench-fchmodSync.js                                                        0000664 0000000 0000000 00000002264 14746647661 0020633 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing'],
  n: [1e3],
});

function main({ n, type }) {
  let files;

  switch (type) {
    case 'existing':
      files = [];

      // Populate tmpdir with mock files
      for (let i = 0; i < n; i++) {
        const path = tmpdir.resolve(`fchmodsync-bench-file-${i}`);
        fs.writeFileSync(path, 'bench');
        files.push(path);
      }
      break;
    case 'non-existing':
      files = new Array(n).fill(tmpdir.resolve(`.non-existing-file-${Date.now()}`));
      break;
    default:
      new Error('Invalid type');
  }

  const fds = files.map((x) => {
    // Try to open, if not return likely invalid fd (1 << 30)
    try {
      return fs.openSync(x, 'r');
    } catch {
      return 1 << 30;
    }
  });

  bench.start();
  for (let i = 0; i < n; i++) {
    try {
      fs.fchmodSync(fds[i], 0o666);
    } catch {
      // do nothing
    }
  }
  bench.end(n);

  for (const x of fds) {
    try {
      fs.closeSync(x);
    } catch {
      // do nothing
    }
  }
}
                                                                                                                                                                                                                                                                                                                                            node-23.7.0/benchmark/fs/bench-fsyncSync.js                                                         0000664 0000000 0000000 00000001457 14746647661 0020520 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const tmpfile = tmpdir.resolve(`.existing-file-${process.pid}`);
fs.writeFileSync(tmpfile, 'this-is-for-a-benchmark', 'utf8');

const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing'],
  n: [1e4],
});

function main({ n, type }) {
  let fd;

  switch (type) {
    case 'existing':
      fd = fs.openSync(tmpfile, 'r', 0o666);
      break;
    case 'non-existing':
      fd = 1 << 30;
      break;
    default:
      new Error('Invalid type');
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    try {
      fs.fsyncSync(fd);
    } catch {
      // do nothing
    }
  }

  bench.end(n);

  if (type === 'existing') fs.closeSync(fd);
}
                                                                                                                                                                                                                 node-23.7.0/benchmark/fs/bench-ftruncateSync.js                                                     0000664 0000000 0000000 00000001401 14746647661 0021356 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const path = tmpdir.resolve(`new-file-${process.pid}`);
fs.appendFileSync(path, 'Some content.');

const bench = common.createBenchmark(main, {
  type: ['invalid', 'valid'],
  n: [1e4],
});

function main({ n, type }) {
  let fd;

  switch (type) {
    case 'invalid':
      fd = 1 << 30;
      break;
    case 'valid':
      fd = fs.openSync(path, 'r+');
      break;
    default:
      throw new Error('Invalid type');
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    try {
      fs.ftruncateSync(fd, 4);
    } catch {
      // do nothing
    }
  }
  bench.end(n);
  if (type === 'valid') fs.closeSync(fd);
}
                                                                                                                                                                                                                                                               node-23.7.0/benchmark/fs/bench-glob.js                                                              0000664 0000000 0000000 00000001552 14746647661 0017460 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const path = require('path');
const assert = require('node:assert');

const benchmarkDirectory = path.resolve(__dirname, '..', '..');

const configs = {
  n: [1e3],
  dir: ['lib'],
  pattern: ['**/*', '*.js', '**/**.js'],
  mode: ['async', 'sync'],
  recursive: ['true', 'false'],
};

const bench = common.createBenchmark(main, configs);

async function main(config) {
  const fullPath = path.resolve(benchmarkDirectory, config.dir);
  const { pattern, recursive, mode } = config;

  let noDead;
  bench.start();

  for (let i = 0; i < config.n; i++) {
    if (mode === 'async') {
      noDead = await fs.promises.glob(pattern, { cwd: fullPath, recursive });
    } else {
      noDead = fs.globSync(pattern, { cwd: fullPath, recursive });
    }
  }

  bench.end(config.n);
  assert.ok(noDead);
}
                                                                                                                                                      node-23.7.0/benchmark/fs/bench-linkSync.js                                                          0000664 0000000 0000000 00000002074 14746647661 0020327 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const assert = require('assert');
const tmpdir = require('../../test/common/tmpdir');

tmpdir.refresh();
const tmpfile = tmpdir.resolve(`.bench-file-data-${Date.now()}`);
fs.writeFileSync(tmpfile, 'bench-file', 'utf-8');

const bench = common.createBenchmark(main, {
  type: ['valid', 'invalid'],
  n: [1e3],
});

function main({ n, type }) {
  switch (type) {
    case 'valid': {
      bench.start();
      for (let i = 0; i < n; i++) {
        fs.linkSync(tmpfile, tmpdir.resolve(`.valid-${i}`), 'file');
      }
      bench.end(n);

      break;
    }

    case 'invalid': {
      let hasError = false;
      bench.start();
      for (let i = 0; i < n; i++) {
        try {
          fs.linkSync(
            tmpdir.resolve(`.non-existing-file-for-linkSync-${i}`),
            __filename,
            'file',
          );
        } catch {
          hasError = true;
        }
      }
      bench.end(n);
      assert.ok(hasError);
      break;
    }
    default:
      new Error('Invalid type');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/benchmark/fs/bench-mkdirSync.js                                                         0000664 0000000 0000000 00000001743 14746647661 0020502 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing'],
  recursive: ['true', 'false'],
  n: [1e3],
});

function main({ n, type, recursive }) {
  recursive = recursive === 'true';
  let files;

  switch (type) {
    case 'non-existing':
      files = [];

      // Populate tmpdir with target dirs
      for (let i = 0; i < n; i++) {
        const path = tmpdir.resolve(recursive ? `rmdirsync-bench-dir-${process.pid}-${i}/a/b/c` : `rmdirsync-bench-dir-${process.pid}-${i}`);
        files.push(path);
      }
      break;
    case 'existing':
      files = new Array(n).fill(__dirname);
      break;
    default:
      new Error('Invalid type');
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    try {
      fs.mkdirSync(files[i], { recursive });
    } catch {
      // do nothing
    }
  }
  bench.end(n);
}
                             node-23.7.0/benchmark/fs/bench-mkdirp.js                                                            0000664 0000000 0000000 00000000767 14746647661 0020032 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();
let dirc = 0;

const bench = common.createBenchmark(main, {
  n: [1e4],
});

function main({ n }) {
  bench.start();
  (function r(cntr) {
    if (cntr-- <= 0)
      return bench.end(n);
    const pathname = `${tmpdir.path}/${++dirc}/${++dirc}/${++dirc}/${++dirc}`;
    fs.mkdir(pathname, { recursive: true }, (err) => {
      r(cntr);
    });
  }(n));
}
         node-23.7.0/benchmark/fs/bench-mkdtempSync.js                                                       0000664 0000000 0000000 00000001646 14746647661 0021037 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const assert = require('assert');
const tmpdir = require('../../test/common/tmpdir');

const bench = common.createBenchmark(main, {
  type: ['valid-string', 'valid-buffer', 'invalid'],
  n: [1e4],
});

function main({ n, type }) {
  tmpdir.refresh();
  const options = { encoding: 'utf8' };
  let prefix;
  let out = true;

  switch (type) {
    case 'valid-string':
      prefix = tmpdir.resolve(`${Date.now()}`);
      break;
    case 'valid-buffer':
      prefix = Buffer.from(tmpdir.resolve(`${Date.now()}`));
      break;
    case 'invalid':
      prefix = tmpdir.resolve('non-existent', 'foo', 'bar');
      break;
    default:
      new Error('Invalid type');
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    try {
      out = fs.mkdtempSync(prefix, options);
    } catch {
      // do nothing
    }
  }
  bench.end(n);
  assert.ok(out);
}
                                                                                          node-23.7.0/benchmark/fs/bench-openSync.js                                                          0000664 0000000 0000000 00000001314 14746647661 0020327 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing'],
  n: [1e5],
});

function main({ n, type }) {
  let path;

  switch (type) {
    case 'existing':
      path = __filename;
      break;
    case 'non-existing':
      path = tmpdir.resolve(`.non-existing-file-${process.pid}`);
      break;
    default:
      new Error('Invalid type');
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    try {
      const fd = fs.openSync(path, 'r', 0o666);
      fs.closeSync(fd);
    } catch {
      // do nothing
    }
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                    node-23.7.0/benchmark/fs/bench-opendir.js                                                           0000664 0000000 0000000 00000002461 14746647661 0020175 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const path = require('path');

const bench = common.createBenchmark(main, {
  n: [100],
  dir: [ 'lib', 'test/parallel'],
  mode: [ 'async', 'sync', 'callback' ],
  bufferSize: [ 4, 32, 1024 ],
});

async function main({ n, dir, mode, bufferSize }) {
  const fullPath = path.resolve(__dirname, '../../', dir);

  bench.start();

  let counter = 0;
  for (let i = 0; i < n; i++) {
    if (mode === 'async') {
      const dir = await fs.promises.opendir(fullPath, { bufferSize });
      // eslint-disable-next-line no-unused-vars
      for await (const entry of dir)
        counter++;
    } else if (mode === 'callback') {
      const dir = await fs.promises.opendir(fullPath, { bufferSize });
      await new Promise((resolve, reject) => {
        function read() {
          dir.read((err, entry) => {
            if (err) {
              reject(err);
            } else if (entry === null) {
              resolve(dir.close());
            } else {
              counter++;
              read();
            }
          });
        }

        read();
      });
    } else {
      const dir = fs.opendirSync(fullPath, { bufferSize });
      while (dir.readSync() !== null)
        counter++;
      dir.closeSync();
    }
  }

  bench.end(counter);
}
                                                                                                                                                                                                               node-23.7.0/benchmark/fs/bench-opendirSync.js                                                       0000664 0000000 0000000 00000001665 14746647661 0021037 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const path = require('path');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const testFiles = fs.readdirSync('test', { withFileTypes: true })
  .filter((f) => f.isDirectory())
  .map((f) => path.join(f.path, f.name));
const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing'],
  n: [1e3],
});

function main({ n, type }) {
  let files;

  switch (type) {
    case 'existing':
      files = testFiles;
      break;
    case 'non-existing':
      files = [tmpdir.resolve(`.non-existing-file-${Date.now()}`)];
      break;
    default:
      new Error('Invalid type');
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < files.length; j++) {
      try {
        const dir = fs.opendirSync(files[j]);
        dir.closeSync();
      } catch {
        // do nothing
      }
    }
  }
  bench.end(n);
}
                                                                           node-23.7.0/benchmark/fs/bench-readSync.js                                                          0000664 0000000 0000000 00000002414 14746647661 0020303 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const bufferSize = 1024;
const sectorSize = 512;

const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing'],
  n: [1e4],
});

function main({ n, type }) {
  let fd;

  const tmpfile = { name: tmpdir.resolve(`.existing-file-${process.pid}`),
                    len: bufferSize * n };


  tmpfile.contents = Buffer.allocUnsafe(tmpfile.len);

  for (let offset = 0; offset < tmpfile.len; offset += sectorSize) {
    const fillByte = 256 * Math.random();
    const nBytesToFill = Math.min(sectorSize, tmpfile.len - offset);
    tmpfile.contents.fill(fillByte, offset, offset + nBytesToFill);
  }

  fs.writeFileSync(tmpfile.name, tmpfile.contents);

  switch (type) {
    case 'existing':
      fd = fs.openSync(tmpfile.name, 'r', 0o666);
      break;
    case 'non-existing':
      fd = 1 << 30;
      break;
    default:
      new Error('Invalid type');
  }

  const buffer = Buffer.alloc(bufferSize);

  bench.start();
  for (let i = 0; i < n; i++) {
    try {
      fs.readSync(fd, buffer);
    } catch {
      // Continue regardless of error.
    }
  }
  bench.end(n);

  if (type === 'existing') fs.closeSync(fd);
}
                                                                                                                                                                                                                                                    node-23.7.0/benchmark/fs/bench-readdir.js                                                           0000664 0000000 0000000 00000001057 14746647661 0020147 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const path = require('path');

const bench = common.createBenchmark(main, {
  n: [10],
  dir: [ 'lib', 'test/parallel'],
  withFileTypes: ['true', 'false'],
});

function main({ n, dir, withFileTypes }) {
  withFileTypes = withFileTypes === 'true';
  const fullPath = path.resolve(__dirname, '../../', dir);
  bench.start();
  (function r(cntr) {
    if (cntr-- <= 0)
      return bench.end(n);
    fs.readdir(fullPath, { withFileTypes }, () => {
      r(cntr);
    });
  }(n));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/benchmark/fs/bench-readdirSync.js                                                       0000664 0000000 0000000 00000000773 14746647661 0021010 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const path = require('path');

const bench = common.createBenchmark(main, {
  n: [10],
  dir: [ 'lib', 'test/parallel'],
  withFileTypes: ['true', 'false'],
});


function main({ n, dir, withFileTypes }) {
  withFileTypes = withFileTypes === 'true';
  const fullPath = path.resolve(__dirname, '../../', dir);
  bench.start();
  for (let i = 0; i < n; i++) {
    fs.readdirSync(fullPath, { withFileTypes });
  }
  bench.end(n);
}
     node-23.7.0/benchmark/fs/bench-readlinkSync.js                                                      0000664 0000000 0000000 00000002526 14746647661 0021165 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const assert = require('assert');
const tmpdir = require('../../test/common/tmpdir');

if (process.platform === 'win32') {
  console.log('Skipping: Windows does not play well with `symlinkSync`');
  process.exit(0);
}

const bench = common.createBenchmark(main, {
  type: ['valid', 'invalid'],
  n: [1e3],
});

function main({ n, type }) {
  switch (type) {
    case 'valid': {
      tmpdir.refresh();
      const tmpfile = tmpdir.resolve(`.readlink-file-${process.pid}`);
      fs.writeFileSync(tmpfile, 'data', 'utf8');
      let returnValue;
      for (let i = 0; i < n; i++) {
        fs.symlinkSync(tmpfile, tmpdir.resolve(`.readlink-sync-${i}`), 'file');
      }
      bench.start();
      for (let i = 0; i < n; i++) {
        returnValue = fs.readlinkSync(tmpdir.resolve(`.readlink-sync-${i}`), { encoding: 'utf8' });
      }
      bench.end(n);
      assert.ok(returnValue);
      break;
    }

    case 'invalid': {
      let hasError = false;
      bench.start();
      for (let i = 0; i < n; i++) {
        try {
          fs.readlinkSync(tmpdir.resolve('.non-existing-file-for-readlinkSync'));
        } catch {
          hasError = true;
        }
      }
      bench.end(n);
      assert.ok(hasError);
      break;
    }
    default:
      new Error('Invalid type');
  }
}
                                                                                                                                                                          node-23.7.0/benchmark/fs/bench-readvSync.js                                                         0000664 0000000 0000000 00000002344 14746647661 0020473 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const assert = require('assert');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const exptectedBuff = Buffer.from('Benchmark Data');
const expectedLength = exptectedBuff.length;

const bufferArr = [Buffer.alloc(expectedLength)];

const filename = tmpdir.resolve('readv_sync.txt');
fs.writeFileSync(filename, exptectedBuff);

const bench = common.createBenchmark(main, {
  type: ['valid', 'invalid'],
  n: [1e5],
});

function main({ n, type }) {
  let fd;
  let result;

  switch (type) {
    case 'valid':
      fd = fs.openSync(filename, 'r');

      bench.start();
      for (let i = 0; i < n; i++) {
        result = fs.readvSync(fd, bufferArr, 0);
      }

      bench.end(n);
      assert.strictEqual(result, expectedLength);
      fs.closeSync(fd);
      break;
    case 'invalid': {
      fd = 1 << 30;
      let hasError = false;
      bench.start();
      for (let i = 0; i < n; i++) {
        try {
          result = fs.readvSync(fd, bufferArr, 0);
        } catch {
          hasError = true;
        }
      }

      bench.end(n);
      assert.ok(hasError);
      break;
    }
    default:
      throw new Error('Invalid type');
  }
}
                                                                                                                                                                                                                                                                                            node-23.7.0/benchmark/fs/bench-realpath.js                                                          0000664 0000000 0000000 00000001447 14746647661 0020340 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const path = require('path');
const resolved_path = path.resolve(__dirname, '../../lib/');
const relative_path = path.relative(__dirname, '../../lib/');

const bench = common.createBenchmark(main, {
  n: [1e4],
  pathType: ['relative', 'resolved'],
});


function main({ n, pathType }) {
  bench.start();
  if (pathType === 'relative')
    relativePath(n);
  else
    resolvedPath(n);
}

function relativePath(n) {
  (function r(cntr) {
    if (cntr-- <= 0)
      return bench.end(n);
    fs.realpath(relative_path, () => {
      r(cntr);
    });
  }(n));
}

function resolvedPath(n) {
  (function r(cntr) {
    if (cntr-- <= 0)
      return bench.end(n);
    fs.realpath(resolved_path, () => {
      r(cntr);
    });
  }(n));
}
                                                                                                                                                                                                                         node-23.7.0/benchmark/fs/bench-realpathSync.js                                                      0000664 0000000 0000000 00000001063 14746647661 0021167 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const path = require('path');

process.chdir(__dirname);
const resolved_path = path.resolve(__dirname, '../../lib/');
const relative_path = path.relative(__dirname, '../../lib/');

const bench = common.createBenchmark(main, {
  n: [1e4],
  pathType: ['relative', 'resolved'],
});


function main({ n, pathType }) {
  const path = pathType === 'relative' ? relative_path : resolved_path;
  bench.start();
  for (let i = 0; i < n; i++) {
    fs.realpathSync(path);
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/benchmark/fs/bench-renameSync.js                                                        0000664 0000000 0000000 00000002146 14746647661 0020641 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const assert = require('assert');
const tmpdir = require('../../test/common/tmpdir');

const bench = common.createBenchmark(main, {
  type: ['invalid', 'valid'],
  n: [2e3],
});

function main({ n, type }) {
  switch (type) {
    case 'invalid': {
      let hasError = false;
      bench.start();
      for (let i = 0; i < n; i++) {
        try {
          fs.renameSync(tmpdir.resolve(`.non-existing-file-${i}`), tmpdir.resolve(`.new-file-${i}`));
        } catch {
          hasError = true;
        }
      }
      bench.end(n);
      assert.ok(hasError);
      break;
    }
    case 'valid': {
      tmpdir.refresh();
      for (let i = 0; i < n; i++) {
        fs.writeFileSync(tmpdir.resolve(`.existing-file-${i}`), 'bench', 'utf8');
      }

      bench.start();
      for (let i = 0; i < n; i++) {
        fs.renameSync(
          tmpdir.resolve(`.existing-file-${i}`),
          tmpdir.resolve(`.new-existing-file-${i}`),
        );
      }

      bench.end(n);
      break;
    }
    default:
      throw new Error('Invalid type');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/benchmark/fs/bench-rmdirSync.js                                                         0000664 0000000 0000000 00000001626 14746647661 0020511 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing'],
  n: [1e4],
});

function main({ n, type }) {
  switch (type) {
    case 'existing': {
      for (let i = 0; i < n; i++) {
        fs.mkdirSync(tmpdir.resolve(`rmdirsync-bench-dir-${i}`));
      }

      bench.start();
      for (let i = 0; i < n; i++) {
        fs.rmdirSync(tmpdir.resolve(`rmdirsync-bench-dir-${i}`));
      }
      bench.end(n);
      break;
    }
    case 'non-existing': {
      bench.start();
      for (let i = 0; i < n; i++) {
        try {
          fs.rmdirSync(tmpdir.resolve(`.non-existent-folder-${i}`));
        } catch {
          // do nothing
        }
      }
      bench.end(n);
      break;
    }
    default:
      new Error('Invalid type');
  }
}
                                                                                                          node-23.7.0/benchmark/fs/bench-stat-promise.js                                                      0000664 0000000 0000000 00000001262 14746647661 0021162 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fsPromises = require('fs').promises;

const bench = common.createBenchmark(main, {
  n: [20e4],
  statType: ['fstat', 'lstat', 'stat'],
});

async function run(n, statType) {
  const handleMode = statType === 'fstat';
  const arg = handleMode ? await fsPromises.open(__filename, 'r') : __filename;
  let remaining = n;
  bench.start();
  while (remaining-- > 0)
    await (handleMode ? arg.stat() : fsPromises[statType](arg));
  bench.end(n);

  if (typeof arg.close === 'function')
    await arg.close();
}

function main(conf) {
  const n = conf.n >>> 0;
  const statType = conf.statType;
  run(n, statType).catch(console.log);
}
                                                                                                                                                                                                                                                                                                                                              node-23.7.0/benchmark/fs/bench-stat.js                                                              0000664 0000000 0000000 00000001062 14746647661 0017504 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');

const bench = common.createBenchmark(main, {
  n: [20e4],
  statType: ['fstat', 'lstat', 'stat'],
});


function main({ n, statType }) {
  let arg;
  if (statType === 'fstat')
    arg = fs.openSync(__filename, 'r');
  else
    arg = __filename;

  bench.start();
  (function r(cntr, fn) {
    if (cntr-- <= 0) {
      bench.end(n);
      if (statType === 'fstat')
        fs.closeSync(arg);
      return;
    }
    fn(arg, () => {
      r(cntr, fn);
    });
  }(n, fs[statType]));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/benchmark/fs/bench-statSync-failure.js                                                  0000664 0000000 0000000 00000001556 14746647661 0021776 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const path = require('path');

const bench = common.createBenchmark(main, {
  n: [1e4],
  statSyncType: ['fstatSync', 'lstatSync', 'statSync'],
  throwType: [ 'throw', 'noThrow' ],
}, {
  // fstatSync does not support throwIfNoEntry
  combinationFilter: ({ statSyncType, throwType }) => !(statSyncType === 'fstatSync' && throwType === 'noThrow'),
});


function main({ n, statSyncType, throwType }) {
  const arg = (statSyncType === 'fstatSync' ?
    (1 << 30) :
    path.join(__dirname, 'non.existent'));

  const fn = fs[statSyncType];

  bench.start();
  for (let i = 0; i < n; i++) {
    if (throwType === 'noThrow') {
      fn(arg, { throwIfNoEntry: false });
    } else {
      try {
        fn(arg);
      } catch {
        // Continue regardless of error.
      }
    }
  }
  bench.end(n);
}
                                                                                                                                                  node-23.7.0/benchmark/fs/bench-statSync.js                                                          0000664 0000000 0000000 00000000774 14746647661 0020352 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');

const bench = common.createBenchmark(main, {
  n: [1e4],
  statSyncType: ['fstatSync', 'lstatSync', 'statSync'],
});


function main({ n, statSyncType }) {
  const arg = (statSyncType === 'fstatSync' ?
    fs.openSync(__filename, 'r') :
    __dirname);
  const fn = fs[statSyncType];

  bench.start();
  for (let i = 0; i < n; i++) {
    fn(arg);
  }
  bench.end(n);

  if (statSyncType === 'fstatSync')
    fs.closeSync(arg);
}
    node-23.7.0/benchmark/fs/bench-symlinkSync.js                                                       0000664 0000000 0000000 00000002155 14746647661 0021060 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const assert = require('assert');
const tmpdir = require('../../test/common/tmpdir');

if (process.platform === 'win32') {
  console.log('Skipping: Windows does not play well with `symlink`');
  process.exit(0);
}

const bench = common.createBenchmark(main, {
  type: ['valid', 'invalid'],
  n: [1e3],
});

function main({ n, type }) {
  switch (type) {
    case 'valid': {
      tmpdir.refresh();
      bench.start();
      for (let i = 0; i < n; i++) {
        fs.symlinkSync(tmpdir.resolve('.non-existent-symlink-file'), tmpdir.resolve(`.valid-${i}`), 'file');
      }
      bench.end(n);
      break;
    }

    case 'invalid': {
      let hasError = false;
      bench.start();
      for (let i = 0; i < n; i++) {
        try {
          fs.symlinkSync(
            tmpdir.resolve('.non-existent-symlink-file'),
            __filename,
            'file',
          );
        } catch {
          hasError = true;
        }
      }
      bench.end(n);
      assert.ok(hasError);
      break;
    }
    default:
      new Error('Invalid type');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/benchmark/fs/bench-timesSync.js                                                         0000664 0000000 0000000 00000002507 14746647661 0020514 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing'],
  func: [ 'utimes', 'futimes', 'lutimes' ],
  n: [1e3],
});

function main({ n, type, func }) {
  const useFds = func === 'futimes';
  const fsFunc = fs[func + 'Sync'];

  switch (type) {
    case 'existing': {
      const files = [];

      // Populate tmpdir with mock files
      for (let i = 0; i < n; i++) {
        const path = tmpdir.resolve(`timessync-bench-file-${i}`);
        fs.writeFileSync(path, 'bench');
        files.push(useFds ? fs.openSync(path, 'r+') : path);
      }

      bench.start();
      for (let i = 0; i < n; i++) {
        fsFunc(files[i], i, i);
      }
      bench.end(n);

      if (useFds) files.forEach((x) => {
        try {
          fs.closeSync(x);
        } catch {
          // do nothing
        }
      });

      break;
    }
    case 'non-existing': {
      bench.start();
      for (let i = 0; i < n; i++) {
        try {
          fsFunc(useFds ? (1 << 30) : tmpdir.resolve(`.non-existing-file-${Date.now()}`), i, i);
        } catch {
          // do nothing
        }
      }
      bench.end(n);

      break;
    }
    default:
      new Error('Invalid type');
  }
}
                                                                                                                                                                                         node-23.7.0/benchmark/fs/bench-unlinkSync.js                                                        0000664 0000000 0000000 00000001614 14746647661 0020671 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing'],
  n: [1e3],
});

function main({ n, type }) {
  let files;

  switch (type) {
    case 'existing':
      files = [];

      // Populate tmpdir with mock files
      for (let i = 0; i < n; i++) {
        const path = tmpdir.resolve(`unlinksync-bench-file-${i}`);
        fs.writeFileSync(path, 'bench');
        files.push(path);
      }
      break;
    case 'non-existing':
      files = new Array(n).fill(tmpdir.resolve(`.non-existing-file-${Date.now()}`));
      break;
    default:
      new Error('Invalid type');
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    try {
      fs.unlinkSync(files[i]);
    } catch {
      // do nothing
    }
  }
  bench.end(n);
}
                                                                                                                    node-23.7.0/benchmark/fs/bench-writeFileSync.js                                                     0000664 0000000 0000000 00000002053 14746647661 0021321 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

// Some variants are commented out as they do not show a change and just slow
const bench = common.createBenchmark(main, {
  encoding: ['utf8'],
  useFd: ['true', 'false'],
  length: [1024, 102400, 1024 * 1024],

  // useBuffer: ['true', 'false'],
  useBuffer: ['false'],

  // func: ['appendFile', 'writeFile'],
  func: ['writeFile'],

  n: [1e3],
});

function main({ n, func, encoding, length, useFd, useBuffer }) {
  tmpdir.refresh();
  const enc = encoding === 'undefined' ? undefined : encoding;
  const path = tmpdir.resolve(`.writefilesync-file-${Date.now()}`);

  useFd = useFd === 'true';
  const file = useFd ? fs.openSync(path, 'w') : path;

  let data = 'a'.repeat(length);
  if (useBuffer === 'true') data = Buffer.from(data, encoding);

  const fn = fs[func + 'Sync'];

  bench.start();
  for (let i = 0; i < n; ++i) {
    fn(file, data, enc);
  }
  bench.end(n);

  if (useFd) fs.closeSync(file);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/benchmark/fs/bench-writevSync.js                                                        0000664 0000000 0000000 00000002137 14746647661 0020712 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const assert = require('assert');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const path = tmpdir.resolve(`new-file-${process.pid}`);
fs.writeFileSync(path, 'Some content.');

const bench = common.createBenchmark(main, {
  type: ['valid', 'invalid'],
  n: [1e5],
});

const buffer = Buffer.from('Benchmark data.');

function main({ n, type }) {
  let fd;
  let result;

  switch (type) {
    case 'valid':
      fd = fs.openSync(path, 'r+');

      bench.start();
      for (let i = 0; i < n; i++) {
        result = fs.writevSync(fd, [buffer]);
      }

      bench.end(n);
      assert.ok(result);
      fs.closeSync(fd);
      break;
    case 'invalid': {
      fd = 1 << 30;
      let hasError = false;
      bench.start();
      for (let i = 0; i < n; i++) {
        try {
          result = fs.writevSync(fd, [buffer]);
        } catch {
          hasError = true;
        }
      }

      bench.end(n);
      assert.ok(hasError);
      break;
    }
    default:
      throw new Error('Invalid type');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/benchmark/fs/bench_fdatasyncSync.js                                                     0000664 0000000 0000000 00000001463 14746647661 0021431 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();

const tmpfile = tmpdir.resolve(`.existing-file-${process.pid}`);
fs.writeFileSync(tmpfile, 'this-is-for-a-benchmark', 'utf8');

const bench = common.createBenchmark(main, {
  type: ['existing', 'non-existing'],
  n: [1e4],
});

function main({ n, type }) {
  let fd;

  switch (type) {
    case 'existing':
      fd = fs.openSync(tmpfile, 'r', 0o666);
      break;
    case 'non-existing':
      fd = 1 << 30;
      break;
    default:
      new Error('Invalid type');
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    try {
      fs.fdatasyncSync(fd);
    } catch {
      // do nothing
    }
  }

  bench.end(n);

  if (type === 'existing') fs.closeSync(fd);
}
                                                                                                                                                                                                             node-23.7.0/benchmark/fs/read-stream-throughput.js                                                  0000664 0000000 0000000 00000004016 14746647661 0022071 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Test the throughput of the fs.WriteStream class.
'use strict';

const common = require('../common.js');
const fs = require('fs');
const assert = require('assert');

const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();
const filename = tmpdir.resolve(`.removeme-benchmark-garbage-${process.pid}`);

const bench = common.createBenchmark(main, {
  encodingType: ['buf', 'asc', 'utf'],
  filesize: [1000 * 1024],
  highWaterMark: [1024, 4096, 65535, 1024 * 1024],
  n: 1024,
});

function main(conf) {
  const { encodingType, highWaterMark, filesize } = conf;
  let { n } = conf;

  let encoding = '';
  switch (encodingType) {
    case 'buf':
      encoding = null;
      break;
    case 'asc':
      encoding = 'ascii';
      break;
    case 'utf':
      encoding = 'utf8';
      break;
    default:
      throw new Error(`invalid encodingType: ${encodingType}`);
  }

  // Make file
  const buf = Buffer.allocUnsafe(filesize);
  if (encoding === 'utf8') {
    // ü
    for (let i = 0; i < buf.length; i++) {
      buf[i] = i % 2 === 0 ? 0xC3 : 0xBC;
    }
  } else if (encoding === 'ascii') {
    buf.fill('a');
  } else {
    buf.fill('x');
  }

  try {
    fs.unlinkSync(filename);
  } catch {
    // Continue regardless of error.
  }
  const ws = fs.createWriteStream(filename);
  ws.on('close', runTest.bind(null, filesize, highWaterMark, encoding, n));
  ws.on('drain', write);
  write();
  function write() {
    do {
      n--;
    } while (false !== ws.write(buf) && n > 0);
    if (n === 0)
      ws.end();
  }
}

function runTest(filesize, highWaterMark, encoding, n) {
  assert.strictEqual(fs.statSync(filename).size, filesize * n);
  const rs = fs.createReadStream(filename, {
    highWaterMark,
    encoding,
  });

  rs.on('open', () => {
    bench.start();
  });

  let bytes = 0;
  rs.on('data', (chunk) => {
    bytes += chunk.length;
  });

  rs.on('end', () => {
    try {
      fs.unlinkSync(filename);
    } catch {
      // Continue regardless of error.
    }
    // MB/sec
    bench.end(bytes / (1024 * 1024));
  });
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/fs/readFileSync.js                                                            0000664 0000000 0000000 00000001522 14746647661 0020025 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const fs = require('fs');

const bench = common.createBenchmark(main, {
  encoding: ['undefined', 'utf8', 'ascii'],
  path: ['existing', 'non-existing'],
  hasFileDescriptor: ['true', 'false'],
  n: [1e4],
});

function main({ n, encoding, path, hasFileDescriptor }) {
  const enc = encoding === 'undefined' ? undefined : encoding;
  let file;
  let shouldClose = false;

  if (hasFileDescriptor === 'true') {
    shouldClose = path === 'existing';
    file = path === 'existing' ? fs.openSync(__filename) : -1;
  } else {
    file = path === 'existing' ? __filename : '/tmp/not-found';
  }
  bench.start();
  for (let i = 0; i < n; ++i) {
    try {
      fs.readFileSync(file, enc);
    } catch {
      // do nothing
    }
  }
  bench.end(n);
  if (shouldClose) {
    fs.closeSync(file);
  }
}
                                                                                                                                                                              node-23.7.0/benchmark/fs/readfile-partitioned.js                                                    0000664 0000000 0000000 00000004321 14746647661 0021550 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Submit a mix of short and long jobs to the threadpool.
// Report total job throughput.
// If we partition the long job, overall job throughput goes up significantly.
// However, this comes at the cost of the long job throughput.
//
// Short jobs: small zip jobs.
// Long jobs: fs.readFile on a large file.

'use strict';

const path = require('path');
const common = require('../common.js');
const filename = path.resolve(__dirname,
                              `.removeme-benchmark-garbage-${process.pid}`);
const fs = require('fs');
const zlib = require('zlib');

const bench = common.createBenchmark(main, {
  duration: [5],
  encoding: ['', 'utf-8'],
  len: [1024, 16 * 1024 * 1024],
  concurrent: [1, 10],
});

function main({ len, duration, concurrent, encoding }) {
  try {
    fs.unlinkSync(filename);
  } catch {
    // Continue regardless of error.
  }
  let data = Buffer.alloc(len, 'x');
  fs.writeFileSync(filename, data);
  data = null;

  const zipData = Buffer.alloc(1024, 'a');

  let waitConcurrent = 0;

  // Plus one because of zip
  const targetConcurrency = concurrent + 1;
  const startedAt = Date.now();
  const endAt = startedAt + (duration * 1000);

  let reads = 0;
  let zips = 0;

  bench.start();

  function stop() {
    const totalOps = reads + zips;
    bench.end(totalOps);

    try {
      fs.unlinkSync(filename);
    } catch {
      // Continue regardless of error.
    }
  }

  function read() {
    fs.readFile(filename, encoding, afterRead);
  }

  function afterRead(er, data) {
    if (er) {
      throw er;
    }

    if (data.length !== len)
      throw new Error('wrong number of bytes returned');

    reads++;
    const benchEnded = Date.now() >= endAt;

    if (benchEnded && (++waitConcurrent) === targetConcurrency) {
      stop();
    } else if (!benchEnded) {
      read();
    }
  }

  function zip() {
    zlib.deflate(zipData, afterZip);
  }

  function afterZip(er, data) {
    if (er)
      throw er;

    zips++;
    const benchEnded = Date.now() >= endAt;

    if (benchEnded && (++waitConcurrent) === targetConcurrency) {
      stop();
    } else if (!benchEnded) {
      zip();
    }
  }

  // Start reads
  for (let i = 0; i < concurrent; i++) read();

  // Start a competing zip
  zip();
}
                                                                                                                                                                                                                                                                                                               node-23.7.0/benchmark/fs/readfile-permission-enabled.js                                             0000664 0000000 0000000 00000003155 14746647661 0023012 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Call fs.readFile with permission system enabled
// over and over again really fast.
// Then see how many times it got called.
'use strict';

const common = require('../common.js');
const fs = require('fs');

const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();
const filename = tmpdir.resolve(`.removeme-benchmark-garbage-${process.pid}`);

const bench = common.createBenchmark(main, {
  duration: [5],
  encoding: ['', 'utf-8'],
  len: [1024, 16 * 1024 * 1024],
  concurrent: [1, 10],
}, {
  flags: [
    '--permission',
    '--allow-fs-read=*',
    '--allow-fs-write=*',
    '--allow-child-process',
  ],
});

function main({ len, duration, concurrent, encoding }) {
  try {
    fs.unlinkSync(filename);
  } catch {
    // Continue regardless of error.
  }
  let data = Buffer.alloc(len, 'x');
  fs.writeFileSync(filename, data);
  data = null;

  let reads = 0;
  let waitConcurrent = 0;

  const startedAt = Date.now();
  const endAt = startedAt + (duration * 1000);

  bench.start();

  function stop() {
    bench.end(reads);

    try {
      fs.unlinkSync(filename);
    } catch {
      // Continue regardless of error.
    }

    process.exit(0);
  }

  function read() {
    fs.readFile(filename, encoding, afterRead);
  }

  function afterRead(er, data) {
    if (er) {
      throw er;
    }

    if (data.length !== len)
      throw new Error('wrong number of bytes returned');

    reads++;
    const benchEnded = Date.now() >= endAt;

    if (benchEnded && (++waitConcurrent) === concurrent) {
      stop();
    } else if (!benchEnded) {
      read();
    }
  }

  for (let i = 0; i < concurrent; i++) read();
}
                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/benchmark/fs/readfile-promises.js                                                       0000664 0000000 0000000 00000003303 14746647661 0021066 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Call fs.promises.readFile over and over again really fast.
// Then see how many times it got called.
// Yes, this is a silly benchmark.  Most benchmarks are silly.
'use strict';

const common = require('../common.js');
const fs = require('fs');

const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();
const filename = tmpdir.resolve(`.removeme-benchmark-garbage-${process.pid}`);

const bench = common.createBenchmark(main, {
  duration: [5],
  encoding: ['', 'utf-8'],
  len: [
    1024,
    512 * 1024,
    4 * 1024 ** 2,
    8 * 1024 ** 2,
    16 * 1024 ** 2,
    32 * 1024 ** 2,
  ],
  concurrent: [1, 10],
});

function main({ len, duration, concurrent, encoding }) {
  try {
    fs.unlinkSync(filename);
  } catch {
    // Continue regardless of error.
  }
  let data = Buffer.alloc(len, 'x');
  fs.writeFileSync(filename, data);
  data = null;

  let reads = 0;
  let waitConcurrent = 0;

  const startedAt = Date.now();
  const endAt = startedAt + (duration * 1000);

  bench.start();

  function stop() {
    bench.end(reads);

    try {
      fs.unlinkSync(filename);
    } catch {
      // Continue regardless of error.
    }

    process.exit(0);
  }

  function read() {
    fs.promises.readFile(filename, encoding)
      .then((res) => afterRead(undefined, res))
      .catch((err) => afterRead(err));
  }

  function afterRead(er, data) {
    if (er) {
      throw er;
    }

    if (data.length !== len)
      throw new Error('wrong number of bytes returned');

    reads++;
    const benchEnded = Date.now() >= endAt;

    if (benchEnded && (++waitConcurrent) === concurrent) {
      stop();
    } else if (!benchEnded) {
      read();
    }
  }

  for (let i = 0; i < concurrent; i++) read();
}
                                                                                                                                                                                                                                                                                                                             node-23.7.0/benchmark/fs/readfile.js                                                                0000664 0000000 0000000 00000003032 14746647661 0017226 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Call fs.readFile over and over again really fast.
// Then see how many times it got called.
// Yes, this is a silly benchmark.  Most benchmarks are silly.
'use strict';

const common = require('../common.js');
const fs = require('fs');

const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();
const filename = tmpdir.resolve(`.removeme-benchmark-garbage-${process.pid}`);

const bench = common.createBenchmark(main, {
  duration: [5],
  encoding: ['', 'utf-8', 'ascii'],
  len: [1024, 16 * 1024 * 1024],
  concurrent: [1, 10],
});

function main({ len, duration, concurrent, encoding }) {
  try {
    fs.unlinkSync(filename);
  } catch {
    // Continue regardless of error.
  }
  let data = Buffer.alloc(len, 'x');
  fs.writeFileSync(filename, data);
  data = null;

  let reads = 0;
  let waitConcurrent = 0;

  const startedAt = Date.now();
  const endAt = startedAt + (duration * 1000);

  bench.start();

  function read() {
    fs.readFile(filename, encoding, afterRead);
  }

  function stop() {
    bench.end(reads);

    try {
      fs.unlinkSync(filename);
    } catch {
      // Continue regardless of error.
    }

    process.exit(0);
  }

  function afterRead(er, data) {
    if (er) {
      throw er;
    }

    if (data.length !== len)
      throw new Error('wrong number of bytes returned');

    reads++;
    const benchEnded = Date.now() >= endAt;

    if (benchEnded && (++waitConcurrent) === concurrent) {
      stop();
    } else if (!benchEnded) {
      read();
    }
  }

  for (let i = 0; i < concurrent; i++) read();
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/benchmark/fs/write-stream-throughput.js                                                 0000664 0000000 0000000 00000003131 14746647661 0022305 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Test the throughput of the fs.WriteStream class.
'use strict';

const common = require('../common.js');
const fs = require('fs');

const tmpdir = require('../../test/common/tmpdir');
tmpdir.refresh();
const filename = tmpdir.resolve(`.removeme-benchmark-garbage-${process.pid}`);

const bench = common.createBenchmark(main, {
  dur: [5],
  encodingType: ['buf', 'asc', 'utf'],
  size: [2, 1024, 65535, 1024 * 1024],
});

function main({ dur, encodingType, size }) {
  let encoding;

  let chunk;
  switch (encodingType) {
    case 'buf':
      chunk = Buffer.alloc(size, 'b');
      break;
    case 'asc':
      chunk = 'a'.repeat(size);
      encoding = 'ascii';
      break;
    case 'utf':
      chunk = 'ü'.repeat(Math.ceil(size / 2));
      encoding = 'utf8';
      break;
    default:
      throw new Error(`invalid encodingType: ${encodingType}`);
  }

  try {
    fs.unlinkSync(filename);
  } catch {
    // Continue regardless of error.
  }

  let started = false;
  let ended = false;

  const f = fs.createWriteStream(filename);
  f.on('drain', write);
  f.on('open', write);
  f.on('close', done);
  f.on('finish', () => {
    ended = true;
    const written = fs.statSync(filename).size / 1024;
    try {
      fs.unlinkSync(filename);
    } catch {
      // Continue regardless of error.
    }
    bench.end(written / 1024);
  });


  function write() {
    if (!started) {
      started = true;
      setTimeout(() => {
        f.end();
      }, dur * 1000);
      bench.start();
    }

    while (false !== f.write(chunk, encoding));
  }

  function done() {
    if (!ended)
      f.emit('finish');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/benchmark/fs/writefile-promises.js                                                      0000664 0000000 0000000 00000003563 14746647661 0021315 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Call fs.promises.writeFile over and over again really fast.
// Then see how many times it got called.
// Yes, this is a silly benchmark.  Most benchmarks are silly.
'use strict';

const common = require('../common.js');
const fs = require('fs');
const tmpdir = require('../../test/common/tmpdir');

tmpdir.refresh();
const filename = tmpdir.resolve(`.removeme-benchmark-garbage-${process.pid}`);
let filesWritten = 0;
const bench = common.createBenchmark(main, {
  duration: [5],
  encodingType: ['buf', 'asc', 'utf'],
  size: [2, 1024, 65535, 1024 * 1024],
  concurrent: [1, 10],
});

function main({ encodingType, duration, concurrent, size }) {
  let encoding;
  let chunk;
  switch (encodingType) {
    case 'buf':
      chunk = Buffer.alloc(size, 'b');
      break;
    case 'asc':
      chunk = 'a'.repeat(size);
      encoding = 'ascii';
      break;
    case 'utf':
      chunk = 'ü'.repeat(Math.ceil(size / 2));
      encoding = 'utf8';
      break;
    default:
      throw new Error(`invalid encodingType: ${encodingType}`);
  }

  let writes = 0;
  let waitConcurrent = 0;

  const startedAt = Date.now();
  const endAt = startedAt + (duration * 1000);

  bench.start();

  function stop() {
    bench.end(writes);

    for (let i = 0; i < filesWritten; i++) {
      try {
        fs.unlinkSync(`${filename}-${i}`);
      } catch {
        // Continue regardless of error.
      }
    }

    process.exit(0);
  }

  function write() {
    fs.promises.writeFile(`${filename}-${filesWritten++}`, chunk, encoding)
      .then(() => afterWrite())
      .catch((err) => afterWrite(err));
  }

  function afterWrite(er) {
    if (er) {
      throw er;
    }

    writes++;
    const benchEnded = Date.now() >= endAt;

    if (benchEnded && (++waitConcurrent) === concurrent) {
      stop();
    } else if (!benchEnded) {
      write();
    }
  }

  for (let i = 0; i < concurrent; i++) write();
}
                                                                                                                                             node-23.7.0/benchmark/http/                                                                         0000775 0000000 0000000 00000000000 14746647661 0015466 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/http/_chunky_http_client.js                                                   0000664 0000000 0000000 00000005544 14746647661 0022071 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// test HTTP throughput in fragmented header case
const common = require('../common.js');
const net = require('net');

const bench = common.createBenchmark(main, {
  len: [1, 4, 8, 16, 32, 64, 128],
  n: [5, 50, 500, 2000],
  type: ['send'],
});


function main({ len, n }) {
  let todo = [];
  const headers = [];
  // Chose 7 because 9 showed "Connection error" / "Connection closed"
  // An odd number could result in a better length dispersion.
  for (let i = 7; i <= 7 * 7 * 7; i *= 7)
    headers.push('o'.repeat(i));

  function WriteHTTPHeaders(channel, has_keep_alive, extra_header_count) {
    todo = [];
    todo.push('GET / HTTP/1.1');
    todo.push('Host: localhost');
    todo.push('Connection: keep-alive');
    todo.push('Accept: text/html,application/xhtml+xml,' +
              'application/xml;q=0.9,image/webp,*/*;q=0.8');
    todo.push('User-Agent: Mozilla/5.0 (X11; Linux x86_64) ' +
              'AppleWebKit/537.36 (KHTML, like Gecko) ' +
              'Chrome/39.0.2171.71 Safari/537.36');
    todo.push('Accept-Encoding: gzip, deflate, sdch');
    todo.push('Accept-Language: en-US,en;q=0.8');
    for (let i = 0; i < extra_header_count; i++) {
      // Utilize first three powers of a small integer for an odd cycle and
      // because the fourth power of some integers overloads the server.
      todo.push(`X-Header-${i}: ${headers[i % 3]}`);
    }
    todo.push('');
    todo.push('');
    todo = todo.join('\r\n');
    // Using odd numbers in many places may increase length coverage.
    const chunksize = 37;
    for (let i = 0; i < todo.length; i += chunksize) {
      const cur = todo.slice(i, i + chunksize);
      channel.write(cur);
    }
  }

  const min = 10;
  let size = 0;
  const mod = 317;
  const mult = 17;
  const add = 11;
  let count = 0;
  const PIPE = process.env.PIPE_NAME;
  const socket = net.connect(PIPE, () => {
    bench.start();
    WriteHTTPHeaders(socket, 1, len);
    socket.setEncoding('utf8');
    socket.on('data', (d) => {
      let did = false;
      let pattern = 'HTTP/1.1 200 OK\r\n';
      if ((d.length === pattern.length && d === pattern) ||
          (d.length > pattern.length &&
           d.slice(0, pattern.length) === pattern)) {
        did = true;
      } else {
        pattern = 'HTTP/1.1 ';
        if ((d.length === pattern.length && d === pattern) ||
            (d.length > pattern.length &&
             d.slice(0, pattern.length) === pattern)) {
          did = true;
        }
      }
      size = (size * mult + add) % mod;
      if (did) {
        count += 1;
        if (count === n) {
          bench.end(count);
          process.exit(0);
        } else {
          WriteHTTPHeaders(socket, 1, min + size);
        }
      }
    });
    socket.on('close', () => {
      console.log('Connection closed');
    });

    socket.on('error', () => {
      throw new Error('Connection error');
    });
  });
}
                                                                                                                                                            node-23.7.0/benchmark/http/bench-parser.js                                                          0000664 0000000 0000000 00000002555 14746647661 0020404 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const bench = common.createBenchmark(main, {
  len: [4, 8, 16, 32],
  n: [1e5],
}, {
  flags: ['--expose-internals', '--no-warnings'],
});

function main({ len, n }) {
  const { HTTPParser } = common.binding('http_parser');
  const REQUEST = HTTPParser.REQUEST;
  const kOnHeaders = HTTPParser.kOnHeaders | 0;
  const kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;
  const kOnBody = HTTPParser.kOnBody | 0;
  const kOnMessageComplete = HTTPParser.kOnMessageComplete | 0;
  const CRLF = '\r\n';

  function processHeader(header, n) {
    const parser = newParser(REQUEST);

    bench.start();
    for (let i = 0; i < n; i++) {
      parser.execute(header, 0, header.length);
      parser.initialize(REQUEST, {});
    }
    bench.end(n);
  }

  function newParser(type) {
    const parser = new HTTPParser();
    parser.initialize(type, {});

    parser.headers = [];

    parser[kOnHeaders] = function() { };
    parser[kOnHeadersComplete] = function() { };
    parser[kOnBody] = function() { };
    parser[kOnMessageComplete] = function() { };

    return parser;
  }

  let header = `GET /hello HTTP/1.1${CRLF}Content-Type: text/plain${CRLF}`;

  for (let i = 0; i < len; i++) {
    header += `X-Filler${i}: ${Math.random().toString(36).substring(2)}${CRLF}`;
  }
  header += CRLF;

  processHeader(Buffer.from(header), n);
}
                                                                                                                                                   node-23.7.0/benchmark/http/check_invalid_header_char.js                                             0000664 0000000 0000000 00000003767 14746647661 0023131 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const _checkInvalidHeaderChar = require('_http_common')._checkInvalidHeaderChar;

const groupedInputs = {
  // Representative set of inputs from an AcmeAir benchmark run:
  // all valid strings, average length 14.4, stdev 13.0
  group_acmeair: [
    'W/"2-d4cbb29"', 'OK', 'Express', 'X-HTTP-Method-Override', 'Express',
    'application/json', 'application/json; charset=utf-8', '206', 'OK',
    'sessionid=; Path=/', 'text/html; charset=utf-8',
    'text/html; charset=utf-8', '10', 'W/"a-eda64de5"', 'OK', 'Express',
    'application/json', 'application/json; charset=utf-8', '2', 'W/"2-d4cbb29"',
    'OK', 'Express', 'X-HTTP-Method-Override', 'sessionid=; Path=/', 'Express',
    'sessionid=; Path=/,sessionid=6b059402-d62f-4e6f-b3dd-ce5b9e487c39; Path=/',
    'text/html; charset=utf-8', 'text/html; charset=utf-8', '9', 'OK',
    'sessionid=; Path=/', 'text/html; charset=utf-8',
    'text/html; charset=utf-8', '10', 'W/"a-eda64de5"', 'OK', 'Express',
    'Express', 'X-HTTP-Method-Override', 'sessionid=; Path=/',
    'application/json',
  ],

  // Put it here so the benchmark result lines will not be super long.
  LONG_AND_INVALID: ['Here is a value that is really a folded header ' +
    'value\r\n  this should be supported, but it is not currently'],
};

const inputs = [
  // Valid
  '',
  '1',
  '\t\t\t\t\t\t\t\t\t\tFoo bar baz',
  'keep-alive',
  'close',
  'gzip',
  '20091',
  'private',
  'text/html; charset=utf-8',
  'text/plain',
  'Sat, 07 May 2016 16:54:48 GMT',
  'SAMEORIGIN',
  'en-US',

  // Invalid
  '中文呢', // unicode
  'foo\nbar',
  '\x7F',
];

const bench = common.createBenchmark(main, {
  input: inputs.concat(Object.keys(groupedInputs)),
  n: [1e6],
});

function main({ n, input }) {
  let inputs = [input];
  if (Object.hasOwn(groupedInputs, input)) {
    inputs = groupedInputs[input];
  }

  const len = inputs.length;
  bench.start();
  for (let i = 0; i < n; i++) {
    _checkInvalidHeaderChar(inputs[i % len]);
  }
  bench.end(n);
}
         node-23.7.0/benchmark/http/check_is_http_token.js                                                   0000664 0000000 0000000 00000001703 14746647661 0022034 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const _checkIsHttpToken = require('_http_common')._checkIsHttpToken;

const bench = common.createBenchmark(main, {
  key: [
    'TCN',
    'ETag',
    'date',
    'Vary',
    'server',
    'Server',
    'status',
    'version',
    'Expires',
    'alt-svc',
    'location',
    'Connection',
    'Keep-Alive',
    'content-type',
    'Content-Type',
    'Cache-Control',
    'Last-Modified',
    'Accept-Ranges',
    'content-length',
    'x-frame-options',
    'x-xss-protection',
    'Content-Encoding',
    'Content-Location',
    'Transfer-Encoding',
    'alternate-protocol',
    ':', // invalid input
    '@@',
    '中文呢', // unicode
    '((((())))', // invalid
    ':alternate-protocol', // fast bailout
    'alternate-protocol:', // slow bailout
  ],
  n: [1e6],
});

function main({ n, key }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    _checkIsHttpToken(key);
  }
  bench.end(n);
}
                                                             node-23.7.0/benchmark/http/chunked.js                                                               0000664 0000000 0000000 00000002002 14746647661 0017437 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // When calling .end(buffer) right away, this triggers a "hot path"
// optimization in http.js, to avoid an extra write call.
//
// However, the overhead of copying a large buffer is higher than
// the overhead of an extra write() call, so the hot path was not
// always as hot as it could be.
//
// Verify that our assumptions are valid.
'use strict';

const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [1, 4, 8, 16],
  len: [1, 64, 256],
  c: [100],
  duration: 5,
});

function main({ len, n, c, duration }) {
  const http = require('http');
  const chunk = Buffer.alloc(len, '8');

  const server = http.createServer((req, res) => {
    function send(left) {
      if (left === 0) return res.end();
      res.write(chunk);
      setTimeout(() => {
        send(left - 1);
      }, 0);
    }
    send(n);
  });

  server.listen(0, () => {
    bench.http({
      connections: c,
      duration,
      port: server.address().port,
    }, () => {
      server.close();
    });
  });
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/benchmark/http/client-request-body.js                                                   0000664 0000000 0000000 00000002644 14746647661 0021731 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Measure the time it takes for the HTTP client to send a request body.
'use strict';

const common = require('../common.js');
const http = require('http');

const bench = common.createBenchmark(main, {
  dur: [5],
  type: ['asc', 'utf', 'buf'],
  len: [32, 256, 1024],
  method: ['write', 'end'],
});

function main({ dur, len, type, method }) {
  let encoding;
  let chunk;
  switch (type) {
    case 'buf':
      chunk = Buffer.alloc(len, 'x');
      break;
    case 'utf':
      encoding = 'utf8';
      chunk = 'ü'.repeat(len / 2);
      break;
    case 'asc':
      chunk = 'a'.repeat(len);
      break;
  }

  let nreqs = 0;
  const options = {
    headers: { 'Connection': 'keep-alive', 'Transfer-Encoding': 'chunked' },
    agent: new http.Agent({ maxSockets: 1 }),
    host: '127.0.0.1',
    path: '/',
    method: 'POST',
  };

  const server = http.createServer((req, res) => {
    res.end();
  });
  server.listen(0, options.host, () => {
    setTimeout(done, dur * 1000);
    bench.start();
    pummel(server.address().port);
  });

  function pummel(port) {
    options.port = port;
    const req = http.request(options, (res) => {
      nreqs++;
      pummel(port);  // Line up next request.
      res.resume();
    });
    if (method === 'write') {
      req.write(chunk, encoding);
      req.end();
    } else {
      req.end(chunk, encoding);
    }
  }

  function done() {
    bench.end(nreqs);
    process.exit(0);
  }
}
                                                                                            node-23.7.0/benchmark/http/cluster.js                                                               0000664 0000000 0000000 00000001630 14746647661 0017505 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const PORT = common.PORT;

const cluster = require('cluster');
let bench;
if (cluster.isPrimary) {
  bench = common.createBenchmark(main, {
    // Unicode confuses ab on os x.
    type: ['bytes', 'buffer'],
    len: [4, 1024, 102400],
    c: [50, 500],
    duration: 5,
  });
} else {
  const port = parseInt(process.env.PORT || PORT);
  require('../fixtures/simple-http-server.js').listen(port);
}

function main({ type, len, c, duration }) {
  process.env.PORT = PORT;
  let workers = 0;
  const w1 = cluster.fork();
  const w2 = cluster.fork();

  cluster.on('listening', () => {
    workers++;
    if (workers < 2)
      return;

    setImmediate(() => {
      const path = `/${type}/${len}`;

      bench.http({
        path: path,
        connections: c,
        duration,
      }, () => {
        w1.destroy();
        w2.destroy();
      });
    });
  });
}
                                                                                                        node-23.7.0/benchmark/http/create-clientrequest.js                                                  0000664 0000000 0000000 00000002725 14746647661 0022162 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const { ClientRequest } = require('http');
const assert = require('assert');

const types = Object.keys(common.urls)
  .filter((i) => common.urls[i]
  .startsWith('http://'));
const bench = common.createBenchmark(main, {
  // Use 'url' to avoid name clash with other http benchmark
  url: types.concat(['wpt']),
  arg: ['URL', 'string', 'options'],
  e: [1],
});

function noop() {}

function main({ url: type, arg, e }) {
  e = Number(e);
  const data = common.bakeUrlData(type, e, false, false)
    .filter((i) => i.startsWith('http://'));
  const len = data.length;
  let result;
  switch (arg) {
    case 'options': {
      const options = data.map((i) => ({
        path: new URL(i).path, createConnection: noop,
      }));
      bench.start();
      for (let i = 0; i < len; i++) {
        result = new ClientRequest(options[i]);
      }
      bench.end(len);
      break;
    }
    case 'URL': {
      const options = data.map((i) => new URL(i));
      bench.start();
      for (let i = 0; i < len; i++) {
        result = new ClientRequest(options[i], { createConnection: noop });
      }
      bench.end(len);
      break;
    }
    case 'string': {
      bench.start();
      for (let i = 0; i < len; i++) {
        result = new ClientRequest(data[i], { createConnection: noop });
      }
      bench.end(len);
      break;
    }
    default: {
      throw new Error(`Unknown arg type ${arg}`);
    }
  }
  assert.ok(result);
}
                                           node-23.7.0/benchmark/http/end-vs-write-end.js                                                      0000664 0000000 0000000 00000002426 14746647661 0021120 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // When calling .end(buffer) right away, this triggers a "hot path"
// optimization in http.js, to avoid an extra write call.
//
// However, the overhead of copying a large buffer is higher than
// the overhead of an extra write() call, so the hot path was not
// always as hot as it could be.
//
// Verify that our assumptions are valid.
'use strict';

const common = require('../common.js');

const bench = common.createBenchmark(main, {
  type: ['asc', 'utf', 'buf'],
  len: [64 * 1024, 128 * 1024, 256 * 1024, 1024 * 1024],
  c: [100],
  method: ['write', 'end'],
  duration: 5,
});

function main({ len, type, method, c, duration }) {
  const http = require('http');
  let chunk;
  switch (type) {
    case 'buf':
      chunk = Buffer.alloc(len, 'x');
      break;
    case 'utf':
      chunk = 'ü'.repeat(len / 2);
      break;
    case 'asc':
      chunk = 'a'.repeat(len);
      break;
  }

  function write(res) {
    res.write(chunk);
    res.end();
  }

  function end(res) {
    res.end(chunk);
  }

  const fn = method === 'write' ? write : end;

  const server = http.createServer((req, res) => {
    fn(res);
  });

  server.listen(0, () => {
    bench.http({
      connections: c,
      duration,
      port: server.address().port,
    }, () => {
      server.close();
    });
  });
}
                                                                                                                                                                                                                                          node-23.7.0/benchmark/http/headers.js                                                               0000664 0000000 0000000 00000001707 14746647661 0017444 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const http = require('http');

const bench = common.createBenchmark(main, {
  fewHeaders: {
    n: [10],
    len: [1, 5],
    duration: 5,
  },
  mediumHeaders: {
    n: [50],
    len: [1, 10],
    duration: 5,
  },
  manyHeaders: {
    n: [600],
    len: [1, 100],
    duration: 5,
  },
}, { byGroups: true });

function main({ len, n, duration }) {
  const headers = {
    'Connection': 'keep-alive',
    'Transfer-Encoding': 'chunked',
  };

  const Is = [...Array(n / len).keys()];
  const Js = [...Array(len).keys()];

  for (const i of Is) {
    headers[`foo${i}`] = Js.map(() => `some header value ${i}`);
  }

  const server = http.createServer((req, res) => {
    res.writeHead(200, headers);
    res.end();
  });

  server.listen(0, () => {
    bench.http({
      path: '/',
      connections: 10,
      duration,
      port: server.address().port,
    }, () => {
      server.close();
    });
  });
}
                                                         node-23.7.0/benchmark/http/http_server_for_chunky_client.js                                         0000664 0000000 0000000 00000002006 14746647661 0024154 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const assert = require('assert');
const http = require('http');
const { fork } = require('child_process');
const common = require('../common.js');
const { PIPE } = require('../../test/common');
const tmpdir = require('../../test/common/tmpdir');
process.env.PIPE_NAME = PIPE;

tmpdir.refresh();

// For Node.js versions below v13.3.0 this benchmark will require
// the flag --max-http-header-size 64000 in order to work properly
const server = http.createServer({ maxHeaderSize: 64000 }, (req, res) => {
  const headers = {
    'content-type': 'text/plain',
    'content-length': '2',
  };
  res.writeHead(200, headers);
  res.end('ok');
});

server.on('error', (err) => {
  throw new Error(`server error: ${err}`);
});
server.listen(PIPE);

const child = fork(
  `${__dirname}/_chunky_http_client.js`,
  process.argv.slice(2),
);
child.on('message', (data) => {
  if (data.type === 'report') {
    common.sendResult(data);
  }
});
child.on('close', (code) => {
  server.close();
  assert.strictEqual(code, 0);
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/benchmark/http/incoming_headers.js                                                      0000664 0000000 0000000 00000002322 14746647661 0021321 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const http = require('http');

const bench = common.createBenchmark(main, {
  connections: [50], // Concurrent connections
  headers: [20], // Number of header lines to append after the common headers
  w: [0, 6], // Amount of trailing whitespace
  duration: 5,
});

function main({ connections, headers, w, duration }) {
  const server = http.createServer((req, res) => {
    res.end();
  });

  server.listen(0, () => {
    const headers = {
      'Content-Type': 'text/plain',
      'Accept': 'text/plain',
      'User-Agent': 'nodejs-benchmark',
      'Date': new Date().toString(),
      'Cache-Control': 'no-cache',
    };
    for (let i = 0; i < headers; i++) {
      // Note:
      // - autocannon does not send header values with OWS
      // - wrk can only send trailing OWS. This is a side-effect of wrk
      // processing requests with http-parser before sending them, causing
      // leading OWS to be stripped.
      headers[`foo${i}`] = `some header value ${i}${' \t'.repeat(w / 2)}`;
    }
    bench.http({
      path: '/',
      connections,
      headers,
      duration,
      port: server.address().port,
    }, () => {
      server.close();
    });
  });
}
                                                                                                                                                                                                                                                                                                              node-23.7.0/benchmark/http/set-header.js                                                            0000664 0000000 0000000 00000001401 14746647661 0020041 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  res: ['normal', 'setHeader', 'setHeaderWH'],
  duration: 5,
});

const type = 'bytes';
const len = 4;
const chunks = 0;
const chunkedEnc = 0;
const c = 50;

// normal: writeHead(status, {...})
// setHeader: statusCode = status, setHeader(...) x2
// setHeaderWH: setHeader(...), writeHead(status, ...)
function main({ res, duration }) {
  const server = require('../fixtures/simple-http-server.js')
  .listen(0)
  .on('listening', () => {
    const path = `/${type}/${len}/${chunks}/${res}/${chunkedEnc}`;

    bench.http({
      path: path,
      connections: c,
      duration,
      port: server.address().port,
    }, () => {
      server.close();
    });
  });
}
                                                                                                                                                                                                                                                               node-23.7.0/benchmark/http/set_header.js                                                            0000664 0000000 0000000 00000000753 14746647661 0020134 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const { OutgoingMessage } = require('_http_outgoing');

const bench = common.createBenchmark(main, {
  value: [
    'X-Powered-By',
    'Vary',
    'Set-Cookie',
    'Content-Type',
    'Content-Length',
    'Connection',
    'Transfer-Encoding',
  ],
  n: [1e6],
});

function main({ n, value }) {
  const og = new OutgoingMessage();

  bench.start();
  for (let i = 0; i < n; i++) {
    og.setHeader(value, '');
  }
  bench.end(n);
}
                     node-23.7.0/benchmark/http/simple.js                                                                0000664 0000000 0000000 00000001216 14746647661 0017315 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  // Unicode confuses ab on os x.
  type: ['bytes', 'buffer'],
  len: [4, 1024, 102400],
  chunks: [1, 4],
  c: [50, 500],
  chunkedEnc: [1, 0],
  duration: 5,
});

function main({ type, len, chunks, c, chunkedEnc, duration }) {
  const server = require('../fixtures/simple-http-server.js')
  .listen(0)
  .on('listening', () => {
    const path = `/${type}/${len}/${chunks}/normal/${chunkedEnc}`;

    bench.http({
      path,
      connections: c,
      duration,
      port: server.address().port,
    }, () => {
      server.close();
    });
  });
}
                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/http/upgrade.js                                                               0000664 0000000 0000000 00000002206 14746647661 0017453 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const net = require('net');

const bench = common.createBenchmark(main, {
  n: [5, 1000],
});

const reqData = 'GET / HTTP/1.1\r\n' +
                'Upgrade: WebSocket\r\n' +
                'Connection: Upgrade\r\n' +
                '\r\n' +
                'WjN}|M(6';

const resData = 'HTTP/1.1 101 Web Socket Protocol Handshake\r\n' +
                'Upgrade: WebSocket\r\n' +
                'Connection: Upgrade\r\n' +
                '\r\n\r\n';

function main({ n }) {
  const server = require('../fixtures/simple-http-server.js')
    .listen(0)
    .on('listening', () => {
      bench.start();
      doBench(server.address(), n, () => {
        bench.end(n);
        server.close();
      });
    })
    .on('upgrade', (req, socket, upgradeHead) => {
      socket.resume();
      socket.write(resData);
      socket.end();
    });
}

function doBench(address, count, done) {
  if (count === 0) {
    done();
    return;
  }

  const conn = net.createConnection(address.port);
  conn.write(reqData);
  conn.resume();

  conn.on('end', () => {
    doBench(address, count - 1, done);
  });
}
                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/benchmark/http2/                                                                        0000775 0000000 0000000 00000000000 14746647661 0015550 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/http2/compat.js                                                               0000664 0000000 0000000 00000001751 14746647661 0017375 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const path = require('path');
const fs = require('fs');
const file = path.join(path.resolve(__dirname, '../fixtures'), 'alice.html');

const bench = common.createBenchmark(main, {
  requests: [100, 1000, 5000],
  streams: [1, 10, 20, 40, 100, 200],
  clients: [2],
  benchmarker: ['test-double-http2'],
  duration: 5,
}, { flags: ['--no-warnings'] });

function main({ requests, streams, clients, duration }) {
  const http2 = require('http2');
  const server = http2.createServer();
  server.on('request', (req, res) => {
    const out = fs.createReadStream(file);
    res.setHeader('content-type', 'text/html');
    out.pipe(res);
    out.on('error', (err) => {
      res.destroy();
    });
  });
  server.listen(0, () => {
    bench.http({
      path: '/',
      port: server.address().port,
      requests,
      maxConcurrentStreams: streams,
      clients,
      threads: clients,
      duration,
    }, () => { server.close(); });
  });
}
                       node-23.7.0/benchmark/http2/headers.js                                                              0000664 0000000 0000000 00000002404 14746647661 0017521 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [1e3],
  nheaders: [0, 10, 100, 1000],
}, { flags: ['--no-warnings'] });

function main({ n, nheaders }) {
  const http2 = require('http2');
  const server = http2.createServer({
    maxHeaderListPairs: 20000,
  });

  const headersObject = {
    ':path': '/',
    ':scheme': 'http',
    'accept-encoding': 'gzip, deflate',
    'accept-language': 'en',
    'content-type': 'text/plain',
    'referer': 'https://example.org/',
    'user-agent': 'SuperBenchmarker 3000',
  };

  for (let i = 0; i < nheaders; i++) {
    headersObject[`foo${i}`] = `some header value ${i}`;
  }

  server.on('stream', (stream) => {
    stream.respond();
    stream.end('Hi!');
  });
  server.listen(0, () => {
    const client = http2.connect(`http://localhost:${server.address().port}/`, {
      maxHeaderListPairs: 20000,
    });

    function doRequest(remaining) {
      const req = client.request(headersObject);
      req.resume();
      req.on('end', () => {
        if (remaining > 0) {
          doRequest(remaining - 1);
        } else {
          bench.end(n);
          server.close();
          client.destroy();
        }
      });
    }

    bench.start();
    doRequest(n);
  });
}
                                                                                                                                                                                                                                                            node-23.7.0/benchmark/http2/respond-with-fd.js                                                      0000664 0000000 0000000 00000001750 14746647661 0021123 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const path = require('path');
const fs = require('fs');

const file = path.join(path.resolve(__dirname, '../fixtures'), 'alice.html');

const bench = common.createBenchmark(main, {
  requests: [100, 1000, 5000],
  streams: [1, 10, 20, 40, 100, 200],
  clients: [2],
  benchmarker: ['test-double-http2'],
  duration: 5,
}, { flags: ['--no-warnings'] });

function main({ requests, streams, clients, duration }) {
  fs.open(file, 'r', (err, fd) => {
    if (err)
      throw err;

    const http2 = require('http2');
    const server = http2.createServer();
    server.on('stream', (stream) => {
      stream.respondWithFD(fd);
      stream.on('error', (err) => {});
    });
    server.listen(0, () => {
      bench.http({
        path: '/',
        requests,
        port: server.address().port,
        maxConcurrentStreams: streams,
        clients,
        duration,
        threads: clients,
      }, () => server.close());
    });

  });

}
                        node-23.7.0/benchmark/http2/simple.js                                                               0000664 0000000 0000000 00000001670 14746647661 0017403 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const path = require('path');
const fs = require('fs');
const file = path.join(path.resolve(__dirname, '../fixtures'), 'alice.html');

const bench = common.createBenchmark(main, {
  requests: [100, 1000, 5000],
  streams: [1, 10, 20, 40, 100, 200],
  clients: [2],
  benchmarker: ['test-double-http2'],
  duration: 5,
}, { flags: ['--no-warnings'] });

function main({ requests, streams, clients, duration }) {
  const http2 = require('http2');
  const server = http2.createServer();
  server.on('stream', (stream) => {
    const out = fs.createReadStream(file);
    stream.respond();
    out.pipe(stream);
    stream.on('error', (err) => {});
  });
  server.listen(0, () => {
    bench.http({
      path: '/',
      port: server.address().port,
      requests,
      maxConcurrentStreams: streams,
      clients,
      duration,
      threads: clients,
    }, () => { server.close(); });
  });
}
                                                                        node-23.7.0/benchmark/http2/write.js                                                                0000664 0000000 0000000 00000001624 14746647661 0017243 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const bench = common.createBenchmark(main, {
  streams: [100, 200, 1000],
  length: [64 * 1024, 128 * 1024, 256 * 1024, 1024 * 1024],
  size: [100000],
  benchmarker: ['test-double-http2'],
  duration: 5,
}, { flags: ['--no-warnings'] });

function main({ streams, length, size, duration }) {
  const http2 = require('http2');
  const server = http2.createServer();
  server.on('stream', (stream) => {
    stream.respond();
    let written = 0;
    function write() {
      stream.write('ü'.repeat(size));
      written += size;
      if (written < length)
        setImmediate(write);
      else
        stream.end();
    }
    write();
  });
  server.listen(0, () => {
    bench.http({
      path: '/',
      port: server.address().port,
      requests: 10000,
      duration,
      maxConcurrentStreams: streams,
    }, () => { server.close(); });
  });
}
                                                                                                            node-23.7.0/benchmark/https/                                                                        0000775 0000000 0000000 00000000000 14746647661 0015651 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/https/simple.js                                                               0000664 0000000 0000000 00000001212 14746647661 0017474 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  type: ['bytes', 'buffer'],
  len: [4, 1024, 102400],
  chunks: [1, 4],
  c: [50, 500],
  chunkedEnc: [1, 0],
  benchmarker: ['test-double-https'],
  duration: 5,
});

function main({ type, len, chunks, c, chunkedEnc, duration }) {
  const server = require('../fixtures/simple-https-server.js')
  .listen(common.PORT)
  .on('listening', () => {
    const path = `/${type}/${len}/${chunks}/${chunkedEnc}`;

    bench.http({
      path,
      connections: c,
      scheme: 'https',
      duration,
    }, () => {
      server.close();
    });
  });
}
                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/benchmark/mime/                                                                         0000775 0000000 0000000 00000000000 14746647661 0015436 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/mime/mimetype-instantiation.js                                                0000664 0000000 0000000 00000002145 14746647661 0022511 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { MIMEType } = require('util');

const bench = common.createBenchmark(main, {
  n: [1e5],
  value: [
    'application/ecmascript; ',
    'text/html;charset=gbk',
    `text/html;${'0123456789'.repeat(12)}=x;charset=gbk`,
    'text/html;test=\u00FF;charset=gbk',
    'x/x;\n\r\t x=x\n\r\t ;x=y',
  ],
}, {
});

function main({ n, value }) {
  // Warm up.
  const length = 1024;
  const array = [];
  let errCase = false;

  for (let i = 0; i < length; ++i) {
    try {
      array.push(new MIMEType(value));
    } catch (e) {
      errCase = true;
      array.push(e);
    }
  }

  // console.log(`errCase: ${errCase}`);
  bench.start();

  for (let i = 0; i < n; ++i) {
    const index = i % length;
    try {
      array[index] = new MIMEType(value);
    } catch (e) {
      array[index] = e;
    }
  }

  bench.end(n);

  // Verify the entries to prevent dead code elimination from making
  // the benchmark invalid.
  for (let i = 0; i < length; ++i) {
    assert.strictEqual(typeof array[i], errCase ? 'object' : 'object');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/benchmark/mime/mimetype-to-string.js                                                    0000664 0000000 0000000 00000002202 14746647661 0021545 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { MIMEType } = require('util');

const bench = common.createBenchmark(main, {
  n: [1e5],
  value: [
    'application/ecmascript; ',
    'text/html;charset=gbk',
    `text/html;${'0123456789'.repeat(12)}=x;charset=gbk`,
    'text/html;test=\u00FF;charset=gbk',
    'x/x;\n\r\t x=x\n\r\t ;x=y',
  ],
}, {
});

function main({ n, value }) {
  // Warm up.
  const length = 1024;
  const array = [];
  let errCase = false;

  const mime = new MIMEType(value);

  for (let i = 0; i < length; ++i) {
    try {
      array.push(mime.toString());
    } catch (e) {
      errCase = true;
      array.push(e);
    }
  }

  // console.log(`errCase: ${errCase}`);
  bench.start();

  for (let i = 0; i < n; ++i) {
    const index = i % length;
    try {
      array[index] = mime.toString();
    } catch (e) {
      array[index] = e;
    }
  }

  bench.end(n);

  // Verify the entries to prevent dead code elimination from making
  // the benchmark invalid.
  for (let i = 0; i < length; ++i) {
    assert.strictEqual(typeof array[i], errCase ? 'object' : 'string');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/benchmark/misc/                                                                         0000775 0000000 0000000 00000000000 14746647661 0015442 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/misc/arguments.js                                                             0000664 0000000 0000000 00000002113 14746647661 0020002 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const { createBenchmark } = require('../common.js');
const { format } = require('util');

const methods = [
  'restAndSpread',
  'argumentsAndApply',
  'restAndApply',
  'predefined',
];

const bench = createBenchmark(main, {
  method: methods,
  n: [1e6],
});

function usingRestAndSpread(...args) {
  format(...args);
}

function usingRestAndApply(...args) {
  format.apply(null, args);
}

function usingArgumentsAndApply() {
  format.apply(null, arguments);
}

function usingPredefined() {
  format('part 1', 'part', 2, 'part 3', 'part', 4);
}

function main({ n, method, args }) {
  let fn;
  switch (method) {
    case 'restAndSpread':
      fn = usingRestAndSpread;
      break;
    case 'restAndApply':
      fn = usingRestAndApply;
      break;
    case 'argumentsAndApply':
      fn = usingArgumentsAndApply;
      break;
    case 'predefined':
      fn = usingPredefined;
      break;
    default:
      throw new Error(`Unexpected method "${method}"`);
  }

  bench.start();
  for (let i = 0; i < n; i++)
    fn('part 1', 'part', 2, 'part 3', 'part', 4);
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/benchmark/misc/freelist.js                                                              0000664 0000000 0000000 00000001405 14746647661 0017615 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [100000],
}, {
  flags: ['--expose-internals'],
});

function main({ n }) {
  let FreeList = require('internal/freelist');
  if (FreeList.FreeList)
    FreeList = FreeList.FreeList;
  const poolSize = 1000;
  const list = new FreeList('test', poolSize, Object);
  let j;
  const used = [];

  // First, alloc `poolSize` items
  for (j = 0; j < poolSize; j++) {
    used.push(list.alloc());
  }

  bench.start();

  for (let i = 0; i < n; i++) {
    // Return all the items to the pool
    for (j = 0; j < poolSize; j++) {
      list.free(used[j]);
    }

    // Re-alloc from pool
    for (j = 0; j < poolSize; j++) {
      list.alloc();
    }
  }

  bench.end(n);
}
                                                                                                                                                                                                                                                           node-23.7.0/benchmark/misc/getstringwidth.js                                                        0000664 0000000 0000000 00000001254 14746647661 0021050 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const bench = common.createBenchmark(main, {
  type: ['ascii', 'mixed', 'emojiseq', 'fullwidth'],
  n: [10e4],
}, {
  flags: ['--expose-internals'],
});

function main({ n, type }) {
  const { getStringWidth } = require('internal/util/inspect');

  const str = ({
    ascii: 'foobar'.repeat(100),
    mixed: 'foo'.repeat(100) + '😀' + 'bar'.repeat(100),
    emojiseq: '👨‍👨‍👧‍👦👨‍👩‍👦‍👦👨‍👩‍👧‍👧👩‍👩‍👧‍👦'.repeat(10),
    fullwidth: '你好'.repeat(150),
  })[type];

  bench.start();
  for (let j = 0; j < n; j += 1)
    getStringWidth(str);
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/benchmark/misc/object-property-bench.js                                                 0000664 0000000 0000000 00000002656 14746647661 0022216 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

/* eslint-disable dot-notation */

const common = require('../common.js');

const bench = common.createBenchmark(main, {
  method: ['property', 'string', 'variable', 'symbol'],
  n: [1e9],
});

function runProperty(n) {
  const object = {};

  bench.start();
  for (let i = 0; i < n; i++) {
    object.p1 = 21;
    object.p2 = 21;
    object.p1 += object.p2;
  }
  bench.end(n);
}

function runString(n) {
  const object = {};

  bench.start();
  for (let i = 0; i < n; i++) {
    object['p1'] = 21;
    object['p2'] = 21;
    object['p1'] += object['p2'];
  }
  bench.end(n);
}

function runVariable(n) {
  const object = {};
  const var1 = 'p1';
  const var2 = 'p2';

  bench.start();
  for (let i = 0; i < n; i++) {
    object[var1] = 21;
    object[var2] = 21;
    object[var1] += object[var2];
  }
  bench.end(n);
}

function runSymbol(n) {
  const object = {};
  const symbol1 = Symbol('p1');
  const symbol2 = Symbol('p2');

  bench.start();
  for (let i = 0; i < n; i++) {
    object[symbol1] = 21;
    object[symbol2] = 21;
    object[symbol1] += object[symbol2];
  }
  bench.end(n);
}

function main({ n, method }) {

  switch (method) {
    case 'property':
      runProperty(n);
      break;
    case 'string':
      runString(n);
      break;
    case 'variable':
      runVariable(n);
      break;
    case 'symbol':
      runSymbol(n);
      break;
    default:
      throw new Error(`Unexpected method "${method}"`);
  }
}
                                                                                  node-23.7.0/benchmark/misc/print.js                                                                 0000664 0000000 0000000 00000002331 14746647661 0017133 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { spawn } = require('child_process');

const bench = common.createBenchmark(main, {
  dur: [1],
  code: ['1', '"string"', 'process.versions', 'process'],
});

function spawnProcess(code) {
  const cmd = process.execPath || process.argv[0];
  const argv = ['-p', code];
  return spawn(cmd, argv);
}

function start(state, code, bench, getNode) {
  const node = getNode(code);
  let stdout = '';
  let stderr = '';

  node.stdout.on('data', (data) => {
    stdout += data;
  });

  node.stderr.on('data', (data) => {
    stderr += data;
  });

  node.on('exit', (code) => {
    if (code !== 0) {
      console.error('------ stdout ------');
      console.error(stdout);
      console.error('------ stderr ------');
      console.error(stderr);
      throw new Error(`Error during node startup, exit code ${code}`);
    }
    state.throughput++;

    if (state.go) {
      start(state, code, bench, getNode);
    } else {
      bench.end(state.throughput);
    }
  });
}

function main({ dur, code }) {
  const state = {
    go: true,
    throughput: 0,
  };

  setTimeout(() => {
    state.go = false;
  }, dur * 1000);

  bench.start();
  start(state, code, bench, spawnProcess);
}
                                                                                                                                                                                                                                                                                                       node-23.7.0/benchmark/misc/punycode.js                                                              0000664 0000000 0000000 00000003342 14746647661 0017630 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
let icu;
try {
  icu = common.binding('icu');
} catch {
  // Continue regardless of error.
}
const punycode = require('punycode');

const bench = common.createBenchmark(main, {
  method: ['punycode'].concat(icu !== undefined ? ['icu'] : []),
  n: [1024],
  val: [
    'افغانستا.icom.museum',
    'الجزائر.icom.museum',
    'österreich.icom.museum',
    'বাংলাদেশ.icom.museum',
    'беларусь.icom.museum',
    'belgië.icom.museum',
    'българия.icom.museum',
    'تشادر.icom.museum',
    '中国.icom.museum',
    'القمر.icom.museum',
    'κυπρος.icom.museum',
    'českárepublika.icom.museum',
    'مصر.icom.museum',
    'ελλάδα.icom.museum',
    'magyarország.icom.museum',
    'ísland.icom.museum',
    'भारत.icom.museum',
    'ايران.icom.museum',
    'éire.icom.museum',
    'איקו״ם.ישראל.museum',
    '日本.icom.museum',
    'الأردن.icom.museum',
  ],
});

function usingPunycode(val) {
  punycode.toUnicode(punycode.toASCII(val));
}

function usingICU(val) {
  icu.toUnicode(icu.toASCII(val));
}

function runPunycode(n, val) {
  for (let i = 0; i < n; i++)
    usingPunycode(val);
  bench.start();
  for (let i = 0; i < n; i++)
    usingPunycode(val);
  bench.end(n);
}

function runICU(n, val) {
  bench.start();
  for (let i = 0; i < n; i++)
    usingICU(val);
  bench.end(n);
}

function main({ n, val, method }) {
  switch (method) {
    case 'punycode':
      runPunycode(n, val);
      break;
    case 'icu':
      if (icu !== undefined) {
        runICU(n, val);
        break;
      }
      // fallthrough
    default:
      throw new Error(`Unexpected method "${method}"`);
  }
}
                                                                                                                                                                                                                                                                                              node-23.7.0/benchmark/misc/startup-cli-version.js                                                   0000664 0000000 0000000 00000003450 14746647661 0021734 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { spawnSync } = require('child_process');
const { existsSync } = require('fs');
const path = require('path');

// This benchmarks the startup of various CLI tools that are already
// checked into the source code. We use --version because the output
// tends to be minimal and fewer operations are done to generate
// these so that the startup cost is still dominated by a more
// indispensible part of the CLI.
// NOTE: not all tools are present in tarball hence need to filter
const availableCli = [
  'tools/eslint/node_modules/eslint/bin/eslint.js',
  'deps/npm/bin/npx-cli.js',
  'deps/npm/bin/npm-cli.js',
  'deps/corepack/dist/corepack.js',
].filter((cli) => existsSync(path.resolve(__dirname, '../../', cli)));
const bench = common.createBenchmark(main, {
  cli: availableCli,
  n: [30],
});

function spawnProcess(cli, bench, state) {
  const cmd = process.execPath || process.argv[0];
  while (state.finished < state.n) {
    const child = spawnSync(cmd, [cli, '--version'], {
      env: { npm_config_loglevel: 'silent', ...process.env },
    });
    // Log some information for debugging if it fails, which it shouldn't.
    if (child.status !== 0) {
      console.log('---- STDOUT ----');
      console.log(child.stdout.toString());
      console.log('---- STDERR ----');
      console.log(child.stderr.toString());
      throw new Error(`Child process stopped with exit code ${child.status}`);
    }
    state.finished++;
    if (state.finished === 0) {
      // Finished warmup.
      bench.start();
    }

    if (state.finished === state.n) {
      bench.end(state.n);
    }
  }
}

function main({ n, cli }) {
  cli = path.resolve(__dirname, '../../', cli);
  const warmup = 3;
  const state = { n, finished: -warmup };
  spawnProcess(cli, bench, state);
}
                                                                                                                                                                                                                        node-23.7.0/benchmark/misc/startup-core.js                                                          0000664 0000000 0000000 00000003423 14746647661 0020432 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { spawnSync } = require('child_process');
const path = require('path');

let Worker;  // Lazy loaded in main

const bench = common.createBenchmark(main, {
  script: [
    'benchmark/fixtures/require-builtins',
    'test/fixtures/semicolon',
    'test/fixtures/snapshot/typescript',
  ],
  mode: ['process', 'worker'],
  n: [30],
});

function spawnProcess(script, bench, state) {
  const cmd = process.execPath || process.argv[0];
  while (state.finished < state.n) {
    const child = spawnSync(cmd, [script]);
    if (child.status !== 0) {
      console.log('---- STDOUT ----');
      console.log(child.stdout.toString());
      console.log('---- STDERR ----');
      console.log(child.stderr.toString());
      throw new Error(`Child process stopped with exit code ${child.status}`);
    }
    state.finished++;
    if (state.finished === 0) {
      // Finished warmup.
      bench.start();
    }

    if (state.finished === state.n) {
      bench.end(state.n);
    }
  }
}

function spawnWorker(script, bench, state) {
  const child = new Worker(script);
  child.on('exit', (code) => {
    if (code !== 0) {
      throw new Error(`Worker stopped with exit code ${code}`);
    }
    state.finished++;
    if (state.finished === 0) {
      // Finished warmup.
      bench.start();
    }
    if (state.finished < state.n) {
      spawnWorker(script, bench, state);
    } else {
      bench.end(state.n);
    }
  });
}

function main({ n, script, mode }) {
  script = path.resolve(__dirname, '../../', `${script}.js`);
  const warmup = 3;
  const state = { n, finished: -warmup };
  if (mode === 'worker') {
    Worker = require('worker_threads').Worker;
    spawnWorker(script, bench, state);
  } else {
    spawnProcess(script, bench, state);
  }
}
                                                                                                                                                                                                                                             node-23.7.0/benchmark/misc/structured-clone.js                                                      0000664 0000000 0000000 00000001736 14746647661 0021311 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  type: ['string', 'object', 'arraybuffer'],
  n: [1e4],
});

function main({ n, type }) {
  const data = [];

  switch (type) {
    case 'string':
      for (let i = 0; i < n; ++i) {
        data.push(new Date().toISOString());
      }
      break;
    case 'object':
      for (let i = 0; i < n; ++i) {
        data.push({ ...process.config });
      }
      break;
    case 'arraybuffer':
      for (let i = 0; i < n; ++i) {
        data.push(new ArrayBuffer(10));
      }
      break;
    default:
      throw new Error('Unsupported payload type');
  }

  const run = type === 'arraybuffer' ? (i) => {
    data[i] = structuredClone(data[i], { transfer: [ data[i] ] });
  } : (i) => {
    data[i] = structuredClone(data[i]);
  };

  bench.start();
  for (let i = 0; i < n; ++i) {
    run(i);
  }
  bench.end(n);
  assert.strictEqual(data.length, n);
}
                                  node-23.7.0/benchmark/misc/trace.js                                                                 0000664 0000000 0000000 00000002131 14746647661 0017073 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [100000],
  method: ['trace', 'isTraceCategoryEnabled'],
}, {
  flags: [
    '--expose-internals',
    '--no-warnings',
    '--trace-event-categories', 'foo',
  ],
});

const {
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: kBeforeEvent,
} = common.binding('constants').trace;

function doTrace(n, trace) {
  bench.start();
  for (let i = 0; i < n; i++) {
    trace(kBeforeEvent, 'foo', 'test', 0, 'test');
  }
  bench.end(n);
}

function doIsTraceCategoryEnabled(n, isTraceCategoryEnabled) {
  bench.start();
  for (let i = 0; i < n; i++) {
    isTraceCategoryEnabled('foo');
    isTraceCategoryEnabled('bar');
  }
  bench.end(n);
}

function main({ n, method }) {
  const {
    trace,
    isTraceCategoryEnabled,
  } = common.binding('trace_events');

  switch (method) {
    case 'trace':
      doTrace(n, trace);
      break;
    case 'isTraceCategoryEnabled':
      doIsTraceCategoryEnabled(n, isTraceCategoryEnabled);
      break;
    default:
      throw new Error(`Unexpected method "${method}"`);
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/benchmark/misc/util-extend-vs-object-assign.js                                          0000664 0000000 0000000 00000001303 14746647661 0023413 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const util = require('util');

const bench = common.createBenchmark(main, {
  type: ['extend', 'assign'],
  n: [10e4],
});

function main({ n, type }) {
  let fn;
  if (type === 'extend') {
    fn = util._extend;
  } else if (type === 'assign') {
    fn = Object.assign;
  }

  // Force-optimize the method to test so that the benchmark doesn't
  // get disrupted by the optimizer kicking in halfway through.
  for (let i = 0; i < type.length * 10; i += 1)
    fn({}, process.env);

  const obj = new Proxy({}, { set: function(a, b, c) { return true; } });

  bench.start();
  for (let j = 0; j < n; j += 1)
    fn(obj, process.env);
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                             node-23.7.0/benchmark/module/                                                                       0000775 0000000 0000000 00000000000 14746647661 0015774 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/module/module-loader-circular.js                                              0000664 0000000 0000000 00000001432 14746647661 0022665 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const fs = require('fs');
const path = require('path');
const common = require('../common.js');

const tmpdir = require('../../test/common/tmpdir');
const benchmarkDirectory = tmpdir.resolve('benchmark-module-circular');

const bench = common.createBenchmark(main, {
  n: [1e4],
});

function main({ n }) {
  tmpdir.refresh();

  const aDotJS = path.join(benchmarkDirectory, 'a.js');
  const bDotJS = path.join(benchmarkDirectory, 'b.js');

  fs.mkdirSync(benchmarkDirectory);
  fs.writeFileSync(aDotJS, 'require("./b.js");');
  fs.writeFileSync(bDotJS, 'require("./a.js");');

  bench.start();
  for (let i = 0; i < n; i++) {
    require(aDotJS);
    require(bDotJS);
    delete require.cache[aDotJS];
    delete require.cache[bDotJS];
  }
  bench.end(n);

  tmpdir.refresh();
}
                                                                                                                                                                                                                                      node-23.7.0/benchmark/module/module-loader-deep.js                                                  0000664 0000000 0000000 00000002157 14746647661 0022003 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const fs = require('fs');
const common = require('../common.js');

const tmpdir = require('../../test/common/tmpdir');
const benchmarkDirectory = tmpdir.resolve('nodejs-benchmark-module');

const bench = common.createBenchmark(main, {
  ext: ['', '.js'],
  files: [1e3],
  cache: ['true', 'false'],
});

function main({ ext, cache, files }) {
  tmpdir.refresh();
  fs.mkdirSync(benchmarkDirectory);
  fs.writeFileSync(
    `${benchmarkDirectory}/a.js`,
    'module.exports = {};',
  );
  for (let i = 0; i <= files; i++) {
    fs.mkdirSync(`${benchmarkDirectory}/${i}`);
    fs.writeFileSync(
      `${benchmarkDirectory}/${i}/package.json`,
      '{"main": "index.js"}',
    );
    fs.writeFileSync(
      `${benchmarkDirectory}/${i}/index.js`,
      `require('../a${ext}');`,
    );
  }

  measureDir(cache === 'true', files);

  tmpdir.refresh();
}

function measureDir(cache, files) {
  if (cache) {
    for (let i = 0; i <= files; i++) {
      require(`${benchmarkDirectory}/${i}`);
    }
  }
  bench.start();
  for (let i = 0; i <= files; i++) {
    require(`${benchmarkDirectory}/${i}`);
  }
  bench.end(files);
}
                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/benchmark/module/module-loader.js                                                       0000664 0000000 0000000 00000003155 14746647661 0021067 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const fs = require('fs');
const path = require('path');
const { builtinModules } = require('module');
const common = require('../common.js');

const tmpdir = require('../../test/common/tmpdir');
let benchmarkDirectory = tmpdir.resolve('nodejs-benchmark-module');

// Filter all irregular modules.
const otherModules = builtinModules.filter((name) => !/\/|^_|^sys/.test(name));

const bench = common.createBenchmark(main, {
  name: ['', '/', '/index.js'],
  dir: ['rel', 'abs'],
  files: [5e2],
  n: [1, 1e3],
  cache: ['true', 'false'],
}, { flags: '--no-warnings' });

function main({ n, name, cache, files, dir }) {
  tmpdir.refresh();
  fs.mkdirSync(benchmarkDirectory);
  for (let i = 0; i <= files; i++) {
    fs.mkdirSync(`${benchmarkDirectory}${i}`);
    fs.writeFileSync(
      `${benchmarkDirectory}${i}/package.json`,
      '{"main": "index.js"}',
    );
    fs.writeFileSync(
      `${benchmarkDirectory}${i}/index.js`,
      'module.exports = "";',
    );
  }

  if (dir === 'rel')
    benchmarkDirectory = path.relative(__dirname, benchmarkDirectory);

  measureDir(n, cache === 'true', files, name);

  tmpdir.refresh();
}

function measureDir(n, cache, files, name) {
  if (cache) {
    for (let i = 0; i <= files; i++) {
      require(`${benchmarkDirectory}${i}${name}`);
    }
  }
  bench.start();
  for (let i = 0; i <= files; i++) {
    for (let j = 0; j < n; j++)
      require(`${benchmarkDirectory}${i}${name}`);
    // Pretend mixed input (otherwise the results are less representative due to
    // highly specialized code).
    require(otherModules[i % otherModules.length]);
  }
  bench.end(n * files);
}
                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/benchmark/module/module-require.js                                                      0000664 0000000 0000000 00000003142 14746647661 0021271 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const fs = require('fs');
const common = require('../common.js');
const tmpdir = require('../../test/common/tmpdir');
const benchmarkDirectory = tmpdir.resolve('nodejs-benchmark-module');

const bench = common.createBenchmark(main, {
  type: ['.js', '.json', 'dir'],
  n: [1e4],
});

function main({ type, n }) {
  tmpdir.refresh();
  createEntryPoint(n);

  switch (type) {
    case '.js':
      measureJSFile(n);
      break;
    case '.json':
      measureJSONFile(n);
      break;
    case 'dir':
      measureDir(n);
  }

  tmpdir.refresh();
}

function measureJSFile(n) {
  bench.start();
  for (let i = 0; i < n; i++) {
    require(`${benchmarkDirectory}/${i}`);
  }
  bench.end(n);
}

function measureJSONFile(n) {
  bench.start();
  for (let i = 0; i < n; i++) {
    require(`${benchmarkDirectory}/json_${i}.json`);
  }
  bench.end(n);
}

function measureDir(n) {
  bench.start();
  for (let i = 0; i < n; i++) {
    require(`${benchmarkDirectory}${i}`);
  }
  bench.end(n);
}

function createEntryPoint(n) {
  fs.mkdirSync(benchmarkDirectory);

  const JSFileContent = 'module.exports = [];';
  const JSONFileContent = '[]';

  for (let i = 0; i < n; i++) {
    // JS file.
    fs.writeFileSync(`${benchmarkDirectory}/${i}.js`, JSFileContent);

    // JSON file.
    fs.writeFileSync(`${benchmarkDirectory}/json_${i}.json`, JSONFileContent);

    // Dir.
    fs.mkdirSync(`${benchmarkDirectory}${i}`);
    fs.writeFileSync(
      `${benchmarkDirectory}${i}/package.json`,
      '{"main": "index.js"}',
    );
    fs.writeFileSync(
      `${benchmarkDirectory}${i}/index.js`,
      JSFileContent,
    );
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/benchmark/napi/                                                                         0000775 0000000 0000000 00000000000 14746647661 0015436 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/napi/buffer/                                                                  0000775 0000000 0000000 00000000000 14746647661 0016707 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/napi/buffer/.gitignore                                                        0000664 0000000 0000000 00000000007 14746647661 0020674 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        build/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/napi/buffer/binding.cc                                                        0000664 0000000 0000000 00000006254 14746647661 0020637 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node_api.h>
#include <stdio.h>
#include <stdlib.h>

#define NODE_API_CALL(call)                                                    \
  do {                                                                         \
    napi_status status = call;                                                 \
    if (status != napi_ok) {                                                   \
      fprintf(stderr, #call " failed: %d\n", status);                          \
      abort();                                                                 \
    }                                                                          \
  } while (0)

#define ABORT_IF_FALSE(condition)                                              \
  if (!(condition)) {                                                          \
    fprintf(stderr, #condition " failed\n");                                   \
    abort();                                                                   \
  }

static void Finalize(node_api_basic_env env, void* data, void* hint) {
  delete[] static_cast<uint8_t*>(data);
}

static napi_value CreateExternalBuffer(napi_env env, napi_callback_info info) {
  napi_value argv[2], undefined, start, end;
  size_t argc = 2;
  int32_t n = 0;
  napi_valuetype val_type = napi_undefined;

  // Validate params and retrieve start and end function.
  NODE_API_CALL(napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr));
  ABORT_IF_FALSE(argc == 2);
  NODE_API_CALL(napi_typeof(env, argv[0], &val_type));
  ABORT_IF_FALSE(val_type == napi_object);
  NODE_API_CALL(napi_typeof(env, argv[1], &val_type));
  ABORT_IF_FALSE(val_type == napi_number);
  NODE_API_CALL(napi_get_named_property(env, argv[0], "start", &start));
  NODE_API_CALL(napi_typeof(env, start, &val_type));
  ABORT_IF_FALSE(val_type == napi_function);
  NODE_API_CALL(napi_get_named_property(env, argv[0], "end", &end));
  NODE_API_CALL(napi_typeof(env, end, &val_type));
  ABORT_IF_FALSE(val_type == napi_function);
  NODE_API_CALL(napi_get_value_int32(env, argv[1], &n));

  NODE_API_CALL(napi_get_undefined(env, &undefined));

  constexpr uint32_t kBufferLen = 32;

  // Start the benchmark.
  napi_call_function(env, argv[0], start, 0, nullptr, nullptr);

  for (int32_t idx = 0; idx < n; idx++) {
    napi_handle_scope scope;
    uint8_t* buffer = new uint8_t[kBufferLen];
    napi_value jsbuffer;
    NODE_API_CALL(napi_open_handle_scope(env, &scope));
    NODE_API_CALL(napi_create_external_buffer(
        env, kBufferLen, buffer, Finalize, nullptr, &jsbuffer));
    NODE_API_CALL(napi_close_handle_scope(env, scope));
  }

  // Conclude the benchmark.
  napi_value end_argv[] = {argv[1]};
  NODE_API_CALL(napi_call_function(env, argv[0], end, 1, end_argv, nullptr));

  return undefined;
}

NAPI_MODULE_INIT() {
  napi_property_descriptor props[] = {
      {"createExternalBuffer",
       nullptr,
       CreateExternalBuffer,
       nullptr,
       nullptr,
       nullptr,
       static_cast<napi_property_attributes>(napi_writable | napi_configurable |
                                             napi_enumerable),
       nullptr},
  };

  NODE_API_CALL(napi_define_properties(
      env, exports, sizeof(props) / sizeof(*props), props));
  return exports;
}
                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/benchmark/napi/buffer/binding.gyp                                                       0000664 0000000 0000000 00000000461 14746647661 0021043 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'defines': [
          'NAPI_EXPERIMENTAL'
      ]
    },
    {
      'target_name': 'binding_node_api_v8',
      'sources': [ 'binding.cc' ],
      'defines': [
          'NAPI_VERSION=8'
      ]
    }
  ]
}
                                                                                                                                                                                                               node-23.7.0/benchmark/napi/buffer/index.js                                                          0000664 0000000 0000000 00000000522 14746647661 0020353 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common.js');

const bench = common.createBenchmark(main, {
  n: [5e6],
  addon: ['binding', 'binding_node_api_v8'],
  implem: ['createExternalBuffer'],
});

function main({ n, implem, addon }) {
  const binding = require(`./build/${common.buildType}/${addon}`);
  binding[implem](bench, n);
}
                                                                                                                                                                              node-23.7.0/benchmark/napi/define_properties/                                                       0000775 0000000 0000000 00000000000 14746647661 0021144 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/napi/define_properties/.gitignore                                             0000664 0000000 0000000 00000000007 14746647661 0023131 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        build/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/napi/define_properties/binding.c                                              0000664 0000000 0000000 00000007250 14746647661 0022726 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node_api.h>
#include <stdio.h>
#include <stdlib.h>

#define NODE_API_CALL(call)                                                    \
  do {                                                                         \
    napi_status status = call;                                                 \
    if (status != napi_ok) {                                                   \
      fprintf(stderr, #call " failed: %d\n", status);                          \
      abort();                                                                 \
    }                                                                          \
  } while (0)

#define ABORT_IF_FALSE(condition)                                              \
  if (!(condition)) {                                                          \
    fprintf(stderr, #condition " failed\n");                                   \
    abort();                                                                   \
  }

static napi_value Runner(napi_env env,
                         napi_callback_info info,
                         napi_property_attributes attr) {
  napi_value argv[2], undefined, js_array_length, start, end;
  size_t argc = 2;
  napi_valuetype val_type = napi_undefined;
  bool is_array = false;
  uint32_t array_length = 0;
  napi_value* native_array;

  // Validate params and retrieve start and end function.
  NODE_API_CALL(napi_get_cb_info(env, info, &argc, argv, NULL, NULL));
  ABORT_IF_FALSE(argc == 2);
  NODE_API_CALL(napi_typeof(env, argv[0], &val_type));
  ABORT_IF_FALSE(val_type == napi_object);
  NODE_API_CALL(napi_is_array(env, argv[1], &is_array));
  ABORT_IF_FALSE(is_array);
  NODE_API_CALL(napi_get_array_length(env, argv[1], &array_length));
  NODE_API_CALL(napi_get_named_property(env, argv[0], "start", &start));
  NODE_API_CALL(napi_typeof(env, start, &val_type));
  ABORT_IF_FALSE(val_type == napi_function);
  NODE_API_CALL(napi_get_named_property(env, argv[0], "end", &end));
  NODE_API_CALL(napi_typeof(env, end, &val_type));
  ABORT_IF_FALSE(val_type == napi_function);

  NODE_API_CALL(napi_get_undefined(env, &undefined));
  NODE_API_CALL(napi_create_uint32(env, array_length, &js_array_length));

  // Copy objects into a native array.
  native_array = malloc(array_length * sizeof(*native_array));
  for (uint32_t idx = 0; idx < array_length; idx++) {
    NODE_API_CALL(napi_get_element(env, argv[1], idx, &native_array[idx]));
  }

  const napi_property_descriptor desc = {
      "prop", NULL, NULL, NULL, NULL, js_array_length, attr, NULL};

  // Start the benchmark.
  napi_call_function(env, argv[0], start, 0, NULL, NULL);

  for (uint32_t idx = 0; idx < array_length; idx++) {
    NODE_API_CALL(napi_define_properties(env, native_array[idx], 1, &desc));
  }

  // Conclude the benchmark.
  NODE_API_CALL(
      napi_call_function(env, argv[0], end, 1, &js_array_length, NULL));

  free(native_array);

  return undefined;
}

static napi_value RunFastPath(napi_env env, napi_callback_info info) {
  return Runner(env, info, napi_writable | napi_enumerable | napi_configurable);
}

static napi_value RunSlowPath(napi_env env, napi_callback_info info) {
  return Runner(env, info, napi_writable | napi_enumerable);
}

NAPI_MODULE_INIT() {
  napi_property_descriptor props[] = {
      {"runFastPath",
       NULL,
       RunFastPath,
       NULL,
       NULL,
       NULL,
       napi_writable | napi_configurable | napi_enumerable,
       NULL},
      {"runSlowPath",
       NULL,
       RunSlowPath,
       NULL,
       NULL,
       NULL,
       napi_writable | napi_configurable | napi_enumerable,
       NULL},
  };

  NODE_API_CALL(napi_define_properties(
      env, exports, sizeof(props) / sizeof(*props), props));
  return exports;
}
                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/napi/define_properties/binding.gyp                                            0000664 0000000 0000000 00000000144 14746647661 0023276 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.c' ]
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/benchmark/napi/define_properties/index.js                                               0000664 0000000 0000000 00000000545 14746647661 0022615 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common.js');

const binding = require(`./build/${common.buildType}/binding`);

const bench = common.createBenchmark(main, {
  n: [5e6],
  implem: ['runFastPath', 'runSlowPath'],
});

function main({ n, implem }) {
  const objs = Array(n).fill(null).map((item) => new Object());
  binding[implem](bench, objs);
}
                                                                                                                                                           node-23.7.0/benchmark/napi/function_args/                                                           0000775 0000000 0000000 00000000000 14746647661 0020277 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/napi/function_args/.gitignore                                                 0000664 0000000 0000000 00000000007 14746647661 0022264 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        build/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/napi/function_args/binding.cc                                                 0000664 0000000 0000000 00000011614 14746647661 0022223 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <v8.h>
#include <node.h>
#include <assert.h>

using v8::Array;
using v8::ArrayBuffer;
using v8::ArrayBufferView;
using v8::BackingStore;
using v8::Context;
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::MaybeLocal;
using v8::Number;
using v8::Object;
using v8::String;
using v8::Uint32;
using v8::Value;

void CallWithString(const FunctionCallbackInfo<Value>& args) {
  assert(args.Length() == 1 && args[0]->IsString());
  if (args.Length() == 1 && args[0]->IsString()) {
    Local<String> str = args[0].As<String>();
    const int32_t length = str->Utf8Length(args.GetIsolate()) + 1;
    char* buf = new char[length];
    str->WriteUtf8(args.GetIsolate(), buf, length);
    delete[] buf;
  }
}

void CallWithArray(const FunctionCallbackInfo<Value>& args) {
  assert(args.Length() == 1 && args[0]->IsArray());
  if (args.Length() == 1 && args[0]->IsArray()) {
    const Local<Array> array = args[0].As<Array>();
    uint32_t length = array->Length();
    for (uint32_t i = 0; i < length; i++) {
      Local<Value> v;
      v = array->Get(args.GetIsolate()->GetCurrentContext(),
                     i).ToLocalChecked();
    }
  }
}

void CallWithNumber(const FunctionCallbackInfo<Value>& args) {
  assert(args.Length() == 1 && args[0]->IsNumber());
  if (args.Length() == 1 && args[0]->IsNumber()) {
    args[0].As<Number>()->Value();
  }
}

void CallWithObject(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();

  assert(args.Length() == 1 && args[0]->IsObject());
  if (args.Length() == 1 && args[0]->IsObject()) {
    Local<Object> obj = args[0].As<Object>();

    MaybeLocal<String> map_key = String::NewFromUtf8(isolate,
        "map", v8::NewStringType::kNormal);
    assert(!map_key.IsEmpty());
    MaybeLocal<Value> map_maybe = obj->Get(context,
        map_key.ToLocalChecked());
    assert(!map_maybe.IsEmpty());
    Local<Value> map;
    map = map_maybe.ToLocalChecked();

    MaybeLocal<String> operand_key = String::NewFromUtf8(isolate,
        "operand", v8::NewStringType::kNormal);
    assert(!operand_key.IsEmpty());
    MaybeLocal<Value> operand_maybe = obj->Get(context,
        operand_key.ToLocalChecked());
    assert(!operand_maybe.IsEmpty());
    Local<Value> operand;
    operand = operand_maybe.ToLocalChecked();

    MaybeLocal<String> data_key = String::NewFromUtf8(isolate,
        "data", v8::NewStringType::kNormal);
    assert(!data_key.IsEmpty());
    MaybeLocal<Value> data_maybe = obj->Get(context,
        data_key.ToLocalChecked());
    assert(!data_maybe.IsEmpty());
    Local<Value> data;
    data = data_maybe.ToLocalChecked();

    MaybeLocal<String> reduce_key = String::NewFromUtf8(isolate,
        "reduce", v8::NewStringType::kNormal);
    assert(!reduce_key.IsEmpty());
    MaybeLocal<Value> reduce_maybe = obj->Get(context,
        reduce_key.ToLocalChecked());
    assert(!reduce_maybe.IsEmpty());
    Local<Value> reduce;
    reduce = reduce_maybe.ToLocalChecked();
  }
}

void CallWithTypedarray(const FunctionCallbackInfo<Value>& args) {
  assert(args.Length() == 1 && args[0]->IsArrayBufferView());
  if (args.Length() == 1 && args[0]->IsArrayBufferView()) {
    assert(args[0]->IsArrayBufferView());
    Local<ArrayBufferView> view = args[0].As<ArrayBufferView>();
    const size_t byte_offset = view->ByteOffset();
    const size_t byte_length = view->ByteLength();
    assert(byte_length > 0);
    assert(view->HasBuffer());
    Local<ArrayBuffer> buffer = view->Buffer();
    std::shared_ptr<BackingStore> bs = buffer->GetBackingStore();
    const uint32_t* data = reinterpret_cast<uint32_t*>(
        static_cast<uint8_t*>(bs->Data()) + byte_offset);
    assert(data);
  }
}

void CallWithArguments(const FunctionCallbackInfo<Value>& args) {
  assert(args.Length() > 1 && args[0]->IsNumber());
  if (args.Length() > 1 && args[0]->IsNumber()) {
    int32_t loop = args[0].As<Uint32>()->Value();
    for (int32_t i = 1; i < loop; ++i) {
      assert(i < args.Length());
      assert(args[i]->IsUint32());
      args[i].As<Uint32>()->Value();
    }
  }
}

void Initialize(Local<Object> target,
                Local<Value> module,
                void* data) {
  NODE_SET_METHOD(target, "callWithString", CallWithString);
  NODE_SET_METHOD(target, "callWithLongString", CallWithString);

  NODE_SET_METHOD(target, "callWithArray", CallWithArray);
  NODE_SET_METHOD(target, "callWithLargeArray", CallWithArray);
  NODE_SET_METHOD(target, "callWithHugeArray", CallWithArray);

  NODE_SET_METHOD(target, "callWithNumber", CallWithNumber);
  NODE_SET_METHOD(target, "callWithObject", CallWithObject);
  NODE_SET_METHOD(target, "callWithTypedarray", CallWithTypedarray);

  NODE_SET_METHOD(target, "callWith10Numbers", CallWithArguments);
  NODE_SET_METHOD(target, "callWith100Numbers", CallWithArguments);
  NODE_SET_METHOD(target, "callWith1000Numbers", CallWithArguments);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                    node-23.7.0/benchmark/napi/function_args/binding.gyp                                                0000664 0000000 0000000 00000000275 14746647661 0022436 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'napi_binding',
      'sources': [ 'napi_binding.c' ]
    },
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ]
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                   node-23.7.0/benchmark/napi/function_args/index.js                                                   0000664 0000000 0000000 00000004675 14746647661 0021760 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Show the difference between calling a V8 binding C++ function
// relative to a comparable N-API C++ function,
// in various types/numbers of arguments.
// Reports n of calls per second.
'use strict';

const common = require('../../common.js');

let v8;
let napi;

try {
  v8 = require(`./build/${common.buildType}/binding`);
} catch {
  console.error(`${__filename}: V8 Binding failed to load`);
  process.exit(0);
}

try {
  napi = require(`./build/${common.buildType}/napi_binding`);
} catch {
  console.error(`${__filename}: NAPI-Binding failed to load`);
  process.exit(0);
}

const argsTypes = ['String', 'Number', 'Object', 'Array', 'Typedarray',
                   '10Numbers', '100Numbers', '1000Numbers'];

const generateArgs = (argType) => {
  let args = [];

  if (argType === 'String') {
    args.push('The quick brown fox jumps over the lazy dog');
  } else if (argType === 'LongString') {
    args.push(Buffer.alloc(32768, '42').toString());
  } else if (argType === 'Number') {
    args.push(Math.floor(314158964 * Math.random()));
  } else if (argType === 'Object') {
    args.push({
      map: 'add',
      operand: 10,
      data: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
      reduce: 'add',
    });
  } else if (argType === 'Array') {
    const arr = [];
    for (let i = 0; i < 50; ++i) {
      arr.push(Math.random() * 10e9);
    }
    args.push(arr);
  } else if (argType === 'Typedarray') {
    const arr = new Uint32Array(1000);
    for (let i = 0; i < 1000; ++i) {
      arr[i] = Math.random() * 4294967296;
    }
    args.push(arr);
  } else if (argType === '10Numbers') {
    args.push(10);
    for (let i = 0; i < 9; ++i) {
      args = [...args, ...generateArgs('Number')];
    }
  } else if (argType === '100Numbers') {
    args.push(100);
    for (let i = 0; i < 99; ++i) {
      args = [...args, ...generateArgs('Number')];
    }
  } else if (argType === '1000Numbers') {
    args.push(1000);
    for (let i = 0; i < 999; ++i) {
      args = [...args, ...generateArgs('Number')];
    }
  }

  return args;
};

const bench = common.createBenchmark(main, {
  type: argsTypes,
  engine: ['v8', 'napi'],
  n: [1, 1e1, 1e2, 1e3, 1e4, 1e5],
});

function main({ n, engine, type }) {
  const bindings = engine === 'v8' ? v8 : napi;
  const methodName = 'callWith' + type;
  const fn = bindings[methodName];

  if (fn) {
    const args = generateArgs(type);

    bench.start();
    for (let i = 0; i < n; i++) {
      fn.apply(null, args);
    }
    bench.end(n);
  }
}
                                                                   node-23.7.0/benchmark/napi/function_args/napi_binding.c                                             0000664 0000000 0000000 00000014727 14746647661 0023077 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node_api.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

static napi_value CallWithString(napi_env env, napi_callback_info info) {
  napi_status status;

  size_t argc = 1;
  napi_value args[1];
  status = napi_get_cb_info(env, info, &argc, args, NULL, NULL);
  assert(status == napi_ok);

  napi_valuetype types[1];
  status = napi_typeof(env, args[0], types);
  assert(status == napi_ok);

  assert(types[0] == napi_string);
  if (types[0] == napi_string) {
    size_t len = 0;
    // Get the length
    status = napi_get_value_string_utf8(env, args[0], NULL, 0, &len);
    assert(status == napi_ok);
    char* buf = (char*)malloc(len + 1);
    status = napi_get_value_string_utf8(env, args[0], buf, len + 1, &len);
    assert(status == napi_ok);
    free(buf);
  }

  return NULL;
}

static napi_value CallWithArray(napi_env env, napi_callback_info info) {
  napi_status status;

  size_t argc = 1;
  napi_value args[1];
  status = napi_get_cb_info(env, info, &argc, args, NULL, NULL);
  assert(status == napi_ok);

  napi_value array = args[0];
  bool is_array = false;
  status = napi_is_array(env, array, &is_array);
  assert(status == napi_ok);

  assert(is_array);
  if (is_array) {
    uint32_t length;
    status = napi_get_array_length(env, array, &length);
    assert(status == napi_ok);

    uint32_t i;
    for (i = 0; i < length; ++i) {
      napi_value v;
      status = napi_get_element(env, array, i, &v);
      assert(status == napi_ok);
    }
  }

  return NULL;
}

static napi_value CallWithNumber(napi_env env, napi_callback_info info) {
  napi_status status;

  size_t argc = 1;
  napi_value args[1];
  status = napi_get_cb_info(env, info, &argc, args, NULL, NULL);
  assert(status == napi_ok);

  napi_valuetype types[1];
  status = napi_typeof(env, args[0], types);
  assert(status == napi_ok);

  assert(types[0] == napi_number);
  if (types[0] == napi_number) {
    double value = 0.0;
    status = napi_get_value_double(env, args[0], &value);
    assert(status == napi_ok);
  }

  return NULL;
}

static napi_value CallWithObject(napi_env env, napi_callback_info info) {
  napi_status status;

  size_t argc = 1;
  napi_value args[1];
  status = napi_get_cb_info(env, info, &argc, args, NULL, NULL);
  assert(status == napi_ok);

  napi_valuetype types[1];
  status = napi_typeof(env, args[0], types);
  assert(status == napi_ok);

  assert(argc == 1 && types[0] == napi_object);
  if (argc == 1 && types[0] == napi_object) {
    napi_value value;

    status = napi_get_named_property(env, args[0], "map", &value);
    assert(status == napi_ok);

    status = napi_get_named_property(env, args[0], "operand", &value);
    assert(status == napi_ok);

    status = napi_get_named_property(env, args[0], "data", &value);
    assert(status == napi_ok);

    status = napi_get_named_property(env, args[0], "reduce", &value);
    assert(status == napi_ok);
  }

  return NULL;
}

static napi_value CallWithTypedarray(napi_env env, napi_callback_info info) {
  napi_status status;

  size_t argc = 1;
  napi_value args[1];
  status = napi_get_cb_info(env, info, &argc, args, NULL, NULL);
  assert(status == napi_ok);

  bool is_typedarray = false;
  status = napi_is_typedarray(env, args[0], &is_typedarray);
  assert(status == napi_ok);

  assert(is_typedarray);
  if (is_typedarray) {
    napi_typedarray_type type;
    napi_value input_buffer;
    size_t byte_offset = 0;
    size_t length = 0;
    status = napi_get_typedarray_info(env, args[0], &type, &length,
        NULL, &input_buffer, &byte_offset);
    assert(status == napi_ok);
    assert(length > 0);

    void* data = NULL;
    size_t byte_length = 0;
    status = napi_get_arraybuffer_info(env,
        input_buffer, &data, &byte_length);
    assert(status == napi_ok);

    uint32_t* input_integers = (uint32_t*)((uint8_t*)(data) + byte_offset);
    assert(input_integers);
  }

  return NULL;
}

static napi_value CallWithArguments(napi_env env, napi_callback_info info) {
  napi_status status;

  size_t argc = 1;
  napi_value args[1000];
  // Get the length
  status = napi_get_cb_info(env, info, &argc, NULL, NULL, NULL);
  assert(status == napi_ok);

  status = napi_get_cb_info(env, info, &argc, args, NULL, NULL);
  assert(status == napi_ok);
  assert(argc <= 1000);

  napi_valuetype types[1];
  status = napi_typeof(env, args[0], types);
  assert(status == napi_ok);

  assert(argc > 1 && types[0] == napi_number);
  if (argc > 1 && types[0] == napi_number) {
    uint32_t loop = 0;
    status = napi_get_value_uint32(env, args[0], &loop);
    assert(status == napi_ok);

    uint32_t i;
    for (i = 1; i < loop; ++i) {
      assert(i < argc);
      status = napi_typeof(env, args[i], types);
      assert(status == napi_ok);
      assert(types[0] == napi_number);

      uint32_t value = 0;
      status = napi_get_value_uint32(env, args[i], &value);
      assert(status == napi_ok);
    }
  }

  return NULL;
}


#define EXPORT_FUNC(env, exports, name, func)       \
  do {                                              \
    napi_status status;                             \
    napi_value js_func;                             \
    status = napi_create_function((env),            \
                                  (name),           \
                                  NAPI_AUTO_LENGTH, \
                                  (func),           \
                                  NULL,             \
                                  &js_func);        \
    assert(status == napi_ok);                      \
    status = napi_set_named_property((env),         \
                                     (exports),     \
                                     (name),        \
                                     js_func);      \
    assert(status == napi_ok);                      \
  } while (0);


NAPI_MODULE_INIT() {
  EXPORT_FUNC(env, exports, "callWithString", CallWithString);
  EXPORT_FUNC(env, exports, "callWithLongString", CallWithString);

  EXPORT_FUNC(env, exports, "callWithArray", CallWithArray);
  EXPORT_FUNC(env, exports, "callWithLargeArray", CallWithArray);
  EXPORT_FUNC(env, exports, "callWithHugeArray", CallWithArray);

  EXPORT_FUNC(env, exports, "callWithNumber", CallWithNumber);

  EXPORT_FUNC(env, exports, "callWithObject", CallWithObject);
  EXPORT_FUNC(env, exports, "callWithTypedarray", CallWithTypedarray);

  EXPORT_FUNC(env, exports, "callWith10Numbers", CallWithArguments);
  EXPORT_FUNC(env, exports, "callWith100Numbers", CallWithArguments);
  EXPORT_FUNC(env, exports, "callWith1000Numbers", CallWithArguments);

  return exports;
}
                                         node-23.7.0/benchmark/napi/function_call/                                                           0000775 0000000 0000000 00000000000 14746647661 0020256 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/napi/function_call/.gitignore                                                 0000664 0000000 0000000 00000000007 14746647661 0022243 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        build/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/napi/function_call/binding.cc                                                 0000664 0000000 0000000 00000000556 14746647661 0022205 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <v8.h>
#include <node.h>

static int c = 0;

void Hello(const v8::FunctionCallbackInfo<v8::Value>& args) {
  args.GetReturnValue().Set(c++);
}

void Initialize(v8::Local<v8::Object> target,
                v8::Local<v8::Value> module,
                void* data) {
  NODE_SET_METHOD(target, "hello", Hello);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                  node-23.7.0/benchmark/napi/function_call/binding.gyp                                                0000664 0000000 0000000 00000000275 14746647661 0022415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'napi_binding',
      'sources': [ 'napi_binding.c' ]
    },
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ]
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                   node-23.7.0/benchmark/napi/function_call/index.js                                                   0000664 0000000 0000000 00000002321 14746647661 0021721 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Show the difference between calling a short js function
// relative to a comparable C++ function.
// Reports n of calls per second.
// Note that JS speed goes up, while cxx speed stays about the same.
'use strict';

const assert = require('assert');
const common = require('../../common.js');

// This fails when we try to open with a different version of node,
// which is quite common for benchmarks.  so in that case, just
// abort quietly.

let binding;
try {
  binding = require(`./build/${common.buildType}/binding`);
} catch {
  console.error('misc/function_call.js Binding failed to load');
  process.exit(0);
}
const cxx = binding.hello;

let napi_binding;
try {
  napi_binding = require(`./build/${common.buildType}/napi_binding`);
} catch {
  console.error('misc/function_call/index.js NAPI-Binding failed to load');
  process.exit(0);
}
const napi = napi_binding.hello;

let c = 0;
function js() {
  return c++;
}

assert(js() === cxx());

const bench = common.createBenchmark(main, {
  type: ['js', 'cxx', 'napi'],
  n: [1e6, 1e7, 5e7],
});

function main({ n, type }) {
  const fn = type === 'cxx' ? cxx : type === 'napi' ? napi : js;
  bench.start();
  for (let i = 0; i < n; i++) {
    fn();
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                               node-23.7.0/benchmark/napi/function_call/napi_binding.c                                             0000664 0000000 0000000 00000001276 14746647661 0023051 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <assert.h>
#include <node_api.h>

static int32_t increment = 0;

static napi_value Hello(napi_env env, napi_callback_info info) {
  napi_value result;
  napi_status status = napi_create_int32(env, increment++, &result);
  assert(status == napi_ok);
  return result;
}

NAPI_MODULE_INIT() {
  napi_value hello;
  napi_status status =
      napi_create_function(env,
                           "hello",
                           NAPI_AUTO_LENGTH,
                           Hello,
                           NULL,
                           &hello);
  assert(status == napi_ok);
  status = napi_set_named_property(env, exports, "hello", hello);
  assert(status == napi_ok);
  return exports;
}
                                                                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/napi/property_keys/                                                           0000775 0000000 0000000 00000000000 14746647661 0020355 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/napi/property_keys/.gitignore                                                 0000664 0000000 0000000 00000000007 14746647661 0022342 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        build/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/napi/property_keys/binding.cc                                                 0000664 0000000 0000000 00000010025 14746647661 0022274 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node_api.h>
#include <stdio.h>
#include <stdlib.h>

#define NODE_API_CALL(call)                                                    \
  do {                                                                         \
    napi_status status = call;                                                 \
    if (status != napi_ok) {                                                   \
      fprintf(stderr, #call " failed: %d\n", status);                          \
      abort();                                                                 \
    }                                                                          \
  } while (0)

#define ABORT_IF_FALSE(condition)                                              \
  if (!(condition)) {                                                          \
    fprintf(stderr, #condition " failed\n");                                   \
    abort();                                                                   \
  }

static napi_value Runner(napi_env env,
                         napi_callback_info info,
                         napi_value property_key) {
  napi_value argv[2], undefined, js_array_length, start, end;
  size_t argc = 2;
  napi_valuetype val_type = napi_undefined;
  bool is_array = false;
  uint32_t array_length = 0;
  napi_value* native_array;

  // Validate params and retrieve start and end function.
  NODE_API_CALL(napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr));
  ABORT_IF_FALSE(argc == 2);
  NODE_API_CALL(napi_typeof(env, argv[0], &val_type));
  ABORT_IF_FALSE(val_type == napi_object);
  NODE_API_CALL(napi_is_array(env, argv[1], &is_array));
  ABORT_IF_FALSE(is_array);
  NODE_API_CALL(napi_get_array_length(env, argv[1], &array_length));
  NODE_API_CALL(napi_get_named_property(env, argv[0], "start", &start));
  NODE_API_CALL(napi_typeof(env, start, &val_type));
  ABORT_IF_FALSE(val_type == napi_function);
  NODE_API_CALL(napi_get_named_property(env, argv[0], "end", &end));
  NODE_API_CALL(napi_typeof(env, end, &val_type));
  ABORT_IF_FALSE(val_type == napi_function);

  NODE_API_CALL(napi_get_undefined(env, &undefined));
  NODE_API_CALL(napi_create_uint32(env, array_length, &js_array_length));

  // Copy objects into a native array.
  native_array =
      static_cast<napi_value*>(malloc(array_length * sizeof(napi_value)));
  for (uint32_t idx = 0; idx < array_length; idx++) {
    NODE_API_CALL(napi_get_element(env, argv[1], idx, &native_array[idx]));
  }

  // Start the benchmark.
  napi_call_function(env, argv[0], start, 0, nullptr, nullptr);

  for (uint32_t idx = 0; idx < array_length; idx++) {
    NODE_API_CALL(
        napi_set_property(env, native_array[idx], property_key, undefined));
  }

  // Conclude the benchmark.
  NODE_API_CALL(
      napi_call_function(env, argv[0], end, 1, &js_array_length, nullptr));

  free(native_array);

  return undefined;
}

static napi_value RunPropertyKey(napi_env env, napi_callback_info info) {
  napi_value property_key;
  NODE_API_CALL(node_api_create_property_key_utf16(
      env, u"prop", NAPI_AUTO_LENGTH, &property_key));
  return Runner(env, info, property_key);
}

static napi_value RunNormalString(napi_env env, napi_callback_info info) {
  napi_value property_key;
  NODE_API_CALL(
      napi_create_string_utf16(env, u"prop", NAPI_AUTO_LENGTH, &property_key));
  return Runner(env, info, property_key);
}

NAPI_MODULE_INIT() {
  napi_property_descriptor props[] = {
      {"RunPropertyKey",
       nullptr,
       RunPropertyKey,
       nullptr,
       nullptr,
       nullptr,
       static_cast<napi_property_attributes>(napi_writable | napi_configurable |
                                             napi_enumerable),
       nullptr},
      {"RunNormalString",
       nullptr,
       RunNormalString,
       nullptr,
       nullptr,
       nullptr,
       static_cast<napi_property_attributes>(napi_writable | napi_configurable |
                                             napi_enumerable),
       nullptr},
  };

  NODE_API_CALL(napi_define_properties(
      env, exports, sizeof(props) / sizeof(*props), props));
  return exports;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/benchmark/napi/property_keys/binding.gyp                                                0000664 0000000 0000000 00000000220 14746647661 0022502 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'defines': [ 'NAPI_EXPERIMENTAL' ],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/benchmark/napi/property_keys/index.js                                                   0000664 0000000 0000000 00000000554 14746647661 0022026 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common.js');

const binding = require(`./build/${common.buildType}/binding`);

const bench = common.createBenchmark(main, {
  n: [5e6],
  implem: ['RunPropertyKey', 'RunNormalString'],
});

function main({ n, implem }) {
  const objs = Array(n).fill(null).map((item) => new Object());
  binding[implem](bench, objs);
}
                                                                                                                                                    node-23.7.0/benchmark/napi/ref/                                                                     0000775 0000000 0000000 00000000000 14746647661 0016212 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/napi/ref/.gitignore                                                           0000664 0000000 0000000 00000000007 14746647661 0020177 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        build/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/napi/ref/addon.c                                                              0000664 0000000 0000000 00000004434 14746647661 0017450 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node_api.h>
#include <stdlib.h>

#define NAPI_CALL(env, call)                          \
  do {                                                \
    napi_status status = (call);                      \
    if (status != napi_ok) {                          \
      napi_throw_error((env), NULL, #call " failed"); \
      return NULL;                                    \
    }                                                 \
  } while (0)

static napi_value
GetCount(napi_env env, napi_callback_info info) {
  napi_value result;
  size_t* count;

  NAPI_CALL(env, napi_get_instance_data(env, (void**)&count));
  NAPI_CALL(env, napi_create_uint32(env, *count, &result));

  return result;
}

static napi_value
SetCount(napi_env env, napi_callback_info info) {
  size_t* count;

  NAPI_CALL(env, napi_get_instance_data(env, (void**)&count));

  // Set the count to zero irrespective of what is passed into the setter.
  *count = 0;

  return NULL;
}

static void IncrementCounter(node_api_basic_env env, void* data, void* hint) {
  size_t* count = data;
  (*count) = (*count) + 1;
}

static napi_value
NewWeak(napi_env env, napi_callback_info info) {
  napi_value result;
  void* instance_data;

  NAPI_CALL(env, napi_create_object(env, &result));
  NAPI_CALL(env, napi_get_instance_data(env, &instance_data));
  NAPI_CALL(env, napi_add_finalizer(env,
                                    result,
                                    instance_data,
                                    IncrementCounter,
                                    NULL,
                                    NULL));

  return result;
}

static void
FreeCount(napi_env env, void* data, void* hint) {
  free(data);
}

/* napi_value */
NAPI_MODULE_INIT(/* napi_env env, napi_value exports */) {
  napi_property_descriptor props[] = {
    { "count", NULL, NULL, GetCount, SetCount, NULL, napi_enumerable, NULL },
    { "newWeak", NULL, NewWeak, NULL, NULL, NULL, napi_enumerable, NULL }
  };

  size_t* count = malloc(sizeof(*count));
  *count = 0;

  NAPI_CALL(env, napi_define_properties(env,
                                        exports,
                                        sizeof(props) / sizeof(*props),
                                        props));
  NAPI_CALL(env, napi_set_instance_data(env, count, FreeCount, NULL));

  return exports;
}
                                                                                                                                                                                                                                    node-23.7.0/benchmark/napi/ref/binding.gyp                                                          0000664 0000000 0000000 00000000156 14746647661 0020347 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'addon',
      'sources': [
        'addon.c'
      ]
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/napi/ref/index.js                                                             0000664 0000000 0000000 00000000737 14746647661 0017666 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const addon = require(`./build/${common.buildType}/addon`);
const bench = common.createBenchmark(main, { n: [1e7] });

function callNewWeak() {
  addon.newWeak();
}

function main({ n }) {
  addon.count = 0;
  bench.start();
  new Promise((resolve) => {
    (function oneIteration() {
      callNewWeak();
      setImmediate(() => ((addon.count < n) ? oneIteration() : resolve()));
    })();
  }).then(() => bench.end(n));
}
                                 node-23.7.0/benchmark/napi/string/                                                                  0000775 0000000 0000000 00000000000 14746647661 0016744 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/napi/string/.gitignore                                                        0000664 0000000 0000000 00000000007 14746647661 0020731 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        build/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/napi/string/binding.c                                                         0000664 0000000 0000000 00000006270 14746647661 0020527 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <assert.h>
#define NAPI_EXPERIMENTAL
#include <node_api.h>

#define NAPI_CALL(call)                                                        \
  do {                                                                         \
    napi_status status = call;                                                 \
    assert(status == napi_ok && #call " failed");                              \
  } while (0);

#define EXPORT_FUNC(env, exports, name, func)                                  \
  do {                                                                         \
    napi_value js_func;                                                        \
    NAPI_CALL(napi_create_function(                                            \
        (env), (name), NAPI_AUTO_LENGTH, (func), NULL, &js_func));             \
    NAPI_CALL(napi_set_named_property((env), (exports), (name), js_func));     \
  } while (0);

const char* one_byte_string = "The Quick Brown Fox Jumped Over The Lazy Dog.";
const char16_t* two_byte_string =
    u"The Quick Brown Fox Jumped Over The Lazy Dog.";

#define DECLARE_BINDING(CapName, lowercase_name, var_name)                     \
  static napi_value CreateString##CapName(napi_env env,                        \
                                          napi_callback_info info) {           \
    size_t argc = 4;                                                           \
    napi_value argv[4];                                                        \
    uint32_t n;                                                                \
    uint32_t index;                                                            \
    napi_handle_scope scope;                                                   \
    napi_value js_string;                                                      \
                                                                               \
    NAPI_CALL(napi_get_cb_info(env, info, &argc, argv, NULL, NULL));           \
    NAPI_CALL(napi_get_value_uint32(env, argv[0], &n));                        \
    NAPI_CALL(napi_open_handle_scope(env, &scope));                            \
    NAPI_CALL(napi_call_function(env, argv[1], argv[2], 0, NULL, NULL));       \
    for (index = 0; index < n; index++) {                                      \
      NAPI_CALL(napi_create_string_##lowercase_name(                           \
          env, (var_name), NAPI_AUTO_LENGTH, &js_string));                     \
    }                                                                          \
    NAPI_CALL(napi_call_function(env, argv[1], argv[3], 1, &argv[0], NULL));   \
    NAPI_CALL(napi_close_handle_scope(env, scope));                            \
                                                                               \
    return NULL;                                                               \
  }

DECLARE_BINDING(Latin1, latin1, one_byte_string)
DECLARE_BINDING(Utf8, utf8, one_byte_string)
DECLARE_BINDING(Utf16, utf16, two_byte_string)

NAPI_MODULE_INIT() {
  EXPORT_FUNC(env, exports, "createStringLatin1", CreateStringLatin1);
  EXPORT_FUNC(env, exports, "createStringUtf8", CreateStringUtf8);
  EXPORT_FUNC(env, exports, "createStringUtf16", CreateStringUtf16);
  return exports;
}
                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/napi/string/binding.gyp                                                       0000664 0000000 0000000 00000000144 14746647661 0021076 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.c' ]
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/benchmark/napi/string/index.js                                                          0000664 0000000 0000000 00000000705 14746647661 0020413 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common.js');

let binding;
try {
  binding = require(`./build/${common.buildType}/binding`);
} catch {
  console.error(`${__filename}: Binding failed to load`);
  process.exit(0);
}

const bench = common.createBenchmark(main, {
  n: [1e5, 1e6, 1e7],
  stringType: ['Latin1', 'Utf8', 'Utf16'],
});

function main({ n, stringType }) {
  binding[`createString${stringType}`](n, bench, bench.start, bench.end);
}
                                                           node-23.7.0/benchmark/napi/type-tag-check/                                                          0000775 0000000 0000000 00000000000 14746647661 0020243 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/napi/type-tag-check/.gitignore                                                0000664 0000000 0000000 00000000007 14746647661 0022230 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        build/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/napi/type-tag-check/binding.gyp                                               0000664 0000000 0000000 00000000160 14746647661 0022373 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ '../type-tag/binding.c' ]
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/benchmark/napi/type-tag-check/index.js                                                  0000664 0000000 0000000 00000000600 14746647661 0021704 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common.js');

let binding;
try {
  binding = require(`./build/${common.buildType}/binding`);
} catch {
  console.error(`${__filename}: Binding failed to load`);
  process.exit(0);
}

const bench = common.createBenchmark(main, {
  n: [1e5, 1e6, 1e7],
});

function main({ n }) {
  binding.checkObjectTag(n, bench, bench.start, bench.end);
}
                                                                                                                                node-23.7.0/benchmark/napi/type-tag/                                                                0000775 0000000 0000000 00000000000 14746647661 0017170 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/napi/type-tag/.gitignore                                                      0000664 0000000 0000000 00000000007 14746647661 0021155 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        build/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/napi/type-tag/binding.c                                                       0000664 0000000 0000000 00000005440 14746647661 0020751 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <assert.h>
#define NAPI_EXPERIMENTAL
#include <node_api.h>

#define NAPI_CALL(call)                           \
  do {                                            \
    napi_status status = call;                    \
    assert(status == napi_ok && #call " failed"); \
  } while (0);

#define EXPORT_FUNC(env, exports, name, func)       \
  do {                                              \
    napi_value js_func;                             \
    NAPI_CALL(napi_create_function((env),           \
                                  (name),           \
                                  NAPI_AUTO_LENGTH, \
                                  (func),           \
                                  NULL,             \
                                  &js_func));       \
    NAPI_CALL(napi_set_named_property((env),        \
                                     (exports),     \
                                     (name),        \
                                     js_func));     \
  } while (0);

static const napi_type_tag tag = {
  0xe7ecbcd5954842f6, 0x9e75161c9bf27282
};

static napi_value TagObject(napi_env env, napi_callback_info info) {
  size_t argc = 4;
  napi_value argv[4];
  uint32_t n;
  uint32_t index;
  napi_handle_scope scope;

  NAPI_CALL(napi_get_cb_info(env, info, &argc, argv, NULL, NULL));
  NAPI_CALL(napi_get_value_uint32(env, argv[0], &n));
  NAPI_CALL(napi_open_handle_scope(env, &scope));
  napi_value objects[n];
  for (index = 0; index < n; index++) {
    NAPI_CALL(napi_create_object(env, &objects[index]));
  }

  // Time the object tag creation.
  NAPI_CALL(napi_call_function(env, argv[1], argv[2], 0, NULL, NULL));
  for (index = 0; index < n; index++) {
    NAPI_CALL(napi_type_tag_object(env, objects[index], &tag));
  }
  NAPI_CALL(napi_call_function(env, argv[1], argv[3], 1, &argv[0], NULL));

  NAPI_CALL(napi_close_handle_scope(env, scope));
  return NULL;
}

static napi_value CheckObjectTag(napi_env env, napi_callback_info info) {
  size_t argc = 4;
  napi_value argv[4];
  uint32_t n;
  uint32_t index;
  bool is_of_type;

  NAPI_CALL(napi_get_cb_info(env, info, &argc, argv, NULL, NULL));
  NAPI_CALL(napi_get_value_uint32(env, argv[0], &n));
  napi_value object;
  NAPI_CALL(napi_create_object(env, &object));
  NAPI_CALL(napi_type_tag_object(env, object, &tag));

  // Time the object tag checking.
  NAPI_CALL(napi_call_function(env, argv[1], argv[2], 0, NULL, NULL));
  for (index = 0; index < n; index++) {
    NAPI_CALL(napi_check_object_type_tag(env, object, &tag, &is_of_type));
    assert(is_of_type && " type mismatch");
  }
  NAPI_CALL(napi_call_function(env, argv[1], argv[3], 1, &argv[0], NULL));

  return NULL;
}

NAPI_MODULE_INIT() {
  EXPORT_FUNC(env, exports, "tagObject", TagObject);
  EXPORT_FUNC(env, exports, "checkObjectTag", CheckObjectTag);
  return exports;
}
                                                                                                                                                                                                                                node-23.7.0/benchmark/napi/type-tag/binding.gyp                                                     0000664 0000000 0000000 00000000144 14746647661 0021322 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.c' ]
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/benchmark/napi/type-tag/check-object-tag.js                                             0000664 0000000 0000000 00000000600 14746647661 0022614 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common.js');

let binding;
try {
  binding = require(`./build/${common.buildType}/binding`);
} catch {
  console.error(`${__filename}: Binding failed to load`);
  process.exit(0);
}

const bench = common.createBenchmark(main, {
  n: [1e5, 1e6, 1e7],
});

function main({ n }) {
  binding.checkObjectTag(n, bench, bench.start, bench.end);
}
                                                                                                                                node-23.7.0/benchmark/napi/type-tag/index.js                                                        0000664 0000000 0000000 00000000573 14746647661 0020642 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common.js');

let binding;
try {
  binding = require(`./build/${common.buildType}/binding`);
} catch {
  console.error(`${__filename}: Binding failed to load`);
  process.exit(0);
}

const bench = common.createBenchmark(main, {
  n: [1e3, 1e4, 1e5],
});

function main({ n }) {
  binding.tagObject(n, bench, bench.start, bench.end);
}
                                                                                                                                     node-23.7.0/benchmark/net/                                                                          0000775 0000000 0000000 00000000000 14746647661 0015275 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/net/net-c2s-cork.js                                                           0000664 0000000 0000000 00000003406 14746647661 0020045 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Test the speed of .pipe() with sockets
'use strict';

const common = require('../common.js');
const net = require('net');
const PORT = common.PORT;

const bench = common.createBenchmark(main, {
  len: [4, 8, 16, 32, 64, 128, 512, 1024],
  type: ['buf'],
  dur: [5],
});

let chunk;
let encoding;

function main({ dur, len, type }) {
  switch (type) {
    case 'buf':
      chunk = Buffer.alloc(len, 'x');
      break;
    case 'utf':
      encoding = 'utf8';
      chunk = 'ü'.repeat(len / 2);
      break;
    case 'asc':
      encoding = 'ascii';
      chunk = 'x'.repeat(len);
      break;
    default:
      throw new Error(`invalid type: ${type}`);
  }

  const writer = new Writer();

  // The actual benchmark.
  const server = net.createServer((socket) => {
    socket.pipe(writer);
  });

  server.listen(PORT, () => {
    const socket = net.connect(PORT);
    socket.on('connect', () => {
      bench.start();

      socket.on('drain', send);
      send();

      setTimeout(() => {
        const bytes = writer.received;
        const gbits = (bytes * 8) / (1024 * 1024 * 1024);
        bench.end(gbits);
        process.exit(0);
      }, dur * 1000);

      function send() {
        socket.cork();
        while (socket.write(chunk, encoding));
        socket.uncork();
      }
    });
  });
}

function Writer() {
  this.received = 0;
  this.writable = true;
}

Writer.prototype.write = function(chunk, encoding, cb) {
  this.received += chunk.length;

  if (typeof encoding === 'function')
    encoding();
  else if (typeof cb === 'function')
    cb();

  return true;
};

// Doesn't matter, never emits anything.
Writer.prototype.on = function() {};
Writer.prototype.once = function() {};
Writer.prototype.emit = function() {};
Writer.prototype.prependListener = function() {};
                                                                                                                                                                                                                                                          node-23.7.0/benchmark/net/net-c2s.js                                                                0000664 0000000 0000000 00000004025 14746647661 0017107 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Test the speed of .pipe() with sockets
'use strict';

const common = require('../common.js');
const net = require('net');
const PORT = common.PORT;

const bench = common.createBenchmark(main, {
  len: [64, 102400, 1024 * 64 * 16],
  type: ['utf', 'asc', 'buf'],
  dur: [5],
}, {
  test: { len: 1024 },
});

let chunk;
let encoding;

function main({ dur, len, type }) {
  switch (type) {
    case 'buf':
      chunk = Buffer.alloc(len, 'x');
      break;
    case 'utf':
      encoding = 'utf8';
      chunk = 'ü'.repeat(len / 2);
      break;
    case 'asc':
      encoding = 'ascii';
      chunk = 'x'.repeat(len);
      break;
    default:
      throw new Error(`invalid type: ${type}`);
  }

  const reader = new Reader();
  const writer = new Writer();

  // The actual benchmark.
  const server = net.createServer((socket) => {
    socket.pipe(writer);
  });

  server.listen(PORT, () => {
    const socket = net.connect(PORT);
    socket.on('connect', () => {
      bench.start();

      reader.pipe(socket);

      setTimeout(() => {
        const bytes = writer.received;
        const gbits = (bytes * 8) / (1024 * 1024 * 1024);
        bench.end(gbits);
        process.exit(0);
      }, dur * 1000);
    });
  });
}

function Writer() {
  this.received = 0;
  this.writable = true;
}

Writer.prototype.write = function(chunk, encoding, cb) {
  this.received += chunk.length;

  if (typeof encoding === 'function')
    encoding();
  else if (typeof cb === 'function')
    cb();

  return true;
};

// Doesn't matter, never emits anything.
Writer.prototype.on = function() {};
Writer.prototype.once = function() {};
Writer.prototype.emit = function() {};
Writer.prototype.prependListener = function() {};


function flow() {
  const dest = this.dest;
  const res = dest.write(chunk, encoding);
  if (!res)
    dest.once('drain', this.flow);
  else
    process.nextTick(this.flow);
}

function Reader() {
  this.flow = flow.bind(this);
  this.readable = true;
}

Reader.prototype.pipe = function(dest) {
  this.dest = dest;
  this.flow();
  return dest;
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/benchmark/net/net-is-ip-v4.js                                                           0000664 0000000 0000000 00000000636 14746647661 0017774 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const { isIPv4 } = require('net');

const ips = [
  '0.0.0.0',
  '255.255.255.255',
  '0.0.0.0.0',
  '192.168.0.1',
  '10.168.209.250',
];

const bench = common.createBenchmark(main, {
  n: [1e7],
});

function main({ n }) {
  bench.start();
  for (let i = 0; i < n; ++i) {
    for (let j = 0; j < ips.length; ++j)
      isIPv4(ips[j]);
  }
  bench.end(n);
}
                                                                                                  node-23.7.0/benchmark/net/net-is-ip-v6.js                                                           0000664 0000000 0000000 00000000613 14746647661 0017771 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const { isIPv6 } = require('net');

const ips = [
  '::1',
  'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff',
  '0.0.0.0',
];

const bench = common.createBenchmark(main, {
  n: [1e7],
});

function main({ n }) {
  bench.start();
  for (let i = 0; i < n; ++i) {
    for (let j = 0; j < ips.length; ++j)
      isIPv6(ips[j]);
  }
  bench.end(n);
}
                                                                                                                     node-23.7.0/benchmark/net/net-pipe.js                                                               0000664 0000000 0000000 00000004221 14746647661 0017353 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Test the speed of .pipe() with sockets
'use strict';

const common = require('../common.js');
const net = require('net');
const PORT = common.PORT;

const bench = common.createBenchmark(main, {
  len: [2, 64, 102400, 1024 * 64 * 16],
  type: ['utf', 'asc', 'buf'],
  dur: [5],
}, {
  test: { len: 1024 },
});

let chunk;
let encoding;

function main({ dur, len, type }) {
  switch (type) {
    case 'buf':
      chunk = Buffer.alloc(len, 'x');
      break;
    case 'utf':
      encoding = 'utf8';
      chunk = 'ü'.repeat(len / 2);
      break;
    case 'asc':
      encoding = 'ascii';
      chunk = 'x'.repeat(len);
      break;
    default:
      throw new Error(`invalid type: ${type}`);
  }

  const reader = new Reader();
  const writer = new Writer();

  // The actual benchmark.
  const server = net.createServer((socket) => {
    socket.pipe(socket);
  });

  server.listen(PORT, () => {
    const socket = net.connect(PORT);
    socket.on('connect', () => {
      bench.start();

      reader.pipe(socket);
      socket.pipe(writer);

      setTimeout(() => {
        // Multiply by 2 since we're sending it first one way
        // then back again.
        const bytes = writer.received * 2;
        const gbits = (bytes * 8) / (1024 * 1024 * 1024);
        bench.end(gbits);
        process.exit(0);
      }, dur * 1000);
    });
  });
}

function Writer() {
  this.received = 0;
  this.writable = true;
}

Writer.prototype.write = function(chunk, encoding, cb) {
  this.received += chunk.length;

  if (typeof encoding === 'function')
    encoding();
  else if (typeof cb === 'function')
    cb();

  return true;
};

// Doesn't matter, never emits anything.
Writer.prototype.on = function() {};
Writer.prototype.once = function() {};
Writer.prototype.emit = function() {};
Writer.prototype.prependListener = function() {};


function flow() {
  const dest = this.dest;
  const res = dest.write(chunk, encoding);
  if (!res)
    dest.once('drain', this.flow);
  else
    process.nextTick(this.flow);
}

function Reader() {
  this.flow = flow.bind(this);
  this.readable = true;
}

Reader.prototype.pipe = function(dest) {
  this.dest = dest;
  this.flow();
  return dest;
};
                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/benchmark/net/net-s2c.js                                                                0000664 0000000 0000000 00000005612 14746647661 0017112 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Test the speed of .pipe() with sockets
'use strict';

const common = require('../common.js');
const PORT = common.PORT;

const bench = common.createBenchmark(main, {
  sendchunklen: [256, 32 * 1024, 128 * 1024, 16 * 64 * 1024],
  type: ['utf', 'asc', 'buf'],
  recvbuflen: [0, 64 * 1024, 1024 * 1024],
  recvbufgenfn: ['true', 'false'],
  dur: [5],
}, {
  test: { sendchunklen: 256 },
});

let chunk;
let encoding;
let recvbuf;
let received = 0;

function main({ dur, sendchunklen, type, recvbuflen, recvbufgenfn }) {
  if (isFinite(recvbuflen) && recvbuflen > 0)
    recvbuf = Buffer.alloc(recvbuflen);

  switch (type) {
    case 'buf':
      chunk = Buffer.alloc(sendchunklen, 'x');
      break;
    case 'utf':
      encoding = 'utf8';
      chunk = 'ü'.repeat(sendchunklen / 2);
      break;
    case 'asc':
      encoding = 'ascii';
      chunk = 'x'.repeat(sendchunklen);
      break;
    default:
      throw new Error(`invalid type: ${type}`);
  }

  const reader = new Reader();
  let writer;
  let socketOpts;
  if (recvbuf === undefined) {
    writer = new Writer();
    socketOpts = { port: PORT };
  } else {
    let buffer = recvbuf;
    if (recvbufgenfn === 'true') {
      let bufidx = -1;
      const bufpool = [
        recvbuf,
        Buffer.from(recvbuf),
        Buffer.from(recvbuf),
      ];
      buffer = () => {
        bufidx = (bufidx + 1) % bufpool.length;
        return bufpool[bufidx];
      };
    }
    socketOpts = {
      port: PORT,
      onread: {
        buffer,
        callback: function(nread, buf) {
          received += nread;
        },
      },
    };
  }

  // The actual benchmark.
  const server = net.createServer((socket) => {
    reader.pipe(socket);
  });

  server.listen(PORT, () => {
    const socket = net.connect(socketOpts);
    socket.on('connect', () => {
      bench.start();

      if (recvbuf === undefined)
        socket.pipe(writer);

      setTimeout(() => {
        const bytes = received;
        const gbits = (bytes * 8) / (1024 * 1024 * 1024);
        bench.end(gbits);
        process.exit(0);
      }, dur * 1000);
    });
  });
}

const net = require('net');

function Writer() {
  this.writable = true;
}

Writer.prototype.write = function(chunk, encoding, cb) {
  received += chunk.length;

  if (typeof encoding === 'function')
    encoding();
  else if (typeof cb === 'function')
    cb();

  return true;
};

// Doesn't matter, never emits anything.
Writer.prototype.on = function() {};
Writer.prototype.once = function() {};
Writer.prototype.emit = function() {};
Writer.prototype.prependListener = function() {};


function flow() {
  const dest = this.dest;
  const res = dest.write(chunk, encoding);
  if (!res)
    dest.once('drain', this.flow);
  else
    process.nextTick(this.flow);
}

function Reader() {
  this.flow = flow.bind(this);
  this.readable = true;
}

Reader.prototype.pipe = function(dest) {
  this.dest = dest;
  this.flow();
  return dest;
};
                                                                                                                      node-23.7.0/benchmark/net/net-wrap-js-stream-passthrough.js                                         0000664 0000000 0000000 00000004055 14746647661 0023644 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Test the speed of .pipe() with JSStream wrapping for PassThrough streams
'use strict';

const common = require('../common.js');
const { PassThrough } = require('stream');

const bench = common.createBenchmark(main, {
  len: [64, 102400, 1024 * 64 * 16],
  type: ['utf', 'asc', 'buf'],
  dur: [5],
}, {
  test: { len: 64 },
  flags: ['--expose-internals'],
});

let chunk;
let encoding;

function main({ dur, len, type }) {
  // Can only require internals inside main().
  const JSStreamWrap = require('internal/js_stream_socket');

  switch (type) {
    case 'buf':
      chunk = Buffer.alloc(len, 'x');
      break;
    case 'utf':
      encoding = 'utf8';
      chunk = 'ü'.repeat(len / 2);
      break;
    case 'asc':
      encoding = 'ascii';
      chunk = 'x'.repeat(len);
      break;
    default:
      throw new Error(`invalid type: ${type}`);
  }

  const reader = new Reader();
  const writer = new Writer();

  // The actual benchmark.
  const fakeSocket = new JSStreamWrap(new PassThrough());
  bench.start();
  reader.pipe(fakeSocket);
  fakeSocket.pipe(writer);

  setTimeout(() => {
    const bytes = writer.received;
    const gbits = (bytes * 8) / (1024 * 1024 * 1024);
    bench.end(gbits);
    process.exit(0);
  }, dur * 1000);
}

function Writer() {
  this.received = 0;
  this.writable = true;
}

Writer.prototype.write = function(chunk, encoding, cb) {
  this.received += chunk.length;

  if (typeof encoding === 'function')
    encoding();
  else if (typeof cb === 'function')
    cb();

  return true;
};

// Doesn't matter, never emits anything.
Writer.prototype.on = function() {};
Writer.prototype.once = function() {};
Writer.prototype.emit = function() {};
Writer.prototype.prependListener = function() {};


function flow() {
  const dest = this.dest;
  const res = dest.write(chunk, encoding);
  if (!res)
    dest.once('drain', this.flow);
  else
    process.nextTick(this.flow);
}

function Reader() {
  this.flow = flow.bind(this);
  this.readable = true;
}

Reader.prototype.pipe = function(dest) {
  this.dest = dest;
  this.flow();
  return dest;
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/benchmark/net/tcp-raw-c2s.js                                                            0000664 0000000 0000000 00000006216 14746647661 0017702 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // In this benchmark, we connect a client to the server, and write
// as many bytes as we can in the specified time (default = 10s)
'use strict';

const common = require('../common.js');
const util = require('util');

// If there are --dur=N and --len=N args, then
// run the function with those settings.
// if not, then queue up a bunch of child processes.
const bench = common.createBenchmark(main, {
  len: [102400, 1024 * 64 * 16],
  type: ['utf', 'asc', 'buf'],
  dur: [5],
}, {
  test: { len: 1024 },
  flags: [ '--expose-internals', '--no-warnings' ],
});

function main({ dur, len, type }) {
  const {
    TCP,
    TCPConnectWrap,
    constants: TCPConstants,
  } = common.binding('tcp_wrap');
  const { WriteWrap } = common.binding('stream_wrap');
  const PORT = common.PORT;

  const serverHandle = new TCP(TCPConstants.SERVER);
  let err = serverHandle.bind('127.0.0.1', PORT);
  if (err)
    fail(err, 'bind');

  err = serverHandle.listen(511);
  if (err)
    fail(err, 'listen');

  serverHandle.onconnection = function(err, clientHandle) {
    if (err)
      fail(err, 'connect');

    // The meat of the benchmark is right here:
    bench.start();
    let bytes = 0;

    setTimeout(() => {
      // report in Gb/sec
      bench.end((bytes * 8) / (1024 * 1024 * 1024));
      process.exit(0);
    }, dur * 1000);

    clientHandle.onread = function(buffer) {
      // We're not expecting to ever get an EOF from the client.
      // Just lots of data forever.
      if (!buffer)
        fail('read');

      // Don't slice the buffer. The point of this is to isolate, not
      // simulate real traffic.
      bytes += buffer.byteLength;
    };

    clientHandle.readStart();
  };

  client(type, len);

  function fail(err, syscall) {
    throw util._errnoException(err, syscall);
  }

  function client(type, len) {
    let chunk;
    switch (type) {
      case 'buf':
        chunk = Buffer.alloc(len, 'x');
        break;
      case 'utf':
        chunk = 'ü'.repeat(len / 2);
        break;
      case 'asc':
        chunk = 'x'.repeat(len);
        break;
      default:
        throw new Error(`invalid type: ${type}`);
    }

    const clientHandle = new TCP(TCPConstants.SOCKET);
    const connectReq = new TCPConnectWrap();
    const err = clientHandle.connect(connectReq, '127.0.0.1', PORT);

    if (err)
      fail(err, 'connect');

    clientHandle.readStart();

    connectReq.oncomplete = function(err) {
      if (err)
        fail(err, 'connect');

      while (clientHandle.writeQueueSize === 0)
        write();
    };

    function write() {
      const writeReq = new WriteWrap();
      writeReq.oncomplete = afterWrite;
      let err;
      switch (type) {
        case 'buf':
          err = clientHandle.writeBuffer(writeReq, chunk);
          break;
        case 'utf':
          err = clientHandle.writeUtf8String(writeReq, chunk);
          break;
        case 'asc':
          err = clientHandle.writeAsciiString(writeReq, chunk);
          break;
      }

      if (err)
        fail(err, 'write');
    }

    function afterWrite(err, handle) {
      if (err)
        fail(err, 'write');

      while (clientHandle.writeQueueSize === 0)
        write();
    }
  }
}
                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/net/tcp-raw-pipe.js                                                           0000664 0000000 0000000 00000006456 14746647661 0020156 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // In this benchmark, we connect a client to the server, and write
// as many bytes as we can in the specified time (default = 10s)
'use strict';

const common = require('../common.js');
const util = require('util');

// If there are --dur=N and --len=N args, then
// run the function with those settings.
// if not, then queue up a bunch of child processes.
const bench = common.createBenchmark(main, {
  len: [102400, 1024 * 64 * 16],
  type: ['utf', 'asc', 'buf'],
  dur: [5],
}, {
  test: { len: 1024 },
  flags: [ '--expose-internals', '--no-warnings' ],
});

function main({ dur, len, type }) {
  const {
    TCP,
    TCPConnectWrap,
    constants: TCPConstants,
  } = common.binding('tcp_wrap');
  const { WriteWrap } = common.binding('stream_wrap');
  const PORT = common.PORT;

  function fail(err, syscall) {
    throw util._errnoException(err, syscall);
  }

  // Server
  const serverHandle = new TCP(TCPConstants.SERVER);
  let err = serverHandle.bind('127.0.0.1', PORT);
  if (err)
    fail(err, 'bind');

  err = serverHandle.listen(511);
  if (err)
    fail(err, 'listen');

  serverHandle.onconnection = function(err, clientHandle) {
    if (err)
      fail(err, 'connect');

    clientHandle.onread = function(buffer) {
      // We're not expecting to ever get an EOF from the client.
      // Just lots of data forever.
      if (!buffer)
        fail('read');

      const writeReq = new WriteWrap();
      writeReq.async = false;
      err = clientHandle.writeBuffer(writeReq, Buffer.from(buffer));

      if (err)
        fail(err, 'write');

      writeReq.oncomplete = function(status, handle, err) {
        if (err)
          fail(err, 'write');
      };
    };

    clientHandle.readStart();
  };

  // Client
  let chunk;
  switch (type) {
    case 'buf':
      chunk = Buffer.alloc(len, 'x');
      break;
    case 'utf':
      chunk = 'ü'.repeat(len / 2);
      break;
    case 'asc':
      chunk = 'x'.repeat(len);
      break;
    default:
      throw new Error(`invalid type: ${type}`);
  }

  const clientHandle = new TCP(TCPConstants.SOCKET);
  const connectReq = new TCPConnectWrap();
  let bytes = 0;

  err = clientHandle.connect(connectReq, '127.0.0.1', PORT);
  if (err)
    fail(err, 'connect');

  clientHandle.onread = function(buffer) {
    if (!buffer)
      fail('read');

    bytes += buffer.byteLength;
  };

  connectReq.oncomplete = function(err) {
    if (err)
      fail(err, 'connect');

    bench.start();

    clientHandle.readStart();

    setTimeout(() => {
      // Multiply by 2 since we're sending it first one way
      // then back again.
      bench.end(2 * (bytes * 8) / (1024 * 1024 * 1024));
      process.exit(0);
    }, dur * 1000);

    while (clientHandle.writeQueueSize === 0)
      write();
  };

  function write() {
    const writeReq = new WriteWrap();
    writeReq.oncomplete = afterWrite;
    let err;
    switch (type) {
      case 'buf':
        err = clientHandle.writeBuffer(writeReq, chunk);
        break;
      case 'utf':
        err = clientHandle.writeUtf8String(writeReq, chunk);
        break;
      case 'asc':
        err = clientHandle.writeAsciiString(writeReq, chunk);
        break;
    }

    if (err)
      fail(err, 'write');
  }

  function afterWrite(err, handle) {
    if (err)
      fail(err, 'write');

    while (clientHandle.writeQueueSize === 0)
      write();
  }
}
                                                                                                                                                                                                                  node-23.7.0/benchmark/net/tcp-raw-s2c.js                                                            0000664 0000000 0000000 00000006426 14746647661 0017705 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // In this benchmark, we connect a client to the server, and write
// as many bytes as we can in the specified time (default = 10s)
'use strict';

const common = require('../common.js');
const util = require('util');

// If there are dur=N and len=N args, then
// run the function with those settings.
// If not, then queue up a bunch of child processes.
const bench = common.createBenchmark(main, {
  len: [102400, 1024 * 64 * 16],
  type: ['utf', 'asc', 'buf'],
  dur: [5],
}, {
  test: { len: 1024 },
  flags: [ '--expose-internals', '--no-warnings' ],
});

function main({ dur, len, type }) {
  const {
    TCP,
    TCPConnectWrap,
    constants: TCPConstants,
  } = common.binding('tcp_wrap');
  const { WriteWrap } = common.binding('stream_wrap');
  const PORT = common.PORT;

  const serverHandle = new TCP(TCPConstants.SERVER);
  let err = serverHandle.bind('127.0.0.1', PORT);
  if (err)
    fail(err, 'bind');

  err = serverHandle.listen(511);
  if (err)
    fail(err, 'listen');

  serverHandle.onconnection = function(err, clientHandle) {
    if (err)
      fail(err, 'connect');

    let chunk;
    switch (type) {
      case 'buf':
        chunk = Buffer.alloc(len, 'x');
        break;
      case 'utf':
        chunk = 'ü'.repeat(len / 2);
        break;
      case 'asc':
        chunk = 'x'.repeat(len);
        break;
      default:
        throw new Error(`invalid type: ${type}`);
    }

    clientHandle.readStart();

    while (clientHandle.writeQueueSize === 0)
      write();

    function write() {
      const writeReq = new WriteWrap();
      writeReq.async = false;
      writeReq.oncomplete = afterWrite;
      let err;
      switch (type) {
        case 'buf':
          err = clientHandle.writeBuffer(writeReq, chunk);
          break;
        case 'utf':
          err = clientHandle.writeUtf8String(writeReq, chunk);
          break;
        case 'asc':
          err = clientHandle.writeAsciiString(writeReq, chunk);
          break;
      }

      if (err) {
        fail(err, 'write');
      } else if (!writeReq.async) {
        process.nextTick(() => {
          afterWrite(0, clientHandle);
        });
      }
    }

    function afterWrite(status, handle) {
      if (status)
        fail(status, 'write');

      while (clientHandle.writeQueueSize === 0)
        write();
    }
  };

  client(dur);

  function fail(err, syscall) {
    throw util._errnoException(err, syscall);
  }

  function client(dur) {
    const clientHandle = new TCP(TCPConstants.SOCKET);
    const connectReq = new TCPConnectWrap();
    const err = clientHandle.connect(connectReq, '127.0.0.1', PORT);

    if (err)
      fail(err, 'connect');

    connectReq.oncomplete = function() {
      let bytes = 0;
      clientHandle.onread = function(buffer) {
        // We're not expecting to ever get an EOF from the client.
        // Just lots of data forever.
        if (!buffer)
          fail('read');

        // Don't slice the buffer. The point of this is to isolate, not
        // simulate real traffic.
        bytes += buffer.byteLength;
      };

      clientHandle.readStart();

      // The meat of the benchmark is right here:
      bench.start();

      setTimeout(() => {
        // report in Gb/sec
        bench.end((bytes * 8) / (1024 * 1024 * 1024));
        process.exit(0);
      }, dur * 1000);
    };
  }
}
                                                                                                                                                                                                                                          node-23.7.0/benchmark/os/                                                                           0000775 0000000 0000000 00000000000 14746647661 0015130 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/os/cpus.js                                                                    0000664 0000000 0000000 00000000373 14746647661 0016443 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const cpus = require('os').cpus;

const bench = common.createBenchmark(main, {
  n: [3e4],
});

function main({ n }) {
  bench.start();
  for (let i = 0; i < n; ++i)
    cpus();
  bench.end(n);
}
                                                                                                                                                                                                                                                                     node-23.7.0/benchmark/os/homedir.js                                                                 0000664 0000000 0000000 00000001225 14746647661 0017115 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const homedir = require('os').homedir;
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [1e6],
});

function main({ n }) {
  // Warm up.
  const length = 1024;
  const array = [];
  for (let i = 0; i < length; ++i) {
    array.push(homedir());
  }

  bench.start();
  for (let i = 0; i < n; ++i) {
    const index = i % length;
    array[index] = homedir();
  }
  bench.end(n);

  // Verify the entries to prevent dead code elimination from making
  // the benchmark invalid.
  for (let i = 0; i < length; ++i) {
    assert.strictEqual(typeof array[i], 'string');
  }
}
                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/benchmark/os/hostname.js                                                                0000664 0000000 0000000 00000001231 14746647661 0017301 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const hostname = require('os').hostname;
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [1e6],
});

function main({ n }) {
  // Warm up.
  const length = 1024;
  const array = [];
  for (let i = 0; i < length; ++i) {
    array.push(hostname());
  }

  bench.start();
  for (let i = 0; i < n; ++i) {
    const index = i % length;
    array[index] = hostname();
  }
  bench.end(n);

  // Verify the entries to prevent dead code elimination from making
  // the benchmark invalid.
  for (let i = 0; i < length; ++i) {
    assert.strictEqual(typeof array[i], 'string');
  }
}
                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/benchmark/os/loadavg.js                                                                 0000664 0000000 0000000 00000000404 14746647661 0017101 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const loadavg = require('os').loadavg;

const bench = common.createBenchmark(main, {
  n: [5e6],
});

function main({ n }) {
  bench.start();
  for (let i = 0; i < n; ++i)
    loadavg();
  bench.end(n);
}
                                                                                                                                                                                                                                                            node-23.7.0/benchmark/os/networkInterfaces.js                                                       0000664 0000000 0000000 00000000442 14746647661 0021163 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const networkInterfaces = require('os').networkInterfaces;

const bench = common.createBenchmark(main, {
  n: [1e4],
});

function main({ n }) {
  bench.start();
  for (let i = 0; i < n; ++i)
    networkInterfaces();
  bench.end(n);
}
                                                                                                                                                                                                                              node-23.7.0/benchmark/os/tmpdir.js                                                                  0000664 0000000 0000000 00000001216 14746647661 0016765 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const { tmpdir } = require('os');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [1e6],
});

function main({ n }) {
  // Warm up.
  const length = 1024;
  const array = [];
  for (let i = 0; i < length; ++i) {
    array.push(tmpdir());
  }

  bench.start();
  for (let i = 0; i < n; ++i) {
    const index = i % length;
    array[index] = tmpdir();
  }
  bench.end(n);

  // Verify the entries to prevent dead code elimination from making
  // the benchmark invalid.
  for (let i = 0; i < length; ++i) {
    assert.strictEqual(typeof array[i], 'string');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/os/uptime.js                                                                  0000664 0000000 0000000 00000001435 14746647661 0016774 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const os = require('os');
const common = require('../common.js');
const assert = require('assert');

const uptime = os.uptime;

const bench = common.createBenchmark(main, {
  n: [1e5],
});

function main({ n }) {
  if (os.type() === 'OS400') {
    console.log('Skipping: os.uptime is not implemented on IBMi');
    process.exit(0);
  }

  // Warm up.
  const length = 1024;
  const array = [];
  for (let i = 0; i < length; ++i) {
    array.push(uptime());
  }

  bench.start();
  for (let i = 0; i < n; ++i) {
    const index = i % length;
    array[index] = uptime();
  }
  bench.end(n);

  // Verify the entries to prevent dead code elimination from making
  // the benchmark invalid.
  for (let i = 0; i < length; ++i) {
    assert.strictEqual(typeof array[i], 'number');
  }
}
                                                                                                                                                                                                                                   node-23.7.0/benchmark/path/                                                                         0000775 0000000 0000000 00000000000 14746647661 0015443 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/path/basename-posix.js                                                        0000664 0000000 0000000 00000001341 14746647661 0020713 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { posix } = require('path');

const bench = common.createBenchmark(main, {
  pathext: [
    '',
    '/',
    '/foo',
    '/foo/.bar.baz',
    ['/foo/.bar.baz', '.baz'].join('|'),
    'foo',
    'foo/bar.',
    ['foo/bar.', '.'].join('|'),
    '/foo/bar/baz/asdf/quux.html',
    ['/foo/bar/baz/asdf/quux.html', '.html'].join('|'),
  ],
  n: [1e5],
});

function main({ n, pathext }) {
  let ext;
  const extIdx = pathext.indexOf('|');
  if (extIdx !== -1) {
    ext = pathext.slice(extIdx + 1);
    pathext = pathext.slice(0, extIdx);
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    posix.basename(i % 3 === 0 ? `${pathext}${i}` : pathext, ext);
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                               node-23.7.0/benchmark/path/basename-win32.js                                                        0000664 0000000 0000000 00000001373 14746647661 0020520 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { win32 } = require('path');

const bench = common.createBenchmark(main, {
  pathext: [
    '',
    'C:\\',
    'C:\\foo',
    'D:\\foo\\.bar.baz',
    ['E:\\foo\\.bar.baz', '.baz'].join('|'),
    'foo',
    'foo\\bar.',
    ['foo\\bar.', '.'].join('|'),
    '\\foo\\bar\\baz\\asdf\\quux.html',
    ['\\foo\\bar\\baz\\asdf\\quux.html', '.html'].join('|'),
  ],
  n: [1e5],
});

function main({ n, pathext }) {
  let ext;
  const extIdx = pathext.indexOf('|');
  if (extIdx !== -1) {
    ext = pathext.slice(extIdx + 1);
    pathext = pathext.slice(0, extIdx);
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    win32.basename(i % 3 === 0 ? `${pathext}${i}` : pathext, ext);
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                     node-23.7.0/benchmark/path/dirname-posix.js                                                         0000664 0000000 0000000 00000000647 14746647661 0020567 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { posix } = require('path');

const bench = common.createBenchmark(main, {
  path: [
    '',
    '/',
    '/foo',
    '/foo/bar',
    'foo',
    'foo/bar',
    '/foo/bar/baz/asdf/quux',
  ],
  n: [1e5],
});

function main({ n, path }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    posix.dirname(i % 3 === 0 ? `${path}${i}` : path);
  }
  bench.end(n);
}
                                                                                         node-23.7.0/benchmark/path/dirname-win32.js                                                         0000664 0000000 0000000 00000000665 14746647661 0020367 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { win32 } = require('path');

const bench = common.createBenchmark(main, {
  path: [
    '',
    '\\',
    '\\foo',
    'C:\\foo\\bar',
    'foo',
    'foo\\bar',
    'D:\\foo\\bar\\baz\\asdf\\quux',
  ],
  n: [1e5],
});

function main({ n, path }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    win32.dirname(i % 3 === 0 ? `${path}${i}` : path);
  }
  bench.end(n);
}
                                                                           node-23.7.0/benchmark/path/extname-posix.js                                                         0000664 0000000 0000000 00000001025 14746647661 0020600 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { posix } = require('path');

const bench = common.createBenchmark(main, {
  path: [
    '',
    '/',
    '/foo',
    'foo/.bar.baz',
    'index.html',
    'index',
    'foo/bar/..baz.quux',
    'foo/bar/...baz.quux',
    '/foo/bar/baz/asdf/quux',
    '/foo/bar/baz/asdf/quux.foobarbazasdfquux',
  ],
  n: [1e5],
});

function main({ n, path }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    posix.extname(i % 3 === 0 ? `${path}${i}` : path);
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/benchmark/path/extname-win32.js                                                         0000664 0000000 0000000 00000001052 14746647661 0020400 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { win32 } = require('path');

const bench = common.createBenchmark(main, {
  path: [
    '',
    '\\',
    'C:\\foo',
    'foo\\.bar.baz',
    'index.html',
    'index',
    'foo\\bar\\..baz.quux',
    'foo\\bar\\...baz.quux',
    'D:\\foo\\bar\\baz\\asdf\\quux',
    '\\foo\\bar\\baz\\asdf\\quux.foobarbazasdfquux',
  ],
  n: [1e5],
});

function main({ n, path }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    win32.extname(i % 3 === 0 ? `${path}${i}` : path);
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/benchmark/path/format-posix.js                                                          0000664 0000000 0000000 00000001127 14746647661 0020432 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { posix } = require('path');

const bench = common.createBenchmark(main, {
  props: [
    ['/', '/home/user/dir', 'index.html', '.html', 'index'].join('|'),
  ],
  n: [1e6],
});

function main({ n, props }) {
  props = props.split('|');
  const obj = {
    root: props[0] || '',
    dir: props[1] || '',
    base: '',
    ext: props[3] || '',
    name: '',
  };

  bench.start();
  for (let i = 0; i < n; i++) {
    obj.base = `a${i}${props[2] || ''}`;
    obj.name = `a${i}${props[4] || ''}`;
    posix.format(obj);
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/path/format-win32.js                                                          0000664 0000000 0000000 00000001131 14746647661 0020225 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { win32 } = require('path');

const bench = common.createBenchmark(main, {
  props: [
    ['C:\\', 'C:\\path\\dir', 'index.html', '.html', 'index'].join('|'),
  ],
  n: [1e6],
});

function main({ n, props }) {
  props = props.split('|');
  const obj = {
    root: props[0] || '',
    dir: props[1] || '',
    base: '',
    ext: props[3] || '',
    name: '',
  };

  bench.start();
  for (let i = 0; i < n; i++) {
    obj.base = `a${i}${props[2] || ''}`;
    obj.name = `a${i}${props[4] || ''}`;
    win32.format(obj);
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/benchmark/path/isAbsolute-posix.js                                                      0000664 0000000 0000000 00000000604 14746647661 0021253 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { posix } = require('path');

const bench = common.createBenchmark(main, {
  path: [
    '',
    '.',
    '/foo/bar',
    '/baz/..',
    'bar/baz',
  ],
  n: [1e5],
});

function main({ n, path }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    posix.isAbsolute(i % 3 === 0 ? `${path}${i}` : path);
  }
  bench.end(n);
}
                                                                                                                            node-23.7.0/benchmark/path/isAbsolute-win32.js                                                      0000664 0000000 0000000 00000000632 14746647661 0021054 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { win32 } = require('path');

const bench = common.createBenchmark(main, {
  path: [
    '',
    '.',
    '//server',
    'C:\\baz\\..',
    'C:baz\\..',
    'bar\\baz',
  ],
  n: [1e5],
});

function main({ n, path }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    win32.isAbsolute(i % 3 === 0 ? `${path}${i}` : path);
  }
  bench.end(n);
}
                                                                                                      node-23.7.0/benchmark/path/join-posix.js                                                            0000664 0000000 0000000 00000001035 14746647661 0020077 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { posix } = require('path');

const bench = common.createBenchmark(main, {
  paths: [
    ['/foo', 'bar', '', 'baz/asdf', 'quux', '..'].join('|'),
  ],
  n: [1e5],
});

function main({ n, paths }) {
  const args = paths.split('|');
  const copy = [...args];
  const orig = copy[1];

  bench.start();
  for (let i = 0; i < n; i++) {
    if (i % 3 === 0) {
      copy[1] = `${orig}${i}`;
      posix.join(...copy);
    } else {
      posix.join(...args);
    }
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/benchmark/path/join-win32.js                                                            0000664 0000000 0000000 00000001041 14746647661 0017674 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { win32 } = require('path');

const bench = common.createBenchmark(main, {
  paths: [
    ['C:\\foo', 'bar', '', 'baz\\asdf', 'quux', '..'].join('|'),
  ],
  n: [1e5],
});

function main({ n, paths }) {
  const args = paths.split('|');
  const copy = [...args];
  const orig = copy[1];

  bench.start();
  for (let i = 0; i < n; i++) {
    if (i % 3 === 0) {
      copy[1] = `${orig}${i}`;
      win32.join(...copy);
    } else {
      win32.join(...args);
    }
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/benchmark/path/makeLong-win32.js                                                        0000664 0000000 0000000 00000000611 14746647661 0020474 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { win32 } = require('path');

const bench = common.createBenchmark(main, {
  path: [
    'foo\\bar',
    'C:\\foo',
    '\\\\foo\\bar',
    '\\\\?\\foo',
  ],
  n: [1e5],
});

function main({ n, path }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    win32._makeLong(i % 3 === 0 ? `${path}${i}` : path);
  }
  bench.end(n);
}
                                                                                                                       node-23.7.0/benchmark/path/normalize-posix.js                                                       0000664 0000000 0000000 00000000637 14746647661 0021147 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { posix } = require('path');

const bench = common.createBenchmark(main, {
  path: [
    '',
    '.',
    '/../',
    '/foo',
    '/foo/bar',
    '/foo/bar//baz/asdf/quux/..',
  ],
  n: [1e5],
});

function main({ n, path }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    posix.normalize(i % 3 === 0 ? `${path}${i}` : path);
  }
  bench.end(n);
}
                                                                                                 node-23.7.0/benchmark/path/normalize-win32.js                                                       0000664 0000000 0000000 00000000663 14746647661 0020746 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { win32 } = require('path');

const bench = common.createBenchmark(main, {
  path: [
    '',
    '.',
    'C:\\..\\',
    'C:\\foo',
    'C:\\foo\\bar',
    'C:\\foo\\bar\\\\baz\\asdf\\quux\\..',
  ],
  n: [1e5],
});

function main({ n, path }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    win32.normalize(i % 3 === 0 ? `${path}${i}` : path);
  }
  bench.end(n);
}
                                                                             node-23.7.0/benchmark/path/parse-posix.js                                                           0000664 0000000 0000000 00000000663 14746647661 0020260 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { posix } = require('path');

const bench = common.createBenchmark(main, {
  path: [
    '',
    '/',
    '/foo',
    '/foo/bar.baz',
    'foo/.bar.baz',
    'foo/bar',
    '/foo/bar/baz/asdf/.quux',
  ],
  n: [1e5],
});

function main({ n, path }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    posix.parse(i % 3 === 0 ? `${path}${i}` : path);
  }
  bench.end(n);
}
                                                                             node-23.7.0/benchmark/path/parse-win32.js                                                           0000664 0000000 0000000 00000000721 14746647661 0020053 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { win32 } = require('path');

const bench = common.createBenchmark(main, {
  path: [
    '',
    'C:\\',
    'C:\\foo',
    '\\foo',
    'E:\\foo\\bar.baz',
    'foo\\.bar.baz',
    'foo\\bar',
    '\\foo\\bar\\baz\\asdf\\.quux',
  ],
  n: [1e5],
});

function main({ n, path }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    win32.parse(i % 3 === 0 ? `${path}${i}` : path);
  }
  bench.end(n);
}
                                               node-23.7.0/benchmark/path/relative-posix.js                                                        0000664 0000000 0000000 00000001513 14746647661 0020754 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { posix } = require('path');

const bench = common.createBenchmark(main, {
  paths: [
    ['/data/orandea/test/aaa', '/data/orandea/impl/bbb'].join('|'),
    ['/', '/var'].join('|'),
    ['/', '/'].join('|'),
    ['/var', '/bin'].join('|'),
    ['/foo/bar/baz/quux', '/'].join('|'),
    ['/foo/bar/baz/quux', '/foo/bar/baz/quux'].join('|'),
    ['/foo/bar/baz/quux', '/var/log'].join('|'),
  ],
  n: [1e5],
});

function main({ n, paths }) {
  let to = '';
  const delimIdx = paths.indexOf('|');
  if (delimIdx > -1) {
    to = paths.slice(delimIdx + 1);
    paths = paths.slice(0, delimIdx);
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    if (i % 3 === 0)
      posix.relative(`${paths}${i}`, `${to}${i}`);
    else
      posix.relative(paths, to);
  }
  bench.end(n);
}
                                                                                                                                                                                     node-23.7.0/benchmark/path/relative-win32.js                                                        0000664 0000000 0000000 00000001575 14746647661 0020564 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { win32 } = require('path');

const bench = common.createBenchmark(main, {
  paths: [
    ['C:\\orandea\\test\\aaa', 'C:\\orandea\\impl\\bbb'].join('|'),
    ['C:\\', 'D:\\'].join('|'),
    ['C:\\foo\\bar\\baz', 'C:\\foo\\bar\\baz'].join('|'),
    ['C:\\foo\\BAR\\BAZ', 'C:\\foo\\bar\\baz'].join('|'),
    ['C:\\foo\\bar\\baz\\quux', 'C:\\'].join('|'),
    ['c:\\İ\\a\\İ', 'c:\\İ\\b\\İ\\test.txt', '..\\..\\b\\İ\\test.txt'].join('|'),
  ],
  n: [1e5],
});

function main({ n, paths }) {
  let to = '';
  const delimIdx = paths.indexOf('|');
  if (delimIdx > -1) {
    to = paths.slice(delimIdx + 1);
    paths = paths.slice(0, delimIdx);
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    if (i % 3 === 0)
      win32.relative(`${paths}${i}`, `${to}${i}`);
    else
      win32.relative(paths, to);
  }
  bench.end(n);
}
                                                                                                                                   node-23.7.0/benchmark/path/resolve-posix.js                                                         0000664 0000000 0000000 00000001153 14746647661 0020620 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { posix } = require('path');

const bench = common.createBenchmark(main, {
  paths: [
    '',
    ['', ''].join('|'),
    ['foo/bar', '/tmp/file/', '..', 'a/../subfile'].join('|'),
    ['a/b/c/', '../../..'].join('|'),
  ],
  n: [1e5],
});

function main({ n, paths }) {
  const args = paths.split('|');
  const copy = [...args];
  const orig = copy[0];

  bench.start();
  for (let i = 0; i < n; i++) {
    if (i % 3 === 0) {
      copy[0] = `${orig}${i}`;
      posix.resolve(...copy);
    } else {
      posix.resolve(...args);
    }
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/benchmark/path/resolve-win32.js                                                         0000664 0000000 0000000 00000001165 14746647661 0020423 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { win32 } = require('path');

const bench = common.createBenchmark(main, {
  paths: [
    '',
    ['', ''].join('|'),
    ['c:/ignore', 'd:\\a/b\\c/d', '\\e.exe'].join('|'),
    ['c:/blah\\blah', 'd:/games', 'c:../a'].join('|'),
  ],
  n: [1e5],
});

function main({ n, paths }) {
  const args = paths.split('|');
  const copy = [...args];
  const orig = copy[0];

  bench.start();
  for (let i = 0; i < n; i++) {
    if (i % 3 === 0) {
      copy[0] = `${orig}${i}`;
      win32.resolve(...copy);
    } else {
      win32.resolve(...args);
    }
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/benchmark/path/toNamespacedPath-posix.js                                                0000664 0000000 0000000 00000000731 14746647661 0022362 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { posix } = require('path');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  path: [
    '',
    '.',
    '/tmp/bar',
    '/home/node/..',
    posix.join(__dirname, '/..'),
    'bar/baz',
  ],
  n: [1e5],
});

function main({ n, path }) {
  bench.start();
  let a;
  for (let i = 0; i < n; i++) {
    a = posix.toNamespacedPath(path);
  }
  bench.end(n);
  assert.ok(a + 'a');
}
                                       node-23.7.0/benchmark/path/toNamespacedPath-win32.js                                                0000664 0000000 0000000 00000001003 14746647661 0022153 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { win32 } = require('path');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  path: [
    '',
    'c:/ignore',
    'd:\\a/b\\c/d',
    '\\e.exe',
    'c:/blah\\blah',
    'd:/games',
    'c:../a',
    win32.join(__dirname, '/..'),
  ],
  n: [1e5],
});

function main({ n, path }) {
  bench.start();
  let a;
  for (let i = 0; i < n; i++) {
    a = win32.toNamespacedPath(path);
  }
  bench.end(n);
  assert.ok(a + 'a');
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/benchmark/perf_hooks/                                                                   0000775 0000000 0000000 00000000000 14746647661 0016646 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/perf_hooks/bench-eventlooputil.js                                             0000664 0000000 0000000 00000002603 14746647661 0023173 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const assert = require('assert').ok;
const { performance } = require('perf_hooks');
const { nodeTiming, eventLoopUtilization } = performance;

const bench = common.createBenchmark(main, {
  n: [1e6],
  method: [
    'idleTime',
    'ELU_simple',
    'ELU_passed',
  ],
});

function main({ method, n }) {
  switch (method) {
    case 'idleTime':
      benchIdleTime(n);
      break;
    case 'ELU_simple':
      benchELUSimple(n);
      break;
    case 'ELU_passed':
      benchELUPassed(n);
      break;
    default:
      throw new Error(`Unsupported method ${method}`);
  }
}

function benchIdleTime(n) {
  bench.start();
  for (let i = 0; i < n; i++)
    nodeTiming.idleTime; // eslint-disable-line no-unused-expressions
  bench.end(n);
}

function benchELUSimple(n) {
  // Need to put this in setImmediate or will always return 0.
  setImmediate(() => {
    const elu = eventLoopUtilization();
    assert(elu.active + elu.idle > 0);

    bench.start();
    for (let i = 0; i < n; i++)
      eventLoopUtilization();
    bench.end(n);
  });
}

function benchELUPassed(n) {
  // Need to put this in setImmediate or will always return 0.
  setImmediate(() => {
    let elu = eventLoopUtilization();
    assert(elu.active + elu.idle > 0);

    bench.start();
    for (let i = 0; i < n; i++)
      elu = eventLoopUtilization(elu);
    bench.end(n);
  });
}
                                                                                                                             node-23.7.0/benchmark/perf_hooks/histogram-clone.js                                                 0000664 0000000 0000000 00000000711 14746647661 0022276 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const assert = require('assert');
const common = require('../common.js');

const { createHistogram } = require('perf_hooks');

const bench = common.createBenchmark(main, {
  n: [1e5],
});

let _histogram;

function main({ n }) {
  const histogram = createHistogram();

  bench.start();
  for (let i = 0; i < n; i++)
    _histogram = structuredClone(histogram);
  bench.end(n);

  // Avoid V8 deadcode (elimination)
  assert.ok(_histogram);
}
                                                       node-23.7.0/benchmark/perf_hooks/histogram-create.js                                                0000664 0000000 0000000 00000000630 14746647661 0022441 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const assert = require('assert');
const common = require('../common.js');

const { createHistogram } = require('perf_hooks');

const bench = common.createBenchmark(main, {
  n: [1e5],
});

let _histogram;

function main({ n }) {
  bench.start();
  for (let i = 0; i < n; i++)
    _histogram = createHistogram();
  bench.end(n);

  // Avoid V8 deadcode (elimination)
  assert.ok(_histogram);
}
                                                                                                        node-23.7.0/benchmark/perf_hooks/histogram-record.js                                                0000664 0000000 0000000 00000001060 14746647661 0022452 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const assert = require('assert');
const common = require('../common.js');

const { createHistogram } = require('perf_hooks');

const bench = common.createBenchmark(main, {
  n: [1e5],
});

function main({ n }) {
  const histogram = createHistogram();
  bench.start();
  for (let i = 0; i < n; i++) {
    histogram.record(i + 1);
    /* eslint-disable no-unused-expressions */
    histogram.max;
    histogram.mean;
    /* eslint-enable no-unused-expressions */
  }
  bench.end(n);

  // Avoid V8 deadcode (elimination)
  assert.ok(histogram);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/benchmark/perf_hooks/nodetiming-uvmetricsinfo.js                                        0000664 0000000 0000000 00000001113 14746647661 0024230 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const assert = require('node:assert');
const fs = require('node:fs/promises');

const {
  performance,
} = require('perf_hooks');

const bench = common.createBenchmark(main, {
  n: [1e6],
  events: [1, 1000, 10000],
});

async function runEvents(events) {
  for (let i = 0; i < events; ++i) {
    assert.ok(await fs.statfs(__filename));
  }
}

async function main({ n, events }) {
  await runEvents(events);
  bench.start();
  for (let i = 0; i < n; i++) {
    assert.ok(performance.nodeTiming.uvMetricsInfo);
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/benchmark/perf_hooks/now.js                                                             0000664 0000000 0000000 00000000624 14746647661 0020011 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const assert = require('assert');
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [1e6],
});

function main({ n }) {
  const arr = [];
  for (let i = 0; i < n; ++i) {
    arr.push(performance.now());
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    arr[i] = performance.now();
  }
  bench.end(n);

  assert.strictEqual(arr.length, n);
}
                                                                                                            node-23.7.0/benchmark/perf_hooks/performance-observer.js                                            0000664 0000000 0000000 00000001655 14746647661 0023341 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const assert = require('assert');
const common = require('../common.js');

const {
  PerformanceObserver,
  performance,
} = require('perf_hooks');

function randomFn() {
  return Math.random();
}

const bench = common.createBenchmark(main, {
  n: [1e6],
  pending: [1, 10],
}, {
  options: ['--expose-internals'],
});

let _result;

function fillQueue(timerfied, pending) {
  for (let i = 0; i < pending; i++) {
    _result = timerfied();
  }
  // Avoid V8 deadcode (elimination)
  assert.ok(_result);
}

function main({ n, pending }) {
  const timerfied = performance.timerify(randomFn);

  let count = 0;
  const obs = new PerformanceObserver((entries) => {
    count += entries.getEntries().length;

    if (count >= n) {
      bench.end(count);
    } else {
      fillQueue(timerfied, pending);
    }
  });
  obs.observe({ entryTypes: ['function'], buffered: true });

  bench.start();
  fillQueue(timerfied, pending);
}
                                                                                   node-23.7.0/benchmark/perf_hooks/resourcetiming.js                                                  0000664 0000000 0000000 00000003210 14746647661 0022237 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const {
  PerformanceObserver,
  performance,
} = require('perf_hooks');

function createTimingInfo({
  startTime = 0,
  redirectStartTime = 0,
  redirectEndTime = 0,
  postRedirectStartTime = 0,
  finalServiceWorkerStartTime = 0,
  finalNetworkRequestStartTime = 0,
  finalNetworkResponseStartTime = 0,
  endTime = 0,
  encodedBodySize = 0,
  decodedBodySize = 0,
  finalConnectionTimingInfo = null,
}) {
  if (finalConnectionTimingInfo !== null) {
    finalConnectionTimingInfo.domainLookupStartTime ||= 0;
    finalConnectionTimingInfo.domainLookupEndTime ||= 0;
    finalConnectionTimingInfo.connectionStartTime ||= 0;
    finalConnectionTimingInfo.connectionEndTime ||= 0;
    finalConnectionTimingInfo.secureConnectionStartTime ||= 0;
    finalConnectionTimingInfo.ALPNNegotiatedProtocol ||= [];
  }
  return {
    startTime,
    redirectStartTime,
    redirectEndTime,
    postRedirectStartTime,
    finalServiceWorkerStartTime,
    finalNetworkRequestStartTime,
    finalNetworkResponseStartTime,
    endTime,
    encodedBodySize,
    decodedBodySize,
    finalConnectionTimingInfo,
  };
}

const bench = common.createBenchmark(main, {
  n: [1e6],
  observe: ['resource'],
});

function test() {
  const timingInfo = createTimingInfo({ finalConnectionTimingInfo: {} });
  performance.markResourceTiming(
    timingInfo,
    'http://localhost:8080',
    'fetch',
    {},
    '',
  );
}

function main({ n, observe }) {
  const obs = new PerformanceObserver(() => {
    bench.end(n);
  });
  obs.observe({ entryTypes: [observe], buffered: true });

  bench.start();
  for (let i = 0; i < n; i++)
    test();
}
                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/perf_hooks/time-origin.js                                                     0000664 0000000 0000000 00000001467 14746647661 0021437 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const assert = require('assert');
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [1e6],
  method: ['timeOrigin', 'toJSON'],
});

function main({ method, n }) {
  switch (method) {
    case 'timeOrigin':
      benchTimeOrigin(n);
      break;
    case 'toJSON':
      benchToJSON(n);
      break;
    default:
      throw new Error(`Unsupported method ${method}`);
  }
}

function benchTimeOrigin(n) {
  const arr = [];
  for (let i = 0; i < n; ++i) {
    arr.push(performance.timeOrigin);
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    arr[i] = performance.timeOrigin;
  }
  bench.end(n);

  assert.strictEqual(arr.length, n);
}

function benchToJSON(n) {
  bench.start();
  for (let i = 0; i < n; i++) {
    performance.toJSON();
  }
  bench.end(n);
}
                                                                                                                                                                                                         node-23.7.0/benchmark/perf_hooks/timerfied.js                                                       0000664 0000000 0000000 00000001230 14746647661 0021150 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const assert = require('assert');
const common = require('../common.js');

const {
  PerformanceObserver,
  performance,
} = require('perf_hooks');

function randomFn() {
  return Math.random();
}

const bench = common.createBenchmark(main, {
  n: [1e6],
  observe: ['function'],
});

let _result;

function main({ n, observe }) {
  const obs = new PerformanceObserver(() => {
    bench.end(n);
  });
  obs.observe({ entryTypes: [observe], buffered: true });

  const timerfied = performance.timerify(randomFn);

  bench.start();
  for (let i = 0; i < n; i++)
    _result = timerfied();

  // Avoid V8 deadcode (elimination)
  assert.ok(_result);
}
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/perf_hooks/usertiming.js                                                      0000664 0000000 0000000 00000001231 14746647661 0021367 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const {
  PerformanceObserver,
  performance,
} = require('perf_hooks');

const bench = common.createBenchmark(main, {
  n: [1e6],
  observe: ['all', 'measure'],
});

function test() {
  performance.mark('a');
  performance.mark('b');
  performance.measure('a to b', 'a', 'b');
}

function main({ n, observe }) {
  const entryTypes = observe === 'all' ?
    [ 'mark', 'measure' ] :
    [ observe ];
  const obs = new PerformanceObserver(() => {
    bench.end(n);
  });
  obs.observe({ entryTypes, buffered: true });

  bench.start();
  performance.mark('start');
  for (let i = 0; i < 1e5; i++)
    test();
}
                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/benchmark/permission/                                                                   0000775 0000000 0000000 00000000000 14746647661 0016677 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/permission/permission-processhas-fs-read.js                                   0000664 0000000 0000000 00000002007 14746647661 0025113 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const path = require('path');

const configs = {
  n: [1e5],
  concurrent: [1, 10],
};

const rootPath = path.resolve(__dirname, '../../..');

const options = {
  flags: [
    '--permission',
    `--allow-fs-read=${rootPath}`,
    '--allow-child-process',
    '--no-warnings',
  ],
};

const bench = common.createBenchmark(main, configs, options);

// This is a naive benchmark and might not demonstrate real-world use cases.
// New benchmarks will be created once the permission model config is available
// through a config file.
async function main(conf) {
  const benchmarkDir = path.join(__dirname, '../..');
  bench.start();

  for (let i = 0; i < conf.n; i++) {
    // Valid file in a sequence of denied files
    process.permission.has('fs.read', benchmarkDir + '/valid-file');
    // Denied file
    process.permission.has('fs.read', __filename);
    // Valid file a granted directory
    process.permission.has('fs.read', '/tmp/example');
  }

  bench.end(conf.n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/permission/permission-startup.js                                              0000664 0000000 0000000 00000002770 14746647661 0023133 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const path = require('path');
const { spawnSync } = require('child_process');

function mockFiles(n, prefix = '/tmp') {
  const files = [];
  for (let i = 0; i < n; ++i) {
    files.push(prefix + '/file' + i + '.js');
  }

  return files;
}

const bench = common.createBenchmark(main, {
  script: [
    'test/fixtures/semicolon',
  ],
  prefixPath: ['/tmp'],
  nFiles: [10, 100, 1000],
  count: [30],
});

function spawnProcess(script, bench, state) {
  const cmd = process.execPath || process.argv[0];
  while (state.finished < state.count) {
    const child = spawnSync(cmd, script);
    if (child.status !== 0) {
      console.log('---- STDOUT ----');
      console.log(child.stdout.toString());
      console.log('---- STDERR ----');
      console.log(child.stderr.toString());
      throw new Error(`Child process stopped with exit code ${child.status}`);
    }
    state.finished++;
    if (state.finished === 0) {
      // Finished warmup.
      bench.start();
    }

    if (state.finished === state.count) {
      bench.end(state.count);
    }
  }
}

function main({ count, script, nFiles, prefixPath }) {
  script = path.resolve(__dirname, '../../', `${script}.js`);
  const optionsWithScript = [
    '--permission',
    `--allow-fs-read=${script}`,
    ...mockFiles(nFiles, prefixPath).map((file) => '--allow-fs-read=' + file),
    script,
  ];
  const warmup = 3;
  const state = { count, finished: -warmup };
  spawnProcess(optionsWithScript, bench, state);
}
        node-23.7.0/benchmark/process/                                                                      0000775 0000000 0000000 00000000000 14746647661 0016165 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/process/bench-env.js                                                          0000664 0000000 0000000 00000002644 14746647661 0020376 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const bench = common.createBenchmark(main, {
  n: [1e6],
  operation: ['get', 'set', 'enumerate', 'query', 'delete'],
});


function main({ n, operation }) {
  switch (operation) {
    case 'get':
      bench.start();
      for (let i = 0; i < n; i++) {
        process.env.PATH; // eslint-disable-line no-unused-expressions
      }
      bench.end(n);
      break;
    case 'set':
      bench.start();
      for (let i = 0; i < n; i++) {
        process.env.DUMMY = 'hello, world';
      }
      bench.end(n);
      break;
    case 'enumerate':
      // First, normalize process.env so that benchmark results are comparable.
      for (const key of Object.keys(process.env))
        delete process.env[key];
      for (let i = 0; i < 64; i++)
        process.env[Math.random()] = Math.random();

      n /= 10;  // Enumeration is comparatively heavy.
      bench.start();
      for (let i = 0; i < n; i++) {
        // Access every item in object to process values.
        Object.keys(process.env);
      }
      bench.end(n);
      break;
    case 'query':
      bench.start();
      for (let i = 0; i < n; i++) {
        'PATH' in process.env; // eslint-disable-line no-unused-expressions
      }
      bench.end(n);
      break;
    case 'delete':
      bench.start();
      for (let i = 0; i < n; i++) {
        delete process.env.DUMMY;
      }
      bench.end(n);
      break;
  }
}
                                                                                            node-23.7.0/benchmark/process/bench-hrtime.js                                                       0000664 0000000 0000000 00000001511 14746647661 0021066 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [1e6],
  type: ['raw', 'diff', 'bigint'],
});

function main({ n, type }) {
  const hrtime = process.hrtime;
  let noDead = type === 'bigint' ? hrtime.bigint() : hrtime();

  switch (type) {
    case 'raw':
      bench.start();
      for (let i = 0; i < n; i++) {
        noDead = hrtime();
      }
      bench.end(n);
      break;
    case 'diff':
      bench.start();
      for (let i = 0; i < n; i++) {
        noDead = hrtime(noDead);
      }
      bench.end(n);
      break;
    case 'bigint':
      bench.start();
      for (let i = 0; i < n; i++) {
        noDead = hrtime.bigint();
      }
      bench.end(n);
      break;
  }

  assert.ok(Array.isArray(noDead) || typeof noDead === 'bigint');
}
                                                                                                                                                                                       node-23.7.0/benchmark/process/coverage.js                                                           0000664 0000000 0000000 00000001506 14746647661 0020320 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // This benchmark is meant to exercise a grab bag of code paths that would
// be expected to run slower under coverage.
'use strict';

const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [1e5],
});
const { rmSync } = require('fs');
const { spawnSync } = require('child_process');
const tmpdir = require('../../test/common/tmpdir');

const coverageDir = tmpdir.resolve(`cov-${Date.now()}`);

function main({ n }) {
  bench.start();
  const result = spawnSync(process.execPath, [
    require.resolve('../fixtures/coverage-many-branches'),
  ], {
    env: {
      NODE_V8_COVERAGE: coverageDir,
      N: n,
      ...process.env,
    },
  });
  bench.end(n);
  rmSync(coverageDir, { recursive: true, force: true });
  if (result.status !== 0) {
    throw new Error(result.stderr.toString('utf8'));
  }
}
                                                                                                                                                                                          node-23.7.0/benchmark/process/getActiveResourcesInfo.js                                             0000664 0000000 0000000 00000001737 14746647661 0023155 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const { createBenchmark } = require('../common.js');

const { connect, createServer } = require('net');
const { open } = require('fs');

const bench = createBenchmark(main, {
  handlesCount: [1e4],
  requestsCount: [1e4],
  timeoutsCount: [1e4],
  immediatesCount: [1e4],
  n: [1e5],
});

function main({ handlesCount, requestsCount, timeoutsCount, immediatesCount, n }) {
  const server = createServer().listen();
  const clients = [];
  for (let i = 0; i < handlesCount; i++) {
    clients.push(connect({ port: server.address().port }));
  }

  for (let i = 0; i < requestsCount; i++) {
    open(__filename, 'r', () => {});
  }

  for (let i = 0; i < timeoutsCount; ++i) {
    setTimeout(() => {}, 1);
  }

  for (let i = 0; i < immediatesCount; ++i) {
    setImmediate(() => {});
  }

  bench.start();
  for (let i = 0; i < n; ++i) {
    process.getActiveResourcesInfo();
  }
  bench.end(n);

  for (const client of clients) {
    client.destroy();
  }
  server.close();
}
                                 node-23.7.0/benchmark/process/memoryUsage.js                                                        0000664 0000000 0000000 00000000356 14746647661 0021024 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [1e5],
});

function main({ n }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    process.memoryUsage();
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/process/next-tick-breadth-args.js                                             0000664 0000000 0000000 00000001434 14746647661 0022774 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [1e7],
});

function main({ n }) {
  let j = 0;

  function cb1(arg1) {
    j++;
    if (j === n)
      bench.end(n);
  }

  function cb2(arg1, arg2) {
    j++;
    if (j === n)
      bench.end(n);
  }

  function cb3(arg1, arg2, arg3) {
    j++;
    if (j === n)
      bench.end(n);
  }

  function cb4(arg1, arg2, arg3, arg4) {
    j++;
    if (j === n)
      bench.end(n);
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    if (i % 4 === 0)
      process.nextTick(cb4, 3.14, 1024, true, false);
    else if (i % 3 === 0)
      process.nextTick(cb3, 512, true, null);
    else if (i % 2 === 0)
      process.nextTick(cb2, false, 5.1);
    else
      process.nextTick(cb1, 0);
  }
}
                                                                                                                                                                                                                                    node-23.7.0/benchmark/process/next-tick-breadth.js                                                  0000664 0000000 0000000 00000000460 14746647661 0022040 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [1e7],
});

function main({ n }) {
  let j = 0;

  function cb() {
    j++;
    if (j === n)
      bench.end(n);
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    process.nextTick(cb);
  }
}
                                                                                                                                                                                                                node-23.7.0/benchmark/process/next-tick-depth-args.js                                               0000664 0000000 0000000 00000003270 14746647661 0022467 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [7e6],
});

function main({ n }) {
  let counter = n;
  function cb4(arg1, arg2, arg3, arg4) {
    if (--counter) {
      if (counter % 4 === 0)
        process.nextTick(cb4, 3.14, 1024, true, false);
      else if (counter % 3 === 0)
        process.nextTick(cb3, 512, true, null);
      else if (counter % 2 === 0)
        process.nextTick(cb2, false, 5.1);
      else
        process.nextTick(cb1, 0);
    } else
      bench.end(n);
  }

  function cb3(arg1, arg2, arg3) {
    if (--counter) {
      if (counter % 4 === 0)
        process.nextTick(cb4, 3.14, 1024, true, false);
      else if (counter % 3 === 0)
        process.nextTick(cb3, 512, true, null);
      else if (counter % 2 === 0)
        process.nextTick(cb2, false, 5.1);
      else
        process.nextTick(cb1, 0);
    } else
      bench.end(n);
  }

  function cb2(arg1, arg2) {
    if (--counter) {
      if (counter % 4 === 0)
        process.nextTick(cb4, 3.14, 1024, true, false);
      else if (counter % 3 === 0)
        process.nextTick(cb3, 512, true, null);
      else if (counter % 2 === 0)
        process.nextTick(cb2, false, 5.1);
      else
        process.nextTick(cb1, 0);
    } else
      bench.end(n);
  }

  function cb1(arg1) {
    if (--counter) {
      if (counter % 4 === 0)
        process.nextTick(cb4, 3.14, 1024, true, false);
      else if (counter % 3 === 0)
        process.nextTick(cb3, 512, true, null);
      else if (counter % 2 === 0)
        process.nextTick(cb2, false, 5.1);
      else
        process.nextTick(cb1, 0);
    } else
      bench.end(n);
  }
  bench.start();
  process.nextTick(cb1, true);
}
                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/process/next-tick-depth.js                                                    0000664 0000000 0000000 00000000503 14746647661 0021531 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [7e6],
});

function main({ n }) {
  let counter = n;
  bench.start();
  process.nextTick(onNextTick);
  function onNextTick() {
    if (--counter)
      process.nextTick(onNextTick);
    else
      bench.end(n);
  }
}
                                                                                                                                                                                             node-23.7.0/benchmark/process/next-tick-exec-args.js                                                0000664 0000000 0000000 00000001032 14746647661 0022301 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [4e6],
});

function main({ n }) {
  function onNextTick(i) {
    if (i + 1 === n)
      bench.end(n);
  }

  for (let i = 0; i < n; i++) {
    if (i % 4 === 0)
      process.nextTick(onNextTick, i, true, 10, 'test');
    else if (i % 3 === 0)
      process.nextTick(onNextTick, i, true, 10);
    else if (i % 2 === 0)
      process.nextTick(onNextTick, i, 20);
    else
      process.nextTick(onNextTick, i);
  }

  bench.start();
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/benchmark/process/next-tick-exec.js                                                     0000664 0000000 0000000 00000000461 14746647661 0021354 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [4e6],
});

function main({ n }) {
  function onNextTick(i) {
    if (i + 1 === n)
      bench.end(n);
  }

  for (let i = 0; i < n; i++) {
    process.nextTick(onNextTick, i);
  }

  bench.start();
}
                                                                                                                                                                                                               node-23.7.0/benchmark/process/next-tick-loop-args.js                                                0000664 0000000 0000000 00000001311 14746647661 0022326 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [1e4, 2e4, 4e4],
  loop: [1e2, 2e2],
});

function main({ n, loop }) {
  bench.start();
  run();
  function run() {
    let j = 0;

    function cb() {
      j++;
      if (j === n) {
        loop--;
        if (loop === 0) {
          bench.end(n);
        } else {
          run();
        }
      }
    }

    for (let i = 0; i < n; i++) {
      if (i % 4 === 0)
        process.nextTick(cb, i, true, 10, 'test');
      else if (i % 3 === 0)
        process.nextTick(cb, i, true, 10);
      else if (i % 2 === 0)
        process.nextTick(cb, i, 20);
      else
        process.nextTick(cb, i);
    }
  }
}
                                                                                                                                                                                                                                                                                                                       node-23.7.0/benchmark/process/next-tick-loop.js                                                     0000664 0000000 0000000 00000000747 14746647661 0021410 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [1e4, 2e4, 4e4],
  loop: [1e2, 2e2],
});

function main({ n, loop }) {
  bench.start();
  run();
  function run() {
    let j = 0;

    function cb() {
      j++;
      if (j === n) {
        loop--;
        if (loop === 0) {
          bench.end(n);
        } else {
          run();
        }
      }
    }

    for (let i = 0; i < n; i++) {
      process.nextTick(cb);
    }
  }
}
                         node-23.7.0/benchmark/process/queue-microtask-breadth.js                                            0000664 0000000 0000000 00000000456 14746647661 0023255 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [4e5],
});

function main({ n }) {
  let j = 0;

  function cb() {
    j++;
    if (j === n)
      bench.end(n);
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    queueMicrotask(cb);
  }
}
                                                                                                                                                                                                                  node-23.7.0/benchmark/process/queue-microtask-depth.js                                              0000664 0000000 0000000 00000000500 14746647661 0022736 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [12e5],
});

function main({ n }) {
  let counter = n;
  bench.start();
  queueMicrotask(onNextTick);
  function onNextTick() {
    if (--counter)
      queueMicrotask(onNextTick);
    else
      bench.end(n);
  }
}
                                                                                                                                                                                                node-23.7.0/benchmark/process/resourceUsage.js                                                      0000664 0000000 0000000 00000000360 14746647661 0021336 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [1e5],
});

function main({ n }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    process.resourceUsage();
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                node-23.7.0/benchmark/querystring/                                                                  0000775 0000000 0000000 00000000000 14746647661 0017103 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/querystring/querystring-parse.js                                              0000664 0000000 0000000 00000001507 14746647661 0023150 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const querystring = require('querystring');
const inputs = common.searchParams;

const bench = common.createBenchmark(main, {
  type: Object.keys(inputs),
  n: [1e6],
});

function main({ type, n }) {
  const input = inputs[type];

  // Execute the function a "sufficient" number of times before the timed
  // loop to ensure the function is optimized just once.
  if (type === 'multicharsep') {
    for (let i = 0; i < n; i += 1)
      querystring.parse(input, '&&&&&&&&&&');

    bench.start();
    for (let i = 0; i < n; i += 1)
      querystring.parse(input, '&&&&&&&&&&');
    bench.end(n);
  } else {
    for (let i = 0; i < n; i += 1)
      querystring.parse(input);

    bench.start();
    for (let i = 0; i < n; i += 1)
      querystring.parse(input);
    bench.end(n);
  }
}
                                                                                                                                                                                         node-23.7.0/benchmark/querystring/querystring-stringify.js                                          0000664 0000000 0000000 00000002123 14746647661 0024047 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const querystring = require('querystring');

const bench = common.createBenchmark(main, {
  type: ['noencode', 'encodemany', 'encodelast', 'array', 'multiprimitives'],
  n: [1e6],
});

function main({ type, n }) {
  const inputs = {
    noencode: {
      foo: 'bar',
      baz: 'quux',
      xyzzy: 'thud',
    },
    encodemany: {
      '\u0080\u0083\u0089': 'bar',
      '\u008C\u008E\u0099': 'quux',
      'xyzzy': '\u00A5q\u00A3r',
    },
    encodelast: {
      foo: 'bar',
      baz: 'quux',
      xyzzy: 'thu\u00AC',
    },
    array: {
      foo: [],
      baz: ['bar'],
      xyzzy: ['bar', 'quux', 'thud'],
    },
    multiprimitives: {
      foo: false,
      bar: -13.37,
      baz: '',
    },
  };
  const input = inputs[type];

  // Force-optimize querystring.stringify() so that the benchmark doesn't get
  // disrupted by the optimizer kicking in halfway through.
  for (const name in inputs)
    querystring.stringify(inputs[name]);

  bench.start();
  for (let i = 0; i < n; i += 1)
    querystring.stringify(input);
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/benchmark/querystring/querystring-unescapebuffer.js                                     0000664 0000000 0000000 00000001073 14746647661 0025031 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const querystring = require('querystring');

const bench = common.createBenchmark(main, {
  input: [
    'there is nothing to unescape here',
    'there%20are%20several%20spaces%20that%20need%20to%20be%20unescaped',
    'there%2Qare%0-fake%escaped values in%%%%this%9Hstring',
    '%20%21%22%23%24%25%26%27%28%29%2A%2B%2C%2D%2E%2F%30%31%32%33%34%35%36%37',
  ],
  n: [10e6],
});

function main({ input, n }) {
  bench.start();
  for (let i = 0; i < n; i += 1)
    querystring.unescapeBuffer(input);
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/benchmark/readline/                                                                     0000775 0000000 0000000 00000000000 14746647661 0016272 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/readline/readline-iterable.js                                                 0000664 0000000 0000000 00000004307 14746647661 0022204 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const readline = require('readline');
const { Readable } = require('stream');

const bench = common.createBenchmark(main, {
  n: [1e1, 1e2, 1e3, 1e4, 1e5, 1e6],
  type: ['old', 'new'],
});

const loremIpsum = `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed
do eiusmod tempor incididunt ut labore et dolore magna aliqua.
Dui accumsan sit amet nulla facilisi morbi tempus iaculis urna.
Eget dolor morbi non arcu risus quis varius quam quisque.
Lacus viverra vitae congue eu consequat ac felis donec.
Amet porttitor eget dolor morbi non arcu.
Velit ut tortor pretium viverra suspendisse.
Mauris nunc congue nisi vitae suscipit tellus.
Amet nisl suscipit adipiscing bibendum est ultricies integer.
Sit amet dictum sit amet justo donec enim diam.
Condimentum mattis pellentesque id nibh tortor id aliquet lectus proin.
Diam in arcu cursus euismod quis viverra nibh.
Rest of line`;

function oldWay() {
  const readable = new Readable({
    objectMode: true,
    read: () => {
      this.resume();
    },
    destroy: (err, cb) => {
      this.off('line', lineListener);
      this.off('close', closeListener);
      this.close();
      cb(err);
    },
  });
  const lineListener = (input) => {
    if (!readable.push(input)) {
      // TODO(rexagod): drain to resume flow
      this.pause();
    }
  };
  const closeListener = () => {
    readable.push(null);
  };
  const errorListener = (err) => {
    readable.destroy(err);
  };
  this.on('error', errorListener);
  this.on('line', lineListener);
  this.on('close', closeListener);
  return readable[Symbol.asyncIterator]();
}

function getLoremIpsumStream(repetitions) {
  const readable = Readable({
    objectMode: true,
  });
  let i = 0;
  readable._read = () => readable.push(
    i++ >= repetitions ? null : loremIpsum,
  );
  return readable;
}

async function main({ n, type }) {
  bench.start();
  let lineCount = 0;

  const iterable = readline.createInterface({
    input: getLoremIpsumStream(n),
  });

  const readlineIterable = type === 'old' ? oldWay.call(iterable) : iterable;

  // eslint-disable-next-line no-unused-vars
  for await (const _ of readlineIterable) {
    lineCount++;
  }
  bench.end(lineCount);
}
                                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/run.js                                                                        0000664 0000000 0000000 00000006664 14746647661 0015665 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const path = require('path');
const { spawn, fork } = require('node:child_process');
const CLI = require('./_cli.js');

const cli = new CLI(`usage: ./node run.js [options] [--] <category> ...
  Run each benchmark in the <category> directory a single time, more than one
  <category> directory can be specified.

  --filter   pattern        includes only benchmark scripts matching <pattern>
                            (can be repeated)
  --exclude  pattern        excludes scripts matching <pattern> (can be
                            repeated)
  --runs   variable=value   set the amount of benchmark suite execution.
                            Default: 1
  --set    variable=value   set benchmark variable (can be repeated)
  --format [simple|csv]     optional value that specifies the output format
  test                      only run a single configuration from the options
                            matrix
  all                       each benchmark category is run one after the other

  Examples:
    --set CPUSET=0            Runs benchmarks on CPU core 0.
    --set CPUSET=0-2          Specifies that benchmarks should run on CPU cores 0 to 2.

  Note: The CPUSET format should match the specifications of the 'taskset' command on your system.
`, { arrayArgs: ['set', 'filter', 'exclude'] });

const benchmarks = cli.benchmarks();

if (benchmarks.length === 0) {
  console.error('No benchmarks found');
  process.exitCode = 1;
  return;
}

const validFormats = ['csv', 'simple'];
const format = cli.optional.format || 'simple';
if (!validFormats.includes(format)) {
  console.error('Invalid format detected');
  process.exitCode = 1;
  return;
}

if (format === 'csv') {
  console.log('"filename", "configuration", "rate", "time"');
}

function runBenchmark(filename) {
  const scriptPath = path.resolve(__dirname, filename);

  const args = cli.test ? ['--test'] : cli.optional.set;
  const cpuCore = cli.getCpuCoreSetting();
  let child;
  if (cpuCore !== null) {
    child = spawn('taskset', ['-c', cpuCore, 'node', scriptPath, ...args], {
      stdio: ['inherit', 'inherit', 'inherit', 'ipc'],
    });
  } else {
    child = fork(
      scriptPath,
      args,
    );
  }

  return new Promise((resolve, reject) => {
    child.on('message', (data) => {
      if (data.type !== 'report') {
        return;
      }
      // Construct configuration string, " A=a, B=b, ..."
      let conf = '';
      for (const key of Object.keys(data.conf)) {
        if (conf !== '')
          conf += ' ';
        conf += `${key}=${JSON.stringify(data.conf[key])}`;
      }
      if (format === 'csv') {
        // Escape quotes (") for correct csv formatting
        conf = conf.replace(/"/g, '""');
        console.log(`"${data.name}", "${conf}", ${data.rate}, ${data.time}`);
      } else {
        let rate = data.rate.toString().split('.');
        rate[0] = rate[0].replace(/(\d)(?=(?:\d\d\d)+(?!\d))/g, '$1,');
        rate = (rate[1] ? rate.join('.') : rate[0]);
        console.log(`${data.name} ${conf}: ${rate}`);
      }
    });
    child.once('close', (code) => {
      if (code) {
        reject(code);
      } else {
        resolve(code);
      }
    });
  });
}

async function run() {
  for (let i = 0; i < benchmarks.length; ++i) {
    let runs = cli.optional.runs ?? 1;
    const filename = benchmarks[i];
    if (format !== 'csv') {
      console.log();
      console.log(filename);
    }

    while (runs-- > 0) {
      await runBenchmark(filename);
    }
  }
}

run();
                                                                            node-23.7.0/benchmark/scatter.R                                                                     0000664 0000000 0000000 00000004566 14746647661 0016312 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #!/usr/bin/env Rscript
library(ggplot2);
library(plyr);

# get __dirname and load ./_cli.R
args = commandArgs(trailingOnly = F);
dirname = dirname(sub("--file=", "", args[grep("--file", args)]));
source(paste0(dirname, '/_cli.R'), chdir=T);

if (is.null(args.options$xaxis) || is.null(args.options$category) ||
   (!is.null(args.options$plot) && args.options$plot == TRUE)) {
  stop("usage: cat file.csv | Rscript scatter.R [variable=value ...]
  --xaxis    variable   variable name to use as xaxis (required)
  --category variable   variable name to use as colored category (required)
  --plot     filename   save plot to filename
  --log                 use a log-2 scale for xaxis in the plot");
}

plot.filename = args.options$plot;

# parse options
x.axis.name = args.options$xaxis;
category.name = args.options$category;
use.log2 = !is.null(args.options$log);

# parse data
dat = read.csv(file('stdin'), strip.white=TRUE);
dat = data.frame(dat);

# List of aggregated variables
aggregate = names(dat);
aggregate = aggregate[
  ! aggregate %in% c('rate', 'time', 'filename', x.axis.name, category.name)
];
# Variables that don't change aren't aggregated
for (aggregate.key in aggregate) {
  if (length(unique(dat[[aggregate.key]])) == 1) {
    aggregate = aggregate[aggregate != aggregate.key];
  }
}

# Print out aggregated variables
for (aggregate.variable in aggregate) {
  cat(sprintf('aggregating variable: %s\n', aggregate.variable));
}
if (length(aggregate) > 0) {
  cat('\n');
}

# Calculate statistics
stats = ddply(dat, c(x.axis.name, category.name), function(subdat) {
  rate = subdat$rate;

  # calculate confidence interval of the mean
  ci = NA;
  if (length(rate) > 1) {
    se = sqrt(var(rate)/length(rate));
    ci = se * qt(0.975, length(rate) - 1)
  }

  # calculate mean and 95 % confidence interval
  r = list(
    rate = mean(rate),
    confidence.interval = ci
  );

  return(data.frame(r));
});

print(stats, row.names=F);

if (!is.null(plot.filename)) {
  p = ggplot(stats, aes_string(x=x.axis.name, y='rate', colour=category.name));
  if (use.log2) {
    p = p + scale_x_continuous(trans='log2');
  }
  p = p + geom_errorbar(
    aes(ymin=rate-confidence.interval, ymax=rate+confidence.interval),
    width=.1, na.rm=TRUE
  );
  p = p + geom_point();
  p = p + geom_line();
  p = p + ylab("rate of operations (higher is better)");
  p = p + ggtitle(dat[1, 1]);
  ggsave(plot.filename, p);
}
                                                                                                                                          node-23.7.0/benchmark/scatter.js                                                                    0000664 0000000 0000000 00000003502 14746647661 0016512 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const fork = require('child_process').fork;
const path = require('path');
const CLI = require('./_cli.js');

//
// Parse arguments
//
const cli = new CLI(`usage: ./node scatter.js [options] [--] <filename>
  Run the benchmark script <filename> many times and output the rate (ops/s)
  together with the benchmark variables as a csv.

  --runs 30              number of samples
  --set  variable=value  set benchmark variable (can be repeated)
`, { arrayArgs: ['set'] });

if (cli.items.length !== 1) {
  cli.abort(cli.usage);
}

// Create queue from the benchmarks list such both node versions are tested
// `runs` amount of times each.
const filepath = path.resolve(cli.items[0]);
const name = filepath.slice(__dirname.length + 1);
const runs = cli.optional.runs ? parseInt(cli.optional.runs, 10) : 30;

let printHeader = true;

function csvEncodeValue(value) {
  if (typeof value === 'number') {
    return value.toString();
  }
  return `"${value.replace(/"/g, '""')}"`;
}

(function recursive(i) {
  const child = fork(path.resolve(__dirname, filepath), cli.optional.set);

  child.on('message', (data) => {
    if (data.type !== 'report') {
      return;
    }

    // print csv header
    if (printHeader) {
      const confHeader = Object.keys(data.conf)
        .map(csvEncodeValue)
        .join(', ');
      console.log(`"filename", ${confHeader}, "rate", "time"`);
      printHeader = false;
    }

    // print data row
    const confData = Object.keys(data.conf)
      .map((key) => csvEncodeValue(data.conf[key]))
      .join(', ');

    console.log(`"${name}", ${confData}, ${data.rate}, ${data.time}`);
  });

  child.once('close', (code) => {
    if (code) {
      process.exit(code);
      return;
    }

    // If there are more benchmarks execute the next
    if (i + 1 < runs) {
      recursive(i + 1);
    }
  });
})(0);
                                                                                                                                                                                              node-23.7.0/benchmark/streams/                                                                      0000775 0000000 0000000 00000000000 14746647661 0016165 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/streams/compose.js                                                            0000664 0000000 0000000 00000001730 14746647661 0020171 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const {
  PassThrough,
  Readable,
  Writable,
  compose,
} = require('node:stream');

const bench = common.createBenchmark(main, {
  n: [1e3],
});

function main({ n }) {
  const cachedPassThroughs = [];
  const cachedReadables = [];
  const cachedWritables = [];

  for (let i = 0; i < n; i++) {
    const numberOfPassThroughs = 100;
    const passThroughs = [];

    for (let i = 0; i < numberOfPassThroughs; i++) {
      passThroughs.push(new PassThrough());
    }

    const readable = Readable.from(['hello', 'world']);
    const writable = new Writable({ objectMode: true, write: (chunk, encoding, cb) => cb() });

    cachedPassThroughs.push(passThroughs);
    cachedReadables.push(readable);
    cachedWritables.push(writable);
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    const composed = compose(cachedReadables[i], ...cachedPassThroughs[i], cachedWritables[i]);
    composed.end();
  }
  bench.end(n);
}
                                        node-23.7.0/benchmark/streams/creation.js                                                           0000664 0000000 0000000 00000002062 14746647661 0020327 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const {
  Duplex,
  Readable,
  Transform,
  Writable,
} = require('stream');

const bench = common.createBenchmark(main, {
  n: [50e6],
  kind: ['duplex', 'readable', 'transform', 'writable'],
});

function main({ n, kind }) {
  switch (kind) {
    case 'duplex':
      new Duplex({});
      new Duplex();

      bench.start();
      for (let i = 0; i < n; ++i)
        new Duplex();
      bench.end(n);
      break;
    case 'readable':
      new Readable({});
      new Readable();

      bench.start();
      for (let i = 0; i < n; ++i)
        new Readable();
      bench.end(n);
      break;
    case 'writable':
      new Writable({});
      new Writable();

      bench.start();
      for (let i = 0; i < n; ++i)
        new Writable();
      bench.end(n);
      break;
    case 'transform':
      new Transform({});
      new Transform();

      bench.start();
      for (let i = 0; i < n; ++i)
        new Transform();
      bench.end(n);
      break;
    default:
      throw new Error('Invalid kind');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/benchmark/streams/destroy.js                                                            0000664 0000000 0000000 00000002131 14746647661 0020211 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const {
  Duplex,
  Readable,
  Transform,
  Writable,
} = require('stream');

const bench = common.createBenchmark(main, {
  n: [1e6],
  kind: ['duplex', 'readable', 'transform', 'writable'],
});

function main({ n, kind }) {
  switch (kind) {
    case 'duplex':
      new Duplex({});
      new Duplex();

      bench.start();
      for (let i = 0; i < n; ++i)
        new Duplex().destroy();
      bench.end(n);
      break;
    case 'readable':
      new Readable({});
      new Readable();

      bench.start();
      for (let i = 0; i < n; ++i)
        new Readable().destroy();
      bench.end(n);
      break;
    case 'writable':
      new Writable({});
      new Writable();

      bench.start();
      for (let i = 0; i < n; ++i)
        new Writable().destroy();
      bench.end(n);
      break;
    case 'transform':
      new Transform({});
      new Transform();

      bench.start();
      for (let i = 0; i < n; ++i)
        new Transform().destroy();
      bench.end(n);
      break;
    default:
      throw new Error('Invalid kind');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/benchmark/streams/pipe-object-mode.js                                                   0000664 0000000 0000000 00000000731 14746647661 0021647 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Readable, Writable } = require('stream');

const bench = common.createBenchmark(main, {
  n: [5e6],
});

function main({ n }) {
  const b = {};
  const r = new Readable({ objectMode: true });
  const w = new Writable({ objectMode: true });

  let i = 0;

  r._read = () => r.push(i++ === n ? null : b);
  w._write = (data, enc, cb) => cb();

  bench.start();

  r.pipe(w);
  w.on('finish', () => bench.end(n));
}
                                       node-23.7.0/benchmark/streams/pipe.js                                                               0000664 0000000 0000000 00000000701 14746647661 0017456 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { Readable, Writable } = require('stream');

const bench = common.createBenchmark(main, {
  n: [5e6],
});

function main({ n }) {
  const b = Buffer.alloc(1024);
  const r = new Readable();
  const w = new Writable();

  let i = 0;

  r._read = () => r.push(i++ === n ? null : b);
  w._write = (data, enc, cb) => cb();

  bench.start();

  r.pipe(w);
  w.on('finish', () => bench.end(n));
}
                                                               node-23.7.0/benchmark/streams/readable-async-iterator.js                                            0000664 0000000 0000000 00000001250 14746647661 0023222 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const Readable = require('stream').Readable;

const bench = common.createBenchmark(main, {
  n: [1e5],
  sync: ['yes', 'no'],
});

async function main({ n, sync }) {
  sync = sync === 'yes';

  const s = new Readable({
    objectMode: true,
    read() {
      if (sync) {
        this.push(1);
      } else {
        process.nextTick(() => {
          this.push(1);
        });
      }
    },
  });

  bench.start();

  let x = 0;
  for await (const chunk of s) {
    x += chunk;
    if (x > n) {
      break;
    }
  }

  // Use x to ensure V8 does not optimize away the loop as a noop.
  console.assert(x);

  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/streams/readable-bigread.js                                                   0000664 0000000 0000000 00000000654 14746647661 0021662 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const Readable = require('stream').Readable;

const bench = common.createBenchmark(main, {
  n: [1e3],
});

function main({ n }) {
  const b = Buffer.alloc(32);
  const s = new Readable();
  function noop() {}
  s._read = noop;

  bench.start();
  for (let k = 0; k < n; ++k) {
    for (let i = 0; i < 1e3; ++i)
      s.push(b);
    while (s.read(128));
  }
  bench.end(n);
}
                                                                                    node-23.7.0/benchmark/streams/readable-bigunevenread.js                                             0000664 0000000 0000000 00000000654 14746647661 0023103 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const Readable = require('stream').Readable;

const bench = common.createBenchmark(main, {
  n: [1e3],
});

function main({ n }) {
  const b = Buffer.alloc(32);
  const s = new Readable();
  function noop() {}
  s._read = noop;

  bench.start();
  for (let k = 0; k < n; ++k) {
    for (let i = 0; i < 1e4; ++i)
      s.push(b);
    while (s.read(106));
  }
  bench.end(n);
}
                                                                                    node-23.7.0/benchmark/streams/readable-boundaryread.js                                              0000664 0000000 0000000 00000000776 14746647661 0022751 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const Readable = require('stream').Readable;

const bench = common.createBenchmark(main, {
  n: [200e1],
  type: ['string', 'buffer'],
});

function main({ n, type }) {
  const s = new Readable();
  let data = 'a'.repeat(32);
  if (type === 'buffer')
    data = Buffer.from(data);
  s._read = function() {};

  bench.start();
  for (let k = 0; k < n; ++k) {
    for (let i = 0; i < 1e4; ++i)
      s.push(data);
    while (s.read(32));
  }
  bench.end(n);
}
  node-23.7.0/benchmark/streams/readable-from.js                                                      0000664 0000000 0000000 00000002435 14746647661 0021227 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const Readable = require('stream').Readable;

const bench = common.createBenchmark(main, {
  n: [1e7],
  type: ['array', 'sync-generator-with-sync-values', 'sync-generator-with-async-values', 'async-generator'],
});

async function main({ n, type }) {
  let fromArg;

  switch (type) {
    case 'array': {
      fromArg = [];
      for (let i = 0; i < n; i++) {
        fromArg.push(`${i}`);
      }

      break;
    }

    case 'sync-generator-with-sync-values': {
      fromArg = (function* () {
        for (let i = 0; i < n; i++) {
          yield `${i}`;
        }
      })();

      break;
    }

    case 'sync-generator-with-async-values': {
      fromArg = (function* () {
        for (let i = 0; i < n; i++) {
          yield Promise.resolve(`${i}`);
        }
      })();

      break;
    }

    case 'async-generator': {
      fromArg = (async function* () {
        for (let i = 0; i < n; i++) {
          yield `${i}`;
        }
      })();

      break;
    }

    default: {
      throw new Error(`Unknown type: ${type}`);
    }
  }

  const s = new Readable.from(fromArg);

  bench.start();
  s.on('data', (data) => {
    // eslint-disable-next-line no-unused-expressions
    data;
  });
  s.on('close', () => {
    bench.end(n);
  });
}
                                                                                                                                                                                                                                   node-23.7.0/benchmark/streams/readable-readall.js                                                   0000664 0000000 0000000 00000000652 14746647661 0021667 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const Readable = require('stream').Readable;

const bench = common.createBenchmark(main, {
  n: [50e2],
});

function main({ n }) {
  const b = Buffer.alloc(32);
  const s = new Readable();
  function noop() {}
  s._read = noop;

  bench.start();
  for (let k = 0; k < n; ++k) {
    for (let i = 0; i < 1e3; ++i)
      s.push(b);
    while (s.read());
  }
  bench.end(n);
}
                                                                                      node-23.7.0/benchmark/streams/readable-uint8array.js                                                0000664 0000000 0000000 00000001415 14746647661 0022367 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { Readable } = require('stream');

const bench = common.createBenchmark(main, {
  n: [1e6],
  kind: ['read', 'encoding'],
});
const ABC = new Uint8Array([0x41, 0x42, 0x43]);

function main({ n, kind }) {
  switch (kind) {
    case 'read': {
      bench.start();
      const readable = new Readable({
        read() {},
      });
      for (let i = 0; i < n; ++i) readable.push(ABC);
      bench.end(n);
      break;
    }

    case 'encoding': {
      bench.start();
      const readable = new Readable({
        read() {},
      });
      readable.setEncoding('utf8');
      for (let i = 0; i < n; ++i) readable.push(ABC);
      bench.end(n);
      break;
    }
    default:
      throw new Error('Invalid kind');
  }
}
                                                                                                                                                                                                                                                   node-23.7.0/benchmark/streams/readable-unevenread.js                                                0000664 0000000 0000000 00000000653 14746647661 0022420 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const Readable = require('stream').Readable;

const bench = common.createBenchmark(main, {
  n: [1e3],
});

function main({ n }) {
  const b = Buffer.alloc(32);
  const s = new Readable();
  function noop() {}
  s._read = noop;

  bench.start();
  for (let k = 0; k < n; ++k) {
    for (let i = 0; i < 1e4; ++i)
      s.push(b);
    while (s.read(12));
  }
  bench.end(n);
}
                                                                                     node-23.7.0/benchmark/streams/writable-manywrites.js                                                0000664 0000000 0000000 00000001641 14746647661 0022536 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const Writable = require('stream').Writable;

const bench = common.createBenchmark(main, {
  n: [1e5],
  sync: ['yes', 'no'],
  writev: ['yes', 'no'],
  callback: ['yes', 'no'],
  len: [1024, 32 * 1024],
});

function main({ n, sync, writev, callback, len }) {
  const b = Buffer.allocUnsafe(len);
  const s = new Writable({ highWaterMark: 16 * 1024 });
  sync = sync === 'yes';

  const writecb = (cb) => {
    if (sync)
      cb();
    else
      process.nextTick(cb);
  };

  if (writev === 'yes') {
    s._writev = (chunks, cb) => writecb(cb);
  } else {
    s._write = (chunk, encoding, cb) => writecb(cb);
  }

  const cb = callback === 'yes' ? () => {} : null;

  bench.start();

  let k = 0;
  function run() {
    while (k++ < n && s.write(b, cb));
    if (k >= n) {
      bench.end(n);
      s.removeListener('drain', run);
    }
  }
  s.on('drain', run);
  run();
}
                                                                                               node-23.7.0/benchmark/streams/writable-uint8array.js                                                0000664 0000000 0000000 00000002076 14746647661 0022445 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { Writable } = require('stream');

const bench = common.createBenchmark(main, {
  n: [50e6],
  kind: ['write', 'object-mode', 'writev'],
});
const ABC = new Uint8Array([0x41, 0x42, 0x43]);

function main({ n, kind }) {
  switch (kind) {
    case 'write': {
      bench.start();
      const wr = new Writable({
        write(chunk, encoding, cb) {
          cb();
        },
      });
      for (let i = 0; i < n; ++i) wr.write(ABC);
      bench.end(n);
      break;
    }

    case 'object-mode': {
      bench.start();
      const wr = new Writable({
        objectMode: true,
        write(chunk, encoding, cb) {
          cb();
        },
      });
      for (let i = 0; i < n; ++i) wr.write(ABC);
      bench.end(n);
      break;
    }
    case 'writev': {
      bench.start();
      const wr = new Writable({
        writev(chunks, cb) {
          cb();
        },
      });
      for (let i = 0; i < n; ++i) wr.write(ABC);
      bench.end(n);
      break;
    }
    default:
      throw new Error('Invalid kind');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/string_decoder/                                                               0000775 0000000 0000000 00000000000 14746647661 0017502 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/string_decoder/string-decoder-create.js                                       0000664 0000000 0000000 00000000637 14746647661 0024220 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const StringDecoder = require('string_decoder').StringDecoder;

const bench = common.createBenchmark(main, {
  encoding: [
    'ascii', 'utf8', 'utf-8', 'base64', 'ucs2', 'UTF-8', 'AscII', 'UTF-16LE',
  ],
  n: [25e6],
});

function main({ encoding, n }) {
  bench.start();
  for (let i = 0; i < n; ++i) {
    new StringDecoder(encoding);
  }
  bench.end(n);
}
                                                                                                 node-23.7.0/benchmark/string_decoder/string-decoder.js                                              0000664 0000000 0000000 00000004145 14746647661 0022755 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const StringDecoder = require('string_decoder').StringDecoder;

const bench = common.createBenchmark(main, {
  encoding: ['ascii', 'utf8', 'base64-utf8', 'base64-ascii', 'utf16le'],
  inLen: [32, 128, 1024, 4096],
  chunkLen: [16, 64, 256, 1024],
  n: [25e5],
});

const UTF8_ALPHA = 'Blåbærsyltetøy';
const ASC_ALPHA = 'Blueberry jam';
const UTF16_BUF = Buffer.from('Blåbærsyltetøy', 'utf16le');

function main({ encoding, inLen, chunkLen, n }) {
  let alpha;
  let buf;
  const chunks = [];
  let str = '';
  const isBase64 = (encoding === 'base64-ascii' || encoding === 'base64-utf8');

  if (encoding === 'ascii' || encoding === 'base64-ascii')
    alpha = ASC_ALPHA;
  else if (encoding === 'utf8' || encoding === 'base64-utf8')
    alpha = UTF8_ALPHA;
  else if (encoding === 'utf16le') {
    buf = UTF16_BUF;
    str = Buffer.alloc(0);
  } else
    throw new Error('Bad encoding');

  const sd = new StringDecoder(isBase64 ? 'base64' : encoding);

  for (let i = 0; i < inLen; ++i) {
    if (i > 0 && (i % chunkLen) === 0 && !isBase64) {
      if (alpha) {
        chunks.push(Buffer.from(str, encoding));
        str = '';
      } else {
        chunks.push(str);
        str = Buffer.alloc(0);
      }
    }
    if (alpha)
      str += alpha[i % alpha.length];
    else {
      let start = i;
      let end = i + 2;
      if (i % 2 !== 0) {
        ++start;
        ++end;
      }
      str = Buffer.concat([
        str,
        buf.slice(start % buf.length, end % buf.length),
      ]);
    }
  }

  if (!alpha) {
    if (str.length > 0)
      chunks.push(str);
  } else if (str.length > 0 && !isBase64)
    chunks.push(Buffer.from(str, encoding));

  if (isBase64) {
    str = Buffer.from(str, 'utf8').toString('base64');
    while (str.length > 0) {
      const len = Math.min(chunkLen, str.length);
      chunks.push(Buffer.from(str.substring(0, len), 'utf8'));
      str = str.substring(len);
    }
  }

  const nChunks = chunks.length;

  bench.start();
  for (let i = 0; i < n; ++i) {
    for (let j = 0; j < nChunks; ++j)
      sd.write(chunks[j]);
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/benchmark/test_runner/                                                                  0000775 0000000 0000000 00000000000 14746647661 0017057 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/test_runner/global-concurrent-tests.js                                        0000664 0000000 0000000 00000001663 14746647661 0024203 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { it } = require('node:test');

const bench = common.createBenchmark(main, {
  n: [100, 1000, 1e4],
  type: ['sync', 'async'],
}, {
  // We don't want to test the reporter here
  flags: ['--test-reporter=./benchmark/fixtures/empty-test-reporter.js'],
});

async function run(n, type) {
  const promises = new Array(n);

  // eslint-disable-next-line no-unused-vars
  let avoidV8Optimization;

  switch (type) {
    case 'sync': {
      for (let i = 0; i < n; i++) {
        promises[i] = it(`${i}`, () => {
          avoidV8Optimization = i;
        });
      }
      break;
    }

    case 'async':
      for (let i = 0; i < n; i++) {
        promises[i] = it(`${i}`, async () => {
          avoidV8Optimization = i;
        });
      }
      break;
  }

  await Promise.all(promises);
}

function main({ n, type }) {
  bench.start();
  run(n, type).then(() => {
    bench.end(n);
  });
}
                                                                             node-23.7.0/benchmark/test_runner/global-sequential-tests.js                                        0000664 0000000 0000000 00000001627 14746647661 0024173 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { it } = require('node:test');


const bench = common.createBenchmark(main, {
  n: [100, 1000, 1e4],
  type: ['sync', 'async'],
}, {
  // We don't want to test the reporter here
  flags: ['--test-reporter=./benchmark/fixtures/empty-test-reporter.js'],
});

async function run(n, type) {
  // eslint-disable-next-line no-unused-vars
  let avoidV8Optimization;

  const promises = new Array(n);
  switch (type) {
    case 'sync': {
      for (let i = 0; i < n; i++) {
        await it(`${i}`, () => {
          avoidV8Optimization = i;
        });
      }
      break;
    }

    case 'async':
      for (let i = 0; i < n; i++) {
        await it(`${i}`, async () => {
          avoidV8Optimization = i;
        });
      }
      break;
  }

  await Promise.all(promises);
}

function main({ n }) {
  bench.start();
  run(n).then(() => {
    bench.end(n);
  });
}
                                                                                                         node-23.7.0/benchmark/test_runner/mock-fn.js                                                        0000664 0000000 0000000 00000001707 14746647661 0020754 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('node:assert');
const { test } = require('node:test');

const bench = common.createBenchmark(main, {
  n: [1e6],
  mode: ['define', 'execute'],
}, {
  // We don't want to test the reporter here
  flags: ['--test-reporter=./benchmark/fixtures/empty-test-reporter.js'],
});

const noop = () => {};

function benchmarkDefine(n) {
  let noDead;
  test((t) => {
    bench.start();
    for (let i = 0; i < n; i++) {
      noDead = t.mock.fn(noop);
    }
    bench.end(n);
    assert.ok(noDead);
  });
}

function benchmarkExecute(n) {
  let noDead;
  test((t) => {
    const mocked = t.mock.fn(noop);
    bench.start();
    for (let i = 0; i < n; i++) {
      noDead = mocked();
    }
    bench.end(n);
    assert.strictEqual(noDead, noop());
  });
}

function main({ n, mode }) {
  if (mode === 'define') {
    benchmarkDefine(n);
  } else if (mode === 'execute') {
    benchmarkExecute(n);
  }
}
                                                         node-23.7.0/benchmark/test_runner/run-single-test-file.js                                           0000664 0000000 0000000 00000003322 14746647661 0023372 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

const tmpdir = require('../../test/common/tmpdir');
const { run } = require('node:test');
const { writeFileSync, mkdirSync } = require('node:fs');
const { join } = require('node:path');

const fixtureContent = "const test = require('node:test'); test('test has ran');";

function makeTestDirWithFiles(dirPath, count) {
  mkdirSync(dirPath);
  for (let i = 0; i < count; i++) {
    writeFileSync(join(dirPath, `test-${i}.js`), fixtureContent);
  }
}

function getTestDirPath(numberOfTestFiles) {
  return join(tmpdir.path, `${numberOfTestFiles}-tests`);
}

function setup(numberOfTestFiles) {
  tmpdir.refresh();
  const dirPath = getTestDirPath(numberOfTestFiles);
  makeTestDirWithFiles(dirPath, numberOfTestFiles);
}

/**
 * This benchmark evaluates the overhead of running a single test file under different
 * isolation modes.
 * Specifically, it compares the performance of running tests in the
 * same process versus creating multiple processes.
 */
const bench = common.createBenchmark(main, {
  numberOfTestFiles: [1, 10, 100],
  isolation: ['none', 'process'],
}, {
  // We don't want to test the reporter here
  flags: ['--test-reporter=./benchmark/fixtures/empty-test-reporter.js'],
});

async function runBenchmark({ numberOfTestFiles, isolation }) {
  const dirPath = getTestDirPath(numberOfTestFiles);
  const stream = run({
    cwd: dirPath,
    isolation,
    concurrency: false, // We don't want to run tests concurrently
  });

  // eslint-disable-next-line no-unused-vars
  for await (const _ of stream);

  return numberOfTestFiles;
}

function main(params) {
  setup(params.numberOfTestFiles);
  bench.start();
  runBenchmark(params).then(() => {
    bench.end(1);
  });
}
                                                                                                                                                                                                                                                                                                              node-23.7.0/benchmark/test_runner/suite-tests.js                                                    0000664 0000000 0000000 00000002771 14746647661 0021715 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const { finished } = require('node:stream/promises');

const reporter = require('../fixtures/empty-test-reporter');

const { describe, it } = require('node:test');

const bench = common.createBenchmark(main, {
  numberOfSuites: [10, 100],
  testsPerSuite: [10, 100, 1000],
  testType: ['sync', 'async'],
  concurrency: ['yes', 'no'],
}, {
  // We don't want to test the reporter here
  flags: ['--test-reporter=./benchmark/fixtures/empty-test-reporter.js'],
});

async function run({ numberOfSuites, testsPerSuite, testType, concurrency }) {
  concurrency = concurrency === 'yes';

  // eslint-disable-next-line no-unused-vars
  let avoidV8Optimization;

  switch (testType) {
    case 'sync': {
      for (let i = 0; i < numberOfSuites; i++) {
        describe(`${i}`, { concurrency }, () => {
          for (let j = 0; j < testsPerSuite; j++) {
            it(`${j}`, () => {
              avoidV8Optimization = i;
            });
          }
        });
      }

      break;
    }

    case 'async': {
      for (let i = 0; i < numberOfSuites; i++) {
        describe(`${i}`, { concurrency }, () => {
          for (let j = 0; j < testsPerSuite; j++) {
            it(`${j}`, async () => {
              avoidV8Optimization = i;
            });
          }
        });
      }

      break;
    }
  }

  await finished(reporter);

  return numberOfSuites * testsPerSuite;
}

function main(params) {
  bench.start();
  run(params).then((ops) => {
    bench.end(ops);
  });
}
       node-23.7.0/benchmark/test_runner/test-reporters.js                                                 0000664 0000000 0000000 00000001754 14746647661 0022426 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { run } = require('node:test');
const reporters = require('node:test/reporters');
const { Readable } = require('node:stream');
const assert = require('node:assert');

const bench = common.createBenchmark(main, {
  n: [1e4],
  reporter: Object.keys(reporters),
});

// No need to run this for every benchmark,
// it should always be the same data.
const stream = run({
  files: ['../fixtures/basic-test-runner.js'],
});
let testResults;

async function main({ n, reporter: r }) {
  testResults ??= await stream.toArray();

  // Create readable streams for each iteration
  const readables = Array.from({ length: n }, () => Readable.from(testResults));

  // Get the selected reporter
  const reporter = reporters[r];

  bench.start();

  let noDead;
  for (const readable of readables) {
    // Process each readable stream through the reporter
    noDead = await readable.compose(reporter).toArray();
  }

  bench.end(n);

  assert.ok(noDead);
}
                    node-23.7.0/benchmark/timers/                                                                       0000775 0000000 0000000 00000000000 14746647661 0016012 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/timers/immediate.js                                                           0000664 0000000 0000000 00000003560 14746647661 0020312 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [5e6],
  type: ['depth', 'depth1', 'breadth', 'breadth1', 'breadth4', 'clear'],
});

function main({ n, type }) {
  switch (type) {
    case 'depth':
      depth(n);
      break;
    case 'depth1':
      depth1(n);
      break;
    case 'breadth':
      breadth(n);
      break;
    case 'breadth1':
      breadth1(n);
      break;
    case 'breadth4':
      breadth4(n);
      break;
    case 'clear':
      clear(n);
      break;
  }
}

// setImmediate tail recursion, 0 arguments
function depth(N) {
  let n = 0;
  bench.start();
  setImmediate(cb);
  function cb() {
    n++;
    if (n === N)
      bench.end(n);
    else
      setImmediate(cb);
  }
}

// setImmediate tail recursion, 1 argument
function depth1(N) {
  let n = 0;
  bench.start();
  setImmediate(cb, 1);
  function cb(a1) {
    n++;
    if (n === N)
      bench.end(N);
    else
      setImmediate(cb, 1);
  }
}

// Concurrent setImmediate, 0 arguments
function breadth(N) {
  let n = 0;
  bench.start();
  function cb() {
    n++;
    if (n === N)
      bench.end(N);
  }
  for (let i = 0; i < N; i++) {
    setImmediate(cb);
  }
}

// Concurrent setImmediate, 1 argument
function breadth1(N) {
  let n = 0;
  bench.start();
  function cb(a1) {
    n++;
    if (n === N)
      bench.end(n);
  }
  for (let i = 0; i < N; i++) {
    setImmediate(cb, 1);
  }
}

// Concurrent setImmediate, 4 arguments
function breadth4(N) {
  N /= 2;
  let n = 0;
  bench.start();
  function cb(a1, a2, a3, a4) {
    n++;
    if (n === N)
      bench.end(n);
  }
  for (let i = 0; i < N; i++) {
    setImmediate(cb, 1, 2, 3, 4);
  }
}

function clear(N) {
  N *= 4;
  bench.start();
  function cb(a1) {
    if (a1 === 2)
      bench.end(N);
  }
  for (let i = 0; i < N; i++) {
    clearImmediate(setImmediate(cb, 1));
  }
  setImmediate(cb, 2);
}
                                                                                                                                                node-23.7.0/benchmark/timers/set-immediate-breadth-args.js                                          0000664 0000000 0000000 00000001020 14746647661 0023431 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [5e6],
});

function main({ n }) {

  process.on('exit', () => {
    bench.end(n);
  });

  function cb1(arg1) {}

  function cb2(arg1, arg2) {}

  function cb3(arg1, arg2, arg3) {}

  bench.start();
  for (let i = 0; i < n; i++) {
    if (i % 3 === 0)
      setImmediate(cb3, 512, true, null, 512, true, null);
    else if (i % 2 === 0)
      setImmediate(cb2, false, 5.1, 512);
    else
      setImmediate(cb1, 0);
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/benchmark/timers/set-immediate-breadth.js                                               0000664 0000000 0000000 00000000444 14746647661 0022510 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [1e7],
});

function main({ n }) {

  process.on('exit', () => {
    bench.end(n);
  });

  function cb() {}

  bench.start();
  for (let i = 0; i < n; i++) {
    setImmediate(cb);
  }
}
                                                                                                                                                                                                                            node-23.7.0/benchmark/timers/set-immediate-depth-args.js                                            0000664 0000000 0000000 00000001711 14746647661 0023133 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [5e6],
});

function main({ n }) {

  process.on('exit', () => {
    bench.end(n);
  });

  function cb3(n, arg2, arg3) {
    if (--n) {
      if (n % 3 === 0)
        setImmediate(cb3, n, true, null, 5.1, null, true);
      else if (n % 2 === 0)
        setImmediate(cb2, n, 5.1, true);
      else
        setImmediate(cb1, n);
    }
  }

  function cb2(n, arg2) {
    if (--n) {
      if (n % 3 === 0)
        setImmediate(cb3, n, true, null, 5.1, null, true);
      else if (n % 2 === 0)
        setImmediate(cb2, n, 5.1, true);
      else
        setImmediate(cb1, n);
    }
  }

  function cb1(n) {
    if (--n) {
      if (n % 3 === 0)
        setImmediate(cb3, n, true, null, 5.1, null, true);
      else if (n % 2 === 0)
        setImmediate(cb2, n, 5.1, true);
      else
        setImmediate(cb1, n);
    }
  }
  bench.start();
  setImmediate(cb1, n);
}
                                                       node-23.7.0/benchmark/timers/timers-breadth-args.js                                                 0000664 0000000 0000000 00000001417 14746647661 0022217 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [1e6],
});

function main({ n }) {
  let j = 0;
  function cb1(arg1) {
    j++;
    if (j === n)
      bench.end(n);
  }

  function cb2(arg1, arg2) {
    j++;
    if (j === n)
      bench.end(n);
  }

  function cb3(arg1, arg2, arg3) {
    j++;
    if (j === n)
      bench.end(n);
  }

  function cb4(arg1, arg2, arg3, arg4) {
    j++;
    if (j === n)
      bench.end(n);
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    if (i % 4 === 0)
      setTimeout(cb4, 1, 3.14, 1024, true, false);
    else if (i % 3 === 0)
      setTimeout(cb3, 1, 512, true, null);
    else if (i % 2 === 0)
      setTimeout(cb2, 1, false, 5.1);
    else
      setTimeout(cb1, 1, 0);
  }
}
                                                                                                                                                                                                                                                 node-23.7.0/benchmark/timers/timers-breadth.js                                                      0000664 0000000 0000000 00000000453 14746647661 0021264 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [5e6],
});

function main({ n }) {
  let j = 0;
  bench.start();
  function cb() {
    j++;
    if (j === n)
      bench.end(n);
  }
  for (let i = 0; i < n; i++) {
    setTimeout(cb, 1);
  }
}
                                                                                                                                                                                                                     node-23.7.0/benchmark/timers/timers-cancel-pooled.js                                                0000664 0000000 0000000 00000001033 14746647661 0022353 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [5e6],
});

function main({ n }) {

  let timer = setTimeout(() => {}, 1);
  for (let i = 0; i < n; i++) {
    setTimeout(cb, 1);
  }
  let next = timer._idlePrev;
  clearTimeout(timer);

  bench.start();

  for (let j = 0; j < n; j++) {
    timer = next;
    next = timer._idlePrev;
    clearTimeout(timer);
  }

  bench.end(n);
}

function cb() {
  assert.fail('Timer should not call callback');
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/benchmark/timers/timers-cancel-unpooled.js                                              0000664 0000000 0000000 00000001210 14746647661 0022713 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [1e6],
  direction: ['start', 'end'],
});

function main({ n, direction }) {

  const timersList = [];
  for (let i = 0; i < n; i++) {
    timersList.push(setTimeout(cb, i + 1));
  }

  bench.start();
  if (direction === 'start') {
    for (let j = 0; j < n; j++) {
      clearTimeout(timersList[j]);
    }
  } else {
    for (let j = n - 1; j >= 0; j--) {
      clearTimeout(timersList[j]);
    }
  }
  bench.end(n);
}

function cb() {
  assert.fail(`Timer ${this._idleTimeout} should not call callback`);
}
                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/timers/timers-depth.js                                                        0000664 0000000 0000000 00000000447 14746647661 0020762 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [1e3],
});

function main({ n }) {
  let i = 0;
  bench.start();
  setTimeout(cb, 1);
  function cb() {
    i++;
    if (i === n)
      bench.end(n);
    else
      setTimeout(cb, 1);
  }
}
                                                                                                                                                                                                                         node-23.7.0/benchmark/timers/timers-insert-pooled.js                                                0000664 0000000 0000000 00000000363 14746647661 0022437 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [5e6],
});

function main({ n }) {

  bench.start();

  for (let i = 0; i < n; i++) {
    setTimeout(() => {}, 1);
  }

  bench.end(n);
}
                                                                                                                                                                                                                                                                             node-23.7.0/benchmark/timers/timers-insert-unpooled.js                                              0000664 0000000 0000000 00000001207 14746647661 0023000 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [1e6],
  direction: ['start', 'end'],
});

function main({ direction, n }) {
  const timersList = [];

  bench.start();
  if (direction === 'start') {
    for (let i = 1; i <= n; i++) {
      timersList.push(setTimeout(cb, i));
    }
  } else {
    for (let i = n; i > 0; i--) {
      timersList.push(setTimeout(cb, i));
    }
  }
  bench.end(n);

  for (let j = 0; j < n; j++) {
    clearTimeout(timersList[j]);
  }
}

function cb() {
  assert.fail(`Timer ${this._idleTimeout} should not call callback`);
}
                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/timers/timers-timeout-nexttick.js                                             0000664 0000000 0000000 00000001462 14746647661 0023171 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

// The following benchmark measures setting up n * 1e6 timeouts,
// as well as scheduling a next tick from each timeout. Those
// then get executed on the next uv tick.

const bench = common.createBenchmark(main, {
  n: [5e4, 5e6],
});

function main({ n }) {
  let count = 0;

  // Function tracking on the hidden class in V8 can cause misleading
  // results in this benchmark if only a single function is used —
  // alternate between two functions for a fairer benchmark.

  function cb() {
    process.nextTick(counter);
  }

  function cb2() {
    process.nextTick(counter);
  }

  function counter() {
    count++;
    if (count === n)
      bench.end(n);
  }

  for (let i = 0; i < n; i++) {
    setTimeout(i % 2 ? cb : cb2, 1);
  }

  bench.start();
}
                                                                                                                                                                                                              node-23.7.0/benchmark/timers/timers-timeout-pooled.js                                               0000664 0000000 0000000 00000001317 14746647661 0022621 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

// The following benchmark measures setting up n * 1e6 timeouts,
// which then get executed on the next uv tick

const bench = common.createBenchmark(main, {
  n: [1e7],
});

function main({ n }) {
  let count = 0;

  // Function tracking on the hidden class in V8 can cause misleading
  // results in this benchmark if only a single function is used —
  // alternate between two functions for a fairer benchmark

  function cb() {
    count++;
    if (count === n)
      bench.end(n);
  }

  function cb2() {
    count++;
    if (count === n)
      bench.end(n);
  }

  for (let i = 0; i < n; i++) {
    setTimeout(i % 2 ? cb : cb2, 1);
  }

  bench.start();
}
                                                                                                                                                                                                                                                                                                                 node-23.7.0/benchmark/timers/timers-timeout-unpooled.js                                             0000664 0000000 0000000 00000001471 14746647661 0023165 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

// The following benchmark sets up n * 1e6 unpooled timeouts,
// then measures their execution on the next uv tick

const bench = common.createBenchmark(main, {
  n: [1e6],
});

function main({ n }) {
  let count = 0;

  // Function tracking on the hidden class in V8 can cause misleading
  // results in this benchmark if only a single function is used —
  // alternate between two functions for a fairer benchmark

  function cb() {
    count++;
    if (count === n)
      bench.end(n);
  }

  function cb2() {
    count++;
    if (count === n)
      bench.end(n);
  }

  for (let i = 0; i < n; i++) {
    // unref().ref() will cause each of these timers to
    // allocate their own handle
    setTimeout(i % 2 ? cb : cb2, 1).unref().ref();
  }

  bench.start();
}
                                                                                                                                                                                                       node-23.7.0/benchmark/tls/                                                                          0000775 0000000 0000000 00000000000 14746647661 0015311 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/tls/convertprotocols.js                                                       0000664 0000000 0000000 00000000670 14746647661 0021277 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const tls = require('tls');

const bench = common.createBenchmark(main, {
  n: [1, 50000],
});

function main({ n }) {
  const input = ['ABC', 'XYZ123', 'FOO'];
  let m = {};
  // First call dominates results
  if (n > 1) {
    tls.convertALPNProtocols(input, m);
    m = {};
  }
  bench.start();
  for (let i = 0; i < n; i++)
    tls.convertALPNProtocols(input, m);
  bench.end(n);
}
                                                                        node-23.7.0/benchmark/tls/secure-pair.js                                                            0000664 0000000 0000000 00000005653 14746647661 0020077 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const bench = common.createBenchmark(main, {
  dur: [5],
  securing: ['SecurePair', 'TLSSocket', 'clear'],
  size: [100, 1024, 1024 * 1024],
}, {
  flags: ['--no-warnings'],
});

const fixtures = require('../../test/common/fixtures');
const tls = require('tls');
const net = require('net');

const REDIRECT_PORT = 28347;

function main({ dur, size, securing }) {
  const chunk = Buffer.alloc(size, 'b');

  const options = {
    key: fixtures.readKey('rsa_private.pem'),
    cert: fixtures.readKey('rsa_cert.crt'),
    ca: fixtures.readKey('rsa_ca.crt'),
    ciphers: 'AES256-GCM-SHA384',
    isServer: true,
    requestCert: true,
    rejectUnauthorized: true,
    maxVersion: 'TLSv1.2',
  };

  const server = net.createServer(onRedirectConnection);
  server.listen(REDIRECT_PORT, () => {
    const proxy = net.createServer(onProxyConnection);
    proxy.listen(common.PORT, () => {
      const clientOptions = {
        port: common.PORT,
        ca: options.ca,
        key: options.key,
        cert: options.cert,
        isServer: false,
        rejectUnauthorized: false,
        maxVersion: options.maxVersion,
      };
      const network = securing === 'clear' ? net : tls;
      const conn = network.connect(clientOptions, () => {
        setTimeout(() => {
          const mbits = (received * 8) / (1024 * 1024);
          bench.end(mbits);
          if (conn)
            conn.destroy();
          server.close();
          proxy.close();
        }, dur * 1000);
        bench.start();
        conn.on('drain', write);
        write();
      });
      conn.on('error', (e) => {
        throw new Error(`Client error: ${e}`);
      });

      function write() {
        while (false !== conn.write(chunk));
      }
    });
  });

  function onProxyConnection(conn) {
    const client = net.connect(REDIRECT_PORT, () => {
      switch (securing) {
        case 'SecurePair':
          securePair(conn, client);
          break;
        case 'TLSSocket':
          secureTLSSocket(conn, client);
          break;
        case 'clear':
          conn.pipe(client);
          break;
        default:
          throw new Error('Invalid securing method');
      }
    });
  }

  function securePair(conn, client) {
    const serverCtx = tls.createSecureContext(options);
    const serverPair = tls.createSecurePair(serverCtx, true, true, false);
    conn.pipe(serverPair.encrypted);
    serverPair.encrypted.pipe(conn);
    serverPair.on('error', (error) => {
      throw new Error(`Pair error: ${error}`);
    });
    serverPair.cleartext.pipe(client);
  }

  function secureTLSSocket(conn, client) {
    const serverSocket = new tls.TLSSocket(conn, options);
    serverSocket.on('error', (e) => {
      throw new Error(`Socket error: ${e}`);
    });
    serverSocket.pipe(client);
  }

  let received = 0;
  function onRedirectConnection(conn) {
    conn.on('data', (chunk) => {
      received += chunk.length;
    });
  }
}
                                                                                     node-23.7.0/benchmark/tls/throughput-c2s.js                                                         0000664 0000000 0000000 00000003106 14746647661 0020545 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const bench = common.createBenchmark(main, {
  dur: [5],
  type: ['buf', 'asc', 'utf'],
  size: [100, 1024, 1024 * 1024, 4 * 1024 * 1024, 16 * 1024 * 1024],
});

const fixtures = require('../../test/common/fixtures');
let options;
const tls = require('tls');

function main({ dur, type, size }) {
  let encoding;
  let chunk;
  switch (type) {
    case 'buf':
      chunk = Buffer.alloc(size, 'b');
      break;
    case 'asc':
      chunk = 'a'.repeat(size);
      encoding = 'ascii';
      break;
    case 'utf':
      chunk = 'ü'.repeat(size / 2);
      encoding = 'utf8';
      break;
    default:
      throw new Error('invalid type');
  }

  options = {
    key: fixtures.readKey('rsa_private.pem'),
    cert: fixtures.readKey('rsa_cert.crt'),
    ca: fixtures.readKey('rsa_ca.crt'),
    ciphers: 'AES256-GCM-SHA384',
    maxVersion: 'TLSv1.2',
  };

  const server = tls.createServer(options, onConnection);
  let conn;
  server.listen(common.PORT, () => {
    const opt = { port: common.PORT, rejectUnauthorized: false };
    conn = tls.connect(opt, () => {
      setTimeout(done, dur * 1000);
      bench.start();
      conn.on('drain', write);
      write();
    });

    function write() {
      while (false !== conn.write(chunk, encoding));
    }
  });

  let received = 0;
  function onConnection(conn) {
    conn.on('data', (chunk) => {
      received += chunk.length;
    });
  }

  function done() {
    const mbits = (received * 8) / (1024 * 1024);
    bench.end(mbits);
    if (conn)
      conn.destroy();
    server.close();
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/benchmark/tls/throughput-s2c.js                                                         0000664 0000000 0000000 00000004601 14746647661 0020546 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const bench = common.createBenchmark(main, {
  dur: [5],
  type: ['buf', 'asc', 'utf'],
  sendchunklen: [256, 32 * 1024, 128 * 1024, 16 * 1024 * 1024],
  recvbuflen: [0, 64 * 1024, 1024 * 1024],
  recvbufgenfn: ['true', 'false'],
});

const fixtures = require('../../test/common/fixtures');
let options;
let recvbuf;
let received = 0;
const tls = require('tls');

function main({ dur, type, sendchunklen, recvbuflen, recvbufgenfn }) {
  if (isFinite(recvbuflen) && recvbuflen > 0)
    recvbuf = Buffer.alloc(recvbuflen);

  let encoding;
  let chunk;
  switch (type) {
    case 'buf':
      chunk = Buffer.alloc(sendchunklen, 'b');
      break;
    case 'asc':
      chunk = 'a'.repeat(sendchunklen);
      encoding = 'ascii';
      break;
    case 'utf':
      chunk = 'ü'.repeat(sendchunklen / 2);
      encoding = 'utf8';
      break;
    default:
      throw new Error('invalid type');
  }

  options = {
    key: fixtures.readKey('rsa_private.pem'),
    cert: fixtures.readKey('rsa_cert.crt'),
    ca: fixtures.readKey('rsa_ca.crt'),
    ciphers: 'AES256-GCM-SHA384',
    maxVersion: 'TLSv1.2',
  };

  let socketOpts;
  if (recvbuf === undefined) {
    socketOpts = { port: common.PORT, rejectUnauthorized: false };
  } else {
    let buffer = recvbuf;
    if (recvbufgenfn === 'true') {
      let bufidx = -1;
      const bufpool = [
        recvbuf,
        Buffer.from(recvbuf),
        Buffer.from(recvbuf),
      ];
      buffer = () => {
        bufidx = (bufidx + 1) % bufpool.length;
        return bufpool[bufidx];
      };
    }
    socketOpts = {
      port: common.PORT,
      rejectUnauthorized: false,
      onread: {
        buffer,
        callback: function(nread, buf) {
          received += nread;
        },
      },
    };
  }

  const server = tls.createServer(options, (socket) => {
    socket.on('data', (buf) => {
      socket.on('drain', write);
      write();
    });

    function write() {
      while (false !== socket.write(chunk, encoding));
    }
  });

  let conn;
  server.listen(common.PORT, () => {
    conn = tls.connect(socketOpts, () => {
      setTimeout(done, dur * 1000);
      bench.start();
      conn.write('hello');
    });

    conn.on('data', (chunk) => {
      received += chunk.length;
    });
  });

  function done() {
    const mbits = (received * 8) / (1024 * 1024);
    bench.end(mbits);
    process.exit(0);
  }
}
                                                                                                                               node-23.7.0/benchmark/tls/tls-connect.js                                                            0000664 0000000 0000000 00000003032 14746647661 0020076 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const fixtures = require('../../test/common/fixtures');
const tls = require('tls');

const common = require('../common.js');
const bench = common.createBenchmark(main, {
  concurrency: [1, 10],
  dur: [5],
});

let clientConn = 0;
let serverConn = 0;
let dur;
let concurrency;
let running = true;

function main(conf) {
  dur = conf.dur;
  concurrency = conf.concurrency;
  const options = {
    key: fixtures.readKey('rsa_private.pem'),
    cert: fixtures.readKey('rsa_cert.crt'),
    ca: fixtures.readKey('rsa_ca.crt'),
    ciphers: 'AES256-GCM-SHA384',
    maxVersion: 'TLSv1.2',
  };

  const server = tls.createServer(options, onConnection);
  server.listen(common.PORT, onListening);
}

function onListening() {
  setTimeout(done, dur * 1000);
  bench.start();
  for (let i = 0; i < concurrency; i++)
    makeConnection();
}

function onConnection(conn) {
  serverConn++;
}

function makeConnection() {
  const options = {
    port: common.PORT,
    rejectUnauthorized: false,
  };
  const conn = tls.connect(options, () => {
    clientConn++;
    conn.on('error', (er) => {
      console.error('client error', er);
      throw er;
    });
    conn.end();
    if (running) makeConnection();
  });
}

function done() {
  running = false;
  // It's only an established connection if they both saw it.
  // because we destroy the server somewhat abruptly, these
  // don't always match.  Generally, serverConn will be
  // the smaller number, but take the min just to be sure.
  bench.end(Math.min(serverConn, clientConn));
  process.exit(0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/benchmark/ts/                                                                           0000775 0000000 0000000 00000000000 14746647661 0015135 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/ts/strip-typescript.js                                                        0000664 0000000 0000000 00000001200 14746647661 0021031 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const path = require('path');
const assert = require('node:assert');


const js = path.resolve(__dirname, '../fixtures/strip-types-benchmark.js');
const ts = path.resolve(__dirname, '../fixtures/strip-types-benchmark.ts');

const bench = common.createBenchmark(main, {
  filepath: [ts, js],
  n: [1e4],
}, {
  flags: ['--disable-warning=ExperimentalWarning'],
});

async function main({ n, filepath }) {
  let output;
  bench.start();
  for (let i = 0; i < n; i++) {
    const { result } = await import(`${filepath}?${i}`);
    output = result;
  }
  bench.end(n);
  assert.ok(output);
}
                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/benchmark/ts/transform-typescript.js                                                    0000664 0000000 0000000 00000001251 14746647661 0021711 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const path = require('path');
const assert = require('node:assert');

const js = path.resolve(__dirname, '../fixtures/transform-types-benchmark.js');
const ts = path.resolve(__dirname, '../fixtures/transform-types-benchmark.ts');

const bench = common.createBenchmark(main, {
  filepath: [js, ts],
  n: [1e4],
}, {
  flags: ['--experimental-transform-types', '--disable-warning=ExperimentalWarning'],
});

async function main({ n, filepath }) {
  let output;
  bench.start();
  for (let i = 0; i < n; i++) {
    const { result } = await import(`${filepath}?${i}`);
    output = result;
  }
  bench.end(n);
  assert.ok(output);
}
                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/benchmark/url/                                                                          0000775 0000000 0000000 00000000000 14746647661 0015311 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/url/legacy-url-get-prop.js                                                    0000664 0000000 0000000 00000002044 14746647661 0021446 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const url = require('url');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  type: common.urlDataTypes,
  e: [1],
});

function main({ type, e }) {
  const data = common.bakeUrlData(type, e, false, false).map((i) => url.parse(i));
  const obj = url.parse(data[0]);
  const noDead = {
    protocol: obj.protocol,
    auth: obj.auth,
    host: obj.host,
    hostname: obj.hostname,
    port: obj.port,
    pathname: obj.pathname,
    search: obj.search,
    hash: obj.hash,
  };
  const len = data.length;
  // It's necessary to assign the values to an object
  // to avoid loop invariant code motion.
  bench.start();
  for (let i = 0; i < len; i++) {
    const obj = data[i];
    noDead.protocol = obj.protocol;
    noDead.auth = obj.auth;
    noDead.host = obj.host;
    noDead.hostname = obj.hostname;
    noDead.port = obj.port;
    noDead.pathname = obj.pathname;
    noDead.search = obj.search;
    noDead.hash = obj.hash;
  }
  bench.end(len);
  assert.ok(noDead);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/benchmark/url/legacy-url-parse.js                                                       0000664 0000000 0000000 00000000773 14746647661 0021032 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const url = require('url');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  type: common.urlDataTypes,
  e: [1],
});

function main({ e, type }) {
  const data = common.bakeUrlData(type, e, false, false);
  let result = url.parse(data[0]);  // Avoid dead code elimination

  bench.start();
  for (let i = 0; i < data.length; ++i) {
    result = url.parse(data[i]);
  }
  bench.end(data.length);

  assert.ok(result);
}
     node-23.7.0/benchmark/url/legacy-vs-whatwg-url-searchparams-parse.js                                0000664 0000000 0000000 00000001744 14746647661 0025425 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const querystring = require('querystring');
const searchParams = common.searchParams;

const bench = common.createBenchmark(main, {
  searchParam: Object.keys(searchParams),
  method: ['legacy', 'whatwg'],
  n: [1e6],
});

function useLegacy(n, input) {
  querystring.parse(input);
  bench.start();
  for (let i = 0; i < n; i += 1) {
    querystring.parse(input);
  }
  bench.end(n);
}

function useWHATWG(n, param) {
  new URLSearchParams(param);
  bench.start();
  for (let i = 0; i < n; i += 1) {
    new URLSearchParams(param);
  }
  bench.end(n);
}

function main({ searchParam, n, method }) {
  const param = searchParams[searchParam];
  if (!param) {
    throw new Error(`Unknown search parameter type "${searchParam}"`);
  }

  switch (method) {
    case 'legacy':
      useLegacy(n, param);
      break;
    case 'whatwg':
      useWHATWG(n, param);
      break;
    default:
      throw new Error(`Unknown method ${method}`);
  }
}
                            node-23.7.0/benchmark/url/legacy-vs-whatwg-url-searchparams-serialize.js                            0000664 0000000 0000000 00000002056 14746647661 0026277 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const querystring = require('querystring');
const searchParams = common.searchParams;

const bench = common.createBenchmark(main, {
  searchParam: Object.keys(searchParams),
  method: ['legacy', 'whatwg'],
  n: [1e6],
});

function useLegacy(n, input, prop) {
  const obj = querystring.parse(input);
  querystring.stringify(obj);
  bench.start();
  for (let i = 0; i < n; i += 1) {
    querystring.stringify(obj);
  }
  bench.end(n);
}

function useWHATWG(n, param, prop) {
  const obj = new URLSearchParams(param);
  obj.toString();
  bench.start();
  for (let i = 0; i < n; i += 1) {
    obj.toString();
  }
  bench.end(n);
}

function main({ searchParam, n, method }) {
  const param = searchParams[searchParam];
  if (!param) {
    throw new Error(`Unknown search parameter type "${searchParam}"`);
  }

  switch (method) {
    case 'legacy':
      useLegacy(n, param);
      break;
    case 'whatwg':
      useWHATWG(n, param);
      break;
    default:
      throw new Error(`Unknown method ${method}`);
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/url/legacy-vs-whatwg-url-serialize.js                                         0000664 0000000 0000000 00000002153 14746647661 0023626 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const url = require('url');
const URL = url.URL;
const assert = require('assert');

const bench = common.createBenchmark(main, {
  type: common.urlDataTypes,
  method: ['legacy', 'whatwg'],
  e: [1],
});

function useLegacy(data) {
  const obj = url.parse(data[0]);
  const len = data.length;
  let noDead = url.format(obj);
  bench.start();
  for (let i = 0; i < len; i++) {
    noDead = data[i].toString();
  }
  bench.end(len);
  return noDead;
}

function useWHATWG(data) {
  const obj = new URL(data[0]);
  const len = data.length;
  let noDead = obj.toString();
  bench.start();
  for (let i = 0; i < len; i++) {
    noDead = data[i].toString();
  }
  bench.end(len);
  return noDead;
}

function main({ type, e, method }) {
  const data = common.bakeUrlData(type, e, false, false);

  let noDead;  // Avoid dead code elimination.
  switch (method) {
    case 'legacy':
      noDead = useLegacy(data);
      break;
    case 'whatwg':
      noDead = useWHATWG(data);
      break;
    default:
      throw new Error(`Unknown method ${method}`);
  }

  assert.ok(noDead);
}
                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/benchmark/url/url-format.js                                                             0000664 0000000 0000000 00000001170 14746647661 0017736 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const url = require('url');

const inputs = {
  slashes: { slashes: true, host: 'localhost' },
  file: { protocol: 'file:', pathname: '/foo' },
};

const bench = common.createBenchmark(main, {
  type: Object.keys(inputs),
  n: [25e6],
});

function main({ type, n }) {
  const input = inputs[type];

  // Force-optimize url.format() so that the benchmark doesn't get
  // disrupted by the optimizer kicking in halfway through.
  for (const name in inputs)
    url.format(inputs[name]);

  bench.start();
  for (let i = 0; i < n; i += 1)
    url.format(input);
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/url/url-parse.js                                                              0000664 0000000 0000000 00000000641 14746647661 0017562 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const url = require('url');

const inputs = {
  normal: 'http://foo.com/bar',
  escaped: 'https://foo.bar/{}^`/abcd',
};

const bench = common.createBenchmark(main, {
  type: Object.keys(inputs),
  n: [1e7],
});

function main({ type, n }) {
  const input = inputs[type];

  bench.start();
  for (let i = 0; i < n; i += 1)
    url.parse(input);
  bench.end(n);
}
                                                                                               node-23.7.0/benchmark/url/url-resolve.js                                                            0000664 0000000 0000000 00000001201 14746647661 0020120 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const url = require('url');
const hrefs = common.urls;
hrefs.noscheme = 'some.ran/dom/url.thing?oh=yes#whoo';

const paths = {
  'up': '../../../../../etc/passwd',
  'sibling': '../foo/bar?baz=boom',
  'foo/bar': 'foo/bar',
  'withscheme': 'http://nodejs.org',
  'down': './foo/bar?baz',
};

const bench = common.createBenchmark(main, {
  href: Object.keys(hrefs),
  path: Object.keys(paths),
  n: [1e5],
});

function main({ n, href, path }) {
  const h = hrefs[href];
  const p = paths[path];

  bench.start();
  for (let i = 0; i < n; i += 1)
    url.resolve(h, p);
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/benchmark/url/url-searchparams-append.js                                                0000664 0000000 0000000 00000000617 14746647661 0022371 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  type: ['URL', 'URLSearchParams'],
  n: [1e3, 1e6],
});

function main({ type, n }) {
  const params = type === 'URL' ?
    new URL('https://nodejs.org').searchParams :
    new URLSearchParams();

  bench.start();
  for (let i = 0; i < n; i++) {
    params.append('test', i);
  }
  bench.end(n);
}
                                                                                                                 node-23.7.0/benchmark/url/url-searchparams-creation.js                                              0000664 0000000 0000000 00000003565 14746647661 0022733 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const values = {
  noencode: {
    foo: 'bar',
    baz: 'quux',
    xyzzy: 'thud',
  },
  encodemany: {
    '\u0080\u0083\u0089': 'bar',
    '\u008C\u008E\u0099': 'quux',
    'xyzzy': '\u00A5q\u00A3r',
  },
  encodelast: {
    foo: 'bar',
    baz: 'quux',
    xyzzy: 'thu\u00AC',
  },
  array: {
    foo: [],
    baz: ['bar'],
    xyzzy: ['bar', 'quux', 'thud'],
  },
  multiprimitives: {
    foo: false,
    bar: -13.37,
    baz: 'baz',
  },
};

function paramGenerator(paramType) {
  const valueKeys = Object.keys(values);
  switch (paramType) {
    case 'string':
      // Return the values object with all values as strings
      return valueKeys.reduce((acc, key) => {
        acc[key] = Object.keys(values[key]).reduce((acc, k, i) => {
          acc += `${k}=${values[key][k]}${i < valueKeys.length - 1 ? '&' : ''}`;
          return acc;
        }, '');
        return acc;
      }, {});
    case 'iterable':
      // Return the values object with all values as iterable
      return valueKeys.reduce((acc, key) => {
        acc[key] = Object.keys(values[key]).reduce((acc, k) => {
          acc.push([k, values[key][k]]);
          return acc;
        }, []);
        return acc;
      }, {});
    case 'object':
      // Return the values object with all values as objects
      return values;
    default:
  }
}

const bench = common.createBenchmark(main, {
  type: ['noencode', 'encodemany', 'encodelast', 'array', 'multiprimitives'],
  inputType: ['string', 'iterable', 'object'],
  n: [1e6],
});

function main({ n, type, inputType }) {
  const inputs = paramGenerator(inputType);
  const input = inputs[type];

  // Force optimization before starting the benchmark
  for (const name in inputs) {
    new URLSearchParams(inputs[name]);
  }

  bench.start();
  for (let i = 0; i < n; i += 1)
    new URLSearchParams(input);
  bench.end(n);
}
                                                                                                                                           node-23.7.0/benchmark/url/url-searchparams-iteration.js                                             0000664 0000000 0000000 00000002236 14746647661 0023117 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  loopMethod: ['forEach', 'iterator'],
  n: [1e6],
});

const str = 'one=single&two=first&three=first&two=2nd&three=2nd&three=3rd';

function forEach(n) {
  const params = new URLSearchParams(str);
  const noDead = [];
  const cb = (val, key) => {
    noDead[0] = key;
    noDead[1] = val;
  };

  bench.start();
  for (let i = 0; i < n; i += 1)
    params.forEach(cb);
  bench.end(n);

  assert.strictEqual(noDead[0], 'three');
  assert.strictEqual(noDead[1], '3rd');
}

function iterator(n) {
  const params = new URLSearchParams(str);
  const noDead = [];

  bench.start();
  for (let i = 0; i < n; i += 1) {
    for (const pair of params) {
      noDead[0] = pair[0];
      noDead[1] = pair[1];
    }
  }
  bench.end(n);

  assert.strictEqual(noDead[0], 'three');
  assert.strictEqual(noDead[1], '3rd');
}

function main({ loopMethod, n }) {
  switch (loopMethod) {
    case 'forEach':
      forEach(n);
      break;
    case 'iterator':
      iterator(n);
      break;
    default:
      throw new Error(`Unknown method ${loopMethod}`);
  }
}
                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/url/url-searchparams-read.js                                                  0000664 0000000 0000000 00000001056 14746647661 0022033 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  accessMethod: ['get', 'getAll', 'has'],
  param: ['one', 'two', 'three', 'nonexistent'],
  n: [2e7],
});

const str = 'one=single&two=first&three=first&two=2nd&three=2nd&three=3rd';

function main({ accessMethod, param, n }) {
  const params = new URLSearchParams(str);
  if (!params[accessMethod])
    throw new Error(`Unknown method ${accessMethod}`);

  bench.start();
  for (let i = 0; i < n; i += 1)
    params[accessMethod](param);
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/url/url-searchparams-sort.js                                                  0000664 0000000 0000000 00000002356 14746647661 0022113 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const inputs = {
  wpt: 'wpt',  // To work around tests
  empty: '',
  sorted: 'a&b&c&d&e&f&g&h&i&j&k&l&m&n&o&p&q&r&s&t&u&v&w&x&y&z',
  almostsorted: 'a&b&c&d&e&f&g&i&h&j&k&l&m&n&o&p&q&r&s&t&u&w&v&x&y&z',
  reversed: 'z&y&x&w&v&u&t&s&r&q&p&o&n&m&l&k&j&i&h&g&f&e&d&c&b&a',
  random: 'm&t&d&c&z&v&a&n&p&y&u&o&h&l&f&j&e&q&b&i&s&x&k&w&r&g',
  // 8 parameters
  short: 'm&t&d&c&z&v&a&n',
  // 88 parameters
  long: 'g&r&t&h&s&r&d&w&b&n&h&k&x&m&k&h&o&e&x&c&c&g&e&b&p&p&s&n&j&b&y&z&' +
        'u&l&o&r&w&a&u&l&m&f&j&q&p&f&e&y&e&n&e&l&m&w&u&w&t&n&t&q&v&y&c&o&' +
        'k&f&j&i&l&m&g&j&d&i&z&q&p&x&q&q&d&n&y&w&g&i&v&r',
};

function getParams(str) {
  const out = [];
  for (const key of str.split('&')) {
    out.push(key, '');
  }
  return out;
}

const bench = common.createBenchmark(main, {
  type: Object.keys(inputs),
  n: [1e6],
}, {
  flags: ['--expose-internals'],
});

function main({ type, n }) {
  const searchParams = require('internal/url').searchParamsSymbol;
  const input = inputs[type];
  const params = new URLSearchParams();
  const array = getParams(input);

  bench.start();
  for (let i = 0; i < n; i++) {
    params[searchParams] = array.slice();
    params.sort();
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/url/url-searchparams-toString.js                                              0000664 0000000 0000000 00000003466 14746647661 0022740 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const values = {
  noencode: {
    foo: 'bar',
    baz: 'quux',
    xyzzy: 'thud',
  },
  encodemany: {
    '\u0080\u0083\u0089': 'bar',
    '\u008C\u008E\u0099': 'quux',
    'xyzzy': '\u00A5q\u00A3r',
  },
  encodelast: {
    foo: 'bar',
    baz: 'quux',
    xyzzy: 'thu\u00AC',
  },
  array: {
    foo: [],
    baz: ['bar'],
    xyzzy: ['bar', 'quux', 'thud'],
  },
  multiprimitives: {
    foo: false,
    bar: -13.37,
    baz: 'baz',
  },
};

function paramGenerator(paramType) {
  const valueKeys = Object.keys(values);
  switch (paramType) {
    case 'string':
      // Return the values object with all values as strings
      return valueKeys.reduce((acc, key) => {
        const objectKeys = Object.keys(values[key]);
        acc[key] = objectKeys.reduce((acc, k, i) => {
          acc += `${k}=${values[key][k]}${i < objectKeys.length - 1 ? '&' : ''}`;
          return acc;
        }, '');
        return acc;
      }, {});
    case 'iterable':
      // Return the values object with all values as iterable
      return valueKeys.reduce((acc, key) => {
        acc[key] = Object.keys(values[key]).reduce((acc, k) => {
          acc.push([k, values[key][k]]);
          return acc;
        }, []);
        return acc;
      }, {});
    case 'object':
      // Return the values object with all values as objects
      return values;
    default:
  }
}

const bench = common.createBenchmark(main, {
  type: ['noencode', 'encodemany', 'encodelast', 'array', 'multiprimitives'],
  inputType: ['string', 'iterable', 'object'],
  n: [1e6],
});

function main({ n, type, inputType }) {
  const inputs = paramGenerator(inputType);
  const input = inputs[type];
  const u = new URLSearchParams(input);

  bench.start();
  for (let i = 0; i < n; i += 1)
    u.toString();
  bench.end(n);
}
                                                                                                                                                                                                          node-23.7.0/benchmark/url/url-searchparams-update.js                                                0000664 0000000 0000000 00000001444 14746647661 0022403 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  searchParams: ['true', 'false'],
  property: ['pathname', 'search', 'hash'],
  n: [1e6],
});

function getMethod(url, property) {
  if (property === 'pathname') return (x) => url.pathname = `/${x}`;
  if (property === 'search') return (x) => url.search = `?${x}`;
  if (property === 'hash') return (x) => url.hash = `#${x}`;
  throw new Error(`Unsupported property "${property}"`);
}

function main({ searchParams, property, n }) {
  const url = new URL('https://nodejs.org');
  if (searchParams === 'true') assert.ok(url.searchParams);

  const method = getMethod(url, property);

  bench.start();
  for (let i = 0; i < n; i++) {
    method(i);
  }
  bench.end(n);
}
                                                                                                                                                                                                                            node-23.7.0/benchmark/url/whatwg-url-canParse.js                                                    0000664 0000000 0000000 00000000435 14746647661 0021504 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  type: Object.keys(common.urls),
  n: [1e6],
});

function main({ type, n }) {
  bench.start();
  for (let i = 0; i < n; i += 1)
    URL.canParse(common.urls[type]);
  bench.end(n);
}
                                                                                                                                                                                                                                   node-23.7.0/benchmark/url/whatwg-url-get-prop.js                                                    0000664 0000000 0000000 00000001757 14746647661 0021515 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const url = require('url');
const URL = url.URL;
const assert = require('assert');

const bench = common.createBenchmark(main, {
  type: common.urlDataTypes,
  e: [1],
});

function main({ type, e }) {
  const data = common.bakeUrlData(type, e, false, true);
  const obj = new URL(data[0]);
  const noDead = {
    protocol: obj.protocol,
    auth: `${obj.username}:${obj.password}`,
    host: obj.host,
    hostname: obj.hostname,
    port: obj.port,
    pathname: obj.pathname,
    search: obj.search,
    hash: obj.hash,
  };
  const len = data.length;
  bench.start();
  for (let i = 0; i < len; i++) {
    const obj = data[i];
    noDead.protocol = obj.protocol;
    noDead.auth = `${obj.username}:${obj.password}`;
    noDead.host = obj.host;
    noDead.hostname = obj.hostname;
    noDead.port = obj.port;
    noDead.pathname = obj.pathname;
    noDead.search = obj.search;
    noDead.hash = obj.hash;
  }
  bench.end(len);
  assert.ok(noDead);
}
                 node-23.7.0/benchmark/url/whatwg-url-idna.js                                                        0000664 0000000 0000000 00000001542 14746647661 0020663 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { domainToASCII, domainToUnicode } = require('url');

const domains = {
  empty: {
    ascii: '',
    unicode: '',
  },
  none: {
    ascii: 'passports',
    unicode: 'passports',
  },
  some: {
    ascii: 'Paßstraße',
    unicode: 'xn--Pastrae-1vae',
  },
  all: {
    ascii: '他们不说中文',
    unicode: 'xn--ihqwczyycu19kkg2c',
  },
  nonstring: {
    ascii: { toString() { return ''; } },
    unicode: { toString() { return ''; } },
  },
};

const bench = common.createBenchmark(main, {
  domain: Object.keys(domains),
  to: ['ascii', 'unicode'],
  n: [5e6],
});

function main({ n, to, domain }) {
  const value = domains[domain][to];
  const method = to === 'ascii' ? domainToASCII : domainToUnicode;

  bench.start();
  for (let i = 0; i < n; i++) {
    method(value);
  }
  bench.end(n);
}
                                                                                                                                                              node-23.7.0/benchmark/url/whatwg-url-parse.js                                                       0000664 0000000 0000000 00000002035 14746647661 0021060 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const url = require('url');
const URL = url.URL;
const assert = require('assert');

const bench = common.createBenchmark(main, {
  withBase: ['true', 'false'],
  type: common.urlDataTypes,
  e: [1],
});

function useWHATWGWithBase(data) {
  const len = data.length;
  let result = new URL(data[0][0], data[0][1]);  // Avoid dead code elimination
  bench.start();
  for (let i = 0; i < len; ++i) {
    const item = data[i];
    result = new URL(item[0], item[1]);
  }
  bench.end(len);
  return result;
}

function useWHATWGWithoutBase(data) {
  const len = data.length;
  let result = new URL(data[0]);  // Avoid dead code elimination
  bench.start();
  for (let i = 0; i < len; ++i) {
    result = new URL(data[i]);
  }
  bench.end(len);
  return result;
}

function main({ e, type, withBase }) {
  withBase = withBase === 'true';
  const data = common.bakeUrlData(type, e, withBase, false);
  const noDead = withBase ? useWHATWGWithBase(data) : useWHATWGWithoutBase(data);

  assert.ok(noDead);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/benchmark/url/whatwg-url-properties.js                                                  0000664 0000000 0000000 00000002507 14746647661 0022146 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  withBase: ['true', 'false'],
  type: ['wpt'],  // Too many combinations - just use WPT by default
  e: [1],
  prop: ['href', 'origin', 'protocol',
         'username', 'password', 'host', 'hostname', 'port',
         'pathname', 'search', 'searchParams', 'hash'],
});

function setAndGet(data, prop) {
  const len = data.length;
  let result = data[0][prop];
  bench.start();
  for (let i = 0; i < len; ++i) {
    result = data[i][prop];
    data[i][prop] = result;
  }
  bench.end(len);
  return result;
}

function get(data, prop) {
  const len = data.length;
  let result = data[0][prop];
  bench.start();
  for (let i = 0; i < len; ++i) {
    result = data[i][prop]; // get
  }
  bench.end(len);
  return result;
}

function main({ e, type, prop, withBase }) {
  withBase = withBase === 'true';
  const data = common.bakeUrlData(type, e, withBase, true);
  switch (prop) {
    case 'protocol':
    case 'username':
    case 'password':
    case 'host':
    case 'hostname':
    case 'port':
    case 'pathname':
    case 'search':
    case 'hash':
    case 'href':
      setAndGet(data, prop);
      break;
    case 'origin':
    case 'searchParams':
      get(data, prop);
      break;
    default:
      throw new Error('Unknown prop');
  }
}
                                                                                                                                                                                         node-23.7.0/benchmark/url/whatwg-url-to-and-from-path.js                                            0000664 0000000 0000000 00000002350 14746647661 0023023 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { fileURLToPath, pathToFileURL } = require('node:url');
const isWindows = process.platform === 'win32';

const inputs = isWindows ? [
  'C:\\foo',
  'C:\\Program Files\\Music\\Web Sys\\main.html?REQUEST=RADIO',
  '\\\\nas\\My Docs\\File.doc',
  '\\\\?\\UNC\\server\\share\\folder\\file.txt',
  'file:///C:/foo',
  'file:///C:/dir/foo?query=1',
  'file:///C:/dir/foo#fragment',
] : [
  '/dev/null',
  '/dev/null?key=param&bool',
  '/dev/null?key=param&bool#hash',
  'file:///dev/null',
  'file:///dev/null?key=param&bool',
  'file:///dev/null?key=param&bool#hash',
];

const bench = common.createBenchmark(
  main,
  {
    method: ['pathToFileURL', 'fileURLToPath'],
    input: Object.values(inputs),
    n: [5e6],
  },
  {
    combinationFilter: (p) => (
      (isWindows ?
        (!p.input.startsWith('file://') && p.method === 'pathToFileURL') :
        p.method === 'pathToFileURL'
      ) ||
      (p.input.startsWith('file://') && p.method === 'fileURLToPath')
    ),
  },
);

function main({ method, input, n }) {
  const methodFunc = method === 'fileURLToPath' ? fileURLToPath : pathToFileURL;
  bench.start();
  for (let i = 0; i < n; i++) {
    methodFunc(input);
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/url/whatwg-url-validity.js                                                    0000664 0000000 0000000 00000001012 14746647661 0021565 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const url = require('url');
const URL = url.URL;

const bench = common.createBenchmark(main, {
  type: ['valid', 'invalid'],
  e: [1e5],
});

// This benchmark is used to compare the `Invalid URL` path of the URL parser
function main({ type, e }) {
  const url = type === 'valid' ? 'https://www.nodejs.org' : 'www.nodejs.org';
  bench.start();
  for (let i = 0; i < e; i++) {
    try {
      new URL(url);
    } catch {
      // do nothing
    }
  }
  bench.end(e);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/benchmark/util/                                                                         0000775 0000000 0000000 00000000000 14746647661 0015464 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/util/format.js                                                                0000664 0000000 0000000 00000001666 14746647661 0017323 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const util = require('util');
const common = require('../common');

const inputs = {
  'string': ['Hello, my name is %s', 'Fred'],
  'string-2': ['Hello, %s is my name', 'Fred'],
  'number': ['Hi, I was born in %d', 1989],
  'replace-object': ['An error occurred %j', { msg: 'This is an error' }],
  'unknown': ['hello %a', 'test'],
  'no-replace': [1, 2],
  'no-replace-2': ['foobar', 'yeah', 'mensch', 5],
  'only-objects': [{ msg: 'This is an error' }, { msg: 'This is an error' }],
  'many-%': ['replace%%%%s%%%%many%s%s%s', 'percent'],
  'object-to-string': ['foo %s bar', { toString() { return 'bla'; } }],
  'object-%s': ['foo %s bar', { a: true, b: false }],
};

const bench = common.createBenchmark(main, {
  n: [1e6],
  type: Object.keys(inputs),
});

function main({ n, type }) {
  const [first, second] = inputs[type];

  bench.start();
  for (let i = 0; i < n; i++) {
    util.format(first, second);
  }
  bench.end(n);
}
                                                                          node-23.7.0/benchmark/util/get-callsite.js                                                          0000664 0000000 0000000 00000003155 14746647661 0020403 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const { getCallSites } = require('node:util');
const assert = require('node:assert');

const bench = common.createBenchmark(main, {
  n: [1e6],
  method: ['ErrorCallSites', 'ErrorCallSitesSerialized', 'CPP'],
});

function ErrorGetCallSites() {
  const originalStackFormatter = Error.prepareStackTrace;
  Error.prepareStackTrace = (_err, stack) => {
    if (stack && stack.length > 1) {
      // Remove node:util
      return stack.slice(1);
    }
    return stack;
  };
  const err = new Error();
  // With the V8 Error API, the stack is not formatted until it is accessed
  err.stack; // eslint-disable-line no-unused-expressions
  Error.prepareStackTrace = originalStackFormatter;
  return err.stack;
}

function ErrorCallSitesSerialized() {
  const callSites = ErrorGetCallSites();
  const serialized = [];
  for (let i = 0; i < callSites.length; ++i) {
    serialized.push({
      functionName: callSites[i].getFunctionName(),
      scriptName: callSites[i].getFileName(),
      lineNumber: callSites[i].getLineNumber(),
      column: callSites[i].getColumnNumber(),
    });
  }
  return serialized;
}

function main({ n, method }) {
  let fn;
  switch (method) {
    case 'ErrorCallSites':
      fn = ErrorGetCallSites;
      break;
    case 'ErrorCallSitesSerialized':
      fn = ErrorCallSitesSerialized;
      break;
    case 'CPP':
      fn = getCallSites;
      break;
  }
  let lastStack = {};

  bench.start();
  for (let i = 0; i < n; i++) {
    const stack = fn();
    lastStack = stack;
  }
  bench.end(n);
  // Attempt to avoid dead-code elimination
  assert.ok(lastStack);
}
                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/benchmark/util/inspect-array.js                                                         0000664 0000000 0000000 00000001510 14746647661 0020600 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const util = require('util');

const bench = common.createBenchmark(main, {
  n: [5e3],
  len: [1e2, 1e5],
  type: [
    'denseArray',
    'sparseArray',
    'mixedArray',
    'denseArray_showHidden',
  ],
});

function main({ n, len, type }) {
  let arr = Array(len);
  let opts;

  switch (type) {
    case 'denseArray_showHidden':
      opts = { showHidden: true };
      arr = arr.fill('denseArray');
      break;
    case 'denseArray':
      arr = arr.fill('denseArray');
      break;
    case 'sparseArray':
      break;
    case 'mixedArray':
      for (let i = 0; i < n; i += 2)
        arr[i] = i;
      break;
    default:
      throw new Error(`Unsupported type ${type}`);
  }
  bench.start();
  for (let i = 0; i < n; i++) {
    util.inspect(arr, opts);
  }
  bench.end(n);
}
                                                                                                                                                                                        node-23.7.0/benchmark/util/inspect-proxy.js                                                         0000664 0000000 0000000 00000000776 14746647661 0020660 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const util = require('util');
const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [1e5],
  showProxy: [0, 1],
  isProxy: [0, 1],
});

function main({ n, showProxy, isProxy }) {
  let proxyA = {};
  let proxyB = () => {};
  if (isProxy) {
    proxyA = new Proxy(proxyA, { get: () => {} });
    proxyB = new Proxy(proxyB, {});
  }
  bench.start();
  for (let i = 0; i < n; i += 1)
    util.inspect({ a: proxyA, b: proxyB }, { showProxy });
  bench.end(n);
}
  node-23.7.0/benchmark/util/inspect.js                                                               0000664 0000000 0000000 00000004632 14746647661 0017474 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const util = require('util');

const common = require('../common.js');

const opts = {
  showHidden: { showHidden: true },
  colors: { colors: true },
  none: undefined,
};
const bench = common.createBenchmark(main, {
  n: [8e4],
  method: [
    'Object',
    'Object_empty',
    'Object_deep_ln',
    'String',
    'String_complex',
    'String_boxed',
    'Date',
    'Set',
    'Error',
    'Array',
    'TypedArray',
    'TypedArray_extra',
    'Number',
  ],
  option: Object.keys(opts),
});

function benchmark(n, obj, options) {
  bench.start();
  for (let i = 0; i < n; i += 1) {
    util.inspect(obj, options);
  }
  bench.end(n);
}

function main({ method, n, option }) {
  let obj;
  const options = opts[option];
  switch (method) {
    case 'Object':
      benchmark(n, { a: 'a', b: 'b', c: 'c', d: 'd' }, options);
      break;
    case 'Object_empty':
      benchmark(n, {}, options);
      break;
    case 'Object_deep_ln':
      if (options)
        options.depth = Infinity;
      obj = { first:
              { second:
                { third:
                  { a: 'first',
                    b: 'second',
                    c: 'third',
                    d: 'fourth',
                    e: 'fifth',
                    f: 'sixth',
                    g: 'seventh' } } } };
      benchmark(n, obj, options || { depth: Infinity });
      break;
    case 'String':
      benchmark(n, 'Simple string', options);
      break;
    case 'String_complex':
      benchmark(n, 'This string\nhas to be\tescaped!', options);
      break;
    case 'String_boxed':
      benchmark(n, new String('string'), options);
      break;
    case 'Date':
      benchmark(n, new Date(), options);
      break;
    case 'Set':
      obj = new Set([5, 3]);
      benchmark(n, obj, options);
      break;
    case 'Error':
      benchmark(n, new Error('error'), options);
      break;
    case 'Array':
      benchmark(n, Array(50).fill().map((_, i) => i), options);
      break;
    case 'TypedArray':
      obj = new Uint8Array(Array(50).fill().map((_, i) => i));
      benchmark(n, obj, options);
      break;
    case 'TypedArray_extra':
      obj = new Uint8Array(Array(50).fill().map((_, i) => i));
      obj.foo = 'bar';
      obj[Symbol('baz')] = 5;
      benchmark(n, obj, options);
      break;
    case 'Number':
      benchmark(n, 0, options);
      break;
    default:
      throw new Error(`Unsupported method "${method}"`);
  }
}
                                                                                                      node-23.7.0/benchmark/util/normalize-encoding.js                                                    0000664 0000000 0000000 00000002735 14746647661 0021615 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const assert = require('assert');

const groupedInputs = {
  group_common: ['undefined', 'utf8', 'utf-8', 'base64',
                 'binary', 'latin1', 'ucs2'],
  group_upper: ['UTF-8', 'UTF8', 'UCS2',
                'UTF16LE', 'BASE64', 'UCS2'],
  group_uncommon: ['foo'],
  group_misc: ['', 'utf16le', 'hex', 'HEX', 'BINARY'],
};

const inputs = [
  '', 'utf8', 'utf-8', 'UTF-8', 'UTF8', 'Utf8',
  'ucs2', 'UCS2', 'utf16le', 'UTF16LE',
  'binary', 'BINARY', 'latin1', 'base64', 'BASE64',
  'hex', 'HEX', 'foo', 'undefined',
];

const bench = common.createBenchmark(main, {
  input: inputs.concat(Object.keys(groupedInputs)),
  n: [1e6],
}, {
  flags: '--expose-internals',
});

function getInput(input) {
  switch (input) {
    case 'group_common':
      return groupedInputs.group_common;
    case 'group_upper':
      return groupedInputs.group_upper;
    case 'group_uncommon':
      return groupedInputs.group_uncommon;
    case 'group_misc':
      return groupedInputs.group_misc;
    case 'undefined':
      return [undefined];
    default:
      return [input];
  }
}

function main({ input, n }) {
  const { normalizeEncoding } = require('internal/util');
  const inputs = getInput(input);
  let noDead = '';

  bench.start();
  for (let i = 0; i < n; ++i) {
    for (let j = 0; j < inputs.length; ++j) {
      noDead = normalizeEncoding(inputs[j]);
    }
  }
  bench.end(n);
  assert.ok(noDead === undefined || noDead.length > 0);
}
                                   node-23.7.0/benchmark/util/parse-env.js                                                             0000664 0000000 0000000 00000001014 14746647661 0017716 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const { createBenchmark } = require('../common.js');
const path = require('node:path');
const fs = require('node:fs');
const util = require('node:util');
const assert = require('node:assert');

const bench = createBenchmark(main, {
  n: 3e4,
});

const env = fs.readFileSync(path.resolve(__dirname, '../fixtures/valid.env'), 'utf-8');

function main({ n }) {
  let noDead;
  bench.start();
  for (let i = 0; i < n; i++) {
    noDead = util.parseEnv(env);
  }
  bench.end(n);
  assert(noDead !== undefined);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/benchmark/util/priority-queue.js                                                        0000664 0000000 0000000 00000000661 14746647661 0021030 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const bench = common.createBenchmark(main, {
  n: [1e5],
}, { flags: ['--expose-internals'] });

function main({ n, type }) {
  const PriorityQueue = require('internal/priority_queue');
  const queue = new PriorityQueue();
  bench.start();
  for (let i = 0; i < n; i++)
    queue.insert(Math.random() * 1e7 | 0);
  for (let i = 0; i < n; i++)
    queue.shift();
  bench.end(n);
}
                                                                               node-23.7.0/benchmark/util/splice-one.js                                                            0000664 0000000 0000000 00000001213 14746647661 0020055 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const bench = common.createBenchmark(main, {
  n: [5e6],
  pos: ['start', 'middle', 'end'],
  size: [10, 100, 500],
}, { flags: ['--expose-internals'] });

function main({ n, pos, size }) {
  const { spliceOne } = require('internal/util');
  const arr = new Array(size);
  arr.fill('');
  let index;
  switch (pos) {
    case 'end':
      index = size - 1;
      break;
    case 'middle':
      index = Math.floor(size / 2);
      break;
    default: // start
      index = 0;
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    spliceOne(arr, index);
    arr.push('');
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/benchmark/util/style-text.js                                                            0000664 0000000 0000000 00000001636 14746647661 0020152 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const { styleText } = require('node:util');
const assert = require('node:assert');

const bench = common.createBenchmark(main, {
  messageType: ['string', 'number', 'boolean', 'invalid'],
  format: ['red', 'italic', 'invalid'],
  validateStream: [1, 0],
  n: [1e3],
});

function main({ messageType, format, validateStream, n }) {
  let str;
  switch (messageType) {
    case 'string':
      str = 'hello world';
      break;
    case 'number':
      str = 10;
      break;
    case 'boolean':
      str = true;
      break;
    case 'invalid':
      str = undefined;
      break;
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    let colored = '';
    try {
      colored = styleText(format, str, { validateStream });
      assert.ok(colored); // Attempt to avoid dead-code elimination
    } catch {
      // eslint-disable no-empty
    }
  }
  bench.end(n);
}
                                                                                                  node-23.7.0/benchmark/util/text-decoder.js                                                          0000664 0000000 0000000 00000001552 14746647661 0020414 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const bench = common.createBenchmark(main, {
  encoding: ['utf-8', 'windows-1252', 'iso-8859-3'],
  ignoreBOM: [0, 1],
  fatal: [0, 1],
  len: [256, 1024 * 16, 1024 * 128],
  n: [1e3],
  type: ['SharedArrayBuffer', 'ArrayBuffer', 'Buffer'],
});

function main({ encoding, len, n, ignoreBOM, type, fatal }) {
  const decoder = new TextDecoder(encoding, { ignoreBOM, fatal });
  let buf;

  switch (type) {
    case 'SharedArrayBuffer': {
      buf = new SharedArrayBuffer(len);
      break;
    }
    case 'ArrayBuffer': {
      buf = new ArrayBuffer(len);
      break;
    }
    case 'Buffer': {
      buf = Buffer.allocUnsafe(len);
      break;
    }
  }

  bench.start();
  for (let i = 0; i < n; i++) {
    try {
      decoder.decode(buf);
    } catch {
      // eslint-disable no-empty
    }
  }
  bench.end(n);
}
                                                                                                                                                      node-23.7.0/benchmark/util/text-encoder.js                                                          0000664 0000000 0000000 00000002322 14746647661 0020422 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  len: [32, 256, 1024, 1024 * 8],
  n: [1e6],
  type: ['one-byte-string', 'two-byte-string', 'ascii'],
  op: ['encode', 'encodeInto'],
});

function main({ n, op, len, type }) {
  const encoder = new TextEncoder();
  let base = '';

  switch (type) {
    case 'ascii':
      base = 'a';
      break;
    case 'one-byte-string':
      base = '\xff';
      break;
    case 'two-byte-string':
      base = 'ğ';
      break;
  }

  const input = base.repeat(len);
  if (op === 'encode') {
    const expected = encoder.encode(input);
    let result;
    bench.start();
    for (let i = 0; i < n; i++)
      result = encoder.encode(input);
    bench.end(n);
    assert.deepStrictEqual(result, expected);
  } else {
    const expected = new Uint8Array(len);
    const subarray = new Uint8Array(len);
    const expectedStats = encoder.encodeInto(input, expected);
    let result;
    bench.start();
    for (let i = 0; i < n; i++)
      result = encoder.encodeInto(input, subarray);
    bench.end(n);
    assert.deepStrictEqual(subarray, expected);
    assert.deepStrictEqual(result, expectedStats);
  }
}
                                                                                                                                                                                                                                                                                                              node-23.7.0/benchmark/util/type-check.js                                                            0000664 0000000 0000000 00000002152 14746647661 0020056 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const arrayBuffer = new ArrayBuffer();
const dataView = new DataView(arrayBuffer);
const uint8Array = new Uint8Array(arrayBuffer);
const int32Array = new Int32Array(arrayBuffer);

const args = {
  ArrayBufferView: {
    'true': dataView,
    'false-primitive': true,
    'false-object': arrayBuffer,
  },
  TypedArray: {
    'true': int32Array,
    'false-primitive': true,
    'false-object': arrayBuffer,
  },
  Uint8Array: {
    'true': uint8Array,
    'false-primitive': true,
    'false-object': int32Array,
  },
};

const bench = common.createBenchmark(main, {
  type: Object.keys(args),
  version: ['native', 'js'],
  argument: ['true', 'false-primitive', 'false-object'],
  n: [1e6],
}, {
  flags: ['--expose-internals', '--no-warnings'],
});

function main({ type, argument, version, n }) {
  const util = common.binding('util');
  const types = require('internal/util/types');

  const func = { native: util, js: types }[version][`is${type}`];
  const arg = args[type][argument];

  bench.start();
  for (let i = 0; i < n; i++) {
    func(arg);
  }
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/benchmark/v8/                                                                           0000775 0000000 0000000 00000000000 14746647661 0015044 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/v8/get-stats.js                                                               0000664 0000000 0000000 00000000512 14746647661 0017313 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const v8 = require('v8');

const bench = common.createBenchmark(main, {
  method: [
    'getHeapStatistics',
    'getHeapSpaceStatistics',
  ],
  n: [1e6],
});

function main({ method, n }) {
  bench.start();
  for (let i = 0; i < n; i++)
    v8[method]();
  bench.end(n);
}
                                                                                                                                                                                      node-23.7.0/benchmark/v8/serialize.js                                                               0000664 0000000 0000000 00000000553 14746647661 0017374 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const v8 = require('v8');

const bench = common.createBenchmark(main, {
  len: [256, 1024 * 16, 1024 * 512],
  n: [1e6],
});

function main({ n, len }) {
  const typedArray = new BigUint64Array(len);
  bench.start();
  for (let i = 0; i < n; i++)
    v8.serialize({ a: 1, b: typedArray });
  bench.end(n);
}
                                                                                                                                                     node-23.7.0/benchmark/validators/                                                                   0000775 0000000 0000000 00000000000 14746647661 0016657 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/validators/parse-file-mode.js                                                 0000664 0000000 0000000 00000002137 14746647661 0022171 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [1e7],
  value: [
    "'777'",
    '0o777',
  ],
}, {
  flags: ['--expose-internals'],
});

function getParseFactory() {
  const {
    parseFileMode,
  } = require('internal/validators');

  return (n) => parseFileMode(n, 'n');
}

function main({ n, value }) {
  const parse = getParseFactory();

  value = value === "'777'" ? '777' : 0o777;

  // Warm up.
  const length = 1024;
  const array = [];
  let errCase = false;

  for (let i = 0; i < length; ++i) {
    try {
      array.push(parse(value));
    } catch (e) {
      errCase = true;
      array.push(e);
    }
  }

  bench.start();

  for (let i = 0; i < n; ++i) {
    const index = i % length;
    try {
      array[index] = parse(value);
    } catch (e) {
      array[index] = e;
    }
  }

  bench.end(n);

  // Verify the entries to prevent dead code elimination from making
  // the benchmark invalid.
  for (let i = 0; i < length; ++i) {
    assert.strictEqual(typeof array[i], errCase ? 'object' : 'number');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/benchmark/validators/validate-array.js                                                  0000664 0000000 0000000 00000002302 14746647661 0022117 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [1e7],
  value: [
    '[]',
    '[1,2,3]',
  ],
}, {
  flags: ['--expose-internals'],
});

function getValidateFactory() {
  const {
    validateArray,
  } = require('internal/validators');

  return (n) => validateArray(n, 'n');
}

function main({ n, value }) {
  const validate = getValidateFactory();

  switch (value) {
    case '[]':
      value = [];
      break;
    case '[1,2,3]':
      value = [1, 2, 3];
      break;
  }

  // Warm up.
  const length = 1024;
  const array = [];
  let errCase = false;

  for (let i = 0; i < length; ++i) {
    try {
      array.push(validate(value));
    } catch (e) {
      errCase = true;
      array.push(e);
    }
  }

  bench.start();

  for (let i = 0; i < n; ++i) {
    const index = i % length;
    try {
      array[index] = validate(value);
    } catch (e) {
      array[index] = e;
    }
  }

  bench.end(n);

  // Verify the entries to prevent dead code elimination from making
  // the benchmark invalid.
  for (let i = 0; i < length; ++i) {
    assert.strictEqual(typeof array[i], errCase ? 'object' : 'undefined');
  }
}
                                                                                                                                                                                                                                                                                                                              node-23.7.0/benchmark/validators/validate-boolean.js                                                0000664 0000000 0000000 00000002016 14746647661 0022422 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [1e8],
  code: [
    'validateBoolean',
  ],
  value: [
    'true',
    'false',
  ],
}, {
  flags: ['--expose-internals'],
});

function getValidateFactory(code) {
  const {
    validateBoolean,
  } = require('internal/validators');

  switch (code) {
    case 'validateBoolean':
      return (n) => validateBoolean(n, 'n');
  }
}

function main({ n, code, value }) {
  const validate = getValidateFactory(code);
  const v = value === 'true';

  // Warm up.
  const length = 1024;
  const array = [];
  for (let i = 0; i < length; ++i) {
    array.push(validate(v));
  }

  bench.start();

  for (let i = 0; i < n; ++i) {
    const index = i % length;
    array[index] = validate(v);
  }

  bench.end(n);

  // Verify the entries to prevent dead code elimination from making
  // the benchmark invalid.
  for (let i = 0; i < length; ++i) {
    assert.strictEqual(typeof array[i], 'undefined');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/validators/validate-encoding.js                                               0000664 0000000 0000000 00000002070 14746647661 0022571 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [1e8],
  encoding: [
    'ascii',
    'utf8',
    'utf-8',
    'utf16le',
    'ucs2',
    'ucs-2',
    'base64',
    'latin1',
    'binary',
    'hex',
  ],
  value: [
    'test',
  ],
}, {
  flags: ['--expose-internals'],
});

function getValidateFactory(encoding) {
  const {
    validateEncoding,
  } = require('internal/validators');

  return (n) => validateEncoding(n, encoding);
}

function main({ n, encoding, value }) {
  const validate = getValidateFactory(encoding);

  // Warm up.
  const length = 1024;
  const array = [];
  for (let i = 0; i < length; ++i) {
    array.push(validate(value));
  }

  bench.start();

  for (let i = 0; i < n; ++i) {
    const index = i % length;
    array[index] = validate(value);
  }

  bench.end(n);

  // Verify the entries to prevent dead code elimination from making
  // the benchmark invalid.
  for (let i = 0; i < length; ++i) {
    assert.strictEqual(typeof array[i], 'undefined');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/validators/validate-object.js                                                 0000664 0000000 0000000 00000003061 14746647661 0022252 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [1e5],
  objectToTest: [
    'object',
    'null',
    'array',
    'function',
  ],
}, {
  flags: ['--expose-internals'],
});

function getObjectToTest(objectToTest) {
  switch (objectToTest) {
    case 'object':
      return { foo: 'bar' };
    case 'null':
      return null;
    case 'array':
      return ['foo', 'bar'];
    case 'function':
      return () => 'foo';
    default:
      throw new Error(`Value ${objectToTest} is not a valid objectToTest.`);
  }
}

function getOptions(objectToTest) {
  const {
    kValidateObjectAllowNullable,
    kValidateObjectAllowArray,
    kValidateObjectAllowFunction,
  } = require('internal/validators');

  switch (objectToTest) {
    case 'object':
      return 0;
    case 'null':
      return kValidateObjectAllowNullable;
    case 'array':
      return kValidateObjectAllowArray;
    case 'function':
      return kValidateObjectAllowFunction;
    default:
      throw new Error(`Value ${objectToTest} is not a valid objectToTest.`);
  }
}

let _validateResult;

function main({ n, objectToTest }) {
  const {
    validateObject,
  } = require('internal/validators');

  const value = getObjectToTest(objectToTest);
  const options = getOptions(objectToTest);

  bench.start();
  for (let i = 0; i < n; ++i) {
    try {
      _validateResult = validateObject(value, 'Object', options);
    } catch {
      _validateResult = undefined;
    }
  }
  bench.end(n);

  assert.ok(!_validateResult);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/benchmark/validators/validate-one-of.js                                                 0000664 0000000 0000000 00000002332 14746647661 0022167 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [1e7],
  code: [
    'validateOneOf',
  ],
  value: [
    'fifo',
    'lifo',
    'lilo',
  ],
  validLength: [
    1,
    2,
    3,
  ],
}, {
  flags: ['--expose-internals'],
});

const validValues = [
  'fifo',
  'lifo',
  'lilo',
  'filo',
];

function getValidateFactory(code, validLength) {
  const {
    validateOneOf,
  } = require('internal/validators');

  switch (code) {
    case 'validateOneOf':
      return (n) => validateOneOf(n, 'n', validValues.slice(0, validLength));
  }
}

function main({ n, code, validLength }) {
  const validate = getValidateFactory(code, validLength);

  // Warm up.
  const length = 1024;
  const array = [];

  const value = validValues[validLength - 1];

  for (let i = 0; i < length; ++i) {
    array.push(validate(value));
  }

  bench.start();
  for (let i = 0; i < n; ++i) {
    const index = i % length;
    array[index] = validate(value);
  }
  bench.end(n);


  // Verify the entries to prevent dead code elimination from making
  // the benchmark invalid.
  for (let i = 0; i < length; ++i) {
    assert.strictEqual(typeof array[i], 'undefined');
  }
}
                                                                                                                                                                                                                                                                                                      node-23.7.0/benchmark/validators/validate-x-array.js                                                0000664 0000000 0000000 00000002566 14746647661 0022400 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [1e8],
  type: [
    'validateStringArray',
    'validateBooleanArray',
  ],
  arrayLength: [
    0,
    1,
    10,
    100,
  ],
}, {
  flags: ['--expose-internals'],
});

function getValidateFactory(type, arrayLength) {
  const {
    validateBooleanArray,
    validateStringArray,
  } = require('internal/validators');

  switch (type) {
    case 'validateBooleanArray':
      return [
        (n) => validateBooleanArray(n, 'n'),
        Array.from({ length: arrayLength }, (v, i) => ((i & 1) === 0)),
      ];
    case 'validateStringArray':
      return [
        (n) => validateStringArray(n, 'n'),
        Array.from({ length: arrayLength }, (v, i) => `foo${i}`),
      ];
  }
}

function main({ n, type, arrayLength }) {
  const [validate, value] = getValidateFactory(type, arrayLength);

  // Warm up.
  const length = 1024;
  const array = [];
  for (let i = 0; i < length; ++i) {
    array.push(validate(value));
  }

  bench.start();

  for (let i = 0; i < n; ++i) {
    const index = i % length;
    array[index] = validate(value);
  }

  bench.end(n);

  // Verify the entries to prevent dead code elimination from making
  // the benchmark invalid.
  for (let i = 0; i < length; ++i) {
    assert.strictEqual(typeof array[i], 'undefined');
  }
}
                                                                                                                                          node-23.7.0/benchmark/vm/                                                                           0000775 0000000 0000000 00000000000 14746647661 0015131 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/vm/compile-script-in-isolate-cache.js                                         0000664 0000000 0000000 00000002115 14746647661 0023523 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// This benchmarks compiling scripts that hit the in-isolate compilation
// cache (by having the same source).
const common = require('../common.js');
const fs = require('fs');
const vm = require('vm');
const path = require('path');

const bench = common.createBenchmark(main, {
  type: ['with-dynamic-import-callback', 'without-dynamic-import-callback'],
  filename: ['test/fixtures/snapshot/typescript.js', 'test/fixtures/syntax/good_syntax.js'],
  n: [1000],
});

function main({ n, type, filename }) {
  const scriptPath = path.resolve(__dirname, '..', '..', filename);
  const scriptSource = fs.readFileSync(scriptPath, 'utf8');
  let script;
  bench.start();
  const options = {};
  switch (type) {
    case 'with-dynamic-import-callback':
      // Use a dummy callback for now until we really need to benchmark it.
      options.importModuleDynamically = async () => {};
      break;
    case 'without-dynamic-import-callback':
      break;
  }
  for (let i = 0; i < n; i++) {
    script = new vm.Script(scriptSource, options);
  }
  bench.end(n);
  script.runInThisContext();
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/benchmark/vm/context-global-proxy.js                                                    0000664 0000000 0000000 00000000571 14746647661 0021573 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [100000],
});

const vm = require('vm');
const script = new vm.Script(`
  globalThis.foo++;
`);
const context = vm.createContext({ foo: 1 });

function main({ n }) {
  bench.start();
  for (let i = 0; i < n; i++) {
    script.runInContext(context);
  }
  bench.end(n);
}
                                                                                                                                       node-23.7.0/benchmark/vm/create-context.js                                                          0000664 0000000 0000000 00000000626 14746647661 0020420 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [100],
});

const vm = require('vm');

const ctxFn = new vm.Script(`
  var b = Math.random();
  var c = a + b;
`);

function main({ n }) {
  bench.start();
  let context;
  for (let i = 0; i < n; i++) {
    context = vm.createContext({ a: 'a' });
  }
  bench.end(n);
  ctxFn.runInContext(context);
}
                                                                                                          node-23.7.0/benchmark/vm/run-in-context.js                                                          0000664 0000000 0000000 00000001124 14746647661 0020357 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [1],
  breakOnSigint: [0, 1],
  withSigintListener: [0, 1],
});

const vm = require('vm');

function main({ n, breakOnSigint, withSigintListener }) {
  const options = breakOnSigint ? { breakOnSigint: true } : {};

  process.removeAllListeners('SIGINT');
  if (withSigintListener)
    process.on('SIGINT', () => {});

  const contextifiedSandbox = vm.createContext();

  bench.start();
  for (let i = 0; i < n; i++)
    vm.runInContext('0', contextifiedSandbox, options);
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/benchmark/vm/run-in-this-context.js                                                     0000664 0000000 0000000 00000001020 14746647661 0021317 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const bench = common.createBenchmark(main, {
  n: [1],
  breakOnSigint: [0, 1],
  withSigintListener: [0, 1],
});

const vm = require('vm');

function main({ n, breakOnSigint, withSigintListener }) {
  const options = breakOnSigint ? { breakOnSigint: true } : {};

  process.removeAllListeners('SIGINT');
  if (withSigintListener)
    process.on('SIGINT', () => {});

  bench.start();
  for (let i = 0; i < n; i++)
    vm.runInThisContext('0', options);
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/benchmark/websocket/                                                                    0000775 0000000 0000000 00000000000 14746647661 0016475 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/websocket/simple.js                                                           0000664 0000000 0000000 00000004451 14746647661 0020330 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const crypto = require('crypto');
const http = require('http');

const GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';

const configs = {
  size: [64, 16 * 1024, 128 * 1024, 1024 * 1024],
  useBinary: ['true', 'false'],
  roundtrips: [5000, 1000, 100],
};

const bench = common.createBenchmark(main, configs);

function createFrame(data, opcode) {
  let infoLength = 2;
  let payloadLength = data.length;

  if (payloadLength >= 65536) {
    infoLength += 8;
    payloadLength = 127;
  } else if (payloadLength > 125) {
    infoLength += 2;
    payloadLength = 126;
  }

  const info = Buffer.alloc(infoLength);

  info[0] = opcode | 0x80;
  info[1] = payloadLength;

  if (payloadLength === 126) {
    info.writeUInt16BE(data.length, 2);
  } else if (payloadLength === 127) {
    info[2] = info[3] = 0;
    info.writeUIntBE(data.length, 4, 6);
  }

  return Buffer.concat([info, data]);
}

function main(conf) {
  const frame = createFrame(Buffer.alloc(conf.size).fill('.'), conf.useBinary === 'true' ? 2 : 1);
  const server = http.createServer();
  server.on('upgrade', (req, socket) => {
    const key = crypto
      .createHash('sha1')
      .update(req.headers['sec-websocket-key'] + GUID)
      .digest('base64');

    let bytesReceived = 0;
    let roundtrip = 0;

    socket.on('data', function onData(chunk) {
      bytesReceived += chunk.length;

      if (bytesReceived === frame.length + 4) { // +4 for the mask.
        // Message completely received.
        bytesReceived = 0;

        if (++roundtrip === conf.roundtrips) {
          socket.removeListener('data', onData);
          socket.resume();
          socket.end();
          server.close();

          bench.end(conf.roundtrips);
        } else {
          socket.write(frame);
        }
      }
    });

    socket.write(
      [
        'HTTP/1.1 101 Switching Protocols',
        'Upgrade: websocket',
        'Connection: Upgrade',
        `Sec-WebSocket-Accept: ${key}`,
        '\r\n',
      ].join('\r\n'),
    );

    socket.write(frame);
  });

  server.listen(0, () => {
    const ws = new WebSocket(`ws://localhost:${server.address().port}`);
    ws.addEventListener('open', () => {
      bench.start();
    });

    ws.addEventListener('message', (event) => {
      ws.send(event.data);
    });
  });
}
                                                                                                                                                                                                                       node-23.7.0/benchmark/webstorage/                                                                   0000775 0000000 0000000 00000000000 14746647661 0016651 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/webstorage/getItem.js                                                         0000664 0000000 0000000 00000003450 14746647661 0020607 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const { join } = require('node:path');
const common = require('../common.js');
const tmpdir = require('../../test/common/tmpdir');

let cnt = 0;

tmpdir.refresh();

function nextLocalStorage() {
  return join(tmpdir.path, `${++cnt}.localstorage`);
}

const options = {
  flags: ['--experimental-webstorage', `--localstorage-file=${nextLocalStorage()}`],
};

const bench = common.createBenchmark(main, {
  type: ['localStorage-getItem',
         'localStorage-getter',
         'sessionStorage-getItem',
         'sessionStorage-getter'],
  // Note: web storage has only 10mb quota
  n: [1e5],
}, options);

function fillStorage(storage, n) {
  for (let i = 0; i < n; i++) {
    storage.setItem(i, i);
  }
}

function main({ n, type }) {
  const localStorage = globalThis.localStorage;
  const sessionStorage = globalThis.sessionStorage;

  switch (type) {
    case 'localStorage-getItem':
      fillStorage(localStorage, n);
      bench.start();
      for (let i = 0; i < n; i++) {
        localStorage.getItem(i);
      }
      bench.end(n);
      break;
    case 'localStorage-getter':
      fillStorage(localStorage, n);
      bench.start();
      for (let i = 0; i < n; i++) {
        // eslint-disable-next-line no-unused-expressions
        localStorage[i];
      }
      bench.end(n);
      break;
    case 'sessionStorage-getItem':
      fillStorage(sessionStorage, n);
      bench.start();
      for (let i = 0; i < n; i++) {
        sessionStorage.getItem(i);
      }
      bench.end(n);
      break;
    case 'sessionStorage-getter':
      fillStorage(sessionStorage, n);
      bench.start();
      for (let i = 0; i < n; i++) {
        // eslint-disable-next-line no-unused-expressions
        sessionStorage[i];
      }
      bench.end(n);
      break;
    default:
      new Error('Invalid type');
  }
}
                                                                                                                                                                                                                        node-23.7.0/benchmark/webstorage/removeItem.js                                                      0000664 0000000 0000000 00000003327 14746647661 0021330 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const { join } = require('node:path');
const common = require('../common.js');
const tmpdir = require('../../test/common/tmpdir');

let cnt = 0;

tmpdir.refresh();

function nextLocalStorage() {
  return join(tmpdir.path, `${++cnt}.localstorage`);
}

const options = {
  flags: ['--experimental-webstorage', `--localstorage-file=${nextLocalStorage()}`],
};

const bench = common.createBenchmark(main, {
  type: ['localStorage-removeItem',
         'localStorage-delete',
         'sessionStorage-removeItem',
         'sessionStorage-delete',
  ],
  // Note: web storage has only 10mb quota
  n: [1e5],
}, options);

function fillStorage(storage, n) {
  for (let i = 0; i < n; i++) {
    storage.setItem(i, i);
  }
}

function main({ n, type }) {
  const localStorage = globalThis.localStorage;
  const sessionStorage = globalThis.sessionStorage;

  switch (type) {
    case 'localStorage-removeItem':
      fillStorage(localStorage, n);
      bench.start();
      for (let i = 0; i < n; i++) {
        localStorage.removeItem(i);
      }
      bench.end(n);
      break;
    case 'localStorage-delete':
      fillStorage(localStorage, n);
      bench.start();
      for (let i = 0; i < n; i++) {
        delete localStorage[i];
      }
      bench.end(n);
      break;
    case 'sessionStorage-removeItem':
      fillStorage(sessionStorage, n);
      bench.start();
      for (let i = 0; i < n; i++) {
        sessionStorage.removeItem(i);
      }
      bench.end(n);
      break;

    case 'sessionStorage-delete':
      fillStorage(localStorage, n);
      bench.start();
      for (let i = 0; i < n; i++) {
        delete sessionStorage[i];
      }
      bench.end(n);
      break;
    default:
      new Error('Invalid type');
  }
}
                                                                                                                                                                                                                                                                                                         node-23.7.0/benchmark/webstorage/setItem.js                                                         0000664 0000000 0000000 00000002711 14746647661 0020622 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const { join } = require('node:path');
const common = require('../common.js');
const tmpdir = require('../../test/common/tmpdir');

let cnt = 0;

tmpdir.refresh();

function nextLocalStorage() {
  return join(tmpdir.path, `${++cnt}.localstorage`);
}

const options = {
  flags: ['--experimental-webstorage', `--localstorage-file=${nextLocalStorage()}`],
};

const bench = common.createBenchmark(main, {
  type: ['localStorage-setItem',
         'localStorage-setter',
         'sessionStorage-setItem',
         'sessionStorage-setter'],
  // Note: web storage has only 10mb quota
  n: [1e5],
}, options);

function main({ n, type }) {
  const localStorage = globalThis.localStorage;
  const sessionStorage = globalThis.sessionStorage;

  switch (type) {
    case 'localStorage-setItem':
      bench.start();
      for (let i = 0; i < n; i++) {
        localStorage.setItem(i, i);
      }
      bench.end(n);
      break;
    case 'localStorage-setter':
      bench.start();
      for (let i = 0; i < n; i++) {
        localStorage[i] = i;
      }
      bench.end(n);
      break;
    case 'sessionStorage-setItem':
      bench.start();
      for (let i = 0; i < n; i++) {
        sessionStorage.setItem(i, i);
      }
      bench.end(n);
      break;
    case 'sessionStorage-setter':
      bench.start();
      for (let i = 0; i < n; i++) {
        sessionStorage[i] = i;
      }
      bench.end(n);
      break;
    default:
      new Error('Invalid type');
  }
}
                                                       node-23.7.0/benchmark/webstreams/                                                                   0000775 0000000 0000000 00000000000 14746647661 0016663 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/webstreams/creation.js                                                        0000664 0000000 0000000 00000004743 14746647661 0021035 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const {
  ReadableStream,
  ReadableStreamDefaultReader,
  ReadableStreamBYOBReader,
  TransformStream,
  WritableStream,
} = require('node:stream/web');
const assert = require('assert');

const bench = common.createBenchmark(main, {
  n: [50e3],
  kind: [
    'ReadableStream',
    'TransformStream',
    'WritableStream',

    'ReadableStreamDefaultReader',
    'ReadableStreamBYOBReader',

    'ReadableStream.tee',
  ],
});

let readableStream;
let transformStream;
let writableStream;
let readableStreamDefaultReader;
let readableStreamBYOBReader;
let teeResult;

function main({ n, kind }) {
  switch (kind) {
    case 'ReadableStream':
      bench.start();
      for (let i = 0; i < n; ++i)
        readableStream = new ReadableStream();
      bench.end(n);

      // Avoid V8 deadcode (elimination)
      assert.ok(readableStream);
      break;
    case 'WritableStream':
      bench.start();
      for (let i = 0; i < n; ++i)
        writableStream = new WritableStream();
      bench.end(n);

      // Avoid V8 deadcode (elimination)
      assert.ok(writableStream);
      break;
    case 'TransformStream':
      bench.start();
      for (let i = 0; i < n; ++i)
        transformStream = new TransformStream();
      bench.end(n);

      // Avoid V8 deadcode (elimination)
      assert.ok(transformStream);
      break;
    case 'ReadableStreamDefaultReader': {
      const readers = Array.from({ length: n }, () => new ReadableStream());

      bench.start();
      for (let i = 0; i < n; ++i)
        readableStreamDefaultReader = new ReadableStreamDefaultReader(readers[i]);
      bench.end(n);

      // Avoid V8 deadcode (elimination)
      assert.ok(readableStreamDefaultReader);
      break;
    }
    case 'ReadableStreamBYOBReader': {
      const readers = Array.from({ length: n }, () => new ReadableStream({ type: 'bytes' }));

      bench.start();
      for (let i = 0; i < n; ++i)
        readableStreamBYOBReader = new ReadableStreamBYOBReader(readers[i]);
      bench.end(n);

      // Avoid V8 deadcode (elimination)
      assert.ok(readableStreamBYOBReader);
      break;
    }
    case 'ReadableStream.tee': {
      const streams = Array.from({ length: n }, () => new ReadableStream());

      bench.start();
      for (let i = 0; i < n; ++i)
        teeResult = streams[i].tee();
      bench.end(n);

      // Avoid V8 deadcode (elimination)
      assert.ok(teeResult);
      break;
    }
    default:
      throw new Error('Invalid kind');
  }
}
                             node-23.7.0/benchmark/webstreams/js_transfer.js                                                     0000664 0000000 0000000 00000002143 14746647661 0021541 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');

const { MessageChannel } = require('worker_threads');
const { WritableStream, TransformStream, ReadableStream } = require('stream/web');

const bench = common.createBenchmark(main, {
  payload: ['WritableStream', 'ReadableStream', 'TransformStream'],
  n: [1e4],
});

function main({ n, payload: payloadType }) {
  let createPayload;
  let messages = 0;

  switch (payloadType) {
    case 'WritableStream':
      createPayload = () => new WritableStream();
      break;
    case 'ReadableStream':
      createPayload = () => new ReadableStream();
      break;
    case 'TransformStream':
      createPayload = () => new TransformStream();
      break;
    default:
      throw new Error('Unsupported payload type');
  }

  const { port1, port2 } = new MessageChannel();

  port2.onmessage = onMessage;

  function onMessage() {
    if (messages++ === n) {
      bench.end(n);
      port1.close();
    } else {
      send();
    }
  }

  function send() {
    const stream = createPayload();

    port1.postMessage(stream, [stream]);
  }

  bench.start();
  send();
}
                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/benchmark/webstreams/pipe-to.js                                                         0000664 0000000 0000000 00000001414 14746647661 0020576 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const {
  ReadableStream,
  WritableStream,
} = require('node:stream/web');

const bench = common.createBenchmark(main, {
  n: [5e5],
  highWaterMarkR: [512, 1024, 2048, 4096],
  highWaterMarkW: [512, 1024, 2048, 4096],
});


async function main({ n, highWaterMarkR, highWaterMarkW }) {
  const b = Buffer.alloc(1024);
  let i = 0;
  const rs = new ReadableStream({
    highWaterMark: highWaterMarkR,
    pull: function(controller) {
      if (i++ < n) {
        controller.enqueue(b);
      } else {
        controller.close();
      }
    },
  });
  const ws = new WritableStream({
    highWaterMark: highWaterMarkW,
    write(chunk, controller) {},
    close() { bench.end(n); },
  });

  bench.start();
  rs.pipeTo(ws);
}
                                                                                                                                                                                                                                                    node-23.7.0/benchmark/webstreams/readable-async-iterator.js                                         0000664 0000000 0000000 00000001036 14746647661 0023722 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const {
  ReadableStream,
} = require('node:stream/web');

const bench = common.createBenchmark(main, {
  n: [1e5],
});


async function main({ n }) {
  const rs = new ReadableStream({
    pull: function(controller) {
      controller.enqueue(1);
    },
  });

  let x = 0;

  bench.start();
  for await (const chunk of rs) {
    x += chunk;
    if (x > n) {
      break;
    }
  }
  // Use x to ensure V8 does not optimize away the loop as a noop.
  console.assert(x);
  bench.end(n);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/benchmark/webstreams/readable-read.js                                                   0000664 0000000 0000000 00000002230 14746647661 0021666 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const { ReadableStream } = require('node:stream/web');

const bench = common.createBenchmark(main, {
  n: [1e5],
  type: ['normal', 'byob'],
});

async function main({ n, type }) {
  switch (type) {
    case 'normal': {
      const rs = new ReadableStream({
        pull: function(controller) {
          controller.enqueue('a');
        },
      });
      const reader = rs.getReader();
      let x = null;
      bench.start();
      for (let i = 0; i < n; i++) {
        const { value } = await reader.read();
        x = value;
      }
      bench.end(n);
      console.assert(x);
      break;
    }
    case 'byob': {
      const encode = new TextEncoder();
      const rs = new ReadableStream({
        type: 'bytes',
        pull: function(controller) {
          controller.enqueue(encode.encode('a'));
        },
      });
      const reader = rs.getReader({ mode: 'byob' });
      let x = null;
      bench.start();
      for (let i = 0; i < n; i++) {
        const { value } = await reader.read(new Uint8Array(1));
        x = value;
      }
      bench.end(n);
      console.assert(x);
      break;
    }
  }
}
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/worker/                                                                       0000775 0000000 0000000 00000000000 14746647661 0016020 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/worker/atomics-wait.js                                                        0000664 0000000 0000000 00000000707 14746647661 0020763 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

if (typeof SharedArrayBuffer === 'undefined') {
  throw new Error('SharedArrayBuffers must be enabled to run this benchmark');
}

const common = require('../common.js');
const bench = common.createBenchmark(main, {
  n: [1e7],
});

function main({ n }) {
  const i32arr = new Int32Array(new SharedArrayBuffer(4));
  bench.start();
  for (let i = 0; i < n; i++)
    Atomics.wait(i32arr, 0, 1);  // Will return immediately.
  bench.end(n);
}
                                                         node-23.7.0/benchmark/worker/bench-eventlooputil.js                                                 0000664 0000000 0000000 00000002563 14746647661 0022352 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const { Worker, parentPort } = require('worker_threads');

if (process.argv[2] === 'idle cats') {
  return parentPort.once('message', () => {});
}

const bench = common.createBenchmark(main, {
  n: [1e6],
  method: [
    'ELU_simple',
    'ELU_passed',
  ],
});

function main({ method, n }) {
  switch (method) {
    case 'ELU_simple':
      benchELUSimple(n);
      break;
    case 'ELU_passed':
      benchELUPassed(n);
      break;
    default:
      throw new Error(`Unsupported method ${method}`);
  }
}

function benchELUSimple(n) {
  const worker = new Worker(__filename, { argv: ['idle cats'] });

  spinUntilIdle(worker, () => {
    bench.start();
    for (let i = 0; i < n; i++)
      worker.performance.eventLoopUtilization();
    bench.end(n);
    worker.postMessage('bye');
  });
}

function benchELUPassed(n) {
  const worker = new Worker(__filename, { argv: ['idle cats'] });

  spinUntilIdle(worker, () => {
    let elu = worker.performance.eventLoopUtilization();
    bench.start();
    for (let i = 0; i < n; i++)
      elu = worker.performance.eventLoopUtilization(elu);
    bench.end(n);
    worker.postMessage('bye');
  });
}

function spinUntilIdle(w, cb) {
  const t = w.performance.eventLoopUtilization();
  if (t.idle + t.active > 0)
    return process.nextTick(cb);
  setTimeout(() => spinUntilIdle(w, cb), 1);
}
                                                                                                                                             node-23.7.0/benchmark/worker/echo.js                                                                0000664 0000000 0000000 00000003010 14746647661 0017266 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const { Worker } = require('worker_threads');
const path = require('path');
const bench = common.createBenchmark(main, {
  workers: [1],
  payload: ['string', 'object'],
  sendsPerBroadcast: [1, 10],
  n: [1e5],
});

const workerPath = path.resolve(__dirname, '..', 'fixtures', 'echo.worker.js');

function main({ n, workers, sendsPerBroadcast: sends, payload: payloadType }) {
  const expectedPerBroadcast = sends * workers;
  let payload;
  let readies = 0;
  let broadcasts = 0;
  let msgCount = 0;

  switch (payloadType) {
    case 'string':
      payload = 'hello world!';
      break;
    case 'object':
      payload = { action: 'pewpewpew', powerLevel: 9001 };
      break;
    default:
      throw new Error('Unsupported payload type');
  }

  const workerObjs = [];

  for (let i = 0; i < workers; ++i) {
    const worker = new Worker(workerPath);
    workerObjs.push(worker);
    worker.on('online', onOnline);
    worker.on('message', onMessage);
  }

  function onOnline() {
    if (++readies === workers) {
      bench.start();
      broadcast();
    }
  }

  function broadcast() {
    if (broadcasts++ === n) {
      bench.end(n);
      for (const worker of workerObjs) {
        worker.unref();
      }
      return;
    }
    for (const worker of workerObjs) {
      for (let i = 0; i < sends; ++i)
        worker.postMessage(payload);
    }
  }

  function onMessage() {
    if (++msgCount === expectedPerBroadcast) {
      msgCount = 0;
      broadcast();
    }
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/worker/messageport.js                                                         0000664 0000000 0000000 00000002074 14746647661 0020712 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common.js');
const { MessageChannel } = require('worker_threads');
const bench = common.createBenchmark(main, {
  payload: ['string', 'object'],
  style: ['eventtarget', 'eventemitter'],
  n: [1e6],
});

function main(conf) {
  const n = conf.n;
  let payload;

  switch (conf.payload) {
    case 'string':
      payload = 'hello world!';
      break;
    case 'object':
      payload = { action: 'pewpewpew', powerLevel: 9001 };
      break;
    default:
      throw new Error('Unsupported payload type');
  }

  const { port1, port2 } = new MessageChannel();

  let messages = 0;
  function listener() {
    if (messages++ === n) {
      bench.end(n);
      port1.close();
    } else {
      write();
    }
  }

  switch (conf.style) {
    case 'eventtarget':
      port2.onmessage = listener;
      break;
    case 'eventemitter':
      port2.on('message', listener);
      break;
    default:
      throw new Error('Unsupported listener type');
  }

  bench.start();
  write();

  function write() {
    port1.postMessage(payload);
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/benchmark/zlib/                                                                         0000775 0000000 0000000 00000000000 14746647661 0015447 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/benchmark/zlib/createInflate.js                                                         0000664 0000000 0000000 00000001315 14746647661 0020553 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const zlib = require('zlib');

const bench = common.createBenchmark(main, {
  inputLen: [16 * 1024 * 1024],
  chunkLen: [1024],
  n: [1e2],
});

function main({ n, inputLen, chunkLen }) {
  const input = zlib.deflateSync(Buffer.alloc(inputLen, 'a'));

  let i = 0;
  bench.start();
  (function next() {
    let p = 0;
    const inflater = zlib.createInflate();
    inflater.resume();
    inflater.on('finish', () => {
      if (i++ === n)
        return bench.end(n);
      next();
    });

    (function nextChunk() {
      if (p >= input.length)
        return inflater.end();
      inflater.write(input.slice(p, p += chunkLen), nextChunk);
    })();
  })();
}
                                                                                                                                                                                                                                                                                                                   node-23.7.0/benchmark/zlib/creation.js                                                              0000664 0000000 0000000 00000001270 14746647661 0017611 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const zlib = require('zlib');

const bench = common.createBenchmark(main, {
  type: [
    'Deflate', 'DeflateRaw', 'Inflate', 'InflateRaw', 'Gzip', 'Gunzip', 'Unzip',
    'BrotliCompress', 'BrotliDecompress',
  ],
  options: ['true', 'false'],
  n: [5e5],
});

function main({ n, type, options }) {
  const fn = zlib[`create${type}`];
  if (typeof fn !== 'function')
    throw new Error('Invalid zlib type');

  if (options === 'true') {
    const opts = {};
    bench.start();
    for (let i = 0; i < n; ++i)
      fn(opts);
    bench.end(n);
  } else {
    bench.start();
    for (let i = 0; i < n; ++i)
      fn();
    bench.end(n);
  }
}
                                                                                                                                                                                                                                                                                                                                        node-23.7.0/benchmark/zlib/deflate.js                                                               0000664 0000000 0000000 00000002600 14746647661 0017407 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const zlib = require('zlib');

const bench = common.createBenchmark(main, {
  method: ['createDeflate', 'deflate', 'deflateSync'],
  inputLen: [1024],
  n: [4e5],
});

function main({ n, method, inputLen }) {
  // Default method value for testing.
  method ||= 'deflate';
  const chunk = Buffer.alloc(inputLen, 'a');

  switch (method) {
    // Performs `n` writes for a single deflate stream
    case 'createDeflate': {
      let i = 0;
      const deflater = zlib.createDeflate();
      deflater.resume();
      deflater.on('finish', () => {
        bench.end(n);
      });

      bench.start();
      (function next() {
        if (i++ === n)
          return deflater.end();
        deflater.write(chunk, next);
      })();
      break;
    }
    // Performs `n` single deflate operations
    case 'deflate': {
      let i = 0;
      const deflate = zlib.deflate;
      bench.start();
      (function next(err, result) {
        if (i++ === n)
          return bench.end(n);
        deflate(chunk, next);
      })();
      break;
    }
    // Performs `n` single deflateSync operations
    case 'deflateSync': {
      const deflateSync = zlib.deflateSync;
      bench.start();
      for (let i = 0; i < n; ++i)
        deflateSync(chunk);
      bench.end(n);
      break;
    }
    default:
      throw new Error('Unsupported deflate method');
  }
}
                                                                                                                                node-23.7.0/benchmark/zlib/inflate.js                                                               0000664 0000000 0000000 00000001731 14746647661 0017431 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const zlib = require('zlib');

const bench = common.createBenchmark(main, {
  method: ['inflate', 'inflateSync'],
  inputLen: [1024],
  n: [4e5],
});

function main({ n, method, inputLen }) {
  // Default method value for tests.
  method ||= 'inflate';
  const chunk = zlib.deflateSync(Buffer.alloc(inputLen, 'a'));

  let i = 0;
  switch (method) {
    // Performs `n` single inflate operations
    case 'inflate': {
      const inflate = zlib.inflate;
      bench.start();
      (function next(err, result) {
        if (i++ === n)
          return bench.end(n);
        inflate(chunk, next);
      })();
      break;
    }
    // Performs `n` single inflateSync operations
    case 'inflateSync': {
      const inflateSync = zlib.inflateSync;
      bench.start();
      for (; i < n; ++i)
        inflateSync(chunk);
      bench.end(n);
      break;
    }
    default:
      throw new Error('Unsupported inflate method');
  }
}
                                       node-23.7.0/benchmark/zlib/pipe.js                                                                  0000664 0000000 0000000 00000002236 14746647661 0016745 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common.js');
const fs = require('fs');
const zlib = require('zlib');

const bench = common.createBenchmark(main, {
  inputLen: [1024],
  duration: [5],
  type: ['string', 'buffer'],
  algorithm: ['gzip', 'brotli'],
}, {
  test: {
    inputLen: 1024,
    duration: 0.2,
  },
});

function main({ inputLen, duration, type, algorithm }) {
  const buffer = Buffer.alloc(inputLen, fs.readFileSync(__filename));
  const chunk = type === 'buffer' ? buffer : buffer.toString('utf8');

  const input = algorithm === 'gzip' ?
    zlib.createGzip() : zlib.createBrotliCompress();
  const output = algorithm === 'gzip' ?
    zlib.createGunzip() : zlib.createBrotliDecompress();

  let readFromOutput = 0;
  input.pipe(output);
  if (type === 'string')
    output.setEncoding('utf8');
  output.on('data', (chunk) => readFromOutput += chunk.length);

  function write() {
    input.write(chunk, write);
  }

  bench.start();
  write();

  setTimeout(() => {
    // Give result in GBit/s, like the net benchmarks do
    bench.end(readFromOutput * 8 / (1024 ** 3));

    // Cut off writing the easy way.
    input.write = () => {};
  }, duration * 1000);
}
                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/codecov.yml                                                                             0000664 0000000 0000000 00000000740 14746647661 0014723 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        comment:
  # Only show diff and files changed:
  layout: diff, files
  # Don't post if no changes in coverage:
  require_changes: true

codecov:
  notify:
    # Wait for all coverage builds:
    # - coverage-linux.yml
    # - coverage-windows.yml [manually disabled see #50489]
    # - coverage-linux-without-intl.yml
    after_n_builds: 2

coverage:
  # Useful for blocking Pull Requests that don't meet a particular coverage threshold.
  status:
    project: off
    patch: off
                                node-23.7.0/common.gypi                                                                             0000664 0000000 0000000 00000062653 14746647661 0014753 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'variables': {
    'configuring_node%': 0,
    'asan%': 0,
    'ubsan%': 0,
    'visibility%': 'hidden',          # V8's visibility setting
    'target_arch%': 'ia32',           # set v8's target architecture
    'host_arch%': 'ia32',             # set v8's host architecture
    'want_separate_host_toolset%': 0, # V8 should not build target and host
    'library%': 'static_library',     # allow override to 'shared_library' for DLL/.so builds
    'component%': 'static_library',   # NB. these names match with what V8 expects
    'msvs_multi_core_compile': '0',   # we do enable multicore compiles, but not using the V8 way
    'enable_pgo_generate%': '0',
    'enable_pgo_use%': '0',
    'python%': 'python',

    'node_shared%': 'false',
    'force_dynamic_crt%': 0,
    'node_use_v8_platform%': 'true',
    'node_use_bundled_v8%': 'true',
    'node_module_version%': '',
    'node_with_ltcg%': '',
    'node_shared_openssl%': 'false',

    'node_tag%': '',
    'uv_library%': 'static_library',

    'clang%': 0,
    'error_on_warn%': 'false',

    'openssl_product': '<(STATIC_LIB_PREFIX)openssl<(STATIC_LIB_SUFFIX)',
    'openssl_no_asm%': 0,

    # Don't use ICU data file (icudtl.dat) from V8, we use our own.
    'icu_use_data_file_flag%': 0,

    # Reset this number to 0 on major V8 upgrades.
    # Increment by one for each non-official patch applied to deps/v8.
    'v8_embedder_string': '-node.12',

    ##### V8 defaults for Node.js #####

    # Turn on SipHash for hash seed generation, addresses HashWick
    'v8_use_siphash': 'true',

    # These are more relevant for V8 internal development.
    # Refs: https://github.com/nodejs/node/issues/23122
    # Refs: https://github.com/nodejs/node/issues/23167
    # Enable compiler warnings when using V8_DEPRECATED apis from V8 code.
    'v8_deprecation_warnings': 0,
    # Enable compiler warnings when using V8_DEPRECATE_SOON apis from V8 code.
    'v8_imminent_deprecation_warnings': 0,

    # Enable disassembler for `--print-code` v8 options
    'v8_enable_disassembler': 1,

    # Sets -dOBJECT_PRINT.
    'v8_enable_object_print%': 1,

    # https://github.com/nodejs/node/pull/22920/files#r222779926
    'v8_enable_handle_zapping': 0,

    # Disable pointer compression. Can be enabled at build time via configure
    # options but default values are required here as this file is also used by
    # node-gyp to build addons.
    'v8_enable_pointer_compression%': 0,
    'v8_enable_31bit_smis_on_64bit_arch%': 0,

    # Disable v8 hugepage by default.
    'v8_enable_hugepage%': 0,

    # This is more of a V8 dev setting
    # https://github.com/nodejs/node/pull/22920/files#r222779926
    'v8_enable_fast_mksnapshot': 0,

    'v8_win64_unwinding_info': 1,

    # Variables controlling external defines exposed in public headers.
    'v8_enable_conservative_stack_scanning%': 0,
    'v8_enable_direct_local%': 0,
    'v8_enable_map_packing%': 0,
    'v8_enable_pointer_compression_shared_cage%': 0,
    'v8_enable_sandbox%': 0,
    'v8_enable_v8_checks%': 0,
    'v8_enable_zone_compression%': 0,
    'v8_use_perfetto': 0,
    'tsan%': 0,

    ##### end V8 defaults #####

    'conditions': [
      ['OS == "win"', {
        'os_posix': 0,
        'v8_postmortem_support%': 0,
        'obj_dir': '<(PRODUCT_DIR)/obj',
        'v8_base': '<(PRODUCT_DIR)/lib/libv8_snapshot.a',
      }, {
        'os_posix': 1,
        'v8_postmortem_support%': 1,
      }],
      ['GENERATOR == "ninja"', {
        'obj_dir': '<(PRODUCT_DIR)/obj',
        'v8_base': '<(PRODUCT_DIR)/obj/tools/v8_gypfiles/libv8_snapshot.a',
      }, {
        'obj_dir%': '<(PRODUCT_DIR)/obj.target',
        'v8_base': '<(PRODUCT_DIR)/obj.target/tools/v8_gypfiles/libv8_snapshot.a',
      }],
      ['OS=="mac"', {
        'obj_dir%': '<(PRODUCT_DIR)/obj.target',
        'v8_base': '<(PRODUCT_DIR)/libv8_snapshot.a',
      }],
      # V8 pointer compression only supports 64bit architectures.
      ['target_arch in "arm ia32 mips mipsel ppc"', {
        'v8_enable_pointer_compression': 0,
        'v8_enable_31bit_smis_on_64bit_arch': 0,
        'v8_enable_sandbox': 0
      }],
      ['target_arch in "ppc64 s390x"', {
        'v8_enable_backtrace': 1,
      }],
      ['OS=="linux"', {
        'node_section_ordering_info%': ''
      }],
      ['OS == "zos"', {
        # use ICU data file on z/OS
        'icu_use_data_file_flag%': 1
      }]
    ],
  },

  'target_defaults': {
    'default_configuration': 'Release',
    'configurations': {
      'Debug': {
        'variables': {
          'v8_enable_handle_zapping': 1,
          'conditions': [
            ['node_shared != "true"', {
              'MSVC_runtimeType': 1,    # MultiThreadedDebug (/MTd)
            }, {
              'MSVC_runtimeType': 3,    # MultiThreadedDebugDLL (/MDd)
            }],
          ],
        },
        'defines': [ 'DEBUG', '_DEBUG' ],
        'cflags': [ '-g', '-O0' ],
        'conditions': [
          ['OS in "aix os400"', {
            'cflags': [ '-gxcoff' ],
            'ldflags': [ '-Wl,-bbigtoc' ],
          }],
          ['OS == "android"', {
            'cflags': [ '-fPIC' ],
            'ldflags': [ '-fPIC' ]
          }],
          ['clang==1', {
            'msbuild_toolset': 'ClangCL',
          }],
        ],
        'msvs_settings': {
          'VCCLCompilerTool': {
            'BasicRuntimeChecks': 3,        # /RTC1
            'MinimalRebuild': 'false',
            'OmitFramePointers': 'false',
            'Optimization': 0,              # /Od, no optimization
            'RuntimeLibrary': '<(MSVC_runtimeType)',
          },
          'VCLinkerTool': {
            'LinkIncremental': 2, # enable incremental linking
          },
        },
        'xcode_settings': {
          'GCC_OPTIMIZATION_LEVEL': '0', # stop gyp from defaulting to -Os
        },
      },
      'Release': {
        'variables': {
          'v8_enable_handle_zapping': 0,
          'pgo_generate': ' -fprofile-generate ',
          'pgo_use': ' -fprofile-use -fprofile-correction ',
          'conditions': [
            ['node_shared != "true"', {
              'MSVC_runtimeType': 0    # MultiThreaded (/MT)
            }, {
              'MSVC_runtimeType': 2   # MultiThreadedDLL (/MD)
            }],
            ['clang==1', {
              'lto': ' -flto ', # Clang
            }, {
              'lto': ' -flto=4 -fuse-linker-plugin -ffat-lto-objects ', # GCC
            }],
          ],
        },
        'cflags': [ '-O3' ],
        'conditions': [
          ['enable_lto=="true"', {
            'cflags': ['<(lto)'],
            'ldflags': ['<(lto)'],
            'xcode_settings': {
              'LLVM_LTO': 'YES',
            },
          }],
          ['OS=="linux"', {
            'conditions': [
              ['node_section_ordering_info!=""', {
                'cflags': [
                  '-fuse-ld=gold',
                  '-ffunction-sections',
                ],
                'ldflags': [
                  '-fuse-ld=gold',
                  '-Wl,--section-ordering-file=<(node_section_ordering_info)',
                ],
              }],
            ],
          }],
          ['OS=="solaris"', {
            # pull in V8's postmortem metadata
            'ldflags': [ '-Wl,-z,allextract' ]
          }],
          ['OS=="zos"', {
            # increase performance, number from experimentation
            'cflags': [ '-qINLINE=::150:100000' ]
          }],
          ['OS!="mac" and OS!="win" and OS!="zos"', {
            # -fno-omit-frame-pointer is necessary for the --perf_basic_prof
            # flag to work correctly. perf(1) gets confused about JS stack
            # frames otherwise, even with --call-graph dwarf.
            'cflags': [ '-fno-omit-frame-pointer' ],
          }],
          ['OS=="linux"', {
            'conditions': [
              ['enable_pgo_generate=="true"', {
                'cflags': ['<(pgo_generate)'],
                'ldflags': ['<(pgo_generate)'],
              },],
              ['enable_pgo_use=="true"', {
                'cflags': ['<(pgo_use)'],
                'ldflags': ['<(pgo_use)'],
              },],
            ],
          },],
          ['OS == "android"', {
            'cflags': [ '-fPIC', '-I<(android_ndk_path)/sources/android/cpufeatures' ],
            'ldflags': [ '-fPIC' ]
          }],
          ['clang==1', {
            'msbuild_toolset': 'ClangCL',
          }],
        ],
        'msvs_settings': {
          'VCCLCompilerTool': {
            'conditions': [
              ['target_arch=="arm64"', {
                'FloatingPointModel': 1 # /fp:strict
              }]
            ],
            'EnableFunctionLevelLinking': 'true',
            'EnableIntrinsicFunctions': 'true',
            'FavorSizeOrSpeed': 1,          # /Ot, favor speed over size
            'InlineFunctionExpansion': 2,   # /Ob2, inline anything eligible
            'OmitFramePointers': 'true',
            'Optimization': 3,              # /Ox, full optimization
            'RuntimeLibrary': '<(MSVC_runtimeType)',
            'RuntimeTypeInfo': 'false',
          }
        },
        'xcode_settings': {
          'GCC_OPTIMIZATION_LEVEL': '3', # stop gyp from defaulting to -Os
        },
      }
    },

    # Defines these mostly for node-gyp to pickup.
    'defines': [
      '_GLIBCXX_USE_CXX11_ABI=1',
    ],

    # Forcibly disable -Werror.  We support a wide range of compilers, it's
    # simply not feasible to squelch all warnings, never mind that the
    # libraries in deps/ are not under our control.
    'conditions': [
      [ 'error_on_warn=="false"', {
        'cflags!': ['-Werror'],
      }, '(_target_name!="<(node_lib_target_name)" or '
          '_target_name!="<(node_core_target_name)")', {
        'cflags!': ['-Werror'],
      }],
    ],
    'msvs_settings': {
      'VCCLCompilerTool': {
        # TODO(targos): Remove condition and always use LanguageStandard options
        # once node-gyp supports them.
        'conditions': [
          ['clang==1', {
            'LanguageStandard': 'stdcpp20',
            'LanguageStandard_C': 'stdc11',
            'AdditionalOptions': [
              '/Zc:__cplusplus',
              # The following option reduces the "error C1060: compiler is out of heap space"
              '/Zm2000',
            ],
          }, {
            'AdditionalOptions': [
              '/Zc:__cplusplus',
              # The following option enables c++20 on Windows. This is needed for V8 v12.4+
              '-std:c++20',
              # The following option reduces the "error C1060: compiler is out of heap space"
              '/Zm2000',
            ],
          }],
        ],
        'BufferSecurityCheck': 'true',
        'DebugInformationFormat': 1,          # /Z7 embed info in .obj files
        'ExceptionHandling': 0,               # /EHsc
        'MultiProcessorCompilation': 'true',
        'StringPooling': 'true',              # pool string literals
        'SuppressStartupBanner': 'true',
        'WarnAsError': 'false',
        'WarningLevel': 3,                    # /W3
      },
      'VCLinkerTool': {
        'target_conditions': [
          ['_type=="executable"', {
            'SubSystem': 1,                   # /SUBSYSTEM:CONSOLE
          }],
        ],
        'conditions': [
          ['target_arch=="ia32"', {
            'TargetMachine' : 1,              # /MACHINE:X86
          }],
          ['target_arch=="x64"', {
            'TargetMachine' : 17,             # /MACHINE:X64
          }],
          ['target_arch=="arm64"', {
            'TargetMachine' : 0,              # NotSet. MACHINE:ARM64 is inferred from the input files.
          }],
        ],
        'GenerateDebugInformation': 'true',
        'SuppressStartupBanner': 'true',
      },
    },
    # Disable warnings:
    # - "C4251: class needs to have dll-interface"
    # - "C4275: non-DLL-interface used as base for DLL-interface"
    #   Over 10k of these warnings are generated when compiling node,
    #   originating from v8.h. Most of them are false positives.
    #   See also: https://github.com/nodejs/node/pull/15570
    #   TODO: re-enable when Visual Studio fixes these upstream.
    #
    # - "C4267: conversion from 'size_t' to 'int'"
    #   Many any originate from our dependencies, and their sheer number
    #   drowns out other, more legitimate warnings.
    # - "C4244: conversion from 'type1' to 'type2', possible loss of data"
    #   Ususaly safe. Disable for `dep`, enable for `src`
    'msvs_disabled_warnings': [4351, 4355, 4800, 4251, 4275, 4244, 4267],
    'msvs_cygwin_shell': 0, # prevent actions from trying to use cygwin

    'conditions': [
      [ 'configuring_node', {
        'msvs_configuration_attributes': {
          'OutputDirectory': '<(DEPTH)/out/$(Configuration)/',
          'IntermediateDirectory': '$(OutDir)obj/$(ProjectName)/'
        },
      }],
      [ 'target_arch=="x64"', {
        'msvs_configuration_platform': 'x64',
      }],
      [ 'target_arch=="arm64"', {
        'msvs_configuration_platform': 'arm64',
      }],
      ['asan == 1 and OS != "mac" and OS != "zos"', {
        'cflags+': [
          '-fno-omit-frame-pointer',
          '-fsanitize=address',
          '-fsanitize-address-use-after-scope',
        ],
        'defines': [ 'LEAK_SANITIZER', 'V8_USE_ADDRESS_SANITIZER' ],
        'cflags!': [ '-fomit-frame-pointer' ],
        'ldflags': [ '-fsanitize=address' ],
      }],
      ['asan == 1 and OS == "mac"', {
        'xcode_settings': {
          'OTHER_CFLAGS+': [
            '-fno-omit-frame-pointer',
            '-gline-tables-only',
            '-fsanitize=address',
            '-DLEAK_SANITIZER'
          ],
          'OTHER_CFLAGS!': [
            '-fomit-frame-pointer',
          ],
        },
        'target_conditions': [
          ['_type!="static_library"', {
            'xcode_settings': {'OTHER_LDFLAGS': ['-fsanitize=address']},
          }],
        ],
      }],
      ['ubsan == 1 and OS != "mac" and OS != "zos"', {
        'cflags+': [
          '-fno-omit-frame-pointer',
          '-fsanitize=undefined',
        ],
        'defines': [ 'UNDEFINED_SANITIZER'],
        'cflags!': [ '-fno-omit-frame-pointer' ],
        'ldflags': [ '-fsanitize=undefined' ],
      }],
      ['ubsan == 1 and OS == "mac"', {
        'xcode_settings': {
          'OTHER_CFLAGS+': [
            '-fno-omit-frame-pointer',
            '-fsanitize=undefined',
            '-DUNDEFINED_SANITIZER'
          ],
        },
        'target_conditions': [
          ['_type!="static_library"', {
            'xcode_settings': {'OTHER_LDFLAGS': ['-fsanitize=undefined']},
          }],
        ],
      }],
      # The defines bellow must include all things from the external_v8_defines
      # list in v8/BUILD.gn.
      ['v8_enable_v8_checks == 1', {
        'defines': ['V8_ENABLE_CHECKS'],
      }],
      ['v8_enable_pointer_compression == 1', {
        'defines': ['V8_COMPRESS_POINTERS'],
      }],
      ['v8_enable_pointer_compression_shared_cage == 1', {
        'defines': ['V8_COMPRESS_POINTERS_IN_SHARED_CAGE'],
      }],
      ['v8_enable_pointer_compression == 1 and v8_enable_pointer_compression_shared_cage != 1', {
        'defines': ['V8_COMPRESS_POINTERS_IN_ISOLATE_CAGE'],
      }],
      ['v8_enable_pointer_compression == 1 or v8_enable_31bit_smis_on_64bit_arch == 1', {
        'defines': ['V8_31BIT_SMIS_ON_64BIT_ARCH'],
      }],
      ['v8_enable_zone_compression == 1', {
        'defines': ['V8_COMPRESS_ZONES',],
      }],
      ['v8_enable_sandbox == 1', {
        'defines': ['V8_ENABLE_SANDBOX',],
      }],
      ['v8_deprecation_warnings == 1', {
        'defines': ['V8_DEPRECATION_WARNINGS',],
      }],
      ['v8_imminent_deprecation_warnings == 1', {
        'defines': ['V8_IMMINENT_DEPRECATION_WARNINGS',],
      }],
      ['v8_use_perfetto == 1', {
        'defines': ['V8_USE_PERFETTO',],
      }],
      ['v8_enable_map_packing == 1', {
        'defines': ['V8_MAP_PACKING',],
      }],
      ['tsan == 1', {
        'defines': ['V8_IS_TSAN',],
      }],
      ['v8_enable_conservative_stack_scanning == 1', {
        'defines': ['V8_ENABLE_CONSERVATIVE_STACK_SCANNING',],
      }],
      ['v8_enable_direct_local == 1', {
        'defines': ['V8_ENABLE_DIRECT_LOCAL',],
      }],
      ['OS == "win"', {
        'defines': [
          'WIN32',
          # we don't really want VC++ warning us about
          # how dangerous C functions are...
          '_CRT_SECURE_NO_DEPRECATE',
          # ... or that C implementations shouldn't use
          # POSIX names
          '_CRT_NONSTDC_NO_DEPRECATE',
          # Make sure the STL doesn't try to use exceptions
          '_HAS_EXCEPTIONS=0',
          'BUILDING_V8_SHARED=1',
          'BUILDING_UV_SHARED=1',
          # Stop <windows.h> from defining macros that conflict with
          # std::min() and std::max().  We don't use <windows.h> (much)
          # but we still inherit it from uv.h.
          'NOMINMAX',
        ],
      }],
      [ 'OS in "linux freebsd openbsd solaris aix os400"', {
        'cflags': [ '-pthread' ],
        'ldflags': [ '-pthread' ],
      }],
      [ 'OS in "linux freebsd openbsd solaris android aix os400 cloudabi"', {
        'cflags': [ '-Wall', '-Wextra', '-Wno-unused-parameter', ],
        'cflags_cc': [
          '-fno-rtti',
          '-fno-exceptions',
          '-fno-strict-aliasing',
          '-std=gnu++20',
        ],
        'defines': [ '__STDC_FORMAT_MACROS' ],
        'ldflags': [ '-rdynamic' ],
        'target_conditions': [
          # The 1990s toolchain on SmartOS can't handle thin archives.
          ['_type=="static_library" and OS=="solaris"', {
            'standalone_static_library': 1,
          }],
          ['OS=="openbsd"', {
            'cflags': [ '-I/usr/local/include' ],
            'ldflags': [ '-Wl,-z,wxneeded' ],
          }],
          ['_toolset=="host"', {
            'conditions': [
              [ 'host_arch=="ia32"', {
                'cflags': [ '-m32' ],
                'ldflags': [ '-m32' ],
              }],
              [ 'host_arch=="x64"', {
                'cflags': [ '-m64' ],
                'ldflags': [ '-m64' ],
              }],
              [ 'host_arch=="ppc" and OS not in "aix os400"', {
                'cflags': [ '-m32' ],
                'ldflags': [ '-m32' ],
              }],
              [ 'host_arch=="ppc64" and OS not in "aix os400"', {
                'cflags': [ '-m64', '-mminimal-toc' ],
                'ldflags': [ '-m64' ],
              }],
              [ 'host_arch=="s390x" and OS=="linux"', {
                'cflags': [ '-m64', '-march=z196' ],
                'ldflags': [ '-m64', '-march=z196' ],
              }],
            ],
          }],
          ['_toolset=="target"', {
            'conditions': [
              [ 'target_arch=="ia32"', {
                'cflags': [ '-m32' ],
                'ldflags': [ '-m32' ],
              }],
              [ 'target_arch=="x64"', {
                'cflags': [ '-m64' ],
                'ldflags': [ '-m64' ],
              }],
              [ 'target_arch=="ppc" and OS not in "aix os400"', {
                'cflags': [ '-m32' ],
                'ldflags': [ '-m32' ],
              }],
              [ 'target_arch=="ppc64" and OS not in "aix os400"', {
                'cflags': [ '-m64', '-mminimal-toc' ],
                'ldflags': [ '-m64' ],
              }],
              [ 'target_arch=="s390x" and OS=="linux"', {
                'cflags': [ '-m64', '-march=z196' ],
                'ldflags': [ '-m64', '-march=z196' ],
              }],
            ],
          }],
        ],
        'conditions': [
          [ 'OS=="solaris"', {
            'cflags': [ '-pthreads' ],
            'ldflags': [ '-pthreads' ],
            'cflags!': [ '-pthread' ],
            'ldflags!': [ '-pthread' ],
          }],
          [ 'node_shared=="true"', {
            'cflags': [ '-fPIC' ],
          }],
        ],
      }],
      [ 'OS in "aix os400"', {
        'variables': {
          # Used to differentiate `AIX` and `OS400`(IBM i).
          'aix_variant_name': '<!(uname -s)',
        },
        'cflags': [ '-maix64', ],
        'ldflags!': [ '-rdynamic', ],
        'ldflags': [
          '-Wl,-bbigtoc',
          '-maix64',
        ],
        'conditions': [
          [ '"<(aix_variant_name)"=="OS400"', {            # a.k.a. `IBM i`
            'ldflags': [
              '-Wl,-blibpath:/QOpenSys/pkgs/lib:/QOpenSys/usr/lib',
              '-Wl,-brtl',
            ],
          }, {                                             # else it's `AIX`
            'variables': {
              'gcc_major': '<!(<(python) -c "import os; import subprocess; CXX=os.environ.get(\'CXX\', \'g++\'); subprocess.run([CXX, \'-dumpversion\'])")'
            },
            # Disable the following compiler warning:
            #
            #   warning: visibility attribute not supported in this
            #   configuration; ignored [-Wattributes]
            #
            # This is gcc complaining about __attribute((visibility("default"))
            # in static library builds. Legitimate but harmless and it drowns
            # out more relevant warnings.
            'cflags': [ '-Wno-attributes' ],
            'ldflags': [
              '-Wl,-blibpath:/usr/lib:/lib:/opt/freeware/lib/gcc/powerpc-ibm-aix7.3.0.0/>(gcc_major)/pthread/ppc64:/opt/freeware/lib/gcc/powerpc-ibm-aix7.2.0.0/>(gcc_major)/pthread/ppc64:/opt/freeware/lib/pthread/ppc64',
            ],
          }],
        ],
      }],
      ['OS=="android"', {
        'target_conditions': [
          ['_toolset=="target"', {
            'defines': [ '_GLIBCXX_USE_C99_MATH' ],
            'libraries': [ '-llog' ],
          }],
          ['_toolset=="host"', {
            'cflags': [ '-pthread' ],
            'ldflags': [ '-pthread' ],
          }],
        ],
      }],
      ['OS=="mac"', {
        'defines': ['_DARWIN_USE_64_BIT_INODE=1'],
        'xcode_settings': {
          'ALWAYS_SEARCH_USER_PATHS': 'NO',
          'GCC_CW_ASM_SYNTAX': 'NO',                # No -fasm-blocks
          'GCC_DYNAMIC_NO_PIC': 'NO',               # No -mdynamic-no-pic
                                                    # (Equivalent to -fPIC)
          'GCC_ENABLE_CPP_EXCEPTIONS': 'NO',        # -fno-exceptions
          'GCC_ENABLE_CPP_RTTI': 'NO',              # -fno-rtti
          'GCC_ENABLE_PASCAL_STRINGS': 'NO',        # No -mpascal-strings
          'GCC_STRICT_ALIASING': 'NO',              # -fno-strict-aliasing
          'PREBINDING': 'NO',                       # No -Wl,-prebind
          'MACOSX_DEPLOYMENT_TARGET': '11.0',       # -mmacosx-version-min=11.0
          'USE_HEADERMAP': 'NO',
          'WARNING_CFLAGS': [
            '-Wall',
            '-Wendif-labels',
            '-W',
            '-Wno-unused-parameter',
          ],
        },
        'target_conditions': [
          ['_type!="static_library"', {
            'xcode_settings': {
              'OTHER_LDFLAGS': [
                '-Wl,-search_paths_first'
              ],
            },
          }],
        ],
        'conditions': [
          ['target_arch=="ia32"', {
            'xcode_settings': {'ARCHS': ['i386']},
          }],
          ['target_arch=="x64"', {
            'xcode_settings': {'ARCHS': ['x86_64']},
          }],
          ['target_arch=="arm64"', {
            'xcode_settings': {
              'ARCHS': ['arm64'],
              'OTHER_LDFLAGS!': [
                '-Wl,-no_pie',
              ],
            },
          }],
          ['clang==1', {
            'xcode_settings': {
              'GCC_VERSION': 'com.apple.compilers.llvm.clang.1_0',
              'CLANG_CXX_LANGUAGE_STANDARD': 'gnu++20',  # -std=gnu++20
              'CLANG_CXX_LIBRARY': 'libc++',
            },
          }],
        ],
      }],
      ['OS=="freebsd"', {
        'ldflags': [
          '-Wl,--export-dynamic',
        ],
      }],
      # if node is built as an executable,
      #      the openssl mechanism for keeping itself "dload"-ed to ensure proper
      #      atexit cleanup does not apply
      ['node_shared_openssl!="true" and node_shared!="true"', {
        'defines': [
          # `OPENSSL_NO_PINSHARED` prevents openssl from dload
          #      current node executable,
          #      see https://github.com/nodejs/node/pull/21848
          #      or https://github.com/nodejs/node/issues/27925
          'OPENSSL_NO_PINSHARED'
        ],
      }],
      ['node_shared_openssl!="true"', {
        # `OPENSSL_THREADS` is defined via GYP for openSSL for all architectures.
        'defines': [
          'OPENSSL_THREADS',
        ],
      }],
      ['node_shared_openssl!="true" and openssl_no_asm==1', {
        'defines': [
          'OPENSSL_NO_ASM',
        ],
      }],
      ['OS == "zos"', {
        'defines': [
          '_XOPEN_SOURCE_EXTENDED',
          '_XOPEN_SOURCE=600',
          '_UNIX03_THREADS',
          '_UNIX03_WITHDRAWN',
          '_UNIX03_SOURCE',
          '_OPEN_SYS_SOCK_IPV6',
          '_OPEN_SYS_FILE_EXT=1',
          '_POSIX_SOURCE',
          '_OPEN_SYS',
          '_OPEN_SYS_IF_EXT',
          '_OPEN_SYS_SOCK_IPV6',
          '_OPEN_MSGQ_EXT',
          '_LARGE_TIME_API',
          '_ALL_SOURCE',
          '_AE_BIMODAL=1',
          '__IBMCPP_TR1__',
          'NODE_PLATFORM="os390"',
          'PATH_MAX=1024',
          '_ENHANCED_ASCII_EXT=0xFFFFFFFF',
          '_Export=extern',
          '__static_assert=static_assert',
        ],
        'cflags': [
          '-q64',
          '-Wc,DLL',
          '-Wa,GOFF',
          '-qARCH=10',
          '-qASCII',
          '-qTUNE=12',
          '-qENUM=INT',
          '-qEXPORTALL',
          '-qASM',
        ],
        'cflags_cc': [
          '-qxclang=-std=c++14',
        ],
        'ldflags': [
          '-q64',
        ],
        # for addons due to v8config.h include of "zos-base.h":
        'include_dirs':  ['<(zoslib_include_dir)'],
      }],
    ],
  }
}
                                                                                     node-23.7.0/configure                                                                               0000775 0000000 0000000 00000002627 14746647661 0014473 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #!/bin/sh

# Locate an acceptable Python interpreter and then re-execute the script.
# Note that the mix of single and double quotes is intentional,
# as is the fact that the ] goes on a new line.
_=[ 'exec' '/bin/sh' '-c' '''
command -v python3.13 >/dev/null && exec python3.13 "$0" "$@"
command -v python3.12 >/dev/null && exec python3.12 "$0" "$@"
command -v python3.11 >/dev/null && exec python3.11 "$0" "$@"
command -v python3.10 >/dev/null && exec python3.10 "$0" "$@"
command -v python3.9 >/dev/null && exec python3.9 "$0" "$@"
command -v python3.8 >/dev/null && exec python3.8 "$0" "$@"
command -v python3 >/dev/null && exec python3 "$0" "$@"
exec python "$0" "$@"
''' "$0" "$@"
]
del _

import sys
try:
  from shutil import which
except ImportError:
  from distutils.spawn import find_executable as which

print('Node.js configure: Found Python {}.{}.{}...'.format(*sys.version_info))
acceptable_pythons = ((3, 13), (3, 12), (3, 11), (3, 10), (3, 9), (3, 8))
if sys.version_info[:2] in acceptable_pythons:
  import configure
else:
  python_cmds = ['python{}.{}'.format(*vers) for vers in acceptable_pythons]
  sys.stderr.write('Please use {}.\n'.format(' or '.join(python_cmds)))
  for python_cmd in python_cmds:
      python_cmd_path = which(python_cmd)
      if python_cmd_path and 'pyenv/shims' not in python_cmd_path:
        sys.stderr.write('\t{} {}\n'.format(python_cmd_path, ' '.join(sys.argv[:1])))
  sys.exit(1)
                                                                                                         node-23.7.0/configure.py                                                                            0000775 0000000 0000000 00000243576 14746647661 0015134 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        from __future__ import print_function

import json
import sys
import errno
import argparse
import os
import pprint
import re
import shlex
import subprocess
import shutil
import bz2
import io
from pathlib import Path

# If not run from node/, cd to node/.
os.chdir(Path(__file__).parent)

original_argv = sys.argv[1:]

# gcc and g++ as defaults matches what GYP's Makefile generator does,
# except on OS X.
CC = os.environ.get('CC', 'cc' if sys.platform == 'darwin' else 'gcc')
CXX = os.environ.get('CXX', 'c++' if sys.platform == 'darwin' else 'g++')

tools_path = Path('tools')

sys.path.insert(0, str(tools_path / 'gyp' / 'pylib'))
from gyp.common import GetFlavor
from packaging.version import Version

# imports in tools/configure.d
sys.path.insert(0, str(tools_path / 'configure.d'))
import nodedownload

# imports in tools/
sys.path.insert(0, 'tools')
import getmoduleversion
import getnapibuildversion
import getsharedopensslhasquic
from gyp_node import run_gyp
from utils import SearchFiles

# parse our options
parser = argparse.ArgumentParser()

valid_os = ('win', 'mac', 'solaris', 'freebsd', 'openbsd', 'linux',
            'android', 'aix', 'cloudabi', 'os400', 'ios')
valid_arch = ('arm', 'arm64', 'ia32', 'mips', 'mipsel', 'mips64el', 'ppc',
              'ppc64', 'x64', 'x86', 'x86_64', 's390x', 'riscv64', 'loong64')
valid_arm_float_abi = ('soft', 'softfp', 'hard')
valid_arm_fpu = ('vfp', 'vfpv3', 'vfpv3-d16', 'neon')
valid_mips_arch = ('loongson', 'r1', 'r2', 'r6', 'rx')
valid_mips_fpu = ('fp32', 'fp64', 'fpxx')
valid_mips_float_abi = ('soft', 'hard')
valid_intl_modes = ('none', 'small-icu', 'full-icu', 'system-icu')
icu_versions = json.loads((tools_path / 'icu' / 'icu_versions.json').read_text(encoding='utf-8'))
maglev_enabled_architectures = ('x64', 'arm', 'arm64')

# builtins may be removed later if they have been disabled by options
shareable_builtins = {'cjs_module_lexer/lexer': 'deps/cjs-module-lexer/lexer.js',
                     'cjs_module_lexer/dist/lexer': 'deps/cjs-module-lexer/dist/lexer.js',
                     'undici/undici': 'deps/undici/undici.js',
                     'amaro/dist/index': 'deps/amaro/dist/index.js'
}

# create option groups
shared_optgroup = parser.add_argument_group("Shared libraries",
    "Flags that allows you to control whether you want to build against "
    "built-in dependencies or its shared representations. If necessary, "
    "provide multiple libraries with comma.")
static_optgroup = parser.add_argument_group("Static libraries",
    "Flags that allows you to control whether you want to build against "
    "additional static libraries.")
intl_optgroup = parser.add_argument_group("Internationalization",
    "Flags that lets you enable i18n features in Node.js as well as which "
    "library you want to build against.")
http2_optgroup = parser.add_argument_group("HTTP2",
    "Flags that allows you to control HTTP2 features in Node.js")
shared_builtin_optgroup = parser.add_argument_group("Shared builtins",
    "Flags that allows you to control whether you want to build against "
    "internal builtins or shared files.")

# Options should be in alphabetical order but keep --prefix at the top,
# that's arguably the one people will be looking for most.
parser.add_argument('--prefix',
    action='store',
    dest='prefix',
    default='/usr/local',
    help='select the install prefix [default: %(default)s]')

parser.add_argument('--coverage',
    action='store_true',
    dest='coverage',
    default=None,
    help='Build node with code coverage enabled')

parser.add_argument('--debug',
    action='store_true',
    dest='debug',
    default=None,
    help='also build debug build')

parser.add_argument('--debug-node',
    action='store_true',
    dest='debug_node',
    default=None,
    help='build the Node.js part of the binary with debugging symbols')

parser.add_argument('--dest-cpu',
    action='store',
    dest='dest_cpu',
    choices=valid_arch,
    help=f"CPU architecture to build for ({', '.join(valid_arch)})")

parser.add_argument('--cross-compiling',
    action='store_true',
    dest='cross_compiling',
    default=None,
    help='force build to be considered as cross compiled')
parser.add_argument('--no-cross-compiling',
    action='store_false',
    dest='cross_compiling',
    default=None,
    help='force build to be considered as NOT cross compiled')

parser.add_argument('--use-prefix-to-find-headers',
    action='store_true',
    dest='use_prefix_to_find_headers',
    default=None,
    help='use the prefix to look for pre-installed headers')

parser.add_argument('--use_clang',
    action='store_true',
    dest='use_clang',
    default=None,
    help='use clang instead of gcc')

parser.add_argument('--dest-os',
    action='store',
    dest='dest_os',
    choices=valid_os,
    help=f"operating system to build for ({', '.join(valid_os)})")

parser.add_argument('--error-on-warn',
    action='store_true',
    dest='error_on_warn',
    default=None,
    help='Turn compiler warnings into errors for node core sources.')

parser.add_argument('--gdb',
    action='store_true',
    dest='gdb',
    default=None,
    help='add gdb support')

parser.add_argument('--no-ifaddrs',
    action='store_true',
    dest='no_ifaddrs',
    default=None,
    help='use on deprecated SunOS systems that do not support ifaddrs.h')

parser.add_argument('--disable-single-executable-application',
    action='store_true',
    dest='disable_single_executable_application',
    default=None,
    help='Disable Single Executable Application support.')

parser.add_argument("--fully-static",
    action="store_true",
    dest="fully_static",
    default=None,
    help="Generate an executable without external dynamic libraries. This "
         "will not work on macOS when using the default compilation environment")

parser.add_argument("--partly-static",
    action="store_true",
    dest="partly_static",
    default=None,
    help="Generate an executable with libgcc and libstdc++ libraries. This "
         "will not work on macOS when using the default compilation environment")

parser.add_argument("--enable-vtune-profiling",
    action="store_true",
    dest="enable_vtune_profiling",
    help="Enable profiling support for Intel VTune profiler to profile "
         "JavaScript code executed in Node.js. This feature is only available "
         "for x32, x86, and x64 architectures.")

parser.add_argument("--enable-pgo-generate",
    action="store_true",
    dest="enable_pgo_generate",
    default=None,
    help="Enable profiling with pgo of a binary. This feature is only available "
         "on linux with gcc and g++ 5.4.1 or newer.")

parser.add_argument("--enable-pgo-use",
    action="store_true",
    dest="enable_pgo_use",
    default=None,
    help="Enable use of the profile generated with --enable-pgo-generate. This "
         "feature is only available on linux with gcc and g++ 5.4.1 or newer.")

parser.add_argument("--enable-lto",
    action="store_true",
    dest="enable_lto",
    default=None,
    help="Enable compiling with lto of a binary. This feature is only available "
         "with gcc 5.4.1+ or clang 3.9.1+.")

parser.add_argument("--link-module",
    action="append",
    dest="linked_module",
    help="Path to a JS file to be bundled in the binary as a builtin. "
         "This module will be referenced by path without extension; "
         "e.g. /root/x/y.js will be referenced via require('root/x/y'). "
         "Can be used multiple times")

parser.add_argument("--openssl-conf-name",
    action="store",
    dest="openssl_conf_name",
    default='nodejs_conf',
    help="The OpenSSL config appname (config section name) used by Node.js")

parser.add_argument('--openssl-default-cipher-list',
    action='store',
    dest='openssl_default_cipher_list',
    help='Use the specified cipher list as the default cipher list')

parser.add_argument("--openssl-no-asm",
    action="store_true",
    dest="openssl_no_asm",
    default=None,
    help="Do not build optimized assembly for OpenSSL")

parser.add_argument('--openssl-is-fips',
    action='store_true',
    dest='openssl_is_fips',
    default=None,
    help='specifies that the OpenSSL library is FIPS compatible')

parser.add_argument('--openssl-use-def-ca-store',
    action='store_true',
    dest='use_openssl_ca_store',
    default=None,
    help='Use OpenSSL supplied CA store instead of compiled-in Mozilla CA copy.')

parser.add_argument('--openssl-system-ca-path',
    action='store',
    dest='openssl_system_ca_path',
    help='Use the specified path to system CA (PEM format) in addition to '
         'the OpenSSL supplied CA store or compiled-in Mozilla CA copy.')

parser.add_argument('--experimental-http-parser',
    action='store_true',
    dest='experimental_http_parser',
    default=None,
    help='(no-op)')

shared_optgroup.add_argument('--shared-http-parser',
    action='store_true',
    dest='shared_http_parser',
    default=None,
    help='link to a shared http_parser DLL instead of static linking')

shared_optgroup.add_argument('--shared-http-parser-includes',
    action='store',
    dest='shared_http_parser_includes',
    help='directory containing http_parser header files')

shared_optgroup.add_argument('--shared-http-parser-libname',
    action='store',
    dest='shared_http_parser_libname',
    default='http_parser',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-http-parser-libpath',
    action='store',
    dest='shared_http_parser_libpath',
    help='a directory to search for the shared http_parser DLL')

shared_optgroup.add_argument('--shared-libuv',
    action='store_true',
    dest='shared_libuv',
    default=None,
    help='link to a shared libuv DLL instead of static linking')

shared_optgroup.add_argument('--shared-libuv-includes',
    action='store',
    dest='shared_libuv_includes',
    help='directory containing libuv header files')

shared_optgroup.add_argument('--shared-libuv-libname',
    action='store',
    dest='shared_libuv_libname',
    default='uv',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-libuv-libpath',
    action='store',
    dest='shared_libuv_libpath',
    help='a directory to search for the shared libuv DLL')

shared_optgroup.add_argument('--shared-nghttp2',
    action='store_true',
    dest='shared_nghttp2',
    default=None,
    help='link to a shared nghttp2 DLL instead of static linking')

shared_optgroup.add_argument('--shared-nghttp2-includes',
    action='store',
    dest='shared_nghttp2_includes',
    help='directory containing nghttp2 header files')

shared_optgroup.add_argument('--shared-nghttp2-libname',
    action='store',
    dest='shared_nghttp2_libname',
    default='nghttp2',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-nghttp2-libpath',
    action='store',
    dest='shared_nghttp2_libpath',
    help='a directory to search for the shared nghttp2 DLLs')

shared_optgroup.add_argument('--shared-nghttp3',
    action='store_true',
    dest='shared_nghttp3',
    default=None,
    help='link to a shared nghttp3 DLL instead of static linking')

shared_optgroup.add_argument('--shared-nghttp3-includes',
    action='store',
    dest='shared_nghttp3_includes',
    help='directory containing nghttp3 header files')

shared_optgroup.add_argument('--shared-nghttp3-libname',
    action='store',
    dest='shared_nghttp3_libname',
    default='nghttp3',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-nghttp3-libpath',
    action='store',
    dest='shared_nghttp3_libpath',
    help='a directory to search for the shared nghttp3 DLLs')

shared_optgroup.add_argument('--shared-ngtcp2',
    action='store_true',
    dest='shared_ngtcp2',
    default=None,
    help='link to a shared ngtcp2 DLL instead of static linking')

shared_optgroup.add_argument('--shared-ngtcp2-includes',
    action='store',
    dest='shared_ngtcp2_includes',
    help='directory containing ngtcp2 header files')

shared_optgroup.add_argument('--shared-ngtcp2-libname',
    action='store',
    dest='shared_ngtcp2_libname',
    default='ngtcp2',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-ngtcp2-libpath',
    action='store',
    dest='shared_ngtcp2_libpath',
    help='a directory to search for the shared tcp2 DLLs')

shared_optgroup.add_argument('--shared-openssl',
    action='store_true',
    dest='shared_openssl',
    default=None,
    help='link to a shared OpenSSl DLL instead of static linking')

shared_optgroup.add_argument('--shared-openssl-includes',
    action='store',
    dest='shared_openssl_includes',
    help='directory containing OpenSSL header files')

shared_optgroup.add_argument('--shared-openssl-libname',
    action='store',
    dest='shared_openssl_libname',
    default='crypto,ssl',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-openssl-libpath',
    action='store',
    dest='shared_openssl_libpath',
    help='a directory to search for the shared OpenSSL DLLs')

shared_optgroup.add_argument('--shared-uvwasi',
    action='store_true',
    dest='shared_uvwasi',
    default=None,
    help='link to a shared uvwasi DLL instead of static linking')

shared_optgroup.add_argument('--shared-uvwasi-includes',
    action='store',
    dest='shared_uvwasi_includes',
    help='directory containing uvwasi header files')

shared_optgroup.add_argument('--shared-uvwasi-libname',
    action='store',
    dest='shared_uvwasi_libname',
    default='uvwasi',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-uvwasi-libpath',
    action='store',
    dest='shared_uvwasi_libpath',
    help='a directory to search for the shared uvwasi DLL')

shared_optgroup.add_argument('--shared-zlib',
    action='store_true',
    dest='shared_zlib',
    default=None,
    help='link to a shared zlib DLL instead of static linking')

shared_optgroup.add_argument('--shared-zlib-includes',
    action='store',
    dest='shared_zlib_includes',
    help='directory containing zlib header files')

shared_optgroup.add_argument('--shared-zlib-libname',
    action='store',
    dest='shared_zlib_libname',
    default='z',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-zlib-libpath',
    action='store',
    dest='shared_zlib_libpath',
    help='a directory to search for the shared zlib DLL')

shared_optgroup.add_argument('--shared-simdjson',
    action='store_true',
    dest='shared_simdjson',
    default=None,
    help='link to a shared simdjson DLL instead of static linking')

shared_optgroup.add_argument('--shared-simdjson-includes',
    action='store',
    dest='shared_simdjson_includes',
    help='directory containing simdjson header files')

shared_optgroup.add_argument('--shared-simdjson-libname',
    action='store',
    dest='shared_simdjson_libname',
    default='simdjson',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-simdjson-libpath',
    action='store',
    dest='shared_simdjson_libpath',
    help='a directory to search for the shared simdjson DLL')


shared_optgroup.add_argument('--shared-simdutf',
    action='store_true',
    dest='shared_simdutf',
    default=None,
    help='link to a shared simdutf DLL instead of static linking')

shared_optgroup.add_argument('--shared-simdutf-includes',
    action='store',
    dest='shared_simdutf_includes',
    help='directory containing simdutf header files')

shared_optgroup.add_argument('--shared-simdutf-libname',
    action='store',
    dest='shared_simdutf_libname',
    default='simdutf',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-simdutf-libpath',
    action='store',
    dest='shared_simdutf_libpath',
    help='a directory to search for the shared simdutf DLL')


shared_optgroup.add_argument('--shared-ada',
    action='store_true',
    dest='shared_ada',
    default=None,
    help='link to a shared ada DLL instead of static linking')

shared_optgroup.add_argument('--shared-ada-includes',
    action='store',
    dest='shared_ada_includes',
    help='directory containing ada header files')

shared_optgroup.add_argument('--shared-ada-libname',
    action='store',
    dest='shared_ada_libname',
    default='ada',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-ada-libpath',
    action='store',
    dest='shared_ada_libpath',
    help='a directory to search for the shared ada DLL')

shared_optgroup.add_argument('--shared-brotli',
    action='store_true',
    dest='shared_brotli',
    default=None,
    help='link to a shared brotli DLL instead of static linking')

shared_optgroup.add_argument('--shared-brotli-includes',
    action='store',
    dest='shared_brotli_includes',
    help='directory containing brotli header files')

shared_optgroup.add_argument('--shared-brotli-libname',
    action='store',
    dest='shared_brotli_libname',
    default='brotlidec,brotlienc',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-brotli-libpath',
    action='store',
    dest='shared_brotli_libpath',
    help='a directory to search for the shared brotli DLL')

shared_optgroup.add_argument('--shared-cares',
    action='store_true',
    dest='shared_cares',
    default=None,
    help='link to a shared cares DLL instead of static linking')

shared_optgroup.add_argument('--shared-cares-includes',
    action='store',
    dest='shared_cares_includes',
    help='directory containing cares header files')

shared_optgroup.add_argument('--shared-cares-libname',
    action='store',
    dest='shared_cares_libname',
    default='cares',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-cares-libpath',
    action='store',
    dest='shared_cares_libpath',
    help='a directory to search for the shared cares DLL')

shared_optgroup.add_argument('--shared-sqlite',
    action='store_true',
    dest='shared_sqlite',
    default=None,
    help='link to a shared sqlite DLL instead of static linking')

shared_optgroup.add_argument('--shared-sqlite-includes',
    action='store',
    dest='shared_sqlite_includes',
    help='directory containing sqlite header files')

shared_optgroup.add_argument('--shared-sqlite-libname',
    action='store',
    dest='shared_sqlite_libname',
    default='sqlite3',
    help='alternative lib name to link to [default: %(default)s]')

shared_optgroup.add_argument('--shared-sqlite-libpath',
    action='store',
    dest='shared_sqlite_libpath',
    help='a directory to search for the shared sqlite DLL')


for builtin in shareable_builtins:
  builtin_id = 'shared_builtin_' + builtin + '_path'
  shared_builtin_optgroup.add_argument('--shared-builtin-' + builtin + '-path',
    action='store',
    dest='node_shared_builtin_' + builtin.replace('/', '_') + '_path',
    help='Path to shared file for ' + builtin + ' builtin. '
         'Will be used instead of bundled version at runtime')

static_optgroup.add_argument('--static-zoslib-gyp',
    action='store',
    dest='static_zoslib_gyp',
    help='path to zoslib.gyp file for includes and to link to static zoslib library')

parser.add_argument('--tag',
    action='store',
    dest='tag',
    help='custom build tag')

parser.add_argument('--release-urlbase',
    action='store',
    dest='release_urlbase',
    help='Provide a custom URL prefix for the `process.release` properties '
         '`sourceUrl` and `headersUrl`. When compiling a release build, this '
         'will default to https://nodejs.org/download/release/')

parser.add_argument('--enable-d8',
    action='store_true',
    dest='enable_d8',
    default=None,
    help=argparse.SUPPRESS)  # Unsupported, undocumented.

parser.add_argument('--enable-trace-maps',
    action='store_true',
    dest='trace_maps',
    default=None,
    help='Enable the --trace-maps flag in V8 (use at your own risk)')

parser.add_argument('--experimental-enable-pointer-compression',
    action='store_true',
    dest='enable_pointer_compression',
    default=None,
    help='[Experimental] Enable V8 pointer compression (limits max heap to 4GB and breaks ABI compatibility)')

parser.add_argument('--disable-shared-readonly-heap',
    action='store_true',
    dest='disable_shared_ro_heap',
    default=None,
    help='Disable the shared read-only heap feature in V8')

parser.add_argument('--v8-options',
    action='store',
    dest='v8_options',
    help='v8 options to pass, see `node --v8-options` for examples.')

parser.add_argument('--with-ossfuzz',
    action='store_true',
    dest='ossfuzz',
    default=None,
    help='Enables building of fuzzers. This command should be run in an OSS-Fuzz Docker image.')

parser.add_argument('--with-arm-float-abi',
    action='store',
    dest='arm_float_abi',
    choices=valid_arm_float_abi,
    help=f"specifies which floating-point ABI to use ({', '.join(valid_arm_float_abi)}).")

parser.add_argument('--with-arm-fpu',
    action='store',
    dest='arm_fpu',
    choices=valid_arm_fpu,
    help=f"ARM FPU mode ({', '.join(valid_arm_fpu)}) [default: %(default)s]")

parser.add_argument('--with-mips-arch-variant',
    action='store',
    dest='mips_arch_variant',
    default='r2',
    choices=valid_mips_arch,
    help=f"MIPS arch variant ({', '.join(valid_mips_arch)}) [default: %(default)s]")

parser.add_argument('--with-mips-fpu-mode',
    action='store',
    dest='mips_fpu_mode',
    default='fp32',
    choices=valid_mips_fpu,
    help=f"MIPS FPU mode ({', '.join(valid_mips_fpu)}) [default: %(default)s]")

parser.add_argument('--with-mips-float-abi',
    action='store',
    dest='mips_float_abi',
    default='hard',
    choices=valid_mips_float_abi,
    help=f"MIPS floating-point ABI ({', '.join(valid_mips_float_abi)}) [default: %(default)s]")

parser.add_argument('--use-largepages',
    action='store_true',
    dest='node_use_large_pages',
    default=None,
    help='This option has no effect. --use-largepages is now a runtime option.')

parser.add_argument('--use-largepages-script-lld',
    action='store_true',
    dest='node_use_large_pages_script_lld',
    default=None,
    help='This option has no effect. --use-largepages is now a runtime option.')

parser.add_argument('--use-section-ordering-file',
    action='store',
    dest='node_section_ordering_info',
    default='',
    help='Pass a section ordering file to the linker. This requires that ' +
         'Node.js be linked using the gold linker. The gold linker must have ' +
         'version 1.2 or greater.')

intl_optgroup.add_argument('--with-intl',
    action='store',
    dest='with_intl',
    default='full-icu',
    choices=valid_intl_modes,
    help=f"Intl mode (valid choices: {', '.join(valid_intl_modes)}) [default: %(default)s]")

intl_optgroup.add_argument('--without-intl',
    action='store_const',
    dest='with_intl',
    const='none',
    help='Disable Intl, same as --with-intl=none')

intl_optgroup.add_argument('--with-icu-path',
    action='store',
    dest='with_icu_path',
    help='Path to icu.gyp (ICU i18n, Chromium version only.)')

icu_default_locales='root,en'

intl_optgroup.add_argument('--with-icu-locales',
    action='store',
    dest='with_icu_locales',
    default=icu_default_locales,
    help='Comma-separated list of locales for "small-icu". "root" is assumed. '
        '[default: %(default)s]')

intl_optgroup.add_argument('--with-icu-source',
    action='store',
    dest='with_icu_source',
    help='Intl mode: optional local path to icu/ dir, or path/URL of '
        'the icu4c source archive. '
        f"v{icu_versions['minimum_icu']}.x or later recommended.")

intl_optgroup.add_argument('--with-icu-default-data-dir',
    action='store',
    dest='with_icu_default_data_dir',
    help='Path to the icuXXdt{lb}.dat file. If unspecified, ICU data will '
         'only be read if the NODE_ICU_DATA environment variable or the '
         '--icu-data-dir runtime argument is used. This option has effect '
         'only when Node.js is built with --with-intl=small-icu.')

parser.add_argument('--with-ltcg',
    action='store_true',
    dest='with_ltcg',
    default=None,
    help='Use Link Time Code Generation. This feature is only available on Windows.')

parser.add_argument('--write-snapshot-as-array-literals',
    action='store_true',
    dest='write_snapshot_as_array_literals',
    default=None,
    help='Write the snapshot data as array literals for readability.'
         'By default the snapshot data may be written as string literals on some '
         'platforms to speed up compilation.')

parser.add_argument('--without-node-snapshot',
    action='store_true',
    dest='without_node_snapshot',
    default=None,
    help='Turn off V8 snapshot integration. Currently experimental.')

parser.add_argument('--without-node-code-cache',
    action='store_true',
    dest='without_node_code_cache',
    default=None,
    help='Turn off V8 Code cache integration.')

intl_optgroup.add_argument('--download',
    action='store',
    dest='download_list',
    help=nodedownload.help())

intl_optgroup.add_argument('--download-path',
    action='store',
    dest='download_path',
    default='deps',
    help='Download directory [default: %(default)s]')

parser.add_argument('--debug-lib',
    action='store_true',
    dest='node_debug_lib',
    default=None,
    help='build lib with DCHECK macros')

http2_optgroup.add_argument('--debug-nghttp2',
    action='store_true',
    dest='debug_nghttp2',
    default=None,
    help='build nghttp2 with DEBUGBUILD (default is false)')

parser.add_argument('--without-amaro',
    action='store_true',
    dest='without_amaro',
    default=None,
    help='do not install the bundled Amaro (TypeScript utils)')

parser.add_argument('--without-npm',
    action='store_true',
    dest='without_npm',
    default=None,
    help='do not install the bundled npm (package manager)')

parser.add_argument('--without-corepack',
    action='store_true',
    dest='without_corepack',
    default=None,
    help='do not install the bundled Corepack')

# Dummy option for backwards compatibility
parser.add_argument('--without-report',
    action='store_true',
    dest='unused_without_report',
    default=None,
    help=argparse.SUPPRESS)

parser.add_argument('--with-snapshot',
    action='store_true',
    dest='unused_with_snapshot',
    default=None,
    help=argparse.SUPPRESS)

parser.add_argument('--without-snapshot',
    action='store_true',
    dest='unused_without_snapshot',
    default=None,
    help=argparse.SUPPRESS)

parser.add_argument('--without-siphash',
    action='store_true',
    dest='without_siphash',
    default=None,
    help=argparse.SUPPRESS)

# End dummy list.

parser.add_argument('--without-ssl',
    action='store_true',
    dest='without_ssl',
    default=None,
    help='build without SSL (disables crypto, https, inspector, etc.)')

parser.add_argument('--without-node-options',
    action='store_true',
    dest='without_node_options',
    default=None,
    help='build without NODE_OPTIONS support')

parser.add_argument('--ninja',
    action='store_true',
    dest='use_ninja',
    default=None,
    help='generate build files for use with Ninja')

parser.add_argument('--enable-asan',
    action='store_true',
    dest='enable_asan',
    default=None,
    help='compile for Address Sanitizer to find memory bugs')

parser.add_argument('--enable-ubsan',
    action='store_true',
    dest='enable_ubsan',
    default=None,
    help='compile for Undefined Behavior Sanitizer')

parser.add_argument('--enable-static',
    action='store_true',
    dest='enable_static',
    default=None,
    help='build as static library')

parser.add_argument('--no-browser-globals',
    action='store_true',
    dest='no_browser_globals',
    default=None,
    help='do not export browser globals like setTimeout, console, etc. ' +
         '(This mode is deprecated and not officially supported for regular ' +
         'applications)')

parser.add_argument('--without-inspector',
    action='store_true',
    dest='without_inspector',
    default=None,
    help='disable the V8 inspector protocol')

parser.add_argument('--shared',
    action='store_true',
    dest='shared',
    default=None,
    help='compile shared library for embedding node in another project. ' +
         '(This mode is not officially supported for regular applications)')

parser.add_argument('--libdir',
    action='store',
    dest='libdir',
    default='lib',
    help='a directory to install the shared library into relative to the '
         'prefix. This is a no-op if --shared is not specified. ' +
         '(This mode is not officially supported for regular applications)')

parser.add_argument('--without-v8-platform',
    action='store_true',
    dest='without_v8_platform',
    default=False,
    help='do not initialize v8 platform during node.js startup. ' +
         '(This mode is not officially supported for regular applications)')

parser.add_argument('--without-bundled-v8',
    action='store_true',
    dest='without_bundled_v8',
    default=False,
    help='do not use V8 includes from the bundled deps folder. ' +
         '(This mode is not officially supported for regular applications)')

parser.add_argument('--verbose',
    action='store_true',
    dest='verbose',
    default=False,
    help='get more output from this script')

parser.add_argument('--v8-non-optimized-debug',
    action='store_true',
    dest='v8_non_optimized_debug',
    default=False,
    help='compile V8 with minimal optimizations and with runtime checks')

parser.add_argument('--v8-with-dchecks',
    action='store_true',
    dest='v8_with_dchecks',
    default=False,
    help='compile V8 with debug checks and runtime debugging features enabled')

parser.add_argument('--v8-lite-mode',
    action='store_true',
    dest='v8_lite_mode',
    default=False,
    help='compile V8 in lite mode for constrained environments (lowers V8 '+
         'memory footprint, but also implies no just-in-time compilation ' +
         'support, thus much slower execution)')

parser.add_argument('--v8-enable-object-print',
    action='store_true',
    dest='v8_enable_object_print',
    default=True,
    help='compile V8 with auxiliary functions for native debuggers')

parser.add_argument('--v8-disable-object-print',
    action='store_true',
    dest='v8_disable_object_print',
    default=False,
    help='disable the V8 auxiliary functions for native debuggers')

parser.add_argument('--v8-enable-hugepage',
    action='store_true',
    dest='v8_enable_hugepage',
    default=None,
    help='Enable V8 transparent hugepage support. This feature is only '+
         'available on Linux platform.')

maglev_enabled_by_default_help = f"(Maglev is enabled by default on {','.join(maglev_enabled_architectures)})"

parser.add_argument('--v8-disable-maglev',
    action='store_true',
    dest='v8_disable_maglev',
    default=None,
    help=f"Disable V8's Maglev compiler. {maglev_enabled_by_default_help}")

parser.add_argument('--v8-enable-short-builtin-calls',
    action='store_true',
    dest='v8_enable_short_builtin_calls',
    default=None,
    help='Enable V8 short builtin calls support. This feature is enabled '+
         'on x86_64 platform by default.')

parser.add_argument('--v8-enable-snapshot-compression',
    action='store_true',
    dest='v8_enable_snapshot_compression',
    default=None,
    help='Enable the built-in snapshot compression in V8.')

parser.add_argument('--node-builtin-modules-path',
    action='store',
    dest='node_builtin_modules_path',
    default=False,
    help='node will load builtin modules from disk instead of from binary')

parser.add_argument('--node-snapshot-main',
    action='store',
    dest='node_snapshot_main',
    default=None,
    help='Run a file when building the embedded snapshot. Currently ' +
         'experimental.')

# Create compile_commands.json in out/Debug and out/Release.
parser.add_argument('-C',
    action='store_true',
    dest='compile_commands_json',
    default=None,
    help=argparse.SUPPRESS)

parser.add_argument('--clang-cl',
    action='store',
    dest='clang_cl',
    default=None,
    help='Configure for clang-cl on Windows. This flag sets the GYP "clang" ' +
         'variable to 1 and "llvm_version" to the specified value.')

(options, args) = parser.parse_known_args()

# Expand ~ in the install prefix now, it gets written to multiple files.
options.prefix = str(Path(options.prefix or '').expanduser())

# set up auto-download list
auto_downloads = nodedownload.parse(options.download_list)


def error(msg):
  prefix = '\033[1m\033[31mERROR\033[0m' if os.isatty(1) else 'ERROR'
  print(f'{prefix}: {msg}')
  sys.exit(1)

def warn(msg):
  warn.warned = True
  prefix = '\033[1m\033[93mWARNING\033[0m' if os.isatty(1) else 'WARNING'
  print(f'{prefix}: {msg}')

# track if warnings occurred
warn.warned = False

def info(msg):
  prefix = '\033[1m\033[32mINFO\033[0m' if os.isatty(1) else 'INFO'
  print(f'{prefix}: {msg}')

def print_verbose(x):
  if not options.verbose:
    return
  if isinstance(x, str):
    print(x)
  else:
    pprint.pprint(x, indent=2)

def b(value):
  """Returns the string 'true' if value is truthy, 'false' otherwise."""
  return 'true' if value else 'false'

def B(value):
  """Returns 1 if value is truthy, 0 otherwise."""
  return 1 if value else 0

def to_utf8(s):
  return s if isinstance(s, str) else s.decode("utf-8")

def pkg_config(pkg):
  """Run pkg-config on the specified package
  Returns ("-l flags", "-I flags", "-L flags", "version")
  otherwise (None, None, None, None)"""
  pkg_config = os.environ.get('PKG_CONFIG', 'pkg-config')
  args = []  # Print pkg-config warnings on first round.
  retval = []
  for flag in ['--libs-only-l', '--cflags-only-I',
               '--libs-only-L', '--modversion']:
    args += [flag]
    if isinstance(pkg, list):
      args += pkg
    else:
      args += [pkg]
    try:
      proc = subprocess.Popen(shlex.split(pkg_config) + args,
                              stdout=subprocess.PIPE)
      with proc:
        val = to_utf8(proc.communicate()[0]).strip()
    except OSError as e:
      if e.errno != errno.ENOENT:
        raise e  # Unexpected error.
      return (None, None, None, None)  # No pkg-config/pkgconf installed.
    retval.append(val)
    args = ['--silence-errors']
  return tuple(retval)


def try_check_compiler(cc, lang):
  try:
    proc = subprocess.Popen(shlex.split(cc) + ['-E', '-P', '-x', lang, '-'],
                            stdin=subprocess.PIPE, stdout=subprocess.PIPE)
  except OSError:
    return (False, False, '', '')

  with proc:
    proc.stdin.write(b'__clang__ __GNUC__ __GNUC_MINOR__ __GNUC_PATCHLEVEL__ '
                     b'__clang_major__ __clang_minor__ __clang_patchlevel__')

    if sys.platform == 'zos':
      values = (to_utf8(proc.communicate()[0]).split('\n')[-2].split() + ['0'] * 7)[0:7]
    else:
      values = (to_utf8(proc.communicate()[0]).split() + ['0'] * 7)[0:7]

  is_clang = values[0] == '1'
  gcc_version = tuple(map(int, values[1:1+3]))
  clang_version = tuple(map(int, values[4:4+3])) if is_clang else None

  return (True, is_clang, clang_version, gcc_version)


#
# The version of asm compiler is needed for building openssl asm files.
# See deps/openssl/openssl.gypi for detail.
# Commands and regular expressions to obtain its version number are taken from
# https://github.com/openssl/openssl/blob/OpenSSL_1_0_2-stable/crypto/sha/asm/sha512-x86_64.pl#L112-L129
#
def get_version_helper(cc, regexp):
  try:
    proc = subprocess.Popen(shlex.split(cc) + ['-v'], stdin=subprocess.PIPE,
                            stderr=subprocess.PIPE, stdout=subprocess.PIPE)
  except OSError:
    error('''No acceptable C compiler found!

       Please make sure you have a C compiler installed on your system and/or
       consider adjusting the CC environment variable if you installed
       it in a non-standard prefix.''')

  with proc:
    match = re.search(regexp, to_utf8(proc.communicate()[1]))

  return match.group(2) if match else '0.0'

def get_nasm_version(asm):
  try:
    proc = subprocess.Popen(shlex.split(asm) + ['-v'],
                            stdin=subprocess.PIPE, stderr=subprocess.PIPE,
                            stdout=subprocess.PIPE)
  except OSError:
    warn('''No acceptable ASM compiler found!
         Please make sure you have installed NASM from https://www.nasm.us
         and refer BUILDING.md.''')
    return '0.0'

  with proc:
    match = re.match(r"NASM version ([2-9]\.[0-9][0-9]+)",
                     to_utf8(proc.communicate()[0]))

  return match.group(1) if match else '0.0'

def get_llvm_version(cc):
  return get_version_helper(
    cc, r"(^(?:.+ )?clang version|based on LLVM) ([0-9]+\.[0-9]+)")

def get_xcode_version(cc):
  return get_version_helper(
    cc, r"(^Apple (?:clang|LLVM) version) ([0-9]+\.[0-9]+)")

def get_gas_version(cc):
  try:
    custom_env = os.environ.copy()
    custom_env["LC_ALL"] = "C"
    proc = subprocess.Popen(shlex.split(cc) + ['-Wa,-v', '-c', '-o',
                                               '/dev/null', '-x',
                                               'assembler',  '/dev/null'],
                            stdin=subprocess.PIPE, stderr=subprocess.PIPE,
                            stdout=subprocess.PIPE, env=custom_env)
  except OSError:
    error('''No acceptable C compiler found!

       Please make sure you have a C compiler installed on your system and/or
       consider adjusting the CC environment variable if you installed
       it in a non-standard prefix.''')

  with proc:
    gas_ret = to_utf8(proc.communicate()[1])

  match = re.match(r"GNU assembler version ([2-9]\.[0-9]+)", gas_ret)

  if match:
    return match.group(1)

  warn(f'Could not recognize `gas`: {gas_ret}')
  return '0.0'

# Note: Apple clang self-reports as clang 4.2.0 and gcc 4.2.1.  It passes
# the version check more by accident than anything else but a more rigorous
# check involves checking the build number against an allowlist.  I'm not
# quite prepared to go that far yet.
def check_compiler(o):
  if sys.platform == 'win32':
    if options.clang_cl:
      o['variables']['clang'] = 1
      o['variables']['llvm_version'] = options.clang_cl
    else:
      o['variables']['clang'] = 0
      o['variables']['llvm_version'] = '0.0'

    if not options.openssl_no_asm and options.dest_cpu in ('x86', 'x64'):
      nasm_version = get_nasm_version('nasm')
      o['variables']['nasm_version'] = nasm_version
      if nasm_version == '0.0':
        o['variables']['openssl_no_asm'] = 1
    return

  ok, is_clang, clang_version, gcc_version = try_check_compiler(CXX, 'c++')
  o['variables']['clang'] = B(is_clang)
  version_str = ".".join(map(str, clang_version if is_clang else gcc_version))
  print_verbose(f"Detected {'clang ' if is_clang else ''}C++ compiler (CXX={CXX}) version: {version_str}")
  if not ok:
    warn(f'failed to autodetect C++ compiler version (CXX={CXX})')
  elif clang_version < (8, 0, 0) if is_clang else gcc_version < (12, 2, 0):
    warn(f'C++ compiler (CXX={CXX}, {version_str}) too old, need g++ 12.2.0 or clang++ 8.0.0')

  ok, is_clang, clang_version, gcc_version = try_check_compiler(CC, 'c')
  version_str = ".".join(map(str, clang_version if is_clang else gcc_version))
  print_verbose(f"Detected {'clang ' if is_clang else ''}C compiler (CC={CC}) version: {version_str}")
  if not ok:
    warn(f'failed to autodetect C compiler version (CC={CC})')
  elif not is_clang and gcc_version < (4, 2, 0):
    # clang 3.2 is a little white lie because any clang version will probably
    # do for the C bits.  However, we might as well encourage people to upgrade
    # to a version that is not completely ancient.
    warn(f'C compiler (CC={CC}, {version_str}) too old, need gcc 4.2 or clang 3.2')

  o['variables']['llvm_version'] = get_llvm_version(CC) if is_clang else '0.0'

  # Need xcode_version or gas_version when openssl asm files are compiled.
  if options.without_ssl or options.openssl_no_asm or options.shared_openssl:
    return

  if is_clang:
    if sys.platform == 'darwin':
      o['variables']['xcode_version'] = get_xcode_version(CC)
  else:
    o['variables']['gas_version'] = get_gas_version(CC)


def cc_macros(cc=None):
  """Checks predefined macros using the C compiler command."""

  try:
    p = subprocess.Popen(shlex.split(cc or CC) + ['-dM', '-E', '-'],
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
  except OSError:
    error('''No acceptable C compiler found!

       Please make sure you have a C compiler installed on your system and/or
       consider adjusting the CC environment variable if you installed
       it in a non-standard prefix.''')

  with p:
    p.stdin.write(b'\n')
    out = to_utf8(p.communicate()[0]).split('\n')

  k = {}
  for line in out:
    lst = shlex.split(line)
    if len(lst) > 2:
      key = lst[1]
      val = lst[2]
      k[key] = val
  return k


def is_arch_armv7():
  """Check for ARMv7 instructions"""
  cc_macros_cache = cc_macros()
  return cc_macros_cache.get('__ARM_ARCH') == '7'


def is_arch_armv6():
  """Check for ARMv6 instructions"""
  cc_macros_cache = cc_macros()
  return cc_macros_cache.get('__ARM_ARCH') == '6'


def is_arm_hard_float_abi():
  """Check for hardfloat or softfloat eabi on ARM"""
  # GCC versions 4.6 and above define __ARM_PCS or __ARM_PCS_VFP to specify
  # the Floating Point ABI used (PCS stands for Procedure Call Standard).
  # We use these as well as a couple of other defines to statically determine
  # what FP ABI used.

  return '__ARM_PCS_VFP' in cc_macros()


def host_arch_cc():
  """Host architecture check using the CC command."""

  if sys.platform.startswith('zos'):
    return 's390x'
  k = cc_macros(os.environ.get('CC_host'))

  matchup = {
    '__aarch64__' : 'arm64',
    '__arm__'     : 'arm',
    '__i386__'    : 'ia32',
    '__MIPSEL__'  : 'mipsel',
    '__mips__'    : 'mips',
    '__PPC64__'   : 'ppc64',
    '__PPC__'     : 'ppc64',
    '__x86_64__'  : 'x64',
    '__s390x__'   : 's390x',
    '__riscv'     : 'riscv',
    '__loongarch64': 'loong64',
  }

  rtn = 'ia32' # default

  for key, value in matchup.items():
    if k.get(key, 0) and k[key] != '0':
      rtn = value
      break

  if rtn == 'mipsel' and '_LP64' in k:
    rtn = 'mips64el'

  if rtn == 'riscv':
    if k['__riscv_xlen'] == '64':
      rtn = 'riscv64'
    else:
      rtn = 'riscv32'

  return rtn


def host_arch_win():
  """Host architecture check using environ vars (better way to do this?)"""

  observed_arch = os.environ.get('PROCESSOR_ARCHITECTURE', 'AMD64')
  arch = os.environ.get('PROCESSOR_ARCHITEW6432', observed_arch)

  matchup = {
    'AMD64'  : 'x64',
    'arm'    : 'arm',
    'mips'   : 'mips',
    'ARM64'  : 'arm64'
  }

  return matchup.get(arch, 'x64')

def set_configuration_variable(configs, name, release=None, debug=None):
  configs['Release'][name] = release
  configs['Debug'][name] = debug

def configure_arm(o):
  if options.arm_float_abi:
    arm_float_abi = options.arm_float_abi
  elif is_arm_hard_float_abi():
    arm_float_abi = 'hard'
  else:
    arm_float_abi = 'default'

  arm_fpu = 'vfp'

  if is_arch_armv7():
    arm_fpu = 'vfpv3'
    o['variables']['arm_version'] = '7'
  else:
    o['variables']['arm_version'] = '6' if is_arch_armv6() else 'default'

  o['variables']['arm_thumb'] = 0      # -marm
  o['variables']['arm_float_abi'] = arm_float_abi

  if options.dest_os == 'android':
    arm_fpu = 'vfpv3'
    o['variables']['arm_version'] = '7'

  o['variables']['arm_fpu'] = options.arm_fpu or arm_fpu


def configure_mips(o, target_arch):
  can_use_fpu_instructions = options.mips_float_abi != 'soft'
  o['variables']['v8_can_use_fpu_instructions'] = b(can_use_fpu_instructions)
  o['variables']['v8_use_mips_abi_hardfloat'] = b(can_use_fpu_instructions)
  o['variables']['mips_arch_variant'] = options.mips_arch_variant
  o['variables']['mips_fpu_mode'] = options.mips_fpu_mode
  host_byteorder = 'little' if target_arch in ('mipsel', 'mips64el') else 'big'
  o['variables']['v8_host_byteorder'] = host_byteorder

def configure_zos(o):
  o['variables']['node_static_zoslib'] = b(True)
  if options.static_zoslib_gyp:
    # Apply to all Node.js components for now
    o['variables']['zoslib_include_dir'] = Path(options.static_zoslib_gyp).parent / 'include'
    o['include_dirs'] += [o['variables']['zoslib_include_dir']]
  else:
    raise Exception('--static-zoslib-gyp=<path to zoslib.gyp file> is required.')

def clang_version_ge(version_checked):
  for compiler in [(CC, 'c'), (CXX, 'c++')]:
    _, is_clang, clang_version, _1 = (
      try_check_compiler(compiler[0], compiler[1])
    )
    if is_clang and clang_version >= version_checked:
      return True
  return False

def gcc_version_ge(version_checked):
  for compiler in [(CC, 'c'), (CXX, 'c++')]:
    _, is_clang, _1, gcc_version = (
      try_check_compiler(compiler[0], compiler[1])
    )
    if is_clang or gcc_version < version_checked:
      return False
  return True

def configure_node_lib_files(o):
  o['variables']['node_library_files'] = SearchFiles('lib', 'js')

def configure_node(o):
  if options.dest_os == 'android':
    o['variables']['OS'] = 'android'
  o['variables']['node_prefix'] = options.prefix
  o['variables']['node_install_npm'] = b(not options.without_npm)
  o['variables']['node_install_corepack'] = b(not options.without_corepack)
  o['variables']['node_use_amaro'] = b(not options.without_amaro)
  o['variables']['debug_node'] = b(options.debug_node)
  o['default_configuration'] = 'Debug' if options.debug else 'Release'
  o['variables']['error_on_warn'] = b(options.error_on_warn)
  o['variables']['use_prefix_to_find_headers'] = b(options.use_prefix_to_find_headers)

  host_arch = host_arch_win() if os.name == 'nt' else host_arch_cc()
  target_arch = options.dest_cpu or host_arch
  # ia32 is preferred by the build tools (GYP) over x86 even if we prefer the latter
  # the Makefile resets this to x86 afterward
  if target_arch == 'x86':
    target_arch = 'ia32'
  # x86_64 is common across linuxes, allow it as an alias for x64
  if target_arch == 'x86_64':
    target_arch = 'x64'
  o['variables']['host_arch'] = host_arch
  o['variables']['target_arch'] = target_arch
  o['variables']['node_byteorder'] = sys.byteorder

  # Allow overriding the compiler - needed by embedders.
  if options.use_clang:
    o['variables']['clang'] = 1

  cross_compiling = (options.cross_compiling
                     if options.cross_compiling is not None
                     else target_arch != host_arch)
  if cross_compiling:
    os.environ['GYP_CROSSCOMPILE'] = "1"
  if options.unused_without_snapshot:
    warn('building --without-snapshot is no longer possible')

  o['variables']['want_separate_host_toolset'] = int(cross_compiling)

  if target_arch == 'arm64':
    o['variables']['arm_fpu'] = options.arm_fpu or 'neon'

  if options.node_snapshot_main is not None:
    if options.shared:
      # This should be possible to fix, but we will need to refactor the
      # libnode target to avoid building it twice.
      error('--node-snapshot-main is incompatible with --shared')
    if options.without_node_snapshot:
      error('--node-snapshot-main is incompatible with ' +
            '--without-node-snapshot')
    if cross_compiling:
      error('--node-snapshot-main is incompatible with cross compilation')
    o['variables']['node_snapshot_main'] = options.node_snapshot_main

  if options.without_node_snapshot or options.node_builtin_modules_path:
    o['variables']['node_use_node_snapshot'] = 'false'
  else:
    o['variables']['node_use_node_snapshot'] = b(
      not cross_compiling and not options.shared)

  # Do not use code cache when Node.js is built for collecting coverage of itself, this allows more
  # precise coverage for the JS built-ins.
  if options.without_node_code_cache or options.without_node_snapshot or options.node_builtin_modules_path or options.coverage:
    o['variables']['node_use_node_code_cache'] = 'false'
  else:
    # TODO(refack): fix this when implementing embedded code-cache when cross-compiling.
    o['variables']['node_use_node_code_cache'] = b(
      not cross_compiling and not options.shared)

  if options.write_snapshot_as_array_literals is not None:
     o['variables']['node_write_snapshot_as_array_literals'] = b(options.write_snapshot_as_array_literals)
  else:
     o['variables']['node_write_snapshot_as_array_literals'] = b(flavor != 'mac' and flavor != 'linux')

  if target_arch == 'arm':
    configure_arm(o)
  elif target_arch in ('mips', 'mipsel', 'mips64el'):
    configure_mips(o, target_arch)
  elif sys.platform == 'zos':
    configure_zos(o)

  if flavor in ('aix', 'os400'):
    o['variables']['node_target_type'] = 'static_library'

  if target_arch in ('x86', 'x64', 'ia32', 'x32'):
    o['variables']['node_enable_v8_vtunejit'] = b(options.enable_vtune_profiling)
  elif options.enable_vtune_profiling:
    raise Exception(
       'The VTune profiler for JavaScript is only supported on x32, x86, and x64 '
       'architectures.')
  else:
    o['variables']['node_enable_v8_vtunejit'] = 'false'

  if flavor != 'linux' and (options.enable_pgo_generate or options.enable_pgo_use):
    raise Exception(
      'The pgo option is supported only on linux.')

  if flavor == 'linux':
    if options.enable_pgo_generate or options.enable_pgo_use:
      version_checked = (5, 4, 1)
      if not gcc_version_ge(version_checked):
        version_checked_str = ".".join(map(str, version_checked))
        raise Exception(
          'The options --enable-pgo-generate and --enable-pgo-use '
          f'are supported for gcc and gxx {version_checked_str} or newer only.')

    if options.enable_pgo_generate and options.enable_pgo_use:
      raise Exception(
        'Only one of the --enable-pgo-generate or --enable-pgo-use options '
        'can be specified at a time. You would like to use '
        '--enable-pgo-generate first, profile node, and then recompile '
        'with --enable-pgo-use')

  o['variables']['enable_pgo_generate'] = b(options.enable_pgo_generate)
  o['variables']['enable_pgo_use']      = b(options.enable_pgo_use)

  if flavor == 'win' and (options.enable_lto):
    raise Exception(
      'Use Link Time Code Generation instead.')

  if options.enable_lto:
    gcc_version_checked = (5, 4, 1)
    clang_version_checked = (3, 9, 1)
    if not gcc_version_ge(gcc_version_checked) and not clang_version_ge(clang_version_checked):
      gcc_version_checked_str = ".".join(map(str, gcc_version_checked))
      clang_version_checked_str = ".".join(map(str, clang_version_checked))
      raise Exception(
        f'The option --enable-lto is supported for gcc {gcc_version_checked_str}+'
        f'or clang {clang_version_checked_str}+ only.')

  o['variables']['enable_lto'] = b(options.enable_lto)

  if options.node_use_large_pages or options.node_use_large_pages_script_lld:
    warn('''The `--use-largepages` and `--use-largepages-script-lld` options
         have no effect during build time. Support for mapping to large pages is
         now a runtime option of Node.js. Run `node --use-largepages` or add
         `--use-largepages` to the `NODE_OPTIONS` environment variable once
         Node.js is built to enable mapping to large pages.''')

  if options.no_ifaddrs:
    o['defines'] += ['SUNOS_NO_IFADDRS']

  o['variables']['single_executable_application'] = b(not options.disable_single_executable_application)
  if options.disable_single_executable_application:
    o['defines'] += ['DISABLE_SINGLE_EXECUTABLE_APPLICATION']

  o['variables']['node_with_ltcg'] = b(options.with_ltcg)
  if flavor != 'win' and options.with_ltcg:
    raise Exception('Link Time Code Generation is only supported on Windows.')

  if options.tag:
    o['variables']['node_tag'] = '-' + options.tag
  else:
    o['variables']['node_tag'] = ''

  o['variables']['node_release_urlbase'] = options.release_urlbase or ''

  if options.v8_options:
    o['variables']['node_v8_options'] = options.v8_options.replace('"', '\\"')

  if options.enable_static:
    o['variables']['node_target_type'] = 'static_library'

  o['variables']['node_debug_lib'] = b(options.node_debug_lib)

  if options.debug_nghttp2:
    o['variables']['debug_nghttp2'] = 1
  else:
    o['variables']['debug_nghttp2'] = 'false'

  o['variables']['node_no_browser_globals'] = b(options.no_browser_globals)

  o['variables']['node_shared'] = b(options.shared)
  o['variables']['libdir'] = options.libdir
  node_module_version = getmoduleversion.get_version()

  if options.dest_os == 'android':
    shlib_suffix = 'so'
  elif sys.platform == 'darwin':
    shlib_suffix = '%s.dylib'
  elif sys.platform.startswith('aix'):
    shlib_suffix = '%s.a'
  elif sys.platform == 'os400':
    shlib_suffix = '%s.a'
  elif sys.platform.startswith('zos'):
    shlib_suffix = '%s.x'
  else:
    shlib_suffix = 'so.%s'
  if '%s' in shlib_suffix:
    shlib_suffix %= node_module_version

  o['variables']['node_module_version'] = int(node_module_version)
  o['variables']['shlib_suffix'] = shlib_suffix

  if options.linked_module:
    o['variables']['linked_module_files'] = options.linked_module

  o['variables']['asan'] = int(options.enable_asan or 0)
  o['variables']['ubsan'] = int(options.enable_ubsan or 0)

  if options.coverage:
    o['variables']['coverage'] = 'true'
  else:
    o['variables']['coverage'] = 'false'

  if options.shared:
    o['variables']['node_target_type'] = 'shared_library'
  elif options.enable_static:
    o['variables']['node_target_type'] = 'static_library'
  else:
    o['variables']['node_target_type'] = 'executable'

  if options.node_builtin_modules_path:
    print('Warning! Loading builtin modules from disk is for development')
    o['variables']['node_builtin_modules_path'] = options.node_builtin_modules_path

def configure_napi(output):
  version = getnapibuildversion.get_napi_version()
  output['variables']['napi_build_version'] = version

def configure_library(lib, output, pkgname=None):
  shared_lib = 'shared_' + lib
  output['variables']['node_' + shared_lib] = b(getattr(options, shared_lib))

  if getattr(options, shared_lib):
    (pkg_libs, pkg_cflags, pkg_libpath, _) = pkg_config(pkgname or lib)

    if options.__dict__[shared_lib + '_includes']:
      output['include_dirs'] += [options.__dict__[shared_lib + '_includes']]
    elif pkg_cflags:
      stripped_flags = [flag.strip() for flag in pkg_cflags.split('-I')]
      output['include_dirs'] += [flag for flag in stripped_flags if flag]

    # libpath needs to be provided ahead libraries
    if options.__dict__[shared_lib + '_libpath']:
      if flavor == 'win':
        if 'msvs_settings' not in output:
          output['msvs_settings'] = { 'VCLinkerTool': { 'AdditionalOptions': [] } }
        output['msvs_settings']['VCLinkerTool']['AdditionalOptions'] += [
          f"/LIBPATH:{options.__dict__[shared_lib + '_libpath']}"]
      else:
        output['libraries'] += [
            f"-L{options.__dict__[shared_lib + '_libpath']}"]
    elif pkg_libpath:
      output['libraries'] += [pkg_libpath]

    default_libs = getattr(options, shared_lib + '_libname')
    default_libs = [f'-l{l}' for l in default_libs.split(',')]

    if default_libs:
      output['libraries'] += default_libs
    elif pkg_libs:
      output['libraries'] += pkg_libs.split()


def configure_v8(o, configs):
  set_configuration_variable(configs, 'v8_enable_v8_checks', release=1, debug=0)

  o['variables']['v8_enable_webassembly'] = 0 if options.v8_lite_mode else 1
  o['variables']['v8_enable_javascript_promise_hooks'] = 1
  o['variables']['v8_enable_lite_mode'] = 1 if options.v8_lite_mode else 0
  o['variables']['v8_enable_gdbjit'] = 1 if options.gdb else 0
  o['variables']['v8_optimized_debug'] = 0 if options.v8_non_optimized_debug else 1
  o['variables']['dcheck_always_on'] = 1 if options.v8_with_dchecks else 0
  o['variables']['v8_enable_object_print'] = 0 if options.v8_disable_object_print else 1
  o['variables']['v8_random_seed'] = 0  # Use a random seed for hash tables.
  o['variables']['v8_promise_internal_field_count'] = 1 # Add internal field to promises for async hooks.
  o['variables']['v8_use_siphash'] = 0 if options.without_siphash else 1
  o['variables']['v8_enable_maglev'] = B(not options.v8_disable_maglev and
                                         o['variables']['target_arch'] in maglev_enabled_architectures)
  o['variables']['v8_enable_pointer_compression'] = 1 if options.enable_pointer_compression else 0
  o['variables']['v8_enable_sandbox'] = 1 if options.enable_pointer_compression else 0
  o['variables']['v8_enable_31bit_smis_on_64bit_arch'] = 1 if options.enable_pointer_compression else 0
  o['variables']['v8_enable_shared_ro_heap'] = 0 if options.enable_pointer_compression or options.disable_shared_ro_heap else 1
  o['variables']['v8_enable_extensible_ro_snapshot'] = 0
  o['variables']['v8_trace_maps'] = 1 if options.trace_maps else 0
  o['variables']['node_use_v8_platform'] = b(not options.without_v8_platform)
  o['variables']['node_use_bundled_v8'] = b(not options.without_bundled_v8)
  o['variables']['force_dynamic_crt'] = 1 if options.shared else 0
  o['variables']['node_enable_d8'] = b(options.enable_d8)
  if options.enable_d8:
    o['variables']['test_isolation_mode'] = 'noop'  # Needed by d8.gyp.
  if options.without_bundled_v8 and options.enable_d8:
    raise Exception('--enable-d8 is incompatible with --without-bundled-v8.')
  if options.static_zoslib_gyp:
    o['variables']['static_zoslib_gyp'] = options.static_zoslib_gyp
  if flavor != 'linux' and options.v8_enable_hugepage:
    raise Exception('--v8-enable-hugepage is supported only on linux.')
  o['variables']['v8_enable_hugepage'] = 1 if options.v8_enable_hugepage else 0
  if options.v8_enable_short_builtin_calls or o['variables']['target_arch'] == 'x64':
    o['variables']['v8_enable_short_builtin_calls'] = 1
  if options.v8_enable_snapshot_compression:
    o['variables']['v8_enable_snapshot_compression'] = 1
  if all(opt in sys.argv for opt in ['--v8-enable-object-print', '--v8-disable-object-print']):
    raise Exception(
        'Only one of the --v8-enable-object-print or --v8-disable-object-print options '
        'can be specified at a time.')
  if sys.platform != 'darwin':
    if o['variables']['v8_enable_webassembly'] and o['variables']['target_arch'] == 'x64':
      o['variables']['v8_enable_wasm_simd256_revec'] = 1

def configure_openssl(o):
  variables = o['variables']
  variables['node_use_openssl'] = b(not options.without_ssl)
  variables['node_shared_openssl'] = b(options.shared_openssl)
  variables['node_shared_ngtcp2'] = b(options.shared_ngtcp2)
  variables['node_shared_nghttp3'] = b(options.shared_nghttp3)
  variables['openssl_is_fips'] = b(options.openssl_is_fips)
  variables['node_fipsinstall'] = b(False)

  if options.openssl_no_asm:
    variables['openssl_no_asm'] = 1

  o['defines'] += ['NODE_OPENSSL_CONF_NAME=' + options.openssl_conf_name]

  if options.without_ssl:
    def without_ssl_error(option):
      error(f'--without-ssl is incompatible with {option}')
    if options.shared_openssl:
      without_ssl_error('--shared-openssl')
    if options.openssl_no_asm:
      without_ssl_error('--openssl-no-asm')
    if options.openssl_is_fips:
      without_ssl_error('--openssl-is-fips')
    if options.openssl_default_cipher_list:
      without_ssl_error('--openssl-default-cipher-list')
    return

  if options.use_openssl_ca_store:
    o['defines'] += ['NODE_OPENSSL_CERT_STORE']
  if options.openssl_system_ca_path:
    variables['openssl_system_ca_path'] = options.openssl_system_ca_path
  variables['node_without_node_options'] = b(options.without_node_options)
  if options.without_node_options:
      o['defines'] += ['NODE_WITHOUT_NODE_OPTIONS']
  if options.openssl_default_cipher_list:
    variables['openssl_default_cipher_list'] = \
            options.openssl_default_cipher_list

  if not options.shared_openssl and not options.openssl_no_asm:
    is_x86 = 'x64' in variables['target_arch'] or 'ia32' in variables['target_arch']

    # supported asm compiler for AVX2. See https://github.com/openssl/openssl/
    # blob/OpenSSL_1_1_0-stable/crypto/modes/asm/aesni-gcm-x86_64.pl#L52-L69
    openssl110_asm_supported = \
      ('gas_version' in variables and Version(variables['gas_version']) >= Version('2.23')) or \
      ('xcode_version' in variables and Version(variables['xcode_version']) >= Version('5.0')) or \
      ('llvm_version' in variables and Version(variables['llvm_version']) >= Version('3.3')) or \
      ('nasm_version' in variables and Version(variables['nasm_version']) >= Version('2.10'))

    if is_x86 and not openssl110_asm_supported:
      error('''Did not find a new enough assembler, install one or build with
       --openssl-no-asm.
       Please refer to BUILDING.md''')

  elif options.openssl_no_asm:
    warn('''--openssl-no-asm will result in binaries that do not take advantage
         of modern CPU cryptographic instructions and will therefore be slower.
         Please refer to BUILDING.md''')

  if options.openssl_no_asm and options.shared_openssl:
    error('--openssl-no-asm is incompatible with --shared-openssl')

  if options.openssl_is_fips:
    o['defines'] += ['OPENSSL_FIPS']

  if options.openssl_is_fips and not options.shared_openssl:
    variables['node_fipsinstall'] = b(True)

  if options.shared_openssl:
    has_quic = getsharedopensslhasquic.get_has_quic(options.__dict__['shared_openssl_includes'])
  else:
    has_quic = getsharedopensslhasquic.get_has_quic('deps/openssl/openssl/include')

  variables['openssl_quic'] = b(has_quic)
  if has_quic:
    o['defines'] += ['NODE_OPENSSL_HAS_QUIC']

  configure_library('openssl', o)


def configure_static(o):
  if options.fully_static or options.partly_static:
    if flavor == 'mac':
      warn("Generation of static executable will not work on macOS "
            "when using the default compilation environment")
      return

    if options.fully_static:
      o['libraries'] += ['-static']
    elif options.partly_static:
      o['libraries'] += ['-static-libgcc', '-static-libstdc++']
      if options.enable_asan:
        o['libraries'] += ['-static-libasan']


def write(filename, data):
  print_verbose(f'creating {filename}')
  with Path(filename).open(mode='w+', encoding='utf-8') as f:
    f.write(data)

do_not_edit = '# Do not edit. Generated by the configure script.\n'

def glob_to_var(dir_base, dir_sub, patch_dir):
  file_list = []
  dir_all = f'{dir_base}/{dir_sub}'
  files = os.walk(dir_all)
  for ent in files:
    (_, _1, files) = ent
    for file in files:
      if file.endswith(('.cpp', '.c', '.h')):
        # srcfile uses "slash" as dir separator as its output is consumed by gyp
        srcfile = f'{dir_sub}/{file}'
        if patch_dir:
          patchfile = Path(dir_base, patch_dir, file)
          if patchfile.is_file():
            srcfile = f'{patch_dir}/{file}'
            info(f'Using floating patch "{patchfile}" from "{dir_base}"')
        file_list.append(srcfile)
    break
  return file_list

def configure_intl(o):
  def icu_download(path):
    depFile = tools_path / 'icu' / 'current_ver.dep'
    icus = json.loads(depFile.read_text(encoding='utf-8'))
    # download ICU, if needed
    if not os.access(options.download_path, os.W_OK):
      error('''Cannot write to desired download path.
        Either create it or verify permissions.''')
    attemptdownload = nodedownload.candownload(auto_downloads, "icu")
    for icu in icus:
      url = icu['url']
      (expectHash, hashAlgo, allAlgos) = nodedownload.findHash(icu)
      if not expectHash:
        error(f'''Could not find a hash to verify ICU download.
          {depFile} may be incorrect.
          For the entry {url},
          Expected one of these keys: {' '.join(allAlgos)}''')
      local = url.split('/')[-1]
      targetfile = Path(options.download_path, local)
      if not targetfile.is_file():
        if attemptdownload:
          nodedownload.retrievefile(url, targetfile)
      else:
        print(f'Re-using existing {targetfile}')
      if targetfile.is_file():
        print(f'Checking file integrity with {hashAlgo}:\r')
        gotHash = nodedownload.checkHash(targetfile, hashAlgo)
        print(f'{hashAlgo}:      {gotHash}  {targetfile}')
        if expectHash == gotHash:
          return targetfile

        warn(f'Expected: {expectHash}      *MISMATCH*')
        warn(f'\n ** Corrupted ZIP? Delete {targetfile} to retry download.\n')
    return None
  icu_config = {
    'variables': {}
  }
  icu_config_name = 'icu_config.gypi'

  # write an empty file to start with
  write(icu_config_name, do_not_edit +
        pprint.pformat(icu_config, indent=2, width=1024) + '\n')

  # always set icu_small, node.gyp depends on it being defined.
  o['variables']['icu_small'] = b(False)

  # prevent data override
  o['defines'] += ['ICU_NO_USER_DATA_OVERRIDE']

  with_intl = options.with_intl
  with_icu_source = options.with_icu_source
  have_icu_path = bool(options.with_icu_path)
  if have_icu_path and with_intl != 'none':
    error('Cannot specify both --with-icu-path and --with-intl')
  elif have_icu_path:
    # Chromium .gyp mode: --with-icu-path
    o['variables']['v8_enable_i18n_support'] = 1
    # use the .gyp given
    o['variables']['icu_gyp_path'] = options.with_icu_path
    return

  # --with-intl=<with_intl>
  # set the default
  if with_intl in (None, 'none'):
    o['variables']['v8_enable_i18n_support'] = 0
    return  # no Intl

  if with_intl == 'small-icu':
    # small ICU (English only)
    o['variables']['v8_enable_i18n_support'] = 1
    o['variables']['icu_small'] = b(True)
    locs = set(options.with_icu_locales.split(','))
    locs.add('root')  # must have root
    o['variables']['icu_locales'] = ','.join(str(loc) for loc in sorted(locs))
    # We will check a bit later if we can use the canned deps/icu-small
    o['variables']['icu_default_data'] = options.with_icu_default_data_dir or ''
  elif with_intl == 'full-icu':
    # full ICU
    o['variables']['v8_enable_i18n_support'] = 1
  elif with_intl == 'system-icu':
    # ICU from pkg-config.
    o['variables']['v8_enable_i18n_support'] = 1
    pkgicu = pkg_config(['icu-i18n', 'icu-uc'])
    if not pkgicu[0]:
      error('''Could not load pkg-config data for "icu-i18n".
       See above errors or the README.md.''')
    (libs, cflags, libpath, icuversion) = pkgicu
    icu_ver_major = icuversion.split('.')[0]
    o['variables']['icu_ver_major'] = icu_ver_major
    if int(icu_ver_major) < icu_versions['minimum_icu']:
      error(f"icu4c v{icuversion} is too old, v{icu_versions['minimum_icu']}.x or later is required.")
    # libpath provides linker path which may contain spaces
    if libpath:
      o['libraries'] += [libpath]
    # safe to split, cannot contain spaces
    o['libraries'] += libs.split()
    if cflags:
      stripped_flags = [flag.strip() for flag in cflags.split('-I')]
      o['include_dirs'] += [flag for flag in stripped_flags if flag]
    # use the "system" .gyp
    o['variables']['icu_gyp_path'] = 'tools/icu/icu-system.gyp'
    return

  # this is just the 'deps' dir. Used for unpacking.
  icu_parent_path = 'deps'

  # The full path to the ICU source directory. Should not include './'.
  icu_deps_path = 'deps/icu'
  icu_full_path = icu_deps_path

  # icu-tmp is used to download and unpack the ICU tarball.
  icu_tmp_path = Path(icu_parent_path, 'icu-tmp')

  # canned ICU. see tools/icu/README.md to update.
  canned_icu_dir = 'deps/icu-small'

  # use the README to verify what the canned ICU is
  canned_icu_path = Path(canned_icu_dir)
  canned_is_full = (canned_icu_path / 'README-FULL-ICU.txt').is_file()
  canned_is_small = (canned_icu_path / 'README-SMALL-ICU.txt').is_file()
  if canned_is_small:
    warn(f'Ignoring {canned_icu_dir} - in-repo small icu is no longer supported.')

  # We can use 'deps/icu-small' - pre-canned ICU *iff*
  # - canned_is_full AND
  # - with_icu_source is unset (i.e. no other ICU was specified)
  #
  # This is *roughly* equivalent to
  # $ configure --with-intl=full-icu --with-icu-source=deps/icu-small
  # .. Except that we avoid copying icu-small over to deps/icu.
  # In this default case, deps/icu is ignored, although make clean will
  # still harmlessly remove deps/icu.

  if (not with_icu_source) and canned_is_full:
    # OK- we can use the canned ICU.
    icu_full_path = canned_icu_dir
    icu_config['variables']['icu_full_canned'] = 1
  # --with-icu-source processing
  # now, check that they didn't pass --with-icu-source=deps/icu
  elif with_icu_source and Path(icu_full_path).resolve() == Path(with_icu_source).resolve():
    warn(f'Ignoring redundant --with-icu-source={with_icu_source}')
    with_icu_source = None
  # if with_icu_source is still set, try to use it.
  if with_icu_source:
    if Path(icu_full_path).is_dir():
      print(f'Deleting old ICU source: {icu_full_path}')
      shutil.rmtree(icu_full_path)
    # now, what path was given?
    if Path(with_icu_source).is_dir():
      # it's a path. Copy it.
      print(f'{with_icu_source} -> {icu_full_path}')
      shutil.copytree(with_icu_source, icu_full_path)
    else:
      # could be file or URL.
      # Set up temporary area
      if Path(icu_tmp_path).is_dir():
        shutil.rmtree(icu_tmp_path)
      icu_tmp_path.mkdir()
      icu_tarball = None
      if Path(with_icu_source).is_file():
        # it's a file. Try to unpack it.
        icu_tarball = with_icu_source
      else:
        # Can we download it?
        local = icu_tmp_path / with_icu_source.split('/')[-1]  # local part
        icu_tarball = nodedownload.retrievefile(with_icu_source, local)
      # continue with "icu_tarball"
      nodedownload.unpack(icu_tarball, icu_tmp_path)
      # Did it unpack correctly? Should contain 'icu'
      tmp_icu = icu_tmp_path / 'icu'
      if tmp_icu.is_dir():
        tmp_icu.rename(icu_full_path)
        shutil.rmtree(icu_tmp_path)
      else:
        shutil.rmtree(icu_tmp_path)
        error(f'--with-icu-source={with_icu_source} did not result in an "icu" dir.')

  # ICU mode. (icu-generic.gyp)
  o['variables']['icu_gyp_path'] = 'tools/icu/icu-generic.gyp'
  # ICU source dir relative to tools/icu (for .gyp file)
  o['variables']['icu_path'] = icu_full_path
  if not Path(icu_full_path).is_dir():
    # can we download (or find) a zipfile?
    localzip = icu_download(icu_full_path)
    if localzip:
      nodedownload.unpack(localzip, icu_parent_path)
    else:
      warn(f"* ECMA-402 (Intl) support didn't find ICU in {icu_full_path}..")
  if not Path(icu_full_path).is_dir():
    error(f'''Cannot build Intl without ICU in {icu_full_path}.
       Fix, or disable with "--with-intl=none"''')
  else:
    print_verbose(f'* Using ICU in {icu_full_path}')
  # Now, what version of ICU is it? We just need the "major", such as 54.
  # uvernum.h contains it as a #define.
  uvernum_h = Path(icu_full_path, 'source', 'common', 'unicode', 'uvernum.h')
  if not uvernum_h.is_file():
    error(f'Could not load {uvernum_h} - is ICU installed?')
  icu_ver_major = None
  matchVerExp = r'^\s*#define\s+U_ICU_VERSION_SHORT\s+"([^"]*)".*'
  match_version = re.compile(matchVerExp)
  with io.open(uvernum_h, encoding='utf8') as in_file:
    for line in in_file:
      m = match_version.match(line)
      if m:
        icu_ver_major = str(m.group(1))
  if not icu_ver_major:
    error(f'Could not read U_ICU_VERSION_SHORT version from {uvernum_h}')
  elif int(icu_ver_major) < icu_versions['minimum_icu']:
    error(f"icu4c v{icu_ver_major}.x is too old, v{icu_versions['minimum_icu']}.x or later is required.")
  icu_endianness = sys.byteorder[0]
  o['variables']['icu_ver_major'] = icu_ver_major
  o['variables']['icu_endianness'] = icu_endianness
  icu_data_file_l = f'icudt{icu_ver_major}l.dat' # LE filename
  icu_data_file = f'icudt{icu_ver_major}{icu_endianness}.dat'
  # relative to configure
  icu_data_path = Path(icu_full_path, 'source', 'data', 'in', icu_data_file_l) # LE
  compressed_data = f'{icu_data_path}.bz2'
  if not icu_data_path.is_file() and Path(compressed_data).is_file():
    # unpack. deps/icu is a temporary path
    if icu_tmp_path.is_dir():
      shutil.rmtree(icu_tmp_path)
    icu_tmp_path.mkdir()
    icu_data_path = icu_tmp_path / icu_data_file_l
    with icu_data_path.open(mode='wb') as outf:
        inf = bz2.BZ2File(compressed_data, 'rb')
        try:
          shutil.copyfileobj(inf, outf)
        finally:
          inf.close()
    # Now, proceed..

  # relative to dep..
  icu_data_in = Path('..', '..', icu_data_path)
  if not icu_data_path.is_file() and icu_endianness != 'l':
    # use host endianness
    icu_data_path = Path(icu_full_path, 'source', 'data', 'in', icu_data_file) # will be generated
  if not icu_data_path.is_file():
    # .. and we're not about to build it from .gyp!
    error(f'''ICU prebuilt data file {icu_data_path} does not exist.
       See the README.md.''')

  # this is the input '.dat' file to use .. icudt*.dat
  # may be little-endian if from a icu-project.org tarball
  o['variables']['icu_data_in'] = str(icu_data_in)

  # map from variable name to subdirs
  icu_src = {
    'stubdata': 'stubdata',
    'common': 'common',
    'i18n': 'i18n',
    'tools': 'tools/toolutil',
    'genccode': 'tools/genccode',
    'genrb': 'tools/genrb',
    'icupkg': 'tools/icupkg',
  }
  # this creates a variable icu_src_XXX for each of the subdirs
  # with a list of the src files to use
  for key, value in icu_src.items():
    var  = f'icu_src_{key}'
    path = f'../../{icu_full_path}/source/{value}'
    icu_config['variables'][var] = glob_to_var('tools/icu', path, f'patches/{icu_ver_major}/source/{value}')
  # calculate platform-specific genccode args
  # print("platform %s, flavor %s" % (sys.platform, flavor))
  # if sys.platform == 'darwin':
  #   shlib_suffix = '%s.dylib'
  # elif sys.platform.startswith('aix'):
  #   shlib_suffix = '%s.a'
  # else:
  #   shlib_suffix = 'so.%s'
  if flavor == 'win':
    icu_config['variables']['icu_asm_ext'] = 'obj'
    icu_config['variables']['icu_asm_opts'] = [ '-o ' ]
  elif with_intl == 'small-icu' or options.cross_compiling:
    icu_config['variables']['icu_asm_ext'] = 'c'
    icu_config['variables']['icu_asm_opts'] = []
  elif flavor == 'mac':
    icu_config['variables']['icu_asm_ext'] = 'S'
    icu_config['variables']['icu_asm_opts'] = [ '-a', 'gcc-darwin' ]
  elif sys.platform == 'os400':
    icu_config['variables']['icu_asm_ext'] = 'S'
    icu_config['variables']['icu_asm_opts'] = [ '-a', 'xlc' ]
  elif sys.platform.startswith('aix'):
    icu_config['variables']['icu_asm_ext'] = 'S'
    icu_config['variables']['icu_asm_opts'] = [ '-a', 'xlc' ]
  elif sys.platform == 'zos':
    icu_config['variables']['icu_asm_ext'] = 'S'
    icu_config['variables']['icu_asm_opts'] = [ '-a', 'zos' ]
  else:
    # assume GCC-compatible asm is OK
    icu_config['variables']['icu_asm_ext'] = 'S'
    icu_config['variables']['icu_asm_opts'] = [ '-a', 'gcc' ]

  # write updated icu_config.gypi with a bunch of paths
  write(icu_config_name, do_not_edit +
        pprint.pformat(icu_config, indent=2, width=1024) + '\n')
  return  # end of configure_intl

def configure_inspector(o):
  disable_inspector = (options.without_inspector or
                       options.without_ssl)
  o['variables']['v8_enable_inspector'] = 0 if disable_inspector else 1

def configure_section_file(o):
  try:
    proc = subprocess.Popen(['ld.gold'] + ['-v'], stdin = subprocess.PIPE,
                            stdout = subprocess.PIPE, stderr = subprocess.PIPE)
  except OSError:
    if options.node_section_ordering_info != "":
      warn('''No acceptable ld.gold linker found!''')
    return 0

  with proc:
    match = re.match(r"^GNU gold.*([0-9]+)\.([0-9]+)$",
                     proc.communicate()[0].decode("utf-8"))

  if match:
    gold_major_version = match.group(1)
    gold_minor_version = match.group(2)
    if int(gold_major_version) == 1 and int(gold_minor_version) <= 1:
      error('''GNU gold version must be greater than 1.2 in order to use section
            reordering''')

  if options.node_section_ordering_info != "":
    o['variables']['node_section_ordering_info'] = os.path.realpath(
      str(options.node_section_ordering_info))
  else:
    o['variables']['node_section_ordering_info'] = ""

def make_bin_override():
  if sys.platform == 'win32':
    raise Exception('make_bin_override should not be called on win32.')
  # If the system python is not the python we are running (which should be
  # python 3.8+), then create a directory with a symlink called `python` to our
  # sys.executable. This directory will be prefixed to the PATH, so that
  # other tools that shell out to `python` will use the appropriate python

  which_python = shutil.which('python')
  if (which_python and
      os.path.realpath(which_python) == os.path.realpath(sys.executable)):
    return

  bin_override = Path('out', 'tools', 'bin').resolve()
  try:
    bin_override.mkdir(parents=True)
  except OSError as e:
    if e.errno != errno.EEXIST:
      raise e

  python_link = bin_override / 'python'
  try:
    python_link.unlink()
  except OSError as e:
    if e.errno != errno.ENOENT:
      raise e
  os.symlink(sys.executable, python_link)

  # We need to set the environment right now so that when gyp (in run_gyp)
  # shells out, it finds the right python (specifically at
  # https://github.com/nodejs/node/blob/d82e107/deps/v8/gypfiles/toolchain.gypi#L43)
  os.environ['PATH'] = str(bin_override) + ':' + os.environ['PATH']

  return bin_override

output = {
  'variables': {},
  'include_dirs': [],
  'libraries': [],
  'defines': [],
  'cflags': [],
}
configurations = {
  'Release': { 'variables': {} },
  'Debug': { 'variables': {} },
}

# Print a warning when the compiler is too old.
check_compiler(output)

# determine the "flavor" (operating system) we're building for,
# leveraging gyp's GetFlavor function
flavor_params = {}
if options.dest_os:
  flavor_params['flavor'] = options.dest_os
flavor = GetFlavor(flavor_params)

configure_node(output)
configure_node_lib_files(output)
configure_napi(output)
configure_library('zlib', output)
configure_library('http_parser', output)
configure_library('libuv', output)
configure_library('ada', output)
configure_library('simdjson', output)
configure_library('simdutf', output)
configure_library('brotli', output, pkgname=['libbrotlidec', 'libbrotlienc'])
configure_library('cares', output, pkgname='libcares')
configure_library('nghttp2', output, pkgname='libnghttp2')
configure_library('nghttp3', output, pkgname='libnghttp3')
configure_library('ngtcp2', output, pkgname='libngtcp2')
configure_library('sqlite', output, pkgname='sqlite3')
configure_library('uvwasi', output, pkgname='libuvwasi')
configure_v8(output, configurations)
configure_openssl(output)
configure_intl(output)
configure_static(output)
configure_inspector(output)
configure_section_file(output)

# remove builtins that have been disabled
if options.without_amaro:
    del shareable_builtins['amaro/dist/index']

# configure shareable builtins
output['variables']['node_builtin_shareable_builtins'] = []
for builtin, value in shareable_builtins.items():
  builtin_id = 'node_shared_builtin_' + builtin.replace('/', '_') + '_path'
  if getattr(options, builtin_id):
    output['defines'] += [builtin_id.upper() + '=' + getattr(options, builtin_id)]
  else:
    output['variables']['node_builtin_shareable_builtins'] += [value]

# Forward OSS-Fuzz settings
output['variables']['ossfuzz'] = b(options.ossfuzz)

# variables should be a root level element,
# move everything else to target_defaults
variables = output['variables']
del output['variables']

# make_global_settings should be a root level element too
if 'make_global_settings' in output:
  make_global_settings = output['make_global_settings']
  del output['make_global_settings']
else:
  make_global_settings = False

# Add configurations to target defaults
output['configurations'] = configurations

output = {
  'variables': variables,
  'target_defaults': output,
}
if make_global_settings:
  output['make_global_settings'] = make_global_settings

print_verbose(output)

write('config.gypi', do_not_edit +
      pprint.pformat(output, indent=2, width=128) + '\n')

write('config.status', '#!/bin/sh\nset -x\nexec ./configure ' +
      ' '.join([shlex.quote(arg) for arg in original_argv]) + '\n')
Path('config.status').chmod(0o775)


config = {
  'BUILDTYPE': 'Debug' if options.debug else 'Release',
  'NODE_TARGET_TYPE': variables['node_target_type'],
}

# Not needed for trivial case. Useless when it's a win32 path.
if sys.executable != 'python' and ':\\' not in sys.executable:
  config['PYTHON'] = sys.executable

if options.prefix:
  config['PREFIX'] = options.prefix

if options.use_ninja:
  config['BUILD_WITH'] = 'ninja'

# On Windows there is another find.exe in C:\Windows\System32
if sys.platform == 'win32':
  config['FIND'] = '/usr/bin/find'

config_lines = ['='.join((k,v)) for k,v in config.items()]
# Add a blank string to get a blank line at the end.
config_lines += ['']
config_str = '\n'.join(config_lines)

# On Windows there's no reason to search for a different python binary.
bin_override = None if sys.platform == 'win32' else make_bin_override()
if bin_override:
  config_str = 'export PATH:=' + str(bin_override) + ':$(PATH)\n' + config_str

write('config.mk', do_not_edit + config_str)



gyp_args = ['--no-parallel', '-Dconfiguring_node=1']
gyp_args += ['-Dbuild_type=' + config['BUILDTYPE']]

# Remove the trailing .exe from the executable name, otherwise the python.exe
# would be rewrote as python_host.exe due to hack in GYP for supporting cross
# compilation on Windows.
# See https://github.com/nodejs/node/pull/32867 for related change.
python = sys.executable
if flavor == 'win' and python.lower().endswith('.exe'):
  python = python[:-4]
# Always set 'python' variable, otherwise environments that only have python3
# will fail to run python scripts.
gyp_args += ['-Dpython=' + python]

if options.use_ninja:
  gyp_args += ['-f', 'ninja-' + flavor]
elif flavor == 'win' and sys.platform != 'msys':
  gyp_args += ['-f', 'msvs', '-G', 'msvs_version=auto']
else:
  gyp_args += ['-f', 'make-' + flavor]

if options.compile_commands_json:
  gyp_args += ['-f', 'compile_commands_json']
  if sys.platform != 'win32':
    os.path.lexists('./compile_commands.json') and os.unlink('./compile_commands.json')
    os.symlink('./out/' + config['BUILDTYPE'] + '/compile_commands.json', './compile_commands.json')

# pass the leftover non-whitespace positional arguments to GYP
gyp_args += [arg for arg in args if not str.isspace(arg)]

if warn.warned and not options.verbose:
  warn('warnings were emitted in the configure phase')

print_verbose("running: \n    " + " ".join(['python', 'tools/gyp_node.py'] + gyp_args))
run_gyp(gyp_args)
if options.compile_commands_json and sys.platform == 'win32':
  os.path.isfile('./compile_commands.json') and os.unlink('./compile_commands.json')
  shutil.copy2('./out/' + config['BUILDTYPE'] + '/compile_commands.json', './compile_commands.json')
info('configure completed successfully')
                                                                                                                                  node-23.7.0/deps/                                                                                   0000775 0000000 0000000 00000000000 14746647661 0013510 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/acorn/                                                                             0000775 0000000 0000000 00000000000 14746647661 0014612 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/acorn/acorn-walk/                                                                  0000775 0000000 0000000 00000000000 14746647661 0016650 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/acorn/acorn-walk/CHANGELOG.md                                                      0000664 0000000 0000000 00000007102 14746647661 0020461 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ## 8.3.4 (2024-09-09)

### Bug fixes

Walk SwitchCase nodes as separate nodes.

## 8.3.3 (2024-01-11)

### Bug fixes

Make acorn a dependency because acorn-walk uses the types from that package.

## 8.3.2 (2024-01-11)

### Bug fixes

Add missing type for `findNodeBefore`.

## 8.3.1 (2023-12-06)

### Bug fixes

Add `Function` and `Class` to the `AggregateType` type, so that they can be used in walkers without raising a type error.

Visitor functions are now called in such a way that their `this` refers to the object they are part of.

## 8.3.0 (2023-10-26)

### New features

Use a set of new, much more precise, TypeScript types.

## 8.2.0 (2021-09-06)

### New features

Add support for walking ES2022 class static blocks.

## 8.1.1 (2021-06-29)

### Bug fixes

Include `base` in the type declarations.

## 8.1.0 (2021-04-24)

### New features

Support node types for class fields and private methods.

## 8.0.2 (2021-01-25)

### Bug fixes

Adjust package.json to work with Node 12.16.0 and 13.0-13.6.

## 8.0.0 (2021-01-05)

### Bug fixes

Fix a bug where `full` and `fullAncestor` would skip nodes with overridden types.

## 8.0.0 (2020-08-12)

### New features

The package can now be loaded directly as an ECMAScript module in node 13+.

## 7.2.0 (2020-06-17)

### New features

Support optional chaining and nullish coalescing.

Support `import.meta`.

Add support for `export * as ns from "source"`.

## 7.1.1 (2020-02-13)

### Bug fixes

Clean up the type definitions to actually work well with the main parser.

## 7.1.0 (2020-02-11)

### New features

Add a TypeScript definition file for the library.

## 7.0.0 (2017-08-12)

### New features

Support walking `ImportExpression` nodes.

## 6.2.0 (2017-07-04)

### New features

Add support for `Import` nodes.

## 6.1.0 (2018-09-28)

### New features

The walker now walks `TemplateElement` nodes.

## 6.0.1 (2018-09-14)

### Bug fixes

Fix bad "main" field in package.json.

## 6.0.0 (2018-09-14)

### Breaking changes

This is now a separate package, `acorn-walk`, rather than part of the main `acorn` package.

The `ScopeBody` and `ScopeExpression` meta-node-types are no longer supported.

## 5.7.1 (2018-06-15)

### Bug fixes

Make sure the walker and bin files are rebuilt on release (the previous release didn't get the up-to-date versions).

## 5.7.0 (2018-06-15)

### Bug fixes

Fix crash in walker when walking a binding-less catch node.

## 5.6.2 (2018-06-05)

### Bug fixes

In the walker, go back to allowing the `baseVisitor` argument to be null to default to the default base everywhere.

## 5.6.1 (2018-06-01)

### Bug fixes

Fix regression when passing `null` as fourth argument to `walk.recursive`.

## 5.6.0 (2018-05-31)

### Bug fixes

Fix a bug in the walker that caused a crash when walking an object pattern spread.

## 5.5.1 (2018-03-06)

### Bug fixes

Fix regression in walker causing property values in object patterns to be walked as expressions.

## 5.5.0 (2018-02-27)

### Bug fixes

Support object spread in the AST walker.

## 5.4.1 (2018-02-02)

### Bug fixes

5.4.0 somehow accidentally included an old version of walk.js.

## 5.2.0 (2017-10-30)

### Bug fixes

The `full` and `fullAncestor` walkers no longer visit nodes multiple times.

## 5.1.0 (2017-07-05)

### New features

New walker functions `full` and `fullAncestor`.

## 3.2.0 (2016-06-07)

### New features

Make it possible to use `visit.ancestor` with a walk state.

## 3.1.0 (2016-04-18)

### New features

The walker now allows defining handlers for `CatchClause` nodes.

## 2.5.2 (2015-10-27)

### Fixes

Fix bug where the walker walked an exported `let` statement as an expression.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/acorn/acorn-walk/LICENSE                                                           0000664 0000000 0000000 00000002113 14746647661 0017652 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        MIT License

Copyright (C) 2012-2020 by various contributors (see AUTHORS)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/acorn/acorn-walk/README.md                                                         0000664 0000000 0000000 00000010563 14746647661 0020134 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Acorn AST walker

An abstract syntax tree walker for the
[ESTree](https://github.com/estree/estree) format.

## Community

Acorn is open source software released under an
[MIT license](https://github.com/acornjs/acorn/blob/master/acorn-walk/LICENSE).

You are welcome to
[report bugs](https://github.com/acornjs/acorn/issues) or create pull
requests on [github](https://github.com/acornjs/acorn).

## Installation

The easiest way to install acorn is from [`npm`](https://www.npmjs.com/):

```sh
npm install acorn-walk
```

Alternately, you can download the source and build acorn yourself:

```sh
git clone https://github.com/acornjs/acorn.git
cd acorn
npm install
```

## Interface

An algorithm for recursing through a syntax tree is stored as an
object, with a property for each tree node type holding a function
that will recurse through such a node. There are several ways to run
such a walker.

**simple**`(node, visitors, base, state)` does a 'simple' walk over a
tree. `node` should be the AST node to walk, and `visitors` an object
with properties whose names correspond to node types in the [ESTree
spec](https://github.com/estree/estree). The properties should contain
functions that will be called with the node object and, if applicable
the state at that point. The last two arguments are optional. `base`
is a walker algorithm, and `state` is a start state. The default
walker will simply visit all statements and expressions and not
produce a meaningful state. (An example of a use of state is to track
scope at each point in the tree.)

```js
const acorn = require("acorn")
const walk = require("acorn-walk")

walk.simple(acorn.parse("let x = 10"), {
  Literal(node) {
    console.log(`Found a literal: ${node.value}`)
  }
})
```

**ancestor**`(node, visitors, base, state)` does a 'simple' walk over
a tree, building up an array of ancestor nodes (including the current node)
and passing the array to the callbacks as a third parameter.

```js
const acorn = require("acorn")
const walk = require("acorn-walk")

walk.ancestor(acorn.parse("foo('hi')"), {
  Literal(_node, _state, ancestors) {
    console.log("This literal's ancestors are:", ancestors.map(n => n.type))
  }
})
```

**recursive**`(node, state, functions, base)` does a 'recursive'
walk, where the walker functions are responsible for continuing the
walk on the child nodes of their target node. `state` is the start
state, and `functions` should contain an object that maps node types
to walker functions. Such functions are called with `(node, state, c)`
arguments, and can cause the walk to continue on a sub-node by calling
the `c` argument on it with `(node, state)` arguments. The optional
`base` argument provides the fallback walker functions for node types
that aren't handled in the `functions` object. If not given, the
default walkers will be used.

**make**`(functions, base)` builds a new walker object by using the
walker functions in `functions` and filling in the missing ones by
taking defaults from `base`.

**full**`(node, callback, base, state)` does a 'full' walk over a
tree, calling the callback with the arguments (node, state, type) for
each node

**fullAncestor**`(node, callback, base, state)` does a 'full' walk
over a tree, building up an array of ancestor nodes (including the
current node) and passing the array to the callbacks as a third
parameter.

```js
const acorn = require("acorn")
const walk = require("acorn-walk")

walk.full(acorn.parse("1 + 1"), node => {
  console.log(`There's a ${node.type} node at ${node.ch}`)
})
```

**findNodeAt**`(node, start, end, test, base, state)` tries to locate
a node in a tree at the given start and/or end offsets, which
satisfies the predicate `test`. `start` and `end` can be either `null`
(as wildcard) or a number. `test` may be a string (indicating a node
type) or a function that takes `(nodeType, node)` arguments and
returns a boolean indicating whether this node is interesting. `base`
and `state` are optional, and can be used to specify a custom walker.
Nodes are tested from inner to outer, so if two nodes match the
boundaries, the inner one will be preferred.

**findNodeAround**`(node, pos, test, base, state)` is a lot like
`findNodeAt`, but will match any node that exists 'around' (spanning)
the given position.

**findNodeAfter**`(node, pos, test, base, state)` is similar to
`findNodeAround`, but will match all nodes *after* the given position
(testing outer nodes before inner nodes).
                                                                                                                                             node-23.7.0/deps/acorn/acorn-walk/dist/                                                             0000775 0000000 0000000 00000000000 14746647661 0017613 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/acorn/acorn-walk/dist/walk.d.mts                                                   0000664 0000000 0000000 00000013502 14746647661 0021521 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import * as acorn from "acorn"

export type FullWalkerCallback<TState> = (
  node: acorn.Node,
  state: TState,
  type: string
) => void

export type FullAncestorWalkerCallback<TState> = (
  node: acorn.Node,
  state: TState,
  ancestors: acorn.Node[],
  type: string
) => void

type AggregateType = {
  Expression: acorn.Expression,
  Statement: acorn.Statement,
  Function: acorn.Function,
  Class: acorn.Class,
  Pattern: acorn.Pattern,
  ForInit: acorn.VariableDeclaration | acorn.Expression
}

export type SimpleVisitors<TState> = {
  [type in acorn.AnyNode["type"]]?: (node: Extract<acorn.AnyNode, { type: type }>, state: TState) => void
} & {
  [type in keyof AggregateType]?: (node: AggregateType[type], state: TState) => void
}

export type AncestorVisitors<TState> = {
  [type in acorn.AnyNode["type"]]?: ( node: Extract<acorn.AnyNode, { type: type }>, state: TState, ancestors: acorn.Node[]
) => void
} & {
  [type in keyof AggregateType]?: (node: AggregateType[type], state: TState, ancestors: acorn.Node[]) => void
}

export type WalkerCallback<TState> = (node: acorn.Node, state: TState) => void

export type RecursiveVisitors<TState> = {
  [type in acorn.AnyNode["type"]]?: ( node: Extract<acorn.AnyNode, { type: type }>, state: TState, callback: WalkerCallback<TState>) => void
} &  {
  [type in keyof AggregateType]?: (node: AggregateType[type], state: TState, callback: WalkerCallback<TState>) => void
}

export type FindPredicate = (type: string, node: acorn.Node) => boolean

export interface Found<TState> {
  node: acorn.Node,
  state: TState
}

/**
 * does a 'simple' walk over a tree
 * @param node the AST node to walk
 * @param visitors an object with properties whose names correspond to node types in the {@link https://github.com/estree/estree | ESTree spec}. The properties should contain functions that will be called with the node object and, if applicable the state at that point.
 * @param base a walker algorithm
 * @param state a start state. The default walker will simply visit all statements and expressions and not produce a meaningful state. (An example of a use of state is to track scope at each point in the tree.)
 */
export function simple<TState>(
  node: acorn.Node,
  visitors: SimpleVisitors<TState>,
  base?: RecursiveVisitors<TState>,
  state?: TState
): void

/**
 * does a 'simple' walk over a tree, building up an array of ancestor nodes (including the current node) and passing the array to the callbacks as a third parameter.
 * @param node
 * @param visitors
 * @param base
 * @param state
 */
export function ancestor<TState>(
    node: acorn.Node,
    visitors: AncestorVisitors<TState>,
    base?: RecursiveVisitors<TState>,
    state?: TState
  ): void

/**
 * does a 'recursive' walk, where the walker functions are responsible for continuing the walk on the child nodes of their target node.
 * @param node
 * @param state the start state
 * @param functions contain an object that maps node types to walker functions
 * @param base provides the fallback walker functions for node types that aren't handled in the {@link functions} object. If not given, the default walkers will be used.
 */
export function recursive<TState>(
  node: acorn.Node,
  state: TState,
  functions: RecursiveVisitors<TState>,
  base?: RecursiveVisitors<TState>
): void

/**
 * does a 'full' walk over a tree, calling the {@link callback} with the arguments (node, state, type) for each node
 * @param node
 * @param callback
 * @param base
 * @param state
 */
export function full<TState>(
  node: acorn.Node,
  callback: FullWalkerCallback<TState>,
  base?: RecursiveVisitors<TState>,
  state?: TState
): void

/**
 * does a 'full' walk over a tree, building up an array of ancestor nodes (including the current node) and passing the array to the callbacks as a third parameter.
 * @param node
 * @param callback
 * @param base
 * @param state
 */
export function fullAncestor<TState>(
  node: acorn.Node,
  callback: FullAncestorWalkerCallback<TState>,
  base?: RecursiveVisitors<TState>,
  state?: TState
): void

/**
 * builds a new walker object by using the walker functions in {@link functions} and filling in the missing ones by taking defaults from {@link base}.
 * @param functions
 * @param base
 */
export function make<TState>(
  functions: RecursiveVisitors<TState>,
  base?: RecursiveVisitors<TState>
): RecursiveVisitors<TState>

/**
 * tries to locate a node in a tree at the given start and/or end offsets, which satisfies the predicate test. {@link start} and {@link end} can be either `null` (as wildcard) or a `number`. {@link test} may be a string (indicating a node type) or a function that takes (nodeType, node) arguments and returns a boolean indicating whether this node is interesting. {@link base} and {@link state} are optional, and can be used to specify a custom walker. Nodes are tested from inner to outer, so if two nodes match the boundaries, the inner one will be preferred.
 * @param node
 * @param start
 * @param end
 * @param type
 * @param base
 * @param state
 */
export function findNodeAt<TState>(
  node: acorn.Node,
  start: number | undefined,
  end?: number | undefined,
  type?: FindPredicate | string,
  base?: RecursiveVisitors<TState>,
  state?: TState
): Found<TState> | undefined

/**
 * like {@link findNodeAt}, but will match any node that exists 'around' (spanning) the given position.
 * @param node
 * @param start
 * @param type
 * @param base
 * @param state
 */
export function findNodeAround<TState>(
  node: acorn.Node,
  start: number | undefined,
  type?: FindPredicate | string,
  base?: RecursiveVisitors<TState>,
  state?: TState
): Found<TState> | undefined

/**
 * Find the outermost matching node after a given position.
 */
export const findNodeAfter: typeof findNodeAround

/**
 * Find the outermost matching node before a given position.
 */
export const findNodeBefore: typeof findNodeAround

export const base: RecursiveVisitors<any>
                                                                                                                                                                                              node-23.7.0/deps/acorn/acorn-walk/dist/walk.d.ts                                                    0000664 0000000 0000000 00000013502 14746647661 0021344 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import * as acorn from "acorn"

export type FullWalkerCallback<TState> = (
  node: acorn.Node,
  state: TState,
  type: string
) => void

export type FullAncestorWalkerCallback<TState> = (
  node: acorn.Node,
  state: TState,
  ancestors: acorn.Node[],
  type: string
) => void

type AggregateType = {
  Expression: acorn.Expression,
  Statement: acorn.Statement,
  Function: acorn.Function,
  Class: acorn.Class,
  Pattern: acorn.Pattern,
  ForInit: acorn.VariableDeclaration | acorn.Expression
}

export type SimpleVisitors<TState> = {
  [type in acorn.AnyNode["type"]]?: (node: Extract<acorn.AnyNode, { type: type }>, state: TState) => void
} & {
  [type in keyof AggregateType]?: (node: AggregateType[type], state: TState) => void
}

export type AncestorVisitors<TState> = {
  [type in acorn.AnyNode["type"]]?: ( node: Extract<acorn.AnyNode, { type: type }>, state: TState, ancestors: acorn.Node[]
) => void
} & {
  [type in keyof AggregateType]?: (node: AggregateType[type], state: TState, ancestors: acorn.Node[]) => void
}

export type WalkerCallback<TState> = (node: acorn.Node, state: TState) => void

export type RecursiveVisitors<TState> = {
  [type in acorn.AnyNode["type"]]?: ( node: Extract<acorn.AnyNode, { type: type }>, state: TState, callback: WalkerCallback<TState>) => void
} &  {
  [type in keyof AggregateType]?: (node: AggregateType[type], state: TState, callback: WalkerCallback<TState>) => void
}

export type FindPredicate = (type: string, node: acorn.Node) => boolean

export interface Found<TState> {
  node: acorn.Node,
  state: TState
}

/**
 * does a 'simple' walk over a tree
 * @param node the AST node to walk
 * @param visitors an object with properties whose names correspond to node types in the {@link https://github.com/estree/estree | ESTree spec}. The properties should contain functions that will be called with the node object and, if applicable the state at that point.
 * @param base a walker algorithm
 * @param state a start state. The default walker will simply visit all statements and expressions and not produce a meaningful state. (An example of a use of state is to track scope at each point in the tree.)
 */
export function simple<TState>(
  node: acorn.Node,
  visitors: SimpleVisitors<TState>,
  base?: RecursiveVisitors<TState>,
  state?: TState
): void

/**
 * does a 'simple' walk over a tree, building up an array of ancestor nodes (including the current node) and passing the array to the callbacks as a third parameter.
 * @param node
 * @param visitors
 * @param base
 * @param state
 */
export function ancestor<TState>(
    node: acorn.Node,
    visitors: AncestorVisitors<TState>,
    base?: RecursiveVisitors<TState>,
    state?: TState
  ): void

/**
 * does a 'recursive' walk, where the walker functions are responsible for continuing the walk on the child nodes of their target node.
 * @param node
 * @param state the start state
 * @param functions contain an object that maps node types to walker functions
 * @param base provides the fallback walker functions for node types that aren't handled in the {@link functions} object. If not given, the default walkers will be used.
 */
export function recursive<TState>(
  node: acorn.Node,
  state: TState,
  functions: RecursiveVisitors<TState>,
  base?: RecursiveVisitors<TState>
): void

/**
 * does a 'full' walk over a tree, calling the {@link callback} with the arguments (node, state, type) for each node
 * @param node
 * @param callback
 * @param base
 * @param state
 */
export function full<TState>(
  node: acorn.Node,
  callback: FullWalkerCallback<TState>,
  base?: RecursiveVisitors<TState>,
  state?: TState
): void

/**
 * does a 'full' walk over a tree, building up an array of ancestor nodes (including the current node) and passing the array to the callbacks as a third parameter.
 * @param node
 * @param callback
 * @param base
 * @param state
 */
export function fullAncestor<TState>(
  node: acorn.Node,
  callback: FullAncestorWalkerCallback<TState>,
  base?: RecursiveVisitors<TState>,
  state?: TState
): void

/**
 * builds a new walker object by using the walker functions in {@link functions} and filling in the missing ones by taking defaults from {@link base}.
 * @param functions
 * @param base
 */
export function make<TState>(
  functions: RecursiveVisitors<TState>,
  base?: RecursiveVisitors<TState>
): RecursiveVisitors<TState>

/**
 * tries to locate a node in a tree at the given start and/or end offsets, which satisfies the predicate test. {@link start} and {@link end} can be either `null` (as wildcard) or a `number`. {@link test} may be a string (indicating a node type) or a function that takes (nodeType, node) arguments and returns a boolean indicating whether this node is interesting. {@link base} and {@link state} are optional, and can be used to specify a custom walker. Nodes are tested from inner to outer, so if two nodes match the boundaries, the inner one will be preferred.
 * @param node
 * @param start
 * @param end
 * @param type
 * @param base
 * @param state
 */
export function findNodeAt<TState>(
  node: acorn.Node,
  start: number | undefined,
  end?: number | undefined,
  type?: FindPredicate | string,
  base?: RecursiveVisitors<TState>,
  state?: TState
): Found<TState> | undefined

/**
 * like {@link findNodeAt}, but will match any node that exists 'around' (spanning) the given position.
 * @param node
 * @param start
 * @param type
 * @param base
 * @param state
 */
export function findNodeAround<TState>(
  node: acorn.Node,
  start: number | undefined,
  type?: FindPredicate | string,
  base?: RecursiveVisitors<TState>,
  state?: TState
): Found<TState> | undefined

/**
 * Find the outermost matching node after a given position.
 */
export const findNodeAfter: typeof findNodeAround

/**
 * Find the outermost matching node before a given position.
 */
export const findNodeBefore: typeof findNodeAround

export const base: RecursiveVisitors<any>
                                                                                                                                                                                              node-23.7.0/deps/acorn/acorn-walk/dist/walk.js                                                      0000664 0000000 0000000 00000036615 14746647661 0021122 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        (function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.acorn = global.acorn || {}, global.acorn.walk = {})));
})(this, (function (exports) { 'use strict';

  // AST walker module for ESTree compatible trees

  // A simple walk is one where you simply specify callbacks to be
  // called on specific nodes. The last two arguments are optional. A
  // simple use would be
  //
  //     walk.simple(myTree, {
  //         Expression: function(node) { ... }
  //     });
  //
  // to do something with all expressions. All ESTree node types
  // can be used to identify node types, as well as Expression and
  // Statement, which denote categories of nodes.
  //
  // The base argument can be used to pass a custom (recursive)
  // walker, and state can be used to give this walked an initial
  // state.

  function simple(node, visitors, baseVisitor, state, override) {
    if (!baseVisitor) { baseVisitor = base
    ; }(function c(node, st, override) {
      var type = override || node.type;
      baseVisitor[type](node, st, c);
      if (visitors[type]) { visitors[type](node, st); }
    })(node, state, override);
  }

  // An ancestor walk keeps an array of ancestor nodes (including the
  // current node) and passes them to the callback as third parameter
  // (and also as state parameter when no other state is present).
  function ancestor(node, visitors, baseVisitor, state, override) {
    var ancestors = [];
    if (!baseVisitor) { baseVisitor = base
    ; }(function c(node, st, override) {
      var type = override || node.type;
      var isNew = node !== ancestors[ancestors.length - 1];
      if (isNew) { ancestors.push(node); }
      baseVisitor[type](node, st, c);
      if (visitors[type]) { visitors[type](node, st || ancestors, ancestors); }
      if (isNew) { ancestors.pop(); }
    })(node, state, override);
  }

  // A recursive walk is one where your functions override the default
  // walkers. They can modify and replace the state parameter that's
  // threaded through the walk, and can opt how and whether to walk
  // their child nodes (by calling their third argument on these
  // nodes).
  function recursive(node, state, funcs, baseVisitor, override) {
    var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor
    ;(function c(node, st, override) {
      visitor[override || node.type](node, st, c);
    })(node, state, override);
  }

  function makeTest(test) {
    if (typeof test === "string")
      { return function (type) { return type === test; } }
    else if (!test)
      { return function () { return true; } }
    else
      { return test }
  }

  var Found = function Found(node, state) { this.node = node; this.state = state; };

  // A full walk triggers the callback on each node
  function full(node, callback, baseVisitor, state, override) {
    if (!baseVisitor) { baseVisitor = base; }
    var last
    ;(function c(node, st, override) {
      var type = override || node.type;
      baseVisitor[type](node, st, c);
      if (last !== node) {
        callback(node, st, type);
        last = node;
      }
    })(node, state, override);
  }

  // An fullAncestor walk is like an ancestor walk, but triggers
  // the callback on each node
  function fullAncestor(node, callback, baseVisitor, state) {
    if (!baseVisitor) { baseVisitor = base; }
    var ancestors = [], last
    ;(function c(node, st, override) {
      var type = override || node.type;
      var isNew = node !== ancestors[ancestors.length - 1];
      if (isNew) { ancestors.push(node); }
      baseVisitor[type](node, st, c);
      if (last !== node) {
        callback(node, st || ancestors, ancestors, type);
        last = node;
      }
      if (isNew) { ancestors.pop(); }
    })(node, state);
  }

  // Find a node with a given start, end, and type (all are optional,
  // null can be used as wildcard). Returns a {node, state} object, or
  // undefined when it doesn't find a matching node.
  function findNodeAt(node, start, end, test, baseVisitor, state) {
    if (!baseVisitor) { baseVisitor = base; }
    test = makeTest(test);
    try {
      (function c(node, st, override) {
        var type = override || node.type;
        if ((start == null || node.start <= start) &&
            (end == null || node.end >= end))
          { baseVisitor[type](node, st, c); }
        if ((start == null || node.start === start) &&
            (end == null || node.end === end) &&
            test(type, node))
          { throw new Found(node, st) }
      })(node, state);
    } catch (e) {
      if (e instanceof Found) { return e }
      throw e
    }
  }

  // Find the innermost node of a given type that contains the given
  // position. Interface similar to findNodeAt.
  function findNodeAround(node, pos, test, baseVisitor, state) {
    test = makeTest(test);
    if (!baseVisitor) { baseVisitor = base; }
    try {
      (function c(node, st, override) {
        var type = override || node.type;
        if (node.start > pos || node.end < pos) { return }
        baseVisitor[type](node, st, c);
        if (test(type, node)) { throw new Found(node, st) }
      })(node, state);
    } catch (e) {
      if (e instanceof Found) { return e }
      throw e
    }
  }

  // Find the outermost matching node after a given position.
  function findNodeAfter(node, pos, test, baseVisitor, state) {
    test = makeTest(test);
    if (!baseVisitor) { baseVisitor = base; }
    try {
      (function c(node, st, override) {
        if (node.end < pos) { return }
        var type = override || node.type;
        if (node.start >= pos && test(type, node)) { throw new Found(node, st) }
        baseVisitor[type](node, st, c);
      })(node, state);
    } catch (e) {
      if (e instanceof Found) { return e }
      throw e
    }
  }

  // Find the outermost matching node before a given position.
  function findNodeBefore(node, pos, test, baseVisitor, state) {
    test = makeTest(test);
    if (!baseVisitor) { baseVisitor = base; }
    var max
    ;(function c(node, st, override) {
      if (node.start > pos) { return }
      var type = override || node.type;
      if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))
        { max = new Found(node, st); }
      baseVisitor[type](node, st, c);
    })(node, state);
    return max
  }

  // Used to create a custom walker. Will fill in all missing node
  // type properties with the defaults.
  function make(funcs, baseVisitor) {
    var visitor = Object.create(baseVisitor || base);
    for (var type in funcs) { visitor[type] = funcs[type]; }
    return visitor
  }

  function skipThrough(node, st, c) { c(node, st); }
  function ignore(_node, _st, _c) {}

  // Node walkers.

  var base = {};

  base.Program = base.BlockStatement = base.StaticBlock = function (node, st, c) {
    for (var i = 0, list = node.body; i < list.length; i += 1)
      {
      var stmt = list[i];

      c(stmt, st, "Statement");
    }
  };
  base.Statement = skipThrough;
  base.EmptyStatement = ignore;
  base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression =
    function (node, st, c) { return c(node.expression, st, "Expression"); };
  base.IfStatement = function (node, st, c) {
    c(node.test, st, "Expression");
    c(node.consequent, st, "Statement");
    if (node.alternate) { c(node.alternate, st, "Statement"); }
  };
  base.LabeledStatement = function (node, st, c) { return c(node.body, st, "Statement"); };
  base.BreakStatement = base.ContinueStatement = ignore;
  base.WithStatement = function (node, st, c) {
    c(node.object, st, "Expression");
    c(node.body, st, "Statement");
  };
  base.SwitchStatement = function (node, st, c) {
    c(node.discriminant, st, "Expression");
    for (var i = 0, list = node.cases; i < list.length; i += 1) {
      var cs = list[i];

      c(cs, st);
    }
  };
  base.SwitchCase = function (node, st, c) {
    if (node.test) { c(node.test, st, "Expression"); }
    for (var i = 0, list = node.consequent; i < list.length; i += 1)
      {
      var cons = list[i];

      c(cons, st, "Statement");
    }
  };
  base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {
    if (node.argument) { c(node.argument, st, "Expression"); }
  };
  base.ThrowStatement = base.SpreadElement =
    function (node, st, c) { return c(node.argument, st, "Expression"); };
  base.TryStatement = function (node, st, c) {
    c(node.block, st, "Statement");
    if (node.handler) { c(node.handler, st); }
    if (node.finalizer) { c(node.finalizer, st, "Statement"); }
  };
  base.CatchClause = function (node, st, c) {
    if (node.param) { c(node.param, st, "Pattern"); }
    c(node.body, st, "Statement");
  };
  base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
    c(node.test, st, "Expression");
    c(node.body, st, "Statement");
  };
  base.ForStatement = function (node, st, c) {
    if (node.init) { c(node.init, st, "ForInit"); }
    if (node.test) { c(node.test, st, "Expression"); }
    if (node.update) { c(node.update, st, "Expression"); }
    c(node.body, st, "Statement");
  };
  base.ForInStatement = base.ForOfStatement = function (node, st, c) {
    c(node.left, st, "ForInit");
    c(node.right, st, "Expression");
    c(node.body, st, "Statement");
  };
  base.ForInit = function (node, st, c) {
    if (node.type === "VariableDeclaration") { c(node, st); }
    else { c(node, st, "Expression"); }
  };
  base.DebuggerStatement = ignore;

  base.FunctionDeclaration = function (node, st, c) { return c(node, st, "Function"); };
  base.VariableDeclaration = function (node, st, c) {
    for (var i = 0, list = node.declarations; i < list.length; i += 1)
      {
      var decl = list[i];

      c(decl, st);
    }
  };
  base.VariableDeclarator = function (node, st, c) {
    c(node.id, st, "Pattern");
    if (node.init) { c(node.init, st, "Expression"); }
  };

  base.Function = function (node, st, c) {
    if (node.id) { c(node.id, st, "Pattern"); }
    for (var i = 0, list = node.params; i < list.length; i += 1)
      {
      var param = list[i];

      c(param, st, "Pattern");
    }
    c(node.body, st, node.expression ? "Expression" : "Statement");
  };

  base.Pattern = function (node, st, c) {
    if (node.type === "Identifier")
      { c(node, st, "VariablePattern"); }
    else if (node.type === "MemberExpression")
      { c(node, st, "MemberPattern"); }
    else
      { c(node, st); }
  };
  base.VariablePattern = ignore;
  base.MemberPattern = skipThrough;
  base.RestElement = function (node, st, c) { return c(node.argument, st, "Pattern"); };
  base.ArrayPattern = function (node, st, c) {
    for (var i = 0, list = node.elements; i < list.length; i += 1) {
      var elt = list[i];

      if (elt) { c(elt, st, "Pattern"); }
    }
  };
  base.ObjectPattern = function (node, st, c) {
    for (var i = 0, list = node.properties; i < list.length; i += 1) {
      var prop = list[i];

      if (prop.type === "Property") {
        if (prop.computed) { c(prop.key, st, "Expression"); }
        c(prop.value, st, "Pattern");
      } else if (prop.type === "RestElement") {
        c(prop.argument, st, "Pattern");
      }
    }
  };

  base.Expression = skipThrough;
  base.ThisExpression = base.Super = base.MetaProperty = ignore;
  base.ArrayExpression = function (node, st, c) {
    for (var i = 0, list = node.elements; i < list.length; i += 1) {
      var elt = list[i];

      if (elt) { c(elt, st, "Expression"); }
    }
  };
  base.ObjectExpression = function (node, st, c) {
    for (var i = 0, list = node.properties; i < list.length; i += 1)
      {
      var prop = list[i];

      c(prop, st);
    }
  };
  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
  base.SequenceExpression = function (node, st, c) {
    for (var i = 0, list = node.expressions; i < list.length; i += 1)
      {
      var expr = list[i];

      c(expr, st, "Expression");
    }
  };
  base.TemplateLiteral = function (node, st, c) {
    for (var i = 0, list = node.quasis; i < list.length; i += 1)
      {
      var quasi = list[i];

      c(quasi, st);
    }

    for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)
      {
      var expr = list$1[i$1];

      c(expr, st, "Expression");
    }
  };
  base.TemplateElement = ignore;
  base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
    c(node.argument, st, "Expression");
  };
  base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
    c(node.left, st, "Expression");
    c(node.right, st, "Expression");
  };
  base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
    c(node.left, st, "Pattern");
    c(node.right, st, "Expression");
  };
  base.ConditionalExpression = function (node, st, c) {
    c(node.test, st, "Expression");
    c(node.consequent, st, "Expression");
    c(node.alternate, st, "Expression");
  };
  base.NewExpression = base.CallExpression = function (node, st, c) {
    c(node.callee, st, "Expression");
    if (node.arguments)
      { for (var i = 0, list = node.arguments; i < list.length; i += 1)
        {
          var arg = list[i];

          c(arg, st, "Expression");
        } }
  };
  base.MemberExpression = function (node, st, c) {
    c(node.object, st, "Expression");
    if (node.computed) { c(node.property, st, "Expression"); }
  };
  base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
    if (node.declaration)
      { c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression"); }
    if (node.source) { c(node.source, st, "Expression"); }
  };
  base.ExportAllDeclaration = function (node, st, c) {
    if (node.exported)
      { c(node.exported, st); }
    c(node.source, st, "Expression");
  };
  base.ImportDeclaration = function (node, st, c) {
    for (var i = 0, list = node.specifiers; i < list.length; i += 1)
      {
      var spec = list[i];

      c(spec, st);
    }
    c(node.source, st, "Expression");
  };
  base.ImportExpression = function (node, st, c) {
    c(node.source, st, "Expression");
  };
  base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;

  base.TaggedTemplateExpression = function (node, st, c) {
    c(node.tag, st, "Expression");
    c(node.quasi, st, "Expression");
  };
  base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, "Class"); };
  base.Class = function (node, st, c) {
    if (node.id) { c(node.id, st, "Pattern"); }
    if (node.superClass) { c(node.superClass, st, "Expression"); }
    c(node.body, st);
  };
  base.ClassBody = function (node, st, c) {
    for (var i = 0, list = node.body; i < list.length; i += 1)
      {
      var elt = list[i];

      c(elt, st);
    }
  };
  base.MethodDefinition = base.PropertyDefinition = base.Property = function (node, st, c) {
    if (node.computed) { c(node.key, st, "Expression"); }
    if (node.value) { c(node.value, st, "Expression"); }
  };

  exports.ancestor = ancestor;
  exports.base = base;
  exports.findNodeAfter = findNodeAfter;
  exports.findNodeAround = findNodeAround;
  exports.findNodeAt = findNodeAt;
  exports.findNodeBefore = findNodeBefore;
  exports.full = full;
  exports.fullAncestor = fullAncestor;
  exports.make = make;
  exports.recursive = recursive;
  exports.simple = simple;

}));
                                                                                                                   node-23.7.0/deps/acorn/acorn-walk/dist/walk.mjs                                                     0000664 0000000 0000000 00000034005 14746647661 0021266 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // AST walker module for ESTree compatible trees

// A simple walk is one where you simply specify callbacks to be
// called on specific nodes. The last two arguments are optional. A
// simple use would be
//
//     walk.simple(myTree, {
//         Expression: function(node) { ... }
//     });
//
// to do something with all expressions. All ESTree node types
// can be used to identify node types, as well as Expression and
// Statement, which denote categories of nodes.
//
// The base argument can be used to pass a custom (recursive)
// walker, and state can be used to give this walked an initial
// state.

function simple(node, visitors, baseVisitor, state, override) {
  if (!baseVisitor) { baseVisitor = base
  ; }(function c(node, st, override) {
    var type = override || node.type;
    baseVisitor[type](node, st, c);
    if (visitors[type]) { visitors[type](node, st); }
  })(node, state, override);
}

// An ancestor walk keeps an array of ancestor nodes (including the
// current node) and passes them to the callback as third parameter
// (and also as state parameter when no other state is present).
function ancestor(node, visitors, baseVisitor, state, override) {
  var ancestors = [];
  if (!baseVisitor) { baseVisitor = base
  ; }(function c(node, st, override) {
    var type = override || node.type;
    var isNew = node !== ancestors[ancestors.length - 1];
    if (isNew) { ancestors.push(node); }
    baseVisitor[type](node, st, c);
    if (visitors[type]) { visitors[type](node, st || ancestors, ancestors); }
    if (isNew) { ancestors.pop(); }
  })(node, state, override);
}

// A recursive walk is one where your functions override the default
// walkers. They can modify and replace the state parameter that's
// threaded through the walk, and can opt how and whether to walk
// their child nodes (by calling their third argument on these
// nodes).
function recursive(node, state, funcs, baseVisitor, override) {
  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor
  ;(function c(node, st, override) {
    visitor[override || node.type](node, st, c);
  })(node, state, override);
}

function makeTest(test) {
  if (typeof test === "string")
    { return function (type) { return type === test; } }
  else if (!test)
    { return function () { return true; } }
  else
    { return test }
}

var Found = function Found(node, state) { this.node = node; this.state = state; };

// A full walk triggers the callback on each node
function full(node, callback, baseVisitor, state, override) {
  if (!baseVisitor) { baseVisitor = base; }
  var last
  ;(function c(node, st, override) {
    var type = override || node.type;
    baseVisitor[type](node, st, c);
    if (last !== node) {
      callback(node, st, type);
      last = node;
    }
  })(node, state, override);
}

// An fullAncestor walk is like an ancestor walk, but triggers
// the callback on each node
function fullAncestor(node, callback, baseVisitor, state) {
  if (!baseVisitor) { baseVisitor = base; }
  var ancestors = [], last
  ;(function c(node, st, override) {
    var type = override || node.type;
    var isNew = node !== ancestors[ancestors.length - 1];
    if (isNew) { ancestors.push(node); }
    baseVisitor[type](node, st, c);
    if (last !== node) {
      callback(node, st || ancestors, ancestors, type);
      last = node;
    }
    if (isNew) { ancestors.pop(); }
  })(node, state);
}

// Find a node with a given start, end, and type (all are optional,
// null can be used as wildcard). Returns a {node, state} object, or
// undefined when it doesn't find a matching node.
function findNodeAt(node, start, end, test, baseVisitor, state) {
  if (!baseVisitor) { baseVisitor = base; }
  test = makeTest(test);
  try {
    (function c(node, st, override) {
      var type = override || node.type;
      if ((start == null || node.start <= start) &&
          (end == null || node.end >= end))
        { baseVisitor[type](node, st, c); }
      if ((start == null || node.start === start) &&
          (end == null || node.end === end) &&
          test(type, node))
        { throw new Found(node, st) }
    })(node, state);
  } catch (e) {
    if (e instanceof Found) { return e }
    throw e
  }
}

// Find the innermost node of a given type that contains the given
// position. Interface similar to findNodeAt.
function findNodeAround(node, pos, test, baseVisitor, state) {
  test = makeTest(test);
  if (!baseVisitor) { baseVisitor = base; }
  try {
    (function c(node, st, override) {
      var type = override || node.type;
      if (node.start > pos || node.end < pos) { return }
      baseVisitor[type](node, st, c);
      if (test(type, node)) { throw new Found(node, st) }
    })(node, state);
  } catch (e) {
    if (e instanceof Found) { return e }
    throw e
  }
}

// Find the outermost matching node after a given position.
function findNodeAfter(node, pos, test, baseVisitor, state) {
  test = makeTest(test);
  if (!baseVisitor) { baseVisitor = base; }
  try {
    (function c(node, st, override) {
      if (node.end < pos) { return }
      var type = override || node.type;
      if (node.start >= pos && test(type, node)) { throw new Found(node, st) }
      baseVisitor[type](node, st, c);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) { return e }
    throw e
  }
}

// Find the outermost matching node before a given position.
function findNodeBefore(node, pos, test, baseVisitor, state) {
  test = makeTest(test);
  if (!baseVisitor) { baseVisitor = base; }
  var max
  ;(function c(node, st, override) {
    if (node.start > pos) { return }
    var type = override || node.type;
    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))
      { max = new Found(node, st); }
    baseVisitor[type](node, st, c);
  })(node, state);
  return max
}

// Used to create a custom walker. Will fill in all missing node
// type properties with the defaults.
function make(funcs, baseVisitor) {
  var visitor = Object.create(baseVisitor || base);
  for (var type in funcs) { visitor[type] = funcs[type]; }
  return visitor
}

function skipThrough(node, st, c) { c(node, st); }
function ignore(_node, _st, _c) {}

// Node walkers.

var base = {};

base.Program = base.BlockStatement = base.StaticBlock = function (node, st, c) {
  for (var i = 0, list = node.body; i < list.length; i += 1)
    {
    var stmt = list[i];

    c(stmt, st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression =
  function (node, st, c) { return c(node.expression, st, "Expression"); };
base.IfStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Statement");
  if (node.alternate) { c(node.alternate, st, "Statement"); }
};
base.LabeledStatement = function (node, st, c) { return c(node.body, st, "Statement"); };
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function (node, st, c) {
  c(node.object, st, "Expression");
  c(node.body, st, "Statement");
};
base.SwitchStatement = function (node, st, c) {
  c(node.discriminant, st, "Expression");
  for (var i = 0, list = node.cases; i < list.length; i += 1) {
    var cs = list[i];

    c(cs, st);
  }
};
base.SwitchCase = function (node, st, c) {
  if (node.test) { c(node.test, st, "Expression"); }
  for (var i = 0, list = node.consequent; i < list.length; i += 1)
    {
    var cons = list[i];

    c(cons, st, "Statement");
  }
};
base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {
  if (node.argument) { c(node.argument, st, "Expression"); }
};
base.ThrowStatement = base.SpreadElement =
  function (node, st, c) { return c(node.argument, st, "Expression"); };
base.TryStatement = function (node, st, c) {
  c(node.block, st, "Statement");
  if (node.handler) { c(node.handler, st); }
  if (node.finalizer) { c(node.finalizer, st, "Statement"); }
};
base.CatchClause = function (node, st, c) {
  if (node.param) { c(node.param, st, "Pattern"); }
  c(node.body, st, "Statement");
};
base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForStatement = function (node, st, c) {
  if (node.init) { c(node.init, st, "ForInit"); }
  if (node.test) { c(node.test, st, "Expression"); }
  if (node.update) { c(node.update, st, "Expression"); }
  c(node.body, st, "Statement");
};
base.ForInStatement = base.ForOfStatement = function (node, st, c) {
  c(node.left, st, "ForInit");
  c(node.right, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForInit = function (node, st, c) {
  if (node.type === "VariableDeclaration") { c(node, st); }
  else { c(node, st, "Expression"); }
};
base.DebuggerStatement = ignore;

base.FunctionDeclaration = function (node, st, c) { return c(node, st, "Function"); };
base.VariableDeclaration = function (node, st, c) {
  for (var i = 0, list = node.declarations; i < list.length; i += 1)
    {
    var decl = list[i];

    c(decl, st);
  }
};
base.VariableDeclarator = function (node, st, c) {
  c(node.id, st, "Pattern");
  if (node.init) { c(node.init, st, "Expression"); }
};

base.Function = function (node, st, c) {
  if (node.id) { c(node.id, st, "Pattern"); }
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    c(param, st, "Pattern");
  }
  c(node.body, st, node.expression ? "Expression" : "Statement");
};

base.Pattern = function (node, st, c) {
  if (node.type === "Identifier")
    { c(node, st, "VariablePattern"); }
  else if (node.type === "MemberExpression")
    { c(node, st, "MemberPattern"); }
  else
    { c(node, st); }
};
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
base.RestElement = function (node, st, c) { return c(node.argument, st, "Pattern"); };
base.ArrayPattern = function (node, st, c) {
  for (var i = 0, list = node.elements; i < list.length; i += 1) {
    var elt = list[i];

    if (elt) { c(elt, st, "Pattern"); }
  }
};
base.ObjectPattern = function (node, st, c) {
  for (var i = 0, list = node.properties; i < list.length; i += 1) {
    var prop = list[i];

    if (prop.type === "Property") {
      if (prop.computed) { c(prop.key, st, "Expression"); }
      c(prop.value, st, "Pattern");
    } else if (prop.type === "RestElement") {
      c(prop.argument, st, "Pattern");
    }
  }
};

base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = function (node, st, c) {
  for (var i = 0, list = node.elements; i < list.length; i += 1) {
    var elt = list[i];

    if (elt) { c(elt, st, "Expression"); }
  }
};
base.ObjectExpression = function (node, st, c) {
  for (var i = 0, list = node.properties; i < list.length; i += 1)
    {
    var prop = list[i];

    c(prop, st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = function (node, st, c) {
  for (var i = 0, list = node.expressions; i < list.length; i += 1)
    {
    var expr = list[i];

    c(expr, st, "Expression");
  }
};
base.TemplateLiteral = function (node, st, c) {
  for (var i = 0, list = node.quasis; i < list.length; i += 1)
    {
    var quasi = list[i];

    c(quasi, st);
  }

  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)
    {
    var expr = list$1[i$1];

    c(expr, st, "Expression");
  }
};
base.TemplateElement = ignore;
base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
  c(node.argument, st, "Expression");
};
base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
  c(node.left, st, "Expression");
  c(node.right, st, "Expression");
};
base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
  c(node.left, st, "Pattern");
  c(node.right, st, "Expression");
};
base.ConditionalExpression = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Expression");
  c(node.alternate, st, "Expression");
};
base.NewExpression = base.CallExpression = function (node, st, c) {
  c(node.callee, st, "Expression");
  if (node.arguments)
    { for (var i = 0, list = node.arguments; i < list.length; i += 1)
      {
        var arg = list[i];

        c(arg, st, "Expression");
      } }
};
base.MemberExpression = function (node, st, c) {
  c(node.object, st, "Expression");
  if (node.computed) { c(node.property, st, "Expression"); }
};
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
  if (node.declaration)
    { c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression"); }
  if (node.source) { c(node.source, st, "Expression"); }
};
base.ExportAllDeclaration = function (node, st, c) {
  if (node.exported)
    { c(node.exported, st); }
  c(node.source, st, "Expression");
};
base.ImportDeclaration = function (node, st, c) {
  for (var i = 0, list = node.specifiers; i < list.length; i += 1)
    {
    var spec = list[i];

    c(spec, st);
  }
  c(node.source, st, "Expression");
};
base.ImportExpression = function (node, st, c) {
  c(node.source, st, "Expression");
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;

base.TaggedTemplateExpression = function (node, st, c) {
  c(node.tag, st, "Expression");
  c(node.quasi, st, "Expression");
};
base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, "Class"); };
base.Class = function (node, st, c) {
  if (node.id) { c(node.id, st, "Pattern"); }
  if (node.superClass) { c(node.superClass, st, "Expression"); }
  c(node.body, st);
};
base.ClassBody = function (node, st, c) {
  for (var i = 0, list = node.body; i < list.length; i += 1)
    {
    var elt = list[i];

    c(elt, st);
  }
};
base.MethodDefinition = base.PropertyDefinition = base.Property = function (node, st, c) {
  if (node.computed) { c(node.key, st, "Expression"); }
  if (node.value) { c(node.value, st, "Expression"); }
};

export { ancestor, base, findNodeAfter, findNodeAround, findNodeAt, findNodeBefore, full, fullAncestor, make, recursive, simple };
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/acorn/acorn-walk/package.json                                                      0000664 0000000 0000000 00000002062 14746647661 0021136 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  "name": "acorn-walk",
  "description": "ECMAScript (ESTree) AST walker",
  "homepage": "https://github.com/acornjs/acorn",
  "main": "dist/walk.js",
  "types": "dist/walk.d.ts",
  "module": "dist/walk.mjs",
  "exports": {
    ".": [
      {
        "import": "./dist/walk.mjs",
        "require": "./dist/walk.js",
        "default": "./dist/walk.js"
      },
      "./dist/walk.js"
    ],
    "./package.json": "./package.json"
  },
  "version": "8.3.4",
  "engines": {
    "node": ">=0.4.0"
  },
  "dependencies": {
    "acorn": "^8.11.0"
  },
  "maintainers": [
    {
      "name": "Marijn Haverbeke",
      "email": "marijnh@gmail.com",
      "web": "https://marijnhaverbeke.nl"
    },
    {
      "name": "Ingvar Stepanyan",
      "email": "me@rreverser.com",
      "web": "https://rreverser.com/"
    },
    {
      "name": "Adrian Heine",
      "web": "http://adrianheine.de"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/acornjs/acorn.git"
  },
  "scripts": {
    "prepare": "cd ..; npm run build:walk"
  },
  "license": "MIT"
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/acorn/acorn/                                                                       0000775 0000000 0000000 00000000000 14746647661 0015714 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/acorn/acorn/CHANGELOG.md                                                           0000664 0000000 0000000 00000053747 14746647661 0017545 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ## 8.14.0 (2024-10-27)

### New features

Support ES2025 import attributes.

Support ES2025 RegExp modifiers.

### Bug fixes

Support some missing Unicode properties.

## 8.13.0 (2024-10-16)

### New features

Upgrade to Unicode 16.0.

## 8.12.1 (2024-07-03)

### Bug fixes

Fix a regression that caused Acorn to no longer run on Node versions <8.10.

## 8.12.0 (2024-06-14)

### New features

Support ES2025 duplicate capture group names in regular expressions.

### Bug fixes

Include `VariableDeclarator` in the `AnyNode` type so that walker objects can refer to it without getting a type error.

Properly raise a parse error for invalid `for`/`of` statements using `async` as binding name.

Properly recognize \"use strict\" when preceded by a string with an escaped newline.

Mark the `Parser` constructor as protected, not private, so plugins can extend it without type errors.

Fix a bug where some invalid `delete` expressions were let through when the operand was parenthesized and `preserveParens` was enabled.

Properly normalize line endings in raw strings of invalid template tokens.

Properly track line numbers for escaped newlines in strings.

Fix a bug that broke line number accounting after a template literal with invalid escape sequences.

## 8.11.3 (2023-12-29)

### Bug fixes

Add `Function` and `Class` to the `AggregateType` type, so that they can be used in walkers without raising a type error.

Make sure `onToken` get an `import` keyword token when parsing `import.meta`.

Fix a bug where `.loc.start` could be undefined for `new.target` `meta` nodes.

## 8.11.2 (2023-10-27)

### Bug fixes

Fix a bug that caused regular expressions after colon tokens to not be properly tokenized in some circumstances.

## 8.11.1 (2023-10-26)

### Bug fixes

Fix a regression where `onToken` would receive 'name' tokens for 'new' keyword tokens.

## 8.11.0 (2023-10-26)

### Bug fixes

Fix an issue where tokenizing (without parsing) an object literal with a property named `class` or `function` could, in some circumstance, put the tokenizer into an invalid state.

Fix an issue where a slash after a call to a propery named the same as some keywords would be tokenized as a regular expression.

### New features

Upgrade to Unicode 15.1.

Use a set of new, much more precise, TypeScript types.

## 8.10.0 (2023-07-05)

### New features

Add a `checkPrivateFields` option that disables strict checking of private property use.

## 8.9.0 (2023-06-16)

### Bug fixes

Forbid dynamic import after `new`, even when part of a member expression.

### New features

Add Unicode properties for ES2023.

Add support for the `v` flag to regular expressions.

## 8.8.2 (2023-01-23)

### Bug fixes

Fix a bug that caused `allowHashBang` to be set to false when not provided, even with `ecmaVersion >= 14`.

Fix an exception when passing no option object to `parse` or `new Parser`.

Fix incorrect parse error on `if (0) let\n[astral identifier char]`.

## 8.8.1 (2022-10-24)

### Bug fixes

Make type for `Comment` compatible with estree types.

## 8.8.0 (2022-07-21)

### Bug fixes

Allow parentheses around spread args in destructuring object assignment.

Fix an issue where the tree contained `directive` properties in when parsing with a language version that doesn't support them.

### New features

Support hashbang comments by default in ECMAScript 2023 and later.

## 8.7.1 (2021-04-26)

### Bug fixes

Stop handling `"use strict"` directives in ECMAScript versions before 5.

Fix an issue where duplicate quoted export names in `export *` syntax were incorrectly checked.

Add missing type for `tokTypes`.

## 8.7.0 (2021-12-27)

### New features

Support quoted export names.

Upgrade to Unicode 14.

Add support for Unicode 13 properties in regular expressions.

### Bug fixes

Use a loop to find line breaks, because the existing regexp search would overrun the end of the searched range and waste a lot of time in minified code.

## 8.6.0 (2021-11-18)

### Bug fixes

Fix a bug where an object literal with multiple `__proto__` properties would incorrectly be accepted if a later property value held an assigment.

### New features

Support class private fields with the `in` operator.

## 8.5.0 (2021-09-06)

### Bug fixes

Improve context-dependent tokenization in a number of corner cases.

Fix location tracking after a 0x2028 or 0x2029 character in a string literal (which before did not increase the line number).

Fix an issue where arrow function bodies in for loop context would inappropriately consume `in` operators.

Fix wrong end locations stored on SequenceExpression nodes.

Implement restriction that `for`/`of` loop LHS can't start with `let`.

### New features

Add support for ES2022 class static blocks.

Allow multiple input files to be passed to the CLI tool.

## 8.4.1 (2021-06-24)

### Bug fixes

Fix a bug where `allowAwaitOutsideFunction` would allow `await` in class field initializers, and setting `ecmaVersion` to 13 or higher would allow top-level await in non-module sources.

## 8.4.0 (2021-06-11)

### New features

A new option, `allowSuperOutsideMethod`, can be used to suppress the error when `super` is used in the wrong context.

## 8.3.0 (2021-05-31)

### New features

Default `allowAwaitOutsideFunction` to true for ECMAScript 2022 an higher.

Add support for the `d` ([indices](https://github.com/tc39/proposal-regexp-match-indices)) regexp flag.

## 8.2.4 (2021-05-04)

### Bug fixes

Fix spec conformity in corner case 'for await (async of ...)'.

## 8.2.3 (2021-05-04)

### Bug fixes

Fix an issue where the library couldn't parse 'for (async of ...)'.

Fix a bug in UTF-16 decoding that would read characters incorrectly in some circumstances.

## 8.2.2 (2021-04-29)

### Bug fixes

Fix a bug where a class field initialized to an async arrow function wouldn't allow await inside it. Same issue existed for generator arrow functions with yield.

## 8.2.1 (2021-04-24)

### Bug fixes

Fix a regression introduced in 8.2.0 where static or async class methods with keyword names fail to parse.

## 8.2.0 (2021-04-24)

### New features

Add support for ES2022 class fields and private methods.

## 8.1.1 (2021-04-12)

### Various

Stop shipping source maps in the NPM package.

## 8.1.0 (2021-03-09)

### Bug fixes

Fix a spurious error in nested destructuring arrays.

### New features

Expose `allowAwaitOutsideFunction` in CLI interface.

Make `allowImportExportAnywhere` also apply to `import.meta`.

## 8.0.5 (2021-01-25)

### Bug fixes

Adjust package.json to work with Node 12.16.0 and 13.0-13.6.

## 8.0.4 (2020-10-05)

### Bug fixes

Make `await x ** y` an error, following the spec.

Fix potentially exponential regular expression.

## 8.0.3 (2020-10-02)

### Bug fixes

Fix a wasteful loop during `Parser` creation when setting `ecmaVersion` to `"latest"`.

## 8.0.2 (2020-09-30)

### Bug fixes

Make the TypeScript types reflect the current allowed values for `ecmaVersion`.

Fix another regexp/division tokenizer issue.

## 8.0.1 (2020-08-12)

### Bug fixes

Provide the correct value in the `version` export.

## 8.0.0 (2020-08-12)

### Bug fixes

Disallow expressions like `(a = b) = c`.

Make non-octal escape sequences a syntax error in strict mode.

### New features

The package can now be loaded directly as an ECMAScript module in node 13+.

Update to the set of Unicode properties from ES2021.

### Breaking changes

The `ecmaVersion` option is now required. For the moment, omitting it will still work with a warning, but that will change in a future release.

Some changes to method signatures that may be used by plugins.

## 7.4.0 (2020-08-03)

### New features

Add support for logical assignment operators.

Add support for numeric separators.

## 7.3.1 (2020-06-11)

### Bug fixes

Make the string in the `version` export match the actual library version.

## 7.3.0 (2020-06-11)

### Bug fixes

Fix a bug that caused parsing of object patterns with a property named `set` that had a default value to fail.

### New features

Add support for optional chaining (`?.`).

## 7.2.0 (2020-05-09)

### Bug fixes

Fix precedence issue in parsing of async arrow functions.

### New features

Add support for nullish coalescing.

Add support for `import.meta`.

Support `export * as ...` syntax.

Upgrade to Unicode 13.

## 6.4.1 (2020-03-09)

### Bug fixes

More carefully check for valid UTF16 surrogate pairs in regexp validator.

## 7.1.1 (2020-03-01)

### Bug fixes

Treat `\8` and `\9` as invalid escapes in template strings.

Allow unicode escapes in property names that are keywords.

Don't error on an exponential operator expression as argument to `await`.

More carefully check for valid UTF16 surrogate pairs in regexp validator.

## 7.1.0 (2019-09-24)

### Bug fixes

Disallow trailing object literal commas when ecmaVersion is less than 5.

### New features

Add a static `acorn` property to the `Parser` class that contains the entire module interface, to allow plugins to access the instance of the library that they are acting on.

## 7.0.0 (2019-08-13)

### Breaking changes

Changes the node format for dynamic imports to use the `ImportExpression` node type, as defined in [ESTree](https://github.com/estree/estree/blob/master/es2020.md#importexpression).

Makes 10 (ES2019) the default value for the `ecmaVersion` option.

## 6.3.0 (2019-08-12)

### New features

`sourceType: "module"` can now be used even when `ecmaVersion` is less than 6, to parse module-style code that otherwise conforms to an older standard.

## 6.2.1 (2019-07-21)

### Bug fixes

Fix bug causing Acorn to treat some characters as identifier characters that shouldn't be treated as such.

Fix issue where setting the `allowReserved` option to `"never"` allowed reserved words in some circumstances.

## 6.2.0 (2019-07-04)

### Bug fixes

Improve valid assignment checking in `for`/`in` and `for`/`of` loops.

Disallow binding `let` in patterns.

### New features

Support bigint syntax with `ecmaVersion` >= 11.

Support dynamic `import` syntax with `ecmaVersion` >= 11.

Upgrade to Unicode version 12.

## 6.1.1 (2019-02-27)

### Bug fixes

Fix bug that caused parsing default exports of with names to fail.

## 6.1.0 (2019-02-08)

### Bug fixes

Fix scope checking when redefining a `var` as a lexical binding.

### New features

Split up `parseSubscripts` to use an internal `parseSubscript` method to make it easier to extend with plugins.

## 6.0.7 (2019-02-04)

### Bug fixes

Check that exported bindings are defined.

Don't treat `\u180e` as a whitespace character.

Check for duplicate parameter names in methods.

Don't allow shorthand properties when they are generators or async methods.

Forbid binding `await` in async arrow function's parameter list.

## 6.0.6 (2019-01-30)

### Bug fixes

The content of class declarations and expressions is now always parsed in strict mode.

Don't allow `let` or `const` to bind the variable name `let`.

Treat class declarations as lexical.

Don't allow a generator function declaration as the sole body of an `if` or `else`.

Ignore `"use strict"` when after an empty statement.

Allow string line continuations with special line terminator characters.

Treat `for` bodies as part of the `for` scope when checking for conflicting bindings.

Fix bug with parsing `yield` in a `for` loop initializer.

Implement special cases around scope checking for functions.

## 6.0.5 (2019-01-02)

### Bug fixes

Fix TypeScript type for `Parser.extend` and add `allowAwaitOutsideFunction` to options type.

Don't treat `let` as a keyword when the next token is `{` on the next line.

Fix bug that broke checking for parentheses around an object pattern in a destructuring assignment when `preserveParens` was on.

## 6.0.4 (2018-11-05)

### Bug fixes

Further improvements to tokenizing regular expressions in corner cases.

## 6.0.3 (2018-11-04)

### Bug fixes

Fix bug in tokenizing an expression-less return followed by a function followed by a regular expression.

Remove stray symlink in the package tarball.

## 6.0.2 (2018-09-26)

### Bug fixes

Fix bug where default expressions could fail to parse inside an object destructuring assignment expression.

## 6.0.1 (2018-09-14)

### Bug fixes

Fix wrong value in `version` export.

## 6.0.0 (2018-09-14)

### Bug fixes

Better handle variable-redefinition checks for catch bindings and functions directly under if statements.

Forbid `new.target` in top-level arrow functions.

Fix issue with parsing a regexp after `yield` in some contexts.

### New features

The package now comes with TypeScript definitions.

### Breaking changes

The default value of the `ecmaVersion` option is now 9 (2018).

Plugins work differently, and will have to be rewritten to work with this version.

The loose parser and walker have been moved into separate packages (`acorn-loose` and `acorn-walk`).

## 5.7.3 (2018-09-10)

### Bug fixes

Fix failure to tokenize regexps after expressions like `x.of`.

Better error message for unterminated template literals.

## 5.7.2 (2018-08-24)

### Bug fixes

Properly handle `allowAwaitOutsideFunction` in for statements.

Treat function declarations at the top level of modules like let bindings.

Don't allow async function declarations as the only statement under a label.

## 5.7.0 (2018-06-15)

### New features

Upgraded to Unicode 11.

## 5.6.0 (2018-05-31)

### New features

Allow U+2028 and U+2029 in string when ECMAVersion >= 10.

Allow binding-less catch statements when ECMAVersion >= 10.

Add `allowAwaitOutsideFunction` option for parsing top-level `await`.

## 5.5.3 (2018-03-08)

### Bug fixes

A _second_ republish of the code in 5.5.1, this time with yarn, to hopefully get valid timestamps.

## 5.5.2 (2018-03-08)

### Bug fixes

A republish of the code in 5.5.1 in an attempt to solve an issue with the file timestamps in the npm package being 0.

## 5.5.1 (2018-03-06)

### Bug fixes

Fix misleading error message for octal escapes in template strings.

## 5.5.0 (2018-02-27)

### New features

The identifier character categorization is now based on Unicode version 10.

Acorn will now validate the content of regular expressions, including new ES9 features.

## 5.4.0 (2018-02-01)

### Bug fixes

Disallow duplicate or escaped flags on regular expressions.

Disallow octal escapes in strings in strict mode.

### New features

Add support for async iteration.

Add support for object spread and rest.

## 5.3.0 (2017-12-28)

### Bug fixes

Fix parsing of floating point literals with leading zeroes in loose mode.

Allow duplicate property names in object patterns.

Don't allow static class methods named `prototype`.

Disallow async functions directly under `if` or `else`.

Parse right-hand-side of `for`/`of` as an assignment expression.

Stricter parsing of `for`/`in`.

Don't allow unicode escapes in contextual keywords.

### New features

Parsing class members was factored into smaller methods to allow plugins to hook into it.

## 5.2.1 (2017-10-30)

### Bug fixes

Fix a token context corruption bug.

## 5.2.0 (2017-10-30)

### Bug fixes

Fix token context tracking for `class` and `function` in property-name position.

Make sure `%*` isn't parsed as a valid operator.

Allow shorthand properties `get` and `set` to be followed by default values.

Disallow `super` when not in callee or object position.

### New features

Support [`directive` property](https://github.com/estree/estree/compare/b3de58c9997504d6fba04b72f76e6dd1619ee4eb...1da8e603237144f44710360f8feb7a9977e905e0) on directive expression statements.

## 5.1.2 (2017-09-04)

### Bug fixes

Disable parsing of legacy HTML-style comments in modules.

Fix parsing of async methods whose names are keywords.

## 5.1.1 (2017-07-06)

### Bug fixes

Fix problem with disambiguating regexp and division after a class.

## 5.1.0 (2017-07-05)

### Bug fixes

Fix tokenizing of regexps in an object-desctructuring `for`/`of` loop and after `yield`.

Parse zero-prefixed numbers with non-octal digits as decimal.

Allow object/array patterns in rest parameters.

Don't error when `yield` is used as a property name.

Allow `async` as a shorthand object property.

### New features

Implement the [template literal revision proposal](https://github.com/tc39/proposal-template-literal-revision) for ES9.

## 5.0.3 (2017-04-01)

### Bug fixes

Fix spurious duplicate variable definition errors for named functions.

## 5.0.2 (2017-03-30)

### Bug fixes

A binary operator after a parenthesized arrow expression is no longer incorrectly treated as an error.

## 5.0.0 (2017-03-28)

### Bug fixes

Raise an error for duplicated lexical bindings.

Fix spurious error when an assignement expression occurred after a spread expression.

Accept regular expressions after `of` (in `for`/`of`), `yield` (in a generator), and braced arrow functions.

Allow labels in front or `var` declarations, even in strict mode.

### Breaking changes

Parse declarations following `export default` as declaration nodes, not expressions. This means that class and function declarations nodes can now have `null` as their `id`.

## 4.0.11 (2017-02-07)

### Bug fixes

Allow all forms of member expressions to be parenthesized as lvalue.

## 4.0.10 (2017-02-07)

### Bug fixes

Don't expect semicolons after default-exported functions or classes, even when they are expressions.

Check for use of `'use strict'` directives in non-simple parameter functions, even when already in strict mode.

## 4.0.9 (2017-02-06)

### Bug fixes

Fix incorrect error raised for parenthesized simple assignment targets, so that `(x) = 1` parses again.

## 4.0.8 (2017-02-03)

### Bug fixes

Solve spurious parenthesized pattern errors by temporarily erring on the side of accepting programs that our delayed errors don't handle correctly yet.

## 4.0.7 (2017-02-02)

### Bug fixes

Accept invalidly rejected code like `(x).y = 2` again.

Don't raise an error when a function _inside_ strict code has a non-simple parameter list.

## 4.0.6 (2017-02-02)

### Bug fixes

Fix exponential behavior (manifesting itself as a complete hang for even relatively small source files) introduced by the new 'use strict' check.

## 4.0.5 (2017-02-02)

### Bug fixes

Disallow parenthesized pattern expressions.

Allow keywords as export names.

Don't allow the `async` keyword to be parenthesized.

Properly raise an error when a keyword contains a character escape.

Allow `"use strict"` to appear after other string literal expressions.

Disallow labeled declarations.

## 4.0.4 (2016-12-19)

### Bug fixes

Fix crash when `export` was followed by a keyword that can't be
exported.

## 4.0.3 (2016-08-16)

### Bug fixes

Allow regular function declarations inside single-statement `if` branches in loose mode. Forbid them entirely in strict mode.

Properly parse properties named `async` in ES2017 mode.

Fix bug where reserved words were broken in ES2017 mode.

## 4.0.2 (2016-08-11)

### Bug fixes

Don't ignore period or 'e' characters after octal numbers.

Fix broken parsing for call expressions in default parameter values of arrow functions.

## 4.0.1 (2016-08-08)

### Bug fixes

Fix false positives in duplicated export name errors.

## 4.0.0 (2016-08-07)

### Breaking changes

The default `ecmaVersion` option value is now 7.

A number of internal method signatures changed, so plugins might need to be updated.

### Bug fixes

The parser now raises errors on duplicated export names.

`arguments` and `eval` can now be used in shorthand properties.

Duplicate parameter names in non-simple argument lists now always produce an error.

### New features

The `ecmaVersion` option now also accepts year-style version numbers
(2015, etc).

Support for `async`/`await` syntax when `ecmaVersion` is >= 8.

Support for trailing commas in call expressions when `ecmaVersion` is >= 8.

## 3.3.0 (2016-07-25)

### Bug fixes

Fix bug in tokenizing of regexp operator after a function declaration.

Fix parser crash when parsing an array pattern with a hole.

### New features

Implement check against complex argument lists in functions that enable strict mode in ES7.

## 3.2.0 (2016-06-07)

### Bug fixes

Improve handling of lack of unicode regexp support in host
environment.

Properly reject shorthand properties whose name is a keyword.

### New features

Visitors created with `visit.make` now have their base as _prototype_, rather than copying properties into a fresh object.

## 3.1.0 (2016-04-18)

### Bug fixes

Properly tokenize the division operator directly after a function expression.

Allow trailing comma in destructuring arrays.

## 3.0.4 (2016-02-25)

### Fixes

Allow update expressions as left-hand-side of the ES7 exponential operator.

## 3.0.2 (2016-02-10)

### Fixes

Fix bug that accidentally made `undefined` a reserved word when parsing ES7.

## 3.0.0 (2016-02-10)

### Breaking changes

The default value of the `ecmaVersion` option is now 6 (used to be 5).

Support for comprehension syntax (which was dropped from the draft spec) has been removed.

### Fixes

`let` and `yield` are now “contextual keywords”, meaning you can mostly use them as identifiers in ES5 non-strict code.

A parenthesized class or function expression after `export default` is now parsed correctly.

### New features

When `ecmaVersion` is set to 7, Acorn will parse the exponentiation operator (`**`).

The identifier character ranges are now based on Unicode 8.0.0.

Plugins can now override the `raiseRecoverable` method to override the way non-critical errors are handled.

## 2.7.0 (2016-01-04)

### Fixes

Stop allowing rest parameters in setters.

Disallow `y` rexexp flag in ES5.

Disallow `\00` and `\000` escapes in strict mode.

Raise an error when an import name is a reserved word.

## 2.6.2 (2015-11-10)

### Fixes

Don't crash when no options object is passed.

## 2.6.0 (2015-11-09)

### Fixes

Add `await` as a reserved word in module sources.

Disallow `yield` in a parameter default value for a generator.

Forbid using a comma after a rest pattern in an array destructuring.

### New features

Support parsing stdin in command-line tool.

## 2.5.0 (2015-10-27)

### Fixes

Fix tokenizer support in the command-line tool.

Stop allowing `new.target` outside of functions.

Remove legacy `guard` and `guardedHandler` properties from try nodes.

Stop allowing multiple `__proto__` properties on an object literal in strict mode.

Don't allow rest parameters to be non-identifier patterns.

Check for duplicate paramter names in arrow functions.
                         node-23.7.0/deps/acorn/acorn/LICENSE                                                                0000664 0000000 0000000 00000002113 14746647661 0016716 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        MIT License

Copyright (C) 2012-2022 by various contributors (see AUTHORS)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/acorn/acorn/README.md                                                              0000664 0000000 0000000 00000025057 14746647661 0017204 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Acorn

A tiny, fast JavaScript parser written in JavaScript.

## Community

Acorn is open source software released under an
[MIT license](https://github.com/acornjs/acorn/blob/master/acorn/LICENSE).

You are welcome to
[report bugs](https://github.com/acornjs/acorn/issues) or create pull
requests on [github](https://github.com/acornjs/acorn).

## Installation

The easiest way to install acorn is from [`npm`](https://www.npmjs.com/):

```sh
npm install acorn
```

Alternately, you can download the source and build acorn yourself:

```sh
git clone https://github.com/acornjs/acorn.git
cd acorn
npm install
```

## Interface

**parse**`(input, options)` is the main interface to the library. The
`input` parameter is a string, `options` must be an object setting
some of the options listed below. The return value will be an abstract
syntax tree object as specified by the [ESTree
spec](https://github.com/estree/estree).

```javascript
let acorn = require("acorn");
console.log(acorn.parse("1 + 1", {ecmaVersion: 2020}));
```

When encountering a syntax error, the parser will raise a
`SyntaxError` object with a meaningful message. The error object will
have a `pos` property that indicates the string offset at which the
error occurred, and a `loc` object that contains a `{line, column}`
object referring to that same position.

Options are provided by in a second argument, which should be an
object containing any of these fields (only `ecmaVersion` is
required):

- **ecmaVersion**: Indicates the ECMAScript version to parse. Can be a
  number, either in year (`2022`) or plain version number (`6`) form,
  or `"latest"` (the latest the library supports). This influences
  support for strict mode, the set of reserved words, and support for
  new syntax features.

  **NOTE**: Only 'stage 4' (finalized) ECMAScript features are being
  implemented by Acorn. Other proposed new features must be
  implemented through plugins.

- **sourceType**: Indicate the mode the code should be parsed in. Can be
  either `"script"` or `"module"`. This influences global strict mode
  and parsing of `import` and `export` declarations.

  **NOTE**: If set to `"module"`, then static `import` / `export` syntax
  will be valid, even if `ecmaVersion` is less than 6.

- **onInsertedSemicolon**: If given a callback, that callback will be
  called whenever a missing semicolon is inserted by the parser. The
  callback will be given the character offset of the point where the
  semicolon is inserted as argument, and if `locations` is on, also a
  `{line, column}` object representing this position.

- **onTrailingComma**: Like `onInsertedSemicolon`, but for trailing
  commas.

- **allowReserved**: If `false`, using a reserved word will generate
  an error. Defaults to `true` for `ecmaVersion` 3, `false` for higher
  versions. When given the value `"never"`, reserved words and
  keywords can also not be used as property names (as in Internet
  Explorer's old parser).

- **allowReturnOutsideFunction**: By default, a return statement at
  the top level raises an error. Set this to `true` to accept such
  code.

- **allowImportExportEverywhere**: By default, `import` and `export`
  declarations can only appear at a program's top level. Setting this
  option to `true` allows them anywhere where a statement is allowed,
  and also allows `import.meta` expressions to appear in scripts
  (when `sourceType` is not `"module"`).

- **allowAwaitOutsideFunction**: If `false`, `await` expressions can
  only appear inside `async` functions. Defaults to `true` in modules
  for `ecmaVersion` 2022 and later, `false` for lower versions.
  Setting this option to `true` allows to have top-level `await`
  expressions. They are still not allowed in non-`async` functions,
  though.

- **allowSuperOutsideMethod**: By default, `super` outside a method
  raises an error. Set this to `true` to accept such code.

- **allowHashBang**: When this is enabled, if the code starts with the
  characters `#!` (as in a shellscript), the first line will be
  treated as a comment. Defaults to true when `ecmaVersion` >= 2023.

- **checkPrivateFields**: By default, the parser will verify that
  private properties are only used in places where they are valid and
  have been declared. Set this to false to turn such checks off.

- **locations**: When `true`, each node has a `loc` object attached
  with `start` and `end` subobjects, each of which contains the
  one-based line and zero-based column numbers in `{line, column}`
  form. Default is `false`.

- **onToken**: If a function is passed for this option, each found
  token will be passed in same format as tokens returned from
  `tokenizer().getToken()`.

  If array is passed, each found token is pushed to it.

  Note that you are not allowed to call the parser from the
  callback—that will corrupt its internal state.

- **onComment**: If a function is passed for this option, whenever a
  comment is encountered the function will be called with the
  following parameters:

  - `block`: `true` if the comment is a block comment, false if it
    is a line comment.
  - `text`: The content of the comment.
  - `start`: Character offset of the start of the comment.
  - `end`: Character offset of the end of the comment.

  When the `locations` options is on, the `{line, column}` locations
  of the comment’s start and end are passed as two additional
  parameters.

  If array is passed for this option, each found comment is pushed
  to it as object in Esprima format:

  ```javascript
  {
    "type": "Line" | "Block",
    "value": "comment text",
    "start": Number,
    "end": Number,
    // If `locations` option is on:
    "loc": {
      "start": {line: Number, column: Number}
      "end": {line: Number, column: Number}
    },
    // If `ranges` option is on:
    "range": [Number, Number]
  }
  ```

  Note that you are not allowed to call the parser from the
  callback—that will corrupt its internal state.

- **ranges**: Nodes have their start and end characters offsets
  recorded in `start` and `end` properties (directly on the node,
  rather than the `loc` object, which holds line/column data. To also
  add a
  [semi-standardized](https://bugzilla.mozilla.org/show_bug.cgi?id=745678)
  `range` property holding a `[start, end]` array with the same
  numbers, set the `ranges` option to `true`.

- **program**: It is possible to parse multiple files into a single
  AST by passing the tree produced by parsing the first file as the
  `program` option in subsequent parses. This will add the toplevel
  forms of the parsed file to the "Program" (top) node of an existing
  parse tree.

- **sourceFile**: When the `locations` option is `true`, you can pass
  this option to add a `source` attribute in every node’s `loc`
  object. Note that the contents of this option are not examined or
  processed in any way; you are free to use whatever format you
  choose.

- **directSourceFile**: Like `sourceFile`, but a `sourceFile` property
  will be added (regardless of the `location` option) directly to the
  nodes, rather than the `loc` object.

- **preserveParens**: If this option is `true`, parenthesized expressions
  are represented by (non-standard) `ParenthesizedExpression` nodes
  that have a single `expression` property containing the expression
  inside parentheses.

**parseExpressionAt**`(input, offset, options)` will parse a single
expression in a string, and return its AST. It will not complain if
there is more of the string left after the expression.

**tokenizer**`(input, options)` returns an object with a `getToken`
method that can be called repeatedly to get the next token, a `{start,
end, type, value}` object (with added `loc` property when the
`locations` option is enabled and `range` property when the `ranges`
option is enabled). When the token's type is `tokTypes.eof`, you
should stop calling the method, since it will keep returning that same
token forever.

Note that tokenizing JavaScript without parsing it is, in modern
versions of the language, not really possible due to the way syntax is
overloaded in ways that can only be disambiguated by the parse
context. This package applies a bunch of heuristics to try and do a
reasonable job, but you are advised to use `parse` with the `onToken`
option instead of this.

In ES6 environment, returned result can be used as any other
protocol-compliant iterable:

```javascript
for (let token of acorn.tokenizer(str)) {
  // iterate over the tokens
}

// transform code to array of tokens:
var tokens = [...acorn.tokenizer(str)];
```

**tokTypes** holds an object mapping names to the token type objects
that end up in the `type` properties of tokens.

**getLineInfo**`(input, offset)` can be used to get a `{line,
column}` object for a given program string and offset.

### The `Parser` class

Instances of the **`Parser`** class contain all the state and logic
that drives a parse. It has static methods `parse`,
`parseExpressionAt`, and `tokenizer` that match the top-level
functions by the same name.

When extending the parser with plugins, you need to call these methods
on the extended version of the class. To extend a parser with plugins,
you can use its static `extend` method.

```javascript
var acorn = require("acorn");
var jsx = require("acorn-jsx");
var JSXParser = acorn.Parser.extend(jsx());
JSXParser.parse("foo(<bar/>)", {ecmaVersion: 2020});
```

The `extend` method takes any number of plugin values, and returns a
new `Parser` class that includes the extra parser logic provided by
the plugins.

## Command line interface

The `bin/acorn` utility can be used to parse a file from the command
line. It accepts as arguments its input file and the following
options:

- `--ecma3|--ecma5|--ecma6|--ecma7|--ecma8|--ecma9|--ecma10`: Sets the ECMAScript version
  to parse. Default is version 9.

- `--module`: Sets the parsing mode to `"module"`. Is set to `"script"` otherwise.

- `--locations`: Attaches a "loc" object to each node with "start" and
  "end" subobjects, each of which contains the one-based line and
  zero-based column numbers in `{line, column}` form.

- `--allow-hash-bang`: If the code starts with the characters #! (as
  in a shellscript), the first line will be treated as a comment.

- `--allow-await-outside-function`: Allows top-level `await` expressions.
  See the `allowAwaitOutsideFunction` option for more information.

- `--compact`: No whitespace is used in the AST output.

- `--silent`: Do not output the AST, just return the exit status.

- `--help`: Print the usage information and quit.

The utility spits out the syntax tree as JSON data.

## Existing plugins

 - [`acorn-jsx`](https://github.com/RReverser/acorn-jsx): Parse [Facebook JSX syntax extensions](https://github.com/facebook/jsx)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/acorn/acorn/bin/                                                                   0000775 0000000 0000000 00000000000 14746647661 0016464 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/acorn/acorn/bin/acorn                                                              0000775 0000000 0000000 00000000074 14746647661 0017515 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #!/usr/bin/env node
"use strict"

require("../dist/bin.js")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/acorn/acorn/dist/                                                                  0000775 0000000 0000000 00000000000 14746647661 0016657 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/acorn/acorn/dist/acorn.d.mts                                                       0000664 0000000 0000000 00000052115 14746647661 0020734 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        export interface Node {
  start: number
  end: number
  type: string
  range?: [number, number]
  loc?: SourceLocation | null
}

export interface SourceLocation {
  source?: string | null
  start: Position
  end: Position
}

export interface Position {
  /** 1-based */
  line: number
  /** 0-based */
  column: number
}

export interface Identifier extends Node {
  type: "Identifier"
  name: string
}

export interface Literal extends Node {
  type: "Literal"
  value?: string | boolean | null | number | RegExp | bigint
  raw?: string
  regex?: {
    pattern: string
    flags: string
  }
  bigint?: string
}

export interface Program extends Node {
  type: "Program"
  body: Array<Statement | ModuleDeclaration>
  sourceType: "script" | "module"
}

export interface Function extends Node {
  id?: Identifier | null
  params: Array<Pattern>
  body: BlockStatement | Expression
  generator: boolean
  expression: boolean
  async: boolean
}

export interface ExpressionStatement extends Node {
  type: "ExpressionStatement"
  expression: Expression | Literal
  directive?: string
}

export interface BlockStatement extends Node {
  type: "BlockStatement"
  body: Array<Statement>
}

export interface EmptyStatement extends Node {
  type: "EmptyStatement"
}

export interface DebuggerStatement extends Node {
  type: "DebuggerStatement"
}

export interface WithStatement extends Node {
  type: "WithStatement"
  object: Expression
  body: Statement
}

export interface ReturnStatement extends Node {
  type: "ReturnStatement"
  argument?: Expression | null
}

export interface LabeledStatement extends Node {
  type: "LabeledStatement"
  label: Identifier
  body: Statement
}

export interface BreakStatement extends Node {
  type: "BreakStatement"
  label?: Identifier | null
}

export interface ContinueStatement extends Node {
  type: "ContinueStatement"
  label?: Identifier | null
}

export interface IfStatement extends Node {
  type: "IfStatement"
  test: Expression
  consequent: Statement
  alternate?: Statement | null
}

export interface SwitchStatement extends Node {
  type: "SwitchStatement"
  discriminant: Expression
  cases: Array<SwitchCase>
}

export interface SwitchCase extends Node {
  type: "SwitchCase"
  test?: Expression | null
  consequent: Array<Statement>
}

export interface ThrowStatement extends Node {
  type: "ThrowStatement"
  argument: Expression
}

export interface TryStatement extends Node {
  type: "TryStatement"
  block: BlockStatement
  handler?: CatchClause | null
  finalizer?: BlockStatement | null
}

export interface CatchClause extends Node {
  type: "CatchClause"
  param?: Pattern | null
  body: BlockStatement
}

export interface WhileStatement extends Node {
  type: "WhileStatement"
  test: Expression
  body: Statement
}

export interface DoWhileStatement extends Node {
  type: "DoWhileStatement"
  body: Statement
  test: Expression
}

export interface ForStatement extends Node {
  type: "ForStatement"
  init?: VariableDeclaration | Expression | null
  test?: Expression | null
  update?: Expression | null
  body: Statement
}

export interface ForInStatement extends Node {
  type: "ForInStatement"
  left: VariableDeclaration | Pattern
  right: Expression
  body: Statement
}

export interface FunctionDeclaration extends Function {
  type: "FunctionDeclaration"
  id: Identifier
  body: BlockStatement
}

export interface VariableDeclaration extends Node {
  type: "VariableDeclaration"
  declarations: Array<VariableDeclarator>
  kind: "var" | "let" | "const"
}

export interface VariableDeclarator extends Node {
  type: "VariableDeclarator"
  id: Pattern
  init?: Expression | null
}

export interface ThisExpression extends Node {
  type: "ThisExpression"
}

export interface ArrayExpression extends Node {
  type: "ArrayExpression"
  elements: Array<Expression | SpreadElement | null>
}

export interface ObjectExpression extends Node {
  type: "ObjectExpression"
  properties: Array<Property | SpreadElement>
}

export interface Property extends Node {
  type: "Property"
  key: Expression
  value: Expression
  kind: "init" | "get" | "set"
  method: boolean
  shorthand: boolean
  computed: boolean
}

export interface FunctionExpression extends Function {
  type: "FunctionExpression"
  body: BlockStatement
}

export interface UnaryExpression extends Node {
  type: "UnaryExpression"
  operator: UnaryOperator
  prefix: boolean
  argument: Expression
}

export type UnaryOperator = "-" | "+" | "!" | "~" | "typeof" | "void" | "delete"

export interface UpdateExpression extends Node {
  type: "UpdateExpression"
  operator: UpdateOperator
  argument: Expression
  prefix: boolean
}

export type UpdateOperator = "++" | "--"

export interface BinaryExpression extends Node {
  type: "BinaryExpression"
  operator: BinaryOperator
  left: Expression | PrivateIdentifier
  right: Expression
}

export type BinaryOperator = "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "|" | "^" | "&" | "in" | "instanceof" | "**"

export interface AssignmentExpression extends Node {
  type: "AssignmentExpression"
  operator: AssignmentOperator
  left: Pattern
  right: Expression
}

export type AssignmentOperator = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=" | "**=" | "||=" | "&&=" | "??="

export interface LogicalExpression extends Node {
  type: "LogicalExpression"
  operator: LogicalOperator
  left: Expression
  right: Expression
}

export type LogicalOperator = "||" | "&&" | "??"

export interface MemberExpression extends Node {
  type: "MemberExpression"
  object: Expression | Super
  property: Expression | PrivateIdentifier
  computed: boolean
  optional: boolean
}

export interface ConditionalExpression extends Node {
  type: "ConditionalExpression"
  test: Expression
  alternate: Expression
  consequent: Expression
}

export interface CallExpression extends Node {
  type: "CallExpression"
  callee: Expression | Super
  arguments: Array<Expression | SpreadElement>
  optional: boolean
}

export interface NewExpression extends Node {
  type: "NewExpression"
  callee: Expression
  arguments: Array<Expression | SpreadElement>
}

export interface SequenceExpression extends Node {
  type: "SequenceExpression"
  expressions: Array<Expression>
}

export interface ForOfStatement extends Node {
  type: "ForOfStatement"
  left: VariableDeclaration | Pattern
  right: Expression
  body: Statement
  await: boolean
}

export interface Super extends Node {
  type: "Super"
}

export interface SpreadElement extends Node {
  type: "SpreadElement"
  argument: Expression
}

export interface ArrowFunctionExpression extends Function {
  type: "ArrowFunctionExpression"
}

export interface YieldExpression extends Node {
  type: "YieldExpression"
  argument?: Expression | null
  delegate: boolean
}

export interface TemplateLiteral extends Node {
  type: "TemplateLiteral"
  quasis: Array<TemplateElement>
  expressions: Array<Expression>
}

export interface TaggedTemplateExpression extends Node {
  type: "TaggedTemplateExpression"
  tag: Expression
  quasi: TemplateLiteral
}

export interface TemplateElement extends Node {
  type: "TemplateElement"
  tail: boolean
  value: {
    cooked?: string | null
    raw: string
  }
}

export interface AssignmentProperty extends Node {
  type: "Property"
  key: Expression
  value: Pattern
  kind: "init"
  method: false
  shorthand: boolean
  computed: boolean
}

export interface ObjectPattern extends Node {
  type: "ObjectPattern"
  properties: Array<AssignmentProperty | RestElement>
}

export interface ArrayPattern extends Node {
  type: "ArrayPattern"
  elements: Array<Pattern | null>
}

export interface RestElement extends Node {
  type: "RestElement"
  argument: Pattern
}

export interface AssignmentPattern extends Node {
  type: "AssignmentPattern"
  left: Pattern
  right: Expression
}

export interface Class extends Node {
  id?: Identifier | null
  superClass?: Expression | null
  body: ClassBody
}

export interface ClassBody extends Node {
  type: "ClassBody"
  body: Array<MethodDefinition | PropertyDefinition | StaticBlock>
}

export interface MethodDefinition extends Node {
  type: "MethodDefinition"
  key: Expression | PrivateIdentifier
  value: FunctionExpression
  kind: "constructor" | "method" | "get" | "set"
  computed: boolean
  static: boolean
}

export interface ClassDeclaration extends Class {
  type: "ClassDeclaration"
  id: Identifier
}

export interface ClassExpression extends Class {
  type: "ClassExpression"
}

export interface MetaProperty extends Node {
  type: "MetaProperty"
  meta: Identifier
  property: Identifier
}

export interface ImportDeclaration extends Node {
  type: "ImportDeclaration"
  specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>
  source: Literal
  attributes: Array<ImportAttribute>
}

export interface ImportSpecifier extends Node {
  type: "ImportSpecifier"
  imported: Identifier | Literal
  local: Identifier
}

export interface ImportDefaultSpecifier extends Node {
  type: "ImportDefaultSpecifier"
  local: Identifier
}

export interface ImportNamespaceSpecifier extends Node {
  type: "ImportNamespaceSpecifier"
  local: Identifier
}

export interface ImportAttribute extends Node {
  type: "ImportAttribute"
  key: Identifier | Literal
  value: Literal
}

export interface ExportNamedDeclaration extends Node {
  type: "ExportNamedDeclaration"
  declaration?: Declaration | null
  specifiers: Array<ExportSpecifier>
  source?: Literal | null
  attributes: Array<ImportAttribute>
}

export interface ExportSpecifier extends Node {
  type: "ExportSpecifier"
  exported: Identifier | Literal
  local: Identifier | Literal
}

export interface AnonymousFunctionDeclaration extends Function {
  type: "FunctionDeclaration"
  id: null
  body: BlockStatement
}

export interface AnonymousClassDeclaration extends Class {
  type: "ClassDeclaration"
  id: null
}

export interface ExportDefaultDeclaration extends Node {
  type: "ExportDefaultDeclaration"
  declaration: AnonymousFunctionDeclaration | FunctionDeclaration | AnonymousClassDeclaration | ClassDeclaration | Expression
}

export interface ExportAllDeclaration extends Node {
  type: "ExportAllDeclaration"
  source: Literal
  exported?: Identifier | Literal | null
  attributes: Array<ImportAttribute>
}

export interface AwaitExpression extends Node {
  type: "AwaitExpression"
  argument: Expression
}

export interface ChainExpression extends Node {
  type: "ChainExpression"
  expression: MemberExpression | CallExpression
}

export interface ImportExpression extends Node {
  type: "ImportExpression"
  source: Expression
  options: Expression | null
}

export interface ParenthesizedExpression extends Node {
  type: "ParenthesizedExpression"
  expression: Expression
}

export interface PropertyDefinition extends Node {
  type: "PropertyDefinition"
  key: Expression | PrivateIdentifier
  value?: Expression | null
  computed: boolean
  static: boolean
}

export interface PrivateIdentifier extends Node {
  type: "PrivateIdentifier"
  name: string
}

export interface StaticBlock extends Node {
  type: "StaticBlock"
  body: Array<Statement>
}

export type Statement = 
| ExpressionStatement
| BlockStatement
| EmptyStatement
| DebuggerStatement
| WithStatement
| ReturnStatement
| LabeledStatement
| BreakStatement
| ContinueStatement
| IfStatement
| SwitchStatement
| ThrowStatement
| TryStatement
| WhileStatement
| DoWhileStatement
| ForStatement
| ForInStatement
| ForOfStatement
| Declaration

export type Declaration = 
| FunctionDeclaration
| VariableDeclaration
| ClassDeclaration

export type Expression = 
| Identifier
| Literal
| ThisExpression
| ArrayExpression
| ObjectExpression
| FunctionExpression
| UnaryExpression
| UpdateExpression
| BinaryExpression
| AssignmentExpression
| LogicalExpression
| MemberExpression
| ConditionalExpression
| CallExpression
| NewExpression
| SequenceExpression
| ArrowFunctionExpression
| YieldExpression
| TemplateLiteral
| TaggedTemplateExpression
| ClassExpression
| MetaProperty
| AwaitExpression
| ChainExpression
| ImportExpression
| ParenthesizedExpression

export type Pattern = 
| Identifier
| MemberExpression
| ObjectPattern
| ArrayPattern
| RestElement
| AssignmentPattern

export type ModuleDeclaration = 
| ImportDeclaration
| ExportNamedDeclaration
| ExportDefaultDeclaration
| ExportAllDeclaration

export type AnyNode = Statement | Expression | Declaration | ModuleDeclaration | Literal | Program | SwitchCase | CatchClause | Property | Super | SpreadElement | TemplateElement | AssignmentProperty | ObjectPattern | ArrayPattern | RestElement | AssignmentPattern | ClassBody | MethodDefinition | MetaProperty | ImportAttribute | ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier | AnonymousFunctionDeclaration | AnonymousClassDeclaration | PropertyDefinition | PrivateIdentifier | StaticBlock | VariableDeclarator

export function parse(input: string, options: Options): Program

export function parseExpressionAt(input: string, pos: number, options: Options): Expression

export function tokenizer(input: string, options: Options): {
  getToken(): Token
  [Symbol.iterator](): Iterator<Token>
}

export type ecmaVersion = 3 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 2015 | 2016 | 2017 | 2018 | 2019 | 2020 | 2021 | 2022 | 2023 | 2024 | 2025 | "latest"

export interface Options {
  /**
   * `ecmaVersion` indicates the ECMAScript version to parse. Can be a
   * number, either in year (`2022`) or plain version number (`6`) form,
   * or `"latest"` (the latest the library supports). This influences
   * support for strict mode, the set of reserved words, and support for
   * new syntax features.
   */
  ecmaVersion: ecmaVersion

  /**
   * `sourceType` indicates the mode the code should be parsed in.
   * Can be either `"script"` or `"module"`. This influences global
   * strict mode and parsing of `import` and `export` declarations.
   */
  sourceType?: "script" | "module"

  /**
   * a callback that will be called when a semicolon is automatically inserted.
   * @param lastTokEnd the position of the comma as an offset
   * @param lastTokEndLoc location if {@link locations} is enabled
   */
  onInsertedSemicolon?: (lastTokEnd: number, lastTokEndLoc?: Position) => void

  /**
   * similar to `onInsertedSemicolon`, but for trailing commas
   * @param lastTokEnd the position of the comma as an offset
   * @param lastTokEndLoc location if `locations` is enabled
   */
  onTrailingComma?: (lastTokEnd: number, lastTokEndLoc?: Position) => void

  /**
   * By default, reserved words are only enforced if ecmaVersion >= 5.
   * Set `allowReserved` to a boolean value to explicitly turn this on
   * an off. When this option has the value "never", reserved words
   * and keywords can also not be used as property names.
   */
  allowReserved?: boolean | "never"

  /** 
   * When enabled, a return at the top level is not considered an error.
   */
  allowReturnOutsideFunction?: boolean

  /**
   * When enabled, import/export statements are not constrained to
   * appearing at the top of the program, and an import.meta expression
   * in a script isn't considered an error.
   */
  allowImportExportEverywhere?: boolean

  /**
   * By default, `await` identifiers are allowed to appear at the top-level scope only if {@link ecmaVersion} >= 2022.
   * When enabled, await identifiers are allowed to appear at the top-level scope,
   * but they are still not allowed in non-async functions.
   */
  allowAwaitOutsideFunction?: boolean

  /**
   * When enabled, super identifiers are not constrained to
   * appearing in methods and do not raise an error when they appear elsewhere.
   */
  allowSuperOutsideMethod?: boolean

  /**
   * When enabled, hashbang directive in the beginning of file is
   * allowed and treated as a line comment. Enabled by default when
   * {@link ecmaVersion} >= 2023.
   */
  allowHashBang?: boolean

  /**
   * By default, the parser will verify that private properties are
   * only used in places where they are valid and have been declared.
   * Set this to false to turn such checks off.
   */
  checkPrivateFields?: boolean

  /**
   * When `locations` is on, `loc` properties holding objects with
   * `start` and `end` properties as {@link Position} objects will be attached to the
   * nodes.
   */
  locations?: boolean

  /**
   * a callback that will cause Acorn to call that export function with object in the same
   * format as tokens returned from `tokenizer().getToken()`. Note
   * that you are not allowed to call the parser from the
   * callback—that will corrupt its internal state.
   */
  onToken?: ((token: Token) => void) | Token[]


  /**
   * This takes a export function or an array.
   * 
   * When a export function is passed, Acorn will call that export function with `(block, text, start,
   * end)` parameters whenever a comment is skipped. `block` is a
   * boolean indicating whether this is a block (`/* *\/`) comment,
   * `text` is the content of the comment, and `start` and `end` are
   * character offsets that denote the start and end of the comment.
   * When the {@link locations} option is on, two more parameters are
   * passed, the full locations of {@link Position} export type of the start and
   * end of the comments.
   * 
   * When a array is passed, each found comment of {@link Comment} export type is pushed to the array.
   * 
   * Note that you are not allowed to call the
   * parser from the callback—that will corrupt its internal state.
   */
  onComment?: ((
    isBlock: boolean, text: string, start: number, end: number, startLoc?: Position,
    endLoc?: Position
  ) => void) | Comment[]

  /**
   * Nodes have their start and end characters offsets recorded in
   * `start` and `end` properties (directly on the node, rather than
   * the `loc` object, which holds line/column data. To also add a
   * [semi-standardized][range] `range` property holding a `[start,
   * end]` array with the same numbers, set the `ranges` option to
   * `true`.
   */
  ranges?: boolean

  /**
   * It is possible to parse multiple files into a single AST by
   * passing the tree produced by parsing the first file as
   * `program` option in subsequent parses. This will add the
   * toplevel forms of the parsed file to the `Program` (top) node
   * of an existing parse tree.
   */
  program?: Node

  /**
   * When {@link locations} is on, you can pass this to record the source
   * file in every node's `loc` object.
   */
  sourceFile?: string

  /**
   * This value, if given, is stored in every node, whether {@link locations} is on or off.
   */
  directSourceFile?: string

  /**
   * When enabled, parenthesized expressions are represented by
   * (non-standard) ParenthesizedExpression nodes
   */
  preserveParens?: boolean
}
  
export class Parser {
  options: Options
  input: string
  
  protected constructor(options: Options, input: string, startPos?: number)
  parse(): Program
  
  static parse(input: string, options: Options): Program
  static parseExpressionAt(input: string, pos: number, options: Options): Expression
  static tokenizer(input: string, options: Options): {
    getToken(): Token
    [Symbol.iterator](): Iterator<Token>
  }
  static extend(...plugins: ((BaseParser: typeof Parser) => typeof Parser)[]): typeof Parser
}

export const defaultOptions: Options

export function getLineInfo(input: string, offset: number): Position

export class TokenType {
  label: string
  keyword: string | undefined
}

export const tokTypes: {
  num: TokenType
  regexp: TokenType
  string: TokenType
  name: TokenType
  privateId: TokenType
  eof: TokenType

  bracketL: TokenType
  bracketR: TokenType
  braceL: TokenType
  braceR: TokenType
  parenL: TokenType
  parenR: TokenType
  comma: TokenType
  semi: TokenType
  colon: TokenType
  dot: TokenType
  question: TokenType
  questionDot: TokenType
  arrow: TokenType
  template: TokenType
  invalidTemplate: TokenType
  ellipsis: TokenType
  backQuote: TokenType
  dollarBraceL: TokenType

  eq: TokenType
  assign: TokenType
  incDec: TokenType
  prefix: TokenType
  logicalOR: TokenType
  logicalAND: TokenType
  bitwiseOR: TokenType
  bitwiseXOR: TokenType
  bitwiseAND: TokenType
  equality: TokenType
  relational: TokenType
  bitShift: TokenType
  plusMin: TokenType
  modulo: TokenType
  star: TokenType
  slash: TokenType
  starstar: TokenType
  coalesce: TokenType

  _break: TokenType
  _case: TokenType
  _catch: TokenType
  _continue: TokenType
  _debugger: TokenType
  _default: TokenType
  _do: TokenType
  _else: TokenType
  _finally: TokenType
  _for: TokenType
  _function: TokenType
  _if: TokenType
  _return: TokenType
  _switch: TokenType
  _throw: TokenType
  _try: TokenType
  _var: TokenType
  _const: TokenType
  _while: TokenType
  _with: TokenType
  _new: TokenType
  _this: TokenType
  _super: TokenType
  _class: TokenType
  _extends: TokenType
  _export: TokenType
  _import: TokenType
  _null: TokenType
  _true: TokenType
  _false: TokenType
  _in: TokenType
  _instanceof: TokenType
  _typeof: TokenType
  _void: TokenType
  _delete: TokenType
}

export interface Comment {
  type: "Line" | "Block"
  value: string
  start: number
  end: number
  loc?: SourceLocation
  range?: [number, number]
}

export class Token {
  type: TokenType
  start: number
  end: number
  loc?: SourceLocation
  range?: [number, number]
}

export const version: string
                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/acorn/acorn/dist/acorn.d.ts                                                        0000664 0000000 0000000 00000052115 14746647661 0020557 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        export interface Node {
  start: number
  end: number
  type: string
  range?: [number, number]
  loc?: SourceLocation | null
}

export interface SourceLocation {
  source?: string | null
  start: Position
  end: Position
}

export interface Position {
  /** 1-based */
  line: number
  /** 0-based */
  column: number
}

export interface Identifier extends Node {
  type: "Identifier"
  name: string
}

export interface Literal extends Node {
  type: "Literal"
  value?: string | boolean | null | number | RegExp | bigint
  raw?: string
  regex?: {
    pattern: string
    flags: string
  }
  bigint?: string
}

export interface Program extends Node {
  type: "Program"
  body: Array<Statement | ModuleDeclaration>
  sourceType: "script" | "module"
}

export interface Function extends Node {
  id?: Identifier | null
  params: Array<Pattern>
  body: BlockStatement | Expression
  generator: boolean
  expression: boolean
  async: boolean
}

export interface ExpressionStatement extends Node {
  type: "ExpressionStatement"
  expression: Expression | Literal
  directive?: string
}

export interface BlockStatement extends Node {
  type: "BlockStatement"
  body: Array<Statement>
}

export interface EmptyStatement extends Node {
  type: "EmptyStatement"
}

export interface DebuggerStatement extends Node {
  type: "DebuggerStatement"
}

export interface WithStatement extends Node {
  type: "WithStatement"
  object: Expression
  body: Statement
}

export interface ReturnStatement extends Node {
  type: "ReturnStatement"
  argument?: Expression | null
}

export interface LabeledStatement extends Node {
  type: "LabeledStatement"
  label: Identifier
  body: Statement
}

export interface BreakStatement extends Node {
  type: "BreakStatement"
  label?: Identifier | null
}

export interface ContinueStatement extends Node {
  type: "ContinueStatement"
  label?: Identifier | null
}

export interface IfStatement extends Node {
  type: "IfStatement"
  test: Expression
  consequent: Statement
  alternate?: Statement | null
}

export interface SwitchStatement extends Node {
  type: "SwitchStatement"
  discriminant: Expression
  cases: Array<SwitchCase>
}

export interface SwitchCase extends Node {
  type: "SwitchCase"
  test?: Expression | null
  consequent: Array<Statement>
}

export interface ThrowStatement extends Node {
  type: "ThrowStatement"
  argument: Expression
}

export interface TryStatement extends Node {
  type: "TryStatement"
  block: BlockStatement
  handler?: CatchClause | null
  finalizer?: BlockStatement | null
}

export interface CatchClause extends Node {
  type: "CatchClause"
  param?: Pattern | null
  body: BlockStatement
}

export interface WhileStatement extends Node {
  type: "WhileStatement"
  test: Expression
  body: Statement
}

export interface DoWhileStatement extends Node {
  type: "DoWhileStatement"
  body: Statement
  test: Expression
}

export interface ForStatement extends Node {
  type: "ForStatement"
  init?: VariableDeclaration | Expression | null
  test?: Expression | null
  update?: Expression | null
  body: Statement
}

export interface ForInStatement extends Node {
  type: "ForInStatement"
  left: VariableDeclaration | Pattern
  right: Expression
  body: Statement
}

export interface FunctionDeclaration extends Function {
  type: "FunctionDeclaration"
  id: Identifier
  body: BlockStatement
}

export interface VariableDeclaration extends Node {
  type: "VariableDeclaration"
  declarations: Array<VariableDeclarator>
  kind: "var" | "let" | "const"
}

export interface VariableDeclarator extends Node {
  type: "VariableDeclarator"
  id: Pattern
  init?: Expression | null
}

export interface ThisExpression extends Node {
  type: "ThisExpression"
}

export interface ArrayExpression extends Node {
  type: "ArrayExpression"
  elements: Array<Expression | SpreadElement | null>
}

export interface ObjectExpression extends Node {
  type: "ObjectExpression"
  properties: Array<Property | SpreadElement>
}

export interface Property extends Node {
  type: "Property"
  key: Expression
  value: Expression
  kind: "init" | "get" | "set"
  method: boolean
  shorthand: boolean
  computed: boolean
}

export interface FunctionExpression extends Function {
  type: "FunctionExpression"
  body: BlockStatement
}

export interface UnaryExpression extends Node {
  type: "UnaryExpression"
  operator: UnaryOperator
  prefix: boolean
  argument: Expression
}

export type UnaryOperator = "-" | "+" | "!" | "~" | "typeof" | "void" | "delete"

export interface UpdateExpression extends Node {
  type: "UpdateExpression"
  operator: UpdateOperator
  argument: Expression
  prefix: boolean
}

export type UpdateOperator = "++" | "--"

export interface BinaryExpression extends Node {
  type: "BinaryExpression"
  operator: BinaryOperator
  left: Expression | PrivateIdentifier
  right: Expression
}

export type BinaryOperator = "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "|" | "^" | "&" | "in" | "instanceof" | "**"

export interface AssignmentExpression extends Node {
  type: "AssignmentExpression"
  operator: AssignmentOperator
  left: Pattern
  right: Expression
}

export type AssignmentOperator = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=" | "**=" | "||=" | "&&=" | "??="

export interface LogicalExpression extends Node {
  type: "LogicalExpression"
  operator: LogicalOperator
  left: Expression
  right: Expression
}

export type LogicalOperator = "||" | "&&" | "??"

export interface MemberExpression extends Node {
  type: "MemberExpression"
  object: Expression | Super
  property: Expression | PrivateIdentifier
  computed: boolean
  optional: boolean
}

export interface ConditionalExpression extends Node {
  type: "ConditionalExpression"
  test: Expression
  alternate: Expression
  consequent: Expression
}

export interface CallExpression extends Node {
  type: "CallExpression"
  callee: Expression | Super
  arguments: Array<Expression | SpreadElement>
  optional: boolean
}

export interface NewExpression extends Node {
  type: "NewExpression"
  callee: Expression
  arguments: Array<Expression | SpreadElement>
}

export interface SequenceExpression extends Node {
  type: "SequenceExpression"
  expressions: Array<Expression>
}

export interface ForOfStatement extends Node {
  type: "ForOfStatement"
  left: VariableDeclaration | Pattern
  right: Expression
  body: Statement
  await: boolean
}

export interface Super extends Node {
  type: "Super"
}

export interface SpreadElement extends Node {
  type: "SpreadElement"
  argument: Expression
}

export interface ArrowFunctionExpression extends Function {
  type: "ArrowFunctionExpression"
}

export interface YieldExpression extends Node {
  type: "YieldExpression"
  argument?: Expression | null
  delegate: boolean
}

export interface TemplateLiteral extends Node {
  type: "TemplateLiteral"
  quasis: Array<TemplateElement>
  expressions: Array<Expression>
}

export interface TaggedTemplateExpression extends Node {
  type: "TaggedTemplateExpression"
  tag: Expression
  quasi: TemplateLiteral
}

export interface TemplateElement extends Node {
  type: "TemplateElement"
  tail: boolean
  value: {
    cooked?: string | null
    raw: string
  }
}

export interface AssignmentProperty extends Node {
  type: "Property"
  key: Expression
  value: Pattern
  kind: "init"
  method: false
  shorthand: boolean
  computed: boolean
}

export interface ObjectPattern extends Node {
  type: "ObjectPattern"
  properties: Array<AssignmentProperty | RestElement>
}

export interface ArrayPattern extends Node {
  type: "ArrayPattern"
  elements: Array<Pattern | null>
}

export interface RestElement extends Node {
  type: "RestElement"
  argument: Pattern
}

export interface AssignmentPattern extends Node {
  type: "AssignmentPattern"
  left: Pattern
  right: Expression
}

export interface Class extends Node {
  id?: Identifier | null
  superClass?: Expression | null
  body: ClassBody
}

export interface ClassBody extends Node {
  type: "ClassBody"
  body: Array<MethodDefinition | PropertyDefinition | StaticBlock>
}

export interface MethodDefinition extends Node {
  type: "MethodDefinition"
  key: Expression | PrivateIdentifier
  value: FunctionExpression
  kind: "constructor" | "method" | "get" | "set"
  computed: boolean
  static: boolean
}

export interface ClassDeclaration extends Class {
  type: "ClassDeclaration"
  id: Identifier
}

export interface ClassExpression extends Class {
  type: "ClassExpression"
}

export interface MetaProperty extends Node {
  type: "MetaProperty"
  meta: Identifier
  property: Identifier
}

export interface ImportDeclaration extends Node {
  type: "ImportDeclaration"
  specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>
  source: Literal
  attributes: Array<ImportAttribute>
}

export interface ImportSpecifier extends Node {
  type: "ImportSpecifier"
  imported: Identifier | Literal
  local: Identifier
}

export interface ImportDefaultSpecifier extends Node {
  type: "ImportDefaultSpecifier"
  local: Identifier
}

export interface ImportNamespaceSpecifier extends Node {
  type: "ImportNamespaceSpecifier"
  local: Identifier
}

export interface ImportAttribute extends Node {
  type: "ImportAttribute"
  key: Identifier | Literal
  value: Literal
}

export interface ExportNamedDeclaration extends Node {
  type: "ExportNamedDeclaration"
  declaration?: Declaration | null
  specifiers: Array<ExportSpecifier>
  source?: Literal | null
  attributes: Array<ImportAttribute>
}

export interface ExportSpecifier extends Node {
  type: "ExportSpecifier"
  exported: Identifier | Literal
  local: Identifier | Literal
}

export interface AnonymousFunctionDeclaration extends Function {
  type: "FunctionDeclaration"
  id: null
  body: BlockStatement
}

export interface AnonymousClassDeclaration extends Class {
  type: "ClassDeclaration"
  id: null
}

export interface ExportDefaultDeclaration extends Node {
  type: "ExportDefaultDeclaration"
  declaration: AnonymousFunctionDeclaration | FunctionDeclaration | AnonymousClassDeclaration | ClassDeclaration | Expression
}

export interface ExportAllDeclaration extends Node {
  type: "ExportAllDeclaration"
  source: Literal
  exported?: Identifier | Literal | null
  attributes: Array<ImportAttribute>
}

export interface AwaitExpression extends Node {
  type: "AwaitExpression"
  argument: Expression
}

export interface ChainExpression extends Node {
  type: "ChainExpression"
  expression: MemberExpression | CallExpression
}

export interface ImportExpression extends Node {
  type: "ImportExpression"
  source: Expression
  options: Expression | null
}

export interface ParenthesizedExpression extends Node {
  type: "ParenthesizedExpression"
  expression: Expression
}

export interface PropertyDefinition extends Node {
  type: "PropertyDefinition"
  key: Expression | PrivateIdentifier
  value?: Expression | null
  computed: boolean
  static: boolean
}

export interface PrivateIdentifier extends Node {
  type: "PrivateIdentifier"
  name: string
}

export interface StaticBlock extends Node {
  type: "StaticBlock"
  body: Array<Statement>
}

export type Statement = 
| ExpressionStatement
| BlockStatement
| EmptyStatement
| DebuggerStatement
| WithStatement
| ReturnStatement
| LabeledStatement
| BreakStatement
| ContinueStatement
| IfStatement
| SwitchStatement
| ThrowStatement
| TryStatement
| WhileStatement
| DoWhileStatement
| ForStatement
| ForInStatement
| ForOfStatement
| Declaration

export type Declaration = 
| FunctionDeclaration
| VariableDeclaration
| ClassDeclaration

export type Expression = 
| Identifier
| Literal
| ThisExpression
| ArrayExpression
| ObjectExpression
| FunctionExpression
| UnaryExpression
| UpdateExpression
| BinaryExpression
| AssignmentExpression
| LogicalExpression
| MemberExpression
| ConditionalExpression
| CallExpression
| NewExpression
| SequenceExpression
| ArrowFunctionExpression
| YieldExpression
| TemplateLiteral
| TaggedTemplateExpression
| ClassExpression
| MetaProperty
| AwaitExpression
| ChainExpression
| ImportExpression
| ParenthesizedExpression

export type Pattern = 
| Identifier
| MemberExpression
| ObjectPattern
| ArrayPattern
| RestElement
| AssignmentPattern

export type ModuleDeclaration = 
| ImportDeclaration
| ExportNamedDeclaration
| ExportDefaultDeclaration
| ExportAllDeclaration

export type AnyNode = Statement | Expression | Declaration | ModuleDeclaration | Literal | Program | SwitchCase | CatchClause | Property | Super | SpreadElement | TemplateElement | AssignmentProperty | ObjectPattern | ArrayPattern | RestElement | AssignmentPattern | ClassBody | MethodDefinition | MetaProperty | ImportAttribute | ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier | AnonymousFunctionDeclaration | AnonymousClassDeclaration | PropertyDefinition | PrivateIdentifier | StaticBlock | VariableDeclarator

export function parse(input: string, options: Options): Program

export function parseExpressionAt(input: string, pos: number, options: Options): Expression

export function tokenizer(input: string, options: Options): {
  getToken(): Token
  [Symbol.iterator](): Iterator<Token>
}

export type ecmaVersion = 3 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 2015 | 2016 | 2017 | 2018 | 2019 | 2020 | 2021 | 2022 | 2023 | 2024 | 2025 | "latest"

export interface Options {
  /**
   * `ecmaVersion` indicates the ECMAScript version to parse. Can be a
   * number, either in year (`2022`) or plain version number (`6`) form,
   * or `"latest"` (the latest the library supports). This influences
   * support for strict mode, the set of reserved words, and support for
   * new syntax features.
   */
  ecmaVersion: ecmaVersion

  /**
   * `sourceType` indicates the mode the code should be parsed in.
   * Can be either `"script"` or `"module"`. This influences global
   * strict mode and parsing of `import` and `export` declarations.
   */
  sourceType?: "script" | "module"

  /**
   * a callback that will be called when a semicolon is automatically inserted.
   * @param lastTokEnd the position of the comma as an offset
   * @param lastTokEndLoc location if {@link locations} is enabled
   */
  onInsertedSemicolon?: (lastTokEnd: number, lastTokEndLoc?: Position) => void

  /**
   * similar to `onInsertedSemicolon`, but for trailing commas
   * @param lastTokEnd the position of the comma as an offset
   * @param lastTokEndLoc location if `locations` is enabled
   */
  onTrailingComma?: (lastTokEnd: number, lastTokEndLoc?: Position) => void

  /**
   * By default, reserved words are only enforced if ecmaVersion >= 5.
   * Set `allowReserved` to a boolean value to explicitly turn this on
   * an off. When this option has the value "never", reserved words
   * and keywords can also not be used as property names.
   */
  allowReserved?: boolean | "never"

  /** 
   * When enabled, a return at the top level is not considered an error.
   */
  allowReturnOutsideFunction?: boolean

  /**
   * When enabled, import/export statements are not constrained to
   * appearing at the top of the program, and an import.meta expression
   * in a script isn't considered an error.
   */
  allowImportExportEverywhere?: boolean

  /**
   * By default, `await` identifiers are allowed to appear at the top-level scope only if {@link ecmaVersion} >= 2022.
   * When enabled, await identifiers are allowed to appear at the top-level scope,
   * but they are still not allowed in non-async functions.
   */
  allowAwaitOutsideFunction?: boolean

  /**
   * When enabled, super identifiers are not constrained to
   * appearing in methods and do not raise an error when they appear elsewhere.
   */
  allowSuperOutsideMethod?: boolean

  /**
   * When enabled, hashbang directive in the beginning of file is
   * allowed and treated as a line comment. Enabled by default when
   * {@link ecmaVersion} >= 2023.
   */
  allowHashBang?: boolean

  /**
   * By default, the parser will verify that private properties are
   * only used in places where they are valid and have been declared.
   * Set this to false to turn such checks off.
   */
  checkPrivateFields?: boolean

  /**
   * When `locations` is on, `loc` properties holding objects with
   * `start` and `end` properties as {@link Position} objects will be attached to the
   * nodes.
   */
  locations?: boolean

  /**
   * a callback that will cause Acorn to call that export function with object in the same
   * format as tokens returned from `tokenizer().getToken()`. Note
   * that you are not allowed to call the parser from the
   * callback—that will corrupt its internal state.
   */
  onToken?: ((token: Token) => void) | Token[]


  /**
   * This takes a export function or an array.
   * 
   * When a export function is passed, Acorn will call that export function with `(block, text, start,
   * end)` parameters whenever a comment is skipped. `block` is a
   * boolean indicating whether this is a block (`/* *\/`) comment,
   * `text` is the content of the comment, and `start` and `end` are
   * character offsets that denote the start and end of the comment.
   * When the {@link locations} option is on, two more parameters are
   * passed, the full locations of {@link Position} export type of the start and
   * end of the comments.
   * 
   * When a array is passed, each found comment of {@link Comment} export type is pushed to the array.
   * 
   * Note that you are not allowed to call the
   * parser from the callback—that will corrupt its internal state.
   */
  onComment?: ((
    isBlock: boolean, text: string, start: number, end: number, startLoc?: Position,
    endLoc?: Position
  ) => void) | Comment[]

  /**
   * Nodes have their start and end characters offsets recorded in
   * `start` and `end` properties (directly on the node, rather than
   * the `loc` object, which holds line/column data. To also add a
   * [semi-standardized][range] `range` property holding a `[start,
   * end]` array with the same numbers, set the `ranges` option to
   * `true`.
   */
  ranges?: boolean

  /**
   * It is possible to parse multiple files into a single AST by
   * passing the tree produced by parsing the first file as
   * `program` option in subsequent parses. This will add the
   * toplevel forms of the parsed file to the `Program` (top) node
   * of an existing parse tree.
   */
  program?: Node

  /**
   * When {@link locations} is on, you can pass this to record the source
   * file in every node's `loc` object.
   */
  sourceFile?: string

  /**
   * This value, if given, is stored in every node, whether {@link locations} is on or off.
   */
  directSourceFile?: string

  /**
   * When enabled, parenthesized expressions are represented by
   * (non-standard) ParenthesizedExpression nodes
   */
  preserveParens?: boolean
}
  
export class Parser {
  options: Options
  input: string
  
  protected constructor(options: Options, input: string, startPos?: number)
  parse(): Program
  
  static parse(input: string, options: Options): Program
  static parseExpressionAt(input: string, pos: number, options: Options): Expression
  static tokenizer(input: string, options: Options): {
    getToken(): Token
    [Symbol.iterator](): Iterator<Token>
  }
  static extend(...plugins: ((BaseParser: typeof Parser) => typeof Parser)[]): typeof Parser
}

export const defaultOptions: Options

export function getLineInfo(input: string, offset: number): Position

export class TokenType {
  label: string
  keyword: string | undefined
}

export const tokTypes: {
  num: TokenType
  regexp: TokenType
  string: TokenType
  name: TokenType
  privateId: TokenType
  eof: TokenType

  bracketL: TokenType
  bracketR: TokenType
  braceL: TokenType
  braceR: TokenType
  parenL: TokenType
  parenR: TokenType
  comma: TokenType
  semi: TokenType
  colon: TokenType
  dot: TokenType
  question: TokenType
  questionDot: TokenType
  arrow: TokenType
  template: TokenType
  invalidTemplate: TokenType
  ellipsis: TokenType
  backQuote: TokenType
  dollarBraceL: TokenType

  eq: TokenType
  assign: TokenType
  incDec: TokenType
  prefix: TokenType
  logicalOR: TokenType
  logicalAND: TokenType
  bitwiseOR: TokenType
  bitwiseXOR: TokenType
  bitwiseAND: TokenType
  equality: TokenType
  relational: TokenType
  bitShift: TokenType
  plusMin: TokenType
  modulo: TokenType
  star: TokenType
  slash: TokenType
  starstar: TokenType
  coalesce: TokenType

  _break: TokenType
  _case: TokenType
  _catch: TokenType
  _continue: TokenType
  _debugger: TokenType
  _default: TokenType
  _do: TokenType
  _else: TokenType
  _finally: TokenType
  _for: TokenType
  _function: TokenType
  _if: TokenType
  _return: TokenType
  _switch: TokenType
  _throw: TokenType
  _try: TokenType
  _var: TokenType
  _const: TokenType
  _while: TokenType
  _with: TokenType
  _new: TokenType
  _this: TokenType
  _super: TokenType
  _class: TokenType
  _extends: TokenType
  _export: TokenType
  _import: TokenType
  _null: TokenType
  _true: TokenType
  _false: TokenType
  _in: TokenType
  _instanceof: TokenType
  _typeof: TokenType
  _void: TokenType
  _delete: TokenType
}

export interface Comment {
  type: "Line" | "Block"
  value: string
  start: number
  end: number
  loc?: SourceLocation
  range?: [number, number]
}

export class Token {
  type: TokenType
  start: number
  end: number
  loc?: SourceLocation
  range?: [number, number]
}

export const version: string
                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/acorn/acorn/dist/acorn.js                                                          0000664 0000000 0000000 00000721236 14746647661 0020332 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        (function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.acorn = {}));
})(this, (function (exports) { 'use strict';

  // This file was generated. Do not modify manually!
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

  // This file was generated. Do not modify manually!
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];

  // This file was generated. Do not modify manually!
  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";

  // This file was generated. Do not modify manually!
  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7cd\ua7d0\ua7d1\ua7d3\ua7d5-\ua7dc\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

  // These are a run-length and offset encoded representation of the
  // >0xffff code points that are a valid part of identifiers. The
  // offset starts at 0x10000, and each pair of numbers represents an
  // offset to the next range, and then a size of the range.

  // Reserved word lists for various dialects of the language

  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };

  // And the keywords

  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

  var keywords$1 = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };

  var keywordRelationalOperator = /^in(stanceof)?$/;

  // ## Character categories

  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  // This has a complexity linear to the value of the code. The
  // assumption is that looking up astral identifier characters is
  // rare.
  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) { return false }
      pos += set[i + 1];
      if (pos >= code) { return true }
    }
    return false
  }

  // Test whether a given character code starts an identifier.

  function isIdentifierStart(code, astral) {
    if (code < 65) { return code === 36 }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes)
  }

  // Test whether a given character is part of an identifier.

  function isIdentifierChar(code, astral) {
    if (code < 48) { return code === 36 }
    if (code < 58) { return true }
    if (code < 65) { return false }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
  }

  // ## Token types

  // The assignment of fine-grained, information-carrying type objects
  // allows the tokenizer to store the information it has about a
  // token in a way that is very cheap for the parser to look up.

  // All token type variables start with an underscore, to make them
  // easy to recognize.

  // The `beforeExpr` property is used to disambiguate between regular
  // expressions and divisions. It is set on all token types that can
  // be followed by an expression (thus, a slash after them would be a
  // regular expression).
  //
  // The `startsExpr` property is used to check if the token ends a
  // `yield` expression. It is set on all token types that either can
  // directly start an expression (like a quotation mark) or can
  // continue an expression (like the body of a string).
  //
  // `isLoop` marks a keyword as starting a loop, which is important
  // to know when parsing a label, in order to allow or disallow
  // continue jumps to that label.

  var TokenType = function TokenType(label, conf) {
    if ( conf === void 0 ) conf = {};

    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };

  function binop(name, prec) {
    return new TokenType(name, {beforeExpr: true, binop: prec})
  }
  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

  // Map keyword names to token types.

  var keywords = {};

  // Succinct definitions of keyword token types
  function kw(name, options) {
    if ( options === void 0 ) options = {};

    options.keyword = name;
    return keywords[name] = new TokenType(name, options)
  }

  var types$1 = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    privateId: new TokenType("privateId", startsExpr),
    eof: new TokenType("eof"),

    // Punctuation token types.
    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

    // Operators. These carry several kinds of properties to help the
    // parser use them properly (the presence of these properties is
    // what categorizes them as operators).
    //
    // `binop`, when present, specifies that this operator is a binary
    // operator, and will refer to its precedence.
    //
    // `prefix` and `postfix` mark the operator as a prefix or postfix
    // unary operator.
    //
    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
    // binary operators with a very low precedence, that should result
    // in AssignmentExpression nodes.

    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {beforeExpr: true}),
    coalesce: binop("??", 1),

    // Keyword token types.
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {isLoop: true, beforeExpr: true}),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {isLoop: true}),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {isLoop: true}),
    _with: kw("with"),
    _new: kw("new", {beforeExpr: true, startsExpr: true}),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {beforeExpr: true, binop: 7}),
    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
  };

  // Matches a whole line break (where CRLF is considered a single
  // line break). Used to count lines.

  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");

  function isNewLine(code) {
    return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
  }

  function nextLineBreak(code, from, end) {
    if ( end === void 0 ) end = code.length;

    for (var i = from; i < end; i++) {
      var next = code.charCodeAt(i);
      if (isNewLine(next))
        { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
    }
    return -1
  }

  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  var ref = Object.prototype;
  var hasOwnProperty = ref.hasOwnProperty;
  var toString = ref.toString;

  var hasOwn = Object.hasOwn || (function (obj, propName) { return (
    hasOwnProperty.call(obj, propName)
  ); });

  var isArray = Array.isArray || (function (obj) { return (
    toString.call(obj) === "[object Array]"
  ); });

  var regexpCache = Object.create(null);

  function wordsRegexp(words) {
    return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"))
  }

  function codePointToString(code) {
    // UTF-16 Decoding
    if (code <= 0xFFFF) { return String.fromCharCode(code) }
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
  }

  var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

  // These are used when `options.locations` is on, for the
  // `startLoc` and `endLoc` properties.

  var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
  };

  Position.prototype.offset = function offset (n) {
    return new Position(this.line, this.column + n)
  };

  var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) { this.source = p.sourceFile; }
  };

  // The `getLineInfo` function is mostly useful when the
  // `locations` option is off (for performance reasons) and you
  // want to find the line/column position for a given character
  // offset. `input` should be the code string that the offset refers
  // into.

  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0;;) {
      var nextBreak = nextLineBreak(input, cur, offset);
      if (nextBreak < 0) { return new Position(line, offset - cur) }
      ++line;
      cur = nextBreak;
    }
  }

  // A second argument must be given to configure the parser process.
  // These options are recognized (only `ecmaVersion` is required):

  var defaultOptions = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
    // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
    // (the latest version the library supports). This influences
    // support for strict mode, the set of reserved words, and support
    // for new syntax features.
    ecmaVersion: null,
    // `sourceType` indicates the mode the code should be parsed in.
    // Can be either `"script"` or `"module"`. This influences global
    // strict mode and parsing of `import` and `export` declarations.
    sourceType: "script",
    // `onInsertedSemicolon` can be a callback that will be called when
    // a semicolon is automatically inserted. It will be passed the
    // position of the inserted semicolon as an offset, and if
    // `locations` is enabled, it is given the location as a `{line,
    // column}` object as second argument.
    onInsertedSemicolon: null,
    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
    // trailing commas.
    onTrailingComma: null,
    // By default, reserved words are only enforced if ecmaVersion >= 5.
    // Set `allowReserved` to a boolean value to explicitly turn this on
    // an off. When this option has the value "never", reserved words
    // and keywords can also not be used as property names.
    allowReserved: null,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: false,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program, and an import.meta expression
    // in a script isn't considered an error.
    allowImportExportEverywhere: false,
    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
    // When enabled, await identifiers are allowed to appear at the top-level scope,
    // but they are still not allowed in non-async functions.
    allowAwaitOutsideFunction: null,
    // When enabled, super identifiers are not constrained to
    // appearing in methods and do not raise an error when they appear elsewhere.
    allowSuperOutsideMethod: null,
    // When enabled, hashbang directive in the beginning of file is
    // allowed and treated as a line comment. Enabled by default when
    // `ecmaVersion` >= 2023.
    allowHashBang: false,
    // By default, the parser will verify that private properties are
    // only used in places where they are valid and have been declared.
    // Set this to false to turn such checks off.
    checkPrivateFields: true,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokens returned from `tokenizer().getToken()`. Note
    // that you are not allowed to call the parser from the
    // callback—that will corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callback—that will corrupt its internal state.
    // When this option has an array as value, objects representing the
    // comments are pushed to it.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: false
  };

  // Interpret and default an options object

  var warnedAboutEcmaVersion = false;

  function getOptions(opts) {
    var options = {};

    for (var opt in defaultOptions)
      { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }

    if (options.ecmaVersion === "latest") {
      options.ecmaVersion = 1e8;
    } else if (options.ecmaVersion == null) {
      if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
        warnedAboutEcmaVersion = true;
        console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
      }
      options.ecmaVersion = 11;
    } else if (options.ecmaVersion >= 2015) {
      options.ecmaVersion -= 2009;
    }

    if (options.allowReserved == null)
      { options.allowReserved = options.ecmaVersion < 5; }

    if (!opts || opts.allowHashBang == null)
      { options.allowHashBang = options.ecmaVersion >= 14; }

    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) { return tokens.push(token); };
    }
    if (isArray(options.onComment))
      { options.onComment = pushComment(options, options.onComment); }

    return options
  }

  function pushComment(options, array) {
    return function(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start: start,
        end: end
      };
      if (options.locations)
        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
      if (options.ranges)
        { comment.range = [start, end]; }
      array.push(comment);
    }
  }

  // Each scope gets a bitset that may contain these flags
  var
      SCOPE_TOP = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_ASYNC = 4,
      SCOPE_GENERATOR = 8,
      SCOPE_ARROW = 16,
      SCOPE_SIMPLE_CATCH = 32,
      SCOPE_SUPER = 64,
      SCOPE_DIRECT_SUPER = 128,
      SCOPE_CLASS_STATIC_BLOCK = 256,
      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
  }

  // Used in checkLVal* and declareName to determine the type of a binding
  var
      BIND_NONE = 0, // Not a binding
      BIND_VAR = 1, // Var-style binding
      BIND_LEXICAL = 2, // Let- or const-style binding
      BIND_FUNCTION = 3, // Function declaration
      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

  var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
      reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
      if (options.sourceType === "module") { reserved += " await"; }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);

    // Used to signal to callers of `readWord1` whether the word
    // contained any escape sequences. This is needed because words with
    // escape sequences must not be interpreted as keywords.
    this.containsEsc = false;

    // Set up token state

    // The current position of the tokenizer in the input.
    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    // Properties of the current token:
    // Its type
    this.type = types$1.eof;
    // For tokens that include more information than their type, the value
    this.value = null;
    // Its start and end offset
    this.start = this.end = this.pos;
    // And, if locations are used, the {line, column} object
    // corresponding to those offsets
    this.startLoc = this.endLoc = this.curPosition();

    // Position information for the previous token
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    // The context stack is used to superficially track syntactic
    // context to predict whether a regular expression is allowed in a
    // given position.
    this.context = this.initialContext();
    this.exprAllowed = true;

    // Figure out if it's a module code.
    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);

    // Used to signify the start of a potential arrow function
    this.potentialArrowAt = -1;
    this.potentialArrowInForAwait = false;

    // Positions to delayed-check that yield/await does not exist in default parameters.
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    // Labels in scope.
    this.labels = [];
    // Thus-far undefined exports.
    this.undefinedExports = Object.create(null);

    // If enabled, skip leading hashbang line.
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
      { this.skipLineComment(2); }

    // Scope tracking for duplicate variable names (see scope.js)
    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);

    // For RegExp validation
    this.regexpState = null;

    // The stack of private names.
    // Each element has two properties: 'declared' and 'used'.
    // When it exited from the outermost class definition, all used private names must be declared.
    this.privateNameStack = [];
  };

  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

  Parser.prototype.parse = function parse () {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node)
  };

  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };

  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };

  prototypeAccessors.canAwait.get = function () {
    for (var i = this.scopeStack.length - 1; i >= 0; i--) {
      var scope = this.scopeStack[i];
      if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }
      if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }
    }
    return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
  };

  prototypeAccessors.allowSuper.get = function () {
    var ref = this.currentThisScope();
      var flags = ref.flags;
      var inClassFieldInit = ref.inClassFieldInit;
    return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
  };

  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

  prototypeAccessors.allowNewDotTarget.get = function () {
    var ref = this.currentThisScope();
      var flags = ref.flags;
      var inClassFieldInit = ref.inClassFieldInit;
    return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
  };

  prototypeAccessors.inClassStaticBlock.get = function () {
    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
  };

  Parser.extend = function extend () {
      var plugins = [], len = arguments.length;
      while ( len-- ) plugins[ len ] = arguments[ len ];

    var cls = this;
    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
    return cls
  };

  Parser.parse = function parse (input, options) {
    return new this(options, input).parse()
  };

  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression()
  };

  Parser.tokenizer = function tokenizer (input, options) {
    return new this(options, input)
  };

  Object.defineProperties( Parser.prototype, prototypeAccessors );

  var pp$9 = Parser.prototype;

  // ## Parser utilities

  var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
  pp$9.strictDirective = function(start) {
    if (this.options.ecmaVersion < 5) { return false }
    for (;;) {
      // Try to find string literal.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) { return false }
      if ((match[1] || match[2]) === "use strict") {
        skipWhiteSpace.lastIndex = start + match[0].length;
        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
        var next = this.input.charAt(end);
        return next === ";" || next === "}" ||
          (lineBreak.test(spaceAfter[0]) &&
           !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
      }
      start += match[0].length;

      // Skip semicolon, if any.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";")
        { start++; }
    }
  };

  // Predicate that tests whether the next token is of the given
  // type, and if yes, consumes it as a side effect.

  pp$9.eat = function(type) {
    if (this.type === type) {
      this.next();
      return true
    } else {
      return false
    }
  };

  // Tests whether parsed token is a contextual keyword.

  pp$9.isContextual = function(name) {
    return this.type === types$1.name && this.value === name && !this.containsEsc
  };

  // Consumes contextual keyword if possible.

  pp$9.eatContextual = function(name) {
    if (!this.isContextual(name)) { return false }
    this.next();
    return true
  };

  // Asserts that following token is given contextual keyword.

  pp$9.expectContextual = function(name) {
    if (!this.eatContextual(name)) { this.unexpected(); }
  };

  // Test whether a semicolon can be inserted at the current position.

  pp$9.canInsertSemicolon = function() {
    return this.type === types$1.eof ||
      this.type === types$1.braceR ||
      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  pp$9.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon)
        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
      return true
    }
  };

  // Consume a semicolon, or, failing that, see if we are allowed to
  // pretend that there is a semicolon at this position.

  pp$9.semicolon = function() {
    if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
  };

  pp$9.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma)
        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
      if (!notNext)
        { this.next(); }
      return true
    }
  };

  // Expect a token of a given type. If found, consume it, otherwise,
  // raise an unexpected token error.

  pp$9.expect = function(type) {
    this.eat(type) || this.unexpected();
  };

  // Raise an unexpected token error.

  pp$9.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };

  var DestructuringErrors = function DestructuringErrors() {
    this.shorthandAssign =
    this.trailingComma =
    this.parenthesizedAssign =
    this.parenthesizedBind =
    this.doubleProto =
      -1;
  };

  pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) { return }
    if (refDestructuringErrors.trailingComma > -1)
      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
  };

  pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) { return false }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
    if (shorthandAssign >= 0)
      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
    if (doubleProto >= 0)
      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
  };

  pp$9.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
    if (this.awaitPos)
      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
  };

  pp$9.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression")
      { return this.isSimpleAssignTarget(expr.expression) }
    return expr.type === "Identifier" || expr.type === "MemberExpression"
  };

  var pp$8 = Parser.prototype;

  // ### Statement parsing

  // Parse a program. Initializes the parser, reads any number of
  // statements, and wraps them in a Program node.  Optionally takes a
  // `program` argument.  If present, the statements will be appended
  // to its body instead of creating a new node.

  pp$8.parseTopLevel = function(node) {
    var exports = Object.create(null);
    if (!node.body) { node.body = []; }
    while (this.type !== types$1.eof) {
      var stmt = this.parseStatement(null, true, exports);
      node.body.push(stmt);
    }
    if (this.inModule)
      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
        {
          var name = list[i];

          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
        } }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program")
  };

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  pp$8.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    // For ambiguous cases, determine if a LexicalDeclaration (or only a
    // Statement) is allowed here. If context is not empty then only a Statement
    // is allowed. However, `let [` is an explicit negative lookahead for
    // ExpressionStatement, so special-case it first.
    if (nextCh === 91 || nextCh === 92) { return true } // '[', '\'
    if (context) { return false }

    if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
      if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) { return true }
    }
    return false
  };

  // check 'async [no LineTerminator here] function'
  // - 'async /*foo*/ function' is OK.
  // - 'async /*\n*/ function' is invalid.
  pp$8.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      { return false }

    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, after;
    return !lineBreak.test(this.input.slice(this.pos, next)) &&
      this.input.slice(next, next + 8) === "function" &&
      (next + 8 === this.input.length ||
       !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
  };

  // Parse a single statement.
  //
  // If expecting a statement and finding a slash operator, parse a
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
  // does not help.

  pp$8.parseStatement = function(context, topLevel, exports) {
    var starttype = this.type, node = this.startNode(), kind;

    if (this.isLet(context)) {
      starttype = types$1._var;
      kind = "let";
    }

    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.

    switch (starttype) {
    case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
    case types$1._debugger: return this.parseDebuggerStatement(node)
    case types$1._do: return this.parseDoStatement(node)
    case types$1._for: return this.parseForStatement(node)
    case types$1._function:
      // Function as sole body of either an if statement or a labeled statement
      // works, but not when it is part of a labeled statement that is the sole
      // body of an if statement.
      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
      return this.parseFunctionStatement(node, false, !context)
    case types$1._class:
      if (context) { this.unexpected(); }
      return this.parseClass(node, true)
    case types$1._if: return this.parseIfStatement(node)
    case types$1._return: return this.parseReturnStatement(node)
    case types$1._switch: return this.parseSwitchStatement(node)
    case types$1._throw: return this.parseThrowStatement(node)
    case types$1._try: return this.parseTryStatement(node)
    case types$1._const: case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") { this.unexpected(); }
      return this.parseVarStatement(node, kind)
    case types$1._while: return this.parseWhileStatement(node)
    case types$1._with: return this.parseWithStatement(node)
    case types$1.braceL: return this.parseBlock(true, node)
    case types$1.semi: return this.parseEmptyStatement(node)
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) // '(' or '.'
          { return this.parseExpressionStatement(node, this.parseExpression()) }
      }

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel)
          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
        if (!this.inModule)
          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)

      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction()) {
        if (context) { this.unexpected(); }
        this.next();
        return this.parseFunctionStatement(node, true, !context)
      }

      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
        { return this.parseLabeledStatement(node, maybeName, expr, context) }
      else { return this.parseExpressionStatement(node, expr) }
    }
  };

  pp$8.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
    else if (this.type !== types$1.name) { this.unexpected(); }
    else {
      node.label = this.parseIdent();
      this.semicolon();
    }

    // Verify that there is an actual destination to break or
    // continue to.
    var i = 0;
    for (; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
        if (node.label && isBreak) { break }
      }
    }
    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
  };

  pp$8.parseDebuggerStatement = function(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement")
  };

  pp$8.parseDoStatement = function(node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types$1._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6)
      { this.eat(types$1.semi); }
    else
      { this.semicolon(); }
    return this.finishNode(node, "DoWhileStatement")
  };

  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
  // loop is non-trivial. Basically, we have to parse the init `var`
  // statement or expression, disallowing the `in` operator (see
  // the second parameter to `parseExpression`), and then check
  // whether the next token is `in` or `of`. When there is no init
  // part (semicolon immediately after the opening parenthesis), it
  // is a regular `for` loop.

  pp$8.parseForStatement = function(node) {
    this.next();
    var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types$1.parenL);
    if (this.type === types$1.semi) {
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, null)
    }
    var isLet = this.isLet();
    if (this.type === types$1._var || this.type === types$1._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types$1._in) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
          } else { node.await = awaitAt > -1; }
        }
        return this.parseForIn(node, init$1)
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init$1)
    }
    var startsWithLet = this.isContextual("let"), isForOf = false;
    var containsEsc = this.containsEsc;
    var refDestructuringErrors = new DestructuringErrors;
    var initPos = this.start;
    var init = awaitAt > -1
      ? this.parseExprSubscripts(refDestructuringErrors, "await")
      : this.parseExpression(true, refDestructuringErrors);
    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (awaitAt > -1) { // implies `ecmaVersion >= 9` (see declaration of awaitAt)
        if (this.type === types$1._in) { this.unexpected(awaitAt); }
        node.await = true;
      } else if (isForOf && this.options.ecmaVersion >= 8) {
        if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") { this.unexpected(); }
        else if (this.options.ecmaVersion >= 9) { node.await = false; }
      }
      if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLValPattern(init);
      return this.parseForIn(node, init)
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init)
  };

  pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
  };

  pp$8.parseIfStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    // allow function declarations in branches, but only in non-strict mode
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement")
  };

  pp$8.parseReturnStatement = function(node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
      { this.raise(this.start, "'return' outside of function"); }
    this.next();

    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.

    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
    else { node.argument = this.parseExpression(); this.semicolon(); }
    return this.finishNode(node, "ReturnStatement")
  };

  pp$8.parseSwitchStatement = function(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types$1.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);

    // Statements under must be grouped (by label) in SwitchCase
    // nodes. `cur` is used to keep the node that we are currently
    // adding statements to.

    var cur;
    for (var sawDefault = false; this.type !== types$1.braceR;) {
      if (this.type === types$1._case || this.type === types$1._default) {
        var isCase = this.type === types$1._case;
        if (cur) { this.finishNode(cur, "SwitchCase"); }
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types$1.colon);
      } else {
        if (!cur) { this.unexpected(); }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) { this.finishNode(cur, "SwitchCase"); }
    this.next(); // Closing brace
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement")
  };

  pp$8.parseThrowStatement = function(node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement")
  };

  // Reused empty array added for node fields that are always empty.

  var empty$1 = [];

  pp$8.parseCatchClauseParam = function() {
    var param = this.parseBindingAtom();
    var simple = param.type === "Identifier";
    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
    this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
    this.expect(types$1.parenR);

    return param
  };

  pp$8.parseTryStatement = function(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types$1._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types$1.parenL)) {
        clause.param = this.parseCatchClauseParam();
      } else {
        if (this.options.ecmaVersion < 10) { this.unexpected(); }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer)
      { this.raise(node.start, "Missing catch or finally clause"); }
    return this.finishNode(node, "TryStatement")
  };

  pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
    this.next();
    this.parseVar(node, false, kind, allowMissingInitializer);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration")
  };

  pp$8.parseWhileStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement")
  };

  pp$8.parseWithStatement = function(node) {
    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement")
  };

  pp$8.parseEmptyStatement = function(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement")
  };

  pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
      {
      var label = list[i$1];

      if (label.name === maybeName)
        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    } }
    var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
    for (var i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart === node.start) {
        // Update information about previous labels on this node
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else { break }
    }
    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement")
  };

  pp$8.parseExpressionStatement = function(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement")
  };

  // Parse a semicolon-enclosed block of statements, handling `"use
  // strict"` declarations when `allowStrict` is true (used for
  // function bodies).

  pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
    if ( node === void 0 ) node = this.startNode();

    node.body = [];
    this.expect(types$1.braceL);
    if (createNewLexicalScope) { this.enterScope(0); }
    while (this.type !== types$1.braceR) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    if (exitStrict) { this.strict = false; }
    this.next();
    if (createNewLexicalScope) { this.exitScope(); }
    return this.finishNode(node, "BlockStatement")
  };

  // Parse a regular `for` loop. The disambiguation code in
  // `parseStatement` will already have parsed the init statement or
  // expression.

  pp$8.parseFor = function(node, init) {
    node.init = init;
    this.expect(types$1.semi);
    node.test = this.type === types$1.semi ? null : this.parseExpression();
    this.expect(types$1.semi);
    node.update = this.type === types$1.parenR ? null : this.parseExpression();
    this.expect(types$1.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement")
  };

  // Parse a `for`/`in` and `for`/`of` loop, which are almost
  // same from parser's perspective.

  pp$8.parseForIn = function(node, init) {
    var isForIn = this.type === types$1._in;
    this.next();

    if (
      init.type === "VariableDeclaration" &&
      init.declarations[0].init != null &&
      (
        !isForIn ||
        this.options.ecmaVersion < 8 ||
        this.strict ||
        init.kind !== "var" ||
        init.declarations[0].id.type !== "Identifier"
      )
    ) {
      this.raise(
        init.start,
        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
      );
    }
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types$1.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
  };

  // Parse a list of variable declarations.

  pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types$1.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
        this.unexpected();
      } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types$1.comma)) { break }
    }
    return node
  };

  pp$8.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };

  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

  // Parse a function declaration or literal (depending on the
  // `statement & FUNC_STATEMENT`).

  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
  pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
        { this.unexpected(); }
      node.generator = this.eat(types$1.star);
    }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    if (statement & FUNC_STATEMENT) {
      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();
      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
        // If it is a regular function declaration in sloppy mode, then it is
        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
        // mode depends on properties of the current scope (see
        // treatFunctionsAsVar).
        { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
    }

    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));

    if (!(statement & FUNC_STATEMENT))
      { node.id = this.type === types$1.name ? this.parseIdent() : null; }

    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false, forInit);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
  };

  pp$8.parseFunctionParams = function(node) {
    this.expect(types$1.parenL);
    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };

  // Parse a class declaration or literal (depending on the
  // `isStatement` parameter).

  pp$8.parseClass = function(node, isStatement) {
    this.next();

    // ecma-262 14.6 Class Definitions
    // A class definition is always strict mode code.
    var oldStrict = this.strict;
    this.strict = true;

    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var privateNameMap = this.enterClassBody();
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types$1.braceL);
    while (this.type !== types$1.braceR) {
      var element = this.parseClassElement(node.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) { this.raiseRecoverable(element.start, "Duplicate constructor in the same class"); }
          hadConstructor = true;
        } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
          this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
        }
      }
    }
    this.strict = oldStrict;
    this.next();
    node.body = this.finishNode(classBody, "ClassBody");
    this.exitClassBody();
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
  };

  pp$8.parseClassElement = function(constructorAllowsSuper) {
    if (this.eat(types$1.semi)) { return null }

    var ecmaVersion = this.options.ecmaVersion;
    var node = this.startNode();
    var keyName = "";
    var isGenerator = false;
    var isAsync = false;
    var kind = "method";
    var isStatic = false;

    if (this.eatContextual("static")) {
      // Parse static init block
      if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
        this.parseClassStaticBlock(node);
        return node
      }
      if (this.isClassElementNameStart() || this.type === types$1.star) {
        isStatic = true;
      } else {
        keyName = "static";
      }
    }
    node.static = isStatic;
    if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
      if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
        isAsync = true;
      } else {
        keyName = "async";
      }
    }
    if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
      isGenerator = true;
    }
    if (!keyName && !isAsync && !isGenerator) {
      var lastValue = this.value;
      if (this.eatContextual("get") || this.eatContextual("set")) {
        if (this.isClassElementNameStart()) {
          kind = lastValue;
        } else {
          keyName = lastValue;
        }
      }
    }

    // Parse element name
    if (keyName) {
      // 'async', 'get', 'set', or 'static' were not a keyword contextually.
      // The last token is any of those. Make it the element name.
      node.computed = false;
      node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
      node.key.name = keyName;
      this.finishNode(node.key, "Identifier");
    } else {
      this.parseClassElementName(node);
    }

    // Parse element value
    if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
      var isConstructor = !node.static && checkKeyName(node, "constructor");
      var allowsDirectSuper = isConstructor && constructorAllowsSuper;
      // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
      if (isConstructor && kind !== "method") { this.raise(node.key.start, "Constructor can't have get/set modifier"); }
      node.kind = isConstructor ? "constructor" : kind;
      this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
    } else {
      this.parseClassField(node);
    }

    return node
  };

  pp$8.isClassElementNameStart = function() {
    return (
      this.type === types$1.name ||
      this.type === types$1.privateId ||
      this.type === types$1.num ||
      this.type === types$1.string ||
      this.type === types$1.bracketL ||
      this.type.keyword
    )
  };

  pp$8.parseClassElementName = function(element) {
    if (this.type === types$1.privateId) {
      if (this.value === "constructor") {
        this.raise(this.start, "Classes can't have an element named '#constructor'");
      }
      element.computed = false;
      element.key = this.parsePrivateIdent();
    } else {
      this.parsePropertyName(element);
    }
  };

  pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    // Check key and flags
    var key = method.key;
    if (method.kind === "constructor") {
      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
    } else if (method.static && checkKeyName(method, "prototype")) {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }

    // Parse value
    var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);

    // Check value
    if (method.kind === "get" && value.params.length !== 0)
      { this.raiseRecoverable(value.start, "getter should have no params"); }
    if (method.kind === "set" && value.params.length !== 1)
      { this.raiseRecoverable(value.start, "setter should have exactly one param"); }
    if (method.kind === "set" && value.params[0].type === "RestElement")
      { this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"); }

    return this.finishNode(method, "MethodDefinition")
  };

  pp$8.parseClassField = function(field) {
    if (checkKeyName(field, "constructor")) {
      this.raise(field.key.start, "Classes can't have a field named 'constructor'");
    } else if (field.static && checkKeyName(field, "prototype")) {
      this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
    }

    if (this.eat(types$1.eq)) {
      // To raise SyntaxError if 'arguments' exists in the initializer.
      var scope = this.currentThisScope();
      var inClassFieldInit = scope.inClassFieldInit;
      scope.inClassFieldInit = true;
      field.value = this.parseMaybeAssign();
      scope.inClassFieldInit = inClassFieldInit;
    } else {
      field.value = null;
    }
    this.semicolon();

    return this.finishNode(field, "PropertyDefinition")
  };

  pp$8.parseClassStaticBlock = function(node) {
    node.body = [];

    var oldLabels = this.labels;
    this.labels = [];
    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
    while (this.type !== types$1.braceR) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    this.next();
    this.exitScope();
    this.labels = oldLabels;

    return this.finishNode(node, "StaticBlock")
  };

  pp$8.parseClassId = function(node, isStatement) {
    if (this.type === types$1.name) {
      node.id = this.parseIdent();
      if (isStatement)
        { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
    } else {
      if (isStatement === true)
        { this.unexpected(); }
      node.id = null;
    }
  };

  pp$8.parseClassSuper = function(node) {
    node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
  };

  pp$8.enterClassBody = function() {
    var element = {declared: Object.create(null), used: []};
    this.privateNameStack.push(element);
    return element.declared
  };

  pp$8.exitClassBody = function() {
    var ref = this.privateNameStack.pop();
    var declared = ref.declared;
    var used = ref.used;
    if (!this.options.checkPrivateFields) { return }
    var len = this.privateNameStack.length;
    var parent = len === 0 ? null : this.privateNameStack[len - 1];
    for (var i = 0; i < used.length; ++i) {
      var id = used[i];
      if (!hasOwn(declared, id.name)) {
        if (parent) {
          parent.used.push(id);
        } else {
          this.raiseRecoverable(id.start, ("Private field '#" + (id.name) + "' must be declared in an enclosing class"));
        }
      }
    }
  };

  function isPrivateNameConflicted(privateNameMap, element) {
    var name = element.key.name;
    var curr = privateNameMap[name];

    var next = "true";
    if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
      next = (element.static ? "s" : "i") + element.kind;
    }

    // `class { get #a(){}; static set #a(_){} }` is also conflict.
    if (
      curr === "iget" && next === "iset" ||
      curr === "iset" && next === "iget" ||
      curr === "sget" && next === "sset" ||
      curr === "sset" && next === "sget"
    ) {
      privateNameMap[name] = "true";
      return false
    } else if (!curr) {
      privateNameMap[name] = next;
      return false
    } else {
      return true
    }
  }

  function checkKeyName(node, name) {
    var computed = node.computed;
    var key = node.key;
    return !computed && (
      key.type === "Identifier" && key.name === name ||
      key.type === "Literal" && key.value === name
    )
  }

  // Parses module export declaration.

  pp$8.parseExportAllDeclaration = function(node, exports) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node.exported = this.parseModuleExportName();
        this.checkExport(exports, node.exported, this.lastTokStart);
      } else {
        node.exported = null;
      }
    }
    this.expectContextual("from");
    if (this.type !== types$1.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    if (this.options.ecmaVersion >= 16)
      { node.attributes = this.parseWithClause(); }
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  };

  pp$8.parseExport = function(node, exports) {
    this.next();
    // export * from '...'
    if (this.eat(types$1.star)) {
      return this.parseExportAllDeclaration(node, exports)
    }
    if (this.eat(types$1._default)) { // export default ...
      this.checkExport(exports, "default", this.lastTokStart);
      node.declaration = this.parseExportDefaultDeclaration();
      return this.finishNode(node, "ExportDefaultDeclaration")
    }
    // export var|const|let|function|class ...
    if (this.shouldParseExportStatement()) {
      node.declaration = this.parseExportDeclaration(node);
      if (node.declaration.type === "VariableDeclaration")
        { this.checkVariableExport(exports, node.declaration.declarations); }
      else
        { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
      node.specifiers = [];
      node.source = null;
    } else { // export { x, y as z } [from '...']
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers(exports);
      if (this.eatContextual("from")) {
        if (this.type !== types$1.string) { this.unexpected(); }
        node.source = this.parseExprAtom();
        if (this.options.ecmaVersion >= 16)
          { node.attributes = this.parseWithClause(); }
      } else {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          // check for keywords used as local names
          var spec = list[i];

          this.checkUnreserved(spec.local);
          // check if export is defined
          this.checkLocalExport(spec.local);

          if (spec.local.type === "Literal") {
            this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
          }
        }

        node.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration")
  };

  pp$8.parseExportDeclaration = function(node) {
    return this.parseStatement(null)
  };

  pp$8.parseExportDefaultDeclaration = function() {
    var isAsync;
    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync)
    } else if (this.type === types$1._class) {
      var cNode = this.startNode();
      return this.parseClass(cNode, "nullableID")
    } else {
      var declaration = this.parseMaybeAssign();
      this.semicolon();
      return declaration
    }
  };

  pp$8.checkExport = function(exports, name, pos) {
    if (!exports) { return }
    if (typeof name !== "string")
      { name = name.type === "Identifier" ? name.name : name.value; }
    if (hasOwn(exports, name))
      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
    exports[name] = true;
  };

  pp$8.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if (type === "Identifier")
      { this.checkExport(exports, pat, pat.start); }
    else if (type === "ObjectPattern")
      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
        {
          var prop = list[i];

          this.checkPatternExport(exports, prop);
        } }
    else if (type === "ArrayPattern")
      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];

          if (elt) { this.checkPatternExport(exports, elt); }
      } }
    else if (type === "Property")
      { this.checkPatternExport(exports, pat.value); }
    else if (type === "AssignmentPattern")
      { this.checkPatternExport(exports, pat.left); }
    else if (type === "RestElement")
      { this.checkPatternExport(exports, pat.argument); }
  };

  pp$8.checkVariableExport = function(exports, decls) {
    if (!exports) { return }
    for (var i = 0, list = decls; i < list.length; i += 1)
      {
      var decl = list[i];

      this.checkPatternExport(exports, decl.id);
    }
  };

  pp$8.shouldParseExportStatement = function() {
    return this.type.keyword === "var" ||
      this.type.keyword === "const" ||
      this.type.keyword === "class" ||
      this.type.keyword === "function" ||
      this.isLet() ||
      this.isAsyncFunction()
  };

  // Parses a comma-separated list of module exports.

  pp$8.parseExportSpecifier = function(exports) {
    var node = this.startNode();
    node.local = this.parseModuleExportName();

    node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
    this.checkExport(
      exports,
      node.exported,
      node.exported.start
    );

    return this.finishNode(node, "ExportSpecifier")
  };

  pp$8.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    // export { x, y as z } [from '...']
    this.expect(types$1.braceL);
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR)) { break }
      } else { first = false; }

      nodes.push(this.parseExportSpecifier(exports));
    }
    return nodes
  };

  // Parses import declaration.

  pp$8.parseImport = function(node) {
    this.next();

    // import '...'
    if (this.type === types$1.string) {
      node.specifiers = empty$1;
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
    }
    if (this.options.ecmaVersion >= 16)
      { node.attributes = this.parseWithClause(); }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration")
  };

  // Parses a comma-separated list of module imports.

  pp$8.parseImportSpecifier = function() {
    var node = this.startNode();
    node.imported = this.parseModuleExportName();

    if (this.eatContextual("as")) {
      node.local = this.parseIdent();
    } else {
      this.checkUnreserved(node.imported);
      node.local = node.imported;
    }
    this.checkLValSimple(node.local, BIND_LEXICAL);

    return this.finishNode(node, "ImportSpecifier")
  };

  pp$8.parseImportDefaultSpecifier = function() {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLValSimple(node.local, BIND_LEXICAL);
    return this.finishNode(node, "ImportDefaultSpecifier")
  };

  pp$8.parseImportNamespaceSpecifier = function() {
    var node = this.startNode();
    this.next();
    this.expectContextual("as");
    node.local = this.parseIdent();
    this.checkLValSimple(node.local, BIND_LEXICAL);
    return this.finishNode(node, "ImportNamespaceSpecifier")
  };

  pp$8.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types$1.name) {
      nodes.push(this.parseImportDefaultSpecifier());
      if (!this.eat(types$1.comma)) { return nodes }
    }
    if (this.type === types$1.star) {
      nodes.push(this.parseImportNamespaceSpecifier());
      return nodes
    }
    this.expect(types$1.braceL);
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR)) { break }
      } else { first = false; }

      nodes.push(this.parseImportSpecifier());
    }
    return nodes
  };

  pp$8.parseWithClause = function() {
    var nodes = [];
    if (!this.eat(types$1._with)) {
      return nodes
    }
    this.expect(types$1.braceL);
    var attributeKeys = {};
    var first = true;
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR)) { break }
      } else { first = false; }

      var attr = this.parseImportAttribute();
      var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
      if (hasOwn(attributeKeys, keyName))
        { this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'"); }
      attributeKeys[keyName] = true;
      nodes.push(attr);
    }
    return nodes
  };

  pp$8.parseImportAttribute = function() {
    var node = this.startNode();
    node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    this.expect(types$1.colon);
    if (this.type !== types$1.string) {
      this.unexpected();
    }
    node.value = this.parseExprAtom();
    return this.finishNode(node, "ImportAttribute")
  };

  pp$8.parseModuleExportName = function() {
    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
      var stringLiteral = this.parseLiteral(this.value);
      if (loneSurrogate.test(stringLiteral.value)) {
        this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
      }
      return stringLiteral
    }
    return this.parseIdent(true)
  };

  // Set `ExpressionStatement#directive` property for directive prologues.
  pp$8.adaptDirectivePrologue = function(statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
      statements[i].directive = statements[i].expression.raw.slice(1, -1);
    }
  };
  pp$8.isDirectiveCandidate = function(statement) {
    return (
      this.options.ecmaVersion >= 5 &&
      statement.type === "ExpressionStatement" &&
      statement.expression.type === "Literal" &&
      typeof statement.expression.value === "string" &&
      // Reject parenthesized strings.
      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
    )
  };

  var pp$7 = Parser.prototype;

  // Convert existing expression atom to assignable pattern
  // if possible.

  pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) {
      switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await")
          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
        break

      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break

      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];

        this.toAssignable(prop, isBinding);
          // Early error:
          //   AssignmentRestProperty[Yield, Await] :
          //     `...` DestructuringAssignmentTarget[Yield, Await]
          //
          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
          if (
            prop.type === "RestElement" &&
            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
          ) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break

      case "Property":
        // AssignmentProperty has type === "Property"
        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
        this.toAssignable(node.value, isBinding);
        break

      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        this.toAssignableList(node.elements, isBinding);
        break

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern")
          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
        break

      case "AssignmentExpression":
        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break

      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break

      case "MemberExpression":
        if (!isBinding) { break }

      default:
        this.raise(node.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
    return node
  };

  // Convert list of expression atoms to binding list.

  pp$7.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt) { this.toAssignable(elt, isBinding); }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
        { this.unexpected(last.argument.start); }
    }
    return exprList
  };

  // Parses spread element.

  pp$7.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement")
  };

  pp$7.parseRestBinding = function() {
    var node = this.startNode();
    this.next();

    // RestElement inside of a function parameter must be an identifier
    if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
      { this.unexpected(); }

    node.argument = this.parseBindingAtom();

    return this.finishNode(node, "RestElement")
  };

  // Parses lvalue (assignable) atom.

  pp$7.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern")

      case types$1.braceL:
        return this.parseObj(true)
      }
    }
    return this.parseIdent()
  };

  pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) { first = false; }
      else { this.expect(types$1.comma); }
      if (allowEmpty && this.type === types$1.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
        break
      } else if (this.type === types$1.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types$1.comma) { this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"); }
        this.expect(close);
        break
      } else {
        elts.push(this.parseAssignableListItem(allowModifiers));
      }
    }
    return elts
  };

  pp$7.parseAssignableListItem = function(allowModifiers) {
    var elem = this.parseMaybeDefault(this.start, this.startLoc);
    this.parseBindingListItem(elem);
    return elem
  };

  pp$7.parseBindingListItem = function(param) {
    return param
  };

  // Parses assignment pattern around given atom if possible.

  pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern")
  };

  // The following three functions all verify that a node is an lvalue —
  // something that can be bound, or assigned to. In order to do so, they perform
  // a variety of checks:
  //
  // - Check that none of the bound/assigned-to identifiers are reserved words.
  // - Record name declarations for bindings in the appropriate scope.
  // - Check duplicate argument names, if checkClashes is set.
  //
  // If a complex binding pattern is encountered (e.g., object and array
  // destructuring), the entire pattern is recursively checked.
  //
  // There are three versions of checkLVal*() appropriate for different
  // circumstances:
  //
  // - checkLValSimple() shall be used if the syntactic construct supports
  //   nothing other than identifiers and member expressions. Parenthesized
  //   expressions are also correctly handled. This is generally appropriate for
  //   constructs for which the spec says
  //
  //   > It is a Syntax Error if AssignmentTargetType of [the production] is not
  //   > simple.
  //
  //   It is also appropriate for checking if an identifier is valid and not
  //   defined elsewhere, like import declarations or function/class identifiers.
  //
  //   Examples where this is used include:
  //     a += …;
  //     import a from '…';
  //   where a is the node to be checked.
  //
  // - checkLValPattern() shall be used if the syntactic construct supports
  //   anything checkLValSimple() supports, as well as object and array
  //   destructuring patterns. This is generally appropriate for constructs for
  //   which the spec says
  //
  //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
  //   > an ArrayLiteral and AssignmentTargetType of [the production] is not
  //   > simple.
  //
  //   Examples where this is used include:
  //     (a = …);
  //     const a = …;
  //     try { … } catch (a) { … }
  //   where a is the node to be checked.
  //
  // - checkLValInnerPattern() shall be used if the syntactic construct supports
  //   anything checkLValPattern() supports, as well as default assignment
  //   patterns, rest elements, and other constructs that may appear within an
  //   object or array destructuring pattern.
  //
  //   As a special case, function parameters also use checkLValInnerPattern(),
  //   as they also support defaults and rest constructs.
  //
  // These functions deliberately support both assignment and binding constructs,
  // as the logic for both is exceedingly similar. If the node is the target of
  // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
  // should be set to the appropriate BIND_* constant, like BIND_VAR or
  // BIND_LEXICAL.
  //
  // If the function is called with a non-BIND_NONE bindingType, then
  // additionally a checkClashes object may be specified to allow checking for
  // duplicate argument names. checkClashes is ignored if the provided construct
  // is an assignment (i.e., bindingType is BIND_NONE).

  pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    var isBind = bindingType !== BIND_NONE;

    switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
        { this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let")
          { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name))
            { this.raiseRecoverable(expr.start, "Argument name clash"); }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
      }
      break

    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break

    case "MemberExpression":
      if (isBind) { this.raiseRecoverable(expr.start, "Binding member expression"); }
      break

    case "ParenthesizedExpression":
      if (isBind) { this.raiseRecoverable(expr.start, "Binding parenthesized expression"); }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes)

    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
    }
  };

  pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
        var prop = list[i];

      this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

      if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }
      }
      break

    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
    }
  };

  pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    switch (expr.type) {
    case "Property":
      // AssignmentProperty has type === "Property"
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break

    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break

    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break

    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
    }
  };

  // The algorithm used to determine whether a regexp can appear at a
  // given point in the program is loosely based on sweet.js' approach.
  // See https://github.com/mozilla/sweet.js/wiki/design


  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };

  var types = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };

  var pp$6 = Parser.prototype;

  pp$6.initialContext = function() {
    return [types.b_stat]
  };

  pp$6.curContext = function() {
    return this.context[this.context.length - 1]
  };

  pp$6.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types.f_expr || parent === types.f_stat)
      { return true }
    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
      { return !parent.isExpr }

    // The check for `tt.name && exprAllowed` detects whether we are
    // after a `yield` or `of` construct. See the `updateContext` for
    // `tt.name`.
    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
      { return true }
    if (prevType === types$1.braceL)
      { return parent === types.b_stat }
    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
      { return false }
    return !this.exprAllowed
  };

  pp$6.inGeneratorContext = function() {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if (context.token === "function")
        { return context.generator }
    }
    return false
  };

  pp$6.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types$1.dot)
      { this.exprAllowed = false; }
    else if (update = type.updateContext)
      { update.call(this, prevType); }
    else
      { this.exprAllowed = type.beforeExpr; }
  };

  // Used to handle edge cases when token context could not be inferred correctly during tokenization phase

  pp$6.overrideContext = function(tokenCtx) {
    if (this.curContext() !== tokenCtx) {
      this.context[this.context.length - 1] = tokenCtx;
    }
  };

  // Token-specific context update code

  types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return
    }
    var out = this.context.pop();
    if (out === types.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };

  types$1.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
    this.exprAllowed = true;
  };

  types$1.dollarBraceL.updateContext = function() {
    this.context.push(types.b_tmpl);
    this.exprAllowed = true;
  };

  types$1.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
    this.context.push(statementParens ? types.p_stat : types.p_expr);
    this.exprAllowed = true;
  };

  types$1.incDec.updateContext = function() {
    // tokExprAllowed stays unchanged
  };

  types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types$1._else &&
        !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
        !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
        !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
      { this.context.push(types.f_expr); }
    else
      { this.context.push(types.f_stat); }
    this.exprAllowed = false;
  };

  types$1.colon.updateContext = function() {
    if (this.curContext().token === "function") { this.context.pop(); }
    this.exprAllowed = true;
  };

  types$1.backQuote.updateContext = function() {
    if (this.curContext() === types.q_tmpl)
      { this.context.pop(); }
    else
      { this.context.push(types.q_tmpl); }
    this.exprAllowed = false;
  };

  types$1.star.updateContext = function(prevType) {
    if (prevType === types$1._function) {
      var index = this.context.length - 1;
      if (this.context[index] === types.f_expr)
        { this.context[index] = types.f_expr_gen; }
      else
        { this.context[index] = types.f_gen; }
    }
    this.exprAllowed = true;
  };

  types$1.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
      if (this.value === "of" && !this.exprAllowed ||
          this.value === "yield" && this.inGeneratorContext())
        { allowed = true; }
    }
    this.exprAllowed = allowed;
  };

  // A recursive descent parser operates by defining functions for all
  // syntactic elements, and recursively calling those, each function
  // advancing the input stream and returning an AST node. Precedence
  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
  // instead of `(!x)[1]` is handled by the fact that the parser
  // function that parses unary prefix operators is called first, and
  // in turn calls the function that parses `[]` subscripts — that
  // way, it'll receive the node for `x[1]` already parsed, and wraps
  // *that* in the unary operator node.
  //
  // Acorn uses an [operator precedence parser][opp] to handle binary
  // operator precedence, because it is much more compact than using
  // the technique outlined above, which uses different, nesting
  // functions to specify precedence, for all of the ten binary
  // precedence levels that JavaScript defines.
  //
  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser


  var pp$5 = Parser.prototype;

  // Check if property name clashes with already added.
  // Object/class getters and setters are not allowed to clash —
  // either with each other or with an init property — and in
  // strict mode, init properties are also not allowed to be repeated.

  pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
      { return }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
      { return }
    var key = prop.key;
    var name;
    switch (key.type) {
    case "Identifier": name = key.name; break
    case "Literal": name = String(key.value); break
    default: return
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0) {
              refDestructuringErrors.doubleProto = key.start;
            }
          } else {
            this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
          }
        }
        propHash.proto = true;
      }
      return
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition)
        { this.raiseRecoverable(key.start, "Redefinition of property"); }
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };

  // ### Expression parsing

  // These nest, from the most general expression type at the top to
  // 'atomic', nondivisible expression types at the bottom. Most of
  // the functions will simply let the function(s) below them parse,
  // and, *if* the syntactic construct they handle is present, wrap
  // the AST node that the inner parser gave them in another node.

  // Parse a full expression. The optional arguments are used to
  // forbid the `in` operator (in for loops initalization expressions)
  // and provide reference for storing '=' operator inside shorthand
  // property assignment in contexts where both object expression
  // and object pattern might appear (so it's possible to raise
  // delayed syntax error at correct position).

  pp$5.parseExpression = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
    if (this.type === types$1.comma) {
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
      return this.finishNode(node, "SequenceExpression")
    }
    return expr
  };

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) { return this.parseYield(forInit) }
      // The tokenizer will assume an expression is allowed after
      // `yield`, but this isn't that kind of yield
      else { this.exprAllowed = false; }
    }

    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      oldDoubleProto = refDestructuringErrors.doubleProto;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors;
      ownDestructuringErrors = true;
    }

    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types$1.parenL || this.type === types$1.name) {
      this.potentialArrowAt = this.start;
      this.potentialArrowInForAwait = forInit === "await";
    }
    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
    if (this.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      if (this.type === types$1.eq)
        { left = this.toAssignable(left, false, refDestructuringErrors); }
      if (!ownDestructuringErrors) {
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      }
      if (refDestructuringErrors.shorthandAssign >= left.start)
        { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
      if (this.type === types$1.eq)
        { this.checkLValPattern(left); }
      else
        { this.checkLValSimple(left); }
      node.left = left;
      this.next();
      node.right = this.parseMaybeAssign(forInit);
      if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
      return this.finishNode(node, "AssignmentExpression")
    } else {
      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
    }
    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
    return left
  };

  // Parse a ternary conditional (`?:`) operator.

  pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(forInit, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    if (this.eat(types$1.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types$1.colon);
      node.alternate = this.parseMaybeAssign(forInit);
      return this.finishNode(node, "ConditionalExpression")
    }
    return expr
  };

  // Start the precedence parser.

  pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)
  };

  // Parse binary operators with the operator precedence parsing
  // algorithm. `left` is the left-hand side of the operator.
  // `minPrec` provides context that allows the function to stop and
  // defer further parser to one of its callers when it encounters an
  // operator that has a lower precedence than the set it is parsing.

  pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
    var prec = this.type.binop;
    if (prec != null && (!forInit || this.type !== types$1._in)) {
      if (prec > minPrec) {
        var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
        var coalesce = this.type === types$1.coalesce;
        if (coalesce) {
          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
          prec = types$1.logicalAND.binop;
        }
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
        if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
        }
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
      }
    }
    return left
  };

  pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
  };

  // Parse unary operators, both prefix and postfix.

  pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && this.canAwait) {
      expr = this.parseAwait(forInit);
      sawUnary = true;
    } else if (this.type.prefix) {
      var node = this.startNode(), update = this.type === types$1.incDec;
      node.operator = this.value;
      node.prefix = true;
      this.next();
      node.argument = this.parseMaybeUnary(null, true, update, forInit);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) { this.checkLValSimple(node.argument); }
      else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument))
        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
      else if (node.operator === "delete" && isPrivateFieldAccess(node.argument))
        { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
      else { sawUnary = true; }
      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else if (!sawUnary && this.type === types$1.privateId) {
      if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) { this.unexpected(); }
      expr = this.parsePrivateIdent();
      // only could be private fields in 'in', such as #x in obj
      if (this.type !== types$1._in) { this.unexpected(); }
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value;
        node$1.prefix = false;
        node$1.argument = expr;
        this.checkLValSimple(expr);
        this.next();
        expr = this.finishNode(node$1, "UpdateExpression");
      }
    }

    if (!incDec && this.eat(types$1.starstar)) {
      if (sawUnary)
        { this.unexpected(this.lastTokStart); }
      else
        { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false) }
    } else {
      return expr
    }
  };

  function isLocalVariableAccess(node) {
    return (
      node.type === "Identifier" ||
      node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression)
    )
  }

  function isPrivateFieldAccess(node) {
    return (
      node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" ||
      node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) ||
      node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression)
    )
  }

  // Parse call, dot, and `[]`-subscript expressions.

  pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors, forInit);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
      { return expr }
    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
      if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }
    }
    return result
  };

  pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
        this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
        this.potentialArrowAt === base.start;
    var optionalChained = false;

    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);

      if (element.optional) { optionalChained = true; }
      if (element === base || element.type === "ArrowFunctionExpression") {
        if (optionalChained) {
          var chainNode = this.startNodeAt(startPos, startLoc);
          chainNode.expression = element;
          element = this.finishNode(chainNode, "ChainExpression");
        }
        return element
      }

      base = element;
    }
  };

  pp$5.shouldParseAsyncArrow = function() {
    return !this.canInsertSemicolon() && this.eat(types$1.arrow)
  };

  pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)
  };

  pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
    var optionalSupported = this.options.ecmaVersion >= 11;
    var optional = optionalSupported && this.eat(types$1.questionDot);
    if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

    var computed = this.eat(types$1.bracketL);
    if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      if (computed) {
        node.property = this.parseExpression();
        this.expect(types$1.bracketR);
      } else if (this.type === types$1.privateId && base.type !== "Super") {
        node.property = this.parsePrivateIdent();
      } else {
        node.property = this.parseIdent(this.options.allowReserved !== "never");
      }
      node.computed = !!computed;
      if (optionalSupported) {
        node.optional = optional;
      }
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types$1.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0)
          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit)
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      if (optionalSupported) {
        node$1.optional = optional;
      }
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types$1.backQuote) {
      if (optional || optionalChained) {
        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      }
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({isTagged: true});
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base
  };

  // Parse an atomic expression — either a single token that is an
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
    // If a division operator appears in an expression position, the
    // tokenizer got confused, and we force it to read a regexp instead.
    if (this.type === types$1.slash) { this.readRegexp(); }

    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
    case types$1._super:
      if (!this.allowSuper)
        { this.raise(this.start, "'super' keyword outside a method"); }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper)
        { this.raise(node.start, "super() call outside constructor of a subclass"); }
      // The `super` keyword can appear at below:
      // SuperProperty:
      //     super [ Expression ]
      //     super . IdentifierName
      // SuperCall:
      //     super ( Arguments )
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
        { this.unexpected(); }
      return this.finishNode(node, "Super")

    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression")

    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow))
          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
            (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
            { this.unexpected(); }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
        }
      }
      return id

    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {pattern: value.pattern, flags: value.flags};
      return node

    case types$1.num: case types$1.string:
      return this.parseLiteral(this.value)

    case types$1._null: case types$1._true: case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal")

    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
          { refDestructuringErrors.parenthesizedAssign = start; }
        if (refDestructuringErrors.parenthesizedBind < 0)
          { refDestructuringErrors.parenthesizedBind = start; }
      }
      return expr

    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression")

    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors)

    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0)

    case types$1._class:
      return this.parseClass(this.startNode(), false)

    case types$1._new:
      return this.parseNew()

    case types$1.backQuote:
      return this.parseTemplate()

    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew)
      } else {
        return this.unexpected()
      }

    default:
      return this.parseExprAtomDefault()
    }
  };

  pp$5.parseExprAtomDefault = function() {
    this.unexpected();
  };

  pp$5.parseExprImport = function(forNew) {
    var node = this.startNode();

    // Consume `import` as an identifier for `import.meta`.
    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
    this.next();

    if (this.type === types$1.parenL && !forNew) {
      return this.parseDynamicImport(node)
    } else if (this.type === types$1.dot) {
      var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
      meta.name = "import";
      node.meta = this.finishNode(meta, "Identifier");
      return this.parseImportMeta(node)
    } else {
      this.unexpected();
    }
  };

  pp$5.parseDynamicImport = function(node) {
    this.next(); // skip `(`

    // Parse node.source.
    node.source = this.parseMaybeAssign();

    if (this.options.ecmaVersion >= 16) {
      if (!this.eat(types$1.parenR)) {
        this.expect(types$1.comma);
        if (!this.afterTrailingComma(types$1.parenR)) {
          node.options = this.parseMaybeAssign();
          if (!this.eat(types$1.parenR)) {
            this.expect(types$1.comma);
            if (!this.afterTrailingComma(types$1.parenR)) {
              this.unexpected();
            }
          }
        } else {
          node.options = null;
        }
      } else {
        node.options = null;
      }
    } else {
      // Verify ending.
      if (!this.eat(types$1.parenR)) {
        var errorPos = this.start;
        if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
          this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        } else {
          this.unexpected(errorPos);
        }
      }
    }

    return this.finishNode(node, "ImportExpression")
  };

  pp$5.parseImportMeta = function(node) {
    this.next(); // skip `.`

    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);

    if (node.property.name !== "meta")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
    if (containsEsc)
      { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
    if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
      { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

    return this.finishNode(node, "MetaProperty")
  };

  pp$5.parseLiteral = function(value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
    this.next();
    return this.finishNode(node, "Literal")
  };

  pp$5.parseParenExpression = function() {
    this.expect(types$1.parenL);
    var val = this.parseExpression();
    this.expect(types$1.parenR);
    return val
  };

  pp$5.shouldParseArrow = function(exprList) {
    return !this.canInsertSemicolon()
  };

  pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();

      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      // Do not save awaitIdentPos to allow checking awaits nested in parameters
      while (this.type !== types$1.parenR) {
        first ? first = false : this.expect(types$1.comma);
        if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
          lastIsComma = true;
          break
        } else if (this.type === types$1.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types$1.comma) {
            this.raiseRecoverable(
              this.start,
              "Comma is not permitted after the rest element"
            );
          }
          break
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
      this.expect(types$1.parenR);

      if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList, forInit)
      }

      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
      if (spreadStart) { this.unexpected(spreadStart); }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }

    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression")
    } else {
      return val
    }
  };

  pp$5.parseParenItem = function(item) {
    return item
  };

  pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
  };

  // New's precedence is slightly tricky. It must allow its argument to
  // be a `[]` or dot subscript expression, but not a call — at least,
  // not without wrapping it in parentheses. Thus, it uses the noCalls
  // argument to parseSubscripts to prevent it from consuming the
  // argument list.

  var empty = [];

  pp$5.parseNew = function() {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
    var node = this.startNode();
    this.next();
    if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
      var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
      meta.name = "new";
      node.meta = this.finishNode(meta, "Identifier");
      this.next();
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "target")
        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
      if (containsEsc)
        { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
      if (!this.allowNewDotTarget)
        { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
      return this.finishNode(node, "MetaProperty")
    }
    var startPos = this.start, startLoc = this.startLoc;
    node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
    if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
    else { node.arguments = empty; }
    return this.finishNode(node, "NewExpression")
  };

  // Parse template expression.

  pp$5.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged;

    var elem = this.startNode();
    if (this.type === types$1.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value.replace(/\r\n?/g, "\n"),
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types$1.backQuote;
    return this.finishNode(elem, "TemplateElement")
  };

  pp$5.parseTemplate = function(ref) {
    if ( ref === void 0 ) ref = {};
    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({isTagged: isTagged});
    node.quasis = [curElt];
    while (!curElt.tail) {
      if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
      this.expect(types$1.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types$1.braceR);
      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral")
  };

  pp$5.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
      (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  // Parse an object literal or binding pattern.

  pp$5.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = true, propHash = {};
    node.properties = [];
    this.next();
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
      } else { first = false; }

      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
      node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
  };

  pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types$1.comma) {
          this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement")
      }
      // Parse argument.
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      // To disallow trailing comma via `this.toAssignable()`.
      if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      // Finish
      return this.finishNode(prop, "SpreadElement")
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern)
        { isGenerator = this.eat(types$1.star); }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
      this.parsePropertyName(prop);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property")
  };

  pp$5.parseGetterSetter = function(prop) {
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        { this.raiseRecoverable(start, "getter should have no params"); }
      else
        { this.raiseRecoverable(start, "setter should have exactly one param"); }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
    }
  };

  pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types$1.colon)
      { this.unexpected(); }

    if (this.eat(types$1.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
      if (isPattern) { this.unexpected(); }
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc &&
               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
               (prop.key.name === "get" || prop.key.name === "set") &&
               (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
      if (isGenerator || isAsync) { this.unexpected(); }
      this.parseGetterSetter(prop);
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) { this.unexpected(); }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = startPos; }
      prop.kind = "init";
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
      } else if (this.type === types$1.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0)
          { refDestructuringErrors.shorthandAssign = this.start; }
        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
      } else {
        prop.value = this.copyNode(prop.key);
      }
      prop.shorthand = true;
    } else { this.unexpected(); }
  };

  pp$5.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types$1.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types$1.bracketR);
        return prop.key
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
  };

  // Initialize empty function node.

  pp$5.initFunction = function(node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
    if (this.options.ecmaVersion >= 8) { node.async = false; }
  };

  // Parse object or class method.

  pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.initFunction(node);
    if (this.options.ecmaVersion >= 6)
      { node.generator = isGenerator; }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

    this.expect(types$1.parenL);
    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression")
  };

  // Parse arrow function expression with given parameters.

  pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;

    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false, forInit);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression")
  };

  // Parse function body and check parameters.

  pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
    var isExpression = isArrowFunction && this.type !== types$1.braceL;
    var oldStrict = this.strict, useStrict = false;

    if (isExpression) {
      node.body = this.parseMaybeAssign(forInit);
      node.expression = true;
      this.checkParams(node, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        // If this is a strict mode function, verify that argument names
        // are not repeated, and it does not try to bind the words `eval`
        // or `arguments`.
        if (useStrict && nonSimple)
          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
      }
      // Start a new scope with regard to labels and the `inFunction`
      // flag (restore them to their old value afterwards).
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) { this.strict = true; }

      // Add the params to varDeclaredNames to ensure that an error is thrown
      // if a let/const declaration in the function clashes with one of the params.
      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
      if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }
      node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
      node.expression = false;
      this.adaptDirectivePrologue(node.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();
  };

  pp$5.isSimpleParamList = function(params) {
    for (var i = 0, list = params; i < list.length; i += 1)
      {
      var param = list[i];

      if (param.type !== "Identifier") { return false
    } }
    return true
  };

  // Checks function params for various disallowed patterns such as using "eval"
  // or "arguments" and duplicate parameters.

  pp$5.checkParams = function(node, allowDuplicates) {
    var nameHash = Object.create(null);
    for (var i = 0, list = node.params; i < list.length; i += 1)
      {
      var param = list[i];

      this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };

  // Parses a comma-separated list of expressions, and returns them as
  // an array. `close` is the token type that ends the list, and
  // `allowEmpty` can be turned on to allow subsequent commas with
  // nothing in between them to be parsed as `null` (which is needed
  // for array literals).

  pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types$1.comma);
        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
      } else { first = false; }

      var elt = (void 0);
      if (allowEmpty && this.type === types$1.comma)
        { elt = null; }
      else if (this.type === types$1.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
          { refDestructuringErrors.trailingComma = this.start; }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts
  };

  pp$5.checkUnreserved = function(ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;

    if (this.inGenerator && name === "yield")
      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
    if (this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
    if (this.currentThisScope().inClassFieldInit && name === "arguments")
      { this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"); }
    if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
      { this.raise(start, ("Cannot use " + name + " in class static initialization block")); }
    if (this.keywords.test(name))
      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
    if (this.options.ecmaVersion < 6 &&
      this.input.slice(start, end).indexOf("\\") !== -1) { return }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
      if (!this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
    }
  };

  // Parse the next token as an identifier. If `liberal` is true (used
  // when parsing properties), it will also convert keywords into
  // identifiers.

  pp$5.parseIdent = function(liberal) {
    var node = this.parseIdentNode();
    this.next(!!liberal);
    this.finishNode(node, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node);
      if (node.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = node.start; }
    }
    return node
  };

  pp$5.parseIdentNode = function() {
    var node = this.startNode();
    if (this.type === types$1.name) {
      node.name = this.value;
    } else if (this.type.keyword) {
      node.name = this.type.keyword;

      // To fix https://github.com/acornjs/acorn/issues/575
      // `class` and `function` keywords push new context into this.context.
      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
      if ((node.name === "class" || node.name === "function") &&
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
      this.type = types$1.name;
    } else {
      this.unexpected();
    }
    return node
  };

  pp$5.parsePrivateIdent = function() {
    var node = this.startNode();
    if (this.type === types$1.privateId) {
      node.name = this.value;
    } else {
      this.unexpected();
    }
    this.next();
    this.finishNode(node, "PrivateIdentifier");

    // For validating existence
    if (this.options.checkPrivateFields) {
      if (this.privateNameStack.length === 0) {
        this.raise(node.start, ("Private field '#" + (node.name) + "' must be declared in an enclosing class"));
      } else {
        this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
      }
    }

    return node
  };

  // Parses yield expression inside generator.

  pp$5.parseYield = function(forInit) {
    if (!this.yieldPos) { this.yieldPos = this.start; }

    var node = this.startNode();
    this.next();
    if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types$1.star);
      node.argument = this.parseMaybeAssign(forInit);
    }
    return this.finishNode(node, "YieldExpression")
  };

  pp$5.parseAwait = function(forInit) {
    if (!this.awaitPos) { this.awaitPos = this.start; }

    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, true, false, forInit);
    return this.finishNode(node, "AwaitExpression")
  };

  var pp$4 = Parser.prototype;

  // This function is used to raise exceptions on parse errors. It
  // takes an offset integer (into the current `input`) to indicate
  // the location of the error, attaches the position to the end
  // of the error message, and then raises a `SyntaxError` with that
  // message.

  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
    throw err
  };

  pp$4.raiseRecoverable = pp$4.raise;

  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart)
    }
  };

  var pp$3 = Parser.prototype;

  var Scope = function Scope(flags) {
    this.flags = flags;
    // A list of var-declared names in the current lexical scope
    this.var = [];
    // A list of lexically-declared names in the current lexical scope
    this.lexical = [];
    // A list of lexically-declared FunctionDeclaration names in the current lexical scope
    this.functions = [];
    // A switch to disallow the identifier reference 'arguments'
    this.inClassFieldInit = false;
  };

  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

  pp$3.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  };

  pp$3.exitScope = function() {
    this.scopeStack.pop();
  };

  // The spec says:
  // > At the top level of a function, or script, function declarations are
  // > treated like var declarations rather than like lexical declarations.
  pp$3.treatFunctionsAsVarInScope = function(scope) {
    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
  };

  pp$3.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      scope.lexical.push(name);
      if (this.inModule && (scope.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
    } else if (bindingType === BIND_SIMPLE_CATCH)