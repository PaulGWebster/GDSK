ror, return
    // failure.
    else if (pointer != input.end()) {
      ada_log(
          "parse_ipv6 Otherwise, if c is not the EOF code point, validation "
          "error, return failure");
      return is_valid = false;
    }

    // Set address[pieceIndex] to value.
    address[piece_index] = value;

    // Increase pieceIndex by 1.
    piece_index++;
  }

  // If compress is non-null, then:
  if (compress.has_value()) {
    // Let swaps be pieceIndex - compress.
    int swaps = piece_index - *compress;

    // Set pieceIndex to 7.
    piece_index = 7;

    // While pieceIndex is not 0 and swaps is greater than 0,
    // swap address[pieceIndex] with address[compress + swaps - 1], and then
    // decrease both pieceIndex and swaps by 1.
    while (piece_index != 0 && swaps > 0) {
      std::swap(address[piece_index], address[*compress + swaps - 1]);
      piece_index--;
      swaps--;
    }
  }
  // Otherwise, if compress is null and pieceIndex is not 8, validation error,
  // return failure.
  else if (piece_index != 8) {
    ada_log(
        "parse_ipv6 if compress is null and pieceIndex is not 8, validation "
        "error, return failure");
    return is_valid = false;
  }
  host = ada::serializers::ipv6(address);
  ada_log("parse_ipv6 ", *host);
  host_type = IPV6;
  return true;
}

template <bool has_state_override>
ada_really_inline bool url::parse_scheme(const std::string_view input) {
  auto parsed_type = ada::scheme::get_scheme_type(input);
  bool is_input_special = (parsed_type != ada::scheme::NOT_SPECIAL);
  /**
   * In the common case, we will immediately recognize a special scheme (e.g.,
   *http, https), in which case, we can go really fast.
   **/
  if (is_input_special) {  // fast path!!!
    if (has_state_override) {
      // If url's scheme is not a special scheme and buffer is a special scheme,
      // then return.
      if (is_special() != is_input_special) {
        return false;
      }

      // If url includes credentials or has a non-null port, and buffer is
      // "file", then return.
      if ((has_credentials() || port.has_value()) &&
          parsed_type == ada::scheme::type::FILE) {
        return false;
      }

      // If url's scheme is "file" and its host is an empty host, then return.
      // An empty host is the empty string.
      if (type == ada::scheme::type::FILE && host.has_value() &&
          host.value().empty()) {
        return false;
      }
    }

    type = parsed_type;

    if (has_state_override) {
      // This is uncommon.
      uint16_t urls_scheme_port = get_special_port();

      if (urls_scheme_port) {
        // If url's port is url's scheme's default port, then set url's port to
        // null.
        if (port.has_value() && *port == urls_scheme_port) {
          port = std::nullopt;
        }
      }
    }
  } else {  // slow path
    std::string _buffer(input);
    // Next function is only valid if the input is ASCII and returns false
    // otherwise, but it seems that we always have ascii content so we do not
    // need to check the return value.
    // bool is_ascii =
    unicode::to_lower_ascii(_buffer.data(), _buffer.size());

    if (has_state_override) {
      // If url's scheme is a special scheme and buffer is not a special scheme,
      // then return. If url's scheme is not a special scheme and buffer is a
      // special scheme, then return.
      if (is_special() != ada::scheme::is_special(_buffer)) {
        return true;
      }

      // If url includes credentials or has a non-null port, and buffer is
      // "file", then return.
      if ((has_credentials() || port.has_value()) && _buffer == "file") {
        return true;
      }

      // If url's scheme is "file" and its host is an empty host, then return.
      // An empty host is the empty string.
      if (type == ada::scheme::type::FILE && host.has_value() &&
          host.value().empty()) {
        return true;
      }
    }

    set_scheme(std::move(_buffer));

    if (has_state_override) {
      // This is uncommon.
      uint16_t urls_scheme_port = get_special_port();

      if (urls_scheme_port) {
        // If url's port is url's scheme's default port, then set url's port to
        // null.
        if (port.has_value() && *port == urls_scheme_port) {
          port = std::nullopt;
        }
      }
    }
  }

  return true;
}

ada_really_inline bool url::parse_host(std::string_view input) {
  ada_log("parse_host ", input, " [", input.size(), " bytes]");
  if (input.empty()) {
    return is_valid = false;
  }  // technically unnecessary.
  // If input starts with U+005B ([), then:
  if (input[0] == '[') {
    // If input does not end with U+005D (]), validation error, return failure.
    if (input.back() != ']') {
      return is_valid = false;
    }
    ada_log("parse_host ipv6");

    // Return the result of IPv6 parsing input with its leading U+005B ([) and
    // trailing U+005D (]) removed.
    input.remove_prefix(1);
    input.remove_suffix(1);
    return parse_ipv6(input);
  }

  // If isNotSpecial is true, then return the result of opaque-host parsing
  // input.
  if (!is_special()) {
    return parse_opaque_host(input);
  }
  // Let domain be the result of running UTF-8 decode without BOM on the
  // percent-decoding of input. Let asciiDomain be the result of running domain
  // to ASCII with domain and false. The most common case is an ASCII input, in
  // which case we do not need to call the expensive 'to_ascii' if a few
  // conditions are met: no '%' and no 'xn-' subsequence.
  std::string buffer = std::string(input);
  // This next function checks that the result is ascii, but we are going to
  // to check anyhow with is_forbidden.
  // bool is_ascii =
  unicode::to_lower_ascii(buffer.data(), buffer.size());
  bool is_forbidden = unicode::contains_forbidden_domain_code_point(
      buffer.data(), buffer.size());
  if (is_forbidden == 0 && buffer.find("xn-") == std::string_view::npos) {
    // fast path
    host = std::move(buffer);
    if (checkers::is_ipv4(host.value())) {
      ada_log("parse_host fast path ipv4");
      return parse_ipv4(host.value());
    }
    ada_log("parse_host fast path ", *host);
    return true;
  }
  ada_log("parse_host calling to_ascii");
  is_valid = ada::unicode::to_ascii(host, input, input.find('%'));
  if (!is_valid) {
    ada_log("parse_host to_ascii returns false");
    return is_valid = false;
  }
  ada_log("parse_host to_ascii succeeded ", *host, " [", host->size(),
          " bytes]");

  if (std::any_of(host.value().begin(), host.value().end(),
                  ada::unicode::is_forbidden_domain_code_point)) {
    host = std::nullopt;
    return is_valid = false;
  }

  // If asciiDomain ends in a number, then return the result of IPv4 parsing
  // asciiDomain.
  if (checkers::is_ipv4(host.value())) {
    ada_log("parse_host got ipv4 ", *host);
    return parse_ipv4(host.value());
  }

  return true;
}

ada_really_inline void url::parse_path(std::string_view input) {
  ada_log("parse_path ", input);
  std::string tmp_buffer;
  std::string_view internal_input;
  if (unicode::has_tabs_or_newline(input)) {
    tmp_buffer = input;
    // Optimization opportunity: Instead of copying and then pruning, we could
    // just directly build the string from user_input.
    helpers::remove_ascii_tab_or_newline(tmp_buffer);
    internal_input = tmp_buffer;
  } else {
    internal_input = input;
  }

  // If url is special, then:
  if (is_special()) {
    if (internal_input.empty()) {
      path = "/";
    } else if ((internal_input[0] == '/') || (internal_input[0] == '\\')) {
      helpers::parse_prepared_path(internal_input.substr(1), type, path);
      return;
    } else {
      helpers::parse_prepared_path(internal_input, type, path);
      return;
    }
  } else if (!internal_input.empty()) {
    if (internal_input[0] == '/') {
      helpers::parse_prepared_path(internal_input.substr(1), type, path);
      return;
    } else {
      helpers::parse_prepared_path(internal_input, type, path);
      return;
    }
  } else {
    if (!host.has_value()) {
      path = "/";
    }
  }
}

[[nodiscard]] std::string url::to_string() const {
  if (!is_valid) {
    return "null";
  }
  std::string answer;
  auto back = std::back_insert_iterator(answer);
  answer.append("{\n");
  answer.append("\t\"protocol\":\"");
  helpers::encode_json(get_protocol(), back);
  answer.append("\",\n");
  if (has_credentials()) {
    answer.append("\t\"username\":\"");
    helpers::encode_json(username, back);
    answer.append("\",\n");
    answer.append("\t\"password\":\"");
    helpers::encode_json(password, back);
    answer.append("\",\n");
  }
  if (host.has_value()) {
    answer.append("\t\"host\":\"");
    helpers::encode_json(host.value(), back);
    answer.append("\",\n");
  }
  if (port.has_value()) {
    answer.append("\t\"port\":\"");
    answer.append(std::to_string(port.value()));
    answer.append("\",\n");
  }
  answer.append("\t\"path\":\"");
  helpers::encode_json(path, back);
  answer.append("\",\n");
  answer.append("\t\"opaque path\":");
  answer.append((has_opaque_path ? "true" : "false"));
  if (has_search()) {
    answer.append(",\n");
    answer.append("\t\"query\":\"");
    helpers::encode_json(query.value(), back);
    answer.append("\"");
  }
  if (hash.has_value()) {
    answer.append(",\n");
    answer.append("\t\"hash\":\"");
    helpers::encode_json(hash.value(), back);
    answer.append("\"");
  }
  answer.append("\n}");
  return answer;
}

[[nodiscard]] bool url::has_valid_domain() const noexcept {
  if (!host.has_value()) {
    return false;
  }
  return checkers::verify_dns_length(host.value());
}

}  // namespace ada
/* end file src/url.cpp */
/* begin file src/url-getters.cpp */
/**
 * @file url-getters.cpp
 * Includes all the getters of `ada::url`
 */

#include <string>

namespace ada {
[[nodiscard]] std::string url::get_origin() const noexcept {
  if (is_special()) {
    // Return a new opaque origin.
    if (type == scheme::FILE) {
      return "null";
    }
    return ada::helpers::concat(get_protocol(), "//", get_host());
  }

  if (non_special_scheme == "blob") {
    if (!path.empty()) {
      auto result = ada::parse<ada::url>(path);
      if (result &&
          (result->type == scheme::HTTP || result->type == scheme::HTTPS)) {
        // If pathURL's scheme is not "http" and not "https", then return a
        // new opaque origin.
        return ada::helpers::concat(result->get_protocol(), "//",
                                    result->get_host());
      }
    }
  }

  // Return a new opaque origin.
  return "null";
}

[[nodiscard]] std::string url::get_protocol() const noexcept {
  if (is_special()) {
    return helpers::concat(ada::scheme::details::is_special_list[type], ":");
  }
  // We only move the 'scheme' if it is non-special.
  return helpers::concat(non_special_scheme, ":");
}

[[nodiscard]] std::string url::get_host() const noexcept {
  // If url's host is null, then return the empty string.
  // If url's port is null, return url's host, serialized.
  // Return url's host, serialized, followed by U+003A (:) and url's port,
  // serialized.
  if (!host.has_value()) {
    return "";
  }
  if (port.has_value()) {
    return host.value() + ":" + get_port();
  }
  return host.value();
}

[[nodiscard]] std::string url::get_hostname() const noexcept {
  return host.value_or("");
}

[[nodiscard]] std::string_view url::get_pathname() const noexcept {
  return path;
}

[[nodiscard]] std::string url::get_search() const noexcept {
  // If this's URL's query is either null or the empty string, then return the
  // empty string. Return U+003F (?), followed by this's URL's query.
  return (!query.has_value() || (query.value().empty())) ? ""
                                                         : "?" + query.value();
}

[[nodiscard]] const std::string& url::get_username() const noexcept {
  return username;
}

[[nodiscard]] const std::string& url::get_password() const noexcept {
  return password;
}

[[nodiscard]] std::string url::get_port() const noexcept {
  return port.has_value() ? std::to_string(port.value()) : "";
}

[[nodiscard]] std::string url::get_hash() const noexcept {
  // If this's URL's fragment is either null or the empty string, then return
  // the empty string. Return U+0023 (#), followed by this's URL's fragment.
  return (!hash.has_value() || (hash.value().empty())) ? ""
                                                       : "#" + hash.value();
}

}  // namespace ada
/* end file src/url-getters.cpp */
/* begin file src/url-setters.cpp */
/**
 * @file url-setters.cpp
 * Includes all the setters of `ada::url`
 */

#include <optional>
#include <string>

namespace ada {

template <bool override_hostname>
bool url::set_host_or_hostname(const std::string_view input) {
  if (has_opaque_path) {
    return false;
  }

  std::optional<std::string> previous_host = host;
  std::optional<uint16_t> previous_port = port;

  size_t host_end_pos = input.find('#');
  std::string _host(input.data(), host_end_pos != std::string_view::npos
                                      ? host_end_pos
                                      : input.size());
  helpers::remove_ascii_tab_or_newline(_host);
  std::string_view new_host(_host);

  // If url's scheme is "file", then set state to file host state, instead of
  // host state.
  if (type != ada::scheme::type::FILE) {
    std::string_view host_view(_host.data(), _host.length());
    auto [location, found_colon] =
        helpers::get_host_delimiter_location(is_special(), host_view);

    // Otherwise, if c is U+003A (:) and insideBrackets is false, then:
    // Note: the 'found_colon' value is true if and only if a colon was
    // encountered while not inside brackets.
    if (found_colon) {
      if (override_hostname) {
        return false;
      }
      std::string_view buffer = new_host.substr(location + 1);
      if (!buffer.empty()) {
        set_port(buffer);
      }
    }
    // If url is special and host_view is the empty string, validation error,
    // return failure. Otherwise, if state override is given, host_view is the
    // empty string, and either url includes credentials or url's port is
    // non-null, return.
    else if (host_view.empty() &&
             (is_special() || has_credentials() || port.has_value())) {
      return false;
    }

    // Let host be the result of host parsing host_view with url is not special.
    if (host_view.empty() && !is_special()) {
      host = "";
      return true;
    }

    bool succeeded = parse_host(host_view);
    if (!succeeded) {
      host = previous_host;
      update_base_port(previous_port);
    }
    return succeeded;
  }

  size_t location = new_host.find_first_of("/\\?");
  if (location != std::string_view::npos) {
    new_host.remove_suffix(new_host.length() - location);
  }

  if (new_host.empty()) {
    // Set url's host to the empty string.
    host = "";
  } else {
    // Let host be the result of host parsing buffer with url is not special.
    if (!parse_host(new_host)) {
      host = previous_host;
      update_base_port(previous_port);
      return false;
    }

    // If host is "localhost", then set host to the empty string.
    if (host.has_value() && host.value() == "localhost") {
      host = "";
    }
  }
  return true;
}

bool url::set_host(const std::string_view input) {
  return set_host_or_hostname<false>(input);
}

bool url::set_hostname(const std::string_view input) {
  return set_host_or_hostname<true>(input);
}

bool url::set_username(const std::string_view input) {
  if (cannot_have_credentials_or_port()) {
    return false;
  }
  username = ada::unicode::percent_encode(
      input, character_sets::USERINFO_PERCENT_ENCODE);
  return true;
}

bool url::set_password(const std::string_view input) {
  if (cannot_have_credentials_or_port()) {
    return false;
  }
  password = ada::unicode::percent_encode(
      input, character_sets::USERINFO_PERCENT_ENCODE);
  return true;
}

bool url::set_port(const std::string_view input) {
  if (cannot_have_credentials_or_port()) {
    return false;
  }
  std::string trimmed(input);
  helpers::remove_ascii_tab_or_newline(trimmed);
  if (trimmed.empty()) {
    port = std::nullopt;
    return true;
  }
  // Input should not start with control characters.
  if (ada::unicode::is_c0_control_or_space(trimmed.front())) {
    return false;
  }
  // Input should contain at least one ascii digit.
  if (input.find_first_of("0123456789") == std::string_view::npos) {
    return false;
  }

  // Revert changes if parse_port fails.
  std::optional<uint16_t> previous_port = port;
  parse_port(trimmed);
  if (is_valid) {
    return true;
  }
  port = previous_port;
  is_valid = true;
  return false;
}

void url::set_hash(const std::string_view input) {
  if (input.empty()) {
    hash = std::nullopt;
    helpers::strip_trailing_spaces_from_opaque_path(*this);
    return;
  }

  std::string new_value;
  new_value = input[0] == '#' ? input.substr(1) : input;
  helpers::remove_ascii_tab_or_newline(new_value);
  hash = unicode::percent_encode(new_value,
                                 ada::character_sets::FRAGMENT_PERCENT_ENCODE);
}

void url::set_search(const std::string_view input) {
  if (input.empty()) {
    query = std::nullopt;
    helpers::strip_trailing_spaces_from_opaque_path(*this);
    return;
  }

  std::string new_value;
  new_value = input[0] == '?' ? input.substr(1) : input;
  helpers::remove_ascii_tab_or_newline(new_value);

  auto query_percent_encode_set =
      is_special() ? ada::character_sets::SPECIAL_QUERY_PERCENT_ENCODE
                   : ada::character_sets::QUERY_PERCENT_ENCODE;

  query = ada::unicode::percent_encode(std::string_view(new_value),
                                       query_percent_encode_set);
}

bool url::set_pathname(const std::string_view input) {
  if (has_opaque_path) {
    return false;
  }
  path = "";
  parse_path(input);
  return true;
}

bool url::set_protocol(const std::string_view input) {
  std::string view(input);
  helpers::remove_ascii_tab_or_newline(view);
  if (view.empty()) {
    return true;
  }

  // Schemes should start with alpha values.
  if (!checkers::is_alpha(view[0])) {
    return false;
  }

  view.append(":");

  std::string::iterator pointer =
      std::find_if_not(view.begin(), view.end(), unicode::is_alnum_plus);

  if (pointer != view.end() && *pointer == ':') {
    return parse_scheme<true>(
        std::string_view(view.data(), pointer - view.begin()));
  }
  return false;
}

bool url::set_href(const std::string_view input) {
  ada::result<ada::url> out = ada::parse<ada::url>(input);

  if (out) {
    username = out->username;
    password = out->password;
    host = out->host;
    port = out->port;
    path = out->path;
    query = out->query;
    hash = out->hash;
    type = out->type;
    non_special_scheme = out->non_special_scheme;
    has_opaque_path = out->has_opaque_path;
  }

  return out.has_value();
}

}  // namespace ada
/* end file src/url-setters.cpp */
/* begin file src/parser.cpp */

#include <limits>


namespace ada::parser {

template <class result_type, bool store_values>
result_type parse_url_impl(std::string_view user_input,
                           const result_type* base_url) {
  // We can specialize the implementation per type.
  // Important: result_type_is_ada_url is evaluated at *compile time*. This
  // means that doing if constexpr(result_type_is_ada_url) { something } else {
  // something else } is free (at runtime). This means that ada::url_aggregator
  // and ada::url **do not have to support the exact same API**.
  constexpr bool result_type_is_ada_url =
      std::is_same<ada::url, result_type>::value;
  constexpr bool result_type_is_ada_url_aggregator =
      std::is_same<ada::url_aggregator, result_type>::value;
  static_assert(result_type_is_ada_url ||
                result_type_is_ada_url_aggregator);  // We don't support
                                                     // anything else for now.

  ada_log("ada::parser::parse_url('", user_input, "' [", user_input.size(),
          " bytes],", (base_url != nullptr ? base_url->to_string() : "null"),
          ")");

  ada::state state = ada::state::SCHEME_START;
  result_type url{};

  // We refuse to parse URL strings that exceed 4GB. Such strings are almost
  // surely the result of a bug or are otherwise a security concern.
  if (user_input.size() > std::numeric_limits<uint32_t>::max()) {
    url.is_valid = false;
  }
  // Going forward, user_input.size() is in [0,
  // std::numeric_limits<uint32_t>::max). If we are provided with an invalid
  // base, or the optional_url was invalid, we must return.
  if (base_url != nullptr) {
    url.is_valid &= base_url->is_valid;
  }
  if (!url.is_valid) {
    return url;
  }
  if constexpr (result_type_is_ada_url_aggregator && store_values) {
    // Most of the time, we just need user_input.size().
    // In some instances, we may need a bit more.
    ///////////////////////////
    // This is *very* important. This line should *not* be removed
    // hastily. There are principled reasons why reserve is important
    // for performance. If you have a benchmark with small inputs,
    // it may not matter, but in other instances, it could.
    ////
    // This rounds up to the next power of two.
    // We know that user_input.size() is in [0,
    // std::numeric_limits<uint32_t>::max).
    uint32_t reserve_capacity =
        (0xFFFFFFFF >>
         helpers::leading_zeroes(uint32_t(1 | user_input.size()))) +
        1;
    url.reserve(reserve_capacity);
  }
  std::string tmp_buffer;
  std::string_view internal_input;
  if (unicode::has_tabs_or_newline(user_input)) {
    tmp_buffer = user_input;
    // Optimization opportunity: Instead of copying and then pruning, we could
    // just directly build the string from user_input.
    helpers::remove_ascii_tab_or_newline(tmp_buffer);
    internal_input = tmp_buffer;
  } else {
    internal_input = user_input;
  }

  // Leading and trailing control characters are uncommon and easy to deal with
  // (no performance concern).
  std::string_view url_data = internal_input;
  helpers::trim_c0_whitespace(url_data);

  // Optimization opportunity. Most websites do not have fragment.
  std::optional<std::string_view> fragment = helpers::prune_hash(url_data);
  // We add it last so that an implementation like ada::url_aggregator
  // can append it last to its internal buffer, thus improving performance.

  // Here url_data no longer has its fragment.
  // We are going to access the data from url_data (it is immutable).
  // At any given time, we are pointing at byte 'input_position' in url_data.
  // The input_position variable should range from 0 to input_size.
  // It is illegal to access url_data at input_size.
  size_t input_position = 0;
  const size_t input_size = url_data.size();
  // Keep running the following state machine by switching on state.
  // If after a run pointer points to the EOF code point, go to the next step.
  // Otherwise, increase pointer by 1 and continue with the state machine.
  // We never decrement input_position.
  while (input_position <= input_size) {
    ada_log("In parsing at ", input_position, " out of ", input_size,
            " in state ", ada::to_string(state));
    switch (state) {
      case ada::state::SCHEME_START: {
        ada_log("SCHEME_START ", helpers::substring(url_data, input_position));
        // If c is an ASCII alpha, append c, lowercased, to buffer, and set
        // state to scheme state.
        if ((input_position != input_size) &&
            checkers::is_alpha(url_data[input_position])) {
          state = ada::state::SCHEME;
          input_position++;
        } else {
          // Otherwise, if state override is not given, set state to no scheme
          // state and decrease pointer by 1.
          state = ada::state::NO_SCHEME;
        }
        break;
      }
      case ada::state::SCHEME: {
        ada_log("SCHEME ", helpers::substring(url_data, input_position));
        // If c is an ASCII alphanumeric, U+002B (+), U+002D (-), or U+002E (.),
        // append c, lowercased, to buffer.
        while ((input_position != input_size) &&
               (ada::unicode::is_alnum_plus(url_data[input_position]))) {
          input_position++;
        }
        // Otherwise, if c is U+003A (:), then:
        if ((input_position != input_size) &&
            (url_data[input_position] == ':')) {
          ada_log("SCHEME the scheme should be ",
                  url_data.substr(0, input_position));
          if constexpr (result_type_is_ada_url) {
            if (!url.parse_scheme(url_data.substr(0, input_position))) {
              return url;
            }
          } else {
            // we pass the colon along instead of painfully adding it back.
            if (!url.parse_scheme_with_colon(
                    url_data.substr(0, input_position + 1))) {
              return url;
            }
          }
          ada_log("SCHEME the scheme is ", url.get_protocol());

          // If url's scheme is "file", then:
          if (url.type == ada::scheme::type::FILE) {
            // Set state to file state.
            state = ada::state::FILE;
          }
          // Otherwise, if url is special, base is non-null, and base's scheme
          // is url's scheme: Note: Doing base_url->scheme is unsafe if base_url
          // != nullptr is false.
          else if (url.is_special() && base_url != nullptr &&
                   base_url->type == url.type) {
            // Set state to special relative or authority state.
            state = ada::state::SPECIAL_RELATIVE_OR_AUTHORITY;
          }
          // Otherwise, if url is special, set state to special authority
          // slashes state.
          else if (url.is_special()) {
            state = ada::state::SPECIAL_AUTHORITY_SLASHES;
          }
          // Otherwise, if remaining starts with an U+002F (/), set state to
          // path or authority state and increase pointer by 1.
          else if (input_position + 1 < input_size &&
                   url_data[input_position + 1] == '/') {
            state = ada::state::PATH_OR_AUTHORITY;
            input_position++;
          }
          // Otherwise, set url's path to the empty string and set state to
          // opaque path state.
          else {
            state = ada::state::OPAQUE_PATH;
          }
        }
        // Otherwise, if state override is not given, set buffer to the empty
        // string, state to no scheme state, and start over (from the first code
        // point in input).
        else {
          state = ada::state::NO_SCHEME;
          input_position = 0;
          break;
        }
        input_position++;
        break;
      }
      case ada::state::NO_SCHEME: {
        ada_log("NO_SCHEME ", helpers::substring(url_data, input_position));
        // If base is null, or base has an opaque path and c is not U+0023 (#),
        // validation error, return failure.
        if (base_url == nullptr ||
            (base_url->has_opaque_path && !fragment.has_value())) {
          ada_log("NO_SCHEME validation error");
          url.is_valid = false;
          return url;
        }
        // Otherwise, if base has an opaque path and c is U+0023 (#),
        // set url's scheme to base's scheme, url's path to base's path, url's
        // query to base's query, and set state to fragment state.
        else if (base_url->has_opaque_path && fragment.has_value() &&
                 input_position == input_size) {
          ada_log("NO_SCHEME opaque base with fragment");
          url.copy_scheme(*base_url);
          url.has_opaque_path = base_url->has_opaque_path;

          if constexpr (result_type_is_ada_url) {
            url.path = base_url->path;
            url.query = base_url->query;
          } else {
            url.update_base_pathname(base_url->get_pathname());
            url.update_base_search(base_url->get_search());
          }
          url.update_unencoded_base_hash(*fragment);
          return url;
        }
        // Otherwise, if base's scheme is not "file", set state to relative
        // state and decrease pointer by 1.
        else if (base_url->type != ada::scheme::type::FILE) {
          ada_log("NO_SCHEME non-file relative path");
          state = ada::state::RELATIVE_SCHEME;
        }
        // Otherwise, set state to file state and decrease pointer by 1.
        else {
          ada_log("NO_SCHEME file base type");
          state = ada::state::FILE;
        }
        break;
      }
      case ada::state::AUTHORITY: {
        ada_log("AUTHORITY ", helpers::substring(url_data, input_position));
        // most URLs have no @. Having no @ tells us that we don't have to worry
        // about AUTHORITY. Of course, we could have @ and still not have to
        // worry about AUTHORITY.
        // TODO: Instead of just collecting a bool, collect the location of the
        // '@' and do something useful with it.
        // TODO: We could do various processing early on, using a single pass
        // over the string to collect information about it, e.g., telling us
        // whether there is a @ and if so, where (or how many).
        const bool contains_ampersand =
            (url_data.find('@', input_position) != std::string_view::npos);

        if (!contains_ampersand) {
          state = ada::state::HOST;
          break;
        }
        bool at_sign_seen{false};
        bool password_token_seen{false};
        /**
         * We expect something of the sort...
         * https://user:pass@example.com:1234/foo/bar?baz#quux
         * --------^
         */
        do {
          std::string_view view = helpers::substring(url_data, input_position);
          // The delimiters are @, /, ? \\.
          size_t location =
              url.is_special() ? helpers::find_authority_delimiter_special(view)
                               : helpers::find_authority_delimiter(view);
          std::string_view authority_view(view.data(), location);
          size_t end_of_authority = input_position + authority_view.size();
          // If c is U+0040 (@), then:
          if ((end_of_authority != input_size) &&
              (url_data[end_of_authority] == '@')) {
            // If atSignSeen is true, then prepend "%40" to buffer.
            if (at_sign_seen) {
              if (password_token_seen) {
                if constexpr (result_type_is_ada_url) {
                  url.password += "%40";
                } else {
                  url.append_base_password("%40");
                }
              } else {
                if constexpr (result_type_is_ada_url) {
                  url.username += "%40";
                } else {
                  url.append_base_username("%40");
                }
              }
            }

            at_sign_seen = true;

            if (!password_token_seen) {
              size_t password_token_location = authority_view.find(':');
              password_token_seen =
                  password_token_location != std::string_view::npos;

              if constexpr (store_values) {
                if (!password_token_seen) {
                  if constexpr (result_type_is_ada_url) {
                    url.username += unicode::percent_encode(
                        authority_view,
                        character_sets::USERINFO_PERCENT_ENCODE);
                  } else {
                    url.append_base_username(unicode::percent_encode(
                        authority_view,
                        character_sets::USERINFO_PERCENT_ENCODE));
                  }
                } else {
                  if constexpr (result_type_is_ada_url) {
                    url.username += unicode::percent_encode(
                        authority_view.substr(0, password_token_location),
                        character_sets::USERINFO_PERCENT_ENCODE);
                    url.password += unicode::percent_encode(
                        authority_view.substr(password_token_location + 1),
                        character_sets::USERINFO_PERCENT_ENCODE);
                  } else {
                    url.append_base_username(unicode::percent_encode(
                        authority_view.substr(0, password_token_location),
                        character_sets::USERINFO_PERCENT_ENCODE));
                    url.append_base_password(unicode::percent_encode(
                        authority_view.substr(password_token_location + 1),
                        character_sets::USERINFO_PERCENT_ENCODE));
                  }
                }
              }
            } else if constexpr (store_values) {
              if constexpr (result_type_is_ada_url) {
                url.password += unicode::percent_encode(
                    authority_view, character_sets::USERINFO_PERCENT_ENCODE);
              } else {
                url.append_base_password(unicode::percent_encode(
                    authority_view, character_sets::USERINFO_PERCENT_ENCODE));
              }
            }
          }
          // Otherwise, if one of the following is true:
          // - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
          // - url is special and c is U+005C (\)
          else if (end_of_authority == input_size ||
                   url_data[end_of_authority] == '/' ||
                   url_data[end_of_authority] == '?' ||
                   (url.is_special() && url_data[end_of_authority] == '\\')) {
            // If atSignSeen is true and authority_view is the empty string,
            // validation error, return failure.
            if (at_sign_seen && authority_view.empty()) {
              url.is_valid = false;
              return url;
            }
            state = ada::state::HOST;
            break;
          }
          if (end_of_authority == input_size) {
            if constexpr (store_values) {
              if (fragment.has_value()) {
                url.update_unencoded_base_hash(*fragment);
              }
            }
            return url;
          }
          input_position = end_of_authority + 1;
        } while (true);

        break;
      }
      case ada::state::SPECIAL_RELATIVE_OR_AUTHORITY: {
        ada_log("SPECIAL_RELATIVE_OR_AUTHORITY ",
                helpers::substring(url_data, input_position));

        // If c is U+002F (/) and remaining starts with U+002F (/),
        // then set state to special authority ignore slashes state and increase
        // pointer by 1.
        std::string_view view = helpers::substring(url_data, input_position);
        if (ada::checkers::begins_with(view, "//")) {
          state = ada::state::SPECIAL_AUTHORITY_IGNORE_SLASHES;
          input_position += 2;
        } else {
          // Otherwise, validation error, set state to relative state and
          // decrease pointer by 1.
          state = ada::state::RELATIVE_SCHEME;
        }

        break;
      }
      case ada::state::PATH_OR_AUTHORITY: {
        ada_log("PATH_OR_AUTHORITY ",
                helpers::substring(url_data, input_position));

        // If c is U+002F (/), then set state to authority state.
        if ((input_position != input_size) &&
            (url_data[input_position] == '/')) {
          state = ada::state::AUTHORITY;
          input_position++;
        } else {
          // Otherwise, set state to path state, and decrease pointer by 1.
          state = ada::state::PATH;
        }

        break;
      }
      case ada::state::RELATIVE_SCHEME: {
        ada_log("RELATIVE_SCHEME ",
                helpers::substring(url_data, input_position));

        // Set url's scheme to base's scheme.
        url.copy_scheme(*base_url);

        // If c is U+002F (/), then set state to relative slash state.
        if ((input_position != input_size) &&
            (url_data[input_position] == '/')) {
          ada_log(
              "RELATIVE_SCHEME if c is U+002F (/), then set state to relative "
              "slash state");
          state = ada::state::RELATIVE_SLASH;
        } else if (url.is_special() && (input_position != input_size) &&
                   (url_data[input_position] == '\\')) {
          // Otherwise, if url is special and c is U+005C (\), validation error,
          // set state to relative slash state.
          ada_log(
              "RELATIVE_SCHEME  if url is special and c is U+005C, validation "
              "error, set state to relative slash state");
          state = ada::state::RELATIVE_SLASH;
        } else {
          ada_log("RELATIVE_SCHEME otherwise");
          // Set url's username to base's username, url's password to base's
          // password, url's host to base's host, url's port to base's port,
          // url's path to a clone of base's path, and url's query to base's
          // query.
          if constexpr (result_type_is_ada_url) {
            url.username = base_url->username;
            url.password = base_url->password;
            url.host = base_url->host;
            url.port = base_url->port;
            // cloning the base path includes cloning the has_opaque_path flag
            url.has_opaque_path = base_url->has_opaque_path;
            url.path = base_url->path;
            url.query = base_url->query;
          } else {
            url.update_base_authority(base_url->get_href(),
                                      base_url->get_components());
            // TODO: Get rid of set_hostname and replace it with
            // update_base_hostname
            url.set_hostname(base_url->get_hostname());
            url.update_base_port(base_url->retrieve_base_port());
            // cloning the base path includes cloning the has_opaque_path flag
            url.has_opaque_path = base_url->has_opaque_path;
            url.update_base_pathname(base_url->get_pathname());
            url.update_base_search(base_url->get_search());
          }

          url.has_opaque_path = base_url->has_opaque_path;

          // If c is U+003F (?), then set url's query to the empty string, and
          // state to query state.
          if ((input_position != input_size) &&
              (url_data[input_position] == '?')) {
            state = ada::state::QUERY;
          }
          // Otherwise, if c is not the EOF code point:
          else if (input_position != input_size) {
            // Set url's query to null.
            url.clear_search();
            if constexpr (result_type_is_ada_url) {
              // Shorten url's path.
              helpers::shorten_path(url.path, url.type);
            } else {
              std::string_view path = url.get_pathname();
              if (helpers::shorten_path(path, url.type)) {
                url.update_base_pathname(std::string(path));
              }
            }
            // Set state to path state and decrease pointer by 1.
            state = ada::state::PATH;
            break;
          }
        }
        input_position++;
        break;
      }
      case ada::state::RELATIVE_SLASH: {
        ada_log("RELATIVE_SLASH ",
                helpers::substring(url_data, input_position));

        // If url is special and c is U+002F (/) or U+005C (\), then:
        if (url.is_special() && (input_position != input_size) &&
            (url_data[input_position] == '/' ||
             url_data[input_position] == '\\')) {
          // Set state to special authority ignore slashes state.
          state = ada::state::SPECIAL_AUTHORITY_IGNORE_SLASHES;
        }
        // Otherwise, if c is U+002F (/), then set state to authority state.
        else if ((input_position != input_size) &&
                 (url_data[input_position] == '/')) {
          state = ada::state::AUTHORITY;
        }
        // Otherwise, set
        // - url's username to base's username,
        // - url's password to base's password,
        // - url's host to base's host,
        // - url's port to base's port,
        // - state to path state, and then, decrease pointer by 1.
        else {
          if constexpr (result_type_is_ada_url) {
            url.username = base_url->username;
            url.password = base_url->password;
            url.host = base_url->host;
            url.port = base_url->port;
          } else {
            url.update_base_authority(base_url->get_href(),
                                      base_url->get_components());
            // TODO: Get rid of set_hostname and replace it with
            // update_base_hostname
            url.set_hostname(base_url->get_hostname());
            url.update_base_port(base_url->retrieve_base_port());
          }
          state = ada::state::PATH;
          break;
        }

        input_position++;
        break;
      }
      case ada::state::SPECIAL_AUTHORITY_SLASHES: {
        ada_log("SPECIAL_AUTHORITY_SLASHES ",
                helpers::substring(url_data, input_position));

        // If c is U+002F (/) and remaining starts with U+002F (/),
        // then set state to special authority ignore slashes state and increase
        // pointer by 1.
        std::string_view view = helpers::substring(url_data, input_position);
        if (ada::checkers::begins_with(view, "//")) {
          input_position += 2;
        }

        [[fallthrough]];
      }
      case ada::state::SPECIAL_AUTHORITY_IGNORE_SLASHES: {
        ada_log("SPECIAL_AUTHORITY_IGNORE_SLASHES ",
                helpers::substring(url_data, input_position));

        // If c is neither U+002F (/) nor U+005C (\), then set state to
        // authority state and decrease pointer by 1.
        while ((input_position != input_size) &&
               ((url_data[input_position] == '/') ||
                (url_data[input_position] == '\\'))) {
          input_position++;
        }
        state = ada::state::AUTHORITY;

        break;
      }
      case ada::state::QUERY: {
        ada_log("QUERY ", helpers::substring(url_data, input_position));
        if constexpr (store_values) {
          // Let queryPercentEncodeSet be the special-query percent-encode set
          // if url is special; otherwise the query percent-encode set.
          const uint8_t* query_percent_encode_set =
              url.is_special()
                  ? ada::character_sets::SPECIAL_QUERY_PERCENT_ENCODE
                  : ada::character_sets::QUERY_PERCENT_ENCODE;

          // Percent-encode after encoding, with encoding, buffer, and
          // queryPercentEncodeSet, and append the result to url's query.
          url.update_base_search(helpers::substring(url_data, input_position),
                                 query_percent_encode_set);
          ada_log("QUERY update_base_search completed ");
          if (fragment.has_value()) {
            url.update_unencoded_base_hash(*fragment);
          }
        }
        return url;
      }
      case ada::state::HOST: {
        ada_log("HOST ", helpers::substring(url_data, input_position));

        std::string_view host_view =
            helpers::substring(url_data, input_position);
        auto [location, found_colon] =
            helpers::get_host_delimiter_location(url.is_special(), host_view);
        input_position = (location != std::string_view::npos)
                             ? input_position + location
                             : input_size;
        // Otherwise, if c is U+003A (:) and insideBrackets is false, then:
        // Note: the 'found_colon' value is true if and only if a colon was
        // encountered while not inside brackets.
        if (found_colon) {
          // If buffer is the empty string, validation error, return failure.
          // Let host be the result of host parsing buffer with url is not
          // special.
          ada_log("HOST parsing ", host_view);
          if (!url.parse_host(host_view)) {
            return url;
          }
          ada_log("HOST parsing results in ", url.get_hostname());
          // Set url's host to host, buffer to the empty string, and state to
          // port state.
          state = ada::state::PORT;
          input_position++;
        }
        // Otherwise, if one of the following is true:
        // - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
        // - url is special and c is U+005C (\)
        // The get_host_delimiter_location function either brings us to
        // the colon outside of the bracket, or to one of those characters.
        else {
          // If url is special and host_view is the empty string, validation
          // error, return failure.
          if (url.is_special() && host_view.empty()) {
            url.is_valid = false;
            return url;
          }
          ada_log("HOST parsing ", host_view, " href=", url.get_href());
          // Let host be the result of host parsing host_view with url is not
          // special.
          if (host_view.empty()) {
            url.update_base_hostname("");
          } else if (!url.parse_host(host_view)) {
            return url;
          }
          ada_log("HOST parsing results in ", url.get_hostname(),
                  " href=", url.get_href());

          // Set url's host to host, and state to path start state.
          state = ada::state::PATH_START;
        }

        break;
      }
      case ada::state::OPAQUE_PATH: {
        ada_log("OPAQUE_PATH ", helpers::substring(url_data, input_position));
        std::string_view view = helpers::substring(url_data, input_position);
        // If c is U+003F (?), then set url's query to the empty string and
        // state to query state.
        size_t location = view.find('?');
        if (location != std::string_view::npos) {
          view.remove_suffix(view.size() - location);
          state = ada::state::QUERY;
          input_position += location + 1;
        } else {
          input_position = input_size + 1;
        }
        url.has_opaque_path = true;
        // This is a really unlikely scenario in real world. We should not seek
        // to optimize it.
        url.update_base_pathname(unicode::percent_encode(
            view, character_sets::C0_CONTROL_PERCENT_ENCODE));
        break;
      }
      case ada::state::PORT: {
        ada_log("PORT ", helpers::substring(url_data, input_position));
        std::string_view port_view =
            helpers::substring(url_data, input_position);
        size_t consumed_bytes = url.parse_port(port_view, true);
        input_position += consumed_bytes;
        if (!url.is_valid) {
          return url;
        }
        state = state::PATH_START;
        [[fallthrough]];
      }
      case ada::state::PATH_START: {
        ada_log("PATH_START ", helpers::substring(url_data, input_position));

        // If url is special, then:
        if (url.is_special()) {
          // Set state to path state.
          state = ada::state::PATH;

          // Optimization: Avoiding going into PATH state improves the
          // performance of urls ending with /.
          if (input_position == input_size) {
            if constexpr (store_values) {
              url.update_base_pathname("/");
              if (fragment.has_value()) {
                url.update_unencoded_base_hash(*fragment);
              }
            }
            return url;
          }
          // If c is neither U+002F (/) nor U+005C (\), then decrease pointer
          // by 1. We know that (input_position == input_size) is impossible
          // here, because of the previous if-check.
          if ((url_data[input_position] != '/') &&
              (url_data[input_position] != '\\')) {
            break;
          }
        }
        // Otherwise, if state override is not given and c is U+003F (?),
        // set url's query to the empty string and state to query state.
        else if ((input_position != input_size) &&
                 (url_data[input_position] == '?')) {
          state = ada::state::QUERY;
        }
        // Otherwise, if c is not the EOF code point:
        else if (input_position != input_size) {
          // Set state to path state.
          state = ada::state::PATH;

          // If c is not U+002F (/), then decrease pointer by 1.
          if (url_data[input_position] != '/') {
            break;
          }
        }

        input_position++;
        break;
      }
      case ada::state::PATH: {
        std::string_view view = helpers::substring(url_data, input_position);
        ada_log("PATH ", helpers::substring(url_data, input_position));

        // Most time, we do not need percent encoding.
        // Furthermore, we can immediately locate the '?'.
        size_t locofquestionmark = view.find('?');
        if (locofquestionmark != std::string_view::npos) {
          state = ada::state::QUERY;
          view.remove_suffix(view.size() - locofquestionmark);
          input_position += locofquestionmark + 1;
        } else {
          input_position = input_size + 1;
        }
        if constexpr (store_values) {
          if constexpr (result_type_is_ada_url) {
            helpers::parse_prepared_path(view, url.type, url.path);
          } else {
            url.consume_prepared_path(view);
            ADA_ASSERT_TRUE(url.validate());
          }
        }
        break;
      }
      case ada::state::FILE_SLASH: {
        ada_log("FILE_SLASH ", helpers::substring(url_data, input_position));

        // If c is U+002F (/) or U+005C (\), then:
        if ((input_position != input_size) &&
            (url_data[input_position] == '/' ||
             url_data[input_position] == '\\')) {
          ada_log("FILE_SLASH c is U+002F or U+005C");
          // Set state to file host state.
          state = ada::state::FILE_HOST;
          input_position++;
        } else {
          ada_log("FILE_SLASH otherwise");
          // If base is non-null and base's scheme is "file", then:
          // Note: it is unsafe to do base_url->scheme unless you know that
          // base_url_has_value() is true.
          if (base_url != nullptr &&
              base_url->type == ada::scheme::type::FILE) {
            // Set url's host to base's host.
            if constexpr (result_type_is_ada_url) {
              url.host = base_url->host;
            } else {
              // TODO: Optimization opportunity.
              url.set_host(base_url->get_host());
            }
            // If the code point substring from pointer to the end of input does
            // not start with a Windows drive letter and base's path[0] is a
            // normalized Windows drive letter, then append base's path[0] to
            // url's path.
            if (!base_url->get_pathname().empty()) {
              if (!checkers::is_windows_drive_letter(
                      helpers::substring(url_data, input_position))) {
                std::string_view first_base_url_path =
                    base_url->get_pathname().substr(1);
                size_t loc = first_base_url_path.find('/');
                if (loc != std::string_view::npos) {
                  helpers::resize(first_base_url_path, loc);
                }
                if (checkers::is_normalized_windows_drive_letter(
                        first_base_url_path)) {
                  if constexpr (result_type_is_ada_url) {
                    url.path += '/';
                    url.path += first_base_url_path;
                  } else {
                    url.append_base_pathname(
                        helpers::concat("/", first_base_url_path));
                  }
                }
              }
            }
          }

          // Set state to path state, and decrease pointer by 1.
          state = ada::state::PATH;
        }

        break;
      }
      case ada::state::FILE_HOST: {
        std::string_view view = helpers::substring(url_data, input_position);
        ada_log("FILE_HOST ", helpers::substring(url_data, input_position));

        size_t location = view.find_first_of("/\\?");
        std::string_view file_host_buffer(
            view.data(),
            (location != std::string_view::npos) ? location : view.size());

        if (checkers::is_windows_drive_letter(file_host_buffer)) {
          state = ada::state::PATH;
        } else if (file_host_buffer.empty()) {
          // Set url's host to the empty string.
          if constexpr (result_type_is_ada_url) {
            url.host = "";
          } else {
            url.update_base_hostname("");
          }
          // Set state to path start state.
          state = ada::state::PATH_START;
        } else {
          size_t consumed_bytes = file_host_buffer.size();
          input_position += consumed_bytes;
          // Let host be the result of host parsing buffer with url is not
          // special.
          if (!url.parse_host(file_host_buffer)) {
            return url;
          }

          if constexpr (result_type_is_ada_url) {
            // If host is "localhost", then set host to the empty string.
            if (url.host.has_value() && url.host.value() == "localhost") {
              url.host = "";
            }
          } else {
            if (url.get_hostname() == "localhost") {
              url.update_base_hostname("");
            }
          }

          // Set buffer to the empty string and state to path start state.
          state = ada::state::PATH_START;
        }

        break;
      }
      case ada::state::FILE: {
        ada_log("FILE ", helpers::substring(url_data, input_position));
        std::string_view file_view =
            helpers::substring(url_data, input_position);

        url.set_protocol_as_file();
        if constexpr (result_type_is_ada_url) {
          // Set url's host to the empty string.
          url.host = "";
        } else {
          url.update_base_hostname("");
        }
        // If c is U+002F (/) or U+005C (\), then:
        if (input_position != input_size &&
            (url_data[input_position] == '/' ||
             url_data[input_position] == '\\')) {
          ada_log("FILE c is U+002F or U+005C");
          // Set state to file slash state.
          state = ada::state::FILE_SLASH;
        }
        // Otherwise, if base is non-null and base's scheme is "file":
        else if (base_url != nullptr &&
                 base_url->type == ada::scheme::type::FILE) {
          // Set url's host to base's host, url's path to a clone of base's
          // path, and url's query to base's query.
          ada_log("FILE base non-null");
          if constexpr (result_type_is_ada_url) {
            url.host = base_url->host;
            url.path = base_url->path;
            url.query = base_url->query;
          } else {
            // TODO: Get rid of set_hostname and replace it with
            // update_base_hostname
            url.set_hostname(base_url->get_hostname());
            url.update_base_pathname(base_url->get_pathname());
            url.update_base_search(base_url->get_search());
          }
          url.has_opaque_path = base_url->has_opaque_path;

          // If c is U+003F (?), then set url's query to the empty string and
          // state to query state.
          if (input_position != input_size && url_data[input_position] == '?') {
            state = ada::state::QUERY;
          }
          // Otherwise, if c is not the EOF code point:
          else if (input_position != input_size) {
            // Set url's query to null.
            url.clear_search();
            // If the code point substring from pointer to the end of input does
            // not start with a Windows drive letter, then shorten url's path.
            if (!checkers::is_windows_drive_letter(file_view)) {
              if constexpr (result_type_is_ada_url) {
                helpers::shorten_path(url.path, url.type);
              } else {
                std::string_view path = url.get_pathname();
                if (helpers::shorten_path(path, url.type)) {
                  url.update_base_pathname(std::string(path));
                }
              }
            }
            // Otherwise:
            else {
              // Set url's path to an empty list.
              url.clear_pathname();
              url.has_opaque_path = true;
            }

            // Set state to path state and decrease pointer by 1.
            state = ada::state::PATH;
            break;
          }
        }
        // Otherwise, set state to path state, and decrease pointer by 1.
        else {
          ada_log("FILE go to path");
          state = ada::state::PATH;
          break;
        }

        input_position++;
        break;
      }
      default:
        ada::unreachable();
    }
  }
  if constexpr (store_values) {
    if (fragment.has_value()) {
      url.update_unencoded_base_hash(*fragment);
    }
  }
  return url;
}

template url parse_url_impl(std::string_view user_input,
                            const url* base_url = nullptr);
template url_aggregator parse_url_impl(
    std::string_view user_input, const url_aggregator* base_url = nullptr);

template <class result_type>
result_type parse_url(std::string_view user_input,
                      const result_type* base_url) {
  return parse_url_impl<result_type, true>(user_input, base_url);
}

template url parse_url<url>(std::string_view user_input,
                            const url* base_url = nullptr);
template url_aggregator parse_url<url_aggregator>(
    std::string_view user_input, const url_aggregator* base_url = nullptr);
}  // namespace ada::parser
/* end file src/parser.cpp */
/* begin file src/url_components.cpp */

#include <numeric>
#include <string>

namespace ada {

[[nodiscard]] bool url_components::check_offset_consistency() const noexcept {
  /**
   * https://user:pass@example.com:1234/foo/bar?baz#quux
   *       |     |    |          | ^^^^|       |   |
   *       |     |    |          | |   |       |   `----- hash_start
   *       |     |    |          | |   |       `--------- search_start
   *       |     |    |          | |   `----------------- pathname_start
   *       |     |    |          | `--------------------- port
   *       |     |    |          `----------------------- host_end
   *       |     |    `---------------------------------- host_start
   *       |     `--------------------------------------- username_end
   *       `--------------------------------------------- protocol_end
   */
  // These conditions can be made more strict.
  uint32_t index = 0;

  if (protocol_end == url_components::omitted) {
    return false;
  }
  if (protocol_end < index) {
    return false;
  }
  index = protocol_end;

  if (username_end == url_components::omitted) {
    return false;
  }
  if (username_end < index) {
    return false;
  }
  index = username_end;

  if (host_start == url_components::omitted) {
    return false;
  }
  if (host_start < index) {
    return false;
  }
  index = host_start;

  if (port != url_components::omitted) {
    if (port > 0xffff) {
      return false;
    }
    uint32_t port_length = helpers::fast_digit_count(port) + 1;
    if (index + port_length < index) {
      return false;
    }
    index += port_length;
  }

  if (pathname_start == url_components::omitted) {
    return false;
  }
  if (pathname_start < index) {
    return false;
  }
  index = pathname_start;

  if (search_start != url_components::omitted) {
    if (search_start < index) {
      return false;
    }
    index = search_start;
  }

  if (hash_start != url_components::omitted) {
    if (hash_start < index) {
      return false;
    }
  }

  return true;
}

[[nodiscard]] std::string url_components::to_string() const {
  std::string answer;
  auto back = std::back_insert_iterator(answer);
  answer.append("{\n");

  answer.append("\t\"protocol_end\":\"");
  helpers::encode_json(std::to_string(protocol_end), back);
  answer.append("\",\n");

  answer.append("\t\"username_end\":\"");
  helpers::encode_json(std::to_string(username_end), back);
  answer.append("\",\n");

  answer.append("\t\"host_start\":\"");
  helpers::encode_json(std::to_string(host_start), back);
  answer.append("\",\n");

  answer.append("\t\"host_end\":\"");
  helpers::encode_json(std::to_string(host_end), back);
  answer.append("\",\n");

  answer.append("\t\"port\":\"");
  helpers::encode_json(std::to_string(port), back);
  answer.append("\",\n");

  answer.append("\t\"pathname_start\":\"");
  helpers::encode_json(std::to_string(pathname_start), back);
  answer.append("\",\n");

  answer.append("\t\"search_start\":\"");
  helpers::encode_json(std::to_string(search_start), back);
  answer.append("\",\n");

  answer.append("\t\"hash_start\":\"");
  helpers::encode_json(std::to_string(hash_start), back);
  answer.append("\",\n");

  answer.append("\n}");
  return answer;
}

}  // namespace ada
/* end file src/url_components.cpp */
/* begin file src/url_aggregator.cpp */

#include <string>
#include <string_view>

namespace ada {
template <bool has_state_override>
[[nodiscard]] ada_really_inline bool url_aggregator::parse_scheme_with_colon(
    const std::string_view input_with_colon) {
  ada_log("url_aggregator::parse_scheme_with_colon ", input_with_colon);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input_with_colon, buffer));
  std::string_view input{input_with_colon};
  input.remove_suffix(1);
  auto parsed_type = ada::scheme::get_scheme_type(input);
  bool is_input_special = (parsed_type != ada::scheme::NOT_SPECIAL);
  /**
   * In the common case, we will immediately recognize a special scheme (e.g.,
   *http, https), in which case, we can go really fast.
   **/
  if (is_input_special) {  // fast path!!!
    if (has_state_override) {
      // If url's scheme is not a special scheme and buffer is a special scheme,
      // then return.
      if (is_special() != is_input_special) {
        return false;
      }

      // If url includes credentials or has a non-null port, and buffer is
      // "file", then return.
      if ((has_credentials() || components.port != url_components::omitted) &&
          parsed_type == ada::scheme::type::FILE) {
        return false;
      }

      // If url's scheme is "file" and its host is an empty host, then return.
      // An empty host is the empty string.
      if (type == ada::scheme::type::FILE &&
          components.host_start == components.host_end) {
        return false;
      }
    }

    type = parsed_type;
    set_scheme_from_view_with_colon(input_with_colon);

    if (has_state_override) {
      // This is uncommon.
      uint16_t urls_scheme_port = get_special_port();

      // If url's port is url's scheme's default port, then set url's port to
      // null.
      if (components.port == urls_scheme_port) {
        clear_port();
      }
    }
  } else {  // slow path
    std::string _buffer(input);
    // Next function is only valid if the input is ASCII and returns false
    // otherwise, but it seems that we always have ascii content so we do not
    // need to check the return value.
    unicode::to_lower_ascii(_buffer.data(), _buffer.size());

    if (has_state_override) {
      // If url's scheme is a special scheme and buffer is not a special scheme,
      // then return. If url's scheme is not a special scheme and buffer is a
      // special scheme, then return.
      if (is_special() != ada::scheme::is_special(_buffer)) {
        return true;
      }

      // If url includes credentials or has a non-null port, and buffer is
      // "file", then return.
      if ((has_credentials() || components.port != url_components::omitted) &&
          _buffer == "file") {
        return true;
      }

      // If url's scheme is "file" and its host is an empty host, then return.
      // An empty host is the empty string.
      if (type == ada::scheme::type::FILE &&
          components.host_start == components.host_end) {
        return true;
      }
    }

    set_scheme(_buffer);

    if (has_state_override) {
      // This is uncommon.
      uint16_t urls_scheme_port = get_special_port();

      // If url's port is url's scheme's default port, then set url's port to
      // null.
      if (components.port == urls_scheme_port) {
        clear_port();
      }
    }
  }
  ADA_ASSERT_TRUE(validate());
  return true;
}

inline void url_aggregator::copy_scheme(const url_aggregator& u) noexcept {
  ada_log("url_aggregator::copy_scheme ", u.buffer);
  ADA_ASSERT_TRUE(validate());
  // next line could overflow but unsigned arithmetic has well-defined
  // overflows.
  uint32_t new_difference = u.components.protocol_end - components.protocol_end;
  type = u.type;
  buffer.erase(0, components.protocol_end);
  buffer.insert(0, u.get_protocol());
  components.protocol_end = u.components.protocol_end;

  // No need to update the components
  if (new_difference == 0) {
    return;
  }

  // Update the rest of the components.
  components.username_end += new_difference;
  components.host_start += new_difference;
  components.host_end += new_difference;
  components.pathname_start += new_difference;
  if (components.search_start != url_components::omitted) {
    components.search_start += new_difference;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += new_difference;
  }
  ADA_ASSERT_TRUE(validate());
}

inline void url_aggregator::set_scheme_from_view_with_colon(
    std::string_view new_scheme_with_colon) noexcept {
  ada_log("url_aggregator::set_scheme_from_view_with_colon ",
          new_scheme_with_colon);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!new_scheme_with_colon.empty() &&
                  new_scheme_with_colon.back() == ':');
  // next line could overflow but unsigned arithmetic has well-defined
  // overflows.
  uint32_t new_difference =
      uint32_t(new_scheme_with_colon.size()) - components.protocol_end;

  if (buffer.empty()) {
    buffer.append(new_scheme_with_colon);
  } else {
    buffer.erase(0, components.protocol_end);
    buffer.insert(0, new_scheme_with_colon);
  }
  components.protocol_end += new_difference;

  // Update the rest of the components.
  components.username_end += new_difference;
  components.host_start += new_difference;
  components.host_end += new_difference;
  components.pathname_start += new_difference;
  if (components.search_start != url_components::omitted) {
    components.search_start += new_difference;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += new_difference;
  }
  ADA_ASSERT_TRUE(validate());
}

inline void url_aggregator::set_scheme(std::string_view new_scheme) noexcept {
  ada_log("url_aggregator::set_scheme ", new_scheme);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(new_scheme.empty() || new_scheme.back() != ':');
  // next line could overflow but unsigned arithmetic has well-defined
  // overflows.
  uint32_t new_difference =
      uint32_t(new_scheme.size()) - components.protocol_end + 1;

  type = ada::scheme::get_scheme_type(new_scheme);
  if (buffer.empty()) {
    buffer.append(helpers::concat(new_scheme, ":"));
  } else {
    buffer.erase(0, components.protocol_end);
    buffer.insert(0, helpers::concat(new_scheme, ":"));
  }
  components.protocol_end = uint32_t(new_scheme.size() + 1);

  // Update the rest of the components.
  components.username_end += new_difference;
  components.host_start += new_difference;
  components.host_end += new_difference;
  components.pathname_start += new_difference;
  if (components.search_start != url_components::omitted) {
    components.search_start += new_difference;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += new_difference;
  }
  ADA_ASSERT_TRUE(validate());
}

bool url_aggregator::set_protocol(const std::string_view input) {
  ada_log("url_aggregator::set_protocol ", input);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  std::string view(input);
  helpers::remove_ascii_tab_or_newline(view);
  if (view.empty()) {
    return true;
  }

  // Schemes should start with alpha values.
  if (!checkers::is_alpha(view[0])) {
    return false;
  }

  view.append(":");

  std::string::iterator pointer =
      std::find_if_not(view.begin(), view.end(), unicode::is_alnum_plus);

  if (pointer != view.end() && *pointer == ':') {
    return parse_scheme_with_colon<true>(
        std::string_view(view.data(), pointer - view.begin() + 1));
  }
  return false;
}

bool url_aggregator::set_username(const std::string_view input) {
  ada_log("url_aggregator::set_username '", input, "' ");
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  if (cannot_have_credentials_or_port()) {
    return false;
  }
  size_t idx = ada::unicode::percent_encode_index(
      input, character_sets::USERINFO_PERCENT_ENCODE);
  if (idx == input.size()) {
    update_base_username(input);
  } else {
    // We only create a temporary string if we have to!
    update_base_username(ada::unicode::percent_encode(
        input, character_sets::USERINFO_PERCENT_ENCODE, idx));
  }
  ADA_ASSERT_TRUE(validate());
  return true;
}

bool url_aggregator::set_password(const std::string_view input) {
  ada_log("url_aggregator::set_password '", input, "'");
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  if (cannot_have_credentials_or_port()) {
    return false;
  }
  size_t idx = ada::unicode::percent_encode_index(
      input, character_sets::USERINFO_PERCENT_ENCODE);
  if (idx == input.size()) {
    update_base_password(input);
  } else {
    // We only create a temporary string if we have to!
    update_base_password(ada::unicode::percent_encode(
        input, character_sets::USERINFO_PERCENT_ENCODE, idx));
  }
  ADA_ASSERT_TRUE(validate());
  return true;
}

bool url_aggregator::set_port(const std::string_view input) {
  ada_log("url_aggregator::set_port ", input);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  if (cannot_have_credentials_or_port()) {
    return false;
  }
  std::string trimmed(input);
  helpers::remove_ascii_tab_or_newline(trimmed);
  if (trimmed.empty()) {
    clear_port();
    return true;
  }
  // Input should not start with control characters.
  if (ada::unicode::is_c0_control_or_space(trimmed.front())) {
    return false;
  }
  // Input should contain at least one ascii digit.
  if (input.find_first_of("0123456789") == std::string_view::npos) {
    return false;
  }

  // Revert changes if parse_port fails.
  uint32_t previous_port = components.port;
  parse_port(trimmed);
  if (is_valid) {
    return true;
  }
  update_base_port(previous_port);
  is_valid = true;
  ADA_ASSERT_TRUE(validate());
  return false;
}

bool url_aggregator::set_pathname(const std::string_view input) {
  ada_log("url_aggregator::set_pathname ", input);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  if (has_opaque_path) {
    return false;
  }
  clear_pathname();
  parse_path(input);
  if (checkers::begins_with(get_pathname(), "//") && !has_authority() &&
      !has_dash_dot()) {
    buffer.insert(components.pathname_start, "/.");
    components.pathname_start += 2;
  }
  ADA_ASSERT_TRUE(validate());
  return true;
}

ada_really_inline void url_aggregator::parse_path(std::string_view input) {
  ada_log("url_aggregator::parse_path ", input);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  std::string tmp_buffer;
  std::string_view internal_input;
  if (unicode::has_tabs_or_newline(input)) {
    tmp_buffer = input;
    // Optimization opportunity: Instead of copying and then pruning, we could
    // just directly build the string from user_input.
    helpers::remove_ascii_tab_or_newline(tmp_buffer);
    internal_input = tmp_buffer;
  } else {
    internal_input = input;
  }

  // If url is special, then:
  if (is_special()) {
    if (internal_input.empty()) {
      update_base_pathname("/");
    } else if ((internal_input[0] == '/') || (internal_input[0] == '\\')) {
      consume_prepared_path(internal_input.substr(1));
    } else {
      consume_prepared_path(internal_input);
    }
  } else if (!internal_input.empty()) {
    if (internal_input[0] == '/') {
      consume_prepared_path(internal_input.substr(1));
    } else {
      consume_prepared_path(internal_input);
    }
  } else {
    // Non-special URLs with an empty host can have their paths erased
    // Path-only URLs cannot have their paths erased
    if (components.host_start == components.host_end && !has_authority()) {
      update_base_pathname("/");
    }
  }
  ADA_ASSERT_TRUE(validate());
}

void url_aggregator::set_search(const std::string_view input) {
  ada_log("url_aggregator::set_search ", input);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  if (input.empty()) {
    clear_search();
    helpers::strip_trailing_spaces_from_opaque_path(*this);
    return;
  }

  std::string new_value;
  new_value = input[0] == '?' ? input.substr(1) : input;
  helpers::remove_ascii_tab_or_newline(new_value);

  auto query_percent_encode_set =
      is_special() ? ada::character_sets::SPECIAL_QUERY_PERCENT_ENCODE
                   : ada::character_sets::QUERY_PERCENT_ENCODE;

  update_base_search(new_value, query_percent_encode_set);
  ADA_ASSERT_TRUE(validate());
}

void url_aggregator::set_hash(const std::string_view input) {
  ada_log("url_aggregator::set_hash ", input);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  if (input.empty()) {
    if (components.hash_start != url_components::omitted) {
      buffer.resize(components.hash_start);
      components.hash_start = url_components::omitted;
    }
    helpers::strip_trailing_spaces_from_opaque_path(*this);
    return;
  }

  std::string new_value;
  new_value = input[0] == '#' ? input.substr(1) : input;
  helpers::remove_ascii_tab_or_newline(new_value);
  update_unencoded_base_hash(new_value);
  ADA_ASSERT_TRUE(validate());
}

bool url_aggregator::set_href(const std::string_view input) {
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  ada_log("url_aggregator::set_href ", input, " [", input.size(), " bytes]");
  ada::result<url_aggregator> out = ada::parse<url_aggregator>(input);
  ada_log("url_aggregator::set_href, success :", out.has_value());

  if (out) {
    ada_log("url_aggregator::set_href, parsed ", out->to_string());
    // TODO: Figure out why the following line puts test to never finish.
    *this = *out;
  }

  return out.has_value();
}

ada_really_inline bool url_aggregator::parse_host(std::string_view input) {
  ada_log("url_aggregator:parse_host \"", input, "\" [", input.size(),
          " bytes]");
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  if (input.empty()) {
    return is_valid = false;
  }  // technically unnecessary.
  // If input starts with U+005B ([), then:
  if (input[0] == '[') {
    // If input does not end with U+005D (]), validation error, return failure.
    if (input.back() != ']') {
      return is_valid = false;
    }
    ada_log("parse_host ipv6");

    // Return the result of IPv6 parsing input with its leading U+005B ([) and
    // trailing U+005D (]) removed.
    input.remove_prefix(1);
    input.remove_suffix(1);
    return parse_ipv6(input);
  }

  // If isNotSpecial is true, then return the result of opaque-host parsing
  // input.
  if (!is_special()) {
    return parse_opaque_host(input);
  }
  // Let domain be the result of running UTF-8 decode without BOM on the
  // percent-decoding of input. Let asciiDomain be the result of running domain
  // to ASCII with domain and false. The most common case is an ASCII input, in
  // which case we do not need to call the expensive 'to_ascii' if a few
  // conditions are met: no '%' and no 'xn-' subsequence.

  // Often, the input does not contain any forbidden code points, and no upper
  // case ASCII letter, then we can just copy it to the buffer. We want to
  // optimize for such a common case.
  uint8_t is_forbidden_or_upper =
      unicode::contains_forbidden_domain_code_point_or_upper(input.data(),
                                                             input.size());
  // Minor optimization opportunity:
  // contains_forbidden_domain_code_point_or_upper could be extend to check for
  // the presence of characters that cannot appear in the ipv4 address and we
  // could also check whether x and n and - are present, and so we could skip
  // some of the checks below. However, the gains are likely to be small, and
  // the code would be more complex.
  if (is_forbidden_or_upper == 0 &&
      input.find("xn-") == std::string_view::npos) {
    // fast path
    update_base_hostname(input);
    if (checkers::is_ipv4(get_hostname())) {
      ada_log("parse_host fast path ipv4");
      return parse_ipv4(get_hostname(), true);
    }
    ada_log("parse_host fast path ", get_hostname());
    return true;
  }
  // We have encountered at least one forbidden code point or the input contains
  // 'xn-' (case insensitive), so we need to call 'to_ascii' to perform the full
  // conversion.

  ada_log("parse_host calling to_ascii");
  std::optional<std::string> host = std::string(get_hostname());
  is_valid = ada::unicode::to_ascii(host, input, input.find('%'));
  if (!is_valid) {
    ada_log("parse_host to_ascii returns false");
    return is_valid = false;
  }
  ada_log("parse_host to_ascii succeeded ", *host, " [", host->size(),
          " bytes]");

  if (std::any_of(host.value().begin(), host.value().end(),
                  ada::unicode::is_forbidden_domain_code_point)) {
    return is_valid = false;
  }

  // If asciiDomain ends in a number, then return the result of IPv4 parsing
  // asciiDomain.
  if (checkers::is_ipv4(host.value())) {
    ada_log("parse_host got ipv4 ", *host);
    return parse_ipv4(host.value(), false);
  }

  update_base_hostname(host.value());
  ADA_ASSERT_TRUE(validate());
  return true;
}

template <bool override_hostname>
bool url_aggregator::set_host_or_hostname(const std::string_view input) {
  ada_log("url_aggregator::set_host_or_hostname ", input);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  if (has_opaque_path) {
    return false;
  }

  std::string previous_host(get_hostname());
  uint32_t previous_port = components.port;

  size_t host_end_pos = input.find('#');
  std::string _host(input.data(), host_end_pos != std::string_view::npos
                                      ? host_end_pos
                                      : input.size());
  helpers::remove_ascii_tab_or_newline(_host);
  std::string_view new_host(_host);

  // If url's scheme is "file", then set state to file host state, instead of
  // host state.
  if (type != ada::scheme::type::FILE) {
    std::string_view host_view(_host.data(), _host.length());
    auto [location, found_colon] =
        helpers::get_host_delimiter_location(is_special(), host_view);

    // Otherwise, if c is U+003A (:) and insideBrackets is false, then:
    // Note: the 'found_colon' value is true if and only if a colon was
    // encountered while not inside brackets.
    if (found_colon) {
      if (override_hostname) {
        return false;
      }
      std::string_view sub_buffer = new_host.substr(location + 1);
      if (!sub_buffer.empty()) {
        set_port(sub_buffer);
      }
    }
    // If url is special and host_view is the empty string, validation error,
    // return failure. Otherwise, if state override is given, host_view is the
    // empty string, and either url includes credentials or url's port is
    // non-null, return.
    else if (host_view.empty() &&
             (is_special() || has_credentials() || has_port())) {
      return false;
    }

    // Let host be the result of host parsing host_view with url is not special.
    if (host_view.empty() && !is_special()) {
      if (has_hostname()) {
        clear_hostname();  // easy!
      } else if (has_dash_dot()) {
        add_authority_slashes_if_needed();
        delete_dash_dot();
      }
      return true;
    }

    bool succeeded = parse_host(host_view);
    if (!succeeded) {
      update_base_hostname(previous_host);
      update_base_port(previous_port);
    } else if (has_dash_dot()) {
      // Should remove dash_dot from pathname
      delete_dash_dot();
    }
    return succeeded;
  }

  size_t location = new_host.find_first_of("/\\?");
  if (location != std::string_view::npos) {
    new_host.remove_suffix(new_host.length() - location);
  }

  if (new_host.empty()) {
    // Set url's host to the empty string.
    clear_hostname();
  } else {
    // Let host be the result of host parsing buffer with url is not special.
    if (!parse_host(new_host)) {
      update_base_hostname(previous_host);
      update_base_port(previous_port);
      return false;
    }

    // If host is "localhost", then set host to the empty string.
    if (helpers::substring(buffer, components.host_start,
                           components.host_end) == "localhost") {
      clear_hostname();
    }
  }
  ADA_ASSERT_TRUE(validate());
  return true;
}

bool url_aggregator::set_host(const std::string_view input) {
  ada_log("url_aggregator::set_host '", input, "'");
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  return set_host_or_hostname<false>(input);
}

bool url_aggregator::set_hostname(const std::string_view input) {
  ada_log("url_aggregator::set_hostname '", input, "'");
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  return set_host_or_hostname<true>(input);
}

[[nodiscard]] std::string url_aggregator::get_origin() const noexcept {
  ada_log("url_aggregator::get_origin");
  if (is_special()) {
    // Return a new opaque origin.
    if (type == scheme::FILE) {
      return "null";
    }

    return helpers::concat(get_protocol(), "//", get_host());
  }

  if (get_protocol() == "blob:") {
    std::string_view path = get_pathname();
    if (!path.empty()) {
      auto out = ada::parse<ada::url_aggregator>(path);
      if (out && (out->type == scheme::HTTP || out->type == scheme::HTTPS)) {
        // If pathURL's scheme is not "http" and not "https", then return a
        // new opaque origin.
        return helpers::concat(out->get_protocol(), "//", out->get_host());
      }
    }
  }

  // Return a new opaque origin.
  return "null";
}

[[nodiscard]] std::string_view url_aggregator::get_username() const noexcept
    ada_lifetime_bound {
  ada_log("url_aggregator::get_username");
  if (has_non_empty_username()) {
    return helpers::substring(buffer, components.protocol_end + 2,
                              components.username_end);
  }
  return "";
}

[[nodiscard]] std::string_view url_aggregator::get_password() const noexcept
    ada_lifetime_bound {
  ada_log("url_aggregator::get_password");
  if (has_non_empty_password()) {
    return helpers::substring(buffer, components.username_end + 1,
                              components.host_start);
  }
  return "";
}

[[nodiscard]] std::string_view url_aggregator::get_port() const noexcept
    ada_lifetime_bound {
  ada_log("url_aggregator::get_port");
  if (components.port == url_components::omitted) {
    return "";
  }
  return helpers::substring(buffer, components.host_end + 1,
                            components.pathname_start);
}

[[nodiscard]] std::string_view url_aggregator::get_hash() const noexcept
    ada_lifetime_bound {
  ada_log("url_aggregator::get_hash");
  // If this's URL's fragment is either null or the empty string, then return
  // the empty string. Return U+0023 (#), followed by this's URL's fragment.
  if (components.hash_start == url_components::omitted) {
    return "";
  }
  if (buffer.size() - components.hash_start <= 1) {
    return "";
  }
  return helpers::substring(buffer, components.hash_start);
}

[[nodiscard]] std::string_view url_aggregator::get_host() const noexcept
    ada_lifetime_bound {
  ada_log("url_aggregator::get_host");
  // Technically, we should check if there is a hostname, but
  // the code below works even if there isn't.
  // if(!has_hostname()) { return ""; }
  size_t start = components.host_start;
  if (components.host_end > components.host_start &&
      buffer[components.host_start] == '@') {
    start++;
  }
  // if we have an empty host, then the space between components.host_end and
  // components.pathname_start may be occupied by /.
  if (start == components.host_end) {
    return {};
  }
  return helpers::substring(buffer, start, components.pathname_start);
}

[[nodiscard]] std::string_view url_aggregator::get_hostname() const noexcept
    ada_lifetime_bound {
  ada_log("url_aggregator::get_hostname");
  // Technically, we should check if there is a hostname, but
  // the code below works even if there isn't.
  // if(!has_hostname()) { return ""; }
  size_t start = components.host_start;
  // So host_start is not where the host begins.
  if (components.host_end > components.host_start &&
      buffer[components.host_start] == '@') {
    start++;
  }
  return helpers::substring(buffer, start, components.host_end);
}

[[nodiscard]] std::string_view url_aggregator::get_pathname() const noexcept
    ada_lifetime_bound {
  ada_log("url_aggregator::get_pathname pathname_start = ",
          components.pathname_start, " buffer.size() = ", buffer.size(),
          " components.search_start = ", components.search_start,
          " components.hash_start = ", components.hash_start);
  auto ending_index = uint32_t(buffer.size());
  if (components.search_start != url_components::omitted) {
    ending_index = components.search_start;
  } else if (components.hash_start != url_components::omitted) {
    ending_index = components.hash_start;
  }
  return helpers::substring(buffer, components.pathname_start, ending_index);
}

[[nodiscard]] std::string_view url_aggregator::get_search() const noexcept
    ada_lifetime_bound {
  ada_log("url_aggregator::get_search");
  // If this's URL's query is either null or the empty string, then return the
  // empty string. Return U+003F (?), followed by this's URL's query.
  if (components.search_start == url_components::omitted) {
    return "";
  }
  auto ending_index = uint32_t(buffer.size());
  if (components.hash_start != url_components::omitted) {
    ending_index = components.hash_start;
  }
  if (ending_index - components.search_start <= 1) {
    return "";
  }
  return helpers::substring(buffer, components.search_start, ending_index);
}

[[nodiscard]] std::string_view url_aggregator::get_protocol() const noexcept
    ada_lifetime_bound {
  ada_log("url_aggregator::get_protocol");
  return helpers::substring(buffer, 0, components.protocol_end);
}

[[nodiscard]] std::string ada::url_aggregator::to_string() const {
  ada_log("url_aggregator::to_string buffer:", buffer, " [", buffer.size(),
          " bytes]");
  if (!is_valid) {
    return "null";
  }

  std::string answer;
  auto back = std::back_insert_iterator(answer);
  answer.append("{\n");

  answer.append("\t\"buffer\":\"");
  helpers::encode_json(buffer, back);
  answer.append("\",\n");

  answer.append("\t\"protocol\":\"");
  helpers::encode_json(get_protocol(), back);
  answer.append("\",\n");

  if (has_credentials()) {
    answer.append("\t\"username\":\"");
    helpers::encode_json(get_username(), back);
    answer.append("\",\n");
    answer.append("\t\"password\":\"");
    helpers::encode_json(get_password(), back);
    answer.append("\",\n");
  }

  answer.append("\t\"host\":\"");
  helpers::encode_json(get_host(), back);
  answer.append("\",\n");

  answer.append("\t\"path\":\"");
  helpers::encode_json(get_pathname(), back);
  answer.append("\",\n");
  answer.append("\t\"opaque path\":");
  answer.append((has_opaque_path ? "true" : "false"));
  answer.append(",\n");

  if (components.search_start != url_components::omitted) {
    answer.append("\t\"query\":\"");
    helpers::encode_json(get_search(), back);
    answer.append("\",\n");
  }
  if (components.hash_start != url_components::omitted) {
    answer.append("\t\"fragment\":\"");
    helpers::encode_json(get_hash(), back);
    answer.append("\",\n");
  }

  auto convert_offset_to_string = [](uint32_t offset) -> std::string {
    if (offset == url_components::omitted) {
      return "null";
    } else {
      return std::to_string(offset);
    }
  };

  answer.append("\t\"protocol_end\":");
  answer.append(convert_offset_to_string(components.protocol_end));
  answer.append(",\n");

  answer.append("\t\"username_end\":");
  answer.append(convert_offset_to_string(components.username_end));
  answer.append(",\n");

  answer.append("\t\"host_start\":");
  answer.append(convert_offset_to_string(components.host_start));
  answer.append(",\n");

  answer.append("\t\"host_end\":");
  answer.append(convert_offset_to_string(components.host_end));
  answer.append(",\n");

  answer.append("\t\"port\":");
  answer.append(convert_offset_to_string(components.port));
  answer.append(",\n");

  answer.append("\t\"pathname_start\":");
  answer.append(convert_offset_to_string(components.pathname_start));
  answer.append(",\n");

  answer.append("\t\"search_start\":");
  answer.append(convert_offset_to_string(components.search_start));
  answer.append(",\n");

  answer.append("\t\"hash_start\":");
  answer.append(convert_offset_to_string(components.hash_start));
  answer.append("\n}");

  return answer;
}

[[nodiscard]] bool url_aggregator::has_valid_domain() const noexcept {
  if (components.host_start == components.host_end) {
    return false;
  }
  return checkers::verify_dns_length(get_hostname());
}

bool url_aggregator::parse_ipv4(std::string_view input, bool in_place) {
  ada_log("parse_ipv4 ", input, " [", input.size(),
          " bytes], overlaps with buffer: ",
          helpers::overlaps(input, buffer) ? "yes" : "no");
  ADA_ASSERT_TRUE(validate());
  const bool trailing_dot = (input.back() == '.');
  if (trailing_dot) {
    input.remove_suffix(1);
  }
  size_t digit_count{0};
  int pure_decimal_count = 0;  // entries that are decimal
  uint64_t ipv4{0};
  // we could unroll for better performance?
  for (; (digit_count < 4) && !(input.empty()); digit_count++) {
    uint32_t
        segment_result{};  // If any number exceeds 32 bits, we have an error.
    bool is_hex = checkers::has_hex_prefix(input);
    if (is_hex && ((input.length() == 2) ||
                   ((input.length() > 2) && (input[2] == '.')))) {
      // special case
      segment_result = 0;
      input.remove_prefix(2);
    } else {
      std::from_chars_result r{};
      if (is_hex) {
        ada_log("parse_ipv4 trying to parse hex number");
        r = std::from_chars(input.data() + 2, input.data() + input.size(),
                            segment_result, 16);
      } else if ((input.length() >= 2) && input[0] == '0' &&
                 checkers::is_digit(input[1])) {
        ada_log("parse_ipv4 trying to parse octal number");
        r = std::from_chars(input.data() + 1, input.data() + input.size(),
                            segment_result, 8);
      } else {
        ada_log("parse_ipv4 trying to parse decimal number");
        pure_decimal_count++;
        r = std::from_chars(input.data(), input.data() + input.size(),
                            segment_result, 10);
      }
      if (r.ec != std::errc()) {
        ada_log("parse_ipv4 parsing failed");
        return is_valid = false;
      }
      ada_log("parse_ipv4 parsed ", segment_result);
      input.remove_prefix(r.ptr - input.data());
    }
    if (input.empty()) {
      // We have the last value.
      // At this stage, ipv4 contains digit_count*8 bits.
      // So we have 32-digit_count*8 bits left.
      if (segment_result >= (uint64_t(1) << (32 - digit_count * 8))) {
        return is_valid = false;
      }
      ipv4 <<= (32 - digit_count * 8);
      ipv4 |= segment_result;
      goto final;
    } else {
      // There is more, so that the value must no be larger than 255
      // and we must have a '.'.
      if ((segment_result > 255) || (input[0] != '.')) {
        return is_valid = false;
      }
      ipv4 <<= 8;
      ipv4 |= segment_result;
      input.remove_prefix(1);  // remove '.'
    }
  }
  if ((digit_count != 4) || (!input.empty())) {
    ada_log("parse_ipv4 found invalid (more than 4 numbers or empty) ");
    return is_valid = false;
  }
final:
  ada_log("url_aggregator::parse_ipv4 completed ", get_href(),
          " host: ", get_host());

  // We could also check r.ptr to see where the parsing ended.
  if (in_place && pure_decimal_count == 4 && !trailing_dot) {
    ada_log(
        "url_aggregator::parse_ipv4 completed and was already correct in the "
        "buffer");
    // The original input was already all decimal and we validated it. So we
    // don't need to do anything.
  } else {
    ada_log("url_aggregator::parse_ipv4 completed and we need to update it");
    // Optimization opportunity: Get rid of unnecessary string return in ipv4
    // serializer.
    // TODO: This is likely a bug because it goes back update_base_hostname, not
    // what we want to do.
    update_base_hostname(
        ada::serializers::ipv4(ipv4));  // We have to reserialize the address.
  }
  host_type = IPV4;
  ADA_ASSERT_TRUE(validate());
  return true;
}

bool url_aggregator::parse_ipv6(std::string_view input) {
  // TODO: Implement in_place optimization: we know that input points
  // in the buffer, so we can just check whether the buffer is already
  // well formatted.
  // TODO: Find a way to merge parse_ipv6 with url.cpp implementation.
  ada_log("parse_ipv6 ", input, " [", input.size(), " bytes]");
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  if (input.empty()) {
    return is_valid = false;
  }
  // Let address be a new IPv6 address whose IPv6 pieces are all 0.
  std::array<uint16_t, 8> address{};

  // Let pieceIndex be 0.
  int piece_index = 0;

  // Let compress be null.
  std::optional<int> compress{};

  // Let pointer be a pointer for input.
  std::string_view::iterator pointer = input.begin();

  // If c is U+003A (:), then:
  if (input[0] == ':') {
    // If remaining does not start with U+003A (:), validation error, return
    // failure.
    if (input.size() == 1 || input[1] != ':') {
      ada_log("parse_ipv6 starts with : but the rest does not start with :");
      return is_valid = false;
    }

    // Increase pointer by 2.
    pointer += 2;

    // Increase pieceIndex by 1 and then set compress to pieceIndex.
    compress = ++piece_index;
  }

  // While c is not the EOF code point:
  while (pointer != input.end()) {
    // If pieceIndex is 8, validation error, return failure.
    if (piece_index == 8) {
      ada_log("parse_ipv6 piece_index == 8");
      return is_valid = false;
    }

    // If c is U+003A (:), then:
    if (*pointer == ':') {
      // If compress is non-null, validation error, return failure.
      if (compress.has_value()) {
        ada_log("parse_ipv6 compress is non-null");
        return is_valid = false;
      }

      // Increase pointer and pieceIndex by 1, set compress to pieceIndex, and
      // then continue.
      pointer++;
      compress = ++piece_index;
      continue;
    }

    // Let value and length be 0.
    uint16_t value = 0, length = 0;

    // While length is less than 4 and c is an ASCII hex digit,
    // set value to value times 0x10 + c interpreted as hexadecimal number, and
    // increase pointer and length by 1.
    while (length < 4 && pointer != input.end() &&
           unicode::is_ascii_hex_digit(*pointer)) {
      // https://stackoverflow.com/questions/39060852/why-does-the-addition-of-two-shorts-return-an-int
      value = uint16_t(value * 0x10 + unicode::convert_hex_to_binary(*pointer));
      pointer++;
      length++;
    }

    // If c is U+002E (.), then:
    if (pointer != input.end() && *pointer == '.') {
      // If length is 0, validation error, return failure.
      if (length == 0) {
        ada_log("parse_ipv6 length is 0");
        return is_valid = false;
      }

      // Decrease pointer by length.
      pointer -= length;

      // If pieceIndex is greater than 6, validation error, return failure.
      if (piece_index > 6) {
        ada_log("parse_ipv6 piece_index > 6");
        return is_valid = false;
      }

      // Let numbersSeen be 0.
      int numbers_seen = 0;

      // While c is not the EOF code point:
      while (pointer != input.end()) {
        // Let ipv4Piece be null.
        std::optional<uint16_t> ipv4_piece{};

        // If numbersSeen is greater than 0, then:
        if (numbers_seen > 0) {
          // If c is a U+002E (.) and numbersSeen is less than 4, then increase
          // pointer by 1.
          if (*pointer == '.' && numbers_seen < 4) {
            pointer++;
          } else {
            // Otherwise, validation error, return failure.
            ada_log("parse_ipv6 Otherwise, validation error, return failure");
            return is_valid = false;
          }
        }

        // If c is not an ASCII digit, validation error, return failure.
        if (pointer == input.end() || !checkers::is_digit(*pointer)) {
          ada_log(
              "parse_ipv6 If c is not an ASCII digit, validation error, return "
              "failure");
          return is_valid = false;
        }

        // While c is an ASCII digit:
        while (pointer != input.end() && checkers::is_digit(*pointer)) {
          // Let number be c interpreted as decimal number.
          int number = *pointer - '0';

          // If ipv4Piece is null, then set ipv4Piece to number.
          if (!ipv4_piece.has_value()) {
            ipv4_piece = number;
          }
          // Otherwise, if ipv4Piece is 0, validation error, return failure.
          else if (ipv4_piece == 0) {
            ada_log("parse_ipv6 if ipv4Piece is 0, validation error");
            return is_valid = false;
          }
          // Otherwise, set ipv4Piece to ipv4Piece times 10 + number.
          else {
            ipv4_piece = *ipv4_piece * 10 + number;
          }

          // If ipv4Piece is greater than 255, validation error, return failure.
          if (ipv4_piece > 255) {
            ada_log("parse_ipv6 ipv4_piece > 255");
            return is_valid = false;
          }

          // Increase pointer by 1.
          pointer++;
        }

        // Set address[pieceIndex] to address[pieceIndex] times 0x100 +
        // ipv4Piece.
        // https://stackoverflow.com/questions/39060852/why-does-the-addition-of-two-shorts-return-an-int
        address[piece_index] =
            uint16_t(address[piece_index] * 0x100 + *ipv4_piece);

        // Increase numbersSeen by 1.
        numbers_seen++;

        // If numbersSeen is 2 or 4, then increase pieceIndex by 1.
        if (numbers_seen == 2 || numbers_seen == 4) {
          piece_index++;
        }
      }

      // If numbersSeen is not 4, validation error, return failure.
      if (numbers_seen != 4) {
        return is_valid = false;
      }

      // Break.
      break;
    }
    // Otherwise, if c is U+003A (:):
    else if ((pointer != input.end()) && (*pointer == ':')) {
      // Increase pointer by 1.
      pointer++;

      // If c is the EOF code point, validation error, return failure.
      if (pointer == input.end()) {
        ada_log(
            "parse_ipv6 If c is the EOF code point, validation error, return "
            "failure");
        return is_valid = false;
      }
    }
    // Otherwise, if c is not the EOF code point, validation error, return
    // failure.
    else if (pointer != input.end()) {
      ada_log(
          "parse_ipv6 Otherwise, if c is not the EOF code point, validation "
          "error, return failure");
      return is_valid = false;
    }

    // Set address[pieceIndex] to value.
    address[piece_index] = value;

    // Increase pieceIndex by 1.
    piece_index++;
  }

  // If compress is non-null, then:
  if (compress.has_value()) {
    // Let swaps be pieceIndex - compress.
    int swaps = piece_index - *compress;

    // Set pieceIndex to 7.
    piece_index = 7;

    // While pieceIndex is not 0 and swaps is greater than 0,
    // swap address[pieceIndex] with address[compress + swaps - 1], and then
    // decrease both pieceIndex and swaps by 1.
    while (piece_index != 0 && swaps > 0) {
      std::swap(address[piece_index], address[*compress + swaps - 1]);
      piece_index--;
      swaps--;
    }
  }
  // Otherwise, if compress is null and pieceIndex is not 8, validation error,
  // return failure.
  else if (piece_index != 8) {
    ada_log(
        "parse_ipv6 if compress is null and pieceIndex is not 8, validation "
        "error, return failure");
    return is_valid = false;
  }
  // TODO: Optimization opportunity: Get rid of unnecessary string creation.
  // TODO: This is likely a bug because it goes back update_base_hostname, not
  // what we want to do.
  update_base_hostname(ada::serializers::ipv6(address));
  ada_log("parse_ipv6 ", get_hostname());
  ADA_ASSERT_TRUE(validate());
  host_type = IPV6;
  return true;
}

bool url_aggregator::parse_opaque_host(std::string_view input) {
  ada_log("parse_opaque_host ", input, " [", input.size(), " bytes]");
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  if (std::any_of(input.begin(), input.end(),
                  ada::unicode::is_forbidden_host_code_point)) {
    return is_valid = false;
  }

  // Return the result of running UTF-8 percent-encode on input using the C0
  // control percent-encode set.
  size_t idx = ada::unicode::percent_encode_index(
      input, character_sets::C0_CONTROL_PERCENT_ENCODE);
  if (idx == input.size()) {
    update_base_hostname(input);
  } else {
    // We only create a temporary string if we need to.
    update_base_hostname(ada::unicode::percent_encode(
        input, character_sets::C0_CONTROL_PERCENT_ENCODE, idx));
  }
  ADA_ASSERT_TRUE(validate());
  return true;
}

[[nodiscard]] std::string url_aggregator::to_diagram() const {
  if (!is_valid) {
    return "invalid";
  }
  std::string answer;
  answer.append(buffer);
  answer.append(" [");
  answer.append(std::to_string(buffer.size()));
  answer.append(" bytes]");
  answer.append("\n");
  // first line
  std::string line1;
  line1.resize(buffer.size(), ' ');
  if (components.hash_start != url_components::omitted) {
    line1[components.hash_start] = '|';
  }
  if (components.search_start != url_components::omitted) {
    line1[components.search_start] = '|';
  }
  if (components.pathname_start != buffer.size()) {
    line1[components.pathname_start] = '|';
  }
  if (components.host_end != buffer.size()) {
    line1[components.host_end] = '|';
  }
  if (components.host_start != buffer.size()) {
    line1[components.host_start] = '|';
  }
  if (components.username_end != buffer.size()) {
    line1[components.username_end] = '|';
  }
  if (components.protocol_end != buffer.size()) {
    line1[components.protocol_end] = '|';
  }
  answer.append(line1);
  answer.append("\n");

  std::string line2 = line1;
  if (components.hash_start != url_components::omitted) {
    line2[components.hash_start] = '`';
    line1[components.hash_start] = ' ';

    for (size_t i = components.hash_start + 1; i < line2.size(); i++) {
      line2[i] = '-';
    }
    line2.append(" hash_start");
    answer.append(line2);
    answer.append("\n");
  }

  std::string line3 = line1;
  if (components.search_start != url_components::omitted) {
    line3[components.search_start] = '`';
    line1[components.search_start] = ' ';

    for (size_t i = components.search_start + 1; i < line3.size(); i++) {
      line3[i] = '-';
    }
    line3.append(" search_start ");
    line3.append(std::to_string(components.search_start));
    answer.append(line3);
    answer.append("\n");
  }

  std::string line4 = line1;
  if (components.pathname_start != buffer.size()) {
    line4[components.pathname_start] = '`';
    line1[components.pathname_start] = ' ';
    for (size_t i = components.pathname_start + 1; i < line4.size(); i++) {
      line4[i] = '-';
    }
    line4.append(" pathname_start ");
    line4.append(std::to_string(components.pathname_start));
    answer.append(line4);
    answer.append("\n");
  }

  std::string line5 = line1;
  if (components.host_end != buffer.size()) {
    line5[components.host_end] = '`';
    line1[components.host_end] = ' ';

    for (size_t i = components.host_end + 1; i < line5.size(); i++) {
      line5[i] = '-';
    }
    line5.append(" host_end ");
    line5.append(std::to_string(components.host_end));
    answer.append(line5);
    answer.append("\n");
  }

  std::string line6 = line1;
  if (components.host_start != buffer.size()) {
    line6[components.host_start] = '`';
    line1[components.host_start] = ' ';

    for (size_t i = components.host_start + 1; i < line6.size(); i++) {
      line6[i] = '-';
    }
    line6.append(" host_start ");
    line6.append(std::to_string(components.host_start));
    answer.append(line6);
    answer.append("\n");
  }

  std::string line7 = line1;
  if (components.username_end != buffer.size()) {
    line7[components.username_end] = '`';
    line1[components.username_end] = ' ';

    for (size_t i = components.username_end + 1; i < line7.size(); i++) {
      line7[i] = '-';
    }
    line7.append(" username_end ");
    line7.append(std::to_string(components.username_end));
    answer.append(line7);
    answer.append("\n");
  }

  std::string line8 = line1;
  if (components.protocol_end != buffer.size()) {
    line8[components.protocol_end] = '`';
    line1[components.protocol_end] = ' ';

    for (size_t i = components.protocol_end + 1; i < line8.size(); i++) {
      line8[i] = '-';
    }
    line8.append(" protocol_end ");
    line8.append(std::to_string(components.protocol_end));
    answer.append(line8);
    answer.append("\n");
  }

  if (components.hash_start == url_components::omitted) {
    answer.append("note: hash omitted\n");
  }
  if (components.search_start == url_components::omitted) {
    answer.append("note: search omitted\n");
  }
  if (components.protocol_end > buffer.size()) {
    answer.append("warning: protocol_end overflows\n");
  }
  if (components.username_end > buffer.size()) {
    answer.append("warning: username_end overflows\n");
  }
  if (components.host_start > buffer.size()) {
    answer.append("warning: host_start overflows\n");
  }
  if (components.host_end > buffer.size()) {
    answer.append("warning: host_end overflows\n");
  }
  if (components.pathname_start > buffer.size()) {
    answer.append("warning: pathname_start overflows\n");
  }
  return answer;
}

[[nodiscard]] bool url_aggregator::validate() const noexcept {
  if (!is_valid) {
    return true;
  }
  if (!components.check_offset_consistency()) {
    ada_log("url_aggregator::validate inconsistent components \n",
            to_diagram());
    return false;
  }
  // We have a credible components struct, but let us investivate more
  // carefully:
  /**
   * https://user:pass@example.com:1234/foo/bar?baz#quux
   *       |     |    |          | ^^^^|       |   |
   *       |     |    |          | |   |       |   `----- hash_start
   *       |     |    |          | |   |       `--------- search_start
   *       |     |    |          | |   `----------------- pathname_start
   *       |     |    |          | `--------------------- port
   *       |     |    |          `----------------------- host_end
   *       |     |    `---------------------------------- host_start
   *       |     `--------------------------------------- username_end
   *       `--------------------------------------------- protocol_end
   */
  if (components.protocol_end == url_components::omitted) {
    ada_log("url_aggregator::validate omitted protocol_end \n", to_diagram());
    return false;
  }
  if (components.username_end == url_components::omitted) {
    ada_log("url_aggregator::validate omitted username_end \n", to_diagram());
    return false;
  }
  if (components.host_start == url_components::omitted) {
    ada_log("url_aggregator::validate omitted host_start \n", to_diagram());
    return false;
  }
  if (components.host_end == url_components::omitted) {
    ada_log("url_aggregator::validate omitted host_end \n", to_diagram());
    return false;
  }
  if (components.pathname_start == url_components::omitted) {
    ada_log("url_aggregator::validate omitted pathname_start \n", to_diagram());
    return false;
  }

  if (components.protocol_end > buffer.size()) {
    ada_log("url_aggregator::validate protocol_end overflow \n", to_diagram());
    return false;
  }
  if (components.username_end > buffer.size()) {
    ada_log("url_aggregator::validate username_end overflow \n", to_diagram());
    return false;
  }
  if (components.host_start > buffer.size()) {
    ada_log("url_aggregator::validate host_start overflow \n", to_diagram());
    return false;
  }
  if (components.host_end > buffer.size()) {
    ada_log("url_aggregator::validate host_end overflow \n", to_diagram());
    return false;
  }
  if (components.pathname_start > buffer.size()) {
    ada_log("url_aggregator::validate pathname_start overflow \n",
            to_diagram());
    return false;
  }

  if (components.protocol_end > 0) {
    if (buffer[components.protocol_end - 1] != ':') {
      ada_log(
          "url_aggregator::validate missing : at the end of the protocol \n",
          to_diagram());
      return false;
    }
  }

  if (components.username_end != buffer.size() &&
      components.username_end > components.protocol_end + 2) {
    if (buffer[components.username_end] != ':' &&
        buffer[components.username_end] != '@') {
      ada_log(
          "url_aggregator::validate missing : or @ at the end of the username "
          "\n",
          to_diagram());
      return false;
    }
  }

  if (components.host_start != buffer.size()) {
    if (components.host_start > components.username_end) {
      if (buffer[components.host_start] != '@') {
        ada_log(
            "url_aggregator::validate missing @ at the end of the password \n",
            to_diagram());
        return false;
      }
    } else if (components.host_start == components.username_end &&
               components.host_end > components.host_start) {
      if (components.host_start == components.protocol_end + 2) {
        if (buffer[components.protocol_end] != '/' ||
            buffer[components.protocol_end + 1] != '/') {
          ada_log(
              "url_aggregator::validate missing // between protocol and host "
              "\n",
              to_diagram());
          return false;
        }
      } else {
        if (components.host_start > components.protocol_end &&
            buffer[components.host_start] != '@') {
          ada_log(
              "url_aggregator::validate missing @ at the end of the username "
              "\n",
              to_diagram());
          return false;
        }
      }
    } else {
      if (components.host_end != components.host_start) {
        ada_log("url_aggregator::validate expected omitted host \n",
                to_diagram());
        return false;
      }
    }
  }
  if (components.host_end != buffer.size() &&
      components.pathname_start > components.host_end) {
    if (components.pathname_start == components.host_end + 2 &&
        buffer[components.host_end] == '/' &&
        buffer[components.host_end + 1] == '.') {
      if (components.pathname_start + 1 >= buffer.size() ||
          buffer[components.pathname_start] != '/' ||
          buffer[components.pathname_start + 1] != '/') {
        ada_log(
            "url_aggregator::validate expected the path to begin with // \n",
            to_diagram());
        return false;
      }
    } else if (buffer[components.host_end] != ':') {
      ada_log("url_aggregator::validate missing : at the port \n",
              to_diagram());
      return false;
    }
  }
  if (components.pathname_start != buffer.size() &&
      components.pathname_start < components.search_start &&
      components.pathname_start < components.hash_start && !has_opaque_path) {
    if (buffer[components.pathname_start] != '/') {
      ada_log("url_aggregator::validate missing / at the path \n",
              to_diagram());
      return false;
    }
  }
  if (components.search_start != url_components::omitted) {
    if (buffer[components.search_start] != '?') {
      ada_log("url_aggregator::validate missing ? at the search \n",
              to_diagram());
      return false;
    }
  }
  if (components.hash_start != url_components::omitted) {
    if (buffer[components.hash_start] != '#') {
      ada_log("url_aggregator::validate missing # at the hash \n",
              to_diagram());
      return false;
    }
  }

  return true;
}

void url_aggregator::delete_dash_dot() {
  ada_log("url_aggregator::delete_dash_dot");
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(has_dash_dot());
  buffer.erase(components.host_end, 2);
  components.pathname_start -= 2;
  if (components.search_start != url_components::omitted) {
    components.search_start -= 2;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start -= 2;
  }
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!has_dash_dot());
}

inline void url_aggregator::consume_prepared_path(std::string_view input) {
  ada_log("url_aggregator::consume_prepared_path ", input);
  /***
   * This is largely duplicated code from helpers::parse_prepared_path, which is
   * unfortunate. This particular function is nearly identical, except that it
   * is a method on url_aggregator. The idea is that the trivial path (which is
   * very common) merely appends to the buffer. This is the same trivial path as
   * with helpers::parse_prepared_path, except that we have the additional check
   * for is_at_path(). Otherwise, we grab a copy of the current path and we
   * modify it, and then insert it back into the buffer.
   */
  uint8_t accumulator = checkers::path_signature(input);
  // Let us first detect a trivial case.
  // If it is special, we check that we have no dot, no %,  no \ and no
  // character needing percent encoding. Otherwise, we check that we have no %,
  // no dot, and no character needing percent encoding.
  constexpr uint8_t need_encoding = 1;
  constexpr uint8_t backslash_char = 2;
  constexpr uint8_t dot_char = 4;
  constexpr uint8_t percent_char = 8;
  bool special = type != ada::scheme::NOT_SPECIAL;
  bool may_need_slow_file_handling = (type == ada::scheme::type::FILE &&
                                      checkers::is_windows_drive_letter(input));
  bool trivial_path =
      (special ? (accumulator == 0)
               : ((accumulator & (need_encoding | dot_char | percent_char)) ==
                  0)) &&
      (!may_need_slow_file_handling);
  if (accumulator == dot_char && !may_need_slow_file_handling) {
    // '4' means that we have at least one dot, but nothing that requires
    // percent encoding or decoding. The only part that is not trivial is
    // that we may have single dots and double dots path segments.
    // If we have such segments, then we either have a path that begins
    // with '.' (easy to check), or we have the sequence './'.
    // Note: input cannot be empty, it must at least contain one character ('.')
    // Note: we know that '\' is not present.
    if (input[0] != '.') {
      size_t slashdot = input.find("/.");
      if (slashdot == std::string_view::npos) {  // common case
        trivial_path = true;
      } else {  // uncommon
        // only three cases matter: /./, /.. or a final /
        trivial_path =
            !(slashdot + 2 == input.size() || input[slashdot + 2] == '.' ||
              input[slashdot + 2] == '/');
      }
    }
  }
  if (trivial_path && is_at_path()) {
    ada_log("parse_path trivial");
    buffer += '/';
    buffer += input;
    return;
  }
  std::string path = std::string(get_pathname());
  // We are going to need to look a bit at the path, but let us see if we can
  // ignore percent encoding *and* backslashes *and* percent characters.
  // Except for the trivial case, this is likely to capture 99% of paths out
  // there.
  bool fast_path =
      (special &&
       (accumulator & (need_encoding | backslash_char | percent_char)) == 0) &&
      (type != ada::scheme::type::FILE);
  if (fast_path) {
    ada_log("parse_prepared_path fast");
    // Here we don't need to worry about \ or percent encoding.
    // We also do not have a file protocol. We might have dots, however,
    // but dots must as appear as '.', and they cannot be encoded because
    // the symbol '%' is not present.
    size_t previous_location = 0;  // We start at 0.
    do {
      size_t new_location = input.find('/', previous_location);
      // std::string_view path_view = input;
      //  We process the last segment separately:
      if (new_location == std::string_view::npos) {
        std::string_view path_view = input.substr(previous_location);
        if (path_view == "..") {  // The path ends with ..
          // e.g., if you receive ".." with an empty path, you go to "/".
          if (path.empty()) {
            path = '/';
            update_base_pathname(path);
            return;
          }
          // Fast case where we have nothing to do:
          if (path.back() == '/') {
            update_base_pathname(path);
            return;
          }
          // If you have the path "/joe/myfriend",
          // then you delete 'myfriend'.
          path.resize(path.rfind('/') + 1);
          update_base_pathname(path);
          return;
        }
        path += '/';
        if (path_view != ".") {
          path.append(path_view);
        }
        update_base_pathname(path);
        return;
      } else {
        // This is a non-final segment.
        std::string_view path_view =
            input.substr(previous_location, new_location - previous_location);
        previous_location = new_location + 1;
        if (path_view == "..") {
          size_t last_delimiter = path.rfind('/');
          if (last_delimiter != std::string::npos) {
            path.erase(last_delimiter);
          }
        } else if (path_view != ".") {
          path += '/';
          path.append(path_view);
        }
      }
    } while (true);
  } else {
    ada_log("parse_path slow");
    // we have reached the general case
    bool needs_percent_encoding = (accumulator & 1);
    std::string path_buffer_tmp;
    do {
      size_t location = (special && (accumulator & 2))
                            ? input.find_first_of("/\\")
                            : input.find('/');
      std::string_view path_view = input;
      if (location != std::string_view::npos) {
        path_view.remove_suffix(path_view.size() - location);
        input.remove_prefix(location + 1);
      }
      // path_buffer is either path_view or it might point at a percent encoded
      // temporary string.
      std::string_view path_buffer =
          (needs_percent_encoding &&
           ada::unicode::percent_encode<false>(
               path_view, character_sets::PATH_PERCENT_ENCODE, path_buffer_tmp))
              ? path_buffer_tmp
              : path_view;
      if (unicode::is_double_dot_path_segment(path_buffer)) {
        if ((helpers::shorten_path(path, type) || special) &&
            location == std::string_view::npos) {
          path += '/';
        }
      } else if (unicode::is_single_dot_path_segment(path_buffer) &&
                 (location == std::string_view::npos)) {
        path += '/';
      }
      // Otherwise, if path_buffer is not a single-dot path segment, then:
      else if (!unicode::is_single_dot_path_segment(path_buffer)) {
        // If url's scheme is "file", url's path is empty, and path_buffer is a
        // Windows drive letter, then replace the second code point in
        // path_buffer with U+003A (:).
        if (type == ada::scheme::type::FILE && path.empty() &&
            checkers::is_windows_drive_letter(path_buffer)) {
          path += '/';
          path += path_buffer[0];
          path += ':';
          path_buffer.remove_prefix(2);
          path.append(path_buffer);
        } else {
          // Append path_buffer to url's path.
          path += '/';
          path.append(path_buffer);
        }
      }
      if (location == std::string_view::npos) {
        update_base_pathname(path);
        return;
      }
    } while (true);
  }
}
}  // namespace ada
/* end file src/url_aggregator.cpp */
/* begin file src/ada_c.cpp */

ada::result<ada::url_aggregator>& get_instance(void* result) noexcept {
  return *(ada::result<ada::url_aggregator>*)result;
}

extern "C" {
typedef void* ada_url;
typedef void* ada_url_search_params;
typedef void* ada_strings;
typedef void* ada_url_search_params_keys_iter;
typedef void* ada_url_search_params_values_iter;
typedef void* ada_url_search_params_entries_iter;

struct ada_string {
  const char* data;
  size_t length;
};

struct ada_owned_string {
  const char* data;
  size_t length;
};

struct ada_string_pair {
  ada_string key;
  ada_string value;
};

ada_string ada_string_create(const char* data, size_t length) {
  ada_string out{};
  out.data = data;
  out.length = length;
  return out;
}

struct ada_url_components {
  /*
   * By using 32-bit integers, we implicitly assume that the URL string
   * cannot exceed 4 GB.
   *
   * https://user:pass@example.com:1234/foo/bar?baz#quux
   *       |     |    |          | ^^^^|       |   |
   *       |     |    |          | |   |       |   `----- hash_start
   *       |     |    |          | |   |       `--------- search_start
   *       |     |    |          | |   `----------------- pathname_start
   *       |     |    |          | `--------------------- port
   *       |     |    |          `----------------------- host_end
   *       |     |    `---------------------------------- host_start
   *       |     `--------------------------------------- username_end
   *       `--------------------------------------------- protocol_end
   */
  uint32_t protocol_end;
  /**
   * Username end is not `omitted` by default (-1) to make username and password
   * getters less costly to implement.
   */
  uint32_t username_end;
  uint32_t host_start;
  uint32_t host_end;
  uint32_t port;
  uint32_t pathname_start;
  uint32_t search_start;
  uint32_t hash_start;
};

ada_url ada_parse(const char* input, size_t length) noexcept {
  return new ada::result<ada::url_aggregator>(
      ada::parse<ada::url_aggregator>(std::string_view(input, length)));
}

ada_url ada_parse_with_base(const char* input, size_t input_length,
                            const char* base, size_t base_length) noexcept {
  auto base_out =
      ada::parse<ada::url_aggregator>(std::string_view(base, base_length));

  if (!base_out) {
    return new ada::result<ada::url_aggregator>(base_out);
  }

  return new ada::result<ada::url_aggregator>(ada::parse<ada::url_aggregator>(
      std::string_view(input, input_length), &base_out.value()));
}

bool ada_can_parse(const char* input, size_t length) noexcept {
  return ada::can_parse(std::string_view(input, length));
}

bool ada_can_parse_with_base(const char* input, size_t input_length,
                             const char* base, size_t base_length) noexcept {
  std::string_view base_view(base, base_length);
  return ada::can_parse(std::string_view(input, input_length), &base_view);
}

void ada_free(ada_url result) noexcept {
  auto* r = (ada::result<ada::url_aggregator>*)result;
  delete r;
}

ada_url ada_copy(ada_url input) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(input);
  return new ada::result<ada::url_aggregator>(r);
}

bool ada_is_valid(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  return r.has_value();
}

// caller must free the result with ada_free_owned_string
ada_owned_string ada_get_origin(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  ada_owned_string owned{};
  if (!r) {
    owned.data = nullptr;
    owned.length = 0;
    return owned;
  }
  std::string out = r->get_origin();
  owned.length = out.size();
  owned.data = new char[owned.length];
  memcpy((void*)owned.data, out.data(), owned.length);
  return owned;
}

void ada_free_owned_string(ada_owned_string owned) noexcept {
  delete[] owned.data;
}

ada_string ada_get_href(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  std::string_view out = r->get_href();
  return ada_string_create(out.data(), out.length());
}

ada_string ada_get_username(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  std::string_view out = r->get_username();
  return ada_string_create(out.data(), out.length());
}

ada_string ada_get_password(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  std::string_view out = r->get_password();
  return ada_string_create(out.data(), out.length());
}

ada_string ada_get_port(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  std::string_view out = r->get_port();
  return ada_string_create(out.data(), out.length());
}

ada_string ada_get_hash(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  std::string_view out = r->get_hash();
  return ada_string_create(out.data(), out.length());
}

ada_string ada_get_host(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  std::string_view out = r->get_host();
  return ada_string_create(out.data(), out.length());
}

ada_string ada_get_hostname(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  std::string_view out = r->get_hostname();
  return ada_string_create(out.data(), out.length());
}

ada_string ada_get_pathname(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  std::string_view out = r->get_pathname();
  return ada_string_create(out.data(), out.length());
}

ada_string ada_get_search(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  std::string_view out = r->get_search();
  return ada_string_create(out.data(), out.length());
}

ada_string ada_get_protocol(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  std::string_view out = r->get_protocol();
  return ada_string_create(out.data(), out.length());
}

uint8_t ada_get_host_type(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return 0;
  }
  return r->host_type;
}

uint8_t ada_get_scheme_type(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return 0;
  }
  return r->type;
}

bool ada_set_href(ada_url result, const char* input, size_t length) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->set_href(std::string_view(input, length));
}

bool ada_set_host(ada_url result, const char* input, size_t length) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->set_host(std::string_view(input, length));
}

bool ada_set_hostname(ada_url result, const char* input,
                      size_t length) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->set_hostname(std::string_view(input, length));
}

bool ada_set_protocol(ada_url result, const char* input,
                      size_t length) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->set_protocol(std::string_view(input, length));
}

bool ada_set_username(ada_url result, const char* input,
                      size_t length) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->set_username(std::string_view(input, length));
}

bool ada_set_password(ada_url result, const char* input,
                      size_t length) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->set_password(std::string_view(input, length));
}

bool ada_set_port(ada_url result, const char* input, size_t length) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->set_port(std::string_view(input, length));
}

bool ada_set_pathname(ada_url result, const char* input,
                      size_t length) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->set_pathname(std::string_view(input, length));
}

/**
 * Update the search/query of the URL.
 *
 * If a URL has `?` as the search value, passing empty string to this function
 * does not remove the attribute. If you need to remove it, please use
 * `ada_clear_search` method.
 */
void ada_set_search(ada_url result, const char* input, size_t length) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (r) {
    r->set_search(std::string_view(input, length));
  }
}

/**
 * Update the hash/fragment of the URL.
 *
 * If a URL has `#` as the hash value, passing empty string to this function
 * does not remove the attribute. If you need to remove it, please use
 * `ada_clear_hash` method.
 */
void ada_set_hash(ada_url result, const char* input, size_t length) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (r) {
    r->set_hash(std::string_view(input, length));
  }
}

void ada_clear_port(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (r) {
    r->clear_port();
  }
}

/**
 * Removes the hash of the URL.
 *
 * Despite `ada_set_hash` method, this function allows the complete
 * removal of the hash attribute, even if it has a value of `#`.
 */
void ada_clear_hash(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (r) {
    r->clear_hash();
  }
}

/**
 * Removes the search of the URL.
 *
 * Despite `ada_set_search` method, this function allows the complete
 * removal of the search attribute, even if it has a value of `?`.
 */
void ada_clear_search(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (r) {
    r->clear_search();
  }
}

bool ada_has_credentials(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->has_credentials();
}

bool ada_has_empty_hostname(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->has_empty_hostname();
}

bool ada_has_hostname(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->has_hostname();
}

bool ada_has_non_empty_username(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->has_non_empty_username();
}

bool ada_has_non_empty_password(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->has_non_empty_password();
}

bool ada_has_port(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->has_port();
}

bool ada_has_password(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->has_password();
}

bool ada_has_hash(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->has_hash();
}

bool ada_has_search(ada_url result) noexcept {
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return false;
  }
  return r->has_search();
}

// returns a pointer to the internal url_aggregator::url_components
const ada_url_components* ada_get_components(ada_url result) noexcept {
  static_assert(sizeof(ada_url_components) == sizeof(ada::url_components));
  ada::result<ada::url_aggregator>& r = get_instance(result);
  if (!r) {
    return nullptr;
  }
  return reinterpret_cast<const ada_url_components*>(&r->get_components());
}

ada_owned_string ada_idna_to_unicode(const char* input, size_t length) {
  std::string out = ada::idna::to_unicode(std::string_view(input, length));
  ada_owned_string owned{};
  owned.length = out.length();
  owned.data = new char[owned.length];
  memcpy((void*)owned.data, out.data(), owned.length);
  return owned;
}

ada_owned_string ada_idna_to_ascii(const char* input, size_t length) {
  std::string out = ada::idna::to_ascii(std::string_view(input, length));
  ada_owned_string owned{};
  owned.length = out.size();
  owned.data = new char[owned.length];
  memcpy((void*)owned.data, out.data(), owned.length);
  return owned;
}

ada_url_search_params ada_parse_search_params(const char* input,
                                              size_t length) {
  return new ada::result<ada::url_search_params>(
      ada::url_search_params(std::string_view(input, length)));
}

void ada_free_search_params(ada_url_search_params result) {
  auto* r = (ada::result<ada::url_search_params>*)result;
  delete r;
}

ada_owned_string ada_search_params_to_string(ada_url_search_params result) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (!r) return ada_owned_string{nullptr, 0};
  std::string out = r->to_string();
  ada_owned_string owned{};
  owned.length = out.size();
  owned.data = new char[owned.length];
  memcpy((void*)owned.data, out.data(), owned.length);
  return owned;
}

size_t ada_search_params_size(ada_url_search_params result) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (!r) {
    return 0;
  }
  return r->size();
}

void ada_search_params_sort(ada_url_search_params result) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (r) {
    r->sort();
  }
}

void ada_search_params_reset(ada_url_search_params result, const char* input,
                             size_t length) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (r) {
    r->reset(std::string_view(input, length));
  }
}

void ada_search_params_append(ada_url_search_params result, const char* key,
                              size_t key_length, const char* value,
                              size_t value_length) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (r) {
    r->append(std::string_view(key, key_length),
              std::string_view(value, value_length));
  }
}

void ada_search_params_set(ada_url_search_params result, const char* key,
                           size_t key_length, const char* value,
                           size_t value_length) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (r) {
    r->set(std::string_view(key, key_length),
           std::string_view(value, value_length));
  }
}

void ada_search_params_remove(ada_url_search_params result, const char* key,
                              size_t key_length) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (r) {
    r->remove(std::string_view(key, key_length));
  }
}

void ada_search_params_remove_value(ada_url_search_params result,
                                    const char* key, size_t key_length,
                                    const char* value, size_t value_length) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (r) {
    r->remove(std::string_view(key, key_length),
              std::string_view(value, value_length));
  }
}

bool ada_search_params_has(ada_url_search_params result, const char* key,
                           size_t key_length) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (!r) {
    return false;
  }
  return r->has(std::string_view(key, key_length));
}

bool ada_search_params_has_value(ada_url_search_params result, const char* key,
                                 size_t key_length, const char* value,
                                 size_t value_length) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (!r) {
    return false;
  }
  return r->has(std::string_view(key, key_length),
                std::string_view(value, value_length));
}

ada_string ada_search_params_get(ada_url_search_params result, const char* key,
                                 size_t key_length) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  auto found = r->get(std::string_view(key, key_length));
  if (!found.has_value()) {
    return ada_string_create(nullptr, 0);
  }
  return ada_string_create(found->data(), found->length());
}

ada_strings ada_search_params_get_all(ada_url_search_params result,
                                      const char* key, size_t key_length) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (!r) {
    return new ada::result<std::vector<std::string>>(
        std::vector<std::string>());
  }
  return new ada::result<std::vector<std::string>>(
      r->get_all(std::string_view(key, key_length)));
}

ada_url_search_params_keys_iter ada_search_params_get_keys(
    ada_url_search_params result) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (!r) {
    return new ada::result<ada::url_search_params_keys_iter>(
        ada::url_search_params_keys_iter());
  }
  return new ada::result<ada::url_search_params_keys_iter>(r->get_keys());
}

ada_url_search_params_values_iter ada_search_params_get_values(
    ada_url_search_params result) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (!r) {
    return new ada::result<ada::url_search_params_values_iter>(
        ada::url_search_params_values_iter());
  }
  return new ada::result<ada::url_search_params_values_iter>(r->get_values());
}

ada_url_search_params_entries_iter ada_search_params_get_entries(
    ada_url_search_params result) {
  ada::result<ada::url_search_params>& r =
      *(ada::result<ada::url_search_params>*)result;
  if (!r) {
    return new ada::result<ada::url_search_params_entries_iter>(
        ada::url_search_params_entries_iter());
  }
  return new ada::result<ada::url_search_params_entries_iter>(r->get_entries());
}

void ada_free_strings(ada_strings result) {
  auto* r = (ada::result<std::vector<std::string>>*)result;
  delete r;
}

size_t ada_strings_size(ada_strings result) {
  auto* r = (ada::result<std::vector<std::string>>*)result;
  if (!r) {
    return 0;
  }
  return (*r)->size();
}

ada_string ada_strings_get(ada_strings result, size_t index) {
  auto* r = (ada::result<std::vector<std::string>>*)result;
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  std::string_view view = (*r)->at(index);
  return ada_string_create(view.data(), view.length());
}

void ada_free_search_params_keys_iter(ada_url_search_params_keys_iter result) {
  auto* r = (ada::result<ada::url_search_params_keys_iter>*)result;
  delete r;
}

ada_string ada_search_params_keys_iter_next(
    ada_url_search_params_keys_iter result) {
  auto* r = (ada::result<ada::url_search_params_keys_iter>*)result;
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  auto next = (*r)->next();
  if (!next.has_value()) {
    return ada_string_create(nullptr, 0);
  }
  return ada_string_create(next->data(), next->length());
}

bool ada_search_params_keys_iter_has_next(
    ada_url_search_params_keys_iter result) {
  auto* r = (ada::result<ada::url_search_params_keys_iter>*)result;
  if (!r) {
    return false;
  }
  return (*r)->has_next();
}

void ada_free_search_params_values_iter(
    ada_url_search_params_values_iter result) {
  auto* r = (ada::result<ada::url_search_params_values_iter>*)result;
  delete r;
}

ada_string ada_search_params_values_iter_next(
    ada_url_search_params_values_iter result) {
  auto* r = (ada::result<ada::url_search_params_values_iter>*)result;
  if (!r) {
    return ada_string_create(nullptr, 0);
  }
  auto next = (*r)->next();
  if (!next.has_value()) {
    return ada_string_create(nullptr, 0);
  }
  return ada_string_create(next->data(), next->length());
}

bool ada_search_params_values_iter_has_next(
    ada_url_search_params_values_iter result) {
  auto* r = (ada::result<ada::url_search_params_values_iter>*)result;
  if (!r) {
    return false;
  }
  return (*r)->has_next();
}

void ada_free_search_params_entries_iter(
    ada_url_search_params_entries_iter result) {
  auto* r = (ada::result<ada::url_search_params_entries_iter>*)result;
  delete r;
}

ada_string_pair ada_search_params_entries_iter_next(
    ada_url_search_params_entries_iter result) {
  auto* r = (ada::result<ada::url_search_params_entries_iter>*)result;
  if (!r) return {ada_string_create(nullptr, 0), ada_string_create(nullptr, 0)};
  auto next = (*r)->next();
  if (!next.has_value()) {
    return {ada_string_create(nullptr, 0), ada_string_create(nullptr, 0)};
  }
  return ada_string_pair{
      ada_string_create(next->first.data(), next->first.length()),
      ada_string_create(next->second.data(), next->second.length())};
}

bool ada_search_params_entries_iter_has_next(
    ada_url_search_params_entries_iter result) {
  auto* r = (ada::result<ada::url_search_params_entries_iter>*)result;
  if (!r) {
    return false;
  }
  return (*r)->has_next();
}

}  // extern "C"
/* end file src/ada_c.cpp */
/* end file src/ada.cpp */
                                                                           node-23.7.0/deps/ada/ada.gyp                                                                        0000664 0000000 0000000 00000000513 14746647661 0015502 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'variables': {
    'v8_enable_i18n_support%': 1,
    'ada_sources': [ 'ada.cpp' ],
  },
  'targets': [
    {
      'target_name': 'ada',
      'type': 'static_library',
      'include_dirs': ['.'],
      'direct_dependent_settings': {
        'include_dirs': ['.'],
      },
      'sources': [ '<@(ada_sources)' ]
    },
  ]
}
                                                                                                                                                                                     node-23.7.0/deps/ada/ada.h                                                                          0000664 0000000 0000000 00000772653 14746647661 0015157 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* auto-generated on 2024-09-02 20:07:32 -0400. Do not edit! */
/* begin file include/ada.h */
/**
 * @file ada.h
 * @brief Includes all definitions for Ada.
 */
#ifndef ADA_H
#define ADA_H

/* begin file include/ada/ada_idna.h */
/* auto-generated on 2023-09-19 15:58:51 -0400. Do not edit! */
/* begin file include/idna.h */
#ifndef ADA_IDNA_H
#define ADA_IDNA_H

/* begin file include/ada/idna/unicode_transcoding.h */
#ifndef ADA_IDNA_UNICODE_TRANSCODING_H
#define ADA_IDNA_UNICODE_TRANSCODING_H

#include <string>
#include <string_view>

namespace ada::idna {

size_t utf8_to_utf32(const char* buf, size_t len, char32_t* utf32_output);

size_t utf8_length_from_utf32(const char32_t* buf, size_t len);

size_t utf32_length_from_utf8(const char* buf, size_t len);

size_t utf32_to_utf8(const char32_t* buf, size_t len, char* utf8_output);

}  // namespace ada::idna

#endif  // ADA_IDNA_UNICODE_TRANSCODING_H
/* end file include/ada/idna/unicode_transcoding.h */
/* begin file include/ada/idna/mapping.h */
#ifndef ADA_IDNA_MAPPING_H
#define ADA_IDNA_MAPPING_H

#include <string>
#include <string_view>

namespace ada::idna {

// If the input is ascii, then the mapping is just -> lower case.
void ascii_map(char* input, size_t length);
// check whether an ascii string needs mapping
bool ascii_has_upper_case(char* input, size_t length);
// Map the characters according to IDNA, returning the empty string on error.
std::u32string map(std::u32string_view input);

}  // namespace ada::idna

#endif
/* end file include/ada/idna/mapping.h */
/* begin file include/ada/idna/normalization.h */
#ifndef ADA_IDNA_NORMALIZATION_H
#define ADA_IDNA_NORMALIZATION_H

#include <string>
#include <string_view>

namespace ada::idna {

// Normalize the characters according to IDNA (Unicode Normalization Form C).
void normalize(std::u32string& input);

}  // namespace ada::idna
#endif
/* end file include/ada/idna/normalization.h */
/* begin file include/ada/idna/punycode.h */
#ifndef ADA_IDNA_PUNYCODE_H
#define ADA_IDNA_PUNYCODE_H

#include <string>
#include <string_view>

namespace ada::idna {

bool punycode_to_utf32(std::string_view input, std::u32string& out);
bool verify_punycode(std::string_view input);
bool utf32_to_punycode(std::u32string_view input, std::string& out);

}  // namespace ada::idna

#endif  // ADA_IDNA_PUNYCODE_H
/* end file include/ada/idna/punycode.h */
/* begin file include/ada/idna/validity.h */
#ifndef ADA_IDNA_VALIDITY_H
#define ADA_IDNA_VALIDITY_H

#include <string>
#include <string_view>

namespace ada::idna {

/**
 * @see https://www.unicode.org/reports/tr46/#Validity_Criteria
 */
bool is_label_valid(std::u32string_view label);

}  // namespace ada::idna

#endif  // ADA_IDNA_VALIDITY_H
/* end file include/ada/idna/validity.h */
/* begin file include/ada/idna/to_ascii.h */
#ifndef ADA_IDNA_TO_ASCII_H
#define ADA_IDNA_TO_ASCII_H

#include <string>
#include <string_view>

namespace ada::idna {

// Converts a domain (e.g., www.google.com) possibly containing international
// characters to an ascii domain (with punycode). It will not do percent
// decoding: percent decoding should be done prior to calling this function. We
// do not remove tabs and spaces, they should have been removed prior to calling
// this function. We also do not trim control characters. We also assume that
// the input is not empty. We return "" on error.
//
//
// This function may accept or even produce invalid domains.
std::string to_ascii(std::string_view ut8_string);

// Returns true if the string contains a forbidden code point according to the
// WHATGL URL specification:
// https://url.spec.whatwg.org/#forbidden-domain-code-point
bool contains_forbidden_domain_code_point(std::string_view ascii_string);

bool begins_with(std::u32string_view view, std::u32string_view prefix);
bool begins_with(std::string_view view, std::string_view prefix);

bool constexpr is_ascii(std::u32string_view view);
bool constexpr is_ascii(std::string_view view);

}  // namespace ada::idna

#endif  // ADA_IDNA_TO_ASCII_H
/* end file include/ada/idna/to_ascii.h */
/* begin file include/ada/idna/to_unicode.h */

#ifndef ADA_IDNA_TO_UNICODE_H
#define ADA_IDNA_TO_UNICODE_H

#include <string_view>

namespace ada::idna {

std::string to_unicode(std::string_view input);

}  // namespace ada::idna

#endif  // ADA_IDNA_TO_UNICODE_H
/* end file include/ada/idna/to_unicode.h */

#endif
/* end file include/idna.h */
/* end file include/ada/ada_idna.h */
/* begin file include/ada/character_sets-inl.h */
/**
 * @file character_sets-inl.h
 * @brief Definitions of the character sets used by unicode functions.
 * @author Node.js
 * @see https://github.com/nodejs/node/blob/main/src/node_url_tables.cc
 */
#ifndef ADA_CHARACTER_SETS_INL_H
#define ADA_CHARACTER_SETS_INL_H

/* begin file include/ada/character_sets.h */
/**
 * @file character_sets.h
 * @brief Declaration of the character sets used by unicode functions.
 * @author Node.js
 * @see https://github.com/nodejs/node/blob/main/src/node_url_tables.cc
 */
#ifndef ADA_CHARACTER_SETS_H
#define ADA_CHARACTER_SETS_H

/* begin file include/ada/common_defs.h */
/**
 * @file common_defs.h
 * @brief Common definitions for cross-platform compiler support.
 */
#ifndef ADA_COMMON_DEFS_H
#define ADA_COMMON_DEFS_H

#ifdef _MSC_VER
#define ADA_VISUAL_STUDIO 1
/**
 * We want to differentiate carefully between
 * clang under visual studio and regular visual
 * studio.
 */
#ifdef __clang__
// clang under visual studio
#define ADA_CLANG_VISUAL_STUDIO 1
#else
// just regular visual studio (best guess)
#define ADA_REGULAR_VISUAL_STUDIO 1
#endif  // __clang__
#endif  // _MSC_VER

#if defined(__GNUC__)
// Marks a block with a name so that MCA analysis can see it.
#define ADA_BEGIN_DEBUG_BLOCK(name) __asm volatile("# LLVM-MCA-BEGIN " #name);
#define ADA_END_DEBUG_BLOCK(name) __asm volatile("# LLVM-MCA-END " #name);
#define ADA_DEBUG_BLOCK(name, block) \
  BEGIN_DEBUG_BLOCK(name);           \
  block;                             \
  END_DEBUG_BLOCK(name);
#else
#define ADA_BEGIN_DEBUG_BLOCK(name)
#define ADA_END_DEBUG_BLOCK(name)
#define ADA_DEBUG_BLOCK(name, block)
#endif

// Align to N-byte boundary
#define ADA_ROUNDUP_N(a, n) (((a) + ((n)-1)) & ~((n)-1))
#define ADA_ROUNDDOWN_N(a, n) ((a) & ~((n)-1))

#define ADA_ISALIGNED_N(ptr, n) (((uintptr_t)(ptr) & ((n)-1)) == 0)

#if defined(ADA_REGULAR_VISUAL_STUDIO)

#define ada_really_inline __forceinline
#define ada_never_inline __declspec(noinline)

#define ada_unused
#define ada_warn_unused

#ifndef ada_likely
#define ada_likely(x) x
#endif
#ifndef ada_unlikely
#define ada_unlikely(x) x
#endif

#define ADA_PUSH_DISABLE_WARNINGS __pragma(warning(push))
#define ADA_PUSH_DISABLE_ALL_WARNINGS __pragma(warning(push, 0))
#define ADA_DISABLE_VS_WARNING(WARNING_NUMBER) \
  __pragma(warning(disable : WARNING_NUMBER))
// Get rid of Intellisense-only warnings (Code Analysis)
// Though __has_include is C++17, it is supported in Visual Studio 2017 or
// better (_MSC_VER>=1910).
#ifdef __has_include
#if __has_include(<CppCoreCheck\Warnings.h>)
#include <CppCoreCheck\Warnings.h>
#define ADA_DISABLE_UNDESIRED_WARNINGS \
  ADA_DISABLE_VS_WARNING(ALL_CPPCORECHECK_WARNINGS)
#endif
#endif

#ifndef ADA_DISABLE_UNDESIRED_WARNINGS
#define ADA_DISABLE_UNDESIRED_WARNINGS
#endif

#define ADA_DISABLE_DEPRECATED_WARNING ADA_DISABLE_VS_WARNING(4996)
#define ADA_DISABLE_STRICT_OVERFLOW_WARNING
#define ADA_POP_DISABLE_WARNINGS __pragma(warning(pop))

#else  // ADA_REGULAR_VISUAL_STUDIO

#define ada_really_inline inline __attribute__((always_inline))
#define ada_never_inline inline __attribute__((noinline))

#define ada_unused __attribute__((unused))
#define ada_warn_unused __attribute__((warn_unused_result))

#ifndef ada_likely
#define ada_likely(x) __builtin_expect(!!(x), 1)
#endif
#ifndef ada_unlikely
#define ada_unlikely(x) __builtin_expect(!!(x), 0)
#endif

#define ADA_PUSH_DISABLE_WARNINGS _Pragma("GCC diagnostic push")
// gcc doesn't seem to disable all warnings with all and extra, add warnings
// here as necessary
#define ADA_PUSH_DISABLE_ALL_WARNINGS               \
  ADA_PUSH_DISABLE_WARNINGS                         \
  ADA_DISABLE_GCC_WARNING("-Weffc++")               \
  ADA_DISABLE_GCC_WARNING("-Wall")                  \
  ADA_DISABLE_GCC_WARNING("-Wconversion")           \
  ADA_DISABLE_GCC_WARNING("-Wextra")                \
  ADA_DISABLE_GCC_WARNING("-Wattributes")           \
  ADA_DISABLE_GCC_WARNING("-Wimplicit-fallthrough") \
  ADA_DISABLE_GCC_WARNING("-Wnon-virtual-dtor")     \
  ADA_DISABLE_GCC_WARNING("-Wreturn-type")          \
  ADA_DISABLE_GCC_WARNING("-Wshadow")               \
  ADA_DISABLE_GCC_WARNING("-Wunused-parameter")     \
  ADA_DISABLE_GCC_WARNING("-Wunused-variable")
#define ADA_PRAGMA(P) _Pragma(#P)
#define ADA_DISABLE_GCC_WARNING(WARNING) \
  ADA_PRAGMA(GCC diagnostic ignored WARNING)
#if defined(ADA_CLANG_VISUAL_STUDIO)
#define ADA_DISABLE_UNDESIRED_WARNINGS \
  ADA_DISABLE_GCC_WARNING("-Wmicrosoft-include")
#else
#define ADA_DISABLE_UNDESIRED_WARNINGS
#endif
#define ADA_DISABLE_DEPRECATED_WARNING \
  ADA_DISABLE_GCC_WARNING("-Wdeprecated-declarations")
#define ADA_DISABLE_STRICT_OVERFLOW_WARNING \
  ADA_DISABLE_GCC_WARNING("-Wstrict-overflow")
#define ADA_POP_DISABLE_WARNINGS _Pragma("GCC diagnostic pop")

#endif  // MSC_VER

#if defined(ADA_VISUAL_STUDIO)
/**
 * It does not matter here whether you are using
 * the regular visual studio or clang under visual
 * studio.
 */
#if ADA_USING_LIBRARY
#define ADA_DLLIMPORTEXPORT __declspec(dllimport)
#else
#define ADA_DLLIMPORTEXPORT __declspec(dllexport)
#endif
#else
#define ADA_DLLIMPORTEXPORT
#endif

/// If EXPR is an error, returns it.
#define ADA_TRY(EXPR)   \
  {                     \
    auto _err = (EXPR); \
    if (_err) {         \
      return _err;      \
    }                   \
  }

// __has_cpp_attribute is part of C++20
#if !defined(__has_cpp_attribute)
#define __has_cpp_attribute(x) 0
#endif

#if __has_cpp_attribute(gnu::noinline)
#define ADA_ATTRIBUTE_NOINLINE [[gnu::noinline]]
#else
#define ADA_ATTRIBUTE_NOINLINE
#endif

namespace ada {
[[noreturn]] inline void unreachable() {
#ifdef __GNUC__
  __builtin_unreachable();
#elif defined(_MSC_VER)
  __assume(false);
#else
#endif
}
}  // namespace ada

#if defined(__GNUC__) && !defined(__clang__)
#if __GNUC__ <= 8
#define ADA_OLD_GCC 1
#endif  //  __GNUC__ <= 8
#endif  // defined(__GNUC__) && !defined(__clang__)

#if ADA_OLD_GCC
#define ada_constexpr
#else
#define ada_constexpr constexpr
#endif

#if defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__)
#define ADA_IS_BIG_ENDIAN (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
#elif defined(_WIN32)
#define ADA_IS_BIG_ENDIAN 0
#else
#if defined(__APPLE__) || \
    defined(__FreeBSD__)  // defined __BYTE_ORDER__ && defined
                          // __ORDER_BIG_ENDIAN__
#include <machine/endian.h>
#elif defined(sun) || \
    defined(__sun)  // defined(__APPLE__) || defined(__FreeBSD__)
#include <sys/byteorder.h>
#else  // defined(__APPLE__) || defined(__FreeBSD__)

#ifdef __has_include
#if __has_include(<endian.h>)
#include <endian.h>
#endif  //__has_include(<endian.h>)
#endif  //__has_include

#endif  // defined(__APPLE__) || defined(__FreeBSD__)

#ifndef !defined(__BYTE_ORDER__) || !defined(__ORDER_LITTLE_ENDIAN__)
#define ADA_IS_BIG_ENDIAN 0
#endif

#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
#define ADA_IS_BIG_ENDIAN 0
#else  // __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
#define ADA_IS_BIG_ENDIAN 1
#endif  // __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__

#endif  // defined __BYTE_ORDER__ && defined __ORDER_BIG_ENDIAN__

// Unless the programmer has already set ADA_DEVELOPMENT_CHECKS,
// we want to set it under debug builds. We detect a debug build
// under Visual Studio when the _DEBUG macro is set. Under the other
// compilers, we use the fact that they define __OPTIMIZE__ whenever
// they allow optimizations.
// It is possible that this could miss some cases where ADA_DEVELOPMENT_CHECKS
// is helpful, but the programmer can set the macro ADA_DEVELOPMENT_CHECKS.
// It could also wrongly set ADA_DEVELOPMENT_CHECKS (e.g., if the programmer
// sets _DEBUG in a release build under Visual Studio, or if some compiler fails
// to set the __OPTIMIZE__ macro).
#if !defined(ADA_DEVELOPMENT_CHECKS) && !defined(NDEBUG)
#ifdef _MSC_VER
// Visual Studio seems to set _DEBUG for debug builds.
#ifdef _DEBUG
#define ADA_DEVELOPMENT_CHECKS 1
#endif  // _DEBUG
#else   // _MSC_VER
// All other compilers appear to set __OPTIMIZE__ to a positive integer
// when the compiler is optimizing.
#ifndef __OPTIMIZE__
#define ADA_DEVELOPMENT_CHECKS 1
#endif  // __OPTIMIZE__
#endif  // _MSC_VER
#endif  // ADA_DEVELOPMENT_CHECKS

#define ADA_STR(x) #x

#if ADA_DEVELOPMENT_CHECKS
#define ADA_REQUIRE(EXPR) \
  {                       \
    if (!(EXPR) { abort(); }) }

#define ADA_FAIL(MESSAGE)                            \
  do {                                               \
    std::cerr << "FAIL: " << (MESSAGE) << std::endl; \
    abort();                                         \
  } while (0);
#define ADA_ASSERT_EQUAL(LHS, RHS, MESSAGE)                                    \
  do {                                                                         \
    if (LHS != RHS) {                                                          \
      std::cerr << "Mismatch: '" << LHS << "' - '" << RHS << "'" << std::endl; \
      ADA_FAIL(MESSAGE);                                                       \
    }                                                                          \
  } while (0);
#define ADA_ASSERT_TRUE(COND)                                               \
  do {                                                                      \
    if (!(COND)) {                                                          \
      std::cerr << "Assert at line " << __LINE__ << " of file " << __FILE__ \
                << std::endl;                                               \
      ADA_FAIL(ADA_STR(COND));                                              \
    }                                                                       \
  } while (0);
#else
#define ADA_FAIL(MESSAGE)
#define ADA_ASSERT_EQUAL(LHS, RHS, MESSAGE)
#define ADA_ASSERT_TRUE(COND)
#endif

#ifdef ADA_VISUAL_STUDIO
#define ADA_ASSUME(COND) __assume(COND)
#else
#define ADA_ASSUME(COND)       \
  do {                         \
    if (!(COND)) {             \
      __builtin_unreachable(); \
    }                          \
  } while (0)
#endif

#if defined(__SSE2__) || defined(__x86_64__) || defined(__x86_64) || \
    (defined(_M_AMD64) || defined(_M_X64) ||                         \
     (defined(_M_IX86_FP) && _M_IX86_FP == 2))
#define ADA_SSE2 1
#endif

#if defined(__aarch64__) || defined(_M_ARM64)
#define ADA_NEON 1
#endif

#ifndef __has_cpp_attribute
#define ada_lifetime_bound
#elif __has_cpp_attribute(msvc::lifetimebound)
#define ada_lifetime_bound [[msvc::lifetimebound]]
#elif __has_cpp_attribute(clang::lifetimebound)
#define ada_lifetime_bound [[clang::lifetimebound]]
#elif __has_cpp_attribute(lifetimebound)
#define ada_lifetime_bound [[lifetimebound]]
#else
#define ada_lifetime_bound
#endif

#endif  // ADA_COMMON_DEFS_H
/* end file include/ada/common_defs.h */
#include <cstdint>

/**
 * These functions are not part of our public API and may
 * change at any time.
 * @private
 * @namespace ada::character_sets
 * @brief Includes the definitions for unicode character sets.
 */
namespace ada::character_sets {
ada_really_inline bool bit_at(const uint8_t a[], uint8_t i);
}  // namespace ada::character_sets

#endif  // ADA_CHARACTER_SETS_H
/* end file include/ada/character_sets.h */

/**
 * These functions are not part of our public API and may
 * change at any time.
 * @private
 */
namespace ada::character_sets {

constexpr char hex[1024] =
    "%00\0%01\0%02\0%03\0%04\0%05\0%06\0%07\0"
    "%08\0%09\0%0A\0%0B\0%0C\0%0D\0%0E\0%0F\0"
    "%10\0%11\0%12\0%13\0%14\0%15\0%16\0%17\0"
    "%18\0%19\0%1A\0%1B\0%1C\0%1D\0%1E\0%1F\0"
    "%20\0%21\0%22\0%23\0%24\0%25\0%26\0%27\0"
    "%28\0%29\0%2A\0%2B\0%2C\0%2D\0%2E\0%2F\0"
    "%30\0%31\0%32\0%33\0%34\0%35\0%36\0%37\0"
    "%38\0%39\0%3A\0%3B\0%3C\0%3D\0%3E\0%3F\0"
    "%40\0%41\0%42\0%43\0%44\0%45\0%46\0%47\0"
    "%48\0%49\0%4A\0%4B\0%4C\0%4D\0%4E\0%4F\0"
    "%50\0%51\0%52\0%53\0%54\0%55\0%56\0%57\0"
    "%58\0%59\0%5A\0%5B\0%5C\0%5D\0%5E\0%5F\0"
    "%60\0%61\0%62\0%63\0%64\0%65\0%66\0%67\0"
    "%68\0%69\0%6A\0%6B\0%6C\0%6D\0%6E\0%6F\0"
    "%70\0%71\0%72\0%73\0%74\0%75\0%76\0%77\0"
    "%78\0%79\0%7A\0%7B\0%7C\0%7D\0%7E\0%7F\0"
    "%80\0%81\0%82\0%83\0%84\0%85\0%86\0%87\0"
    "%88\0%89\0%8A\0%8B\0%8C\0%8D\0%8E\0%8F\0"
    "%90\0%91\0%92\0%93\0%94\0%95\0%96\0%97\0"
    "%98\0%99\0%9A\0%9B\0%9C\0%9D\0%9E\0%9F\0"
    "%A0\0%A1\0%A2\0%A3\0%A4\0%A5\0%A6\0%A7\0"
    "%A8\0%A9\0%AA\0%AB\0%AC\0%AD\0%AE\0%AF\0"
    "%B0\0%B1\0%B2\0%B3\0%B4\0%B5\0%B6\0%B7\0"
    "%B8\0%B9\0%BA\0%BB\0%BC\0%BD\0%BE\0%BF\0"
    "%C0\0%C1\0%C2\0%C3\0%C4\0%C5\0%C6\0%C7\0"
    "%C8\0%C9\0%CA\0%CB\0%CC\0%CD\0%CE\0%CF\0"
    "%D0\0%D1\0%D2\0%D3\0%D4\0%D5\0%D6\0%D7\0"
    "%D8\0%D9\0%DA\0%DB\0%DC\0%DD\0%DE\0%DF\0"
    "%E0\0%E1\0%E2\0%E3\0%E4\0%E5\0%E6\0%E7\0"
    "%E8\0%E9\0%EA\0%EB\0%EC\0%ED\0%EE\0%EF\0"
    "%F0\0%F1\0%F2\0%F3\0%F4\0%F5\0%F6\0%F7\0"
    "%F8\0%F9\0%FA\0%FB\0%FC\0%FD\0%FE\0%FF";

constexpr uint8_t C0_CONTROL_PERCENT_ENCODE[32] = {
    // 00     01     02     03     04     05     06     07
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 08     09     0A     0B     0C     0D     0E     0F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 10     11     12     13     14     15     16     17
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 18     19     1A     1B     1C     1D     1E     1F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 20     21     22     23     24     25     26     27
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 28     29     2A     2B     2C     2D     2E     2F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 30     31     32     33     34     35     36     37
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 38     39     3A     3B     3C     3D     3E     3F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 40     41     42     43     44     45     46     47
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 48     49     4A     4B     4C     4D     4E     4F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 50     51     52     53     54     55     56     57
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 58     59     5A     5B     5C     5D     5E     5F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 60     61     62     63     64     65     66     67
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 68     69     6A     6B     6C     6D     6E     6F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 70     71     72     73     74     75     76     77
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 78     79     7A     7B     7C     7D     7E     7F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x80,
    // 80     81     82     83     84     85     86     87
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 88     89     8A     8B     8C     8D     8E     8F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 90     91     92     93     94     95     96     97
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 98     99     9A     9B     9C     9D     9E     9F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A0     A1     A2     A3     A4     A5     A6     A7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A8     A9     AA     AB     AC     AD     AE     AF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B0     B1     B2     B3     B4     B5     B6     B7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B8     B9     BA     BB     BC     BD     BE     BF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C0     C1     C2     C3     C4     C5     C6     C7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C8     C9     CA     CB     CC     CD     CE     CF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D0     D1     D2     D3     D4     D5     D6     D7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D8     D9     DA     DB     DC     DD     DE     DF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E0     E1     E2     E3     E4     E5     E6     E7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E8     E9     EA     EB     EC     ED     EE     EF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F0     F1     F2     F3     F4     F5     F6     F7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F8     F9     FA     FB     FC     FD     FE     FF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80};

constexpr uint8_t SPECIAL_QUERY_PERCENT_ENCODE[32] = {
    // 00     01     02     03     04     05     06     07
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 08     09     0A     0B     0C     0D     0E     0F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 10     11     12     13     14     15     16     17
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 18     19     1A     1B     1C     1D     1E     1F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 20     21     22     23     24     25     26     27
    0x01 | 0x00 | 0x04 | 0x08 | 0x00 | 0x00 | 0x00 | 0x80,
    // 28     29     2A     2B     2C     2D     2E     2F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 30     31     32     33     34     35     36     37
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 38     39     3A     3B     3C     3D     3E     3F
    0x00 | 0x00 | 0x00 | 0x00 | 0x10 | 0x00 | 0x40 | 0x00,
    // 40     41     42     43     44     45     46     47
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 48     49     4A     4B     4C     4D     4E     4F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 50     51     52     53     54     55     56     57
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 58     59     5A     5B     5C     5D     5E     5F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 60     61     62     63     64     65     66     67
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 68     69     6A     6B     6C     6D     6E     6F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 70     71     72     73     74     75     76     77
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 78     79     7A     7B     7C     7D     7E     7F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x80,
    // 80     81     82     83     84     85     86     87
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 88     89     8A     8B     8C     8D     8E     8F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 90     91     92     93     94     95     96     97
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 98     99     9A     9B     9C     9D     9E     9F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A0     A1     A2     A3     A4     A5     A6     A7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A8     A9     AA     AB     AC     AD     AE     AF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B0     B1     B2     B3     B4     B5     B6     B7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B8     B9     BA     BB     BC     BD     BE     BF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C0     C1     C2     C3     C4     C5     C6     C7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C8     C9     CA     CB     CC     CD     CE     CF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D0     D1     D2     D3     D4     D5     D6     D7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D8     D9     DA     DB     DC     DD     DE     DF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E0     E1     E2     E3     E4     E5     E6     E7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E8     E9     EA     EB     EC     ED     EE     EF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F0     F1     F2     F3     F4     F5     F6     F7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F8     F9     FA     FB     FC     FD     FE     FF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80};

constexpr uint8_t QUERY_PERCENT_ENCODE[32] = {
    // 00     01     02     03     04     05     06     07
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 08     09     0A     0B     0C     0D     0E     0F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 10     11     12     13     14     15     16     17
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 18     19     1A     1B     1C     1D     1E     1F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 20     21     22     23     24     25     26     27
    0x01 | 0x00 | 0x04 | 0x08 | 0x00 | 0x00 | 0x00 | 0x00,
    // 28     29     2A     2B     2C     2D     2E     2F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 30     31     32     33     34     35     36     37
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 38     39     3A     3B     3C     3D     3E     3F
    0x00 | 0x00 | 0x00 | 0x00 | 0x10 | 0x00 | 0x40 | 0x00,
    // 40     41     42     43     44     45     46     47
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 48     49     4A     4B     4C     4D     4E     4F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 50     51     52     53     54     55     56     57
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 58     59     5A     5B     5C     5D     5E     5F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 60     61     62     63     64     65     66     67
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 68     69     6A     6B     6C     6D     6E     6F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 70     71     72     73     74     75     76     77
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 78     79     7A     7B     7C     7D     7E     7F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x80,
    // 80     81     82     83     84     85     86     87
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 88     89     8A     8B     8C     8D     8E     8F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 90     91     92     93     94     95     96     97
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 98     99     9A     9B     9C     9D     9E     9F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A0     A1     A2     A3     A4     A5     A6     A7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A8     A9     AA     AB     AC     AD     AE     AF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B0     B1     B2     B3     B4     B5     B6     B7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B8     B9     BA     BB     BC     BD     BE     BF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C0     C1     C2     C3     C4     C5     C6     C7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C8     C9     CA     CB     CC     CD     CE     CF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D0     D1     D2     D3     D4     D5     D6     D7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D8     D9     DA     DB     DC     DD     DE     DF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E0     E1     E2     E3     E4     E5     E6     E7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E8     E9     EA     EB     EC     ED     EE     EF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F0     F1     F2     F3     F4     F5     F6     F7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F8     F9     FA     FB     FC     FD     FE     FF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80};

constexpr uint8_t FRAGMENT_PERCENT_ENCODE[32] = {
    // 00     01     02     03     04     05     06     07
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 08     09     0A     0B     0C     0D     0E     0F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 10     11     12     13     14     15     16     17
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 18     19     1A     1B     1C     1D     1E     1F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 20     21     22     23     24     25     26     27
    0x01 | 0x00 | 0x04 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 28     29     2A     2B     2C     2D     2E     2F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 30     31     32     33     34     35     36     37
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 38     39     3A     3B     3C     3D     3E     3F
    0x00 | 0x00 | 0x00 | 0x00 | 0x10 | 0x00 | 0x40 | 0x00,
    // 40     41     42     43     44     45     46     47
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 48     49     4A     4B     4C     4D     4E     4F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 50     51     52     53     54     55     56     57
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 58     59     5A     5B     5C     5D     5E     5F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 60     61     62     63     64     65     66     67
    0x01 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 68     69     6A     6B     6C     6D     6E     6F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 70     71     72     73     74     75     76     77
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 78     79     7A     7B     7C     7D     7E     7F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x80,
    // 80     81     82     83     84     85     86     87
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 88     89     8A     8B     8C     8D     8E     8F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 90     91     92     93     94     95     96     97
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 98     99     9A     9B     9C     9D     9E     9F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A0     A1     A2     A3     A4     A5     A6     A7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A8     A9     AA     AB     AC     AD     AE     AF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B0     B1     B2     B3     B4     B5     B6     B7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B8     B9     BA     BB     BC     BD     BE     BF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C0     C1     C2     C3     C4     C5     C6     C7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C8     C9     CA     CB     CC     CD     CE     CF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D0     D1     D2     D3     D4     D5     D6     D7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D8     D9     DA     DB     DC     DD     DE     DF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E0     E1     E2     E3     E4     E5     E6     E7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E8     E9     EA     EB     EC     ED     EE     EF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F0     F1     F2     F3     F4     F5     F6     F7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F8     F9     FA     FB     FC     FD     FE     FF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80};

constexpr uint8_t USERINFO_PERCENT_ENCODE[32] = {
    // 00     01     02     03     04     05     06     07
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 08     09     0A     0B     0C     0D     0E     0F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 10     11     12     13     14     15     16     17
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 18     19     1A     1B     1C     1D     1E     1F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 20     21     22     23     24     25     26     27
    0x01 | 0x00 | 0x04 | 0x08 | 0x00 | 0x00 | 0x00 | 0x00,
    // 28     29     2A     2B     2C     2D     2E     2F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x80,
    // 30     31     32     33     34     35     36     37
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 38     39     3A     3B     3C     3D     3E     3F
    0x00 | 0x00 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 40     41     42     43     44     45     46     47
    0x01 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 48     49     4A     4B     4C     4D     4E     4F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 50     51     52     53     54     55     56     57
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 58     59     5A     5B     5C     5D     5E     5F
    0x00 | 0x00 | 0x00 | 0x08 | 0x10 | 0x20 | 0x40 | 0x00,
    // 60     61     62     63     64     65     66     67
    0x01 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 68     69     6A     6B     6C     6D     6E     6F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 70     71     72     73     74     75     76     77
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 78     79     7A     7B     7C     7D     7E     7F
    0x00 | 0x00 | 0x00 | 0x08 | 0x10 | 0x20 | 0x00 | 0x80,
    // 80     81     82     83     84     85     86     87
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 88     89     8A     8B     8C     8D     8E     8F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 90     91     92     93     94     95     96     97
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 98     99     9A     9B     9C     9D     9E     9F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A0     A1     A2     A3     A4     A5     A6     A7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A8     A9     AA     AB     AC     AD     AE     AF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B0     B1     B2     B3     B4     B5     B6     B7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B8     B9     BA     BB     BC     BD     BE     BF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C0     C1     C2     C3     C4     C5     C6     C7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C8     C9     CA     CB     CC     CD     CE     CF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D0     D1     D2     D3     D4     D5     D6     D7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D8     D9     DA     DB     DC     DD     DE     DF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E0     E1     E2     E3     E4     E5     E6     E7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E8     E9     EA     EB     EC     ED     EE     EF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F0     F1     F2     F3     F4     F5     F6     F7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F8     F9     FA     FB     FC     FD     FE     FF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80};

constexpr uint8_t PATH_PERCENT_ENCODE[32] = {
    // 00     01     02     03     04     05     06     07
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 08     09     0A     0B     0C     0D     0E     0F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 10     11     12     13     14     15     16     17
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 18     19     1A     1B     1C     1D     1E     1F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 20     21     22     23     24     25     26     27
    0x01 | 0x00 | 0x04 | 0x08 | 0x00 | 0x00 | 0x00 | 0x00,
    // 28     29     2A     2B     2C     2D     2E     2F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 30     31     32     33     34     35     36     37
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 38     39     3A     3B     3C     3D     3E     3F
    0x00 | 0x00 | 0x00 | 0x00 | 0x10 | 0x00 | 0x40 | 0x80,
    // 40     41     42     43     44     45     46     47
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 48     49     4A     4B     4C     4D     4E     4F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 50     51     52     53     54     55     56     57
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 58     59     5A     5B     5C     5D     5E     5F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 60     61     62     63     64     65     66     67
    0x01 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 68     69     6A     6B     6C     6D     6E     6F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 70     71     72     73     74     75     76     77
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 78     79     7A     7B     7C     7D     7E     7F
    0x00 | 0x00 | 0x00 | 0x08 | 0x00 | 0x20 | 0x00 | 0x80,
    // 80     81     82     83     84     85     86     87
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 88     89     8A     8B     8C     8D     8E     8F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 90     91     92     93     94     95     96     97
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 98     99     9A     9B     9C     9D     9E     9F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A0     A1     A2     A3     A4     A5     A6     A7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A8     A9     AA     AB     AC     AD     AE     AF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B0     B1     B2     B3     B4     B5     B6     B7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B8     B9     BA     BB     BC     BD     BE     BF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C0     C1     C2     C3     C4     C5     C6     C7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C8     C9     CA     CB     CC     CD     CE     CF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D0     D1     D2     D3     D4     D5     D6     D7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D8     D9     DA     DB     DC     DD     DE     DF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E0     E1     E2     E3     E4     E5     E6     E7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E8     E9     EA     EB     EC     ED     EE     EF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F0     F1     F2     F3     F4     F5     F6     F7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F8     F9     FA     FB     FC     FD     FE     FF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80};

constexpr uint8_t WWW_FORM_URLENCODED_PERCENT_ENCODE[32] = {
    // 00     01     02     03     04     05     06     07
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 08     09     0A     0B     0C     0D     0E     0F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 10     11     12     13     14     15     16     17
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 18     19     1A     1B     1C     1D     1E     1F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 20     21     22     23     24     25     26     27
    0x00 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 28     29     2A     2B     2C     2D     2E     2F
    0x01 | 0x02 | 0x00 | 0x08 | 0x10 | 0x00 | 0x00 | 0x80,
    // 30     31     32     33     34     35     36     37
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 38     39     3A     3B     3C     3D     3E     3F
    0x00 | 0x00 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 40     41     42     43     44     45     46     47
    0x01 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 48     49     4A     4B     4C     4D     4E     4F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 50     51     52     53     54     55     56     57
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 58     59     5A     5B     5C     5D     5E     5F
    0x00 | 0x00 | 0x00 | 0x08 | 0x00 | 0x20 | 0x40 | 0x00,
    // 60     61     62     63     64     65     66     67
    0x01 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 68     69     6A     6B     6C     6D     6E     6F
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 70     71     72     73     74     75     76     77
    0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00 | 0x00,
    // 78     79     7A     7B     7C     7D     7E     7F
    0x00 | 0x00 | 0x00 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 80     81     82     83     84     85     86     87
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 88     89     8A     8B     8C     8D     8E     8F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 90     91     92     93     94     95     96     97
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // 98     99     9A     9B     9C     9D     9E     9F
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A0     A1     A2     A3     A4     A5     A6     A7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // A8     A9     AA     AB     AC     AD     AE     AF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B0     B1     B2     B3     B4     B5     B6     B7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // B8     B9     BA     BB     BC     BD     BE     BF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C0     C1     C2     C3     C4     C5     C6     C7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // C8     C9     CA     CB     CC     CD     CE     CF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D0     D1     D2     D3     D4     D5     D6     D7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // D8     D9     DA     DB     DC     DD     DE     DF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E0     E1     E2     E3     E4     E5     E6     E7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // E8     E9     EA     EB     EC     ED     EE     EF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F0     F1     F2     F3     F4     F5     F6     F7
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80,
    // F8     F9     FA     FB     FC     FD     FE     FF
    0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 | 0x80};

ada_really_inline bool bit_at(const uint8_t a[], const uint8_t i) {
  return !!(a[i >> 3] & (1 << (i & 7)));
}

}  // namespace ada::character_sets

#endif  // ADA_CHARACTER_SETS_INL_H
/* end file include/ada/character_sets-inl.h */
/* begin file include/ada/checkers-inl.h */
/**
 * @file checkers-inl.h
 * @brief Definitions for URL specific checkers used within Ada.
 */
#ifndef ADA_CHECKERS_INL_H
#define ADA_CHECKERS_INL_H


#include <algorithm>
#include <string_view>
#include <cstring>

namespace ada::checkers {

inline bool has_hex_prefix_unsafe(std::string_view input) {
  // This is actually efficient code, see has_hex_prefix for the assembly.
  uint32_t value_one = 1;
  bool is_little_endian = (reinterpret_cast<char*>(&value_one)[0] == 1);
  uint16_t word0x{};
  std::memcpy(&word0x, "0x", 2);  // we would use bit_cast in C++20 and the
                                  // function could be constexpr.
  uint16_t two_first_bytes{};
  std::memcpy(&two_first_bytes, input.data(), 2);
  if (is_little_endian) {
    two_first_bytes |= 0x2000;
  } else {
    two_first_bytes |= 0x020;
  }
  return two_first_bytes == word0x;
}

inline bool has_hex_prefix(std::string_view input) {
  return input.size() >= 2 && has_hex_prefix_unsafe(input);
}

constexpr bool is_digit(char x) noexcept { return (x >= '0') & (x <= '9'); }

constexpr char to_lower(char x) noexcept { return (x | 0x20); }

constexpr bool is_alpha(char x) noexcept {
  return (to_lower(x) >= 'a') && (to_lower(x) <= 'z');
}

inline constexpr bool is_windows_drive_letter(std::string_view input) noexcept {
  return input.size() >= 2 &&
         (is_alpha(input[0]) && ((input[1] == ':') || (input[1] == '|'))) &&
         ((input.size() == 2) || (input[2] == '/' || input[2] == '\\' ||
                                  input[2] == '?' || input[2] == '#'));
}

inline constexpr bool is_normalized_windows_drive_letter(
    std::string_view input) noexcept {
  return input.size() >= 2 && (is_alpha(input[0]) && (input[1] == ':'));
}

ada_really_inline bool begins_with(std::string_view view,
                                   std::string_view prefix) {
  // in C++20, you have view.begins_with(prefix)
  // std::equal is constexpr in C++20
  return view.size() >= prefix.size() &&
         std::equal(prefix.begin(), prefix.end(), view.begin());
}

}  // namespace ada::checkers

#endif  // ADA_CHECKERS_INL_H
/* end file include/ada/checkers-inl.h */
/* begin file include/ada/log.h */
/**
 * @file log.h
 * @brief Includes the definitions for logging.
 * @private Excluded from docs through the doxygen file.
 */
#ifndef ADA_LOG_H
#define ADA_LOG_H

#include <iostream>
// To enable logging, set ADA_LOGGING to 1:
#ifndef ADA_LOGGING
#define ADA_LOGGING 0
#endif

namespace ada {

/**
 * Private function used for logging messages.
 * @private
 */
template <typename T>
ada_really_inline void inner_log([[maybe_unused]] T t) {
#if ADA_LOGGING
  std::cout << t << std::endl;
#endif
}

/**
 * Private function used for logging messages.
 * @private
 */
template <typename T, typename... Args>
ada_really_inline void inner_log([[maybe_unused]] T t,
                                 [[maybe_unused]] Args... args) {
#if ADA_LOGGING
  std::cout << t;
  inner_log(args...);
#endif
}

/**
 * Log a message.
 * @private
 */
template <typename T, typename... Args>
ada_really_inline void log([[maybe_unused]] T t,
                           [[maybe_unused]] Args... args) {
#if ADA_LOGGING
  std::cout << "ADA_LOG: " << t;
  inner_log(args...);
#endif
}

/**
 * Log a message.
 * @private
 */
template <typename T>
ada_really_inline void log([[maybe_unused]] T t) {
#if ADA_LOGGING
  std::cout << "ADA_LOG: " << t << std::endl;
#endif
}
}  // namespace ada

#if ADA_LOGGING

#ifndef ada_log
#define ada_log(...)       \
  do {                     \
    ada::log(__VA_ARGS__); \
  } while (0)
#endif  // ada_log
#else
#define ada_log(...)
#endif  // ADA_LOGGING

#endif  // ADA_LOG_H
/* end file include/ada/log.h */
/* begin file include/ada/encoding_type.h */
/**
 * @file encoding_type.h
 * @brief Definition for supported encoding types.
 */
#ifndef ADA_ENCODING_TYPE_H
#define ADA_ENCODING_TYPE_H

#include <string>

namespace ada {

/**
 * This specification defines three encodings with the same names as encoding
 * schemes defined in the Unicode standard: UTF-8, UTF-16LE, and UTF-16BE.
 *
 * @see https://encoding.spec.whatwg.org/#encodings
 */
enum class encoding_type {
  UTF8,
  UTF_16LE,
  UTF_16BE,
};

/**
 * Convert a encoding_type to string.
 */
ada_warn_unused std::string to_string(encoding_type type);

}  // namespace ada

#endif  // ADA_ENCODING_TYPE_H
/* end file include/ada/encoding_type.h */
/* begin file include/ada/helpers.h */
/**
 * @file helpers.h
 * @brief Definitions for helper functions used within Ada.
 */
#ifndef ADA_HELPERS_H
#define ADA_HELPERS_H

/* begin file include/ada/state.h */
/**
 * @file state.h
 * @brief Definitions for the states of the URL state machine.
 */
#ifndef ADA_STATE_H
#define ADA_STATE_H


#include <string>

namespace ada {

/**
 * @see https://url.spec.whatwg.org/#url-parsing
 */
enum class state {
  /**
   * @see https://url.spec.whatwg.org/#authority-state
   */
  AUTHORITY,

  /**
   * @see https://url.spec.whatwg.org/#scheme-start-state
   */
  SCHEME_START,

  /**
   * @see https://url.spec.whatwg.org/#scheme-state
   */
  SCHEME,

  /**
   * @see https://url.spec.whatwg.org/#host-state
   */
  HOST,

  /**
   * @see https://url.spec.whatwg.org/#no-scheme-state
   */
  NO_SCHEME,

  /**
   * @see https://url.spec.whatwg.org/#fragment-state
   */
  FRAGMENT,

  /**
   * @see https://url.spec.whatwg.org/#relative-state
   */
  RELATIVE_SCHEME,

  /**
   * @see https://url.spec.whatwg.org/#relative-slash-state
   */
  RELATIVE_SLASH,

  /**
   * @see https://url.spec.whatwg.org/#file-state
   */
  FILE,

  /**
   * @see https://url.spec.whatwg.org/#file-host-state
   */
  FILE_HOST,

  /**
   * @see https://url.spec.whatwg.org/#file-slash-state
   */
  FILE_SLASH,

  /**
   * @see https://url.spec.whatwg.org/#path-or-authority-state
   */
  PATH_OR_AUTHORITY,

  /**
   * @see https://url.spec.whatwg.org/#special-authority-ignore-slashes-state
   */
  SPECIAL_AUTHORITY_IGNORE_SLASHES,

  /**
   * @see https://url.spec.whatwg.org/#special-authority-slashes-state
   */
  SPECIAL_AUTHORITY_SLASHES,

  /**
   * @see https://url.spec.whatwg.org/#special-relative-or-authority-state
   */
  SPECIAL_RELATIVE_OR_AUTHORITY,

  /**
   * @see https://url.spec.whatwg.org/#query-state
   */
  QUERY,

  /**
   * @see https://url.spec.whatwg.org/#path-state
   */
  PATH,

  /**
   * @see https://url.spec.whatwg.org/#path-start-state
   */
  PATH_START,

  /**
   * @see https://url.spec.whatwg.org/#cannot-be-a-base-url-path-state
   */
  OPAQUE_PATH,

  /**
   * @see https://url.spec.whatwg.org/#port-state
   */
  PORT,
};

/**
 * Stringify a URL state machine state.
 */
ada_warn_unused std::string to_string(ada::state s);

}  // namespace ada

#endif  // ADA_STATE_H
/* end file include/ada/state.h */
/* begin file include/ada/url_base.h */
/**
 * @file url_base.h
 * @brief Declaration for the basic URL definitions
 */
#ifndef ADA_URL_BASE_H
#define ADA_URL_BASE_H

/* begin file include/ada/url_components.h */
/**
 * @file url_components.h
 * @brief Declaration for the URL Components
 */
#ifndef ADA_URL_COMPONENTS_H
#define ADA_URL_COMPONENTS_H


#include <optional>
#include <string_view>

namespace ada {

/**
 * @brief URL Component representations using offsets.
 *
 * @details We design the url_components struct so that it is as small
 * and simple as possible. This version uses 32 bytes.
 *
 * This struct is used to extract components from a single 'href'.
 */
struct url_components {
  constexpr static uint32_t omitted = uint32_t(-1);

  url_components() = default;
  url_components(const url_components &u) = default;
  url_components(url_components &&u) noexcept = default;
  url_components &operator=(url_components &&u) noexcept = default;
  url_components &operator=(const url_components &u) = default;
  ~url_components() = default;

  /*
   * By using 32-bit integers, we implicitly assume that the URL string
   * cannot exceed 4 GB.
   *
   * https://user:pass@example.com:1234/foo/bar?baz#quux
   *       |     |    |          | ^^^^|       |   |
   *       |     |    |          | |   |       |   `----- hash_start
   *       |     |    |          | |   |       `--------- search_start
   *       |     |    |          | |   `----------------- pathname_start
   *       |     |    |          | `--------------------- port
   *       |     |    |          `----------------------- host_end
   *       |     |    `---------------------------------- host_start
   *       |     `--------------------------------------- username_end
   *       `--------------------------------------------- protocol_end
   */
  uint32_t protocol_end{0};
  /**
   * Username end is not `omitted` by default to make username and password
   * getters less costly to implement.
   */
  uint32_t username_end{0};
  uint32_t host_start{0};
  uint32_t host_end{0};
  uint32_t port{omitted};
  uint32_t pathname_start{0};
  uint32_t search_start{omitted};
  uint32_t hash_start{omitted};

  /**
   * Check the following conditions:
   * protocol_end < username_end < ... < hash_start,
   * expect when a value is omitted. It also computes
   * a lower bound on  the possible string length that may match these
   * offsets.
   * @return true if the offset values are
   *  consistent with a possible URL string
   */
  [[nodiscard]] bool check_offset_consistency() const noexcept;

  /**
   * Converts a url_components to JSON stringified version.
   */
  [[nodiscard]] std::string to_string() const;

};  // struct url_components

}  // namespace ada
#endif
/* end file include/ada/url_components.h */
/* begin file include/ada/scheme.h */
/**
 * @file scheme.h
 * @brief Declarations for the URL scheme.
 */
#ifndef ADA_SCHEME_H
#define ADA_SCHEME_H


#include <array>
#include <optional>
#include <string>

/**
 * @namespace ada::scheme
 * @brief Includes the scheme declarations
 */
namespace ada::scheme {

/**
 * Type of the scheme as an enum.
 * Using strings to represent a scheme type is not ideal because
 * checking for types involves string comparisons. It is faster to use
 * a simple integer.
 * In C++11, we are allowed to specify the underlying type of the enum.
 * We pick an 8-bit integer (which allows up to 256 types). Specifying the
 * type of the enum may help integration with other systems if the type
 * variable is exposed (since its value will not depend on the compiler).
 */
enum type : uint8_t {
  HTTP = 0,
  NOT_SPECIAL = 1,
  HTTPS = 2,
  WS = 3,
  FTP = 4,
  WSS = 5,
  FILE = 6
};

/**
 * A special scheme is an ASCII string that is listed in the first column of the
 * following table. The default port for a special scheme is listed in the
 * second column on the same row. The default port for any other ASCII string is
 * null.
 *
 * @see https://url.spec.whatwg.org/#url-miscellaneous
 * @param scheme
 * @return If scheme is a special scheme
 */
ada_really_inline constexpr bool is_special(std::string_view scheme);

/**
 * A special scheme is an ASCII string that is listed in the first column of the
 * following table. The default port for a special scheme is listed in the
 * second column on the same row. The default port for any other ASCII string is
 * null.
 *
 * @see https://url.spec.whatwg.org/#url-miscellaneous
 * @param scheme
 * @return The special port
 */
constexpr uint16_t get_special_port(std::string_view scheme) noexcept;

/**
 * Returns the port number of a special scheme.
 * @see https://url.spec.whatwg.org/#special-scheme
 */
constexpr uint16_t get_special_port(ada::scheme::type type) noexcept;
/**
 * Returns the scheme of an input, or NOT_SPECIAL if it's not a special scheme
 * defined by the spec.
 */
constexpr ada::scheme::type get_scheme_type(std::string_view scheme) noexcept;

}  // namespace ada::scheme

#endif  // ADA_SCHEME_H
/* end file include/ada/scheme.h */

#include <string_view>

namespace ada {

/**
 * Type of URL host as an enum.
 */
enum url_host_type : uint8_t {
  /**
   * Represents common URLs such as "https://www.google.com"
   */
  DEFAULT = 0,
  /**
   * Represents ipv4 addresses such as "http://127.0.0.1"
   */
  IPV4 = 1,
  /**
   * Represents ipv6 addresses such as
   * "http://[2001:db8:3333:4444:5555:6666:7777:8888]"
   */
  IPV6 = 2,
};

/**
 * @brief Base class of URL implementations
 *
 * @details A url_base contains a few attributes: is_valid, has_opaque_path and
 * type. All non-trivial implementation details are in derived classes such as
 * ada::url and ada::url_aggregator.
 *
 * It is an abstract class that cannot be instantiated directly.
 */
struct url_base {
  virtual ~url_base() = default;

  /**
   * Used for returning the validity from the result of the URL parser.
   */
  bool is_valid{true};

  /**
   * A URL has an opaque path if its path is a string.
   */
  bool has_opaque_path{false};

  /**
   * URL hosts type
   */
  url_host_type host_type = url_host_type::DEFAULT;

  /**
   * @private
   */
  ada::scheme::type type{ada::scheme::type::NOT_SPECIAL};

  /**
   * A URL is special if its scheme is a special scheme. A URL is not special if
   * its scheme is not a special scheme.
   */
  [[nodiscard]] ada_really_inline bool is_special() const noexcept;

  /**
   * The origin getter steps are to return the serialization of this's URL's
   * origin. [HTML]
   * @return a newly allocated string.
   * @see https://url.spec.whatwg.org/#concept-url-origin
   */
  [[nodiscard]] virtual std::string get_origin() const noexcept = 0;

  /**
   * Returns true if this URL has a valid domain as per RFC 1034 and
   * corresponding specifications. Among other things, it requires
   * that the domain string has fewer than 255 octets.
   */
  [[nodiscard]] virtual bool has_valid_domain() const noexcept = 0;

  /**
   * @private
   *
   * Return the 'special port' if the URL is special and not 'file'.
   * Returns 0 otherwise.
   */
  [[nodiscard]] inline uint16_t get_special_port() const noexcept;

  /**
   * @private
   *
   * Get the default port if the url's scheme has one, returns 0 otherwise.
   */
  [[nodiscard]] ada_really_inline uint16_t scheme_default_port() const noexcept;

  /**
   * @private
   *
   * Parse a port (16-bit decimal digit) from the provided input.
   * We assume that the input does not contain spaces or tabs
   * within the ASCII digits.
   * It returns how many bytes were consumed when a number is successfully
   * parsed.
   * @return On failure, it returns zero.
   * @see https://url.spec.whatwg.org/#host-parsing
   */
  virtual size_t parse_port(std::string_view view,
                            bool check_trailing_content) noexcept = 0;

  virtual ada_really_inline size_t parse_port(std::string_view view) noexcept {
    return this->parse_port(view, false);
  }

  /**
   * Returns a JSON string representation of this URL.
   */
  [[nodiscard]] virtual std::string to_string() const = 0;

  /** @private */
  virtual inline void clear_pathname() = 0;

  /** @private */
  virtual inline void clear_search() = 0;

  /** @private */
  [[nodiscard]] virtual inline bool has_hash() const noexcept = 0;

  /** @private */
  [[nodiscard]] virtual inline bool has_search() const noexcept = 0;

};  // url_base

}  // namespace ada

#endif
/* end file include/ada/url_base.h */

#include <string_view>
#include <optional>

/**
 * These functions are not part of our public API and may
 * change at any time.
 *
 * @private
 * @namespace ada::helpers
 * @brief Includes the definitions for helper functions
 */
namespace ada::helpers {

/**
 * @private
 */
template <typename out_iter>
void encode_json(std::string_view view, out_iter out);

/**
 * @private
 * This function is used to prune a fragment from a url, and returning the
 * removed string if input has fragment.
 *
 * @details prune_hash seeks the first '#' and returns everything after it
 * as a string_view, and modifies (in place) the input so that it points at
 * everything before the '#'. If no '#' is found, the input is left unchanged
 * and std::nullopt is returned.
 *
 * @attention The function is non-allocating and it does not throw.
 * @returns Note that the returned string_view might be empty!
 */
ada_really_inline std::optional<std::string_view> prune_hash(
    std::string_view& input) noexcept;

/**
 * @private
 * Defined by the URL specification, shorten a URLs paths.
 * @see https://url.spec.whatwg.org/#shorten-a-urls-path
 * @returns Returns true if path is shortened.
 */
ada_really_inline bool shorten_path(std::string& path,
                                    ada::scheme::type type) noexcept;

/**
 * @private
 * Defined by the URL specification, shorten a URLs paths.
 * @see https://url.spec.whatwg.org/#shorten-a-urls-path
 * @returns Returns true if path is shortened.
 */
ada_really_inline bool shorten_path(std::string_view& path,
                                    ada::scheme::type type) noexcept;

/**
 * @private
 *
 * Parse the path from the provided input and append to the existing
 * (possibly empty) path. The input cannot contain tabs and spaces: it
 * is the user's responsibility to check.
 *
 * The input is expected to be UTF-8.
 *
 * @see https://url.spec.whatwg.org/
 */
ada_really_inline void parse_prepared_path(std::string_view input,
                                           ada::scheme::type type,
                                           std::string& path);

/**
 * @private
 * Remove and mutate all ASCII tab or newline characters from an input.
 */
ada_really_inline void remove_ascii_tab_or_newline(std::string& input) noexcept;

/**
 * @private
 * Return the substring from input going from index pos to the end.
 * This function cannot throw.
 */
ada_really_inline std::string_view substring(std::string_view input,
                                             size_t pos) noexcept;

/**
 * @private
 * Returns true if the string_view points within the string.
 */
bool overlaps(std::string_view input1, const std::string& input2) noexcept;

/**
 * @private
 * Return the substring from input going from index pos1 to the pos2 (non
 * included). The length of the substring is pos2 - pos1.
 */
ada_really_inline std::string_view substring(const std::string& input,
                                             size_t pos1,
                                             size_t pos2) noexcept {
#if ADA_DEVELOPMENT_CHECKS
  if (pos2 < pos1) {
    std::cerr << "Negative-length substring: [" << pos1 << " to " << pos2 << ")"
              << std::endl;
    abort();
  }
#endif
  return std::string_view(input.data() + pos1, pos2 - pos1);
}

/**
 * @private
 * Modify the string_view so that it has the new size pos, assuming that pos <=
 * input.size(). This function cannot throw.
 */
ada_really_inline void resize(std::string_view& input, size_t pos) noexcept;

/**
 * @private
 * Returns a host's delimiter location depending on the state of the instance,
 * and whether a colon was found outside brackets. Used by the host parser.
 */
ada_really_inline std::pair<size_t, bool> get_host_delimiter_location(
    const bool is_special, std::string_view& view) noexcept;

/**
 * @private
 * Removes leading and trailing C0 control and whitespace characters from
 * string.
 */
ada_really_inline void trim_c0_whitespace(std::string_view& input) noexcept;

/**
 * @private
 * @see
 * https://url.spec.whatwg.org/#potentially-strip-trailing-spaces-from-an-opaque-path
 */
template <class url_type>
ada_really_inline void strip_trailing_spaces_from_opaque_path(
    url_type& url) noexcept;

/**
 * @private
 * Finds the delimiter of a view in authority state.
 */
ada_really_inline size_t
find_authority_delimiter_special(std::string_view view) noexcept;

/**
 * @private
 * Finds the delimiter of a view in authority state.
 */
ada_really_inline size_t
find_authority_delimiter(std::string_view view) noexcept;

/**
 * @private
 */
template <typename T, typename... Args>
inline void inner_concat(std::string& buffer, T t) {
  buffer.append(t);
}

/**
 * @private
 */
template <typename T, typename... Args>
inline void inner_concat(std::string& buffer, T t, Args... args) {
  buffer.append(t);
  return inner_concat(buffer, args...);
}

/**
 * @private
 * Concatenate the arguments and return a string.
 * @returns a string
 */
template <typename... Args>
std::string concat(Args... args) {
  std::string answer;
  inner_concat(answer, args...);
  return answer;
}

/**
 * @private
 * @return Number of leading zeroes.
 */
inline int leading_zeroes(uint32_t input_num) noexcept {
#if ADA_REGULAR_VISUAL_STUDIO
  unsigned long leading_zero(0);
  unsigned long in(input_num);
  return _BitScanReverse(&leading_zero, in) ? int(31 - leading_zero) : 32;
#else
  return __builtin_clz(input_num);
#endif  // ADA_REGULAR_VISUAL_STUDIO
}

/**
 * @private
 * Counts the number of decimal digits necessary to represent x.
 * faster than std::to_string(x).size().
 * @return digit count
 */
inline int fast_digit_count(uint32_t x) noexcept {
  auto int_log2 = [](uint32_t z) -> int {
    return 31 - ada::helpers::leading_zeroes(z | 1);
  };
  // Compiles to very few instructions. Note that the
  // table is static and thus effectively a constant.
  // We leave it inside the function because it is meaningless
  // outside of it (this comes at no performance cost).
  const static uint64_t table[] = {
      4294967296,  8589934582,  8589934582,  8589934582,  12884901788,
      12884901788, 12884901788, 17179868184, 17179868184, 17179868184,
      21474826480, 21474826480, 21474826480, 21474826480, 25769703776,
      25769703776, 25769703776, 30063771072, 30063771072, 30063771072,
      34349738368, 34349738368, 34349738368, 34349738368, 38554705664,
      38554705664, 38554705664, 41949672960, 41949672960, 41949672960,
      42949672960, 42949672960};
  return int((x + table[int_log2(x)]) >> 32);
}
}  // namespace ada::helpers

#endif  // ADA_HELPERS_H
/* end file include/ada/helpers.h */
/* begin file include/ada/parser.h */
/**
 * @file parser.h
 * @brief Definitions for the parser.
 */
#ifndef ADA_PARSER_H
#define ADA_PARSER_H

#include <optional>
#include <string_view>

/* begin file include/ada/expected.h */
/**
 * @file expected.h
 * @brief Definitions for std::expected
 * @private Excluded from docs through the doxygen file.
 */
///
// expected - An implementation of std::expected with extensions
// Written in 2017 by Sy Brand (tartanllama@gmail.com, @TartanLlama)
//
// Documentation available at http://tl.tartanllama.xyz/
//
// To the extent possible under law, the author(s) have dedicated all
// copyright and related and neighboring rights to this software to the
// public domain worldwide. This software is distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication
// along with this software. If not, see
// <http://creativecommons.org/publicdomain/zero/1.0/>.
///

#ifndef TL_EXPECTED_HPP
#define TL_EXPECTED_HPP

#define TL_EXPECTED_VERSION_MAJOR 1
#define TL_EXPECTED_VERSION_MINOR 1
#define TL_EXPECTED_VERSION_PATCH 0

#include <exception>
#include <functional>
#include <type_traits>
#include <utility>

#if defined(__EXCEPTIONS) || defined(_CPPUNWIND)
#define TL_EXPECTED_EXCEPTIONS_ENABLED
#endif

#if (defined(_MSC_VER) && _MSC_VER == 1900)
#define TL_EXPECTED_MSVC2015
#define TL_EXPECTED_MSVC2015_CONSTEXPR
#else
#define TL_EXPECTED_MSVC2015_CONSTEXPR constexpr
#endif

#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 && \
     !defined(__clang__))
#define TL_EXPECTED_GCC49
#endif

#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 4 && \
     !defined(__clang__))
#define TL_EXPECTED_GCC54
#endif

#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 5 && \
     !defined(__clang__))
#define TL_EXPECTED_GCC55
#endif

#if !defined(TL_ASSERT)
// can't have assert in constexpr in C++11 and GCC 4.9 has a compiler bug
#if (__cplusplus > 201103L) && !defined(TL_EXPECTED_GCC49)
#include <cassert>
#define TL_ASSERT(x) assert(x)
#else
#define TL_ASSERT(x)
#endif
#endif

#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 && \
     !defined(__clang__))
// GCC < 5 doesn't support overloading on const&& for member functions

#define TL_EXPECTED_NO_CONSTRR
// GCC < 5 doesn't support some standard C++11 type traits
#define TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T) \
  std::has_trivial_copy_constructor<T>
#define TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(T) \
  std::has_trivial_copy_assign<T>

// This one will be different for GCC 5.7 if it's ever supported
#define TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(T) \
  std::is_trivially_destructible<T>

// GCC 5 < v < 8 has a bug in is_trivially_copy_constructible which breaks
// std::vector for non-copyable types
#elif (defined(__GNUC__) && __GNUC__ < 8 && !defined(__clang__))
#ifndef TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX
#define TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX
namespace tl {
namespace detail {
template <class T>
struct is_trivially_copy_constructible
    : std::is_trivially_copy_constructible<T> {};
#ifdef _GLIBCXX_VECTOR
template <class T, class A>
struct is_trivially_copy_constructible<std::vector<T, A>> : std::false_type {};
#endif
}  // namespace detail
}  // namespace tl
#endif

#define TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T) \
  tl::detail::is_trivially_copy_constructible<T>
#define TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(T) \
  std::is_trivially_copy_assignable<T>
#define TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(T) \
  std::is_trivially_destructible<T>
#else
#define TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T) \
  std::is_trivially_copy_constructible<T>
#define TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(T) \
  std::is_trivially_copy_assignable<T>
#define TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(T) \
  std::is_trivially_destructible<T>
#endif

#if __cplusplus > 201103L
#define TL_EXPECTED_CXX14
#endif

#ifdef TL_EXPECTED_GCC49
#define TL_EXPECTED_GCC49_CONSTEXPR
#else
#define TL_EXPECTED_GCC49_CONSTEXPR constexpr
#endif

#if (__cplusplus == 201103L || defined(TL_EXPECTED_MSVC2015) || \
     defined(TL_EXPECTED_GCC49))
#define TL_EXPECTED_11_CONSTEXPR
#else
#define TL_EXPECTED_11_CONSTEXPR constexpr
#endif

namespace tl {
template <class T, class E>
class expected;

#ifndef TL_MONOSTATE_INPLACE_MUTEX
#define TL_MONOSTATE_INPLACE_MUTEX
class monostate {};

struct in_place_t {
  explicit in_place_t() = default;
};
static constexpr in_place_t in_place{};
#endif

template <class E>
class unexpected {
 public:
  static_assert(!std::is_same<E, void>::value, "E must not be void");

  unexpected() = delete;
  constexpr explicit unexpected(const E &e) : m_val(e) {}

  constexpr explicit unexpected(E &&e) : m_val(std::move(e)) {}

  template <class... Args, typename std::enable_if<std::is_constructible<
                               E, Args &&...>::value>::type * = nullptr>
  constexpr explicit unexpected(Args &&...args)
      : m_val(std::forward<Args>(args)...) {}
  template <
      class U, class... Args,
      typename std::enable_if<std::is_constructible<
          E, std::initializer_list<U> &, Args &&...>::value>::type * = nullptr>
  constexpr explicit unexpected(std::initializer_list<U> l, Args &&...args)
      : m_val(l, std::forward<Args>(args)...) {}

  constexpr const E &value() const & { return m_val; }
  TL_EXPECTED_11_CONSTEXPR E &value() & { return m_val; }
  TL_EXPECTED_11_CONSTEXPR E &&value() && { return std::move(m_val); }
  constexpr const E &&value() const && { return std::move(m_val); }

 private:
  E m_val;
};

#ifdef __cpp_deduction_guides
template <class E>
unexpected(E) -> unexpected<E>;
#endif

template <class E>
constexpr bool operator==(const unexpected<E> &lhs, const unexpected<E> &rhs) {
  return lhs.value() == rhs.value();
}
template <class E>
constexpr bool operator!=(const unexpected<E> &lhs, const unexpected<E> &rhs) {
  return lhs.value() != rhs.value();
}
template <class E>
constexpr bool operator<(const unexpected<E> &lhs, const unexpected<E> &rhs) {
  return lhs.value() < rhs.value();
}
template <class E>
constexpr bool operator<=(const unexpected<E> &lhs, const unexpected<E> &rhs) {
  return lhs.value() <= rhs.value();
}
template <class E>
constexpr bool operator>(const unexpected<E> &lhs, const unexpected<E> &rhs) {
  return lhs.value() > rhs.value();
}
template <class E>
constexpr bool operator>=(const unexpected<E> &lhs, const unexpected<E> &rhs) {
  return lhs.value() >= rhs.value();
}

template <class E>
unexpected<typename std::decay<E>::type> make_unexpected(E &&e) {
  return unexpected<typename std::decay<E>::type>(std::forward<E>(e));
}

struct unexpect_t {
  unexpect_t() = default;
};
static constexpr unexpect_t unexpect{};

namespace detail {
template <typename E>
[[noreturn]] TL_EXPECTED_11_CONSTEXPR void throw_exception(E &&e) {
#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
  throw std::forward<E>(e);
#else
  (void)e;
#ifdef _MSC_VER
  __assume(0);
#else
  __builtin_unreachable();
#endif
#endif
}

#ifndef TL_TRAITS_MUTEX
#define TL_TRAITS_MUTEX
// C++14-style aliases for brevity
template <class T>
using remove_const_t = typename std::remove_const<T>::type;
template <class T>
using remove_reference_t = typename std::remove_reference<T>::type;
template <class T>
using decay_t = typename std::decay<T>::type;
template <bool E, class T = void>
using enable_if_t = typename std::enable_if<E, T>::type;
template <bool B, class T, class F>
using conditional_t = typename std::conditional<B, T, F>::type;

// std::conjunction from C++17
template <class...>
struct conjunction : std::true_type {};
template <class B>
struct conjunction<B> : B {};
template <class B, class... Bs>
struct conjunction<B, Bs...>
    : std::conditional<bool(B::value), conjunction<Bs...>, B>::type {};

#if defined(_LIBCPP_VERSION) && __cplusplus == 201103L
#define TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
#endif

// In C++11 mode, there's an issue in libc++'s std::mem_fn
// which results in a hard-error when using it in a noexcept expression
// in some cases. This is a check to workaround the common failing case.
#ifdef TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
template <class T>
struct is_pointer_to_non_const_member_func : std::false_type {};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...)>
    : std::true_type {};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) &>
    : std::true_type {};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) &&>
    : std::true_type {};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) volatile>
    : std::true_type {};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) volatile &>
    : std::true_type {};
template <class T, class Ret, class... Args>
struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) volatile &&>
    : std::true_type {};

template <class T>
struct is_const_or_const_ref : std::false_type {};
template <class T>
struct is_const_or_const_ref<T const &> : std::true_type {};
template <class T>
struct is_const_or_const_ref<T const> : std::true_type {};
#endif

// std::invoke from C++17
// https://stackoverflow.com/questions/38288042/c11-14-invoke-workaround
template <
    typename Fn, typename... Args,
#ifdef TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
    typename = enable_if_t<!(is_pointer_to_non_const_member_func<Fn>::value &&
                             is_const_or_const_ref<Args...>::value)>,
#endif
    typename = enable_if_t<std::is_member_pointer<decay_t<Fn>>::value>, int = 0>
constexpr auto invoke(Fn &&f, Args &&...args) noexcept(
    noexcept(std::mem_fn(f)(std::forward<Args>(args)...)))
    -> decltype(std::mem_fn(f)(std::forward<Args>(args)...)) {
  return std::mem_fn(f)(std::forward<Args>(args)...);
}

template <typename Fn, typename... Args,
          typename = enable_if_t<!std::is_member_pointer<decay_t<Fn>>::value>>
constexpr auto invoke(Fn &&f, Args &&...args) noexcept(
    noexcept(std::forward<Fn>(f)(std::forward<Args>(args)...)))
    -> decltype(std::forward<Fn>(f)(std::forward<Args>(args)...)) {
  return std::forward<Fn>(f)(std::forward<Args>(args)...);
}

// std::invoke_result from C++17
template <class F, class, class... Us>
struct invoke_result_impl;

template <class F, class... Us>
struct invoke_result_impl<
    F,
    decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...), void()),
    Us...> {
  using type =
      decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...));
};

template <class F, class... Us>
using invoke_result = invoke_result_impl<F, void, Us...>;

template <class F, class... Us>
using invoke_result_t = typename invoke_result<F, Us...>::type;

#if defined(_MSC_VER) && _MSC_VER <= 1900
// TODO make a version which works with MSVC 2015
template <class T, class U = T>
struct is_swappable : std::true_type {};

template <class T, class U = T>
struct is_nothrow_swappable : std::true_type {};
#else
// https://stackoverflow.com/questions/26744589/what-is-a-proper-way-to-implement-is-swappable-to-test-for-the-swappable-concept
namespace swap_adl_tests {
// if swap ADL finds this then it would call std::swap otherwise (same
// signature)
struct tag {};

template <class T>
tag swap(T &, T &);
template <class T, std::size_t N>
tag swap(T (&a)[N], T (&b)[N]);

// helper functions to test if an unqualified swap is possible, and if it
// becomes std::swap
template <class, class>
std::false_type can_swap(...) noexcept(false);
template <class T, class U,
          class = decltype(swap(std::declval<T &>(), std::declval<U &>()))>
std::true_type can_swap(int) noexcept(noexcept(swap(std::declval<T &>(),
                                                    std::declval<U &>())));

template <class, class>
std::false_type uses_std(...);
template <class T, class U>
std::is_same<decltype(swap(std::declval<T &>(), std::declval<U &>())), tag>
uses_std(int);

template <class T>
struct is_std_swap_noexcept
    : std::integral_constant<bool,
                             std::is_nothrow_move_constructible<T>::value &&
                                 std::is_nothrow_move_assignable<T>::value> {};

template <class T, std::size_t N>
struct is_std_swap_noexcept<T[N]> : is_std_swap_noexcept<T> {};

template <class T, class U>
struct is_adl_swap_noexcept
    : std::integral_constant<bool, noexcept(can_swap<T, U>(0))> {};
}  // namespace swap_adl_tests

template <class T, class U = T>
struct is_swappable
    : std::integral_constant<
          bool,
          decltype(detail::swap_adl_tests::can_swap<T, U>(0))::value &&
              (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value ||
               (std::is_move_assignable<T>::value &&
                std::is_move_constructible<T>::value))> {};

template <class T, std::size_t N>
struct is_swappable<T[N], T[N]>
    : std::integral_constant<
          bool,
          decltype(detail::swap_adl_tests::can_swap<T[N], T[N]>(0))::value &&
              (!decltype(detail::swap_adl_tests::uses_std<T[N], T[N]>(
                   0))::value ||
               is_swappable<T, T>::value)> {};

template <class T, class U = T>
struct is_nothrow_swappable
    : std::integral_constant<
          bool,
          is_swappable<T, U>::value &&
              ((decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value &&
                detail::swap_adl_tests::is_std_swap_noexcept<T>::value) ||
               (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value &&
                detail::swap_adl_tests::is_adl_swap_noexcept<T, U>::value))> {};
#endif
#endif

// Trait for checking if a type is a tl::expected
template <class T>
struct is_expected_impl : std::false_type {};
template <class T, class E>
struct is_expected_impl<expected<T, E>> : std::true_type {};
template <class T>
using is_expected = is_expected_impl<decay_t<T>>;

template <class T, class E, class U>
using expected_enable_forward_value = detail::enable_if_t<
    std::is_constructible<T, U &&>::value &&
    !std::is_same<detail::decay_t<U>, in_place_t>::value &&
    !std::is_same<expected<T, E>, detail::decay_t<U>>::value &&
    !std::is_same<unexpected<E>, detail::decay_t<U>>::value>;

template <class T, class E, class U, class G, class UR, class GR>
using expected_enable_from_other = detail::enable_if_t<
    std::is_constructible<T, UR>::value &&
    std::is_constructible<E, GR>::value &&
    !std::is_constructible<T, expected<U, G> &>::value &&
    !std::is_constructible<T, expected<U, G> &&>::value &&
    !std::is_constructible<T, const expected<U, G> &>::value &&
    !std::is_constructible<T, const expected<U, G> &&>::value &&
    !std::is_convertible<expected<U, G> &, T>::value &&
    !std::is_convertible<expected<U, G> &&, T>::value &&
    !std::is_convertible<const expected<U, G> &, T>::value &&
    !std::is_convertible<const expected<U, G> &&, T>::value>;

template <class T, class U>
using is_void_or = conditional_t<std::is_void<T>::value, std::true_type, U>;

template <class T>
using is_copy_constructible_or_void =
    is_void_or<T, std::is_copy_constructible<T>>;

template <class T>
using is_move_constructible_or_void =
    is_void_or<T, std::is_move_constructible<T>>;

template <class T>
using is_copy_assignable_or_void = is_void_or<T, std::is_copy_assignable<T>>;

template <class T>
using is_move_assignable_or_void = is_void_or<T, std::is_move_assignable<T>>;

}  // namespace detail

namespace detail {
struct no_init_t {};
static constexpr no_init_t no_init{};

// Implements the storage of the values, and ensures that the destructor is
// trivial if it can be.
//
// This specialization is for where neither `T` or `E` is trivially
// destructible, so the destructors must be called on destruction of the
// `expected`
template <class T, class E, bool = std::is_trivially_destructible<T>::value,
          bool = std::is_trivially_destructible<E>::value>
struct expected_storage_base {
  constexpr expected_storage_base() : m_val(T{}), m_has_val(true) {}
  constexpr expected_storage_base(no_init_t) : m_no_init(), m_has_val(false) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
                nullptr>
  constexpr expected_storage_base(in_place_t, Args &&...args)
      : m_val(std::forward<Args>(args)...), m_has_val(true) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr expected_storage_base(in_place_t, std::initializer_list<U> il,
                                  Args &&...args)
      : m_val(il, std::forward<Args>(args)...), m_has_val(true) {}
  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected_storage_base(unexpect_t, Args &&...args)
      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected_storage_base(unexpect_t,
                                           std::initializer_list<U> il,
                                           Args &&...args)
      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}

  ~expected_storage_base() {
    if (m_has_val) {
      m_val.~T();
    } else {
      m_unexpect.~unexpected<E>();
    }
  }
  union {
    T m_val;
    unexpected<E> m_unexpect;
    char m_no_init;
  };
  bool m_has_val;
};

// This specialization is for when both `T` and `E` are trivially-destructible,
// so the destructor of the `expected` can be trivial.
template <class T, class E>
struct expected_storage_base<T, E, true, true> {
  constexpr expected_storage_base() : m_val(T{}), m_has_val(true) {}
  constexpr expected_storage_base(no_init_t) : m_no_init(), m_has_val(false) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
                nullptr>
  constexpr expected_storage_base(in_place_t, Args &&...args)
      : m_val(std::forward<Args>(args)...), m_has_val(true) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr expected_storage_base(in_place_t, std::initializer_list<U> il,
                                  Args &&...args)
      : m_val(il, std::forward<Args>(args)...), m_has_val(true) {}
  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected_storage_base(unexpect_t, Args &&...args)
      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected_storage_base(unexpect_t,
                                           std::initializer_list<U> il,
                                           Args &&...args)
      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}

  ~expected_storage_base() = default;
  union {
    T m_val;
    unexpected<E> m_unexpect;
    char m_no_init;
  };
  bool m_has_val;
};

// T is trivial, E is not.
template <class T, class E>
struct expected_storage_base<T, E, true, false> {
  constexpr expected_storage_base() : m_val(T{}), m_has_val(true) {}
  TL_EXPECTED_MSVC2015_CONSTEXPR expected_storage_base(no_init_t)
      : m_no_init(), m_has_val(false) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
                nullptr>
  constexpr expected_storage_base(in_place_t, Args &&...args)
      : m_val(std::forward<Args>(args)...), m_has_val(true) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr expected_storage_base(in_place_t, std::initializer_list<U> il,
                                  Args &&...args)
      : m_val(il, std::forward<Args>(args)...), m_has_val(true) {}
  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected_storage_base(unexpect_t, Args &&...args)
      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected_storage_base(unexpect_t,
                                           std::initializer_list<U> il,
                                           Args &&...args)
      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}

  ~expected_storage_base() {
    if (!m_has_val) {
      m_unexpect.~unexpected<E>();
    }
  }

  union {
    T m_val;
    unexpected<E> m_unexpect;
    char m_no_init;
  };
  bool m_has_val;
};

// E is trivial, T is not.
template <class T, class E>
struct expected_storage_base<T, E, false, true> {
  constexpr expected_storage_base() : m_val(T{}), m_has_val(true) {}
  constexpr expected_storage_base(no_init_t) : m_no_init(), m_has_val(false) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
                nullptr>
  constexpr expected_storage_base(in_place_t, Args &&...args)
      : m_val(std::forward<Args>(args)...), m_has_val(true) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr expected_storage_base(in_place_t, std::initializer_list<U> il,
                                  Args &&...args)
      : m_val(il, std::forward<Args>(args)...), m_has_val(true) {}
  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected_storage_base(unexpect_t, Args &&...args)
      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected_storage_base(unexpect_t,
                                           std::initializer_list<U> il,
                                           Args &&...args)
      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}

  ~expected_storage_base() {
    if (m_has_val) {
      m_val.~T();
    }
  }
  union {
    T m_val;
    unexpected<E> m_unexpect;
    char m_no_init;
  };
  bool m_has_val;
};

// `T` is `void`, `E` is trivially-destructible
template <class E>
struct expected_storage_base<void, E, false, true> {
#if __GNUC__ <= 5
// no constexpr for GCC 4/5 bug
#else
  TL_EXPECTED_MSVC2015_CONSTEXPR
#endif
  expected_storage_base() : m_has_val(true) {}

  constexpr expected_storage_base(no_init_t) : m_val(), m_has_val(false) {}

  constexpr expected_storage_base(in_place_t) : m_has_val(true) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected_storage_base(unexpect_t, Args &&...args)
      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected_storage_base(unexpect_t,
                                           std::initializer_list<U> il,
                                           Args &&...args)
      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}

  ~expected_storage_base() = default;
  struct dummy {};
  union {
    unexpected<E> m_unexpect;
    dummy m_val;
  };
  bool m_has_val;
};

// `T` is `void`, `E` is not trivially-destructible
template <class E>
struct expected_storage_base<void, E, false, false> {
  constexpr expected_storage_base() : m_dummy(), m_has_val(true) {}
  constexpr expected_storage_base(no_init_t) : m_dummy(), m_has_val(false) {}

  constexpr expected_storage_base(in_place_t) : m_dummy(), m_has_val(true) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected_storage_base(unexpect_t, Args &&...args)
      : m_unexpect(std::forward<Args>(args)...), m_has_val(false) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected_storage_base(unexpect_t,
                                           std::initializer_list<U> il,
                                           Args &&...args)
      : m_unexpect(il, std::forward<Args>(args)...), m_has_val(false) {}

  ~expected_storage_base() {
    if (!m_has_val) {
      m_unexpect.~unexpected<E>();
    }
  }

  union {
    unexpected<E> m_unexpect;
    char m_dummy;
  };
  bool m_has_val;
};

// This base class provides some handy member functions which can be used in
// further derived classes
template <class T, class E>
struct expected_operations_base : expected_storage_base<T, E> {
  using expected_storage_base<T, E>::expected_storage_base;

  template <class... Args>
  void construct(Args &&...args) noexcept {
    new (std::addressof(this->m_val)) T(std::forward<Args>(args)...);
    this->m_has_val = true;
  }

  template <class Rhs>
  void construct_with(Rhs &&rhs) noexcept {
    new (std::addressof(this->m_val)) T(std::forward<Rhs>(rhs).get());
    this->m_has_val = true;
  }

  template <class... Args>
  void construct_error(Args &&...args) noexcept {
    new (std::addressof(this->m_unexpect))
        unexpected<E>(std::forward<Args>(args)...);
    this->m_has_val = false;
  }

#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED

  // These assign overloads ensure that the most efficient assignment
  // implementation is used while maintaining the strong exception guarantee.
  // The problematic case is where rhs has a value, but *this does not.
  //
  // This overload handles the case where we can just copy-construct `T`
  // directly into place without throwing.
  template <class U = T,
            detail::enable_if_t<std::is_nothrow_copy_constructible<U>::value>
                * = nullptr>
  void assign(const expected_operations_base &rhs) noexcept {
    if (!this->m_has_val && rhs.m_has_val) {
      geterr().~unexpected<E>();
      construct(rhs.get());
    } else {
      assign_common(rhs);
    }
  }

  // This overload handles the case where we can attempt to create a copy of
  // `T`, then no-throw move it into place if the copy was successful.
  template <class U = T,
            detail::enable_if_t<!std::is_nothrow_copy_constructible<U>::value &&
                                std::is_nothrow_move_constructible<U>::value>
                * = nullptr>
  void assign(const expected_operations_base &rhs) noexcept {
    if (!this->m_has_val && rhs.m_has_val) {
      T tmp = rhs.get();
      geterr().~unexpected<E>();
      construct(std::move(tmp));
    } else {
      assign_common(rhs);
    }
  }

  // This overload is the worst-case, where we have to move-construct the
  // unexpected value into temporary storage, then try to copy the T into place.
  // If the construction succeeds, then everything is fine, but if it throws,
  // then we move the old unexpected value back into place before rethrowing the
  // exception.
  template <class U = T,
            detail::enable_if_t<!std::is_nothrow_copy_constructible<U>::value &&
                                !std::is_nothrow_move_constructible<U>::value>
                * = nullptr>
  void assign(const expected_operations_base &rhs) {
    if (!this->m_has_val && rhs.m_has_val) {
      auto tmp = std::move(geterr());
      geterr().~unexpected<E>();

#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
      try {
        construct(rhs.get());
      } catch (...) {
        geterr() = std::move(tmp);
        throw;
      }
#else
      construct(rhs.get());
#endif
    } else {
      assign_common(rhs);
    }
  }

  // These overloads do the same as above, but for rvalues
  template <class U = T,
            detail::enable_if_t<std::is_nothrow_move_constructible<U>::value>
                * = nullptr>
  void assign(expected_operations_base &&rhs) noexcept {
    if (!this->m_has_val && rhs.m_has_val) {
      geterr().~unexpected<E>();
      construct(std::move(rhs).get());
    } else {
      assign_common(std::move(rhs));
    }
  }

  template <class U = T,
            detail::enable_if_t<!std::is_nothrow_move_constructible<U>::value>
                * = nullptr>
  void assign(expected_operations_base &&rhs) {
    if (!this->m_has_val && rhs.m_has_val) {
      auto tmp = std::move(geterr());
      geterr().~unexpected<E>();
#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
      try {
        construct(std::move(rhs).get());
      } catch (...) {
        geterr() = std::move(tmp);
        throw;
      }
#else
      construct(std::move(rhs).get());
#endif
    } else {
      assign_common(std::move(rhs));
    }
  }

#else

  // If exceptions are disabled then we can just copy-construct
  void assign(const expected_operations_base &rhs) noexcept {
    if (!this->m_has_val && rhs.m_has_val) {
      geterr().~unexpected<E>();
      construct(rhs.get());
    } else {
      assign_common(rhs);
    }
  }

  void assign(expected_operations_base &&rhs) noexcept {
    if (!this->m_has_val && rhs.m_has_val) {
      geterr().~unexpected<E>();
      construct(std::move(rhs).get());
    } else {
      assign_common(std::move(rhs));
    }
  }

#endif

  // The common part of move/copy assigning
  template <class Rhs>
  void assign_common(Rhs &&rhs) {
    if (this->m_has_val) {
      if (rhs.m_has_val) {
        get() = std::forward<Rhs>(rhs).get();
      } else {
        destroy_val();
        construct_error(std::forward<Rhs>(rhs).geterr());
      }
    } else {
      if (!rhs.m_has_val) {
        geterr() = std::forward<Rhs>(rhs).geterr();
      }
    }
  }

  bool has_value() const { return this->m_has_val; }

  TL_EXPECTED_11_CONSTEXPR T &get() & { return this->m_val; }
  constexpr const T &get() const & { return this->m_val; }
  TL_EXPECTED_11_CONSTEXPR T &&get() && { return std::move(this->m_val); }
#ifndef TL_EXPECTED_NO_CONSTRR
  constexpr const T &&get() const && { return std::move(this->m_val); }
#endif

  TL_EXPECTED_11_CONSTEXPR unexpected<E> &geterr() & {
    return this->m_unexpect;
  }
  constexpr const unexpected<E> &geterr() const & { return this->m_unexpect; }
  TL_EXPECTED_11_CONSTEXPR unexpected<E> &&geterr() && {
    return std::move(this->m_unexpect);
  }
#ifndef TL_EXPECTED_NO_CONSTRR
  constexpr const unexpected<E> &&geterr() const && {
    return std::move(this->m_unexpect);
  }
#endif

  TL_EXPECTED_11_CONSTEXPR void destroy_val() { get().~T(); }
};

// This base class provides some handy member functions which can be used in
// further derived classes
template <class E>
struct expected_operations_base<void, E> : expected_storage_base<void, E> {
  using expected_storage_base<void, E>::expected_storage_base;

  template <class... Args>
  void construct() noexcept {
    this->m_has_val = true;
  }

  // This function doesn't use its argument, but needs it so that code in
  // levels above this can work independently of whether T is void
  template <class Rhs>
  void construct_with(Rhs &&) noexcept {
    this->m_has_val = true;
  }

  template <class... Args>
  void construct_error(Args &&...args) noexcept {
    new (std::addressof(this->m_unexpect))
        unexpected<E>(std::forward<Args>(args)...);
    this->m_has_val = false;
  }

  template <class Rhs>
  void assign(Rhs &&rhs) noexcept {
    if (!this->m_has_val) {
      if (rhs.m_has_val) {
        geterr().~unexpected<E>();
        construct();
      } else {
        geterr() = std::forward<Rhs>(rhs).geterr();
      }
    } else {
      if (!rhs.m_has_val) {
        construct_error(std::forward<Rhs>(rhs).geterr());
      }
    }
  }

  bool has_value() const { return this->m_has_val; }

  TL_EXPECTED_11_CONSTEXPR unexpected<E> &geterr() & {
    return this->m_unexpect;
  }
  constexpr const unexpected<E> &geterr() const & { return this->m_unexpect; }
  TL_EXPECTED_11_CONSTEXPR unexpected<E> &&geterr() && {
    return std::move(this->m_unexpect);
  }
#ifndef TL_EXPECTED_NO_CONSTRR
  constexpr const unexpected<E> &&geterr() const && {
    return std::move(this->m_unexpect);
  }
#endif

  TL_EXPECTED_11_CONSTEXPR void destroy_val() {
    // no-op
  }
};

// This class manages conditionally having a trivial copy constructor
// This specialization is for when T and E are trivially copy constructible
template <class T, class E,
          bool = is_void_or<T, TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(
                                   T)>::value &&
                 TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(E)::value>
struct expected_copy_base : expected_operations_base<T, E> {
  using expected_operations_base<T, E>::expected_operations_base;
};

// This specialization is for when T or E are not trivially copy constructible
template <class T, class E>
struct expected_copy_base<T, E, false> : expected_operations_base<T, E> {
  using expected_operations_base<T, E>::expected_operations_base;

  expected_copy_base() = default;
  expected_copy_base(const expected_copy_base &rhs)
      : expected_operations_base<T, E>(no_init) {
    if (rhs.has_value()) {
      this->construct_with(rhs);
    } else {
      this->construct_error(rhs.geterr());
    }
  }

  expected_copy_base(expected_copy_base &&rhs) = default;
  expected_copy_base &operator=(const expected_copy_base &rhs) = default;
  expected_copy_base &operator=(expected_copy_base &&rhs) = default;
};

// This class manages conditionally having a trivial move constructor
// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
// doesn't implement an analogue to std::is_trivially_move_constructible. We
// have to make do with a non-trivial move constructor even if T is trivially
// move constructible
#ifndef TL_EXPECTED_GCC49
template <class T, class E,
          bool =
              is_void_or<T, std::is_trivially_move_constructible<T>>::value &&
              std::is_trivially_move_constructible<E>::value>
struct expected_move_base : expected_copy_base<T, E> {
  using expected_copy_base<T, E>::expected_copy_base;
};
#else
template <class T, class E, bool = false>
struct expected_move_base;
#endif
template <class T, class E>
struct expected_move_base<T, E, false> : expected_copy_base<T, E> {
  using expected_copy_base<T, E>::expected_copy_base;

  expected_move_base() = default;
  expected_move_base(const expected_move_base &rhs) = default;

  expected_move_base(expected_move_base &&rhs) noexcept(
      std::is_nothrow_move_constructible<T>::value)
      : expected_copy_base<T, E>(no_init) {
    if (rhs.has_value()) {
      this->construct_with(std::move(rhs));
    } else {
      this->construct_error(std::move(rhs.geterr()));
    }
  }
  expected_move_base &operator=(const expected_move_base &rhs) = default;
  expected_move_base &operator=(expected_move_base &&rhs) = default;
};

// This class manages conditionally having a trivial copy assignment operator
template <
    class T, class E,
    bool =
        is_void_or<
            T, conjunction<TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(T),
                           TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T),
                           TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(T)>>::value &&
        TL_EXPECTED_IS_TRIVIALLY_COPY_ASSIGNABLE(E)::value &&
        TL_EXPECTED_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(E)::value &&
        TL_EXPECTED_IS_TRIVIALLY_DESTRUCTIBLE(E)::value>
struct expected_copy_assign_base : expected_move_base<T, E> {
  using expected_move_base<T, E>::expected_move_base;
};

template <class T, class E>
struct expected_copy_assign_base<T, E, false> : expected_move_base<T, E> {
  using expected_move_base<T, E>::expected_move_base;

  expected_copy_assign_base() = default;
  expected_copy_assign_base(const expected_copy_assign_base &rhs) = default;

  expected_copy_assign_base(expected_copy_assign_base &&rhs) = default;
  expected_copy_assign_base &operator=(const expected_copy_assign_base &rhs) {
    this->assign(rhs);
    return *this;
  }
  expected_copy_assign_base &operator=(expected_copy_assign_base &&rhs) =
      default;
};

// This class manages conditionally having a trivial move assignment operator
// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
// doesn't implement an analogue to std::is_trivially_move_assignable. We have
// to make do with a non-trivial move assignment operator even if T is trivially
// move assignable
#ifndef TL_EXPECTED_GCC49
template <
    class T, class E,
    bool = is_void_or<
               T, conjunction<std::is_trivially_destructible<T>,
                              std::is_trivially_move_constructible<T>,
                              std::is_trivially_move_assignable<T>>>::value &&
           std::is_trivially_destructible<E>::value &&
           std::is_trivially_move_constructible<E>::value &&
           std::is_trivially_move_assignable<E>::value>
struct expected_move_assign_base : expected_copy_assign_base<T, E> {
  using expected_copy_assign_base<T, E>::expected_copy_assign_base;
};
#else
template <class T, class E, bool = false>
struct expected_move_assign_base;
#endif

template <class T, class E>
struct expected_move_assign_base<T, E, false>
    : expected_copy_assign_base<T, E> {
  using expected_copy_assign_base<T, E>::expected_copy_assign_base;

  expected_move_assign_base() = default;
  expected_move_assign_base(const expected_move_assign_base &rhs) = default;

  expected_move_assign_base(expected_move_assign_base &&rhs) = default;

  expected_move_assign_base &operator=(const expected_move_assign_base &rhs) =
      default;

  expected_move_assign_base &operator=(
      expected_move_assign_base
          &&rhs) noexcept(std::is_nothrow_move_constructible<T>::value &&
                          std::is_nothrow_move_assignable<T>::value) {
    this->assign(std::move(rhs));
    return *this;
  }
};

// expected_delete_ctor_base will conditionally delete copy and move
// constructors depending on whether T is copy/move constructible
template <class T, class E,
          bool EnableCopy = (is_copy_constructible_or_void<T>::value &&
                             std::is_copy_constructible<E>::value),
          bool EnableMove = (is_move_constructible_or_void<T>::value &&
                             std::is_move_constructible<E>::value)>
struct expected_delete_ctor_base {
  expected_delete_ctor_base() = default;
  expected_delete_ctor_base(const expected_delete_ctor_base &) = default;
  expected_delete_ctor_base(expected_delete_ctor_base &&) noexcept = default;
  expected_delete_ctor_base &operator=(const expected_delete_ctor_base &) =
      default;
  expected_delete_ctor_base &operator=(expected_delete_ctor_base &&) noexcept =
      default;
};

template <class T, class E>
struct expected_delete_ctor_base<T, E, true, false> {
  expected_delete_ctor_base() = default;
  expected_delete_ctor_base(const expected_delete_ctor_base &) = default;
  expected_delete_ctor_base(expected_delete_ctor_base &&) noexcept = delete;
  expected_delete_ctor_base &operator=(const expected_delete_ctor_base &) =
      default;
  expected_delete_ctor_base &operator=(expected_delete_ctor_base &&) noexcept =
      default;
};

template <class T, class E>
struct expected_delete_ctor_base<T, E, false, true> {
  expected_delete_ctor_base() = default;
  expected_delete_ctor_base(const expected_delete_ctor_base &) = delete;
  expected_delete_ctor_base(expected_delete_ctor_base &&) noexcept = default;
  expected_delete_ctor_base &operator=(const expected_delete_ctor_base &) =
      default;
  expected_delete_ctor_base &operator=(expected_delete_ctor_base &&) noexcept =
      default;
};

template <class T, class E>
struct expected_delete_ctor_base<T, E, false, false> {
  expected_delete_ctor_base() = default;
  expected_delete_ctor_base(const expected_delete_ctor_base &) = delete;
  expected_delete_ctor_base(expected_delete_ctor_base &&) noexcept = delete;
  expected_delete_ctor_base &operator=(const expected_delete_ctor_base &) =
      default;
  expected_delete_ctor_base &operator=(expected_delete_ctor_base &&) noexcept =
      default;
};

// expected_delete_assign_base will conditionally delete copy and move
// constructors depending on whether T and E are copy/move constructible +
// assignable
template <class T, class E,
          bool EnableCopy = (is_copy_constructible_or_void<T>::value &&
                             std::is_copy_constructible<E>::value &&
                             is_copy_assignable_or_void<T>::value &&
                             std::is_copy_assignable<E>::value),
          bool EnableMove = (is_move_constructible_or_void<T>::value &&
                             std::is_move_constructible<E>::value &&
                             is_move_assignable_or_void<T>::value &&
                             std::is_move_assignable<E>::value)>
struct expected_delete_assign_base {
  expected_delete_assign_base() = default;
  expected_delete_assign_base(const expected_delete_assign_base &) = default;
  expected_delete_assign_base(expected_delete_assign_base &&) noexcept =
      default;
  expected_delete_assign_base &operator=(const expected_delete_assign_base &) =
      default;
  expected_delete_assign_base &operator=(
      expected_delete_assign_base &&) noexcept = default;
};

template <class T, class E>
struct expected_delete_assign_base<T, E, true, false> {
  expected_delete_assign_base() = default;
  expected_delete_assign_base(const expected_delete_assign_base &) = default;
  expected_delete_assign_base(expected_delete_assign_base &&) noexcept =
      default;
  expected_delete_assign_base &operator=(const expected_delete_assign_base &) =
      default;
  expected_delete_assign_base &operator=(
      expected_delete_assign_base &&) noexcept = delete;
};

template <class T, class E>
struct expected_delete_assign_base<T, E, false, true> {
  expected_delete_assign_base() = default;
  expected_delete_assign_base(const expected_delete_assign_base &) = default;
  expected_delete_assign_base(expected_delete_assign_base &&) noexcept =
      default;
  expected_delete_assign_base &operator=(const expected_delete_assign_base &) =
      delete;
  expected_delete_assign_base &operator=(
      expected_delete_assign_base &&) noexcept = default;
};

template <class T, class E>
struct expected_delete_assign_base<T, E, false, false> {
  expected_delete_assign_base() = default;
  expected_delete_assign_base(const expected_delete_assign_base &) = default;
  expected_delete_assign_base(expected_delete_assign_base &&) noexcept =
      default;
  expected_delete_assign_base &operator=(const expected_delete_assign_base &) =
      delete;
  expected_delete_assign_base &operator=(
      expected_delete_assign_base &&) noexcept = delete;
};

// This is needed to be able to construct the expected_default_ctor_base which
// follows, while still conditionally deleting the default constructor.
struct default_constructor_tag {
  explicit constexpr default_constructor_tag() = default;
};

// expected_default_ctor_base will ensure that expected has a deleted default
// consturctor if T is not default constructible.
// This specialization is for when T is default constructible
template <class T, class E,
          bool Enable =
              std::is_default_constructible<T>::value || std::is_void<T>::value>
struct expected_default_ctor_base {
  constexpr expected_default_ctor_base() noexcept = default;
  constexpr expected_default_ctor_base(
      expected_default_ctor_base const &) noexcept = default;
  constexpr expected_default_ctor_base(expected_default_ctor_base &&) noexcept =
      default;
  expected_default_ctor_base &operator=(
      expected_default_ctor_base const &) noexcept = default;
  expected_default_ctor_base &operator=(
      expected_default_ctor_base &&) noexcept = default;

  constexpr explicit expected_default_ctor_base(default_constructor_tag) {}
};

// This specialization is for when T is not default constructible
template <class T, class E>
struct expected_default_ctor_base<T, E, false> {
  constexpr expected_default_ctor_base() noexcept = delete;
  constexpr expected_default_ctor_base(
      expected_default_ctor_base const &) noexcept = default;
  constexpr expected_default_ctor_base(expected_default_ctor_base &&) noexcept =
      default;
  expected_default_ctor_base &operator=(
      expected_default_ctor_base const &) noexcept = default;
  expected_default_ctor_base &operator=(
      expected_default_ctor_base &&) noexcept = default;

  constexpr explicit expected_default_ctor_base(default_constructor_tag) {}
};
}  // namespace detail

template <class E>
class bad_expected_access : public std::exception {
 public:
  explicit bad_expected_access(E e) : m_val(std::move(e)) {}

  virtual const char *what() const noexcept override {
    return "Bad expected access";
  }

  const E &error() const & { return m_val; }
  E &error() & { return m_val; }
  const E &&error() const && { return std::move(m_val); }
  E &&error() && { return std::move(m_val); }

 private:
  E m_val;
};

/// An `expected<T, E>` object is an object that contains the storage for
/// another object and manages the lifetime of this contained object `T`.
/// Alternatively it could contain the storage for another unexpected object
/// `E`. The contained object may not be initialized after the expected object
/// has been initialized, and may not be destroyed before the expected object
/// has been destroyed. The initialization state of the contained object is
/// tracked by the expected object.
template <class T, class E>
class expected : private detail::expected_move_assign_base<T, E>,
                 private detail::expected_delete_ctor_base<T, E>,
                 private detail::expected_delete_assign_base<T, E>,
                 private detail::expected_default_ctor_base<T, E> {
  static_assert(!std::is_reference<T>::value, "T must not be a reference");
  static_assert(!std::is_same<T, std::remove_cv<in_place_t>::type>::value,
                "T must not be in_place_t");
  static_assert(!std::is_same<T, std::remove_cv<unexpect_t>::type>::value,
                "T must not be unexpect_t");
  static_assert(
      !std::is_same<T, typename std::remove_cv<unexpected<E>>::type>::value,
      "T must not be unexpected<E>");
  static_assert(!std::is_reference<E>::value, "E must not be a reference");

  T *valptr() { return std::addressof(this->m_val); }
  const T *valptr() const { return std::addressof(this->m_val); }
  unexpected<E> *errptr() { return std::addressof(this->m_unexpect); }
  const unexpected<E> *errptr() const {
    return std::addressof(this->m_unexpect);
  }

  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR U &val() {
    return this->m_val;
  }
  TL_EXPECTED_11_CONSTEXPR unexpected<E> &err() { return this->m_unexpect; }

  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  constexpr const U &val() const {
    return this->m_val;
  }
  constexpr const unexpected<E> &err() const { return this->m_unexpect; }

  using impl_base = detail::expected_move_assign_base<T, E>;
  using ctor_base = detail::expected_default_ctor_base<T, E>;

 public:
  typedef T value_type;
  typedef E error_type;
  typedef unexpected<E> unexpected_type;

#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) && \
    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto and_then(F &&f) & {
    return and_then_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto and_then(F &&f) && {
    return and_then_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr auto and_then(F &&f) const & {
    return and_then_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F>
  constexpr auto and_then(F &&f) const && {
    return and_then_impl(std::move(*this), std::forward<F>(f));
  }
#endif

#else
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto and_then(F &&f) & -> decltype(and_then_impl(
      std::declval<expected &>(), std::forward<F>(f))) {
    return and_then_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto and_then(F &&f) && -> decltype(and_then_impl(
      std::declval<expected &&>(), std::forward<F>(f))) {
    return and_then_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr auto and_then(F &&f) const & -> decltype(and_then_impl(
      std::declval<expected const &>(), std::forward<F>(f))) {
    return and_then_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F>
  constexpr auto and_then(F &&f) const && -> decltype(and_then_impl(
      std::declval<expected const &&>(), std::forward<F>(f))) {
    return and_then_impl(std::move(*this), std::forward<F>(f));
  }
#endif
#endif

#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) && \
    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto map(F &&f) & {
    return expected_map_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto map(F &&f) && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr auto map(F &&f) const & {
    return expected_map_impl(*this, std::forward<F>(f));
  }
  template <class F>
  constexpr auto map(F &&f) const && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
#else
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(expected_map_impl(
      std::declval<expected &>(), std::declval<F &&>()))
  map(F &&f) & {
    return expected_map_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(expected_map_impl(std::declval<expected>(),
                                                      std::declval<F &&>()))
  map(F &&f) && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr decltype(expected_map_impl(std::declval<const expected &>(),
                                       std::declval<F &&>()))
  map(F &&f) const & {
    return expected_map_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F>
  constexpr decltype(expected_map_impl(std::declval<const expected &&>(),
                                       std::declval<F &&>()))
  map(F &&f) const && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
#endif
#endif

#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) && \
    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto transform(F &&f) & {
    return expected_map_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto transform(F &&f) && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr auto transform(F &&f) const & {
    return expected_map_impl(*this, std::forward<F>(f));
  }
  template <class F>
  constexpr auto transform(F &&f) const && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
#else
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(expected_map_impl(
      std::declval<expected &>(), std::declval<F &&>()))
  transform(F &&f) & {
    return expected_map_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(expected_map_impl(std::declval<expected>(),
                                                      std::declval<F &&>()))
  transform(F &&f) && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr decltype(expected_map_impl(std::declval<const expected &>(),
                                       std::declval<F &&>()))
  transform(F &&f) const & {
    return expected_map_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F>
  constexpr decltype(expected_map_impl(std::declval<const expected &&>(),
                                       std::declval<F &&>()))
  transform(F &&f) const && {
    return expected_map_impl(std::move(*this), std::forward<F>(f));
  }
#endif
#endif

#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) && \
    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto map_error(F &&f) & {
    return map_error_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto map_error(F &&f) && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr auto map_error(F &&f) const & {
    return map_error_impl(*this, std::forward<F>(f));
  }
  template <class F>
  constexpr auto map_error(F &&f) const && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
#else
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(map_error_impl(std::declval<expected &>(),
                                                   std::declval<F &&>()))
  map_error(F &&f) & {
    return map_error_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(map_error_impl(std::declval<expected &&>(),
                                                   std::declval<F &&>()))
  map_error(F &&f) && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr decltype(map_error_impl(std::declval<const expected &>(),
                                    std::declval<F &&>()))
  map_error(F &&f) const & {
    return map_error_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F>
  constexpr decltype(map_error_impl(std::declval<const expected &&>(),
                                    std::declval<F &&>()))
  map_error(F &&f) const && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
#endif
#endif
#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) && \
    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto transform_error(F &&f) & {
    return map_error_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR auto transform_error(F &&f) && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr auto transform_error(F &&f) const & {
    return map_error_impl(*this, std::forward<F>(f));
  }
  template <class F>
  constexpr auto transform_error(F &&f) const && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
#else
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(map_error_impl(std::declval<expected &>(),
                                                   std::declval<F &&>()))
  transform_error(F &&f) & {
    return map_error_impl(*this, std::forward<F>(f));
  }
  template <class F>
  TL_EXPECTED_11_CONSTEXPR decltype(map_error_impl(std::declval<expected &&>(),
                                                   std::declval<F &&>()))
  transform_error(F &&f) && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
  template <class F>
  constexpr decltype(map_error_impl(std::declval<const expected &>(),
                                    std::declval<F &&>()))
  transform_error(F &&f) const & {
    return map_error_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F>
  constexpr decltype(map_error_impl(std::declval<const expected &&>(),
                                    std::declval<F &&>()))
  transform_error(F &&f) const && {
    return map_error_impl(std::move(*this), std::forward<F>(f));
  }
#endif
#endif
  template <class F>
  expected TL_EXPECTED_11_CONSTEXPR or_else(F &&f) & {
    return or_else_impl(*this, std::forward<F>(f));
  }

  template <class F>
  expected TL_EXPECTED_11_CONSTEXPR or_else(F &&f) && {
    return or_else_impl(std::move(*this), std::forward<F>(f));
  }

  template <class F>
  expected constexpr or_else(F &&f) const & {
    return or_else_impl(*this, std::forward<F>(f));
  }

#ifndef TL_EXPECTED_NO_CONSTRR
  template <class F>
  expected constexpr or_else(F &&f) const && {
    return or_else_impl(std::move(*this), std::forward<F>(f));
  }
#endif
  constexpr expected() = default;
  constexpr expected(const expected &rhs) = default;
  constexpr expected(expected &&rhs) = default;
  expected &operator=(const expected &rhs) = default;
  expected &operator=(expected &&rhs) = default;

  template <class... Args,
            detail::enable_if_t<std::is_constructible<T, Args &&...>::value> * =
                nullptr>
  constexpr expected(in_place_t, Args &&...args)
      : impl_base(in_place, std::forward<Args>(args)...),
        ctor_base(detail::default_constructor_tag{}) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr expected(in_place_t, std::initializer_list<U> il, Args &&...args)
      : impl_base(in_place, il, std::forward<Args>(args)...),
        ctor_base(detail::default_constructor_tag{}) {}

  template <class G = E,
            detail::enable_if_t<std::is_constructible<E, const G &>::value> * =
                nullptr,
            detail::enable_if_t<!std::is_convertible<const G &, E>::value> * =
                nullptr>
  explicit constexpr expected(const unexpected<G> &e)
      : impl_base(unexpect, e.value()),
        ctor_base(detail::default_constructor_tag{}) {}

  template <
      class G = E,
      detail::enable_if_t<std::is_constructible<E, const G &>::value> * =
          nullptr,
      detail::enable_if_t<std::is_convertible<const G &, E>::value> * = nullptr>
  constexpr expected(unexpected<G> const &e)
      : impl_base(unexpect, e.value()),
        ctor_base(detail::default_constructor_tag{}) {}

  template <
      class G = E,
      detail::enable_if_t<std::is_constructible<E, G &&>::value> * = nullptr,
      detail::enable_if_t<!std::is_convertible<G &&, E>::value> * = nullptr>
  explicit constexpr expected(unexpected<G> &&e) noexcept(
      std::is_nothrow_constructible<E, G &&>::value)
      : impl_base(unexpect, std::move(e.value())),
        ctor_base(detail::default_constructor_tag{}) {}

  template <
      class G = E,
      detail::enable_if_t<std::is_constructible<E, G &&>::value> * = nullptr,
      detail::enable_if_t<std::is_convertible<G &&, E>::value> * = nullptr>
  constexpr expected(unexpected<G> &&e) noexcept(
      std::is_nothrow_constructible<E, G &&>::value)
      : impl_base(unexpect, std::move(e.value())),
        ctor_base(detail::default_constructor_tag{}) {}

  template <class... Args,
            detail::enable_if_t<std::is_constructible<E, Args &&...>::value> * =
                nullptr>
  constexpr explicit expected(unexpect_t, Args &&...args)
      : impl_base(unexpect, std::forward<Args>(args)...),
        ctor_base(detail::default_constructor_tag{}) {}

  template <class U, class... Args,
            detail::enable_if_t<std::is_constructible<
                E, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  constexpr explicit expected(unexpect_t, std::initializer_list<U> il,
                              Args &&...args)
      : impl_base(unexpect, il, std::forward<Args>(args)...),
        ctor_base(detail::default_constructor_tag{}) {}

  template <class U, class G,
            detail::enable_if_t<!(std::is_convertible<U const &, T>::value &&
                                  std::is_convertible<G const &, E>::value)> * =
                nullptr,
            detail::expected_enable_from_other<T, E, U, G, const U &, const G &>
                * = nullptr>
  explicit TL_EXPECTED_11_CONSTEXPR expected(const expected<U, G> &rhs)
      : ctor_base(detail::default_constructor_tag{}) {
    if (rhs.has_value()) {
      this->construct(*rhs);
    } else {
      this->construct_error(rhs.error());
    }
  }

  template <class U, class G,
            detail::enable_if_t<(std::is_convertible<U const &, T>::value &&
                                 std::is_convertible<G const &, E>::value)> * =
                nullptr,
            detail::expected_enable_from_other<T, E, U, G, const U &, const G &>
                * = nullptr>
  TL_EXPECTED_11_CONSTEXPR expected(const expected<U, G> &rhs)
      : ctor_base(detail::default_constructor_tag{}) {
    if (rhs.has_value()) {
      this->construct(*rhs);
    } else {
      this->construct_error(rhs.error());
    }
  }

  template <
      class U, class G,
      detail::enable_if_t<!(std::is_convertible<U &&, T>::value &&
                            std::is_convertible<G &&, E>::value)> * = nullptr,
      detail::expected_enable_from_other<T, E, U, G, U &&, G &&> * = nullptr>
  explicit TL_EXPECTED_11_CONSTEXPR expected(expected<U, G> &&rhs)
      : ctor_base(detail::default_constructor_tag{}) {
    if (rhs.has_value()) {
      this->construct(std::move(*rhs));
    } else {
      this->construct_error(std::move(rhs.error()));
    }
  }

  template <
      class U, class G,
      detail::enable_if_t<(std::is_convertible<U &&, T>::value &&
                           std::is_convertible<G &&, E>::value)> * = nullptr,
      detail::expected_enable_from_other<T, E, U, G, U &&, G &&> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR expected(expected<U, G> &&rhs)
      : ctor_base(detail::default_constructor_tag{}) {
    if (rhs.has_value()) {
      this->construct(std::move(*rhs));
    } else {
      this->construct_error(std::move(rhs.error()));
    }
  }

  template <
      class U = T,
      detail::enable_if_t<!std::is_convertible<U &&, T>::value> * = nullptr,
      detail::expected_enable_forward_value<T, E, U> * = nullptr>
  explicit TL_EXPECTED_MSVC2015_CONSTEXPR expected(U &&v)
      : expected(in_place, std::forward<U>(v)) {}

  template <
      class U = T,
      detail::enable_if_t<std::is_convertible<U &&, T>::value> * = nullptr,
      detail::expected_enable_forward_value<T, E, U> * = nullptr>
  TL_EXPECTED_MSVC2015_CONSTEXPR expected(U &&v)
      : expected(in_place, std::forward<U>(v)) {}

  template <
      class U = T, class G = T,
      detail::enable_if_t<std::is_nothrow_constructible<T, U &&>::value> * =
          nullptr,
      detail::enable_if_t<!std::is_void<G>::value> * = nullptr,
      detail::enable_if_t<
          (!std::is_same<expected<T, E>, detail::decay_t<U>>::value &&
           !detail::conjunction<std::is_scalar<T>,
                                std::is_same<T, detail::decay_t<U>>>::value &&
           std::is_constructible<T, U>::value &&
           std::is_assignable<G &, U>::value &&
           std::is_nothrow_move_constructible<E>::value)> * = nullptr>
  expected &operator=(U &&v) {
    if (has_value()) {
      val() = std::forward<U>(v);
    } else {
      err().~unexpected<E>();
      ::new (valptr()) T(std::forward<U>(v));
      this->m_has_val = true;
    }

    return *this;
  }

  template <
      class U = T, class G = T,
      detail::enable_if_t<!std::is_nothrow_constructible<T, U &&>::value> * =
          nullptr,
      detail::enable_if_t<!std::is_void<U>::value> * = nullptr,
      detail::enable_if_t<
          (!std::is_same<expected<T, E>, detail::decay_t<U>>::value &&
           !detail::conjunction<std::is_scalar<T>,
                                std::is_same<T, detail::decay_t<U>>>::value &&
           std::is_constructible<T, U>::value &&
           std::is_assignable<G &, U>::value &&
           std::is_nothrow_move_constructible<E>::value)> * = nullptr>
  expected &operator=(U &&v) {
    if (has_value()) {
      val() = std::forward<U>(v);
    } else {
      auto tmp = std::move(err());
      err().~unexpected<E>();

#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
      try {
        ::new (valptr()) T(std::forward<U>(v));
        this->m_has_val = true;
      } catch (...) {
        err() = std::move(tmp);
        throw;
      }
#else
      ::new (valptr()) T(std::forward<U>(v));
      this->m_has_val = true;
#endif
    }

    return *this;
  }

  template <class G = E,
            detail::enable_if_t<std::is_nothrow_copy_constructible<G>::value &&
                                std::is_assignable<G &, G>::value> * = nullptr>
  expected &operator=(const unexpected<G> &rhs) {
    if (!has_value()) {
      err() = rhs;
    } else {
      this->destroy_val();
      ::new (errptr()) unexpected<E>(rhs);
      this->m_has_val = false;
    }

    return *this;
  }

  template <class G = E,
            detail::enable_if_t<std::is_nothrow_move_constructible<G>::value &&
                                std::is_move_assignable<G>::value> * = nullptr>
  expected &operator=(unexpected<G> &&rhs) noexcept {
    if (!has_value()) {
      err() = std::move(rhs);
    } else {
      this->destroy_val();
      ::new (errptr()) unexpected<E>(std::move(rhs));
      this->m_has_val = false;
    }

    return *this;
  }

  template <class... Args, detail::enable_if_t<std::is_nothrow_constructible<
                               T, Args &&...>::value> * = nullptr>
  void emplace(Args &&...args) {
    if (has_value()) {
      val().~T();
    } else {
      err().~unexpected<E>();
      this->m_has_val = true;
    }
    ::new (valptr()) T(std::forward<Args>(args)...);
  }

  template <class... Args, detail::enable_if_t<!std::is_nothrow_constructible<
                               T, Args &&...>::value> * = nullptr>
  void emplace(Args &&...args) {
    if (has_value()) {
      val().~T();
      ::new (valptr()) T(std::forward<Args>(args)...);
    } else {
      auto tmp = std::move(err());
      err().~unexpected<E>();

#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
      try {
        ::new (valptr()) T(std::forward<Args>(args)...);
        this->m_has_val = true;
      } catch (...) {
        err() = std::move(tmp);
        throw;
      }
#else
      ::new (valptr()) T(std::forward<Args>(args)...);
      this->m_has_val = true;
#endif
    }
  }

  template <class U, class... Args,
            detail::enable_if_t<std::is_nothrow_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  void emplace(std::initializer_list<U> il, Args &&...args) {
    if (has_value()) {
      T t(il, std::forward<Args>(args)...);
      val() = std::move(t);
    } else {
      err().~unexpected<E>();
      ::new (valptr()) T(il, std::forward<Args>(args)...);
      this->m_has_val = true;
    }
  }

  template <class U, class... Args,
            detail::enable_if_t<!std::is_nothrow_constructible<
                T, std::initializer_list<U> &, Args &&...>::value> * = nullptr>
  void emplace(std::initializer_list<U> il, Args &&...args) {
    if (has_value()) {
      T t(il, std::forward<Args>(args)...);
      val() = std::move(t);
    } else {
      auto tmp = std::move(err());
      err().~unexpected<E>();

#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
      try {
        ::new (valptr()) T(il, std::forward<Args>(args)...);
        this->m_has_val = true;
      } catch (...) {
        err() = std::move(tmp);
        throw;
      }
#else
      ::new (valptr()) T(il, std::forward<Args>(args)...);
      this->m_has_val = true;
#endif
    }
  }

 private:
  using t_is_void = std::true_type;
  using t_is_not_void = std::false_type;
  using t_is_nothrow_move_constructible = std::true_type;
  using move_constructing_t_can_throw = std::false_type;
  using e_is_nothrow_move_constructible = std::true_type;
  using move_constructing_e_can_throw = std::false_type;

  void swap_where_both_have_value(expected & /*rhs*/, t_is_void) noexcept {
    // swapping void is a no-op
  }

  void swap_where_both_have_value(expected &rhs, t_is_not_void) {
    using std::swap;
    swap(val(), rhs.val());
  }

  void swap_where_only_one_has_value(expected &rhs, t_is_void) noexcept(
      std::is_nothrow_move_constructible<E>::value) {
    ::new (errptr()) unexpected_type(std::move(rhs.err()));
    rhs.err().~unexpected_type();
    std::swap(this->m_has_val, rhs.m_has_val);
  }

  void swap_where_only_one_has_value(expected &rhs, t_is_not_void) {
    swap_where_only_one_has_value_and_t_is_not_void(
        rhs, typename std::is_nothrow_move_constructible<T>::type{},
        typename std::is_nothrow_move_constructible<E>::type{});
  }

  void swap_where_only_one_has_value_and_t_is_not_void(
      expected &rhs, t_is_nothrow_move_constructible,
      e_is_nothrow_move_constructible) noexcept {
    auto temp = std::move(val());
    val().~T();
    ::new (errptr()) unexpected_type(std::move(rhs.err()));
    rhs.err().~unexpected_type();
    ::new (rhs.valptr()) T(std::move(temp));
    std::swap(this->m_has_val, rhs.m_has_val);
  }

  void swap_where_only_one_has_value_and_t_is_not_void(
      expected &rhs, t_is_nothrow_move_constructible,
      move_constructing_e_can_throw) {
    auto temp = std::move(val());
    val().~T();
#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
    try {
      ::new (errptr()) unexpected_type(std::move(rhs.err()));
      rhs.err().~unexpected_type();
      ::new (rhs.valptr()) T(std::move(temp));
      std::swap(this->m_has_val, rhs.m_has_val);
    } catch (...) {
      val() = std::move(temp);
      throw;
    }
#else
    ::new (errptr()) unexpected_type(std::move(rhs.err()));
    rhs.err().~unexpected_type();
    ::new (rhs.valptr()) T(std::move(temp));
    std::swap(this->m_has_val, rhs.m_has_val);
#endif
  }

  void swap_where_only_one_has_value_and_t_is_not_void(
      expected &rhs, move_constructing_t_can_throw,
      e_is_nothrow_move_constructible) {
    auto temp = std::move(rhs.err());
    rhs.err().~unexpected_type();
#ifdef TL_EXPECTED_EXCEPTIONS_ENABLED
    try {
      ::new (rhs.valptr()) T(std::move(val()));
      val().~T();
      ::new (errptr()) unexpected_type(std::move(temp));
      std::swap(this->m_has_val, rhs.m_has_val);
    } catch (...) {
      rhs.err() = std::move(temp);
      throw;
    }
#else
    ::new (rhs.valptr()) T(std::move(val()));
    val().~T();
    ::new (errptr()) unexpected_type(std::move(temp));
    std::swap(this->m_has_val, rhs.m_has_val);
#endif
  }

 public:
  template <class OT = T, class OE = E>
  detail::enable_if_t<detail::is_swappable<OT>::value &&
                      detail::is_swappable<OE>::value &&
                      (std::is_nothrow_move_constructible<OT>::value ||
                       std::is_nothrow_move_constructible<OE>::value)>
  swap(expected &rhs) noexcept(std::is_nothrow_move_constructible<T>::value &&
                               detail::is_nothrow_swappable<T>::value &&
                               std::is_nothrow_move_constructible<E>::value &&
                               detail::is_nothrow_swappable<E>::value) {
    if (has_value() && rhs.has_value()) {
      swap_where_both_have_value(rhs, typename std::is_void<T>::type{});
    } else if (!has_value() && rhs.has_value()) {
      rhs.swap(*this);
    } else if (has_value()) {
      swap_where_only_one_has_value(rhs, typename std::is_void<T>::type{});
    } else {
      using std::swap;
      swap(err(), rhs.err());
    }
  }

  constexpr const T *operator->() const {
    TL_ASSERT(has_value());
    return valptr();
  }
  TL_EXPECTED_11_CONSTEXPR T *operator->() {
    TL_ASSERT(has_value());
    return valptr();
  }

  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  constexpr const U &operator*() const & {
    TL_ASSERT(has_value());
    return val();
  }
  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR U &operator*() & {
    TL_ASSERT(has_value());
    return val();
  }
  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  constexpr const U &&operator*() const && {
    TL_ASSERT(has_value());
    return std::move(val());
  }
  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR U &&operator*() && {
    TL_ASSERT(has_value());
    return std::move(val());
  }

  constexpr bool has_value() const noexcept { return this->m_has_val; }
  constexpr explicit operator bool() const noexcept { return this->m_has_val; }

  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR const U &value() const & {
    if (!has_value())
      detail::throw_exception(bad_expected_access<E>(err().value()));
    return val();
  }
  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR U &value() & {
    if (!has_value())
      detail::throw_exception(bad_expected_access<E>(err().value()));
    return val();
  }
  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR const U &&value() const && {
    if (!has_value())
      detail::throw_exception(bad_expected_access<E>(std::move(err()).value()));
    return std::move(val());
  }
  template <class U = T,
            detail::enable_if_t<!std::is_void<U>::value> * = nullptr>
  TL_EXPECTED_11_CONSTEXPR U &&value() && {
    if (!has_value())
      detail::throw_exception(bad_expected_access<E>(std::move(err()).value()));
    return std::move(val());
  }

  constexpr const E &error() const & {
    TL_ASSERT(!has_value());
    return err().value();
  }
  TL_EXPECTED_11_CONSTEXPR E &error() & {
    TL_ASSERT(!has_value());
    return err().value();
  }
  constexpr const E &&error() const && {
    TL_ASSERT(!has_value());
    return std::move(err().value());
  }
  TL_EXPECTED_11_CONSTEXPR E &&error() && {
    TL_ASSERT(!has_value());
    return std::move(err().value());
  }

  template <class U>
  constexpr T value_or(U &&v) const & {
    static_assert(std::is_copy_constructible<T>::value &&
                      std::is_convertible<U &&, T>::value,
                  "T must be copy-constructible and convertible to from U&&");
    return bool(*this) ? **this : static_cast<T>(std::forward<U>(v));
  }
  template <class U>
  TL_EXPECTED_11_CONSTEXPR T value_or(U &&v) && {
    static_assert(std::is_move_constructible<T>::value &&
                      std::is_convertible<U &&, T>::value,
                  "T must be move-constructible and convertible to from U&&");
    return bool(*this) ? std::move(**this) : static_cast<T>(std::forward<U>(v));
  }
};

namespace detail {
template <class Exp>
using exp_t = typename detail::decay_t<Exp>::value_type;
template <class Exp>
using err_t = typename detail::decay_t<Exp>::error_type;
template <class Exp, class Ret>
using ret_t = expected<Ret, err_t<Exp>>;

#ifdef TL_EXPECTED_CXX14
template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Exp>()))>
constexpr auto and_then_impl(Exp &&exp, F &&f) {
  static_assert(detail::is_expected<Ret>::value, "F must return an expected");

  return exp.has_value()
             ? detail::invoke(std::forward<F>(f), *std::forward<Exp>(exp))
             : Ret(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>()))>
constexpr auto and_then_impl(Exp &&exp, F &&f) {
  static_assert(detail::is_expected<Ret>::value, "F must return an expected");

  return exp.has_value() ? detail::invoke(std::forward<F>(f))
                         : Ret(unexpect, std::forward<Exp>(exp).error());
}
#else
template <class>
struct TC;
template <class Exp, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Exp>())),
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr>
auto and_then_impl(Exp &&exp, F &&f) -> Ret {
  static_assert(detail::is_expected<Ret>::value, "F must return an expected");

  return exp.has_value()
             ? detail::invoke(std::forward<F>(f), *std::forward<Exp>(exp))
             : Ret(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          class Ret = decltype(detail::invoke(std::declval<F>())),
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr>
constexpr auto and_then_impl(Exp &&exp, F &&f) -> Ret {
  static_assert(detail::is_expected<Ret>::value, "F must return an expected");

  return exp.has_value() ? detail::invoke(std::forward<F>(f))
                         : Ret(unexpect, std::forward<Exp>(exp).error());
}
#endif

#ifdef TL_EXPECTED_CXX14
template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Exp>())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto expected_map_impl(Exp &&exp, F &&f) {
  using result = ret_t<Exp, detail::decay_t<Ret>>;
  return exp.has_value() ? result(detail::invoke(std::forward<F>(f),
                                                 *std::forward<Exp>(exp)))
                         : result(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Exp>())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
auto expected_map_impl(Exp &&exp, F &&f) {
  using result = expected<void, err_t<Exp>>;
  if (exp.has_value()) {
    detail::invoke(std::forward<F>(f), *std::forward<Exp>(exp));
    return result();
  }

  return result(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto expected_map_impl(Exp &&exp, F &&f) {
  using result = ret_t<Exp, detail::decay_t<Ret>>;
  return exp.has_value() ? result(detail::invoke(std::forward<F>(f)))
                         : result(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
auto expected_map_impl(Exp &&exp, F &&f) {
  using result = expected<void, err_t<Exp>>;
  if (exp.has_value()) {
    detail::invoke(std::forward<F>(f));
    return result();
  }

  return result(unexpect, std::forward<Exp>(exp).error());
}
#else
template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Exp>())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>

constexpr auto expected_map_impl(Exp &&exp, F &&f)
    -> ret_t<Exp, detail::decay_t<Ret>> {
  using result = ret_t<Exp, detail::decay_t<Ret>>;

  return exp.has_value() ? result(detail::invoke(std::forward<F>(f),
                                                 *std::forward<Exp>(exp)))
                         : result(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              *std::declval<Exp>())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>

auto expected_map_impl(Exp &&exp, F &&f) -> expected<void, err_t<Exp>> {
  if (exp.has_value()) {
    detail::invoke(std::forward<F>(f), *std::forward<Exp>(exp));
    return {};
  }

  return unexpected<err_t<Exp>>(std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>

constexpr auto expected_map_impl(Exp &&exp, F &&f)
    -> ret_t<Exp, detail::decay_t<Ret>> {
  using result = ret_t<Exp, detail::decay_t<Ret>>;

  return exp.has_value() ? result(detail::invoke(std::forward<F>(f)))
                         : result(unexpect, std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>

auto expected_map_impl(Exp &&exp, F &&f) -> expected<void, err_t<Exp>> {
  if (exp.has_value()) {
    detail::invoke(std::forward<F>(f));
    return {};
  }

  return unexpected<err_t<Exp>>(std::forward<Exp>(exp).error());
}
#endif

#if defined(TL_EXPECTED_CXX14) && !defined(TL_EXPECTED_GCC49) && \
    !defined(TL_EXPECTED_GCC54) && !defined(TL_EXPECTED_GCC55)
template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto map_error_impl(Exp &&exp, F &&f) {
  using result = expected<exp_t<Exp>, detail::decay_t<Ret>>;
  return exp.has_value()
             ? result(*std::forward<Exp>(exp))
             : result(unexpect, detail::invoke(std::forward<F>(f),
                                               std::forward<Exp>(exp).error()));
}
template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
auto map_error_impl(Exp &&exp, F &&f) {
  using result = expected<exp_t<Exp>, monostate>;
  if (exp.has_value()) {
    return result(*std::forward<Exp>(exp));
  }

  detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
  return result(unexpect, monostate{});
}
template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto map_error_impl(Exp &&exp, F &&f) {
  using result = expected<exp_t<Exp>, detail::decay_t<Ret>>;
  return exp.has_value()
             ? result()
             : result(unexpect, detail::invoke(std::forward<F>(f),
                                               std::forward<Exp>(exp).error()));
}
template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
auto map_error_impl(Exp &&exp, F &&f) {
  using result = expected<exp_t<Exp>, monostate>;
  if (exp.has_value()) {
    return result();
  }

  detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
  return result(unexpect, monostate{});
}
#else
template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto map_error_impl(Exp &&exp, F &&f)
    -> expected<exp_t<Exp>, detail::decay_t<Ret>> {
  using result = expected<exp_t<Exp>, detail::decay_t<Ret>>;

  return exp.has_value()
             ? result(*std::forward<Exp>(exp))
             : result(unexpect, detail::invoke(std::forward<F>(f),
                                               std::forward<Exp>(exp).error()));
}

template <class Exp, class F,
          detail::enable_if_t<!std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
auto map_error_impl(Exp &&exp, F &&f) -> expected<exp_t<Exp>, monostate> {
  using result = expected<exp_t<Exp>, monostate>;
  if (exp.has_value()) {
    return result(*std::forward<Exp>(exp));
  }

  detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
  return result(unexpect, monostate{});
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto map_error_impl(Exp &&exp, F &&f)
    -> expected<exp_t<Exp>, detail::decay_t<Ret>> {
  using result = expected<exp_t<Exp>, detail::decay_t<Ret>>;

  return exp.has_value()
             ? result()
             : result(unexpect, detail::invoke(std::forward<F>(f),
                                               std::forward<Exp>(exp).error()));
}

template <class Exp, class F,
          detail::enable_if_t<std::is_void<exp_t<Exp>>::value> * = nullptr,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
auto map_error_impl(Exp &&exp, F &&f) -> expected<exp_t<Exp>, monostate> {
  using result = expected<exp_t<Exp>, monostate>;
  if (exp.has_value()) {
    return result();
  }

  detail::invoke(std::forward<F>(f), std::forward<Exp>(exp).error());
  return result(unexpect, monostate{});
}
#endif

#ifdef TL_EXPECTED_CXX14
template <class Exp, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
constexpr auto or_else_impl(Exp &&exp, F &&f) {
  static_assert(detail::is_expected<Ret>::value, "F must return an expected");
  return exp.has_value() ? std::forward<Exp>(exp)
                         : detail::invoke(std::forward<F>(f),
                                          std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
detail::decay_t<Exp> or_else_impl(Exp &&exp, F &&f) {
  return exp.has_value() ? std::forward<Exp>(exp)
                         : (detail::invoke(std::forward<F>(f),
                                           std::forward<Exp>(exp).error()),
                            std::forward<Exp>(exp));
}
#else
template <class Exp, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>
auto or_else_impl(Exp &&exp, F &&f) -> Ret {
  static_assert(detail::is_expected<Ret>::value, "F must return an expected");
  return exp.has_value() ? std::forward<Exp>(exp)
                         : detail::invoke(std::forward<F>(f),
                                          std::forward<Exp>(exp).error());
}

template <class Exp, class F,
          class Ret = decltype(detail::invoke(std::declval<F>(),
                                              std::declval<Exp>().error())),
          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>
detail::decay_t<Exp> or_else_impl(Exp &&exp, F &&f) {
  return exp.has_value() ? std::forward<Exp>(exp)
                         : (detail::invoke(std::forward<F>(f),
                                           std::forward<Exp>(exp).error()),
                            std::forward<Exp>(exp));
}
#endif
}  // namespace detail

template <class T, class E, class U, class F>
constexpr bool operator==(const expected<T, E> &lhs,
                          const expected<U, F> &rhs) {
  return (lhs.has_value() != rhs.has_value())
             ? false
             : (!lhs.has_value() ? lhs.error() == rhs.error() : *lhs == *rhs);
}
template <class T, class E, class U, class F>
constexpr bool operator!=(const expected<T, E> &lhs,
                          const expected<U, F> &rhs) {
  return (lhs.has_value() != rhs.has_value())
             ? true
             : (!lhs.has_value() ? lhs.error() != rhs.error() : *lhs != *rhs);
}
template <class E, class F>
constexpr bool operator==(const expected<void, E> &lhs,
                          const expected<void, F> &rhs) {
  return (lhs.has_value() != rhs.has_value())
             ? false
             : (!lhs.has_value() ? lhs.error() == rhs.error() : true);
}
template <class E, class F>
constexpr bool operator!=(const expected<void, E> &lhs,
                          const expected<void, F> &rhs) {
  return (lhs.has_value() != rhs.has_value())
             ? true
             : (!lhs.has_value() ? lhs.error() == rhs.error() : false);
}

template <class T, class E, class U>
constexpr bool operator==(const expected<T, E> &x, const U &v) {
  return x.has_value() ? *x == v : false;
}
template <class T, class E, class U>
constexpr bool operator==(const U &v, const expected<T, E> &x) {
  return x.has_value() ? *x == v : false;
}
template <class T, class E, class U>
constexpr bool operator!=(const expected<T, E> &x, const U &v) {
  return x.has_value() ? *x != v : true;
}
template <class T, class E, class U>
constexpr bool operator!=(const U &v, const expected<T, E> &x) {
  return x.has_value() ? *x != v : true;
}

template <class T, class E>
constexpr bool operator==(const expected<T, E> &x, const unexpected<E> &e) {
  return x.has_value() ? false : x.error() == e.value();
}
template <class T, class E>
constexpr bool operator==(const unexpected<E> &e, const expected<T, E> &x) {
  return x.has_value() ? false : x.error() == e.value();
}
template <class T, class E>
constexpr bool operator!=(const expected<T, E> &x, const unexpected<E> &e) {
  return x.has_value() ? true : x.error() != e.value();
}
template <class T, class E>
constexpr bool operator!=(const unexpected<E> &e, const expected<T, E> &x) {
  return x.has_value() ? true : x.error() != e.value();
}

template <class T, class E,
          detail::enable_if_t<(std::is_void<T>::value ||
                               std::is_move_constructible<T>::value) &&
                              detail::is_swappable<T>::value &&
                              std::is_move_constructible<E>::value &&
                              detail::is_swappable<E>::value> * = nullptr>
void swap(expected<T, E> &lhs,
          expected<T, E> &rhs) noexcept(noexcept(lhs.swap(rhs))) {
  lhs.swap(rhs);
}
}  // namespace tl

#endif
/* end file include/ada/expected.h */

/**
 * @private
 */
namespace ada {
struct url_aggregator;
struct url;
}  // namespace ada

/**
 * @namespace ada::parser
 * @brief Includes the definitions for supported parsers
 */
namespace ada::parser {
/**
 * Parses a url. The parameter user_input is the input to be parsed:
 * it should be a valid UTF-8 string. The parameter base_url is an optional
 * parameter that can be used to resolve relative URLs. If the base_url is
 * provided, the user_input is resolved against the base_url.
 */
template <typename result_type = ada::url_aggregator>
result_type parse_url(std::string_view user_input,
                      const result_type* base_url = nullptr);

extern template url_aggregator parse_url<url_aggregator>(
    std::string_view user_input, const url_aggregator* base_url);
extern template url parse_url<url>(std::string_view user_input,
                                   const url* base_url);

template <typename result_type = ada::url_aggregator, bool store_values = true>
result_type parse_url_impl(std::string_view user_input,
                           const result_type* base_url = nullptr);

extern template url_aggregator parse_url_impl<url_aggregator>(
    std::string_view user_input, const url_aggregator* base_url);
extern template url parse_url_impl<url>(std::string_view user_input,
                                        const url* base_url);
}  // namespace ada::parser

#endif  // ADA_PARSER_H
/* end file include/ada/parser.h */
/* begin file include/ada/scheme-inl.h */
/**
 * @file scheme-inl.h
 * @brief Definitions for the URL scheme.
 */
#ifndef ADA_SCHEME_INL_H
#define ADA_SCHEME_INL_H


namespace ada::scheme {

/**
 * @namespace ada::scheme::details
 * @brief Includes the definitions for scheme specific entities
 */
namespace details {
// for use with is_special and get_special_port
// Spaces, if present, are removed from URL.
constexpr std::string_view is_special_list[] = {"http", " ",   "https", "ws",
                                                "ftp",  "wss", "file",  " "};
// for use with get_special_port
constexpr uint16_t special_ports[] = {80, 0, 443, 80, 21, 443, 0, 0};
}  // namespace details

/****
 * @private
 * In is_special, get_scheme_type, and get_special_port, we
 * use a standard hashing technique to find the index of the scheme in
 * the is_special_list. The hashing technique is based on the size of
 * the scheme and the first character of the scheme. It ensures that we
 * do at most one string comparison per call. If the protocol is
 * predictible (e.g., it is always "http"), we can get a better average
 * performance by using a simpler approach where we loop and compare
 * scheme with all possible protocols starting with the most likely
 * protocol. Doing multiple comparisons may have a poor worst case
 * performance, however. In this instance, we choose a potentially
 * slightly lower best-case performance for a better worst-case
 * performance. We can revisit this choice at any time.
 *
 * Reference:
 * Schmidt, Douglas C. "Gperf: A perfect hash function generator."
 * More C++ gems 17 (2000).
 *
 * Reference: https://en.wikipedia.org/wiki/Perfect_hash_function
 *
 * Reference: https://github.com/ada-url/ada/issues/617
 ****/

ada_really_inline constexpr bool is_special(std::string_view scheme) {
  if (scheme.empty()) {
    return false;
  }
  int hash_value = (2 * scheme.size() + (unsigned)(scheme[0])) & 7;
  const std::string_view target = details::is_special_list[hash_value];
  return (target[0] == scheme[0]) && (target.substr(1) == scheme.substr(1));
}
constexpr uint16_t get_special_port(std::string_view scheme) noexcept {
  if (scheme.empty()) {
    return 0;
  }
  int hash_value = (2 * scheme.size() + (unsigned)(scheme[0])) & 7;
  const std::string_view target = details::is_special_list[hash_value];
  if ((target[0] == scheme[0]) && (target.substr(1) == scheme.substr(1))) {
    return details::special_ports[hash_value];
  } else {
    return 0;
  }
}
constexpr uint16_t get_special_port(ada::scheme::type type) noexcept {
  return details::special_ports[int(type)];
}
constexpr ada::scheme::type get_scheme_type(std::string_view scheme) noexcept {
  if (scheme.empty()) {
    return ada::scheme::NOT_SPECIAL;
  }
  int hash_value = (2 * scheme.size() + (unsigned)(scheme[0])) & 7;
  const std::string_view target = details::is_special_list[hash_value];
  if ((target[0] == scheme[0]) && (target.substr(1) == scheme.substr(1))) {
    return ada::scheme::type(hash_value);
  } else {
    return ada::scheme::NOT_SPECIAL;
  }
}

}  // namespace ada::scheme

#endif  // ADA_SCHEME_INL_H
/* end file include/ada/scheme-inl.h */
/* begin file include/ada/serializers.h */
/**
 * @file serializers.h
 * @brief Definitions for the URL serializers.
 */
#ifndef ADA_SERIALIZERS_H
#define ADA_SERIALIZERS_H


#include <array>
#include <optional>
#include <string>

/**
 * @namespace ada::serializers
 * @brief Includes the definitions for URL serializers
 */
namespace ada::serializers {

/**
 * Finds and returns the longest sequence of 0 values in a ipv6 input.
 */
void find_longest_sequence_of_ipv6_pieces(
    const std::array<uint16_t, 8>& address, size_t& compress,
    size_t& compress_length) noexcept;

/**
 * Serializes an ipv6 address.
 * @details An IPv6 address is a 128-bit unsigned integer that identifies a
 * network address.
 * @see https://url.spec.whatwg.org/#concept-ipv6-serializer
 */
std::string ipv6(const std::array<uint16_t, 8>& address) noexcept;

/**
 * Serializes an ipv4 address.
 * @details An IPv4 address is a 32-bit unsigned integer that identifies a
 * network address.
 * @see https://url.spec.whatwg.org/#concept-ipv4-serializer
 */
std::string ipv4(uint64_t address) noexcept;

}  // namespace ada::serializers

#endif  // ADA_SERIALIZERS_H
/* end file include/ada/serializers.h */
/* begin file include/ada/unicode.h */
/**
 * @file unicode.h
 * @brief Definitions for all unicode specific functions.
 */
#ifndef ADA_UNICODE_H
#define ADA_UNICODE_H


#include <string>
#include <optional>

/**
 * Unicode operations. These functions are not part of our public API and may
 * change at any time.
 *
 * @private
 * @namespace ada::unicode
 * @brief Includes the definitions for unicode operations
 */
namespace ada::unicode {

/**
 * @private
 * We receive a UTF-8 string representing a domain name.
 * If the string is percent encoded, we apply percent decoding.
 *
 * Given a domain, we need to identify its labels.
 * They are separated by label-separators:
 *
 * U+002E (.) FULL STOP
 * U+FF0E FULLWIDTH FULL STOP
 * U+3002 IDEOGRAPHIC FULL STOP
 * U+FF61 HALFWIDTH IDEOGRAPHIC FULL STOP
 *
 * They are all mapped to U+002E.
 *
 * We process each label into a string that should not exceed 63 octets.
 * If the string is already punycode (starts with "xn--"), then we must
 * scan it to look for unallowed code points.
 * Otherwise, if the string is not pure ASCII, we need to transcode it
 * to punycode by following RFC 3454 which requires us to
 * - Map characters  (see section 3),
 * - Normalize (see section 4),
 * - Reject forbidden characters,
 * - Check for right-to-left characters and if so, check all requirements (see
 * section 6),
 * - Optionally reject based on unassigned code points (section 7).
 *
 * The Unicode standard provides a table of code points with a mapping, a list
 * of forbidden code points and so forth. This table is subject to change and
 * will vary based on the implementation. For Unicode 15, the table is at
 * https://www.unicode.org/Public/idna/15.0.0/IdnaMappingTable.txt
 * If you use ICU, they parse this table and map it to code using a Python
 * script.
 *
 * The resulting strings should not exceed 255 octets according to RFC 1035
 * section 2.3.4. ICU checks for label size and domain size, but these errors
 * are ignored.
 *
 * @see https://url.spec.whatwg.org/#concept-domain-to-ascii
 *
 */
bool to_ascii(std::optional<std::string>& out, std::string_view plain,
              size_t first_percent);

/**
 * @private
 * Checks if the input has tab or newline characters.
 *
 * @attention The has_tabs_or_newline function is a bottleneck and it is simple
 * enough that compilers like GCC can 'autovectorize it'.
 */
ada_really_inline bool has_tabs_or_newline(
    std::string_view user_input) noexcept;

/**
 * @private
 * Checks if the input is a forbidden host code point.
 * @see https://url.spec.whatwg.org/#forbidden-host-code-point
 */
ada_really_inline constexpr bool is_forbidden_host_code_point(char c) noexcept;

/**
 * @private
 * Checks if the input contains a forbidden domain code point.
 * @see https://url.spec.whatwg.org/#forbidden-domain-code-point
 */
ada_really_inline constexpr bool contains_forbidden_domain_code_point(
    const char* input, size_t length) noexcept;

/**
 * @private
 * Checks if the input contains a forbidden domain code point in which case
 * the first bit is set to 1. If the input contains an upper case ASCII letter,
 * then the second bit is set to 1.
 * @see https://url.spec.whatwg.org/#forbidden-domain-code-point
 */
ada_really_inline constexpr uint8_t
contains_forbidden_domain_code_point_or_upper(const char* input,
                                              size_t length) noexcept;

/**
 * @private
 * Checks if the input is a forbidden domain code point.
 * @see https://url.spec.whatwg.org/#forbidden-domain-code-point
 */
ada_really_inline constexpr bool is_forbidden_domain_code_point(
    char c) noexcept;

/**
 * @private
 * Checks if the input is alphanumeric, '+', '-' or '.'
 */
ada_really_inline constexpr bool is_alnum_plus(char c) noexcept;

/**
 * @private
 * @details An ASCII hex digit is an ASCII upper hex digit or ASCII lower hex
 * digit. An ASCII upper hex digit is an ASCII digit or a code point in the
 * range U+0041 (A) to U+0046 (F), inclusive. An ASCII lower hex digit is an
 * ASCII digit or a code point in the range U+0061 (a) to U+0066 (f), inclusive.
 */
ada_really_inline constexpr bool is_ascii_hex_digit(char c) noexcept;

/**
 * @private
 * Checks if the input is a C0 control or space character.
 *
 * @details A C0 control or space is a C0 control or U+0020 SPACE.
 * A C0 control is a code point in the range U+0000 NULL to U+001F INFORMATION
 * SEPARATOR ONE, inclusive.
 */
ada_really_inline constexpr bool is_c0_control_or_space(char c) noexcept;

/**
 * @private
 * Checks if the input is a ASCII tab or newline character.
 *
 * @details An ASCII tab or newline is U+0009 TAB, U+000A LF, or U+000D CR.
 */
ada_really_inline constexpr bool is_ascii_tab_or_newline(char c) noexcept;

/**
 * @private
 * @details A double-dot path segment must be ".." or an ASCII case-insensitive
 * match for ".%2e", "%2e.", or "%2e%2e".
 */
ada_really_inline ada_constexpr bool is_double_dot_path_segment(
    std::string_view input) noexcept;

/**
 * @private
 * @details A single-dot path segment must be "." or an ASCII case-insensitive
 * match for "%2e".
 */
ada_really_inline constexpr bool is_single_dot_path_segment(
    std::string_view input) noexcept;

/**
 * @private
 * @details ipv4 character might contain 0-9 or a-f character ranges.
 */
ada_really_inline constexpr bool is_lowercase_hex(char c) noexcept;

/**
 * @private
 * @details Convert hex to binary. Caller is responsible to ensure that
 * the parameter is an hexadecimal digit (0-9, A-F, a-f).
 */
ada_really_inline unsigned constexpr convert_hex_to_binary(char c) noexcept;

/**
 * @private
 * first_percent should be  = input.find('%')
 *
 * @todo It would be faster as noexcept maybe, but it could be unsafe since.
 * @author Node.js
 * @see https://github.com/nodejs/node/blob/main/src/node_url.cc#L245
 * @see https://encoding.spec.whatwg.org/#utf-8-decode-without-bom
 */
std::string percent_decode(std::string_view input, size_t first_percent);

/**
 * @private
 * Returns a percent-encoding string whether percent encoding was needed or not.
 * @see https://github.com/nodejs/node/blob/main/src/node_url.cc#L226
 */
std::string percent_encode(std::string_view input,
                           const uint8_t character_set[]);
/**
 * @private
 * Returns a percent-encoded string version of input, while starting the percent
 * encoding at the provided index.
 * @see https://github.com/nodejs/node/blob/main/src/node_url.cc#L226
 */
std::string percent_encode(std::string_view input,
                           const uint8_t character_set[], size_t index);
/**
 * @private
 * Returns true if percent encoding was needed, in which case, we store
 * the percent-encoded content in 'out'. If the boolean 'append' is set to
 * true, the content is appended to 'out'.
 * If percent encoding is not needed, out is left unchanged.
 * @see https://github.com/nodejs/node/blob/main/src/node_url.cc#L226
 */
template <bool append>
bool percent_encode(std::string_view input, const uint8_t character_set[],
                    std::string& out);
/**
 * @private
 * Returns the index at which percent encoding should start, or (equivalently),
 * the length of the prefix that does not require percent encoding.
 */
ada_really_inline size_t percent_encode_index(std::string_view input,
                                              const uint8_t character_set[]);
/**
 * @private
 * Lowers the string in-place, assuming that the content is ASCII.
 * Return true if the content was ASCII.
 */
constexpr bool to_lower_ascii(char* input, size_t length) noexcept;
}  // namespace ada::unicode

#endif  // ADA_UNICODE_H
/* end file include/ada/unicode.h */
/* begin file include/ada/url_base-inl.h */
/**
 * @file url_base-inl.h
 * @brief Inline functions for url base
 */
#ifndef ADA_URL_BASE_INL_H
#define ADA_URL_BASE_INL_H

/* begin file include/ada/url_aggregator.h */
/**
 * @file url_aggregator.h
 * @brief Declaration for the basic URL definitions
 */
#ifndef ADA_URL_AGGREGATOR_H
#define ADA_URL_AGGREGATOR_H

#include <string>
#include <string_view>


namespace ada {

/**
 * @brief Lightweight URL struct.
 *
 * @details The url_aggregator class aims to minimize temporary memory
 * allocation while representing a parsed URL. Internally, it contains a single
 * normalized URL (the href), and it makes available the components, mostly
 * using std::string_view.
 */
struct url_aggregator : url_base {
  url_aggregator() = default;
  url_aggregator(const url_aggregator &u) = default;
  url_aggregator(url_aggregator &&u) noexcept = default;
  url_aggregator &operator=(url_aggregator &&u) noexcept = default;
  url_aggregator &operator=(const url_aggregator &u) = default;
  ~url_aggregator() override = default;

  bool set_href(std::string_view input);
  bool set_host(std::string_view input);
  bool set_hostname(std::string_view input);
  bool set_protocol(std::string_view input);
  bool set_username(std::string_view input);
  bool set_password(std::string_view input);
  bool set_port(std::string_view input);
  bool set_pathname(std::string_view input);
  void set_search(std::string_view input);
  void set_hash(std::string_view input);

  [[nodiscard]] bool has_valid_domain() const noexcept override;
  /**
   * The origin getter steps are to return the serialization of this's URL's
   * origin. [HTML]
   * @return a newly allocated string.
   * @see https://url.spec.whatwg.org/#concept-url-origin
   */
  [[nodiscard]] std::string get_origin() const noexcept override;
  /**
   * Return the normalized string.
   * This function does not allocate memory.
   * It is highly efficient.
   * @return a constant reference to the underlying normalized URL.
   * @see https://url.spec.whatwg.org/#dom-url-href
   * @see https://url.spec.whatwg.org/#concept-url-serializer
   */
  [[nodiscard]] inline std::string_view get_href() const noexcept
      ada_lifetime_bound;
  /**
   * The username getter steps are to return this's URL's username.
   * This function does not allocate memory.
   * @return a lightweight std::string_view.
   * @see https://url.spec.whatwg.org/#dom-url-username
   */
  [[nodiscard]] std::string_view get_username() const noexcept
      ada_lifetime_bound;
  /**
   * The password getter steps are to return this's URL's password.
   * This function does not allocate memory.
   * @return a lightweight std::string_view.
   * @see https://url.spec.whatwg.org/#dom-url-password
   */
  [[nodiscard]] std::string_view get_password() const noexcept
      ada_lifetime_bound;
  /**
   * Return this's URL's port, serialized.
   * This function does not allocate memory.
   * @return a lightweight std::string_view.
   * @see https://url.spec.whatwg.org/#dom-url-port
   */
  [[nodiscard]] std::string_view get_port() const noexcept ada_lifetime_bound;
  /**
   * Return U+0023 (#), followed by this's URL's fragment.
   * This function does not allocate memory.
   * @return a lightweight std::string_view..
   * @see https://url.spec.whatwg.org/#dom-url-hash
   */
  [[nodiscard]] std::string_view get_hash() const noexcept ada_lifetime_bound;
  /**
   * Return url's host, serialized, followed by U+003A (:) and url's port,
   * serialized.
   * This function does not allocate memory.
   * When there is no host, this function returns the empty view.
   * @return a lightweight std::string_view.
   * @see https://url.spec.whatwg.org/#dom-url-host
   */
  [[nodiscard]] std::string_view get_host() const noexcept ada_lifetime_bound;
  /**
   * Return this's URL's host, serialized.
   * This function does not allocate memory.
   * When there is no host, this function returns the empty view.
   * @return a lightweight std::string_view.
   * @see https://url.spec.whatwg.org/#dom-url-hostname
   */
  [[nodiscard]] std::string_view get_hostname() const noexcept
      ada_lifetime_bound;
  /**
   * The pathname getter steps are to return the result of URL path serializing
   * this's URL.
   * This function does not allocate memory.
   * @return a lightweight std::string_view.
   * @see https://url.spec.whatwg.org/#dom-url-pathname
   */
  [[nodiscard]] std::string_view get_pathname() const noexcept
      ada_lifetime_bound;
  /**
   * Compute the pathname length in bytes without instantiating a view or a
   * string.
   * @return size of the pathname in bytes
   * @see https://url.spec.whatwg.org/#dom-url-pathname
   */
  [[nodiscard]] ada_really_inline uint32_t get_pathname_length() const noexcept;
  /**
   * Return U+003F (?), followed by this's URL's query.
   * This function does not allocate memory.
   * @return a lightweight std::string_view.
   * @see https://url.spec.whatwg.org/#dom-url-search
   */
  [[nodiscard]] std::string_view get_search() const noexcept ada_lifetime_bound;
  /**
   * The protocol getter steps are to return this's URL's scheme, followed by
   * U+003A (:).
   * This function does not allocate memory.
   * @return a lightweight std::string_view.
   * @see https://url.spec.whatwg.org/#dom-url-protocol
   */
  [[nodiscard]] std::string_view get_protocol() const noexcept
      ada_lifetime_bound;

  /**
   * A URL includes credentials if its username or password is not the empty
   * string.
   */
  [[nodiscard]] ada_really_inline bool has_credentials() const noexcept;

  /**
   * Useful for implementing efficient serialization for the URL.
   *
   * https://user:pass@example.com:1234/foo/bar?baz#quux
   *       |     |    |          | ^^^^|       |   |
   *       |     |    |          | |   |       |   `----- hash_start
   *       |     |    |          | |   |       `--------- search_start
   *       |     |    |          | |   `----------------- pathname_start
   *       |     |    |          | `--------------------- port
   *       |     |    |          `----------------------- host_end
   *       |     |    `---------------------------------- host_start
   *       |     `--------------------------------------- username_end
   *       `--------------------------------------------- protocol_end
   *
   * Inspired after servo/url
   *
   * @return a constant reference to the underlying component attribute.
   *
   * @see
   * https://github.com/servo/rust-url/blob/b65a45515c10713f6d212e6726719a020203cc98/url/src/quirks.rs#L31
   */
  [[nodiscard]] ada_really_inline const ada::url_components &get_components()
      const noexcept;
  /**
   * Returns a string representation of this URL.
   */
  [[nodiscard]] std::string to_string() const override;
  /**
   * Returns a string diagram of this URL.
   */
  [[nodiscard]] std::string to_diagram() const;

  /**
   * Verifies that the parsed URL could be valid. Useful for debugging purposes.
   * @return true if the URL is valid, otherwise return true of the offsets are
   * possible.
   */
  [[nodiscard]] bool validate() const noexcept;

  /** @return true if it has an host but it is the empty string */
  [[nodiscard]] inline bool has_empty_hostname() const noexcept;
  /** @return true if it has a host (included an empty host) */
  [[nodiscard]] inline bool has_hostname() const noexcept;
  /** @return true if the URL has a non-empty username */
  [[nodiscard]] inline bool has_non_empty_username() const noexcept;
  /** @return true if the URL has a non-empty password */
  [[nodiscard]] inline bool has_non_empty_password() const noexcept;
  /** @return true if the URL has a (non default) port */
  [[nodiscard]] inline bool has_port() const noexcept;
  /** @return true if the URL has a password */
  [[nodiscard]] inline bool has_password() const noexcept;
  /** @return true if the URL has a hash component */
  [[nodiscard]] inline bool has_hash() const noexcept override;
  /** @return true if the URL has a search component */
  [[nodiscard]] inline bool has_search() const noexcept override;

  inline void clear_port();
  inline void clear_hash();
  inline void clear_search() override;

 private:
  friend ada::url_aggregator ada::parser::parse_url<ada::url_aggregator>(
      std::string_view, const ada::url_aggregator *);
  friend void ada::helpers::strip_trailing_spaces_from_opaque_path<
      ada::url_aggregator>(ada::url_aggregator &url) noexcept;
  friend ada::url_aggregator ada::parser::parse_url_impl<
      ada::url_aggregator, true>(std::string_view, const ada::url_aggregator *);
  friend ada::url_aggregator
  ada::parser::parse_url_impl<ada::url_aggregator, false>(
      std::string_view, const ada::url_aggregator *);

  std::string buffer{};
  url_components components{};

  /**
   * Returns true if neither the search, nor the hash nor the pathname
   * have been set.
   * @return true if the buffer is ready to receive the path.
   */
  [[nodiscard]] ada_really_inline bool is_at_path() const noexcept;

  inline void add_authority_slashes_if_needed() noexcept;

  /**
   * To optimize performance, you may indicate how much memory to allocate
   * within this instance.
   */
  inline void reserve(uint32_t capacity);

  ada_really_inline size_t parse_port(
      std::string_view view, bool check_trailing_content) noexcept override;

  ada_really_inline size_t parse_port(std::string_view view) noexcept override {
    return this->parse_port(view, false);
  }

  /**
   * Return true on success. The 'in_place' parameter indicates whether the
   * the string_view input is pointing in the buffer. When in_place is false,
   * we must nearly always update the buffer.
   * @see https://url.spec.whatwg.org/#concept-ipv4-parser
   */
  [[nodiscard]] bool parse_ipv4(std::string_view input, bool in_place);

  /**
   * Return true on success.
   * @see https://url.spec.whatwg.org/#concept-ipv6-parser
   */
  [[nodiscard]] bool parse_ipv6(std::string_view input);

  /**
   * Return true on success.
   * @see https://url.spec.whatwg.org/#concept-opaque-host-parser
   */
  [[nodiscard]] bool parse_opaque_host(std::string_view input);

  ada_really_inline void parse_path(std::string_view input);

  /**
   * A URL cannot have a username/password/port if its host is null or the empty
   * string, or its scheme is "file".
   */
  [[nodiscard]] inline bool cannot_have_credentials_or_port() const;

  template <bool override_hostname = false>
  bool set_host_or_hostname(std::string_view input);

  ada_really_inline bool parse_host(std::string_view input);

  inline void update_base_authority(std::string_view base_buffer,
                                    const ada::url_components &base);
  inline void update_unencoded_base_hash(std::string_view input);
  inline void update_base_hostname(std::string_view input);
  inline void update_base_search(std::string_view input);
  inline void update_base_search(std::string_view input,
                                 const uint8_t *query_percent_encode_set);
  inline void update_base_pathname(std::string_view input);
  inline void update_base_username(std::string_view input);
  inline void append_base_username(std::string_view input);
  inline void update_base_password(std::string_view input);
  inline void append_base_password(std::string_view input);
  inline void update_base_port(uint32_t input);
  inline void append_base_pathname(std::string_view input);
  [[nodiscard]] inline uint32_t retrieve_base_port() const;
  inline void clear_hostname();
  inline void clear_password();
  inline void clear_pathname() override;
  [[nodiscard]] inline bool has_dash_dot() const noexcept;
  void delete_dash_dot();
  inline void consume_prepared_path(std::string_view input);
  template <bool has_state_override = false>
  [[nodiscard]] ada_really_inline bool parse_scheme_with_colon(
      std::string_view input);
  ada_really_inline uint32_t replace_and_resize(uint32_t start, uint32_t end,
                                                std::string_view input);
  [[nodiscard]] inline bool has_authority() const noexcept;
  inline void set_protocol_as_file();
  inline void set_scheme(std::string_view new_scheme) noexcept;
  /**
   * Fast function to set the scheme from a view with a colon in the
   * buffer, does not change type.
   */
  inline void set_scheme_from_view_with_colon(
      std::string_view new_scheme_with_colon) noexcept;
  inline void copy_scheme(const url_aggregator &u) noexcept;

};  // url_aggregator

inline std::ostream &operator<<(std::ostream &out, const ada::url &u);
}  // namespace ada

#endif
/* end file include/ada/url_aggregator.h */
/* begin file include/ada/checkers.h */
/**
 * @file checkers.h
 * @brief Declarations for URL specific checkers used within Ada.
 */
#ifndef ADA_CHECKERS_H
#define ADA_CHECKERS_H


#include <string_view>
#include <cstring>

/**
 * These functions are not part of our public API and may
 * change at any time.
 * @private
 * @namespace ada::checkers
 * @brief Includes the definitions for validation functions
 */
namespace ada::checkers {

/**
 * @private
 * Assuming that x is an ASCII letter, this function returns the lower case
 * equivalent.
 * @details More likely to be inlined by the compiler and constexpr.
 */
constexpr char to_lower(char x) noexcept;

/**
 * @private
 * Returns true if the character is an ASCII letter. Equivalent to std::isalpha
 * but more likely to be inlined by the compiler.
 *
 * @attention std::isalpha is not constexpr generally.
 */
constexpr bool is_alpha(char x) noexcept;

/**
 * @private
 * Check whether a string starts with 0x or 0X. The function is only
 * safe if input.size() >=2.
 *
 * @see has_hex_prefix
 */
inline bool has_hex_prefix_unsafe(std::string_view input);
/**
 * @private
 * Check whether a string starts with 0x or 0X.
 */
inline bool has_hex_prefix(std::string_view input);

/**
 * @private
 * Check whether x is an ASCII digit. More likely to be inlined than
 * std::isdigit.
 */
constexpr bool is_digit(char x) noexcept;

/**
 * @private
 * @details A string starts with a Windows drive letter if all of the following
 * are true:
 *
 *   - its length is greater than or equal to 2
 *   - its first two code points are a Windows drive letter
 *   - its length is 2 or its third code point is U+002F (/), U+005C (\), U+003F
 * (?), or U+0023 (#).
 *
 * https://url.spec.whatwg.org/#start-with-a-windows-drive-letter
 */
inline constexpr bool is_windows_drive_letter(std::string_view input) noexcept;

/**
 * @private
 * @details A normalized Windows drive letter is a Windows drive letter of which
 * the second code point is U+003A (:).
 */
inline constexpr bool is_normalized_windows_drive_letter(
    std::string_view input) noexcept;

/**
 * @private
 * @warning Will be removed when Ada requires C++20.
 */
ada_really_inline bool begins_with(std::string_view view,
                                   std::string_view prefix);

/**
 * @private
 * Returns true if an input is an ipv4 address. It is assumed that the string
 * does not contain uppercase ASCII characters (the input should have been
 * lowered cased before calling this function) and is not empty.
 */
ada_really_inline ada_constexpr bool is_ipv4(std::string_view view) noexcept;

/**
 * @private
 * Returns a bitset. If the first bit is set, then at least one character needs
 * percent encoding. If the second bit is set, a \\ is found. If the third bit
 * is set then we have a dot. If the fourth bit is set, then we have a percent
 * character.
 */
ada_really_inline constexpr uint8_t path_signature(
    std::string_view input) noexcept;

/**
 * @private
 * Returns true if the length of the domain name and its labels are according to
 * the specifications. The length of the domain must be 255 octets (253
 * characters not including the last 2 which are the empty label reserved at the
 * end). When the empty label is included (a dot at the end), the domain name
 * can have 254 characters. The length of a label must be at least 1 and at most
 * 63 characters.
 * @see section 3.1. of https://www.rfc-editor.org/rfc/rfc1034
 * @see https://www.unicode.org/reports/tr46/#ToASCII
 */
ada_really_inline constexpr bool verify_dns_length(
    std::string_view input) noexcept;

}  // namespace ada::checkers

#endif  // ADA_CHECKERS_H
/* end file include/ada/checkers.h */
/* begin file include/ada/url.h */
/**
 * @file url.h
 * @brief Declaration for the URL
 */
#ifndef ADA_URL_H
#define ADA_URL_H

#include <algorithm>
#include <charconv>
#include <iostream>
#include <optional>
#include <string>
#include <string_view>


namespace ada {

/**
 * @brief Generic URL struct reliant on std::string instantiation.
 *
 * @details To disambiguate from a valid URL string it can also be referred to
 * as a URL record. A URL is a struct that represents a universal identifier.
 * Unlike the url_aggregator, the ada::url represents the different components
 * of a parsed URL as independent std::string instances. This makes the
 * structure heavier and more reliant on memory allocations. When getting
 * components from the parsed URL, a new std::string is typically constructed.
 *
 * @see https://url.spec.whatwg.org/#url-representation
 */
struct url : url_base {
  url() = default;
  url(const url &u) = default;
  url(url &&u) noexcept = default;
  url &operator=(url &&u) noexcept = default;
  url &operator=(const url &u) = default;
  ~url() override = default;

  /**
   * @private
   * A URL's username is an ASCII string identifying a username. It is initially
   * the empty string.
   */
  std::string username{};

  /**
   * @private
   * A URL's password is an ASCII string identifying a password. It is initially
   * the empty string.
   */
  std::string password{};

  /**
   * @private
   * A URL's host is null or a host. It is initially null.
   */
  std::optional<std::string> host{};

  /**
   * @private
   * A URL's port is either null or a 16-bit unsigned integer that identifies a
   * networking port. It is initially null.
   */
  std::optional<uint16_t> port{};

  /**
   * @private
   * A URL's path is either an ASCII string or a list of zero or more ASCII
   * strings, usually identifying a location.
   */
  std::string path{};

  /**
   * @private
   * A URL's query is either null or an ASCII string. It is initially null.
   */
  std::optional<std::string> query{};

  /**
   * @private
   * A URL's fragment is either null or an ASCII string that can be used for
   * further processing on the resource the URL's other components identify. It
   * is initially null.
   */
  std::optional<std::string> hash{};

  /** @return true if it has an host but it is the empty string */
  [[nodiscard]] inline bool has_empty_hostname() const noexcept;
  /** @return true if the URL has a (non default) port */
  [[nodiscard]] inline bool has_port() const noexcept;
  /** @return true if it has a host (included an empty host) */
  [[nodiscard]] inline bool has_hostname() const noexcept;
  [[nodiscard]] bool has_valid_domain() const noexcept override;

  /**
   * Returns a JSON string representation of this URL.
   */
  [[nodiscard]] std::string to_string() const override;

  /**
   * @see https://url.spec.whatwg.org/#dom-url-href
   * @see https://url.spec.whatwg.org/#concept-url-serializer
   */
  [[nodiscard]] ada_really_inline std::string get_href() const noexcept;

  /**
   * The origin getter steps are to return the serialization of this's URL's
   * origin. [HTML]
   * @return a newly allocated string.
   * @see https://url.spec.whatwg.org/#concept-url-origin
   */
  [[nodiscard]] std::string get_origin() const noexcept override;

  /**
   * The protocol getter steps are to return this's URL's scheme, followed by
   * U+003A (:).
   * @return a newly allocated string.
   * @see https://url.spec.whatwg.org/#dom-url-protocol
   */
  [[nodiscard]] std::string get_protocol() const noexcept;

  /**
   * Return url's host, serialized, followed by U+003A (:) and url's port,
   * serialized.
   * When there is no host, this function returns the empty string.
   * @return a newly allocated string.
   * @see https://url.spec.whatwg.org/#dom-url-host
   */
  [[nodiscard]] std::string get_host() const noexcept;

  /**
   * Return this's URL's host, serialized.
   * When there is no host, this function returns the empty string.
   * @return a newly allocated string.
   * @see https://url.spec.whatwg.org/#dom-url-hostname
   */
  [[nodiscard]] std::string get_hostname() const noexcept;

  /**
   * The pathname getter steps are to return the result of URL path serializing
   * this's URL.
   * @return a newly allocated string.
   * @see https://url.spec.whatwg.org/#dom-url-pathname
   */
  [[nodiscard]] std::string_view get_pathname() const noexcept;

  /**
   * Compute the pathname length in bytes without instantiating a view or a
   * string.
   * @return size of the pathname in bytes
   * @see https://url.spec.whatwg.org/#dom-url-pathname
   */
  [[nodiscard]] ada_really_inline size_t get_pathname_length() const noexcept;

  /**
   * Return U+003F (?), followed by this's URL's query.
   * @return a newly allocated string.
   * @see https://url.spec.whatwg.org/#dom-url-search
   */
  [[nodiscard]] std::string get_search() const noexcept;

  /**
   * The username getter steps are to return this's URL's username.
   * @return a constant reference to the underlying string.
   * @see https://url.spec.whatwg.org/#dom-url-username
   */
  [[nodiscard]] const std::string &get_username() const noexcept;

  /**
   * @return Returns true on successful operation.
   * @see https://url.spec.whatwg.org/#dom-url-username
   */
  bool set_username(std::string_view input);

  /**
   * @return Returns true on success.
   * @see https://url.spec.whatwg.org/#dom-url-password
   */
  bool set_password(std::string_view input);

  /**
   * @return Returns true on success.
   * @see https://url.spec.whatwg.org/#dom-url-port
   */
  bool set_port(std::string_view input);

  /**
   * This function always succeeds.
   * @see https://url.spec.whatwg.org/#dom-url-hash
   */
  void set_hash(std::string_view input);

  /**
   * This function always succeeds.
   * @see https://url.spec.whatwg.org/#dom-url-search
   */
  void set_search(std::string_view input);

  /**
   * @return Returns true on success.
   * @see https://url.spec.whatwg.org/#dom-url-search
   */
  bool set_pathname(std::string_view input);

  /**
   * @return Returns true on success.
   * @see https://url.spec.whatwg.org/#dom-url-host
   */
  bool set_host(std::string_view input);

  /**
   * @return Returns true on success.
   * @see https://url.spec.whatwg.org/#dom-url-hostname
   */
  bool set_hostname(std::string_view input);

  /**
   * @return Returns true on success.
   * @see https://url.spec.whatwg.org/#dom-url-protocol
   */
  bool set_protocol(std::string_view input);

  /**
   * @see https://url.spec.whatwg.org/#dom-url-href
   */
  bool set_href(std::string_view input);

  /**
   * The password getter steps are to return this's URL's password.
   * @return a constant reference to the underlying string.
   * @see https://url.spec.whatwg.org/#dom-url-password
   */
  [[nodiscard]] const std::string &get_password() const noexcept;

  /**
   * Return this's URL's port, serialized.
   * @return a newly constructed string representing the port.
   * @see https://url.spec.whatwg.org/#dom-url-port
   */
  [[nodiscard]] std::string get_port() const noexcept;

  /**
   * Return U+0023 (#), followed by this's URL's fragment.
   * @return a newly constructed string representing the hash.
   * @see https://url.spec.whatwg.org/#dom-url-hash
   */
  [[nodiscard]] std::string get_hash() const noexcept;

  /**
   * A URL includes credentials if its username or password is not the empty
   * string.
   */
  [[nodiscard]] ada_really_inline bool has_credentials() const noexcept;

  /**
   * Useful for implementing efficient serialization for the URL.
   *
   * https://user:pass@example.com:1234/foo/bar?baz#quux
   *       |     |    |          | ^^^^|       |   |
   *       |     |    |          | |   |       |   `----- hash_start
   *       |     |    |          | |   |       `--------- search_start
   *       |     |    |          | |   `----------------- pathname_start
   *       |     |    |          | `--------------------- port
   *       |     |    |          `----------------------- host_end
   *       |     |    `---------------------------------- host_start
   *       |     `--------------------------------------- username_end
   *       `--------------------------------------------- protocol_end
   *
   * Inspired after servo/url
   *
   * @return a newly constructed component.
   *
   * @see
   * https://github.com/servo/rust-url/blob/b65a45515c10713f6d212e6726719a020203cc98/url/src/quirks.rs#L31
   */
  [[nodiscard]] ada_really_inline ada::url_components get_components()
      const noexcept;
  /** @return true if the URL has a hash component */
  [[nodiscard]] inline bool has_hash() const noexcept override;
  /** @return true if the URL has a search component */
  [[nodiscard]] inline bool has_search() const noexcept override;

 private:
  friend ada::url ada::parser::parse_url<ada::url>(std::string_view,
                                                   const ada::url *);
  friend ada::url_aggregator ada::parser::parse_url<ada::url_aggregator>(
      std::string_view, const ada::url_aggregator *);
  friend void ada::helpers::strip_trailing_spaces_from_opaque_path<ada::url>(
      ada::url &url) noexcept;

  friend ada::url ada::parser::parse_url_impl<ada::url, true>(std::string_view,
                                                              const ada::url *);
  friend ada::url_aggregator ada::parser::parse_url_impl<
      ada::url_aggregator, true>(std::string_view, const ada::url_aggregator *);

  inline void update_unencoded_base_hash(std::string_view input);
  inline void update_base_hostname(std::string_view input);
  inline void update_base_search(std::string_view input);
  inline void update_base_search(std::string_view input,
                                 const uint8_t query_percent_encode_set[]);
  inline void update_base_search(std::optional<std::string> input);
  inline void update_base_pathname(std::string_view input);
  inline void update_base_username(std::string_view input);
  inline void update_base_password(std::string_view input);
  inline void update_base_port(std::optional<uint16_t> input);

  /**
   * Sets the host or hostname according to override condition.
   * Return true on success.
   * @see https://url.spec.whatwg.org/#hostname-state
   */
  template <bool override_hostname = false>
  bool set_host_or_hostname(std::string_view input);

  /**
   * Return true on success.
   * @see https://url.spec.whatwg.org/#concept-ipv4-parser
   */
  [[nodiscard]] bool parse_ipv4(std::string_view input);

  /**
   * Return true on success.
   * @see https://url.spec.whatwg.org/#concept-ipv6-parser
   */
  [[nodiscard]] bool parse_ipv6(std::string_view input);

  /**
   * Return true on success.
   * @see https://url.spec.whatwg.org/#concept-opaque-host-parser
   */
  [[nodiscard]] bool parse_opaque_host(std::string_view input);

  /**
   * A URL's scheme is an ASCII string that identifies the type of URL and can
   * be used to dispatch a URL for further processing after parsing. It is
   * initially the empty string. We only set non_special_scheme when the scheme
   * is non-special, otherwise we avoid constructing string.
   *
   * Special schemes are stored in ada::scheme::details::is_special_list so we
   * typically do not need to store them in each url instance.
   */
  std::string non_special_scheme{};

  /**
   * A URL cannot have a username/password/port if its host is null or the empty
   * string, or its scheme is "file".
   */
  [[nodiscard]] inline bool cannot_have_credentials_or_port() const;

  ada_really_inline size_t parse_port(
      std::string_view view, bool check_trailing_content) noexcept override;

  ada_really_inline size_t parse_port(std::string_view view) noexcept override {
    return this->parse_port(view, false);
  }

  /**
   * Take the scheme from another URL. The scheme string is copied from the
   * provided url.
   */
  inline void copy_scheme(const ada::url &u);

  /**
   * Parse the host from the provided input. We assume that
   * the input does not contain spaces or tabs. Control
   * characters and spaces are not trimmed (they should have
   * been removed if needed).
   * Return true on success.
   * @see https://url.spec.whatwg.org/#host-parsing
   */
  [[nodiscard]] ada_really_inline bool parse_host(std::string_view input);

  template <bool has_state_override = false>
  [[nodiscard]] ada_really_inline bool parse_scheme(std::string_view input);

  inline void clear_pathname() override;
  inline void clear_search() override;
  inline void set_protocol_as_file();

  /**
   * Parse the path from the provided input.
   * Return true on success. Control characters not
   * trimmed from the ends (they should have
   * been removed if needed).
   *
   * The input is expected to be UTF-8.
   *
   * @see https://url.spec.whatwg.org/
   */
  ada_really_inline void parse_path(std::string_view input);

  /**
   * Set the scheme for this URL. The provided scheme should be a valid
   * scheme string, be lower-cased, not contain spaces or tabs. It should
   * have no spurious trailing or leading content.
   */
  inline void set_scheme(std::string &&new_scheme) noexcept;

  /**
   * Take the scheme from another URL. The scheme string is moved from the
   * provided url.
   */
  inline void copy_scheme(ada::url &&u) noexcept;

};  // struct url

inline std::ostream &operator<<(std::ostream &out, const ada::url &u);
}  // namespace ada

#endif  // ADA_URL_H
/* end file include/ada/url.h */

#include <optional>
#include <string>
#if ADA_REGULAR_VISUAL_STUDIO
#include <intrin.h>
#endif  // ADA_REGULAR_VISUAL_STUDIO

namespace ada {

[[nodiscard]] ada_really_inline bool url_base::is_special() const noexcept {
  return type != ada::scheme::NOT_SPECIAL;
}

[[nodiscard]] inline uint16_t url_base::get_special_port() const noexcept {
  return ada::scheme::get_special_port(type);
}

[[nodiscard]] ada_really_inline uint16_t
url_base::scheme_default_port() const noexcept {
  return scheme::get_special_port(type);
}

}  // namespace ada

#endif  // ADA_URL_BASE_INL_H
/* end file include/ada/url_base-inl.h */
/* begin file include/ada/url-inl.h */
/**
 * @file url-inl.h
 * @brief Definitions for the URL
 */
#ifndef ADA_URL_INL_H
#define ADA_URL_INL_H


#include <optional>
#include <string>
#if ADA_REGULAR_VISUAL_STUDIO
#include <intrin.h>
#endif  // ADA_REGULAR_VISUAL_STUDIO

namespace ada {
[[nodiscard]] ada_really_inline bool url::has_credentials() const noexcept {
  return !username.empty() || !password.empty();
}
[[nodiscard]] ada_really_inline bool url::has_port() const noexcept {
  return port.has_value();
}
[[nodiscard]] inline bool url::cannot_have_credentials_or_port() const {
  return !host.has_value() || host.value().empty() ||
         type == ada::scheme::type::FILE;
}
[[nodiscard]] inline bool url::has_empty_hostname() const noexcept {
  if (!host.has_value()) {
    return false;
  }
  return host.value().empty();
}
[[nodiscard]] inline bool url::has_hostname() const noexcept {
  return host.has_value();
}
inline std::ostream &operator<<(std::ostream &out, const ada::url &u) {
  return out << u.to_string();
}

[[nodiscard]] size_t url::get_pathname_length() const noexcept {
  return path.size();
}

[[nodiscard]] ada_really_inline ada::url_components url::get_components()
    const noexcept {
  url_components out{};

  // protocol ends with ':'. for example: "https:"
  out.protocol_end = uint32_t(get_protocol().size());

  // Trailing index is always the next character of the current one.
  size_t running_index = out.protocol_end;

  if (host.has_value()) {
    // 2 characters for "//" and 1 character for starting index
    out.host_start = out.protocol_end + 2;

    if (has_credentials()) {
      out.username_end = uint32_t(out.host_start + username.size());

      out.host_start += uint32_t(username.size());

      if (!password.empty()) {
        out.host_start += uint32_t(password.size() + 1);
      }

      out.host_end = uint32_t(out.host_start + host.value().size());
    } else {
      out.username_end = out.host_start;

      // Host does not start with "@" if it does not include credentials.
      out.host_end = uint32_t(out.host_start + host.value().size()) - 1;
    }

    running_index = out.host_end + 1;
  } else {
    // Update host start and end date to the same index, since it does not
    // exist.
    out.host_start = out.protocol_end;
    out.host_end = out.host_start;

    if (!has_opaque_path && checkers::begins_with(path, "//")) {
      // If url's host is null, url does not have an opaque path, url's path's
      // size is greater than 1, and url's path[0] is the empty string, then
      // append U+002F (/) followed by U+002E (.) to output.
      running_index = out.protocol_end + 2;
    } else {
      running_index = out.protocol_end;
    }
  }

  if (port.has_value()) {
    out.port = *port;
    running_index += helpers::fast_digit_count(*port) + 1;  // Port omits ':'
  }

  out.pathname_start = uint32_t(running_index);

  running_index += path.size();

  if (query.has_value()) {
    out.search_start = uint32_t(running_index);
    running_index += get_search().size();
    if (get_search().empty()) {
      running_index++;
    }
  }

  if (hash.has_value()) {
    out.hash_start = uint32_t(running_index);
  }

  return out;
}

inline void url::update_base_hostname(std::string_view input) { host = input; }

inline void url::update_unencoded_base_hash(std::string_view input) {
  // We do the percent encoding
  hash = unicode::percent_encode(input,
                                 ada::character_sets::FRAGMENT_PERCENT_ENCODE);
}

inline void url::update_base_search(std::string_view input,
                                    const uint8_t query_percent_encode_set[]) {
  query = ada::unicode::percent_encode(input, query_percent_encode_set);
}

inline void url::update_base_search(std::optional<std::string> input) {
  query = input;
}

inline void url::update_base_pathname(const std::string_view input) {
  path = input;
}

inline void url::update_base_username(const std::string_view input) {
  username = input;
}

inline void url::update_base_password(const std::string_view input) {
  password = input;
}

inline void url::update_base_port(std::optional<uint16_t> input) {
  port = input;
}

inline void url::clear_pathname() { path.clear(); }

inline void url::clear_search() { query = std::nullopt; }

[[nodiscard]] inline bool url::has_hash() const noexcept {
  return hash.has_value();
}

[[nodiscard]] inline bool url::has_search() const noexcept {
  return query.has_value();
}

inline void url::set_protocol_as_file() { type = ada::scheme::type::FILE; }

inline void url::set_scheme(std::string &&new_scheme) noexcept {
  type = ada::scheme::get_scheme_type(new_scheme);
  // We only move the 'scheme' if it is non-special.
  if (!is_special()) {
    non_special_scheme = std::move(new_scheme);
  }
}

inline void url::copy_scheme(ada::url &&u) noexcept {
  non_special_scheme = u.non_special_scheme;
  type = u.type;
}

inline void url::copy_scheme(const ada::url &u) {
  non_special_scheme = u.non_special_scheme;
  type = u.type;
}

[[nodiscard]] ada_really_inline std::string url::get_href() const noexcept {
  std::string output = get_protocol();

  if (host.has_value()) {
    output += "//";
    if (has_credentials()) {
      output += username;
      if (!password.empty()) {
        output += ":" + get_password();
      }
      output += "@";
    }
    output += host.value();
    if (port.has_value()) {
      output += ":" + get_port();
    }
  } else if (!has_opaque_path && checkers::begins_with(path, "//")) {
    // If url's host is null, url does not have an opaque path, url's path's
    // size is greater than 1, and url's path[0] is the empty string, then
    // append U+002F (/) followed by U+002E (.) to output.
    output += "/.";
  }
  output += path;
  if (query.has_value()) {
    output += "?" + query.value();
  }
  if (hash.has_value()) {
    output += "#" + hash.value();
  }
  return output;
}

ada_really_inline size_t url::parse_port(std::string_view view,
                                         bool check_trailing_content) noexcept {
  ada_log("parse_port('", view, "') ", view.size());
  if (!view.empty() && view[0] == '-') {
    ada_log("parse_port: view[0] == '0' && view.size() > 1");
    is_valid = false;
    return 0;
  }
  uint16_t parsed_port{};
  auto r = std::from_chars(view.data(), view.data() + view.size(), parsed_port);
  if (r.ec == std::errc::result_out_of_range) {
    ada_log("parse_port: r.ec == std::errc::result_out_of_range");
    is_valid = false;
    return 0;
  }
  ada_log("parse_port: ", parsed_port);
  const size_t consumed = size_t(r.ptr - view.data());
  ada_log("parse_port: consumed ", consumed);
  if (check_trailing_content) {
    is_valid &=
        (consumed == view.size() || view[consumed] == '/' ||
         view[consumed] == '?' || (is_special() && view[consumed] == '\\'));
  }
  ada_log("parse_port: is_valid = ", is_valid);
  if (is_valid) {
    // scheme_default_port can return 0, and we should allow 0 as a base port.
    auto default_port = scheme_default_port();
    bool is_port_valid = (default_port == 0 && parsed_port == 0) ||
                         (default_port != parsed_port);
    port = (r.ec == std::errc() && is_port_valid)
               ? std::optional<uint16_t>(parsed_port)
               : std::nullopt;
  }
  return consumed;
}

}  // namespace ada

#endif  // ADA_URL_H
/* end file include/ada/url-inl.h */
/* begin file include/ada/url_aggregator-inl.h */
/**
 * @file url_aggregator-inl.h
 * @brief Inline functions for url aggregator
 */
#ifndef ADA_URL_AGGREGATOR_INL_H
#define ADA_URL_AGGREGATOR_INL_H

/* begin file include/ada/unicode-inl.h */
/**
 * @file unicode-inl.h
 * @brief Definitions for unicode operations.
 */
#ifndef ADA_UNICODE_INL_H
#define ADA_UNICODE_INL_H
#include <algorithm>

/**
 * Unicode operations. These functions are not part of our public API and may
 * change at any time.
 *
 * private
 * @namespace ada::unicode
 * @brief Includes the declarations for unicode operations
 */
namespace ada::unicode {
ada_really_inline size_t percent_encode_index(const std::string_view input,
                                              const uint8_t character_set[]) {
  return std::distance(
      input.begin(),
      std::find_if(input.begin(), input.end(), [character_set](const char c) {
        return character_sets::bit_at(character_set, c);
      }));
}
}  // namespace ada::unicode

#endif  // ADA_UNICODE_INL_H
/* end file include/ada/unicode-inl.h */

#include <optional>
#include <string_view>

namespace ada {

inline void url_aggregator::update_base_authority(
    std::string_view base_buffer, const ada::url_components &base) {
  std::string_view input = base_buffer.substr(
      base.protocol_end, base.host_start - base.protocol_end);
  ada_log("url_aggregator::update_base_authority ", input);

  bool input_starts_with_dash = checkers::begins_with(input, "//");
  uint32_t diff = components.host_start - components.protocol_end;

  buffer.erase(components.protocol_end,
               components.host_start - components.protocol_end);
  components.username_end = components.protocol_end;

  if (input_starts_with_dash) {
    input.remove_prefix(2);
    diff += 2;  // add "//"
    buffer.insert(components.protocol_end, "//");
    components.username_end += 2;
  }

  size_t password_delimiter = input.find(':');

  // Check if input contains both username and password by checking the
  // delimiter: ":" A typical input that contains authority would be "user:pass"
  if (password_delimiter != std::string_view::npos) {
    // Insert both username and password
    std::string_view username = input.substr(0, password_delimiter);
    std::string_view password = input.substr(password_delimiter + 1);

    buffer.insert(components.protocol_end + diff, username);
    diff += uint32_t(username.size());
    buffer.insert(components.protocol_end + diff, ":");
    components.username_end = components.protocol_end + diff;
    buffer.insert(components.protocol_end + diff + 1, password);
    diff += uint32_t(password.size()) + 1;
  } else if (!input.empty()) {
    // Insert only username
    buffer.insert(components.protocol_end + diff, input);
    components.username_end =
        components.protocol_end + diff + uint32_t(input.size());
    diff += uint32_t(input.size());
  }

  components.host_start += diff;

  if (buffer.size() > base.host_start && buffer[base.host_start] != '@') {
    buffer.insert(components.host_start, "@");
    diff++;
  }
  components.host_end += diff;
  components.pathname_start += diff;
  if (components.search_start != url_components::omitted) {
    components.search_start += diff;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += diff;
  }
}

inline void url_aggregator::update_unencoded_base_hash(std::string_view input) {
  ada_log("url_aggregator::update_unencoded_base_hash ", input, " [",
          input.size(), " bytes], buffer is '", buffer, "' [", buffer.size(),
          " bytes] components.hash_start = ", components.hash_start);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  if (components.hash_start != url_components::omitted) {
    buffer.resize(components.hash_start);
  }
  components.hash_start = uint32_t(buffer.size());
  buffer += "#";
  bool encoding_required = unicode::percent_encode<true>(
      input, ada::character_sets::FRAGMENT_PERCENT_ENCODE, buffer);
  // When encoding_required is false, then buffer is left unchanged, and percent
  // encoding was not deemed required.
  if (!encoding_required) {
    buffer.append(input);
  }
  ada_log("url_aggregator::update_unencoded_base_hash final buffer is '",
          buffer, "' [", buffer.size(), " bytes]");
  ADA_ASSERT_TRUE(validate());
}

ada_really_inline uint32_t url_aggregator::replace_and_resize(
    uint32_t start, uint32_t end, std::string_view input) {
  uint32_t current_length = end - start;
  uint32_t input_size = uint32_t(input.size());
  uint32_t new_difference = input_size - current_length;

  if (current_length == 0) {
    buffer.insert(start, input);
  } else if (input_size == current_length) {
    buffer.replace(start, input_size, input);
  } else if (input_size < current_length) {
    buffer.erase(start, current_length - input_size);
    buffer.replace(start, input_size, input);
  } else {
    buffer.replace(start, current_length, input.substr(0, current_length));
    buffer.insert(start + current_length, input.substr(current_length));
  }

  return new_difference;
}

inline void url_aggregator::update_base_hostname(const std::string_view input) {
  ada_log("url_aggregator::update_base_hostname ", input, " [", input.size(),
          " bytes], buffer is '", buffer, "' [", buffer.size(), " bytes]");
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));

  // This next line is required for when parsing a URL like `foo://`
  add_authority_slashes_if_needed();

  bool has_credentials = components.protocol_end + 2 < components.host_start;
  uint32_t new_difference =
      replace_and_resize(components.host_start, components.host_end, input);

  if (has_credentials) {
    buffer.insert(components.host_start, "@");
    new_difference++;
  }
  components.host_end += new_difference;
  components.pathname_start += new_difference;
  if (components.search_start != url_components::omitted) {
    components.search_start += new_difference;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += new_difference;
  }
  ADA_ASSERT_TRUE(validate());
}

[[nodiscard]] ada_really_inline uint32_t
url_aggregator::get_pathname_length() const noexcept {
  ada_log("url_aggregator::get_pathname_length");
  uint32_t ending_index = uint32_t(buffer.size());
  if (components.search_start != url_components::omitted) {
    ending_index = components.search_start;
  } else if (components.hash_start != url_components::omitted) {
    ending_index = components.hash_start;
  }
  return ending_index - components.pathname_start;
}

[[nodiscard]] ada_really_inline bool url_aggregator::is_at_path()
    const noexcept {
  return buffer.size() == components.pathname_start;
}

inline void url_aggregator::update_base_search(std::string_view input) {
  ada_log("url_aggregator::update_base_search ", input);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  if (input.empty()) {
    clear_search();
    return;
  }

  if (input[0] == '?') {
    input.remove_prefix(1);
  }

  if (components.hash_start == url_components::omitted) {
    if (components.search_start == url_components::omitted) {
      components.search_start = uint32_t(buffer.size());
      buffer += "?";
    } else {
      buffer.resize(components.search_start + 1);
    }

    buffer.append(input);
  } else {
    if (components.search_start == url_components::omitted) {
      components.search_start = components.hash_start;
    } else {
      buffer.erase(components.search_start,
                   components.hash_start - components.search_start);
      components.hash_start = components.search_start;
    }

    buffer.insert(components.search_start, "?");
    buffer.insert(components.search_start + 1, input);
    components.hash_start += uint32_t(input.size() + 1);  // Do not forget `?`
  }

  ADA_ASSERT_TRUE(validate());
}

inline void url_aggregator::update_base_search(
    std::string_view input, const uint8_t query_percent_encode_set[]) {
  ada_log("url_aggregator::update_base_search ", input,
          " with encoding parameter ", to_string(), "\n", to_diagram());
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));

  if (components.hash_start == url_components::omitted) {
    if (components.search_start == url_components::omitted) {
      components.search_start = uint32_t(buffer.size());
      buffer += "?";
    } else {
      buffer.resize(components.search_start + 1);
    }

    bool encoding_required =
        unicode::percent_encode<true>(input, query_percent_encode_set, buffer);
    // When encoding_required is false, then buffer is left unchanged, and
    // percent encoding was not deemed required.
    if (!encoding_required) {
      buffer.append(input);
    }
  } else {
    if (components.search_start == url_components::omitted) {
      components.search_start = components.hash_start;
    } else {
      buffer.erase(components.search_start,
                   components.hash_start - components.search_start);
      components.hash_start = components.search_start;
    }

    buffer.insert(components.search_start, "?");
    size_t idx =
        ada::unicode::percent_encode_index(input, query_percent_encode_set);
    if (idx == input.size()) {
      buffer.insert(components.search_start + 1, input);
      components.hash_start += uint32_t(input.size() + 1);  // Do not forget `?`
    } else {
      buffer.insert(components.search_start + 1, input, 0, idx);
      input.remove_prefix(idx);
      // We only create a temporary string if we need percent encoding and
      // we attempt to create as small a temporary string as we can.
      std::string encoded =
          ada::unicode::percent_encode(input, query_percent_encode_set);
      buffer.insert(components.search_start + idx + 1, encoded);
      components.hash_start +=
          uint32_t(encoded.size() + idx + 1);  // Do not forget `?`
    }
  }

  ADA_ASSERT_TRUE(validate());
}

inline void url_aggregator::update_base_pathname(const std::string_view input) {
  ada_log("url_aggregator::update_base_pathname '", input, "' [", input.size(),
          " bytes] \n", to_diagram());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
  ADA_ASSERT_TRUE(validate());

  const bool begins_with_dashdash = checkers::begins_with(input, "//");
  if (!begins_with_dashdash && has_dash_dot()) {
    ada_log("url_aggregator::update_base_pathname has /.: \n", to_diagram());
    // We must delete the ./
    delete_dash_dot();
  }

  if (begins_with_dashdash && !has_opaque_path && !has_authority() &&
      !has_dash_dot()) {
    // If url's host is null, url does not have an opaque path, url's path's
    // size is greater than 1, then append U+002F (/) followed by U+002E (.) to
    // output.
    buffer.insert(components.pathname_start, "/.");
    components.pathname_start += 2;
  }

  uint32_t difference = replace_and_resize(
      components.pathname_start,
      components.pathname_start + get_pathname_length(), input);
  if (components.search_start != url_components::omitted) {
    components.search_start += difference;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += difference;
  }
  ada_log("url_aggregator::update_base_pathname end '", input, "' [",
          input.size(), " bytes] \n", to_diagram());
  ADA_ASSERT_TRUE(validate());
}

inline void url_aggregator::append_base_pathname(const std::string_view input) {
  ada_log("url_aggregator::append_base_pathname ", input, " ", to_string(),
          "\n", to_diagram());
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
#if ADA_DEVELOPMENT_CHECKS
  // computing the expected password.
  std::string path_expected(get_pathname());
  path_expected.append(input);
#endif  // ADA_DEVELOPMENT_CHECKS
  uint32_t ending_index = uint32_t(buffer.size());
  if (components.search_start != url_components::omitted) {
    ending_index = components.search_start;
  } else if (components.hash_start != url_components::omitted) {
    ending_index = components.hash_start;
  }
  buffer.insert(ending_index, input);

  if (components.search_start != url_components::omitted) {
    components.search_start += uint32_t(input.size());
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += uint32_t(input.size());
  }
#if ADA_DEVELOPMENT_CHECKS
  std::string path_after = std::string(get_pathname());
  ADA_ASSERT_EQUAL(
      path_expected, path_after,
      "append_base_pathname problem after inserting " + std::string(input));
#endif  // ADA_DEVELOPMENT_CHECKS
  ADA_ASSERT_TRUE(validate());
}

inline void url_aggregator::update_base_username(const std::string_view input) {
  ada_log("url_aggregator::update_base_username '", input, "' ", to_string(),
          "\n", to_diagram());
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));

  add_authority_slashes_if_needed();

  bool has_password = has_non_empty_password();
  bool host_starts_with_at = buffer.size() > components.host_start &&
                             buffer[components.host_start] == '@';
  uint32_t diff = replace_and_resize(components.protocol_end + 2,
                                     components.username_end, input);

  components.username_end += diff;
  components.host_start += diff;

  if (!input.empty() && !host_starts_with_at) {
    buffer.insert(components.host_start, "@");
    diff++;
  } else if (input.empty() && host_starts_with_at && !has_password) {
    // Input is empty, there is no password, and we need to remove "@" from
    // hostname
    buffer.erase(components.host_start, 1);
    diff--;
  }

  components.host_end += diff;
  components.pathname_start += diff;
  if (components.search_start != url_components::omitted) {
    components.search_start += diff;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += diff;
  }
  ADA_ASSERT_TRUE(validate());
}

inline void url_aggregator::append_base_username(const std::string_view input) {
  ada_log("url_aggregator::append_base_username ", input);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
#if ADA_DEVELOPMENT_CHECKS
  // computing the expected password.
  std::string username_expected(get_username());
  username_expected.append(input);
#endif  // ADA_DEVELOPMENT_CHECKS
  add_authority_slashes_if_needed();

  // If input is empty, do nothing.
  if (input.empty()) {
    return;
  }

  uint32_t difference = uint32_t(input.size());
  buffer.insert(components.username_end, input);
  components.username_end += difference;
  components.host_start += difference;

  if (buffer[components.host_start] != '@' &&
      components.host_start != components.host_end) {
    buffer.insert(components.host_start, "@");
    difference++;
  }

  components.host_end += difference;
  components.pathname_start += difference;
  if (components.search_start != url_components::omitted) {
    components.search_start += difference;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += difference;
  }
#if ADA_DEVELOPMENT_CHECKS
  std::string username_after(get_username());
  ADA_ASSERT_EQUAL(
      username_expected, username_after,
      "append_base_username problem after inserting " + std::string(input));
#endif  // ADA_DEVELOPMENT_CHECKS
  ADA_ASSERT_TRUE(validate());
}

inline void url_aggregator::clear_password() {
  ada_log("url_aggregator::clear_password ", to_string(), "\n", to_diagram());
  ADA_ASSERT_TRUE(validate());
  if (!has_password()) {
    return;
  }

  uint32_t diff = components.host_start - components.username_end;
  buffer.erase(components.username_end, diff);
  components.host_start -= diff;
  components.host_end -= diff;
  components.pathname_start -= diff;
  if (components.search_start != url_components::omitted) {
    components.search_start -= diff;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start -= diff;
  }
}

inline void url_aggregator::update_base_password(const std::string_view input) {
  ada_log("url_aggregator::update_base_password ", input);
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));

  add_authority_slashes_if_needed();

  // TODO: Optimization opportunity. Merge the following removal functions.
  if (input.empty()) {
    clear_password();

    // Remove username too, if it is empty.
    if (!has_non_empty_username()) {
      update_base_username("");
    }

    return;
  }

  bool password_exists = has_password();
  uint32_t difference = uint32_t(input.size());

  if (password_exists) {
    uint32_t current_length =
        components.host_start - components.username_end - 1;
    buffer.erase(components.username_end + 1, current_length);
    difference -= current_length;
  } else {
    buffer.insert(components.username_end, ":");
    difference++;
  }

  buffer.insert(components.username_end + 1, input);
  components.host_start += difference;

  // The following line is required to add "@" to hostname. When updating
  // password if hostname does not start with "@", it is "update_base_password"s
  // responsibility to set it.
  if (buffer[components.host_start] != '@') {
    buffer.insert(components.host_start, "@");
    difference++;
  }

  components.host_end += difference;
  components.pathname_start += difference;
  if (components.search_start != url_components::omitted) {
    components.search_start += difference;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += difference;
  }
  ADA_ASSERT_TRUE(validate());
}

inline void url_aggregator::append_base_password(const std::string_view input) {
  ada_log("url_aggregator::append_base_password ", input, " ", to_string(),
          "\n", to_diagram());
  ADA_ASSERT_TRUE(validate());
  ADA_ASSERT_TRUE(!helpers::overlaps(input, buffer));
#if ADA_DEVELOPMENT_CHECKS
  // computing the expected password.
  std::string password_expected = std::string(get_password());
  password_expected.append(input);
#endif  // ADA_DEVELOPMENT_CHECKS
  add_authority_slashes_if_needed();

  // If input is empty, do nothing.
  if (input.empty()) {
    return;
  }

  uint32_t difference = uint32_t(input.size());
  if (has_password()) {
    buffer.insert(components.host_start, input);
  } else {
    difference++;  // Increment for ":"
    buffer.insert(components.username_end, ":");
    buffer.insert(components.username_end + 1, input);
  }
  components.host_start += difference;

  // The following line is required to add "@" to hostname. When updating
  // password if hostname does not start with "@", it is "append_base_password"s
  // responsibility to set it.
  if (buffer[components.host_start] != '@') {
    buffer.insert(components.host_start, "@");
    difference++;
  }

  components.host_end += difference;
  components.pathname_start += difference;
  if (components.search_start != url_components::omitted) {
    components.search_start += difference;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += difference;
  }
#if ADA_DEVELOPMENT_CHECKS
  std::string password_after(get_password());
  ADA_ASSERT_EQUAL(
      password_expected, password_after,
      "append_base_password problem after inserting " + std::string(input));
#endif  // ADA_DEVELOPMENT_CHECKS
  ADA_ASSERT_TRUE(validate());
}

inline void url_aggregator::update_base_port(uint32_t input) {
  ada_log("url_aggregator::update_base_port");
  ADA_ASSERT_TRUE(validate());
  if (input == url_components::omitted) {
    clear_port();
    return;
  }
  // calling std::to_string(input.value()) is unfortunate given that the port
  // value is probably already available as a string.
  std::string value = helpers::concat(":", std::to_string(input));
  uint32_t difference = uint32_t(value.size());

  if (components.port != url_components::omitted) {
    difference -= components.pathname_start - components.host_end;
    buffer.erase(components.host_end,
                 components.pathname_start - components.host_end);
  }

  buffer.insert(components.host_end, value);
  components.pathname_start += difference;
  if (components.search_start != url_components::omitted) {
    components.search_start += difference;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += difference;
  }
  components.port = input;
  ADA_ASSERT_TRUE(validate());
}

inline void url_aggregator::clear_port() {
  ada_log("url_aggregator::clear_port");
  ADA_ASSERT_TRUE(validate());
  if (components.port == url_components::omitted) {
    return;
  }
  uint32_t length = components.pathname_start - components.host_end;
  buffer.erase(components.host_end, length);
  components.pathname_start -= length;
  if (components.search_start != url_components::omitted) {
    components.search_start -= length;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start -= length;
  }
  components.port = url_components::omitted;
  ADA_ASSERT_TRUE(validate());
}

[[nodiscard]] inline uint32_t url_aggregator::retrieve_base_port() const {
  ada_log("url_aggregator::retrieve_base_port");
  return components.port;
}

inline void url_aggregator::clear_search() {
  ada_log("url_aggregator::clear_search");
  ADA_ASSERT_TRUE(validate());
  if (components.search_start == url_components::omitted) {
    return;
  }

  if (components.hash_start == url_components::omitted) {
    buffer.resize(components.search_start);
  } else {
    buffer.erase(components.search_start,
                 components.hash_start - components.search_start);
    components.hash_start = components.search_start;
  }

  components.search_start = url_components::omitted;

#if ADA_DEVELOPMENT_CHECKS
  ADA_ASSERT_EQUAL(get_search(), "",
                   "search should have been cleared on buffer=" + buffer +
                       " with " + components.to_string() + "\n" + to_diagram());
#endif
  ADA_ASSERT_TRUE(validate());
}

inline void url_aggregator::clear_hash() {
  ada_log("url_aggregator::clear_hash");
  ADA_ASSERT_TRUE(validate());
  if (components.hash_start == url_components::omitted) {
    return;
  }
  buffer.resize(components.hash_start);
  components.hash_start = url_components::omitted;

#if ADA_DEVELOPMENT_CHECKS
  ADA_ASSERT_EQUAL(get_hash(), "",
                   "hash should have been cleared on buffer=" + buffer +
                       " with " + components.to_string() + "\n" + to_diagram());
#endif
  ADA_ASSERT_TRUE(validate());
}

inline void url_aggregator::clear_pathname() {
  ada_log("url_aggregator::clear_pathname");
  ADA_ASSERT_TRUE(validate());
  uint32_t ending_index = uint32_t(buffer.size());
  if (components.search_start != url_components::omitted) {
    ending_index = components.search_start;
  } else if (components.hash_start != url_components::omitted) {
    ending_index = components.hash_start;
  }
  uint32_t pathname_length = ending_index - components.pathname_start;
  buffer.erase(components.pathname_start, pathname_length);
  uint32_t difference = pathname_length;
  if (components.pathname_start == components.host_end + 2 &&
      buffer[components.host_end] == '/' &&
      buffer[components.host_end + 1] == '.') {
    components.pathname_start -= 2;
    buffer.erase(components.host_end, 2);
    difference += 2;
  }
  if (components.search_start != url_components::omitted) {
    components.search_start -= difference;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start -= difference;
  }
  ada_log("url_aggregator::clear_pathname completed, running checks...");
#if ADA_DEVELOPMENT_CHECKS
  ADA_ASSERT_EQUAL(get_pathname(), "",
                   "pathname should have been cleared on buffer=" + buffer +
                       " with " + components.to_string() + "\n" + to_diagram());
#endif
  ADA_ASSERT_TRUE(validate());
  ada_log("url_aggregator::clear_pathname completed, running checks... ok");
}

inline void url_aggregator::clear_hostname() {
  ada_log("url_aggregator::clear_hostname");
  ADA_ASSERT_TRUE(validate());
  if (!has_authority()) {
    return;
  }
  ADA_ASSERT_TRUE(has_authority());

  uint32_t hostname_length = components.host_end - components.host_start;
  uint32_t start = components.host_start;

  // If hostname starts with "@", we should not remove that character.
  if (hostname_length > 0 && buffer[start] == '@') {
    start++;
    hostname_length--;
  }
  buffer.erase(start, hostname_length);
  components.host_end = start;
  components.pathname_start -= hostname_length;
  if (components.search_start != url_components::omitted) {
    components.search_start -= hostname_length;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start -= hostname_length;
  }
#if ADA_DEVELOPMENT_CHECKS
  ADA_ASSERT_EQUAL(get_hostname(), "",
                   "hostname should have been cleared on buffer=" + buffer +
                       " with " + components.to_string() + "\n" + to_diagram());
#endif
  ADA_ASSERT_TRUE(has_authority());
  ADA_ASSERT_EQUAL(has_empty_hostname(), true,
                   "hostname should have been cleared on buffer=" + buffer +
                       " with " + components.to_string() + "\n" + to_diagram());
  ADA_ASSERT_TRUE(validate());
}

[[nodiscard]] inline bool url_aggregator::has_hash() const noexcept {
  ada_log("url_aggregator::has_hash");
  return components.hash_start != url_components::omitted;
}

[[nodiscard]] inline bool url_aggregator::has_search() const noexcept {
  ada_log("url_aggregator::has_search");
  return components.search_start != url_components::omitted;
}

ada_really_inline bool url_aggregator::has_credentials() const noexcept {
  ada_log("url_aggregator::has_credentials");
  return has_non_empty_username() || has_non_empty_password();
}

inline bool url_aggregator::cannot_have_credentials_or_port() const {
  ada_log("url_aggregator::cannot_have_credentials_or_port");
  return type == ada::scheme::type::FILE ||
         components.host_start == components.host_end;
}

[[nodiscard]] ada_really_inline const ada::url_components &
url_aggregator::get_components() const noexcept {
  return components;
}

[[nodiscard]] inline bool ada::url_aggregator::has_authority() const noexcept {
  ada_log("url_aggregator::has_authority");
  // Performance: instead of doing this potentially expensive check, we could
  // have a boolean in the struct.
  return components.protocol_end + 2 <= components.host_start &&
         helpers::substring(buffer, components.protocol_end,
                            components.protocol_end + 2) == "//";
}

inline void ada::url_aggregator::add_authority_slashes_if_needed() noexcept {
  ada_log("url_aggregator::add_authority_slashes_if_needed");
  ADA_ASSERT_TRUE(validate());
  // Protocol setter will insert `http:` to the URL. It is up to hostname setter
  // to insert
  // `//` initially to the buffer, since it depends on the hostname existence.
  if (has_authority()) {
    return;
  }
  // Performance: the common case is components.protocol_end == buffer.size()
  // Optimization opportunity: in many cases, the "//" is part of the input and
  // the insert could be fused with another insert.
  buffer.insert(components.protocol_end, "//");
  components.username_end += 2;
  components.host_start += 2;
  components.host_end += 2;
  components.pathname_start += 2;
  if (components.search_start != url_components::omitted) {
    components.search_start += 2;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += 2;
  }
  ADA_ASSERT_TRUE(validate());
}

inline void ada::url_aggregator::reserve(uint32_t capacity) {
  buffer.reserve(capacity);
}

inline bool url_aggregator::has_non_empty_username() const noexcept {
  ada_log("url_aggregator::has_non_empty_username");
  return components.protocol_end + 2 < components.username_end;
}

inline bool url_aggregator::has_non_empty_password() const noexcept {
  ada_log("url_aggregator::has_non_empty_password");
  return components.host_start - components.username_end > 0;
}

inline bool url_aggregator::has_password() const noexcept {
  ada_log("url_aggregator::has_password");
  // This function does not care about the length of the password
  return components.host_start > components.username_end &&
         buffer[components.username_end] == ':';
}

inline bool url_aggregator::has_empty_hostname() const noexcept {
  if (!has_hostname()) {
    return false;
  }
  if (components.host_start == components.host_end) {
    return true;
  }
  if (components.host_end > components.host_start + 1) {
    return false;
  }
  return components.username_end != components.host_start;
}

inline bool url_aggregator::has_hostname() const noexcept {
  return has_authority();
}

inline bool url_aggregator::has_port() const noexcept {
  ada_log("url_aggregator::has_port");
  // A URL cannot have a username/password/port if its host is null or the empty
  // string, or its scheme is "file".
  return has_hostname() && components.pathname_start != components.host_end;
}

[[nodiscard]] inline bool url_aggregator::has_dash_dot() const noexcept {
  // If url's host is null, url does not have an opaque path, url's path's size
  // is greater than 1, and url's path[0] is the empty string, then append
  // U+002F (/) followed by U+002E (.) to output.
  ada_log("url_aggregator::has_dash_dot");
#if ADA_DEVELOPMENT_CHECKS
  // If pathname_start and host_end are exactly two characters apart, then we
  // either have a one-digit port such as http://test.com:5?param=1 or else we
  // have a /.: sequence such as "non-spec:/.//". We test that this is the case.
  if (components.pathname_start == components.host_end + 2) {
    ADA_ASSERT_TRUE((buffer[components.host_end] == '/' &&
                     buffer[components.host_end + 1] == '.') ||
                    (buffer[components.host_end] == ':' &&
                     checkers::is_digit(buffer[components.host_end + 1])));
  }
  if (components.pathname_start == components.host_end + 2 &&
      buffer[components.host_end] == '/' &&
      buffer[components.host_end + 1] == '.') {
    ADA_ASSERT_TRUE(components.pathname_start + 1 < buffer.size());
    ADA_ASSERT_TRUE(buffer[components.pathname_start] == '/');
    ADA_ASSERT_TRUE(buffer[components.pathname_start + 1] == '/');
  }
#endif
  // Performance: it should be uncommon for components.pathname_start ==
  // components.host_end + 2 to be true. So we put this check first in the
  // sequence. Most times, we do not have an opaque path. Checking for '/.' is
  // more expensive, but should be uncommon.
  return components.pathname_start == components.host_end + 2 &&
         !has_opaque_path && buffer[components.host_end] == '/' &&
         buffer[components.host_end + 1] == '.';
}

[[nodiscard]] inline std::string_view url_aggregator::get_href() const noexcept
    ada_lifetime_bound {
  ada_log("url_aggregator::get_href");
  return buffer;
}

ada_really_inline size_t url_aggregator::parse_port(
    std::string_view view, bool check_trailing_content) noexcept {
  ada_log("url_aggregator::parse_port('", view, "') ", view.size());
  if (!view.empty() && view[0] == '-') {
    ada_log("parse_port: view[0] == '0' && view.size() > 1");
    is_valid = false;
    return 0;
  }
  uint16_t parsed_port{};
  auto r = std::from_chars(view.data(), view.data() + view.size(), parsed_port);
  if (r.ec == std::errc::result_out_of_range) {
    ada_log("parse_port: r.ec == std::errc::result_out_of_range");
    is_valid = false;
    return 0;
  }
  ada_log("parse_port: ", parsed_port);
  const size_t consumed = size_t(r.ptr - view.data());
  ada_log("parse_port: consumed ", consumed);
  if (check_trailing_content) {
    is_valid &=
        (consumed == view.size() || view[consumed] == '/' ||
         view[consumed] == '?' || (is_special() && view[consumed] == '\\'));
  }
  ada_log("parse_port: is_valid = ", is_valid);
  if (is_valid) {
    ada_log("parse_port", r.ec == std::errc());
    // scheme_default_port can return 0, and we should allow 0 as a base port.
    auto default_port = scheme_default_port();
    bool is_port_valid = (default_port == 0 && parsed_port == 0) ||
                         (default_port != parsed_port);
    if (r.ec == std::errc() && is_port_valid) {
      update_base_port(parsed_port);
    } else {
      clear_port();
    }
  }
  return consumed;
}

inline void url_aggregator::set_protocol_as_file() {
  ada_log("url_aggregator::set_protocol_as_file ");
  ADA_ASSERT_TRUE(validate());
  type = ada::scheme::type::FILE;
  // next line could overflow but unsigned arithmetic has well-defined
  // overflows.
  uint32_t new_difference = 5 - components.protocol_end;

  if (buffer.empty()) {
    buffer.append("file:");
  } else {
    buffer.erase(0, components.protocol_end);
    buffer.insert(0, "file:");
  }
  components.protocol_end = 5;

  // Update the rest of the components.
  components.username_end += new_difference;
  components.host_start += new_difference;
  components.host_end += new_difference;
  components.pathname_start += new_difference;
  if (components.search_start != url_components::omitted) {
    components.search_start += new_difference;
  }
  if (components.hash_start != url_components::omitted) {
    components.hash_start += new_difference;
  }
  ADA_ASSERT_TRUE(validate());
}

inline std::ostream &operator<<(std::ostream &out,
                                const ada::url_aggregator &u) {
  return out << u.to_string();
}
}  // namespace ada

#endif  // ADA_URL_AGGREGATOR_INL_H
/* end file include/ada/url_aggregator-inl.h */
/* begin file include/ada/url_search_params.h */
/**
 * @file url_search_params.h
 * @brief Declaration for the URL Search Params
 */
#ifndef ADA_URL_SEARCH_PARAMS_H
#define ADA_URL_SEARCH_PARAMS_H

#include <optional>
#include <string>
#include <string_view>
#include <vector>

namespace ada {

enum class url_search_params_iter_type {
  KEYS,
  VALUES,
  ENTRIES,
};

template <typename T, url_search_params_iter_type Type>
struct url_search_params_iter;

typedef std::pair<std::string_view, std::string_view> key_value_view_pair;

using url_search_params_keys_iter =
    url_search_params_iter<std::string_view, url_search_params_iter_type::KEYS>;
using url_search_params_values_iter =
    url_search_params_iter<std::string_view,
                           url_search_params_iter_type::VALUES>;
using url_search_params_entries_iter =
    url_search_params_iter<key_value_view_pair,
                           url_search_params_iter_type::ENTRIES>;

/**
 * @see https://url.spec.whatwg.org/#interface-urlsearchparams
 */
struct url_search_params {
  url_search_params() = default;

  /**
   * @see
   * https://github.com/web-platform-tests/wpt/blob/master/url/urlsearchparams-constructor.any.js
   */
  url_search_params(const std::string_view input) { initialize(input); }

  url_search_params(const url_search_params &u) = default;
  url_search_params(url_search_params &&u) noexcept = default;
  url_search_params &operator=(url_search_params &&u) noexcept = default;
  url_search_params &operator=(const url_search_params &u) = default;
  ~url_search_params() = default;

  [[nodiscard]] inline size_t size() const noexcept;

  /**
   * @see https://url.spec.whatwg.org/#dom-urlsearchparams-append
   */
  inline void append(std::string_view key, std::string_view value);

  /**
   * @see https://url.spec.whatwg.org/#dom-urlsearchparams-delete
   */
  inline void remove(std::string_view key);
  inline void remove(std::string_view key, std::string_view value);

  /**
   * @see https://url.spec.whatwg.org/#dom-urlsearchparams-get
   */
  inline std::optional<std::string_view> get(std::string_view key);

  /**
   * @see https://url.spec.whatwg.org/#dom-urlsearchparams-getall
   */
  inline std::vector<std::string> get_all(std::string_view key);

  /**
   * @see https://url.spec.whatwg.org/#dom-urlsearchparams-has
   */
  inline bool has(std::string_view key) noexcept;
  inline bool has(std::string_view key, std::string_view value) noexcept;

  /**
   * @see https://url.spec.whatwg.org/#dom-urlsearchparams-set
   */
  inline void set(std::string_view key, std::string_view value);

  /**
   * @see https://url.spec.whatwg.org/#dom-urlsearchparams-sort
   */
  inline void sort();

  /**
   * @see https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
   */
  inline std::string to_string() const;

  /**
   * Returns a simple JS-style iterator over all of the keys in this
   * url_search_params. The keys in the iterator are not unique. The valid
   * lifespan of the iterator is tied to the url_search_params. The iterator
   * must be freed when you're done with it.
   * @see https://url.spec.whatwg.org/#interface-urlsearchparams
   */
  inline url_search_params_keys_iter get_keys();

  /**
   * Returns a simple JS-style iterator over all of the values in this
   * url_search_params. The valid lifespan of the iterator is tied to the
   * url_search_params. The iterator must be freed when you're done with it.
   * @see https://url.spec.whatwg.org/#interface-urlsearchparams
   */
  inline url_search_params_values_iter get_values();

  /**
   * Returns a simple JS-style iterator over all of the entries in this
   * url_search_params. The entries are pairs of keys and corresponding values.
   * The valid lifespan of the iterator is tied to the url_search_params. The
   * iterator must be freed when you're done with it.
   * @see https://url.spec.whatwg.org/#interface-urlsearchparams
   */
  inline url_search_params_entries_iter get_entries();

  /**
   * C++ style conventional iterator support. const only because we
   * do not really want the params to be modified via the iterator.
   */
  inline auto begin() const { return params.begin(); }
  inline auto end() const { return params.end(); }
  inline auto front() const { return params.front(); }
  inline auto back() const { return params.back(); }
  inline auto operator[](size_t index) const { return params[index]; }

  /**
   * @private
   * Used to reset the search params to a new input.
   * Used primarily for C API.
   * @param input
   */
  void reset(std::string_view input);

 private:
  typedef std::pair<std::string, std::string> key_value_pair;
  std::vector<key_value_pair> params{};

  /**
   * @see https://url.spec.whatwg.org/#concept-urlencoded-parser
   */
  void initialize(std::string_view init);

  template <typename T, url_search_params_iter_type Type>
  friend struct url_search_params_iter;
};  // url_search_params

/**
 * Implements a non-conventional iterator pattern that is closer in style to
 * JavaScript's definition of an iterator.
 *
 * @see https://webidl.spec.whatwg.org/#idl-iterable
 */
template <typename T, url_search_params_iter_type Type>
struct url_search_params_iter {
  inline url_search_params_iter() : params(EMPTY) {}
  url_search_params_iter(const url_search_params_iter &u) = default;
  url_search_params_iter(url_search_params_iter &&u) noexcept = default;
  url_search_params_iter &operator=(url_search_params_iter &&u) noexcept =
      default;
  url_search_params_iter &operator=(const url_search_params_iter &u) = default;
  ~url_search_params_iter() = default;

  /**
   * Return the next item in the iterator or std::nullopt if done.
   */
  inline std::optional<T> next();

  inline bool has_next();

 private:
  static url_search_params EMPTY;
  inline url_search_params_iter(url_search_params &params_) : params(params_) {}

  url_search_params &params;
  size_t pos = 0;

  friend struct url_search_params;
};

}  // namespace ada
#endif
/* end file include/ada/url_search_params.h */
/* begin file include/ada/url_search_params-inl.h */
/**
 * @file url_search_params-inl.h
 * @brief Inline declarations for the URL Search Params
 */
#ifndef ADA_URL_SEARCH_PARAMS_INL_H
#define ADA_URL_SEARCH_PARAMS_INL_H


#include <algorithm>
#include <optional>
#include <string>
#include <string_view>
#include <vector>

namespace ada {

// A default, empty url_search_params for use with empty iterators.
template <typename T, ada::url_search_params_iter_type Type>
url_search_params url_search_params_iter<T, Type>::EMPTY;

inline void url_search_params::reset(std::string_view input) {
  params.clear();
  initialize(input);
}

inline void url_search_params::initialize(std::string_view input) {
  if (!input.empty() && input.front() == '?') {
    input.remove_prefix(1);
  }

  auto process_key_value = [&](const std::string_view current) {
    auto equal = current.find('=');

    if (equal == std::string_view::npos) {
      std::string name(current);
      std::replace(name.begin(), name.end(), '+', ' ');
      params.emplace_back(unicode::percent_decode(name, name.find('%')), "");
    } else {
      std::string name(current.substr(0, equal));
      std::string value(current.substr(equal + 1));

      std::replace(name.begin(), name.end(), '+', ' ');
      std::replace(value.begin(), value.end(), '+', ' ');

      params.emplace_back(unicode::percent_decode(name, name.find('%')),
                          unicode::percent_decode(value, value.find('%')));
    }
  };

  while (!input.empty()) {
    auto ampersand_index = input.find('&');

    if (ampersand_index == std::string_view::npos) {
      if (!input.empty()) {
        process_key_value(input);
      }
      break;
    } else if (ampersand_index != 0) {
      process_key_value(input.substr(0, ampersand_index));
    }

    input.remove_prefix(ampersand_index + 1);
  }
}

inline void url_search_params::append(const std::string_view key,
                                      const std::string_view value) {
  params.emplace_back(key, value);
}

inline size_t url_search_params::size() const noexcept { return params.size(); }

inline std::optional<std::string_view> url_search_params::get(
    const std::string_view key) {
  auto entry = std::find_if(params.begin(), params.end(),
                            [&key](auto &param) { return param.first == key; });

  if (entry == params.end()) {
    return std::nullopt;
  }

  return entry->second;
}

inline std::vector<std::string> url_search_params::get_all(
    const std::string_view key) {
  std::vector<std::string> out{};

  for (auto &param : params) {
    if (param.first == key) {
      out.emplace_back(param.second);
    }
  }

  return out;
}

inline bool url_search_params::has(const std::string_view key) noexcept {
  auto entry = std::find_if(params.begin(), params.end(),
                            [&key](auto &param) { return param.first == key; });
  return entry != params.end();
}

inline bool url_search_params::has(std::string_view key,
                                   std::string_view value) noexcept {
  auto entry =
      std::find_if(params.begin(), params.end(), [&key, &value](auto &param) {
        return param.first == key && param.second == value;
      });
  return entry != params.end();
}

inline std::string url_search_params::to_string() const {
  auto character_set = ada::character_sets::WWW_FORM_URLENCODED_PERCENT_ENCODE;
  std::string out{};
  for (size_t i = 0; i < params.size(); i++) {
    auto key = ada::unicode::percent_encode(params[i].first, character_set);
    auto value = ada::unicode::percent_encode(params[i].second, character_set);

    // Performance optimization: Move this inside percent_encode.
    std::replace(key.begin(), key.end(), ' ', '+');
    std::replace(value.begin(), value.end(), ' ', '+');

    if (i != 0) {
      out += "&";
    }
    out.append(key);
    out += "=";
    out.append(value);
  }
  return out;
}

inline void url_search_params::set(const std::string_view key,
                                   const std::string_view value) {
  const auto find = [&key](auto &param) { return param.first == key; };

  auto it = std::find_if(params.begin(), params.end(), find);

  if (it == params.end()) {
    params.emplace_back(key, value);
  } else {
    it->second = value;
    params.erase(std::remove_if(std::next(it), params.end(), find),
                 params.end());
  }
}

inline void url_search_params::remove(const std::string_view key) {
  params.erase(
      std::remove_if(params.begin(), params.end(),
                     [&key](auto &param) { return param.first == key; }),
      params.end());
}

inline void url_search_params::remove(const std::string_view key,
                                      const std::string_view value) {
  params.erase(std::remove_if(params.begin(), params.end(),
                              [&key, &value](auto &param) {
                                return param.first == key &&
                                       param.second == value;
                              }),
               params.end());
}

inline void url_search_params::sort() {
  std::stable_sort(params.begin(), params.end(),
                   [](const key_value_pair &lhs, const key_value_pair &rhs) {
                     return lhs.first < rhs.first;
                   });
}

inline url_search_params_keys_iter url_search_params::get_keys() {
  return url_search_params_keys_iter(*this);
}

/**
 * @see https://url.spec.whatwg.org/#interface-urlsearchparams
 */
inline url_search_params_values_iter url_search_params::get_values() {
  return url_search_params_values_iter(*this);
}

/**
 * @see https://url.spec.whatwg.org/#interface-urlsearchparams
 */
inline url_search_params_entries_iter url_search_params::get_entries() {
  return url_search_params_entries_iter(*this);
}

template <typename T, url_search_params_iter_type Type>
inline bool url_search_params_iter<T, Type>::has_next() {
  return pos < params.params.size();
}

template <>
inline std::optional<std::string_view> url_search_params_keys_iter::next() {
  if (!has_next()) {
    return std::nullopt;
  }
  return params.params[pos++].first;
}

template <>
inline std::optional<std::string_view> url_search_params_values_iter::next() {
  if (!has_next()) {
    return std::nullopt;
  }
  return params.params[pos++].second;
}

template <>
inline std::optional<key_value_view_pair>
url_search_params_entries_iter::next() {
  if (!has_next()) {
    return std::nullopt;
  }
  return params.params[pos++];
}

}  // namespace ada

#endif  // ADA_URL_SEARCH_PARAMS_INL_H
/* end file include/ada/url_search_params-inl.h */

// Public API
/* begin file include/ada/ada_version.h */
/**
 * @file ada_version.h
 * @brief Definitions for Ada's version number.
 */
#ifndef ADA_ADA_VERSION_H
#define ADA_ADA_VERSION_H

#define ADA_VERSION "2.9.2"

namespace ada {

enum {
  ADA_VERSION_MAJOR = 2,
  ADA_VERSION_MINOR = 9,
  ADA_VERSION_REVISION = 2,
};

}  // namespace ada

#endif  // ADA_ADA_VERSION_H
/* end file include/ada/ada_version.h */
/* begin file include/ada/implementation.h */
/**
 * @file implementation.h
 * @brief Definitions for user facing functions for parsing URL and it's
 * components.
 */
#ifndef ADA_IMPLEMENTATION_H
#define ADA_IMPLEMENTATION_H

#include <string>
#include <optional>


namespace ada {
enum class errors { generic_error };

template <class result_type = ada::url_aggregator>
using result = tl::expected<result_type, ada::errors>;

/**
 * The URL parser takes a scalar value string input, with an optional null or
 * base URL base (default null). The parser assumes the input is a valid ASCII
 * or UTF-8 string.
 *
 * @param input the string input to analyze (must be valid ASCII or UTF-8)
 * @param base_url the optional URL input to use as a base url.
 * @return a parsed URL.
 */
template <class result_type = ada::url_aggregator>
ada_warn_unused ada::result<result_type> parse(
    std::string_view input, const result_type* base_url = nullptr);

extern template ada::result<url> parse<url>(std::string_view input,
                                            const url* base_url);
extern template ada::result<url_aggregator> parse<url_aggregator>(
    std::string_view input, const url_aggregator* base_url);

/**
 * Verifies whether the URL strings can be parsed. The function assumes
 * that the inputs are valid ASCII or UTF-8 strings.
 * @see https://url.spec.whatwg.org/#dom-url-canparse
 * @return If URL can be parsed or not.
 */
bool can_parse(std::string_view input,
               const std::string_view* base_input = nullptr);

/**
 * Computes a href string from a file path. The function assumes
 * that the input is a valid ASCII or UTF-8 string.
 * @return a href string (starts with file:://)
 */
std::string href_from_file(std::string_view path);
}  // namespace ada

#endif  // ADA_IMPLEMENTATION_H
/* end file include/ada/implementation.h */

#endif  // ADA_H
/* end file include/ada.h */
                                                                                     node-23.7.0/deps/ada/ada_c.h                                                                        0000664 0000000 0000000 00000016265 14746647661 0015447 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /**
 * @file ada_c.h
 * @brief Includes the C definitions for Ada. This is a C file, not C++.
 */
#ifndef ADA_C_H
#define ADA_C_H

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

// This is a reference to ada::url_components::omitted
// It represents "uint32_t(-1)"
#define ada_url_omitted 0xffffffff

// string that is owned by the ada_url instance
typedef struct {
  const char* data;
  size_t length;
} ada_string;

// string that must be freed by the caller
typedef struct {
  const char* data;
  size_t length;
} ada_owned_string;

typedef struct {
  uint32_t protocol_end;
  uint32_t username_end;
  uint32_t host_start;
  uint32_t host_end;
  uint32_t port;
  uint32_t pathname_start;
  uint32_t search_start;
  uint32_t hash_start;
} ada_url_components;

typedef void* ada_url;

// input should be a null terminated C string (ASCII or UTF-8)
// you must call ada_free on the returned pointer
ada_url ada_parse(const char* input, size_t length);
ada_url ada_parse_with_base(const char* input, size_t input_length,
                            const char* base, size_t base_length);

// input and base should be a null terminated C strings
bool ada_can_parse(const char* input, size_t length);
bool ada_can_parse_with_base(const char* input, size_t input_length,
                             const char* base, size_t base_length);

void ada_free(ada_url result);
void ada_free_owned_string(ada_owned_string owned);
ada_url ada_copy(ada_url input);

bool ada_is_valid(ada_url result);

// url_aggregator getters
// if ada_is_valid(result)) is false, an empty string is returned
ada_owned_string ada_get_origin(ada_url result);
ada_string ada_get_href(ada_url result);
ada_string ada_get_username(ada_url result);
ada_string ada_get_password(ada_url result);
ada_string ada_get_port(ada_url result);
ada_string ada_get_hash(ada_url result);
ada_string ada_get_host(ada_url result);
ada_string ada_get_hostname(ada_url result);
ada_string ada_get_pathname(ada_url result);
ada_string ada_get_search(ada_url result);
ada_string ada_get_protocol(ada_url result);
uint8_t ada_get_host_type(ada_url result);
uint8_t ada_get_scheme_type(ada_url result);

// url_aggregator setters
// if ada_is_valid(result)) is false, the setters have no effect
// input should be a null terminated C string
bool ada_set_href(ada_url result, const char* input, size_t length);
bool ada_set_host(ada_url result, const char* input, size_t length);
bool ada_set_hostname(ada_url result, const char* input, size_t length);
bool ada_set_protocol(ada_url result, const char* input, size_t length);
bool ada_set_username(ada_url result, const char* input, size_t length);
bool ada_set_password(ada_url result, const char* input, size_t length);
bool ada_set_port(ada_url result, const char* input, size_t length);
bool ada_set_pathname(ada_url result, const char* input, size_t length);
void ada_set_search(ada_url result, const char* input, size_t length);
void ada_set_hash(ada_url result, const char* input, size_t length);

// url_aggregator clear methods
void ada_clear_port(ada_url result);
void ada_clear_hash(ada_url result);
void ada_clear_search(ada_url result);

// url_aggregator functions
// if ada_is_valid(result) is false, functions below will return false
bool ada_has_credentials(ada_url result);
bool ada_has_empty_hostname(ada_url result);
bool ada_has_hostname(ada_url result);
bool ada_has_non_empty_username(ada_url result);
bool ada_has_non_empty_password(ada_url result);
bool ada_has_port(ada_url result);
bool ada_has_password(ada_url result);
bool ada_has_hash(ada_url result);
bool ada_has_search(ada_url result);

// returns a pointer to the internal url_aggregator::url_components
const ada_url_components* ada_get_components(ada_url result);

// idna methods
ada_owned_string ada_idna_to_unicode(const char* input, size_t length);
ada_owned_string ada_idna_to_ascii(const char* input, size_t length);

// url search params
typedef void* ada_url_search_params;

// Represents an std::vector<std::string>
typedef void* ada_strings;
typedef void* ada_url_search_params_keys_iter;
typedef void* ada_url_search_params_values_iter;

typedef struct {
  ada_string key;
  ada_string value;
} ada_string_pair;

typedef void* ada_url_search_params_entries_iter;

ada_url_search_params ada_parse_search_params(const char* input, size_t length);
void ada_free_search_params(ada_url_search_params result);

size_t ada_search_params_size(ada_url_search_params result);
void ada_search_params_sort(ada_url_search_params result);
ada_owned_string ada_search_params_to_string(ada_url_search_params result);

void ada_search_params_append(ada_url_search_params result, const char* key,
                              size_t key_length, const char* value,
                              size_t value_length);
void ada_search_params_set(ada_url_search_params result, const char* key,
                           size_t key_length, const char* value,
                           size_t value_length);
void ada_search_params_remove(ada_url_search_params result, const char* key,
                              size_t key_length);
void ada_search_params_remove_value(ada_url_search_params result,
                                    const char* key, size_t key_length,
                                    const char* value, size_t value_length);
bool ada_search_params_has(ada_url_search_params result, const char* key,
                           size_t key_length);
bool ada_search_params_has_value(ada_url_search_params result, const char* key,
                                 size_t key_length, const char* value,
                                 size_t value_length);
ada_string ada_search_params_get(ada_url_search_params result, const char* key,
                                 size_t key_length);
ada_strings ada_search_params_get_all(ada_url_search_params result,
                                      const char* key, size_t key_length);
void ada_search_params_reset(ada_url_search_params result, const char* input,
                             size_t length);
ada_url_search_params_keys_iter ada_search_params_get_keys(
    ada_url_search_params result);
ada_url_search_params_values_iter ada_search_params_get_values(
    ada_url_search_params result);
ada_url_search_params_entries_iter ada_search_params_get_entries(
    ada_url_search_params result);

void ada_free_strings(ada_strings result);
size_t ada_strings_size(ada_strings result);
ada_string ada_strings_get(ada_strings result, size_t index);

void ada_free_search_params_keys_iter(ada_url_search_params_keys_iter result);
ada_string ada_search_params_keys_iter_next(
    ada_url_search_params_keys_iter result);
bool ada_search_params_keys_iter_has_next(
    ada_url_search_params_keys_iter result);

void ada_free_search_params_values_iter(
    ada_url_search_params_values_iter result);
ada_string ada_search_params_values_iter_next(
    ada_url_search_params_values_iter result);
bool ada_search_params_values_iter_has_next(
    ada_url_search_params_values_iter result);

void ada_free_search_params_entries_iter(
    ada_url_search_params_entries_iter result);
ada_string_pair ada_search_params_entries_iter_next(
    ada_url_search_params_entries_iter result);
bool ada_search_params_entries_iter_has_next(
    ada_url_search_params_entries_iter result);

#endif  // ADA_C_H
                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/ada/unofficial.gni                                                                 0000664 0000000 0000000 00000001431 14746647661 0017052 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # This file is used by GN for building, which is NOT the build system used for
# building official binaries.
# Please edit the gyp files if you are making changes to build system.

import("../../node.gni")
import("$node_v8_path/gni/v8.gni")

# The actual configurations are put inside a template in unofficial.gni to
# prevent accidental edits from contributors.
template("ada_gn_build") {
  config("ada_config") {
    include_dirs = [ "." ]
  }

  gypi_values = exec_script("../../tools/gypi_to_gn.py",
                            [ rebase_path("ada.gyp") ],
                            "scope",
                            [ "ada.gyp" ])

  source_set(target_name) {
    forward_variables_from(invoker, "*")
    public_configs = [ ":ada_config" ]
    sources = gypi_values.ada_sources
  }
}
                                                                                                                                                                                                                                       node-23.7.0/deps/amaro/                                                                             0000775 0000000 0000000 00000000000 14746647661 0014607 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/amaro/LICENSE.md                                                                   0000664 0000000 0000000 00000002101 14746647661 0016205 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        MIT License

Copyright (c) Marco Ippolito and Amaro contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/amaro/README.md                                                                    0000664 0000000 0000000 00000004222 14746647661 0016066 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Amaro

Amaro is a wrapper around `@swc/wasm-typescript`, a WebAssembly port of the SWC TypeScript parser.
It's currently used as an internal in Node.js for [Type Stripping](https://github.com/nodejs/loaders/issues/208), but in the future it will be possible to be upgraded separately by users.
The main goal of this package is to provide a stable API for TypeScript parser, which is unstable and subject to change.

> Amaro means "bitter" in Italian. It's a reference to [Mount Amaro](https://en.wikipedia.org/wiki/Monte_Amaro_(Abruzzo)) on whose slopes this package was conceived.

## How to Install

To install Amaro, run:

```shell
npm install amaro
```

## How to Use

By default Amaro exports a `transformSync` function that performs type stripping.
Stack traces are preserved, by replacing removed types with white spaces.

```javascript
const amaro = require('amaro');
const { code } = amaro.transformSync("const foo: string = 'bar';", { mode: "strip-only" });
console.log(code); // "const foo         = 'bar';"
```

### Loader

It is possible to use Amaro as an external loader to execute TypeScript files.
This allows the installed Amaro to override the Amaro version used by Node.js.

```bash
node --experimental-strip-types --import="amaro/register" script.ts
```

Or with the alias:

```bash
node --experimental-strip-types --import="amaro/strip" script.ts
```

Enabling TypeScript feature transformation:

```bash
node --experimental-transform-types --import="amaro/transform" script.ts
```

> Note that the "amaro/transform" loader should be used with `--experimental-transform-types` flag, or
> at least with `--enable-source-maps` flag, to preserve the original source maps.

### How to update SWC

To update the SWC version, run:

```shell
./tools/update-swc.sh
git add deps
git commit -m "chore: update swc to vX.Y.Z"
```

Once you have updated the rust source code we must build the wasm.
To build the wasm it is necessary to have Docker installed.

```shell
node ./tools/build-wasm.js
git add lib
git commit -m "chore: build wasm from swc vX.Y.Z"
```

### TypeScript Version

The supported TypeScript version is 5.5.4.

## License (MIT)

See [`LICENSE.md`](./LICENSE.md).
                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/amaro/dist/                                                                        0000775 0000000 0000000 00000000000 14746647661 0015552 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/amaro/dist/LICENSE                                                                 0000664 0000000 0000000 00000025124 14746647661 0016563 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                                                      Apache License
                        Version 2.0, January 2004
                     http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

   "License" shall mean the terms and conditions for use, reproduction,
   and distribution as defined by Sections 1 through 9 of this document.

   "Licensor" shall mean the copyright owner or entity authorized by
   the copyright owner that is granting the License.

   "Legal Entity" shall mean the union of the acting entity and all
   other entities that control, are controlled by, or are under common
   control with that entity. For the purposes of this definition,
   "control" means (i) the power, direct or indirect, to cause the
   direction or management of such entity, whether by contract or
   otherwise, or (ii) ownership of fifty percent (50%) or more of the
   outstanding shares, or (iii) beneficial ownership of such entity.

   "You" (or "Your") shall mean an individual or Legal Entity
   exercising permissions granted by this License.

   "Source" form shall mean the preferred form for making modifications,
   including but not limited to software source code, documentation
   source, and configuration files.

   "Object" form shall mean any form resulting from mechanical
   transformation or translation of a Source form, including but
   not limited to compiled object code, generated documentation,
   and conversions to other media types.

   "Work" shall mean the work of authorship, whether in Source or
   Object form, made available under the License, as indicated by a
   copyright notice that is included in or attached to the work
   (an example is provided in the Appendix below).

   "Derivative Works" shall mean any work, whether in Source or Object
   form, that is based on (or derived from) the Work and for which the
   editorial revisions, annotations, elaborations, or other modifications
   represent, as a whole, an original work of authorship. For the purposes
   of this License, Derivative Works shall not include works that remain
   separable from, or merely link (or bind by name) to the interfaces of,
   the Work and Derivative Works thereof.

   "Contribution" shall mean any work of authorship, including
   the original version of the Work and any modifications or additions
   to that Work or Derivative Works thereof, that is intentionally
   submitted to Licensor for inclusion in the Work by the copyright owner
   or by an individual or Legal Entity authorized to submit on behalf of
   the copyright owner. For the purposes of this definition, "submitted"
   means any form of electronic, verbal, or written communication sent
   to the Licensor or its representatives, including but not limited to
   communication on electronic mailing lists, source code control systems,
   and issue tracking systems that are managed by, or on behalf of, the
   Licensor for the purpose of discussing and improving the Work, but
   excluding communication that is conspicuously marked or otherwise
   designated in writing by the copyright owner as "Not a Contribution."

   "Contributor" shall mean Licensor and any individual or Legal Entity
   on behalf of whom a Contribution has been received by Licensor and
   subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   copyright license to reproduce, prepare Derivative Works of,
   publicly display, publicly perform, sublicense, and distribute the
   Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   (except as stated in this section) patent license to make, have made,
   use, offer to sell, sell, import, and otherwise transfer the Work,
   where such license applies only to those patent claims licensable
   by such Contributor that are necessarily infringed by their
   Contribution(s) alone or by combination of their Contribution(s)
   with the Work to which such Contribution(s) was submitted. If You
   institute patent litigation against any entity (including a
   cross-claim or counterclaim in a lawsuit) alleging that the Work
   or a Contribution incorporated within the Work constitutes direct
   or contributory patent infringement, then any patent licenses
   granted to You under this License for that Work shall terminate
   as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the
   Work or Derivative Works thereof in any medium, with or without
   modifications, and in Source or Object form, provided that You
   meet the following conditions:

   (a) You must give any other recipients of the Work or
       Derivative Works a copy of this License; and

   (b) You must cause any modified files to carry prominent notices
       stating that You changed the files; and

   (c) You must retain, in the Source form of any Derivative Works
       that You distribute, all copyright, patent, trademark, and
       attribution notices from the Source form of the Work,
       excluding those notices that do not pertain to any part of
       the Derivative Works; and

   (d) If the Work includes a "NOTICE" text file as part of its
       distribution, then any Derivative Works that You distribute must
       include a readable copy of the attribution notices contained
       within such NOTICE file, excluding those notices that do not
       pertain to any part of the Derivative Works, in at least one
       of the following places: within a NOTICE text file distributed
       as part of the Derivative Works; within the Source form or
       documentation, if provided along with the Derivative Works; or,
       within a display generated by the Derivative Works, if and
       wherever such third-party notices normally appear. The contents
       of the NOTICE file are for informational purposes only and
       do not modify the License. You may add Your own attribution
       notices within Derivative Works that You distribute, alongside
       or as an addendum to the NOTICE text from the Work, provided
       that such additional attribution notices cannot be construed
       as modifying the License.

   You may add Your own copyright statement to Your modifications and
   may provide additional or different license terms and conditions
   for use, reproduction, or distribution of Your modifications, or
   for any such Derivative Works as a whole, provided Your use,
   reproduction, and distribution of the Work otherwise complies with
   the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise,
   any Contribution intentionally submitted for inclusion in the Work
   by You to the Licensor shall be under the terms and conditions of
   this License, without any additional terms or conditions.
   Notwithstanding the above, nothing herein shall supersede or modify
   the terms of any separate license agreement you may have executed
   with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade
   names, trademarks, service marks, or product names of the Licensor,
   except as required for reasonable and customary use in describing the
   origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or
   agreed to in writing, Licensor provides the Work (and each
   Contributor provides its Contributions) on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied, including, without limitation, any warranties or conditions
   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
   PARTICULAR PURPOSE. You are solely responsible for determining the
   appropriateness of using or redistributing the Work and assume any
   risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory,
   whether in tort (including negligence), contract, or otherwise,
   unless required by applicable law (such as deliberate and grossly
   negligent acts) or agreed to in writing, shall any Contributor be
   liable to You for damages, including any direct, indirect, special,
   incidental, or consequential damages of any character arising as a
   result of this License or out of the use or inability to use the
   Work (including but not limited to damages for loss of goodwill,
   work stoppage, computer failure or malfunction, or any and all
   other commercial damages or losses), even if such Contributor
   has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing
   the Work or Derivative Works thereof, You may choose to offer,
   and charge a fee for, acceptance of support, warranty, indemnity,
   or other liability obligations and/or rights consistent with this
   License. However, in accepting such obligations, You may act only
   on Your own behalf and on Your sole responsibility, not on behalf
   of any other Contributor, and only if You agree to indemnify,
   defend, and hold each Contributor harmless for any liability
   incurred by, or claims asserted against, such Contributor by reason
   of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.

   To apply the Apache License to your work, attach the following
   boilerplate notice, with the fields enclosed by brackets "[]"
   replaced with your own identifying information. (Don't include
   the brackets!)  The text should be enclosed in the appropriate
   comment syntax for the file format. We also recommend that a
   file or class name and description of purpose be included on the
   same "printed page" as the copyright notice for easier
   identification within third-party archives.

Copyright 2024 SWC contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/amaro/dist/errors.js                                                               0000664 0000000 0000000 00000000742 14746647661 0017427 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        "use strict";
export function isSwcError(error) {
  return error.code !== void 0;
}
export function wrapAndReThrowSwcError(error) {
  switch (error.code) {
    case "UnsupportedSyntax": {
      const unsupportedSyntaxError = new Error(error.message);
      unsupportedSyntaxError.name = "UnsupportedSyntaxError";
      throw unsupportedSyntaxError;
    }
    case "InvalidSyntax":
      throw new SyntaxError(error.message);
    default:
      throw new Error(error.message);
  }
}
                              node-23.7.0/deps/amaro/dist/index.js                                                                0000664 0000000 0000000 00015464176 14746647661 0017247 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        "use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/wasm.js
var require_wasm = __commonJS({
  "lib/wasm.js"(exports2, module2) {
    "use strict";
    var imports = {};
    imports["__wbindgen_placeholder__"] = module2.exports;
    var wasm;
    var { TextDecoder, TextEncoder } = require("util");
    var heap = new Array(128).fill(void 0);
    heap.push(void 0, null, true, false);
    function getObject(idx) {
      return heap[idx];
    }
    var heap_next = heap.length;
    function addHeapObject(obj) {
      if (heap_next === heap.length) heap.push(heap.length + 1);
      const idx = heap_next;
      heap_next = heap[idx];
      heap[idx] = obj;
      return idx;
    }
    function handleError(f, args) {
      try {
        return f.apply(this, args);
      } catch (e) {
        wasm.__wbindgen_export_0(addHeapObject(e));
      }
    }
    var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
    cachedTextDecoder.decode();
    var cachedUint8ArrayMemory0 = null;
    function getUint8ArrayMemory0() {
      if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
      }
      return cachedUint8ArrayMemory0;
    }
    function getStringFromWasm0(ptr, len) {
      ptr = ptr >>> 0;
      return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
    }
    function getCachedStringFromWasm0(ptr, len) {
      if (ptr === 0) {
        return getObject(len);
      } else {
        return getStringFromWasm0(ptr, len);
      }
    }
    function dropObject(idx) {
      if (idx < 132) return;
      heap[idx] = heap_next;
      heap_next = idx;
    }
    function takeObject(idx) {
      const ret = getObject(idx);
      dropObject(idx);
      return ret;
    }
    function isLikeNone(x) {
      return x === void 0 || x === null;
    }
    var CLOSURE_DTORS = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((state) => {
      wasm.__wbindgen_export_1.get(state.dtor)(state.a, state.b);
    });
    function makeMutClosure(arg0, arg1, dtor, f) {
      const state = { a: arg0, b: arg1, cnt: 1, dtor };
      const real = (...args) => {
        state.cnt++;
        const a = state.a;
        state.a = 0;
        try {
          return f(a, state.b, ...args);
        } finally {
          if (--state.cnt === 0) {
            wasm.__wbindgen_export_1.get(state.dtor)(a, state.b);
            CLOSURE_DTORS.unregister(state);
          } else {
            state.a = a;
          }
        }
      };
      real.original = state;
      CLOSURE_DTORS.register(real, state, state);
      return real;
    }
    function debugString(val) {
      const type = typeof val;
      if (type == "number" || type == "boolean" || val == null) {
        return `${val}`;
      }
      if (type == "string") {
        return `"${val}"`;
      }
      if (type == "symbol") {
        const description = val.description;
        if (description == null) {
          return "Symbol";
        } else {
          return `Symbol(${description})`;
        }
      }
      if (type == "function") {
        const name = val.name;
        if (typeof name == "string" && name.length > 0) {
          return `Function(${name})`;
        } else {
          return "Function";
        }
      }
      if (Array.isArray(val)) {
        const length = val.length;
        let debug = "[";
        if (length > 0) {
          debug += debugString(val[0]);
        }
        for (let i = 1; i < length; i++) {
          debug += ", " + debugString(val[i]);
        }
        debug += "]";
        return debug;
      }
      const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
      let className;
      if (builtInMatches && builtInMatches.length > 1) {
        className = builtInMatches[1];
      } else {
        return toString.call(val);
      }
      if (className == "Object") {
        try {
          return "Object(" + JSON.stringify(val) + ")";
        } catch (_) {
          return "Object";
        }
      }
      if (val instanceof Error) {
        return `${val.name}: ${val.message}
${val.stack}`;
      }
      return className;
    }
    var WASM_VECTOR_LEN = 0;
    var cachedTextEncoder = new TextEncoder("utf-8");
    var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    function passStringToWasm0(arg, malloc, realloc) {
      if (realloc === void 0) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr2 = malloc(buf.length, 1) >>> 0;
        getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr2;
      }
      let len = arg.length;
      let ptr = malloc(len, 1) >>> 0;
      const mem = getUint8ArrayMemory0();
      let offset = 0;
      for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 127) break;
        mem[ptr + offset] = code;
      }
      if (offset !== len) {
        if (offset !== 0) {
          arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
      }
      WASM_VECTOR_LEN = offset;
      return ptr;
    }
    var cachedDataViewMemory0 = null;
    function getDataViewMemory0() {
      if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
      }
      return cachedDataViewMemory0;
    }
    module2.exports.transform = function(input, options) {
      const ret = wasm.transform(addHeapObject(input), addHeapObject(options));
      return takeObject(ret);
    };
    module2.exports.transformSync = function(input, options) {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.transformSync(retptr, addHeapObject(input), addHeapObject(options));
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    };
    function __wbg_adapter_38(arg0, arg1, arg2) {
      wasm.__wbindgen_export_4(arg0, arg1, addHeapObject(arg2));
    }
    function __wbg_adapter_57(arg0, arg1, arg2, arg3) {
      wasm.__wbindgen_export_5(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
    }
    module2.exports.__wbg_buffer_61b7ce01341d7f88 = function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_call_500db948e69c7330 = function() {
      return handleError(function(arg0, arg1, arg2) {
        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_call_b0d8e36992d9900d = function() {
      return handleError(function(arg0, arg1) {
        const ret = getObject(arg0).call(getObject(arg1));
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_entries_4f2bb9b0d701c0f6 = function(arg0) {
      const ret = Object.entries(getObject(arg0));
      return addHeapObject(ret);
    };
    module2.exports.__wbg_get_9aa3dff3f0266054 = function(arg0, arg1) {
      const ret = getObject(arg0)[arg1 >>> 0];
      return addHeapObject(ret);
    };
    module2.exports.__wbg_getwithrefkey_1dc361bd10053bfe = function(arg0, arg1) {
      const ret = getObject(arg0)[getObject(arg1)];
      return addHeapObject(ret);
    };
    module2.exports.__wbg_instanceof_ArrayBuffer_670ddde44cdb2602 = function(arg0) {
      let result;
      try {
        result = getObject(arg0) instanceof ArrayBuffer;
      } catch (_) {
        result = false;
      }
      const ret = result;
      return ret;
    };
    module2.exports.__wbg_instanceof_Uint8Array_28af5bc19d6acad8 = function(arg0) {
      let result;
      try {
        result = getObject(arg0) instanceof Uint8Array;
      } catch (_) {
        result = false;
      }
      const ret = result;
      return ret;
    };
    module2.exports.__wbg_length_65d1cd11729ced11 = function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    };
    module2.exports.__wbg_length_d65cf0786bfc5739 = function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    };
    module2.exports.__wbg_new_3d446df9155128ef = function(arg0, arg1) {
      try {
        var state0 = { a: arg0, b: arg1 };
        var cb0 = (arg02, arg12) => {
          const a = state0.a;
          state0.a = 0;
          try {
            return __wbg_adapter_57(a, state0.b, arg02, arg12);
          } finally {
            state0.a = a;
          }
        };
        const ret = new Promise(cb0);
        return addHeapObject(ret);
      } finally {
        state0.a = state0.b = 0;
      }
    };
    module2.exports.__wbg_new_3ff5b33b1ce712df = function(arg0) {
      const ret = new Uint8Array(getObject(arg0));
      return addHeapObject(ret);
    };
    module2.exports.__wbg_new_688846f374351c92 = function() {
      const ret = new Object();
      return addHeapObject(ret);
    };
    module2.exports.__wbg_newnoargs_fd9e4bf8be2bc16d = function(arg0, arg1) {
      var v0 = getCachedStringFromWasm0(arg0, arg1);
      const ret = new Function(v0);
      return addHeapObject(ret);
    };
    module2.exports.__wbg_queueMicrotask_2181040e064c0dc8 = function(arg0) {
      queueMicrotask(getObject(arg0));
    };
    module2.exports.__wbg_queueMicrotask_ef9ac43769cbcc4f = function(arg0) {
      const ret = getObject(arg0).queueMicrotask;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_resolve_0bf7c44d641804f9 = function(arg0) {
      const ret = Promise.resolve(getObject(arg0));
      return addHeapObject(ret);
    };
    module2.exports.__wbg_set_23d69db4e5c66a6e = function(arg0, arg1, arg2) {
      getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    };
    module2.exports.__wbg_set_3f1d0b984ed272ed = function(arg0, arg1, arg2) {
      getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
    };
    module2.exports.__wbg_static_accessor_GLOBAL_0be7472e492ad3e3 = function() {
      const ret = typeof global === "undefined" ? null : global;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    };
    module2.exports.__wbg_static_accessor_GLOBAL_THIS_1a6eb482d12c9bfb = function() {
      const ret = typeof globalThis === "undefined" ? null : globalThis;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    };
    module2.exports.__wbg_static_accessor_SELF_1dc398a895c82351 = function() {
      const ret = typeof self === "undefined" ? null : self;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    };
    module2.exports.__wbg_static_accessor_WINDOW_ae1c80c7eea8d64a = function() {
      const ret = typeof window === "undefined" ? null : window;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    };
    module2.exports.__wbg_then_0438fad860fe38e1 = function(arg0, arg1) {
      const ret = getObject(arg0).then(getObject(arg1));
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_boolean_get = function(arg0) {
      const v = getObject(arg0);
      const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
      return ret;
    };
    module2.exports.__wbindgen_cb_drop = function(arg0) {
      const obj = takeObject(arg0).original;
      if (obj.cnt-- == 1) {
        obj.a = 0;
        return true;
      }
      const ret = false;
      return ret;
    };
    module2.exports.__wbindgen_closure_wrapper7374 = function(arg0, arg1, arg2) {
      const ret = makeMutClosure(arg0, arg1, 687, __wbg_adapter_38);
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_debug_string = function(arg0, arg1) {
      const ret = debugString(getObject(arg1));
      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
      const len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    module2.exports.__wbindgen_error_new = function(arg0, arg1) {
      const ret = new Error(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_in = function(arg0, arg1) {
      const ret = getObject(arg0) in getObject(arg1);
      return ret;
    };
    module2.exports.__wbindgen_is_falsy = function(arg0) {
      const ret = !getObject(arg0);
      return ret;
    };
    module2.exports.__wbindgen_is_function = function(arg0) {
      const ret = typeof getObject(arg0) === "function";
      return ret;
    };
    module2.exports.__wbindgen_is_object = function(arg0) {
      const val = getObject(arg0);
      const ret = typeof val === "object" && val !== null;
      return ret;
    };
    module2.exports.__wbindgen_is_string = function(arg0) {
      const ret = typeof getObject(arg0) === "string";
      return ret;
    };
    module2.exports.__wbindgen_is_undefined = function(arg0) {
      const ret = getObject(arg0) === void 0;
      return ret;
    };
    module2.exports.__wbindgen_jsval_loose_eq = function(arg0, arg1) {
      const ret = getObject(arg0) == getObject(arg1);
      return ret;
    };
    module2.exports.__wbindgen_memory = function() {
      const ret = wasm.memory;
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_number_get = function(arg0, arg1) {
      const obj = getObject(arg1);
      const ret = typeof obj === "number" ? obj : void 0;
      getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
    };
    module2.exports.__wbindgen_object_clone_ref = function(arg0) {
      const ret = getObject(arg0);
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_object_drop_ref = function(arg0) {
      takeObject(arg0);
    };
    module2.exports.__wbindgen_string_get = function(arg0, arg1) {
      const obj = getObject(arg1);
      const ret = typeof obj === "string" ? obj : void 0;
      var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);
      var len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    module2.exports.__wbindgen_string_new = function(arg0, arg1) {
      const ret = getStringFromWasm0(arg0, arg1);
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    var { Buffer: Buffer2 } = require("node:buffer");
    var bytes = Buffer2.from("AGFzbQEAAAABzgRJYAJ/fwBgAX8AYAJ/fwF/YAN/f38Bf2ADf39/AGABfwF/YAR/f39/AGAFf39/f38AYAZ/f39/f38AYAR/f39/AX9gAAF/YAd/f39/f39/AGADf39/AX5gA39+fwBgBX9/f39/AX9gAX8BfmACf38BfmAHf39/f39/fwF/YAN/fn4AYAN/fn4Bf2AAAGAAAX5gBn9/f39/fwF/YAJ+fwBgAn9+AGABfgF+YAJ+fgBgBH9+f38AYAR/f39+AGADf39+AX9gAX4AYAR/fH9/AX9gDX9/f39/f39/f39/f38AYAJ/fABgBn9/f39+fwBgD39/f39/f39/f39/f39/fwF/YAR/f35/AGAGf39/fn9/AGADf35/AX9gAn9+AX9gBH5+f38BfmADfn9/AGACfn8Bf2ACfn4BfmADf39+AGAOf39/f39/f39/f39/f38Bf2AIf39/f39/f38Bf2AJf39/f39/f39/AGAEf35/fgF+YAl/f39/f39+fn4AYAV/f39/fwF8YAF8AXxgBn9/fn9+fwBgA35/fwF/YAF/AXxgBX9/f39+AGADf39/AXxgF39/f39/f39/f39/f39/f39/f39/f39/AX9gE39/f39/f39/f39/f39/f39/f38Bf2ALf39/f39/f39/f38Bf2AEf39/fABgAXwBf2AEfn5+fwF+YAR/fn5/AGAEf39/fwF8YAd+fn5/f39/AX5gAn5/AX5gA398fwBgBX9/fX9/AGAEf31/fwBgBX9/fH9/AGAEf3x/fwBgBX9/fn9/AALnEisYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fFl9fd2JpbmRnZW5fYm9vbGVhbl9nZXQABRhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18VX193YmluZGdlbl9zdHJpbmdfbmV3AAIYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fFV9fd2JpbmRnZW5fc3RyaW5nX2dldAAAGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxRfX3diaW5kZ2VuX2lzX3N0cmluZwAFGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxRfX3diaW5kZ2VuX2lzX29iamVjdAAFGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxdfX3diaW5kZ2VuX2lzX3VuZGVmaW5lZAAFGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXw1fX3diaW5kZ2VuX2luAAIYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld18zZDQ0NmRmOTE1NTEyOGVmAAIYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fE19fd2JpbmRnZW5faXNfZmFsc3kABRhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18kX193YmdfZ2V0d2l0aHJlZmtleV8xZGMzNjFiZDEwMDUzYmZlAAIYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2xlbmd0aF9kNjVjZjA3ODZiZmM1NzM5AAUYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX2dldF85YWEzZGZmM2YwMjY2MDU0AAIYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld182ODg4NDZmMzc0MzUxYzkyAAoYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF8zZjFkMGI5ODRlZDI3MmVkAAQYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fIF9fd2JnX25ld25vYXJnc19mZDllNGJmOGJlMmJjMTZkAAIYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fG19fd2JnX2NhbGxfYjBkOGUzNjk5MmQ5OTAwZAACGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXy1fX3diZ19zdGF0aWNfYWNjZXNzb3JfR0xPQkFMXzBiZTc0NzJlNDkyYWQzZTMAChhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18yX193Ymdfc3RhdGljX2FjY2Vzc29yX0dMT0JBTF9USElTXzFhNmViNDgyZDEyYzliZmIAChhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18tX193Ymdfc3RhdGljX2FjY2Vzc29yX1dJTkRPV19hZTFjODBjN2VlYThkNjRhAAoYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fK19fd2JnX3N0YXRpY19hY2Nlc3Nvcl9TRUxGXzFkYzM5OGE4OTVjODIzNTEAChhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18bX193YmdfY2FsbF81MDBkYjk0OGU2OWM3MzMwAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2xlbmd0aF82NWQxY2QxMTcyOWNlZDExAAUYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEV9fd2JpbmRnZW5fbWVtb3J5AAoYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2J1ZmZlcl82MWI3Y2UwMTM0MWQ3Zjg4AAUYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld18zZmY1YjMzYjFjZTcxMmRmAAUYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF8yM2Q2OWRiNGU1YzY2YTZlAAQYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JpbmRnZW5fb2JqZWN0X2Ryb3BfcmVmAAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fG19fd2JpbmRnZW5fb2JqZWN0X2Nsb25lX3JlZgAFGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxRfX3diaW5kZ2VuX2Vycm9yX25ldwACGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxlfX3diaW5kZ2VuX2pzdmFsX2xvb3NlX2VxAAIYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fFV9fd2JpbmRnZW5fbnVtYmVyX2dldAAAGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXyxfX3diZ19pbnN0YW5jZW9mX1VpbnQ4QXJyYXlfMjhhZjViYzE5ZDZhY2FkOAAFGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXy1fX3diZ19pbnN0YW5jZW9mX0FycmF5QnVmZmVyXzY3MGRkZGU0NGNkYjI2MDIABRhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18eX193YmdfZW50cmllc180ZjJiYjliMGQ3MDFjMGY2AAUYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fF19fd2JpbmRnZW5fZGVidWdfc3RyaW5nAAAYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cAABhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18bX193YmdfdGhlbl8wNDM4ZmFkODYwZmUzOGUxAAIYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fJV9fd2JnX3F1ZXVlTWljcm90YXNrXzIxODEwNDBlMDY0YzBkYzgAARhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18lX193YmdfcXVldWVNaWNyb3Rhc2tfZWY5YWM0Mzc2OWNiY2M0ZgAFGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxZfX3diaW5kZ2VuX2lzX2Z1bmN0aW9uAAUYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHl9fd2JnX3Jlc29sdmVfMGJmN2M0NGQ2NDE4MDRmOQAFGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXxJfX3diaW5kZ2VuX2NiX2Ryb3AABRhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18eX193YmluZGdlbl9jbG9zdXJlX3dyYXBwZXI3Mzc0AAMDmy6ZLggIAAAABAYEBAQGBgQEBwcHERYGBh8ABgQEAAYHAgQEAAAAAAAEBAAAAggEAAAACAcHBAADBQQEBgYECAQABgIAAgYAAAsLCAAGBgACBgIGAAYGBgkAAAAIBAQIBgAAAAACAA4JICAABgYGBAQCAgcICAQEAgAABAgABAcLAAcAAAYAAAgICCEAAAUCBQYEAAYEAAQiIgcLCAYEAgEEAAQAAAMAAAIEBAsEBggACwAABxEHBwcHAAAHAgAABwAAAAAEBAQAAAQABAgCBgAAAA4FBgYFCQYCBgQBBAAABgYAAAECBQABAQEIAAgABAIIBwUHAAQEAAoAAQABAAEEBAsHAQQGAAAABwQBBAEEBgcGAAEDAQEIBgECBgAAAQIHBgAIAAEABAAEAQQEAAQEAAQGAQEBAQEBBwcDAQEBAAYGAAYGAAABAAAACwkBCwAJBAAAAAQEBSMABwICCy0HAwIEAAAAAAYEBgYGAAUBBAkCBAsLAAELCAIABQEAAAEDAwcAAQAABwIBAC4AEQYCAAEFAAAACQAGBAYABAQEAAkAAAcIBwYAAQAABAQCAQEEAQcAAAIGBQEABwEBBgIEAwMHAAAHHwIBBgAEAwcHAAAABAQAAgICAAUAABYDAAgIAgYBBggEAC8DAA4DCQEBAQAAAAQEBgQGAwgGAAYGAAMDBgAAAgEAAAMIBAAEAgAEAAQGBgAEAAADAgAACAgGAQQEGwQAAgkAAQAIAAAAAAAAAAABAQACABYIBgYABgIAADAAAQQCAQEBAQEBAQEAAQEDAQAIAwIBAQEAAgQCAQEBAQEBAQEBAQEBARYAAAAABAQAAQEEAAQLAAIAAAcABAAAAwEBBgsHAQAABwYDARICAQEJAAQCCAAAAAIECAcABQUFAAEBAQEBAAEBAQEEBQYEAAIBBwEAFwEAAAQBAgYCBAQDAAcAAAAAAAAAAAgABAIxBAACCAAAAQAEBwUEAAAABAIAAgEABAQGAgQECggGGwYGAQQEAgEAAAQCBgYDAAQRAAAEAAAAAQAGAQYAADIGBAAGBgYCBQQCFgQFBQUAAgIEBAAHAQABMwIEAgYAAAQECAUAAAIGBhEAADQEBAAABgIBAQEBAQ4EBQQLDwEkAzUcBAYHBQIEBgcCAAIICAMAAgQCAwgEAAADAgc2AAcAAQEEAQAABwQCAgAEAAYIBAAEAgAABwcGBgIFAgABAAQEBAAAAgIAAQAABAAEBAYGAAAENwAAAQACAAIBBwEICQQBBwIGBgIAAgMBBgQFASUAAQACAAAABAAACQICAgkCAwAAADgEAQgAAAACBQgAAQEIAAQEBwMDCAIACQQAAQUCBAAIAAgEDwAEACUCAAQABA0AAAEFAQMIAAEAAQACBAQJBAAADwICAQAmAQEAAAEABAgRAgcABAANBAAABgIHAgQAAgACAgEAAQECBAQBAgAEAAQEAgYGAAEAAQUABAQAAQICBAIAAAgIAgAABgEAAQIEAQAIAAYEBAAAAgAACAQJCQMEAAAAAAEACAgABAQBBAECAAEEBgAACQAAAAECAgABAhgBBAMBAAYEAAEGAQAAAAQAAAEBAQEBAQQBAAAGBAQDDwEBAAQFAAEBAgcBAQIGBAABAAACBAQGBgAEBAMBBAYAGAACBAAIOQEHAAQAAAMABAYBAQIEBAIHBgIACQgBAgAEAAQACAQABAICBAECAAEFEQYDAgICADoJEAQDAQQACQACBAYAAQEEBAEADgABAgcAAAABAgQAAwYCBgACBQIGBwQAAAIjAgADBgQCAgIBAQMCAAYCCwIEBAQGAAYEAAABBgYnAAAABgIEAwADBAAEBQQIAgIAOwAAAQUEBQEJAAYFCAYGBgMFAAAAAAMLAwAABQUICAAGAgIEAAAAAAADAAUAAAACEQQCAgABAgIAAgQAAQEBAQAAAAAABQUABRgOEAYGAgIBBgYCAAYAAAYGAgECAgEAAQEBBggFBQUAAAAAAAABAAABBAUEAAAAAAAGAQAAAAMGBgMAAgAFDwIAAAAAAAAAAAAABAQBBwUEBQIAAAUCAgICAAAAAAECAAIFBgIAAAAFAAICAQMHAAAFAAIAAgICAgABAwMEAAsABQIAAAUBAAECAQIACwICAgICAgICAgICAgICAgIBAAQCAQYBAAAEAgAAAAACAgICAgkAAAAJAgICAgACAgAGBAAEBAICAgIAAAQCAgICAgICAgICAgICAgICAgUAAAAAAAAAAAQGBgYAAAUFBQAFAAoCBQIEAwYAAAAAAgIBBAYCBQEFBQUGBAkCBQICGAIAAAABCAABCAEIBgYBAAECAAABBwEDAgIDCAwHCQACAQIAAgACAgEBAAACAAYCDQ4AAQIAAAQFBAAGBAAGBAUAAgQAAQABAAcCPAAFAAAAAAAAAAMAEgcDBAAABAAGAgA9BgAAAwQHCAg+AAIFBgYGBggCBQkAAQABBAUEAAAAAQUFAQgDHQAAAgUCAgABBQUAAgAEAAUCAAQBCQUEAQAFAwAFBQgABQEEBQMHCQAFBAUFAgAFAAAAAAYAAAYABwQABQIACAICAAIoKAACBQMAAAAAAAAABQAAAAAAAAAAAAAAAAIDAAAAAAAABAAIBAACAQAAAAAGAAABBAQACQAABQAAABICAAUAAAUBAQAABgICAgICAQAGAQIHBAAHAAkGAAAHAQECAgICAgICAgICAgIABwAAAAAHAAICBQQEBAQABAQEAAQIAAMCAAUBAAAAAQgAAAABAAEBAgAIBQUFBQkECQcBBAIAAwABHQADBQEAAh0BBgACAAECAAQABQICAQMHAwICAgAFAQQAAQYGBgIBAQEBAQEBAQEBBAIAAQACBAABBgMBAQAEAgUPAQACAgICAgICAgICAAANAAAAAAAFABQAAD8AAAAEAQkJBQAFAQAHAgICAgIAAAAAAQAAAAYAAAEEAgICCAYAAAAGAgIBAAUEAgIFBQQABQUEAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUAAgUADQIABAMBAAAGAAEBAQEBAAAAAAEBAAEAAAAAAQEBAQABAAYBAAACAAIEAgEZAAAHAgMIAQABAQcBAQAAAAAABAQFAgABAgICAgIBAAABAAUEBAQCAAAABgACBAAAAgICAgYAAgICAAACAgICAgICAgAAABAAAAUABAICAgICAgABBQACBAEAAAAECQAFBAIDAQAIAAUGAAQEBAQFAgABAAcEBAUFAAECAgcHAAECAgICAgICAgIDAgAABwcEAQEFAgICAgICAgICAgICAgICAgICAgICAgAAAAAAAA8BAQAAAAAAAgQEAgICAgQAAAQEAgUCAAECBQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAABAAAAAQABAAEGAAACBgAEBAIFAQgKBQQHAgICAQICAQICAgICAgIBKQECAAEBAQEBAQECBwEBAAQCAgEEAAEBAAAAAgIABAQBAAYBBAQAAAMEBQUFBQQGBgACAgABAAAFBQABAQEEAAQAAAADBgoBAAYEAAQAAQcDBAQAAQAAAQQBAQAAAAAAAAABAAcGBAEEAAYEAQUBAAUABAEPAAEBBgAEAQANBQEAAQACAgIABgIAAAAAAAAAAAADAAgAAQADAggFAQEEAAUEAQECAgIBAAEBAQABAAEBAQEBAQIAAgICAQICAgICBAQCAgEEAQICAQECAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgEFAAEAAQEBAQEBAQQBBQABEAEBAQEIAQEDAwEBAQIBAAABAQEBBAIBBQEHAQoBAQBAAAEAAAAAAAAAAAAAAAAAAAICAgcCAgIBAgAABwIJBgECAgICAgICAggAAgICAAEHAQIAAgECAgEBAgEBAQEBAAAAAQEBAQUBAQEBAQEBAQEAAQAAAQICAgEBAQABAQEBAQEBAAAABwAAAAUABAEFAQQBBQEFAAAAAAUCAAAAAQIAAAABAAABQQICAQEAAgACAg0BBAAFBAAEAAkIBAQCAAYCAgIFAQUFAwUFBQUFBQUFBQEBAQEBAQEBAAEqAQEBAQUBAQEBBQEAAQEBAgACCwYAABUEBAEJBAkABAcDBQIEAAEAHgEBAQEBAQEBAAAAAQANAAAAAAEBAQwBAAAAAAAAAAEBAQEBAQEBAAEBAQEEAAAAAAEBAAEBBQIEAg8GAgICBAkGAQEACwIAAQUADAwDAgQAAQEBAQEFCQUCBgICBgUBAQEBAQABAAEBAQEBBgATEwUCAgUAAwYOAgAAAAECAgQAAAICAAAAAAQCAgUFAQICAAAAAAAAAAIMBgYGBgICAgICAgICAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwcCBwQCAgEQEAUCAgAGAgICAgIFAAICBgACAgICBgQCAgAABQAeDAYZAQIAAAICAQEBAgEBAQIAAgEBDQAAAQEBAQEBAQEBAQEFAQEBAQEBEgETAgACABQUAQIBARQUAAAhAAUDFBQFAgEBAgMCAgICCQAYAgICAgICAgACAgMCAgAAAQIFBQABBQAFAQIBARcAAAIFAgICBwcFAgIGAgIGBwICAgICAgICAAICAAQHAgAHAAQCAwIBAgUFBwcCBQEDBQIrAgIFAQEBAQEBAAEBAAIFAAAFAgICAAEBAQEAQgAAAAAAAQEBAQAAACkAAAEFAQEBBQUBAQEAAQEBBgAEAAMAAAAEBwAAAAABAQkABQAAAAAABQQrAAABAAAABAUAAAAABQEABQICBAACAQEAAQABBAAEBBIAAQECHAcFABAAAQEBDAAAAgcGAgcFAQEBAQEBBgEAAAUAARwFAA0BAQEBAQEBAQEAAAQEAgEAAgIFAAICASwBJAIJAQICAgABAQcCAgEAAAICAgIBAAABAAoBAQoAAAICAgsGBAQFAQEEAAQCAgICCwIGBgYCAgkAAAAAAAEBAQUBAQYGBgYBAQAAAAABAQEBAQICAgEDAAAAAQcGBAUJAgYCAQEHBwEEAgUFBioCAgwGAAAAAQUCAgICAgUABgICAQEAAAAAAQACBgAAAAAAAQgCAAEAAAAHAAAACQIBAQEBAQAAAAAGAQUAAAEBAAAJAwUCAAEDAwYAAAAAAQEQAQEAAAMAAAAAAAAABAIAAAAZAAAAAAABAAAAAABDAAABABAAAAAAAAADCQkJCQEJAwcHAQEWAwkEAwMsAQMDAwMHAwkCGAkCCQYCBQwABQQCDAEBAAwCAQkECQEAAQkEAQUEAAEHDkRGSAADAQEFBQUQAQkEAgICAwQEBgYGCQEBAQECDAEBAAEBAQEBAQEBAQQAAAQGAAUTBAQKCgICCQITBgABAQEBAAUAAgEFAAAAAAAXBQIFAQEBAQEKAQEBAQEBAQACAgIBAAEBAgUBAQQFAQEBAQQEBQQEBAUBAgUEBAABAAIDCQAEAwECAAUCAgQDBwQMAQEBAQUFAQEFAQEBAQEKAQEMAQEBAQAAAAEAAAEBAAEMAQEAAQEBAQEBAQEBAQoBAQEBAQEBAQoFAQEFAQEAAQEEBAIBAQQBCQkBAgICBQQDAgABAQEBBQEBAQECAQEBBgYBAQEBAQEBAQEBAQAAAAEAAQAABAAAAAAEBAAAAAEBAQEBAQEAAAAAAAAAAQEBAAAAAAAAAAAAAAEBAQEMBAEBAQEBAQEBAQEBAQEBAQEAAAEBAQEBAQABBAEBAQAAAAAAAAAAAAABAQEAAQEBAQEGAAECAQEAAQEBBwMBAQABAAABAAQBBAIBCgoKCgoKCgoKCgoKAAoBAQABAQEBDwoCBQEBAQEBAQEBAQEBDAwAAAEBAQEAAAABAQIBAQEAAAAABQECAgICAgUKAwEABAQDBwIMAgUZAAEBFwENAQEBAQEBAQEFAQQBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAEAAAACAAAAAAAAAAABAQAAAQAAAQIBAQABAAABAQEBAQEBAQEBAAACAAAAAAAAAAAAAAAAAAAAAAABAQICAgICAgICAQQAABIDAAICAgQCAgICEgACAQAEAgICAAIEAQEBAQIBAQEBAQEBAQEAAQUBAQEBAQEBAQEBAQIBAQEBAQECAgICBgICAgIFBQEBAQEBAQEBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQABAQEBAQABAQEBAQAAAAAAAAABAQEBAQEBAQEAAAABAQEBAQEBAQAAAAEBAQEBAQEBAQEAAAAAAQEBAAAAAQEBAQAAAQEBAQEAAAEBAQEBAQABAQEBAQEBAQEEAwEDAAAAAAAEAAAAAAAAAAAAAAAAAAABAQEBAQEBAQIBAgUFBQMFAgcBAAEBAQECBQEAAQMBBgEBAQEBAQEBAQEeAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEJAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAEBAQEBAQEBAQEBAQEBAQEaAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEB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QShBCBCrICIDIAU2AgggAyAENgIEIAMgDjYCACADIAIpA4AGNwIMIANBFGogAkGIBmopAwA3AgAgA0EcaiACQZAGaikDADcCACADQSRqIAJBmAZqKAIANgIAIAJB2AZqEM8XIAEoApwDIQQgAigC9AIhBiAuIAJB2AVqQSgQ+wYaIAJBgAdqIAJB6ARqKQMANwMAIAJB+AZqIAJB4ARqKQMANwMAIA8gFykDADcDACAmICUpAgA3AgAgJkEIaiAlQQhqKQIANwIAICZBEGogJUEQaikCADcCACACIAIpA9AENwPoBkHwAEEIEKsgIg4gAkHoBmpB4AAQ+wYiBSADNgJoIAUgBiAEIAQgBkkbNgJkIAUgBiAEIAQgBksbNgJgEO4mIAIoArwFEN0oIC0Q+yYMBQsgAkHQBGoQnxYMBgsgAkHoBmoQhyULAkACQAJAIAcQyg0iBgRAIAYoAgBBCUYNAQsgDyAHEJEQIAJBEGogBxCFFCACQfDl3wA2AuwGIAJBNDoA6AYgAigCECACKAIUIAJB6AZqEIEVIQQgBxDKDSIDRQ0BIAMoAgBBJEcNASABIAEpA+ACNwOYAyABKALIAiABQSU2AsgCQSRHDRIgASABKALMAhD/CwwBCyANIAwpAgA3AgAgASgCyAIhBiABQSU2AsgCIAEgASkD4AI3A5gDIA1BCGoiECAMQQhqIhIpAgA3AgAgDUEQaiIYIAxBEGoiKigCADYCACACIAY2AugGIAJB6AZqEMYKIAJBADoA2wcgAkEBOgDdByACIAItAI8IOgDPByACIAItAMwFOgDQByACIAEtALACOgDOByACIAEtAL4COgDcByACIAEtAMYCOgDkByACIAEoAaoCNgDIByACIAEvAa4COwDMByACIAEpALMCNwDRByACIAEvALsCOwDZByACIAEoAsACNgDeByACIAEvAcQCOwDiByALQRVqIAQpAAA3AAAgC0EQaiADKQEANwEAIAtBCGogBSkBADcBACALIBMpAQA3AQAgByACQcgHahDSCCACIAE2AugGIAJBuAZqIAEQswEgAigCvAYhBiACKAK4BiIrQYCAgIB4RwRAAkAgAigCwAYiCUUNAEEAIQUgBiEDIAkhBANAIAMQ9BUgBWohBSADQUBrIQMgBEEBayIEDQALIAVFDQAgAigC5AMhBCACKALgAyED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EhDHCiACQQA6AOsFIAJBAToA7QUgAiACLQDYBjoA3wUgAiACLQCQBDoA4AUgAiABLQCIAzoA3gUgAiABLQCWAzoA7AUgAiABLQCeAzoA9AUgAiABKAGCAzYA2AUgAiABLwGGAzsA3AUgAiABKQCLAzcA4QUgAiABLwCTAzsA6QUgAiABKAKYAzYA7gUgAiABLwGcAzsA8gUgC0EVaiADKQAANwAAIAtBEGogECkBADcBACALQQhqIBYpAQA3AQAgCyATKQEANwEAIBcgAkHYBWoQyQggAiABNgLoBiACQagDaiABELQBIAIoAqwDIQMgAigCqAMiBEGAgICAeEcEQCACIAIoArADIhA2AsAGIAIgAzYCvAYgAiAENgK4BiASEKMmAkACQCAHEOMNIgQEQCAEKAIAQQpGDQELIA8gBxCWCyACQfgBaiAHELgUIAJByOXfADYC7AYgAkE0OgDoBiACKAL4ASACKAL8ASACQegGahCBFSEEIAcQ4w0iA0UNASADKAIAQSRHDQEgASABKQNANwN4IAEoAiggAUElNgIoQSRHDREgASABKAIsEIYMDAELIA0gDCkCADcCACABKAIoIQQgAUElNgIoIAEgASkDQDcDeCAFIAgpAgA3AgAgCSARKAIANgIAIAIgBDYC6AYgAkHoBmoQxwpBACEEAkAgAS0A+AJBAkcNACAHEOMNIgVFDQAgBSgCAEETRw0AIAJBgAJqIAFBoODfABDzASACKAKEAiEEIAIoAoACDQELIAIgBDYCgAYgAkHoBmogASACLQDYBiACLQCQBCADIBAQxRkQqwMgAigC7AYhCCACKALoBiIWQYGAgIB4RwRAIB0gHykCADcDACACIA8pAgA3A6gDIAEtAPgCQQJHIBZBgICAgHhHcg0EIBBBBnQhBQNAIAVFDQUgAygCAEEERgRAIAMoAhAhCSADKAIMIREgAkGpAToA6AYgASARIAkgAkHoBmoQ2BkLIANBQGshAyAFQUBqIQUMAAsACyACQYAGahCRKCAIIQQLIAJBuAZqEPwmDAELIAJB6AZqEKMmIAMhBAsgChDdKAwBCyAVIAIpAugDNwIAIBVBCGogAkHwA2ooAgA2AgAgDyACQcAGaigCADYCACACIAIpArgGNwPoBiABKAJ8IQkgAigCoAYhESACLQCQBCEFIAItANgGIRBByABB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EUkbIS9BASErQgAhZ0IAIWkMBQsgESACKALMCiIDIAMgEUsbIS4gESADIAMgEUkbIS8gAikD0AohZSACKQPICiFmIAIoAsQKIQ0gAkGAA2ogBSkCADcDACACQfYCaiBALQAAOgAAIAIgPykCADcD+AIgAiA+LwAAOwH0AiACKALACiEHIAIoArgDIQMgAi0AzAMhBSACKQP4BhD5GkIAIWlBACErQgAhZwwJCyARIAEoApwDIgMgAyARSxshLiARIAMgAyARSRshL0EBIStCAiFpQgAhZyACKQOIByFlIAIpA4AHIWYgAigC/AYhDSACKAL4BiEHIAwhAyAQIQUMAwsgAikD+AYQ+RoLQgILIWcgDCEDIBAhBSAOIQ0gayFmIGwhZQsgAikDwAoQ+RogZ0ICUQ0MDAQLIAIpA4gHIWUgAikDgAchZiACKAL8BiENIAIoAvgGIQcgAikDwAoQ+RpBAQwBCyACKQPQCiFlIAIpA8gKIWYgAigCxAohDSACKALACiEHQQALIStCACFnC0ICIWkCQCAIEMoNIgVFDQAgBSgCAEECRw0AIAUtAAgNACAFLQAJQQFHDQAgICALKQIANwIAIAEoAsgCIQMgAUElNgLIAiABIAEpA+ACNwOYAyAgQQhqIE8pAgA3AgAgIEEQaiBQKAIANgIAIAIgAzYCoAcgAkGgB2oiAxDGCiADIAEQsAQgAigCqAchAyACKQOgByJpQgJSBEAgAkHgBmogTkEIaikCADcDACACQbYDaiBUQQJqLQAAOgAAIAIgTikCADcD2AYgAiBULwAAOwG0AyACLQC8ByEtDAELIAetIA2tQiCGhCFmIGdQBEAgZhD5GiADIQcMCgsgZiBlEIwrIAMhBwwJCyACQYADaiACQeAGaikDADcDACACQfYCaiACQbYDai0AADoAACACIAIpA9gGNwP4AiACIAIvAbQDOwH0AiARIAEoApwDIgUgBSARSxshLiARIAUgBSARSRshLyAtIQULIFMgAikD+AI3AgAgUiACLwH0AjsAACBTQQhqIAJBgANqKQMANwIAIFJBAmogAkH2AmotAAA6AAAgAiADNgLIByACIGk3A8AHIAIgZTcDuAcgAiBmNwOwByACIA02AqwHIAIgBToA3AcgAiArOgDoByACIC82AuQHIAIgLjYC4AcgUSACKADtAjYAACBR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DQkgCiABIAQgBxDZCCADKAKAAyIFQSpGBEAgBkEBayEGIAIhBQwBCwsgAEEEaiADQYADakEEckE8EPsGGiAAIAU2AgAMGQsgACABIAggBBC3BgwYCyAAIAEgAigCCCACKAIMIAIoAhAgAigCBBDAAgwXCyADIAIoAggiBTYC8AIgAyAFIAIoAgxBHGxqNgL0AiADIAE2AvgCAkAgAS0AC0EBcUUEQCADQfAAaiADQfACahDGGwwBCyADQfAAaiADQfACahDoGgsgAygCcCIFQStHDQELIAAgARDdEQwVCyADKAJ4IQIgAygCdCEEIAVBKkcNAiADQdQBaiEIA0ACQCABLQALQQFxRQRAIANByAFqIANB8AJqEMYbDAELIANByAFqIANB8AJqEOgaCyADKALIASIGQStGBEAgACACNgIIIAAgBDYCBCAAQSo2AgAMFgsgAygC0AEhBSADKALMASEHIAZBKkcNAiADQYADaiABIAIgBxDZCCADKAKAAyICQSpGBEAgBSECDAELCyAAQQRqIANBgANqQQRyQTwQ+wYaIAAgAjYCAAwUCyACKAIIIgUgAigCDCIHQRxsaiEMAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAdFDQAgBSECIAchBgNAIAQgAigCAEEBRmohBCACQRxqIQIgBkEBayIGDQALIARBAkkNACAEIAdPDQELIAMgATYC+AIgAyAMNgL0AiADIAU2AvACIANBgANqIANB8AJqEIUcIAMoAoADIgJBK0YEQCAAIAEQxAwMHwsgAygCiAMhBiADKAKEAyEHIAJBKkcNCiADQYADaiADQfACahCFHCADKAKAAyICQStGBEAgACAGNgIIIAAgBzYCBCAAQSo2AgAMHwsgAygCiAMhCCADKAKEAyEKIAJBKkcNCSADQYADaiICIAEQ+RIgAygChAMhBSADKAKAAyIEQSpHDQggAiABELEXIAMoAoQDIQQgAygCgAMiCUEqRw0HIAIgASAFIAcQ2QggAygCgAMiB0EqRw0GIAIgASAGIAQQ2QggAygCgAMiBkEqRw0FIAIgASAFIAoQ2QggAygCgAMiBkEqRw0EIAIgASAIIAQQ2QggAygCgAMiAkEqRw0DIANB+ABqIANB+AJqKAIANgIAIAMgAykC8AI3A3AgA0HUAWohCANAIANByAFqIANB8ABq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BSADQegCaiADQdgCai0AADoAACADIAMpANACIiY3A+ACQQIhAgJAAkACQAJAAkACQCAmp0H/AXFBAWsOAwIAAQMLQQMhAgwBC0EEIQILIANBKGogAkEBdiIFIBogBUGA9eAAELMeIAMoAiwhByADKAIoIQkgA0EgaiAFIBogAkEBdGogAkEGcSIIayAFQZD14AAQsx4gAygCICAIakECayEEQQAhAiADKAIkIQogByEGIAVBAWsiDiEFA0AgAiAIRg0BIAZFDQIgCiAOSwRAIAIgCWoiCy8AACENIAsgBC8AADsAACAEIA07AAAgBkEBayEGIARBAmshBCAFQQFrIQUgAkECaiECDAELCyAFIApBsPXgABCsEAALIANBGGogA0HgAmoQtyAgASkCrAEhJiADKAIcIQIgAygCGCEFIAFCgICAgMAANwKsASABQQA2ArQBIANBADYCyAMgAyAmNwPAAyADQYADaiIEQQEgBSACEMcNIANBwANqIAQQ6hUCQAJAA0AgAygCyAMiAkUNBCADIAJBAWsiAjYCyAMgA0H4AGogAygCxAMgAkEEdGoiAkEIaikCACImNwMAIAMgAikCADcDcCADLQB8IgJBBEsNAiACRQ0BIAJBAWshEiADLQBxIQUgAy0AcCEKIBAgJqciExD5HSICKAIEIQdBACELIAIoAggiBiECAkADQCACIAtNDQEgBiACIAtqQQF2IgRLBEAgBEEBaiALIAcgBEEDdGotAAUgCkH/AXFJIggbIQsgAiAEIAgbIQIMAQsLIAQgBkHsr8MAEKwQAAsgECATEPkdKAIIIAtGBEAgECADQcADaiAUIBIQ4RghAiAWKAIAIBUoAgAgEyAKIAUgAhDEEgwBCwNAIBAgExD5HSICKAIEIAIoAgggC0G8rsMAELofIgctAAUhCAJAIAVB/wFxIgYgBy0ABCIETwRAIApB/wFxIgIgCE0NAQsgECADQcADaiAUIBIQ4RghAiAWKAIAIBUoAgAgCyATIAogBSACEOwMDAELIAcoAgAhDgJAAkACQAJ/AkACQAJAAkACQAJAAkACfwJAIAIgBEcNACAGIAhHBEAgBiAITQ0BIAhBAWpB/wFxQQh0IAVBEHRyQQFyIQ0gCEEIdCACcgwCCyAFQQh0IAJyIQJBAiEEQQAhBUEBIQZBASERQQAhB0EAIQlBACENDAwLAkAgBiAIRiIHIAIgBE8iCUVxRQRAIAYgCEkiFyINIAIgBEZxDQEgAiAETSIRQQEgBxtFDQMgBiAISyIHIAlFcQ0EIBFBASANG0UNBSAEIAZPIglFIAIgCEZxDQYgAiAISSINIAQgBkZxDQcgByANcQ0IIBcgCUVxDQlB5ezgAEEoQeSwwwAQ9BcAC0ECIREgBEEIdCIEIAVBEHRyQQJyIQ0gAiAEckGAAmshAkEBIQRBACEGQQAhBUEAIQdBACEJDAwLIAhBEHQgBUEBakH/AXFBCHRyIQ0gBUEIdCACcgshAkECIRFBACEGQQAhBUEAIQdBACEJQQIhBAwKC0ECIREgBUEQdCACQQh0ckECciENIApBCHQgBHJBgAJrIQJBACEGQQAhBUEAIQcMCAsgBEEIdCIEIAhBEHRyQQJyIQ0gAiAEckGAAmshAkEBIQkgCEEBaiEHQQMhEUEAIQZBASEEDAgLIAJBCHQgBUEQdHJBAnIhDSAFQQFqIQcgCkEIdCAEckGAAmshAkEAIQZBAyERIAghBQwGC0EBIQkgCkEBaiEHIAJBgIIEbEECciENDAQLQQEhBCAFQQFqIQcgBkGAggRsQQJyIQ0gBUEIdCACckGAAmsMAgsgCEEQdCACQQh0ckECciENQQEhCSAIQQFqIQcMAgsgBEEIdCIGIAVBEHRyQQJyIQ1BASEEIAVBAWohByACIAZyQYACawshAkEAIQZBAyERIAghBUEAIQkMAgsgCkEIdCAEckGAAmshAkEAIQZBAyERQQAhBAwBC0EAIQlBACEECyAfIAU6AAAgICACQQh2OgAAIAMgDTsAzwEgISANQRB2OgAAIAMgETYCyAEgAyAHQQh0IAlyOwHSASADIAJBCHQgBHI7AcwBIAYEQCASRQ0CIANBgANqIgIgDiAUIBIQxw0gA0HAA2ogAhDqFQwCCyAPIBFBA2xqISNBACEHQQEhCCAPIQYDQCAGICNGDQIgB0EBaiEHIAYtAAIhBSAGLQABIQoCQAJAAkACQAJAAkACQAJAIAYtAABBAWsOAgECAAsgDkUEQEEAIQQMBwsgAUEANgKoASABKQKgASEmIAFCgICAgMAANwKgASADQQA2AtgDIAMgJjcD0AMgA0HQA2ogDiAQEMILIgQQ4BgDQCADKALYAyICRQ0FIAMgAkEBayICNgLYAyADKALUAyACQQN0aiICKAIEIQkgECACKAIAIiQQ+R0oAgghJUEAIQIDQCACICVGDQEgECAkEPkdIg0oAgQgDSgCCCACQayvwwAQuh8iDS0ABSEbIA0tAAQhHAJAIA0oAgAiFwRAIBAQwgshDSAWKAIAIBUoAgAgCSAcIBsgDRDEEiADQdADaiAXIA0Q4BgMAQsgFigCACAVKAIAIAkgHCAbQQAQxBILIAJBAWohAgwACwALAAsgECATEPkdIQIgByARRw0EIAsgAigCCCIESQ0BDAQLIA4hBCASDQEMBAsgAigCBCAEIAtBzK7DABC6HyICLQAEIAVB/wFxSw0CIAItAAUgCkH/AXFPDQUMAgsgA0GAA2oiAiAOIBQgEhDHDSADQcADaiACEOoVDAILIAEoAqABICIoAgAQ5SkgGEEIaiADQdgDaigCADYCACAYIAMpA9ADNwIADAELIBAgA0HAA2ogFCASEOEYIQQLIBUoAgAhAiAWKAIAIQkCQAJAIAhFBEAgCSACIAsgEyAKIAUgBBDsDAwBCyAJIAIgExDPHyICKAIIIgggC00NASACKAIEIAtBA3RqIgIgBToABSACIAo6AAQgAiAENgIAQQAhCAsgBkEDaiEGIAtBAWohCwwBCwsLCyALIAhBvK/DABCsEAALQdi6wwBBJEHcrsMAEPQXAAsgAkEEQdSwwwAQrhAAC0EBIAdBoPXgABCsEAALIAEoAqwBIB4oAgAQ7SkgGUEIaiADQcgDaigCADYCACAZIAMpA8ADNwIADAELAAsACwsgAEEQaiADQZADakEwEPsGGiAAQQxqIAIoAgA2AgAgACADKQPIATcCBAwIC0GcrsMAEO8UAAtBjK7DABDvFAALQcC2wwAQ7xQACyADQQA2AogDIANCADcDgAMgA0EAOwGMAyADQcgBaiADQYADaiABKALoARDzByABKALcASABQeABaigCABDtKSAFQQhqIANB0AFqKAIANgIAIAUgAykCyAE3AgAMBQtBkLfDABDvFAALIABBEGogA0GQA2pBMBD7BhogAEEMaiAEKAIANgIAIAAgAykDyAE3AgQgACAGNgIADAQLIANBgANqIAEQsRcgAygChAMhBSADKAKAAyIEQSpGBEAgA0G8AWogAigCECIEEJkSIARBAXQhBCAFrSEmIAIoAgwhAgNAIAQEQCADQbwB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OBCOBAJAIAMtAChBBEcEQCADKQMoIhVC/wGDQgRSDQELIANBKGogASAELQBIEI8IIAMtAChBBEcEQCADKQMoIhVC/wGDQgRSDQELAkAgBC0AREUNACADQQA2AiggA0E4aiABIANBKGpBnsXgAEEGELITIAMtADhBBEcEQCADKQM4IhVC/wGDQgRSDQILIANBKGogARDQESADLQAoQQRGDQAgAykDKCIVQv8Bg0IEUg0BCwJAIAQtAEVFDQAgA0EANgIoIANBOGogASADQShqQYq34ABBCBCyEyADLQA4QQRHBEAgAykDOCIVQv8Bg0IEUg0CCyADQShqIAEQ0BEgAy0AKEEERg0AIAMpAygiFUL/AYNCBFINAQsCQCAELQBGRQ0AIANBADYCKCADQThqIAEgA0EoakHcxOAAQQgQshMgAy0AOEEERwRAIAMpAzgiFUL/AYNCBFINAgsgA0EoaiABENARIAMtAChBBEYNACADKQMoIhVC/wGDQgRSDQELIANBADYCQCADQShqIAEgA0FAa0Gau+AAQQgQshMgAy0AKEEERwRAIAMpAygiFUL/AYNCBFINAQsgA0EoaiABENARIAMtAChBBEcEQCADKQMoIhVC/wGDQgRSDQELAkACQCAEQQhqIgIoAgBBBUYEQCADQShqIARBEGogARCnByADLQAoQQRGDQIgAykDKCIVQv8Bg0IEUg0BDAILIANBKGogASACEL8EIAMtAChBBEYNASADKQMoIhVC/wGDQgRRDQELIBVC/wGDQgRSDQELAkAgBCgCQEUNAAJAIAQtAEdFDQAgA0EoaiABIANBQGtBh7DgAEEBELITIAMtAChBBEYNACADKQMoIhVC/wGDQgRSDQILIANBKGogASADQUBrQeS14ABBARCyEyADLQAoQQRHBEAgAykDKCIVQv8Bg0IEUg0CCyADQShqIAEQ0BEgAy0AKEEERwRAIAMpAygiFUL/AYNCBFINAgsgA0EoaiAEQUBrIAEQ3g0gAy0AKEEERg0AIAMpAygiFUL/AYNCBFINAQsCQCAEKAI8RQ0AAkAgAS0ATQ0AIANBKGogARDQESADLQAoQQRGDQAgAykDKCIVQv8Bg0IEUg0CCyADQShqIAEgA0FAa0GZsOAAQQEQshMgAy0AKEEERwRAIAMpAygiFUL/AYNCBFINAgsCQCABLQBN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0BEgAy0AKEEERg0AIAMpAygiFUL/AYNCBFINAQsCQCAELQA1RQ0AIANBADYCKCADQThqIAEgA0EoakGKt+AAQQgQshMgAy0AOEEERwRAIAMpAzgiFUL/AYNCBFINAgsgA0EoaiABENARIAMtAChBBEYNACADKQMoIhVC/wGDQgRSDQELAkAgBC0AN0UNACADQQA2AiggA0E4aiABIANBKGpB3MTgAEEIELITIAMtADhBBEcEQCADKQM4IhVC/wGDQgRSDQILIANBKGogARDQESADLQAoQQRGDQAgAykDKCIVQv8Bg0IEUg0BCwJAAkACQAJAAkACQAJAAkACQCAELQA4QQFrDgIAAQILIANBADYCKCADQThqIAEgA0EoakGYxeAAQQMQshMgAy0AOEEERwRAIAMpAzgiFUL/AYNCBFINCQtBASAHKAIAdEEVcQ0CIAEtAE0NAyADQShqIAEQ0BEgAy0AKEEERg0DIAMpAygiFUL/AYNCBFENAwwICyADQQA2AiggA0E4aiABIANBKGpBm8XgAEEDELITIAMtADhBBEcEQCADKQM4IhVC/wGDQgRSDQgLQQEgBygCAHRBFXENAyABLQBNDQQgA0EoaiABENARIAMtAChBBEYNBCADKQMoIhVC/wGDQgRRDQQMBwsgBS0ARUUNBCADQQA2AiggA0E4aiABIANBKGpBvLngAEEFELITIAMtADhBBEcEQCADKQM4IhVC/wGDQgRSDQcLIANBKGogARDQESADLQAoQQRGDQQgAykDKCIVQv8Bg0IEUQ0EDAYLIANBKGogARDQESADLQAoQQRGDQAgAykDKCIVQv8Bg0IEUg0FCyADQShqIAEgBxC/BCADLQAoQQRGDQMgAykDKCIVQv8Bg0IEUQ0DDAQLIANBKGogARDQESADLQAoQQRGDQAgAykDKCIVQv8Bg0IEUg0DCyADQShqIAEgBxC/BCADLQAoQQRGDQEgAykDKCIVQv8Bg0IEUg0CDAELAkAgBS0AREUNACADQQA2AiggA0E4aiABIANBKGpB17DgAEEBELITIAMtADhBBEYNACADKQM4IhVC/wGDQgRSDQILIANBKGogASAHEL8EIAMtAChBBEYNACADKQMoIhVC/wGDQgRSDQELAkAgBC0ANkUNACADQQA2AiggA0E4aiABIANBKGpB47XgAEEBELIT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AiABKAIAIQMgBEGUA2ohASAEQawBaiEFAkADQAJAIARBqAFqIAMQlQwgBCgCqAEiAkEQRg0AIAEgBSkCADcCACABQRBqIAVBEGopAgA3AgAgAUEIaiIGIAVBCGopAgA3AgAgBCACNgKQAwJAAkACQAJAAkACQAJAAkACQAJAIAJBB2tBACACQQhPG0EBaw4IAAECAwQFBgcICyAEQYADaiAGKAIANgIAIAQgASkCADcD+AIgBEHIAmogBEH4AmoQ3BAMCAsgBEEBNgKsASAEQYTKxAA2AqgBIARCADcCtAEgBCAEQdAAajYCsAEgBEGoAWpBjMrEABDDHQALIARBATYCrAEgBEHsysQANgKoASAEQgA3ArQBIAQgBEHQAGo2ArABIARBqAFqQfTKxAAQwx0ACyAEQQE2AqwBIARB1MvEADYCqAEgBEIANwK0ASAEIARB0ABqNgKwASAEQagBakHcy8QAEMMdAAsgBEEBNgKsASAEQbjMxAA2AqgBIARCADcCtAEgBCAEQdAAajYCsAEgBEGoAWpBwMzEABDDHQALIARBATYCrAEgBEGkzcQANgKoASAEQgA3ArQBIAQgBEHQAGo2ArABIARBqAFqQazNxAAQwx0ACyAEQQg2AsgCDAILIARBATYCrAEgBEGUzsQANgKoASAEQgA3ArQBIAQgBEHQAGo2ArABIARBqAFqQZzOxAAQwx0ACyAEQeACaiAEQagDaigCADYCACAEQdgCaiAEQaADaikCADcDACAEQdACaiAEQZgDaikCADcDACAEIAQpApADNwPIAgsgAkEJTwRAIARBkANqEPwUCyAEKALIAkEIRg0CIARBqAFqIAMQlQwgBCgCqAFBEEYNDSAEQagDaiAEQcABaigCADYCACAEQaADaiAEQbgBaikCADcDACAEQZgDaiAEQbABaikCADcDACAEIAQpAqgBIhY3A5ADIBanQQ9HDQ4gBEGQA2oQ/BQgBEG8AmogBEHIAmoQuhAMAQsLIARBCDYCyAILIARByAJqEOYkIAQoAsACIAQoAsQCEKkIIARBqAFqIgEgBEG8AmoQWSADIAEQoRgMEwsgBEEANgKcAiAEQoCAgIDAADcClAIgASgCACEFIARBlANqIQEgBEGsAWohAwNAIARBqAFqIAUQlQwCQAJAIAQoAqgBIgJBEEcEQCABIAMpAgA3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QdgmahD9GQsgCC0AAQRAQQAgBigCABCKBCENQd2f2gBBFBDcGiFCIANB+MjfAEEBENwaNwNYIANCADcDYCADQeAmaiIEIANB2ABqEKUcIANBQGsiDCAEKQMANwMAIANByABqIg8gA0HoJmopAwA3AwAgA0HQAGoiByADQfAmaikDADcDACADQgA3AzhB8Z/aAEEjENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpAzg3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQACBEBBACAGKAIAEIoEIQ1BlKDaAEERENwaIUIgA0H4yN8AQQEQ3Bo3A4gBIANCADcDkAEgA0HgJmoiBCADQYgBahClHCADQfAAaiIMIAQpAwA3AwAgA0H4AGoiDyADQegmaikDADcDACADQYABaiIHIANB8CZqKQMANwMAIANCADcDaEGloNoAQSAQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykDaDcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtAAMEQEEAIAYoAgAQigQhDUHFoNoAQRQQ3BohQiADQfjI3wBBARDcGjcDuAEgA0IANwPAASADQeAmaiIEIANBuAFqEKUcIANBoAFqIgwgBCkDADcDACADQagBaiIPIANB6CZqKQMANwMAIANBsAFqIgcgA0HwJmopAwA3AwAgA0IANwOYAUHZoNoAQSMQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykDmAE3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQAEBEBBACAGKAIAEIoEIQ1B/KDaAEEYENwaIUIgA0H4yN8AQQEQ3Bo3A+gBIANCADcD8AEgA0HgJmoiBCADQegBahClHCADQdABaiIMIAQpAwA3AwAgA0HYAWoiDyADQegmaikDADcDACADQeABaiIHIANB8CZqKQMANwMAIANCADcDyAFBlKHaAEEnENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA8gBNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0ABQRAQQAgBigCABCKBCENQbuh2gBBEBDcGiFCIANB+MjfAEEBENwaNwOYAiADQgA3A6ACIANB4CZqIgQgA0GYAmoQpRwgA0GAAmoiDCAEKQMANwMAIANBiAJqIg8gA0HoJmopAwA3AwAgA0GQAmoiByADQfAmaikDADcDACADQgA3A/gBQcuh2gBBHxDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQP4ATcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtAAYEQEEAIAYoAgAQigQhDUHqodoAQRkQ3BohQiADQfjI3wBBARDcGjcDyAIgA0IANwPQAiADQeAmaiIEIANByAJqEKUcIANBsAJqIgwgBCkDADcDACADQbgCaiIPIANB6CZqKQMANwMAIANBwAJqIgcgA0HwJmopAwA3AwAgA0IANwOoAkGDotoAQSgQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykDqAI3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQAHBEBBACAGKAIAEIoEIQ1Bq6LaAEEPENwaIUIgA0H4yN8AQQEQ3Bo3A/gCIANCADcDgAMgA0HgJmoiBCADQfgCahClHCADQeACaiIMIAQpAwA3AwAgA0HoAmoiDyADQegmaikDADcDACADQfACaiIHIANB8CZqKQMANwMAIANCADcD2AJBuqLaAEEeENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA9gCNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0ACARAQQAgBigCABCKBCENQdii2gBBExDcGiFCIANB+MjfAEEBENwaNwOoAyADQgA3A7ADIANB4CZqIgQgA0GoA2oQpRwgA0GQA2oiDCAEKQMANwMAIANBmANqIg8gA0HoJmopAwA3AwAgA0GgA2oiByADQfAmaikDADcDACADQgA3A4gDQeui2gBBIhDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQOIAzcDACAEQUBrQQA6AAAgA0EBNgLk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AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0ADgRAQQAgBigCABCKBCENQbCl2gBBGxDcGiFCIANB+MjfAEEBENwaNwPIBSADQgA3A9AFIANB4CZqIgQgA0HIBWoQpRwgA0GwBWoiDCAEKQMANwMAIANBuAVqIg8gA0HoJmopAwA3AwAgA0HABWoiByADQfAmaikDADcDACADQgA3A6gFQcul2gBBKhDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQOoBTcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtAA8EQEEAIAYoAgAQigQhDUH1pdoAQRsQ3BohQiADQfjI3wBBARDcGjcD+AUgA0IANwOABiADQeAmaiIEIANB+AVqEKUcIANB4AVqIgwgBCkDADcDACADQegFaiIPIANB6CZqKQMANwMAIANB8AVqIgcgA0HwJmopAwA3AwAgA0IANwPYBUGQptoAQSoQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykD2AU3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQAQBEBBACAGKAIAEIoEIQ1BuqbaAEEeENwaIUIgA0H4yN8AQQEQ3Bo3A6gGIANCADcDsAYgA0HgJmoiBCADQagGahClHCADQZAGaiIMIAQpAwA3AwAgA0GYBmoiDyADQegmaikDADcDACADQaAGaiIHIANB8CZqKQMANwMAIANCADcDiAZB2KbaAEEtENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA4gGNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0AEQRAQQAgBigCABCKBCENQYWn2gBBERDcGiFCIANB+MjfAEEBENwaNwPYBiADQgA3A+AGIANB4CZqIgQgA0HYBmoQpRwgA0HABmoiDCAEKQMANwMAIANByAZqIg8gA0HoJmopAwA3AwAgA0HQBmoiByADQfAmaikDADcDACADQgA3A7gGQZan2gBBIBDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQO4BjcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtABIEQEEAIAYoAgAQigQhDUG2p9oAQSwQ3BohQiADQfjI3wBBARDcGjcDiAcgA0IANwOQByADQeAmaiIEIANBiAdqEKUcIANB8AZqIgwgBCkDADcDACADQfgGaiIPIANB6CZqKQMANwMAIANBgAdqIgcgA0HwJmopAwA3AwAgA0IANwPoBkHip9oAQTsQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykD6AY3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQATBEBBACAGKAIAEIoE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IANBkAlqIgwgBCkDADcDACADQZgJaiIPIANB6CZqKQMANwMAIANBoAlqIgcgA0HwJmopAwA3AwAgA0IANwOICUGOq9oAQS0Q3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykDiAk3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQAZBEBBACAGKAIAEIoEIQ1Bu6vaAEEYENwaIUIgA0H4yN8AQQEQ3Bo3A9gJIANCADcD4AkgA0HgJmoiBCADQdgJahClHCADQcAJaiIMIAQpAwA3AwAgA0HICWoiDyADQegmaikDADcDACADQdAJaiIHIANB8CZqKQMANwMAIANCADcDuAlB06vaAEEnENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA7gJNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0AGgRAQQAgBigCABCKBCENQfqr2gBBGxDcGiFCIANB+MjfAEEBENwaNwOICiADQgA3A5AKIANB4CZqIgQgA0GICmoQpRwgA0HwCWoiDCAEKQMANwMAIANB+AlqIg8gA0HoJmopAwA3AwAgA0GACmoiByADQfAmaikDADcDACADQgA3A+gJQZWs2gBBKhDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQPoCTcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtABsEQEEAIAYoAgAQigQhDUG/rNoAQRkQ3BohQiADQfjI3wBBARDcGjcDuAogA0IANwPACiADQeAmaiIEIANBuApqEKUcIANBoApqIgwgBCkDADcDACADQagKaiIPIANB6CZqKQMANwMAIANBsApqIgcgA0HwJmopAwA3AwAgA0IANwOYCkHYrNoAQSgQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykDmAo3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQAcBEBBACAGKAIAEIoEIQ1BgK3aAEEaENwaIUIgA0H4yN8AQQEQ3Bo3A+gKIANCADcD8AogA0HgJmoiBCADQegKahClHCADQdAKaiIMIAQpAwA3AwAgA0HYCmoiDyADQegmaikDADcDACADQeAKaiIHIANB8CZqKQMANwMAIANCADcDyApBmq3aAEEpENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA8gKNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0AHQRAQQAgBigCABCKBCENQcOt2gBBGRDcGiFCIANB+MjfAEEBENwaNwOYCyADQgA3A6ALIANB4CZqIgQgA0GYC2oQpRwgA0GAC2oiDCAEKQMANwMAIANBiAtqIg8gA0HoJmopAwA3AwAgA0GQC2oiByADQfAmaikDADcDACADQgA3A/gKQdyt2gBBKBDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQP4CjcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtAB4EQEEAIAYoAgAQigQhDUGErtoAQSQQ3BohQiADQfjI3wBBARDcGjcDyAsgA0IANwPQCyADQeAmaiIEIANByAtqEKUcIANBsAtqIgwgBCkDADcDACADQbgLaiIPIANB6CZqKQMANwMAIANBwAtqIgcgA0HwJmopAwA3AwAgA0IANwOoC0GortoAQTMQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykDqAs3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQAfBEBBACAGKAIAEIoEIQ1B267aAEEkENwaIUIgA0H4yN8AQQEQ3Bo3A/gLIANCADcDgAwgA0HgJmoiBCADQfgLahClHCADQeALaiIMIAQpAwA3AwAgA0HoC2oiDyADQegmaikDADcDACADQfALaiIHIANB8CZqKQMANwMAIANCADcD2AtB/67aAEEzENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA9gLNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0AIARAQQAgBigCABCKBCENQbKv2gBBIhDcGiFCIANB+MjfAEEBENwaNwOoDCADQgA3A7AMIANB4CZqIgQgA0GoDGoQpRwgA0GQDGoiDCAEKQMANwMAIANBmAxqIg8gA0HoJmopAwA3AwAgA0GgDGoiByADQfAmaikDADcDACADQgA3A4gMQdSv2gBBMRDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQOIDDcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtACEEQEEAIAYoAgAQigQhDUGFsNoAQQoQ3BohQiADQfjI3wBBARDcGjcD2AwgA0IANwPgDCADQeAmaiIEIANB2AxqEKUcIANBwAxqIgwgBCkDADcDACADQcgMaiIPIANB6CZqKQMANwMAIANB0AxqIgcgA0HwJmopAwA3AwAgA0IANwO4DEGPsNoAQRkQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykDuAw3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQAiBEBBACAGKAIAEIoEIQ1BqLDaAEENENwaIUIgA0H4yN8AQQEQ3Bo3A4gNIANCADcDkA0gA0HgJmoiBCADQYgNahClHCADQfAMaiIMIAQpAwA3AwAgA0H4DGoiDyADQegmaikDADcDACADQYANaiIHIANB8CZqKQMANwMAIANCADcD6AxBtbDaAEEcENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA+gMNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0AIwRAQQAgBigCABCKBCENQdGw2gBBCRDcGiFCIANB+MjfAEEBENwaNwO4DSADQgA3A8ANIANB4CZqIgQgA0G4DWoQpRwgA0GgDWoiDCAEKQMANwMAIANBqA1qIg8gA0HoJmopAwA3AwAgA0GwDWoiByADQfAmaikDADcDACADQgA3A5gNQdqw2gBBGBDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQOYDTcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtACQEQEEAIAYoAgAQigQhDUHysNoAQQkQ3BohQiADQfjI3wBBARDcGjcD6A0gA0IANwPwDSADQeAmaiIEIANB6A1qEKUcIANB0A1qIgwgBCkDADcDACADQdgNaiIPIANB6CZqKQMANwMAIANB4A1qIgcgA0HwJmopAwA3AwAgA0IANwPIDUH7sNoAQRgQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykDyA03AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQAlBEBBACAGKAIAEIoEIQ1Bk7HaAEEdENwaIUIgA0H4yN8AQQEQ3Bo3A5gOIANCADcDoA4gA0HgJmoiBCADQZgOahClHCADQYAOaiIMIAQpAwA3AwAgA0GIDmoiDyADQegmaikDADcDACADQZAOaiIHIANB8CZqKQMANwMAIANCADcD+A1BsLHaAEEsENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA/gNNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0AJgRAQQAgBigCABCKBCENQdyx2gBBEBDcGiFCIANB+MjfAEEBENwaNwPIDiADQgA3A9AOIANB4CZqIgQgA0HIDmoQpRwgA0GwDmoiDCAEKQMANwMAIANBuA5qIg8gA0HoJmopAwA3AwAgA0HADmoiByADQfAmaikDADcDACADQgA3A6gOQeyx2gBBHxDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQOoDjcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtACcEQEEAIAYoAgAQigQhDUGLstoAQQwQ3BohQiADQfjI3wBBARDcGjcD+A4gA0IANwOADyADQeAmaiIEIANB+A5qEKUcIANB4A5qIgwgBCkDADcDACADQegOaiIPIANB6CZqKQMANwMAIANB8A5qIgcgA0HwJmopAwA3AwAgA0IANwPYDkGXstoAQRsQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykD2A43AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQAoBEBBACAGKAIAEIoEIQ1BsrLaAEEIENwaIUIgA0H4yN8AQQEQ3Bo3A6gPIANCADcDsA8gA0HgJmoiBCADQagPahClHCADQZAPaiIMIAQpAwA3AwAgA0GYD2oiDyADQegmaikDADcDACADQaAPaiIHIANB8CZqKQMANwMAIANCADcDiA9BurLaAEEXENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA4gPNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0AKQRAQQAgBigCABCKBCENQdGy2gBBBBDcGiFCIANB+MjfAEEBENwaNwPYDyADQgA3A+APIANB4CZqIgQgA0HYD2oQpRwgA0HAD2oiDCAEKQMANwMAIANByA9qIg8gA0HoJmopAwA3AwAgA0HQD2oiByADQfAmaikDADcDACADQgA3A7gPQdWy2gBBExDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQO4DzcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtACoEQEEAIAYoAgAQigQhDUHostoAQREQ3BohQiADQfjI3wBBARDcGjcDiBAgA0IANwOQECADQeAmaiIEIANBiBBqEKUcIANB8A9qIgwgBCkDADcDACADQfgPaiIPIANB6CZqKQMANwMAIANBgBBqIgcgA0HwJmopAwA3AwAgA0IANwPoD0H5stoAQSAQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykD6A83AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQArBEBBACAGKAIAEIoEIQ1BmbPaAEEJENwaIUIgA0H4yN8AQQEQ3Bo3A7gQIANCADcDwBAgA0HgJmoiBCADQbgQahClHCADQaAQaiIMIAQpAwA3AwAgA0GoEGoiDyADQegmaikDADcDACADQbAQaiIHIANB8CZqKQMANwMAIANCADcDmBBBorPaAEEYENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA5gQNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0ALARAQQAgBigCABCKBCENQbqz2gBBDxDcGiFCIANB+MjfAEEBENwaNwPoECADQgA3A/AQIANB4CZqIgQgA0HoEGoQpRwgA0HQEGoiDCAEKQMANwMAIANB2BBqIg8gA0HoJmopAwA3AwAgA0HgEGoiByADQfAmaikDADcDACADQgA3A8gQQcmz2gBBHhDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQPIEDcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtAC0EQEEAIAYoAgAQigQhDUHns9oAQRwQ3BohQiADQfjI3wBBARDcGjcDmBEgA0IANwOgESADQeAmaiIEIANBmBFqEKUcIANBgBFqIgwgBCkDADcDACADQYgRaiIPIANB6CZqKQMANwMAIANBkBFqIgcgA0HwJmopAwA3AwAgA0IANwP4EEGDtNoAQSsQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykD+BA3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQAuBEBBACAGKAIAEIoEIQ1BrrTaAEEbENwaIUIgA0H4yN8AQQEQ3Bo3A8gRIANCADcD0BEgA0HgJmoiBCADQcgRahClHCADQbARaiIMIAQpAwA3AwAgA0G4EWoiDyADQegmaikDADcDACADQcARaiIHIANB8CZqKQMANwMAIANCADcDqBFBybTaAEEqENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA6gRNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0ALwRAQQAgBigCABCKBCENQfO02gBBCxDcGiFCIANB+MjfAEEBENwaNwP4ESADQgA3A4ASIANB4CZqIgQgA0H4EWoQpRwgA0HgEWoiDCAEKQMANwMAIANB6BFqIg8gA0HoJmopAwA3AwAgA0HwEWoiByADQfAmaikDADcDACADQgA3A9gRQf602gBBGhDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQPYETcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtADAEQEEAIAYoAgAQigQhDUGYtdoAQRgQ3BohQiADQfjI3wBBARDcGjcDqBIgA0IANwOwEiADQeAmaiIEIANBqBJqEKUcIANBkBJqIgwgBCkDADcDACADQZgSaiIPIANB6CZqKQMANwMAIANBoBJqIgcgA0HwJmopAwA3AwAgA0IANwOIEkGwtdoAQScQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykDiBI3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQAxBEBBACAGKAIAEIoEIQ1B17XaAEEZENwaIUIgA0H4yN8AQQEQ3Bo3A9gSIANCADcD4BIgA0HgJmoiBCADQdgSahClHCADQcASaiIMIAQpAwA3AwAgA0HIEmoiDyADQegmaikDADcDACADQdASaiIHIANB8CZqKQMANwMAIANCADcDuBJB8LXaAEEoENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA7gSNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0AMgRAQQAgBigCABCKBCENQZi22gBBExDcGiFCIANB+MjfAEEBENwaNwOIEyADQgA3A5ATIANB4CZqIgQgA0GIE2oQpRwgA0HwEmoiDCAEKQMANwMAIANB+BJqIg8gA0HoJmopAwA3AwAgA0GAE2oiByADQfAmaikDADcDACADQgA3A+gSQau22gBBIhDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQPoEjcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtADMEQEEAIAYoAgAQigQhDUHNttoAQRIQ3BohQiADQfjI3wBBARDcGjcDuBMgA0IANwPAEyADQeAmaiIEIANBuBNqEKUcIANBoBNqIgwgBCkDADcDACADQagTaiIPIANB6CZqKQMANwMAIANBsBNqIgcgA0HwJmopAwA3AwAgA0IANwOYE0HfttoAQSEQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykDmBM3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQA0BEBBACAGKAIAEIoEIQ1BgLfaAEEYENwaIUIgA0H4yN8AQQEQ3Bo3A+gTIANCADcD8BMgA0HgJmoiBCADQegTahClHCADQdATaiIMIAQpAwA3AwAgA0HYE2oiDyADQegmaikDADcDACADQeATaiIHIANB8CZqKQMANwMAIANCADcDyBNBmLfaAEEnENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA8gTNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0ANQRAQQAgBigCABCKBCENQb+32gBBHhDcGiFCIANB+MjfAEEBENwaNwOYFCADQgA3A6AUIANB4CZqIgQgA0GYFGoQpRwgA0GAFGoiDCAEKQMANwMAIANBiBRqIg8gA0HoJmopAwA3AwAgA0GQFGoiByADQfAmaikDADcDACADQgA3A/gTQd232gBBLRDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQP4EzcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtADYEQEEAIAYoAgAQigQhDUGKuNoAQQQQ3BohQiADQfjI3wBBARDcGjcDyBQgA0IANwPQFCADQeAmaiIEIANByBRqEKUcIANBsBRqIgwgBCkDADcDACADQbgUaiIPIANB6CZqKQMANwMAIANBwBRqIgcgA0HwJmopAwA3AwAgA0IANwOoFEGOuNoAQRMQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykDqBQ3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQA3BEBBACAGKAIAEIoEIQ1BobjaAEEQENwaIUIgA0H4yN8AQQEQ3Bo3A/gUIANCADcDgBUgA0HgJmoiBCADQfgUahClHCADQeAUaiIMIAQpAwA3AwAgA0HoFGoiDyADQegmaikDADcDACADQfAUaiIHIANB8CZqKQMANwMAIANCADcD2BRBsbjaAEEfENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA9gUNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0AOARAQQAgBigCABCKBCENQdC42gBBEhDcGiFCIANB+MjfAEEBENwaNwOoFSADQgA3A7AVIANB4CZqIgQgA0GoFWoQpRwgA0GQFWoiDCAEKQMANwMAIANBmBVqIg8gA0HoJmopAwA3AwAgA0GgFWoiByADQfAmaikDADcDACADQgA3A4gVQeK42gBBIRDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQOIFTcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtADkEQEEAIAYoAgAQigQhDUGDudoAQRQQ3BohQiADQfjI3wBBARDcGjcD2BUgA0IANwPgFSADQeAmaiIEIANB2BVqEKUcIANBwBVqIgwgBCkDADcDACADQcgVaiIPIANB6CZqKQMANwMAIANB0BVqIgcgA0HwJmopAwA3AwAgA0IANwO4FUGXudoAQSMQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykDuBU3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQA6BEBBACAGKAIAEIoEIQ1BurnaAEEbENwaIUIgA0H4yN8AQQEQ3Bo3A4gWIANCADcDkBYgA0HgJmoiBCADQYgWahClHCADQfAVaiIMIAQpAwA3AwAgA0H4FWoiDyADQegmaikDADcDACADQYAWaiIHIANB8CZqKQMANwMAIANCADcD6BVB1bnaAEEqENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA+gVNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0AOwRAQQAgBigCABCKBCENQf+52gBBDhDcGiFCIANB+MjfAEEBENwaNwO4FiADQgA3A8AWIANB4CZqIgQgA0G4FmoQpRwgA0GgFmoiDCAEKQMANwMAIANBqBZqIg8gA0HoJmopAwA3AwAgA0GwFmoiByADQfAmaikDADcDACADQgA3A5gWQY262gBBHRDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQOYFjcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtADwEQEEAIAYoAgAQigQhDUGqutoAQRQQ3BohQiADQfjI3wBBARDcGjcD6BYgA0IANwPwFiADQeAmaiIEIANB6BZqEKUcIANB0BZqIgwgBCkDADcDACADQdgWaiIPIANB6CZqKQMANwMAIANB4BZqIgcgA0HwJmopAwA3AwAgA0IANwPIFkG+utoAQSMQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykDyBY3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQA9BEBBACAGKAIAEIoEIQ1B4braAEEaENwaIUIgA0H4yN8AQQEQ3Bo3A5gXIANCADcDoBcgA0HgJmoiBCADQZgXahClHCADQYAXaiIMIAQpAwA3AwAgA0GIF2oiDyADQegmaikDADcDACADQZAXaiIHIANB8CZqKQMANwMAIANCADcD+BZB+7raAEEpENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA/gWNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0APgRAQQAgBigCABCKBCENQaS72gBBIBDcGiFCIANB+MjfAEEBENwaNwPIFyADQgA3A9AXIANB4CZqIgQgA0HIF2oQpRwgA0GwF2oiDCAEKQMANwMAIANBuBdqIg8gA0HoJmopAwA3AwAgA0HAF2oiByADQfAmaikDADcDACADQgA3A6gXQcS72gBBLxDcGiFBQcgAEOkgIgRCADcDOCAEQQA6ADQgBCANNgIwIARCADcDKCAEIEI3AyAgBEEYaiAHKQMANwMAIARBEGogDykDADcDACAEQQhqIAwpAwA3AwAgBCADKQOoFzcDACAEQUBrQQA6AAAgA0EBNgLkJiADIAQ2AuAmIANBATYC3CZBGBDpICIEQgA3AwggBCBBNwMAIANB8iZqQgA3AQAgBEEQakIANwMAIANCADcC7CYgAyAENgLoJiADQQA2AtgmIAogA0HYJmoQ/RkLIAgtAD8EQEEAIAYoAgAQigQhDUHzu9oAQRwQ3BohQiADQfjI3wBBARDcGjcD+BcgA0IANwOAGCADQeAmaiIEIANB+BdqEKUcIANB4BdqIgwgBCkDADcDACADQegXaiIPIANB6CZqKQMANwMAIANB8BdqIgcgA0HwJmopAwA3AwAgA0IANwPYF0GPvNoAQSsQ3BohQUHIABDpICIEQgA3AzggBEEAOgA0IAQgDTYCMCAEQgA3AyggBCBCNwMgIARBGGogBykDADcDACAEQRBqIA8pAwA3AwAgBEEIaiAMKQMANwMAIAQgAykD2Bc3AwAgBEFAa0EAOgAAIANBATYC5CYgAyAENgLgJiADQQE2AtwmQRgQ6SAiBEIANwMIIAQgQTcDACADQfImakIANwEAIARBEGpCADcDACADQgA3AuwmIAMgBDYC6CYgA0EANgLYJiAKIANB2CZqEP0ZCyAILQBABEBBACAGKAIAEIoEIQ1BurzaAEEQENwaIUIgA0H4yN8AQQEQ3Bo3A6gYIANCADcDsBggA0HgJmoiBCADQagYahClHCADQZAYaiIMIAQpAwA3AwAgA0GYGGoiDyADQegmaikDADcDACADQaAYaiIHIANB8CZqKQMANwMAIANCADcDiBhByrzaAEEfENwaIUFByAAQ6SAiBEIANwM4IARBADoANCAEIA02AjAgBEIANwMoIAQgQjcDICAEQRhqIAcpAwA3AwAgBEEQaiAPKQMANwMAIARBCGogDCkDADcDACAEIAMpA4gYNwMAIARBQGtBADoAACADQQE2AuQmIAMgBDYC4CYgA0EBNgLcJkEYEOkgIgRCADcDCCAEIEE3AwAgA0HyJmpCADcBACAEQRBqQgA3AwAgA0IANwLsJiADIAQ2AugmIANBADYC2CYgCiADQdgmahD9GQsgCC0AQQRAQQAgBigCABCKBCENQem82gBBBBDcGiFCIANB+MjfAEEBENwaNwPYGCADQgA3A+AYIANB4CZqIgQgA0HYGGoQpRwgA0HAGGoiDCAEKQMANwMAIANByBhqIg8gA0HoJmopAwA3AwAgA0HQGGoiByADQfAmaikDADcDACADQgA3A7gYQe282gBBExDcGiFBQcgAEOkgIgRCADcDOCAE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QQA6AKkCIAMgAS0AjgM6AKgCIAMgAS0AngM6ALgCIAMgASkBggM3AJwCIAMgASgBigM2AKQCIAMgASkDkAM3AKoCIAMgASgCmAM2ALICIAMgAS8BnAM7ALYCIANBsQVqIAFBggNqIgVBFWopAAA3AAAgA0GsBWogBUEQaikBADcCACADQaQFaiAFQQhqKQEANwIAIAMgBSkBADcCnAUgBiADQZwCahDJCCADIAE2ApgFIANByAJqIgogARCvAyADKALIAiEOAkAgAy0A9AIiBUEGRwRAIANB4AFqIhNBBHIgCkEEckEoEPsGGiADQY8CaiADQfcCai0AADoAACADIAMvAPUCOwCNAiADIAU6AIwCIAMgDjYC4AEgA0GYBWoQoyYgAiEOQQAhBiMAQaAJayIEJAAgAUEoaiEJAkAgAS0A+AJBAkcNACAJEOMNIgJFDQAgAigCAEEURw0AIAItAARBBEcNACABLQD4AkECRw0AIAEtAIIDIQUgBEGQAWoiAiABENECIARBAToAiwggBCABKQCDAzcAjAggBCABKQCLAzcAlAggBCABKQCTAzcAnAggBCABKACbAzYApAggBEGQAmogBEGLCGoQyQggBEEoaiACEPABIAQgBCgCLCIcNgKMCSAEIAQoAigiDzYCiAkgDwRAIARBiAlqEJ0gIAIQhBBBACEcDAELIARBuARqIgIgBEGQAWpBqAMQ+wYaIAEQhBAgASACQagDEPsGIQIgBCAFOgDACCAEIAIpAIMDNwDBCCAEIAIpAIsDNwDJCCAEIAIpAJMDNwDRCCAEIAIoAJsDNgDZCCABQYABaiAEQcAIahDJCAsgBEKAgICAgAE3AjQgAUGAAWohKiABQYIDaiEfIAFBLGohDyAEQewIaiEmIARBwARqIRggBEHMBWohJyAEQdwEaiErIARBxARqISUgBEHECGohICAEQbgEakEEciEVIARB2ARqIShBCCEpAkACQAJAAkACQANAAkAgBCAUNgI8IAkQ4w0iAkUEQCABKALYAiECIARBADoAuAQgBCACIAIgBEG4BGoQgRU2ApQBIARBATYCkAEgBEGQAWoQkCQMAQsgBEEANgKQASAEIAI2ApQBIARBkAFqEJAkAkAgCRDjDSICRQ0AIAIoAgBBFEcNACACLQAEQQ5GDQELIAkQ4w0iAgRAIAIoAgBBIkYN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D0EIaikCADcCACAEQcwEaiAPQRBqKAIANgIAIAQgDykCADcCvAQgBCACNgK4BCAEQbgEahDHCkEACwJAIAEtAJoDQQFxRQ0AIAkQ4w0iAkUNACACKAIAQRRHDQAgAi0ABEEGRw0AIAEoAighAiABQSU2AiggASABKQNANwN4IARBxARqIA9BCGopAgA3AgAgBEHMBGogD0EQaigCADYCACAEIA8pAgA3ArwEIAQgAjYCuAQgBEG4BGoQxwoMAgtFDQEgBEHEBGogCRCWCyAEIAkQuBQgBEETNgLABCAEQcCC4AA2ArwEIARBMDoAuAQgBCgCACAEKAIEIARBuARqEIEVIQIgCRDjDSIFRQ0AIAUoAgBBJEcNACABIAEpA0A3A3ggASgCKCABQSU2AihBJEcNAyABIAEoAiwQhgwLIApBgICAgHg2AjwgCiACNgIAIARBNGoQjCcgHBDZKCATEMYXDAELIAogBCkCNDcCPCAKQcQAaiAEQTxqKAIANgIAIAEoAnwhAiAKIBNBMBD7BiIFIBQ6AEggBSAcNgI4IAUgDiACIAIgDkkbNgI0IAUgDiACIAIgDksbNgIwCyAEQaAJaiQADAELQeXs4ABBKEHUguAAEPQXAAsgAygChAMiE0GAgICAeEYEQCADKALIAiEODAILIAMoAswCIRAgAygCyAIhESADQegFaiADQdACakE0EPsGGiADQegEaiADQZADaikDADcDACADIAMpA4gDNwPgBAwDCyADQZgFahCjJgsgAEGBgICAeDYCkAEgACAONgIADAILIAEoAighBSABQSU2AiggASABKQNANwN4IANB1AJqIA1BCGopAgA3AgAgA0HcAmogDUEQaigCADYCACADIA0pAgA3AswCIAMgBTYCyAIgA0HIAmoQxwogAiABKAJ8IgUgAiAFSRshESACIAUgAiAFSxshEEGAgICAeCETCyADIBA2AoQBIANBiAFqIANB6AVqQTQQ+wYaIANByAFqIANB6ARqIgkpAwA3AwAgAyADKQPgBDcDwAEgAyARNgKAASADIBM2ArwBIANBADYC3AEgA0KAgICAgAE3AtQBIANBBzoAlAICQAJAIBNBgICAgHhGDQAgAy0AyAFBAUcNAEEHIQZBACEOIAMoAuQBIQoMAQsgA0HQAmohGSADQcgCakEEciEHIANBzAJqIQ8gA0GYBGohBCADQfADaiESIANB7AJqIRYgA0HcA2ohGkEAIQJBACEOAkACQANAIAgQ4w0iBUUEQCABKALYAiEBIANBADoAyAIgASABIANByAJqEIEVIQUMAwsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBSgCACIFQSBrDgUEBQICAAELIAEgASkDQDcDeCABKAIoIAFBJTYCKEEkRg0PQeXs4ABBKEHw/98AEPQXAAsgBUENRg0BCyADQdQCaiAIEJYLIANBCGogCBC4FCADQSA2AtACIANB4IDgADYCzAIgA0EwOgDIAiADKAIIIAMoAgwgA0HIAmoQgRUhBSAIEOMNIgJFDQ4gAigCAEEkRw0OIAEgASkDQDcDeCABKAIoIAFBJTYCKEEkRw0GIAEgASgCLBCGDAwOCyAIEN4gGgJAAkACQCAIEOESIgUEQCAFKAIAQQdGDQELIANByAJqIAEQhAQgAygCyAIiBUECRg0BIAkgDykCADcCACAJQQhqIA9BCGopAgA3AgAgAyAFNgLkBCADQQE2AuAEIANB4ARqIQoMDAsgCBDeICELAkACQAJAAkACQCAIEOMNIgUEQCAFKAIAQQ1GDQELIANB0AJqIAgQlgsgA0EQaiAIELgUIANB2OHfADYCzAIgA0E0OgDIAiADKAIQIAMoAhQgA0HIAmoQgRUhBSAIEOMNIgJFDRQgAigCAEEkRw0UIAEgASkDQDcDeCABKAIoIAFBJTYCKEEkRg0BQeXs4ABBKEH4geAAEPQXAAsgByANKQIANwIAIAEoAighBSABQSU2AiggASABKQNANwN4IAdBCGoiBiANQQhqIgopAgA3AgAgB0EQaiIMIA1BEGoiFSgCADYCACADIAU2AsgCIANByAJqEMcKIAgQ4w0iBQRAIAUoAgBBB0YNAgsgA0HQAmogCBCWCyADQRhqIAgQuBQgA0Go/t8ANgLMAiADQTQ6AMgCIAMoAhggAygCHCADQcgCahCBFSEFIAgQ4w0iAkUNEyACKAIAQSRHDRMgASABKQNANwN4IAEoAiggAUElNgIoQSRHDQILIAEgASgCLBCGDAwSCyAHIA0pAgA3AgAgASgCKCEFIAFBJTYCKCABIAEpA0A3A3ggBiAKKQIANwIAIAwgFSgCADYCACADIAU2AsgCIANByAJqEMcKIANBKGogARCRBiADKAIsIQUgAygCKA0RIAMgBTYC6AUgCBDjDSIUBEAgFCgCAEEORg0CCyAZIAgQlgsgA0EgaiAIELgUIANBsOHfADYCzAIgA0E0OgDIAiADKAIgIAMoAiQgA0HIAmoQgRUhBSAIEOMNIgJFDQ4gAigCAEEkRw0OIAEgASkDQDcDeCABKAIoIAFBJTYCKEEkRw0GIAEgASgCLBCGDAwOC0Hl7OAAQShB6IHgABD0FwALIAcgDSkCADcCACABKAIoIRQgAUElNgIoIAEgASkDQDcDeCAGIAopAgA3AgAgDCAVKAIANgIAIAMgFDYCyAIgA0HIAmoQxwogCyABKAJ8IgogCiALSxshBiAFDQEgBiEFDA8LIAMoAswCIQUMDgsgAyALIAogCiALSRs2AsQEIAMgBjYCwAQgAyAFNgK8BCADQQI2ArgEIANBuARqIQoMCQsgA0HIAmogARCOEiADKQPIAlBFBEAgBCADKQPIAjcDACAEQRBqIANB2AJqKQMANwMAIARBCGogGSkDADcDACADQQA2ApAEIANBkARqIQoMCQsgAygC0AIhBQwMCyAIEN4gIQsCfwJAAkACQCAIEOESIgVFDQAgBSgCAEEURw0AIAUtAARBDkYNAQsgA0HIAmogASALEEkgAygCyAIhBSADKALYAyILQYGAgIB4Rg0OIAtBgICAgHhHDQEgA0GABmogB0EYaikCADcDACADQfgFaiAHQRBqKQIANwMAIANB8AVqIAdBCGopAgA3AwAgAyAHKQIANwPoBUEEDAILIAEoAighAiABQSU2AiggASABKQNANwN4IANB1AJqIA1BCGopAgA3AgAgA0HcAmogDUEQaigCADYCACADIA0pAgA3AswCIAMgAjYCyAIgA0HIAmoiAhDHCiAIEOMNIgVFBEAgASgC2AIhASADQQA6AMgCIAEgASACEIEVIQUMDgsgBSgCAEEkRgRAIAEgASkDQDcDeCABKAIoIAFBJTYCKEEkRg0NQeXs4ABBKEGAgOAAEPQXAAsgCBDjDSICRQ0IIAIoAgBBJEYEQCABIAEpA0A3A3ggASgCKCABQSU2AihBJEYNDUHl7OAAQShBkIDgABD0FwALIAEoAighAiABQSU2AiggASABKQNANwN4IANB1AJqIA1BCGopAgA3AgAgA0HcAmogDUEQaigCADYCACADIA0pAgA3AswCIAMgAjYCyAIgA0HIAmoQxwoCQCAIEOMNIgIEQCACKAIAQSJGDQELIANByAJqIgIgARCvAyADKALIAiEFIAMtAPQCIgZBBkYNDiADQegFakEEciACQQRyQSgQ+wYaIANBlwZqIANB9wJqLQAAOgAAIAMgAy8A9QI7AJUGIAMgBjoAlAYgAyAFNgLoBSAIEOMNIgIEQCACKAIAQSJGDQULIANB0AJqIAgQlgsgA0EwaiAIELgUIANBmILgADYCzAIgA0E0OgDIAiADKAIwIAMoAjQgA0HIAmoQgRUhBSAIEOMNIgJFDQggAigCAEEkRw0IIAEgASkDQDcDeCABKAIoIAFBJTYCKEEkRw0FIAEgASgCLBCGDAwICyABKAIoIQIgAUElNgIoIAEgASkDQDcDeCADQdQCaiANQQhqKQIANwIAIANB3AJqIA1BEGooAgA2AgAgAyANKQIANwLMAiADIAI2AsgCIANByAJqEMcKIAsgASgCfCICIAIgC0sbIRYgCyACIAIgC0kbIQpBBiEGDAYLQaABQQgQqyAiBiAFNgIAIAYgBykCADcCBCAGQQxqIAdBCGopAgA3AgAgBkEUaiAHQRBqKQIANwIAIAZBHGogB0EYaikCADcCACAGQSRqIBZB7AAQ+wYaIAYgCzYCkAEgBiAaKQIANwKUASAGQZwBaiAaQQhqKAIANgIAIAYhBUEDCyEGIBIgAykD6AU3AwAgEkEYaiADQYAGaikDADcDACASQRBqIANB+AVqKQMANwMAIBJBCGogA0HwBWopAwA3AwAgAyAFNgLsAyADIAY2AugDIANB6ANqIQoMBwtB5ezgAEEoQdiB4AAQ9BcACyABKAIoIQIgAUElNgIoIAEgASkDQDcDeCADQdQCaiANQQhqKQIANwIAIANB3AJqIA1BEGooAgA2AgAgAyANKQIANwLMAiADIAI2AsgCIANByAJqEMcKIAEoAnwhAiADQZgFaiADQegFakEsEPsGGiADQaoGaiADQZUGaiIFQQJqLQAAOgAAIAMgBS8AADsBqAYgCyACIAIgC0sbIRYgCyACIAIgC0kbIQoMAgtB5ezgAEEoQbCC4AAQ9BcAC0Hl7OAAQShBgIHgABD0FwALIANBnAJqIgIgA0GYBWpBLBD7BhogA0GaAmoiBSADQaoGai0AADoAACADIAMvAagGOwGYAiADQeABahCOISADIAo2AuQBIAMgFjYC4AEgA0HoAWogAkEsEPsGGiADQZcCaiAFLQAAOgAAIAMgBjoAlAIgAyADLwGYAjsAlQIMBwsgA0HoBWoQxhcMBQsgASgC2AIhASADQQA6AMgCIAEgASADQcgCahCBFSEFDAQLIAMoAtQBIA5GBEAgA0HUAWoQ0xcLIAMoAtgBIAJqIApBKBD7BhogAyAOQQFqIg42AtwBIAJBKGohAgwBCwsgA0HoBWoQuCkMAQsgASgCLCEFCyAAQYGAgIB4NgKQASAAIAU2AgAgA0HgAWoQjiEgA0HUAWoQ7CYgE0GAgICAeEYNASADQYABahDGIwwBCyAbIAEoAnwiBSAFIBtLGyECIBsgBSAFIBtJGyEFIANBlQJqIQsgA0HoAWohEgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCATQYCAgIB4RgRAIAZBBmsOAgIBAwsgA0HAAWohDiADQYgBaiEHIAZBBmsOAgQDBQtB5ezgAEEoQbCA4AAQ9BcAC0GAgICAeCEBIAMoAtgBIQcgAygC1AEhBiACIRkgBSEaDAwLIAMgCjYCzAIgAyAWNgLIAiADQdACaiASQSwQ+wYhAiADQf8CaiALQQJqLQAAOgAAIAMgBjoA/AIgAyALLwAAOwD9AiADQdcAOgDoBSAWIAogA0HoBWoQgRUhBSAIEOMNIgZFDQkgBigCAEEkRw0JIAEgASkDQDcDeCABKAIoIAFBJTYCKEEkRw0DIAEgASgCLBCGDAwJCyADQZgFaiAHQTQQ+wYaIANBkAVqIA5BCGopAwA3AwAgAyAOKQMANwOIBUEGIQ0gAykC2AEhLyADKALUASEBIBEhCyAQIRIgAiEGIAUhBwwKCyADIBA2AswCIAMgETYCyAIgA0HQAmogB0E0EPsGGiADQZADaiAOQQhqKQMANwMAIAMgEzYChAMgAyAOKQMANwOIAyADQcgCahDBCCEsIANB2AA6AOgFIAMgLDcD8AUgFiAKIANB6AVqEIEVIQIgCBDjDSIFRQ0GIAUoAgBBJEcNBiABIAEpA0A3A3ggASgCKCABQSU2AihBJEcNAiABIAEoAiwQhgwMBgsgAyAQNgLMAiADIBE2AsgCIANB0AJqIAdBNBD7BiEQIANBkANqIA5BCGopAwA3AwAgAyATNgKEAyADIA4pAwA3A4gDIAMgCjYC7AUgAyAWNgLoBSADQfAFaiASQSwQ+wYhByADQZ8GaiALQQJqLQAAOgAAIAMgBjoAnAYgAyALLwAAOwCdBiADIAcQwQg3A6AGIAMgA0HIAmoQwQgiLDcDqAYgA0GgBmogA0GoBmoiBhCaCiAsEPkaIAMpA6AGEPkaDQQgAygC7AUhAiADKALoBSADQcgCahDBCCEsIANB2AA6AKgGIAMgLDcDsAYgAiAGEIEVIQIgCBDjDSIFRQ0DIAUoAgBBJEcNAyABIAEpA0A3A3ggASgCKCABQSU2AihBJEcNAiABIAEoAiwQhgwMAwtB5ezgAEEoQaCA4AAQ9BcAC0Hl7OAAQShBwIDgABD0FwALQeXs4ABBKEHQgOAAEPQXAAsgAEGBgICAeDYCkAEgACACNgIAIAcQxhcgA0HIAmoQxiMMAwsgAygCzAIhEiADKALIAiELIANBmAVqIBBBNBD7BhogA0GQBWogA0GIA2oiAUEIaikDADcDACADQdgFaiADQYwGaikCADcDACADQeAFaiADQZQGaikCADcDACADIAEpAwA3A4gFIAMgAykChAY3A9AFIAMoAoQDIRMgAygC1AEhASADKQLYASEvIAMoAugFIQ4gAygC7AUhGSADKALwBSEaIAMoAvQFIREgAygC+AUhECADKAL8BSEWIAMoAoAGIQogA0HOBWogA0GdBmoiBkECai0AADoAACADIAYvAAA7AcwFIAMtAJwGIQ0gAiEGIAUhBwwDCyAAQYGAgIB4NgKQASAAIAI2AgAgA0HIAmoQxiMMAQsgAEGBgICAeDYCkAEgACAFNgIAIAIQxhcLIANB1AFqEOwmDAELIAAgCjYCICAAIBY2AhwgACAQNgIYIAAgETYCFCAAIBo2AhAgACAZNgIMIAAgDjYCCCAAIAc2AgQgACAGNgIAIAAgAykD0AU3AiQgACANOgA8IAAgAy8BzAU7AD0gAEEsaiADQdgFaikDADcCACAAQTRqIANB4AVqKQMANwIAIABBP2ogA0HOBWotAAA6AAAgACASNgJEIAAgCzYCQCAAQcgAaiADQZgFakE0EPsGGiAAIBM2AnwgACAvNwKUASAAIAE2ApABIAAgAykDiAU3A4ABIABBiAFqIANBkAVqKQMANwMACyADQdwAahCjJgwBC0Hl7OAAQShB4P/fABD0FwALIANBwAZqJAALyEsCKH8FfiMAQcAGayIDJAACQCABQShqIggQyg0iBUUEQCABKAKAAiEBIANBADoAyAIgASABIANByAJqEIEVIQEgAEGBgICAeDYCkAEgACABNgIADAELAkACfwJAAkAgBSgCAEEkRgRAIAEgASkD4AI3A5gDIAEoAsgCIAFBJTYCyAJBJEYNAUHl7OAAQShB0P/fABD0FwALIAgQwyAhGyADQdQCaiABQdQCaikCADcCACADQdwCaiABQdwCaigCADYCACABKALIAiEFIAFBJTYCyAIgASABKQPgAjcDmAMgAyABKQLMAjcCzAIgAyAFNgLIAiAFQRRGDQEgBUEhRw0DQQAMAgsgASgCzAIhASAAQYGAgIB4NgKQASAAIAE2AgAMAwsgAy0AzAJBBEcNAUEBCyEFIAFBzAJqIQ0gA0HIAmoQxgogA0EAOgBMIAMgBToAVyADIAEtALYCOgBLIAMgASkBqgI3AD8gAyABQbICaiIFKAEANgBHIAMgASkDuAI3AE0gAyABLwHAAjsAVSADIAEoAMMCNgBYIANB9QBqIAFBvwJqKQAANwAAIANB8ABqIAFBugJqKQEANwIAIANB6ABqIAUpAQA3AgAgAyABKQGqAjcCYCAIIANBP2oQ0gggAyABNgJcAkACQAJAIAgQyg0iBQRAIAUoAgBBIkYNAQsgA0EAOgCpAiADIAEtALYCOgCoAiADIAEtAMYCOgC4AiADIAEpAaoCNwCcAiADIAEoAbICNgCkAiADIAEpA7gCNwCqAiADIAEoAsACNgCyAiADIAEvAcQCOwC2AiADQbEFaiABQaoCaiIFQRVqKQAANwAAIANBrAVqIAVBEGopAQA3AgAgA0GkBWogBUEIaikBADcCACADIAUpAQA3ApwFIAggA0GcAmoQ0gggAyABNgKYBSADQcgCaiIKIAEQrgMgAygCyAIhDgJAIAMtAPQCIgVBBkcEQCADQeABaiITQQRyIApBBHJBKBD7BhogA0GPAmogA0H3AmotAAA6AAAgAyADLwD1AjsAjQIgAyAFOgCMAiADIA42AuABIANBmAVqEIclIAIhDiMAQZAJayIEJAAgAUEoaiEJAkAgAS0AoAJBAkcNACAJEMoNIgJFDQAgAigCAEEURw0AIAItAARBBEcNACABLQCgAkEC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BSACQbgFaiIDEMcKIAJBADYCVCACQoCAgICAATcCTCABQYABaiEnIAFBLGohESACQcAFaiESIANBBHIhCiACQagFaiEkIAJBgAVqQQRyIRsgAkHkAWohEyACQeABaiELIAJBuAJqISggAkGMAWohHiACQeQFaiEfIAJB4AVqISUgAkG4BmohKSACQfwBaiEWIAJBtAJqIRcgAkH4AWohGCACQbACaiEZAkADQAJAIAJBuAVqIAFBAxDWCAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAItALgFRQRAIAItALkFRQRAAkACQAJAAkACQCAHEOMNIgMEQCADKAIAQQlGDQELIAcQ4w0iA0UNASADKAIAQRRHDQEgAy0ABEEERw0BCyACQbgFaiABQQAQ/wIgAigCuAUiA0ECRg0BDBoLIAcQ4w0iA0UNAiADKAIAQQJHDQIgAy0ACEECRw0CIAMtAAlBFkcNAiACQbgFaiABENECIAJBAToAuAEgAiACKQC7CDcAuQEgAiACKQDDCDcAwQEgAiACKQDLCDcAyQEgAiACKADTCDYA0QEgKSACQbgBahDJCCAbIB8pAgA3AgAgG0EIaiAfQQhqKQIANwIAIBtBEGogH0EQaigCADYCACACKALgBSEDIAJBJTYC4AUgAiADNgKABSACIAIpA/gFNwOwBiACQYAFahDHCgJAAkAgJRDjDSIDBEAgAygCAEEJRg0BCyAlEOMNIgNFDQMgAygCAEEURw0DIAMtAAQgAkG4BWoQhBBBBEYNAQwECyACQbgFahCEEAsgAkG4BWogAUEBEP8CIAIoArgFIgNBAkYNAAwZC0ELIQggAigCvAUhAwwZCyACQbgFahCEEAsgBxDeICEUIAJBuAVqIAFBuOffAEEBQQAQsgIgAigCvAUhCSACKAK4BQRAIAkhAwwZCyACQbgFaiABIBQgCUEARyIgQQAQpgEgAigCvAUhAyACKAK4BSIEQYGAgIB4Rg0CIB4gEikCADcCACAeQRBqIBJBEGooAgA2AgAgHkEIaiASQQhqKQIANwIAIAIgAzYCiAEgAiAENgKEASAEQYCAgIB4RwRAQQohCCACKAKcASEGIAIoApgBIRwgAigClAEhGiACKAKQASEdIAIoAowBIRAgAyENIAQhAwwYCyABLQD4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