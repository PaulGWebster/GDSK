t_t   *server_list,
                                  ares_bool_t     user_specified);
ares_status_t
  ares_sconfig_append(const ares_channel_t *channel, ares_llist_t **sconfig,
                      const struct ares_addr *addr, unsigned short udp_port,
                      unsigned short tcp_port, const char *ll_iface);
ares_status_t ares_sconfig_append_fromstr(const ares_channel_t *channel,
                                          ares_llist_t        **sconfig,
                                          const char           *str,
                                          ares_bool_t           ignore_invalid);
ares_status_t ares_in_addr_to_sconfig_llist(const struct in_addr *servers,
                                            size_t                nservers,
                                            ares_llist_t        **llist);
ares_status_t ares_get_server_addr(const ares_server_t *server,
                                   ares_buf_t          *buf);

struct ares_hosts_entry;
typedef struct ares_hosts_entry ares_hosts_entry_t;

void                            ares_hosts_file_destroy(ares_hosts_file_t *hf);
ares_status_t ares_hosts_search_ipaddr(ares_channel_t *channel,
                                       ares_bool_t use_env, const char *ipaddr,
                                       const ares_hosts_entry_t **entry);
ares_status_t ares_hosts_search_host(ares_channel_t *channel,
                                     ares_bool_t use_env, const char *host,
                                     const ares_hosts_entry_t **entry);
ares_status_t ares_hosts_entry_to_hostent(const ares_hosts_entry_t *entry,
                                          int family, struct hostent **hostent);
ares_status_t ares_hosts_entry_to_addrinfo(const ares_hosts_entry_t *entry,
                                           const char *name, int family,
                                           unsigned short        port,
                                           ares_bool_t           want_cnames,
                                           struct ares_addrinfo *ai);

/* Same as ares_query_dnsrec() except does not take a channel lock.  Use this
 * if a channel lock is already held */
ares_status_t ares_query_nolock(ares_channel_t *channel, const char *name,
                                ares_dns_class_t     dnsclass,
                                ares_dns_rec_type_t  type,
                                ares_callback_dnsrec callback, void *arg,
                                unsigned short *qid);

/*! Flags controlling behavior for ares_send_nolock() */
typedef enum {
  ARES_SEND_FLAG_NOCACHE = 1 << 0, /*!< Do not query the cache */
  ARES_SEND_FLAG_NORETRY = 1 << 1  /*!< Do not retry this query on error */
} ares_send_flags_t;

/* Similar to ares_send_dnsrec() except does not take a channel lock, allows
 * specifying a particular server to use, and also flags controlling behavior.
 */
ares_status_t ares_send_nolock(ares_channel_t *channel, ares_server_t *server,
                               ares_send_flags_t        flags,
                               const ares_dns_record_t *dnsrec,
                               ares_callback_dnsrec callback, void *arg,
                               unsigned short *qid);

/* Same as ares_gethostbyaddr() except does not take a channel lock.  Use this
 * if a channel lock is already held */
void ares_gethostbyaddr_nolock(ares_channel_t *channel, const void *addr,
                               int addrlen, int family,
                               ares_host_callback callback, void *arg);

/*! Parse a compressed DNS name as defined in RFC1035 starting at the current
 *  offset within the buffer.
 *
 *  It is assumed that either a const buffer is being used, or before
 *  the message processing was started that ares_buf_reclaim() was called.
 *
 *  \param[in]  buf        Initialized buffer object
 *  \param[out] name       Pointer passed by reference to be filled in with
 *                         allocated string of the parsed name that must be
 *                         ares_free()'d by the caller.
 *  \param[in] is_hostname if ARES_TRUE, will validate the character set for
 *                         a valid hostname or will return error.
 *  \return ARES_SUCCESS on success
 */
ares_status_t ares_dns_name_parse(ares_buf_t *buf, char **name,
                                  ares_bool_t is_hostname);

/*! Write the DNS name to the buffer in the DNS domain-name syntax as a
 *  series of labels.  The maximum domain name length is 255 characters with
 *  each label being a maximum of 63 characters.  If the validate_hostname
 *  flag is set, it will strictly validate the character set.
 *
 *  \param[in,out]  buf   Initialized buffer object to write name to
 *  \param[in,out]  list  Pointer passed by reference to maintain a list of
 *                        domain name to indexes used for name compression.
 *                        Pass NULL (not by reference) if name compression isn't
 *                        desired.  Otherwise the list will be automatically
 *                        created upon first entry.
 *  \param[in]      validate_hostname Validate the hostname character set.
 *  \param[in]      name              Name to write out, it may have escape
 *                                    sequences.
 *  \return ARES_SUCCESS on success, most likely ARES_EBADNAME if the name is
 *          bad.
 */
ares_status_t ares_dns_name_write(ares_buf_t *buf, ares_llist_t **list,
                                  ares_bool_t validate_hostname,
                                  const char *name);

/*! Check if the queue is empty, if so, wake any waiters.  This is only
 *  effective if built with threading support.
 *
 *  Must be holding a channel lock when calling this function.
 *
 *  \param[in]  channel Initialized ares channel object
 */
void          ares_queue_notify_empty(ares_channel_t *channel);

#define ARES_CONFIG_CHECK(x)                                              \
  (x && x->lookups && ares_slist_len(x->servers) > 0 && x->timeout > 0 && \
   x->tries > 0)

ares_bool_t   ares_subnet_match(const struct ares_addr *addr,
                                const struct ares_addr *subnet,
                                unsigned char           netmask);
ares_bool_t   ares_addr_is_linklocal(const struct ares_addr *addr);

void          ares_qcache_destroy(ares_qcache_t *cache);
ares_status_t ares_qcache_create(ares_rand_state *rand_state,
                                 unsigned int     max_ttl,
                                 ares_qcache_t  **cache_out);
void          ares_qcache_flush(ares_qcache_t *cache);
ares_status_t ares_qcache_insert(ares_channel_t       *channel,
                                 const ares_timeval_t *now,
                                 const ares_query_t   *query,
                                 ares_dns_record_t    *dnsrec);
ares_status_t ares_qcache_fetch(ares_channel_t           *channel,
                                const ares_timeval_t     *now,
                                const ares_dns_record_t  *dnsrec,
                                const ares_dns_record_t **dnsrec_resp);

void   ares_metrics_record(const ares_query_t *query, ares_server_t *server,
                           ares_status_t status, const ares_dns_record_t *dnsrec);
size_t ares_metrics_server_timeout(const ares_server_t  *server,
                                   const ares_timeval_t *now);

ares_status_t ares_cookie_apply(ares_dns_record_t *dnsrec, ares_conn_t *conn,
                                const ares_timeval_t *now);
ares_status_t ares_cookie_validate(ares_query_t            *query,
                                   const ares_dns_record_t *dnsresp,
                                   ares_conn_t             *conn,
                                   const ares_timeval_t    *now);

ares_status_t ares_channel_threading_init(ares_channel_t *channel);
void          ares_channel_threading_destroy(ares_channel_t *channel);
void          ares_channel_lock(const ares_channel_t *channel);
void          ares_channel_unlock(const ares_channel_t *channel);

struct ares_event_thread;
typedef struct ares_event_thread ares_event_thread_t;

void          ares_event_thread_destroy(ares_channel_t *channel);
ares_status_t ares_event_thread_init(ares_channel_t *channel);


#ifdef _WIN32
#  define HOSTENT_ADDRTYPE_TYPE short
#  define HOSTENT_LENGTH_TYPE   short
#else
#  define HOSTENT_ADDRTYPE_TYPE int
#  define HOSTENT_LENGTH_TYPE   int
#endif

#endif /* __ARES_PRIVATE_H */
                                                                                                                                                 node-23.7.0/deps/cares/src/lib/ares_process.c                                                       0000664 0000000 0000000 00000124012 14746647661 0020776 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) 2010 Daniel Stenberg
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_STRINGS_H
#  include <strings.h>
#endif
#ifdef HAVE_SYS_IOCTL_H
#  include <sys/ioctl.h>
#endif
#ifdef NETWARE
#  include <sys/filio.h>
#endif
#ifdef HAVE_STDINT_H
#  include <stdint.h>
#endif

#include <assert.h>
#include <fcntl.h>
#include <limits.h>


static void          timeadd(ares_timeval_t *now, size_t millisecs);
static ares_status_t process_write(ares_channel_t *channel,
                                   ares_socket_t   write_fd);
static ares_status_t process_read(ares_channel_t       *channel,
                                  ares_socket_t         read_fd,
                                  const ares_timeval_t *now);
static ares_status_t process_timeouts(ares_channel_t       *channel,
                                      const ares_timeval_t *now);
static ares_status_t process_answer(ares_channel_t      *channel,
                                    const unsigned char *abuf, size_t alen,
                                    ares_conn_t          *conn,
                                    const ares_timeval_t *now);
static void handle_conn_error(ares_conn_t *conn, ares_bool_t critical_failure,
                              ares_status_t failure_status);
static ares_bool_t same_questions(const ares_query_t      *query,
                                  const ares_dns_record_t *arec);
static void        end_query(ares_channel_t *channel, ares_server_t *server,
                             ares_query_t *query, ares_status_t status,
                             const ares_dns_record_t *dnsrec);

static void        ares_query_remove_from_conn(ares_query_t *query)
{
  /* If its not part of a connection, it can't be tracked for timeouts either */
  ares_slist_node_destroy(query->node_queries_by_timeout);
  ares_llist_node_destroy(query->node_queries_to_conn);
  query->node_queries_by_timeout = NULL;
  query->node_queries_to_conn    = NULL;
  query->conn                    = NULL;
}

/* Invoke the server state callback after a success or failure */
static void invoke_server_state_cb(const ares_server_t *server,
                                   ares_bool_t success, int flags)
{
  const ares_channel_t *channel = server->channel;
  ares_buf_t           *buf;
  ares_status_t         status;
  char                 *server_string;

  if (channel->server_state_cb == NULL) {
    return;
  }

  buf = ares_buf_create();
  if (buf == NULL) {
    return; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  status = ares_get_server_addr(server, buf);
  if (status != ARES_SUCCESS) {
    ares_buf_destroy(buf); /* LCOV_EXCL_LINE: OutOfMemory */
    return;                /* LCOV_EXCL_LINE: OutOfMemory */
  }

  server_string = ares_buf_finish_str(buf, NULL);
  buf           = NULL;
  if (server_string == NULL) {
    return; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  channel->server_state_cb(server_string, success, flags,
                           channel->server_state_cb_data);
  ares_free(server_string);
}

static void server_increment_failures(ares_server_t *server,
                                      ares_bool_t    used_tcp)
{
  ares_slist_node_t    *node;
  const ares_channel_t *channel = server->channel;
  ares_timeval_t        next_retry_time;

  node = ares_slist_node_find(channel->servers, server);
  if (node == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  server->consec_failures++;
  ares_slist_node_reinsert(node);

  ares_tvnow(&next_retry_time);
  timeadd(&next_retry_time, channel->server_retry_delay);
  server->next_retry_time = next_retry_time;

  invoke_server_state_cb(server, ARES_FALSE,
                         used_tcp == ARES_TRUE ? ARES_SERV_STATE_TCP
                                               : ARES_SERV_STATE_UDP);
}

static void server_set_good(ares_server_t *server, ares_bool_t used_tcp)
{
  ares_slist_node_t    *node;
  const ares_channel_t *channel = server->channel;

  node = ares_slist_node_find(channel->servers, server);
  if (node == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  if (server->consec_failures > 0) {
    server->consec_failures = 0;
    ares_slist_node_reinsert(node);
  }

  server->next_retry_time.sec  = 0;
  server->next_retry_time.usec = 0;

  invoke_server_state_cb(server, ARES_TRUE,
                         used_tcp == ARES_TRUE ? ARES_SERV_STATE_TCP
                                               : ARES_SERV_STATE_UDP);
}

/* return true if now is exactly check time or later */
ares_bool_t ares_timedout(const ares_timeval_t *now,
                          const ares_timeval_t *check)
{
  ares_int64_t secs = (now->sec - check->sec);

  if (secs > 0) {
    return ARES_TRUE; /* yes, timed out */
  }
  if (secs < 0) {
    return ARES_FALSE; /* nope, not timed out */
  }

  /* if the full seconds were identical, check the sub second parts */
  return ((ares_int64_t)now->usec - (ares_int64_t)check->usec) >= 0
           ? ARES_TRUE
           : ARES_FALSE;
}

/* add the specific number of milliseconds to the time in the first argument */
static void timeadd(ares_timeval_t *now, size_t millisecs)
{
  now->sec  += (ares_int64_t)millisecs / 1000;
  now->usec += (unsigned int)((millisecs % 1000) * 1000);

  if (now->usec >= 1000000) {
    now->sec  += now->usec / 1000000;
    now->usec %= 1000000;
  }
}

static ares_status_t ares_process_fds_nolock(ares_channel_t         *channel,
                                             const ares_fd_events_t *events,
                                             size_t nevents, unsigned int flags)
{
  ares_timeval_t now;
  size_t         i;
  ares_status_t  status = ARES_SUCCESS;

  if (channel == NULL || (events == NULL && nevents != 0)) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ares_tvnow(&now);

  /* Process write events */
  for (i = 0; i < nevents; i++) {
    if (events[i].fd == ARES_SOCKET_BAD ||
        !(events[i].events & ARES_FD_EVENT_WRITE)) {
      continue;
    }
    status = process_write(channel, events[i].fd);
    /* We only care about ENOMEM, anything else is handled via connection
     * retries, etc */
    if (status == ARES_ENOMEM) {
      goto done;
    }
  }

  /* Process read events */
  for (i = 0; i < nevents; i++) {
    if (events[i].fd == ARES_SOCKET_BAD ||
        !(events[i].events & ARES_FD_EVENT_READ)) {
      continue;
    }
    status = process_read(channel, events[i].fd, &now);
    if (status == ARES_ENOMEM) {
      goto done;
    }
  }

  if (!(flags & ARES_PROCESS_FLAG_SKIP_NON_FD)) {
    ares_check_cleanup_conns(channel);
    status = process_timeouts(channel, &now);
    if (status == ARES_ENOMEM) {
      goto done;
    }
  }

done:
  if (status == ARES_ENOMEM) {
    return ARES_ENOMEM;
  }
  return ARES_SUCCESS;
}

ares_status_t ares_process_fds(ares_channel_t         *channel,
                               const ares_fd_events_t *events, size_t nevents,
                               unsigned int flags)
{
  ares_status_t status;

  if (channel == NULL) {
    return ARES_EFORMERR;
  }

  ares_channel_lock(channel);
  status = ares_process_fds_nolock(channel, events, nevents, flags);
  ares_channel_unlock(channel);
  return status;
}

void ares_process_fd(ares_channel_t *channel, ares_socket_t read_fd,
                     ares_socket_t write_fd)
{
  ares_fd_events_t events[2];
  size_t           nevents = 0;

  memset(events, 0, sizeof(events));

  if (read_fd != ARES_SOCKET_BAD) {
    nevents++;
    events[nevents - 1].fd      = read_fd;
    events[nevents - 1].events |= ARES_FD_EVENT_READ;
  }

  if (write_fd != ARES_SOCKET_BAD) {
    if (write_fd != read_fd) {
      nevents++;
    }
    events[nevents - 1].fd      = write_fd;
    events[nevents - 1].events |= ARES_FD_EVENT_WRITE;
  }

  ares_process_fds(channel, events, nevents, ARES_PROCESS_FLAG_NONE);
}

static ares_socket_t *channel_socket_list(const ares_channel_t *channel,
                                          size_t               *num)
{
  ares_slist_node_t *snode;
  ares_array_t      *arr = ares_array_create(sizeof(ares_socket_t), NULL);

  *num = 0;

  if (arr == NULL) {
    return NULL; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  for (snode = ares_slist_node_first(channel->servers); snode != NULL;
       snode = ares_slist_node_next(snode)) {
    ares_server_t     *server = ares_slist_node_val(snode);
    ares_llist_node_t *node;

    for (node = ares_llist_node_first(server->connections); node != NULL;
         node = ares_llist_node_next(node)) {
      const ares_conn_t *conn = ares_llist_node_val(node);
      ares_socket_t     *sptr;
      ares_status_t      status;

      if (conn->fd == ARES_SOCKET_BAD) {
        continue;
      }

      status = ares_array_insert_last((void **)&sptr, arr);
      if (status != ARES_SUCCESS) {
        ares_array_destroy(arr); /* LCOV_EXCL_LINE: OutOfMemory */
        return NULL;             /* LCOV_EXCL_LINE: OutOfMemory */
      }
      *sptr = conn->fd;
    }
  }

  return ares_array_finish(arr, num);
}

/* Something interesting happened on the wire, or there was a timeout.
 * See what's up and respond accordingly.
 */
void ares_process(ares_channel_t *channel, fd_set *read_fds, fd_set *write_fds)
{
  size_t            i;
  size_t            num_sockets;
  ares_socket_t    *socketlist;
  ares_fd_events_t *events  = NULL;
  size_t            nevents = 0;

  if (channel == NULL) {
    return;
  }

  ares_channel_lock(channel);

  /* There is no good way to iterate across an fd_set, instead we must pull a
   * list of all known fds, and iterate across that checking against the fd_set.
   */
  socketlist = channel_socket_list(channel, &num_sockets);

  /* Lets create an events array, maximum number is the number of sockets in
   * the list, so we'll use that and just track entries with nevents */
  if (num_sockets) {
    events = ares_malloc_zero(sizeof(*events) * num_sockets);
    if (events == NULL) {
      goto done;
    }
  }

  for (i = 0; i < num_sockets; i++) {
    ares_bool_t had_read = ARES_FALSE;
    if (read_fds && FD_ISSET(socketlist[i], read_fds)) {
      nevents++;
      events[nevents - 1].fd      = socketlist[i];
      events[nevents - 1].events |= ARES_FD_EVENT_READ;
      had_read                    = ARES_TRUE;
    }
    if (write_fds && FD_ISSET(socketlist[i], write_fds)) {
      if (!had_read) {
        nevents++;
      }
      events[nevents - 1].fd      = socketlist[i];
      events[nevents - 1].events |= ARES_FD_EVENT_WRITE;
    }
  }

done:
  ares_process_fds_nolock(channel, events, nevents, ARES_PROCESS_FLAG_NONE);
  ares_free(events);
  ares_free(socketlist);
  ares_channel_unlock(channel);
}

static ares_status_t process_write(ares_channel_t *channel,
                                   ares_socket_t   write_fd)
{
  ares_conn_t  *conn = ares_conn_from_fd(channel, write_fd);
  ares_status_t status;

  if (conn == NULL) {
    return ARES_SUCCESS;
  }

  /* Mark as connected if we got here and TFO Initial not set */
  if (!(conn->flags & ARES_CONN_FLAG_TFO_INITIAL)) {
    conn->state_flags |= ARES_CONN_STATE_CONNECTED;
  }

  status = ares_conn_flush(conn);
  if (status != ARES_SUCCESS) {
    handle_conn_error(conn, ARES_TRUE, status);
  }
  return status;
}

void ares_process_pending_write(ares_channel_t *channel)
{
  ares_slist_node_t *node;

  if (channel == NULL) {
    return;
  }

  ares_channel_lock(channel);
  if (!channel->notify_pending_write) {
    ares_channel_unlock(channel);
    return;
  }

  /* Set as untriggerd before calling into ares_conn_flush(), this is
   * because its possible ares_conn_flush() might cause additional data to
   * be enqueued if there is some form of exception so it will need to recurse.
   */
  channel->notify_pending_write = ARES_FALSE;

  for (node = ares_slist_node_first(channel->servers); node != NULL;
       node = ares_slist_node_next(node)) {
    ares_server_t *server = ares_slist_node_val(node);
    ares_conn_t   *conn   = server->tcp_conn;
    ares_status_t  status;

    if (conn == NULL) {
      continue;
    }

    /* Enqueue any pending data if there is any */
    status = ares_conn_flush(conn);
    if (status != ARES_SUCCESS) {
      handle_conn_error(conn, ARES_TRUE, status);
    }
  }

  ares_channel_unlock(channel);
}

static ares_status_t read_conn_packets(ares_conn_t *conn)
{
  ares_bool_t           read_again;
  ares_conn_err_t       err;
  const ares_channel_t *channel = conn->server->channel;

  do {
    size_t         count;
    size_t         len = 65535;
    unsigned char *ptr;
    size_t         start_len = ares_buf_len(conn->in_buf);

    /* If UDP, lets write out a placeholder for the length indicator */
    if (!(conn->flags & ARES_CONN_FLAG_TCP) &&
        ares_buf_append_be16(conn->in_buf, 0) != ARES_SUCCESS) {
      handle_conn_error(conn, ARES_FALSE /* not critical to connection */,
                        ARES_SUCCESS);
      return ARES_ENOMEM;
    }

    /* Get a buffer of sufficient size */
    ptr = ares_buf_append_start(conn->in_buf, &len);

    if (ptr == NULL) {
      handle_conn_error(conn, ARES_FALSE /* not critical to connection */,
                        ARES_SUCCESS);
      return ARES_ENOMEM;
    }

    /* Read from socket */
    err = ares_conn_read(conn, ptr, len, &count);

    if (err != ARES_CONN_ERR_SUCCESS) {
      ares_buf_append_finish(conn->in_buf, 0);
      if (!(conn->flags & ARES_CONN_FLAG_TCP)) {
        ares_buf_set_length(conn->in_buf, start_len);
      }
      break;
    }

    /* Record amount of data read */
    ares_buf_append_finish(conn->in_buf, count);

    /* Only loop if sockets support non-blocking operation, and are using UDP
     * or are using TCP and read the maximum buffer size */
    read_again = ARES_FALSE;
    if (channel->sock_funcs.flags & ARES_SOCKFUNC_FLAG_NONBLOCKING &&
        (!(conn->flags & ARES_CONN_FLAG_TCP) || count == len)) {
      read_again = ARES_TRUE;
    }

    /* If UDP, overwrite length */
    if (!(conn->flags & ARES_CONN_FLAG_TCP)) {
      len = ares_buf_len(conn->in_buf);
      ares_buf_set_length(conn->in_buf, start_len);
      ares_buf_append_be16(conn->in_buf, (unsigned short)count);
      ares_buf_set_length(conn->in_buf, len);
    }
    /* Try to read again only if *we* set up the socket, otherwise it may be
     * a blocking socket and would cause recvfrom to hang. */
  } while (read_again);

  if (err != ARES_CONN_ERR_SUCCESS && err != ARES_CONN_ERR_WOULDBLOCK) {
    handle_conn_error(conn, ARES_TRUE, ARES_ECONNREFUSED);
    return ARES_ECONNREFUSED;
  }

  return ARES_SUCCESS;
}

static ares_status_t read_answers(ares_conn_t *conn, const ares_timeval_t *now)
{
  ares_status_t   status;
  ares_channel_t *channel = conn->server->channel;

  /* Process all queued answers */
  while (1) {
    unsigned short       dns_len  = 0;
    const unsigned char *data     = NULL;
    size_t               data_len = 0;

    /* Tag so we can roll back */
    ares_buf_tag(conn->in_buf);

    /* Read length indicator */
    status = ares_buf_fetch_be16(conn->in_buf, &dns_len);
    if (status != ARES_SUCCESS) {
      ares_buf_tag_rollback(conn->in_buf);
      break;
    }

    /* Not enough data for a full response yet */
    status = ares_buf_consume(conn->in_buf, dns_len);
    if (status != ARES_SUCCESS) {
      ares_buf_tag_rollback(conn->in_buf);
      break;
    }

    /* Can't fail except for misuse */
    data = ares_buf_tag_fetch(conn->in_buf, &data_len);
    if (data == NULL || data_len < 2) {
      ares_buf_tag_clear(conn->in_buf);
      break;
    }

    /* Strip off 2 bytes length */
    data     += 2;
    data_len -= 2;

    /* We finished reading this answer; process it */
    status = process_answer(channel, data, data_len, conn, now);
    if (status != ARES_SUCCESS) {
      handle_conn_error(conn, ARES_TRUE, status);
      return status;
    }

    /* Since we processed the answer, clear the tag so space can be reclaimed */
    ares_buf_tag_clear(conn->in_buf);
  }
  return status;
}

static ares_status_t process_read(ares_channel_t       *channel,
                                  ares_socket_t         read_fd,
                                  const ares_timeval_t *now)
{
  ares_conn_t  *conn = ares_conn_from_fd(channel, read_fd);
  ares_status_t status;

  if (conn == NULL) {
    return ARES_SUCCESS;
  }

  /* TODO: There might be a potential issue here where there was a read that
   *       read some data, then looped and read again and got a disconnect.
   *       Right now, that would cause a resend instead of processing the data
   *       we have.  This is fairly unlikely to occur due to only looping if
   *       a full buffer of 65535 bytes was read. */
  status = read_conn_packets(conn);

  if (status != ARES_SUCCESS) {
    return status;
  }

  return read_answers(conn, now);
}

/* If any queries have timed out, note the timeout and move them on. */
static ares_status_t process_timeouts(ares_channel_t       *channel,
                                      const ares_timeval_t *now)
{
  ares_slist_node_t *node;
  ares_status_t      status = ARES_SUCCESS;

  /* Just keep popping off the first as this list will re-sort as things come
   * and go.  We don't want to try to rely on 'next' as some operation might
   * cause a cleanup of that pointer and would become invalid */
  while ((node = ares_slist_node_first(channel->queries_by_timeout)) != NULL) {
    ares_query_t *query = ares_slist_node_val(node);
    ares_conn_t  *conn;

    /* Since this is sorted, as soon as we hit a query that isn't timed out,
     * break */
    if (!ares_timedout(now, &query->timeout)) {
      break;
    }

    query->timeouts++;

    conn = query->conn;
    server_increment_failures(conn->server, query->using_tcp);
    status = ares_requeue_query(query, now, ARES_ETIMEOUT, ARES_TRUE, NULL);
    if (status == ARES_ENOMEM) {
      goto done;
    }
  }
done:
  if (status == ARES_ENOMEM) {
    return ARES_ENOMEM;
  }
  return ARES_SUCCESS;
}

static ares_status_t rewrite_without_edns(ares_query_t *query)
{
  ares_status_t status = ARES_SUCCESS;
  size_t        i;
  ares_bool_t   found_opt_rr = ARES_FALSE;

  /* Find and remove the OPT RR record */
  for (i = 0; i < ares_dns_record_rr_cnt(query->query, ARES_SECTION_ADDITIONAL);
       i++) {
    const ares_dns_rr_t *rr;
    rr = ares_dns_record_rr_get(query->query, ARES_SECTION_ADDITIONAL, i);
    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {
      ares_dns_record_rr_del(query->query, ARES_SECTION_ADDITIONAL, i);
      found_opt_rr = ARES_TRUE;
      break;
    }
  }

  if (!found_opt_rr) {
    status = ARES_EFORMERR;
    goto done;
  }

done:
  return status;
}

static ares_bool_t issue_might_be_edns(const ares_dns_record_t *req,
                                       const ares_dns_record_t *rsp)
{
  const ares_dns_rr_t *rr;

  /* If we use EDNS and server answers with FORMERR without an OPT RR, the
   * protocol extension is not understood by the responder. We must retry the
   * query without EDNS enabled. */
  if (ares_dns_record_get_rcode(rsp) != ARES_RCODE_FORMERR) {
    return ARES_FALSE;
  }

  rr = ares_dns_get_opt_rr_const(req);
  if (rr == NULL) {
    /* We didn't send EDNS */
    return ARES_FALSE;
  }

  if (ares_dns_get_opt_rr_const(rsp) == NULL) {
    /* Spec says EDNS won't be echo'd back on non-supporting servers, so
     * retry without EDNS */
    return ARES_TRUE;
  }

  /* As per issue #911 some non-compliant servers that do indeed support EDNS
   * but don't support unrecognized option codes exist.  At this point we
   * expect them to have also returned an EDNS opt record, but we may remove
   * that check in the future. Lets detect this situation if we're sending
   * option codes */
  if (ares_dns_rr_get_opt_cnt(rr, ARES_RR_OPT_OPTIONS) == 0) {
    /* We didn't send any option codes */
    return ARES_FALSE;
  }

  if (ares_dns_get_opt_rr_const(rsp) != NULL) {
    /* At this time we're requiring the server to respond with EDNS opt
     * records since that's what has been observed in the field.  We might
     * find in the future we have to remove this, who knows. Lets go
     * ahead and force a retry without EDNS*/
    return ARES_TRUE;
  }

  return ARES_FALSE;
}

/* Handle an answer from a server. This must NEVER cleanup the
 * server connection! Return something other than ARES_SUCCESS to cause
 * the connection to be terminated after this call. */
static ares_status_t process_answer(ares_channel_t      *channel,
                                    const unsigned char *abuf, size_t alen,
                                    ares_conn_t          *conn,
                                    const ares_timeval_t *now)
{
  ares_query_t      *query;
  /* Cache these as once ares_send_query() gets called, it may end up
   * invalidating the connection all-together */
  ares_server_t     *server  = conn->server;
  ares_dns_record_t *rdnsrec = NULL;
  ares_status_t      status;
  ares_bool_t        is_cached = ARES_FALSE;

  /* UDP can have 0-byte messages, drop them to the ground */
  if (alen == 0) {
    return ARES_SUCCESS;
  }

  /* Parse the response */
  status = ares_dns_parse(abuf, alen, 0, &rdnsrec);
  if (status != ARES_SUCCESS) {
    /* Malformations are never accepted */
    status = ARES_EBADRESP;
    goto cleanup;
  }

  /* Find the query corresponding to this packet. The queries are
   * hashed/bucketed by query id, so this lookup should be quick.
   */
  query = ares_htable_szvp_get_direct(channel->queries_by_qid,
                                      ares_dns_record_get_id(rdnsrec));
  if (!query) {
    /* We may have stopped listening for this query, that's ok */
    status = ARES_SUCCESS;
    goto cleanup;
  }

  /* Both the query id and the questions must be the same. We will drop any
   * replies that aren't for the same query as this is considered invalid. */
  if (!same_questions(query, rdnsrec)) {
    /* Possible qid conflict due to delayed response, that's ok */
    status = ARES_SUCCESS;
    goto cleanup;
  }

  /* Validate DNS cookie in response. This function may need to requeue the
   * query. */
  if (ares_cookie_validate(query, rdnsrec, conn, now) != ARES_SUCCESS) {
    /* Drop response and return */
    status = ARES_SUCCESS;
    goto cleanup;
  }

  /* At this point we know we've received an answer for this query, so we should
   * remove it from the connection's queue so we can possibly invalidate the
   * connection. Delay cleaning up the connection though as we may enqueue
   * something new.  */
  ares_llist_node_destroy(query->node_queries_to_conn);
  query->node_queries_to_conn = NULL;

  /* There are old servers that don't understand EDNS at all, then some servers
   * that have non-compliant implementations.  Lets try to detect this sort
   * of thing. */
  if (issue_might_be_edns(query->query, rdnsrec)) {
    status = rewrite_without_edns(query);
    if (status != ARES_SUCCESS) {
      end_query(channel, server, query, status, NULL);
      goto cleanup;
    }

    /* Send to same server */
    ares_send_query(server, query, now);
    status = ARES_SUCCESS;
    goto cleanup;
  }

  /* If we got a truncated UDP packet and are not ignoring truncation,
   * don't accept the packet, and switch the query to TCP if we hadn't
   * done so already.
   */
  if (ares_dns_record_get_flags(rdnsrec) & ARES_FLAG_TC &&
      !(conn->flags & ARES_CONN_FLAG_TCP) &&
      !(channel->flags & ARES_FLAG_IGNTC)) {
    query->using_tcp = ARES_TRUE;
    ares_send_query(NULL, query, now);
    status = ARES_SUCCESS; /* Switched to TCP is ok */
    goto cleanup;
  }

  /* If we aren't passing through all error packets, discard packets
   * with SERVFAIL, NOTIMP, or REFUSED response codes.
   */
  if (!(channel->flags & ARES_FLAG_NOCHECKRESP)) {
    ares_dns_rcode_t rcode = ares_dns_record_get_rcode(rdnsrec);
    if (rcode == ARES_RCODE_SERVFAIL || rcode == ARES_RCODE_NOTIMP ||
        rcode == ARES_RCODE_REFUSED) {
      switch (rcode) {
        case ARES_RCODE_SERVFAIL:
          status = ARES_ESERVFAIL;
          break;
        case ARES_RCODE_NOTIMP:
          status = ARES_ENOTIMP;
          break;
        case ARES_RCODE_REFUSED:
          status = ARES_EREFUSED;
          break;
        default:
          break;
      }

      server_increment_failures(server, query->using_tcp);
      ares_requeue_query(query, now, status, ARES_TRUE, rdnsrec);

      /* Should any of these cause a connection termination?
       * Maybe SERVER_FAILURE? */
      status = ARES_SUCCESS;
      goto cleanup;
    }
  }

  /* If cache insertion was successful, it took ownership.  We ignore
   * other cache insertion failures. */
  if (ares_qcache_insert(channel, now, query, rdnsrec) == ARES_SUCCESS) {
    is_cached = ARES_TRUE;
  }

  server_set_good(server, query->using_tcp);
  end_query(channel, server, query, ARES_SUCCESS, rdnsrec);

  status = ARES_SUCCESS;

cleanup:
  /* Don't cleanup the cached pointer to the dns response */
  if (!is_cached) {
    ares_dns_record_destroy(rdnsrec);
  }

  return status;
}

static void handle_conn_error(ares_conn_t *conn, ares_bool_t critical_failure,
                              ares_status_t failure_status)
{
  ares_server_t *server = conn->server;

  /* Increment failures first before requeue so it is unlikely to requeue
   * to the same server */
  if (critical_failure) {
    server_increment_failures(
      server, (conn->flags & ARES_CONN_FLAG_TCP) ? ARES_TRUE : ARES_FALSE);
  }

  /* This will requeue any connections automatically */
  ares_close_connection(conn, failure_status);
}

ares_status_t ares_requeue_query(ares_query_t *query, const ares_timeval_t *now,
                                 ares_status_t            status,
                                 ares_bool_t              inc_try_count,
                                 const ares_dns_record_t *dnsrec)
{
  ares_channel_t *channel   = query->channel;
  size_t          max_tries = ares_slist_len(channel->servers) * channel->tries;

  ares_query_remove_from_conn(query);

  if (status != ARES_SUCCESS) {
    query->error_status = status;
  }

  if (inc_try_count) {
    query->try_count++;
  }

  if (query->try_count < max_tries && !query->no_retries) {
    return ares_send_query(NULL, query, now);
  }

  /* If we are here, all attempts to perform query failed. */
  if (query->error_status == ARES_SUCCESS) {
    query->error_status = ARES_ETIMEOUT;
  }

  end_query(channel, NULL, query, query->error_status, dnsrec);
  return ARES_ETIMEOUT;
}

/*! Count the number of servers that share the same highest priority (lowest
 *  consecutive failures).  Since they are sorted in priority order, we just
 *  stop when the consecutive failure count changes. Used for random selection
 *  of good servers. */
static size_t count_highest_prio_servers(const ares_channel_t *channel)
{
  ares_slist_node_t *node;
  size_t             cnt                  = 0;
  size_t             last_consec_failures = SIZE_MAX;

  for (node = ares_slist_node_first(channel->servers); node != NULL;
       node = ares_slist_node_next(node)) {
    const ares_server_t *server = ares_slist_node_val(node);

    if (last_consec_failures != SIZE_MAX &&
        last_consec_failures < server->consec_failures) {
      break;
    }

    last_consec_failures = server->consec_failures;
    cnt++;
  }

  return cnt;
}

/* Pick a random *best* server from the list, we first get a random number in
 * the range of the number of *best* servers, then scan until we find that
 * server in the list */
static ares_server_t *ares_random_server(ares_channel_t *channel)
{
  unsigned char      c;
  size_t             cnt;
  size_t             idx;
  ares_slist_node_t *node;
  size_t             num_servers = count_highest_prio_servers(channel);

  /* Silence coverity, not possible */
  if (num_servers == 0) {
    return NULL;
  }

  ares_rand_bytes(channel->rand_state, &c, 1);

  cnt = c;
  idx = cnt % num_servers;

  cnt = 0;
  for (node = ares_slist_node_first(channel->servers); node != NULL;
       node = ares_slist_node_next(node)) {
    if (cnt == idx) {
      return ares_slist_node_val(node);
    }

    cnt++;
  }

  return NULL;
}

static void server_probe_cb(void *arg, ares_status_t status, size_t timeouts,
                            const ares_dns_record_t *dnsrec)
{
  (void)arg;
  (void)status;
  (void)timeouts;
  (void)dnsrec;
  /* Nothing to do, the logic internally will handle success/fail of this */
}

/* Determine if we should probe a downed server */
static void ares_probe_failed_server(ares_channel_t      *channel,
                                     const ares_server_t *server,
                                     const ares_query_t  *query)
{
  const ares_server_t *last_server = ares_slist_last_val(channel->servers);
  unsigned short       r;
  ares_timeval_t       now;
  ares_slist_node_t   *node;
  ares_server_t       *probe_server = NULL;

  /* If no servers have failures, or we're not configured with a server retry
   * chance, then nothing to probe */
  if ((last_server != NULL && last_server->consec_failures == 0) ||
      channel->server_retry_chance == 0) {
    return;
  }

  /* Generate a random value to decide whether to retry a failed server. The
   * probability to use is 1/channel->server_retry_chance, rounded up to a
   * precision of 1/2^B where B is the number of bits in the random value.
   * We use an unsigned short for the random value for increased precision.
   */
  ares_rand_bytes(channel->rand_state, (unsigned char *)&r, sizeof(r));
  if (r % channel->server_retry_chance != 0) {
    return;
  }

  /* Select the first server with failures to retry that has passed the retry
   * timeout and doesn't already have a pending probe */
  ares_tvnow(&now);
  for (node = ares_slist_node_first(channel->servers); node != NULL;
       node = ares_slist_node_next(node)) {
    ares_server_t *node_val = ares_slist_node_val(node);
    if (node_val != NULL && node_val->consec_failures > 0 &&
        !node_val->probe_pending &&
        ares_timedout(&now, &node_val->next_retry_time)) {
      probe_server = node_val;
      break;
    }
  }

  /* Either nothing to probe or the query was enqueud to the same server
   * we were going to probe. Do nothing. */
  if (probe_server == NULL || server == probe_server) {
    return;
  }

  /* Enqueue an identical query onto the specified server without honoring
   * the cache or allowing retries.  We want to make sure it only attempts to
   * use the server in question */
  probe_server->probe_pending = ARES_TRUE;
  ares_send_nolock(channel, probe_server,
                   ARES_SEND_FLAG_NOCACHE | ARES_SEND_FLAG_NORETRY,
                   query->query, server_probe_cb, NULL, NULL);
}

static size_t ares_calc_query_timeout(const ares_query_t   *query,
                                      const ares_server_t  *server,
                                      const ares_timeval_t *now)
{
  const ares_channel_t *channel  = query->channel;
  size_t                timeout  = ares_metrics_server_timeout(server, now);
  size_t                timeplus = timeout;
  size_t                rounds;
  size_t                num_servers = ares_slist_len(channel->servers);

  if (num_servers == 0) {
    return 0; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* For each trip through the entire server list, we want to double the
   * retry from the last retry */
  rounds = (query->try_count / num_servers);
  if (rounds > 0) {
    timeplus <<= rounds;
  }

  if (channel->maxtimeout && timeplus > channel->maxtimeout) {
    timeplus = channel->maxtimeout;
  }

  /* Add some jitter to the retry timeout.
   *
   * Jitter is needed in situation when resolve requests are performed
   * simultaneously from multiple hosts and DNS server throttle these requests.
   * Adding randomness allows to avoid synchronisation of retries.
   *
   * Value of timeplus adjusted randomly to the range [0.5 * timeplus,
   * timeplus].
   */
  if (rounds > 0) {
    unsigned short r;
    float          delta_multiplier;

    ares_rand_bytes(channel->rand_state, (unsigned char *)&r, sizeof(r));
    delta_multiplier  = ((float)r / USHRT_MAX) * 0.5f;
    timeplus         -= (size_t)((float)timeplus * delta_multiplier);
  }

  /* We want explicitly guarantee that timeplus is greater or equal to timeout
   * specified in channel options. */
  if (timeplus < timeout) {
    timeplus = timeout;
  }

  return timeplus;
}

static ares_conn_t *ares_fetch_connection(const ares_channel_t *channel,
                                          ares_server_t        *server,
                                          const ares_query_t   *query)
{
  ares_llist_node_t *node;
  ares_conn_t       *conn;

  if (query->using_tcp) {
    return server->tcp_conn;
  }

  /* Fetch existing UDP connection */
  node = ares_llist_node_first(server->connections);
  if (node == NULL) {
    return NULL;
  }

  conn = ares_llist_node_val(node);
  /* Not UDP, skip */
  if (conn->flags & ARES_CONN_FLAG_TCP) {
    return NULL;
  }

  /* Used too many times */
  if (channel->udp_max_queries > 0 &&
      conn->total_queries >= channel->udp_max_queries) {
    return NULL;
  }

  return conn;
}

static ares_status_t ares_conn_query_write(ares_conn_t          *conn,
                                           ares_query_t         *query,
                                           const ares_timeval_t *now)
{
  ares_server_t  *server  = conn->server;
  ares_channel_t *channel = server->channel;
  ares_status_t   status;

  status = ares_cookie_apply(query->query, conn, now);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* We write using the TCP format even for UDP, we just strip the length
   * before putting on the wire */
  status = ares_dns_write_buf_tcp(query->query, conn->out_buf);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Not pending a TFO write and not connected, so we can't even try to
   * write until we get a signal */
  if (conn->flags & ARES_CONN_FLAG_TCP &&
      !(conn->state_flags & ARES_CONN_STATE_CONNECTED) &&
      !(conn->flags & ARES_CONN_FLAG_TFO_INITIAL)) {
    return ARES_SUCCESS;
  }

  /* Delay actual write if possible (TCP only, and only if callback
   * configured) */
  if (channel->notify_pending_write_cb && !channel->notify_pending_write &&
      conn->flags & ARES_CONN_FLAG_TCP) {
    channel->notify_pending_write = ARES_TRUE;
    channel->notify_pending_write_cb(channel->notify_pending_write_cb_data);
    return ARES_SUCCESS;
  }

  /* Unfortunately we need to write right away and can't aggregate multiple
   * queries into a single write. */
  return ares_conn_flush(conn);
}

ares_status_t ares_send_query(ares_server_t *requested_server,
                              ares_query_t *query, const ares_timeval_t *now)
{
  ares_channel_t *channel = query->channel;
  ares_server_t  *server;
  ares_conn_t    *conn;
  size_t          timeplus;
  ares_status_t   status;
  ares_bool_t     probe_downed_server = ARES_TRUE;


  /* Choose the server to send the query to */
  if (requested_server != NULL) {
    server = requested_server;
  } else {
    /* If rotate is turned on, do a random selection */
    if (channel->rotate) {
      server = ares_random_server(channel);
    } else {
      /* First server in list */
      server = ares_slist_first_val(channel->servers);
    }
  }

  if (server == NULL) {
    end_query(channel, server, query, ARES_ENOSERVER /* ? */, NULL);
    return ARES_ENOSERVER;
  }

  /* If a query is directed to a specific query, or the server chosen has
   * failures, or the query is being retried, don't probe for downed servers */
  if (requested_server != NULL || server->consec_failures > 0 ||
      query->try_count != 0) {
    probe_downed_server = ARES_FALSE;
  }

  conn = ares_fetch_connection(channel, server, query);
  if (conn == NULL) {
    status = ares_open_connection(&conn, channel, server, query->using_tcp);
    switch (status) {
      /* Good result, continue on */
      case ARES_SUCCESS:
        break;

      /* These conditions are retryable as they are server-specific
       * error codes */
      case ARES_ECONNREFUSED:
      case ARES_EBADFAMILY:
        server_increment_failures(server, query->using_tcp);
        return ares_requeue_query(query, now, status, ARES_TRUE, NULL);

      /* Anything else is not retryable, likely ENOMEM */
      default:
        end_query(channel, server, query, status, NULL);
        return status;
    }
  }

  /* Write the query */
  status = ares_conn_query_write(conn, query, now);
  switch (status) {
    /* Good result, continue on */
    case ARES_SUCCESS:
      break;

    case ARES_ENOMEM:
      /* Not retryable */
      end_query(channel, server, query, status, NULL);
      return status;

    /* These conditions are retryable as they are server-specific
     * error codes */
    case ARES_ECONNREFUSED:
    case ARES_EBADFAMILY:
      handle_conn_error(conn, ARES_TRUE, status);
      status = ares_requeue_query(query, now, status, ARES_TRUE, NULL);
      if (status == ARES_ETIMEOUT) {
        status = ARES_ECONNREFUSED;
      }
      return status;

    default:
      server_increment_failures(server, query->using_tcp);
      status = ares_requeue_query(query, now, status, ARES_TRUE, NULL);
      return status;
  }

  timeplus = ares_calc_query_timeout(query, server, now);
  /* Keep track of queries bucketed by timeout, so we can process
   * timeout events quickly.
   */
  ares_slist_node_destroy(query->node_queries_by_timeout);
  query->ts      = *now;
  query->timeout = *now;
  timeadd(&query->timeout, timeplus);
  query->node_queries_by_timeout =
    ares_slist_insert(channel->queries_by_timeout, query);
  if (!query->node_queries_by_timeout) {
    /* LCOV_EXCL_START: OutOfMemory */
    end_query(channel, server, query, ARES_ENOMEM, NULL);
    return ARES_ENOMEM;
    /* LCOV_EXCL_STOP */
  }

  /* Keep track of queries bucketed by connection, so we can process errors
   * quickly. */
  ares_llist_node_destroy(query->node_queries_to_conn);
  query->node_queries_to_conn =
    ares_llist_insert_last(conn->queries_to_conn, query);

  if (query->node_queries_to_conn == NULL) {
    /* LCOV_EXCL_START: OutOfMemory */
    end_query(channel, server, query, ARES_ENOMEM, NULL);
    return ARES_ENOMEM;
    /* LCOV_EXCL_STOP */
  }

  query->conn = conn;
  conn->total_queries++;

  /* We just successfully enqueud a query, see if we should probe downed
   * servers. */
  if (probe_downed_server) {
    ares_probe_failed_server(channel, server, query);
  }

  return ARES_SUCCESS;
}

static ares_bool_t same_questions(const ares_query_t      *query,
                                  const ares_dns_record_t *arec)
{
  size_t                   i;
  ares_bool_t              rv      = ARES_FALSE;
  const ares_dns_record_t *qrec    = query->query;
  const ares_channel_t    *channel = query->channel;


  if (ares_dns_record_query_cnt(qrec) != ares_dns_record_query_cnt(arec)) {
    goto done;
  }

  for (i = 0; i < ares_dns_record_query_cnt(qrec); i++) {
    const char         *qname = NULL;
    const char         *aname = NULL;
    ares_dns_rec_type_t qtype;
    ares_dns_rec_type_t atype;
    ares_dns_class_t    qclass;
    ares_dns_class_t    aclass;

    if (ares_dns_record_query_get(qrec, i, &qname, &qtype, &qclass) !=
          ARES_SUCCESS ||
        qname == NULL) {
      goto done;
    }

    if (ares_dns_record_query_get(arec, i, &aname, &atype, &aclass) !=
          ARES_SUCCESS ||
        aname == NULL) {
      goto done;
    }

    if (qtype != atype || qclass != aclass) {
      goto done;
    }

    if (channel->flags & ARES_FLAG_DNS0x20 && !query->using_tcp) {
      /* NOTE: for DNS 0x20, part of the protection is to use a case-sensitive
       *       comparison of the DNS query name.  This expects the upstream DNS
       *       server to preserve the case of the name in the response packet.
       *       https://datatracker.ietf.org/doc/html/draft-vixie-dnsext-dns0x20-00
       */
      if (!ares_streq(qname, aname)) {
        goto done;
      }
    } else {
      /* without DNS0x20 use case-insensitive matching */
      if (!ares_strcaseeq(qname, aname)) {
        goto done;
      }
    }
  }

  rv = ARES_TRUE;

done:
  return rv;
}

static void ares_detach_query(ares_query_t *query)
{
  /* Remove the query from all the lists in which it is linked */
  ares_query_remove_from_conn(query);
  ares_htable_szvp_remove(query->channel->queries_by_qid, query->qid);
  ares_llist_node_destroy(query->node_all_queries);
  query->node_all_queries = NULL;
}

static void end_query(ares_channel_t *channel, ares_server_t *server,
                      ares_query_t *query, ares_status_t status,
                      const ares_dns_record_t *dnsrec)
{
  /* If we were probing for the server to come back online, lets mark it as
   * no longer being probed */
  if (server != NULL) {
    server->probe_pending = ARES_FALSE;
  }

  ares_metrics_record(query, server, status, dnsrec);

  /* Invoke the callback. */
  query->callback(query->arg, status, query->timeouts, dnsrec);
  ares_free_query(query);

  /* Check and notify if no other queries are enqueued on the channel.  This
   * must come after the callback and freeing the query for 2 reasons.
   *  1) The callback itself may enqueue a new query
   *  2) Technically the current query isn't detached until it is free()'d.
   */
  ares_queue_notify_empty(channel);
}

void ares_free_query(ares_query_t *query)
{
  ares_detach_query(query);
  /* Zero out some important stuff, to help catch bugs */
  query->callback = NULL;
  query->arg      = NULL;
  /* Deallocate the memory associated with the query */
  ares_dns_record_destroy(query->query);

  ares_free(query);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/cares/src/lib/ares_qcache.c                                                        0000664 0000000 0000000 00000027557 14746647661 0020564 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"

struct ares_qcache {
  ares_htable_strvp_t *cache;
  ares_slist_t        *expire;
  unsigned int         max_ttl;
};

typedef struct {
  char              *key;
  ares_dns_record_t *dnsrec;
  time_t             expire_ts;
  time_t             insert_ts;
} ares_qcache_entry_t;

static char *ares_qcache_calc_key(const ares_dns_record_t *dnsrec)
{
  ares_buf_t      *buf = ares_buf_create();
  size_t           i;
  ares_status_t    status;
  ares_dns_flags_t flags;

  if (dnsrec == NULL || buf == NULL) {
    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* Format is OPCODE|FLAGS[|QTYPE1|QCLASS1|QNAME1]... */

  status = ares_buf_append_str(
    buf, ares_dns_opcode_tostr(ares_dns_record_get_opcode(dnsrec)));
  if (status != ARES_SUCCESS) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  status = ares_buf_append_byte(buf, '|');
  if (status != ARES_SUCCESS) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  flags = ares_dns_record_get_flags(dnsrec);
  /* Only care about RD and CD */
  if (flags & ARES_FLAG_RD) {
    status = ares_buf_append_str(buf, "rd");
    if (status != ARES_SUCCESS) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }
  if (flags & ARES_FLAG_CD) {
    status = ares_buf_append_str(buf, "cd");
    if (status != ARES_SUCCESS) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  for (i = 0; i < ares_dns_record_query_cnt(dnsrec); i++) {
    const char         *name;
    size_t              name_len;
    ares_dns_rec_type_t qtype;
    ares_dns_class_t    qclass;

    status = ares_dns_record_query_get(dnsrec, i, &name, &qtype, &qclass);
    if (status != ARES_SUCCESS) {
      goto fail; /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    status = ares_buf_append_byte(buf, '|');
    if (status != ARES_SUCCESS) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    status = ares_buf_append_str(buf, ares_dns_rec_type_tostr(qtype));
    if (status != ARES_SUCCESS) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    status = ares_buf_append_byte(buf, '|');
    if (status != ARES_SUCCESS) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    status = ares_buf_append_str(buf, ares_dns_class_tostr(qclass));
    if (status != ARES_SUCCESS) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    status = ares_buf_append_byte(buf, '|');
    if (status != ARES_SUCCESS) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* On queries, a '.' may be appended to the name to indicate an explicit
     * name lookup without performing a search.  Strip this since its not part
     * of a cached response. */
    name_len = ares_strlen(name);
    if (name_len && name[name_len - 1] == '.') {
      name_len--;
    }

    if (name_len > 0) {
      status = ares_buf_append(buf, (const unsigned char *)name, name_len);
      if (status != ARES_SUCCESS) {
        goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
      }
    }
  }

  return ares_buf_finish_str(buf, NULL);

/* LCOV_EXCL_START: OutOfMemory */
fail:
  ares_buf_destroy(buf);
  return NULL;
  /* LCOV_EXCL_STOP */
}

static void ares_qcache_expire(ares_qcache_t *cache, const ares_timeval_t *now)
{
  ares_slist_node_t *node;

  if (cache == NULL) {
    return;
  }

  while ((node = ares_slist_node_first(cache->expire)) != NULL) {
    const ares_qcache_entry_t *entry = ares_slist_node_val(node);

    /* If now is NULL, we're flushing everything, so don't break */
    if (now != NULL && entry->expire_ts > now->sec) {
      break;
    }

    ares_htable_strvp_remove(cache->cache, entry->key);
    ares_slist_node_destroy(node);
  }
}

void ares_qcache_flush(ares_qcache_t *cache)
{
  ares_qcache_expire(cache, NULL /* flush all */);
}

void ares_qcache_destroy(ares_qcache_t *cache)
{
  if (cache == NULL) {
    return;
  }

  ares_htable_strvp_destroy(cache->cache);
  ares_slist_destroy(cache->expire);
  ares_free(cache);
}

static int ares_qcache_entry_sort_cb(const void *arg1, const void *arg2)
{
  const ares_qcache_entry_t *entry1 = arg1;
  const ares_qcache_entry_t *entry2 = arg2;

  if (entry1->expire_ts > entry2->expire_ts) {
    return 1;
  }

  if (entry1->expire_ts < entry2->expire_ts) {
    return -1;
  }

  return 0;
}

static void ares_qcache_entry_destroy_cb(void *arg)
{
  ares_qcache_entry_t *entry = arg;
  if (entry == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ares_free(entry->key);
  ares_dns_record_destroy(entry->dnsrec);
  ares_free(entry);
}

ares_status_t ares_qcache_create(ares_rand_state *rand_state,
                                 unsigned int     max_ttl,
                                 ares_qcache_t  **cache_out)
{
  ares_status_t  status = ARES_SUCCESS;
  ares_qcache_t *cache;

  cache = ares_malloc_zero(sizeof(*cache));
  if (cache == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  cache->cache = ares_htable_strvp_create(NULL);
  if (cache->cache == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  cache->expire = ares_slist_create(rand_state, ares_qcache_entry_sort_cb,
                                    ares_qcache_entry_destroy_cb);
  if (cache->expire == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  cache->max_ttl = max_ttl;

done:
  if (status != ARES_SUCCESS) {
    *cache_out = NULL;
    ares_qcache_destroy(cache);
    return status;
  }

  *cache_out = cache;
  return status;
}

static unsigned int ares_qcache_calc_minttl(ares_dns_record_t *dnsrec)
{
  unsigned int minttl = 0xFFFFFFFF;
  size_t       sect;

  for (sect = ARES_SECTION_ANSWER; sect <= ARES_SECTION_ADDITIONAL; sect++) {
    size_t i;
    for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, (ares_dns_section_t)sect);
         i++) {
      const ares_dns_rr_t *rr =
        ares_dns_record_rr_get(dnsrec, (ares_dns_section_t)sect, i);
      ares_dns_rec_type_t type = ares_dns_rr_get_type(rr);
      unsigned int        ttl  = ares_dns_rr_get_ttl(rr);

      /* TTL is meaningless on these record types */
      if (type == ARES_REC_TYPE_OPT || type == ARES_REC_TYPE_SOA ||
          type == ARES_REC_TYPE_SIG) {
        continue;
      }

      if (ttl < minttl) {
        minttl = ttl;
      }
    }
  }

  return minttl;
}

static unsigned int ares_qcache_soa_minimum(ares_dns_record_t *dnsrec)
{
  size_t i;

  /* RFC 2308 Section 5 says its the minimum of MINIMUM and the TTL of the
   * record. */
  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_AUTHORITY); i++) {
    const ares_dns_rr_t *rr =
      ares_dns_record_rr_get(dnsrec, ARES_SECTION_AUTHORITY, i);
    ares_dns_rec_type_t type = ares_dns_rr_get_type(rr);
    unsigned int        ttl;
    unsigned int        minimum;

    if (type != ARES_REC_TYPE_SOA) {
      continue;
    }

    minimum = ares_dns_rr_get_u32(rr, ARES_RR_SOA_MINIMUM);
    ttl     = ares_dns_rr_get_ttl(rr);

    if (ttl > minimum) {
      return minimum;
    }
    return ttl;
  }

  return 0;
}

/* On success, takes ownership of dnsrec */
static ares_status_t ares_qcache_insert_int(ares_qcache_t           *qcache,
                                            ares_dns_record_t       *qresp,
                                            const ares_dns_record_t *qreq,
                                            const ares_timeval_t    *now)
{
  ares_qcache_entry_t *entry;
  unsigned int         ttl;
  ares_dns_rcode_t     rcode = ares_dns_record_get_rcode(qresp);
  ares_dns_flags_t     flags = ares_dns_record_get_flags(qresp);

  if (qcache == NULL || qresp == NULL) {
    return ARES_EFORMERR;
  }

  /* Only save NOERROR or NXDOMAIN */
  if (rcode != ARES_RCODE_NOERROR && rcode != ARES_RCODE_NXDOMAIN) {
    return ARES_ENOTIMP;
  }

  /* Don't save truncated queries */
  if (flags & ARES_FLAG_TC) {
    return ARES_ENOTIMP;
  }

  /* Look at SOA for NXDOMAIN for minimum */
  if (rcode == ARES_RCODE_NXDOMAIN) {
    ttl = ares_qcache_soa_minimum(qresp);
  } else {
    ttl = ares_qcache_calc_minttl(qresp);
  }

  if (ttl > qcache->max_ttl) {
    ttl = qcache->max_ttl;
  }

  /* Don't cache something that is already expired */
  if (ttl == 0) {
    return ARES_EREFUSED;
  }

  entry = ares_malloc_zero(sizeof(*entry));
  if (entry == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  entry->dnsrec    = qresp;
  entry->expire_ts = (time_t)now->sec + (time_t)ttl;
  entry->insert_ts = (time_t)now->sec;

  /* We can't guarantee the server responded with the same flags as the
   * request had, so we have to re-parse the request in order to generate the
   * key for caching, but we'll only do this once we know for sure we really
   * want to cache it */
  entry->key = ares_qcache_calc_key(qreq);
  if (entry->key == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  if (!ares_htable_strvp_insert(qcache->cache, entry->key, entry)) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  if (ares_slist_insert(qcache->expire, entry) == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  return ARES_SUCCESS;

/* LCOV_EXCL_START: OutOfMemory */
fail:
  if (entry != NULL && entry->key != NULL) {
    ares_htable_strvp_remove(qcache->cache, entry->key);
    ares_free(entry->key);
    ares_free(entry);
  }
  return ARES_ENOMEM;
  /* LCOV_EXCL_STOP */
}

ares_status_t ares_qcache_fetch(ares_channel_t           *channel,
                                const ares_timeval_t     *now,
                                const ares_dns_record_t  *dnsrec,
                                const ares_dns_record_t **dnsrec_resp)
{
  char                *key = NULL;
  ares_qcache_entry_t *entry;
  ares_status_t        status = ARES_SUCCESS;

  if (channel == NULL || dnsrec == NULL || dnsrec_resp == NULL) {
    return ARES_EFORMERR;
  }

  if (channel->qcache == NULL) {
    return ARES_ENOTFOUND;
  }

  ares_qcache_expire(channel->qcache, now);

  key = ares_qcache_calc_key(dnsrec);
  if (key == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  entry = ares_htable_strvp_get_direct(channel->qcache->cache, key);
  if (entry == NULL) {
    status = ARES_ENOTFOUND;
    goto done;
  }

  ares_dns_record_ttl_decrement(entry->dnsrec,
                                (unsigned int)(now->sec - entry->insert_ts));

  *dnsrec_resp = entry->dnsrec;

done:
  ares_free(key);
  return status;
}

ares_status_t ares_qcache_insert(ares_channel_t       *channel,
                                 const ares_timeval_t *now,
                                 const ares_query_t   *query,
                                 ares_dns_record_t    *dnsrec)
{
  return ares_qcache_insert_int(channel->qcache, dnsrec, query->query, now);
}
                                                                                                                                                 node-23.7.0/deps/cares/src/lib/ares_query.c                                                         0000664 0000000 0000000 00000012010 14746647661 0020457 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif

typedef struct {
  ares_callback_dnsrec callback;
  void                *arg;
} ares_query_dnsrec_arg_t;

static void ares_query_dnsrec_cb(void *arg, ares_status_t status,
                                 size_t                   timeouts,
                                 const ares_dns_record_t *dnsrec)
{
  ares_query_dnsrec_arg_t *qquery = arg;

  if (status != ARES_SUCCESS) {
    qquery->callback(qquery->arg, status, timeouts, dnsrec);
  } else {
    size_t           ancount;
    ares_dns_rcode_t rcode;
    /* Pull the response code and answer count from the packet and convert any
     * errors.
     */
    rcode   = ares_dns_record_get_rcode(dnsrec);
    ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);
    status  = ares_dns_query_reply_tostatus(rcode, ancount);
    qquery->callback(qquery->arg, status, timeouts, dnsrec);
  }
  ares_free(qquery);
}

ares_status_t ares_query_nolock(ares_channel_t *channel, const char *name,
                                ares_dns_class_t     dnsclass,
                                ares_dns_rec_type_t  type,
                                ares_callback_dnsrec callback, void *arg,
                                unsigned short *qid)
{
  ares_status_t            status;
  ares_dns_record_t       *dnsrec = NULL;
  ares_dns_flags_t         flags  = 0;
  ares_query_dnsrec_arg_t *qquery = NULL;

  if (channel == NULL || name == NULL || callback == NULL) {
    /* LCOV_EXCL_START: DefensiveCoding */
    status = ARES_EFORMERR;
    if (callback != NULL) {
      callback(arg, status, 0, NULL);
    }
    return status;
    /* LCOV_EXCL_STOP */
  }

  if (!(channel->flags & ARES_FLAG_NORECURSE)) {
    flags |= ARES_FLAG_RD;
  }

  status = ares_dns_record_create_query(
    &dnsrec, name, dnsclass, type, 0, flags,
    (size_t)(channel->flags & ARES_FLAG_EDNS) ? channel->ednspsz : 0);
  if (status != ARES_SUCCESS) {
    callback(arg, status, 0, NULL); /* LCOV_EXCL_LINE: OutOfMemory */
    return status;                  /* LCOV_EXCL_LINE: OutOfMemory */
  }

  qquery = ares_malloc(sizeof(*qquery));
  if (qquery == NULL) {
    /* LCOV_EXCL_START: OutOfMemory */
    status = ARES_ENOMEM;
    callback(arg, status, 0, NULL);
    ares_dns_record_destroy(dnsrec);
    return status;
    /* LCOV_EXCL_STOP */
  }

  qquery->callback = callback;
  qquery->arg      = arg;

  /* Send it off.  qcallback will be called when we get an answer. */
  status = ares_send_nolock(channel, NULL, 0, dnsrec, ares_query_dnsrec_cb,
                            qquery, qid);

  ares_dns_record_destroy(dnsrec);
  return status;
}

ares_status_t ares_query_dnsrec(ares_channel_t *channel, const char *name,
                                ares_dns_class_t     dnsclass,
                                ares_dns_rec_type_t  type,
                                ares_callback_dnsrec callback, void *arg,
                                unsigned short *qid)
{
  ares_status_t status;

  if (channel == NULL) {
    return ARES_EFORMERR;
  }

  ares_channel_lock(channel);
  status = ares_query_nolock(channel, name, dnsclass, type, callback, arg, qid);
  ares_channel_unlock(channel);
  return status;
}

void ares_query(ares_channel_t *channel, const char *name, int dnsclass,
                int type, ares_callback callback, void *arg)
{
  void *carg = NULL;

  if (channel == NULL) {
    return;
  }

  carg = ares_dnsrec_convert_arg(callback, arg);
  if (carg == NULL) {
    callback(arg, ARES_ENOMEM, 0, NULL, 0); /* LCOV_EXCL_LINE: OutOfMemory */
    return;                                 /* LCOV_EXCL_LINE: OutOfMemory */
  }

  ares_query_dnsrec(channel, name, (ares_dns_class_t)dnsclass,
                    (ares_dns_rec_type_t)type, ares_dnsrec_convert_cb, carg,
                    NULL);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/ares_search.c                                                        0000664 0000000 0000000 00000042747 14746647661 0020603 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_STRINGS_H
#  include <strings.h>
#endif

struct search_query {
  /* Arguments passed to ares_search_dnsrec() */
  ares_channel_t      *channel;
  ares_callback_dnsrec callback;
  void                *arg;

  /* Duplicate of DNS record passed to ares_search_dnsrec() */
  ares_dns_record_t   *dnsrec;

  /* Search order for names */
  char               **names;
  size_t               names_cnt;

  /* State tracking progress through the search query */
  size_t               next_name_idx; /* next name index being attempted */
  size_t      timeouts;        /* number of timeouts we saw for this request */
  ares_bool_t ever_got_nodata; /* did we ever get ARES_ENODATA along the way? */
};

static void squery_free(struct search_query *squery)
{
  if (squery == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }
  ares_strsplit_free(squery->names, squery->names_cnt);
  ares_dns_record_destroy(squery->dnsrec);
  ares_free(squery);
}

/* End a search query by invoking the user callback and freeing the
 * search_query structure.
 */
static void end_squery(struct search_query *squery, ares_status_t status,
                       const ares_dns_record_t *dnsrec)
{
  squery->callback(squery->arg, status, squery->timeouts, dnsrec);
  squery_free(squery);
}

static void search_callback(void *arg, ares_status_t status, size_t timeouts,
                            const ares_dns_record_t *dnsrec);

static ares_status_t ares_search_next(ares_channel_t      *channel,
                                      struct search_query *squery,
                                      ares_bool_t         *skip_cleanup)
{
  ares_status_t status;

  *skip_cleanup = ARES_FALSE;

  /* Misuse check */
  if (squery->next_name_idx >= squery->names_cnt) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  status = ares_dns_record_query_set_name(
    squery->dnsrec, 0, squery->names[squery->next_name_idx++]);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_send_nolock(channel, NULL, 0, squery->dnsrec, search_callback,
                            squery, NULL);

  if (status != ARES_EFORMERR) {
    *skip_cleanup = ARES_TRUE;
  }

  return status;
}

static void search_callback(void *arg, ares_status_t status, size_t timeouts,
                            const ares_dns_record_t *dnsrec)
{
  struct search_query *squery  = (struct search_query *)arg;
  ares_channel_t      *channel = squery->channel;

  ares_status_t        mystatus;
  ares_bool_t          skip_cleanup = ARES_FALSE;

  squery->timeouts += timeouts;

  if (dnsrec) {
    ares_dns_rcode_t rcode = ares_dns_record_get_rcode(dnsrec);
    size_t ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);
    mystatus       = ares_dns_query_reply_tostatus(rcode, ancount);
  } else {
    mystatus = status;
  }

  switch (mystatus) {
    case ARES_ENODATA:
    case ARES_ENOTFOUND:
      break;
    case ARES_ESERVFAIL:
    case ARES_EREFUSED:
      /* Issue #852, systemd-resolved may return SERVFAIL or REFUSED on a
       * single label domain name. */
      if (ares_name_label_cnt(squery->names[squery->next_name_idx - 1]) != 1) {
        end_squery(squery, mystatus, dnsrec);
        return;
      }
      break;
    default:
      end_squery(squery, mystatus, dnsrec);
      return;
  }

  /* If we ever get ARES_ENODATA along the way, record that; if the search
   * should run to the very end and we got at least one ARES_ENODATA,
   * then callers like ares_gethostbyname() may want to try a T_A search
   * even if the last domain we queried for T_AAAA resource records
   * returned ARES_ENOTFOUND.
   */
  if (mystatus == ARES_ENODATA) {
    squery->ever_got_nodata = ARES_TRUE;
  }

  if (squery->next_name_idx < squery->names_cnt) {
    mystatus = ares_search_next(channel, squery, &skip_cleanup);
    if (mystatus != ARES_SUCCESS && !skip_cleanup) {
      end_squery(squery, mystatus, NULL);
    }
    return;
  }

  /* We have no more domains to search, return an appropriate response. */
  if (mystatus == ARES_ENOTFOUND && squery->ever_got_nodata) {
    end_squery(squery, ARES_ENODATA, NULL);
    return;
  }

  end_squery(squery, mystatus, NULL);
}

/* Determine if the domain should be looked up as-is, or if it is eligible
 * for search by appending domains */
static ares_bool_t ares_search_eligible(const ares_channel_t *channel,
                                        const char           *name)
{
  size_t len = ares_strlen(name);

  /* Name ends in '.', cannot search */
  if (len && name[len - 1] == '.') {
    return ARES_FALSE;
  }

  if (channel->flags & ARES_FLAG_NOSEARCH) {
    return ARES_FALSE;
  }

  return ARES_TRUE;
}

size_t ares_name_label_cnt(const char *name)
{
  const char *p;
  size_t      ndots = 0;

  if (name == NULL) {
    return 0;
  }

  for (p = name; p != NULL && *p != 0; p++) {
    if (*p == '.') {
      ndots++;
    }
  }

  /* Label count is 1 greater than ndots */
  return ndots + 1;
}

ares_status_t ares_search_name_list(const ares_channel_t *channel,
                                    const char *name, char ***names,
                                    size_t *names_len)
{
  ares_status_t status;
  char        **list     = NULL;
  size_t        list_len = 0;
  char         *alias    = NULL;
  size_t        ndots    = 0;
  size_t        idx      = 0;
  size_t        i;

  /* Perform HOSTALIASES resolution */
  status = ares_lookup_hostaliases(channel, name, &alias);
  if (status == ARES_SUCCESS) {
    /* If hostalias succeeds, there is no searching, it is used as-is */
    list_len = 1;
    list     = ares_malloc_zero(sizeof(*list) * list_len);
    if (list == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
    list[0] = alias;
    alias   = NULL;
    goto done;
  } else if (status != ARES_ENOTFOUND) {
    goto done;
  }

  /* See if searching is eligible at all, if not, look up as-is only */
  if (!ares_search_eligible(channel, name)) {
    list_len = 1;
    list     = ares_malloc_zero(sizeof(*list) * list_len);
    if (list == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
    list[0] = ares_strdup(name);
    if (list[0] == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    } else {
      status = ARES_SUCCESS;
    }
    goto done;
  }

  /* Count the number of dots in name, 1 less than label count */
  ndots = ares_name_label_cnt(name);
  if (ndots > 0) {
    ndots--;
  }

  /* Allocate an entry for each search domain, plus one for as-is */
  list_len = channel->ndomains + 1;
  list     = ares_malloc_zero(sizeof(*list) * list_len);
  if (list == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  /* Set status here, its possible there are no search domains at all, so
   * status may be ARES_ENOTFOUND from ares_lookup_hostaliases(). */
  status = ARES_SUCCESS;

  /* Try as-is first */
  if (ndots >= channel->ndots) {
    list[idx] = ares_strdup(name);
    if (list[idx] == NULL) {
      status = ARES_ENOMEM;
      goto done;
    }
    idx++;
  }

  /* Append each search suffix to the name */
  for (i = 0; i < channel->ndomains; i++) {
    status = ares_cat_domain(name, channel->domains[i], &list[idx]);
    if (status != ARES_SUCCESS) {
      goto done;
    }
    idx++;
  }

  /* Try as-is last */
  if (ndots < channel->ndots) {
    list[idx] = ares_strdup(name);
    if (list[idx] == NULL) {
      status = ARES_ENOMEM;
      goto done;
    }
    idx++;
  }


done:
  if (status == ARES_SUCCESS) {
    *names     = list;
    *names_len = list_len;
  } else {
    ares_strsplit_free(list, list_len);
  }

  ares_free(alias);
  return status;
}

static ares_status_t ares_search_int(ares_channel_t          *channel,
                                     const ares_dns_record_t *dnsrec,
                                     ares_callback_dnsrec callback, void *arg)
{
  struct search_query *squery = NULL;
  const char          *name;
  ares_status_t        status       = ARES_SUCCESS;
  ares_bool_t          skip_cleanup = ARES_FALSE;

  /* Extract the name for the search. Note that searches are only supported for
   * DNS records containing a single query.
   */
  if (ares_dns_record_query_cnt(dnsrec) != 1) {
    status = ARES_EBADQUERY;
    goto fail;
  }

  status = ares_dns_record_query_get(dnsrec, 0, &name, NULL, NULL);
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  /* Per RFC 7686, reject queries for ".onion" domain names with NXDOMAIN. */
  if (ares_is_onion_domain(name)) {
    status = ARES_ENOTFOUND;
    goto fail;
  }

  /* Allocate a search_query structure to hold the state necessary for
   * doing multiple lookups.
   */
  squery = ares_malloc_zero(sizeof(*squery));
  if (squery == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  squery->channel = channel;

  /* Duplicate DNS record since, name will need to be rewritten */
  squery->dnsrec = ares_dns_record_duplicate(dnsrec);
  if (squery->dnsrec == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  squery->callback        = callback;
  squery->arg             = arg;
  squery->timeouts        = 0;
  squery->ever_got_nodata = ARES_FALSE;

  status =
    ares_search_name_list(channel, name, &squery->names, &squery->names_cnt);
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  status = ares_search_next(channel, squery, &skip_cleanup);
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  return status;

fail:
  if (!skip_cleanup) {
    squery_free(squery);
    callback(arg, status, 0, NULL);
  }
  return status;
}

/* Callback argument structure passed to ares_dnsrec_convert_cb(). */
typedef struct {
  ares_callback callback;
  void         *arg;
} dnsrec_convert_arg_t;

/*! Function to create callback arg for converting from ares_callback_dnsrec
 *  to ares_calback */
void *ares_dnsrec_convert_arg(ares_callback callback, void *arg)
{
  dnsrec_convert_arg_t *carg = ares_malloc_zero(sizeof(*carg));
  if (carg == NULL) {
    return NULL;
  }
  carg->callback = callback;
  carg->arg      = arg;
  return carg;
}

/*! Callback function used to convert from the ares_callback_dnsrec prototype to
 *  the ares_callback prototype, by writing the result and passing that to
 *  the inner callback.
 */
void ares_dnsrec_convert_cb(void *arg, ares_status_t status, size_t timeouts,
                            const ares_dns_record_t *dnsrec)
{
  dnsrec_convert_arg_t *carg = arg;
  unsigned char        *abuf = NULL;
  size_t                alen = 0;

  if (dnsrec != NULL) {
    ares_status_t mystatus = ares_dns_write(dnsrec, &abuf, &alen);
    if (mystatus != ARES_SUCCESS) {
      status = mystatus;
    }
  }

  carg->callback(carg->arg, (int)status, (int)timeouts, abuf, (int)alen);

  ares_free(abuf);
  ares_free(carg);
}

/* Search for a DNS name with given class and type. Wrapper around
 * ares_search_int() where the DNS record to search is first constructed.
 */
void ares_search(ares_channel_t *channel, const char *name, int dnsclass,
                 int type, ares_callback callback, void *arg)
{
  ares_status_t      status;
  ares_dns_record_t *dnsrec = NULL;
  size_t             max_udp_size;
  ares_dns_flags_t   rd_flag;
  void              *carg = NULL;
  if (channel == NULL || name == NULL) {
    return;
  }

  /* For now, ares_search_int() uses the ares_callback prototype. We need to
   * wrap the callback passed to this function in ares_dnsrec_convert_cb, to
   * convert from ares_callback_dnsrec to ares_callback. Allocate the convert
   * arg structure here.
   */
  carg = ares_dnsrec_convert_arg(callback, arg);
  if (carg == NULL) {
    callback(arg, ARES_ENOMEM, 0, NULL, 0);
    return;
  }

  rd_flag      = !(channel->flags & ARES_FLAG_NORECURSE) ? ARES_FLAG_RD : 0;
  max_udp_size = (channel->flags & ARES_FLAG_EDNS) ? channel->ednspsz : 0;
  status       = ares_dns_record_create_query(
    &dnsrec, name, (ares_dns_class_t)dnsclass, (ares_dns_rec_type_t)type, 0,
    rd_flag, max_udp_size);
  if (status != ARES_SUCCESS) {
    callback(arg, (int)status, 0, NULL, 0);
    ares_free(carg);
    return;
  }

  ares_channel_lock(channel);
  ares_search_int(channel, dnsrec, ares_dnsrec_convert_cb, carg);
  ares_channel_unlock(channel);

  ares_dns_record_destroy(dnsrec);
}

/* Search for a DNS record. Wrapper around ares_search_int(). */
ares_status_t ares_search_dnsrec(ares_channel_t          *channel,
                                 const ares_dns_record_t *dnsrec,
                                 ares_callback_dnsrec callback, void *arg)
{
  ares_status_t status;

  if (channel == NULL || dnsrec == NULL || callback == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ares_channel_lock(channel);
  status = ares_search_int(channel, dnsrec, callback, arg);
  ares_channel_unlock(channel);

  return status;
}

/* Concatenate two domains. */
ares_status_t ares_cat_domain(const char *name, const char *domain, char **s)
{
  size_t nlen = ares_strlen(name);
  size_t dlen = ares_strlen(domain);

  *s = ares_malloc(nlen + 1 + dlen + 1);
  if (!*s) {
    return ARES_ENOMEM;
  }
  memcpy(*s, name, nlen);
  (*s)[nlen] = '.';
  if (ares_streq(domain, ".")) {
    /* Avoid appending the root domain to the separator, which would set *s to
       an ill-formed value (ending in two consecutive dots). */
    dlen = 0;
  }
  memcpy(*s + nlen + 1, domain, dlen);
  (*s)[nlen + 1 + dlen] = 0;
  return ARES_SUCCESS;
}

ares_status_t ares_lookup_hostaliases(const ares_channel_t *channel,
                                      const char *name, char **alias)
{
  ares_status_t status      = ARES_SUCCESS;
  const char   *hostaliases = NULL;
  ares_buf_t   *buf         = NULL;
  ares_array_t *lines       = NULL;
  size_t        num;
  size_t        i;

  if (channel == NULL || name == NULL || alias == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  *alias = NULL;

  /* Configuration says to not perform alias lookup */
  if (channel->flags & ARES_FLAG_NOALIASES) {
    return ARES_ENOTFOUND;
  }

  /* If a domain has a '.', its not allowed to perform an alias lookup */
  if (strchr(name, '.') != NULL) {
    return ARES_ENOTFOUND;
  }

  hostaliases = getenv("HOSTALIASES");
  if (hostaliases == NULL) {
    status = ARES_ENOTFOUND;
    goto done;
  }

  buf = ares_buf_create();
  if (buf == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  status = ares_buf_load_file(hostaliases, buf);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  /* The HOSTALIASES file is structured as one alias per line.  The first
   * field in the line is the simple hostname with no periods, followed by
   * whitespace, then the full domain name, e.g.:
   *
   * c-ares  www.c-ares.org
   * curl    www.curl.se
   */

  status = ares_buf_split(buf, (const unsigned char *)"\n", 1,
                          ARES_BUF_SPLIT_TRIM, 0, &lines);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  num = ares_array_len(lines);
  for (i = 0; i < num; i++) {
    ares_buf_t **bufptr       = ares_array_at(lines, i);
    ares_buf_t  *line         = *bufptr;
    char         hostname[64] = "";
    char         fqdn[256]    = "";

    /* Pull off hostname */
    ares_buf_tag(line);
    ares_buf_consume_nonwhitespace(line);
    if (ares_buf_tag_fetch_string(line, hostname, sizeof(hostname)) !=
        ARES_SUCCESS) {
      continue;
    }

    /* Match hostname */
    if (!ares_strcaseeq(hostname, name)) {
      continue;
    }

    /* consume whitespace */
    ares_buf_consume_whitespace(line, ARES_TRUE);

    /* pull off fqdn */
    ares_buf_tag(line);
    ares_buf_consume_nonwhitespace(line);
    if (ares_buf_tag_fetch_string(line, fqdn, sizeof(fqdn)) != ARES_SUCCESS ||
        ares_strlen(fqdn) == 0) {
      continue;
    }

    /* Validate characterset */
    if (!ares_is_hostname(fqdn)) {
      continue;
    }

    *alias = ares_strdup(fqdn);
    if (*alias == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* Good! */
    status = ARES_SUCCESS;
    goto done;
  }

  status = ARES_ENOTFOUND;

done:
  ares_buf_destroy(buf);
  ares_array_destroy(lines);

  return status;
}
                         node-23.7.0/deps/cares/src/lib/ares_send.c                                                          0000664 0000000 0000000 00000020731 14746647661 0020254 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif
#include "ares_nameser.h"

static unsigned short generate_unique_qid(ares_channel_t *channel)
{
  unsigned short id;

  do {
    id = ares_generate_new_id(channel->rand_state);
  } while (ares_htable_szvp_get(channel->queries_by_qid, id, NULL));

  return id;
}

/* https://datatracker.ietf.org/doc/html/draft-vixie-dnsext-dns0x20-00 */
static ares_status_t ares_apply_dns0x20(ares_channel_t    *channel,
                                        ares_dns_record_t *dnsrec)
{
  ares_status_t status = ARES_SUCCESS;
  const char   *name   = NULL;
  char          dns0x20name[256];
  unsigned char randdata[256 / 8];
  size_t        len;
  size_t        remaining_bits;
  size_t        total_bits;
  size_t        i;

  status = ares_dns_record_query_get(dnsrec, 0, &name, NULL, NULL);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  len = ares_strlen(name);
  if (len == 0) {
    return ARES_SUCCESS;
  }

  if (len >= sizeof(dns0x20name)) {
    status = ARES_EBADNAME;
    goto done;
  }

  memset(dns0x20name, 0, sizeof(dns0x20name));

  /* Fetch the minimum amount of random data we'd need for the string, which
   * is 1 bit per byte */
  total_bits     = ((len + 7) / 8) * 8;
  remaining_bits = total_bits;
  ares_rand_bytes(channel->rand_state, randdata, total_bits / 8);

  /* Randomly apply 0x20 to name */
  for (i = 0; i < len; i++) {
    size_t bit;

    /* Only apply 0x20 to alpha characters */
    if (!ares_isalpha(name[i])) {
      dns0x20name[i] = name[i];
      continue;
    }

    /* coin flip */
    bit = total_bits - remaining_bits;
    if (randdata[bit / 8] & (1 << (bit % 8))) {
      dns0x20name[i] = name[i] | 0x20;                          /* Set 0x20 */
    } else {
      dns0x20name[i] = (char)(((unsigned char)name[i]) & 0xDF); /* Unset 0x20 */
    }
    remaining_bits--;
  }

  status = ares_dns_record_query_set_name(dnsrec, 0, dns0x20name);

done:
  return status;
}

ares_status_t ares_send_nolock(ares_channel_t *channel, ares_server_t *server,
                               ares_send_flags_t        flags,
                               const ares_dns_record_t *dnsrec,
                               ares_callback_dnsrec callback, void *arg,
                               unsigned short *qid)
{
  ares_query_t            *query;
  ares_timeval_t           now;
  ares_status_t            status;
  unsigned short           id          = generate_unique_qid(channel);
  const ares_dns_record_t *dnsrec_resp = NULL;

  ares_tvnow(&now);

  if (ares_slist_len(channel->servers) == 0) {
    callback(arg, ARES_ENOSERVER, 0, NULL);
    return ARES_ENOSERVER;
  }

  if (!(flags & ARES_SEND_FLAG_NOCACHE)) {
    /* Check query cache */
    status = ares_qcache_fetch(channel, &now, dnsrec, &dnsrec_resp);
    if (status != ARES_ENOTFOUND) {
      /* ARES_SUCCESS means we retrieved the cache, anything else is a critical
       * failure, all result in termination */
      callback(arg, status, 0, dnsrec_resp);
      return status;
    }
  }

  /* Allocate space for query and allocated fields. */
  query = ares_malloc(sizeof(ares_query_t));
  if (!query) {
    callback(arg, ARES_ENOMEM, 0, NULL); /* LCOV_EXCL_LINE: OutOfMemory */
    return ARES_ENOMEM;                  /* LCOV_EXCL_LINE: OutOfMemory */
  }
  memset(query, 0, sizeof(*query));

  query->channel      = channel;
  query->qid          = id;
  query->timeout.sec  = 0;
  query->timeout.usec = 0;
  query->using_tcp =
    (channel->flags & ARES_FLAG_USEVC) ? ARES_TRUE : ARES_FALSE;

  /* Duplicate Query */
  status = ares_dns_record_duplicate_ex(&query->query, dnsrec);
  if (status != ARES_SUCCESS) {
    /* Sometimes we might get a EBADRESP response from duplicate due to
     * the way it works (write and parse), rewrite it to EBADQUERY. */
    if (status == ARES_EBADRESP) {
      status = ARES_EBADQUERY;
    }
    ares_free(query);
    callback(arg, status, 0, NULL);
    return status;
  }

  ares_dns_record_set_id(query->query, id);

  if (channel->flags & ARES_FLAG_DNS0x20 && !query->using_tcp) {
    status = ares_apply_dns0x20(channel, query->query);
    if (status != ARES_SUCCESS) {
      /* LCOV_EXCL_START: OutOfMemory */
      callback(arg, status, 0, NULL);
      ares_free_query(query);
      return status;
      /* LCOV_EXCL_STOP */
    }
  }

  /* Fill in query arguments. */
  query->callback = callback;
  query->arg      = arg;

  /* Initialize query status. */
  query->try_count = 0;

  if (flags & ARES_SEND_FLAG_NORETRY) {
    query->no_retries = ARES_TRUE;
  }

  query->error_status = ARES_SUCCESS;
  query->timeouts     = 0;

  /* Initialize our list nodes. */
  query->node_queries_by_timeout = NULL;
  query->node_queries_to_conn    = NULL;

  /* Chain the query into the list of all queries. */
  query->node_all_queries = ares_llist_insert_last(channel->all_queries, query);
  if (query->node_all_queries == NULL) {
    /* LCOV_EXCL_START: OutOfMemory */
    callback(arg, ARES_ENOMEM, 0, NULL);
    ares_free_query(query);
    return ARES_ENOMEM;
    /* LCOV_EXCL_STOP */
  }

  /* Keep track of queries bucketed by qid, so we can process DNS
   * responses quickly.
   */
  if (!ares_htable_szvp_insert(channel->queries_by_qid, query->qid, query)) {
    /* LCOV_EXCL_START: OutOfMemory */
    callback(arg, ARES_ENOMEM, 0, NULL);
    ares_free_query(query);
    return ARES_ENOMEM;
    /* LCOV_EXCL_STOP */
  }

  /* Perform the first query action. */

  status = ares_send_query(server, query, &now);
  if (status == ARES_SUCCESS && qid) {
    *qid = id;
  }
  return status;
}

ares_status_t ares_send_dnsrec(ares_channel_t          *channel,
                               const ares_dns_record_t *dnsrec,
                               ares_callback_dnsrec callback, void *arg,
                               unsigned short *qid)
{
  ares_status_t status;

  if (channel == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ares_channel_lock(channel);

  status = ares_send_nolock(channel, NULL, 0, dnsrec, callback, arg, qid);

  ares_channel_unlock(channel);

  return status;
}

void ares_send(ares_channel_t *channel, const unsigned char *qbuf, int qlen,
               ares_callback callback, void *arg)
{
  ares_dns_record_t *dnsrec = NULL;
  ares_status_t      status;
  void              *carg = NULL;

  if (channel == NULL) {
    return;
  }

  /* Verify that the query is at least long enough to hold the header. */
  if (qlen < HFIXEDSZ || qlen >= (1 << 16)) {
    callback(arg, ARES_EBADQUERY, 0, NULL, 0);
    return;
  }

  status = ares_dns_parse(qbuf, (size_t)qlen, 0, &dnsrec);
  if (status != ARES_SUCCESS) {
    callback(arg, (int)status, 0, NULL, 0);
    return;
  }

  carg = ares_dnsrec_convert_arg(callback, arg);
  if (carg == NULL) {
    /* LCOV_EXCL_START: OutOfMemory */
    status = ARES_ENOMEM;
    ares_dns_record_destroy(dnsrec);
    callback(arg, (int)status, 0, NULL, 0);
    return;
    /* LCOV_EXCL_STOP */
  }

  ares_send_dnsrec(channel, dnsrec, ares_dnsrec_convert_cb, carg, NULL);

  ares_dns_record_destroy(dnsrec);
}

size_t ares_queue_active_queries(const ares_channel_t *channel)
{
  size_t len;

  if (channel == NULL) {
    return 0;
  }

  ares_channel_lock(channel);

  len = ares_llist_len(channel->all_queries);

  ares_channel_unlock(channel);

  return len;
}
                                       node-23.7.0/deps/cares/src/lib/ares_set_socket_functions.c                                          0000664 0000000 0000000 00000042205 14746647661 0023556 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#ifdef HAVE_SYS_UIO_H
#  include <sys/uio.h>
#endif
#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif
#ifdef HAVE_NETINET_TCP_H
#  include <netinet/tcp.h>
#endif
#ifdef HAVE_NETDB_H
#  include <netdb.h>
#endif
#ifdef HAVE_ARPA_INET_H
#  include <arpa/inet.h>
#endif

#ifdef HAVE_STRINGS_H
#  include <strings.h>
#endif
#ifdef HAVE_SYS_IOCTL_H
#  include <sys/ioctl.h>
#endif
#ifdef NETWARE
#  include <sys/filio.h>
#endif

#include <assert.h>
#include <fcntl.h>
#include <limits.h>


#if defined(__linux__) && defined(TCP_FASTOPEN_CONNECT)
#  define TFO_SUPPORTED      1
#  define TFO_SKIP_CONNECT   0
#  define TFO_USE_SENDTO     0
#  define TFO_USE_CONNECTX   0
#  define TFO_CLIENT_SOCKOPT TCP_FASTOPEN_CONNECT
#elif defined(__FreeBSD__) && defined(TCP_FASTOPEN)
#  define TFO_SUPPORTED      1
#  define TFO_SKIP_CONNECT   1
#  define TFO_USE_SENDTO     1
#  define TFO_USE_CONNECTX   0
#  define TFO_CLIENT_SOCKOPT TCP_FASTOPEN
#elif defined(__APPLE__) && defined(HAVE_CONNECTX)
#  define TFO_SUPPORTED    1
#  define TFO_SKIP_CONNECT 0
#  define TFO_USE_SENDTO   0
#  define TFO_USE_CONNECTX 1
#  undef TFO_CLIENT_SOCKOPT
#else
#  define TFO_SUPPORTED 0
#endif

#ifndef HAVE_WRITEV
/* Structure for scatter/gather I/O. */
struct iovec {
  void  *iov_base; /* Pointer to data. */
  size_t iov_len;  /* Length of data.  */
};
#endif

ares_status_t
  ares_set_socket_functions_ex(ares_channel_t                        *channel,
                               const struct ares_socket_functions_ex *funcs,
                               void                                  *user_data)
{
  unsigned int known_versions[] = { 1 };
  size_t       i;

  if (channel == NULL || funcs == NULL) {
    return ARES_EFORMERR;
  }

  /* Check to see if we know the version referenced */
  for (i = 0; i < sizeof(known_versions) / sizeof(*known_versions); i++) {
    if (funcs->version == known_versions[i]) {
      break;
    }
  }
  if (i == sizeof(known_versions) / sizeof(*known_versions)) {
    return ARES_EFORMERR;
  }

  memset(&channel->sock_funcs, 0, sizeof(channel->sock_funcs));

  /* Copy individually for ABI compliance.  memcpy() with a sizeof would do
   * invalid reads */
  if (funcs->version >= 1) {
    if (funcs->asocket == NULL || funcs->aclose == NULL ||
        funcs->asetsockopt == NULL || funcs->aconnect == NULL ||
        funcs->arecvfrom == NULL || funcs->asendto == NULL) {
      return ARES_EFORMERR;
    }
    channel->sock_funcs.version      = funcs->version;
    channel->sock_funcs.flags        = funcs->flags;
    channel->sock_funcs.asocket      = funcs->asocket;
    channel->sock_funcs.aclose       = funcs->aclose;
    channel->sock_funcs.asetsockopt  = funcs->asetsockopt;
    channel->sock_funcs.aconnect     = funcs->aconnect;
    channel->sock_funcs.arecvfrom    = funcs->arecvfrom;
    channel->sock_funcs.asendto      = funcs->asendto;
    channel->sock_funcs.agetsockname = funcs->agetsockname;
    channel->sock_funcs.abind        = funcs->abind;
  }

  /* Implement newer versions here ...*/


  channel->sock_func_cb_data = user_data;

  return ARES_SUCCESS;
}

static int setsocknonblock(ares_socket_t sockfd, /* operate on this */
                           int           nonblock /* TRUE or FALSE */)
{
#if defined(HAVE_FCNTL_O_NONBLOCK)

  /* most recent unix versions */
  int flags;
  flags = fcntl(sockfd, F_GETFL, 0);
  if (nonblock) {
    return fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
  } else {
    return fcntl(sockfd, F_SETFL, flags & (~O_NONBLOCK)); /* LCOV_EXCL_LINE */
  }

#elif defined(HAVE_IOCTL_FIONBIO)

  /* older unix versions */
  int flags = nonblock ? 1 : 0;
  return ioctl(sockfd, FIONBIO, &flags);

#elif defined(HAVE_IOCTLSOCKET_FIONBIO)

#  ifdef WATT32
  char flags = nonblock ? 1 : 0;
#  else
  /* Windows */
  unsigned long flags = nonblock ? 1UL : 0UL;
#  endif
  return ioctlsocket(sockfd, (long)FIONBIO, &flags);

#elif defined(HAVE_IOCTLSOCKET_CAMEL_FIONBIO)

  /* Amiga */
  long flags = nonblock ? 1L : 0L;
  return IoctlSocket(sockfd, FIONBIO, flags);

#elif defined(HAVE_SETSOCKOPT_SO_NONBLOCK)

  /* BeOS */
  long b = nonblock ? 1L : 0L;
  return setsockopt(sockfd, SOL_SOCKET, SO_NONBLOCK, &b, sizeof(b));

#else
#  error "no non-blocking method was found/used/set"
#endif
}

static int default_aclose(ares_socket_t sock, void *user_data)
{
  (void)user_data;

#if defined(HAVE_CLOSESOCKET)
  return closesocket(sock);
#elif defined(HAVE_CLOSESOCKET_CAMEL)
  return CloseSocket(sock);
#elif defined(HAVE_CLOSE_S)
  return close_s(sock);
#else
  return close(sock);
#endif
}

static ares_socket_t default_asocket(int domain, int type, int protocol,
                                     void *user_data)
{
  ares_socket_t s;
  (void)user_data;

  s = socket(domain, type, protocol);
  if (s == ARES_SOCKET_BAD) {
    return s;
  }

  if (setsocknonblock(s, 1) != 0) {
    goto fail; /* LCOV_EXCL_LINE */
  }

#if defined(FD_CLOEXEC) && !defined(MSDOS)
  /* Configure the socket fd as close-on-exec. */
  if (fcntl(s, F_SETFD, FD_CLOEXEC) != 0) {
    goto fail; /* LCOV_EXCL_LINE */
  }
#endif

  /* No need to emit SIGPIPE on socket errors */
#if defined(SO_NOSIGPIPE)
  {
    int opt = 1;
    (void)setsockopt(s, SOL_SOCKET, SO_NOSIGPIPE, (void *)&opt, sizeof(opt));
  }
#endif


  if (type == SOCK_STREAM) {
    int opt = 1;

#ifdef TCP_NODELAY
    /*
     * Disable the Nagle algorithm (only relevant for TCP sockets, and thus not
     * in configure_socket). In general, in DNS lookups we're pretty much
     * interested in firing off a single request and then waiting for a reply,
     * so batching isn't very interesting.
     */
    if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (void *)&opt, sizeof(opt)) !=
        0) {
      goto fail;
    }
#endif
  }

#if defined(IPV6_V6ONLY) && defined(USE_WINSOCK)
  /* Support for IPv4-mapped IPv6 addresses.
   * Linux kernel, NetBSD, FreeBSD and Darwin: default is off;
   * Windows Vista and later: default is on;
   * DragonFly BSD: acts like off, and dummy setting;
   * OpenBSD and earlier Windows: unsupported.
   * Linux: controlled by /proc/sys/net/ipv6/bindv6only.
   */
  if (domain == PF_INET6) {
    int on = 0;
    (void)setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, (void *)&on, sizeof(on));
  }
#endif

  return s;

fail:
  default_aclose(s, user_data);
  return ARES_SOCKET_BAD;
}

static int default_asetsockopt(ares_socket_t sock, ares_socket_opt_t opt,
                               const void *val, ares_socklen_t val_size,
                               void *user_data)
{
  switch (opt) {
    case ARES_SOCKET_OPT_SENDBUF_SIZE:
      if (val_size != sizeof(int)) {
        SET_SOCKERRNO(EINVAL);
        return -1;
      }
      return setsockopt(sock, SOL_SOCKET, SO_SNDBUF, val, val_size);

    case ARES_SOCKET_OPT_RECVBUF_SIZE:
      if (val_size != sizeof(int)) {
        SET_SOCKERRNO(EINVAL);
        return -1;
      }
      return setsockopt(sock, SOL_SOCKET, SO_RCVBUF, val, val_size);

    case ARES_SOCKET_OPT_BIND_DEVICE:
      /* Count the number of characters before NULL terminator then
       * validate those are all printable */
      if (!ares_str_isprint(val, ares_strnlen(val, (size_t)val_size))) {
        SET_SOCKERRNO(EINVAL);
        return -1;
      }
#ifdef SO_BINDTODEVICE
      return setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, val, val_size);
#else
      SET_SOCKERRNO(ENOSYS);
      return -1;
#endif

    case ARES_SOCKET_OPT_TCP_FASTOPEN:
      if (val_size != sizeof(ares_bool_t)) {
        SET_SOCKERRNO(EINVAL);
        return -1;
      }
#if defined(TFO_CLIENT_SOCKOPT)
      {
        int                oval;
        const ares_bool_t *pval = val;
        oval                    = (int)*pval;
        return setsockopt(sock, IPPROTO_TCP, TFO_CLIENT_SOCKOPT, (void *)&oval,
                          sizeof(oval));
      }
#elif TFO_SUPPORTED
      return 0;
#else
      SET_SOCKERRNO(ENOSYS);
      return -1;
#endif
  }

  (void)user_data;
  SET_SOCKERRNO(ENOSYS);
  return -1;
}

static int default_aconnect(ares_socket_t sock, const struct sockaddr *address,
                            ares_socklen_t address_len, unsigned int flags,
                            void *user_data)
{
  (void)user_data;

#if defined(TFO_SKIP_CONNECT) && TFO_SKIP_CONNECT
  if (flags & ARES_SOCKET_CONN_TCP_FASTOPEN) {
    return 0;
  }
  return connect(sock, address, address_len);
#elif defined(TFO_USE_CONNECTX) && TFO_USE_CONNECTX
  if (flags & ARES_SOCKET_CONN_TCP_FASTOPEN) {
    sa_endpoints_t endpoints;

    memset(&endpoints, 0, sizeof(endpoints));
    endpoints.sae_dstaddr    = address;
    endpoints.sae_dstaddrlen = address_len;

    return connectx(sock, &endpoints, SAE_ASSOCID_ANY,
                    CONNECT_DATA_IDEMPOTENT | CONNECT_RESUME_ON_READ_WRITE,
                    NULL, 0, NULL, NULL);
  } else {
    return connect(sock, address, address_len);
  }
#else
  (void)flags;
  return connect(sock, address, address_len);
#endif
}

static ares_ssize_t default_arecvfrom(ares_socket_t sock, void *buffer,
                                      size_t length, int flags,
                                      struct sockaddr *address,
                                      ares_socklen_t  *address_len,
                                      void            *user_data)
{
  (void)user_data;

#ifdef HAVE_RECVFROM
  return (ares_ssize_t)recvfrom(sock, buffer, (RECVFROM_TYPE_ARG3)length, flags,
                                address, address_len);
#else
  if (address != NULL && address_len != NULL) {
    memset(address, 0, (size_t)*address_len);
    address->sa_family = AF_UNSPEC;
  }
  return (ares_ssize_t)recv(sock, buffer, (RECVFROM_TYPE_ARG3)length, flags);
#endif
}

static ares_ssize_t default_asendto(ares_socket_t sock, const void *buffer,
                                    size_t length, int flags,
                                    const struct sockaddr *address,
                                    ares_socklen_t address_len, void *user_data)
{
  (void)user_data;

  if (address != NULL) {
#ifdef HAVE_SENDTO
    return (ares_ssize_t)sendto((SEND_TYPE_ARG1)sock, (SEND_TYPE_ARG2)buffer,
                                (SEND_TYPE_ARG3)length, (SEND_TYPE_ARG4)flags,
                                address, address_len);
#else
    (void)address_len;
#endif
  }

  return (ares_ssize_t)send((SEND_TYPE_ARG1)sock, (SEND_TYPE_ARG2)buffer,
                            (SEND_TYPE_ARG3)length, (SEND_TYPE_ARG4)flags);
}

static int default_agetsockname(ares_socket_t sock, struct sockaddr *address,
                                ares_socklen_t *address_len, void *user_data)
{
  (void)user_data;
  return getsockname(sock, address, address_len);
}

static int default_abind(ares_socket_t sock, unsigned int flags,
                         const struct sockaddr *address, socklen_t address_len,
                         void *user_data)
{
  (void)user_data;

#ifdef IP_BIND_ADDRESS_NO_PORT
  if (flags & ARES_SOCKET_BIND_TCP && flags & ARES_SOCKET_BIND_CLIENT) {
    int opt = 1;
    (void)setsockopt(sock, SOL_IP, IP_BIND_ADDRESS_NO_PORT, &opt, sizeof(opt));
  }
#else
  (void)flags;
#endif

  return bind(sock, address, address_len);
}

static unsigned int default_aif_nametoindex(const char *ifname, void *user_data)
{
  (void)user_data;
  return ares_os_if_nametoindex(ifname);
}

static const char *default_aif_indextoname(unsigned int ifindex,
                                           char        *ifname_buf,
                                           size_t       ifname_buf_len,
                                           void        *user_data)
{
  (void)user_data;
  return ares_os_if_indextoname(ifindex, ifname_buf, ifname_buf_len);
}

static const struct ares_socket_functions_ex default_socket_functions = {
  1,
  ARES_SOCKFUNC_FLAG_NONBLOCKING,
  default_asocket,
  default_aclose,
  default_asetsockopt,
  default_aconnect,
  default_arecvfrom,
  default_asendto,
  default_agetsockname,
  default_abind,
  default_aif_nametoindex,
  default_aif_indextoname
};

void ares_set_socket_functions_def(ares_channel_t *channel)
{
  ares_set_socket_functions_ex(channel, &default_socket_functions, NULL);
}

static int legacycb_aclose(ares_socket_t sock, void *user_data)
{
  ares_channel_t *channel = user_data;

  if (channel->legacy_sock_funcs != NULL &&
      channel->legacy_sock_funcs->aclose != NULL) {
    return channel->legacy_sock_funcs->aclose(
      sock, channel->legacy_sock_funcs_cb_data);
  }

  return default_aclose(sock, NULL);
}

static ares_socket_t legacycb_asocket(int domain, int type, int protocol,
                                      void *user_data)
{
  ares_channel_t *channel = user_data;

  if (channel->legacy_sock_funcs != NULL &&
      channel->legacy_sock_funcs->asocket != NULL) {
    return channel->legacy_sock_funcs->asocket(
      domain, type, protocol, channel->legacy_sock_funcs_cb_data);
  }

  return default_asocket(domain, type, protocol, NULL);
}

static int legacycb_asetsockopt(ares_socket_t sock, ares_socket_opt_t opt,
                                const void *val, ares_socklen_t val_size,
                                void *user_data)
{
  (void)sock;
  (void)opt;
  (void)val;
  (void)val_size;
  (void)user_data;
  SET_SOCKERRNO(ENOSYS);
  return -1;
}

static int legacycb_aconnect(ares_socket_t sock, const struct sockaddr *address,
                             ares_socklen_t address_len, unsigned int flags,
                             void *user_data)
{
  ares_channel_t *channel = user_data;

  if (channel->legacy_sock_funcs != NULL &&
      channel->legacy_sock_funcs->aconnect != NULL) {
    return channel->legacy_sock_funcs->aconnect(
      sock, address, address_len, channel->legacy_sock_funcs_cb_data);
  }

  return default_aconnect(sock, address, address_len, flags, NULL);
}

static ares_ssize_t legacycb_arecvfrom(ares_socket_t sock, void *buffer,
                                       size_t length, int flags,
                                       struct sockaddr *address,
                                       ares_socklen_t  *address_len,
                                       void            *user_data)
{
  ares_channel_t *channel = user_data;

  if (channel->legacy_sock_funcs != NULL &&
      channel->legacy_sock_funcs->arecvfrom != NULL) {
    if (address != NULL && address_len != NULL) {
      memset(address, 0, (size_t)*address_len);
      address->sa_family = AF_UNSPEC;
    }
    return channel->legacy_sock_funcs->arecvfrom(
      sock, buffer, length, flags, address, address_len,
      channel->legacy_sock_funcs_cb_data);
  }

  return default_arecvfrom(sock, buffer, length, flags, address, address_len,
                           NULL);
}

static ares_ssize_t legacycb_asendto(ares_socket_t sock, const void *buffer,
                                     size_t length, int flags,
                                     const struct sockaddr *address,
                                     ares_socklen_t         address_len,
                                     void                  *user_data)
{
  ares_channel_t *channel = user_data;

  if (channel->legacy_sock_funcs != NULL &&
      channel->legacy_sock_funcs->asendv != NULL) {
    struct iovec vec;
    vec.iov_base = (void *)((size_t)buffer); /* Cast off const */
    vec.iov_len  = length;
    return channel->legacy_sock_funcs->asendv(
      sock, &vec, 1, channel->legacy_sock_funcs_cb_data);
  }

  return default_asendto(sock, buffer, length, flags, address, address_len,
                         NULL);
}


static const struct ares_socket_functions_ex legacy_socket_functions = {
  1,
  0,
  legacycb_asocket,
  legacycb_aclose,
  legacycb_asetsockopt,
  legacycb_aconnect,
  legacycb_arecvfrom,
  legacycb_asendto,
  NULL, /* agetsockname */
  NULL, /* abind */
  NULL, /* aif_nametoindex */
  NULL  /* aif_indextoname */
};

void ares_set_socket_functions(ares_channel_t                     *channel,
                               const struct ares_socket_functions *funcs,
                               void                               *data)
{
  if (channel == NULL || channel->optmask & ARES_OPT_EVENT_THREAD) {
    return;
  }

  channel->legacy_sock_funcs         = funcs;
  channel->legacy_sock_funcs_cb_data = data;
  ares_set_socket_functions_ex(channel, &legacy_socket_functions, channel);
}
                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/cares/src/lib/ares_setup.h                                                         0000664 0000000 0000000 00000013172 14746647661 0020471 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2004 Daniel Stenberg
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES_SETUP_H
#define __ARES_SETUP_H

/* ============================================================================
 * NOTE: This file is automatically included by ares_private.h and should not
 *       typically be included directly.
 *       All c-ares source files should include ares_private.h as the
 *       first header.
 * ============================================================================
 */

/*
 * Include configuration script results or hand-crafted
 * configuration file for platforms which lack config tool.
 */

#ifdef HAVE_CONFIG_H
#  include "ares_config.h"
#else
#  ifdef _WIN32
#    include "config-win32.h"
#  endif
#endif /* HAVE_CONFIG_H */

/*
 * c-ares external interface definitions are also used internally,
 * and might also include required system header files to define them.
 */

#include "ares_build.h"

/* ================================================================= */
/* No system header file shall be included in this file before this  */
/* point. The only allowed ones are those included from ares_build.h */
/* ================================================================= */

/*
 * Include header files for windows builds before redefining anything.
 * Use this preproessor block only to include or exclude windows.h,
 * winsock2.h, ws2tcpip.h or winsock.h. Any other windows thing belongs
 * to any other further and independent block.  Under Cygwin things work
 * just as under linux (e.g. <sys/socket.h>) and the winsock headers should
 * never be included when __CYGWIN__ is defined.  configure script takes
 * care of this, not defining HAVE_WINDOWS_H, HAVE_WINSOCK_H, HAVE_WINSOCK2_H,
 * neither HAVE_WS2TCPIP_H when __CYGWIN__ is defined.
 */

#ifdef USE_WINSOCK
#  undef USE_WINSOCK
#endif

#ifdef HAVE_WINDOWS_H
#  ifndef WIN32_LEAN_AND_MEAN
#    define WIN32_LEAN_AND_MEAN
#  endif
#  include <windows.h>
#  ifdef HAVE_WINSOCK2_H
#    include <winsock2.h>
#    define USE_WINSOCK 2
#    ifdef HAVE_WS2TCPIP_H
#      include <ws2tcpip.h>
#    endif
#  else
#    ifdef HAVE_WINSOCK_H
#      include <winsock.h>
#      define USE_WINSOCK 1
#    endif
#  endif
#endif


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>

#ifdef HAVE_ERRNO_H
#  include <errno.h>
#endif

#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif

#ifdef HAVE_MALLOC_H
#  include <malloc.h>
#endif

#ifdef HAVE_SYS_STAT_H
#  include <sys/stat.h>
#endif

#ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>
#endif

#ifdef HAVE_TIME_H
#  include <time.h>
#endif

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#ifdef HAVE_SYS_SOCKET_H
#  include <sys/socket.h>
#endif

/*
 * Arg 2 type for gethostname in case it hasn't been defined in config file.
 */

#ifndef GETHOSTNAME_TYPE_ARG2
#  ifdef USE_WINSOCK
#    define GETHOSTNAME_TYPE_ARG2 int
#  else
#    define GETHOSTNAME_TYPE_ARG2 size_t
#  endif
#endif

#ifdef __POCC__
#  include <sys/types.h>
#  include <unistd.h>
#  define ESRCH 3
#endif

/*
 * Android does have the arpa/nameser.h header which is detected by configure
 * but it appears to be empty with recent NDK r7b / r7c, so we undefine here.
 * z/OS does have the arpa/nameser.h header which is detected by configure
 * but it is not fully implemented and missing identifiers, so udefine here.
 */
#if (defined(ANDROID) || defined(__ANDROID__) || defined(__MVS__)) && \
  defined(HAVE_ARPA_NAMESER_H)
#  undef HAVE_ARPA_NAMESER_H
#endif

/*
 * Recent autoconf versions define these symbols in ares_config.h. We don't
 * want them (since they collide with the libcurl ones when we build
 *  --enable-debug) so we undef them again here.
 */

#ifdef PACKAGE_STRING
#  undef PACKAGE_STRING
#endif
#ifdef PACKAGE_TARNAME
#  undef PACKAGE_TARNAME
#endif
#ifdef PACKAGE_VERSION
#  undef PACKAGE_VERSION
#endif
#ifdef PACKAGE_BUGREPORT
#  undef PACKAGE_BUGREPORT
#endif
#ifdef PACKAGE_NAME
#  undef PACKAGE_NAME
#endif
#ifdef VERSION
#  undef VERSION
#endif
#ifdef PACKAGE
#  undef PACKAGE
#endif

/* IPv6 compatibility */
#if !defined(HAVE_AF_INET6)
#  if defined(HAVE_PF_INET6)
#    define AF_INET6 PF_INET6
#  else
#    define AF_INET6 AF_MAX + 1
#  endif
#endif


/* Definition of timeval struct for platforms that don't have it. */

#ifndef HAVE_STRUCT_TIMEVAL
struct timeval {
  ares_int64_t tv_sec;
  long         tv_usec;
};
#endif


/*
 * Macro used to include code only in debug builds.
 */

#ifdef DEBUGBUILD
#  define DEBUGF(x) x
#else
#  define DEBUGF(x) \
    do {            \
    } while (0)
#endif

#endif /* __ARES_SETUP_H */
                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/cares/src/lib/ares_socket.c                                                        0000664 0000000 0000000 00000031046 14746647661 0020614 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) Massachusetts Institute of Technology
 * Copyright (c) The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#ifdef HAVE_SYS_UIO_H
#  include <sys/uio.h>
#endif
#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif
#ifdef HAVE_NETINET_TCP_H
#  include <netinet/tcp.h>
#endif
#ifdef HAVE_NETDB_H
#  include <netdb.h>
#endif
#ifdef HAVE_ARPA_INET_H
#  include <arpa/inet.h>
#endif

#ifdef HAVE_STRINGS_H
#  include <strings.h>
#endif
#ifdef HAVE_SYS_IOCTL_H
#  include <sys/ioctl.h>
#endif
#ifdef NETWARE
#  include <sys/filio.h>
#endif

#include <assert.h>
#include <fcntl.h>
#include <limits.h>

static ares_conn_err_t ares_socket_deref_error(int err)
{
  switch (err) {
#if defined(EWOULDBLOCK)
    case EWOULDBLOCK:
      return ARES_CONN_ERR_WOULDBLOCK;
#endif
#if defined(EAGAIN) && (!defined(EWOULDBLOCK) || EAGAIN != EWOULDBLOCK)
    case EAGAIN:
      return ARES_CONN_ERR_WOULDBLOCK;
#endif
    case EINPROGRESS:
      return ARES_CONN_ERR_WOULDBLOCK;
    case ENETDOWN:
      return ARES_CONN_ERR_NETDOWN;
    case ENETUNREACH:
      return ARES_CONN_ERR_NETUNREACH;
    case ECONNABORTED:
      return ARES_CONN_ERR_CONNABORTED;
    case ECONNRESET:
      return ARES_CONN_ERR_CONNRESET;
    case ECONNREFUSED:
      return ARES_CONN_ERR_CONNREFUSED;
    case ETIMEDOUT:
      return ARES_CONN_ERR_CONNTIMEDOUT;
    case EHOSTDOWN:
      return ARES_CONN_ERR_HOSTDOWN;
    case EHOSTUNREACH:
      return ARES_CONN_ERR_HOSTUNREACH;
    case EINTR:
      return ARES_CONN_ERR_INTERRUPT;
    case EAFNOSUPPORT:
      return ARES_CONN_ERR_AFNOSUPPORT;
    case EADDRNOTAVAIL:
      return ARES_CONN_ERR_BADADDR;
    default:
      break;
  }

  return ARES_CONN_ERR_FAILURE;
}

ares_bool_t ares_sockaddr_addr_eq(const struct sockaddr  *sa,
                                  const struct ares_addr *aa)
{
  const void *addr1;
  const void *addr2;

  if (sa->sa_family == aa->family) {
    switch (aa->family) {
      case AF_INET:
        addr1 = &aa->addr.addr4;
        addr2 = &(CARES_INADDR_CAST(const struct sockaddr_in *, sa))->sin_addr;
        if (memcmp(addr1, addr2, sizeof(aa->addr.addr4)) == 0) {
          return ARES_TRUE; /* match */
        }
        break;
      case AF_INET6:
        addr1 = &aa->addr.addr6;
        addr2 =
          &(CARES_INADDR_CAST(const struct sockaddr_in6 *, sa))->sin6_addr;
        if (memcmp(addr1, addr2, sizeof(aa->addr.addr6)) == 0) {
          return ARES_TRUE; /* match */
        }
        break;
      default:
        break; /* LCOV_EXCL_LINE */
    }
  }
  return ARES_FALSE; /* different */
}

ares_conn_err_t ares_socket_write(ares_channel_t *channel, ares_socket_t fd,
                                  const void *data, size_t len, size_t *written,
                                  const struct sockaddr *sa,
                                  ares_socklen_t         salen)
{
  int             flags = 0;
  ares_ssize_t    rv;
  ares_conn_err_t err = ARES_CONN_ERR_SUCCESS;

#ifdef HAVE_MSG_NOSIGNAL
  flags |= MSG_NOSIGNAL;
#endif

  rv = channel->sock_funcs.asendto(fd, data, len, flags, sa, salen,
                                   channel->sock_func_cb_data);
  if (rv <= 0) {
    err = ares_socket_deref_error(SOCKERRNO);
  } else {
    *written = (size_t)rv;
  }
  return err;
}

ares_conn_err_t ares_socket_recv(ares_channel_t *channel, ares_socket_t s,
                                 ares_bool_t is_tcp, void *data,
                                 size_t data_len, size_t *read_bytes)
{
  ares_ssize_t rv;

  *read_bytes = 0;

  rv = channel->sock_funcs.arecvfrom(s, data, data_len, 0, NULL, 0,
                                     channel->sock_func_cb_data);

  if (rv > 0) {
    *read_bytes = (size_t)rv;
    return ARES_CONN_ERR_SUCCESS;
  }

  if (rv == 0) {
    /* UDP allows 0-byte packets and is connectionless, so this is success */
    if (!is_tcp) {
      return ARES_CONN_ERR_SUCCESS;
    } else {
      return ARES_CONN_ERR_CONNCLOSED;
    }
  }

  /* If we're here, rv<0 */
  return ares_socket_deref_error(SOCKERRNO);
}

ares_conn_err_t ares_socket_recvfrom(ares_channel_t *channel, ares_socket_t s,
                                     ares_bool_t is_tcp, void *data,
                                     size_t data_len, int flags,
                                     struct sockaddr *from,
                                     ares_socklen_t  *from_len,
                                     size_t          *read_bytes)
{
  ares_ssize_t rv;

  rv = channel->sock_funcs.arecvfrom(s, data, data_len, flags, from, from_len,
                                     channel->sock_func_cb_data);

  if (rv > 0) {
    *read_bytes = (size_t)rv;
    return ARES_CONN_ERR_SUCCESS;
  }

  if (rv == 0) {
    /* UDP allows 0-byte packets and is connectionless, so this is success */
    if (!is_tcp) {
      return ARES_CONN_ERR_SUCCESS;
    } else {
      return ARES_CONN_ERR_CONNCLOSED;
    }
  }

  /* If we're here, rv<0 */
  return ares_socket_deref_error(SOCKERRNO);
}

ares_conn_err_t ares_socket_enable_tfo(const ares_channel_t *channel,
                                       ares_socket_t         fd)
{
  ares_bool_t opt = ARES_TRUE;

  if (channel->sock_funcs.asetsockopt(fd, ARES_SOCKET_OPT_TCP_FASTOPEN,
                                      (void *)&opt, sizeof(opt),
                                      channel->sock_func_cb_data) != 0) {
    return ARES_CONN_ERR_NOTIMP;
  }

  return ARES_CONN_ERR_SUCCESS;
}

ares_status_t ares_socket_configure(ares_channel_t *channel, int family,
                                    ares_bool_t is_tcp, ares_socket_t fd)
{
  union {
    struct sockaddr     sa;
    struct sockaddr_in  sa4;
    struct sockaddr_in6 sa6;
  } local;

  ares_socklen_t bindlen = 0;
  int            rv;
  unsigned int   bind_flags = 0;

  /* Set the socket's send and receive buffer sizes. */
  if (channel->socket_send_buffer_size > 0) {
    rv = channel->sock_funcs.asetsockopt(
      fd, ARES_SOCKET_OPT_SENDBUF_SIZE,
      (void *)&channel->socket_send_buffer_size,
      sizeof(channel->socket_send_buffer_size), channel->sock_func_cb_data);
    if (rv != 0 && SOCKERRNO != ENOSYS) {
      return ARES_ECONNREFUSED; /* LCOV_EXCL_LINE: UntestablePath */
    }
  }

  if (channel->socket_receive_buffer_size > 0) {
    rv = channel->sock_funcs.asetsockopt(
      fd, ARES_SOCKET_OPT_RECVBUF_SIZE,
      (void *)&channel->socket_receive_buffer_size,
      sizeof(channel->socket_receive_buffer_size), channel->sock_func_cb_data);
    if (rv != 0 && SOCKERRNO != ENOSYS) {
      return ARES_ECONNREFUSED; /* LCOV_EXCL_LINE: UntestablePath */
    }
  }

  /* Bind to network interface if configured */
  if (ares_strlen(channel->local_dev_name)) {
    /* Prior versions silently ignored failure, so we need to maintain that
     * compatibility */
    (void)channel->sock_funcs.asetsockopt(
      fd, ARES_SOCKET_OPT_BIND_DEVICE, channel->local_dev_name,
      (ares_socklen_t)ares_strlen(channel->local_dev_name),
      channel->sock_func_cb_data);
  }

  /* Bind to ip address if configured */
  if (family == AF_INET && channel->local_ip4) {
    memset(&local.sa4, 0, sizeof(local.sa4));
    local.sa4.sin_family      = AF_INET;
    local.sa4.sin_addr.s_addr = htonl(channel->local_ip4);
    bindlen                   = sizeof(local.sa4);
  } else if (family == AF_INET6 &&
             memcmp(channel->local_ip6, ares_in6addr_any._S6_un._S6_u8,
                    sizeof(channel->local_ip6)) != 0) {
    /* Only if not link-local and an ip other than "::" is specified */
    memset(&local.sa6, 0, sizeof(local.sa6));
    local.sa6.sin6_family = AF_INET6;
    memcpy(&local.sa6.sin6_addr, channel->local_ip6,
           sizeof(channel->local_ip6));
    bindlen = sizeof(local.sa6);
  }


  if (bindlen && channel->sock_funcs.abind != NULL) {
    bind_flags |= ARES_SOCKET_BIND_CLIENT;
    if (is_tcp) {
      bind_flags |= ARES_SOCKET_BIND_TCP;
    }
    if (channel->sock_funcs.abind(fd, bind_flags, &local.sa, bindlen,
                                  channel->sock_func_cb_data) != 0) {
      return ARES_ECONNREFUSED;
    }
  }

  return ARES_SUCCESS;
}

ares_bool_t ares_sockaddr_to_ares_addr(struct ares_addr      *ares_addr,
                                       unsigned short        *port,
                                       const struct sockaddr *sockaddr)
{
  if (sockaddr->sa_family == AF_INET) {
    /* NOTE: memcpy sockaddr_in due to alignment issues found by UBSAN due to
     *       dnsinfo packing on MacOS */
    struct sockaddr_in sockaddr_in;
    memcpy(&sockaddr_in, sockaddr, sizeof(sockaddr_in));

    ares_addr->family = AF_INET;
    memcpy(&ares_addr->addr.addr4, &(sockaddr_in.sin_addr),
           sizeof(ares_addr->addr.addr4));

    if (port) {
      *port = ntohs(sockaddr_in.sin_port);
    }
    return ARES_TRUE;
  }

  if (sockaddr->sa_family == AF_INET6) {
    /* NOTE: memcpy sockaddr_in6 due to alignment issues found by UBSAN due to
     *       dnsinfo packing on MacOS */
    struct sockaddr_in6 sockaddr_in6;
    memcpy(&sockaddr_in6, sockaddr, sizeof(sockaddr_in6));

    ares_addr->family = AF_INET6;
    memcpy(&ares_addr->addr.addr6, &(sockaddr_in6.sin6_addr),
           sizeof(ares_addr->addr.addr6));
    if (port) {
      *port = ntohs(sockaddr_in6.sin6_port);
    }
    return ARES_TRUE;
  }

  return ARES_FALSE;
}

ares_conn_err_t ares_socket_open(ares_socket_t *sock, ares_channel_t *channel,
                                 int af, int type, int protocol)
{
  ares_socket_t s;

  *sock = ARES_SOCKET_BAD;

  s =
    channel->sock_funcs.asocket(af, type, protocol, channel->sock_func_cb_data);

  if (s == ARES_SOCKET_BAD) {
    return ares_socket_deref_error(SOCKERRNO);
  }

  *sock = s;

  return ARES_CONN_ERR_SUCCESS;
}

ares_conn_err_t ares_socket_connect(ares_channel_t *channel,
                                    ares_socket_t sockfd, ares_bool_t is_tfo,
                                    const struct sockaddr *addr,
                                    ares_socklen_t         addrlen)
{
  ares_conn_err_t err   = ARES_CONN_ERR_SUCCESS;
  unsigned int    flags = 0;

  if (is_tfo) {
    flags |= ARES_SOCKET_CONN_TCP_FASTOPEN;
  }

  do {
    int rv;

    rv = channel->sock_funcs.aconnect(sockfd, addr, addrlen, flags,
                                      channel->sock_func_cb_data);

    if (rv < 0) {
      err = ares_socket_deref_error(SOCKERRNO);
    } else {
      err = ARES_CONN_ERR_SUCCESS;
    }
  } while (err == ARES_CONN_ERR_INTERRUPT);

  return err;
}

void ares_socket_close(ares_channel_t *channel, ares_socket_t s)
{
  if (channel == NULL || s == ARES_SOCKET_BAD) {
    return;
  }

  channel->sock_funcs.aclose(s, channel->sock_func_cb_data);
}

void ares_set_socket_callback(ares_channel_t           *channel,
                              ares_sock_create_callback cb, void *data)
{
  if (channel == NULL) {
    return;
  }
  channel->sock_create_cb      = cb;
  channel->sock_create_cb_data = data;
}

void ares_set_socket_configure_callback(ares_channel_t           *channel,
                                        ares_sock_config_callback cb,
                                        void                     *data)
{
  if (channel == NULL || channel->optmask & ARES_OPT_EVENT_THREAD) {
    return;
  }
  channel->sock_config_cb      = cb;
  channel->sock_config_cb_data = data;
}

void ares_set_pending_write_cb(ares_channel_t       *channel,
                               ares_pending_write_cb callback, void *user_data)
{
  if (channel == NULL || channel->optmask & ARES_OPT_EVENT_THREAD) {
    return;
  }
  channel->notify_pending_write_cb      = callback;
  channel->notify_pending_write_cb_data = user_data;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/cares/src/lib/ares_socket.h                                                        0000664 0000000 0000000 00000017137 14746647661 0020626 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#ifndef __ARES_SOCKET_H
#define __ARES_SOCKET_H

/* Macro SOCKERRNO / SET_SOCKERRNO() returns / sets the *socket-related* errno
 * (or equivalent) on this platform to hide platform details to code using it.
 */
#ifdef USE_WINSOCK
#  define SOCKERRNO        ((int)WSAGetLastError())
#  define SET_SOCKERRNO(x) (WSASetLastError((int)(x)))
#else
#  define SOCKERRNO        (errno)
#  define SET_SOCKERRNO(x) (errno = (x))
#endif

/* Portable error number symbolic names defined to Winsock error codes. */
#ifdef USE_WINSOCK
#  undef EBADF           /* override definition in errno.h */
#  define EBADF WSAEBADF
#  undef EINTR           /* override definition in errno.h */
#  define EINTR WSAEINTR
#  undef EINVAL          /* override definition in errno.h */
#  define EINVAL WSAEINVAL
#  undef EWOULDBLOCK     /* override definition in errno.h */
#  define EWOULDBLOCK WSAEWOULDBLOCK
#  undef EINPROGRESS     /* override definition in errno.h */
#  define EINPROGRESS WSAEINPROGRESS
#  undef EALREADY        /* override definition in errno.h */
#  define EALREADY WSAEALREADY
#  undef ENOTSOCK        /* override definition in errno.h */
#  define ENOTSOCK WSAENOTSOCK
#  undef EDESTADDRREQ    /* override definition in errno.h */
#  define EDESTADDRREQ WSAEDESTADDRREQ
#  undef EMSGSIZE        /* override definition in errno.h */
#  define EMSGSIZE WSAEMSGSIZE
#  undef EPROTOTYPE      /* override definition in errno.h */
#  define EPROTOTYPE WSAEPROTOTYPE
#  undef ENOPROTOOPT     /* override definition in errno.h */
#  define ENOPROTOOPT WSAENOPROTOOPT
#  undef EPROTONOSUPPORT /* override definition in errno.h */
#  define EPROTONOSUPPORT WSAEPROTONOSUPPORT
#  define ESOCKTNOSUPPORT WSAESOCKTNOSUPPORT
#  undef EOPNOTSUPP /* override definition in errno.h */
#  define EOPNOTSUPP WSAEOPNOTSUPP
#  undef ENOSYS     /* override definition in errno.h */
#  define ENOSYS       WSAEOPNOTSUPP
#  define EPFNOSUPPORT WSAEPFNOSUPPORT
#  undef EAFNOSUPPORT  /* override definition in errno.h */
#  define EAFNOSUPPORT WSAEAFNOSUPPORT
#  undef EADDRINUSE    /* override definition in errno.h */
#  define EADDRINUSE WSAEADDRINUSE
#  undef EADDRNOTAVAIL /* override definition in errno.h */
#  define EADDRNOTAVAIL WSAEADDRNOTAVAIL
#  undef ENETDOWN      /* override definition in errno.h */
#  define ENETDOWN WSAENETDOWN
#  undef ENETUNREACH   /* override definition in errno.h */
#  define ENETUNREACH WSAENETUNREACH
#  undef ENETRESET     /* override definition in errno.h */
#  define ENETRESET WSAENETRESET
#  undef ECONNABORTED  /* override definition in errno.h */
#  define ECONNABORTED WSAECONNABORTED
#  undef ECONNRESET    /* override definition in errno.h */
#  define ECONNRESET WSAECONNRESET
#  undef ENOBUFS       /* override definition in errno.h */
#  define ENOBUFS WSAENOBUFS
#  undef EISCONN       /* override definition in errno.h */
#  define EISCONN WSAEISCONN
#  undef ENOTCONN      /* override definition in errno.h */
#  define ENOTCONN     WSAENOTCONN
#  define ESHUTDOWN    WSAESHUTDOWN
#  define ETOOMANYREFS WSAETOOMANYREFS
#  undef ETIMEDOUT     /* override definition in errno.h */
#  define ETIMEDOUT WSAETIMEDOUT
#  undef ECONNREFUSED  /* override definition in errno.h */
#  define ECONNREFUSED WSAECONNREFUSED
#  undef ELOOP         /* override definition in errno.h */
#  define ELOOP WSAELOOP
#  ifndef ENAMETOOLONG /* possible previous definition in errno.h */
#    define ENAMETOOLONG WSAENAMETOOLONG
#  endif
#  define EHOSTDOWN WSAEHOSTDOWN
#  undef EHOSTUNREACH /* override definition in errno.h */
#  define EHOSTUNREACH WSAEHOSTUNREACH
#  ifndef ENOTEMPTY   /* possible previous definition in errno.h */
#    define ENOTEMPTY WSAENOTEMPTY
#  endif
#  define EPROCLIM WSAEPROCLIM
#  define EUSERS   WSAEUSERS
#  define EDQUOT   WSAEDQUOT
#  define ESTALE   WSAESTALE
#  define EREMOTE  WSAEREMOTE
#endif

/*! Socket errors */
typedef enum {
  ARES_CONN_ERR_SUCCESS      = 0,  /*!< Success */
  ARES_CONN_ERR_WOULDBLOCK   = 1,  /*!< Operation would block */
  ARES_CONN_ERR_CONNCLOSED   = 2,  /*!< Connection closed (gracefully) */
  ARES_CONN_ERR_CONNABORTED  = 3,  /*!< Connection Aborted */
  ARES_CONN_ERR_CONNRESET    = 4,  /*!< Connection Reset */
  ARES_CONN_ERR_CONNREFUSED  = 5,  /*!< Connection Refused */
  ARES_CONN_ERR_CONNTIMEDOUT = 6,  /*!< Connection Timed Out */
  ARES_CONN_ERR_HOSTDOWN     = 7,  /*!< Host Down */
  ARES_CONN_ERR_HOSTUNREACH  = 8,  /*!< Host Unreachable */
  ARES_CONN_ERR_NETDOWN      = 9,  /*!< Network Down */
  ARES_CONN_ERR_NETUNREACH   = 10, /*!< Network Unreachable */
  ARES_CONN_ERR_INTERRUPT    = 11, /*!< Call interrupted by signal, repeat */
  ARES_CONN_ERR_AFNOSUPPORT  = 12, /*!< Address family not supported */
  ARES_CONN_ERR_BADADDR      = 13, /*!< Bad Address / Unavailable */
  ARES_CONN_ERR_NOMEM        = 14, /*!< Out of memory */
  ARES_CONN_ERR_INVALID      = 15, /*!< Invalid Usage */
  ARES_CONN_ERR_TOOLARGE     = 16, /*!< Request size too large */
  ARES_CONN_ERR_NOTIMP       = 17, /*!< Not implemented */
  ARES_CONN_ERR_FAILURE      = 99  /*!< Generic failure */
} ares_conn_err_t;

ares_bool_t     ares_sockaddr_addr_eq(const struct sockaddr  *sa,
                                      const struct ares_addr *aa);
ares_status_t   ares_socket_configure(ares_channel_t *channel, int family,
                                      ares_bool_t is_tcp, ares_socket_t fd);
ares_conn_err_t ares_socket_enable_tfo(const ares_channel_t *channel,
                                       ares_socket_t         fd);
ares_conn_err_t ares_socket_open(ares_socket_t *sock, ares_channel_t *channel,
                                 int af, int type, int protocol);
ares_bool_t     ares_socket_try_again(int errnum);
void            ares_socket_close(ares_channel_t *channel, ares_socket_t s);
ares_conn_err_t ares_socket_connect(ares_channel_t *channel,
                                    ares_socket_t sockfd, ares_bool_t is_tfo,
                                    const struct sockaddr *addr,
                                    ares_socklen_t         addrlen);
ares_bool_t     ares_sockaddr_to_ares_addr(struct ares_addr      *ares_addr,
                                           unsigned short        *port,
                                           const struct sockaddr *sockaddr);
ares_conn_err_t ares_socket_write(ares_channel_t *channel, ares_socket_t fd,
                                  const void *data, size_t len, size_t *written,
                                  const struct sockaddr *sa,
                                  ares_socklen_t         salen);
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/cares/src/lib/ares_sortaddrinfo.c                                                  0000664 0000000 0000000 00000034150 14746647661 0022021 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Original file name getaddrinfo.c
 * Lifted from the 'Android Bionic' project with the BSD license.
 */

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * Copyright (C) 2018 The Android Open Source Project
 * Copyright (C) 2019 Andrew Selivanov
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include "ares_private.h"

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif
#ifdef HAVE_NETDB_H
#  include <netdb.h>
#endif
#ifdef HAVE_STRINGS_H
#  include <strings.h>
#endif

#include <assert.h>
#include <limits.h>

struct addrinfo_sort_elem {
  struct ares_addrinfo_node *ai;
  ares_bool_t                has_src_addr;
  ares_sockaddr              src_addr;
  size_t                     original_order;
};

#define ARES_IPV6_ADDR_MC_SCOPE(a) ((a)->s6_addr[1] & 0x0f)

#define ARES_IPV6_ADDR_SCOPE_NODELOCAL    0x01
#define ARES_IPV6_ADDR_SCOPE_INTFACELOCAL 0x01
#define ARES_IPV6_ADDR_SCOPE_LINKLOCAL    0x02
#define ARES_IPV6_ADDR_SCOPE_SITELOCAL    0x05
#define ARES_IPV6_ADDR_SCOPE_ORGLOCAL     0x08
#define ARES_IPV6_ADDR_SCOPE_GLOBAL       0x0e

#define ARES_IN_LOOPBACK(a) \
  ((((long unsigned int)(a)) & 0xff000000) == 0x7f000000)

/* RFC 4193. */
#define ARES_IN6_IS_ADDR_ULA(a) (((a)->s6_addr[0] & 0xfe) == 0xfc)

/* These macros are modelled after the ones in <netinet/in6.h>. */
/* RFC 4380, section 2.6 */
#define ARES_IN6_IS_ADDR_TEREDO(a)                             \
  ((*(const unsigned int *)(const void *)(&(a)->s6_addr[0]) == \
    ntohl(0x20010000)))
/* RFC 3056, section 2. */
#define ARES_IN6_IS_ADDR_6TO4(a) \
  (((a)->s6_addr[0] == 0x20) && ((a)->s6_addr[1] == 0x02))
/* 6bone testing address area (3ffe::/16), deprecated in RFC 3701. */
#define ARES_IN6_IS_ADDR_6BONE(a) \
  (((a)->s6_addr[0] == 0x3f) && ((a)->s6_addr[1] == 0xfe))

static int get_scope(const struct sockaddr *addr)
{
  if (addr->sa_family == AF_INET6) {
    const struct sockaddr_in6 *addr6 =
      CARES_INADDR_CAST(const struct sockaddr_in6 *, addr);
    if (IN6_IS_ADDR_MULTICAST(&addr6->sin6_addr)) {
      return ARES_IPV6_ADDR_MC_SCOPE(&addr6->sin6_addr);
    } else if (IN6_IS_ADDR_LOOPBACK(&addr6->sin6_addr) ||
               IN6_IS_ADDR_LINKLOCAL(&addr6->sin6_addr)) {
      /*
       * RFC 4291 section 2.5.3 says loopback is to be treated as having
       * link-local scope.
       */
      return ARES_IPV6_ADDR_SCOPE_LINKLOCAL;
    } else if (IN6_IS_ADDR_SITELOCAL(&addr6->sin6_addr)) {
      return ARES_IPV6_ADDR_SCOPE_SITELOCAL;
    } else {
      return ARES_IPV6_ADDR_SCOPE_GLOBAL;
    }
  } else if (addr->sa_family == AF_INET) {
    const struct sockaddr_in *addr4 =
      CARES_INADDR_CAST(const struct sockaddr_in *, addr);
    unsigned long int na = ntohl(addr4->sin_addr.s_addr);
    if (ARES_IN_LOOPBACK(na) ||          /* 127.0.0.0/8 */
        (na & 0xffff0000) == 0xa9fe0000) /* 169.254.0.0/16 */
    {
      return ARES_IPV6_ADDR_SCOPE_LINKLOCAL;
    } else {
      /*
       * RFC 6724 section 3.2. Other IPv4 addresses, including private
       * addresses and shared addresses (100.64.0.0/10), are assigned global
       * scope.
       */
      return ARES_IPV6_ADDR_SCOPE_GLOBAL;
    }
  } else {
    /*
     * This should never happen.
     * Return a scope with low priority as a last resort.
     */
    return ARES_IPV6_ADDR_SCOPE_NODELOCAL;
  }
}

static int get_label(const struct sockaddr *addr)
{
  if (addr->sa_family == AF_INET) {
    return 4;
  } else if (addr->sa_family == AF_INET6) {
    const struct sockaddr_in6 *addr6 =
      CARES_INADDR_CAST(const struct sockaddr_in6 *, addr);
    if (IN6_IS_ADDR_LOOPBACK(&addr6->sin6_addr)) {
      return 0;
    } else if (IN6_IS_ADDR_V4MAPPED(&addr6->sin6_addr)) {
      return 4;
    } else if (ARES_IN6_IS_ADDR_6TO4(&addr6->sin6_addr)) {
      return 2;
    } else if (ARES_IN6_IS_ADDR_TEREDO(&addr6->sin6_addr)) {
      return 5;
    } else if (ARES_IN6_IS_ADDR_ULA(&addr6->sin6_addr)) {
      return 13;
    } else if (IN6_IS_ADDR_V4COMPAT(&addr6->sin6_addr)) {
      return 3;
    } else if (IN6_IS_ADDR_SITELOCAL(&addr6->sin6_addr)) {
      return 11;
    } else if (ARES_IN6_IS_ADDR_6BONE(&addr6->sin6_addr)) {
      return 12;
    } else {
      /* All other IPv6 addresses, including global unicast addresses. */
      return 1;
    }
  } else {
    /*
     * This should never happen.
     * Return a semi-random label as a last resort.
     */
    return 1;
  }
}

/*
 * Get the precedence for a given IPv4/IPv6 address.
 * RFC 6724, section 2.1.
 */
static int get_precedence(const struct sockaddr *addr)
{
  if (addr->sa_family == AF_INET) {
    return 35;
  } else if (addr->sa_family == AF_INET6) {
    const struct sockaddr_in6 *addr6 =
      CARES_INADDR_CAST(const struct sockaddr_in6 *, addr);
    if (IN6_IS_ADDR_LOOPBACK(&addr6->sin6_addr)) {
      return 50;
    } else if (IN6_IS_ADDR_V4MAPPED(&addr6->sin6_addr)) {
      return 35;
    } else if (ARES_IN6_IS_ADDR_6TO4(&addr6->sin6_addr)) {
      return 30;
    } else if (ARES_IN6_IS_ADDR_TEREDO(&addr6->sin6_addr)) {
      return 5;
    } else if (ARES_IN6_IS_ADDR_ULA(&addr6->sin6_addr)) {
      return 3;
    } else if (IN6_IS_ADDR_V4COMPAT(&addr6->sin6_addr) ||
               IN6_IS_ADDR_SITELOCAL(&addr6->sin6_addr) ||
               ARES_IN6_IS_ADDR_6BONE(&addr6->sin6_addr)) {
      return 1;
    } else {
      /* All other IPv6 addresses, including global unicast addresses. */
      return 40;
    }
  } else {
    return 1;
  }
}

/*
 * Find number of matching initial bits between the two addresses a1 and a2.
 */
static size_t common_prefix_len(const struct in6_addr *a1,
                                const struct in6_addr *a2)
{
  const unsigned char *p1 = (const unsigned char *)a1;
  const unsigned char *p2 = (const unsigned char *)a2;
  size_t               i;
  for (i = 0; i < sizeof(*a1); ++i) {
    unsigned char x;
    size_t        j;
    if (p1[i] == p2[i]) {
      continue;
    }
    x = p1[i] ^ p2[i];
    for (j = 0; j < CHAR_BIT; ++j) {
      if (x & (1 << (CHAR_BIT - 1))) {
        return i * CHAR_BIT + j;
      }
      x <<= 1;
    }
  }
  return sizeof(*a1) * CHAR_BIT;
}

/*
 * Compare two source/destination address pairs.
 * RFC 6724, section 6.
 */
static int rfc6724_compare(const void *ptr1, const void *ptr2)
{
  const struct addrinfo_sort_elem *a1 = (const struct addrinfo_sort_elem *)ptr1;
  const struct addrinfo_sort_elem *a2 = (const struct addrinfo_sort_elem *)ptr2;
  int                              scope_src1;
  int                              scope_dst1;
  int                              scope_match1;
  int                              scope_src2;
  int                              scope_dst2;
  int                              scope_match2;
  int                              label_src1;
  int                              label_dst1;
  int                              label_match1;
  int                              label_src2;
  int                              label_dst2;
  int                              label_match2;
  int                              precedence1;
  int                              precedence2;
  size_t                           prefixlen1;
  size_t                           prefixlen2;

  /* Rule 1: Avoid unusable destinations. */
  if (a1->has_src_addr != a2->has_src_addr) {
    return ((int)a2->has_src_addr) - ((int)a1->has_src_addr);
  }

  /* Rule 2: Prefer matching scope. */
  scope_src1 = ARES_IPV6_ADDR_SCOPE_NODELOCAL;
  if (a1->has_src_addr) {
    scope_src1 = get_scope(&a1->src_addr.sa);
  }
  scope_dst1   = get_scope(a1->ai->ai_addr);
  scope_match1 = (scope_src1 == scope_dst1);

  scope_src2 = ARES_IPV6_ADDR_SCOPE_NODELOCAL;
  if (a2->has_src_addr) {
    scope_src2 = get_scope(&a2->src_addr.sa);
  }
  scope_dst2   = get_scope(a2->ai->ai_addr);
  scope_match2 = (scope_src2 == scope_dst2);

  if (scope_match1 != scope_match2) {
    return scope_match2 - scope_match1;
  }

  /* Rule 3: Avoid deprecated addresses.  */

  /* Rule 4: Prefer home addresses.  */

  /* Rule 5: Prefer matching label. */
  label_src1 = 1;
  if (a1->has_src_addr) {
    label_src1 = get_label(&a1->src_addr.sa);
  }
  label_dst1   = get_label(a1->ai->ai_addr);
  label_match1 = (label_src1 == label_dst1);

  label_src2 = 1;
  if (a2->has_src_addr) {
    label_src2 = get_label(&a2->src_addr.sa);
  }
  label_dst2   = get_label(a2->ai->ai_addr);
  label_match2 = (label_src2 == label_dst2);

  if (label_match1 != label_match2) {
    return label_match2 - label_match1;
  }

  /* Rule 6: Prefer higher precedence. */
  precedence1 = get_precedence(a1->ai->ai_addr);
  precedence2 = get_precedence(a2->ai->ai_addr);
  if (precedence1 != precedence2) {
    return precedence2 - precedence1;
  }

  /* Rule 7: Prefer native transport.  */

  /* Rule 8: Prefer smaller scope. */
  if (scope_dst1 != scope_dst2) {
    return scope_dst1 - scope_dst2;
  }

  /* Rule 9: Use longest matching prefix. */
  if (a1->has_src_addr && a1->ai->ai_addr->sa_family == AF_INET6 &&
      a2->has_src_addr && a2->ai->ai_addr->sa_family == AF_INET6) {
    const struct sockaddr_in6 *a1_src = &a1->src_addr.sa6;
    const struct sockaddr_in6 *a1_dst =
      CARES_INADDR_CAST(const struct sockaddr_in6 *, a1->ai->ai_addr);
    const struct sockaddr_in6 *a2_src = &a2->src_addr.sa6;
    const struct sockaddr_in6 *a2_dst =
      CARES_INADDR_CAST(const struct sockaddr_in6 *, a2->ai->ai_addr);
    prefixlen1 = common_prefix_len(&a1_src->sin6_addr, &a1_dst->sin6_addr);
    prefixlen2 = common_prefix_len(&a2_src->sin6_addr, &a2_dst->sin6_addr);
    if (prefixlen1 != prefixlen2) {
      return (int)prefixlen2 - (int)prefixlen1;
    }
  }

  /*
   * Rule 10: Leave the order unchanged.
   * We need this since qsort() is not necessarily stable.
   */
  return ((int)a1->original_order) - ((int)a2->original_order);
}

/*
 * Find the source address that will be used if trying to connect to the given
 * address.
 *
 * Returns 1 if a source address was found, 0 if the address is unreachable
 * and -1 if a fatal error occurred. If 0 or 1, the contents of src_addr are
 * undefined.
 */
static int find_src_addr(ares_channel_t *channel, const struct sockaddr *addr,
                         struct sockaddr *src_addr)
{
  ares_socket_t   sock;
  ares_socklen_t  len;
  ares_conn_err_t err;

  switch (addr->sa_family) {
    case AF_INET:
      len = sizeof(struct sockaddr_in);
      break;
    case AF_INET6:
      len = sizeof(struct sockaddr_in6);
      break;
    default:
      /* No known usable source address for non-INET families. */
      return 0;
  }

  err =
    ares_socket_open(&sock, channel, addr->sa_family, SOCK_DGRAM, IPPROTO_UDP);
  if (err == ARES_CONN_ERR_AFNOSUPPORT) {
    return 0;
  } else if (err != ARES_CONN_ERR_SUCCESS) {
    return -1;
  }

  err = ares_socket_connect(channel, sock, ARES_FALSE, addr, len);
  if (err != ARES_CONN_ERR_SUCCESS && err != ARES_CONN_ERR_WOULDBLOCK) {
    ares_socket_close(channel, sock);
    return 0;
  }

  if (channel->sock_funcs.agetsockname == NULL ||
      channel->sock_funcs.agetsockname(sock, src_addr, &len,
                                       channel->sock_func_cb_data) != 0) {
    ares_socket_close(channel, sock);
    return -1;
  }
  ares_socket_close(channel, sock);
  return 1;
}

/*
 * Sort the linked list starting at sentinel->ai_next in RFC6724 order.
 * Will leave the list unchanged if an error occurs.
 */
ares_status_t ares_sortaddrinfo(ares_channel_t            *channel,
                                struct ares_addrinfo_node *list_sentinel)
{
  struct ares_addrinfo_node *cur;
  size_t                     nelem = 0;
  size_t                     i;
  int                        has_src_addr;
  struct addrinfo_sort_elem *elems;

  cur = list_sentinel->ai_next;
  while (cur) {
    ++nelem;
    cur = cur->ai_next;
  }

  if (!nelem) {
    return ARES_ENODATA;
  }

  elems = (struct addrinfo_sort_elem *)ares_malloc(
    nelem * sizeof(struct addrinfo_sort_elem));
  if (!elems) {
    return ARES_ENOMEM;
  }

  /*
   * Convert the linked list to an array that also contains the candidate
   * source address for each destination address.
   */
  for (i = 0, cur = list_sentinel->ai_next; i < nelem;
       ++i, cur   = cur->ai_next) {
    assert(cur != NULL);
    elems[i].ai             = cur;
    elems[i].original_order = i;
    has_src_addr = find_src_addr(channel, cur->ai_addr, &elems[i].src_addr.sa);
    if (has_src_addr == -1) {
      ares_free(elems);
      return ARES_ENOTFOUND;
    }
    elems[i].has_src_addr = (has_src_addr == 1) ? ARES_TRUE : ARES_FALSE;
  }

  /* Sort the addresses, and rearrange the linked list so it matches the sorted
   * order. */
  qsort((void *)elems, nelem, sizeof(struct addrinfo_sort_elem),
        rfc6724_compare);

  list_sentinel->ai_next = elems[0].ai;
  for (i = 0; i < nelem - 1; ++i) {
    elems[i].ai->ai_next = elems[i + 1].ai;
  }
  elems[nelem - 1].ai->ai_next = NULL;

  ares_free(elems);
  return ARES_SUCCESS;
}
                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/ares_strerror.c                                                      0000664 0000000 0000000 00000006375 14746647661 0021215 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

const char *ares_strerror(int code)
{
  ares_status_t status = (ares_status_t)code;
  switch (status) {
    case ARES_SUCCESS:
      return "Successful completion";
    case ARES_ENODATA:
      return "DNS server returned answer with no data";
    case ARES_EFORMERR:
      return "DNS server claims query was misformatted";
    case ARES_ESERVFAIL:
      return "DNS server returned general failure";
    case ARES_ENOTFOUND:
      return "Domain name not found";
    case ARES_ENOTIMP:
      return "DNS server does not implement requested operation";
    case ARES_EREFUSED:
      return "DNS server refused query";
    case ARES_EBADQUERY:
      return "Misformatted DNS query";
    case ARES_EBADNAME:
      return "Misformatted domain name";
    case ARES_EBADFAMILY:
      return "Unsupported address family";
    case ARES_EBADRESP:
      return "Misformatted DNS reply";
    case ARES_ECONNREFUSED:
      return "Could not contact DNS servers";
    case ARES_ETIMEOUT:
      return "Timeout while contacting DNS servers";
    case ARES_EOF:
      return "End of file";
    case ARES_EFILE:
      return "Error reading file";
    case ARES_ENOMEM:
      return "Out of memory";
    case ARES_EDESTRUCTION:
      return "Channel is being destroyed";
    case ARES_EBADSTR:
      return "Misformatted string";
    case ARES_EBADFLAGS:
      return "Illegal flags specified";
    case ARES_ENONAME:
      return "Given hostname is not numeric";
    case ARES_EBADHINTS:
      return "Illegal hints flags specified";
    case ARES_ENOTINITIALIZED:
      return "c-ares library initialization not yet performed";
    case ARES_ELOADIPHLPAPI:
      return "Error loading iphlpapi.dll";
    case ARES_EADDRGETNETWORKPARAMS:
      return "Could not find GetNetworkParams function";
    case ARES_ECANCELLED:
      return "DNS query cancelled";
    case ARES_ESERVICE:
      return "Invalid service name or number";
    case ARES_ENOSERVER:
      return "No DNS servers were configured";
  }

  return "unknown";
}
                                                                                                                                                                                                                                                                   node-23.7.0/deps/cares/src/lib/ares_sysconfig.c                                                     0000664 0000000 0000000 00000043324 14746647661 0021332 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) 2007 Daniel Stenberg
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_SYS_PARAM_H
#  include <sys/param.h>
#endif

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif

#ifdef HAVE_NETDB_H
#  include <netdb.h>
#endif

#ifdef HAVE_ARPA_INET_H
#  include <arpa/inet.h>
#endif

#if defined(ANDROID) || defined(__ANDROID__)
#  include <sys/system_properties.h>
#  include "ares_android.h"
/* From the Bionic sources */
#  define DNS_PROP_NAME_PREFIX "net.dns"
#  define MAX_DNS_PROPERTIES   8
#endif

#if defined(CARES_USE_LIBRESOLV)
#  include <resolv.h>
#endif

#include "ares_inet_net_pton.h"


#if defined(__MVS__)
static ares_status_t ares_init_sysconfig_mvs(const ares_channel_t *channel,
                                             ares_sysconfig_t     *sysconfig)
{
  struct __res_state *res = 0;
  size_t              count4;
  size_t              count6;
  int                 i;
  __STATEEXTIPV6     *v6;
  arse__llist_t      *sconfig = NULL;
  ares_status_t       status;

  if (0 == res) {
    int rc = res_init();
    while (rc == -1 && h_errno == TRY_AGAIN) {
      rc = res_init();
    }
    if (rc == -1) {
      return ARES_ENOMEM;
    }
    res = __res();
  }

  v6 = res->__res_extIPv6;
  if (res->nscount > 0) {
    count4 = (size_t)res->nscount;
  }

  if (v6 && v6->__stat_nscount > 0) {
    count6 = (size_t)v6->__stat_nscount;
  } else {
    count6 = 0;
  }

  for (i = 0; i < count4; i++) {
    struct sockaddr_in *addr_in = &(res->nsaddr_list[i]);
    struct ares_addr    addr;

    addr.addr.addr4.s_addr = addr_in->sin_addr.s_addr;
    addr.family            = AF_INET;

    status = ares_sconfig_append(channel, &sysconfig->sconfig, &addr,
                                 htons(addr_in->sin_port),
                                 htons(addr_in->sin_port), NULL);

    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  for (i = 0; i < count6; i++) {
    struct sockaddr_in6 *addr_in = &(v6->__stat_nsaddr_list[i]);
    struct ares_addr     addr;

    addr.family = AF_INET6;
    memcpy(&(addr.addr.addr6), &(addr_in->sin6_addr),
           sizeof(addr_in->sin6_addr));

    status = ares_sconfig_append(channel, &sysconfig->sconfig, &addr,
                                 htons(addr_in->sin_port),
                                 htons(addr_in->sin_port), NULL);

    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  return ARES_SUCCESS;
}
#endif

#if defined(__riscos__)
static ares_status_t ares_init_sysconfig_riscos(const ares_channel_t *channel,
                                                ares_sysconfig_t     *sysconfig)
{
  char         *line;
  ares_status_t status = ARES_SUCCESS;

  /* Under RISC OS, name servers are listed in the
     system variable Inet$Resolvers, space separated. */
  line = getenv("Inet$Resolvers");
  if (line) {
    char *resolvers = ares_strdup(line);
    char *pos;
    char *space;

    if (!resolvers) {
      return ARES_ENOMEM;
    }

    pos = resolvers;
    do {
      space = strchr(pos, ' ');
      if (space) {
        *space = '\0';
      }
      status = ares_sconfig_append_fromstr(channel, &sysconfig->sconfig, pos,
                                           ARES_TRUE);
      if (status != ARES_SUCCESS) {
        break;
      }
      pos = space + 1;
    } while (space);

    ares_free(resolvers);
  }

  return status;
}
#endif

#if defined(WATT32)
static ares_status_t ares_init_sysconfig_watt32(const ares_channel_t *channel,
                                                ares_sysconfig_t     *sysconfig)
{
  size_t        i;
  ares_status_t status;

  sock_init();

  for (i = 0; def_nameservers[i]; i++) {
    struct ares_addr addr;

    addr.family            = AF_INET;
    addr.addr.addr4.s_addr = htonl(def_nameservers[i]);

    status =
      ares_sconfig_append(channel, &sysconfig->sconfig, &addr, 0, 0, NULL);

    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  return ARES_SUCCESS;
}
#endif

#if defined(ANDROID) || defined(__ANDROID__)
static ares_status_t ares_init_sysconfig_android(const ares_channel_t *channel,
                                                 ares_sysconfig_t *sysconfig)
{
  size_t        i;
  char        **dns_servers;
  char         *domains;
  size_t        num_servers;
  ares_status_t status = ARES_EFILE;

  /* Use the Android connectivity manager to get a list
   * of DNS servers. As of Android 8 (Oreo) net.dns#
   * system properties are no longer available. Google claims this
   * improves privacy. Apps now need the ACCESS_NETWORK_STATE
   * permission and must use the ConnectivityManager which
   * is Java only. */
  dns_servers = ares_get_android_server_list(MAX_DNS_PROPERTIES, &num_servers);
  if (dns_servers != NULL) {
    for (i = 0; i < num_servers; i++) {
      status = ares_sconfig_append_fromstr(channel, &sysconfig->sconfig,
                                           dns_servers[i], ARES_TRUE);
      if (status != ARES_SUCCESS) {
        return status;
      }
    }
    for (i = 0; i < num_servers; i++) {
      ares_free(dns_servers[i]);
    }
    ares_free(dns_servers);
  }

  domains            = ares_get_android_search_domains_list();
  sysconfig->domains = ares_strsplit(domains, ", ", &sysconfig->ndomains);
  ares_free(domains);

#  ifdef HAVE___SYSTEM_PROPERTY_GET
  /* Old way using the system property still in place as
   * a fallback. Older android versions can still use this.
   * it's possible for older apps not not have added the new
   * permission and we want to try to avoid breaking those.
   *
   * We'll only run this if we don't have any dns servers
   * because this will get the same ones (if it works). */
  if (sysconfig->sconfig == NULL) {
    char propname[PROP_NAME_MAX];
    char propvalue[PROP_VALUE_MAX] = "";
    for (i = 1; i <= MAX_DNS_PROPERTIES; i++) {
      snprintf(propname, sizeof(propname), "%s%zu", DNS_PROP_NAME_PREFIX, i);
      if (__system_property_get(propname, propvalue) < 1) {
        break;
      }
      status = ares_sconfig_append_fromstr(channel, &sysconfig->sconfig,
                                           propvalue, ARES_TRUE);
      if (status != ARES_SUCCESS) {
        return status;
      }
    }
  }
#  endif /* HAVE___SYSTEM_PROPERTY_GET */

  return status;
}
#endif

#if defined(__QNX__)
static ares_status_t
  ares_init_sysconfig_qnx(const ares_channel_t *channel,
                          ares_sysconfig_t     *sysconfig)
{
  /* QNX:
   *   1. use confstr(_CS_RESOLVE, ...) as primary resolv.conf data, replacing
   *      "_" with " ".  If that is empty, then do normal /etc/resolv.conf
   *      processing.
   *   2. We want to process /etc/nsswitch.conf as normal.
   *   3. if confstr(_CS_DOMAIN, ...) this is the domain name.  Use this as
   *      preference over anything else found.
   */
  ares_buf_t    *buf                = ares_buf_create();
  unsigned char *data               = NULL;
  size_t         data_size          = 0;
  ares_bool_t    process_resolvconf = ARES_TRUE;
  ares_status_t  status             = ARES_SUCCESS;

  /* Prefer confstr(_CS_RESOLVE, ...) */
  buf = ares_buf_create();
  if (buf == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  data_size = 1024;
  data      = ares_buf_append_start(buf, &data_size);
  if (data == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  data_size = confstr(_CS_RESOLVE, (char *)data, data_size);
  if (data_size > 1) {
    /* confstr returns byte for NULL terminator, strip */
    data_size--;

    ares_buf_append_finish(buf, data_size);
    /* Its odd, this uses _ instead of " " between keywords, otherwise the
     * format is the same as resolv.conf, replace. */
    ares_buf_replace(buf, (const unsigned char *)"_", 1,
                     (const unsigned char *)" ", 1);

    status = ares_sysconfig_process_buf(channel, sysconfig, buf,
                                        ares_sysconfig_parse_resolv_line);
    if (status != ARES_SUCCESS) {
      /* ENOMEM is really the only error we'll get here */
      goto done;
    }

    /* don't read resolv.conf if we processed *any* nameservers */
    if (ares_llist_len(sysconfig->sconfig) != 0) {
      process_resolvconf = ARES_FALSE;
    }
  }

  /* Process files */
  status = ares_init_sysconfig_files(channel, sysconfig, process_resolvconf);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  /* Read confstr(_CS_DOMAIN, ...), but if we had a search path specified with
   * more than one domain, lets prefer that instead.  Its not exactly clear
   * the best way to handle this. */
  if (sysconfig->ndomains <= 1) {
    char   domain[256];
    size_t domain_len;

    domain_len = confstr(_CS_DOMAIN, domain, sizeof(domain_len));
    if (domain_len != 0) {
      ares_strsplit_free(sysconfig->domains, sysconfig->ndomains);
      sysconfig->domains = ares_strsplit(domain, ", ", &sysconfig->ndomains);
      if (sysconfig->domains == NULL) {
        status = ARES_ENOMEM;
        goto done;
      }
    }
  }

done:
  ares_buf_destroy(buf);

  return status;
}
#endif

#if defined(CARES_USE_LIBRESOLV)
static ares_status_t
  ares_init_sysconfig_libresolv(const ares_channel_t *channel,
                                ares_sysconfig_t     *sysconfig)
{
  struct __res_state       res;
  ares_status_t            status = ARES_SUCCESS;
  union res_sockaddr_union addr[MAXNS];
  int                      nscount;
  size_t                   i;
  size_t                   entries = 0;
  ares_buf_t              *ipbuf   = NULL;

  memset(&res, 0, sizeof(res));

  if (res_ninit(&res) != 0 || !(res.options & RES_INIT)) {
    return ARES_EFILE;
  }

  nscount = res_getservers(&res, addr, MAXNS);

  for (i = 0; i < (size_t)nscount; ++i) {
    char           ipaddr[INET6_ADDRSTRLEN] = "";
    char          *ipstr                    = NULL;
    unsigned short port                     = 0;
    unsigned int   ll_scope                 = 0;

    sa_family_t    family = addr[i].sin.sin_family;
    if (family == AF_INET) {
      ares_inet_ntop(family, &addr[i].sin.sin_addr, ipaddr, sizeof(ipaddr));
      port = ntohs(addr[i].sin.sin_port);
    } else if (family == AF_INET6) {
      ares_inet_ntop(family, &addr[i].sin6.sin6_addr, ipaddr, sizeof(ipaddr));
      port     = ntohs(addr[i].sin6.sin6_port);
      ll_scope = addr[i].sin6.sin6_scope_id;
    } else {
      continue;
    }


    /* [ip]:port%iface */
    ipbuf = ares_buf_create();
    if (ipbuf == NULL) {
      status = ARES_ENOMEM;
      goto done;
    }

    status = ares_buf_append_str(ipbuf, "[");
    if (status != ARES_SUCCESS) {
      goto done;
    }

    status = ares_buf_append_str(ipbuf, ipaddr);
    if (status != ARES_SUCCESS) {
      goto done;
    }

    status = ares_buf_append_str(ipbuf, "]");
    if (status != ARES_SUCCESS) {
      goto done;
    }

    if (port) {
      status = ares_buf_append_str(ipbuf, ":");
      if (status != ARES_SUCCESS) {
        goto done;
      }
      status = ares_buf_append_num_dec(ipbuf, port, 0);
      if (status != ARES_SUCCESS) {
        goto done;
      }
    }

    if (ll_scope) {
      status = ares_buf_append_str(ipbuf, "%");
      if (status != ARES_SUCCESS) {
        goto done;
      }
      status = ares_buf_append_num_dec(ipbuf, ll_scope, 0);
      if (status != ARES_SUCCESS) {
        goto done;
      }
    }

    ipstr = ares_buf_finish_str(ipbuf, NULL);
    ipbuf = NULL;
    if (ipstr == NULL) {
      status = ARES_ENOMEM;
      goto done;
    }

    status = ares_sconfig_append_fromstr(channel, &sysconfig->sconfig, ipstr,
                                         ARES_TRUE);

    ares_free(ipstr);
    if (status != ARES_SUCCESS) {
      goto done;
    }
  }

  while ((entries < MAXDNSRCH) && res.dnsrch[entries]) {
    entries++;
  }

  if (entries) {
    sysconfig->domains = ares_malloc_zero(entries * sizeof(char *));
    if (sysconfig->domains == NULL) {
      status = ARES_ENOMEM;
      goto done;
    } else {
      sysconfig->ndomains = entries;
      for (i = 0; i < sysconfig->ndomains; i++) {
        sysconfig->domains[i] = ares_strdup(res.dnsrch[i]);
        if (sysconfig->domains[i] == NULL) {
          status = ARES_ENOMEM;
          goto done;
        }
      }
    }
  }

  if (res.ndots >= 0) {
    sysconfig->ndots = (size_t)res.ndots;
  }
/* Apple does not allow configuration of retry, so this is a static dummy
 * value, ignore */
#  ifndef __APPLE__
  if (res.retry > 0) {
    sysconfig->tries = (size_t)res.retry;
  }
#  endif
  if (res.options & RES_ROTATE) {
    sysconfig->rotate = ARES_TRUE;
  }

  if (res.retrans > 0) {
/* Apple does not allow configuration of retrans, so this is a dummy value
 * that is extremely high (5s) */
#  ifndef __APPLE__
    if (res.retrans > 0) {
      sysconfig->timeout_ms = (unsigned int)res.retrans * 1000;
    }
#  endif
  }

done:
  ares_buf_destroy(ipbuf);
  res_ndestroy(&res);
  return status;
}
#endif

static void ares_sysconfig_free(ares_sysconfig_t *sysconfig)
{
  ares_llist_destroy(sysconfig->sconfig);
  ares_strsplit_free(sysconfig->domains, sysconfig->ndomains);
  ares_free(sysconfig->sortlist);
  ares_free(sysconfig->lookups);
  memset(sysconfig, 0, sizeof(*sysconfig));
}

static ares_status_t ares_sysconfig_apply(ares_channel_t         *channel,
                                          const ares_sysconfig_t *sysconfig)
{
  ares_status_t status;

  if (sysconfig->sconfig && !(channel->optmask & ARES_OPT_SERVERS)) {
    status = ares_servers_update(channel, sysconfig->sconfig, ARES_FALSE);
    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  if (sysconfig->domains && !(channel->optmask & ARES_OPT_DOMAINS)) {
    /* Make sure we duplicate first then replace so even if there is
     * ARES_ENOMEM, the channel stays in a good state */
    char **temp =
      ares_strsplit_duplicate(sysconfig->domains, sysconfig->ndomains);
    if (temp == NULL) {
      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    ares_strsplit_free(channel->domains, channel->ndomains);
    channel->domains  = temp;
    channel->ndomains = sysconfig->ndomains;
  }

  if (sysconfig->lookups && !(channel->optmask & ARES_OPT_LOOKUPS)) {
    char *temp = ares_strdup(sysconfig->lookups);
    if (temp == NULL) {
      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    ares_free(channel->lookups);
    channel->lookups = temp;
  }

  if (sysconfig->sortlist && !(channel->optmask & ARES_OPT_SORTLIST)) {
    struct apattern *temp =
      ares_malloc(sizeof(*channel->sortlist) * sysconfig->nsortlist);
    if (temp == NULL) {
      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    }
    memcpy(temp, sysconfig->sortlist,
           sizeof(*channel->sortlist) * sysconfig->nsortlist);

    ares_free(channel->sortlist);
    channel->sortlist = temp;
    channel->nsort    = sysconfig->nsortlist;
  }

  if (!(channel->optmask & ARES_OPT_NDOTS)) {
    channel->ndots = sysconfig->ndots;
  }

  if (sysconfig->tries && !(channel->optmask & ARES_OPT_TRIES)) {
    channel->tries = sysconfig->tries;
  }

  if (sysconfig->timeout_ms && !(channel->optmask & ARES_OPT_TIMEOUTMS)) {
    channel->timeout = sysconfig->timeout_ms;
  }

  if (!(channel->optmask & (ARES_OPT_ROTATE | ARES_OPT_NOROTATE))) {
    channel->rotate = sysconfig->rotate;
  }

  if (sysconfig->usevc) {
    channel->flags |= ARES_FLAG_USEVC;
  }

  return ARES_SUCCESS;
}

ares_status_t ares_init_by_sysconfig(ares_channel_t *channel)
{
  ares_status_t    status;
  ares_sysconfig_t sysconfig;

  memset(&sysconfig, 0, sizeof(sysconfig));
  sysconfig.ndots = 1; /* Default value if not otherwise set */

#if defined(USE_WINSOCK)
  status = ares_init_sysconfig_windows(channel, &sysconfig);
#elif defined(__MVS__)
  status = ares_init_sysconfig_mvs(channel, &sysconfig);
#elif defined(__riscos__)
  status = ares_init_sysconfig_riscos(channel, &sysconfig);
#elif defined(WATT32)
  status = ares_init_sysconfig_watt32(channel, &sysconfig);
#elif defined(ANDROID) || defined(__ANDROID__)
  status = ares_init_sysconfig_android(channel, &sysconfig);
#elif defined(__APPLE__)
  status = ares_init_sysconfig_macos(channel, &sysconfig);
#elif defined(CARES_USE_LIBRESOLV)
  status = ares_init_sysconfig_libresolv(channel, &sysconfig);
#elif defined(__QNX__)
  status = ares_init_sysconfig_qnx(channel, &sysconfig);
#else
  status = ares_init_sysconfig_files(channel, &sysconfig, ARES_TRUE);
#endif

  if (status != ARES_SUCCESS) {
    goto done;
  }

  /* Environment is supposed to override sysconfig */
  status = ares_init_by_environment(&sysconfig);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  /* Lock when applying the configuration to the channel.  Don't need to
   * lock prior to this. */

  ares_channel_lock(channel);

  status = ares_sysconfig_apply(channel, &sysconfig);
  ares_channel_unlock(channel);

  if (status != ARES_SUCCESS) {
    goto done;
  }

done:
  ares_sysconfig_free(&sysconfig);

  return status;
}
                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/cares/src/lib/ares_sysconfig_files.c                                               0000664 0000000 0000000 00000057334 14746647661 0022522 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) 2007 Daniel Stenberg
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_SYS_PARAM_H
#  include <sys/param.h>
#endif

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif

#ifdef HAVE_NETDB_H
#  include <netdb.h>
#endif

#ifdef HAVE_ARPA_INET_H
#  include <arpa/inet.h>
#endif

#if defined(ANDROID) || defined(__ANDROID__)
#  include <sys/system_properties.h>
#  include "ares_android.h"
/* From the Bionic sources */
#  define DNS_PROP_NAME_PREFIX "net.dns"
#  define MAX_DNS_PROPERTIES   8
#endif

#if defined(CARES_USE_LIBRESOLV)
#  include <resolv.h>
#endif

#if defined(USE_WINSOCK) && defined(HAVE_IPHLPAPI_H)
#  include <iphlpapi.h>
#endif

#include "ares_inet_net_pton.h"

static unsigned char ip_natural_mask(const struct ares_addr *addr)
{
  const unsigned char *ptr = NULL;
  /* This is an odd one.  If a raw ipv4 address is specified, then we take
   * what is called a natural mask, which means we look at the first octet
   * of the ip address and for values 0-127 we assume it is a class A (/8),
   * for values 128-191 we assume it is a class B (/16), and for 192-223
   * we assume it is a class C (/24).  223-239 is Class D which and 240-255 is
   * Class E, however, there is no pre-defined mask for this, so we'll use
   * /24 as well as that's what the old code did.
   *
   * For IPv6, we'll use /64.
   */

  if (addr->family == AF_INET6) {
    return 64;
  }

  ptr = (const unsigned char *)&addr->addr.addr4;
  if (*ptr < 128) {
    return 8;
  }

  if (*ptr < 192) {
    return 16;
  }

  return 24;
}

static ares_bool_t sortlist_append(struct apattern **sortlist, size_t *nsort,
                                   const struct apattern *pat)
{
  struct apattern *newsort;

  newsort = ares_realloc(*sortlist, (*nsort + 1) * sizeof(*newsort));
  if (newsort == NULL) {
    return ARES_FALSE; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  *sortlist = newsort;

  memcpy(&(*sortlist)[*nsort], pat, sizeof(**sortlist));
  (*nsort)++;

  return ARES_TRUE;
}

static ares_status_t parse_sort(ares_buf_t *buf, struct apattern *pat)
{
  ares_status_t       status;
  const unsigned char ip_charset[]             = "ABCDEFabcdef0123456789.:";
  char                ipaddr[INET6_ADDRSTRLEN] = "";
  size_t              addrlen;

  memset(pat, 0, sizeof(*pat));

  /* Consume any leading whitespace */
  ares_buf_consume_whitespace(buf, ARES_TRUE);

  /* If no length, just ignore, return ENOTFOUND as an indicator */
  if (ares_buf_len(buf) == 0) {
    return ARES_ENOTFOUND;
  }

  ares_buf_tag(buf);

  /* Consume ip address */
  if (ares_buf_consume_charset(buf, ip_charset, sizeof(ip_charset) - 1) == 0) {
    return ARES_EBADSTR;
  }

  /* Fetch ip address */
  status = ares_buf_tag_fetch_string(buf, ipaddr, sizeof(ipaddr));
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Parse it to make sure its valid */
  pat->addr.family = AF_UNSPEC;
  if (ares_dns_pton(ipaddr, &pat->addr, &addrlen) == NULL) {
    return ARES_EBADSTR;
  }

  /* See if there is a subnet mask */
  if (ares_buf_begins_with(buf, (const unsigned char *)"/", 1)) {
    char                maskstr[16];
    const unsigned char ipv4_charset[] = "0123456789.";


    /* Consume / */
    ares_buf_consume(buf, 1);

    ares_buf_tag(buf);

    /* Consume mask */
    if (ares_buf_consume_charset(buf, ipv4_charset, sizeof(ipv4_charset) - 1) ==
        0) {
      return ARES_EBADSTR;
    }

    /* Fetch mask */
    status = ares_buf_tag_fetch_string(buf, maskstr, sizeof(maskstr));
    if (status != ARES_SUCCESS) {
      return status;
    }

    if (ares_str_isnum(maskstr)) {
      /* Numeric mask */
      int mask = atoi(maskstr);
      if (mask < 0 || mask > 128) {
        return ARES_EBADSTR;
      }
      if (pat->addr.family == AF_INET && mask > 32) {
        return ARES_EBADSTR;
      }
      pat->mask = (unsigned char)mask;
    } else {
      /* Ipv4 subnet style mask */
      struct ares_addr     maskaddr;
      const unsigned char *ptr;

      memset(&maskaddr, 0, sizeof(maskaddr));
      maskaddr.family = AF_INET;
      if (ares_dns_pton(maskstr, &maskaddr, &addrlen) == NULL) {
        return ARES_EBADSTR;
      }
      ptr       = (const unsigned char *)&maskaddr.addr.addr4;
      pat->mask = (unsigned char)(ares_count_bits_u8(ptr[0]) +
                                  ares_count_bits_u8(ptr[1]) +
                                  ares_count_bits_u8(ptr[2]) +
                                  ares_count_bits_u8(ptr[3]));
    }
  } else {
    pat->mask = ip_natural_mask(&pat->addr);
  }

  /* Consume any trailing whitespace */
  ares_buf_consume_whitespace(buf, ARES_TRUE);

  /* If we have any trailing bytes other than whitespace, its a parse failure */
  if (ares_buf_len(buf) != 0) {
    return ARES_EBADSTR;
  }

  return ARES_SUCCESS;
}

ares_status_t ares_parse_sortlist(struct apattern **sortlist, size_t *nsort,
                                  const char *str)
{
  ares_buf_t   *buf    = NULL;
  ares_status_t status = ARES_SUCCESS;
  ares_array_t *arr    = NULL;
  size_t        num    = 0;
  size_t        i;

  if (sortlist == NULL || nsort == NULL || str == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  if (*sortlist != NULL) {
    ares_free(*sortlist);
  }

  *sortlist = NULL;
  *nsort    = 0;

  buf = ares_buf_create_const((const unsigned char *)str, ares_strlen(str));
  if (buf == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  /* Split on space or semicolon */
  status = ares_buf_split(buf, (const unsigned char *)" ;", 2,
                          ARES_BUF_SPLIT_NONE, 0, &arr);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  num = ares_array_len(arr);
  for (i = 0; i < num; i++) {
    ares_buf_t    **bufptr = ares_array_at(arr, i);
    ares_buf_t     *entry  = *bufptr;

    struct apattern pat;

    status = parse_sort(entry, &pat);
    if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {
      goto done;
    }

    if (status != ARES_SUCCESS) {
      continue;
    }

    if (!sortlist_append(sortlist, nsort, &pat)) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  status = ARES_SUCCESS;

done:
  ares_buf_destroy(buf);
  ares_array_destroy(arr);

  if (status != ARES_SUCCESS) {
    ares_free(*sortlist);
    *sortlist = NULL;
    *nsort    = 0;
  }

  return status;
}

static ares_status_t config_search(ares_sysconfig_t *sysconfig, const char *str,
                                   size_t max_domains)
{
  if (sysconfig->domains && sysconfig->ndomains > 0) {
    /* if we already have some domains present, free them first */
    ares_strsplit_free(sysconfig->domains, sysconfig->ndomains);
    sysconfig->domains  = NULL;
    sysconfig->ndomains = 0;
  }

  sysconfig->domains = ares_strsplit(str, ", ", &sysconfig->ndomains);
  if (sysconfig->domains == NULL) {
    return ARES_ENOMEM;
  }

  /* Truncate if necessary */
  if (max_domains && sysconfig->ndomains > max_domains) {
    size_t i;
    for (i = max_domains; i < sysconfig->ndomains; i++) {
      ares_free(sysconfig->domains[i]);
      sysconfig->domains[i] = NULL;
    }
    sysconfig->ndomains = max_domains;
  }

  return ARES_SUCCESS;
}

static ares_status_t buf_fetch_string(ares_buf_t *buf, char *str,
                                      size_t str_len)
{
  ares_status_t status;
  ares_buf_tag(buf);
  ares_buf_consume(buf, ares_buf_len(buf));

  status = ares_buf_tag_fetch_string(buf, str, str_len);
  return status;
}

static ares_status_t config_lookup(ares_sysconfig_t *sysconfig, ares_buf_t *buf,
                                   const char *separators)
{
  ares_status_t status;
  char          lookupstr[32];
  size_t        lookupstr_cnt = 0;
  char        **lookups       = NULL;
  size_t        num           = 0;
  size_t        i;
  size_t        separators_len = ares_strlen(separators);

  status =
    ares_buf_split_str(buf, (const unsigned char *)separators, separators_len,
                       ARES_BUF_SPLIT_TRIM, 0, &lookups, &num);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  for (i = 0; i < num; i++) {
    const char *value = lookups[i];
    char        ch;

    if (ares_strcaseeq(value, "dns") || ares_strcaseeq(value, "bind") ||
        ares_strcaseeq(value, "resolv") || ares_strcaseeq(value, "resolve")) {
      ch = 'b';
    } else if (ares_strcaseeq(value, "files") ||
               ares_strcaseeq(value, "file") ||
               ares_strcaseeq(value, "local")) {
      ch = 'f';
    } else {
      continue;
    }

    /* Look for a duplicate and ignore */
    if (memchr(lookupstr, ch, lookupstr_cnt) == NULL) {
      lookupstr[lookupstr_cnt++] = ch;
    }
  }

  if (lookupstr_cnt) {
    lookupstr[lookupstr_cnt] = 0;
    ares_free(sysconfig->lookups);
    sysconfig->lookups = ares_strdup(lookupstr);
    if (sysconfig->lookups == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  status = ARES_SUCCESS;

done:
  if (status != ARES_ENOMEM) {
    status = ARES_SUCCESS;
  }
  ares_free_array(lookups, num, ares_free);
  return status;
}

static ares_status_t process_option(ares_sysconfig_t *sysconfig,
                                    ares_buf_t       *option)
{
  char        **kv  = NULL;
  size_t        num = 0;
  const char   *key;
  const char   *val;
  unsigned int  valint = 0;
  ares_status_t status;

  /* Split on : */
  status = ares_buf_split_str(option, (const unsigned char *)":", 1,
                              ARES_BUF_SPLIT_TRIM, 2, &kv, &num);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  if (num < 1) {
    status = ARES_EBADSTR;
    goto done;
  }

  key = kv[0];
  if (num == 2) {
    val    = kv[1];
    valint = (unsigned int)strtoul(val, NULL, 10);
  }

  if (ares_streq(key, "ndots")) {
    sysconfig->ndots = valint;
  } else if (ares_streq(key, "retrans") || ares_streq(key, "timeout")) {
    if (valint == 0) {
      return ARES_EFORMERR;
    }
    sysconfig->timeout_ms = valint * 1000;
  } else if (ares_streq(key, "retry") || ares_streq(key, "attempts")) {
    if (valint == 0) {
      return ARES_EFORMERR;
    }
    sysconfig->tries = valint;
  } else if (ares_streq(key, "rotate")) {
    sysconfig->rotate = ARES_TRUE;
  } else if (ares_streq(key, "use-vc") || ares_streq(key, "usevc")) {
    sysconfig->usevc = ARES_TRUE;
  }

done:
  ares_free_array(kv, num, ares_free);
  return status;
}

ares_status_t ares_sysconfig_set_options(ares_sysconfig_t *sysconfig,
                                         const char       *str)
{
  ares_buf_t   *buf     = NULL;
  ares_array_t *options = NULL;
  size_t        num;
  size_t        i;
  ares_status_t status;

  buf = ares_buf_create_const((const unsigned char *)str, ares_strlen(str));
  if (buf == NULL) {
    return ARES_ENOMEM;
  }

  status = ares_buf_split(buf, (const unsigned char *)" \t", 2,
                          ARES_BUF_SPLIT_TRIM, 0, &options);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  num = ares_array_len(options);
  for (i = 0; i < num; i++) {
    ares_buf_t **bufptr = ares_array_at(options, i);
    ares_buf_t  *valbuf = *bufptr;

    status = process_option(sysconfig, valbuf);
    /* Out of memory is the only fatal condition */
    if (status == ARES_ENOMEM) {
      goto done; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  status = ARES_SUCCESS;

done:
  ares_array_destroy(options);
  ares_buf_destroy(buf);
  return status;
}

ares_status_t ares_init_by_environment(ares_sysconfig_t *sysconfig)
{
  const char   *localdomain;
  const char   *res_options;
  ares_status_t status;

  localdomain = getenv("LOCALDOMAIN");
  if (localdomain) {
    char *temp = ares_strdup(localdomain);
    if (temp == NULL) {
      return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    }
    status = config_search(sysconfig, temp, 1);
    ares_free(temp);
    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  res_options = getenv("RES_OPTIONS");
  if (res_options) {
    status = ares_sysconfig_set_options(sysconfig, res_options);
    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  return ARES_SUCCESS;
}

/* Configuration Files:
 *  /etc/resolv.conf
 *    - All Unix-like systems
 *    - Comments start with ; or #
 *    - Lines have a keyword followed by a value that is interpreted specific
 *      to the keyword:
 *    - Keywords:
 *      - nameserver - IP address of nameserver with optional port (using a :
 *        prefix). If using an ipv6 address and specifying a port, the ipv6
 *        address must be encapsulated in brackets. For link-local ipv6
 *        addresses, the interface can also be specified with a % prefix. e.g.:
 *          "nameserver [fe80::1]:1234%iface"
 *        This keyword may be specified multiple times.
 *      - search - whitespace separated list of domains
 *      - domain - obsolete, same as search except only a single domain
 *      - lookup / hostresorder - local, bind, file, files
 *      - sortlist - whitespace separated ip-address/netmask pairs
 *      - options - options controlling resolver variables
 *        - ndots:n - set ndots option
 *        - timeout:n (retrans:n) - timeout per query attempt in seconds
 *        - attempts:n (retry:n) - number of times resolver will send query
 *        - rotate - round-robin selection of name servers
 *        - use-vc / usevc - force tcp
 *  /etc/nsswitch.conf
 *    - Modern Linux, FreeBSD, HP-UX, Solaris
 *    - Search order set via:
 *      "hosts: files dns mdns4_minimal mdns4"
 *      - files is /etc/hosts
 *      - dns is dns
 *      - mdns4_minimal does mdns only if ending in .local
 *      - mdns4 does not limit to domains ending in .local
 *  /etc/netsvc.conf
 *    - AIX
 *    - Search order set via:
 *      "hosts = local , bind"
 *      - bind is dns
 *      - local is /etc/hosts
 *  /etc/svc.conf
 *    - Tru64
 *    - Same format as /etc/netsvc.conf
 *  /etc/host.conf
 *    - Early FreeBSD, Early Linux
 *    - Not worth supporting, format varied based on system, FreeBSD used
 *      just a line per search order, Linux used "order " and a comma
 *      delimited list of "bind" and "hosts"
 */


/* This function will only return ARES_SUCCESS or ARES_ENOMEM.  Any other
 * conditions are ignored.  Users may mess up config files, but we want to
 * process anything we can. */
ares_status_t ares_sysconfig_parse_resolv_line(const ares_channel_t *channel,
                                               ares_sysconfig_t     *sysconfig,
                                               ares_buf_t           *line)
{
  char          option[32];
  char          value[512];
  ares_status_t status = ARES_SUCCESS;

  /* Ignore lines beginning with a comment */
  if (ares_buf_begins_with(line, (const unsigned char *)"#", 1) ||
      ares_buf_begins_with(line, (const unsigned char *)";", 1)) {
    return ARES_SUCCESS;
  }

  ares_buf_tag(line);

  /* Shouldn't be possible, but if it happens, ignore the line. */
  if (ares_buf_consume_nonwhitespace(line) == 0) {
    return ARES_SUCCESS;
  }

  status = ares_buf_tag_fetch_string(line, option, sizeof(option));
  if (status != ARES_SUCCESS) {
    return ARES_SUCCESS;
  }

  ares_buf_consume_whitespace(line, ARES_TRUE);

  status = buf_fetch_string(line, value, sizeof(value));
  if (status != ARES_SUCCESS) {
    return ARES_SUCCESS;
  }

  ares_str_trim(value);
  if (*value == 0) {
    return ARES_SUCCESS;
  }

  /* At this point we have a string option and a string value, both trimmed
   * of leading and trailing whitespace.  Lets try to evaluate them */
  if (ares_streq(option, "domain")) {
    /* Domain is legacy, don't overwrite an existing config set by search */
    if (sysconfig->domains == NULL) {
      status = config_search(sysconfig, value, 1);
    }
  } else if (ares_streq(option, "lookup") ||
             ares_streq(option, "hostresorder")) {
    ares_buf_tag_rollback(line);
    status = config_lookup(sysconfig, line, " \t");
  } else if (ares_streq(option, "search")) {
    status = config_search(sysconfig, value, 0);
  } else if (ares_streq(option, "nameserver")) {
    status = ares_sconfig_append_fromstr(channel, &sysconfig->sconfig, value,
                                         ARES_TRUE);
  } else if (ares_streq(option, "sortlist")) {
    /* Ignore all failures except ENOMEM.  If the sysadmin set a bad
     * sortlist, just ignore the sortlist, don't cause an inoperable
     * channel */
    status =
      ares_parse_sortlist(&sysconfig->sortlist, &sysconfig->nsortlist, value);
    if (status != ARES_ENOMEM) {
      status = ARES_SUCCESS;
    }
  } else if (ares_streq(option, "options")) {
    status = ares_sysconfig_set_options(sysconfig, value);
  }

  return status;
}

/* This function will only return ARES_SUCCESS or ARES_ENOMEM.  Any other
 * conditions are ignored.  Users may mess up config files, but we want to
 * process anything we can. */
static ares_status_t parse_nsswitch_line(const ares_channel_t *channel,
                                         ares_sysconfig_t     *sysconfig,
                                         ares_buf_t           *line)
{
  char          option[32];
  ares_status_t status = ARES_SUCCESS;
  ares_array_t *sects  = NULL;
  ares_buf_t  **bufptr;
  ares_buf_t   *buf;

  (void)channel;

  /* Ignore lines beginning with a comment */
  if (ares_buf_begins_with(line, (const unsigned char *)"#", 1)) {
    return ARES_SUCCESS;
  }

  /* database : values (space delimited) */
  status = ares_buf_split(line, (const unsigned char *)":", 1,
                          ARES_BUF_SPLIT_TRIM, 2, &sects);

  if (status != ARES_SUCCESS || ares_array_len(sects) != 2) {
    goto done;
  }

  bufptr = ares_array_at(sects, 0);
  buf    = *bufptr;

  status = buf_fetch_string(buf, option, sizeof(option));
  if (status != ARES_SUCCESS) {
    goto done;
  }

  /* Only support "hosts:" */
  if (!ares_streq(option, "hosts")) {
    goto done;
  }

  /* Values are space separated */
  bufptr = ares_array_at(sects, 1);
  buf    = *bufptr;
  status = config_lookup(sysconfig, buf, " \t");

done:
  ares_array_destroy(sects);
  if (status != ARES_ENOMEM) {
    status = ARES_SUCCESS;
  }
  return status;
}

/* This function will only return ARES_SUCCESS or ARES_ENOMEM.  Any other
 * conditions are ignored.  Users may mess up config files, but we want to
 * process anything we can. */
static ares_status_t parse_svcconf_line(const ares_channel_t *channel,
                                        ares_sysconfig_t     *sysconfig,
                                        ares_buf_t           *line)
{
  char          option[32];
  ares_buf_t  **bufptr;
  ares_buf_t   *buf;
  ares_status_t status = ARES_SUCCESS;
  ares_array_t *sects  = NULL;

  (void)channel;

  /* Ignore lines beginning with a comment */
  if (ares_buf_begins_with(line, (const unsigned char *)"#", 1)) {
    return ARES_SUCCESS;
  }

  /* database = values (comma delimited)*/
  status = ares_buf_split(line, (const unsigned char *)"=", 1,
                          ARES_BUF_SPLIT_TRIM, 2, &sects);

  if (status != ARES_SUCCESS || ares_array_len(sects) != 2) {
    goto done;
  }

  bufptr = ares_array_at(sects, 0);
  buf    = *bufptr;
  status = buf_fetch_string(buf, option, sizeof(option));
  if (status != ARES_SUCCESS) {
    goto done;
  }

  /* Only support "hosts=" */
  if (!ares_streq(option, "hosts")) {
    goto done;
  }

  /* Values are comma separated */
  bufptr = ares_array_at(sects, 1);
  buf    = *bufptr;
  status = config_lookup(sysconfig, buf, ",");

done:
  ares_array_destroy(sects);
  if (status != ARES_ENOMEM) {
    status = ARES_SUCCESS;
  }
  return status;
}


ares_status_t ares_sysconfig_process_buf(const ares_channel_t    *channel,
                                         ares_sysconfig_t        *sysconfig,
                                         ares_buf_t              *buf,
                                         ares_sysconfig_line_cb_t cb)
{
  ares_array_t *lines  = NULL;
  size_t        num;
  size_t        i;
  ares_status_t status;

  status = ares_buf_split(buf, (const unsigned char *)"\n", 1,
                          ARES_BUF_SPLIT_TRIM, 0, &lines);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  num = ares_array_len(lines);
  for (i = 0; i < num; i++) {
    ares_buf_t **bufptr = ares_array_at(lines, i);
    ares_buf_t  *line   = *bufptr;

    status = cb(channel, sysconfig, line);
    if (status != ARES_SUCCESS) {
      goto done;
    }
  }

done:
  ares_array_destroy(lines);
  return status;
}

/* Should only return:
 *  ARES_ENOTFOUND - file not found
 *  ARES_EFILE     - error reading file (perms)
 *  ARES_ENOMEM    - out of memory
 *  ARES_SUCCESS   - file processed, doesn't necessarily mean it was a good
 *                   file, but we're not erroring out if we can't parse
 *                   something (or anything at all) */
static ares_status_t process_config_lines(const ares_channel_t    *channel,
                                          const char              *filename,
                                          ares_sysconfig_t        *sysconfig,
                                          ares_sysconfig_line_cb_t cb)
{
  ares_status_t status = ARES_SUCCESS;
  ares_buf_t   *buf    = NULL;

  buf = ares_buf_create();
  if (buf == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  status = ares_buf_load_file(filename, buf);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  status = ares_sysconfig_process_buf(channel, sysconfig, buf, cb);

done:
  ares_buf_destroy(buf);

  return status;
}

ares_status_t ares_init_sysconfig_files(const ares_channel_t *channel,
                                        ares_sysconfig_t     *sysconfig,
                                        ares_bool_t process_resolvconf)
{
  ares_status_t status = ARES_SUCCESS;

  /* Resolv.conf */
  if (process_resolvconf) {
    status = process_config_lines(channel,
                                  (channel->resolvconf_path != NULL)
                                    ? channel->resolvconf_path
                                    : PATH_RESOLV_CONF,
                                  sysconfig, ares_sysconfig_parse_resolv_line);
    if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {
      goto done;
    }
  }

  /* Nsswitch.conf */
  status = process_config_lines(channel, "/etc/nsswitch.conf", sysconfig,
                                parse_nsswitch_line);
  if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {
    goto done;
  }

  /* netsvc.conf */
  status = process_config_lines(channel, "/etc/netsvc.conf", sysconfig,
                                parse_svcconf_line);
  if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {
    goto done;
  }

  /* svc.conf */
  status = process_config_lines(channel, "/etc/svc.conf", sysconfig,
                                parse_svcconf_line);
  if (status != ARES_SUCCESS && status != ARES_ENOTFOUND) {
    goto done;
  }

  status = ARES_SUCCESS;

done:
  return status;
}
                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/cares/src/lib/ares_sysconfig_mac.c                                                 0000664 0000000 0000000 00000027325 14746647661 0022155 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#ifdef __APPLE__

/* The DNS configuration for apple is stored in the system configuration
 * database.  Apple does provide an emulated `/etc/resolv.conf` on MacOS (but
 * not iOS), it cannot, however, represent the entirety of the DNS
 * configuration.  Alternatively, libresolv could be used to also retrieve some
 * system configuration, but it too is not capable of retrieving the entirety
 * of the DNS configuration.
 *
 * Attempts to use the preferred public API of `SCDynamicStoreCreate()` and
 * friends yielded incomplete DNS information.  Instead, that leaves some apple
 * "internal" symbols from `configd` that we need to access in order to get the
 * entire configuration.  We can see that we're not the only ones to do this as
 * Google Chrome also does:
 * https://chromium.googlesource.com/chromium/src/+/HEAD/net/dns/dns_config_watcher_mac.cc
 * These internal functions are what `libresolv` and `scutil` use to retrieve
 * the dns configuration.  Since these symbols are not publicly available, we
 * will dynamically load the symbols from `libSystem` and import the `dnsinfo.h`
 * private header extracted from:
 * https://opensource.apple.com/source/configd/configd-1109.140.1/dnsinfo/dnsinfo.h
 */

/* The apple header uses anonymous unions which came with C11 */
#  if defined(__clang__)
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wc11-extensions"
#  endif

#  include "ares_private.h"
#  include <stdio.h>
#  include <stdlib.h>
#  include <string.h>
#  include <dlfcn.h>
#  include <arpa/inet.h>
#  include "thirdparty/apple/dnsinfo.h"
#  include <AvailabilityMacros.h>
#  if MAC_OS_X_VERSION_MIN_REQUIRED >= 1080 /* MacOS 10.8 */
#    include <SystemConfiguration/SCNetworkConfiguration.h>
#  endif

typedef struct {
  void *handle;
  dns_config_t *(*dns_configuration_copy)(void);
  void (*dns_configuration_free)(dns_config_t *config);
} dnsinfo_t;

static void dnsinfo_destroy(dnsinfo_t *dnsinfo)
{
  if (dnsinfo == NULL) {
    return;
  }

  if (dnsinfo->handle) {
    dlclose(dnsinfo->handle);
  }

  ares_free(dnsinfo);
}

static ares_status_t dnsinfo_init(dnsinfo_t **dnsinfo_out)
{
  dnsinfo_t    *dnsinfo = NULL;
  ares_status_t status  = ARES_SUCCESS;
  size_t        i;
  const char   *searchlibs[] = {
    "/usr/lib/libSystem.dylib",
    "/System/Library/Frameworks/SystemConfiguration.framework/"
      "SystemConfiguration",
    NULL
  };

  if (dnsinfo_out == NULL) {
    status = ARES_EFORMERR;
    goto done;
  }

  *dnsinfo_out = NULL;

  dnsinfo = ares_malloc_zero(sizeof(*dnsinfo));
  if (dnsinfo == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  for (i = 0; searchlibs[i] != NULL; i++) {
    dnsinfo->handle = dlopen(searchlibs[i], RTLD_LAZY /* | RTLD_NOLOAD */);
    if (dnsinfo->handle == NULL) {
      /* Fail, loop */
      continue;
    }

    dnsinfo->dns_configuration_copy = (dns_config_t * (*)(void))
      dlsym(dnsinfo->handle, "dns_configuration_copy");

    dnsinfo->dns_configuration_free = (void (*)(dns_config_t *))dlsym(
      dnsinfo->handle, "dns_configuration_free");

    if (dnsinfo->dns_configuration_copy != NULL &&
        dnsinfo->dns_configuration_free != NULL) {
      break;
    }

    /* Fail, loop */
    dlclose(dnsinfo->handle);
    dnsinfo->handle = NULL;
  }


  if (dnsinfo->dns_configuration_copy == NULL ||
      dnsinfo->dns_configuration_free == NULL) {
    status = ARES_ESERVFAIL;
    goto done;
  }


done:
  if (status == ARES_SUCCESS) {
    *dnsinfo_out = dnsinfo;
  } else {
    dnsinfo_destroy(dnsinfo);
  }

  return status;
}

static ares_bool_t search_is_duplicate(const ares_sysconfig_t *sysconfig,
                                       const char             *name)
{
  size_t i;
  for (i = 0; i < sysconfig->ndomains; i++) {
    if (ares_strcaseeq(sysconfig->domains[i], name)) {
      return ARES_TRUE;
    }
  }
  return ARES_FALSE;
}

static ares_status_t read_resolver(const ares_channel_t *channel,
                                   const dns_resolver_t *resolver,
                                   ares_sysconfig_t     *sysconfig)
{
  int            i;
  unsigned short port   = 0;
  ares_status_t  status = ARES_SUCCESS;

#  if MAC_OS_X_VERSION_MIN_REQUIRED >= 1080 /* MacOS 10.8 */
  /* XXX: resolver->domain is for domain-specific servers.  When we implement
   *      this support, we'll want to use this.  But for now, we're going to
   *      skip any servers which set this since we can't properly route.
   *      MacOS used to use this setting for a different purpose in the
   *      past however, so on versions of MacOS < 10.8 just ignore this
   *      completely. */
  if (resolver->domain != NULL) {
    return ARES_SUCCESS;
  }
#  endif

#  if MAC_OS_X_VERSION_MIN_REQUIRED >= 1080 /* MacOS 10.8 */
  /* Check to see if DNS server should be used, base this on if the server is
   * reachable or can be reachable automatically if we send traffic that
   * direction. */
  if (!(resolver->reach_flags &
        (kSCNetworkFlagsReachable |
         kSCNetworkReachabilityFlagsConnectionOnTraffic))) {
    return ARES_SUCCESS;
  }
#  endif

  /* NOTE: it doesn't look like resolver->flags is relevant */

  /* If there's no nameservers, nothing to do */
  if (resolver->n_nameserver <= 0) {
    return ARES_SUCCESS;
  }

  /* Default port */
  port = resolver->port;

  /* Append search list */
  if (resolver->n_search > 0) {
    char **new_domains = ares_realloc_zero(
      sysconfig->domains, sizeof(*sysconfig->domains) * sysconfig->ndomains,
      sizeof(*sysconfig->domains) *
        (sysconfig->ndomains + (size_t)resolver->n_search));
    if (new_domains == NULL) {
      return ARES_ENOMEM;
    }
    sysconfig->domains = new_domains;

    for (i = 0; i < resolver->n_search; i++) {
      const char *search;
      /* UBSAN: copy pointer using memcpy due to misalignment */
      memcpy(&search, resolver->search + i, sizeof(search));

      /* Skip duplicates */
      if (search_is_duplicate(sysconfig, search)) {
        continue;
      }
      sysconfig->domains[sysconfig->ndomains] = ares_strdup(search);
      if (sysconfig->domains[sysconfig->ndomains] == NULL) {
        return ARES_ENOMEM;
      }
      sysconfig->ndomains++;
    }
  }

  /* NOTE: we're going to skip importing the sort addresses for now.  Its
   *       likely not used, its not obvious how to even configure such a thing.
   */
#  if 0
  for (i=0; i<resolver->n_sortaddr; i++) {
    char val[256];
    inet_ntop(AF_INET, &resolver->sortaddr[i]->address, val, sizeof(val));
    printf("\t\t%s/", val);
    inet_ntop(AF_INET, &resolver->sortaddr[i]->mask, val, sizeof(val));
    printf("%s\n", val);
  }
#  endif

  if (resolver->options != NULL) {
    status = ares_sysconfig_set_options(sysconfig, resolver->options);
    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  /* NOTE:
   *   - resolver->timeout appears unused, always 0, so we ignore this
   *   - resolver->service_identifier doesn't appear relevant to us
   *   - resolver->cid also isn't relevant
   *   - resolver->if_name we won't use since it isn't available in MacOS 10.8
   *     or earlier, use resolver->if_index instead to then lookup the name.
   */

  /* XXX: resolver->search_order appears like it might be relevant, we might
   * need to sort the resulting list by this metric if we find in the future we
   * need to.  That said, due to the automatic re-sorting we do, I'm not sure it
   * matters.  Here's an article on this search order stuff:
   *      https://www.cnet.com/tech/computing/os-x-10-6-3-and-dns-server-priority-changes/
   */

  for (i = 0; i < resolver->n_nameserver; i++) {
    struct ares_addr       addr;
    unsigned short         addrport;
    const struct sockaddr *sockaddr;
    char                   if_name_str[256] = "";
    const char            *if_name          = NULL;

    /* UBSAN alignment workaround to fetch memory address */
    memcpy(&sockaddr, resolver->nameserver + i, sizeof(sockaddr));

    if (!ares_sockaddr_to_ares_addr(&addr, &addrport, sockaddr)) {
      continue;
    }

    if (addrport == 0) {
      addrport = port;
    }

    if (channel->sock_funcs.aif_indextoname != NULL) {
      if_name = channel->sock_funcs.aif_indextoname(
        resolver->if_index, if_name_str, sizeof(if_name_str),
        channel->sock_func_cb_data);
    }

    status = ares_sconfig_append(channel, &sysconfig->sconfig, &addr, addrport,
                                 addrport, if_name);
    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  return status;
}

static ares_status_t read_resolvers(const ares_channel_t *channel,
                                    dns_resolver_t **resolvers, int nresolvers,
                                    ares_sysconfig_t *sysconfig)
{
  ares_status_t status = ARES_SUCCESS;
  int           i;

  for (i = 0; status == ARES_SUCCESS && i < nresolvers; i++) {
    const dns_resolver_t *resolver_ptr;

    /* UBSAN doesn't like that this is unaligned, lets use memcpy to get the
     * address.  Equivalent to:
     *   resolver = resolvers[i]
     */
    memcpy(&resolver_ptr, resolvers + i, sizeof(resolver_ptr));

    status = read_resolver(channel, resolver_ptr, sysconfig);
  }

  return status;
}

ares_status_t ares_init_sysconfig_macos(const ares_channel_t *channel,
                                        ares_sysconfig_t     *sysconfig)
{
  dnsinfo_t    *dnsinfo = NULL;
  dns_config_t *sc_dns  = NULL;
  ares_status_t status  = ARES_SUCCESS;

  status = dnsinfo_init(&dnsinfo);

  if (status != ARES_SUCCESS) {
    goto done;
  }

  sc_dns = dnsinfo->dns_configuration_copy();
  if (sc_dns == NULL) {
    status = ARES_ESERVFAIL;
    goto done;
  }

  /* There are `resolver`, `scoped_resolver`, and `service_specific_resolver`
   * settings. The `scoped_resolver` settings appear to be already available via
   * the `resolver` settings and likely are only relevant to link-local dns
   * servers which we can already detect via the address itself, so we'll ignore
   * the `scoped_resolver` section.  It isn't clear what the
   * `service_specific_resolver` is used for, I haven't personally seen it
   * in use so we'll ignore this until at some point where we find we need it.
   * Likely this wasn't available via `/etc/resolv.conf` nor `libresolv` anyhow
   * so its not worse to prior configuration methods, worst case. */

  status =
    read_resolvers(channel, sc_dns->resolver, sc_dns->n_resolver, sysconfig);

done:
  if (dnsinfo) {
    dnsinfo->dns_configuration_free(sc_dns);
    dnsinfo_destroy(dnsinfo);
  }
  return status;
}

#  if defined(__clang__)
#    pragma GCC diagnostic pop
#  endif

#else

/* Prevent compiler warnings due to empty translation unit */
typedef int make_iso_compilers_happy;

#endif
                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/cares/src/lib/ares_sysconfig_win.c                                                 0000664 0000000 0000000 00000046411 14746647661 0022207 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) 2007 Daniel Stenberg
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_SYS_PARAM_H
#  include <sys/param.h>
#endif

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif

#ifdef HAVE_NETDB_H
#  include <netdb.h>
#endif

#ifdef HAVE_ARPA_INET_H
#  include <arpa/inet.h>
#endif

#if defined(USE_WINSOCK)
#  if defined(HAVE_IPHLPAPI_H)
#    include <iphlpapi.h>
#  endif
#  if defined(HAVE_NETIOAPI_H)
#    include <netioapi.h>
#  endif
#endif

#include "ares_inet_net_pton.h"

#if defined(USE_WINSOCK)
/*
 * get_REG_SZ()
 *
 * Given a 'hKey' handle to an open registry key and a 'leafKeyName' pointer
 * to the name of the registry leaf key to be queried, fetch it's string
 * value and return a pointer in *outptr to a newly allocated memory area
 * holding it as a null-terminated string.
 *
 * Returns 0 and nullifies *outptr upon inability to return a string value.
 *
 * Returns 1 and sets *outptr when returning a dynamically allocated string.
 *
 * Supported on Windows NT 3.5 and newer.
 */
static ares_bool_t get_REG_SZ(HKEY hKey, const char *leafKeyName, char **outptr)
{
  DWORD size = 0;
  int   res;

  *outptr = NULL;

  /* Find out size of string stored in registry */
  res = RegQueryValueExA(hKey, leafKeyName, 0, NULL, NULL, &size);
  if ((res != ERROR_SUCCESS && res != ERROR_MORE_DATA) || !size) {
    return ARES_FALSE;
  }

  /* Allocate buffer of indicated size plus one given that string
     might have been stored without null termination */
  *outptr = ares_malloc(size + 1);
  if (!*outptr) {
    return ARES_FALSE;
  }

  /* Get the value for real */
  res = RegQueryValueExA(hKey, leafKeyName, 0, NULL, (unsigned char *)*outptr,
                         &size);
  if ((res != ERROR_SUCCESS) || (size == 1)) {
    ares_free(*outptr);
    *outptr = NULL;
    return ARES_FALSE;
  }

  /* Null terminate buffer always */
  *(*outptr + size) = '\0';

  return ARES_TRUE;
}

static void commanjoin(char **dst, const char * const src, const size_t len)
{
  char  *newbuf;
  size_t newsize;

  /* 1 for terminating 0 and 2 for , and terminating 0 */
  newsize = len + (*dst ? (ares_strlen(*dst) + 2) : 1);
  newbuf  = ares_realloc(*dst, newsize);
  if (!newbuf) {
    return;
  }
  if (*dst == NULL) {
    *newbuf = '\0';
  }
  *dst = newbuf;
  if (ares_strlen(*dst) != 0) {
    strcat(*dst, ",");
  }
  strncat(*dst, src, len);
}

/*
 * commajoin()
 *
 * RTF code.
 */
static void commajoin(char **dst, const char *src)
{
  commanjoin(dst, src, ares_strlen(src));
}

/* A structure to hold the string form of IPv4 and IPv6 addresses so we can
 * sort them by a metric.
 */
typedef struct {
  /* The metric we sort them by. */
  ULONG  metric;

  /* Original index of the item, used as a secondary sort parameter to make
   * qsort() stable if the metrics are equal */
  size_t orig_idx;

  /* Room enough for the string form of any IPv4 or IPv6 address that
   * ares_inet_ntop() will create.  Based on the existing c-ares practice.
   */
  char   text[INET6_ADDRSTRLEN + 8 + 64]; /* [%s]:NNNNN%iface */
} Address;

/* Sort Address values \a left and \a right by metric, returning the usual
 * indicators for qsort().
 */
static int compareAddresses(const void *arg1, const void *arg2)
{
  const Address * const left  = arg1;
  const Address * const right = arg2;
  /* Lower metric the more preferred */
  if (left->metric < right->metric) {
    return -1;
  }
  if (left->metric > right->metric) {
    return 1;
  }
  /* If metrics are equal, lower original index more preferred */
  if (left->orig_idx < right->orig_idx) {
    return -1;
  }
  if (left->orig_idx > right->orig_idx) {
    return 1;
  }
  return 0;
}

/* There can be multiple routes to "the Internet".  And there can be different
 * DNS servers associated with each of the interfaces that offer those routes.
 * We have to assume that any DNS server can serve any request.  But, some DNS
 * servers may only respond if requested over their associated interface.  But
 * we also want to use "the preferred route to the Internet" whenever possible
 * (and not use DNS servers on a non-preferred route even by forcing request
 * to go out on the associated non-preferred interface).  i.e. We want to use
 * the DNS servers associated with the same interface that we would use to
 * make a general request to anything else.
 *
 * But, Windows won't sort the DNS servers by the metrics associated with the
 * routes and interfaces _even_ though it obviously sends IP packets based on
 * those same routes and metrics.  So, we must do it ourselves.
 *
 * So, we sort the DNS servers by the same metric values used to determine how
 * an outgoing IP packet will go, thus effectively using the DNS servers
 * associated with the interface that the DNS requests themselves will
 * travel.  This gives us optimal routing and avoids issues where DNS servers
 * won't respond to requests that don't arrive via some specific subnetwork
 * (and thus some specific interface).
 *
 * This function computes the metric we use to sort.  On the interface
 * identified by \a luid, it determines the best route to \a dest and combines
 * that route's metric with \a interfaceMetric to compute a metric for the
 * destination address on that interface.  This metric can be used as a weight
 * to sort the DNS server addresses associated with each interface (lower is
 * better).
 *
 * Note that by restricting the route search to the specific interface with
 * which the DNS servers are associated, this function asks the question "What
 * is the metric for sending IP packets to this DNS server?" which allows us
 * to sort the DNS servers correctly.
 */
static ULONG getBestRouteMetric(IF_LUID * const luid, /* Can't be const :( */
                                const SOCKADDR_INET * const dest,
                                const ULONG                 interfaceMetric)
{
  /* On this interface, get the best route to that destination. */
#  if defined(__WATCOMC__)
  /* OpenWatcom's builtin Windows SDK does not have a definition for
   * MIB_IPFORWARD_ROW2, and also does not allow the usage of SOCKADDR_INET
   * as a variable. Let's work around this by returning the worst possible
   * metric, but only when using the OpenWatcom compiler.
   * It may be worth investigating using a different version of the Windows
   * SDK with OpenWatcom in the future, though this may be fixed in OpenWatcom
   * 2.0.
   */
  return (ULONG)-1;
#  else
  MIB_IPFORWARD_ROW2 row;
  SOCKADDR_INET      ignored;
  if (GetBestRoute2(/* The interface to use.  The index is ignored since we are
                     * passing a LUID.
                     */
                    luid, 0,
                    /* No specific source address. */
                    NULL,
                    /* Our destination address. */
                    dest,
                    /* No options. */
                    0,
                    /* The route row. */
                    &row,
                    /* The best source address, which we don't need. */
                    &ignored) != NO_ERROR
      /* If the metric is "unused" (-1) or too large for us to add the two
       * metrics, use the worst possible, thus sorting this last.
       */
      || row.Metric == (ULONG)-1 ||
      row.Metric > ((ULONG)-1) - interfaceMetric) {
    /* Return the worst possible metric. */
    return (ULONG)-1;
  }

  /* Return the metric value from that row, plus the interface metric.
   *
   * See
   * http://msdn.microsoft.com/en-us/library/windows/desktop/aa814494(v=vs.85).aspx
   * which describes the combination as a "sum".
   */
  return row.Metric + interfaceMetric;
#  endif /* __WATCOMC__ */
}

/*
 * get_DNS_Windows()
 *
 * Locates DNS info using GetAdaptersAddresses() function from the Internet
 * Protocol Helper (IP Helper) API. When located, this returns a pointer
 * in *outptr to a newly allocated memory area holding a null-terminated
 * string with a space or comma separated list of DNS IP addresses.
 *
 * Returns 0 and nullifies *outptr upon inability to return DNSes string.
 *
 * Returns 1 and sets *outptr when returning a dynamically allocated string.
 *
 * Implementation supports Windows XP and newer.
 */
#  define IPAA_INITIAL_BUF_SZ 15 * 1024
#  define IPAA_MAX_TRIES      3

static ares_bool_t get_DNS_Windows(char **outptr)
{
  IP_ADAPTER_DNS_SERVER_ADDRESS *ipaDNSAddr;
  IP_ADAPTER_ADDRESSES          *ipaa;
  IP_ADAPTER_ADDRESSES          *newipaa;
  IP_ADAPTER_ADDRESSES          *ipaaEntry;
  ULONG                          ReqBufsz  = IPAA_INITIAL_BUF_SZ;
  ULONG                          Bufsz     = IPAA_INITIAL_BUF_SZ;
  ULONG                          AddrFlags = 0;
  int                            trying    = IPAA_MAX_TRIES;
  ULONG                          res;

  /* The capacity of addresses, in elements. */
  size_t                         addressesSize;
  /* The number of elements in addresses. */
  size_t                         addressesIndex = 0;
  /* The addresses we will sort. */
  Address                       *addresses;

  union {
    struct sockaddr     *sa;
    struct sockaddr_in  *sa4;
    struct sockaddr_in6 *sa6;
  } namesrvr;

  *outptr = NULL;

  ipaa = ares_malloc(Bufsz);
  if (!ipaa) {
    return ARES_FALSE;
  }

  /* Start with enough room for a few DNS server addresses and we'll grow it
   * as we encounter more.
   */
  addressesSize = 4;
  addresses     = (Address *)ares_malloc(sizeof(Address) * addressesSize);
  if (addresses == NULL) {
    /* We need room for at least some addresses to function. */
    ares_free(ipaa);
    return ARES_FALSE;
  }

  /* Usually this call succeeds with initial buffer size */
  res = GetAdaptersAddresses(AF_UNSPEC, AddrFlags, NULL, ipaa, &ReqBufsz);
  if ((res != ERROR_BUFFER_OVERFLOW) && (res != ERROR_SUCCESS)) {
    goto done;
  }

  while ((res == ERROR_BUFFER_OVERFLOW) && (--trying)) {
    if (Bufsz < ReqBufsz) {
      newipaa = ares_realloc(ipaa, ReqBufsz);
      if (!newipaa) {
        goto done;
      }
      Bufsz = ReqBufsz;
      ipaa  = newipaa;
    }
    res = GetAdaptersAddresses(AF_UNSPEC, AddrFlags, NULL, ipaa, &ReqBufsz);
    if (res == ERROR_SUCCESS) {
      break;
    }
  }
  if (res != ERROR_SUCCESS) {
    goto done;
  }

  for (ipaaEntry = ipaa; ipaaEntry; ipaaEntry = ipaaEntry->Next) {
    if (ipaaEntry->OperStatus != IfOperStatusUp) {
      continue;
    }

    /* For each interface, find any associated DNS servers as IPv4 or IPv6
     * addresses.  For each found address, find the best route to that DNS
     * server address _on_ _that_ _interface_ (at this moment in time) and
     * compute the resulting total metric, just as Windows routing will do.
     * Then, sort all the addresses found by the metric.
     */
    for (ipaDNSAddr = ipaaEntry->FirstDnsServerAddress; ipaDNSAddr != NULL;
         ipaDNSAddr = ipaDNSAddr->Next) {
      char ipaddr[INET6_ADDRSTRLEN] = "";

      namesrvr.sa = ipaDNSAddr->Address.lpSockaddr;

      if (namesrvr.sa->sa_family == AF_INET) {
        if ((namesrvr.sa4->sin_addr.S_un.S_addr == INADDR_ANY) ||
            (namesrvr.sa4->sin_addr.S_un.S_addr == INADDR_NONE)) {
          continue;
        }

        /* Allocate room for another address, if necessary, else skip. */
        if (addressesIndex == addressesSize) {
          const size_t    newSize = addressesSize + 4;
          Address * const newMem =
            (Address *)ares_realloc(addresses, sizeof(Address) * newSize);
          if (newMem == NULL) {
            continue;
          }
          addresses     = newMem;
          addressesSize = newSize;
        }

        addresses[addressesIndex].metric = getBestRouteMetric(
          &ipaaEntry->Luid, (SOCKADDR_INET *)((void *)(namesrvr.sa)),
          ipaaEntry->Ipv4Metric);

        /* Record insertion index to make qsort stable */
        addresses[addressesIndex].orig_idx = addressesIndex;

        if (!ares_inet_ntop(AF_INET, &namesrvr.sa4->sin_addr, ipaddr,
                            sizeof(ipaddr))) {
          continue;
        }
        snprintf(addresses[addressesIndex].text,
                 sizeof(addresses[addressesIndex].text), "[%s]:%u", ipaddr,
                 ntohs(namesrvr.sa4->sin_port));
        ++addressesIndex;
      } else if (namesrvr.sa->sa_family == AF_INET6) {
        unsigned int     ll_scope = 0;
        struct ares_addr addr;

        if (memcmp(&namesrvr.sa6->sin6_addr, &ares_in6addr_any,
                   sizeof(namesrvr.sa6->sin6_addr)) == 0) {
          continue;
        }

        /* Allocate room for another address, if necessary, else skip. */
        if (addressesIndex == addressesSize) {
          const size_t    newSize = addressesSize + 4;
          Address * const newMem =
            (Address *)ares_realloc(addresses, sizeof(Address) * newSize);
          if (newMem == NULL) {
            continue;
          }
          addresses     = newMem;
          addressesSize = newSize;
        }

        /* See if its link-local */
        memset(&addr, 0, sizeof(addr));
        addr.family = AF_INET6;
        memcpy(&addr.addr.addr6, &namesrvr.sa6->sin6_addr, 16);
        if (ares_addr_is_linklocal(&addr)) {
          ll_scope = ipaaEntry->Ipv6IfIndex;
        }

        addresses[addressesIndex].metric = getBestRouteMetric(
          &ipaaEntry->Luid, (SOCKADDR_INET *)((void *)(namesrvr.sa)),
          ipaaEntry->Ipv6Metric);

        /* Record insertion index to make qsort stable */
        addresses[addressesIndex].orig_idx = addressesIndex;

        if (!ares_inet_ntop(AF_INET6, &namesrvr.sa6->sin6_addr, ipaddr,
                            sizeof(ipaddr))) {
          continue;
        }

        if (ll_scope) {
          snprintf(addresses[addressesIndex].text,
                   sizeof(addresses[addressesIndex].text), "[%s]:%u%%%u",
                   ipaddr, ntohs(namesrvr.sa6->sin6_port), ll_scope);
        } else {
          snprintf(addresses[addressesIndex].text,
                   sizeof(addresses[addressesIndex].text), "[%s]:%u", ipaddr,
                   ntohs(namesrvr.sa6->sin6_port));
        }
        ++addressesIndex;
      } else {
        /* Skip non-IPv4/IPv6 addresses completely. */
        continue;
      }
    }
  }

  /* Sort all of the textual addresses by their metric (and original index if
   * metrics are equal). */
  qsort(addresses, addressesIndex, sizeof(*addresses), compareAddresses);

  /* Join them all into a single string, removing duplicates. */
  {
    size_t i;
    for (i = 0; i < addressesIndex; ++i) {
      size_t j;
      /* Look for this address text appearing previously in the results. */
      for (j = 0; j < i; ++j) {
        if (strcmp(addresses[j].text, addresses[i].text) == 0) {
          break;
        }
      }
      /* Iff we didn't emit this address already, emit it now. */
      if (j == i) {
        /* Add that to outptr (if we can). */
        commajoin(outptr, addresses[i].text);
      }
    }
  }

done:
  ares_free(addresses);

  if (ipaa) {
    ares_free(ipaa);
  }

  if (!*outptr) {
    return ARES_FALSE;
  }

  return ARES_TRUE;
}

/*
 * get_SuffixList_Windows()
 *
 * Reads the "DNS Suffix Search List" from registry and writes the list items
 * whitespace separated to outptr. If the Search List is empty, the
 * "Primary Dns Suffix" is written to outptr.
 *
 * Returns 0 and nullifies *outptr upon inability to return the suffix list.
 *
 * Returns 1 and sets *outptr when returning a dynamically allocated string.
 *
 * Implementation supports Windows Server 2003 and newer
 */
static ares_bool_t get_SuffixList_Windows(char **outptr)
{
  HKEY  hKey;
  HKEY  hKeyEnum;
  char  keyName[256];
  DWORD keyNameBuffSize;
  DWORD keyIdx = 0;
  char *p      = NULL;

  *outptr = NULL;

  /* 1. Global DNS Suffix Search List */
  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0, KEY_READ, &hKey) ==
      ERROR_SUCCESS) {
    get_REG_SZ(hKey, SEARCHLIST_KEY, outptr);
    if (get_REG_SZ(hKey, DOMAIN_KEY, &p)) {
      commajoin(outptr, p);
      ares_free(p);
      p = NULL;
    }
    RegCloseKey(hKey);
  }

  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NT_DNSCLIENT, 0, KEY_READ, &hKey) ==
      ERROR_SUCCESS) {
    if (get_REG_SZ(hKey, SEARCHLIST_KEY, &p)) {
      commajoin(outptr, p);
      ares_free(p);
      p = NULL;
    }
    RegCloseKey(hKey);
  }

  /* 2. Connection Specific Search List composed of:
   *  a. Primary DNS Suffix */
  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_DNSCLIENT, 0, KEY_READ, &hKey) ==
      ERROR_SUCCESS) {
    if (get_REG_SZ(hKey, PRIMARYDNSSUFFIX_KEY, &p)) {
      commajoin(outptr, p);
      ares_free(p);
      p = NULL;
    }
    RegCloseKey(hKey);
  }

  /*  b. Interface SearchList, Domain, DhcpDomain */
  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY "\\" INTERFACES_KEY, 0,
                    KEY_READ, &hKey) == ERROR_SUCCESS) {
    for (;;) {
      keyNameBuffSize = sizeof(keyName);
      if (RegEnumKeyExA(hKey, keyIdx++, keyName, &keyNameBuffSize, 0, NULL,
                        NULL, NULL) != ERROR_SUCCESS) {
        break;
      }
      if (RegOpenKeyExA(hKey, keyName, 0, KEY_QUERY_VALUE, &hKeyEnum) !=
          ERROR_SUCCESS) {
        continue;
      }
      /* p can be comma separated (SearchList) */
      if (get_REG_SZ(hKeyEnum, SEARCHLIST_KEY, &p)) {
        commajoin(outptr, p);
        ares_free(p);
        p = NULL;
      }
      if (get_REG_SZ(hKeyEnum, DOMAIN_KEY, &p)) {
        commajoin(outptr, p);
        ares_free(p);
        p = NULL;
      }
      if (get_REG_SZ(hKeyEnum, DHCPDOMAIN_KEY, &p)) {
        commajoin(outptr, p);
        ares_free(p);
        p = NULL;
      }
      RegCloseKey(hKeyEnum);
    }
    RegCloseKey(hKey);
  }

  return *outptr != NULL ? ARES_TRUE : ARES_FALSE;
}

ares_status_t ares_init_sysconfig_windows(const ares_channel_t *channel,
                                          ares_sysconfig_t     *sysconfig)
{
  char         *line   = NULL;
  ares_status_t status = ARES_SUCCESS;

  if (get_DNS_Windows(&line)) {
    status = ares_sconfig_append_fromstr(channel, &sysconfig->sconfig, line,
                                         ARES_TRUE);
    ares_free(line);
    if (status != ARES_SUCCESS) {
      goto done;
    }
  }

  if (get_SuffixList_Windows(&line)) {
    sysconfig->domains = ares_strsplit(line, ", ", &sysconfig->ndomains);
    ares_free(line);
    if (sysconfig->domains == NULL) {
      status = ARES_EFILE;
    }
    if (status != ARES_SUCCESS) {
      goto done;
    }
  }

done:
  return status;
}
#endif
                                                                                                                                                                                                                                                       node-23.7.0/deps/cares/src/lib/ares_timeout.c                                                       0000664 0000000 0000000 00000010227 14746647661 0021010 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_LIMITS_H
#  include <limits.h>
#endif


void ares_timeval_remaining(ares_timeval_t       *remaining,
                            const ares_timeval_t *now,
                            const ares_timeval_t *tout)
{
  memset(remaining, 0, sizeof(*remaining));

  /* Expired! */
  if (tout->sec < now->sec ||
      (tout->sec == now->sec && tout->usec < now->usec)) {
    return;
  }

  remaining->sec = tout->sec - now->sec;
  if (tout->usec < now->usec) {
    remaining->sec  -= 1;
    remaining->usec  = (tout->usec + 1000000) - now->usec;
  } else {
    remaining->usec = tout->usec - now->usec;
  }
}

void ares_timeval_diff(ares_timeval_t *tvdiff, const ares_timeval_t *tvstart,
                       const ares_timeval_t *tvstop)
{
  tvdiff->sec = tvstop->sec - tvstart->sec;
  if (tvstop->usec > tvstart->usec) {
    tvdiff->usec = tvstop->usec - tvstart->usec;
  } else {
    tvdiff->sec  -= 1;
    tvdiff->usec  = tvstop->usec + 1000000 - tvstart->usec;
  }
}

static void ares_timeval_to_struct_timeval(struct timeval       *tv,
                                           const ares_timeval_t *atv)
{
#ifdef USE_WINSOCK
  tv->tv_sec = (long)atv->sec;
#else
  tv->tv_sec = (time_t)atv->sec;
#endif

  tv->tv_usec = (int)atv->usec;
}

static void struct_timeval_to_ares_timeval(ares_timeval_t       *atv,
                                           const struct timeval *tv)
{
  atv->sec  = (ares_int64_t)tv->tv_sec;
  atv->usec = (unsigned int)tv->tv_usec;
}

static struct timeval *ares_timeout_int(const ares_channel_t *channel,
                                        struct timeval       *maxtv,
                                        struct timeval       *tvbuf)
{
  const ares_query_t *query;
  ares_slist_node_t  *node;
  ares_timeval_t      now;
  ares_timeval_t      atvbuf;
  ares_timeval_t      amaxtv;

  /* The minimum timeout of all queries is always the first entry in
   * channel->queries_by_timeout */
  node = ares_slist_node_first(channel->queries_by_timeout);
  /* no queries/timeout */
  if (node == NULL) {
    return maxtv;
  }

  query = ares_slist_node_val(node);

  ares_tvnow(&now);

  ares_timeval_remaining(&atvbuf, &now, &query->timeout);

  ares_timeval_to_struct_timeval(tvbuf, &atvbuf);

  if (maxtv == NULL) {
    return tvbuf;
  }

  /* Return the minimum time between maxtv and tvbuf */
  struct_timeval_to_ares_timeval(&amaxtv, maxtv);

  if (atvbuf.sec > amaxtv.sec) {
    return maxtv;
  }

  if (atvbuf.sec < amaxtv.sec) {
    return tvbuf;
  }

  if (atvbuf.usec > amaxtv.usec) {
    return maxtv;
  }

  return tvbuf;
}

struct timeval *ares_timeout(const ares_channel_t *channel,
                             struct timeval *maxtv, struct timeval *tvbuf)
{
  struct timeval *rv;

  if (channel == NULL || tvbuf == NULL) {
    return NULL;
  }

  ares_channel_lock(channel);

  rv = ares_timeout_int(channel, maxtv, tvbuf);

  ares_channel_unlock(channel);

  return rv;
}
                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/cares/src/lib/ares_update_servers.c                                                0000664 0000000 0000000 00000112022 14746647661 0022351 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) 2008 Daniel Stenberg
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"

#ifdef HAVE_ARPA_INET_H
#  include <arpa/inet.h>
#endif
#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_SOCKET_H
#  include <sys/socket.h>
#endif
#ifdef HAVE_NET_IF_H
#  include <net/if.h>
#endif
#ifdef HAVE_STDINT_H
#  include <stdint.h>
#endif

#if defined(USE_WINSOCK)
#  if defined(HAVE_IPHLPAPI_H)
#    include <iphlpapi.h>
#  endif
#  if defined(HAVE_NETIOAPI_H)
#    include <netioapi.h>
#  endif
#endif

#include "ares_data.h"
#include "ares_inet_net_pton.h"

typedef struct {
  struct ares_addr addr;
  unsigned short   tcp_port;
  unsigned short   udp_port;

  char             ll_iface[IF_NAMESIZE];
  unsigned int     ll_scope;
} ares_sconfig_t;

static ares_bool_t ares_addr_match(const struct ares_addr *addr1,
                                   const struct ares_addr *addr2)
{
  if (addr1 == NULL && addr2 == NULL) {
    return ARES_TRUE; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  if (addr1 == NULL || addr2 == NULL) {
    return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  if (addr1->family != addr2->family) {
    return ARES_FALSE;
  }

  if (addr1->family == AF_INET && memcmp(&addr1->addr.addr4, &addr2->addr.addr4,
                                         sizeof(addr1->addr.addr4)) == 0) {
    return ARES_TRUE;
  }

  if (addr1->family == AF_INET6 &&
      memcmp(&addr1->addr.addr6._S6_un._S6_u8, &addr2->addr.addr6._S6_un._S6_u8,
             sizeof(addr1->addr.addr6._S6_un._S6_u8)) == 0) {
    return ARES_TRUE;
  }

  return ARES_FALSE;
}

ares_bool_t ares_subnet_match(const struct ares_addr *addr,
                              const struct ares_addr *subnet,
                              unsigned char           netmask)
{
  const unsigned char *addr_ptr;
  const unsigned char *subnet_ptr;
  size_t               len;
  size_t               i;

  if (addr == NULL || subnet == NULL) {
    return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  if (addr->family != subnet->family) {
    return ARES_FALSE;
  }

  if (addr->family == AF_INET) {
    addr_ptr   = (const unsigned char *)&addr->addr.addr4;
    subnet_ptr = (const unsigned char *)&subnet->addr.addr4;
    len        = 4;

    if (netmask > 32) {
      return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */
    }
  } else if (addr->family == AF_INET6) {
    addr_ptr   = (const unsigned char *)&addr->addr.addr6;
    subnet_ptr = (const unsigned char *)&subnet->addr.addr6;
    len        = 16;

    if (netmask > 128) {
      return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */
    }
  } else {
    return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  for (i = 0; i < len && netmask > 0; i++) {
    unsigned char mask = 0xff;
    if (netmask < 8) {
      mask    <<= (8 - netmask);
      netmask   = 0;
    } else {
      netmask -= 8;
    }

    if ((addr_ptr[i] & mask) != (subnet_ptr[i] & mask)) {
      return ARES_FALSE;
    }
  }

  return ARES_TRUE;
}

ares_bool_t ares_addr_is_linklocal(const struct ares_addr *addr)
{
  struct ares_addr    subnet;
  const unsigned char subnetaddr[16] = { 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00,
                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                         0x00, 0x00, 0x00, 0x00 };

  /* fe80::/10 */
  subnet.family = AF_INET6;
  memcpy(&subnet.addr.addr6, subnetaddr, 16);

  return ares_subnet_match(addr, &subnet, 10);
}

static ares_bool_t ares_server_blacklisted(const struct ares_addr *addr)
{
  /* A list of blacklisted IPv6 subnets. */
  const struct {
    const unsigned char netbase[16];
    unsigned char       netmask;
  } blacklist_v6[] = {
    /* fec0::/10 was deprecated by [RFC3879] in September 2004. Formerly a
     * Site-Local scoped address prefix.  These are never valid DNS servers,
     * but are known to be returned at least sometimes on Windows and Android.
     */
    { { 0xfe, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00 },
     10 }
  };

  size_t i;

  if (addr->family != AF_INET6) {
    return ARES_FALSE;
  }

  /* See if ipaddr matches any of the entries in the blacklist. */
  for (i = 0; i < sizeof(blacklist_v6) / sizeof(*blacklist_v6); i++) {
    struct ares_addr subnet;
    subnet.family = AF_INET6;
    memcpy(&subnet.addr.addr6, blacklist_v6[i].netbase, 16);
    if (ares_subnet_match(addr, &subnet, blacklist_v6[i].netmask)) {
      return ARES_TRUE;
    }
  }
  return ARES_FALSE;
}

static ares_status_t parse_nameserver_uri(ares_buf_t     *buf,
                                          ares_sconfig_t *sconfig)
{
  ares_uri_t   *uri    = NULL;
  ares_status_t status = ARES_SUCCESS;
  const char   *port;
  char         *ll_scope;
  char          hoststr[256];
  size_t        addrlen;

  status = ares_uri_parse_buf(&uri, buf);
  if (status != ARES_SUCCESS) {
    return status;
  }

  if (!ares_streq("dns", ares_uri_get_scheme(uri))) {
    status = ARES_EBADSTR;
    goto done;
  }

  ares_strcpy(hoststr, ares_uri_get_host(uri), sizeof(hoststr));
  ll_scope = strchr(hoststr, '%');
  if (ll_scope != NULL) {
    *ll_scope = 0;
    ll_scope++;
    ares_strcpy(sconfig->ll_iface, ll_scope, sizeof(sconfig->ll_iface));
  }

  /* Convert ip address from string to network byte order */
  sconfig->addr.family = AF_UNSPEC;
  if (ares_dns_pton(hoststr, &sconfig->addr, &addrlen) == NULL) {
    status = ARES_EBADSTR;
    goto done;
  }

  sconfig->udp_port = ares_uri_get_port(uri);
  sconfig->tcp_port = sconfig->udp_port;
  port              = ares_uri_get_query_key(uri, "tcpport");
  if (port != NULL) {
    sconfig->tcp_port = (unsigned short)atoi(port);
  }

done:
  ares_uri_destroy(uri);
  return status;
}

/* Parse address and port in these formats, either ipv4 or ipv6 addresses
 * are allowed:
 *   ipaddr
 *   ipv4addr:port
 *   [ipaddr]
 *   [ipaddr]:port
 *
 * Modifiers: %iface
 *
 * TODO: #domain modifier
 *
 * If a port is not specified, will set port to 0.
 *
 * Will fail if an IPv6 nameserver as detected by
 * ares_ipv6_server_blacklisted()
 *
 * Returns an error code on failure, else ARES_SUCCESS
 */

static ares_status_t parse_nameserver(ares_buf_t *buf, ares_sconfig_t *sconfig)
{
  ares_status_t status;
  char          ipaddr[INET6_ADDRSTRLEN] = "";
  size_t        addrlen;

  memset(sconfig, 0, sizeof(*sconfig));

  /* Consume any leading whitespace */
  ares_buf_consume_whitespace(buf, ARES_TRUE);

  /* pop off IP address.  If it is in [ ] then it can be ipv4 or ipv6.  If
   * not, ipv4 only */
  if (ares_buf_begins_with(buf, (const unsigned char *)"[", 1)) {
    /* Consume [ */
    ares_buf_consume(buf, 1);

    ares_buf_tag(buf);

    /* Consume until ] */
    if (ares_buf_consume_until_charset(buf, (const unsigned char *)"]", 1,
                                       ARES_TRUE) == SIZE_MAX) {
      return ARES_EBADSTR;
    }

    status = ares_buf_tag_fetch_string(buf, ipaddr, sizeof(ipaddr));
    if (status != ARES_SUCCESS) {
      return status;
    }

    /* Skip over ] */
    ares_buf_consume(buf, 1);
  } else {
    size_t offset;

    /* Not in [ ], see if '.' is in first 4 characters, if it is, then its ipv4,
     * otherwise treat as ipv6 */
    ares_buf_tag(buf);

    offset = ares_buf_consume_until_charset(buf, (const unsigned char *)".", 1,
                                            ARES_TRUE);
    ares_buf_tag_rollback(buf);
    ares_buf_tag(buf);

    if (offset > 0 && offset < 4) {
      /* IPv4 */
      if (ares_buf_consume_charset(buf, (const unsigned char *)"0123456789.",
                                   11) == 0) {
        return ARES_EBADSTR;
      }
    } else {
      /* IPv6 */
      const unsigned char ipv6_charset[] = "ABCDEFabcdef0123456789.:";
      if (ares_buf_consume_charset(buf, ipv6_charset,
                                   sizeof(ipv6_charset) - 1) == 0) {
        return ARES_EBADSTR;
      }
    }

    status = ares_buf_tag_fetch_string(buf, ipaddr, sizeof(ipaddr));
    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  /* Convert ip address from string to network byte order */
  sconfig->addr.family = AF_UNSPEC;
  if (ares_dns_pton(ipaddr, &sconfig->addr, &addrlen) == NULL) {
    return ARES_EBADSTR;
  }

  /* Pull off port */
  if (ares_buf_begins_with(buf, (const unsigned char *)":", 1)) {
    char portstr[6];

    /* Consume : */
    ares_buf_consume(buf, 1);

    ares_buf_tag(buf);

    /* Read numbers */
    if (ares_buf_consume_charset(buf, (const unsigned char *)"0123456789",
                                 10) == 0) {
      return ARES_EBADSTR;
    }

    status = ares_buf_tag_fetch_string(buf, portstr, sizeof(portstr));
    if (status != ARES_SUCCESS) {
      return status;
    }

    sconfig->udp_port = (unsigned short)atoi(portstr);
    sconfig->tcp_port = sconfig->udp_port;
  }

  /* Pull off interface modifier */
  if (ares_buf_begins_with(buf, (const unsigned char *)"%", 1)) {
    const unsigned char iface_charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                          "abcdefghijklmnopqrstuvwxyz"
                                          "0123456789.-_\\:{}";
    /* Consume % */
    ares_buf_consume(buf, 1);

    ares_buf_tag(buf);

    if (ares_buf_consume_charset(buf, iface_charset,
                                 sizeof(iface_charset) - 1) == 0) {
      return ARES_EBADSTR;
    }

    status = ares_buf_tag_fetch_string(buf, sconfig->ll_iface,
                                       sizeof(sconfig->ll_iface));
    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  /* Consume any trailing whitespace so we can bail out if there is something
   * after we didn't read */
  ares_buf_consume_whitespace(buf, ARES_TRUE);

  if (ares_buf_len(buf) != 0) {
    return ARES_EBADSTR;
  }

  return ARES_SUCCESS;
}

static ares_status_t ares_sconfig_linklocal(const ares_channel_t *channel,
                                            ares_sconfig_t       *s,
                                            const char           *ll_iface)
{
  unsigned int ll_scope = 0;


  if (ares_str_isnum(ll_iface)) {
    char ifname[IF_NAMESIZE] = "";
    ll_scope                 = (unsigned int)atoi(ll_iface);
    if (channel->sock_funcs.aif_indextoname == NULL ||
        channel->sock_funcs.aif_indextoname(ll_scope, ifname, sizeof(ifname),
                                            channel->sock_func_cb_data) ==
          NULL) {
      DEBUGF(fprintf(stderr, "Interface %s for ipv6 Link Local not found\n",
                     ll_iface));
      return ARES_ENOTFOUND;
    }
    ares_strcpy(s->ll_iface, ifname, sizeof(s->ll_iface));
    s->ll_scope = ll_scope;
    return ARES_SUCCESS;
  }

  if (channel->sock_funcs.aif_nametoindex != NULL) {
    ll_scope =
      channel->sock_funcs.aif_nametoindex(ll_iface, channel->sock_func_cb_data);
  }
  if (ll_scope == 0) {
    DEBUGF(fprintf(stderr, "Interface %s for ipv6 Link Local not found\n",
                   ll_iface));
    return ARES_ENOTFOUND;
  }
  ares_strcpy(s->ll_iface, ll_iface, sizeof(s->ll_iface));
  s->ll_scope = ll_scope;
  return ARES_SUCCESS;
}

ares_status_t ares_sconfig_append(const ares_channel_t   *channel,
                                  ares_llist_t          **sconfig,
                                  const struct ares_addr *addr,
                                  unsigned short          udp_port,
                                  unsigned short tcp_port, const char *ll_iface)
{
  ares_sconfig_t *s;
  ares_status_t   status;

  if (sconfig == NULL || addr == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* Silently skip blacklisted IPv6 servers. */
  if (ares_server_blacklisted(addr)) {
    return ARES_SUCCESS;
  }

  s = ares_malloc_zero(sizeof(*s));
  if (s == NULL) {
    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  if (*sconfig == NULL) {
    *sconfig = ares_llist_create(ares_free);
    if (*sconfig == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  memcpy(&s->addr, addr, sizeof(s->addr));
  s->udp_port = udp_port;
  s->tcp_port = tcp_port;

  /* Handle link-local enumeration. If an interface is specified on a
   * non-link-local address, we'll simply end up ignoring that */
  if (ares_addr_is_linklocal(&s->addr)) {
    if (ares_strlen(ll_iface) == 0) {
      /* Silently ignore this entry, we require an interface */
      status = ARES_SUCCESS;
      goto fail;
    }
    status = ares_sconfig_linklocal(channel, s, ll_iface);
    /* Silently ignore this entry, we can't validate the interface */
    if (status != ARES_SUCCESS) {
      status = ARES_SUCCESS;
      goto fail;
    }
  }

  if (ares_llist_insert_last(*sconfig, s) == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  return ARES_SUCCESS;

fail:
  ares_free(s);

  return status;
}

/* Add the IPv4 or IPv6 nameservers in str (separated by commas or spaces) to
 * the servers list, updating servers and nservers as required.
 *
 * If a nameserver is encapsulated in [ ] it may optionally include a port
 * suffix, e.g.:
 *    [127.0.0.1]:59591
 *
 * The extended format is required to support OpenBSD's resolv.conf format:
 *   https://man.openbsd.org/OpenBSD-5.1/resolv.conf.5
 * As well as MacOS libresolv that may include a non-default port number.
 *
 * This will silently ignore blacklisted IPv6 nameservers as detected by
 * ares_ipv6_server_blacklisted().
 *
 * Returns an error code on failure, else ARES_SUCCESS.
 */
ares_status_t ares_sconfig_append_fromstr(const ares_channel_t *channel,
                                          ares_llist_t        **sconfig,
                                          const char           *str,
                                          ares_bool_t           ignore_invalid)
{
  ares_status_t status = ARES_SUCCESS;
  ares_buf_t   *buf    = NULL;
  ares_array_t *list   = NULL;
  size_t        num;
  size_t        i;

  /* On Windows, there may be more than one nameserver specified in the same
   * registry key, so we parse input as a space or comma separated list.
   */
  buf = ares_buf_create_const((const unsigned char *)str, ares_strlen(str));
  if (buf == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  status = ares_buf_split(buf, (const unsigned char *)" ,", 2,
                          ARES_BUF_SPLIT_NONE, 0, &list);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  num = ares_array_len(list);
  for (i = 0; i < num; i++) {
    ares_buf_t   **bufptr = ares_array_at(list, i);
    ares_buf_t    *entry  = *bufptr;
    ares_sconfig_t s;

    status = parse_nameserver_uri(entry, &s);
    if (status != ARES_SUCCESS) {
      status = parse_nameserver(entry, &s);
    }

    if (status != ARES_SUCCESS) {
      if (ignore_invalid) {
        continue;
      } else {
        goto done;
      }
    }

    status = ares_sconfig_append(channel, sconfig, &s.addr, s.udp_port,
                                 s.tcp_port, s.ll_iface);
    if (status != ARES_SUCCESS) {
      goto done; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  status = ARES_SUCCESS;

done:
  ares_array_destroy(list);
  ares_buf_destroy(buf);
  return status;
}

static unsigned short ares_sconfig_get_port(const ares_channel_t *channel,
                                            const ares_sconfig_t *s,
                                            ares_bool_t           is_tcp)
{
  unsigned short port = is_tcp ? s->tcp_port : s->udp_port;

  if (port == 0) {
    port = is_tcp ? channel->tcp_port : channel->udp_port;
  }

  if (port == 0) {
    port = 53;
  }

  return port;
}

static ares_slist_node_t *ares_server_find(const ares_channel_t *channel,
                                           const ares_sconfig_t *s)
{
  ares_slist_node_t *node;

  for (node = ares_slist_node_first(channel->servers); node != NULL;
       node = ares_slist_node_next(node)) {
    const ares_server_t *server = ares_slist_node_val(node);

    if (!ares_addr_match(&server->addr, &s->addr)) {
      continue;
    }

    if (server->tcp_port != ares_sconfig_get_port(channel, s, ARES_TRUE)) {
      continue;
    }

    if (server->udp_port != ares_sconfig_get_port(channel, s, ARES_FALSE)) {
      continue;
    }

    return node;
  }
  return NULL;
}

static ares_bool_t ares_server_isdup(const ares_channel_t *channel,
                                     ares_llist_node_t    *s)
{
  /* Scan backwards to see if this is a duplicate */
  ares_llist_node_t    *prev;
  const ares_sconfig_t *server = ares_llist_node_val(s);

  for (prev = ares_llist_node_prev(s); prev != NULL;
       prev = ares_llist_node_prev(prev)) {
    const ares_sconfig_t *p = ares_llist_node_val(prev);

    if (!ares_addr_match(&server->addr, &p->addr)) {
      continue;
    }

    if (ares_sconfig_get_port(channel, server, ARES_TRUE) !=
        ares_sconfig_get_port(channel, p, ARES_TRUE)) {
      continue;
    }

    if (ares_sconfig_get_port(channel, server, ARES_FALSE) !=
        ares_sconfig_get_port(channel, p, ARES_FALSE)) {
      continue;
    }

    return ARES_TRUE;
  }

  return ARES_FALSE;
}

static ares_status_t ares_server_create(ares_channel_t       *channel,
                                        const ares_sconfig_t *sconfig,
                                        size_t                idx)
{
  ares_status_t  status;
  ares_server_t *server = ares_malloc_zero(sizeof(*server));

  if (server == NULL) {
    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  server->idx         = idx;
  server->channel     = channel;
  server->udp_port    = ares_sconfig_get_port(channel, sconfig, ARES_FALSE);
  server->tcp_port    = ares_sconfig_get_port(channel, sconfig, ARES_TRUE);
  server->addr.family = sconfig->addr.family;
  server->next_retry_time.sec  = 0;
  server->next_retry_time.usec = 0;

  if (sconfig->addr.family == AF_INET) {
    memcpy(&server->addr.addr.addr4, &sconfig->addr.addr.addr4,
           sizeof(server->addr.addr.addr4));
  } else if (sconfig->addr.family == AF_INET6) {
    memcpy(&server->addr.addr.addr6, &sconfig->addr.addr.addr6,
           sizeof(server->addr.addr.addr6));
  }

  /* Copy over link-local settings */
  if (ares_strlen(sconfig->ll_iface)) {
    ares_strcpy(server->ll_iface, sconfig->ll_iface, sizeof(server->ll_iface));
    server->ll_scope = sconfig->ll_scope;
  }

  server->connections = ares_llist_create(NULL);
  if (server->connections == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  if (ares_slist_insert(channel->servers, server) == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  status = ARES_SUCCESS;

done:
  if (status != ARES_SUCCESS) {
    ares_destroy_server(server); /* LCOV_EXCL_LINE: OutOfMemory */
  }

  return status;
}

static ares_bool_t ares_server_in_newconfig(const ares_server_t *server,
                                            ares_llist_t        *srvlist)
{
  ares_llist_node_t    *node;
  const ares_channel_t *channel = server->channel;

  for (node = ares_llist_node_first(srvlist); node != NULL;
       node = ares_llist_node_next(node)) {
    const ares_sconfig_t *s = ares_llist_node_val(node);

    if (!ares_addr_match(&server->addr, &s->addr)) {
      continue;
    }

    if (server->tcp_port != ares_sconfig_get_port(channel, s, ARES_TRUE)) {
      continue;
    }

    if (server->udp_port != ares_sconfig_get_port(channel, s, ARES_FALSE)) {
      continue;
    }

    return ARES_TRUE;
  }

  return ARES_FALSE;
}

static ares_bool_t ares_servers_remove_stale(ares_channel_t *channel,
                                             ares_llist_t   *srvlist)
{
  ares_bool_t        stale_removed = ARES_FALSE;
  ares_slist_node_t *snode         = ares_slist_node_first(channel->servers);

  while (snode != NULL) {
    ares_slist_node_t   *snext  = ares_slist_node_next(snode);
    const ares_server_t *server = ares_slist_node_val(snode);
    if (!ares_server_in_newconfig(server, srvlist)) {
      /* This will clean up all server state via the destruction callback and
       * move any queries to new servers */
      ares_slist_node_destroy(snode);
      stale_removed = ARES_TRUE;
    }
    snode = snext;
  }
  return stale_removed;
}

static void ares_servers_trim_single(ares_channel_t *channel)
{
  while (ares_slist_len(channel->servers) > 1) {
    ares_slist_node_destroy(ares_slist_node_last(channel->servers));
  }
}

ares_status_t ares_servers_update(ares_channel_t *channel,
                                  ares_llist_t   *server_list,
                                  ares_bool_t     user_specified)
{
  ares_llist_node_t *node;
  size_t             idx = 0;
  ares_status_t      status;
  ares_bool_t        list_changed = ARES_FALSE;

  if (channel == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* NOTE: a NULL or zero entry server list is considered valid due to
   *       real-world people needing support for this for their test harnesses
   */

  /* Add new entries */
  for (node = ares_llist_node_first(server_list); node != NULL;
       node = ares_llist_node_next(node)) {
    const ares_sconfig_t *sconfig = ares_llist_node_val(node);
    ares_slist_node_t    *snode;

    /* If a server has already appeared in the list of new servers, skip it. */
    if (ares_server_isdup(channel, node)) {
      continue;
    }

    snode = ares_server_find(channel, sconfig);
    if (snode != NULL) {
      ares_server_t *server = ares_slist_node_val(snode);

      /* Copy over link-local settings.  Its possible some of this data has
       * changed, maybe ...  */
      if (ares_strlen(sconfig->ll_iface)) {
        ares_strcpy(server->ll_iface, sconfig->ll_iface,
                    sizeof(server->ll_iface));
        server->ll_scope = sconfig->ll_scope;
      }

      if (server->idx != idx) {
        server->idx = idx;
        /* Index changed, reinsert node, doesn't require any memory
         * allocations so can't fail. */
        ares_slist_node_reinsert(snode);
      }
    } else {
      status = ares_server_create(channel, sconfig, idx);
      if (status != ARES_SUCCESS) {
        goto done;
      }

      list_changed = ARES_TRUE;
    }

    idx++;
  }

  /* Remove any servers that don't exist in the current configuration */
  if (ares_servers_remove_stale(channel, server_list)) {
    list_changed = ARES_TRUE;
  }

  /* Trim to one server if ARES_FLAG_PRIMARY is set. */
  if (channel->flags & ARES_FLAG_PRIMARY) {
    ares_servers_trim_single(channel);
  }

  if (user_specified) {
    /* Save servers as if they were passed in as an option */
    channel->optmask |= ARES_OPT_SERVERS;
  }

  /* Clear any cached query results only if the server list changed */
  if (list_changed) {
    ares_qcache_flush(channel->qcache);
  }

  status = ARES_SUCCESS;

done:
  return status;
}

static ares_status_t
  ares_addr_node_to_sconfig_llist(const struct ares_addr_node *servers,
                                  ares_llist_t               **llist)
{
  const struct ares_addr_node *node;
  ares_llist_t                *s;

  *llist = NULL;

  s = ares_llist_create(ares_free);
  if (s == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  for (node = servers; node != NULL; node = node->next) {
    ares_sconfig_t *sconfig;

    /* Invalid entry */
    if (node->family != AF_INET && node->family != AF_INET6) {
      continue;
    }

    sconfig = ares_malloc_zero(sizeof(*sconfig));
    if (sconfig == NULL) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    sconfig->addr.family = node->family;
    if (node->family == AF_INET) {
      memcpy(&sconfig->addr.addr.addr4, &node->addr.addr4,
             sizeof(sconfig->addr.addr.addr4));
    } else if (sconfig->addr.family == AF_INET6) {
      memcpy(&sconfig->addr.addr.addr6, &node->addr.addr6,
             sizeof(sconfig->addr.addr.addr6));
    }

    if (ares_llist_insert_last(s, sconfig) == NULL) {
      ares_free(sconfig); /* LCOV_EXCL_LINE: OutOfMemory */
      goto fail;          /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  *llist = s;
  return ARES_SUCCESS;

/* LCOV_EXCL_START: OutOfMemory */
fail:
  ares_llist_destroy(s);
  return ARES_ENOMEM;
  /* LCOV_EXCL_STOP */
}

static ares_status_t
  ares_addrpnode_to_sconfig_llist(const struct ares_addr_port_node *servers,
                                  ares_llist_t                    **llist)
{
  const struct ares_addr_port_node *node;
  ares_llist_t                     *s;

  *llist = NULL;

  s = ares_llist_create(ares_free);
  if (s == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  for (node = servers; node != NULL; node = node->next) {
    ares_sconfig_t *sconfig;

    /* Invalid entry */
    if (node->family != AF_INET && node->family != AF_INET6) {
      continue;
    }

    sconfig = ares_malloc_zero(sizeof(*sconfig));
    if (sconfig == NULL) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    sconfig->addr.family = node->family;
    if (node->family == AF_INET) {
      memcpy(&sconfig->addr.addr.addr4, &node->addr.addr4,
             sizeof(sconfig->addr.addr.addr4));
    } else if (sconfig->addr.family == AF_INET6) {
      memcpy(&sconfig->addr.addr.addr6, &node->addr.addr6,
             sizeof(sconfig->addr.addr.addr6));
    }

    sconfig->tcp_port = (unsigned short)node->tcp_port;
    sconfig->udp_port = (unsigned short)node->udp_port;

    if (ares_llist_insert_last(s, sconfig) == NULL) {
      ares_free(sconfig); /* LCOV_EXCL_LINE: OutOfMemory */
      goto fail;          /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  *llist = s;
  return ARES_SUCCESS;

/* LCOV_EXCL_START: OutOfMemory */
fail:
  ares_llist_destroy(s);
  return ARES_ENOMEM;
  /* LCOV_EXCL_STOP */
}

ares_status_t ares_in_addr_to_sconfig_llist(const struct in_addr *servers,
                                            size_t                nservers,
                                            ares_llist_t        **llist)
{
  size_t        i;
  ares_llist_t *s;

  *llist = NULL;

  s = ares_llist_create(ares_free);
  if (s == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  for (i = 0; servers != NULL && i < nservers; i++) {
    ares_sconfig_t *sconfig;

    sconfig = ares_malloc_zero(sizeof(*sconfig));
    if (sconfig == NULL) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    sconfig->addr.family = AF_INET;
    memcpy(&sconfig->addr.addr.addr4, &servers[i],
           sizeof(sconfig->addr.addr.addr4));

    if (ares_llist_insert_last(s, sconfig) == NULL) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  *llist = s;
  return ARES_SUCCESS;

/* LCOV_EXCL_START: OutOfMemory */
fail:
  ares_llist_destroy(s);
  return ARES_ENOMEM;
  /* LCOV_EXCL_STOP */
}

static ares_bool_t ares_server_use_uri(const ares_server_t *server)
{
  /* Currently only reason to use new format is if the ports for udp and tcp
   * are different */
  if (server->tcp_port != server->udp_port) {
    return ARES_TRUE;
  }
  return ARES_FALSE;
}

static ares_status_t ares_get_server_addr_uri(const ares_server_t *server,
                                              ares_buf_t          *buf)
{
  ares_uri_t   *uri = NULL;
  ares_status_t status;
  char          addr[INET6_ADDRSTRLEN];

  uri = ares_uri_create();
  if (uri == NULL) {
    return ARES_ENOMEM;
  }

  status = ares_uri_set_scheme(uri, "dns");
  if (status != ARES_SUCCESS) {
    goto done;
  }

  ares_inet_ntop(server->addr.family, &server->addr.addr, addr, sizeof(addr));

  if (ares_strlen(server->ll_iface)) {
    char addr_iface[256];

    snprintf(addr_iface, sizeof(addr_iface), "%s%%%s", addr, server->ll_iface);
    status = ares_uri_set_host(uri, addr_iface);
  } else {
    status = ares_uri_set_host(uri, addr);
  }

  if (status != ARES_SUCCESS) {
    goto done;
  }

  status = ares_uri_set_port(uri, server->udp_port);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  if (server->udp_port != server->tcp_port) {
    char port[6];
    snprintf(port, sizeof(port), "%d", server->tcp_port);
    status = ares_uri_set_query_key(uri, "tcpport", port);
    if (status != ARES_SUCCESS) {
      goto done;
    }
  }

  status = ares_uri_write_buf(uri, buf);
  if (status != ARES_SUCCESS) {
    goto done;
  }

done:
  ares_uri_destroy(uri);
  return status;
}

/* Write out the details of a server to a buffer */
ares_status_t ares_get_server_addr(const ares_server_t *server, ares_buf_t *buf)
{
  ares_status_t status;
  char          addr[INET6_ADDRSTRLEN];

  if (ares_server_use_uri(server)) {
    return ares_get_server_addr_uri(server, buf);
  }

  /* ipv4addr or [ipv6addr] */
  if (server->addr.family == AF_INET6) {
    status = ares_buf_append_byte(buf, '[');
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  ares_inet_ntop(server->addr.family, &server->addr.addr, addr, sizeof(addr));

  status = ares_buf_append_str(buf, addr);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  if (server->addr.family == AF_INET6) {
    status = ares_buf_append_byte(buf, ']');
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  /* :port */
  status = ares_buf_append_byte(buf, ':');
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  status = ares_buf_append_num_dec(buf, server->udp_port, 0);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* %iface */
  if (ares_strlen(server->ll_iface)) {
    status = ares_buf_append_byte(buf, '%');
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    status = ares_buf_append_str(buf, server->ll_iface);
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  return ARES_SUCCESS;
}

int ares_get_servers(const ares_channel_t   *channel,
                     struct ares_addr_node **servers)
{
  struct ares_addr_node *srvr_head = NULL;
  struct ares_addr_node *srvr_last = NULL;
  struct ares_addr_node *srvr_curr;
  ares_status_t          status = ARES_SUCCESS;
  ares_slist_node_t     *node;

  if (channel == NULL) {
    return ARES_ENODATA;
  }

  ares_channel_lock(channel);

  for (node = ares_slist_node_first(channel->servers); node != NULL;
       node = ares_slist_node_next(node)) {
    const ares_server_t *server = ares_slist_node_val(node);

    /* Allocate storage for this server node appending it to the list */
    srvr_curr = ares_malloc_data(ARES_DATATYPE_ADDR_NODE);
    if (!srvr_curr) {
      status = ARES_ENOMEM;
      break;
    }
    if (srvr_last) {
      srvr_last->next = srvr_curr;
    } else {
      srvr_head = srvr_curr;
    }
    srvr_last = srvr_curr;

    /* Fill this server node data */
    srvr_curr->family = server->addr.family;
    if (srvr_curr->family == AF_INET) {
      memcpy(&srvr_curr->addr.addr4, &server->addr.addr.addr4,
             sizeof(srvr_curr->addr.addr4));
    } else {
      memcpy(&srvr_curr->addr.addr6, &server->addr.addr.addr6,
             sizeof(srvr_curr->addr.addr6));
    }
  }

  if (status != ARES_SUCCESS) {
    ares_free_data(srvr_head);
    srvr_head = NULL;
  }

  *servers = srvr_head;

  ares_channel_unlock(channel);

  return (int)status;
}

int ares_get_servers_ports(const ares_channel_t        *channel,
                           struct ares_addr_port_node **servers)
{
  struct ares_addr_port_node *srvr_head = NULL;
  struct ares_addr_port_node *srvr_last = NULL;
  struct ares_addr_port_node *srvr_curr;
  ares_status_t               status = ARES_SUCCESS;
  ares_slist_node_t          *node;

  if (channel == NULL) {
    return ARES_ENODATA;
  }

  ares_channel_lock(channel);

  for (node = ares_slist_node_first(channel->servers); node != NULL;
       node = ares_slist_node_next(node)) {
    const ares_server_t *server = ares_slist_node_val(node);

    /* Allocate storage for this server node appending it to the list */
    srvr_curr = ares_malloc_data(ARES_DATATYPE_ADDR_PORT_NODE);
    if (!srvr_curr) {
      status = ARES_ENOMEM;
      break;
    }
    if (srvr_last) {
      srvr_last->next = srvr_curr;
    } else {
      srvr_head = srvr_curr;
    }
    srvr_last = srvr_curr;

    /* Fill this server node data */
    srvr_curr->family   = server->addr.family;
    srvr_curr->udp_port = server->udp_port;
    srvr_curr->tcp_port = server->tcp_port;

    if (srvr_curr->family == AF_INET) {
      memcpy(&srvr_curr->addr.addr4, &server->addr.addr.addr4,
             sizeof(srvr_curr->addr.addr4));
    } else {
      memcpy(&srvr_curr->addr.addr6, &server->addr.addr.addr6,
             sizeof(srvr_curr->addr.addr6));
    }
  }

  if (status != ARES_SUCCESS) {
    ares_free_data(srvr_head);
    srvr_head = NULL;
  }

  *servers = srvr_head;

  ares_channel_unlock(channel);
  return (int)status;
}

int ares_set_servers(ares_channel_t              *channel,
                     const struct ares_addr_node *servers)
{
  ares_llist_t *slist;
  ares_status_t status;

  if (channel == NULL) {
    return ARES_ENODATA;
  }

  status = ares_addr_node_to_sconfig_llist(servers, &slist);
  if (status != ARES_SUCCESS) {
    return (int)status;
  }

  ares_channel_lock(channel);
  status = ares_servers_update(channel, slist, ARES_TRUE);
  ares_channel_unlock(channel);

  ares_llist_destroy(slist);

  return (int)status;
}

int ares_set_servers_ports(ares_channel_t                   *channel,
                           const struct ares_addr_port_node *servers)
{
  ares_llist_t *slist;
  ares_status_t status;

  if (channel == NULL) {
    return ARES_ENODATA;
  }

  status = ares_addrpnode_to_sconfig_llist(servers, &slist);
  if (status != ARES_SUCCESS) {
    return (int)status;
  }

  ares_channel_lock(channel);
  status = ares_servers_update(channel, slist, ARES_TRUE);
  ares_channel_unlock(channel);

  ares_llist_destroy(slist);

  return (int)status;
}

/* Incoming string format: host[:port][,host[:port]]... */
/* IPv6 addresses with ports require square brackets [fe80::1]:53 */
static ares_status_t set_servers_csv(ares_channel_t *channel, const char *_csv)
{
  ares_status_t status;
  ares_llist_t *slist = NULL;

  if (channel == NULL) {
    return ARES_ENODATA;
  }

  if (ares_strlen(_csv) == 0) {
    /* blank all servers */
    ares_channel_lock(channel);
    status = ares_servers_update(channel, NULL, ARES_TRUE);
    ares_channel_unlock(channel);
    return status;
  }

  status = ares_sconfig_append_fromstr(channel, &slist, _csv, ARES_FALSE);
  if (status != ARES_SUCCESS) {
    ares_llist_destroy(slist);
    return status;
  }

  ares_channel_lock(channel);
  status = ares_servers_update(channel, slist, ARES_TRUE);
  ares_channel_unlock(channel);

  ares_llist_destroy(slist);

  return status;
}

/* We'll go ahead and honor ports anyhow */
int ares_set_servers_csv(ares_channel_t *channel, const char *_csv)
{
  return (int)set_servers_csv(channel, _csv);
}

int ares_set_servers_ports_csv(ares_channel_t *channel, const char *_csv)
{
  return (int)set_servers_csv(channel, _csv);
}

char *ares_get_servers_csv(const ares_channel_t *channel)
{
  ares_buf_t        *buf = NULL;
  char              *out = NULL;
  ares_slist_node_t *node;

  ares_channel_lock(channel);

  buf = ares_buf_create();
  if (buf == NULL) {
    goto done; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  for (node = ares_slist_node_first(channel->servers); node != NULL;
       node = ares_slist_node_next(node)) {
    ares_status_t        status;
    const ares_server_t *server = ares_slist_node_val(node);

    if (ares_buf_len(buf)) {
      status = ares_buf_append_byte(buf, ',');
      if (status != ARES_SUCCESS) {
        goto done; /* LCOV_EXCL_LINE: OutOfMemory */
      }
    }

    status = ares_get_server_addr(server, buf);
    if (status != ARES_SUCCESS) {
      goto done; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  out = ares_buf_finish_str(buf, NULL);
  buf = NULL;

done:
  ares_channel_unlock(channel);
  ares_buf_destroy(buf);
  return out;
}

void ares_set_server_state_callback(ares_channel_t            *channel,
                                    ares_server_state_callback cb, void *data)
{
  if (channel == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }
  channel->server_state_cb      = cb;
  channel->server_state_cb_data = data;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/cares/src/lib/ares_version.c                                                       0000664 0000000 0000000 00000002627 14746647661 0021014 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"

const char *ares_version(int *version)
{
  if (version) {
    *version = ARES_VERSION;
  }

  return ARES_VERSION_STR;
}
                                                                                                         node-23.7.0/deps/cares/src/lib/cares.rc                                                             0000664 0000000 0000000 00000005014 14746647661 0017565 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2009 Daniel Stenberg
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include <winver.h>
#include "../../include/ares_version.h"

LANGUAGE  0x09,0x01

#define RC_VERSION  ARES_VERSION_MAJOR, ARES_VERSION_MINOR, ARES_VERSION_PATCH, 0

VS_VERSION_INFO VERSIONINFO
  FILEVERSION     RC_VERSION
  PRODUCTVERSION  RC_VERSION
  FILEFLAGSMASK   0x3fL
#if defined(DEBUGBUILD) || defined(_DEBUG)
  FILEFLAGS 1
#else
  FILEFLAGS 0
#endif
  FILEOS      VOS__WINDOWS32
  FILETYPE    VFT_DLL
  FILESUBTYPE 0x0L

BEGIN
  BLOCK "StringFileInfo"
  BEGIN
    BLOCK "040904b0"
    BEGIN
      VALUE "CompanyName",      "The c-ares library, https://c-ares.org/\0"
#if defined(DEBUGBUILD) || defined(_DEBUG)
      VALUE "FileDescription",  "c-ares Debug Shared Library\0"
      VALUE "FileVersion",      ARES_VERSION_STR "\0"
      VALUE "InternalName",     "c-ares\0"
      VALUE "OriginalFilename", "caresd.dll\0"
#else
      VALUE "FileDescription",  "c-ares Shared Library\0"
      VALUE "FileVersion",      ARES_VERSION_STR "\0"
      VALUE "InternalName",     "c-ares\0"
      VALUE "OriginalFilename", "cares.dll\0"
#endif
      VALUE "ProductName",      "The c-ares library\0"
      VALUE "ProductVersion",   ARES_VERSION_STR "\0"
      VALUE "LegalCopyright",   " " ARES_COPYRIGHT "\0"
      VALUE "License",          "https://c-ares.org/license.html\0"
    END
  END

  BLOCK "VarFileInfo"
  BEGIN
    VALUE "Translation", 0x409, 1200
  END
END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/cares/src/lib/config-dos.h                                                         0000664 0000000 0000000 00000007164 14746647661 0020353 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef HEADER_CONFIG_DOS_H
#define HEADER_CONFIG_DOS_H


/* ================================================================
 *       ares/config-dos.h - Hand crafted config file for DOS
 *
 * Copyright (C) The c-ares project and its contributors
 * SPDX-License-Identifier: MIT
 * ================================================================ */

#define PACKAGE "c-ares"

#define HAVE_ERRNO_H             1
#define HAVE_GETENV              1
#define HAVE_GETTIMEOFDAY        1
#define HAVE_IOCTLSOCKET         1
#define HAVE_IOCTLSOCKET_FIONBIO 1
#define HAVE_LIMITS_H            1
#define HAVE_NET_IF_H            1
#define HAVE_RECV                1
#define HAVE_RECVFROM            1
#define HAVE_SEND                1
#define HAVE_SENDTO              1
#define HAVE_STRDUP              1
#define HAVE_STRICMP             1
#define HAVE_STRUCT_IN6_ADDR     1
#define HAVE_STRUCT_TIMEVAL      1
#define HAVE_SYS_IOCTL_H         1
#define HAVE_SYS_SOCKET_H        1
#define HAVE_SYS_STAT_H          1
#define HAVE_SYS_TYPES_H         1
#define HAVE_TIME_H              1
#define HAVE_UNISTD_H            1
#define HAVE_WRITEV              1
#define HAVE_STAT                1
#define HAVE_MALLOC_H            1

/* Qualifiers for send(), recv(), recvfrom() and getnameinfo(). */

#define SEND_TYPE_ARG1 int
#define SEND_TYPE_ARG2 const void *
#define SEND_TYPE_ARG3 int
#define SEND_TYPE_ARG4 int
#define SEND_TYPE_RETV int

#define RECV_TYPE_ARG1 int
#define RECV_TYPE_ARG2 void *
#define RECV_TYPE_ARG3 int
#define RECV_TYPE_ARG4 int
#define RECV_TYPE_RETV int

#define RECVFROM_TYPE_ARG1         int
#define RECVFROM_TYPE_ARG2         void
#define RECVFROM_TYPE_ARG3         int
#define RECVFROM_TYPE_ARG4         int
#define RECVFROM_TYPE_ARG5         struct sockaddr
#define RECVFROM_TYPE_ARG6         int
#define RECVFROM_TYPE_RETV         int
#define RECVFROM_TYPE_ARG2_IS_VOID 1

#define BSD

/* Target HAVE_x section */

#if defined(DJGPP)
#  undef _SSIZE_T
#  include <sys/types.h> /* For 'ssize_t' */

#  define HAVE_STRCASECMP          1
#  define HAVE_STRNCASECMP         1
#  define HAVE_SYS_TIME_H          1
#  define HAVE_VARIADIC_MACROS_GCC 1

/* Because djgpp <= 2.03 doesn't have snprintf() etc. */
#  if defined(DJGPP_MINOR) && DJGPP_MINOR < 4
#    define _MPRINTF_REPLACE
#  endif

#elif defined(__WATCOMC__)
#  define HAVE_STRCASECMP 1

#elif defined(__HIGHC__)
#  define HAVE_SYS_TIME_H 1
#  define strerror(e)     strerror_s_((e))
#endif

/* This seems odd, can DOS build without WATT32? */
#ifdef WATT32
#  define HAVE_AF_INET6                          1
#  define HAVE_ARPA_INET_H                       1
#  define HAVE_ARPA_NAMESER_H                    1
#  define HAVE_CLOSE_S                           1
#  define HAVE_GETHOSTNAME                       1
#  define HAVE_NETDB_H                           1
#  define HAVE_NETINET_IN_H                      1
#  define HAVE_NETINET_TCP_H                     1
#  define HAVE_PF_INET6                          1
#  define HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID 1
#  define HAVE_STRUCT_ADDRINFO                   1
#  define HAVE_STRUCT_IN6_ADDR                   1
#  define HAVE_STRUCT_SOCKADDR_IN6               1
#  define HAVE_SYS_SOCKET_H                      1
#  define HAVE_SYS_IOCTL_H                       1
#  define HAVE_SYS_UIO_H                         1
#  define NS_INADDRSZ                            4
#  define HAVE_GETSERVBYPORT_R                   1
#  define GETSERVBYPORT_R_ARGS                   6
#  define HAVE_WRITEV                            1
#  define HAVE_IF_NAMETOINDEX                    1
#  define HAVE_IF_INDEXTONAME                    1
#endif

#endif /* HEADER_CONFIG_DOS_H */
                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/cares/src/lib/config-win32.h                                                       0000664 0000000 0000000 00000027742 14746647661 0020534 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2004 Daniel Stenberg
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef HEADER_CARES_CONFIG_WIN32_H
#define HEADER_CARES_CONFIG_WIN32_H

/* ================================================================ */
/*   c-ares/config-win32.h - Hand crafted config file for Windows   */
/* ================================================================ */

/* ---------------------------------------------------------------- */
/*                          HEADER FILES                            */
/* ---------------------------------------------------------------- */

/* Define if you have the <assert.h> header file. */
#define HAVE_ASSERT_H 1

/* Define if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define if you have the <getopt.h> header file. */
#if defined(__MINGW32__) || defined(__POCC__)
#  define HAVE_GETOPT_H 1
#endif

/* Define if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define if you have the <process.h> header file. */
#ifndef __SALFORDC__
#  define HAVE_PROCESS_H 1
#endif

/* Define if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define if you have the <sys/time.h> header file */
/* #define HAVE_SYS_TIME_H 1 */

/* Define if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define if you have the <unistd.h> header file. */
#if defined(__MINGW32__) || defined(__WATCOMC__) || defined(__LCC__) || \
  defined(__POCC__)
#  define HAVE_UNISTD_H 1
#endif

/* Define if you have the <windows.h> header file. */
#define HAVE_WINDOWS_H 1

/* Define if you have the <winsock.h> header file. */
#define HAVE_WINSOCK_H 1

/* Define if you have the <winsock2.h> header file. */
#ifndef __SALFORDC__
#  define HAVE_WINSOCK2_H 1
#endif

/* Define if you have the <ws2tcpip.h> header file. */
#ifndef __SALFORDC__
#  define HAVE_WS2TCPIP_H 1
#endif

/* Define if you have <iphlpapi.h> header file */
#define HAVE_IPHLPAPI_H 1

/* Define if you have <netioapi.h> header file */
#if !defined(__WATCOMC__) && !defined(WATT32)
#  define HAVE_NETIOAPI_H 1
#endif

#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_STAT_H  1

/* If we are building with OpenWatcom, we need to specify that we have
 * <stdint.h>. */
#if defined(__WATCOMC__)
#  define HAVE_STDINT_H
#endif

/* ---------------------------------------------------------------- */
/*                        OTHER HEADER INFO                         */
/* ---------------------------------------------------------------- */

/* Define if you have the ANSI C header files. */
#define STDC_HEADERS 1

/* ---------------------------------------------------------------- */
/*                             FUNCTIONS                            */
/* ---------------------------------------------------------------- */

/* Define if you have the closesocket function. */
#define HAVE_CLOSESOCKET 1

/* Define if you have the getenv function. */
#define HAVE_GETENV 1

/* Define if you have the gethostname function. */
#define HAVE_GETHOSTNAME 1

/* Define if you have the ioctlsocket function. */
#define HAVE_IOCTLSOCKET 1

/* Define if you have a working ioctlsocket FIONBIO function. */
#define HAVE_IOCTLSOCKET_FIONBIO 1

/* Define if you have the strcasecmp function. */
/* #define HAVE_STRCASECMP 1 */

/* Define if you have the strdup function. */
#define HAVE_STRDUP 1

/* Define if you have the stricmp function. */
#define HAVE_STRICMP 1

/* Define if you have the strncasecmp function. */
/* #define HAVE_STRNCASECMP 1 */

/* Define if you have the strnicmp function. */
#define HAVE_STRNICMP 1

/* Define if you have the recv function. */
#define HAVE_RECV 1

/* Define to the type of arg 1 for recv. */
#define RECV_TYPE_ARG1 SOCKET

/* Define to the type of arg 2 for recv. */
#define RECV_TYPE_ARG2 char *

/* Define to the type of arg 3 for recv. */
#define RECV_TYPE_ARG3 int

/* Define to the type of arg 4 for recv. */
#define RECV_TYPE_ARG4 int

/* Define to the function return type for recv. */
#define RECV_TYPE_RETV int

/* Define if you have the recvfrom function. */
#define HAVE_RECVFROM 1

/* Define to the type of arg 1 for recvfrom. */
#define RECVFROM_TYPE_ARG1 SOCKET

/* Define to the type pointed by arg 2 for recvfrom. */
#define RECVFROM_TYPE_ARG2 char

/* Define to the type of arg 3 for recvfrom. */
#define RECVFROM_TYPE_ARG3 int

/* Define to the type of arg 4 for recvfrom. */
#define RECVFROM_TYPE_ARG4 int

/* Define to the type pointed by arg 5 for recvfrom. */
#define RECVFROM_TYPE_ARG5 struct sockaddr

/* Define to the type pointed by arg 6 for recvfrom. */
#define RECVFROM_TYPE_ARG6 int

/* Define to the function return type for recvfrom. */
#define RECVFROM_TYPE_RETV int

/* Define if you have the send function. */
#define HAVE_SEND 1

/* Define if you have the sendto function. */
#define HAVE_SENDTO 1

/* Define to the type of arg 1 for send. */
#define SEND_TYPE_ARG1 SOCKET

/* Define to the type of arg 2 for send. */
#define SEND_TYPE_ARG2 const char *

/* Define to the type of arg 3 for send. */
#define SEND_TYPE_ARG3 int

/* Define to the type of arg 4 for send. */
#define SEND_TYPE_ARG4 int

/* Define to the function return type for send. */
#define SEND_TYPE_RETV int

/* Specifics for the Watt-32 tcp/ip stack. */
#ifdef WATT32
#  undef RECV_TYPE_ARG1
#  define RECV_TYPE_ARG1 int
#  undef SEND_TYPE_ARG1
#  define SEND_TYPE_ARG1 int
#  undef RECVFROM_TYPE_ARG1
#  define RECVFROM_TYPE_ARG1       int
#  define NS_INADDRSZ              4
#  define HAVE_ARPA_NAMESER_H      1
#  define HAVE_ARPA_INET_H         1
#  define HAVE_NETDB_H             1
#  define HAVE_NETINET_IN_H        1
#  define HAVE_SYS_SOCKET_H        1
#  define HAVE_SYS_IOCTL_H         1
#  define HAVE_NETINET_TCP_H       1
#  define HAVE_AF_INET6            1
#  define HAVE_PF_INET6            1
#  define HAVE_STRUCT_IN6_ADDR     1
#  define HAVE_STRUCT_SOCKADDR_IN6 1
#  define HAVE_WRITEV              1
#  define HAVE_IF_NAMETOINDEX      1
#  define HAVE_IF_INDEXTONAME      1
#  define HAVE_GETSERVBYPORT_R     1
#  define GETSERVBYPORT_R_ARGS     6
#  undef HAVE_WINSOCK_H
#  undef HAVE_WINSOCK2_H
#  undef HAVE_WS2TCPIP_H
#  undef HAVE_IPHLPAPI_H
#  undef HAVE_NETIOAPI_H
#endif

/* Threading support enabled */
#define CARES_THREADS 1

/* ---------------------------------------------------------------- */
/*                       TYPEDEF REPLACEMENTS                       */
/* ---------------------------------------------------------------- */

/* ---------------------------------------------------------------- */
/*                            TYPE SIZES                            */
/* ---------------------------------------------------------------- */

/* ---------------------------------------------------------------- */
/*                          STRUCT RELATED                          */
/* ---------------------------------------------------------------- */

/* Define if you have struct addrinfo. */
#define HAVE_STRUCT_ADDRINFO 1

/* Define if you have struct sockaddr_storage. */
#if !defined(__SALFORDC__) && !defined(__BORLANDC__)
#  define HAVE_STRUCT_SOCKADDR_STORAGE 1
#endif

/* Define if you have struct timeval. */
#define HAVE_STRUCT_TIMEVAL 1

/* ---------------------------------------------------------------- */
/*                        COMPILER SPECIFIC                         */
/* ---------------------------------------------------------------- */

/* Define to avoid VS2005 complaining about portable C functions. */
#if defined(_MSC_VER) && (_MSC_VER >= 1400)
#  define _CRT_SECURE_NO_DEPRECATE  1
#  define _CRT_NONSTDC_NO_DEPRECATE 1
#endif

/* Set the Target to Win8 */
#if defined(_MSC_VER) && (_MSC_VER >= 1500)
#  define MSVC_MIN_TARGET 0x0602
#endif

/* MSVC default target settings */
#if defined(_MSC_VER) && (_MSC_VER >= 1500)
#  ifndef _WIN32_WINNT
#    define _WIN32_WINNT MSVC_MIN_TARGET
#  endif
#  ifndef WINVER
#    define WINVER MSVC_MIN_TARGET
#  endif
#endif

/* When no build target is specified Pelles C 5.00 and later default build
   target is Windows Vista. */
#if defined(__POCC__) && (__POCC__ >= 500)
#  ifndef _WIN32_WINNT
#    define _WIN32_WINNT 0x0602
#  endif
#  ifndef WINVER
#    define WINVER 0x0602
#  endif
#endif

/* Availability of freeaddrinfo, getaddrinfo and getnameinfo functions is
   quite convoluted, compiler dependent and even build target dependent. */
#if defined(HAVE_WS2TCPIP_H)
#  if defined(__POCC__)
#    define HAVE_FREEADDRINFO 1
#    define HAVE_GETADDRINFO  1
#    define HAVE_GETNAMEINFO  1
#  elif defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0501)
#    define HAVE_FREEADDRINFO 1
#    define HAVE_GETADDRINFO  1
#    define HAVE_GETNAMEINFO  1
#  elif defined(_MSC_VER) && (_MSC_VER >= 1200)
#    define HAVE_FREEADDRINFO 1
#    define HAVE_GETADDRINFO  1
#    define HAVE_GETNAMEINFO  1
#  endif
#endif

#if defined(__POCC__)
#  ifndef _MSC_VER
#    error Microsoft extensions /Ze compiler option is required
#  endif
#  ifndef __POCC__OLDNAMES
#    error Compatibility names /Go compiler option is required
#  endif
#endif

/* ---------------------------------------------------------------- */
/*                         IPV6 COMPATIBILITY                       */
/* ---------------------------------------------------------------- */

/* Define if you have address family AF_INET6. */
#ifdef HAVE_WINSOCK2_H
#  define HAVE_AF_INET6 1
#endif

/* Define if you have protocol family PF_INET6. */
#ifdef HAVE_WINSOCK2_H
#  define HAVE_PF_INET6 1
#endif

/* Define if you have struct in6_addr. */
#ifdef HAVE_WS2TCPIP_H
#  define HAVE_STRUCT_IN6_ADDR 1
#endif

/* Define if you have struct sockaddr_in6. */
#ifdef HAVE_WS2TCPIP_H
#  define HAVE_STRUCT_SOCKADDR_IN6 1
#endif

/* Define if you have sockaddr_in6 with scopeid. */
#ifdef HAVE_WS2TCPIP_H
#  define HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID 1
#endif

/* Define to 1 if you have the `RegisterWaitForSingleObject' function. */
#define HAVE_REGISTERWAITFORSINGLEOBJECT 1

#if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0600) && \
  !defined(__WATCOMC__) && !defined(WATT32)
/* Define if you have if_nametoindex() */
#  define HAVE_IF_NAMETOINDEX 1
/* Define if you have if_indextoname() */
#  define HAVE_IF_INDEXTONAME 1
/* Define to 1 if you have the `ConvertInterfaceIndexToLuid' function. */
#  define HAVE_CONVERTINTERFACEINDEXTOLUID 1
/* Define to 1 if you have the `ConvertInterfaceLuidToNameA' function. */
#  define HAVE_CONVERTINTERFACELUIDTONAMEA 1
/* Define to 1 if you have the `NotifyIpInterfaceChange' function. */
#  define HAVE_NOTIFYIPINTERFACECHANGE 1
#endif

/* ---------------------------------------------------------------- */
/*                              Win CE                              */
/* ---------------------------------------------------------------- */

/* FIXME: A proper config-win32ce.h should be created to hold these */

/*
 *  System error codes for Windows CE
 */

#if defined(_WIN32_WCE) && !defined(HAVE_ERRNO_H)
#  define ENOENT ERROR_FILE_NOT_FOUND
#  define ESRCH  ERROR_PATH_NOT_FOUND
#  define ENOMEM ERROR_NOT_ENOUGH_MEMORY
#  define ENOSPC ERROR_INVALID_PARAMETER
#endif

#endif /* HEADER_CARES_CONFIG_WIN32_H */
                              node-23.7.0/deps/cares/src/lib/dsa/                                                                 0000775 0000000 0000000 00000000000 14746647661 0016711 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/dsa/ares_array.c                                                     0000664 0000000 0000000 00000023015 14746647661 0021206 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_array.h"

#define ARES__ARRAY_MIN 4

struct ares_array {
  ares_array_destructor_t destruct;
  void                   *arr;
  size_t                  member_size;
  size_t                  cnt;
  size_t                  offset;
  size_t                  alloc_cnt;
};

ares_array_t *ares_array_create(size_t                  member_size,
                                ares_array_destructor_t destruct)
{
  ares_array_t *arr;

  if (member_size == 0) {
    return NULL;
  }

  arr = ares_malloc_zero(sizeof(*arr));
  if (arr == NULL) {
    return NULL;
  }

  arr->member_size = member_size;
  arr->destruct    = destruct;
  return arr;
}

size_t ares_array_len(const ares_array_t *arr)
{
  if (arr == NULL) {
    return 0;
  }
  return arr->cnt;
}

void *ares_array_at(ares_array_t *arr, size_t idx)
{
  if (arr == NULL || idx >= arr->cnt) {
    return NULL;
  }
  return (unsigned char *)arr->arr + ((idx + arr->offset) * arr->member_size);
}

const void *ares_array_at_const(const ares_array_t *arr, size_t idx)
{
  if (arr == NULL || idx >= arr->cnt) {
    return NULL;
  }
  return (unsigned char *)arr->arr + ((idx + arr->offset) * arr->member_size);
}

ares_status_t ares_array_sort(ares_array_t *arr, ares_array_cmp_t cmp)
{
  if (arr == NULL || cmp == NULL) {
    return ARES_EFORMERR;
  }

  /* Nothing to sort */
  if (arr->cnt < 2) {
    return ARES_SUCCESS;
  }

  qsort((unsigned char *)arr->arr + (arr->offset * arr->member_size), arr->cnt,
        arr->member_size, cmp);
  return ARES_SUCCESS;
}

void ares_array_destroy(ares_array_t *arr)
{
  size_t i;

  if (arr == NULL) {
    return;
  }

  if (arr->destruct != NULL) {
    for (i = 0; i < arr->cnt; i++) {
      arr->destruct(ares_array_at(arr, i));
    }
  }

  ares_free(arr->arr);
  ares_free(arr);
}

/* NOTE: this function operates on actual indexes, NOT indexes using the
 *       arr->offset */
static ares_status_t ares_array_move(ares_array_t *arr, size_t dest_idx,
                                     size_t src_idx)
{
  void       *dest_ptr;
  const void *src_ptr;
  size_t      nmembers;

  if (arr == NULL || dest_idx >= arr->alloc_cnt || src_idx >= arr->alloc_cnt) {
    return ARES_EFORMERR;
  }

  /* Nothing to do */
  if (dest_idx == src_idx) {
    return ARES_SUCCESS;
  }

  dest_ptr = (unsigned char *)arr->arr + (dest_idx * arr->member_size);
  src_ptr  = (unsigned char *)arr->arr + (src_idx * arr->member_size);

  /* Check to make sure shifting to the right won't overflow our allocation
   * boundary */
  if (dest_idx > src_idx && arr->cnt + (dest_idx - src_idx) > arr->alloc_cnt) {
    return ARES_EFORMERR;
  }

  nmembers = arr->cnt - (src_idx - arr->offset);
  memmove(dest_ptr, src_ptr, nmembers * arr->member_size);

  return ARES_SUCCESS;
}

void *ares_array_finish(ares_array_t *arr, size_t *num_members)
{
  void *ptr;

  if (arr == NULL || num_members == NULL) {
    return NULL;
  }

  /* Make sure we move data to beginning of allocation */
  if (arr->offset != 0) {
    if (ares_array_move(arr, 0, arr->offset) != ARES_SUCCESS) {
      return NULL;
    }
    arr->offset = 0;
  }

  ptr          = arr->arr;
  *num_members = arr->cnt;
  ares_free(arr);
  return ptr;
}

ares_status_t ares_array_set_size(ares_array_t *arr, size_t size)
{
  void *temp;

  if (arr == NULL || size == 0 || size < arr->cnt) {
    return ARES_EFORMERR;
  }

  /* Always operate on powers of 2 */
  size = ares_round_up_pow2(size);

  if (size < ARES__ARRAY_MIN) {
    size = ARES__ARRAY_MIN;
  }

  /* If our allocation size is already large enough, skip */
  if (size <= arr->alloc_cnt) {
    return ARES_SUCCESS;
  }

  temp = ares_realloc_zero(arr->arr, arr->alloc_cnt * arr->member_size,
                           size * arr->member_size);
  if (temp == NULL) {
    return ARES_ENOMEM;
  }
  arr->alloc_cnt = size;
  arr->arr       = temp;
  return ARES_SUCCESS;
}

ares_status_t ares_array_insert_at(void **elem_ptr, ares_array_t *arr,
                                   size_t idx)
{
  void         *ptr;
  ares_status_t status;

  if (arr == NULL) {
    return ARES_EFORMERR;
  }

  /* Not >= since we are allowed to append to the end */
  if (idx > arr->cnt) {
    return ARES_EFORMERR;
  }

  /* Allocate more if needed */
  status = ares_array_set_size(arr, arr->cnt + 1);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Shift if we have memory but not enough room at the end */
  if (arr->cnt + 1 + arr->offset > arr->alloc_cnt) {
    status = ares_array_move(arr, 0, arr->offset);
    if (status != ARES_SUCCESS) {
      return status;
    }
    arr->offset = 0;
  }

  /* If we're inserting anywhere other than the end, we need to move some
   * elements out of the way */
  if (idx != arr->cnt) {
    status = ares_array_move(arr, idx + arr->offset + 1, idx + arr->offset);
    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  /* Ok, we're guaranteed to have a gap where we need it, lets zero it out,
   * and return it */
  ptr = (unsigned char *)arr->arr + ((idx + arr->offset) * arr->member_size);
  memset(ptr, 0, arr->member_size);
  arr->cnt++;

  if (elem_ptr) {
    *elem_ptr = ptr;
  }

  return ARES_SUCCESS;
}

ares_status_t ares_array_insert_last(void **elem_ptr, ares_array_t *arr)
{
  return ares_array_insert_at(elem_ptr, arr, ares_array_len(arr));
}

ares_status_t ares_array_insert_first(void **elem_ptr, ares_array_t *arr)
{
  return ares_array_insert_at(elem_ptr, arr, 0);
}

ares_status_t ares_array_insertdata_at(ares_array_t *arr, size_t idx,
                                       const void *data_ptr)
{
  ares_status_t status;
  void         *ptr = NULL;

  status = ares_array_insert_at(&ptr, arr, idx);
  if (status != ARES_SUCCESS) {
    return status;
  }
  memcpy(ptr, data_ptr, arr->member_size);
  return ARES_SUCCESS;
}

ares_status_t ares_array_insertdata_last(ares_array_t *arr,
                                         const void   *data_ptr)
{
  ares_status_t status;
  void         *ptr = NULL;

  status = ares_array_insert_last(&ptr, arr);
  if (status != ARES_SUCCESS) {
    return status;
  }
  memcpy(ptr, data_ptr, arr->member_size);
  return ARES_SUCCESS;
}

ares_status_t ares_array_insertdata_first(ares_array_t *arr,
                                          const void   *data_ptr)
{
  ares_status_t status;
  void         *ptr = NULL;

  status = ares_array_insert_last(&ptr, arr);
  if (status != ARES_SUCCESS) {
    return status;
  }
  memcpy(ptr, data_ptr, arr->member_size);
  return ARES_SUCCESS;
}

void *ares_array_first(ares_array_t *arr)
{
  return ares_array_at(arr, 0);
}

void *ares_array_last(ares_array_t *arr)
{
  size_t cnt = ares_array_len(arr);
  if (cnt == 0) {
    return NULL;
  }
  return ares_array_at(arr, cnt - 1);
}

const void *ares_array_first_const(const ares_array_t *arr)
{
  return ares_array_at_const(arr, 0);
}

const void *ares_array_last_const(const ares_array_t *arr)
{
  size_t cnt = ares_array_len(arr);
  if (cnt == 0) {
    return NULL;
  }
  return ares_array_at_const(arr, cnt - 1);
}

ares_status_t ares_array_claim_at(void *dest, size_t dest_size,
                                  ares_array_t *arr, size_t idx)
{
  ares_status_t status;

  if (arr == NULL || idx >= arr->cnt) {
    return ARES_EFORMERR;
  }

  if (dest != NULL && dest_size < arr->member_size) {
    return ARES_EFORMERR;
  }

  if (dest) {
    memcpy(dest, ares_array_at(arr, idx), arr->member_size);
  }

  if (idx == 0) {
    /* Optimization, if first element, just increment offset, makes removing a
     * lot from the start quick */
    arr->offset++;
  } else if (idx != arr->cnt - 1) {
    /* Must shift entire array if removing an element from the middle. Does
     * nothing if removing last element other than decrement count. */
    status = ares_array_move(arr, idx + arr->offset, idx + arr->offset + 1);
    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  arr->cnt--;
  return ARES_SUCCESS;
}

ares_status_t ares_array_remove_at(ares_array_t *arr, size_t idx)
{
  void *ptr = ares_array_at(arr, idx);
  if (arr == NULL || ptr == NULL) {
    return ARES_EFORMERR;
  }

  if (arr->destruct != NULL) {
    arr->destruct(ptr);
  }

  return ares_array_claim_at(NULL, 0, arr, idx);
}

ares_status_t ares_array_remove_first(ares_array_t *arr)
{
  return ares_array_remove_at(arr, 0);
}

ares_status_t ares_array_remove_last(ares_array_t *arr)
{
  size_t cnt = ares_array_len(arr);
  if (cnt == 0) {
    return ARES_EFORMERR;
  }
  return ares_array_remove_at(arr, cnt - 1);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/cares/src/lib/dsa/ares_htable.c                                                    0000664 0000000 0000000 00000031524 14746647661 0021333 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_llist.h"
#include "ares_htable.h"

#define ARES__HTABLE_MAX_BUCKETS    (1U << 24)
#define ARES__HTABLE_MIN_BUCKETS    (1U << 4)
#define ARES__HTABLE_EXPAND_PERCENT 75

struct ares_htable {
  ares_htable_hashfunc_t    hash;
  ares_htable_bucket_key_t  bucket_key;
  ares_htable_bucket_free_t bucket_free;
  ares_htable_key_eq_t      key_eq;
  unsigned int              seed;
  unsigned int              size;
  size_t                    num_keys;
  size_t                    num_collisions;
  /* NOTE: if we converted buckets into ares_slist_t we could guarantee on
   *       hash collisions we would have O(log n) worst case insert and search
   *       performance.  (We'd also need to make key_eq into a key_cmp to
   *       support sort).  That said, risk with a random hash seed is near zero,
   *       and ares_slist_t is heavier weight, so I think using ares_llist_t
   *       is an overall win. */
  ares_llist_t            **buckets;
};

static unsigned int ares_htable_generate_seed(ares_htable_t *htable)
{
#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  /* Seed needs to be static for fuzzing */
  return 0;
#else
  unsigned int seed = 0;
  time_t       t    = time(NULL);

  /* Mix stack address, heap address, and time to generate a random seed, it
   * doesn't have to be super secure, just quick.  Likelihood of a hash
   * collision attack is very low with a small amount of effort */
  seed |= (unsigned int)((size_t)htable & 0xFFFFFFFF);
  seed |= (unsigned int)((size_t)&seed & 0xFFFFFFFF);
  seed |= (unsigned int)(((ares_uint64_t)t) & 0xFFFFFFFF);
  return seed;
#endif
}

static void ares_htable_buckets_destroy(ares_llist_t **buckets,
                                        unsigned int   size,
                                        ares_bool_t    destroy_vals)
{
  unsigned int i;

  if (buckets == NULL) {
    return;
  }

  for (i = 0; i < size; i++) {
    if (buckets[i] == NULL) {
      continue;
    }

    if (!destroy_vals) {
      ares_llist_replace_destructor(buckets[i], NULL);
    }

    ares_llist_destroy(buckets[i]);
  }

  ares_free(buckets);
}

void ares_htable_destroy(ares_htable_t *htable)
{
  if (htable == NULL) {
    return;
  }
  ares_htable_buckets_destroy(htable->buckets, htable->size, ARES_TRUE);
  ares_free(htable);
}

ares_htable_t *ares_htable_create(ares_htable_hashfunc_t    hash_func,
                                  ares_htable_bucket_key_t  bucket_key,
                                  ares_htable_bucket_free_t bucket_free,
                                  ares_htable_key_eq_t      key_eq)
{
  ares_htable_t *htable = NULL;

  if (hash_func == NULL || bucket_key == NULL || bucket_free == NULL ||
      key_eq == NULL) {
    goto fail;
  }

  htable = ares_malloc_zero(sizeof(*htable));
  if (htable == NULL) {
    goto fail;
  }

  htable->hash        = hash_func;
  htable->bucket_key  = bucket_key;
  htable->bucket_free = bucket_free;
  htable->key_eq      = key_eq;
  htable->seed        = ares_htable_generate_seed(htable);
  htable->size        = ARES__HTABLE_MIN_BUCKETS;
  htable->buckets = ares_malloc_zero(sizeof(*htable->buckets) * htable->size);

  if (htable->buckets == NULL) {
    goto fail;
  }

  return htable;

fail:
  ares_htable_destroy(htable);
  return NULL;
}

const void **ares_htable_all_buckets(const ares_htable_t *htable, size_t *num)
{
  const void **out = NULL;
  size_t       cnt = 0;
  size_t       i;

  if (htable == NULL || num == NULL) {
    return NULL; /* LCOV_EXCL_LINE */
  }

  *num = 0;

  out = ares_malloc_zero(sizeof(*out) * htable->num_keys);
  if (out == NULL) {
    return NULL; /* LCOV_EXCL_LINE */
  }

  for (i = 0; i < htable->size; i++) {
    ares_llist_node_t *node;
    for (node = ares_llist_node_first(htable->buckets[i]); node != NULL;
         node = ares_llist_node_next(node)) {
      out[cnt++] = ares_llist_node_val(node);
    }
  }

  *num = cnt;
  return out;
}

/*! Grabs the Hashtable index from the key and length.  The h index is
 *  the hash of the function reduced to the size of the bucket list.
 *  We are doing "hash & (size - 1)" since we are guaranteeing a power of
 *  2 for size. This is equivalent to "hash % size", but should be more
 * efficient */
#define HASH_IDX(h, key) h->hash(key, h->seed) & (h->size - 1)

static ares_llist_node_t *ares_htable_find(const ares_htable_t *htable,
                                           unsigned int idx, const void *key)
{
  ares_llist_node_t *node = NULL;

  for (node = ares_llist_node_first(htable->buckets[idx]); node != NULL;
       node = ares_llist_node_next(node)) {
    if (htable->key_eq(key, htable->bucket_key(ares_llist_node_val(node)))) {
      break;
    }
  }

  return node;
}

static ares_bool_t ares_htable_expand(ares_htable_t *htable)
{
  ares_llist_t **buckets  = NULL;
  unsigned int   old_size = htable->size;
  size_t         i;
  ares_llist_t **prealloc_llist     = NULL;
  size_t         prealloc_llist_len = 0;
  ares_bool_t    rv                 = ARES_FALSE;

  /* Not a failure, just won't expand */
  if (old_size == ARES__HTABLE_MAX_BUCKETS) {
    return ARES_TRUE; /* LCOV_EXCL_LINE */
  }

  htable->size <<= 1;

  /* We must pre-allocate all memory we'll need before moving entries to the
   * new hash array.  Otherwise if there's a memory allocation failure in the
   * middle, we wouldn't be able to recover. */
  buckets = ares_malloc_zero(sizeof(*buckets) * htable->size);
  if (buckets == NULL) {
    goto done; /* LCOV_EXCL_LINE */
  }

  /* The maximum number of new llists we'll need is the number of collisions
   * that were recorded */
  prealloc_llist_len = htable->num_collisions;
  if (prealloc_llist_len) {
    prealloc_llist =
      ares_malloc_zero(sizeof(*prealloc_llist) * prealloc_llist_len);
    if (prealloc_llist == NULL) {
      goto done; /* LCOV_EXCL_LINE */
    }
  }
  for (i = 0; i < prealloc_llist_len; i++) {
    prealloc_llist[i] = ares_llist_create(htable->bucket_free);
    if (prealloc_llist[i] == NULL) {
      goto done;
    }
  }

  /* Iterate across all buckets and move the entries to the new buckets */
  htable->num_collisions = 0;
  for (i = 0; i < old_size; i++) {
    ares_llist_node_t *node;

    /* Nothing in this bucket */
    if (htable->buckets[i] == NULL) {
      continue;
    }

    /* Fast path optimization (most likely case), there is likely only a single
     * entry in both the source and destination, check for this to confirm and
     * if so, just move the bucket over */
    if (ares_llist_len(htable->buckets[i]) == 1) {
      const void *val = ares_llist_first_val(htable->buckets[i]);
      size_t      idx = HASH_IDX(htable, htable->bucket_key(val));

      if (buckets[idx] == NULL) {
        /* Swap! */
        buckets[idx]       = htable->buckets[i];
        htable->buckets[i] = NULL;
        continue;
      }
    }

    /* Slow path, collisions */
    while ((node = ares_llist_node_first(htable->buckets[i])) != NULL) {
      const void *val = ares_llist_node_val(node);
      size_t      idx = HASH_IDX(htable, htable->bucket_key(val));

      /* Try fast path again as maybe we popped one collision off and the
       * next we can reuse the llist parent */
      if (buckets[idx] == NULL && ares_llist_len(htable->buckets[i]) == 1) {
        /* Swap! */
        buckets[idx]       = htable->buckets[i];
        htable->buckets[i] = NULL;
        break;
      }

      /* Grab one off our preallocated list */
      if (buckets[idx] == NULL) {
        /* Silence static analysis, this isn't possible but it doesn't know */
        if (prealloc_llist == NULL || prealloc_llist_len == 0) {
          goto done; /* LCOV_EXCL_LINE */
        }
        buckets[idx] = prealloc_llist[prealloc_llist_len - 1];
        prealloc_llist_len--;
      } else {
        /* Collision occurred since the bucket wasn't empty */
        htable->num_collisions++;
      }

      ares_llist_node_mvparent_first(node, buckets[idx]);
    }

    /* Abandoned bucket, destroy */
    if (htable->buckets[i] != NULL) {
      ares_llist_destroy(htable->buckets[i]);
      htable->buckets[i] = NULL;
    }
  }

  /* We have guaranteed all the buckets have either been moved or destroyed,
   * so we just call ares_free() on the array and swap out the pointer */
  ares_free(htable->buckets);
  htable->buckets = buckets;
  buckets         = NULL;
  rv              = ARES_TRUE;

done:
  ares_free(buckets);
  /* destroy any unused preallocated buckets */
  ares_htable_buckets_destroy(prealloc_llist, (unsigned int)prealloc_llist_len,
                              ARES_FALSE);

  /* On failure, we need to restore the htable size */
  if (rv != ARES_TRUE) {
    htable->size = old_size; /* LCOV_EXCL_LINE */
  }

  return rv;
}

ares_bool_t ares_htable_insert(ares_htable_t *htable, void *bucket)
{
  unsigned int       idx  = 0;
  ares_llist_node_t *node = NULL;
  const void        *key  = NULL;

  if (htable == NULL || bucket == NULL) {
    return ARES_FALSE;
  }


  key = htable->bucket_key(bucket);
  idx = HASH_IDX(htable, key);

  /* See if we have a matching bucket already, if so, replace it */
  node = ares_htable_find(htable, idx, key);
  if (node != NULL) {
    ares_llist_node_replace(node, bucket);
    return ARES_TRUE;
  }

  /* Check to see if we should rehash because likelihood of collisions has
   * increased beyond our threshold */
  if (htable->num_keys + 1 >
      (htable->size * ARES__HTABLE_EXPAND_PERCENT) / 100) {
    if (!ares_htable_expand(htable)) {
      return ARES_FALSE; /* LCOV_EXCL_LINE */
    }
    /* If we expanded, need to calculate a new index */
    idx = HASH_IDX(htable, key);
  }

  /* We lazily allocate the linked list */
  if (htable->buckets[idx] == NULL) {
    htable->buckets[idx] = ares_llist_create(htable->bucket_free);
    if (htable->buckets[idx] == NULL) {
      return ARES_FALSE;
    }
  }

  node = ares_llist_insert_first(htable->buckets[idx], bucket);
  if (node == NULL) {
    return ARES_FALSE;
  }

  /* Track collisions for rehash stability */
  if (ares_llist_len(htable->buckets[idx]) > 1) {
    htable->num_collisions++;
  }

  htable->num_keys++;

  return ARES_TRUE;
}

void *ares_htable_get(const ares_htable_t *htable, const void *key)
{
  unsigned int idx;

  if (htable == NULL || key == NULL) {
    return NULL;
  }

  idx = HASH_IDX(htable, key);

  return ares_llist_node_val(ares_htable_find(htable, idx, key));
}

ares_bool_t ares_htable_remove(ares_htable_t *htable, const void *key)
{
  ares_llist_node_t *node;
  unsigned int       idx;

  if (htable == NULL || key == NULL) {
    return ARES_FALSE;
  }

  idx  = HASH_IDX(htable, key);
  node = ares_htable_find(htable, idx, key);
  if (node == NULL) {
    return ARES_FALSE;
  }

  htable->num_keys--;

  /* Reduce collisions */
  if (ares_llist_len(ares_llist_node_parent(node)) > 1) {
    htable->num_collisions--;
  }

  ares_llist_node_destroy(node);
  return ARES_TRUE;
}

size_t ares_htable_num_keys(const ares_htable_t *htable)
{
  if (htable == NULL) {
    return 0;
  }
  return htable->num_keys;
}

unsigned int ares_htable_hash_FNV1a(const unsigned char *key, size_t key_len,
                                    unsigned int seed)
{
  unsigned int hv = seed ^ 2166136261U;
  size_t       i;

  for (i = 0; i < key_len; i++) {
    hv ^= (unsigned int)key[i];
    /* hv *= 16777619 (0x01000193) */
    hv += (hv << 1) + (hv << 4) + (hv << 7) + (hv << 8) + (hv << 24);
  }

  return hv;
}

/* Case insensitive version, meant for ASCII strings */
unsigned int ares_htable_hash_FNV1a_casecmp(const unsigned char *key,
                                            size_t key_len, unsigned int seed)
{
  unsigned int hv = seed ^ 2166136261U;
  size_t       i;

  for (i = 0; i < key_len; i++) {
    hv ^= (unsigned int)ares_tolower(key[i]);
    /* hv *= 16777619 (0x01000193) */
    hv += (hv << 1) + (hv << 4) + (hv << 7) + (hv << 8) + (hv << 24);
  }

  return hv;
}
                                                                                                                                                                            node-23.7.0/deps/cares/src/lib/dsa/ares_htable.h                                                    0000664 0000000 0000000 00000014565 14746647661 0021346 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__HTABLE_H
#define __ARES__HTABLE_H


/*! \addtogroup ares_htable Base HashTable Data Structure
 *
 * This is a basic hashtable data structure that is meant to be wrapped
 * by a higher level implementation.  This data structure is designed to
 * be callback-based in order to facilitate wrapping without needing to
 * worry about any underlying complexities of the hashtable implementation.
 *
 * This implementation supports automatic growing by powers of 2 when reaching
 * 75% capacity.  A rehash will be performed on the expanded bucket list.
 *
 * Average time complexity:
 *  - Insert: O(1)
 *  - Search: O(1)
 *  - Delete: O(1)
 *
 * @{
 */

struct ares_htable;

/*! Opaque data type for generic hash table implementation */
typedef struct ares_htable ares_htable_t;

/*! Callback for generating a hash of the key.
 *
 *  \param[in] key   pointer to key to be hashed
 *  \param[in] seed  randomly generated seed used by hash function.
 *                   value is specific to the hashtable instance
 *                   but otherwise will not change between calls.
 *  \return hash
 */
typedef unsigned int (*ares_htable_hashfunc_t)(const void  *key,
                                               unsigned int seed);

/*! Callback to free the bucket
 *
 *  \param[in] bucket  user provided bucket
 */
typedef void (*ares_htable_bucket_free_t)(void *bucket);

/*! Callback to extract the key from the user-provided bucket
 *
 *  \param[in] bucket  user provided bucket
 *  \return pointer to key held in bucket
 */
typedef const void *(*ares_htable_bucket_key_t)(const void *bucket);

/*! Callback to compare two keys for equality
 *
 *  \param[in] key1  first key
 *  \param[in] key2  second key
 *  \return ARES_TRUE if equal, ARES_FALSE if not
 */
typedef ares_bool_t (*ares_htable_key_eq_t)(const void *key1, const void *key2);


/*! Destroy the initialized hashtable
 *
 *  \param[in] htable initialized hashtable
 */
void           ares_htable_destroy(ares_htable_t *htable);

/*! Create a new hashtable
 *
 *  \param[in] hash_func   Required. Callback for Hash function.
 *  \param[in] bucket_key  Required. Callback to extract key from bucket.
 *  \param[in] bucket_free Required. Callback to free bucket.
 *  \param[in] key_eq      Required. Callback to check for key equality.
 *  \return initialized hashtable.  NULL if out of memory or misuse.
 */
ares_htable_t *ares_htable_create(ares_htable_hashfunc_t    hash_func,
                                  ares_htable_bucket_key_t  bucket_key,
                                  ares_htable_bucket_free_t bucket_free,
                                  ares_htable_key_eq_t      key_eq);

/*! Count of keys from initialized hashtable
 *
 *  \param[in] htable  Initialized hashtable.
 *  \return count of keys
 */
size_t         ares_htable_num_keys(const ares_htable_t *htable);

/*! Retrieve an array of buckets from the hashtable.  This is mainly used as
 *  a helper for retrieving an array of keys.
 *
 *  \param[in]  htable   Initialized hashtable
 *  \param[out] num      Count of returned buckets
 *  \return Array of pointers to the buckets.  These are internal pointers
 *          to data within the hashtable, so if the key is removed, there
 *          will be a dangling pointer.  It is expected wrappers will make
 *          such values safe by duplicating them.
 */
const void **ares_htable_all_buckets(const ares_htable_t *htable, size_t *num);

/*! Insert bucket into hashtable
 *
 *  \param[in] htable  Initialized hashtable.
 *  \param[in] bucket  User-provided bucket to insert. Takes "ownership". Not
 *                     allowed to be NULL.
 *  \return ARES_TRUE on success, ARES_FALSE if out of memory
 */
ares_bool_t  ares_htable_insert(ares_htable_t *htable, void *bucket);

/*! Retrieve bucket from hashtable based on key.
 *
 *  \param[in] htable  Initialized hashtable
 *  \param[in] key     Pointer to key to use for comparison.
 *  \return matching bucket, or NULL if not found.
 */
void        *ares_htable_get(const ares_htable_t *htable, const void *key);

/*! Remove bucket from hashtable by key
 *
 *  \param[in] htable  Initialized hashtable
 *  \param[in] key     Pointer to key to use for comparison
 *  \return ARES_TRUE if found, ARES_FALSE if not found
 */
ares_bool_t  ares_htable_remove(ares_htable_t *htable, const void *key);

/*! FNV1a hash algorithm.  Can be used as underlying primitive for building
 *  a wrapper hashtable.
 *
 *  \param[in] key      pointer to key
 *  \param[in] key_len  Length of key
 *  \param[in] seed     Seed for generating hash
 *  \return hash value
 */
unsigned int ares_htable_hash_FNV1a(const unsigned char *key, size_t key_len,
                                    unsigned int seed);

/*! FNV1a hash algorithm, but converts all characters to lowercase before
 *  hashing to make the hash case-insensitive. Can be used as underlying
 *  primitive for building a wrapper hashtable.  Used on string-based keys.
 *
 *  \param[in] key      pointer to key
 *  \param[in] key_len  Length of key
 *  \param[in] seed     Seed for generating hash
 *  \return hash value
 */
unsigned int ares_htable_hash_FNV1a_casecmp(const unsigned char *key,
                                            size_t key_len, unsigned int seed);

/*! @} */

#endif /* __ARES__HTABLE_H */
                                                                                                                                           node-23.7.0/deps/cares/src/lib/dsa/ares_htable_asvp.c                                               0000664 0000000 0000000 00000012362 14746647661 0022363 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_htable.h"
#include "ares_htable_asvp.h"

struct ares_htable_asvp {
  ares_htable_asvp_val_free_t free_val;
  ares_htable_t              *hash;
};

typedef struct {
  ares_socket_t       key;
  void               *val;
  ares_htable_asvp_t *parent;
} ares_htable_asvp_bucket_t;

void ares_htable_asvp_destroy(ares_htable_asvp_t *htable)
{
  if (htable == NULL) {
    return;
  }

  ares_htable_destroy(htable->hash);
  ares_free(htable);
}

static unsigned int hash_func(const void *key, unsigned int seed)
{
  const ares_socket_t *arg = key;
  return ares_htable_hash_FNV1a((const unsigned char *)arg, sizeof(*arg), seed);
}

static const void *bucket_key(const void *bucket)
{
  const ares_htable_asvp_bucket_t *arg = bucket;
  return &arg->key;
}

static void bucket_free(void *bucket)
{
  ares_htable_asvp_bucket_t *arg = bucket;

  if (arg->parent->free_val) {
    arg->parent->free_val(arg->val);
  }

  ares_free(arg);
}

static ares_bool_t key_eq(const void *key1, const void *key2)
{
  const ares_socket_t *k1 = key1;
  const ares_socket_t *k2 = key2;

  if (*k1 == *k2) {
    return ARES_TRUE;
  }

  return ARES_FALSE;
}

ares_htable_asvp_t *
  ares_htable_asvp_create(ares_htable_asvp_val_free_t val_free)
{
  ares_htable_asvp_t *htable = ares_malloc(sizeof(*htable));
  if (htable == NULL) {
    goto fail;
  }

  htable->hash = ares_htable_create(hash_func, bucket_key, bucket_free, key_eq);
  if (htable->hash == NULL) {
    goto fail;
  }

  htable->free_val = val_free;

  return htable;

fail:
  if (htable) {
    ares_htable_destroy(htable->hash);
    ares_free(htable);
  }
  return NULL;
}

ares_socket_t *ares_htable_asvp_keys(const ares_htable_asvp_t *htable,
                                     size_t                   *num)
{
  const void   **buckets = NULL;
  size_t         cnt     = 0;
  ares_socket_t *out     = NULL;
  size_t         i;

  if (htable == NULL || num == NULL) {
    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  *num = 0;

  buckets = ares_htable_all_buckets(htable->hash, &cnt);
  if (buckets == NULL || cnt == 0) {
    return NULL;
  }

  out = ares_malloc_zero(sizeof(*out) * cnt);
  if (out == NULL) {
    ares_free(buckets); /* LCOV_EXCL_LINE: OutOfMemory */
    return NULL;        /* LCOV_EXCL_LINE: OutOfMemory */
  }

  for (i = 0; i < cnt; i++) {
    out[i] = ((const ares_htable_asvp_bucket_t *)buckets[i])->key;
  }

  ares_free(buckets);
  *num = cnt;
  return out;
}

ares_bool_t ares_htable_asvp_insert(ares_htable_asvp_t *htable,
                                    ares_socket_t key, void *val)
{
  ares_htable_asvp_bucket_t *bucket = NULL;

  if (htable == NULL) {
    goto fail;
  }

  bucket = ares_malloc(sizeof(*bucket));
  if (bucket == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  bucket->parent = htable;
  bucket->key    = key;
  bucket->val    = val;

  if (!ares_htable_insert(htable->hash, bucket)) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  return ARES_TRUE;

fail:
  if (bucket) {
    ares_free(bucket); /* LCOV_EXCL_LINE: OutOfMemory */
  }
  return ARES_FALSE;
}

ares_bool_t ares_htable_asvp_get(const ares_htable_asvp_t *htable,
                                 ares_socket_t key, void **val)
{
  ares_htable_asvp_bucket_t *bucket = NULL;

  if (val) {
    *val = NULL;
  }

  if (htable == NULL) {
    return ARES_FALSE;
  }

  bucket = ares_htable_get(htable->hash, &key);
  if (bucket == NULL) {
    return ARES_FALSE;
  }

  if (val) {
    *val = bucket->val;
  }
  return ARES_TRUE;
}

void *ares_htable_asvp_get_direct(const ares_htable_asvp_t *htable,
                                  ares_socket_t             key)
{
  void *val = NULL;
  ares_htable_asvp_get(htable, key, &val);
  return val;
}

ares_bool_t ares_htable_asvp_remove(ares_htable_asvp_t *htable,
                                    ares_socket_t       key)
{
  if (htable == NULL) {
    return ARES_FALSE;
  }

  return ares_htable_remove(htable->hash, &key);
}

size_t ares_htable_asvp_num_keys(const ares_htable_asvp_t *htable)
{
  if (htable == NULL) {
    return 0;
  }
  return ares_htable_num_keys(htable->hash);
}
                                                                                                                                                                                                                                                                              node-23.7.0/deps/cares/src/lib/dsa/ares_htable_dict.c                                               0000664 0000000 0000000 00000012317 14746647661 0022335 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_htable.h"
#include "ares_htable_dict.h"

struct ares_htable_dict {
  ares_htable_t *hash;
};

typedef struct {
  char               *key;
  char               *val;
  ares_htable_dict_t *parent;
} ares_htable_dict_bucket_t;

void ares_htable_dict_destroy(ares_htable_dict_t *htable)
{
  if (htable == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ares_htable_destroy(htable->hash);
  ares_free(htable);
}

static unsigned int hash_func(const void *key, unsigned int seed)
{
  return ares_htable_hash_FNV1a_casecmp(key, ares_strlen(key), seed);
}

static const void *bucket_key(const void *bucket)
{
  const ares_htable_dict_bucket_t *arg = bucket;
  return arg->key;
}

static void bucket_free(void *bucket)
{
  ares_htable_dict_bucket_t *arg = bucket;

  ares_free(arg->key);
  ares_free(arg->val);

  ares_free(arg);
}

static ares_bool_t key_eq(const void *key1, const void *key2)
{
  return ares_strcaseeq(key1, key2);
}

ares_htable_dict_t *ares_htable_dict_create(void)
{
  ares_htable_dict_t *htable = ares_malloc(sizeof(*htable));
  if (htable == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  htable->hash = ares_htable_create(hash_func, bucket_key, bucket_free, key_eq);
  if (htable->hash == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  return htable;

/* LCOV_EXCL_START: OutOfMemory */
fail:
  if (htable) {
    ares_htable_destroy(htable->hash);
    ares_free(htable);
  }
  return NULL;
  /* LCOV_EXCL_STOP */
}

ares_bool_t ares_htable_dict_insert(ares_htable_dict_t *htable, const char *key,
                                    const char *val)
{
  ares_htable_dict_bucket_t *bucket = NULL;

  if (htable == NULL || ares_strlen(key) == 0) {
    goto fail;
  }

  bucket = ares_malloc_zero(sizeof(*bucket));
  if (bucket == NULL) {
    goto fail;
  }

  bucket->parent = htable;
  bucket->key    = ares_strdup(key);
  if (bucket->key == NULL) {
    goto fail;
  }

  if (val != NULL) {
    bucket->val = ares_strdup(val);
    if (bucket->val == NULL) {
      goto fail;
    }
  }

  if (!ares_htable_insert(htable->hash, bucket)) {
    goto fail;
  }

  return ARES_TRUE;

fail:
  if (bucket) {
    ares_free(bucket->val);
    ares_free(bucket);
  }
  return ARES_FALSE;
}

ares_bool_t ares_htable_dict_get(const ares_htable_dict_t *htable,
                                 const char *key, const char **val)
{
  const ares_htable_dict_bucket_t *bucket = NULL;

  if (val) {
    *val = NULL;
  }

  if (htable == NULL) {
    return ARES_FALSE;
  }

  bucket = ares_htable_get(htable->hash, key);
  if (bucket == NULL) {
    return ARES_FALSE;
  }

  if (val) {
    *val = bucket->val;
  }
  return ARES_TRUE;
}

const char *ares_htable_dict_get_direct(const ares_htable_dict_t *htable,
                                        const char               *key)
{
  const char *val = NULL;
  ares_htable_dict_get(htable, key, &val);
  return val;
}

ares_bool_t ares_htable_dict_remove(ares_htable_dict_t *htable, const char *key)
{
  if (htable == NULL) {
    return ARES_FALSE;
  }

  return ares_htable_remove(htable->hash, key);
}

size_t ares_htable_dict_num_keys(const ares_htable_dict_t *htable)
{
  if (htable == NULL) {
    return 0;
  }
  return ares_htable_num_keys(htable->hash);
}

char **ares_htable_dict_keys(const ares_htable_dict_t *htable, size_t *num)
{
  const void **buckets = NULL;
  size_t       cnt     = 0;
  char       **out     = NULL;
  size_t       i;

  if (htable == NULL || num == NULL) {
    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  *num = 0;

  buckets = ares_htable_all_buckets(htable->hash, &cnt);
  if (buckets == NULL || cnt == 0) {
    return NULL;
  }

  out = ares_malloc_zero(sizeof(*out) * cnt);
  if (out == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  for (i = 0; i < cnt; i++) {
    out[i] = ares_strdup(((const ares_htable_dict_bucket_t *)buckets[i])->key);
    if (out[i] == NULL) {
      goto fail;
    }
  }

  ares_free(buckets);
  *num = cnt;
  return out;

fail:
  *num = 0;
  ares_free_array(out, cnt, ares_free);
  return NULL;
}
                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/cares/src/lib/dsa/ares_htable_strvp.c                                              0000664 0000000 0000000 00000011611 14746647661 0022564 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_htable.h"
#include "ares_htable_strvp.h"

struct ares_htable_strvp {
  ares_htable_strvp_val_free_t free_val;
  ares_htable_t               *hash;
};

typedef struct {
  char                *key;
  void                *val;
  ares_htable_strvp_t *parent;
} ares_htable_strvp_bucket_t;

void ares_htable_strvp_destroy(ares_htable_strvp_t *htable)
{
  if (htable == NULL) {
    return;
  }

  ares_htable_destroy(htable->hash);
  ares_free(htable);
}

static unsigned int hash_func(const void *key, unsigned int seed)
{
  const char *arg = key;
  return ares_htable_hash_FNV1a_casecmp((const unsigned char *)arg,
                                        ares_strlen(arg), seed);
}

static const void *bucket_key(const void *bucket)
{
  const ares_htable_strvp_bucket_t *arg = bucket;
  return arg->key;
}

static void bucket_free(void *bucket)
{
  ares_htable_strvp_bucket_t *arg = bucket;

  if (arg->parent->free_val) {
    arg->parent->free_val(arg->val);
  }
  ares_free(arg->key);
  ares_free(arg);
}

static ares_bool_t key_eq(const void *key1, const void *key2)
{
  return ares_strcaseeq(key1, key2);
}

ares_htable_strvp_t *
  ares_htable_strvp_create(ares_htable_strvp_val_free_t val_free)
{
  ares_htable_strvp_t *htable = ares_malloc(sizeof(*htable));
  if (htable == NULL) {
    goto fail;
  }

  htable->hash = ares_htable_create(hash_func, bucket_key, bucket_free, key_eq);
  if (htable->hash == NULL) {
    goto fail;
  }

  htable->free_val = val_free;

  return htable;

fail:
  if (htable) {
    ares_htable_destroy(htable->hash);
    ares_free(htable);
  }
  return NULL;
}

ares_bool_t ares_htable_strvp_insert(ares_htable_strvp_t *htable,
                                     const char *key, void *val)
{
  ares_htable_strvp_bucket_t *bucket = NULL;

  if (htable == NULL || key == NULL) {
    goto fail;
  }

  bucket = ares_malloc(sizeof(*bucket));
  if (bucket == NULL) {
    goto fail;
  }

  bucket->parent = htable;
  bucket->key    = ares_strdup(key);
  if (bucket->key == NULL) {
    goto fail;
  }
  bucket->val = val;

  if (!ares_htable_insert(htable->hash, bucket)) {
    goto fail;
  }

  return ARES_TRUE;

fail:
  if (bucket) {
    ares_free(bucket->key);
    ares_free(bucket);
  }
  return ARES_FALSE;
}

ares_bool_t ares_htable_strvp_get(const ares_htable_strvp_t *htable,
                                  const char *key, void **val)
{
  ares_htable_strvp_bucket_t *bucket = NULL;

  if (val) {
    *val = NULL;
  }

  if (htable == NULL || key == NULL) {
    return ARES_FALSE;
  }

  bucket = ares_htable_get(htable->hash, key);
  if (bucket == NULL) {
    return ARES_FALSE;
  }

  if (val) {
    *val = bucket->val;
  }
  return ARES_TRUE;
}

void *ares_htable_strvp_get_direct(const ares_htable_strvp_t *htable,
                                   const char                *key)
{
  void *val = NULL;
  ares_htable_strvp_get(htable, key, &val);
  return val;
}

ares_bool_t ares_htable_strvp_remove(ares_htable_strvp_t *htable,
                                     const char          *key)
{
  if (htable == NULL) {
    return ARES_FALSE;
  }

  return ares_htable_remove(htable->hash, key);
}

void *ares_htable_strvp_claim(ares_htable_strvp_t *htable, const char *key)
{
  ares_htable_strvp_bucket_t *bucket = NULL;
  void                       *val;

  if (htable == NULL || key == NULL) {
    return NULL;
  }

  bucket = ares_htable_get(htable->hash, key);
  if (bucket == NULL) {
    return NULL;
  }

  /* Unassociate value from bucket */
  val         = bucket->val;
  bucket->val = NULL;

  ares_htable_strvp_remove(htable, key);
  return val;
}

size_t ares_htable_strvp_num_keys(const ares_htable_strvp_t *htable)
{
  if (htable == NULL) {
    return 0;
  }
  return ares_htable_num_keys(htable->hash);
}
                                                                                                                       node-23.7.0/deps/cares/src/lib/dsa/ares_htable_szvp.c                                               0000664 0000000 0000000 00000010454 14746647661 0022414 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_htable.h"
#include "ares_htable_szvp.h"

struct ares_htable_szvp {
  ares_htable_szvp_val_free_t free_val;
  ares_htable_t              *hash;
};

typedef struct {
  size_t              key;
  void               *val;
  ares_htable_szvp_t *parent;
} ares_htable_szvp_bucket_t;

void ares_htable_szvp_destroy(ares_htable_szvp_t *htable)
{
  if (htable == NULL) {
    return;
  }

  ares_htable_destroy(htable->hash);
  ares_free(htable);
}

static unsigned int hash_func(const void *key, unsigned int seed)
{
  const size_t *arg = key;
  return ares_htable_hash_FNV1a((const unsigned char *)arg, sizeof(*arg), seed);
}

static const void *bucket_key(const void *bucket)
{
  const ares_htable_szvp_bucket_t *arg = bucket;
  return &arg->key;
}

static void bucket_free(void *bucket)
{
  ares_htable_szvp_bucket_t *arg = bucket;

  if (arg->parent->free_val) {
    arg->parent->free_val(arg->val);
  }

  ares_free(arg);
}

static ares_bool_t key_eq(const void *key1, const void *key2)
{
  const size_t *k1 = key1;
  const size_t *k2 = key2;

  if (*k1 == *k2) {
    return ARES_TRUE;
  }

  return ARES_FALSE;
}

ares_htable_szvp_t *
  ares_htable_szvp_create(ares_htable_szvp_val_free_t val_free)
{
  ares_htable_szvp_t *htable = ares_malloc(sizeof(*htable));
  if (htable == NULL) {
    goto fail;
  }

  htable->hash = ares_htable_create(hash_func, bucket_key, bucket_free, key_eq);
  if (htable->hash == NULL) {
    goto fail;
  }

  htable->free_val = val_free;

  return htable;

fail:
  if (htable) {
    ares_htable_destroy(htable->hash);
    ares_free(htable);
  }
  return NULL;
}

ares_bool_t ares_htable_szvp_insert(ares_htable_szvp_t *htable, size_t key,
                                    void *val)
{
  ares_htable_szvp_bucket_t *bucket = NULL;

  if (htable == NULL) {
    goto fail;
  }

  bucket = ares_malloc(sizeof(*bucket));
  if (bucket == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  bucket->parent = htable;
  bucket->key    = key;
  bucket->val    = val;

  if (!ares_htable_insert(htable->hash, bucket)) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  return ARES_TRUE;

fail:
  if (bucket) {
    ares_free(bucket); /* LCOV_EXCL_LINE: OutOfMemory */
  }
  return ARES_FALSE;
}

ares_bool_t ares_htable_szvp_get(const ares_htable_szvp_t *htable, size_t key,
                                 void **val)
{
  ares_htable_szvp_bucket_t *bucket = NULL;

  if (val) {
    *val = NULL;
  }

  if (htable == NULL) {
    return ARES_FALSE;
  }

  bucket = ares_htable_get(htable->hash, &key);
  if (bucket == NULL) {
    return ARES_FALSE;
  }

  if (val) {
    *val = bucket->val;
  }
  return ARES_TRUE;
}

void *ares_htable_szvp_get_direct(const ares_htable_szvp_t *htable, size_t key)
{
  void *val = NULL;
  ares_htable_szvp_get(htable, key, &val);
  return val;
}

ares_bool_t ares_htable_szvp_remove(ares_htable_szvp_t *htable, size_t key)
{
  if (htable == NULL) {
    return ARES_FALSE;
  }

  return ares_htable_remove(htable->hash, &key);
}

size_t ares_htable_szvp_num_keys(const ares_htable_szvp_t *htable)
{
  if (htable == NULL) {
    return 0;
  }
  return ares_htable_num_keys(htable->hash);
}
                                                                                                                                                                                                                    node-23.7.0/deps/cares/src/lib/dsa/ares_htable_vpstr.c                                              0000664 0000000 0000000 00000010565 14746647661 0022573 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_htable.h"
#include "ares_htable_vpstr.h"

struct ares_htable_vpstr {
  ares_htable_t *hash;
};

typedef struct {
  void                *key;
  char                *val;
  ares_htable_vpstr_t *parent;
} ares_htable_vpstr_bucket_t;

void ares_htable_vpstr_destroy(ares_htable_vpstr_t *htable)
{
  if (htable == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ares_htable_destroy(htable->hash);
  ares_free(htable);
}

static unsigned int hash_func(const void *key, unsigned int seed)
{
  return ares_htable_hash_FNV1a((const unsigned char *)&key, sizeof(key), seed);
}

static const void *bucket_key(const void *bucket)
{
  const ares_htable_vpstr_bucket_t *arg = bucket;
  return arg->key;
}

static void bucket_free(void *bucket)
{
  ares_htable_vpstr_bucket_t *arg = bucket;

  ares_free(arg->val);

  ares_free(arg);
}

static ares_bool_t key_eq(const void *key1, const void *key2)
{
  if (key1 == key2) {
    return ARES_TRUE;
  }

  return ARES_FALSE;
}

ares_htable_vpstr_t *ares_htable_vpstr_create(void)
{
  ares_htable_vpstr_t *htable = ares_malloc(sizeof(*htable));
  if (htable == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  htable->hash = ares_htable_create(hash_func, bucket_key, bucket_free, key_eq);
  if (htable->hash == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  return htable;

/* LCOV_EXCL_START: OutOfMemory */
fail:
  if (htable) {
    ares_htable_destroy(htable->hash);
    ares_free(htable);
  }
  return NULL;
  /* LCOV_EXCL_STOP */
}

ares_bool_t ares_htable_vpstr_insert(ares_htable_vpstr_t *htable, void *key,
                                     const char *val)
{
  ares_htable_vpstr_bucket_t *bucket = NULL;

  if (htable == NULL) {
    goto fail;
  }

  bucket = ares_malloc(sizeof(*bucket));
  if (bucket == NULL) {
    goto fail;
  }

  bucket->parent = htable;
  bucket->key    = key;
  bucket->val    = ares_strdup(val);
  if (bucket->val == NULL) {
    goto fail;
  }

  if (!ares_htable_insert(htable->hash, bucket)) {
    goto fail;
  }

  return ARES_TRUE;

fail:
  if (bucket) {
    ares_free(bucket->val);
    ares_free(bucket);
  }
  return ARES_FALSE;
}

ares_bool_t ares_htable_vpstr_get(const ares_htable_vpstr_t *htable,
                                  const void *key, const char **val)
{
  const ares_htable_vpstr_bucket_t *bucket = NULL;

  if (val) {
    *val = NULL;
  }

  if (htable == NULL) {
    return ARES_FALSE;
  }

  bucket = ares_htable_get(htable->hash, key);
  if (bucket == NULL) {
    return ARES_FALSE;
  }

  if (val) {
    *val = bucket->val;
  }
  return ARES_TRUE;
}

const char *ares_htable_vpstr_get_direct(const ares_htable_vpstr_t *htable,
                                         const void                *key)
{
  const char *val = NULL;
  ares_htable_vpstr_get(htable, key, &val);
  return val;
}

ares_bool_t ares_htable_vpstr_remove(ares_htable_vpstr_t *htable,
                                     const void          *key)
{
  if (htable == NULL) {
    return ARES_FALSE;
  }

  return ares_htable_remove(htable->hash, key);
}

size_t ares_htable_vpstr_num_keys(const ares_htable_vpstr_t *htable)
{
  if (htable == NULL) {
    return 0;
  }
  return ares_htable_num_keys(htable->hash);
}
                                                                                                                                           node-23.7.0/deps/cares/src/lib/dsa/ares_htable_vpvp.c                                               0000664 0000000 0000000 00000011045 14746647661 0022402 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_htable.h"
#include "ares_htable_vpvp.h"

struct ares_htable_vpvp {
  ares_htable_vpvp_key_free_t free_key;
  ares_htable_vpvp_val_free_t free_val;
  ares_htable_t              *hash;
};

typedef struct {
  void               *key;
  void               *val;
  ares_htable_vpvp_t *parent;
} ares_htable_vpvp_bucket_t;

void ares_htable_vpvp_destroy(ares_htable_vpvp_t *htable)
{
  if (htable == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ares_htable_destroy(htable->hash);
  ares_free(htable);
}

static unsigned int hash_func(const void *key, unsigned int seed)
{
  return ares_htable_hash_FNV1a((const unsigned char *)&key, sizeof(key), seed);
}

static const void *bucket_key(const void *bucket)
{
  const ares_htable_vpvp_bucket_t *arg = bucket;
  return arg->key;
}

static void bucket_free(void *bucket)
{
  ares_htable_vpvp_bucket_t *arg = bucket;

  if (arg->parent->free_key) {
    arg->parent->free_key(arg->key);
  }

  if (arg->parent->free_val) {
    arg->parent->free_val(arg->val);
  }

  ares_free(arg);
}

static ares_bool_t key_eq(const void *key1, const void *key2)
{
  if (key1 == key2) {
    return ARES_TRUE;
  }

  return ARES_FALSE;
}

ares_htable_vpvp_t *
  ares_htable_vpvp_create(ares_htable_vpvp_key_free_t key_free,
                          ares_htable_vpvp_val_free_t val_free)
{
  ares_htable_vpvp_t *htable = ares_malloc(sizeof(*htable));
  if (htable == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  htable->hash = ares_htable_create(hash_func, bucket_key, bucket_free, key_eq);
  if (htable->hash == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  htable->free_key = key_free;
  htable->free_val = val_free;

  return htable;

/* LCOV_EXCL_START: OutOfMemory */
fail:
  if (htable) {
    ares_htable_destroy(htable->hash);
    ares_free(htable);
  }
  return NULL;
  /* LCOV_EXCL_STOP */
}

ares_bool_t ares_htable_vpvp_insert(ares_htable_vpvp_t *htable, void *key,
                                    void *val)
{
  ares_htable_vpvp_bucket_t *bucket = NULL;

  if (htable == NULL) {
    goto fail;
  }

  bucket = ares_malloc(sizeof(*bucket));
  if (bucket == NULL) {
    goto fail;
  }

  bucket->parent = htable;
  bucket->key    = key;
  bucket->val    = val;

  if (!ares_htable_insert(htable->hash, bucket)) {
    goto fail;
  }

  return ARES_TRUE;

fail:
  if (bucket) {
    ares_free(bucket);
  }
  return ARES_FALSE;
}

ares_bool_t ares_htable_vpvp_get(const ares_htable_vpvp_t *htable,
                                 const void *key, void **val)
{
  ares_htable_vpvp_bucket_t *bucket = NULL;

  if (val) {
    *val = NULL;
  }

  if (htable == NULL) {
    return ARES_FALSE;
  }

  bucket = ares_htable_get(htable->hash, key);
  if (bucket == NULL) {
    return ARES_FALSE;
  }

  if (val) {
    *val = bucket->val;
  }
  return ARES_TRUE;
}

void *ares_htable_vpvp_get_direct(const ares_htable_vpvp_t *htable,
                                  const void               *key)
{
  void *val = NULL;
  ares_htable_vpvp_get(htable, key, &val);
  return val;
}

ares_bool_t ares_htable_vpvp_remove(ares_htable_vpvp_t *htable, const void *key)
{
  if (htable == NULL) {
    return ARES_FALSE;
  }

  return ares_htable_remove(htable->hash, key);
}

size_t ares_htable_vpvp_num_keys(const ares_htable_vpvp_t *htable)
{
  if (htable == NULL) {
    return 0;
  }
  return ares_htable_num_keys(htable->hash);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/cares/src/lib/dsa/ares_llist.c                                                     0000664 0000000 0000000 00000020211 14746647661 0021212 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_llist.h"

struct ares_llist {
  ares_llist_node_t      *head;
  ares_llist_node_t      *tail;
  ares_llist_destructor_t destruct;
  size_t                  cnt;
};

struct ares_llist_node {
  void              *data;
  ares_llist_node_t *prev;
  ares_llist_node_t *next;
  ares_llist_t      *parent;
};

ares_llist_t *ares_llist_create(ares_llist_destructor_t destruct)
{
  ares_llist_t *list = ares_malloc_zero(sizeof(*list));

  if (list == NULL) {
    return NULL;
  }

  list->destruct = destruct;

  return list;
}

void ares_llist_replace_destructor(ares_llist_t           *list,
                                   ares_llist_destructor_t destruct)
{
  if (list == NULL) {
    return;
  }

  list->destruct = destruct;
}

typedef enum {
  ARES__LLIST_INSERT_HEAD,
  ARES__LLIST_INSERT_TAIL,
  ARES__LLIST_INSERT_BEFORE
} ares_llist_insert_type_t;

static void ares_llist_attach_at(ares_llist_t            *list,
                                 ares_llist_insert_type_t type,
                                 ares_llist_node_t *at, ares_llist_node_t *node)
{
  if (list == NULL || node == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  node->parent = list;

  if (type == ARES__LLIST_INSERT_BEFORE && (at == list->head || at == NULL)) {
    type = ARES__LLIST_INSERT_HEAD;
  }

  switch (type) {
    case ARES__LLIST_INSERT_HEAD:
      node->next = list->head;
      node->prev = NULL;
      if (list->head) {
        list->head->prev = node;
      }
      list->head = node;
      break;
    case ARES__LLIST_INSERT_TAIL:
      node->next = NULL;
      node->prev = list->tail;
      if (list->tail) {
        list->tail->next = node;
      }
      list->tail = node;
      break;
    case ARES__LLIST_INSERT_BEFORE:
      node->next = at;
      node->prev = at->prev;
      at->prev   = node;
      break;
  }
  if (list->tail == NULL) {
    list->tail = node;
  }
  if (list->head == NULL) {
    list->head = node;
  }

  list->cnt++;
}

static ares_llist_node_t *ares_llist_insert_at(ares_llist_t            *list,
                                               ares_llist_insert_type_t type,
                                               ares_llist_node_t *at, void *val)
{
  ares_llist_node_t *node = NULL;

  if (list == NULL || val == NULL) {
    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  node = ares_malloc_zero(sizeof(*node));

  if (node == NULL) {
    return NULL;
  }

  node->data = val;
  ares_llist_attach_at(list, type, at, node);

  return node;
}

ares_llist_node_t *ares_llist_insert_first(ares_llist_t *list, void *val)
{
  return ares_llist_insert_at(list, ARES__LLIST_INSERT_HEAD, NULL, val);
}

ares_llist_node_t *ares_llist_insert_last(ares_llist_t *list, void *val)
{
  return ares_llist_insert_at(list, ARES__LLIST_INSERT_TAIL, NULL, val);
}

ares_llist_node_t *ares_llist_insert_before(ares_llist_node_t *node, void *val)
{
  if (node == NULL) {
    return NULL;
  }

  return ares_llist_insert_at(node->parent, ARES__LLIST_INSERT_BEFORE, node,
                              val);
}

ares_llist_node_t *ares_llist_insert_after(ares_llist_node_t *node, void *val)
{
  if (node == NULL) {
    return NULL;
  }

  if (node->next == NULL) {
    return ares_llist_insert_last(node->parent, val);
  }

  return ares_llist_insert_at(node->parent, ARES__LLIST_INSERT_BEFORE,
                              node->next, val);
}

ares_llist_node_t *ares_llist_node_first(ares_llist_t *list)
{
  if (list == NULL) {
    return NULL;
  }
  return list->head;
}

ares_llist_node_t *ares_llist_node_idx(ares_llist_t *list, size_t idx)
{
  ares_llist_node_t *node;
  size_t             cnt;

  if (list == NULL) {
    return NULL;
  }
  if (idx >= list->cnt) {
    return NULL;
  }

  node = list->head;
  for (cnt = 0; node != NULL && cnt < idx; cnt++) {
    node = node->next;
  }

  return node;
}

ares_llist_node_t *ares_llist_node_last(ares_llist_t *list)
{
  if (list == NULL) {
    return NULL;
  }
  return list->tail;
}

ares_llist_node_t *ares_llist_node_next(ares_llist_node_t *node)
{
  if (node == NULL) {
    return NULL;
  }
  return node->next;
}

ares_llist_node_t *ares_llist_node_prev(ares_llist_node_t *node)
{
  if (node == NULL) {
    return NULL;
  }
  return node->prev;
}

void *ares_llist_node_val(ares_llist_node_t *node)
{
  if (node == NULL) {
    return NULL;
  }

  return node->data;
}

size_t ares_llist_len(const ares_llist_t *list)
{
  if (list == NULL) {
    return 0;
  }
  return list->cnt;
}

ares_llist_t *ares_llist_node_parent(ares_llist_node_t *node)
{
  if (node == NULL) {
    return NULL;
  }
  return node->parent;
}

void *ares_llist_first_val(ares_llist_t *list)
{
  return ares_llist_node_val(ares_llist_node_first(list));
}

void *ares_llist_last_val(ares_llist_t *list)
{
  return ares_llist_node_val(ares_llist_node_last(list));
}

static void ares_llist_node_detach(ares_llist_node_t *node)
{
  ares_llist_t *list;

  if (node == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  list = node->parent;

  if (node->prev) {
    node->prev->next = node->next;
  }

  if (node->next) {
    node->next->prev = node->prev;
  }

  if (node == list->head) {
    list->head = node->next;
  }

  if (node == list->tail) {
    list->tail = node->prev;
  }

  node->parent = NULL;
  list->cnt--;
}

void *ares_llist_node_claim(ares_llist_node_t *node)
{
  void *val;

  if (node == NULL) {
    return NULL;
  }

  val = node->data;
  ares_llist_node_detach(node);
  ares_free(node);

  return val;
}

void ares_llist_node_destroy(ares_llist_node_t *node)
{
  ares_llist_destructor_t destruct;
  void                   *val;

  if (node == NULL) {
    return;
  }

  destruct = node->parent->destruct;

  val = ares_llist_node_claim(node);
  if (val != NULL && destruct != NULL) {
    destruct(val);
  }
}

void ares_llist_node_replace(ares_llist_node_t *node, void *val)
{
  ares_llist_destructor_t destruct;

  if (node == NULL) {
    return;
  }

  destruct = node->parent->destruct;
  if (destruct != NULL) {
    destruct(node->data);
  }

  node->data = val;
}

void ares_llist_clear(ares_llist_t *list)
{
  ares_llist_node_t *node;

  if (list == NULL) {
    return;
  }

  while ((node = ares_llist_node_first(list)) != NULL) {
    ares_llist_node_destroy(node);
  }
}

void ares_llist_destroy(ares_llist_t *list)
{
  if (list == NULL) {
    return;
  }
  ares_llist_clear(list);
  ares_free(list);
}

void ares_llist_node_mvparent_last(ares_llist_node_t *node,
                                   ares_llist_t      *new_parent)
{
  if (node == NULL || new_parent == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ares_llist_node_detach(node);
  ares_llist_attach_at(new_parent, ARES__LLIST_INSERT_TAIL, NULL, node);
}

void ares_llist_node_mvparent_first(ares_llist_node_t *node,
                                    ares_llist_t      *new_parent)
{
  if (node == NULL || new_parent == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ares_llist_node_detach(node);
  ares_llist_attach_at(new_parent, ARES__LLIST_INSERT_HEAD, NULL, node);
}
                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/cares/src/lib/dsa/ares_slist.c                                                     0000664 0000000 0000000 00000025747 14746647661 0021244 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_slist.h"

/* SkipList implementation */

#define ARES__SLIST_START_LEVELS 4

struct ares_slist {
  ares_rand_state        *rand_state;
  unsigned char           rand_data[8];
  size_t                  rand_bits;

  ares_slist_node_t     **head;
  size_t                  levels;
  ares_slist_node_t      *tail;

  ares_slist_cmp_t        cmp;
  ares_slist_destructor_t destruct;
  size_t                  cnt;
};

struct ares_slist_node {
  void               *data;
  ares_slist_node_t **prev;
  ares_slist_node_t **next;
  size_t              levels;
  ares_slist_t       *parent;
};

ares_slist_t *ares_slist_create(ares_rand_state        *rand_state,
                                ares_slist_cmp_t        cmp,
                                ares_slist_destructor_t destruct)
{
  ares_slist_t *list;

  if (rand_state == NULL || cmp == NULL) {
    return NULL;
  }

  list = ares_malloc_zero(sizeof(*list));

  if (list == NULL) {
    return NULL;
  }

  list->rand_state = rand_state;
  list->cmp        = cmp;
  list->destruct   = destruct;

  list->levels = ARES__SLIST_START_LEVELS;
  list->head   = ares_malloc_zero(sizeof(*list->head) * list->levels);
  if (list->head == NULL) {
    ares_free(list);
    return NULL;
  }

  return list;
}

static ares_bool_t ares_slist_coin_flip(ares_slist_t *list)
{
  size_t total_bits = sizeof(list->rand_data) * 8;
  size_t bit;

  /* Refill random data used for coin flips.  We pull this in 8 byte chunks.
   * ares_rand_bytes() has some built-in caching of its own so we don't need
   * to be excessive in caching ourselves.  Prefer to require less memory per
   * skiplist */
  if (list->rand_bits == 0) {
    ares_rand_bytes(list->rand_state, list->rand_data, sizeof(list->rand_data));
    list->rand_bits = total_bits;
  }

  bit = total_bits - list->rand_bits;
  list->rand_bits--;

  return (list->rand_data[bit / 8] & (1 << (bit % 8))) ? ARES_TRUE : ARES_FALSE;
}

void ares_slist_replace_destructor(ares_slist_t           *list,
                                   ares_slist_destructor_t destruct)
{
  if (list == NULL) {
    return;
  }

  list->destruct = destruct;
}

static size_t ares_slist_max_level(const ares_slist_t *list)
{
  size_t max_level = 0;

  if (list->cnt + 1 <= (1 << ARES__SLIST_START_LEVELS)) {
    max_level = ARES__SLIST_START_LEVELS;
  } else {
    max_level = ares_log2(ares_round_up_pow2(list->cnt + 1));
  }

  if (list->levels > max_level) {
    max_level = list->levels;
  }

  return max_level;
}

static size_t ares_slist_calc_level(ares_slist_t *list)
{
  size_t max_level = ares_slist_max_level(list);
  size_t level;

  for (level = 1; ares_slist_coin_flip(list) && level < max_level; level++)
    ;

  return level;
}

static void ares_slist_node_push(ares_slist_t *list, ares_slist_node_t *node)
{
  size_t             i;
  ares_slist_node_t *left = NULL;

  /* Scan from highest level in the slist, even if we're not using that number
   * of levels for this entry as this is what makes it O(log n) */
  for (i = list->levels; i-- > 0;) {
    /* set left if left is NULL and the current node value is greater than the
     * head at this level */
    if (left == NULL && list->head[i] != NULL &&
        list->cmp(node->data, list->head[i]->data) > 0) {
      left = list->head[i];
    }

    if (left != NULL) {
      /* scan forward to find our insertion point */
      while (left->next[i] != NULL &&
             list->cmp(node->data, left->next[i]->data) > 0) {
        left = left->next[i];
      }
    }

    /* search only as we didn't randomly select this number of levels */
    if (i >= node->levels) {
      continue;
    }

    if (left == NULL) {
      /* head insertion */
      node->next[i] = list->head[i];
      node->prev[i] = NULL;
      list->head[i] = node;
    } else {
      /* Chain */
      node->next[i] = left->next[i];
      node->prev[i] = left;
      left->next[i] = node;
    }

    if (node->next[i] != NULL) {
      /* chain prev */
      node->next[i]->prev[i] = node;
    } else {
      if (i == 0) {
        /* update tail */
        list->tail = node;
      }
    }
  }
}

ares_slist_node_t *ares_slist_insert(ares_slist_t *list, void *val)
{
  ares_slist_node_t *node = NULL;

  if (list == NULL || val == NULL) {
    return NULL;
  }

  node = ares_malloc_zero(sizeof(*node));

  if (node == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  node->data   = val;
  node->parent = list;

  /* Randomly determine the number of levels we want to use */
  node->levels = ares_slist_calc_level(list);

  /* Allocate array of next and prev nodes for linking each level */
  node->next = ares_malloc_zero(sizeof(*node->next) * node->levels);
  if (node->next == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  node->prev = ares_malloc_zero(sizeof(*node->prev) * node->levels);
  if (node->prev == NULL) {
    goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* If the number of levels is greater than we currently support in the slist,
   * increase the count */
  if (list->levels < node->levels) {
    void *ptr =
      ares_realloc_zero(list->head, sizeof(*list->head) * list->levels,
                        sizeof(*list->head) * node->levels);
    if (ptr == NULL) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    list->head   = ptr;
    list->levels = node->levels;
  }

  ares_slist_node_push(list, node);

  list->cnt++;

  return node;

/* LCOV_EXCL_START: OutOfMemory */
fail:
  if (node) {
    ares_free(node->prev);
    ares_free(node->next);
    ares_free(node);
  }
  return NULL;
  /* LCOV_EXCL_STOP */
}

static void ares_slist_node_pop(ares_slist_node_t *node)
{
  ares_slist_t *list = node->parent;
  size_t        i;

  /* relink each node at each level */
  for (i = node->levels; i-- > 0;) {
    if (node->next[i] == NULL) {
      if (i == 0) {
        list->tail = node->prev[0];
      }
    } else {
      node->next[i]->prev[i] = node->prev[i];
    }

    if (node->prev[i] == NULL) {
      list->head[i] = node->next[i];
    } else {
      node->prev[i]->next[i] = node->next[i];
    }
  }

  memset(node->next, 0, sizeof(*node->next) * node->levels);
  memset(node->prev, 0, sizeof(*node->prev) * node->levels);
}

void *ares_slist_node_claim(ares_slist_node_t *node)
{
  ares_slist_t *list;
  void         *val;

  if (node == NULL) {
    return NULL;
  }

  list = node->parent;
  val  = node->data;

  ares_slist_node_pop(node);

  ares_free(node->next);
  ares_free(node->prev);
  ares_free(node);

  list->cnt--;

  return val;
}

void ares_slist_node_reinsert(ares_slist_node_t *node)
{
  ares_slist_t *list;

  if (node == NULL) {
    return;
  }

  list = node->parent;

  ares_slist_node_pop(node);
  ares_slist_node_push(list, node);
}

ares_slist_node_t *ares_slist_node_find(const ares_slist_t *list,
                                        const void         *val)
{
  size_t             i;
  ares_slist_node_t *node = NULL;
  int                rv   = -1;

  if (list == NULL || val == NULL) {
    return NULL;
  }

  /* Scan nodes starting at the highest level. For each level scan forward
   * until the value is between the prior and next node, or if equal quit
   * as we found a match */
  for (i = list->levels; i-- > 0;) {
    if (node == NULL) {
      node = list->head[i];
    }

    if (node == NULL) {
      continue;
    }

    do {
      rv = list->cmp(val, node->data);

      if (rv < 0) {
        /* back off, our value is greater than current node reference */
        node = node->prev[i];
      } else if (rv > 0) {
        /* move forward and try again. if it goes past, it will loop again and
         * go to previous entry */
        node = node->next[i];
      }

      /* rv == 0 will terminate loop */

    } while (node != NULL && rv > 0);

    /* Found a match, no need to continue */
    if (rv == 0) {
      break;
    }
  }

  /* no match */
  if (rv != 0) {
    return NULL;
  }

  /* The list may have multiple entries that match.  They're guaranteed to be
   * in order, but we're not guaranteed to have selected the _first_ matching
   * node.  Lets scan backwards to find the first match */
  while (node->prev[0] != NULL && list->cmp(node->prev[0]->data, val) == 0) {
    node = node->prev[0];
  }

  return node;
}

ares_slist_node_t *ares_slist_node_first(const ares_slist_t *list)
{
  if (list == NULL) {
    return NULL;
  }

  return list->head[0];
}

ares_slist_node_t *ares_slist_node_last(const ares_slist_t *list)
{
  if (list == NULL) {
    return NULL;
  }
  return list->tail;
}

ares_slist_node_t *ares_slist_node_next(const ares_slist_node_t *node)
{
  if (node == NULL) {
    return NULL;
  }
  return node->next[0];
}

ares_slist_node_t *ares_slist_node_prev(const ares_slist_node_t *node)
{
  if (node == NULL) {
    return NULL;
  }
  return node->prev[0];
}

void *ares_slist_node_val(ares_slist_node_t *node)
{
  if (node == NULL) {
    return NULL;
  }

  return node->data;
}

size_t ares_slist_len(const ares_slist_t *list)
{
  if (list == NULL) {
    return 0;
  }
  return list->cnt;
}

ares_slist_t *ares_slist_node_parent(ares_slist_node_t *node)
{
  if (node == NULL) {
    return NULL;
  }
  return node->parent;
}

void *ares_slist_first_val(const ares_slist_t *list)
{
  return ares_slist_node_val(ares_slist_node_first(list));
}

void *ares_slist_last_val(const ares_slist_t *list)
{
  return ares_slist_node_val(ares_slist_node_last(list));
}

void ares_slist_node_destroy(ares_slist_node_t *node)
{
  ares_slist_destructor_t destruct;
  void                   *val;

  if (node == NULL) {
    return;
  }

  destruct = node->parent->destruct;
  val      = ares_slist_node_claim(node);

  if (val != NULL && destruct != NULL) {
    destruct(val);
  }
}

void ares_slist_destroy(ares_slist_t *list)
{
  ares_slist_node_t *node;

  if (list == NULL) {
    return;
  }

  while ((node = ares_slist_node_first(list)) != NULL) {
    ares_slist_node_destroy(node);
  }

  ares_free(list->head);
  ares_free(list);
}
                         node-23.7.0/deps/cares/src/lib/dsa/ares_slist.h                                                     0000664 0000000 0000000 00000015647 14746647661 0021247 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__SLIST_H
#define __ARES__SLIST_H


/*! \addtogroup ares_slist SkipList Data Structure
 *
 * This data structure is known as a Skip List, which in essence is a sorted
 * linked list with multiple levels of linkage to gain some algorithmic
 * advantages.  The usage symantecs are almost identical to what you'd expect
 * with a linked list.
 *
 * Average time complexity:
 *  - Insert: O(log n)
 *  - Search: O(log n)
 *  - Delete: O(1)   -- delete assumes you hold a node pointer
 *
 * It should be noted, however, that "effort" involved with an insert or
 * remove operation is higher than a normal linked list.  For very small
 * lists this may be less efficient, but for any list with a moderate number
 * of entries this will prove much more efficient.
 *
 * This data structure is often compared with a Binary Search Tree in
 * functionality and usage.
 *
 * @{
 */
struct ares_slist;

/*! SkipList Object, opaque */
typedef struct ares_slist ares_slist_t;

struct ares_slist_node;

/*! SkipList Node Object, opaque */
typedef struct ares_slist_node ares_slist_node_t;

/*! SkipList Node Value destructor callback
 *
 *  \param[in] data  User-defined data to destroy
 */
typedef void (*ares_slist_destructor_t)(void *data);

/*! SkipList comparison function
 *
 *  \param[in] data1 First user-defined data object
 *  \param[in] data2 Second user-defined data object
 *  \return < 0 if data1 < data1, > 0 if data1 > data2, 0 if data1 == data2
 */
typedef int (*ares_slist_cmp_t)(const void *data1, const void *data2);

/*! Create SkipList
 *
 *  \param[in] rand_state   Initialized ares random state.
 *  \param[in] cmp          SkipList comparison function
 *  \param[in] destruct     SkipList Node Value Destructor. Optional, use NULL.
 *  \return Initialized SkipList Object or NULL on misuse or ENOMEM
 */
ares_slist_t      *ares_slist_create(ares_rand_state        *rand_state,
                                     ares_slist_cmp_t        cmp,
                                     ares_slist_destructor_t destruct);

/*! Replace SkipList Node Value Destructor
 *
 *  \param[in] list      Initialized SkipList Object
 *  \param[in] destruct  Replacement destructor. May be NULL.
 */
void               ares_slist_replace_destructor(ares_slist_t           *list,
                                                 ares_slist_destructor_t destruct);

/*! Insert Value into SkipList
 *
 *  \param[in] list   Initialized SkipList Object
 *  \param[in] val    Node Value. Must not be NULL.  Function takes ownership
 *                    and will have destructor called.
 *  \return SkipList Node Object or NULL on misuse or ENOMEM
 */
ares_slist_node_t *ares_slist_insert(ares_slist_t *list, void *val);

/*! Fetch first node in SkipList
 *
 *  \param[in] list  Initialized SkipList Object
 *  \return SkipList Node Object or NULL if none
 */
ares_slist_node_t *ares_slist_node_first(const ares_slist_t *list);

/*! Fetch last node in SkipList
 *
 *  \param[in] list  Initialized SkipList Object
 *  \return SkipList Node Object or NULL if none
 */
ares_slist_node_t *ares_slist_node_last(const ares_slist_t *list);

/*! Fetch next node in SkipList
 *
 *  \param[in] node  SkipList Node Object
 *  \return SkipList Node Object or NULL if none
 */
ares_slist_node_t *ares_slist_node_next(const ares_slist_node_t *node);

/*! Fetch previous node in SkipList
 *
 *  \param[in] node  SkipList Node Object
 *  \return SkipList Node Object or NULL if none
 */
ares_slist_node_t *ares_slist_node_prev(const ares_slist_node_t *node);

/*! Fetch SkipList Node Object by Value
 *
 *  \param[in] list  Initialized SkipList Object
 *  \param[in] val   Object to use for comparison
 *  \return SkipList Node Object or NULL if not found
 */
ares_slist_node_t *ares_slist_node_find(const ares_slist_t *list,
                                        const void         *val);


/*! Fetch Node Value
 *
 *  \param[in] node  SkipList Node Object
 *  \return user defined node value
 */
void              *ares_slist_node_val(ares_slist_node_t *node);

/*! Fetch number of entries in SkipList Object
 *
 *  \param[in] list  Initialized SkipList Object
 *  \return number of entries
 */
size_t             ares_slist_len(const ares_slist_t *list);

/*! Fetch SkipList Object from SkipList Node
 *
 *  \param[in] node  SkipList Node Object
 *  \return SkipList Object
 */
ares_slist_t      *ares_slist_node_parent(ares_slist_node_t *node);

/*! Fetch first Node Value in SkipList
 *
 *  \param[in] list  Initialized SkipList Object
 *  \return user defined node value or NULL if none
 */
void              *ares_slist_first_val(const ares_slist_t *list);

/*! Fetch last Node Value in SkipList
 *
 *  \param[in] list  Initialized SkipList Object
 *  \return user defined node value or NULL if none
 */
void              *ares_slist_last_val(const ares_slist_t *list);

/*! Take back ownership of Node Value in SkipList, remove from SkipList.
 *
 *  \param[in] node  SkipList Node Object
 *  \return user defined node value
 */
void              *ares_slist_node_claim(ares_slist_node_t *node);

/*! The internals of the node have changed, thus its position in the sorted
 *  list is no longer valid.  This function will remove it and re-add it to
 *  the proper position without needing to perform any memory allocations
 *  and thus cannot fail.
 *
 *  \param[in] node  SkipList Node Object
 */
void               ares_slist_node_reinsert(ares_slist_node_t *node);

/*! Remove Node from SkipList, calling destructor for Node Value.
 *
 *  \param[in] node  SkipList Node Object
 */
void               ares_slist_node_destroy(ares_slist_node_t *node);

/*! Destroy SkipList Object.  If there are any nodes, they will be destroyed.
 *
 *  \param[in] list  Initialized SkipList Object
 */
void               ares_slist_destroy(ares_slist_t *list);

/*! @} */

#endif /* __ARES__SLIST_H */
                                                                                         node-23.7.0/deps/cares/src/lib/event/                                                               0000775 0000000 0000000 00000000000 14746647661 0017263 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/event/ares_event.h                                                   0000664 0000000 0000000 00000017325 14746647661 0021577 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__EVENT_H
#define __ARES__EVENT_H

struct ares_event;
typedef struct ares_event ares_event_t;

typedef enum {
  ARES_EVENT_FLAG_NONE  = 0,
  ARES_EVENT_FLAG_READ  = 1 << 0,
  ARES_EVENT_FLAG_WRITE = 1 << 1,
  ARES_EVENT_FLAG_OTHER = 1 << 2
} ares_event_flags_t;

typedef void (*ares_event_cb_t)(ares_event_thread_t *e, ares_socket_t fd,
                                void *data, ares_event_flags_t flags);

typedef void (*ares_event_free_data_t)(void *data);

typedef void (*ares_event_signal_cb_t)(const ares_event_t *event);

struct ares_event {
  /*! Registered event thread this event is bound to */
  ares_event_thread_t   *e;
  /*! Flags to monitor. OTHER is only allowed if the socket is ARES_SOCKET_BAD.
   */
  ares_event_flags_t     flags;
  /*! Callback to be called when event is triggered */
  ares_event_cb_t        cb;
  /*! Socket to monitor, allowed to be ARES_SOCKET_BAD if not monitoring a
   *  socket. */
  ares_socket_t          fd;
  /*! Data associated with event handle that will be passed to the callback.
   *  Typically OS/event subsystem specific data.
   *  Optional, may be NULL. */
  /*! Data to be passed to callback. Optional, may be NULL. */
  void                  *data;
  /*! When cleaning up the registered event (either when removed or during
   *  shutdown), this function will be called to clean up the user-supplied
   *  data. Optional, May be NULL. */
  ares_event_free_data_t free_data_cb;
  /*! Callback to call to trigger an event. */
  ares_event_signal_cb_t signal_cb;
};

typedef struct {
  const char *name;
  ares_bool_t (*init)(ares_event_thread_t *e);
  void (*destroy)(ares_event_thread_t *e);
  ares_bool_t (*event_add)(ares_event_t *event);
  void (*event_del)(ares_event_t *event);
  void (*event_mod)(ares_event_t *event, ares_event_flags_t new_flags);
  size_t (*wait)(ares_event_thread_t *e, unsigned long timeout_ms);
} ares_event_sys_t;

struct ares_event_configchg;
typedef struct ares_event_configchg ares_event_configchg_t;

ares_status_t ares_event_configchg_init(ares_event_configchg_t **configchg,
                                        ares_event_thread_t     *e);

void          ares_event_configchg_destroy(ares_event_configchg_t *configchg);

struct ares_event_thread {
  /*! Whether the event thread should be online or not.  Checked on every wake
   *  event before sleeping. */
  ares_bool_t             isup;
  /*! Handle to the thread for joining during shutdown */
  ares_thread_t          *thread;
  /*! Lock to protect the data contained within the event thread itself */
  ares_thread_mutex_t    *mutex;
  /*! Reference to the ares channel, for being able to call things like
   *  ares_timeout() and ares_process_fd(). */
  ares_channel_t         *channel;
  /*! Whether or not on the next loop we should process a pending write */
  ares_bool_t             process_pending_write;
  /*! Not-yet-processed event handle updates.  These will get enqueued by a
   *  thread other than the event thread itself. The event thread will then
   *  be woken then process these updates itself */
  ares_llist_t           *ev_updates;
  /*! Registered socket event handles */
  ares_htable_asvp_t     *ev_sock_handles;
  /*! Registered custom event handles. Typically used for external triggering.
   */
  ares_htable_vpvp_t     *ev_cust_handles;
  /*! Pointer to the event handle which is used to signal and wake the event
   *  thread itself.  This is needed to be able to do things like update the
   *  file descriptors being waited on and to wake the event subsystem during
   *  shutdown */
  ares_event_t           *ev_signal;
  /*! Handle for configuration change monitoring */
  ares_event_configchg_t *configchg;
  /* Event subsystem callbacks */
  const ares_event_sys_t *ev_sys;
  /* Event subsystem private data */
  void                   *ev_sys_data;
};

/*! Queue an update for the event handle.
 *
 *  Will search by the fd passed if not ARES_SOCKET_BAD to find a match and
 *  perform an update or delete (depending on flags).  Otherwise will add.
 *  Do not use the event handle returned if its not guaranteed to be an add
 *  operation.
 *
 *  \param[out] event        Event handle. Optional, can be NULL.  This handle
 *                           will be invalidate quickly if the result of the
 *                           operation is not an ADD.
 *  \param[in]  e            pointer to event thread handle
 *  \param[in]  flags        flags for the event handle.  Use
 *                           ARES_EVENT_FLAG_NONE if removing a socket from
 *                           queue (not valid if socket is ARES_SOCKET_BAD).
 *                           Non-socket events cannot be removed, and must have
 *                           ARES_EVENT_FLAG_OTHER set.
 *  \param[in]  cb           Callback to call when
 *                           event is triggered. Required if flags is not
 *                           ARES_EVENT_FLAG_NONE. Not allowed to be
 *                           changed, ignored on modification.
 *  \param[in]  fd           File descriptor/socket to monitor. May
 *                           be ARES_SOCKET_BAD if not monitoring file
 *                           descriptor.
 *  \param[in]  data         Optional. Caller-supplied data to be passed to
 *                           callback. Only allowed on initial add, cannot be
 *                           modified later, ignored on modification.
 *  \param[in]  free_data_cb Optional. Callback to clean up caller-supplied
 *                           data. Only allowed on initial add, cannot be
 *                           modified later, ignored on modification.
 *  \param[in]  signal_cb    Optional. Callback to call to trigger an event.
 *  \return ARES_SUCCESS on success
 */
ares_status_t ares_event_update(ares_event_t **event, ares_event_thread_t *e,
                                ares_event_flags_t flags, ares_event_cb_t cb,
                                ares_socket_t fd, void *data,
                                ares_event_free_data_t free_data_cb,
                                ares_event_signal_cb_t signal_cb);


#ifdef HAVE_PIPE
ares_event_t *ares_pipeevent_create(ares_event_thread_t *e);
#endif

#ifdef HAVE_POLL
extern const ares_event_sys_t ares_evsys_poll;
#endif

#ifdef HAVE_KQUEUE
extern const ares_event_sys_t ares_evsys_kqueue;
#endif

#ifdef HAVE_EPOLL
extern const ares_event_sys_t ares_evsys_epoll;
#endif

#ifdef _WIN32
extern const ares_event_sys_t ares_evsys_win32;
#endif

/* All systems have select(), but not all have a way to wake, so we require
 * pipe() to wake the select() */
#ifdef HAVE_PIPE
extern const ares_event_sys_t ares_evsys_select;
#endif

#endif
                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/cares/src/lib/event/ares_event_configchg.c                                         0000664 0000000 0000000 00000045530 14746647661 0023600 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_event.h"

#ifdef __ANDROID__

ares_status_t ares_event_configchg_init(ares_event_configchg_t **configchg,
                                        ares_event_thread_t     *e)
{
  (void)configchg;
  (void)e;
  /* No ability */
  return ARES_ENOTIMP;
}

void ares_event_configchg_destroy(ares_event_configchg_t *configchg)
{
  /* No-op */
  (void)configchg;
}

#elif defined(__linux__)

#  include <sys/inotify.h>

struct ares_event_configchg {
  int                  inotify_fd;
  ares_event_thread_t *e;
};

void ares_event_configchg_destroy(ares_event_configchg_t *configchg)
{
  if (configchg == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* Tell event system to stop monitoring for changes.  This will cause the
   * cleanup to be called */
  ares_event_update(NULL, configchg->e, ARES_EVENT_FLAG_NONE, NULL,
                    configchg->inotify_fd, NULL, NULL, NULL);
}

static void ares_event_configchg_free(void *data)
{
  ares_event_configchg_t *configchg = data;
  if (configchg == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  if (configchg->inotify_fd >= 0) {
    close(configchg->inotify_fd);
    configchg->inotify_fd = -1;
  }

  ares_free(configchg);
}

static void ares_event_configchg_cb(ares_event_thread_t *e, ares_socket_t fd,
                                    void *data, ares_event_flags_t flags)
{
  const ares_event_configchg_t *configchg = data;

  /* Some systems cannot read integer variables if they are not
   * properly aligned. On other systems, incorrect alignment may
   * decrease performance. Hence, the buffer used for reading from
   * the inotify file descriptor should have the same alignment as
   * struct inotify_event. */
  unsigned char                 buf[4096]
    __attribute__((aligned(__alignof__(struct inotify_event))));
  const struct inotify_event *event;
  ssize_t                     len;
  ares_bool_t                 triggered = ARES_FALSE;

  (void)fd;
  (void)flags;

  while (1) {
    const unsigned char *ptr;

    len = read(configchg->inotify_fd, buf, sizeof(buf));
    if (len <= 0) {
      break;
    }

    /* Loop over all events in the buffer. Says kernel will check the buffer
     * size provided, so I assume it won't ever return partial events. */
    for (ptr  = buf; ptr < buf + len;
         ptr += sizeof(struct inotify_event) + event->len) {
      event = (const struct inotify_event *)((const void *)ptr);

      if (event->len == 0 || ares_strlen(event->name) == 0) {
        continue;
      }

      if (ares_strcaseeq(event->name, "resolv.conf") ||
          ares_strcaseeq(event->name, "nsswitch.conf")) {
        triggered = ARES_TRUE;
      }
    }
  }

  /* Only process after all events are read.  No need to process more often as
   * we don't want to reload the config back to back */
  if (triggered) {
    ares_reinit(e->channel);
  }
}

ares_status_t ares_event_configchg_init(ares_event_configchg_t **configchg,
                                        ares_event_thread_t     *e)
{
  ares_status_t           status = ARES_SUCCESS;
  ares_event_configchg_t *c;

  (void)e;

  /* Not used by this implementation */
  *configchg = NULL;

  c = ares_malloc_zero(sizeof(*c));
  if (c == NULL) {
    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  c->e          = e;
  c->inotify_fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);
  if (c->inotify_fd == -1) {
    status = ARES_ESERVFAIL; /* LCOV_EXCL_LINE: UntestablePath */
    goto done;               /* LCOV_EXCL_LINE: UntestablePath */
  }

  /* We need to monitor /etc/resolv.conf, /etc/nsswitch.conf */
  if (inotify_add_watch(c->inotify_fd, "/etc",
                        IN_CREATE | IN_MODIFY | IN_MOVED_TO | IN_ONLYDIR) ==
      -1) {
    status = ARES_ESERVFAIL; /* LCOV_EXCL_LINE: UntestablePath */
    goto done;               /* LCOV_EXCL_LINE: UntestablePath */
  }

  status =
    ares_event_update(NULL, e, ARES_EVENT_FLAG_READ, ares_event_configchg_cb,
                      c->inotify_fd, c, ares_event_configchg_free, NULL);

done:
  if (status != ARES_SUCCESS) {
    ares_event_configchg_free(c);
  } else {
    *configchg = c;
  }
  return status;
}

#elif defined(USE_WINSOCK)

#  include <winsock2.h>
#  include <iphlpapi.h>
#  include <stdio.h>
#  include <windows.h>

struct ares_event_configchg {
  HANDLE               ifchg_hnd;
  HKEY                 regip4;
  HANDLE               regip4_event;
  HANDLE               regip4_wait;
  HKEY                 regip6;
  HANDLE               regip6_event;
  HANDLE               regip6_wait;
  ares_event_thread_t *e;
};

void ares_event_configchg_destroy(ares_event_configchg_t *configchg)
{
  if (configchg == NULL) {
    return;
  }

#  ifdef HAVE_NOTIFYIPINTERFACECHANGE
  if (configchg->ifchg_hnd != NULL) {
    CancelMibChangeNotify2(configchg->ifchg_hnd);
    configchg->ifchg_hnd = NULL;
  }
#  endif

#  ifdef HAVE_REGISTERWAITFORSINGLEOBJECT
  if (configchg->regip4_wait != NULL) {
    UnregisterWait(configchg->regip4_wait);
    configchg->regip4_wait = NULL;
  }

  if (configchg->regip6_wait != NULL) {
    UnregisterWait(configchg->regip6_wait);
    configchg->regip6_wait = NULL;
  }

  if (configchg->regip4 != NULL) {
    RegCloseKey(configchg->regip4);
    configchg->regip4 = NULL;
  }

  if (configchg->regip6 != NULL) {
    RegCloseKey(configchg->regip6);
    configchg->regip6 = NULL;
  }

  if (configchg->regip4_event != NULL) {
    CloseHandle(configchg->regip4_event);
    configchg->regip4_event = NULL;
  }

  if (configchg->regip6_event != NULL) {
    CloseHandle(configchg->regip6_event);
    configchg->regip6_event = NULL;
  }
#  endif

  ares_free(configchg);
}


#  ifdef HAVE_NOTIFYIPINTERFACECHANGE
static void NETIOAPI_API_
  ares_event_configchg_ip_cb(PVOID CallerContext, PMIB_IPINTERFACE_ROW Row,
                             MIB_NOTIFICATION_TYPE NotificationType)
{
  ares_event_configchg_t *configchg = CallerContext;
  (void)Row;
  (void)NotificationType;
  ares_reinit(configchg->e->channel);
}
#  endif

static ares_bool_t
  ares_event_configchg_regnotify(ares_event_configchg_t *configchg)
{
#  ifdef HAVE_REGISTERWAITFORSINGLEOBJECT
#    if defined(__WATCOMC__) && !defined(REG_NOTIFY_THREAD_AGNOSTIC)
#      define REG_NOTIFY_THREAD_AGNOSTIC 0x10000000L
#    endif
  DWORD flags = REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET |
                REG_NOTIFY_THREAD_AGNOSTIC;

  if (RegNotifyChangeKeyValue(configchg->regip4, TRUE, flags,
                              configchg->regip4_event, TRUE) != ERROR_SUCCESS) {
    return ARES_FALSE;
  }

  if (RegNotifyChangeKeyValue(configchg->regip6, TRUE, flags,
                              configchg->regip6_event, TRUE) != ERROR_SUCCESS) {
    return ARES_FALSE;
  }
#  else
  (void)configchg;
#  endif
  return ARES_TRUE;
}

static VOID CALLBACK ares_event_configchg_reg_cb(PVOID   lpParameter,
                                                 BOOLEAN TimerOrWaitFired)
{
  ares_event_configchg_t *configchg = lpParameter;
  (void)TimerOrWaitFired;

  ares_reinit(configchg->e->channel);

  /* Re-arm, as its single-shot.  However, we don't know which one needs to
   * be re-armed, so we just do both */
  ares_event_configchg_regnotify(configchg);
}

ares_status_t ares_event_configchg_init(ares_event_configchg_t **configchg,
                                        ares_event_thread_t     *e)
{
  ares_status_t           status = ARES_SUCCESS;
  ares_event_configchg_t *c      = NULL;

  c = ares_malloc_zero(sizeof(**configchg));
  if (c == NULL) {
    return ARES_ENOMEM;
  }

  c->e = e;

#  ifdef HAVE_NOTIFYIPINTERFACECHANGE
  /* NOTE: If a user goes into the control panel and changes the network
   *       adapter DNS addresses manually, this will NOT trigger a notification.
   *       We've also tried listening on NotifyUnicastIpAddressChange(), but
   *       that didn't get triggered either.
   */
  if (NotifyIpInterfaceChange(AF_UNSPEC, ares_event_configchg_ip_cb, c, FALSE,
                              &c->ifchg_hnd) != NO_ERROR) {
    status = ARES_ESERVFAIL;
    goto done;
  }
#  endif

#  ifdef HAVE_REGISTERWAITFORSINGLEOBJECT
  /* Monitor HKLM\SYSTEM\CurrentControlSet\Services\Tcpip6\Parameters\Interfaces
   * and HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces
   * for changes via RegNotifyChangeKeyValue() */
  if (RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces",
        0, KEY_NOTIFY, &c->regip4) != ERROR_SUCCESS) {
    status = ARES_ESERVFAIL;
    goto done;
  }

  if (RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        L"SYSTEM\\CurrentControlSet\\Services\\Tcpip6\\Parameters\\Interfaces",
        0, KEY_NOTIFY, &c->regip6) != ERROR_SUCCESS) {
    status = ARES_ESERVFAIL;
    goto done;
  }

  c->regip4_event = CreateEvent(NULL, TRUE, FALSE, NULL);
  if (c->regip4_event == NULL) {
    status = ARES_ESERVFAIL;
    goto done;
  }

  c->regip6_event = CreateEvent(NULL, TRUE, FALSE, NULL);
  if (c->regip6_event == NULL) {
    status = ARES_ESERVFAIL;
    goto done;
  }

  if (!RegisterWaitForSingleObject(&c->regip4_wait, c->regip4_event,
                                   ares_event_configchg_reg_cb, c, INFINITE,
                                   WT_EXECUTEDEFAULT)) {
    status = ARES_ESERVFAIL;
    goto done;
  }

  if (!RegisterWaitForSingleObject(&c->regip6_wait, c->regip6_event,
                                   ares_event_configchg_reg_cb, c, INFINITE,
                                   WT_EXECUTEDEFAULT)) {
    status = ARES_ESERVFAIL;
    goto done;
  }
#  endif

  if (!ares_event_configchg_regnotify(c)) {
    status = ARES_ESERVFAIL;
    goto done;
  }

done:
  if (status != ARES_SUCCESS) {
    ares_event_configchg_destroy(c);
  } else {
    *configchg = c;
  }

  return status;
}

#elif defined(__APPLE__)

#  include <sys/types.h>
#  include <unistd.h>
#  include <notify.h>
#  include <dlfcn.h>
#  include <fcntl.h>

struct ares_event_configchg {
  int fd;
  int token;
};

void ares_event_configchg_destroy(ares_event_configchg_t *configchg)
{
  (void)configchg;

  /* Cleanup happens automatically */
}

static void ares_event_configchg_free(void *data)
{
  ares_event_configchg_t *configchg = data;
  if (configchg == NULL) {
    return;
  }

  if (configchg->fd >= 0) {
    notify_cancel(configchg->token);
    /* automatically closes fd */
    configchg->fd = -1;
  }

  ares_free(configchg);
}

static void ares_event_configchg_cb(ares_event_thread_t *e, ares_socket_t fd,
                                    void *data, ares_event_flags_t flags)
{
  ares_event_configchg_t *configchg = data;
  ares_bool_t             triggered = ARES_FALSE;

  (void)fd;
  (void)flags;

  while (1) {
    int     t = 0;
    ssize_t len;

    len = read(configchg->fd, &t, sizeof(t));

    if (len < (ssize_t)sizeof(t)) {
      break;
    }

    /* Token is read in network byte order (yeah, docs don't mention this) */
    t = (int)ntohl(t);

    if (t != configchg->token) {
      continue;
    }

    triggered = ARES_TRUE;
  }

  /* Only process after all events are read.  No need to process more often as
   * we don't want to reload the config back to back */
  if (triggered) {
    ares_reinit(e->channel);
  }
}

ares_status_t ares_event_configchg_init(ares_event_configchg_t **configchg,
                                        ares_event_thread_t     *e)
{
  ares_status_t status                               = ARES_SUCCESS;
  void         *handle                               = NULL;
  const char *(*pdns_configuration_notify_key)(void) = NULL;
  const char *notify_key                             = NULL;
  int         flags;
  size_t      i;
  const char *searchlibs[] = {
    "/usr/lib/libSystem.dylib",
    "/System/Library/Frameworks/SystemConfiguration.framework/"
    "SystemConfiguration",
    NULL
  };

  *configchg = ares_malloc_zero(sizeof(**configchg));
  if (*configchg == NULL) {
    return ARES_ENOMEM;
  }

  /* Load symbol as it isn't normally public */
  for (i = 0; searchlibs[i] != NULL; i++) {
    handle = dlopen(searchlibs[i], RTLD_LAZY);
    if (handle == NULL) {
      /* Fail, loop! */
      continue;
    }

    pdns_configuration_notify_key =
      (const char *(*)(void))dlsym(handle, "dns_configuration_notify_key");
    if (pdns_configuration_notify_key != NULL) {
      break;
    }

    /* Fail, loop! */
    dlclose(handle);
    handle = NULL;
  }

  if (pdns_configuration_notify_key == NULL) {
    status = ARES_ESERVFAIL;
    goto done;
  }

  notify_key = pdns_configuration_notify_key();
  if (notify_key == NULL) {
    status = ARES_ESERVFAIL;
    goto done;
  }

  if (notify_register_file_descriptor(notify_key, &(*configchg)->fd, 0,
                                      &(*configchg)->token) !=
      NOTIFY_STATUS_OK) {
    status = ARES_ESERVFAIL;
    goto done;
  }

  /* Set file descriptor to non-blocking */
  flags = fcntl((*configchg)->fd, F_GETFL, 0);
  fcntl((*configchg)->fd, F_SETFL, flags | O_NONBLOCK);

  /* Register file descriptor with event subsystem */
  status = ares_event_update(NULL, e, ARES_EVENT_FLAG_READ,
                             ares_event_configchg_cb, (*configchg)->fd,
                             *configchg, ares_event_configchg_free, NULL);

done:
  if (status != ARES_SUCCESS) {
    ares_event_configchg_free(*configchg);
    *configchg = NULL;
  }

  if (handle) {
    dlclose(handle);
  }

  return status;
}

#elif defined(HAVE_STAT) && !defined(_WIN32)
#  ifdef HAVE_SYS_TYPES_H
#    include <sys/types.h>
#  endif
#  ifdef HAVE_SYS_STAT_H
#    include <sys/stat.h>
#  endif

typedef struct {
  size_t size;
  time_t mtime;
} fileinfo_t;

struct ares_event_configchg {
  ares_bool_t          isup;
  ares_thread_t       *thread;
  ares_htable_strvp_t *filestat;
  ares_thread_mutex_t *lock;
  ares_thread_cond_t  *wake;
  const char          *resolvconf_path;
  ares_event_thread_t *e;
};

static ares_status_t config_change_check(ares_htable_strvp_t *filestat,
                                         const char          *resolvconf_path)
{
  size_t      i;
  const char *configfiles[16];
  ares_bool_t changed = ARES_FALSE;
  size_t      cnt = 0;

  memset(configfiles, 0, sizeof(configfiles));

  configfiles[cnt++] = resolvconf_path;
  configfiles[cnt++] = "/etc/nsswitch.conf";
#ifdef _AIX
  configfiles[cnt++] = "/etc/netsvc.conf";
#endif
#ifdef __osf /* Tru64 */
  configfiles[cnt++] = "/etc/svc.conf";
#endif
#ifdef __QNX__
  configfiles[cnt++] = "/etc/net.cfg";
#endif
  configfiles[cnt++] = NULL;

  for (i = 0; configfiles[i] != NULL; i++) {
    fileinfo_t *fi = ares_htable_strvp_get_direct(filestat, configfiles[i]);
    struct stat st;

    if (stat(configfiles[i], &st) == 0) {
      if (fi == NULL) {
        fi = ares_malloc_zero(sizeof(*fi));
        if (fi == NULL) {
          return ARES_ENOMEM;
        }
        if (!ares_htable_strvp_insert(filestat, configfiles[i], fi)) {
          ares_free(fi);
          return ARES_ENOMEM;
        }
      }
      if (fi->size != (size_t)st.st_size || fi->mtime != (time_t)st.st_mtime) {
        changed = ARES_TRUE;
      }
      fi->size  = (size_t)st.st_size;
      fi->mtime = (time_t)st.st_mtime;
    } else if (fi != NULL) {
      /* File no longer exists, remove */
      ares_htable_strvp_remove(filestat, configfiles[i]);
      changed = ARES_TRUE;
    }
  }

  if (changed) {
    return ARES_SUCCESS;
  }
  return ARES_ENOTFOUND;
}

static void *ares_event_configchg_thread(void *arg)
{
  ares_event_configchg_t *c = arg;

  ares_thread_mutex_lock(c->lock);
  while (c->isup) {
    ares_status_t status;

    if (ares_thread_cond_timedwait(c->wake, c->lock, 30000) != ARES_ETIMEOUT) {
      continue;
    }

    /* make sure status didn't change even though we got a timeout */
    if (!c->isup) {
      break;
    }

    status = config_change_check(c->filestat, c->resolvconf_path);
    if (status == ARES_SUCCESS) {
      ares_reinit(c->e->channel);
    }
  }

  ares_thread_mutex_unlock(c->lock);
  return NULL;
}

ares_status_t ares_event_configchg_init(ares_event_configchg_t **configchg,
                                        ares_event_thread_t     *e)
{
  ares_status_t           status = ARES_SUCCESS;
  ares_event_configchg_t *c      = NULL;

  *configchg = NULL;

  c = ares_malloc_zero(sizeof(*c));
  if (c == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  c->e = e;

  c->filestat = ares_htable_strvp_create(ares_free);
  if (c->filestat == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  c->wake = ares_thread_cond_create();
  if (c->wake == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  c->resolvconf_path = c->e->channel->resolvconf_path;
  if (c->resolvconf_path == NULL) {
    c->resolvconf_path = PATH_RESOLV_CONF;
  }

  status = config_change_check(c->filestat, c->resolvconf_path);
  if (status == ARES_ENOMEM) {
    goto done;
  }

  c->isup = ARES_TRUE;
  status  = ares_thread_create(&c->thread, ares_event_configchg_thread, c);

done:
  if (status != ARES_SUCCESS) {
    ares_event_configchg_destroy(c);
  } else {
    *configchg = c;
  }
  return status;
}

void ares_event_configchg_destroy(ares_event_configchg_t *configchg)
{
  if (configchg == NULL) {
    return;
  }

  if (configchg->lock) {
    ares_thread_mutex_lock(configchg->lock);
  }

  configchg->isup = ARES_FALSE;
  if (configchg->wake) {
    ares_thread_cond_signal(configchg->wake);
  }

  if (configchg->lock) {
    ares_thread_mutex_unlock(configchg->lock);
  }

  if (configchg->thread) {
    void *rv = NULL;
    ares_thread_join(configchg->thread, &rv);
  }

  ares_thread_mutex_destroy(configchg->lock);
  ares_thread_cond_destroy(configchg->wake);
  ares_htable_strvp_destroy(configchg->filestat);
  ares_free(configchg);
}

#else

ares_status_t ares_event_configchg_init(ares_event_configchg_t **configchg,
                                        ares_event_thread_t     *e)
{
  /* No ability */
  return ARES_ENOTIMP;
}

void ares_event_configchg_destroy(ares_event_configchg_t *configchg)
{
  /* No-op */
}

#endif
                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/event/ares_event_epoll.c                                             0000664 0000000 0000000 00000013216 14746647661 0022760 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_event.h"

#ifdef HAVE_SYS_EPOLL_H
#  include <sys/epoll.h>
#endif
#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif

#ifdef HAVE_EPOLL

typedef struct {
  int epoll_fd;
} ares_evsys_epoll_t;

static void ares_evsys_epoll_destroy(ares_event_thread_t *e)
{
  ares_evsys_epoll_t *ep = NULL;

  if (e == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ep = e->ev_sys_data;
  if (ep == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  if (ep->epoll_fd != -1) {
    close(ep->epoll_fd);
  }

  ares_free(ep);
  e->ev_sys_data = NULL;
}

static ares_bool_t ares_evsys_epoll_init(ares_event_thread_t *e)
{
  ares_evsys_epoll_t *ep = NULL;

  ep = ares_malloc_zero(sizeof(*ep));
  if (ep == NULL) {
    return ARES_FALSE; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  e->ev_sys_data = ep;

  ep->epoll_fd = epoll_create1(EPOLL_CLOEXEC);
  if (ep->epoll_fd == -1) {
    ares_evsys_epoll_destroy(e); /* LCOV_EXCL_LINE: UntestablePath */
    return ARES_FALSE;           /* LCOV_EXCL_LINE: UntestablePath */
  }

  e->ev_signal = ares_pipeevent_create(e);
  if (e->ev_signal == NULL) {
    ares_evsys_epoll_destroy(e); /* LCOV_EXCL_LINE: UntestablePath */
    return ARES_FALSE;           /* LCOV_EXCL_LINE: UntestablePath */
  }

  return ARES_TRUE;
}

static ares_bool_t ares_evsys_epoll_event_add(ares_event_t *event)
{
  const ares_event_thread_t *e  = event->e;
  const ares_evsys_epoll_t  *ep = e->ev_sys_data;
  struct epoll_event         epev;

  memset(&epev, 0, sizeof(epev));
  epev.data.fd = event->fd;
  epev.events  = EPOLLRDHUP | EPOLLERR | EPOLLHUP;
  if (event->flags & ARES_EVENT_FLAG_READ) {
    epev.events |= EPOLLIN;
  }
  if (event->flags & ARES_EVENT_FLAG_WRITE) {
    epev.events |= EPOLLOUT;
  }
  if (epoll_ctl(ep->epoll_fd, EPOLL_CTL_ADD, event->fd, &epev) != 0) {
    return ARES_FALSE; /* LCOV_EXCL_LINE: UntestablePath */
  }
  return ARES_TRUE;
}

static void ares_evsys_epoll_event_del(ares_event_t *event)
{
  const ares_event_thread_t *e  = event->e;
  const ares_evsys_epoll_t  *ep = e->ev_sys_data;
  struct epoll_event         epev;

  memset(&epev, 0, sizeof(epev));
  epev.data.fd = event->fd;
  epoll_ctl(ep->epoll_fd, EPOLL_CTL_DEL, event->fd, &epev);
}

static void ares_evsys_epoll_event_mod(ares_event_t      *event,
                                       ares_event_flags_t new_flags)
{
  const ares_event_thread_t *e  = event->e;
  const ares_evsys_epoll_t  *ep = e->ev_sys_data;
  struct epoll_event         epev;

  memset(&epev, 0, sizeof(epev));
  epev.data.fd = event->fd;
  epev.events  = EPOLLRDHUP | EPOLLERR | EPOLLHUP;
  if (new_flags & ARES_EVENT_FLAG_READ) {
    epev.events |= EPOLLIN;
  }
  if (new_flags & ARES_EVENT_FLAG_WRITE) {
    epev.events |= EPOLLOUT;
  }
  epoll_ctl(ep->epoll_fd, EPOLL_CTL_MOD, event->fd, &epev);
}

static size_t ares_evsys_epoll_wait(ares_event_thread_t *e,
                                    unsigned long        timeout_ms)
{
  struct epoll_event        events[8];
  size_t                    nevents = sizeof(events) / sizeof(*events);
  const ares_evsys_epoll_t *ep      = e->ev_sys_data;
  int                       rv;
  size_t                    i;
  size_t                    cnt = 0;

  memset(events, 0, sizeof(events));

  rv = epoll_wait(ep->epoll_fd, events, (int)nevents,
                  (timeout_ms == 0) ? -1 : (int)timeout_ms);
  if (rv < 0) {
    return 0; /* LCOV_EXCL_LINE: UntestablePath */
  }

  nevents = (size_t)rv;

  for (i = 0; i < nevents; i++) {
    ares_event_t      *ev;
    ares_event_flags_t flags = 0;

    ev = ares_htable_asvp_get_direct(e->ev_sock_handles,
                                     (ares_socket_t)events[i].data.fd);
    if (ev == NULL || ev->cb == NULL) {
      continue; /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    cnt++;

    if (events[i].events & (EPOLLIN | EPOLLRDHUP | EPOLLHUP | EPOLLERR)) {
      flags |= ARES_EVENT_FLAG_READ;
    }
    if (events[i].events & EPOLLOUT) {
      flags |= ARES_EVENT_FLAG_WRITE;
    }

    ev->cb(e, ev->fd, ev->data, flags);
  }

  return cnt;
}

const ares_event_sys_t ares_evsys_epoll = { "epoll",
                                            ares_evsys_epoll_init,
                                            ares_evsys_epoll_destroy,
                                            ares_evsys_epoll_event_add,
                                            ares_evsys_epoll_event_del,
                                            ares_evsys_epoll_event_mod,
                                            ares_evsys_epoll_wait };
#endif
                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/cares/src/lib/event/ares_event_kqueue.c                                            0000664 0000000 0000000 00000015077 14746647661 0023153 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_event.h"

#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_EVENT_H
#  include <sys/event.h>
#endif
#ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>
#endif
#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif

#ifdef HAVE_KQUEUE

typedef struct {
  int            kqueue_fd;
  struct kevent *changelist;
  size_t         nchanges;
  size_t         nchanges_alloc;
} ares_evsys_kqueue_t;

static void ares_evsys_kqueue_destroy(ares_event_thread_t *e)
{
  ares_evsys_kqueue_t *kq = NULL;

  if (e == NULL) {
    return;
  }

  kq = e->ev_sys_data;
  if (kq == NULL) {
    return;
  }

  if (kq->kqueue_fd != -1) {
    close(kq->kqueue_fd);
  }

  ares_free(kq->changelist);
  ares_free(kq);
  e->ev_sys_data = NULL;
}

static ares_bool_t ares_evsys_kqueue_init(ares_event_thread_t *e)
{
  ares_evsys_kqueue_t *kq = NULL;

  kq = ares_malloc_zero(sizeof(*kq));
  if (kq == NULL) {
    return ARES_FALSE;
  }

  e->ev_sys_data = kq;

  kq->kqueue_fd = kqueue();
  if (kq->kqueue_fd == -1) {
    ares_evsys_kqueue_destroy(e);
    return ARES_FALSE;
  }

#  ifdef FD_CLOEXEC
  fcntl(kq->kqueue_fd, F_SETFD, FD_CLOEXEC);
#  endif

  kq->nchanges_alloc = 8;
  kq->changelist =
    ares_malloc_zero(kq->nchanges_alloc * sizeof(*kq->changelist));
  if (kq->changelist == NULL) {
    ares_evsys_kqueue_destroy(e);
    return ARES_FALSE;
  }

  e->ev_signal = ares_pipeevent_create(e);
  if (e->ev_signal == NULL) {
    ares_evsys_kqueue_destroy(e);
    return ARES_FALSE;
  }

  return ARES_TRUE;
}

static void ares_evsys_kqueue_enqueue(ares_evsys_kqueue_t *kq, int fd,
                                      int16_t filter, uint16_t flags)
{
  size_t idx;

  if (kq == NULL) {
    return;
  }

  idx = kq->nchanges;

  kq->nchanges++;

  if (kq->nchanges > kq->nchanges_alloc) {
    kq->nchanges_alloc <<= 1;
    kq->changelist       = ares_realloc_zero(
      kq->changelist, (kq->nchanges_alloc >> 1) * sizeof(*kq->changelist),
      kq->nchanges_alloc * sizeof(*kq->changelist));
  }

  EV_SET(&kq->changelist[idx], fd, filter, flags, 0, 0, 0);
}

static void ares_evsys_kqueue_event_process(ares_event_t      *event,
                                            ares_event_flags_t old_flags,
                                            ares_event_flags_t new_flags)
{
  ares_event_thread_t *e = event->e;
  ares_evsys_kqueue_t *kq;

  if (e == NULL) {
    return;
  }

  kq = e->ev_sys_data;
  if (kq == NULL) {
    return;
  }

  if (new_flags & ARES_EVENT_FLAG_READ && !(old_flags & ARES_EVENT_FLAG_READ)) {
    ares_evsys_kqueue_enqueue(kq, event->fd, EVFILT_READ, EV_ADD | EV_ENABLE);
  }

  if (!(new_flags & ARES_EVENT_FLAG_READ) && old_flags & ARES_EVENT_FLAG_READ) {
    ares_evsys_kqueue_enqueue(kq, event->fd, EVFILT_READ, EV_DELETE);
  }

  if (new_flags & ARES_EVENT_FLAG_WRITE &&
      !(old_flags & ARES_EVENT_FLAG_WRITE)) {
    ares_evsys_kqueue_enqueue(kq, event->fd, EVFILT_WRITE, EV_ADD | EV_ENABLE);
  }

  if (!(new_flags & ARES_EVENT_FLAG_WRITE) &&
      old_flags & ARES_EVENT_FLAG_WRITE) {
    ares_evsys_kqueue_enqueue(kq, event->fd, EVFILT_WRITE, EV_DELETE);
  }
}

static ares_bool_t ares_evsys_kqueue_event_add(ares_event_t *event)
{
  ares_evsys_kqueue_event_process(event, 0, event->flags);
  return ARES_TRUE;
}

static void ares_evsys_kqueue_event_del(ares_event_t *event)
{
  ares_evsys_kqueue_event_process(event, event->flags, 0);
}

static void ares_evsys_kqueue_event_mod(ares_event_t      *event,
                                        ares_event_flags_t new_flags)
{
  ares_evsys_kqueue_event_process(event, event->flags, new_flags);
}

static size_t ares_evsys_kqueue_wait(ares_event_thread_t *e,
                                     unsigned long        timeout_ms)
{
  struct kevent        events[8];
  size_t               nevents = sizeof(events) / sizeof(*events);
  ares_evsys_kqueue_t *kq      = e->ev_sys_data;
  int                  rv;
  size_t               i;
  struct timespec      ts;
  struct timespec     *timeout = NULL;
  size_t               cnt     = 0;

  if (timeout_ms != 0) {
    ts.tv_sec  = (time_t)timeout_ms / 1000;
    ts.tv_nsec = (timeout_ms % 1000) * 1000 * 1000;
    timeout    = &ts;
  }

  memset(events, 0, sizeof(events));

  rv = kevent(kq->kqueue_fd, kq->changelist, (int)kq->nchanges, events,
              (int)nevents, timeout);
  if (rv < 0) {
    return 0;
  }

  /* Changelist was consumed */
  kq->nchanges = 0;
  nevents      = (size_t)rv;

  for (i = 0; i < nevents; i++) {
    ares_event_t      *ev;
    ares_event_flags_t flags = 0;

    ev = ares_htable_asvp_get_direct(e->ev_sock_handles,
                                     (ares_socket_t)events[i].ident);
    if (ev == NULL || ev->cb == NULL) {
      continue;
    }

    cnt++;

    if (events[i].filter == EVFILT_READ ||
        events[i].flags & (EV_EOF | EV_ERROR)) {
      flags |= ARES_EVENT_FLAG_READ;
    } else {
      flags |= ARES_EVENT_FLAG_WRITE;
    }

    ev->cb(e, ev->fd, ev->data, flags);
  }

  return cnt;
}

const ares_event_sys_t ares_evsys_kqueue = { "kqueue",
                                             ares_evsys_kqueue_init,
                                             ares_evsys_kqueue_destroy,
                                             ares_evsys_kqueue_event_add,
                                             ares_evsys_kqueue_event_del,
                                             ares_evsys_kqueue_event_mod,
                                             ares_evsys_kqueue_wait };
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/cares/src/lib/event/ares_event_poll.c                                              0000664 0000000 0000000 00000010057 14746647661 0022613 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_event.h"
#ifdef HAVE_POLL_H
#  include <poll.h>
#endif

#if defined(HAVE_POLL)

static ares_bool_t ares_evsys_poll_init(ares_event_thread_t *e)
{
  e->ev_signal = ares_pipeevent_create(e);
  if (e->ev_signal == NULL) {
    return ARES_FALSE; /* LCOV_EXCL_LINE: UntestablePath */
  }
  return ARES_TRUE;
}

static void ares_evsys_poll_destroy(ares_event_thread_t *e)
{
  (void)e;
}

static ares_bool_t ares_evsys_poll_event_add(ares_event_t *event)
{
  (void)event;
  return ARES_TRUE;
}

static void ares_evsys_poll_event_del(ares_event_t *event)
{
  (void)event;
}

static void ares_evsys_poll_event_mod(ares_event_t      *event,
                                      ares_event_flags_t new_flags)
{
  (void)event;
  (void)new_flags;
}

static size_t ares_evsys_poll_wait(ares_event_thread_t *e,
                                   unsigned long        timeout_ms)
{
  size_t         num_fds = 0;
  ares_socket_t *fdlist  = ares_htable_asvp_keys(e->ev_sock_handles, &num_fds);
  struct pollfd *pollfd  = NULL;
  int            rv;
  size_t         cnt = 0;
  size_t         i;

  if (fdlist != NULL && num_fds) {
    pollfd = ares_malloc_zero(sizeof(*pollfd) * num_fds);
    if (pollfd == NULL) {
      goto done; /* LCOV_EXCL_LINE: OutOfMemory */
    }
    for (i = 0; i < num_fds; i++) {
      const ares_event_t *ev =
        ares_htable_asvp_get_direct(e->ev_sock_handles, fdlist[i]);
      pollfd[i].fd = ev->fd;
      if (ev->flags & ARES_EVENT_FLAG_READ) {
        pollfd[i].events |= POLLIN;
      }
      if (ev->flags & ARES_EVENT_FLAG_WRITE) {
        pollfd[i].events |= POLLOUT;
      }
    }
  }
  ares_free(fdlist);

  rv = poll(pollfd, (nfds_t)num_fds, (timeout_ms == 0) ? -1 : (int)timeout_ms);
  if (rv <= 0) {
    goto done;
  }

  for (i = 0; pollfd != NULL && i < num_fds; i++) {
    ares_event_t      *ev;
    ares_event_flags_t flags = 0;

    if (pollfd[i].revents == 0) {
      continue;
    }

    cnt++;

    ev = ares_htable_asvp_get_direct(e->ev_sock_handles, pollfd[i].fd);
    if (ev == NULL || ev->cb == NULL) {
      continue; /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    if (pollfd[i].revents & (POLLERR | POLLHUP | POLLIN)) {
      flags |= ARES_EVENT_FLAG_READ;
    }

    if (pollfd[i].revents & POLLOUT) {
      flags |= ARES_EVENT_FLAG_WRITE;
    }

    ev->cb(e, pollfd[i].fd, ev->data, flags);
  }

done:
  ares_free(pollfd);
  return cnt;
}

const ares_event_sys_t ares_evsys_poll = { "poll",
                                           ares_evsys_poll_init,
                                           ares_evsys_poll_destroy,   /* NoOp */
                                           ares_evsys_poll_event_add, /* NoOp */
                                           ares_evsys_poll_event_del, /* NoOp */
                                           ares_evsys_poll_event_mod, /* NoOp */
                                           ares_evsys_poll_wait };

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/cares/src/lib/event/ares_event_select.c                                            0000664 0000000 0000000 00000010510 14746647661 0023116 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

/* Some systems might default to something low like 256 (NetBSD), lets define
 * this to assist.  Really, no one should be using select, but lets be safe
 * anyhow */
#define FD_SETSIZE 4096

#include "ares_private.h"
#include "ares_event.h"
#ifdef HAVE_SYS_SELECT_H
#  include <sys/select.h>
#endif

/* All systems have select(), but not all have a way to wake, so we require
 * pipe() to wake the select() */
#if defined(HAVE_PIPE)

static ares_bool_t ares_evsys_select_init(ares_event_thread_t *e)
{
  e->ev_signal = ares_pipeevent_create(e);
  if (e->ev_signal == NULL) {
    return ARES_FALSE; /* LCOV_EXCL_LINE: UntestablePath */
  }
  return ARES_TRUE;
}

static void ares_evsys_select_destroy(ares_event_thread_t *e)
{
  (void)e;
}

static ares_bool_t ares_evsys_select_event_add(ares_event_t *event)
{
  (void)event;
  return ARES_TRUE;
}

static void ares_evsys_select_event_del(ares_event_t *event)
{
  (void)event;
}

static void ares_evsys_select_event_mod(ares_event_t      *event,
                                        ares_event_flags_t new_flags)
{
  (void)event;
  (void)new_flags;
}

static size_t ares_evsys_select_wait(ares_event_thread_t *e,
                                     unsigned long        timeout_ms)
{
  size_t          num_fds = 0;
  ares_socket_t  *fdlist  = ares_htable_asvp_keys(e->ev_sock_handles, &num_fds);
  int             rv;
  size_t          cnt = 0;
  size_t          i;
  fd_set          read_fds;
  fd_set          write_fds;
  fd_set          except_fds;
  int             nfds = 0;
  struct timeval  tv;
  struct timeval *tout = NULL;

  FD_ZERO(&read_fds);
  FD_ZERO(&write_fds);
  FD_ZERO(&except_fds);

  for (i = 0; i < num_fds; i++) {
    const ares_event_t *ev =
      ares_htable_asvp_get_direct(e->ev_sock_handles, fdlist[i]);
    if (ev->flags & ARES_EVENT_FLAG_READ) {
      FD_SET(ev->fd, &read_fds);
    }
    if (ev->flags & ARES_EVENT_FLAG_WRITE) {
      FD_SET(ev->fd, &write_fds);
    }
    FD_SET(ev->fd, &except_fds);
    if (ev->fd + 1 > nfds) {
      nfds = ev->fd + 1;
    }
  }

  if (timeout_ms) {
    tv.tv_sec  = (int)(timeout_ms / 1000);
    tv.tv_usec = (int)((timeout_ms % 1000) * 1000);
    tout       = &tv;
  }

  rv = select(nfds, &read_fds, &write_fds, &except_fds, tout);
  if (rv > 0) {
    for (i = 0; i < num_fds; i++) {
      ares_event_t      *ev;
      ares_event_flags_t flags = 0;

      ev = ares_htable_asvp_get_direct(e->ev_sock_handles, fdlist[i]);
      if (ev == NULL || ev->cb == NULL) {
        continue; /* LCOV_EXCL_LINE: DefensiveCoding */
      }

      if (FD_ISSET(fdlist[i], &read_fds) || FD_ISSET(fdlist[i], &except_fds)) {
        flags |= ARES_EVENT_FLAG_READ;
      }

      if (FD_ISSET(fdlist[i], &write_fds)) {
        flags |= ARES_EVENT_FLAG_WRITE;
      }

      if (flags == 0) {
        continue;
      }

      cnt++;

      ev->cb(e, fdlist[i], ev->data, flags);
    }
  }

  ares_free(fdlist);

  return cnt;
}

const ares_event_sys_t ares_evsys_select = {
  "select",
  ares_evsys_select_init,
  ares_evsys_select_destroy,   /* NoOp */
  ares_evsys_select_event_add, /* NoOp */
  ares_evsys_select_event_del, /* NoOp */
  ares_evsys_select_event_mod, /* NoOp */
  ares_evsys_select_wait
};

#endif
                                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/event/ares_event_thread.c                                            0000664 0000000 0000000 00000036746 14746647661 0023131 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_event.h"

static void ares_event_destroy_cb(void *arg)
{
  ares_event_t *event = arg;
  if (event == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* Unregister from the event thread if it was registered with one */
  if (event->e) {
    const ares_event_thread_t *e = event->e;
    e->ev_sys->event_del(event);
    event->e = NULL;
  }

  if (event->free_data_cb && event->data) {
    event->free_data_cb(event->data);
  }

  ares_free(event);
}

static void ares_event_signal(const ares_event_t *event)
{
  if (event == NULL || event->signal_cb == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }
  event->signal_cb(event);
}

static void ares_event_thread_wake(const ares_event_thread_t *e)
{
  if (e == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ares_event_signal(e->ev_signal);
}

/* See if a pending update already exists. We don't want to enqueue multiple
 * updates for the same event handle. Right now this is O(n) based on number
 * of updates already enqueued.  In the future, it might make sense to make
 * this O(1) with a hashtable.
 * NOTE: in some cases a delete then re-add of the same fd, but really pointing
 *       to a different destination can happen due to a quick close of a
 *       connection then creation of a new one.  So we need to look at the
 *       flags and ignore any delete events when finding a match since we
 *       need to process the delete always, it can't be combined with other
 *       updates. */
static ares_event_t *ares_event_update_find(ares_event_thread_t *e,
                                            ares_socket_t fd, const void *data)
{
  ares_llist_node_t *node;

  for (node = ares_llist_node_first(e->ev_updates); node != NULL;
       node = ares_llist_node_next(node)) {
    ares_event_t *ev = ares_llist_node_val(node);

    if (fd != ARES_SOCKET_BAD && fd == ev->fd && ev->flags != 0) {
      return ev;
    }

    if (fd == ARES_SOCKET_BAD && ev->fd == ARES_SOCKET_BAD &&
        data == ev->data && ev->flags != 0) {
      return ev;
    }
  }

  return NULL;
}

ares_status_t ares_event_update(ares_event_t **event, ares_event_thread_t *e,
                                ares_event_flags_t flags, ares_event_cb_t cb,
                                ares_socket_t fd, void *data,
                                ares_event_free_data_t free_data_cb,
                                ares_event_signal_cb_t signal_cb)
{
  ares_event_t *ev = NULL;
  ares_status_t status;

  if (e == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* Callback must be specified if not a removal event. */
  if (flags != ARES_EVENT_FLAG_NONE && cb == NULL) {
    return ARES_EFORMERR;
  }

  if (event != NULL) {
    *event = NULL;
  }

  /* Validate flags */
  if (fd == ARES_SOCKET_BAD) {
    if (flags & (ARES_EVENT_FLAG_READ | ARES_EVENT_FLAG_WRITE)) {
      return ARES_EFORMERR;
    }
    if (!(flags & ARES_EVENT_FLAG_OTHER)) {
      return ARES_EFORMERR;
    }
  } else {
    if (flags & ARES_EVENT_FLAG_OTHER) {
      return ARES_EFORMERR;
    }
  }

  /* That's all the validation we can really do */

  ares_thread_mutex_lock(e->mutex);

  /* See if we have a queued update already */
  ev = ares_event_update_find(e, fd, data);
  if (ev == NULL) {
    /* Allocate a new one */
    ev = ares_malloc_zero(sizeof(*ev));
    if (ev == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }

    if (ares_llist_insert_last(e->ev_updates, ev) == NULL) {
      ares_free(ev);        /* LCOV_EXCL_LINE: OutOfMemory */
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  ev->flags = flags;
  ev->fd    = fd;
  if (ev->cb == NULL) {
    ev->cb = cb;
  }
  if (ev->data == NULL) {
    ev->data = data;
  }
  if (ev->free_data_cb == NULL) {
    ev->free_data_cb = free_data_cb;
  }
  if (ev->signal_cb == NULL) {
    ev->signal_cb = signal_cb;
  }

  if (event != NULL) {
    *event = ev;
  }

  status = ARES_SUCCESS;

done:
  if (status == ARES_SUCCESS) {
    /* Wake event thread if successful so it can pull the updates */
    ares_event_thread_wake(e);
  }

  ares_thread_mutex_unlock(e->mutex);

  return status;
}

static void ares_event_thread_process_fd(ares_event_thread_t *e,
                                         ares_socket_t fd, void *data,
                                         ares_event_flags_t flags)
{
  ares_fd_events_t event;
  (void)data;

  event.fd     = fd;
  event.events = 0;
  if (flags & ARES_EVENT_FLAG_READ) {
    event.events |= ARES_FD_EVENT_READ;
  }
  if (flags & ARES_EVENT_FLAG_WRITE) {
    event.events |= ARES_FD_EVENT_WRITE;
  }
  ares_process_fds(e->channel, &event, 1, ARES_PROCESS_FLAG_SKIP_NON_FD);
}

static void ares_event_thread_sockstate_cb(void *data, ares_socket_t socket_fd,
                                           int readable, int writable)
{
  ares_event_thread_t *e     = data;
  ares_event_flags_t   flags = ARES_EVENT_FLAG_NONE;

  if (readable) {
    flags |= ARES_EVENT_FLAG_READ;
  }

  if (writable) {
    flags |= ARES_EVENT_FLAG_WRITE;
  }

  /* Update channel fd.  This function will lock e->mutex and also wake the
   * event thread to process the update */
  ares_event_update(NULL, e, flags, ares_event_thread_process_fd, socket_fd,
                    NULL, NULL, NULL);
}

static void notifywrite_cb(void *data)
{
  ares_event_thread_t *e = data;

  ares_thread_mutex_lock(e->mutex);
  e->process_pending_write = ARES_TRUE;
  ares_thread_mutex_unlock(e->mutex);

  ares_event_thread_wake(e);
}

static void ares_event_process_updates(ares_event_thread_t *e)
{
  ares_llist_node_t *node;

  /* Iterate across all updates and apply to internal list, removing from update
   * list */
  while ((node = ares_llist_node_first(e->ev_updates)) != NULL) {
    ares_event_t *newev = ares_llist_node_claim(node);
    ares_event_t *oldev;

    if (newev->fd == ARES_SOCKET_BAD) {
      oldev = ares_htable_vpvp_get_direct(e->ev_cust_handles, newev->data);
    } else {
      oldev = ares_htable_asvp_get_direct(e->ev_sock_handles, newev->fd);
    }

    /* Adding new */
    if (oldev == NULL) {
      newev->e = e;
      /* Don't try to add a new event if all flags are cleared, that's basically
       * someone trying to delete something already deleted.  Also if it fails
       * to add, cleanup. */
      if (newev->flags == ARES_EVENT_FLAG_NONE ||
          !e->ev_sys->event_add(newev)) {
        newev->e = NULL;
        ares_event_destroy_cb(newev);
      } else {
        if (newev->fd == ARES_SOCKET_BAD) {
          ares_htable_vpvp_insert(e->ev_cust_handles, newev->data, newev);
        } else {
          ares_htable_asvp_insert(e->ev_sock_handles, newev->fd, newev);
        }
      }
      continue;
    }

    /* Removal request */
    if (newev->flags == ARES_EVENT_FLAG_NONE) {
      /* the callback for the removal will call e->ev_sys->event_del(e, event)
       */
      if (newev->fd == ARES_SOCKET_BAD) {
        ares_htable_vpvp_remove(e->ev_cust_handles, newev->data);
      } else {
        ares_htable_asvp_remove(e->ev_sock_handles, newev->fd);
      }
      ares_free(newev);
      continue;
    }

    /* Modify request -- only flags can be changed */
    e->ev_sys->event_mod(oldev, newev->flags);
    oldev->flags = newev->flags;
    ares_free(newev);
  }
}

static void ares_event_thread_cleanup(ares_event_thread_t *e)
{
  /* Manually free any updates that weren't processed */
  if (e->ev_updates != NULL) {
    ares_llist_node_t *node;

    while ((node = ares_llist_node_first(e->ev_updates)) != NULL) {
      ares_event_destroy_cb(ares_llist_node_claim(node));
    }
    ares_llist_destroy(e->ev_updates);
    e->ev_updates = NULL;
  }

  if (e->ev_sock_handles != NULL) {
    ares_htable_asvp_destroy(e->ev_sock_handles);
    e->ev_sock_handles = NULL;
  }

  if (e->ev_cust_handles != NULL) {
    ares_htable_vpvp_destroy(e->ev_cust_handles);
    e->ev_cust_handles = NULL;
  }

  if (e->ev_sys != NULL && e->ev_sys->destroy != NULL) {
    e->ev_sys->destroy(e);
    e->ev_sys = NULL;
  }
}

static void *ares_event_thread(void *arg)
{
  ares_event_thread_t *e = arg;
  ares_thread_mutex_lock(e->mutex);

  while (e->isup) {
    struct timeval        tv;
    const struct timeval *tvout;
    unsigned long         timeout_ms = 0; /* 0 = unlimited */
    ares_bool_t           process_pending_write;

    ares_event_process_updates(e);

    /* Don't hold a mutex while waiting on events or calling into anything
     * that might require a c-ares channel lock since a callback could be
     * triggered cross-thread */
    ares_thread_mutex_unlock(e->mutex);

    tvout = ares_timeout(e->channel, NULL, &tv);
    if (tvout != NULL) {
      timeout_ms =
        (unsigned long)((tvout->tv_sec * 1000) + (tvout->tv_usec / 1000) + 1);
    }

    e->ev_sys->wait(e, timeout_ms);

    /* Process pending write operation */
    ares_thread_mutex_lock(e->mutex);
    process_pending_write    = e->process_pending_write;
    e->process_pending_write = ARES_FALSE;
    ares_thread_mutex_unlock(e->mutex);
    if (process_pending_write) {
      ares_process_pending_write(e->channel);
    }

    /* Relock before we loop again */
    ares_thread_mutex_lock(e->mutex);

    /* Each iteration should do timeout processing and any other cleanup
     * that may not have been performed */
    if (e->isup) {
      ares_thread_mutex_unlock(e->mutex);
      ares_process_fds(e->channel, NULL, 0, ARES_PROCESS_FLAG_NONE);
      ares_thread_mutex_lock(e->mutex);
    }
  }

  /* Lets cleanup while we're in the thread itself */
  ares_event_thread_cleanup(e);

  ares_thread_mutex_unlock(e->mutex);

  return NULL;
}

static void ares_event_thread_destroy_int(ares_event_thread_t *e)
{
  /* Wake thread and tell it to shutdown if it exists */
  ares_thread_mutex_lock(e->mutex);
  if (e->isup) {
    e->isup = ARES_FALSE;
    ares_event_thread_wake(e);
  }
  ares_thread_mutex_unlock(e->mutex);

  /* Wait for thread to shutdown */
  if (e->thread) {
    void *rv = NULL;
    ares_thread_join(e->thread, &rv);
    e->thread = NULL;
  }

  /* If the event thread ever got to the point of starting, this is a no-op
   * as it runs this same cleanup when it shuts down */
  ares_event_thread_cleanup(e);

  ares_thread_mutex_destroy(e->mutex);
  e->mutex = NULL;

  ares_free(e);
}

void ares_event_thread_destroy(ares_channel_t *channel)
{
  ares_event_thread_t *e = channel->sock_state_cb_data;

  if (e == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ares_event_thread_destroy_int(e);
  channel->sock_state_cb_data           = NULL;
  channel->sock_state_cb                = NULL;
  channel->notify_pending_write_cb      = NULL;
  channel->notify_pending_write_cb_data = NULL;
}

static const ares_event_sys_t *ares_event_fetch_sys(ares_evsys_t evsys)
{
  switch (evsys) {
    case ARES_EVSYS_WIN32:
#if defined(USE_WINSOCK)
      return &ares_evsys_win32;
#else
      return NULL;
#endif

    case ARES_EVSYS_EPOLL:
#if defined(HAVE_EPOLL)
      return &ares_evsys_epoll;
#else
      return NULL;
#endif

    case ARES_EVSYS_KQUEUE:
#if defined(HAVE_KQUEUE)
      return &ares_evsys_kqueue;
#else
      return NULL;
#endif

    case ARES_EVSYS_POLL:
#if defined(HAVE_POLL)
      return &ares_evsys_poll;
#else
      return NULL;
#endif

    case ARES_EVSYS_SELECT:
#if defined(HAVE_PIPE)
      return &ares_evsys_select;
#else
      return NULL;
#endif

    /* case ARES_EVSYS_DEFAULT: */
    default:
      break;
  }

    /* default */
#if defined(USE_WINSOCK)
  return &ares_evsys_win32;
#elif defined(HAVE_KQUEUE)
  return &ares_evsys_kqueue;
#elif defined(HAVE_EPOLL)
  return &ares_evsys_epoll;
#elif defined(HAVE_POLL)
  return &ares_evsys_poll;
#elif defined(HAVE_PIPE)
  return &ares_evsys_select;
#else
  return NULL;
#endif
}

ares_status_t ares_event_thread_init(ares_channel_t *channel)
{
  ares_event_thread_t *e;

  e = ares_malloc_zero(sizeof(*e));
  if (e == NULL) {
    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  e->mutex = ares_thread_mutex_create();
  if (e->mutex == NULL) {
    ares_event_thread_destroy_int(e); /* LCOV_EXCL_LINE: OutOfMemory */
    return ARES_ENOMEM;               /* LCOV_EXCL_LINE: OutOfMemory */
  }

  e->ev_updates = ares_llist_create(NULL);
  if (e->ev_updates == NULL) {
    ares_event_thread_destroy_int(e); /* LCOV_EXCL_LINE: OutOfMemory */
    return ARES_ENOMEM;               /* LCOV_EXCL_LINE: OutOfMemory */
  }

  e->ev_sock_handles = ares_htable_asvp_create(ares_event_destroy_cb);
  if (e->ev_sock_handles == NULL) {
    ares_event_thread_destroy_int(e); /* LCOV_EXCL_LINE: OutOfMemory */
    return ARES_ENOMEM;               /* LCOV_EXCL_LINE: OutOfMemory */
  }

  e->ev_cust_handles = ares_htable_vpvp_create(NULL, ares_event_destroy_cb);
  if (e->ev_cust_handles == NULL) {
    ares_event_thread_destroy_int(e); /* LCOV_EXCL_LINE: OutOfMemory */
    return ARES_ENOMEM;               /* LCOV_EXCL_LINE: OutOfMemory */
  }

  e->channel = channel;
  e->isup    = ARES_TRUE;
  e->ev_sys  = ares_event_fetch_sys(channel->evsys);
  if (e->ev_sys == NULL) {
    ares_event_thread_destroy_int(e); /* LCOV_EXCL_LINE: UntestablePath */
    return ARES_ENOTIMP;              /* LCOV_EXCL_LINE: UntestablePath */
  }

  channel->sock_state_cb                = ares_event_thread_sockstate_cb;
  channel->sock_state_cb_data           = e;
  channel->notify_pending_write_cb      = notifywrite_cb;
  channel->notify_pending_write_cb_data = e;

  if (!e->ev_sys->init(e)) {
    /* LCOV_EXCL_START: UntestablePath */
    ares_event_thread_destroy_int(e);
    channel->sock_state_cb      = NULL;
    channel->sock_state_cb_data = NULL;
    return ARES_ESERVFAIL;
    /* LCOV_EXCL_STOP */
  }

  /* Before starting the thread, process any possible events the initialization
   * might have enqueued as we may actually depend on these being valid
   * immediately upon return, which may mean before the thread is fully spawned
   * and processed the list itself. We don't want any sort of race conditions
   * (like the event system wake handle itself). */
  ares_event_process_updates(e);

  /* Start thread */
  if (ares_thread_create(&e->thread, ares_event_thread, e) != ARES_SUCCESS) {
    /* LCOV_EXCL_START: UntestablePath */
    ares_event_thread_destroy_int(e);
    channel->sock_state_cb      = NULL;
    channel->sock_state_cb_data = NULL;
    return ARES_ESERVFAIL;
    /* LCOV_EXCL_STOP */
  }

  return ARES_SUCCESS;
}
                          node-23.7.0/deps/cares/src/lib/event/ares_event_wake_pipe.c                                         0000664 0000000 0000000 00000010057 14746647661 0023611 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_event.h"
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef HAVE_FCNTL_H
#  include <fcntl.h>
#endif

#ifdef HAVE_PIPE
typedef struct {
  int filedes[2];
} ares_pipeevent_t;

static void ares_pipeevent_destroy(ares_pipeevent_t *p)
{
  if (p->filedes[0] != -1) {
    close(p->filedes[0]);
  }
  if (p->filedes[1] != -1) {
    close(p->filedes[1]);
  }

  ares_free(p);
}

static void ares_pipeevent_destroy_cb(void *arg)
{
  ares_pipeevent_destroy(arg);
}

static ares_pipeevent_t *ares_pipeevent_init(void)
{
  ares_pipeevent_t *p = ares_malloc_zero(sizeof(*p));
  if (p == NULL) {
    return NULL; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  p->filedes[0] = -1;
  p->filedes[1] = -1;

#  ifdef HAVE_PIPE2
  if (pipe2(p->filedes, O_NONBLOCK | O_CLOEXEC) != 0) {
    ares_pipeevent_destroy(p); /* LCOV_EXCL_LINE: UntestablePath */
    return NULL;               /* LCOV_EXCL_LINE: UntestablePath */
  }
#  else
  if (pipe(p->filedes) != 0) {
    ares_pipeevent_destroy(p);
    return NULL;
  }

#    ifdef O_NONBLOCK
  {
    int val;
    val = fcntl(p->filedes[0], F_GETFL, 0);
    if (val >= 0) {
      val |= O_NONBLOCK;
    }
    fcntl(p->filedes[0], F_SETFL, val);

    val = fcntl(p->filedes[1], F_GETFL, 0);
    if (val >= 0) {
      val |= O_NONBLOCK;
    }
    fcntl(p->filedes[1], F_SETFL, val);
  }
#    endif

#    ifdef FD_CLOEXEC
  fcntl(p->filedes[0], F_SETFD, FD_CLOEXEC);
  fcntl(p->filedes[1], F_SETFD, FD_CLOEXEC);
#    endif
#  endif

#  ifdef F_SETNOSIGPIPE
  fcntl(p->filedes[0], F_SETNOSIGPIPE, 1);
  fcntl(p->filedes[1], F_SETNOSIGPIPE, 1);
#  endif

  return p;
}

static void ares_pipeevent_signal(const ares_event_t *e)
{
  const ares_pipeevent_t *p;

  if (e == NULL || e->data == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  p = e->data;
  (void)write(p->filedes[1], "1", 1);
}

static void ares_pipeevent_cb(ares_event_thread_t *e, ares_socket_t fd,
                              void *data, ares_event_flags_t flags)
{
  unsigned char           buf[32];
  const ares_pipeevent_t *p = NULL;

  (void)e;
  (void)fd;
  (void)flags;

  if (data == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  p = data;

  while (read(p->filedes[0], buf, sizeof(buf)) == sizeof(buf)) {
    /* Do nothing */
  }
}

ares_event_t *ares_pipeevent_create(ares_event_thread_t *e)
{
  ares_event_t     *event = NULL;
  ares_pipeevent_t *p     = NULL;
  ares_status_t     status;

  p = ares_pipeevent_init();
  if (p == NULL) {
    return NULL;
  }

  status = ares_event_update(&event, e, ARES_EVENT_FLAG_READ, ares_pipeevent_cb,
                             p->filedes[0], p, ares_pipeevent_destroy_cb,
                             ares_pipeevent_signal);
  if (status != ARES_SUCCESS) {
    ares_pipeevent_destroy(p); /* LCOV_EXCL_LINE: DefensiveCoding */
    return NULL;               /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  return event;
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/cares/src/lib/event/ares_event_win32.c                                             0000664 0000000 0000000 00000076674 14746647661 0022630 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

/* Uses an anonymous union */
#if defined(__clang__) || defined(__GNUC__)
#  pragma GCC diagnostic push
#  if defined(__clang__)
#    pragma GCC diagnostic ignored "-Wc11-extensions"
#  else
#    pragma GCC diagnostic ignored "-Wpedantic"
#  endif
#endif

#include "ares_private.h"
#include "ares_event.h"
#include "ares_event_win32.h"
#ifdef HAVE_LIMITS_H
#  include <limits.h>
#endif

#if defined(USE_WINSOCK)

/* IMPLEMENTATION NOTES
 * ====================
 *
 * This implementation uses some undocumented functionality within Windows for
 * monitoring sockets. The Ancillary Function Driver (AFD) is the low level
 * implementation that Winsock2 sits on top of.  Winsock2 unfortunately does
 * not expose the equivalent of epoll() or kqueue(), but it is possible to
 * access AFD directly and use along with IOCP to simulate the functionality.
 * We want to use IOCP if possible as it gives us the ability to monitor more
 * than just sockets (WSAPoll is not an option), and perform arbitrary callbacks
 * which means we can hook in non-socket related events.
 *
 * The information for this implementation was gathered from "wepoll" and
 * "libuv" which both use slight variants on this.  We originally went with
 * an implementation methodology more similar to "libuv", but we had a few
 * user reports of crashes during shutdown and memory leaks due to some
 * events not being delivered for cleanup of closed sockets.
 *
 * Initialization:
 *   1. Dynamically load the NtDeviceIoControlFile, NtCreateFile, and
 *      NtCancelIoFileEx internal symbols from ntdll.dll. (Don't believe
 *      Microsoft's documentation for NtCancelIoFileEx as it documents an
 *      invalid prototype). These functions are to open a reference to the
 *      Ancillary Function Driver (AFD), and to submit and cancel POLL
 *      requests.
 *   2. Create an IO Completion Port base handle via CreateIoCompletionPort()
 *      that all socket events will be delivered through.
 *   3. Create a list of AFD Handles and track the number of poll requests
 *      per AFD handle.  When we exceed a pre-determined limit of poll requests
 *      for a handle (128), we will automatically create a new handle.  The
 *      reason behind this is NtCancelIoFileEx uses a horrible algorithm for
 *      issuing cancellations.  See:
 *      https://github.com/python-trio/trio/issues/52#issuecomment-548215128
 *   4. Create a callback to be used to be able to interrupt waiting for IOCP
 *      events, this may be called for allowing enqueuing of additional socket
 *      events or removing socket events. PostQueuedCompletionStatus() is the
 *      obvious choice.  We can use the same container format, the event
 *      delivered won't have an OVERLAPPED pointer so we can differentiate from
 *      socket events.  Use the container as the completion key.
 *
 * Socket Add:
 *   1. Create/Allocate a container for holding metadata about a socket
 *      including:
 *      - SOCKET base_socket;
 *      - IO_STATUS_BLOCK iosb; -- Used by AFD POLL, returned as OVERLAPPED
 *      - AFD_POLL_INFO afd_poll_info; -- Used by AFD POLL
 *      - afd list node -- for tracking which AFD handle a POLL request was
 *        submitted to.
 *   2. Call WSAIoctl(..., SIO_BASE_HANDLE, ...) to unwrap the SOCKET and get
 *      the "base socket" we can use for polling.  It appears this may fail so
 *      we should call WSAIoctl(..., SIO_BSP_HANDLE_POLL, ...) as a fallback.
 *   3. Submit AFD POLL request (see "AFD POLL Request" section)
 *   4. Record a mapping between the "IO Status Block" and the socket container
 *      so when events are delivered we can dereference.
 *
 * Socket Delete:
 *   1. Call
 *      NtCancelIoFileEx(afd, iosb, &temp_iosb);
 *      to cancel any pending operations.
 *   2. Tag the socket container as being queued for deletion
 *   3. Wait for an event to be delivered for the socket (cancel isn't
 *      immediate, it delivers an event to know its complete). Delete only once
 *      that event has been delivered.  If we don't do this we could try to
 *      access free()'d memory at a later point.
 *
 * Socket Modify:
 *   1. Call
 *      NtCancelIoFileEx(afd, iosb, &temp_iosb)
 *      to cancel any pending operation.
 *   2. When the event comes through that the cancel is complete, enqueue
 *      another "AFD Poll Request" for the desired events.
 *
 * Event Wait:
 *   1. Call GetQueuedCompletionStatusEx() with the base IOCP handle, a
 *      stack allocated array of OVERLAPPED_ENTRY's, and an appropriate
 *      timeout.
 *   2. Iterate across returned events, if the lpOverlapped is NULL, then the
 *      the CompletionKey is a pointer to the container registered via
 *      PostQueuedCompletionStatus(), otherwise it is the "IO Status Block"
 *      registered with the "AFD Poll Request" which needs to be dereferenced
 *      to the "socket container".
 *   3. If it is a "socket container", disassociate it from the afd list node
 *      it was previously submitted to.
 *   4. If it is a "socket container" check to see if we are cleaning up, if so,
 *      clean it up.
 *   5. If it is a "socket container" that is still valid, Submit an
 *      AFD POLL Request (see "AFD POLL Request"). We must re-enable the request
 *      each time we receive a response, it is not persistent.
 *   6. Notify of any events received as indicated in the AFD_POLL_INFO
 *      Handles[0].Events (NOTE: check NumberOfHandles > 0, and the status in
 *      the IO_STATUS_BLOCK.  If we received an AFD_POLL_LOCAL_CLOSE, clean up
 *      the connection like the integrator requested it to be cleaned up.
 *
 * AFD Poll Request:
 *   1. Find an afd poll handle in the list that has fewer pending requests than
 *      the limit.
 *   2. If an afd poll handle was not associated (e.g. due to all being over
 *      limit), create a new afd poll handle by calling NtCreateFile()
 *      with path \Device\Afd , then add the AFD handle to the IO Completion
 *      Port.  We can leave the completion key as blank since events for
 *      multiple sockets will be delivered through this and we need to
 *      differentiate via the OVERLAPPED member returned.  Add the new AFD
 *      handle to the list of handles.
 *   3. Initialize the AFD_POLL_INFO structure:
 *      Exclusive         = FALSE; // allow multiple requests
 *      NumberOfHandles   = 1;
 *      Timeout.QuadPart  = LLONG_MAX;
 *      Handles[0].Handle = (HANDLE)base_socket;
 *      Handles[0].Status = 0;
 *      Handles[0].Events = AFD_POLL_LOCAL_CLOSE + additional events to wait for
 *                          such as AFD_POLL_RECEIVE, etc;
 *   4. Zero out the IO_STATUS_BLOCK structures
 *   5. Set the "Status" member of IO_STATUS_BLOCK to STATUS_PENDING
 *   6. Call
 *      NtDeviceIoControlFile(afd, NULL, NULL, &iosb,
 *                            &iosb, IOCTL_AFD_POLL
 *                            &afd_poll_info, sizeof(afd_poll_info),
 *                            &afd_poll_info, sizeof(afd_poll_info));
 *
 *
 * References:
 *   - https://github.com/piscisaureus/wepoll/
 *   - https://github.com/libuv/libuv/
 */

/* Cap the number of outstanding AFD poll requests per AFD handle due to known
 * slowdowns with large lists and NtCancelIoFileEx() */
#  define AFD_POLL_PER_HANDLE 128

#  include <stdarg.h>

/* #  define CARES_DEBUG 1 */

#  ifdef __GNUC__
#    define CARES_PRINTF_LIKE(fmt, args) \
      __attribute__((format(printf, fmt, args)))
#  else
#    define CARES_PRINTF_LIKE(fmt, args)
#  endif

static void CARES_DEBUG_LOG(const char *fmt, ...) CARES_PRINTF_LIKE(1, 2);

static void CARES_DEBUG_LOG(const char *fmt, ...)
{
  va_list ap;

  va_start(ap, fmt);
#  ifdef CARES_DEBUG
  vfprintf(stderr, fmt, ap);
  fflush(stderr);
#  endif
  va_end(ap);
}

typedef struct {
  /* Dynamically loaded symbols */
  NtCreateFile_t          NtCreateFile;
  NtDeviceIoControlFile_t NtDeviceIoControlFile;
  NtCancelIoFileEx_t      NtCancelIoFileEx;

  /* Implementation details */
  ares_slist_t           *afd_handles;
  HANDLE                  iocp_handle;

  /* IO_STATUS_BLOCK * -> ares_evsys_win32_eventdata_t * mapping.  There is
   * no completion key passed to IOCP with this method so we have to look
   * up based on the lpOverlapped returned (which is mapped to IO_STATUS_BLOCK)
   */
  ares_htable_vpvp_t     *sockets;

  /* Flag about whether or not we are shutting down */
  ares_bool_t             is_shutdown;
} ares_evsys_win32_t;

typedef enum {
  POLL_STATUS_NONE    = 0,
  POLL_STATUS_PENDING = 1,
  POLL_STATUS_CANCEL  = 2,
  POLL_STATUS_DESTROY = 3
} poll_status_t;

typedef struct {
  /*! Pointer to parent event container */
  ares_event_t        *event;
  /*! Socket passed in to monitor */
  SOCKET               socket;
  /*! Base socket derived from provided socket */
  SOCKET               base_socket;
  /*! Structure for submitting AFD POLL requests (Internals!) */
  AFD_POLL_INFO        afd_poll_info;
  /*! Status of current polling operation */
  poll_status_t        poll_status;
  /*! IO Status Block structure submitted with AFD POLL requests and returned
   *  with IOCP results as lpOverlapped (even though its a different structure)
   */
  IO_STATUS_BLOCK      iosb;
  /*! AFD handle node an outstanding poll request is associated with */
  ares_slist_node_t   *afd_handle_node;
  /* Lock is only for PostQueuedCompletionStatus() to prevent multiple
   * signals. Tracking via POLL_STATUS_PENDING/POLL_STATUS_NONE */
  ares_thread_mutex_t *lock;
} ares_evsys_win32_eventdata_t;

static size_t ares_evsys_win32_wait(ares_event_thread_t *e,
                                    unsigned long        timeout_ms);

static void   ares_iocpevent_signal(const ares_event_t *event)
{
  ares_event_thread_t          *e           = event->e;
  ares_evsys_win32_t           *ew          = e->ev_sys_data;
  ares_evsys_win32_eventdata_t *ed          = event->data;
  ares_bool_t                   queue_event = ARES_FALSE;

  ares_thread_mutex_lock(ed->lock);
  if (ed->poll_status != POLL_STATUS_PENDING) {
    ed->poll_status = POLL_STATUS_PENDING;
    queue_event     = ARES_TRUE;
  }
  ares_thread_mutex_unlock(ed->lock);

  if (!queue_event) {
    return;
  }

  PostQueuedCompletionStatus(ew->iocp_handle, 0, (ULONG_PTR)event->data, NULL);
}

static void ares_iocpevent_cb(ares_event_thread_t *e, ares_socket_t fd,
                              void *data, ares_event_flags_t flags)
{
  ares_evsys_win32_eventdata_t *ed = data;
  (void)e;
  (void)fd;
  (void)flags;
  ares_thread_mutex_lock(ed->lock);
  ed->poll_status = POLL_STATUS_NONE;
  ares_thread_mutex_unlock(ed->lock);
}

static ares_event_t *ares_iocpevent_create(ares_event_thread_t *e)
{
  ares_event_t *event = NULL;
  ares_status_t status;

  status =
    ares_event_update(&event, e, ARES_EVENT_FLAG_OTHER, ares_iocpevent_cb,
                      ARES_SOCKET_BAD, NULL, NULL, ares_iocpevent_signal);
  if (status != ARES_SUCCESS) {
    return NULL;
  }

  return event;
}

static void ares_evsys_win32_destroy(ares_event_thread_t *e)
{
  ares_evsys_win32_t *ew = NULL;

  if (e == NULL) {
    return;
  }

  CARES_DEBUG_LOG("** Win32 Event Destroy\n");

  ew = e->ev_sys_data;
  if (ew == NULL) {
    return;
  }

  ew->is_shutdown = ARES_TRUE;
  CARES_DEBUG_LOG("  ** waiting on %lu remaining sockets to be destroyed\n",
                  (unsigned long)ares_htable_vpvp_num_keys(ew->sockets));
  while (ares_htable_vpvp_num_keys(ew->sockets)) {
    ares_evsys_win32_wait(e, 0);
  }
  CARES_DEBUG_LOG("  ** all sockets cleaned up\n");


  if (ew->iocp_handle != NULL) {
    CloseHandle(ew->iocp_handle);
  }

  ares_slist_destroy(ew->afd_handles);

  ares_htable_vpvp_destroy(ew->sockets);

  ares_free(ew);
  e->ev_sys_data = NULL;
}

typedef struct {
  size_t poll_cnt;
  HANDLE afd_handle;
} ares_afd_handle_t;

static void ares_afd_handle_destroy(void *arg)
{
  ares_afd_handle_t *hnd = arg;
  if (hnd != NULL && hnd->afd_handle != NULL) {
    CloseHandle(hnd->afd_handle);
  }
  ares_free(hnd);
}

static int ares_afd_handle_cmp(const void *data1, const void *data2)
{
  const ares_afd_handle_t *hnd1 = data1;
  const ares_afd_handle_t *hnd2 = data2;

  if (hnd1->poll_cnt > hnd2->poll_cnt) {
    return 1;
  }
  if (hnd1->poll_cnt < hnd2->poll_cnt) {
    return -1;
  }
  return 0;
}

static void fill_object_attributes(OBJECT_ATTRIBUTES *attr,
                                   UNICODE_STRING *name, ULONG attributes)
{
  memset(attr, 0, sizeof(*attr));
  attr->Length     = sizeof(*attr);
  attr->ObjectName = name;
  attr->Attributes = attributes;
}

#  define UNICODE_STRING_CONSTANT(s) \
    { (sizeof(s) - 1) * sizeof(wchar_t), sizeof(s) * sizeof(wchar_t), L##s }

static ares_slist_node_t *ares_afd_handle_create(ares_evsys_win32_t *ew)
{
  UNICODE_STRING     afd_device_name = UNICODE_STRING_CONSTANT("\\Device\\Afd");
  OBJECT_ATTRIBUTES  afd_attributes;
  NTSTATUS           status;
  IO_STATUS_BLOCK    iosb;
  ares_afd_handle_t *afd  = ares_malloc_zero(sizeof(*afd));
  ares_slist_node_t *node = NULL;
  if (afd == NULL) {
    goto fail;
  }

  /* Open a handle to the AFD subsystem */
  fill_object_attributes(&afd_attributes, &afd_device_name, 0);
  memset(&iosb, 0, sizeof(iosb));
  iosb.Status = STATUS_PENDING;
  status      = ew->NtCreateFile(&afd->afd_handle, SYNCHRONIZE, &afd_attributes,
                                 &iosb, NULL, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 FILE_OPEN, 0, NULL, 0);
  if (status != STATUS_SUCCESS) {
    CARES_DEBUG_LOG("** Failed to create AFD endpoint\n");
    goto fail;
  }

  if (CreateIoCompletionPort(afd->afd_handle, ew->iocp_handle,
                             0 /* CompletionKey */, 0) == NULL) {
    goto fail;
  }

  if (!SetFileCompletionNotificationModes(afd->afd_handle,
                                          FILE_SKIP_SET_EVENT_ON_HANDLE)) {
    goto fail;
  }

  node = ares_slist_insert(ew->afd_handles, afd);
  if (node == NULL) {
    goto fail;
  }

  return node;

fail:

  ares_afd_handle_destroy(afd);
  return NULL;
}

/* Fetch the lowest poll count entry, but if it exceeds the limit, create a
 * new one and return that */
static ares_slist_node_t *ares_afd_handle_fetch(ares_evsys_win32_t *ew)
{
  ares_slist_node_t *node = ares_slist_node_first(ew->afd_handles);
  ares_afd_handle_t *afd  = ares_slist_node_val(node);

  if (afd != NULL && afd->poll_cnt < AFD_POLL_PER_HANDLE) {
    return node;
  }

  return ares_afd_handle_create(ew);
}

static ares_bool_t ares_evsys_win32_init(ares_event_thread_t *e)
{
  ares_evsys_win32_t *ew = NULL;
  HMODULE             ntdll;

  CARES_DEBUG_LOG("** Win32 Event Init\n");

  ew = ares_malloc_zero(sizeof(*ew));
  if (ew == NULL) {
    return ARES_FALSE;
  }

  e->ev_sys_data = ew;

  /* All apps should have ntdll.dll already loaded, so just get a handle to
   * this */
  ntdll = GetModuleHandleA("ntdll.dll");
  if (ntdll == NULL) {
    goto fail;
  }

#  ifdef __GNUC__
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wpedantic"
/* Without the (void *) cast we get:
 *  warning: cast between incompatible function types from 'FARPROC' {aka 'long
 * long int (*)()'} to 'NTSTATUS (*)(...)'} [-Wcast-function-type] but with it
 * we get: warning: ISO C forbids conversion of function pointer to object
 * pointer type [-Wpedantic] look unsolvable short of killing the warning.
 */
#  endif

  /* Load Internal symbols not typically accessible */
  ew->NtCreateFile =
    (NtCreateFile_t)(void *)GetProcAddress(ntdll, "NtCreateFile");
  ew->NtDeviceIoControlFile = (NtDeviceIoControlFile_t)(void *)GetProcAddress(
    ntdll, "NtDeviceIoControlFile");
  ew->NtCancelIoFileEx =
    (NtCancelIoFileEx_t)(void *)GetProcAddress(ntdll, "NtCancelIoFileEx");

#  ifdef __GNUC__
#    pragma GCC diagnostic pop
#  endif

  if (ew->NtCreateFile == NULL || ew->NtCancelIoFileEx == NULL ||
      ew->NtDeviceIoControlFile == NULL) {
    goto fail;
  }

  ew->iocp_handle = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);
  if (ew->iocp_handle == NULL) {
    goto fail;
  }

  ew->afd_handles = ares_slist_create(
    e->channel->rand_state, ares_afd_handle_cmp, ares_afd_handle_destroy);
  if (ew->afd_handles == NULL) {
    goto fail;
  }

  /* Create at least the first afd handle, so we know of any critical system
   * issues during startup */
  if (ares_afd_handle_create(ew) == NULL) {
    goto fail;
  }

  e->ev_signal = ares_iocpevent_create(e);
  if (e->ev_signal == NULL) {
    goto fail;
  }

  ew->sockets = ares_htable_vpvp_create(NULL, NULL);
  if (ew->sockets == NULL) {
    goto fail;
  }

  return ARES_TRUE;

fail:
  ares_evsys_win32_destroy(e);
  return ARES_FALSE;
}

static ares_socket_t ares_evsys_win32_basesocket(ares_socket_t socket)
{
  while (1) {
    DWORD         bytes; /* Not used */
    ares_socket_t base_socket = ARES_SOCKET_BAD;
    int           rv;

    rv = WSAIoctl(socket, SIO_BASE_HANDLE, NULL, 0, &base_socket,
                  sizeof(base_socket), &bytes, NULL, NULL);
    if (rv != SOCKET_ERROR && base_socket != ARES_SOCKET_BAD) {
      socket = base_socket;
      break;
    }

    /* If we're here, an error occurred */
    if (GetLastError() == WSAENOTSOCK) {
      /* This is critical, exit */
      return ARES_SOCKET_BAD;
    }

    /* Work around known bug in Komodia based LSPs, use ARES_BSP_HANDLE_POLL
     * to retrieve the underlying socket to then loop and get the base socket:
     *  https://docs.microsoft.com/en-us/windows/win32/winsock/winsock-ioctls
     *  https://www.komodia.com/newwiki/index.php?title=Komodia%27s_Redirector_bug_fixes#Version_2.2.2.6
     */
    base_socket = ARES_SOCKET_BAD;
    rv          = WSAIoctl(socket, SIO_BSP_HANDLE_POLL, NULL, 0, &base_socket,
                           sizeof(base_socket), &bytes, NULL, NULL);

    if (rv != SOCKET_ERROR && base_socket != ARES_SOCKET_BAD &&
        base_socket != socket) {
      socket = base_socket;
      continue; /* loop! */
    }

    return ARES_SOCKET_BAD;
  }

  return socket;
}

static ares_bool_t ares_evsys_win32_afd_enqueue(ares_event_t      *event,
                                                ares_event_flags_t flags)
{
  ares_event_thread_t          *e  = event->e;
  ares_evsys_win32_t           *ew = e->ev_sys_data;
  ares_evsys_win32_eventdata_t *ed = event->data;
  ares_afd_handle_t            *afd;
  NTSTATUS                      status;

  if (e == NULL || ed == NULL || ew == NULL) {
    return ARES_FALSE;
  }

  /* Misuse */
  if (ed->poll_status != POLL_STATUS_NONE) {
    return ARES_FALSE;
  }

  ed->afd_handle_node = ares_afd_handle_fetch(ew);
  /* System resource issue? */
  if (ed->afd_handle_node == NULL) {
    return ARES_FALSE;
  }

  afd = ares_slist_node_val(ed->afd_handle_node);

  /* Enqueue AFD Poll */
  ed->afd_poll_info.Exclusive         = FALSE;
  ed->afd_poll_info.NumberOfHandles   = 1;
  ed->afd_poll_info.Timeout.QuadPart  = LLONG_MAX;
  ed->afd_poll_info.Handles[0].Handle = (HANDLE)ed->base_socket;
  ed->afd_poll_info.Handles[0].Status = 0;
  ed->afd_poll_info.Handles[0].Events = AFD_POLL_LOCAL_CLOSE;

  if (flags & ARES_EVENT_FLAG_READ) {
    ed->afd_poll_info.Handles[0].Events |=
      (AFD_POLL_RECEIVE | AFD_POLL_DISCONNECT | AFD_POLL_ACCEPT |
       AFD_POLL_ABORT);
  }
  if (flags & ARES_EVENT_FLAG_WRITE) {
    ed->afd_poll_info.Handles[0].Events |=
      (AFD_POLL_SEND | AFD_POLL_CONNECT_FAIL);
  }
  if (flags == 0) {
    ed->afd_poll_info.Handles[0].Events |= AFD_POLL_DISCONNECT;
  }

  memset(&ed->iosb, 0, sizeof(ed->iosb));
  ed->iosb.Status = STATUS_PENDING;

  status = ew->NtDeviceIoControlFile(
    afd->afd_handle, NULL, NULL, &ed->iosb, &ed->iosb, IOCTL_AFD_POLL,
    &ed->afd_poll_info, sizeof(ed->afd_poll_info), &ed->afd_poll_info,
    sizeof(ed->afd_poll_info));
  if (status != STATUS_SUCCESS && status != STATUS_PENDING) {
    CARES_DEBUG_LOG("** afd_enqueue ed=%p FAILED\n", (void *)ed);
    ed->afd_handle_node = NULL;
    return ARES_FALSE;
  }

  /* Record that we submitted a poll request to this handle and tell it to
   * re-sort the node since we changed its sort value */
  afd->poll_cnt++;
  ares_slist_node_reinsert(ed->afd_handle_node);

  ed->poll_status = POLL_STATUS_PENDING;
  CARES_DEBUG_LOG("++ afd_enqueue ed=%p flags=%X\n", (void *)ed,
                  (unsigned int)flags);
  return ARES_TRUE;
}

static ares_bool_t ares_evsys_win32_afd_cancel(ares_evsys_win32_eventdata_t *ed)
{
  IO_STATUS_BLOCK     cancel_iosb;
  ares_evsys_win32_t *ew;
  NTSTATUS            status;
  ares_afd_handle_t  *afd;

  ew = ed->event->e->ev_sys_data;

  /* Misuse */
  if (ed->poll_status != POLL_STATUS_PENDING) {
    return ARES_FALSE;
  }

  afd = ares_slist_node_val(ed->afd_handle_node);

  /* Misuse */
  if (afd == NULL) {
    return ARES_FALSE;
  }

  ed->poll_status = POLL_STATUS_CANCEL;

  /* Not pending, nothing to do. Most likely that means there is a pending
   * event that hasn't yet been delivered otherwise it would be re-armed
   * already */
  if (ed->iosb.Status != STATUS_PENDING) {
    CARES_DEBUG_LOG("** cancel not needed for ed=%p\n", (void *)ed);
    return ARES_FALSE;
  }

  status = ew->NtCancelIoFileEx(afd->afd_handle, &ed->iosb, &cancel_iosb);

  CARES_DEBUG_LOG("** Enqueued cancel for ed=%p, status = %lX\n", (void *)ed,
                  status);

  /* NtCancelIoFileEx() may return STATUS_NOT_FOUND if the operation completed
   * just before calling NtCancelIoFileEx(), but we have not yet received the
   * notifiction (but it should be queued for the next IOCP event).  */
  if (status == STATUS_SUCCESS || status == STATUS_NOT_FOUND) {
    return ARES_TRUE;
  }

  return ARES_FALSE;
}

static void ares_evsys_win32_eventdata_destroy(ares_evsys_win32_t           *ew,
                                               ares_evsys_win32_eventdata_t *ed)
{
  if (ew == NULL || ed == NULL) {
    return;
  }
  CARES_DEBUG_LOG("-- deleting ed=%p (%s)\n", (void *)ed,
                  (ed->socket == ARES_SOCKET_BAD) ? "data" : "socket");
  /* These type of handles are deferred destroy. Update tracking. */
  if (ed->socket != ARES_SOCKET_BAD) {
    ares_htable_vpvp_remove(ew->sockets, &ed->iosb);
  }

  ares_thread_mutex_destroy(ed->lock);

  if (ed->event != NULL) {
    ed->event->data = NULL;
  }

  ares_free(ed);
}

static ares_bool_t ares_evsys_win32_event_add(ares_event_t *event)
{
  ares_event_thread_t          *e  = event->e;
  ares_evsys_win32_t           *ew = e->ev_sys_data;
  ares_evsys_win32_eventdata_t *ed;
  ares_bool_t                   rc = ARES_FALSE;

  ed              = ares_malloc_zero(sizeof(*ed));
  ed->event       = event;
  ed->socket      = event->fd;
  ed->base_socket = ARES_SOCKET_BAD;
  event->data     = ed;

  CARES_DEBUG_LOG("++ add ed=%p (%s) flags=%X\n", (void *)ed,
                  (ed->socket == ARES_SOCKET_BAD) ? "data" : "socket",
                  (unsigned int)event->flags);

  /* Likely a signal event, not something we will directly handle.  We create
   * the ares_evsys_win32_eventdata_t as the placeholder to use as the
   * IOCP Completion Key */
  if (ed->socket == ARES_SOCKET_BAD) {
    ed->lock = ares_thread_mutex_create();
    if (ed->lock == NULL) {
      goto done;
    }
    rc = ARES_TRUE;
    goto done;
  }

  ed->base_socket = ares_evsys_win32_basesocket(ed->socket);
  if (ed->base_socket == ARES_SOCKET_BAD) {
    goto done;
  }

  if (!ares_htable_vpvp_insert(ew->sockets, &ed->iosb, ed)) {
    goto done;
  }

  if (!ares_evsys_win32_afd_enqueue(event, event->flags)) {
    goto done;
  }

  rc = ARES_TRUE;

done:
  if (!rc) {
    ares_evsys_win32_eventdata_destroy(ew, ed);
    event->data = NULL;
  }
  return rc;
}

static void ares_evsys_win32_event_del(ares_event_t *event)
{
  ares_evsys_win32_eventdata_t *ed = event->data;

  /* Already cleaned up, likely a LOCAL_CLOSE */
  if (ed == NULL) {
    return;
  }

  CARES_DEBUG_LOG("-- DELETE requested for ed=%p (%s)\n", (void *)ed,
                  (ed->socket != ARES_SOCKET_BAD) ? "socket" : "data");

  /*
   * Cancel pending AFD Poll operation.
   */
  if (ed->socket != ARES_SOCKET_BAD) {
    ares_evsys_win32_afd_cancel(ed);
    ed->poll_status = POLL_STATUS_DESTROY;
    ed->event       = NULL;
  } else {
    ares_evsys_win32_eventdata_destroy(event->e->ev_sys_data, ed);
  }

  event->data = NULL;
}

static void ares_evsys_win32_event_mod(ares_event_t      *event,
                                       ares_event_flags_t new_flags)
{
  ares_evsys_win32_eventdata_t *ed = event->data;

  /* Not for us */
  if (event->fd == ARES_SOCKET_BAD || ed == NULL) {
    return;
  }

  CARES_DEBUG_LOG("** mod ed=%p new_flags=%X\n", (void *)ed,
                  (unsigned int)new_flags);

  /* All we need to do is cancel the pending operation.  When the event gets
   * delivered for the cancellation, it will automatically re-enqueue a new
   * event */
  ares_evsys_win32_afd_cancel(ed);
}

static ares_bool_t ares_evsys_win32_process_other_event(
  ares_evsys_win32_t *ew, ares_evsys_win32_eventdata_t *ed, size_t i)
{
  ares_event_t *event;

  /* NOTE: do NOT dereference 'ed' if during shutdown as this could be an
   * invalid pointer if the signal handle was cleaned up, but there was still a
   * pending event! */

  if (ew->is_shutdown) {
    CARES_DEBUG_LOG("\t\t** i=%lu, skip non-socket handle during shutdown\n",
                    (unsigned long)i);
    return ARES_FALSE;
  }

  event = ed->event;
  CARES_DEBUG_LOG("\t\t** i=%lu, ed=%p (data)\n", (unsigned long)i, (void *)ed);

  event->cb(event->e, event->fd, event->data, ARES_EVENT_FLAG_OTHER);
  return ARES_TRUE;
}

static ares_bool_t ares_evsys_win32_process_socket_event(
  ares_evsys_win32_t *ew, ares_evsys_win32_eventdata_t *ed, size_t i)
{
  ares_event_flags_t flags = 0;
  ares_event_t      *event = NULL;
  ares_afd_handle_t *afd   = NULL;

  /* Shouldn't be possible */
  if (ed == NULL) {
    CARES_DEBUG_LOG("\t\t** i=%lu, Invalid handle.\n", (unsigned long)i);
    return ARES_FALSE;
  }

  event = ed->event;

  CARES_DEBUG_LOG("\t\t** i=%lu, ed=%p (socket)\n", (unsigned long)i,
                  (void *)ed);

  /* Process events */
  if (ed->poll_status == POLL_STATUS_PENDING &&
      ed->iosb.Status == STATUS_SUCCESS &&
      ed->afd_poll_info.NumberOfHandles > 0) {
    if (ed->afd_poll_info.Handles[0].Events &
        (AFD_POLL_RECEIVE | AFD_POLL_DISCONNECT | AFD_POLL_ACCEPT |
         AFD_POLL_ABORT)) {
      flags |= ARES_EVENT_FLAG_READ;
    }
    if (ed->afd_poll_info.Handles[0].Events &
        (AFD_POLL_SEND | AFD_POLL_CONNECT_FAIL)) {
      flags |= ARES_EVENT_FLAG_WRITE;
    }
    if (ed->afd_poll_info.Handles[0].Events & AFD_POLL_LOCAL_CLOSE) {
      CARES_DEBUG_LOG("\t\t** ed=%p LOCAL CLOSE\n", (void *)ed);
      ed->poll_status = POLL_STATUS_DESTROY;
    }
  }

  CARES_DEBUG_LOG("\t\t** ed=%p, iosb status=%lX, poll_status=%d, flags=%X\n",
                  (void *)ed, (unsigned long)ed->iosb.Status,
                  (int)ed->poll_status, (unsigned int)flags);

  /* Decrement poll count for AFD handle then resort, also disassociate
   * with socket */
  afd = ares_slist_node_val(ed->afd_handle_node);
  afd->poll_cnt--;
  ares_slist_node_reinsert(ed->afd_handle_node);
  ed->afd_handle_node = NULL;

  /* Pending destroy, go ahead and kill it */
  if (ed->poll_status == POLL_STATUS_DESTROY) {
    ares_evsys_win32_eventdata_destroy(ew, ed);
    return ARES_FALSE;
  }

  ed->poll_status = POLL_STATUS_NONE;

  /* Mask flags against current desired flags.  We could have an event
   * queued that is outdated. */
  flags &= event->flags;

  /* Don't actually do anything with the event that was delivered as we are
   * in a shutdown/cleanup process.  Mostly just handling the delayed
   * destruction of sockets */
  if (ew->is_shutdown) {
    return ARES_FALSE;
  }

  /* Re-enqueue so we can get more events on the socket, we either
   * received a real event, or a cancellation notice.  Both cases we
   * re-queue using the current configured event flags.
   *
   * If we can't re-enqueue, that likely means the socket has been
   * closed, so we want to kill our reference to it
   */
  if (!ares_evsys_win32_afd_enqueue(event, event->flags)) {
    ares_evsys_win32_eventdata_destroy(ew, ed);
    return ARES_FALSE;
  }

  /* No events we recognize to deliver */
  if (flags == 0) {
    return ARES_FALSE;
  }

  event->cb(event->e, event->fd, event->data, flags);
  return ARES_TRUE;
}

static size_t ares_evsys_win32_wait(ares_event_thread_t *e,
                                    unsigned long        timeout_ms)
{
  ares_evsys_win32_t *ew = e->ev_sys_data;
  OVERLAPPED_ENTRY    entries[16];
  ULONG               maxentries = sizeof(entries) / sizeof(*entries);
  ULONG               nentries;
  BOOL                status;
  size_t              i;
  size_t              cnt  = 0;
  DWORD               tout = (timeout_ms == 0) ? INFINITE : (DWORD)timeout_ms;

  CARES_DEBUG_LOG("** Wait Enter\n");
  /* Process in a loop for as long as it fills the entire entries buffer, and
   * on subsequent attempts, ensure the timeout is 0 */
  do {
    nentries = maxentries;
    status   = GetQueuedCompletionStatusEx(ew->iocp_handle, entries, nentries,
                                           &nentries, tout, FALSE);

    /* Next loop around, we want to return instantly if there are no events to
     * be processed */
    tout = 0;

    if (!status) {
      break;
    }

    CARES_DEBUG_LOG("\t** GetQueuedCompletionStatusEx returned %lu entries\n",
                    (unsigned long)nentries);
    for (i = 0; i < (size_t)nentries; i++) {
      ares_evsys_win32_eventdata_t *ed = NULL;
      ares_bool_t                   rc;

      /* For things triggered via PostQueuedCompletionStatus() we have an
       * lpCompletionKey we can just use.  Otherwise we need to dereference the
       * pointer returned in lpOverlapped to determine the referenced
       * socket */
      if (entries[i].lpCompletionKey) {
        ed = (ares_evsys_win32_eventdata_t *)entries[i].lpCompletionKey;
        rc = ares_evsys_win32_process_other_event(ew, ed, i);
      } else {
        ed = ares_htable_vpvp_get_direct(ew->sockets, entries[i].lpOverlapped);
        rc = ares_evsys_win32_process_socket_event(ew, ed, i);
      }

      /* We processed actual events */
      if (rc) {
        cnt++;
      }
    }
  } while (nentries == maxentries);

  CARES_DEBUG_LOG("** Wait Exit\n");

  return cnt;
}

const ares_event_sys_t ares_evsys_win32 = { "win32",
                                            ares_evsys_win32_init,
                                            ares_evsys_win32_destroy,
                                            ares_evsys_win32_event_add,
                                            ares_evsys_win32_event_del,
                                            ares_evsys_win32_event_mod,
                                            ares_evsys_win32_wait };
#endif

#if defined(__clang__) || defined(__GNUC__)
#  pragma GCC diagnostic pop
#endif
                                                                    node-23.7.0/deps/cares/src/lib/event/ares_event_win32.h                                             0000664 0000000 0000000 00000013216 14746647661 0022614 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES_EVENT_WIN32_H
#define __ARES_EVENT_WIN32_H

#ifdef _WIN32
#  ifdef HAVE_WINSOCK2_H
#    include <winsock2.h>
#  endif
#  ifdef HAVE_WS2TCPIP_H
#    include <ws2tcpip.h>
#  endif
#  ifdef HAVE_MSWSOCK_H
#    include <mswsock.h>
#  endif
#  ifdef HAVE_WINDOWS_H
#    include <windows.h>
#  endif

/* From winternl.h */

/* If WDK is not installed and not using MinGW, provide the needed definitions
 */
typedef LONG NTSTATUS;

typedef struct _IO_STATUS_BLOCK {
  union {
    NTSTATUS Status;
    PVOID    Pointer;
  };

  ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef VOID(NTAPI *PIO_APC_ROUTINE)(PVOID            ApcContext,
                                     PIO_STATUS_BLOCK IoStatusBlock,
                                     ULONG            Reserved);

/* From ntstatus.h */
#  define STATUS_SUCCESS ((NTSTATUS)0x00000000)
#  ifndef STATUS_PENDING
#    define STATUS_PENDING ((NTSTATUS)0x00000103L)
#  endif
#  define STATUS_CANCELLED ((NTSTATUS)0xC0000120L)
#  define STATUS_NOT_FOUND ((NTSTATUS)0xC0000225L)

typedef struct _UNICODE_STRING {
  USHORT  Length;
  USHORT  MaximumLength;
  LPCWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
  ULONG           Length;
  HANDLE          RootDirectory;
  PUNICODE_STRING ObjectName;
  ULONG           Attributes;
  PVOID           SecurityDescriptor;
  PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

#  ifndef FILE_OPEN
#    define FILE_OPEN 0x00000001UL
#  endif

/* Not sure what headers might have these */
#  define IOCTL_AFD_POLL 0x00012024

#  define AFD_POLL_RECEIVE_BIT           0
#  define AFD_POLL_RECEIVE               (1 << AFD_POLL_RECEIVE_BIT)
#  define AFD_POLL_RECEIVE_EXPEDITED_BIT 1
#  define AFD_POLL_RECEIVE_EXPEDITED     (1 << AFD_POLL_RECEIVE_EXPEDITED_BIT)
#  define AFD_POLL_SEND_BIT              2
#  define AFD_POLL_SEND                  (1 << AFD_POLL_SEND_BIT)
#  define AFD_POLL_DISCONNECT_BIT        3
#  define AFD_POLL_DISCONNECT            (1 << AFD_POLL_DISCONNECT_BIT)
#  define AFD_POLL_ABORT_BIT             4
#  define AFD_POLL_ABORT                 (1 << AFD_POLL_ABORT_BIT)
#  define AFD_POLL_LOCAL_CLOSE_BIT       5
#  define AFD_POLL_LOCAL_CLOSE           (1 << AFD_POLL_LOCAL_CLOSE_BIT)
#  define AFD_POLL_CONNECT_BIT           6
#  define AFD_POLL_CONNECT               (1 << AFD_POLL_CONNECT_BIT)
#  define AFD_POLL_ACCEPT_BIT            7
#  define AFD_POLL_ACCEPT                (1 << AFD_POLL_ACCEPT_BIT)
#  define AFD_POLL_CONNECT_FAIL_BIT      8
#  define AFD_POLL_CONNECT_FAIL          (1 << AFD_POLL_CONNECT_FAIL_BIT)
#  define AFD_POLL_QOS_BIT               9
#  define AFD_POLL_QOS                   (1 << AFD_POLL_QOS_BIT)
#  define AFD_POLL_GROUP_QOS_BIT         10
#  define AFD_POLL_GROUP_QOS             (1 << AFD_POLL_GROUP_QOS_BIT)

#  define AFD_NUM_POLL_EVENTS 11
#  define AFD_POLL_ALL        ((1 << AFD_NUM_POLL_EVENTS) - 1)

typedef struct _AFD_POLL_HANDLE_INFO {
  HANDLE   Handle;
  ULONG    Events;
  NTSTATUS Status;
} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;

typedef struct _AFD_POLL_INFO {
  LARGE_INTEGER        Timeout;
  ULONG                NumberOfHandles;
  ULONG                Exclusive;
  AFD_POLL_HANDLE_INFO Handles[1];
} AFD_POLL_INFO, *PAFD_POLL_INFO;

/* Prototypes for dynamically loaded functions from ntdll.dll */
typedef NTSTATUS(NTAPI *NtCancelIoFileEx_t)(HANDLE           FileHandle,
                                            PIO_STATUS_BLOCK IoRequestToCancel,
                                            PIO_STATUS_BLOCK IoStatusBlock);
typedef NTSTATUS(NTAPI *NtDeviceIoControlFile_t)(
  HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext,
  PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer,
  ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);

typedef NTSTATUS(NTAPI *NtCreateFile_t)(
  PHANDLE FileHandle, ACCESS_MASK DesiredAccess,
  POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,
  PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess,
  ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);

/* On UWP/Windows Store, these definitions aren't there for some reason */
#  ifndef SIO_BSP_HANDLE_POLL
#    define SIO_BSP_HANDLE_POLL 0x4800001D
#  endif

#  ifndef SIO_BASE_HANDLE
#    define SIO_BASE_HANDLE 0x48000022
#  endif

#  ifndef HANDLE_FLAG_INHERIT
#    define HANDLE_FLAG_INHERIT 0x00000001
#  endif

#endif /* _WIN32 */

#endif /* __ARES_EVENT_WIN32_H */
                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/cares/src/lib/include/                                                             0000775 0000000 0000000 00000000000 14746647661 0017565 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/include/ares_array.h                                                 0000664 0000000 0000000 00000027512 14746647661 0022075 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__ARRAY_H
#define __ARES__ARRAY_H

#include "ares.h"

/*! \addtogroup ares_array Array Data Structure
 *
 * This is an array with helpers.  It is meant to have as little overhead
 * as possible over direct array management by applications but to provide
 * safety and some optimization features.  It can also return the array in
 * native form once all manipulation has been performed.
 *
 * @{
 */

struct ares_array;

/*! Opaque data structure for array */
typedef struct ares_array ares_array_t;

/*! Callback to free user-defined member data
 *
 *  \param[in] data  pointer to member of array to be destroyed. The pointer
 *                   itself must not be destroyed, just the data it contains.
 */
typedef void (*ares_array_destructor_t)(void *data);

/*! Callback to compare two array elements used for sorting
 *
 *  \param[in] data1 array member 1
 *  \param[in] data2 array member 2
 *  \return < 0 if data1 < data2, > 0 if data1 > data2, 0 if data1 == data2
 */
typedef int (*ares_array_cmp_t)(const void *data1, const void *data2);

/*! Create an array object
 *
 *  NOTE: members of the array are typically going to be an going to be a
 *        struct with compiler/ABI specific padding to ensure proper alignment.
 *        Care needs to be taken if using primitive types, especially floating
 *        point numbers which size may not indicate the required alignment.
 *        For example, a double may be 80 bits (10 bytes), but required
 *        alignment of 16 bytes.  In such a case, a member_size of 16 would be
 *        required to be used.
 *
 *  \param[in] destruct     Optional. Destructor to call on a removed member
 *  \param[in] member_size  Size of array member, usually determined using
 *                          sizeof() for the member such as a struct.
 *
 *  \return array object or NULL on out of memory
 */
CARES_EXTERN ares_array_t *ares_array_create(size_t member_size,
                                             ares_array_destructor_t destruct);


/*! Request the array be at least the requested size.  Useful if the desired
 *  array size is known prior to populating the array to prevent reallocations.
 *
 *  \param[in] arr  Initialized array object.
 *  \param[in] size Minimum number of members
 *  \return ARES_SUCCESS on success, ARES_EFORMERR on misuse,
 *    ARES_ENOMEM on out of memory */
CARES_EXTERN ares_status_t ares_array_set_size(ares_array_t *arr, size_t size);

/*! Sort the array using the given comparison function.  This is not
 *  persistent, any future elements inserted will not maintain this sort.
 *
 *  \param[in]  arr      Initialized array object.
 *  \param[in]  cb       Sort callback
 *  \return ARES_SUCCESS on success
 */
CARES_EXTERN ares_status_t ares_array_sort(ares_array_t    *arr,
                                           ares_array_cmp_t cmp);

/*! Destroy an array object.  If a destructor is set, will be called on each
 *  member of the array.
 *
 *  \param[in] arr     Initialized array object.
 */
CARES_EXTERN void          ares_array_destroy(ares_array_t *arr);

/*! Retrieve the array in the native format.  This will also destroy the
 *  container.  It is the responsibility of the caller to free the returned
 *  pointer and also any data within each array element.
 *
 *  \param[in] arr  Initialized array object
 *  \param[out] num_members the number of members in the returned array
 *  \return pointer to native array on success, NULL on failure.
 */
CARES_EXTERN void  *ares_array_finish(ares_array_t *arr, size_t *num_members);

/*! Retrieve the number of members in the array
 *
 *  \param[in] arr     Initialized array object.
 *  \return numbrer of members
 */
CARES_EXTERN size_t ares_array_len(const ares_array_t *arr);

/*! Insert a new array member at the given index
 *
 *  \param[out] elem_ptr Optional. Pointer to the returned array element.
 *  \param[in]  arr      Initialized array object.
 *  \param[in]  idx      Index in array to place new element, will shift any
 *                       elements down that exist after this point.
 *  \return ARES_SUCCESS on success, ARES_EFORMERR on bad index,
 *          ARES_ENOMEM on out of memory.
 */
CARES_EXTERN ares_status_t ares_array_insert_at(void        **elem_ptr,
                                                ares_array_t *arr, size_t idx);

/*! Insert a new array member at the end of the array
 *
 *  \param[out] elem_ptr Optional. Pointer to the returned array element.
 *  \param[in]  arr      Initialized array object.
 *  \return ARES_SUCCESS on success, ARES_ENOMEM on out of memory.
 */
CARES_EXTERN ares_status_t ares_array_insert_last(void        **elem_ptr,
                                                  ares_array_t *arr);

/*! Insert a new array member at the beginning of the array
 *
 *  \param[out] elem_ptr Optional. Pointer to the returned array element.
 *  \param[in]  arr      Initialized array object.
 *  \return ARES_SUCCESS on success, ARES_ENOMEM on out of memory.
 */
CARES_EXTERN ares_status_t ares_array_insert_first(void        **elem_ptr,
                                                   ares_array_t *arr);


/*! Insert a new array member at the given index and copy the data pointed
 *  to by the data pointer into the array.  This will copy member_size bytes
 *  from the provided pointer, this may not be safe for some data types
 *  that may have a smaller size than the provided member_size which includes
 *  padding as discussed in ares_array_create().
 *
 *  \param[in]  arr      Initialized array object.
 *  \param[in]  idx      Index in array to place new element, will shift any
 *                       elements down that exist after this point.
 *  \param[in]  data_ptr Pointer to data to copy into array.
 *  \return ARES_SUCCESS on success, ARES_EFORMERR on bad index or null data
 * ptr, ARES_ENOMEM on out of memory.
 */
CARES_EXTERN ares_status_t ares_array_insertdata_at(ares_array_t *arr,
                                                    size_t        idx,
                                                    const void   *data_ptr);

/*! Insert a new array member at the end of the array and copy the data pointed
 *  to by the data pointer into the array.  This will copy member_size bytes
 *  from the provided pointer, this may not be safe for some data types
 *  that may have a smaller size than the provided member_size which includes
 *  padding as discussed in ares_array_create().
 *
 *  \param[in]  arr      Initialized array object.
 *  \param[in]  data_ptr Pointer to data to copy into array.
 *  \return ARES_SUCCESS on success, ARES_EFORMERR on bad index or null data
 * ptr, ARES_ENOMEM on out of memory.
 */
CARES_EXTERN ares_status_t ares_array_insertdata_last(ares_array_t *arr,
                                                      const void   *data_ptr);

/*! Insert a new array member at the beginning of the array and copy the data
 * pointed to by the data pointer into the array.  This will copy member_size
 * bytes from the provided pointer, this may not be safe for some data types
 *  that may have a smaller size than the provided member_size which includes
 *  padding as discussed in ares_array_create().
 *
 *  \param[in]  arr      Initialized array object.
 *  \param[in]  data_ptr Pointer to data to copy into array.
 *  \return ARES_SUCCESS on success, ARES_EFORMERR on bad index or null data
 * ptr, ARES_ENOMEM on out of memory.
 */
CARES_EXTERN ares_status_t ares_array_insertdata_first(ares_array_t *arr,
                                                       const void   *data_ptr);

/*! Fetch a pointer to the given element in the array
 *  \param[in]  array  Initialized array object
 *  \param[in]  idx    Index to fetch
 *  \return pointer on success, NULL on failure */
CARES_EXTERN void         *ares_array_at(ares_array_t *arr, size_t idx);

/*! Fetch a pointer to the first element in the array
 *  \param[in]  array  Initialized array object
 *  \return pointer on success, NULL on failure */
CARES_EXTERN void         *ares_array_first(ares_array_t *arr);

/*! Fetch a pointer to the last element in the array
 *  \param[in]  array  Initialized array object
 *  \return pointer on success, NULL on failure */
CARES_EXTERN void         *ares_array_last(ares_array_t *arr);

/*! Fetch a constant pointer to the given element in the array
 *  \param[in]  array  Initialized array object
 *  \param[in]  idx    Index to fetch
 *  \return pointer on success, NULL on failure */
CARES_EXTERN const void   *ares_array_at_const(const ares_array_t *arr,
                                               size_t              idx);

/*! Fetch a constant pointer to the first element in the array
 *  \param[in]  array  Initialized array object
 *  \return pointer on success, NULL on failure */
CARES_EXTERN const void   *ares_array_first_const(const ares_array_t *arr);

/*! Fetch a constant pointer to the last element in the array
 *  \param[in]  array  Initialized array object
 *  \return pointer on success, NULL on failure */
CARES_EXTERN const void   *ares_array_last_const(const ares_array_t *arr);

/*! Claim the data from the specified array index, copying it to the buffer
 *  provided by the caller.  The index specified in the array will then be
 *  removed (without calling any possible destructor)
 *
 *  \param[in,out] dest      Optional. Buffer to hold array member. Pass NULL
 *                           if not needed.  This could leak memory if array
 *                           member needs destructor if not provided.
 *  \param[in]     dest_size Size of buffer provided, used as a sanity check.
 *                           Must match member_size provided to
 *                           ares_array_create() if dest_size specified.
 *  \param[in]     arr       Initialized array object
 *  \param[in]     idx       Index to claim
 *  \return ARES_SUCCESS on success, ARES_EFORMERR on usage failure.
 */
CARES_EXTERN ares_status_t ares_array_claim_at(void *dest, size_t dest_size,
                                               ares_array_t *arr, size_t idx);

/*! Remove the member at the specified array index.  The destructor will be
 *  called.
 *
 *  \param[in] arr  Initialized array object
 *  \param[in] idx  Index to remove
 *  \return ARES_SUCCESS if removed, ARES_EFORMERR on invalid use
 */
CARES_EXTERN ares_status_t ares_array_remove_at(ares_array_t *arr, size_t idx);

/*! Remove the first member of the array.
 *
 *  \param[in] arr  Initialized array object
 *  \return ARES_SUCCESS if removed, ARES_EFORMERR on invalid use
 */
CARES_EXTERN ares_status_t ares_array_remove_first(ares_array_t *arr);

/*! Remove the last member of the array.
 *
 *  \param[in] arr  Initialized array object
 *  \return ARES_SUCCESS if removed, ARES_EFORMERR on invalid use
 */
CARES_EXTERN ares_status_t ares_array_remove_last(ares_array_t *arr);


/*! @} */

#endif /* __ARES__ARRAY_H */
                                                                                                                                                                                      node-23.7.0/deps/cares/src/lib/include/ares_buf.h                                                   0000664 0000000 0000000 00000101471 14746647661 0021530 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__BUF_H
#define __ARES__BUF_H

#include "ares.h"
#include "ares_array.h"

/*! \addtogroup ares_buf Safe Data Builder and buffer
 *
 * This is a buffer building and parsing framework with a focus on security over
 * performance. All data to be read from the buffer will perform explicit length
 * validation and return a success/fail result.  There are also various helpers
 * for writing data to the buffer which dynamically grows.
 *
 * All operations that fetch or consume data from the buffer will move forward
 * the internal pointer, thus marking the data as processed which may no longer
 * be accessible after certain operations (such as append).
 *
 * The helpers for this object are meant to be added as needed.  If you can't
 * find it, write it!
 *
 * @{
 */
struct ares_buf;

/*! Opaque data type for generic hash table implementation */
typedef struct ares_buf     ares_buf_t;

/*! Create a new buffer object that dynamically allocates buffers for data.
 *
 *  \return initialized buffer object or NULL if out of memory.
 */
CARES_EXTERN ares_buf_t    *ares_buf_create(void);

/*! Create a new buffer object that uses a user-provided data pointer.  The
 *  data provided will not be manipulated, and cannot be appended to.  This
 *  is strictly used for parsing.
 *
 *  \param[in] data     Data to provide to buffer, must not be NULL.
 *  \param[in] data_len Size of buffer provided, must be > 0
 *
 *  \return initialized buffer object or NULL if out of memory or misuse.
 */
CARES_EXTERN ares_buf_t    *ares_buf_create_const(const unsigned char *data,
                                                  size_t               data_len);


/*! Destroy an initialized buffer object.
 *
 *  \param[in] buf  Initialized buf object
 */
CARES_EXTERN void           ares_buf_destroy(ares_buf_t *buf);


/*! Append multiple bytes to a dynamic buffer object
 *
 *  \param[in] buf      Initialized buffer object
 *  \param[in] data     Data to copy to buffer object
 *  \param[in] data_len Length of data to copy to buffer object.
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t  ares_buf_append(ares_buf_t          *buf,
                                            const unsigned char *data,
                                            size_t               data_len);

/*! Append a single byte to the dynamic buffer object
 *
 *  \param[in] buf      Initialized buffer object
 *  \param[in] b        Single byte to append to buffer object.
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t  ares_buf_append_byte(ares_buf_t   *buf,
                                                 unsigned char b);

/*! Append a null-terminated string to the dynamic buffer object
 *
 *  \param[in] buf      Initialized buffer object
 *  \param[in] str      String to append to buffer object.
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t  ares_buf_append_str(ares_buf_t *buf,
                                                const char *str);

/*! Append a 16bit Big Endian number to the buffer.
 *
 *  \param[in]  buf     Initialized buffer object
 *  \param[out] u16     16bit integer
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t  ares_buf_append_be16(ares_buf_t    *buf,
                                                 unsigned short u16);

/*! Append a 32bit Big Endian number to the buffer.
 *
 *  \param[in]  buf     Initialized buffer object
 *  \param[out] u32     32bit integer
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t  ares_buf_append_be32(ares_buf_t  *buf,
                                                 unsigned int u32);

/*! Append a number in ASCII decimal form.
 *
 *  \param[in] buf  Initialized buffer object
 *  \param[in] num  Number to print
 *  \param[in] len  Length to output, use 0 for no padding
 *  \return ARES_SUCCESS on success
 */
CARES_EXTERN ares_status_t  ares_buf_append_num_dec(ares_buf_t *buf, size_t num,
                                                    size_t len);

/*! Append a number in ASCII hexadecimal form.
 *
 *  \param[in] buf  Initialized buffer object
 *  \param[in] num  Number to print
 *  \param[in] len  Length to output, use 0 for no padding
 *  \return ARES_SUCCESS on success
 */
CARES_EXTERN ares_status_t  ares_buf_append_num_hex(ares_buf_t *buf, size_t num,
                                                    size_t len);

/*! Sets the current buffer length.  This *may* be used if there is a need to
 *  override a prior position in the buffer, such as if there is a length
 *  prefix that isn't easily predictable, and you must go back and overwrite
 *  that position.
 *
 *  Only valid on non-const buffers.  Length provided must not exceed current
 *  allocated buffer size, but otherwise there are very few protections on
 *  this function.  Use cautiously.
 *
 *  \param[in]  buf  Initialized buffer object
 *  \param[in]  len  Length to set
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t  ares_buf_set_length(ares_buf_t *buf, size_t len);


/*! Start a dynamic append operation that returns a buffer suitable for
 *  writing.  A desired minimum length is passed in, and the actual allocated
 *  buffer size is returned which may be greater than the requested size.
 *  No operation other than ares_buf_append_finish() is allowed on the
 *  buffer after this request.
 *
 *  \param[in]     buf     Initialized buffer object
 *  \param[in,out] len     Desired non-zero length passed in, actual buffer size
 *                         returned.
 *  \return Pointer to writable buffer or NULL on failure (usage, out of mem)
 */
CARES_EXTERN unsigned char *ares_buf_append_start(ares_buf_t *buf, size_t *len);

/*! Finish a dynamic append operation.  Called after
 *  ares_buf_append_start() once desired data is written.
 *
 *  \param[in] buf    Initialized buffer object.
 *  \param[in] len    Length of data written.  May be zero to terminate
 *                    operation. Must not be greater than returned from
 *                    ares_buf_append_start().
 */
CARES_EXTERN void           ares_buf_append_finish(ares_buf_t *buf, size_t len);

/*! Write the data provided to the buffer in a hexdump format.
 *
 *  \param[in] buf      Initialized buffer object.
 *  \param[in] data     Data to hex dump
 *  \param[in] len      Length of data to hexdump
 *  \return ARES_SUCCESS on success.
 */
CARES_EXTERN ares_status_t  ares_buf_hexdump(ares_buf_t          *buf,
                                             const unsigned char *data,
                                             size_t               len);

/*! Clean up ares_buf_t and return allocated pointer to unprocessed data.  It
 *  is the responsibility of the  caller to ares_free() the returned buffer.
 *  The passed in buf parameter is invalidated by this call.
 *
 * \param[in]  buf    Initialized buffer object. Can not be a "const" buffer.
 * \param[out] len    Length of data returned
 * \return pointer to unprocessed data (may be zero length) or NULL on error.
 */
CARES_EXTERN unsigned char *ares_buf_finish_bin(ares_buf_t *buf, size_t *len);

/*! Clean up ares_buf_t and return allocated pointer to unprocessed data and
 *  return it as a string (null terminated).  It is the responsibility of the
 *  caller to ares_free() the returned buffer. The passed in buf parameter is
 *  invalidated by this call.
 *
 *  This function in no way validates the data in this buffer is actually
 *  a string, that characters are printable, or that there aren't multiple
 *  NULL terminators.  It is assumed that the caller will either validate that
 *  themselves or has built this buffer with only a valid character set.
 *
 * \param[in]  buf    Initialized buffer object. Can not be a "const" buffer.
 * \param[out] len    Optional. Length of data returned, or NULL if not needed.
 * \return pointer to unprocessed data or NULL on error.
 */
CARES_EXTERN char          *ares_buf_finish_str(ares_buf_t *buf, size_t *len);

/*! Replace the given search byte sequence with the replacement byte sequence.
 *  This is only valid for allocated buffers, not const buffers.  Will replace
 *  all byte sequences starting at the current offset to the end of the buffer.
 *
 *  \param[in]  buf       Initialized buffer object. Can not be a "const" buffer.
 *  \param[in]  srch      Search byte sequence, must not be NULL.
 *  \param[in]  srch_size Size of byte sequence, must not be zero.
 *  \param[in]  rplc      Byte sequence to use as replacement.  May be NULL if
 *                        rplc_size is zero.
 *  \param[in]  rplc_size Size of replacement byte sequence, may be 0.
 *  \return ARES_SUCCESS on success, otherwise on may return failure only on
 *          memory allocation failure or misuse.  Will not return indication
 *          if any replacements occurred
 */
CARES_EXTERN ares_status_t  ares_buf_replace(ares_buf_t *buf,
                                             const unsigned char *srch,
                                             size_t srch_size,
                                             const unsigned char *rplc,
                                             size_t rplc_size);

/*! Tag a position to save in the buffer in case parsing needs to rollback,
 *  such as if insufficient data is available, but more data may be added in
 *  the future.  Only a single tag can be set per buffer object.  Setting a
 *  tag will override any pre-existing tag.
 *
 *  \param[in] buf Initialized buffer object
 */
CARES_EXTERN void           ares_buf_tag(ares_buf_t *buf);

/*! Rollback to a tagged position.  Will automatically clear the tag.
 *
 *  \param[in] buf Initialized buffer object
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t  ares_buf_tag_rollback(ares_buf_t *buf);

/*! Clear the tagged position without rolling back.  You should do this any
 *  time a tag is no longer needed as future append operations can reclaim
 *  buffer space.
 *
 *  \param[in] buf Initialized buffer object
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t  ares_buf_tag_clear(ares_buf_t *buf);

/*! Fetch the buffer and length of data starting from the tagged position up
 *  to the _current_ position.  It will not unset the tagged position.  The
 *  data may be invalidated by any future ares_buf_*() calls.
 *
 *  \param[in]  buf    Initialized buffer object
 *  \param[out] len    Length between tag and current offset in buffer
 *  \return NULL on failure (such as no tag), otherwise pointer to start of
 *          buffer
 */
CARES_EXTERN const unsigned char *ares_buf_tag_fetch(const ares_buf_t *buf,
                                                     size_t           *len);

/*! Get the length of the current tag offset to the current position.
 *
 *  \param[in]  buf    Initialized buffer object
 *  \return length
 */
CARES_EXTERN size_t               ares_buf_tag_length(const ares_buf_t *buf);

/*! Fetch the bytes starting from the tagged position up to the _current_
 *  position using the provided buffer.  It will not unset the tagged position.
 *
 *  \param[in]     buf    Initialized buffer object
 *  \param[in,out] bytes  Buffer to hold data
 *  \param[in,out] len    On input, buffer size, on output, bytes place in
 *                        buffer.
 *  \return ARES_SUCCESS if fetched, ARES_EFORMERR if insufficient buffer size
 */
CARES_EXTERN ares_status_t ares_buf_tag_fetch_bytes(const ares_buf_t *buf,
                                                    unsigned char    *bytes,
                                                    size_t           *len);

/*! Fetch the bytes starting from the tagged position up to the _current_
 *  position as a NULL-terminated string using the provided buffer.  The data
 *  is validated to be ASCII-printable data.  It will not unset the tagged
 *  position.
 *
 *  \param[in]     buf    Initialized buffer object
 *  \param[in,out] str    Buffer to hold data
 *  \param[in]     len    buffer size
 *  \return ARES_SUCCESS if fetched, ARES_EFORMERR if insufficient buffer size,
 *          ARES_EBADSTR if not printable ASCII
 */
CARES_EXTERN ares_status_t ares_buf_tag_fetch_string(const ares_buf_t *buf,
                                                     char *str, size_t len);

/*! Fetch the bytes starting from the tagged position up to the _current_
 *  position as a NULL-terminated string and placed into a newly allocated
 *  buffer.  The data is validated to be ASCII-printable data.  It will not
 *  unset the tagged position.
 *
 *  \param[in]  buf    Initialized buffer object
 *  \param[out] str    New buffer to hold output, free with ares_free()
 *
 *  \return ARES_SUCCESS if fetched, ARES_EFORMERR if insufficient buffer size,
 *          ARES_EBADSTR if not printable ASCII
 */
CARES_EXTERN ares_status_t ares_buf_tag_fetch_strdup(const ares_buf_t *buf,
                                                     char            **str);

/*! Fetch the bytes starting from the tagged position up to the _current_
 *  position as const buffer.  Care must be taken to not append or destroy the
 *  passed in buffer until the newly fetched buffer is no longer needed since
 *  it points to memory inside the passed in buffer which could be invalidated.
 *
 *  \param[in]     buf    Initialized buffer object
 *  \param[out]    newbuf New const buffer object, must be destroyed when done.

 *  \return ARES_SUCCESS if fetched
 */
CARES_EXTERN ares_status_t ares_buf_tag_fetch_constbuf(const ares_buf_t *buf,
                                                       ares_buf_t **newbuf);

/*! Consume the given number of bytes without reading them.
 *
 *  \param[in] buf    Initialized buffer object
 *  \param[in] len    Length to consume
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t ares_buf_consume(ares_buf_t *buf, size_t len);

/*! Fetch a 16bit Big Endian number from the buffer.
 *
 *  \param[in]  buf     Initialized buffer object
 *  \param[out] u16     Buffer to hold 16bit integer
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t ares_buf_fetch_be16(ares_buf_t     *buf,
                                               unsigned short *u16);

/*! Fetch a 32bit Big Endian number from the buffer.
 *
 *  \param[in]  buf     Initialized buffer object
 *  \param[out] u32     Buffer to hold 32bit integer
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t ares_buf_fetch_be32(ares_buf_t   *buf,
                                               unsigned int *u32);


/*! Fetch the requested number of bytes into the provided buffer
 *
 *  \param[in]  buf     Initialized buffer object
 *  \param[out] bytes   Buffer to hold data
 *  \param[in]  len     Requested number of bytes (must be > 0)
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t ares_buf_fetch_bytes(ares_buf_t    *buf,
                                                unsigned char *bytes,
                                                size_t         len);


/*! Fetch the requested number of bytes and return a new buffer that must be
 *  ares_free()'d by the caller.
 *
 *  \param[in]  buf       Initialized buffer object
 *  \param[in]  len       Requested number of bytes (must be > 0)
 *  \param[in]  null_term Even though this is considered binary data, the user
 *                        knows it may be a vald string, so add a null
 *                        terminator.
 *  \param[out] bytes     Pointer passed by reference. Will be allocated.
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t ares_buf_fetch_bytes_dup(ares_buf_t *buf, size_t len,
                                                    ares_bool_t     null_term,
                                                    unsigned char **bytes);

/*! Fetch the requested number of bytes and place them into the provided
 *  dest buffer object.
 *
 *  \param[in]  buf     Initialized buffer object
 *  \param[out] dest    Buffer object to append bytes.
 *  \param[in]  len     Requested number of bytes (must be > 0)
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t ares_buf_fetch_bytes_into_buf(ares_buf_t *buf,
                                                         ares_buf_t *dest,
                                                         size_t      len);

/*! Fetch the requested number of bytes and return a new buffer that must be
 *  ares_free()'d by the caller.  The returned buffer is a null terminated
 *  string.  The data is validated to be ASCII-printable.
 *
 *  \param[in]  buf     Initialized buffer object
 *  \param[in]  len     Requested number of bytes (must be > 0)
 *  \param[out] str     Pointer passed by reference. Will be allocated.
 *  \return ARES_SUCCESS or one of the c-ares error codes
 */
CARES_EXTERN ares_status_t ares_buf_fetch_str_dup(ares_buf_t *buf, size_t len,
                                                  char **str);

/*! Consume whitespace characters (0x09, 0x0B, 0x0C, 0x0D, 0x20, and optionally
 *  0x0A).
 *
 *  \param[in]  buf               Initialized buffer object
 *  \param[in]  include_linefeed  ARES_TRUE to include consuming 0x0A,
 *                                ARES_FALSE otherwise.
 *  \return number of whitespace characters consumed
 */
CARES_EXTERN size_t        ares_buf_consume_whitespace(ares_buf_t *buf,
                                                       ares_bool_t include_linefeed);


/*! Consume any non-whitespace character (anything other than 0x09, 0x0B, 0x0C,
 *  0x0D, 0x20, and 0x0A).
 *
 *  \param[in]  buf               Initialized buffer object
 *  \return number of characters consumed
 */
CARES_EXTERN size_t        ares_buf_consume_nonwhitespace(ares_buf_t *buf);


/*! Consume until a character in the character set provided is reached.  Does
 *  not include the character from the charset at the end.
 *
 *  \param[in] buf                Initialized buffer object
 *  \param[in] charset            character set
 *  \param[in] len                length of character set
 *  \param[in] require_charset    require we find a character from the charset.
 *                                if ARES_FALSE it will simply consume the
 *                                rest of the buffer.  If ARES_TRUE will return
 *                                SIZE_MAX if not found.
 *  \return number of characters consumed
 */
CARES_EXTERN size_t        ares_buf_consume_until_charset(ares_buf_t          *buf,
                                                          const unsigned char *charset,
                                                          size_t               len,
                                                          ares_bool_t require_charset);


/*! Consume until a sequence of bytes is encountered.  Does not include the
 *  sequence of characters itself.
 *
 *  \param[in] buf                Initialized buffer object
 *  \param[in] seq                sequence of bytes
 *  \param[in] len                length of sequence
 *  \param[in] require_charset    require we find the sequence.
 *                                if ARES_FALSE it will simply consume the
 *                                rest of the buffer.  If ARES_TRUE will return
 *                                SIZE_MAX if not found.
 *  \return number of characters consumed
 */
CARES_EXTERN size_t        ares_buf_consume_until_seq(ares_buf_t          *buf,
                                                      const unsigned char *seq,
                                                      size_t               len,
                                                      ares_bool_t require_seq);

/*! Consume while the characters match the characters in the provided set.
 *
 *  \param[in] buf                Initialized buffer object
 *  \param[in] charset            character set
 *  \param[in] len                length of character set
 *  \return number of characters consumed
 */
CARES_EXTERN size_t        ares_buf_consume_charset(ares_buf_t          *buf,
                                                    const unsigned char *charset,
                                                    size_t               len);


/*! Consume from the current position until the end of the line, and optionally
 *  the end of line character (0x0A) itself.
 *
 *  \param[in]  buf               Initialized buffer object
 *  \param[in]  include_linefeed  ARES_TRUE to include consuming 0x0A,
 *                                ARES_FALSE otherwise.
 *  \return number of characters consumed
 */
CARES_EXTERN size_t        ares_buf_consume_line(ares_buf_t *buf,
                                                 ares_bool_t include_linefeed);

typedef enum {
  /*! No flags */
  ARES_BUF_SPLIT_NONE = 0,
  /*! The delimiter will be the first character in the buffer, except the
   *  first buffer since the start doesn't have a delimiter.  This option is
   *  incompatible with ARES_BUF_SPLIT_LTRIM since the delimiter is always
   *  the first character.
   */
  ARES_BUF_SPLIT_KEEP_DELIMS = 1 << 0,
  /*! Allow blank sections, by default blank sections are not emitted.  If using
   *  ARES_BUF_SPLIT_KEEP_DELIMS, the delimiter is not counted as part
   *  of the section */
  ARES_BUF_SPLIT_ALLOW_BLANK = 1 << 1,
  /*! Remove duplicate entries */
  ARES_BUF_SPLIT_NO_DUPLICATES = 1 << 2,
  /*! Perform case-insensitive matching when comparing values */
  ARES_BUF_SPLIT_CASE_INSENSITIVE = 1 << 3,
  /*! Trim leading whitespace from buffer */
  ARES_BUF_SPLIT_LTRIM = 1 << 4,
  /*! Trim trailing whitespace from buffer */
  ARES_BUF_SPLIT_RTRIM = 1 << 5,
  /*! Trim leading and trailing whitespace from buffer */
  ARES_BUF_SPLIT_TRIM = (ARES_BUF_SPLIT_LTRIM | ARES_BUF_SPLIT_RTRIM)
} ares_buf_split_t;

/*! Split the provided buffer into multiple sub-buffers stored in the variable
 *  pointed to by the linked list.  The sub buffers are const buffers pointing
 *  into the buf provided.
 *
 *  \param[in]  buf               Initialized buffer object
 *  \param[in]  delims            Possible delimiters
 *  \param[in]  delims_len        Length of possible delimiters
 *  \param[in]  flags             One more more flags
 *  \param[in]  max_sections      Maximum number of sections.  Use 0 for
 *                                unlimited. Useful for splitting key/value
 *                                pairs where the delimiter may be a valid
 *                                character in the value.  A value of 1 would
 *                                have little usefulness and would effectively
 *                                ignore the delimiter itself.
 *  \param[out] arr               Result. Depending on flags, this may be a
 *                                valid array with no elements.  Use
 *                                ares_array_destroy() to free the memory which
 *                                will also free the contained ares_buf_t *
 *                                objects. Each buf object returned by
 *                                ares_array_at() or similar is a pointer to
 *                                an ares_buf_t * object, meaning you need to
 *                                accept it as "ares_buf_t **" then dereference.
 *  \return ARES_SUCCESS on success, or error like ARES_ENOMEM.
 */
CARES_EXTERN ares_status_t ares_buf_split(
  ares_buf_t *buf, const unsigned char *delims, size_t delims_len,
  ares_buf_split_t flags, size_t max_sections, ares_array_t **arr);

/*! Split the provided buffer into an ares_array_t of C strings.
 *
 *  \param[in]  buf               Initialized buffer object
 *  \param[in]  delims            Possible delimiters
 *  \param[in]  delims_len        Length of possible delimiters
 *  \param[in]  flags             One more more flags
 *  \param[in]  max_sections      Maximum number of sections.  Use 0 for
 *                                unlimited. Useful for splitting key/value
 *                                pairs where the delimiter may be a valid
 *                                character in the value.  A value of 1 would
 *                                have little usefulness and would effectively
 *                                ignore the delimiter itself.
 *  \param[out] arr               Array of strings. Free using
 *                                ares_array_destroy().
 *  \return ARES_SUCCESS on success, or error like ARES_ENOMEM.
 */
CARES_EXTERN ares_status_t ares_buf_split_str_array(
  ares_buf_t *buf, const unsigned char *delims, size_t delims_len,
  ares_buf_split_t flags, size_t max_sections, ares_array_t **arr);

/*! Split the provided buffer into a C array of C strings.
 *
 *  \param[in]  buf               Initialized buffer object
 *  \param[in]  delims            Possible delimiters
 *  \param[in]  delims_len        Length of possible delimiters
 *  \param[in]  flags             One more more flags
 *  \param[in]  max_sections      Maximum number of sections.  Use 0 for
 *                                unlimited. Useful for splitting key/value
 *                                pairs where the delimiter may be a valid
 *                                character in the value.  A value of 1 would
 *                                have little usefulness and would effectively
 *                                ignore the delimiter itself.
 *  \param[out] strs              Array of strings. Free using
 *                                ares_free_array(strs, nstrs, ares_free)
 *  \param[out] nstrs             Number of elements in the array.
 *  \return ARES_SUCCESS on success, or error like ARES_ENOMEM.
 */
CARES_EXTERN ares_status_t ares_buf_split_str(
  ares_buf_t *buf, const unsigned char *delims, size_t delims_len,
  ares_buf_split_t flags, size_t max_sections, char ***strs, size_t *nstrs);

/*! Check the unprocessed buffer to see if it begins with the sequence of
 *  characters provided.
 *
 *  \param[in] buf          Initialized buffer object
 *  \param[in] data         Bytes of data to compare.
 *  \param[in] data_len     Length of data to compare.
 *  \return ARES_TRUE on match, ARES_FALSE otherwise.
 */
CARES_EXTERN ares_bool_t          ares_buf_begins_with(const ares_buf_t    *buf,
                                                       const unsigned char *data,
                                                       size_t               data_len);


/*! Size of unprocessed remaining data length
 *
 *  \param[in] buf Initialized buffer object
 *  \return length remaining
 */
CARES_EXTERN size_t               ares_buf_len(const ares_buf_t *buf);

/*! Retrieve a pointer to the currently unprocessed data.  Generally this isn't
 *  recommended to be used in practice.  The returned pointer may be invalidated
 *  by any future ares_buf_*() calls.
 *
 *  \param[in]  buf    Initialized buffer object
 *  \param[out] len    Length of available data
 *  \return Pointer to buffer of unprocessed data
 */
CARES_EXTERN const unsigned char *ares_buf_peek(const ares_buf_t *buf,
                                                size_t           *len);

/*! Retrieve the next byte in the buffer without moving forward.
 *
 *  \param[in]  buf  Initialized buffer object
 *  \param[out] b    Single byte
 *  \return \return ARES_SUCCESS on success, or error
 */
CARES_EXTERN ares_status_t        ares_buf_peek_byte(const ares_buf_t *buf,
                                                     unsigned char    *b);

/*! Wipe any processed data from the beginning of the buffer.  This will
 *  move any remaining data to the front of the internally allocated buffer.
 *
 *  Can not be used on const buffer objects.
 *
 *  Typically not needed to call, as any new append operation will automatically
 *  call this function if there is insufficient space to append the data in
 *  order to try to avoid another memory allocation.
 *
 *  It may be useful to call in order to ensure the current message being
 *  processed is in the beginning of the buffer if there is an intent to use
 *  ares_buf_set_position() and ares_buf_get_position() as may be necessary
 *  when processing DNS compressed names.
 *
 *  If there is an active tag, it will NOT clear the tag, it will use the tag
 *  as the start of the unprocessed data rather than the current offset.  If
 *  a prior tag is no longer needed, may be wise to call ares_buf_tag_clear().
 *
 *  \param[in]  buf    Initialized buffer object
 */
CARES_EXTERN void                 ares_buf_reclaim(ares_buf_t *buf);

/*! Set the current offset within the internal buffer.
 *
 *  Typically this should not be used, if possible, use the ares_buf_tag*()
 *  operations instead.
 *
 *  One exception is DNS name compression which may backwards reference to
 *  an index in the message.  It may be necessary in such a case to call
 *  ares_buf_reclaim() if using a dynamic (non-const) buffer before processing
 *  such a message.
 *
 *  \param[in] buf  Initialized buffer object
 *  \param[in] idx  Index to set position
 *  \return ARES_SUCCESS if valid index
 */
CARES_EXTERN ares_status_t ares_buf_set_position(ares_buf_t *buf, size_t idx);

/*! Get the current offset within the internal buffer.
 *
 *  Typically this should not be used, if possible, use the ares_buf_tag*()
 *  operations instead.
 *
 *  This can be used to get the current position, useful for saving if a
 *  jump via ares_buf_set_position() is performed and need to restore the
 *  current position for future operations.
 *
 *  \param[in] buf Initialized buffer object
 *  \return index of current position
 */
CARES_EXTERN size_t        ares_buf_get_position(const ares_buf_t *buf);

/*! Parse a character-string as defined in RFC1035, as a null-terminated
 *  string.
 *
 *  \param[in]  buf            initialized buffer object
 *  \param[in]  remaining_len  maximum length that should be used for parsing
 *                             the string, this is often less than the remaining
 *                             buffer and is based on the RR record length.
 *  \param[out] name           Pointer passed by reference to be filled in with
 *                             allocated string of the parsed that must be
 *                             ares_free()'d by the caller.
 *  \return ARES_SUCCESS on success
 */
CARES_EXTERN ares_status_t ares_buf_parse_dns_str(ares_buf_t *buf,
                                                  size_t      remaining_len,
                                                  char      **name);

/*! Parse a character-string as defined in RFC1035, as binary, however for
 *  convenience this does guarantee a NULL terminator (that is not included
 *  in the returned length).
 *
 *  \param[in]  buf            initialized buffer object
 *  \param[in]  remaining_len  maximum length that should be used for parsing
 *                             the string, this is often less than the remaining
 *                             buffer and is based on the RR record length.
 *  \param[out] bin            Pointer passed by reference to be filled in with
 *                             allocated string of the parsed that must be
 *                             ares_free()'d by the caller.
 *  \param[out] bin_len        Length of returned string.
 *  \return ARES_SUCCESS on success
 */
CARES_EXTERN ares_status_t ares_buf_parse_dns_binstr(ares_buf_t *buf,
                                                     size_t      remaining_len,
                                                     unsigned char **bin,
                                                     size_t         *bin_len);

/*! Load data from specified file path into provided buffer.  The entire file
 *  is loaded into memory.
 *
 *  \param[in]     filename complete path to file
 *  \param[in,out] buf      Initialized (non-const) buffer object to load data
 *                          into
 *  \return ARES_ENOTFOUND if file not found, ARES_EFILE if issues reading
 *          file, ARES_ENOMEM if out of memory, ARES_SUCCESS on success.
 */
CARES_EXTERN ares_status_t ares_buf_load_file(const char *filename,
                                              ares_buf_t *buf);

/*! @} */

#endif /* __ARES__BUF_H */
                                                                                                                                                                                                       node-23.7.0/deps/cares/src/lib/include/ares_htable_asvp.h                                           0000664 0000000 0000000 00000011321 14746647661 0023236 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__HTABLE_ASVP_H
#define __ARES__HTABLE_ASVP_H

/*! \addtogroup ares_htable_asvp HashTable with ares_socket_t Key and
 *                                void pointer Value
 *
 * This data structure wraps the base ares_htable data structure in order to
 * split the key and value data types as ares_socket_t and void pointer,
 * respectively.
 *
 * Average time complexity:
 *  - Insert: O(1)
 *  - Search: O(1)
 *  - Delete: O(1)
 *
 * @{
 */

struct ares_htable_asvp;

/*! Opaque data type for ares_socket_t key, void pointer hash table
 *  implementation */
typedef struct ares_htable_asvp ares_htable_asvp_t;

/*! Callback to free value stored in hashtable
 *
 *  \param[in] val  user-supplied value
 */
typedef void (*ares_htable_asvp_val_free_t)(void *val);

/*! Destroy hashtable
 *
 *  \param[in] htable  Initialized hashtable
 */
CARES_EXTERN void ares_htable_asvp_destroy(ares_htable_asvp_t *htable);

/*! Create size_t key, void pointer value hash table
 *
 *  \param[in] val_free  Optional. Call back to free user-supplied value.  If
 *                       NULL it is expected the caller will clean up any user
 *                       supplied values.
 */
CARES_EXTERN ares_htable_asvp_t *
  ares_htable_asvp_create(ares_htable_asvp_val_free_t val_free);

/*! Retrieve an array of keys from the hashtable.
 *
 *  \param[in]  htable   Initialized hashtable
 *  \param[out] num      Count of returned keys
 *  \return Array of keys in the hashtable. Must be free'd with ares_free().
 */
CARES_EXTERN ares_socket_t *
  ares_htable_asvp_keys(const ares_htable_asvp_t *htable, size_t *num);


/*! Insert key/value into hash table
 *
 *  \param[in] htable Initialized hash table
 *  \param[in] key    key to associate with value
 *  \param[in] val    value to store (takes ownership). May be NULL.
 *  \return ARES_TRUE on success, ARES_FALSE on out of memory or misuse
 */
CARES_EXTERN ares_bool_t ares_htable_asvp_insert(ares_htable_asvp_t *htable,
                                                 ares_socket_t key, void *val);

/*! Retrieve value from hashtable based on key
 *
 *  \param[in]  htable  Initialized hash table
 *  \param[in]  key     key to use to search
 *  \param[out] val     Optional.  Pointer to store value.
 *  \return ARES_TRUE on success, ARES_FALSE on failure
 */
CARES_EXTERN ares_bool_t ares_htable_asvp_get(const ares_htable_asvp_t *htable,
                                              ares_socket_t key, void **val);

/*! Retrieve value from hashtable directly as return value.  Caveat to this
 *  function over ares_htable_asvp_get() is that if a NULL value is stored
 *  you cannot determine if the key is not found or the value is NULL.
 *
 *  \param[in] htable  Initialized hash table
 *  \param[in] key     key to use to search
 *  \return value associated with key in hashtable or NULL
 */
CARES_EXTERN void *ares_htable_asvp_get_direct(const ares_htable_asvp_t *htable,
                                               ares_socket_t             key);

/*! Remove a value from the hashtable by key
 *
 *  \param[in] htable  Initialized hash table
 *  \param[in] key     key to use to search
 *  \return ARES_TRUE if found, ARES_FALSE if not found
 */
CARES_EXTERN ares_bool_t ares_htable_asvp_remove(ares_htable_asvp_t *htable,
                                                 ares_socket_t       key);

/*! Retrieve the number of keys stored in the hash table
 *
 *  \param[in] htable  Initialized hash table
 *  \return count
 */
CARES_EXTERN size_t ares_htable_asvp_num_keys(const ares_htable_asvp_t *htable);

/*! @} */

#endif /* __ARES__HTABLE_ASVP_H */
                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/cares/src/lib/include/ares_htable_dict.h                                           0000664 0000000 0000000 00000010750 14746647661 0023215 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__HTABLE_DICT_H
#define __ARES__HTABLE_DICT_H

/*! \addtogroup ares_htable_dict HashTable with case-insensitive string Key and
 *  string value
 *
 * This data structure wraps the base ares_htable data structure in order to
 * split the key and value data types as string and string, respectively.
 *
 * Average time complexity:
 *  - Insert: O(1)
 *  - Search: O(1)
 *  - Delete: O(1)
 *
 * @{
 */

struct ares_htable_dict;

/*! Opaque data type for string key, string value hash table
 * implementation */
typedef struct ares_htable_dict ares_htable_dict_t;

/*! Destroy hashtable
 *
 *  \param[in] htable  Initialized hashtable
 */
CARES_EXTERN void ares_htable_dict_destroy(ares_htable_dict_t *htable);

/*! Create void pointer key, string value hash table
 *
 */
CARES_EXTERN ares_htable_dict_t *ares_htable_dict_create(void);

/*! Insert key/value into hash table
 *
 *  \param[in] htable Initialized hash table
 *  \param[in] key    key to associate with value
 *  \param[in] val    value to store (duplicates).
 *  \return ARES_TRUE on success, ARES_FALSE on failure or out of memory
 */
CARES_EXTERN ares_bool_t ares_htable_dict_insert(ares_htable_dict_t *htable,
                                                 const char         *key,
                                                 const char         *val);

/*! Retrieve value from hashtable based on key
 *
 *  \param[in]  htable  Initialized hash table
 *  \param[in]  key     key to use to search
 *  \param[out] val     Optional.  Pointer to store value.
 *  \return ARES_TRUE on success, ARES_FALSE on failure
 */
CARES_EXTERN ares_bool_t ares_htable_dict_get(const ares_htable_dict_t *htable,
                                              const char               *key,
                                              const char              **val);

/*! Retrieve value from hashtable directly as return value.  Caveat to this
 *  function over ares_htable_dict_get() is that if a NULL value is stored
 *  you cannot determine if the key is not found or the value is NULL.
 *
 *  \param[in] htable  Initialized hash table
 *  \param[in] key     key to use to search
 *  \return value associated with key in hashtable or NULL
 */
CARES_EXTERN const char *
  ares_htable_dict_get_direct(const ares_htable_dict_t *htable,
                              const char               *key);

/*! Remove a value from the hashtable by key
 *
 *  \param[in] htable  Initialized hash table
 *  \param[in] key     key to use to search
 *  \return ARES_TRUE if found, ARES_FALSE if not
 */
CARES_EXTERN ares_bool_t ares_htable_dict_remove(ares_htable_dict_t *htable,
                                                 const char         *key);

/*! Retrieve the number of keys stored in the hash table
 *
 *  \param[in] htable  Initialized hash table
 *  \return count
 */
CARES_EXTERN size_t ares_htable_dict_num_keys(const ares_htable_dict_t *htable);

/*! Retrieve an array of keys from the hashtable.
 *
 *  \param[in]  htable   Initialized hashtable
 *  \param[out] num      Count of returned keys
 *  \return Array of keys in the hashtable. Must be free'd with
 *          ares_free_array(strs, num, ares_free);
 */
CARES_EXTERN char **ares_htable_dict_keys(const ares_htable_dict_t *htable,
                                          size_t                   *num);


/*! @} */

#endif /* __ARES__HTABLE_DICT_H */
                        node-23.7.0/deps/cares/src/lib/include/ares_htable_strvp.h                                          0000664 0000000 0000000 00000011327 14746647661 0023451 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__HTABLE_STRVP_H
#define __ARES__HTABLE_STRVP_H

/*! \addtogroup ares_htable_strvp HashTable with string Key and void pointer
 * Value
 *
 * This data structure wraps the base ares_htable data structure in order to
 * split the key and value data types as string and void pointer, respectively.
 *
 * Average time complexity:
 *  - Insert: O(1)
 *  - Search: O(1)
 *  - Delete: O(1)
 *
 * @{
 */

struct ares_htable_strvp;

/*! Opaque data type for size_t key, void pointer hash table implementation */
typedef struct ares_htable_strvp ares_htable_strvp_t;

/*! Callback to free value stored in hashtable
 *
 *  \param[in] val  user-supplied value
 */
typedef void (*ares_htable_strvp_val_free_t)(void *val);

/*! Destroy hashtable
 *
 *  \param[in] htable  Initialized hashtable
 */
CARES_EXTERN void ares_htable_strvp_destroy(ares_htable_strvp_t *htable);

/*! Create string, void pointer value hash table
 *
 *  \param[in] val_free  Optional. Call back to free user-supplied value.  If
 *                       NULL it is expected the caller will clean up any user
 *                       supplied values.
 */
CARES_EXTERN ares_htable_strvp_t *
  ares_htable_strvp_create(ares_htable_strvp_val_free_t val_free);

/*! Insert key/value into hash table
 *
 *  \param[in] htable Initialized hash table
 *  \param[in] key    key to associate with value
 *  \param[in] val    value to store (takes ownership). May be NULL.
 *  \return ARES_TRUE on success, ARES_FALSE on failure or out of memory
 */
CARES_EXTERN ares_bool_t ares_htable_strvp_insert(ares_htable_strvp_t *htable,
                                                  const char *key, void *val);

/*! Retrieve value from hashtable based on key
 *
 *  \param[in]  htable  Initialized hash table
 *  \param[in]  key     key to use to search
 *  \param[out] val     Optional.  Pointer to store value.
 *  \return ARES_TRUE on success, ARES_FALSE on failure
 */
CARES_EXTERN ares_bool_t ares_htable_strvp_get(
  const ares_htable_strvp_t *htable, const char *key, void **val);

/*! Retrieve value from hashtable directly as return value.  Caveat to this
 *  function over ares_htable_strvp_get() is that if a NULL value is stored
 *  you cannot determine if the key is not found or the value is NULL.
 *
 *  \param[in] htable  Initialized hash table
 *  \param[in] key     key to use to search
 *  \return value associated with key in hashtable or NULL
 */
CARES_EXTERN void *
  ares_htable_strvp_get_direct(const ares_htable_strvp_t *htable,
                               const char                *key);

/*! Remove a value from the hashtable by key
 *
 *  \param[in] htable  Initialized hash table
 *  \param[in] key     key to use to search
 *  \return ARES_TRUE if found, ARES_FALSE if not
 */
CARES_EXTERN ares_bool_t ares_htable_strvp_remove(ares_htable_strvp_t *htable,
                                                  const char          *key);

/*! Remove the value from the hashtable, and return the value instead of
 *  calling the val_free passed to ares_htable_strvp_create().
 *
 *  \param[in] htable  Initialized hash table
 *  \param[in] key     key to use to search
 *  \return value in hashtable or NULL on error
 */
CARES_EXTERN void       *ares_htable_strvp_claim(ares_htable_strvp_t *htable,
                                                 const char          *key);

/*! Retrieve the number of keys stored in the hash table
 *
 *  \param[in] htable  Initialized hash table
 *  \return count
 */
CARES_EXTERN size_t
  ares_htable_strvp_num_keys(const ares_htable_strvp_t *htable);

/*! @} */

#endif /* __ARES__HTABLE_STRVP_H */
                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/cares/src/lib/include/ares_htable_szvp.h                                           0000664 0000000 0000000 00000010467 14746647661 0023301 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__HTABLE_STVP_H
#define __ARES__HTABLE_STVP_H

/*! \addtogroup ares_htable_szvp HashTable with size_t Key and void pointer
 * Value
 *
 * This data structure wraps the base ares_htable data structure in order to
 * split the key and value data types as size_t and void pointer, respectively.
 *
 * Average time complexity:
 *  - Insert: O(1)
 *  - Search: O(1)
 *  - Delete: O(1)
 *
 * @{
 */

struct ares_htable_szvp;

/*! Opaque data type for size_t key, void pointer hash table implementation */
typedef struct ares_htable_szvp ares_htable_szvp_t;

/*! Callback to free value stored in hashtable
 *
 *  \param[in] val  user-supplied value
 */
typedef void (*ares_htable_szvp_val_free_t)(void *val);

/*! Destroy hashtable
 *
 *  \param[in] htable  Initialized hashtable
 */
CARES_EXTERN void ares_htable_szvp_destroy(ares_htable_szvp_t *htable);

/*! Create size_t key, void pointer value hash table
 *
 *  \param[in] val_free  Optional. Call back to free user-supplied value.  If
 *                       NULL it is expected the caller will clean up any user
 *                       supplied values.
 */
CARES_EXTERN ares_htable_szvp_t *
  ares_htable_szvp_create(ares_htable_szvp_val_free_t val_free);

/*! Insert key/value into hash table
 *
 *  \param[in] htable Initialized hash table
 *  \param[in] key    key to associate with value
 *  \param[in] val    value to store (takes ownership). May be NULL.
 *  \return ARES_TRUE on success, ARES_FALSE on failure or out of memory
 */
CARES_EXTERN ares_bool_t ares_htable_szvp_insert(ares_htable_szvp_t *htable,
                                                 size_t key, void *val);

/*! Retrieve value from hashtable based on key
 *
 *  \param[in]  htable  Initialized hash table
 *  \param[in]  key     key to use to search
 *  \param[out] val     Optional.  Pointer to store value.
 *  \return ARES_TRUE on success, ARES_FALSE on failure
 */
CARES_EXTERN ares_bool_t ares_htable_szvp_get(const ares_htable_szvp_t *htable,
                                              size_t key, void **val);

/*! Retrieve value from hashtable directly as return value.  Caveat to this
 *  function over ares_htable_szvp_get() is that if a NULL value is stored
 *  you cannot determine if the key is not found or the value is NULL.
 *
 *  \param[in] htable  Initialized hash table
 *  \param[in] key     key to use to search
 *  \return value associated with key in hashtable or NULL
 */
CARES_EXTERN void *ares_htable_szvp_get_direct(const ares_htable_szvp_t *htable,
                                               size_t                    key);

/*! Remove a value from the hashtable by key
 *
 *  \param[in] htable  Initialized hash table
 *  \param[in] key     key to use to search
 *  \return ARES_TRUE if found, ARES_FALSE if not
 */
CARES_EXTERN ares_bool_t ares_htable_szvp_remove(ares_htable_szvp_t *htable,
                                                 size_t              key);

/*! Retrieve the number of keys stored in the hash table
 *
 *  \param[in] htable  Initialized hash table
 *  \return count
 */
CARES_EXTERN size_t ares_htable_szvp_num_keys(const ares_htable_szvp_t *htable);

/*! @} */

#endif /* __ARES__HTABLE_STVP_H */
                                                                                                                                                                                                         node-23.7.0/deps/cares/src/lib/include/ares_htable_vpstr.h                                          0000664 0000000 0000000 00000007650 14746647661 0023455 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__HTABLE_VPSTR_H
#define __ARES__HTABLE_VPSTR_H

/*! \addtogroup ares_htable_vpstr HashTable with void pointer Key and string
 *  value
 *
 * This data structure wraps the base ares_htable data structure in order to
 * split the key and value data types as void pointer and string, respectively.
 *
 * Average time complexity:
 *  - Insert: O(1)
 *  - Search: O(1)
 *  - Delete: O(1)
 *
 * @{
 */

struct ares_htable_vpstr;

/*! Opaque data type for void pointer key, string value hash table
 * implementation */
typedef struct ares_htable_vpstr ares_htable_vpstr_t;

/*! Destroy hashtable
 *
 *  \param[in] htable  Initialized hashtable
 */
CARES_EXTERN void ares_htable_vpstr_destroy(ares_htable_vpstr_t *htable);

/*! Create void pointer key, string value hash table
 *
 */
CARES_EXTERN ares_htable_vpstr_t *ares_htable_vpstr_create(void);

/*! Insert key/value into hash table
 *
 *  \param[in] htable Initialized hash table
 *  \param[in] key    key to associate with value
 *  \param[in] val    value to store (duplicates).
 *  \return ARES_TRUE on success, ARES_FALSE on failure or out of memory
 */
CARES_EXTERN ares_bool_t ares_htable_vpstr_insert(ares_htable_vpstr_t *htable,
                                                  void *key, const char *val);

/*! Retrieve value from hashtable based on key
 *
 *  \param[in]  htable  Initialized hash table
 *  \param[in]  key     key to use to search
 *  \param[out] val     Optional.  Pointer to store value.
 *  \return ARES_TRUE on success, ARES_FALSE on failure
 */
CARES_EXTERN ares_bool_t ares_htable_vpstr_get(
  const ares_htable_vpstr_t *htable, const void *key, const char **val);

/*! Retrieve value from hashtable directly as return value.  Caveat to this
 *  function over ares_htable_vpstr_get() is that if a NULL value is stored
 *  you cannot determine if the key is not found or the value is NULL.
 *
 *  \param[in] htable  Initialized hash table
 *  \param[in] key     key to use to search
 *  \return value associated with key in hashtable or NULL
 */
CARES_EXTERN const char *
  ares_htable_vpstr_get_direct(const ares_htable_vpstr_t *htable,
                               const void                *key);

/*! Remove a value from the hashtable by key
 *
 *  \param[in] htable  Initialized hash table
 *  \param[in] key     key to use to search
 *  \return ARES_TRUE if found, ARES_FALSE if not
 */
CARES_EXTERN ares_bool_t ares_htable_vpstr_remove(ares_htable_vpstr_t *htable,
                                                  const void          *key);

/*! Retrieve the number of keys stored in the hash table
 *
 *  \param[in] htable  Initialized hash table
 *  \return count
 */
CARES_EXTERN size_t
  ares_htable_vpstr_num_keys(const ares_htable_vpstr_t *htable);

/*! @} */

#endif /* __ARES__HTABLE_VPSTR_H */
                                                                                        node-23.7.0/deps/cares/src/lib/include/ares_htable_vpvp.h                                           0000664 0000000 0000000 00000011327 14746647661 0023266 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__HTABLE_VPVP_H
#define __ARES__HTABLE_VPVP_H

/*! \addtogroup ares_htable_vpvp HashTable with void pointer Key and void
 * pointer Value
 *
 * This data structure wraps the base ares_htable data structure in order to
 * split the key and value data types as size_t and void pointer, respectively.
 *
 * Average time complexity:
 *  - Insert: O(1)
 *  - Search: O(1)
 *  - Delete: O(1)
 *
 * @{
 */

struct ares_htable_vpvp;

/*! Opaque data type for size_t key, void pointer hash table implementation */
typedef struct ares_htable_vpvp ares_htable_vpvp_t;

/*! Callback to free key stored in hashtable
 *
 *  \param[in] key  user-supplied key
 */
typedef void (*ares_htable_vpvp_key_free_t)(void *key);

/*! Callback to free value stored in hashtable
 *
 *  \param[in] val  user-supplied value
 */
typedef void (*ares_htable_vpvp_val_free_t)(void *val);

/*! Destroy hashtable
 *
 *  \param[in] htable  Initialized hashtable
 */
CARES_EXTERN void ares_htable_vpvp_destroy(ares_htable_vpvp_t *htable);

/*! Create size_t key, void pointer value hash table
 *
 *  \param[in] key_free  Optional. Call back to free user-supplied key.  If
 *                       NULL it is expected the caller will clean up any user
 *                       supplied keys.
 *  \param[in] val_free  Optional. Call back to free user-supplied value.  If
 *                       NULL it is expected the caller will clean up any user
 *                       supplied values.
 */
CARES_EXTERN ares_htable_vpvp_t *
  ares_htable_vpvp_create(ares_htable_vpvp_key_free_t key_free,
                          ares_htable_vpvp_val_free_t val_free);

/*! Insert key/value into hash table
 *
 *  \param[in] htable Initialized hash table
 *  \param[in] key    key to associate with value
 *  \param[in] val    value to store (takes ownership). May be NULL.
 *  \return ARES_TRUE on success, ARES_FALSE on failure or out of memory
 */
CARES_EXTERN ares_bool_t ares_htable_vpvp_insert(ares_htable_vpvp_t *htable,
                                                 void *key, void *val);

/*! Retrieve value from hashtable based on key
 *
 *  \param[in]  htable  Initialized hash table
 *  \param[in]  key     key to use to search
 *  \param[out] val     Optional.  Pointer to store value.
 *  \return ARES_TRUE on success, ARES_FALSE on failure
 */
CARES_EXTERN ares_bool_t ares_htable_vpvp_get(const ares_htable_vpvp_t *htable,
                                              const void *key, void **val);

/*! Retrieve value from hashtable directly as return value.  Caveat to this
 *  function over ares_htable_vpvp_get() is that if a NULL value is stored
 *  you cannot determine if the key is not found or the value is NULL.
 *
 *  \param[in] htable  Initialized hash table
 *  \param[in] key     key to use to search
 *  \return value associated with key in hashtable or NULL
 */
CARES_EXTERN void *ares_htable_vpvp_get_direct(const ares_htable_vpvp_t *htable,
                                               const void               *key);

/*! Remove a value from the hashtable by key
 *
 *  \param[in] htable  Initialized hash table
 *  \param[in] key     key to use to search
 *  \return ARES_TRUE if found, ARES_FALSE if not
 */
CARES_EXTERN ares_bool_t ares_htable_vpvp_remove(ares_htable_vpvp_t *htable,
                                                 const void         *key);

/*! Retrieve the number of keys stored in the hash table
 *
 *  \param[in] htable  Initialized hash table
 *  \return count
 */
CARES_EXTERN size_t ares_htable_vpvp_num_keys(const ares_htable_vpvp_t *htable);

/*! @} */

#endif /* __ARES__HTABLE_VPVP_H */
                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/cares/src/lib/include/ares_llist.h                                                 0000664 0000000 0000000 00000017610 14746647661 0022104 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__LLIST_H
#define __ARES__LLIST_H

/*! \addtogroup ares_llist LinkedList Data Structure
 *
 * This is a doubly-linked list data structure.
 *
 * Average time complexity:
 *  - Insert: O(1)   -- head or tail
 *  - Search: O(n)
 *  - Delete: O(1)   -- delete assumes you hold a node pointer
 *
 * @{
 */

struct ares_llist;

/*! Opaque data structure for linked list */
typedef struct ares_llist ares_llist_t;

struct ares_llist_node;

/*! Opaque data structure for a node in a linked list */
typedef struct ares_llist_node ares_llist_node_t;

/*! Callback to free user-defined node data
 *
 *  \param[in] data  user supplied data
 */
typedef void (*ares_llist_destructor_t)(void *data);

/*! Create a linked list object
 *
 *  \param[in] destruct  Optional. Destructor to call on all removed nodes
 *  \return linked list object or NULL on out of memory
 */
CARES_EXTERN ares_llist_t *ares_llist_create(ares_llist_destructor_t destruct);

/*! Replace destructor for linked list nodes.  Typically this is used
 *  when wanting to disable the destructor by using NULL.
 *
 *  \param[in] list      Initialized linked list object
 *  \param[in] destruct  replacement destructor, NULL is allowed
 */
CARES_EXTERN void
  ares_llist_replace_destructor(ares_llist_t           *list,
                                ares_llist_destructor_t destruct);

/*! Insert value as the first node in the linked list
 *
 *  \param[in] list   Initialized linked list object
 *  \param[in] val    user-supplied value.
 *  \return node object referencing place in list, or null if out of memory or
 *   misuse
 */
CARES_EXTERN ares_llist_node_t *ares_llist_insert_first(ares_llist_t *list,
                                                        void         *val);

/*! Insert value as the last node in the linked list
 *
 *  \param[in] list   Initialized linked list object
 *  \param[in] val    user-supplied value.
 *  \return node object referencing place in list, or null if out of memory or
 *   misuse
 */
CARES_EXTERN ares_llist_node_t *ares_llist_insert_last(ares_llist_t *list,
                                                       void         *val);

/*! Insert value before specified node in the linked list
 *
 *  \param[in] node  node referenced to insert before
 *  \param[in] val   user-supplied value.
 *  \return node object referencing place in list, or null if out of memory or
 *   misuse
 */
CARES_EXTERN ares_llist_node_t *
  ares_llist_insert_before(ares_llist_node_t *node, void *val);

/*! Insert value after specified node in the linked list
 *
 *  \param[in] node  node referenced to insert after
 *  \param[in] val   user-supplied value.
 *  \return node object referencing place in list, or null if out of memory or
 *   misuse
 */
CARES_EXTERN ares_llist_node_t *ares_llist_insert_after(ares_llist_node_t *node,
                                                        void              *val);

/*! Obtain first node in list
 *
 *  \param[in] list  Initialized list object
 *  \return first node in list or NULL if none
 */
CARES_EXTERN ares_llist_node_t *ares_llist_node_first(ares_llist_t *list);

/*! Obtain last node in list
 *
 *  \param[in] list  Initialized list object
 *  \return last node in list or NULL if none
 */
CARES_EXTERN ares_llist_node_t *ares_llist_node_last(ares_llist_t *list);

/*! Obtain a node based on its index.  This is an O(n) operation.
 *
 *  \param[in] list Initialized list object
 *  \param[in] idx  Index of node to retrieve
 *  \return node at index or NULL if invalid index
 */
CARES_EXTERN ares_llist_node_t *ares_llist_node_idx(ares_llist_t *list,
                                                    size_t        idx);

/*! Obtain next node in respect to specified node
 *
 *  \param[in] node  Node referenced
 *  \return node or NULL if none
 */
CARES_EXTERN ares_llist_node_t *ares_llist_node_next(ares_llist_node_t *node);

/*! Obtain previous node in respect to specified node
 *
 *  \param[in] node  Node referenced
 *  \return node or NULL if none
 */
CARES_EXTERN ares_llist_node_t *ares_llist_node_prev(ares_llist_node_t *node);


/*! Obtain value from node
 *
 *  \param[in] node  Node referenced
 *  \return user provided value from node
 */
CARES_EXTERN void              *ares_llist_node_val(ares_llist_node_t *node);

/*! Obtain the number of entries in the list
 *
 *  \param[in] list  Initialized list object
 *  \return count
 */
CARES_EXTERN size_t             ares_llist_len(const ares_llist_t *list);

/*! Clear all entries in the list, but don't destroy the list object.
 *
 *  \param[in] list  Initialized list object
 */
CARES_EXTERN void               ares_llist_clear(ares_llist_t *list);

/*! Obtain list object from referenced node
 *
 *  \param[in] node  Node referenced
 *  \return list object node belongs to
 */
CARES_EXTERN ares_llist_t      *ares_llist_node_parent(ares_llist_node_t *node);

/*! Obtain the first user-supplied value in the list
 *
 *  \param[in] list Initialized list object
 *  \return first user supplied value or NULL if none
 */
CARES_EXTERN void              *ares_llist_first_val(ares_llist_t *list);

/*! Obtain the last user-supplied value in the list
 *
 *  \param[in] list Initialized list object
 *  \return last user supplied value or NULL if none
 */
CARES_EXTERN void              *ares_llist_last_val(ares_llist_t *list);

/*! Take ownership of user-supplied value in list without calling destructor.
 *  Will unchain entry from list.
 *
 *  \param[in] node Node referenced
 *  \return user supplied value
 */
CARES_EXTERN void              *ares_llist_node_claim(ares_llist_node_t *node);

/*! Replace user-supplied value for node
 *
 *  \param[in] node Node referenced
 *  \param[in] val  new user-supplied value
 */
CARES_EXTERN void ares_llist_node_replace(ares_llist_node_t *node, void *val);

/*! Destroy the node, removing it from the list and calling destructor.
 *
 *  \param[in] node  Node referenced
 */
CARES_EXTERN void ares_llist_node_destroy(ares_llist_node_t *node);

/*! Destroy the list object and all nodes in the list.
 *
 *  \param[in] list Initialized list object
 */
CARES_EXTERN void ares_llist_destroy(ares_llist_t *list);

/*! Detach node from the current list and re-attach it to the new list as the
 *  last entry.
 *
 * \param[in] node       node to move
 * \param[in] new_parent new list
 */
CARES_EXTERN void ares_llist_node_mvparent_last(ares_llist_node_t *node,
                                                ares_llist_t      *new_parent);

/*! Detach node from the current list and re-attach it to the new list as the
 *  first entry.
 *
 * \param[in] node       node to move
 * \param[in] new_parent new list
 */
CARES_EXTERN void ares_llist_node_mvparent_first(ares_llist_node_t *node,
                                                 ares_llist_t      *new_parent);
/*! @} */

#endif /* __ARES__LLIST_H */
                                                                                                                        node-23.7.0/deps/cares/src/lib/include/ares_mem.h                                                   0000664 0000000 0000000 00000003127 14746647661 0021531 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#ifndef __ARES_MEM_H
#define __ARES_MEM_H

/* Memory management functions */
CARES_EXTERN void *ares_malloc(size_t size);
CARES_EXTERN void *ares_realloc(void *ptr, size_t size);
CARES_EXTERN void  ares_free(void *ptr);
CARES_EXTERN void *ares_malloc_zero(size_t size);
CARES_EXTERN void *ares_realloc_zero(void *ptr, size_t orig_size,
                                     size_t new_size);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/cares/src/lib/include/ares_str.h                                                   0000664 0000000 0000000 00000023414 14746647661 0021564 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES_STR_H
#define __ARES_STR_H

CARES_EXTERN char  *ares_strdup(const char *s1);

/*! Scan up to maxlen bytes for the first NULL character and return
 *  its index, or maxlen if not found.  The function only returns
 *  maxlen if the first maxlen bytes were not NULL characters; it
 *  makes no guarantee for what \c str[maxlen] (if defined) is, and
 *  does not access it.  It is behaving like the POSIX \c strnlen()
 *  function, except that it returns 0 if the \p str pointer is \c
 *  NULL.
 *
 *  \param[in] str    The string to scan for the NULL character
 *  \param[in] maxlen The maximum number of bytes to scan
 *  \return Index of first NULL byte. Between 0 and maxlen (inclusive).
 */
CARES_EXTERN size_t ares_strnlen(const char *str, size_t maxlen);

CARES_EXTERN size_t ares_strlen(const char *str);

/*! Copy string from source to destination with destination buffer size
 *  provided.  The destination is guaranteed to be null terminated, if the
 *  provided buffer isn't large enough, only those bytes from the source that
 *  will fit will be copied.
 *
 *  \param[out] dest       Destination buffer
 *  \param[in]  src        Source to copy
 *  \param[in]  dest_size  Size of destination buffer
 *  \return String length.  Will be at most dest_size-1
 */
CARES_EXTERN size_t ares_strcpy(char *dest, const char *src, size_t dest_size);

CARES_EXTERN ares_bool_t    ares_str_isnum(const char *str);
CARES_EXTERN ares_bool_t    ares_str_isalnum(const char *str);

CARES_EXTERN void           ares_str_ltrim(char *str);
CARES_EXTERN void           ares_str_rtrim(char *str);
CARES_EXTERN void           ares_str_trim(char *str);
CARES_EXTERN void           ares_str_lower(char *str);

CARES_EXTERN unsigned char  ares_tolower(unsigned char c);
CARES_EXTERN unsigned char *ares_memmem(const unsigned char *big,
                                        size_t               big_len,
                                        const unsigned char *little,
                                        size_t               little_len);
CARES_EXTERN ares_bool_t    ares_memeq(const unsigned char *ptr,
                                       const unsigned char *val, size_t len);
CARES_EXTERN ares_bool_t    ares_memeq_ci(const unsigned char *ptr,
                                          const unsigned char *val, size_t len);
CARES_EXTERN ares_bool_t    ares_is_hostname(const char *str);

/*! Validate the string provided is printable.  The length specified must be
 *  at least the size of the buffer provided.  If a NULL-terminator is hit
 *  before the length provided is hit, this will not be considered a valid
 *  printable string.  This does not validate that the string is actually
 *  NULL terminated.
 *
 *  \param[in] str  Buffer containing string to evaluate.
 *  \param[in] len  Number of characters to evaluate within provided buffer.
 *                  If 0, will return TRUE since it did not hit an exception.
 *  \return ARES_TRUE if the entire string is printable, ARES_FALSE if not.
 */
CARES_EXTERN ares_bool_t    ares_str_isprint(const char *str, size_t len);

/* We only care about ASCII rules */
#define ares_isascii(x) (((unsigned char)x) <= 127)

#define ares_isdigit(x) (((unsigned char)x) >= '0' && ((unsigned char)x) <= '9')

#define ares_isxdigit(x)                                       \
  (ares_isdigit(x) ||                                          \
   (((unsigned char)x) >= 'a' && ((unsigned char)x) <= 'f') || \
   (((unsigned char)x) >= 'A' && ((unsigned char)x) <= 'F'))

#define ares_isupper(x) (((unsigned char)x) >= 'A' && ((unsigned char)x) <= 'Z')

#define ares_islower(x) (((unsigned char)x) >= 'a' && ((unsigned char)x) <= 'z')

#define ares_isalpha(x) (ares_islower(x) || ares_isupper(x))

#define ares_isspace(x)                                            \
  (((unsigned char)(x)) == '\r' || ((unsigned char)(x)) == '\t' || \
   ((unsigned char)(x)) == ' ' || ((unsigned char)(x)) == '\v' ||  \
   ((unsigned char)(x)) == '\f' || ((unsigned char)(x)) == '\n')

#define ares_isprint(x) \
  (((unsigned char)(x)) >= 0x20 && ((unsigned char)(x)) <= 0x7E)

/* Character set allowed by hostnames.  This is to include the normal
 * domain name character set plus:
 *  - underscores which are used in SRV records.
 *  - Forward slashes such as are used for classless in-addr.arpa
 *    delegation (CNAMEs)
 *  - Asterisks may be used for wildcard domains in CNAMEs as seen in the
 *    real world.
 * While RFC 2181 section 11 does state not to do validation,
 * that applies to servers, not clients.  Vulnerabilities have been
 * reported when this validation is not performed.  Security is more
 * important than edge-case compatibility (which is probably invalid
 * anyhow).
 * [A-Za-z0-9-*._/]
 */
#define ares_is_hostnamech(x)                                           \
  (ares_isalpha(x) || ares_isdigit(x) || ((unsigned char)(x)) == '-' || \
   ((unsigned char)(x)) == '.' || ((unsigned char)(x)) == '_' ||        \
   ((unsigned char)(x)) == '/' || ((unsigned char)(x)) == '*')


/*! Compare two strings (for sorting)
 *
 *  Treats NULL and "" strings as equivalent
 *
 *  \param[in] a First String
 *  \param[in] b Second String
 *  \return < 0 if First String less than Second String,
 *            0 if First String equal to Second String,
 *          > 0 if First String greater than Second String
 */
CARES_EXTERN int ares_strcmp(const char *a, const char *b);

/*! Compare two strings up to specified length (for sorting)
 *
 *  Treats NULL and "" strings as equivalent
 *
 *  \param[in] a First String
 *  \param[in] b Second String
 *  \param[in] n Length
 *  \return < 0 if First String less than Second String,
 *            0 if First String equal to Second String,
 *          > 0 if First String greater than Second String
 */
CARES_EXTERN int ares_strncmp(const char *a, const char *b, size_t n);


/*! Compare two strings in a case-insensitive manner (for sorting)
 *
 *  Treats NULL and "" strings as equivalent
 *
 *  \param[in] a First String
 *  \param[in] b Second String
 *  \return < 0 if First String less than Second String,
 *            0 if First String equal to Second String,
 *          > 0 if First String greater than Second String
 */
CARES_EXTERN int ares_strcasecmp(const char *a, const char *b);

/*! Compare two strings in a case-insensitive manner up to specified length
 *  (for sorting)
 *
 *  Treats NULL and "" strings as equivalent
 *
 *  \param[in] a First String
 *  \param[in] b Second String
 *  \param[in] n Length
 *  \return < 0 if First String less than Second String,
 *            0 if First String equal to Second String,
 *          > 0 if First String greater than Second String
 */
CARES_EXTERN int ares_strncasecmp(const char *a, const char *b, size_t n);

/*! Compare two strings for equality
 *
 *  Treats NULL and "" strings as equivalent
 *
 *  \param[in] a First String
 *  \param[in] b Second String
 *  \return ARES_TRUE on match, or ARES_FALSE if no match
 */
CARES_EXTERN ares_bool_t ares_streq(const char *a, const char *b);

/*! Compare two strings for equality up to specified length
 *
 *  Treats NULL and "" strings as equivalent
 *
 *  \param[in] a First String
 *  \param[in] b Second String
 *  \param[in] n Length
 *  \return ARES_TRUE on match, or ARES_FALSE if no match
 */
CARES_EXTERN ares_bool_t ares_streq_max(const char *a, const char *b, size_t n);

/*! Compare two strings for equality in a case insensitive manner
 *
 *  Treats NULL and "" strings as equivalent
 *
 *  \param[in] a First String
 *  \param[in] b Second String
 *  \return ARES_TRUE on match, or ARES_FALSE if no match
 */
CARES_EXTERN ares_bool_t ares_strcaseeq(const char *a, const char *b);

/*! Compare two strings for equality up to specified length in a case
 *  insensitive manner
 *
 *  Treats NULL and "" strings as equivalent
 *
 *  \param[in] a First String
 *  \param[in] b Second String
 *  \param[in] n Length
 *  \return ARES_TRUE on match, or ARES_FALSE if no match
 */
CARES_EXTERN ares_bool_t ares_strcaseeq_max(const char *a, const char *b,
                                            size_t n);

/*! Free a C array, each element in the array will be freed by the provided
 *  free function.  Both NULL-terminated arrays and known length arrays are
 *  supported.
 *
 *  \param[in] arr      Array to be freed.
 *  \param[in] nmembers Number of members in the array, or SIZE_MAX for
 *                      NULL-terminated arrays
 *  \param[in] freefunc Function to call on each array member (e.g. ares_free)
 */
CARES_EXTERN void        ares_free_array(void *arr, size_t nmembers,
                                         void (*freefunc)(void *));

#endif /* __ARES_STR_H */
                                                                                                                                                                                                                                                    node-23.7.0/deps/cares/src/lib/inet_net_pton.c                                                      0000664 0000000 0000000 00000026530 14746647661 0021161 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2012 by Gilles Chehade <gilles@openbsd.org>
 * Copyright (c) 1996,1999 by Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif
#ifdef HAVE_ARPA_INET_H
#  include <arpa/inet.h>
#endif

#include "ares_nameser.h"

#include "ares_ipv6.h"
#include "ares_inet_net_pton.h"

#ifdef USE_WINSOCK
#  define SOCKERRNO        ((int)WSAGetLastError())
#  define SET_SOCKERRNO(x) (WSASetLastError((int)(x)))
#  undef EMSGSIZE
#  define EMSGSIZE WSAEMSGSIZE
#  undef ENOENT
#  define ENOENT WSA_INVALID_PARAMETER
#  undef EAFNOSUPPORT
#  define EAFNOSUPPORT WSAEAFNOSUPPORT
#else
#  define SOCKERRNO        (errno)
#  define SET_SOCKERRNO(x) (errno = (x))
#endif

const struct ares_in6_addr ares_in6addr_any = { { { 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                                    0, 0, 0, 0, 0, 0, 0 } } };

/*
 * static int
 * inet_net_pton_ipv4(src, dst, size)
 *      convert IPv4 network number from presentation to network format.
 *      accepts hex octets, hex strings, decimal octets, and /CIDR.
 *      "size" is in bytes and describes "dst".
 * return:
 *      number of bits, either imputed classfully or specified with /CIDR,
 *      or -1 if some failure occurred (check errno).  ENOENT means it was
 *      not an IPv4 network specification.
 * note:
 *      network byte order assumed.  this means 192.5.5.240/28 has
 *      0b11110000 in its fourth octet.
 * note:
 *      On Windows we store the error in the thread errno, not
 *      in the winsock error code. This is to avoid losing the
 *      actual last winsock error. So use macro ERRNO to fetch the
 *      errno this function sets when returning (-1), not SOCKERRNO.
 * author:
 *      Paul Vixie (ISC), June 1996
 */
static int ares_inet_net_pton_ipv4(const char *src, unsigned char *dst,
                                   size_t size)
{
  static const char    xdigits[] = "0123456789abcdef";
  static const char    digits[]  = "0123456789";
  int                  n;
  int                  ch;
  int                  tmp = 0;
  int                  dirty;
  int                  bits;
  const unsigned char *odst = dst;

  ch = *src++;
  if (ch == '0' && (src[0] == 'x' || src[0] == 'X') && ares_isascii(src[1]) &&
      ares_isxdigit(src[1])) {
    /* Hexadecimal: Eat nybble string. */
    if (!size) {
      goto emsgsize;
    }
    dirty = 0;
    src++; /* skip x or X. */
    while ((ch = *src++) != '\0' && ares_isascii(ch) && ares_isxdigit(ch)) {
      if (ares_isupper(ch)) {
        ch = ares_tolower((unsigned char)ch);
      }
      n = (int)(strchr(xdigits, ch) - xdigits);
      if (dirty == 0) {
        tmp = n;
      } else {
        tmp = (tmp << 4) | n;
      }
      if (++dirty == 2) {
        if (!size--) {
          goto emsgsize;
        }
        *dst++ = (unsigned char)tmp;
        dirty  = 0;
      }
    }
    if (dirty) { /* Odd trailing nybble? */
      if (!size--) {
        goto emsgsize;
      }
      *dst++ = (unsigned char)(tmp << 4);
    }
  } else if (ares_isascii(ch) && ares_isdigit(ch)) {
    /* Decimal: eat dotted digit string. */
    for (;;) {
      tmp = 0;
      do {
        n    = (int)(strchr(digits, ch) - digits);
        tmp *= 10;
        tmp += n;
        if (tmp > 255) {
          goto enoent;
        }
      } while ((ch = *src++) != '\0' && ares_isascii(ch) && ares_isdigit(ch));
      if (!size--) {
        goto emsgsize;
      }
      *dst++ = (unsigned char)tmp;
      if (ch == '\0' || ch == '/') {
        break;
      }
      if (ch != '.') {
        goto enoent;
      }
      ch = *src++;
      if (!ares_isascii(ch) || !ares_isdigit(ch)) {
        goto enoent;
      }
    }
  } else {
    goto enoent;
  }

  bits = -1;
  if (ch == '/' && ares_isascii(src[0]) && ares_isdigit(src[0]) && dst > odst) {
    /* CIDR width specifier.  Nothing can follow it. */
    ch   = *src++; /* Skip over the /. */
    bits = 0;
    do {
      n     = (int)(strchr(digits, ch) - digits);
      bits *= 10;
      bits += n;
      if (bits > 32) {
        goto enoent;
      }
    } while ((ch = *src++) != '\0' && ares_isascii(ch) && ares_isdigit(ch));
    if (ch != '\0') {
      goto enoent;
    }
  }

  /* Firey death and destruction unless we prefetched EOS. */
  if (ch != '\0') {
    goto enoent;
  }

  /* If nothing was written to the destination, we found no address. */
  if (dst == odst) {
    goto enoent; /* LCOV_EXCL_LINE: all valid paths above increment dst */
  }
  /* If no CIDR spec was given, infer width from net class. */
  if (bits == -1) {
    if (*odst >= 240) {        /* Class E */
      bits = 32;
    } else if (*odst >= 224) { /* Class D */
      bits = 8;
    } else if (*odst >= 192) { /* Class C */
      bits = 24;
    } else if (*odst >= 128) { /* Class B */
      bits = 16;
    } else {                   /* Class A */
      bits = 8;
    }
    /* If imputed mask is narrower than specified octets, widen. */
    if (bits < ((dst - odst) * 8)) {
      bits = (int)(dst - odst) * 8;
    }
    /*
     * If there are no additional bits specified for a class D
     * address adjust bits to 4.
     */
    if (bits == 8 && *odst == 224) {
      bits = 4;
    }
  }
  /* Extend network to cover the actual mask. */
  while (bits > ((dst - odst) * 8)) {
    if (!size--) {
      goto emsgsize;
    }
    *dst++ = '\0';
  }
  return bits;

enoent:
  SET_SOCKERRNO(ENOENT);
  return -1;

emsgsize:
  SET_SOCKERRNO(EMSGSIZE);
  return -1;
}

static int getbits(const char *src, size_t *bitsp)
{
  static const char digits[] = "0123456789";
  size_t            n;
  size_t            val;
  char              ch;

  val = 0;
  n   = 0;
  while ((ch = *src++) != '\0') {
    const char *pch;

    pch = strchr(digits, ch);
    if (pch != NULL) {
      if (n++ != 0 && val == 0) { /* no leading zeros */
        return 0;
      }
      val *= 10;
      val += (size_t)(pch - digits);
      if (val > 128) { /* range */
        return 0;
      }
      continue;
    }
    return 0;
  }
  if (n == 0) {
    return 0;
  }
  *bitsp = val;
  return 1;
}

static int ares_inet_pton6(const char *src, unsigned char *dst)
{
  static const char xdigits_l[] = "0123456789abcdef";
  static const char xdigits_u[] = "0123456789ABCDEF";
  unsigned char     tmp[NS_IN6ADDRSZ];
  unsigned char    *tp;
  unsigned char    *endp;
  unsigned char    *colonp;
  const char       *xdigits;
  const char       *curtok;
  int               ch;
  int               saw_xdigit;
  int               count_xdigit;
  unsigned int      val;

  memset((tp = tmp), '\0', NS_IN6ADDRSZ);
  endp   = tp + NS_IN6ADDRSZ;
  colonp = NULL;
  /* Leading :: requires some special handling. */
  if (*src == ':') {
    if (*++src != ':') {
      goto enoent;
    }
  }
  curtok     = src;
  saw_xdigit = count_xdigit = 0;
  val                       = 0;
  while ((ch = *src++) != '\0') {
    const char *pch;

    if ((pch = strchr((xdigits = xdigits_l), ch)) == NULL) {
      pch = strchr((xdigits = xdigits_u), ch);
    }
    if (pch != NULL) {
      if (count_xdigit >= 4) {
        goto enoent;
      }
      val <<= 4;
      val  |= (unsigned int)(pch - xdigits);
      if (val > 0xffff) {
        goto enoent;
      }
      saw_xdigit = 1;
      count_xdigit++;
      continue;
    }
    if (ch == ':') {
      curtok = src;
      if (!saw_xdigit) {
        if (colonp) {
          goto enoent;
        }
        colonp = tp;
        continue;
      } else if (*src == '\0') {
        goto enoent;
      }
      if (tp + NS_INT16SZ > endp) {
        goto enoent;
      }
      *tp++        = (unsigned char)(val >> 8) & 0xff;
      *tp++        = (unsigned char)val & 0xff;
      saw_xdigit   = 0;
      count_xdigit = 0;
      val          = 0;
      continue;
    }
    if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&
        ares_inet_net_pton_ipv4(curtok, tp, NS_INADDRSZ) > 0) {
      tp         += NS_INADDRSZ;
      saw_xdigit  = 0;
      break; /* '\0' was seen by inet_pton4(). */
    }
    goto enoent;
  }
  if (saw_xdigit) {
    if (tp + NS_INT16SZ > endp) {
      goto enoent;
    }
    *tp++ = (unsigned char)(val >> 8) & 0xff;
    *tp++ = (unsigned char)val & 0xff;
  }
  if (colonp != NULL) {
    /*
     * Since some memmove()'s erroneously fail to handle
     * overlapping regions, we'll do the shift by hand.
     */
    const int n = (int)(tp - colonp);
    int       i;

    if (tp == endp) {
      goto enoent;
    }
    for (i = 1; i <= n; i++) {
      endp[-i]      = colonp[n - i];
      colonp[n - i] = 0;
    }
    tp = endp;
  }
  if (tp != endp) {
    goto enoent;
  }

  memcpy(dst, tmp, NS_IN6ADDRSZ);
  return 1;

enoent:
  SET_SOCKERRNO(ENOENT);
  return -1;
}

static int ares_inet_net_pton_ipv6(const char *src, unsigned char *dst,
                                   size_t size)
{
  struct ares_in6_addr in6;
  int                  ret;
  size_t               bits;
  size_t               bytes;
  char                 buf[INET6_ADDRSTRLEN + sizeof("/128")];
  char                *sep;

  if (ares_strlen(src) >= sizeof buf) {
    SET_SOCKERRNO(EMSGSIZE);
    return -1;
  }
  ares_strcpy(buf, src, sizeof buf);

  sep = strchr(buf, '/');
  if (sep != NULL) {
    *sep++ = '\0';
  }

  ret = ares_inet_pton6(buf, (unsigned char *)&in6);
  if (ret != 1) {
    return -1;
  }

  if (sep == NULL) {
    bits = 128;
  } else {
    if (!getbits(sep, &bits)) {
      SET_SOCKERRNO(ENOENT);
      return -1;
    }
  }

  bytes = (bits + 7) / 8;
  if (bytes > size) {
    SET_SOCKERRNO(EMSGSIZE);
    return -1;
  }
  memcpy(dst, &in6, bytes);
  return (int)bits;
}

/*
 * int
 * inet_net_pton(af, src, dst, size)
 *      convert network number from presentation to network format.
 *      accepts hex octets, hex strings, decimal octets, and /CIDR.
 *      "size" is in bytes and describes "dst".
 * return:
 *      number of bits, either imputed classfully or specified with /CIDR,
 *      or -1 if some failure occurred (check errno).  ENOENT means it was
 *      not a valid network specification.
 * author:
 *      Paul Vixie (ISC), June 1996
 *
 */
int ares_inet_net_pton(int af, const char *src, void *dst, size_t size)
{
  switch (af) {
    case AF_INET:
      return ares_inet_net_pton_ipv4(src, dst, size);
    case AF_INET6:
      return ares_inet_net_pton_ipv6(src, dst, size);
    default:
      return -1;
  }
}

int ares_inet_pton(int af, const char *src, void *dst)
{
  int    result;
  size_t size;

  if (af == AF_INET) {
    size = sizeof(struct in_addr);
  } else if (af == AF_INET6) {
    size = sizeof(struct ares_in6_addr);
  } else {
    SET_SOCKERRNO(EAFNOSUPPORT);
    return -1;
  }
  result = ares_inet_net_pton(af, src, dst, size);
  if (result == -1 && SOCKERRNO == ENOENT) {
    return 0;
  }
  return (result > -1) ? 1 : -1;
}
                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/inet_ntop.c                                                          0000664 0000000 0000000 00000013714 14746647661 0020313 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
 * Copyright (c) 1996-1999 by Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif
#ifdef HAVE_ARPA_INET_H
#  include <arpa/inet.h>
#endif

#include "ares_nameser.h"
#include "ares_ipv6.h"

#ifdef USE_WINSOCK
#  define SOCKERRNO        ((int)WSAGetLastError())
#  define SET_SOCKERRNO(x) (WSASetLastError((int)(x)))
#  undef EMSGSIZE
#  define EMSGSIZE WSAEMSGSIZE
#  undef ENOENT
#  define ENOENT WSA_INVALID_PARAMETER
#  undef EAFNOSUPPORT
#  define EAFNOSUPPORT WSAEAFNOSUPPORT
#  undef ENOSPC
#  define ENOSPC WSA_INVALID_PARAMETER
#else
#  define SOCKERRNO        (errno)
#  define SET_SOCKERRNO(x) (errno = (x))
#endif

/*
 * WARNING: Don't even consider trying to compile this on a system where
 * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
 */

static const char *inet_ntop4(const unsigned char *src, char *dst, size_t size);
static const char *inet_ntop6(const unsigned char *src, char *dst, size_t size);

/* char *
 * inet_ntop(af, src, dst, size)
 *     convert a network format address to presentation format.
 * return:
 *     pointer to presentation format address (`dst'), or NULL (see errno).
 * author:
 *     Paul Vixie, 1996.
 */
const char        *ares_inet_ntop(int af, const void *src, char *dst,
                                  ares_socklen_t size)
{
  switch (af) {
    case AF_INET:
      return inet_ntop4(src, dst, (size_t)size);
    case AF_INET6:
      return inet_ntop6(src, dst, (size_t)size);
    default:
      break;
  }
  SET_SOCKERRNO(EAFNOSUPPORT);
  return NULL;
}

/* const char *
 * inet_ntop4(src, dst, size)
 *     format an IPv4 address
 * return:
 *     `dst' (as a const)
 * notes:
 *     (1) uses no statics
 *     (2) takes a unsigned char* not an in_addr as input
 * author:
 *     Paul Vixie, 1996.
 */
static const char *inet_ntop4(const unsigned char *src, char *dst, size_t size)
{
  static const char fmt[] = "%u.%u.%u.%u";
  char              tmp[sizeof("255.255.255.255")];

  if (size < sizeof(tmp)) {
    SET_SOCKERRNO(ENOSPC);
    return NULL;
  }

  if ((size_t)snprintf(tmp, sizeof(tmp), fmt, src[0], src[1], src[2], src[3]) >=
      size) {
    SET_SOCKERRNO(ENOSPC);
    return NULL;
  }
  ares_strcpy(dst, tmp, size);
  return dst;
}

/* const char *
 * inet_ntop6(src, dst, size)
 *     convert IPv6 binary address into presentation (printable) format
 * author:
 *     Paul Vixie, 1996.
 */
static const char *inet_ntop6(const unsigned char *src, char *dst, size_t size)
{
  /*
   * Note that int32_t and int16_t need only be "at least" large enough
   * to contain a value of the specified size.  On some systems, like
   * Crays, there is no such thing as an integer variable with 16 bits.
   * Keep this in mind if you think this function should have been coded
   * to use pointer overlays.  All the world's not a VAX.
   */
  char  tmp[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];
  char *tp;

  struct {
    ares_ssize_t base;
    size_t       len;
  } best, cur;

  unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];
  size_t       i;

  /*
   * Preprocess:
   *  Copy the input (bytewise) array into a wordwise array.
   *  Find the longest run of 0x00's in src[] for :: shorthanding.
   */
  memset(words, '\0', sizeof(words));
  for (i = 0; i < NS_IN6ADDRSZ; i++) {
    words[i / 2] |= (unsigned int)(src[i] << ((1 - (i % 2)) << 3));
  }
  best.base = -1;
  best.len  = 0;
  cur.base  = -1;
  cur.len   = 0;
  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
    if (words[i] == 0) {
      if (cur.base == -1) {
        cur.base = (ares_ssize_t)i;
        cur.len  = 1;
      } else {
        cur.len++;
      }
    } else {
      if (cur.base != -1) {
        if (best.base == -1 || cur.len > best.len) {
          best = cur;
        }
        cur.base = -1;
      }
    }
  }
  if (cur.base != -1) {
    if (best.base == -1 || cur.len > best.len) {
      best = cur;
    }
  }
  if (best.base != -1 && best.len < 2) {
    best.base = -1;
  }

  /*
   * Format the result.
   */
  tp = tmp;
  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
    /* Are we inside the best run of 0x00's? */
    if (best.base != -1 && i >= (size_t)best.base &&
        i < ((size_t)best.base + best.len)) {
      if (i == (size_t)best.base) {
        *tp++ = ':';
      }
      continue;
    }
    /* Are we following an initial run of 0x00s or any real hex? */
    if (i != 0) {
      *tp++ = ':';
    }
    /* Is this address an encapsulated IPv4? */
    if (i == 6 && best.base == 0 &&
        (best.len == 6 || (best.len == 7 && words[7] != 0x0001) ||
         (best.len == 5 && words[5] == 0xffff))) {
      if (!inet_ntop4(src + 12, tp, sizeof(tmp) - (size_t)(tp - tmp))) {
        return (NULL);
      }
      tp += ares_strlen(tp);
      break;
    }
    tp += snprintf(tp, sizeof(tmp) - (size_t)(tp - tmp), "%x", words[i]);
  }
  /* Was it a trailing run of 0x00's? */
  if (best.base != -1 &&
      ((size_t)best.base + best.len) == (NS_IN6ADDRSZ / NS_INT16SZ)) {
    *tp++ = ':';
  }
  *tp++ = '\0';

  /*
   * Check for overflow, copy, and we're done.
   */
  if ((size_t)(tp - tmp) > size) {
    SET_SOCKERRNO(ENOSPC);
    return NULL;
  }
  ares_strcpy(dst, tmp, size);
  return dst;
}
                                                    node-23.7.0/deps/cares/src/lib/legacy/                                                              0000775 0000000 0000000 00000000000 14746647661 0017406 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/legacy/ares_create_query.c                                           0000664 0000000 0000000 00000005216 14746647661 0023260 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

static int ares_create_query_int(const char *name, int dnsclass, int type,
                                 unsigned short id, int rd,
                                 unsigned char **bufp, int *buflenp,
                                 int max_udp_size)
{
  ares_status_t      status;
  ares_dns_record_t *dnsrec = NULL;
  size_t             len;
  ares_dns_flags_t   rd_flag = rd ? ARES_FLAG_RD : 0;

  if (name == NULL || bufp == NULL || buflenp == NULL) {
    status = ARES_EFORMERR;
    goto done;
  }

  *bufp    = NULL;
  *buflenp = 0;

  status = ares_dns_record_create_query(
    &dnsrec, name, (ares_dns_class_t)dnsclass, (ares_dns_rec_type_t)type, id,
    rd_flag, (size_t)max_udp_size);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  status = ares_dns_write(dnsrec, bufp, &len);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  *buflenp = (int)len;

done:
  ares_dns_record_destroy(dnsrec);
  return (int)status;
}

int ares_create_query(const char *name, int dnsclass, int type,
                      unsigned short id, int rd, unsigned char **bufp,
                      int *buflenp, int max_udp_size)
{
  return ares_create_query_int(name, dnsclass, type, id, rd, bufp, buflenp,
                               max_udp_size);
}

int ares_mkquery(const char *name, int dnsclass, int type, unsigned short id,
                 int rd, unsigned char **buf, int *buflen)
{
  return ares_create_query_int(name, dnsclass, type, id, rd, buf, buflen, 0);
}
                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/cares/src/lib/legacy/ares_expand_name.c                                            0000664 0000000 0000000 00000006012 14746647661 0023042 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998, 2011 Massachusetts Institute of Technology
 * Copyright (c) The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif

#include "ares_nameser.h"

ares_status_t ares_expand_name_validated(const unsigned char *encoded,
                                         const unsigned char *abuf, size_t alen,
                                         char **s, size_t *enclen,
                                         ares_bool_t is_hostname)
{
  ares_status_t status;
  ares_buf_t   *buf = NULL;
  size_t        start_len;

  if (encoded == NULL || abuf == NULL || alen == 0 || enclen == NULL) {
    return ARES_EBADNAME; /* EFORMERR would be better */
  }

  if (encoded < abuf || encoded >= abuf + alen) {
    return ARES_EBADNAME; /* EFORMERR would be better */
  }

  *enclen = 0;

  /* NOTE: we allow 's' to be NULL to skip it */
  if (s) {
    *s = NULL;
  }

  buf = ares_buf_create_const(abuf, alen);

  if (buf == NULL) {
    return ARES_ENOMEM;
  }

  status = ares_buf_set_position(buf, (size_t)(encoded - abuf));
  if (status != ARES_SUCCESS) {
    goto done;
  }

  start_len = ares_buf_len(buf);
  status    = ares_dns_name_parse(buf, s, is_hostname);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  *enclen = start_len - ares_buf_len(buf);

done:
  ares_buf_destroy(buf);
  return status;
}

int ares_expand_name(const unsigned char *encoded, const unsigned char *abuf,
                     int alen, char **s, long *enclen)
{
  /* Keep public API compatible */
  size_t        enclen_temp = 0;
  ares_status_t status;

  if (encoded == NULL || abuf == NULL || alen <= 0 || enclen == NULL) {
    return ARES_EBADNAME;
  }

  status  = ares_expand_name_validated(encoded, abuf, (size_t)alen, s,
                                       &enclen_temp, ARES_FALSE);
  *enclen = (long)enclen_temp;
  return (int)status;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/cares/src/lib/legacy/ares_expand_string.c                                          0000664 0000000 0000000 00000006435 14746647661 0023441 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif

#include "ares_nameser.h"

/* Simply decodes a length-encoded character string. The first byte of the
 * input is the length of the string to be returned and the bytes thereafter
 * are the characters of the string. The returned result will be NULL
 * terminated.
 */
ares_status_t ares_expand_string_ex(const unsigned char *encoded,
                                    const unsigned char *abuf, size_t alen,
                                    unsigned char **s, size_t *enclen)
{
  ares_status_t status;
  ares_buf_t   *buf = NULL;
  size_t        start_len;
  size_t        len = 0;

  if (encoded == NULL || abuf == NULL || alen == 0 || enclen == NULL) {
    return ARES_EBADSTR; /* EFORMERR would be better */
  }

  if (encoded < abuf || encoded >= abuf + alen) {
    return ARES_EBADSTR; /* EFORMERR would be better */
  }

  *enclen = 0;

  /* NOTE: we allow 's' to be NULL to skip it */
  if (s) {
    *s = NULL;
  }

  buf = ares_buf_create_const(abuf, alen);

  if (buf == NULL) {
    return ARES_ENOMEM;
  }

  status = ares_buf_set_position(buf, (size_t)(encoded - abuf));
  if (status != ARES_SUCCESS) {
    goto done;
  }

  start_len = ares_buf_len(buf);
  status    = ares_buf_parse_dns_binstr(buf, ares_buf_len(buf), s, &len);
  /* hrm, no way to pass back 'len' with the prototype */
  if (status != ARES_SUCCESS) {
    goto done;
  }

  *enclen = start_len - ares_buf_len(buf);

done:
  ares_buf_destroy(buf);
  if (status == ARES_EBADNAME || status == ARES_EBADRESP) {
    status = ARES_EBADSTR;
  }
  return status;
}

int ares_expand_string(const unsigned char *encoded, const unsigned char *abuf,
                       int alen, unsigned char **s, long *enclen)
{
  ares_status_t status;
  size_t        temp_enclen = 0;

  if (encoded == NULL || abuf == NULL || alen <= 0 || enclen == NULL) {
    return ARES_EBADRESP;
  }

  status = ares_expand_string_ex(encoded, abuf, (size_t)alen, s, &temp_enclen);

  *enclen = (long)temp_enclen;
  return (int)status;
}
                                                                                                                                                                                                                                   node-23.7.0/deps/cares/src/lib/legacy/ares_fds.c                                                    0000664 0000000 0000000 00000005160 14746647661 0021342 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

int ares_fds(const ares_channel_t *channel, fd_set *read_fds, fd_set *write_fds)
{
  ares_socket_t      nfds;
  ares_slist_node_t *snode;
  /* Are there any active queries? */
  size_t             active_queries;

  if (channel == NULL || read_fds == NULL || write_fds == NULL) {
    return 0;
  }

  ares_channel_lock(channel);

  active_queries = ares_llist_len(channel->all_queries);

  nfds = 0;
  for (snode = ares_slist_node_first(channel->servers); snode != NULL;
       snode = ares_slist_node_next(snode)) {
    ares_server_t     *server = ares_slist_node_val(snode);
    ares_llist_node_t *node;

    for (node = ares_llist_node_first(server->connections); node != NULL;
         node = ares_llist_node_next(node)) {
      const ares_conn_t *conn = ares_llist_node_val(node);

      if (!active_queries && !(conn->flags & ARES_CONN_FLAG_TCP)) {
        continue;
      }

      /* Silence coverity, shouldn't be possible */
      if (conn->fd == ARES_SOCKET_BAD) {
        continue;
      }

      /* Always wait on read */
      FD_SET(conn->fd, read_fds);

      if (conn->fd >= nfds) {
        nfds = conn->fd + 1;
      }

      /* TCP only wait on write if we have the flag set */
      if (conn->state_flags & ARES_CONN_STATE_WRITE) {
        FD_SET(conn->fd, write_fds);
      }
    }
  }

  ares_channel_unlock(channel);
  return (int)nfds;
}
                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/cares/src/lib/legacy/ares_getsock.c                                                0000664 0000000 0000000 00000005462 14746647661 0022232 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2005 Daniel Stenberg
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

int ares_getsock(const ares_channel_t *channel, ares_socket_t *socks,
                 int numsocks) /* size of the 'socks' array */
{
  ares_slist_node_t *snode;
  size_t             sockindex = 0;
  unsigned int       bitmap    = 0;
  unsigned int       setbits   = 0xffffffff;

  /* Are there any active queries? */
  size_t             active_queries;

  if (channel == NULL || numsocks <= 0) {
    return 0;
  }

  ares_channel_lock(channel);

  active_queries = ares_llist_len(channel->all_queries);

  for (snode = ares_slist_node_first(channel->servers); snode != NULL;
       snode = ares_slist_node_next(snode)) {
    ares_server_t     *server = ares_slist_node_val(snode);
    ares_llist_node_t *node;

    for (node = ares_llist_node_first(server->connections); node != NULL;
         node = ares_llist_node_next(node)) {
      const ares_conn_t *conn = ares_llist_node_val(node);

      if (sockindex >= (size_t)numsocks || sockindex >= ARES_GETSOCK_MAXNUM) {
        break;
      }

      /* We only need to register interest in UDP sockets if we have
       * outstanding queries.
       */
      if (!active_queries && !(conn->flags & ARES_CONN_FLAG_TCP)) {
        continue;
      }

      socks[sockindex] = conn->fd;

      if (active_queries || conn->flags & ARES_CONN_FLAG_TCP) {
        bitmap |= ARES_GETSOCK_READABLE(setbits, sockindex);
      }

      if (conn->state_flags & ARES_CONN_STATE_WRITE) {
        /* then the tcp socket is also writable! */
        bitmap |= ARES_GETSOCK_WRITABLE(setbits, sockindex);
      }

      sockindex++;
    }
  }

  ares_channel_unlock(channel);
  return (int)bitmap;
}
                                                                                                                                                                                                              node-23.7.0/deps/cares/src/lib/legacy/ares_parse_a_reply.c                                          0000664 0000000 0000000 00000005744 14746647661 0023423 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) 2019 Andrew Selivanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif
#ifdef HAVE_NETDB_H
#  include <netdb.h>
#endif
#ifdef HAVE_ARPA_INET_H
#  include <arpa/inet.h>
#endif

#ifdef HAVE_STRINGS_H
#  include <strings.h>
#endif

#ifdef HAVE_LIMITS_H
#  include <limits.h>
#endif

int ares_parse_a_reply(const unsigned char *abuf, int alen,
                       struct hostent **host, struct ares_addrttl *addrttls,
                       int *naddrttls)
{
  struct ares_addrinfo ai;
  char                *question_hostname = NULL;
  ares_status_t        status;
  size_t               req_naddrttls = 0;
  ares_dns_record_t   *dnsrec        = NULL;

  if (alen < 0) {
    return ARES_EBADRESP;
  }

  if (naddrttls) {
    req_naddrttls = (size_t)*naddrttls;
    *naddrttls    = 0;
  }

  memset(&ai, 0, sizeof(ai));

  status = ares_dns_parse(abuf, (size_t)alen, 0, &dnsrec);
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  status = ares_parse_into_addrinfo(dnsrec, 0, 0, &ai);
  if (status != ARES_SUCCESS && status != ARES_ENODATA) {
    goto fail;
  }

  if (host != NULL) {
    status = ares_addrinfo2hostent(&ai, AF_INET, host);
    if (status != ARES_SUCCESS && status != ARES_ENODATA) {
      goto fail; /* LCOV_EXCL_LINE: DefensiveCoding */
    }
  }

  if (addrttls != NULL && req_naddrttls) {
    size_t temp_naddrttls = 0;
    ares_addrinfo2addrttl(&ai, AF_INET, req_naddrttls, addrttls, NULL,
                          &temp_naddrttls);
    *naddrttls = (int)temp_naddrttls;
  }


fail:
  ares_freeaddrinfo_cnames(ai.cnames);
  ares_freeaddrinfo_nodes(ai.nodes);
  ares_free(ai.name);
  ares_free(question_hostname);
  ares_dns_record_destroy(dnsrec);

  if (status == ARES_EBADNAME) {
    status = ARES_EBADRESP;
  }

  return (int)status;
}
                            node-23.7.0/deps/cares/src/lib/legacy/ares_parse_aaaa_reply.c                                       0000664 0000000 0000000 00000006066 14746647661 0024064 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) 2005 Dominick Meglio
 * Copyright (c) 2019 Andrew Selivanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif
#ifdef HAVE_NETDB_H
#  include <netdb.h>
#endif
#ifdef HAVE_ARPA_INET_H
#  include <arpa/inet.h>
#endif

#ifdef HAVE_STRINGS_H
#  include <strings.h>
#endif

#ifdef HAVE_LIMITS_H
#  include <limits.h>
#endif

#include "ares_inet_net_pton.h"

int ares_parse_aaaa_reply(const unsigned char *abuf, int alen,
                          struct hostent **host, struct ares_addr6ttl *addrttls,
                          int *naddrttls)
{
  struct ares_addrinfo ai;
  char                *question_hostname = NULL;
  ares_status_t        status;
  size_t               req_naddrttls = 0;
  ares_dns_record_t   *dnsrec        = NULL;

  if (alen < 0) {
    return ARES_EBADRESP;
  }

  if (naddrttls) {
    req_naddrttls = (size_t)*naddrttls;
    *naddrttls    = 0;
  }

  memset(&ai, 0, sizeof(ai));

  status = ares_dns_parse(abuf, (size_t)alen, 0, &dnsrec);
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  status = ares_parse_into_addrinfo(dnsrec, 0, 0, &ai);
  if (status != ARES_SUCCESS && status != ARES_ENODATA) {
    goto fail;
  }

  if (host != NULL) {
    status = ares_addrinfo2hostent(&ai, AF_INET6, host);
    if (status != ARES_SUCCESS && status != ARES_ENODATA) {
      goto fail; /* LCOV_EXCL_LINE: DefensiveCoding */
    }
  }

  if (addrttls != NULL && req_naddrttls) {
    size_t temp_naddrttls = 0;
    ares_addrinfo2addrttl(&ai, AF_INET6, req_naddrttls, NULL, addrttls,
                          &temp_naddrttls);
    *naddrttls = (int)temp_naddrttls;
  }

fail:
  ares_freeaddrinfo_cnames(ai.cnames);
  ares_freeaddrinfo_nodes(ai.nodes);
  ares_free(question_hostname);
  ares_free(ai.name);
  ares_dns_record_destroy(dnsrec);

  if (status == ARES_EBADNAME) {
    status = ARES_EBADRESP;
  }

  return (int)status;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/cares/src/lib/legacy/ares_parse_caa_reply.c                                        0000664 0000000 0000000 00000010640 14746647661 0023716 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"
#include "ares_data.h"

int ares_parse_caa_reply(const unsigned char *abuf, int alen_int,
                         struct ares_caa_reply **caa_out)
{
  ares_status_t          status;
  size_t                 alen;
  struct ares_caa_reply *caa_head = NULL;
  struct ares_caa_reply *caa_last = NULL;
  struct ares_caa_reply *caa_curr;
  ares_dns_record_t     *dnsrec = NULL;
  size_t                 i;

  *caa_out = NULL;

  if (alen_int < 0) {
    return ARES_EBADRESP;
  }

  alen = (size_t)alen_int;

  status = ares_dns_parse(abuf, alen, 0, &dnsrec);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {
    status = ARES_ENODATA;
    goto done;
  }

  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {
    const unsigned char *ptr;
    size_t               ptr_len;
    const ares_dns_rr_t *rr =
      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);

    if (rr == NULL) {
      /* Shouldn't be possible */
      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */
      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    /* XXX: Why do we allow Chaos class? */
    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN &&
        ares_dns_rr_get_class(rr) != ARES_CLASS_CHAOS) {
      continue;
    }

    /* Only looking for CAA records */
    if (ares_dns_rr_get_type(rr) != ARES_REC_TYPE_CAA) {
      continue;
    }

    /* Allocate storage for this CAA answer appending it to the list */
    caa_curr = ares_malloc_data(ARES_DATATYPE_CAA_REPLY);
    if (caa_curr == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* Link in the record */
    if (caa_last) {
      caa_last->next = caa_curr;
    } else {
      caa_head = caa_curr;
    }
    caa_last = caa_curr;

    caa_curr->critical = ares_dns_rr_get_u8(rr, ARES_RR_CAA_CRITICAL);
    caa_curr->property =
      (unsigned char *)ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_CAA_TAG));
    if (caa_curr->property == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      break;                /* LCOV_EXCL_LINE: OutOfMemory */
    }
    /* RFC6844 says this can only be ascii, so not sure why we're recording a
     * length */
    caa_curr->plength = ares_strlen((const char *)caa_curr->property);

    ptr = ares_dns_rr_get_bin(rr, ARES_RR_CAA_VALUE, &ptr_len);
    if (ptr == NULL) {
      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */
      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    /* Wants NULL termination for some reason */
    caa_curr->value = ares_malloc(ptr_len + 1);
    if (caa_curr->value == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
    memcpy(caa_curr->value, ptr, ptr_len);
    caa_curr->value[ptr_len] = 0;
    caa_curr->length         = ptr_len;
  }

done:
  /* clean up on error */
  if (status != ARES_SUCCESS) {
    if (caa_head) {
      ares_free_data(caa_head);
    }
  } else {
    /* everything looks fine, return the data */
    *caa_out = caa_head;
  }
  ares_dns_record_destroy(dnsrec);
  return (int)status;
}
                                                                                                node-23.7.0/deps/cares/src/lib/legacy/ares_parse_mx_reply.c                                         0000664 0000000 0000000 00000006573 14746647661 0023630 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"
#include "ares_data.h"

int ares_parse_mx_reply(const unsigned char *abuf, int alen_int,
                        struct ares_mx_reply **mx_out)
{
  ares_status_t         status;
  size_t                alen;
  struct ares_mx_reply *mx_head = NULL;
  struct ares_mx_reply *mx_last = NULL;
  struct ares_mx_reply *mx_curr;
  ares_dns_record_t    *dnsrec = NULL;
  size_t                i;

  *mx_out = NULL;

  if (alen_int < 0) {
    return ARES_EBADRESP;
  }

  alen = (size_t)alen_int;

  status = ares_dns_parse(abuf, alen, 0, &dnsrec);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {
    status = ARES_ENODATA;
    goto done;
  }

  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {
    const ares_dns_rr_t *rr =
      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);

    if (rr == NULL) {
      /* Shouldn't be possible */
      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */
      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||
        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_MX) {
      continue;
    }

    /* Allocate storage for this MX answer appending it to the list */
    mx_curr = ares_malloc_data(ARES_DATATYPE_MX_REPLY);
    if (mx_curr == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* Link in the record */
    if (mx_last) {
      mx_last->next = mx_curr;
    } else {
      mx_head = mx_curr;
    }
    mx_last = mx_curr;

    mx_curr->priority = ares_dns_rr_get_u16(rr, ARES_RR_MX_PREFERENCE);
    mx_curr->host = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_MX_EXCHANGE));

    if (mx_curr->host == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

done:
  /* clean up on error */
  if (status != ARES_SUCCESS) {
    if (mx_head) {
      ares_free_data(mx_head);
    }
  } else {
    /* everything looks fine, return the data */
    *mx_out = mx_head;
  }
  ares_dns_record_destroy(dnsrec);
  return (int)status;
}
                                                                                                                                     node-23.7.0/deps/cares/src/lib/legacy/ares_parse_naptr_reply.c                                      0000664 0000000 0000000 00000011021 14746647661 0024310 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_data.h"

int ares_parse_naptr_reply(const unsigned char *abuf, int alen_int,
                           struct ares_naptr_reply **naptr_out)
{
  ares_status_t            status;
  size_t                   alen;
  struct ares_naptr_reply *naptr_head = NULL;
  struct ares_naptr_reply *naptr_last = NULL;
  struct ares_naptr_reply *naptr_curr;
  ares_dns_record_t       *dnsrec = NULL;
  size_t                   i;

  *naptr_out = NULL;

  if (alen_int < 0) {
    return ARES_EBADRESP;
  }

  alen = (size_t)alen_int;

  status = ares_dns_parse(abuf, alen, 0, &dnsrec);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {
    status = ARES_ENODATA;
    goto done;
  }

  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {
    const ares_dns_rr_t *rr =
      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);

    if (rr == NULL) {
      /* Shouldn't be possible */
      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */
      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||
        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_NAPTR) {
      continue;
    }

    /* Allocate storage for this NAPTR answer appending it to the list */
    naptr_curr = ares_malloc_data(ARES_DATATYPE_NAPTR_REPLY);
    if (naptr_curr == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* Link in the record */
    if (naptr_last) {
      naptr_last->next = naptr_curr;
    } else {
      naptr_head = naptr_curr;
    }
    naptr_last = naptr_curr;

    naptr_curr->order      = ares_dns_rr_get_u16(rr, ARES_RR_NAPTR_ORDER);
    naptr_curr->preference = ares_dns_rr_get_u16(rr, ARES_RR_NAPTR_PREFERENCE);

    /* XXX: Why is this unsigned char * ? */
    naptr_curr->flags = (unsigned char *)ares_strdup(
      ares_dns_rr_get_str(rr, ARES_RR_NAPTR_FLAGS));
    if (naptr_curr->flags == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
    /* XXX: Why is this unsigned char * ? */
    naptr_curr->service = (unsigned char *)ares_strdup(
      ares_dns_rr_get_str(rr, ARES_RR_NAPTR_SERVICES));
    if (naptr_curr->service == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
    /* XXX: Why is this unsigned char * ? */
    naptr_curr->regexp = (unsigned char *)ares_strdup(
      ares_dns_rr_get_str(rr, ARES_RR_NAPTR_REGEXP));
    if (naptr_curr->regexp == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
    naptr_curr->replacement =
      ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_NAPTR_REPLACEMENT));
    if (naptr_curr->replacement == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

done:
  /* clean up on error */
  if (status != ARES_SUCCESS) {
    if (naptr_head) {
      ares_free_data(naptr_head);
    }
  } else {
    /* everything looks fine, return the data */
    *naptr_out = naptr_head;
  }
  ares_dns_record_destroy(dnsrec);
  return (int)status;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/cares/src/lib/legacy/ares_parse_ns_reply.c                                         0000664 0000000 0000000 00000011112 14746647661 0023605 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif
#ifdef HAVE_NETDB_H
#  include <netdb.h>
#endif
#ifdef HAVE_ARPA_INET_H
#  include <arpa/inet.h>
#endif

int ares_parse_ns_reply(const unsigned char *abuf, int alen_int,
                        struct hostent **host)
{
  ares_status_t      status;
  size_t             alen;
  size_t             nscount  = 0;
  struct hostent    *hostent  = NULL;
  const char        *hostname = NULL;
  ares_dns_record_t *dnsrec   = NULL;
  size_t             i;
  size_t             ancount;

  *host = NULL;

  if (alen_int < 0) {
    return ARES_EBADRESP;
  }

  alen = (size_t)alen_int;

  status = ares_dns_parse(abuf, alen, 0, &dnsrec);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);
  if (ancount == 0) {
    status = ARES_ENODATA;
    goto done;
  }

  /* Response structure */
  hostent = ares_malloc(sizeof(*hostent));
  if (hostent == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  memset(hostent, 0, sizeof(*hostent));

  hostent->h_addr_list = ares_malloc(sizeof(*hostent->h_addr_list));
  if (hostent->h_addr_list == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }
  hostent->h_addr_list[0] = NULL;
  hostent->h_addrtype     = AF_INET;
  hostent->h_length       = sizeof(struct in_addr);

  /* Fill in hostname */
  status = ares_dns_record_query_get(dnsrec, 0, &hostname, NULL, NULL);
  if (status != ARES_SUCCESS) {
    goto done; /* LCOV_EXCL_LINE: DefensiveCoding */
  }
  hostent->h_name = ares_strdup(hostname);
  if (hostent->h_name == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* Preallocate the maximum number + 1 */
  hostent->h_aliases = ares_malloc((ancount + 1) * sizeof(*hostent->h_aliases));
  if (hostent->h_aliases == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }
  memset(hostent->h_aliases, 0, (ancount + 1) * sizeof(*hostent->h_aliases));

  for (i = 0; i < ancount; i++) {
    const ares_dns_rr_t *rr =
      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);

    if (rr == NULL) {
      /* Shouldn't be possible */
      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */
      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||
        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_NS) {
      continue;
    }

    hostname = ares_dns_rr_get_str(rr, ARES_RR_NS_NSDNAME);
    if (hostname == NULL) {
      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */
      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    hostent->h_aliases[nscount] = ares_strdup(hostname);
    if (hostent->h_aliases[nscount] == NULL) {
      status = ARES_ENOMEM;
      goto done;
    }
    nscount++;
  }

  if (nscount == 0) {
    status = ARES_ENODATA;
  } else {
    status = ARES_SUCCESS;
  }

done:
  if (status != ARES_SUCCESS) {
    ares_free_hostent(hostent);
    /* Compatibility */
    if (status == ARES_EBADNAME) {
      status = ARES_EBADRESP;
    }
  } else {
    *host = hostent;
  }
  ares_dns_record_destroy(dnsrec);
  return (int)status;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/cares/src/lib/legacy/ares_parse_ptr_reply.c                                        0000664 0000000 0000000 00000014302 14746647661 0023776 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif
#ifdef HAVE_NETDB_H
#  include <netdb.h>
#endif


ares_status_t ares_parse_ptr_reply_dnsrec(const ares_dns_record_t *dnsrec,
                                          const void *addr, int addrlen,
                                          int family, struct hostent **host)
{
  ares_status_t   status;
  size_t          ptrcount = 0;
  struct hostent *hostent  = NULL;
  const char     *hostname = NULL;
  const char     *ptrname  = NULL;
  size_t          i;
  size_t          ancount;

  *host = NULL;

  /* Fetch name from query as we will use it to compare later on.  Old code
   * did this check, so we'll retain it. */
  status = ares_dns_record_query_get(dnsrec, 0, &ptrname, NULL, NULL);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  ancount = ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER);
  if (ancount == 0) {
    status = ARES_ENODATA;
    goto done;
  }

  /* Response structure */
  hostent = ares_malloc(sizeof(*hostent));
  if (hostent == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  memset(hostent, 0, sizeof(*hostent));

  hostent->h_addr_list = ares_malloc(2 * sizeof(*hostent->h_addr_list));
  if (hostent->h_addr_list == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }
  memset(hostent->h_addr_list, 0, 2 * sizeof(*hostent->h_addr_list));
  if (addr != NULL && addrlen > 0) {
    hostent->h_addr_list[0] = ares_malloc((size_t)addrlen);
    if (hostent->h_addr_list[0] == NULL) {
      status = ARES_ENOMEM;
      goto done;
    }
    memcpy(hostent->h_addr_list[0], addr, (size_t)addrlen);
  }
  hostent->h_addrtype = (HOSTENT_ADDRTYPE_TYPE)family;
  hostent->h_length   = (HOSTENT_LENGTH_TYPE)addrlen;

  /* Preallocate the maximum number + 1 */
  hostent->h_aliases = ares_malloc((ancount + 1) * sizeof(*hostent->h_aliases));
  if (hostent->h_aliases == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }
  memset(hostent->h_aliases, 0, (ancount + 1) * sizeof(*hostent->h_aliases));


  /* Cycle through answers */
  for (i = 0; i < ancount; i++) {
    const ares_dns_rr_t *rr =
      ares_dns_record_rr_get_const(dnsrec, ARES_SECTION_ANSWER, i);

    if (rr == NULL) {
      /* Shouldn't be possible */
      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */
      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN) {
      continue;
    }

    /* Any time we see a CNAME, replace our ptrname with its value */
    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_CNAME) {
      ptrname = ares_dns_rr_get_str(rr, ARES_RR_CNAME_CNAME);
      if (ptrname == NULL) {
        status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */
        goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */
      }
    }

    /* Handling for PTR records below this, otherwise skip */
    if (ares_dns_rr_get_type(rr) != ARES_REC_TYPE_PTR) {
      continue;
    }

    /* Issue #683
     * Old code compared the name in the rr to the ptrname, but I think this
     * is wrong since it was proven wrong for A & AAAA records.  Leaving
     * this code commented out for future reference
     *
     * rname = ares_dns_rr_get_name(rr);
     * if (rname == NULL) {
     *   status = ARES_EBADRESP;
     *   goto done;
     * }
     * if (!ares_strcaseeq(ptrname, rname)) {
     *   continue;
     * }
     */

    /* Save most recent PTR record as the hostname */
    hostname = ares_dns_rr_get_str(rr, ARES_RR_PTR_DNAME);
    if (hostname == NULL) {
      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */
      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    /* Append as an alias */
    hostent->h_aliases[ptrcount] = ares_strdup(hostname);
    if (hostent->h_aliases[ptrcount] == NULL) {
      status = ARES_ENOMEM;
      goto done;
    }
    ptrcount++;
  }

  if (ptrcount == 0) {
    status = ARES_ENODATA;
    goto done;
  } else {
    status = ARES_SUCCESS;
  }

  /* Fill in hostname */
  hostent->h_name = ares_strdup(hostname);
  if (hostent->h_name == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

done:
  if (status != ARES_SUCCESS) {
    ares_free_hostent(hostent);
    /* Compatibility */
    if (status == ARES_EBADNAME) {
      status = ARES_EBADRESP;
    }
  } else {
    *host = hostent;
  }
  return status;
}

int ares_parse_ptr_reply(const unsigned char *abuf, int alen_int,
                         const void *addr, int addrlen, int family,
                         struct hostent **host)
{
  size_t             alen;
  ares_dns_record_t *dnsrec = NULL;
  ares_status_t      status;

  if (alen_int < 0) {
    return ARES_EBADRESP;
  }

  alen = (size_t)alen_int;

  status = ares_dns_parse(abuf, alen, 0, &dnsrec);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  status = ares_parse_ptr_reply_dnsrec(dnsrec, addr, addrlen, family, host);

done:
  ares_dns_record_destroy(dnsrec);
  if (status == ARES_EBADNAME) {
    status = ARES_EBADRESP;
  }
  return (int)status;
}
                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/cares/src/lib/legacy/ares_parse_soa_reply.c                                        0000664 0000000 0000000 00000007406 14746647661 0023762 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"
#include "ares_data.h"

int ares_parse_soa_reply(const unsigned char *abuf, int alen_int,
                         struct ares_soa_reply **soa_out)
{
  ares_status_t          status;
  size_t                 alen;
  struct ares_soa_reply *soa    = NULL;
  ares_dns_record_t     *dnsrec = NULL;
  size_t                 i;

  *soa_out = NULL;

  if (alen_int < 0) {
    return ARES_EBADRESP;
  }

  alen = (size_t)alen_int;

  status = ares_dns_parse(abuf, alen, 0, &dnsrec);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {
    status = ARES_EBADRESP; /* ENODATA might make more sense */
    goto done;
  }

  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {
    const ares_dns_rr_t *rr =
      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);

    if (rr == NULL) {
      /* Shouldn't be possible */
      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */
      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||
        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_SOA) {
      continue;
    }

    /* allocate result struct */
    soa = ares_malloc_data(ARES_DATATYPE_SOA_REPLY);
    if (soa == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }

    soa->serial  = ares_dns_rr_get_u32(rr, ARES_RR_SOA_SERIAL);
    soa->refresh = ares_dns_rr_get_u32(rr, ARES_RR_SOA_REFRESH);
    soa->retry   = ares_dns_rr_get_u32(rr, ARES_RR_SOA_RETRY);
    soa->expire  = ares_dns_rr_get_u32(rr, ARES_RR_SOA_EXPIRE);
    soa->minttl  = ares_dns_rr_get_u32(rr, ARES_RR_SOA_MINIMUM);
    soa->nsname  = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_SOA_MNAME));
    if (soa->nsname == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
    soa->hostmaster = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_SOA_RNAME));
    if (soa->hostmaster == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
    break;
  }

  if (soa == NULL) {
    status = ARES_EBADRESP;
  }

done:
  /* clean up on error */
  if (status != ARES_SUCCESS) {
    ares_free_data(soa);
    /* Compatibility */
    if (status == ARES_EBADNAME) {
      status = ARES_EBADRESP;
    }
  } else {
    /* everything looks fine, return the data */
    *soa_out = soa;
  }
  ares_dns_record_destroy(dnsrec);
  return (int)status;
}
                                                                                                                                                                                                                                                          node-23.7.0/deps/cares/src/lib/legacy/ares_parse_srv_reply.c                                        0000664 0000000 0000000 00000007047 14746647661 0024013 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"
#include "ares_data.h"

int ares_parse_srv_reply(const unsigned char *abuf, int alen_int,
                         struct ares_srv_reply **srv_out)
{
  ares_status_t          status;
  size_t                 alen;
  struct ares_srv_reply *srv_head = NULL;
  struct ares_srv_reply *srv_last = NULL;
  struct ares_srv_reply *srv_curr;
  ares_dns_record_t     *dnsrec = NULL;
  size_t                 i;

  *srv_out = NULL;

  if (alen_int < 0) {
    return ARES_EBADRESP;
  }

  alen = (size_t)alen_int;

  status = ares_dns_parse(abuf, alen, 0, &dnsrec);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {
    status = ARES_ENODATA;
    goto done;
  }

  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {
    const ares_dns_rr_t *rr =
      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);

    if (rr == NULL) {
      /* Shouldn't be possible */
      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */
      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||
        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_SRV) {
      continue;
    }

    /* Allocate storage for this SRV answer appending it to the list */
    srv_curr = ares_malloc_data(ARES_DATATYPE_SRV_REPLY);
    if (srv_curr == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* Link in the record */
    if (srv_last) {
      srv_last->next = srv_curr;
    } else {
      srv_head = srv_curr;
    }
    srv_last = srv_curr;


    srv_curr->priority = ares_dns_rr_get_u16(rr, ARES_RR_SRV_PRIORITY);
    srv_curr->weight   = ares_dns_rr_get_u16(rr, ARES_RR_SRV_WEIGHT);
    srv_curr->port     = ares_dns_rr_get_u16(rr, ARES_RR_SRV_PORT);

    srv_curr->host = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_SRV_TARGET));

    if (srv_curr->host == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

done:
  /* clean up on error */
  if (status != ARES_SUCCESS) {
    if (srv_head) {
      ares_free_data(srv_head);
    }
  } else {
    /* everything looks fine, return the data */
    *srv_out = srv_head;
  }
  ares_dns_record_destroy(dnsrec);
  return (int)status;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/cares/src/lib/legacy/ares_parse_txt_reply.c                                        0000664 0000000 0000000 00000010656 14746647661 0024020 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"
#include "ares_data.h"

static int ares_parse_txt_reply_int(const unsigned char *abuf, size_t alen,
                                    ares_bool_t ex, void **txt_out)
{
  ares_status_t        status;
  struct ares_txt_ext *txt_head = NULL;
  struct ares_txt_ext *txt_last = NULL;
  struct ares_txt_ext *txt_curr;
  ares_dns_record_t   *dnsrec = NULL;
  size_t               i;

  *txt_out = NULL;

  status = ares_dns_parse(abuf, alen, 0, &dnsrec);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {
    status = ARES_ENODATA;
    goto done;
  }

  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {
    const ares_dns_rr_t *rr =
      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);
    size_t j;
    size_t cnt;


    if (rr == NULL) {
      /* Shouldn't be possible */
      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */
      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    /* XXX: Why Chaos? */
    if ((ares_dns_rr_get_class(rr) != ARES_CLASS_IN &&
         ares_dns_rr_get_class(rr) != ARES_CLASS_CHAOS) ||
        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_TXT) {
      continue;
    }

    cnt = ares_dns_rr_get_abin_cnt(rr, ARES_RR_TXT_DATA);

    for (j = 0; j < cnt; j++) {
      const unsigned char *ptr;
      size_t               ptr_len;

      /* Allocate storage for this TXT answer appending it to the list */
      txt_curr =
        ares_malloc_data(ex ? ARES_DATATYPE_TXT_EXT : ARES_DATATYPE_TXT_REPLY);
      if (txt_curr == NULL) {
        status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
        goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
      }

      /* Link in the record */
      if (txt_last) {
        txt_last->next = txt_curr;
      } else {
        txt_head = txt_curr;
      }
      txt_last = txt_curr;

      /* Tag start on first for each TXT record */
      if (ex && j == 0) {
        txt_curr->record_start = 1;
      }

      ptr = ares_dns_rr_get_abin(rr, ARES_RR_TXT_DATA, j, &ptr_len);

      txt_curr->txt = ares_malloc(ptr_len + 1);
      if (txt_curr->txt == NULL) {
        status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
        goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
      }
      memcpy(txt_curr->txt, ptr, ptr_len);
      txt_curr->txt[ptr_len] = 0;
      txt_curr->length       = ptr_len;
    }
  }

done:
  /* clean up on error */
  if (status != ARES_SUCCESS) {
    if (txt_head) {
      ares_free_data(txt_head);
    }
  } else {
    /* everything looks fine, return the data */
    *txt_out = txt_head;
  }
  ares_dns_record_destroy(dnsrec);
  return (int)status;
}

int ares_parse_txt_reply(const unsigned char *abuf, int alen,
                         struct ares_txt_reply **txt_out)
{
  if (alen < 0) {
    return ARES_EBADRESP;
  }
  return ares_parse_txt_reply_int(abuf, (size_t)alen, ARES_FALSE,
                                  (void **)txt_out);
}

int ares_parse_txt_reply_ext(const unsigned char *abuf, int alen,
                             struct ares_txt_ext **txt_out)
{
  if (alen < 0) {
    return ARES_EBADRESP;
  }
  return ares_parse_txt_reply_int(abuf, (size_t)alen, ARES_TRUE,
                                  (void **)txt_out);
}
                                                                                  node-23.7.0/deps/cares/src/lib/legacy/ares_parse_uri_reply.c                                        0000664 0000000 0000000 00000006703 14746647661 0023776 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"
#include "ares_data.h"

int ares_parse_uri_reply(const unsigned char *abuf, int alen_int,
                         struct ares_uri_reply **uri_out)
{
  ares_status_t          status;
  size_t                 alen;
  struct ares_uri_reply *uri_head = NULL;
  struct ares_uri_reply *uri_last = NULL;
  struct ares_uri_reply *uri_curr;
  ares_dns_record_t     *dnsrec = NULL;
  size_t                 i;

  *uri_out = NULL;

  if (alen_int < 0) {
    return ARES_EBADRESP;
  }

  alen = (size_t)alen_int;

  status = ares_dns_parse(abuf, alen, 0, &dnsrec);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  if (ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER) == 0) {
    status = ARES_ENODATA;
    goto done;
  }

  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER); i++) {
    const ares_dns_rr_t *rr =
      ares_dns_record_rr_get(dnsrec, ARES_SECTION_ANSWER, i);

    if (rr == NULL) {
      /* Shouldn't be possible */
      status = ARES_EBADRESP; /* LCOV_EXCL_LINE: DefensiveCoding */
      goto done;              /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    if (ares_dns_rr_get_class(rr) != ARES_CLASS_IN ||
        ares_dns_rr_get_type(rr) != ARES_REC_TYPE_URI) {
      continue;
    }

    /* Allocate storage for this URI answer appending it to the list */
    uri_curr = ares_malloc_data(ARES_DATATYPE_URI_REPLY);
    if (uri_curr == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* Link in the record */
    if (uri_last) {
      uri_last->next = uri_curr;
    } else {
      uri_head = uri_curr;
    }
    uri_last = uri_curr;


    uri_curr->priority = ares_dns_rr_get_u16(rr, ARES_RR_URI_PRIORITY);
    uri_curr->weight   = ares_dns_rr_get_u16(rr, ARES_RR_URI_WEIGHT);
    uri_curr->uri = ares_strdup(ares_dns_rr_get_str(rr, ARES_RR_URI_TARGET));
    uri_curr->ttl = (int)ares_dns_rr_get_ttl(rr);

    if (uri_curr->uri == NULL) {
      status = ARES_ENOMEM;
      goto done;
    }
  }

done:
  /* clean up on error */
  if (status != ARES_SUCCESS) {
    if (uri_head) {
      ares_free_data(uri_head);
    }
  } else {
    /* everything looks fine, return the data */
    *uri_out = uri_head;
  }
  ares_dns_record_destroy(dnsrec);
  return (int)status;
}
                                                             node-23.7.0/deps/cares/src/lib/record/                                                              0000775 0000000 0000000 00000000000 14746647661 0017420 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/record/ares_dns_mapping.c                                            0000664 0000000 0000000 00000065404 14746647661 0023106 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"

ares_bool_t ares_dns_opcode_isvalid(ares_dns_opcode_t opcode)
{
  switch (opcode) {
    case ARES_OPCODE_QUERY:
    case ARES_OPCODE_IQUERY:
    case ARES_OPCODE_STATUS:
    case ARES_OPCODE_NOTIFY:
    case ARES_OPCODE_UPDATE:
      return ARES_TRUE;
  }
  return ARES_FALSE;
}

ares_bool_t ares_dns_rcode_isvalid(ares_dns_rcode_t rcode)
{
  switch (rcode) {
    case ARES_RCODE_NOERROR:
    case ARES_RCODE_FORMERR:
    case ARES_RCODE_SERVFAIL:
    case ARES_RCODE_NXDOMAIN:
    case ARES_RCODE_NOTIMP:
    case ARES_RCODE_REFUSED:
    case ARES_RCODE_YXDOMAIN:
    case ARES_RCODE_YXRRSET:
    case ARES_RCODE_NXRRSET:
    case ARES_RCODE_NOTAUTH:
    case ARES_RCODE_NOTZONE:
    case ARES_RCODE_DSOTYPEI:
    case ARES_RCODE_BADSIG:
    case ARES_RCODE_BADKEY:
    case ARES_RCODE_BADTIME:
    case ARES_RCODE_BADMODE:
    case ARES_RCODE_BADNAME:
    case ARES_RCODE_BADALG:
    case ARES_RCODE_BADTRUNC:
    case ARES_RCODE_BADCOOKIE:
      return ARES_TRUE;
  }
  return ARES_FALSE;
}

ares_bool_t ares_dns_flags_arevalid(unsigned short flags)
{
  unsigned short allflags = ARES_FLAG_QR | ARES_FLAG_AA | ARES_FLAG_TC |
                            ARES_FLAG_RD | ARES_FLAG_RA | ARES_FLAG_AD |
                            ARES_FLAG_CD;

  if (flags & ~allflags) {
    return ARES_FALSE;
  }

  return ARES_TRUE;
}

ares_bool_t ares_dns_rec_type_isvalid(ares_dns_rec_type_t type,
                                      ares_bool_t         is_query)
{
  switch (type) {
    case ARES_REC_TYPE_A:
    case ARES_REC_TYPE_NS:
    case ARES_REC_TYPE_CNAME:
    case ARES_REC_TYPE_SOA:
    case ARES_REC_TYPE_PTR:
    case ARES_REC_TYPE_HINFO:
    case ARES_REC_TYPE_MX:
    case ARES_REC_TYPE_TXT:
    case ARES_REC_TYPE_SIG:
    case ARES_REC_TYPE_AAAA:
    case ARES_REC_TYPE_SRV:
    case ARES_REC_TYPE_NAPTR:
    case ARES_REC_TYPE_OPT:
    case ARES_REC_TYPE_TLSA:
    case ARES_REC_TYPE_SVCB:
    case ARES_REC_TYPE_HTTPS:
    case ARES_REC_TYPE_ANY:
    case ARES_REC_TYPE_URI:
    case ARES_REC_TYPE_CAA:
      return ARES_TRUE;
    case ARES_REC_TYPE_RAW_RR:
      return is_query ? ARES_FALSE : ARES_TRUE;
    default:
      break;
  }
  return is_query ? ARES_TRUE : ARES_FALSE;
}

ares_bool_t ares_dns_rec_allow_name_comp(ares_dns_rec_type_t type)
{
  /* Only record types defined in RFC1035 allow name compression within the
   * RDATA.  Otherwise nameservers that don't understand an RR may not be
   * able to pass along the RR in a proper manner */
  switch (type) {
    case ARES_REC_TYPE_A:
    case ARES_REC_TYPE_NS:
    case ARES_REC_TYPE_CNAME:
    case ARES_REC_TYPE_SOA:
    case ARES_REC_TYPE_PTR:
    case ARES_REC_TYPE_HINFO:
    case ARES_REC_TYPE_MX:
    case ARES_REC_TYPE_TXT:
      return ARES_TRUE;
    default:
      break;
  }
  return ARES_FALSE;
}

ares_bool_t ares_dns_class_isvalid(ares_dns_class_t    qclass,
                                   ares_dns_rec_type_t type,
                                   ares_bool_t         is_query)
{
  /* If we don't understand the record type, we shouldn't validate the class
   * as there are some instances like on RFC 2391 (SIG RR) the class is
   * meaningless, but since we didn't support that record type, we didn't
   * know it shouldn't be validated */
  if (type == ARES_REC_TYPE_RAW_RR) {
    return ARES_TRUE;
  }

  switch (qclass) {
    case ARES_CLASS_IN:
    case ARES_CLASS_CHAOS:
    case ARES_CLASS_HESOID:
    case ARES_CLASS_NONE:
      return ARES_TRUE;
    case ARES_CLASS_ANY:
      if (type == ARES_REC_TYPE_SIG) {
        return ARES_TRUE;
      }
      if (is_query) {
        return ARES_TRUE;
      }
      return ARES_FALSE;
  }
  return ARES_FALSE;
}

ares_bool_t ares_dns_section_isvalid(ares_dns_section_t sect)
{
  switch (sect) {
    case ARES_SECTION_ANSWER:
    case ARES_SECTION_AUTHORITY:
    case ARES_SECTION_ADDITIONAL:
      return ARES_TRUE;
  }
  return ARES_FALSE;
}

ares_dns_rec_type_t ares_dns_rr_key_to_rec_type(ares_dns_rr_key_t key)
{
  /* NOTE: due to the way we've numerated the keys, we can simply divide by
   *       100 to get the type rather than having to do a huge switch
   *       statement.  That said, we do then validate the type returned is
   *       valid in case something completely bogus is passed in */
  ares_dns_rec_type_t type = key / 100;
  if (!ares_dns_rec_type_isvalid(type, ARES_FALSE)) {
    return 0;
  }
  return type;
}

const char *ares_dns_rec_type_tostr(ares_dns_rec_type_t type)
{
  switch (type) {
    case ARES_REC_TYPE_A:
      return "A";
    case ARES_REC_TYPE_NS:
      return "NS";
    case ARES_REC_TYPE_CNAME:
      return "CNAME";
    case ARES_REC_TYPE_SOA:
      return "SOA";
    case ARES_REC_TYPE_PTR:
      return "PTR";
    case ARES_REC_TYPE_HINFO:
      return "HINFO";
    case ARES_REC_TYPE_MX:
      return "MX";
    case ARES_REC_TYPE_TXT:
      return "TXT";
    case ARES_REC_TYPE_SIG:
      return "SIG";
    case ARES_REC_TYPE_AAAA:
      return "AAAA";
    case ARES_REC_TYPE_SRV:
      return "SRV";
    case ARES_REC_TYPE_NAPTR:
      return "NAPTR";
    case ARES_REC_TYPE_OPT:
      return "OPT";
    case ARES_REC_TYPE_TLSA:
      return "TLSA";
    case ARES_REC_TYPE_SVCB:
      return "SVCB";
    case ARES_REC_TYPE_HTTPS:
      return "HTTPS";
    case ARES_REC_TYPE_ANY:
      return "ANY";
    case ARES_REC_TYPE_URI:
      return "URI";
    case ARES_REC_TYPE_CAA:
      return "CAA";
    case ARES_REC_TYPE_RAW_RR:
      return "RAWRR";
  }
  return "UNKNOWN";
}

const char *ares_dns_class_tostr(ares_dns_class_t qclass)
{
  switch (qclass) {
    case ARES_CLASS_IN:
      return "IN";
    case ARES_CLASS_CHAOS:
      return "CH";
    case ARES_CLASS_HESOID:
      return "HS";
    case ARES_CLASS_ANY:
      return "ANY";
    case ARES_CLASS_NONE:
      return "NONE";
  }
  return "UNKNOWN";
}

const char *ares_dns_opcode_tostr(ares_dns_opcode_t opcode)
{
  switch (opcode) {
    case ARES_OPCODE_QUERY:
      return "QUERY";
    case ARES_OPCODE_IQUERY:
      return "IQUERY";
    case ARES_OPCODE_STATUS:
      return "STATUS";
    case ARES_OPCODE_NOTIFY:
      return "NOTIFY";
    case ARES_OPCODE_UPDATE:
      return "UPDATE";
  }
  return "UNKNOWN";
}

const char *ares_dns_rr_key_tostr(ares_dns_rr_key_t key)
{
  switch (key) {
    case ARES_RR_A_ADDR:
      return "ADDR";

    case ARES_RR_NS_NSDNAME:
      return "NSDNAME";

    case ARES_RR_CNAME_CNAME:
      return "CNAME";

    case ARES_RR_SOA_MNAME:
      return "MNAME";

    case ARES_RR_SOA_RNAME:
      return "RNAME";

    case ARES_RR_SOA_SERIAL:
      return "SERIAL";

    case ARES_RR_SOA_REFRESH:
      return "REFRESH";

    case ARES_RR_SOA_RETRY:
      return "RETRY";

    case ARES_RR_SOA_EXPIRE:
      return "EXPIRE";

    case ARES_RR_SOA_MINIMUM:
      return "MINIMUM";

    case ARES_RR_PTR_DNAME:
      return "DNAME";

    case ARES_RR_AAAA_ADDR:
      return "ADDR";

    case ARES_RR_HINFO_CPU:
      return "CPU";

    case ARES_RR_HINFO_OS:
      return "OS";

    case ARES_RR_MX_PREFERENCE:
      return "PREFERENCE";

    case ARES_RR_MX_EXCHANGE:
      return "EXCHANGE";

    case ARES_RR_TXT_DATA:
      return "DATA";

    case ARES_RR_SIG_TYPE_COVERED:
      return "TYPE_COVERED";

    case ARES_RR_SIG_ALGORITHM:
      return "ALGORITHM";

    case ARES_RR_SIG_LABELS:
      return "LABELS";

    case ARES_RR_SIG_ORIGINAL_TTL:
      return "ORIGINAL_TTL";

    case ARES_RR_SIG_EXPIRATION:
      return "EXPIRATION";

    case ARES_RR_SIG_INCEPTION:
      return "INCEPTION";

    case ARES_RR_SIG_KEY_TAG:
      return "KEY_TAG";

    case ARES_RR_SIG_SIGNERS_NAME:
      return "SIGNERS_NAME";

    case ARES_RR_SIG_SIGNATURE:
      return "SIGNATURE";

    case ARES_RR_SRV_PRIORITY:
      return "PRIORITY";

    case ARES_RR_SRV_WEIGHT:
      return "WEIGHT";

    case ARES_RR_SRV_PORT:
      return "PORT";

    case ARES_RR_SRV_TARGET:
      return "TARGET";

    case ARES_RR_NAPTR_ORDER:
      return "ORDER";

    case ARES_RR_NAPTR_PREFERENCE:
      return "PREFERENCE";

    case ARES_RR_NAPTR_FLAGS:
      return "FLAGS";

    case ARES_RR_NAPTR_SERVICES:
      return "SERVICES";

    case ARES_RR_NAPTR_REGEXP:
      return "REGEXP";

    case ARES_RR_NAPTR_REPLACEMENT:
      return "REPLACEMENT";

    case ARES_RR_OPT_UDP_SIZE:
      return "UDP_SIZE";

    case ARES_RR_OPT_VERSION:
      return "VERSION";

    case ARES_RR_OPT_FLAGS:
      return "FLAGS";

    case ARES_RR_OPT_OPTIONS:
      return "OPTIONS";

    case ARES_RR_TLSA_CERT_USAGE:
      return "CERT_USAGE";

    case ARES_RR_TLSA_SELECTOR:
      return "SELECTOR";

    case ARES_RR_TLSA_MATCH:
      return "MATCH";

    case ARES_RR_TLSA_DATA:
      return "DATA";

    case ARES_RR_SVCB_PRIORITY:
      return "PRIORITY";

    case ARES_RR_SVCB_TARGET:
      return "TARGET";

    case ARES_RR_SVCB_PARAMS:
      return "PARAMS";

    case ARES_RR_HTTPS_PRIORITY:
      return "PRIORITY";

    case ARES_RR_HTTPS_TARGET:
      return "TARGET";

    case ARES_RR_HTTPS_PARAMS:
      return "PARAMS";

    case ARES_RR_URI_PRIORITY:
      return "PRIORITY";

    case ARES_RR_URI_WEIGHT:
      return "WEIGHT";

    case ARES_RR_URI_TARGET:
      return "TARGET";

    case ARES_RR_CAA_CRITICAL:
      return "CRITICAL";

    case ARES_RR_CAA_TAG:
      return "TAG";

    case ARES_RR_CAA_VALUE:
      return "VALUE";

    case ARES_RR_RAW_RR_TYPE:
      return "TYPE";

    case ARES_RR_RAW_RR_DATA:
      return "DATA";
  }

  return "UNKNOWN";
}

ares_dns_datatype_t ares_dns_rr_key_datatype(ares_dns_rr_key_t key)
{
  switch (key) {
    case ARES_RR_A_ADDR:
      return ARES_DATATYPE_INADDR;

    case ARES_RR_AAAA_ADDR:
      return ARES_DATATYPE_INADDR6;

    case ARES_RR_NS_NSDNAME:
    case ARES_RR_CNAME_CNAME:
    case ARES_RR_SOA_MNAME:
    case ARES_RR_SOA_RNAME:
    case ARES_RR_PTR_DNAME:
    case ARES_RR_MX_EXCHANGE:
    case ARES_RR_SIG_SIGNERS_NAME:
    case ARES_RR_SRV_TARGET:
    case ARES_RR_SVCB_TARGET:
    case ARES_RR_HTTPS_TARGET:
    case ARES_RR_NAPTR_REPLACEMENT:
    case ARES_RR_URI_TARGET:
      return ARES_DATATYPE_NAME;

    case ARES_RR_HINFO_CPU:
    case ARES_RR_HINFO_OS:
    case ARES_RR_NAPTR_FLAGS:
    case ARES_RR_NAPTR_SERVICES:
    case ARES_RR_NAPTR_REGEXP:
    case ARES_RR_CAA_TAG:
      return ARES_DATATYPE_STR;

    case ARES_RR_SOA_SERIAL:
    case ARES_RR_SOA_REFRESH:
    case ARES_RR_SOA_RETRY:
    case ARES_RR_SOA_EXPIRE:
    case ARES_RR_SOA_MINIMUM:
    case ARES_RR_SIG_ORIGINAL_TTL:
    case ARES_RR_SIG_EXPIRATION:
    case ARES_RR_SIG_INCEPTION:
      return ARES_DATATYPE_U32;

    case ARES_RR_MX_PREFERENCE:
    case ARES_RR_SIG_TYPE_COVERED:
    case ARES_RR_SIG_KEY_TAG:
    case ARES_RR_SRV_PRIORITY:
    case ARES_RR_SRV_WEIGHT:
    case ARES_RR_SRV_PORT:
    case ARES_RR_NAPTR_ORDER:
    case ARES_RR_NAPTR_PREFERENCE:
    case ARES_RR_OPT_UDP_SIZE:
    case ARES_RR_OPT_FLAGS:
    case ARES_RR_SVCB_PRIORITY:
    case ARES_RR_HTTPS_PRIORITY:
    case ARES_RR_URI_PRIORITY:
    case ARES_RR_URI_WEIGHT:
    case ARES_RR_RAW_RR_TYPE:
      return ARES_DATATYPE_U16;

    case ARES_RR_SIG_ALGORITHM:
    case ARES_RR_SIG_LABELS:
    case ARES_RR_OPT_VERSION:
    case ARES_RR_TLSA_CERT_USAGE:
    case ARES_RR_TLSA_SELECTOR:
    case ARES_RR_TLSA_MATCH:
    case ARES_RR_CAA_CRITICAL:
      return ARES_DATATYPE_U8;

    case ARES_RR_CAA_VALUE:
      return ARES_DATATYPE_BINP;

    case ARES_RR_TXT_DATA:
      return ARES_DATATYPE_ABINP;

    case ARES_RR_SIG_SIGNATURE:
    case ARES_RR_TLSA_DATA:
    case ARES_RR_RAW_RR_DATA:
      return ARES_DATATYPE_BIN;

    case ARES_RR_OPT_OPTIONS:
    case ARES_RR_SVCB_PARAMS:
    case ARES_RR_HTTPS_PARAMS:
      return ARES_DATATYPE_OPT;
  }

  return 0;
}

static const ares_dns_rr_key_t rr_a_keys[]     = { ARES_RR_A_ADDR };
static const ares_dns_rr_key_t rr_ns_keys[]    = { ARES_RR_NS_NSDNAME };
static const ares_dns_rr_key_t rr_cname_keys[] = { ARES_RR_CNAME_CNAME };
static const ares_dns_rr_key_t rr_soa_keys[]   = {
  ARES_RR_SOA_MNAME,   ARES_RR_SOA_RNAME, ARES_RR_SOA_SERIAL,
  ARES_RR_SOA_REFRESH, ARES_RR_SOA_RETRY, ARES_RR_SOA_EXPIRE,
  ARES_RR_SOA_MINIMUM
};
static const ares_dns_rr_key_t rr_ptr_keys[]   = { ARES_RR_PTR_DNAME };
static const ares_dns_rr_key_t rr_hinfo_keys[] = { ARES_RR_HINFO_CPU,
                                                   ARES_RR_HINFO_OS };
static const ares_dns_rr_key_t rr_mx_keys[]    = { ARES_RR_MX_PREFERENCE,
                                                   ARES_RR_MX_EXCHANGE };
static const ares_dns_rr_key_t rr_sig_keys[]   = {
  ARES_RR_SIG_TYPE_COVERED, ARES_RR_SIG_ALGORITHM,    ARES_RR_SIG_LABELS,
  ARES_RR_SIG_ORIGINAL_TTL, ARES_RR_SIG_EXPIRATION,   ARES_RR_SIG_INCEPTION,
  ARES_RR_SIG_KEY_TAG,      ARES_RR_SIG_SIGNERS_NAME, ARES_RR_SIG_SIGNATURE
};
static const ares_dns_rr_key_t rr_txt_keys[]  = { ARES_RR_TXT_DATA };
static const ares_dns_rr_key_t rr_aaaa_keys[] = { ARES_RR_AAAA_ADDR };
static const ares_dns_rr_key_t rr_srv_keys[]  = {
  ARES_RR_SRV_PRIORITY, ARES_RR_SRV_WEIGHT, ARES_RR_SRV_PORT, ARES_RR_SRV_TARGET
};
static const ares_dns_rr_key_t rr_naptr_keys[] = {
  ARES_RR_NAPTR_ORDER,    ARES_RR_NAPTR_PREFERENCE, ARES_RR_NAPTR_FLAGS,
  ARES_RR_NAPTR_SERVICES, ARES_RR_NAPTR_REGEXP,     ARES_RR_NAPTR_REPLACEMENT
};
static const ares_dns_rr_key_t rr_opt_keys[]    = { ARES_RR_OPT_UDP_SIZE,
                                                    ARES_RR_OPT_VERSION,
                                                    ARES_RR_OPT_FLAGS,
                                                    ARES_RR_OPT_OPTIONS };
static const ares_dns_rr_key_t rr_tlsa_keys[]   = { ARES_RR_TLSA_CERT_USAGE,
                                                    ARES_RR_TLSA_SELECTOR,
                                                    ARES_RR_TLSA_MATCH,
                                                    ARES_RR_TLSA_DATA };
static const ares_dns_rr_key_t rr_svcb_keys[]   = { ARES_RR_SVCB_PRIORITY,
                                                    ARES_RR_SVCB_TARGET,
                                                    ARES_RR_SVCB_PARAMS };
static const ares_dns_rr_key_t rr_https_keys[]  = { ARES_RR_HTTPS_PRIORITY,
                                                    ARES_RR_HTTPS_TARGET,
                                                    ARES_RR_HTTPS_PARAMS };
static const ares_dns_rr_key_t rr_uri_keys[]    = { ARES_RR_URI_PRIORITY,
                                                    ARES_RR_URI_WEIGHT,
                                                    ARES_RR_URI_TARGET };
static const ares_dns_rr_key_t rr_caa_keys[]    = { ARES_RR_CAA_CRITICAL,
                                                    ARES_RR_CAA_TAG,
                                                    ARES_RR_CAA_VALUE };
static const ares_dns_rr_key_t rr_raw_rr_keys[] = { ARES_RR_RAW_RR_TYPE,
                                                    ARES_RR_RAW_RR_DATA };

const ares_dns_rr_key_t       *ares_dns_rr_get_keys(ares_dns_rec_type_t type,
                                                    size_t             *cnt)
{
  if (cnt == NULL) {
    return NULL;
  }

  *cnt = 0;

  switch (type) {
    case ARES_REC_TYPE_A:
      *cnt = sizeof(rr_a_keys) / sizeof(*rr_a_keys);
      return rr_a_keys;
    case ARES_REC_TYPE_NS:
      *cnt = sizeof(rr_ns_keys) / sizeof(*rr_ns_keys);
      return rr_ns_keys;
    case ARES_REC_TYPE_CNAME:
      *cnt = sizeof(rr_cname_keys) / sizeof(*rr_cname_keys);
      return rr_cname_keys;
    case ARES_REC_TYPE_SOA:
      *cnt = sizeof(rr_soa_keys) / sizeof(*rr_soa_keys);
      return rr_soa_keys;
    case ARES_REC_TYPE_PTR:
      *cnt = sizeof(rr_ptr_keys) / sizeof(*rr_ptr_keys);
      return rr_ptr_keys;
    case ARES_REC_TYPE_HINFO:
      *cnt = sizeof(rr_hinfo_keys) / sizeof(*rr_hinfo_keys);
      return rr_hinfo_keys;
    case ARES_REC_TYPE_MX:
      *cnt = sizeof(rr_mx_keys) / sizeof(*rr_mx_keys);
      return rr_mx_keys;
    case ARES_REC_TYPE_TXT:
      *cnt = sizeof(rr_txt_keys) / sizeof(*rr_txt_keys);
      return rr_txt_keys;
    case ARES_REC_TYPE_SIG:
      *cnt = sizeof(rr_sig_keys) / sizeof(*rr_sig_keys);
      return rr_sig_keys;
    case ARES_REC_TYPE_AAAA:
      *cnt = sizeof(rr_aaaa_keys) / sizeof(*rr_aaaa_keys);
      return rr_aaaa_keys;
    case ARES_REC_TYPE_SRV:
      *cnt = sizeof(rr_srv_keys) / sizeof(*rr_srv_keys);
      return rr_srv_keys;
    case ARES_REC_TYPE_NAPTR:
      *cnt = sizeof(rr_naptr_keys) / sizeof(*rr_naptr_keys);
      return rr_naptr_keys;
    case ARES_REC_TYPE_OPT:
      *cnt = sizeof(rr_opt_keys) / sizeof(*rr_opt_keys);
      return rr_opt_keys;
    case ARES_REC_TYPE_TLSA:
      *cnt = sizeof(rr_tlsa_keys) / sizeof(*rr_tlsa_keys);
      return rr_tlsa_keys;
    case ARES_REC_TYPE_SVCB:
      *cnt = sizeof(rr_svcb_keys) / sizeof(*rr_svcb_keys);
      return rr_svcb_keys;
    case ARES_REC_TYPE_HTTPS:
      *cnt = sizeof(rr_https_keys) / sizeof(*rr_https_keys);
      return rr_https_keys;
    case ARES_REC_TYPE_ANY:
      /* Not real */
      break;
    case ARES_REC_TYPE_URI:
      *cnt = sizeof(rr_uri_keys) / sizeof(*rr_uri_keys);
      return rr_uri_keys;
    case ARES_REC_TYPE_CAA:
      *cnt = sizeof(rr_caa_keys) / sizeof(*rr_caa_keys);
      return rr_caa_keys;
    case ARES_REC_TYPE_RAW_RR:
      *cnt = sizeof(rr_raw_rr_keys) / sizeof(*rr_raw_rr_keys);
      return rr_raw_rr_keys;
  }

  return NULL;
}

ares_bool_t ares_dns_class_fromstr(ares_dns_class_t *qclass, const char *str)
{
  size_t i;

  static const struct {
    const char      *name;
    ares_dns_class_t qclass;
  } list[] = {
    { "IN",   ARES_CLASS_IN     },
    { "CH",   ARES_CLASS_CHAOS  },
    { "HS",   ARES_CLASS_HESOID },
    { "NONE", ARES_CLASS_NONE   },
    { "ANY",  ARES_CLASS_ANY    },
    { NULL,   0                 }
  };

  if (qclass == NULL || str == NULL) {
    return ARES_FALSE;
  }

  for (i = 0; list[i].name != NULL; i++) {
    if (ares_strcaseeq(list[i].name, str)) {
      *qclass = list[i].qclass;
      return ARES_TRUE;
    }
  }
  return ARES_FALSE;
}

ares_bool_t ares_dns_rec_type_fromstr(ares_dns_rec_type_t *qtype,
                                      const char          *str)
{
  size_t i;

  static const struct {
    const char         *name;
    ares_dns_rec_type_t type;
  } list[] = {
    { "A",      ARES_REC_TYPE_A      },
    { "NS",     ARES_REC_TYPE_NS     },
    { "CNAME",  ARES_REC_TYPE_CNAME  },
    { "SOA",    ARES_REC_TYPE_SOA    },
    { "PTR",    ARES_REC_TYPE_PTR    },
    { "HINFO",  ARES_REC_TYPE_HINFO  },
    { "MX",     ARES_REC_TYPE_MX     },
    { "TXT",    ARES_REC_TYPE_TXT    },
    { "SIG",    ARES_REC_TYPE_SIG    },
    { "AAAA",   ARES_REC_TYPE_AAAA   },
    { "SRV",    ARES_REC_TYPE_SRV    },
    { "NAPTR",  ARES_REC_TYPE_NAPTR  },
    { "OPT",    ARES_REC_TYPE_OPT    },
    { "TLSA",   ARES_REC_TYPE_TLSA   },
    { "SVCB",   ARES_REC_TYPE_SVCB   },
    { "HTTPS",  ARES_REC_TYPE_HTTPS  },
    { "ANY",    ARES_REC_TYPE_ANY    },
    { "URI",    ARES_REC_TYPE_URI    },
    { "CAA",    ARES_REC_TYPE_CAA    },
    { "RAW_RR", ARES_REC_TYPE_RAW_RR },
    { NULL,     0                    }
  };

  if (qtype == NULL || str == NULL) {
    return ARES_FALSE;
  }

  for (i = 0; list[i].name != NULL; i++) {
    if (ares_strcaseeq(list[i].name, str)) {
      *qtype = list[i].type;
      return ARES_TRUE;
    }
  }
  return ARES_FALSE;
}

const char *ares_dns_section_tostr(ares_dns_section_t section)
{
  switch (section) {
    case ARES_SECTION_ANSWER:
      return "ANSWER";
    case ARES_SECTION_AUTHORITY:
      return "AUTHORITY";
    case ARES_SECTION_ADDITIONAL:
      return "ADDITIONAL";
  }
  return "UNKNOWN";
}

static ares_dns_opt_datatype_t ares_dns_opt_get_type_opt(unsigned short opt)
{
  ares_opt_param_t param = (ares_opt_param_t)opt;
  switch (param) {
    case ARES_OPT_PARAM_LLQ:
      /* Really it is u16 version, u16 opcode, u16 error, u64 id, u32 lease */
      return ARES_OPT_DATATYPE_BIN;
    case ARES_OPT_PARAM_UL:
      return ARES_OPT_DATATYPE_U32;
    case ARES_OPT_PARAM_NSID:
      return ARES_OPT_DATATYPE_BIN;
    case ARES_OPT_PARAM_DAU:
      return ARES_OPT_DATATYPE_U8_LIST;
    case ARES_OPT_PARAM_DHU:
      return ARES_OPT_DATATYPE_U8_LIST;
    case ARES_OPT_PARAM_N3U:
      return ARES_OPT_DATATYPE_U8_LIST;
    case ARES_OPT_PARAM_EDNS_CLIENT_SUBNET:
      /* Really it is a u16 address family, u8 source prefix length,
       * u8 scope prefix length, address */
      return ARES_OPT_DATATYPE_BIN;
    case ARES_OPT_PARAM_EDNS_EXPIRE:
      return ARES_OPT_DATATYPE_U32;
    case ARES_OPT_PARAM_COOKIE:
      /* 8 bytes for client, 16-40 bytes for server */
      return ARES_OPT_DATATYPE_BIN;
    case ARES_OPT_PARAM_EDNS_TCP_KEEPALIVE:
      /* Timeout in 100ms intervals */
      return ARES_OPT_DATATYPE_U16;
    case ARES_OPT_PARAM_PADDING:
      /* Arbitrary padding */
      return ARES_OPT_DATATYPE_BIN;
    case ARES_OPT_PARAM_CHAIN:
      return ARES_OPT_DATATYPE_NAME;
    case ARES_OPT_PARAM_EDNS_KEY_TAG:
      return ARES_OPT_DATATYPE_U16_LIST;
    case ARES_OPT_PARAM_EXTENDED_DNS_ERROR:
      /* Really 16bit code followed by textual message */
      return ARES_OPT_DATATYPE_BIN;
  }
  return ARES_OPT_DATATYPE_BIN;
}

static ares_dns_opt_datatype_t ares_dns_opt_get_type_svcb(unsigned short opt)
{
  ares_svcb_param_t param = (ares_svcb_param_t)opt;
  switch (param) {
    case ARES_SVCB_PARAM_NO_DEFAULT_ALPN:
      return ARES_OPT_DATATYPE_NONE;
    case ARES_SVCB_PARAM_ECH:
      return ARES_OPT_DATATYPE_BIN;
    case ARES_SVCB_PARAM_MANDATORY:
      return ARES_OPT_DATATYPE_U16_LIST;
    case ARES_SVCB_PARAM_ALPN:
      return ARES_OPT_DATATYPE_STR_LIST;
    case ARES_SVCB_PARAM_PORT:
      return ARES_OPT_DATATYPE_U16;
    case ARES_SVCB_PARAM_IPV4HINT:
      return ARES_OPT_DATATYPE_INADDR4_LIST;
    case ARES_SVCB_PARAM_IPV6HINT:
      return ARES_OPT_DATATYPE_INADDR6_LIST;
  }
  return ARES_OPT_DATATYPE_BIN;
}

ares_dns_opt_datatype_t ares_dns_opt_get_datatype(ares_dns_rr_key_t key,
                                                  unsigned short    opt)
{
  switch (key) {
    case ARES_RR_OPT_OPTIONS:
      return ares_dns_opt_get_type_opt(opt);
    case ARES_RR_SVCB_PARAMS:
    case ARES_RR_HTTPS_PARAMS:
      return ares_dns_opt_get_type_svcb(opt);
    default:
      break;
  }
  return ARES_OPT_DATATYPE_BIN;
}

static const char *ares_dns_opt_get_name_opt(unsigned short opt)
{
  ares_opt_param_t param = (ares_opt_param_t)opt;
  switch (param) {
    case ARES_OPT_PARAM_LLQ:
      return "LLQ";
    case ARES_OPT_PARAM_UL:
      return "UL";
    case ARES_OPT_PARAM_NSID:
      return "NSID";
    case ARES_OPT_PARAM_DAU:
      return "DAU";
    case ARES_OPT_PARAM_DHU:
      return "DHU";
    case ARES_OPT_PARAM_N3U:
      return "N3U";
    case ARES_OPT_PARAM_EDNS_CLIENT_SUBNET:
      return "edns-client-subnet";
    case ARES_OPT_PARAM_EDNS_EXPIRE:
      return "edns-expire";
    case ARES_OPT_PARAM_COOKIE:
      return "COOKIE";
    case ARES_OPT_PARAM_EDNS_TCP_KEEPALIVE:
      return "edns-tcp-keepalive";
    case ARES_OPT_PARAM_PADDING:
      return "Padding";
    case ARES_OPT_PARAM_CHAIN:
      return "CHAIN";
    case ARES_OPT_PARAM_EDNS_KEY_TAG:
      return "edns-key-tag";
    case ARES_OPT_PARAM_EXTENDED_DNS_ERROR:
      return "extended-dns-error";
  }
  return NULL;
}

static const char *ares_dns_opt_get_name_svcb(unsigned short opt)
{
  ares_svcb_param_t param = (ares_svcb_param_t)opt;
  switch (param) {
    case ARES_SVCB_PARAM_NO_DEFAULT_ALPN:
      return "no-default-alpn";
    case ARES_SVCB_PARAM_ECH:
      return "ech";
    case ARES_SVCB_PARAM_MANDATORY:
      return "mandatory";
    case ARES_SVCB_PARAM_ALPN:
      return "alpn";
    case ARES_SVCB_PARAM_PORT:
      return "port";
    case ARES_SVCB_PARAM_IPV4HINT:
      return "ipv4hint";
    case ARES_SVCB_PARAM_IPV6HINT:
      return "ipv6hint";
  }
  return NULL;
}

const char *ares_dns_opt_get_name(ares_dns_rr_key_t key, unsigned short opt)
{
  switch (key) {
    case ARES_RR_OPT_OPTIONS:
      return ares_dns_opt_get_name_opt(opt);
    case ARES_RR_SVCB_PARAMS:
    case ARES_RR_HTTPS_PARAMS:
      return ares_dns_opt_get_name_svcb(opt);
    default:
      break;
  }
  return NULL;
}

const char *ares_dns_rcode_tostr(ares_dns_rcode_t rcode)
{
  switch (rcode) {
    case ARES_RCODE_NOERROR:
      return "NOERROR";
    case ARES_RCODE_FORMERR:
      return "FORMERR";
    case ARES_RCODE_SERVFAIL:
      return "SERVFAIL";
    case ARES_RCODE_NXDOMAIN:
      return "NXDOMAIN";
    case ARES_RCODE_NOTIMP:
      return "NOTIMP";
    case ARES_RCODE_REFUSED:
      return "REFUSED";
    case ARES_RCODE_YXDOMAIN:
      return "YXDOMAIN";
    case ARES_RCODE_YXRRSET:
      return "YXRRSET";
    case ARES_RCODE_NXRRSET:
      return "NXRRSET";
    case ARES_RCODE_NOTAUTH:
      return "NOTAUTH";
    case ARES_RCODE_NOTZONE:
      return "NOTZONE";
    case ARES_RCODE_DSOTYPEI:
      return "DSOTYPEI";
    case ARES_RCODE_BADSIG:
      return "BADSIG";
    case ARES_RCODE_BADKEY:
      return "BADKEY";
    case ARES_RCODE_BADTIME:
      return "BADTIME";
    case ARES_RCODE_BADMODE:
      return "BADMODE";
    case ARES_RCODE_BADNAME:
      return "BADNAME";
    case ARES_RCODE_BADALG:
      return "BADALG";
    case ARES_RCODE_BADTRUNC:
      return "BADTRUNC";
    case ARES_RCODE_BADCOOKIE:
      return "BADCOOKIE";
  }

  return "UNKNOWN";
}

/* Convert an rcode and ancount from a query reply into an ares_status_t
 * value. Used internally by ares_search() and ares_query().
 */
ares_status_t ares_dns_query_reply_tostatus(ares_dns_rcode_t rcode,
                                            size_t           ancount)
{
  ares_status_t status = ARES_SUCCESS;

  switch (rcode) {
    case ARES_RCODE_NOERROR:
      status = (ancount > 0) ? ARES_SUCCESS : ARES_ENODATA;
      break;
    case ARES_RCODE_FORMERR:
      status = ARES_EFORMERR;
      break;
    case ARES_RCODE_SERVFAIL:
      status = ARES_ESERVFAIL;
      break;
    case ARES_RCODE_NXDOMAIN:
      status = ARES_ENOTFOUND;
      break;
    case ARES_RCODE_NOTIMP:
      status = ARES_ENOTIMP;
      break;
    case ARES_RCODE_REFUSED:
      status = ARES_EREFUSED;
      break;
    default:
      break;
  }

  return status;
}
                                                                                                                                                                                                                                                            node-23.7.0/deps/cares/src/lib/record/ares_dns_multistring.c                                        0000664 0000000 0000000 00000017221 14746647661 0024026 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_dns_private.h"

typedef struct {
  unsigned char *data;
  size_t         len;
} multistring_data_t;

struct ares_dns_multistring {
  /*! whether or not cached concatenated string is valid */
  ares_bool_t    cache_invalidated;
  /*! combined/concatenated string cache */
  unsigned char *cache_str;
  /*! length of combined/concatenated string */
  size_t         cache_str_len;
  /*! Data making up strings */
  ares_array_t  *strs; /*!< multistring_data_t type */
};

static void ares_dns_multistring_free_cb(void *arg)
{
  multistring_data_t *data = arg;
  if (data == NULL) {
    return;
  }
  ares_free(data->data);
}

ares_dns_multistring_t *ares_dns_multistring_create(void)
{
  ares_dns_multistring_t *strs = ares_malloc_zero(sizeof(*strs));
  if (strs == NULL) {
    return NULL;
  }

  strs->strs =
    ares_array_create(sizeof(multistring_data_t), ares_dns_multistring_free_cb);
  if (strs->strs == NULL) {
    ares_free(strs);
    return NULL;
  }

  return strs;
}

void ares_dns_multistring_clear(ares_dns_multistring_t *strs)
{
  if (strs == NULL) {
    return;
  }

  while (ares_array_len(strs->strs)) {
    ares_array_remove_last(strs->strs);
  }
}

void ares_dns_multistring_destroy(ares_dns_multistring_t *strs)
{
  if (strs == NULL) {
    return;
  }
  ares_dns_multistring_clear(strs);
  ares_array_destroy(strs->strs);
  ares_free(strs->cache_str);
  ares_free(strs);
}

ares_status_t ares_dns_multistring_swap_own(ares_dns_multistring_t *strs,
                                            size_t idx, unsigned char *str,
                                            size_t len)
{
  multistring_data_t *data;

  if (strs == NULL || str == NULL || len == 0) {
    return ARES_EFORMERR;
  }

  strs->cache_invalidated = ARES_TRUE;

  data = ares_array_at(strs->strs, idx);
  if (data == NULL) {
    return ARES_EFORMERR;
  }

  ares_free(data->data);
  data->data = str;
  data->len  = len;
  return ARES_SUCCESS;
}

ares_status_t ares_dns_multistring_del(ares_dns_multistring_t *strs, size_t idx)
{
  if (strs == NULL) {
    return ARES_EFORMERR;
  }

  strs->cache_invalidated = ARES_TRUE;

  return ares_array_remove_at(strs->strs, idx);
}

ares_status_t ares_dns_multistring_add_own(ares_dns_multistring_t *strs,
                                           unsigned char *str, size_t len)
{
  multistring_data_t *data;
  ares_status_t       status;

  if (strs == NULL) {
    return ARES_EFORMERR;
  }

  strs->cache_invalidated = ARES_TRUE;

  /* NOTE: its ok to have an empty string added */
  if (str == NULL && len != 0) {
    return ARES_EFORMERR;
  }

  status = ares_array_insert_last((void **)&data, strs->strs);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Issue #921, ares_dns_multistring_get() doesn't have a way to indicate
   * success or fail on a zero-length string which is actually valid.  So we
   * are going to allocate a 1-byte buffer to use as a placeholder in this
   * case */
  if (str == NULL) {
    str = ares_malloc_zero(1);
    if (str == NULL) {
      ares_array_remove_last(strs->strs);
      return ARES_ENOMEM;
    }
  }

  data->data = str;
  data->len  = len;

  return ARES_SUCCESS;
}

size_t ares_dns_multistring_cnt(const ares_dns_multistring_t *strs)
{
  if (strs == NULL) {
    return 0;
  }
  return ares_array_len(strs->strs);
}

const unsigned char *
  ares_dns_multistring_get(const ares_dns_multistring_t *strs, size_t idx,
                           size_t *len)
{
  const multistring_data_t *data;

  if (strs == NULL || len == NULL) {
    return NULL;
  }

  data = ares_array_at_const(strs->strs, idx);
  if (data == NULL) {
    return NULL;
  }

  *len = data->len;
  return data->data;
}

const unsigned char *ares_dns_multistring_combined(ares_dns_multistring_t *strs,
                                                   size_t                 *len)
{
  ares_buf_t *buf = NULL;
  size_t      i;

  if (strs == NULL || len == NULL) {
    return NULL;
  }

  *len = 0;

  /* Return cache if possible */
  if (!strs->cache_invalidated) {
    *len = strs->cache_str_len;
    return strs->cache_str;
  }

  /* Clear cache */
  ares_free(strs->cache_str);
  strs->cache_str     = NULL;
  strs->cache_str_len = 0;

  buf = ares_buf_create();

  for (i = 0; i < ares_array_len(strs->strs); i++) {
    const multistring_data_t *data = ares_array_at_const(strs->strs, i);
    if (data == NULL ||
        ares_buf_append(buf, data->data, data->len) != ARES_SUCCESS) {
      ares_buf_destroy(buf);
      return NULL;
    }
  }

  strs->cache_str =
    (unsigned char *)ares_buf_finish_str(buf, &strs->cache_str_len);
  if (strs->cache_str != NULL) {
    strs->cache_invalidated = ARES_FALSE;
  }
  *len = strs->cache_str_len;
  return strs->cache_str;
}

ares_status_t ares_dns_multistring_parse_buf(ares_buf_t *buf,
                                             size_t      remaining_len,
                                             ares_dns_multistring_t **strs,
                                             ares_bool_t validate_printable)
{
  unsigned char len;
  ares_status_t status   = ARES_EBADRESP;
  size_t        orig_len = ares_buf_len(buf);

  if (buf == NULL) {
    return ARES_EFORMERR;
  }

  if (remaining_len == 0) {
    return ARES_EBADRESP;
  }

  if (strs != NULL) {
    *strs = ares_dns_multistring_create();
    if (*strs == NULL) {
      return ARES_ENOMEM;
    }
  }

  while (orig_len - ares_buf_len(buf) < remaining_len) {
    status = ares_buf_fetch_bytes(buf, &len, 1);
    if (status != ARES_SUCCESS) {
      break; /* LCOV_EXCL_LINE: DefensiveCoding */
    }


    /* When used by the _str() parser, it really needs to be validated to
     * be a valid printable ascii string.  Do that here */
    if (len && validate_printable && ares_buf_len(buf) >= len) {
      size_t      mylen;
      const char *data = (const char *)ares_buf_peek(buf, &mylen);
      if (!ares_str_isprint(data, len)) {
        status = ARES_EBADSTR;
        break;
      }
    }

    if (strs != NULL) {
      unsigned char *data = NULL;
      if (len) {
        status = ares_buf_fetch_bytes_dup(buf, len, ARES_TRUE, &data);
        if (status != ARES_SUCCESS) {
          break;
        }
      }
      status = ares_dns_multistring_add_own(*strs, data, len);
      if (status != ARES_SUCCESS) {
        ares_free(data);
        break;
      }
    } else {
      status = ares_buf_consume(buf, len);
      if (status != ARES_SUCCESS) {
        break;
      }
    }

  }

  if (status != ARES_SUCCESS && strs != NULL) {
    ares_dns_multistring_destroy(*strs);
    *strs = NULL;
  }

  return status;
}
                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/cares/src/lib/record/ares_dns_multistring.h                                        0000664 0000000 0000000 00000007126 14746647661 0024036 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES_DNS_MULTISTRING_H
#define __ARES_DNS_MULTISTRING_H

#include "ares_buf.h"

struct ares_dns_multistring;
typedef struct ares_dns_multistring ares_dns_multistring_t;

ares_dns_multistring_t             *ares_dns_multistring_create(void);
void          ares_dns_multistring_clear(ares_dns_multistring_t *strs);
void          ares_dns_multistring_destroy(ares_dns_multistring_t *strs);
ares_status_t ares_dns_multistring_swap_own(ares_dns_multistring_t *strs,
                                            size_t idx, unsigned char *str,
                                            size_t len);
ares_status_t ares_dns_multistring_del(ares_dns_multistring_t *strs,
                                       size_t                  idx);
ares_status_t ares_dns_multistring_add_own(ares_dns_multistring_t *strs,
                                           unsigned char *str, size_t len);
size_t        ares_dns_multistring_cnt(const ares_dns_multistring_t *strs);
const unsigned char *
  ares_dns_multistring_get(const ares_dns_multistring_t *strs, size_t idx,
                           size_t *len);
const unsigned char *ares_dns_multistring_combined(ares_dns_multistring_t *strs,
                                                   size_t                 *len);

/*! Parse an array of character strings as defined in RFC1035, as binary,
 *  however, for convenience this does guarantee a NULL terminator (that is
 *  not included in the length for each value).
 *
 *  \param[in]  buf                initialized buffer object
 *  \param[in]  remaining_len      maximum length that should be used for
 *                                 parsing the string, this is often less than
 *                                 the remaining buffer and is based on the RR
 *                                 record length.
 *  \param[out] strs               Pointer passed by reference to be filled in
 *                                 with
 *                                 the array of values.
 *  \param[out] validate_printable Validate the strings contain only printable
 *                                 data.
 *  \return ARES_SUCCESS on success
 */
ares_status_t        ares_dns_multistring_parse_buf(ares_buf_t *buf,
                                                    size_t      remaining_len,
                                                    ares_dns_multistring_t **strs,
                                                    ares_bool_t validate_printable);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/cares/src/lib/record/ares_dns_name.c                                               0000664 0000000 0000000 00000044161 14746647661 0022370 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"

typedef struct {
  char  *name;
  size_t name_len;
  size_t idx;
} ares_nameoffset_t;

static void ares_nameoffset_free(void *arg)
{
  ares_nameoffset_t *off = arg;
  if (off == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }
  ares_free(off->name);
  ares_free(off);
}

static ares_status_t ares_nameoffset_create(ares_llist_t **list,
                                            const char *name, size_t idx)
{
  ares_status_t      status;
  ares_nameoffset_t *off = NULL;

  if (list == NULL || name == NULL || ares_strlen(name) == 0 ||
      ares_strlen(name) > 255) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  if (*list == NULL) {
    *list = ares_llist_create(ares_nameoffset_free);
  }
  if (*list == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  off = ares_malloc_zero(sizeof(*off));
  if (off == NULL) {
    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  off->name     = ares_strdup(name);
  off->name_len = ares_strlen(off->name);
  off->idx      = idx;

  if (ares_llist_insert_last(*list, off) == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  return ARES_SUCCESS;

/* LCOV_EXCL_START: OutOfMemory */
fail:
  ares_nameoffset_free(off);
  return status;
  /* LCOV_EXCL_STOP */
}

static const ares_nameoffset_t *ares_nameoffset_find(ares_llist_t *list,
                                                     const char   *name)
{
  size_t                   name_len = ares_strlen(name);
  ares_llist_node_t       *node;
  const ares_nameoffset_t *longest_match = NULL;

  if (list == NULL || name == NULL || name_len == 0) {
    return NULL;
  }

  for (node = ares_llist_node_first(list); node != NULL;
       node = ares_llist_node_next(node)) {
    const ares_nameoffset_t *val = ares_llist_node_val(node);
    size_t                   prefix_len;

    /* Can't be a match if the stored name is longer */
    if (val->name_len > name_len) {
      continue;
    }

    /* Can't be the longest match if our existing longest match is longer */
    if (longest_match != NULL && longest_match->name_len > val->name_len) {
      continue;
    }

    prefix_len = name_len - val->name_len;

    /* Due to DNS 0x20, lets not inadvertently mangle things, use case-sensitive
     * matching instead of case-insensitive.  This may result in slightly
     * larger DNS queries overall. */
    if (!ares_streq(val->name, name + prefix_len)) {
      continue;
    }

    /* We need to make sure if `val->name` is "example.com" that name is
     * is separated by a label, e.g. "myexample.com" is not ok, however
     * "my.example.com" is, so we look for the preceding "." */
    if (prefix_len != 0 && name[prefix_len - 1] != '.') {
      continue;
    }

    longest_match = val;
  }

  return longest_match;
}

static void ares_dns_labels_free_cb(void *arg)
{
  ares_buf_t **buf = arg;
  if (buf == NULL) {
    return;
  }

  ares_buf_destroy(*buf);
}

static ares_buf_t *ares_dns_labels_add(ares_array_t *labels)
{
  ares_buf_t **buf;

  if (labels == NULL) {
    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  if (ares_array_insert_last((void **)&buf, labels) != ARES_SUCCESS) {
    return NULL;
  }

  *buf = ares_buf_create();
  if (*buf == NULL) {
    ares_array_remove_last(labels);
    return NULL;
  }

  return *buf;
}

static ares_buf_t *ares_dns_labels_get_last(ares_array_t *labels)
{
  ares_buf_t **buf = ares_array_last(labels);

  if (buf == NULL) {
    return NULL;
  }

  return *buf;
}

static ares_buf_t *ares_dns_labels_get_at(ares_array_t *labels, size_t idx)
{
  ares_buf_t **buf = ares_array_at(labels, idx);

  if (buf == NULL) {
    return NULL;
  }

  return *buf;
}

static void ares_dns_name_labels_del_last(ares_array_t *labels)
{
  ares_array_remove_last(labels);
}

static ares_status_t ares_parse_dns_name_escape(ares_buf_t *namebuf,
                                                ares_buf_t *label,
                                                ares_bool_t validate_hostname)
{
  ares_status_t status;
  unsigned char c;

  status = ares_buf_fetch_bytes(namebuf, &c, 1);
  if (status != ARES_SUCCESS) {
    return ARES_EBADNAME;
  }

  /* If next character is a digit, read 2 more digits */
  if (ares_isdigit(c)) {
    size_t       i;
    unsigned int val = 0;

    val = c - '0';

    for (i = 0; i < 2; i++) {
      status = ares_buf_fetch_bytes(namebuf, &c, 1);
      if (status != ARES_SUCCESS) {
        return ARES_EBADNAME;
      }

      if (!ares_isdigit(c)) {
        return ARES_EBADNAME;
      }
      val *= 10;
      val += c - '0';
    }

    /* Out of range */
    if (val > 255) {
      return ARES_EBADNAME;
    }

    if (validate_hostname && !ares_is_hostnamech((unsigned char)val)) {
      return ARES_EBADNAME;
    }

    return ares_buf_append_byte(label, (unsigned char)val);
  }

  /* We can just output the character */
  if (validate_hostname && !ares_is_hostnamech(c)) {
    return ARES_EBADNAME;
  }

  return ares_buf_append_byte(label, c);
}

static ares_status_t ares_split_dns_name(ares_array_t *labels,
                                         ares_bool_t   validate_hostname,
                                         const char   *name)
{
  ares_status_t status;
  ares_buf_t   *label   = NULL;
  ares_buf_t   *namebuf = NULL;
  size_t        i;
  size_t        total_len = 0;
  unsigned char c;

  if (name == NULL || labels == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* Put name into a buffer for parsing */
  namebuf = ares_buf_create();
  if (namebuf == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  if (*name != '\0') {
    status =
      ares_buf_append(namebuf, (const unsigned char *)name, ares_strlen(name));
    if (status != ARES_SUCCESS) {
      goto done; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  /* Start with 1 label */
  label = ares_dns_labels_add(labels);
  if (label == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  while (ares_buf_fetch_bytes(namebuf, &c, 1) == ARES_SUCCESS) {
    /* New label */
    if (c == '.') {
      label = ares_dns_labels_add(labels);
      if (label == NULL) {
        status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
        goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
      }
      continue;
    }

    /* Escape */
    if (c == '\\') {
      status = ares_parse_dns_name_escape(namebuf, label, validate_hostname);
      if (status != ARES_SUCCESS) {
        goto done;
      }
      continue;
    }

    /* Output direct character */
    if (validate_hostname && !ares_is_hostnamech(c)) {
      status = ARES_EBADNAME;
      goto done;
    }

    status = ares_buf_append_byte(label, c);
    if (status != ARES_SUCCESS) {
      goto done; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  /* Remove trailing blank label */
  if (ares_buf_len(ares_dns_labels_get_last(labels)) == 0) {
    ares_dns_name_labels_del_last(labels);
  }

  /* If someone passed in "." there could have been 2 blank labels, check for
   * that */
  if (ares_array_len(labels) == 1 &&
      ares_buf_len(ares_dns_labels_get_last(labels)) == 0) {
    ares_dns_name_labels_del_last(labels);
  }

  /* Scan to make sure label lengths are valid */
  for (i = 0; i < ares_array_len(labels); i++) {
    const ares_buf_t *buf = ares_dns_labels_get_at(labels, i);
    size_t            len = ares_buf_len(buf);
    /* No 0-length labels, and no labels over 63 bytes */
    if (len == 0 || len > 63) {
      status = ARES_EBADNAME;
      goto done;
    }
    total_len += len;
  }

  /* Can't exceed maximum (unescaped) length */
  if (ares_array_len(labels) && total_len + ares_array_len(labels) - 1 > 255) {
    status = ARES_EBADNAME;
    goto done;
  }

  status = ARES_SUCCESS;

done:
  ares_buf_destroy(namebuf);
  return status;
}

ares_status_t ares_dns_name_write(ares_buf_t *buf, ares_llist_t **list,
                                  ares_bool_t validate_hostname,
                                  const char *name)
{
  const ares_nameoffset_t *off = NULL;
  size_t                   name_len;
  size_t                   orig_name_len;
  size_t                   pos    = ares_buf_len(buf);
  ares_array_t            *labels = NULL;
  char                     name_copy[512];
  ares_status_t            status;

  if (buf == NULL || name == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  labels = ares_array_create(sizeof(ares_buf_t *), ares_dns_labels_free_cb);
  if (labels == NULL) {
    return ARES_ENOMEM;
  }

  /* NOTE: due to possible escaping, name_copy buffer is > 256 to allow for
   *       this */
  name_len      = ares_strcpy(name_copy, name, sizeof(name_copy));
  orig_name_len = name_len;

  /* Find longest match */
  if (list != NULL) {
    off = ares_nameoffset_find(*list, name_copy);
    if (off != NULL && off->name_len != name_len) {
      /* truncate */
      name_len            -= (off->name_len + 1);
      name_copy[name_len]  = 0;
    }
  }

  /* Output labels */
  if (off == NULL || off->name_len != orig_name_len) {
    size_t i;

    status = ares_split_dns_name(labels, validate_hostname, name_copy);
    if (status != ARES_SUCCESS) {
      goto done;
    }

    for (i = 0; i < ares_array_len(labels); i++) {
      size_t               len  = 0;
      const ares_buf_t    *lbuf = ares_dns_labels_get_at(labels, i);
      const unsigned char *ptr  = ares_buf_peek(lbuf, &len);

      status = ares_buf_append_byte(buf, (unsigned char)(len & 0xFF));
      if (status != ARES_SUCCESS) {
        goto done; /* LCOV_EXCL_LINE: OutOfMemory */
      }

      status = ares_buf_append(buf, ptr, len);
      if (status != ARES_SUCCESS) {
        goto done; /* LCOV_EXCL_LINE: OutOfMemory */
      }
    }

    /* If we are NOT jumping to another label, output terminator */
    if (off == NULL) {
      status = ares_buf_append_byte(buf, 0);
      if (status != ARES_SUCCESS) {
        goto done; /* LCOV_EXCL_LINE: OutOfMemory */
      }
    }
  }

  /* Output name compression offset jump */
  if (off != NULL) {
    unsigned short u16 =
      (unsigned short)0xC000 | (unsigned short)(off->idx & 0x3FFF);
    status = ares_buf_append_be16(buf, u16);
    if (status != ARES_SUCCESS) {
      goto done; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  /* Store pointer for future jumps as long as its not an exact match for
   * a prior entry */
  if (list != NULL && (off == NULL || off->name_len != orig_name_len) &&
      name_len > 0) {
    status = ares_nameoffset_create(list, name /* not truncated copy! */, pos);
    if (status != ARES_SUCCESS) {
      goto done; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  status = ARES_SUCCESS;

done:
  ares_array_destroy(labels);
  return status;
}

/* Reserved characters for names that need to be escaped */
static ares_bool_t is_reservedch(int ch)
{
  switch (ch) {
    case '"':
    case '.':
    case ';':
    case '\\':
    case '(':
    case ')':
    case '@':
    case '$':
      return ARES_TRUE;
    default:
      break;
  }

  return ARES_FALSE;
}

static ares_status_t ares_fetch_dnsname_into_buf(ares_buf_t *buf,
                                                 ares_buf_t *dest, size_t len,
                                                 ares_bool_t is_hostname)
{
  size_t               remaining_len;
  const unsigned char *ptr = ares_buf_peek(buf, &remaining_len);
  ares_status_t        status;
  size_t               i;

  if (buf == NULL || len == 0 || remaining_len < len) {
    return ARES_EBADRESP;
  }

  for (i = 0; i < len; i++) {
    unsigned char c = ptr[i];

    /* Hostnames have a very specific allowed character set.  Anything outside
     * of that (non-printable and reserved included) are disallowed */
    if (is_hostname && !ares_is_hostnamech(c)) {
      status = ARES_EBADRESP;
      goto fail;
    }

    /* NOTE: dest may be NULL if the user is trying to skip the name. validation
     *       still occurs above. */
    if (dest == NULL) {
      continue;
    }

    /* Non-printable characters need to be output as \DDD */
    if (!ares_isprint(c)) {
      unsigned char escape[4];

      escape[0] = '\\';
      escape[1] = '0' + (c / 100);
      escape[2] = '0' + ((c % 100) / 10);
      escape[3] = '0' + (c % 10);

      status = ares_buf_append(dest, escape, sizeof(escape));
      if (status != ARES_SUCCESS) {
        goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
      }

      continue;
    }

    /* Reserved characters need to be escaped, otherwise normal */
    if (is_reservedch(c)) {
      status = ares_buf_append_byte(dest, '\\');
      if (status != ARES_SUCCESS) {
        goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
      }
    }

    status = ares_buf_append_byte(dest, c);
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  return ares_buf_consume(buf, len);

fail:
  return status;
}

ares_status_t ares_dns_name_parse(ares_buf_t *buf, char **name,
                                  ares_bool_t is_hostname)
{
  size_t        save_offset = 0;
  unsigned char c;
  ares_status_t status;
  ares_buf_t   *namebuf     = NULL;
  size_t        label_start = ares_buf_get_position(buf);

  if (buf == NULL) {
    return ARES_EFORMERR;
  }

  if (name != NULL) {
    namebuf = ares_buf_create();
    if (namebuf == NULL) {
      status = ARES_ENOMEM;
      goto fail;
    }
  }

  /* The compression scheme allows a domain name in a message to be
   * represented as either:
   *
   * - a sequence of labels ending in a zero octet
   * - a pointer
   * - a sequence of labels ending with a pointer
   */
  while (1) {
    /* Keep track of the minimum label starting position to prevent forward
     * jumping */
    if (label_start > ares_buf_get_position(buf)) {
      label_start = ares_buf_get_position(buf);
    }

    status = ares_buf_fetch_bytes(buf, &c, 1);
    if (status != ARES_SUCCESS) {
      goto fail;
    }

    /* Pointer/Redirect */
    if ((c & 0xc0) == 0xc0) {
      /* The pointer takes the form of a two octet sequence:
       *
       *   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
       *   | 1  1|                OFFSET                   |
       *   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
       *
       * The first two bits are ones.  This allows a pointer to be distinguished
       * from a label, since the label must begin with two zero bits because
       * labels are restricted to 63 octets or less.  (The 10 and 01
       * combinations are reserved for future use.)  The OFFSET field specifies
       * an offset from the start of the message (i.e., the first octet of the
       * ID field in the domain header).  A zero offset specifies the first byte
       * of the ID field, etc.
       */
      size_t offset = (size_t)((c & 0x3F) << 8);

      /* Fetch second byte of the redirect length */
      status = ares_buf_fetch_bytes(buf, &c, 1);
      if (status != ARES_SUCCESS) {
        goto fail;
      }

      offset |= ((size_t)c);

      /* According to RFC 1035 4.1.4:
       *    In this scheme, an entire domain name or a list of labels at
       *    the end of a domain name is replaced with a pointer to a prior
       *    occurrence of the same name.
       * Note the word "prior", meaning it must go backwards.  This was
       * confirmed via the ISC BIND code that it also prevents forward
       * pointers.
       */
      if (offset >= label_start) {
        status = ARES_EBADNAME;
        goto fail;
      }

      /* First time we make a jump, save the current position */
      if (save_offset == 0) {
        save_offset = ares_buf_get_position(buf);
      }

      status = ares_buf_set_position(buf, offset);
      if (status != ARES_SUCCESS) {
        status = ARES_EBADNAME;
        goto fail;
      }

      continue;
    } else if ((c & 0xc0) != 0) {
      /* 10 and 01 are reserved */
      status = ARES_EBADNAME;
      goto fail;
    } else if (c == 0) {
      /* termination via zero octet*/
      break;
    }

    /* New label */

    /* Labels are separated by periods */
    if (ares_buf_len(namebuf) != 0 && name != NULL) {
      status = ares_buf_append_byte(namebuf, '.');
      if (status != ARES_SUCCESS) {
        goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
      }
    }

    status = ares_fetch_dnsname_into_buf(buf, namebuf, c, is_hostname);
    if (status != ARES_SUCCESS) {
      goto fail;
    }
  }

  /* Restore offset read after first redirect/pointer as this is where the DNS
   * message continues */
  if (save_offset) {
    ares_buf_set_position(buf, save_offset);
  }

  if (name != NULL) {
    *name = ares_buf_finish_str(namebuf, NULL);
    if (*name == NULL) {
      status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
      goto fail;            /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  return ARES_SUCCESS;

fail:
  /* We want badname response if we couldn't parse */
  if (status == ARES_EBADRESP) {
    status = ARES_EBADNAME;
  }

  ares_buf_destroy(namebuf);
  return status;
}
                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/cares/src/lib/record/ares_dns_parse.c                                              0000664 0000000 0000000 00000110244 14746647661 0022556 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include <limits.h>
#ifdef HAVE_STDINT_H
#  include <stdint.h>
#endif

static size_t ares_dns_rr_remaining_len(const ares_buf_t *buf, size_t orig_len,
                                        size_t rdlength)
{
  size_t used_len = orig_len - ares_buf_len(buf);
  if (used_len >= rdlength) {
    return 0;
  }
  return rdlength - used_len;
}

static ares_status_t ares_dns_parse_and_set_dns_name(ares_buf_t    *buf,
                                                     ares_bool_t    is_hostname,
                                                     ares_dns_rr_t *rr,
                                                     ares_dns_rr_key_t key)
{
  ares_status_t status;
  char         *name = NULL;

  status = ares_dns_name_parse(buf, &name, is_hostname);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_rr_set_str_own(rr, key, name);
  if (status != ARES_SUCCESS) {
    ares_free(name);
    return status;
  }
  return ARES_SUCCESS;
}

static ares_status_t ares_dns_parse_and_set_dns_str(ares_buf_t       *buf,
                                                    size_t            max_len,
                                                    ares_dns_rr_t    *rr,
                                                    ares_dns_rr_key_t key,
                                                    ares_bool_t blank_allowed)
{
  ares_status_t status;
  char         *str = NULL;

  status = ares_buf_parse_dns_str(buf, max_len, &str);
  if (status != ARES_SUCCESS) {
    return status;
  }

  if (!blank_allowed && ares_strlen(str) == 0) {
    ares_free(str);
    return ARES_EBADRESP;
  }

  status = ares_dns_rr_set_str_own(rr, key, str);
  if (status != ARES_SUCCESS) {
    ares_free(str);
    return status;
  }
  return ARES_SUCCESS;
}

static ares_status_t
  ares_dns_parse_and_set_dns_abin(ares_buf_t *buf, size_t max_len,
                                  ares_dns_rr_t *rr, ares_dns_rr_key_t key,
                                  ares_bool_t validate_printable)
{
  ares_status_t           status;
  ares_dns_multistring_t *strs = NULL;

  status =
    ares_dns_multistring_parse_buf(buf, max_len, &strs, validate_printable);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_rr_set_abin_own(rr, key, strs);
  if (status != ARES_SUCCESS) {
    ares_dns_multistring_destroy(strs);
    return status;
  }
  return ARES_SUCCESS;
}

static ares_status_t ares_dns_parse_and_set_be32(ares_buf_t       *buf,
                                                 ares_dns_rr_t    *rr,
                                                 ares_dns_rr_key_t key)
{
  ares_status_t status;
  unsigned int  u32;

  status = ares_buf_fetch_be32(buf, &u32);
  if (status != ARES_SUCCESS) {
    return status;
  }

  return ares_dns_rr_set_u32(rr, key, u32);
}

static ares_status_t ares_dns_parse_and_set_be16(ares_buf_t       *buf,
                                                 ares_dns_rr_t    *rr,
                                                 ares_dns_rr_key_t key)
{
  ares_status_t  status;
  unsigned short u16;

  status = ares_buf_fetch_be16(buf, &u16);
  if (status != ARES_SUCCESS) {
    return status;
  }

  return ares_dns_rr_set_u16(rr, key, u16);
}

static ares_status_t ares_dns_parse_and_set_u8(ares_buf_t       *buf,
                                               ares_dns_rr_t    *rr,
                                               ares_dns_rr_key_t key)
{
  ares_status_t status;
  unsigned char u8;

  status = ares_buf_fetch_bytes(buf, &u8, 1);
  if (status != ARES_SUCCESS) {
    return status;
  }

  return ares_dns_rr_set_u8(rr, key, u8);
}

static ares_status_t ares_dns_parse_rr_a(ares_buf_t *buf, ares_dns_rr_t *rr,
                                         size_t rdlength)
{
  struct in_addr addr;
  ares_status_t  status;

  (void)rdlength; /* Not needed */

  status = ares_buf_fetch_bytes(buf, (unsigned char *)&addr, sizeof(addr));
  if (status != ARES_SUCCESS) {
    return status;
  }

  return ares_dns_rr_set_addr(rr, ARES_RR_A_ADDR, &addr);
}

static ares_status_t ares_dns_parse_rr_ns(ares_buf_t *buf, ares_dns_rr_t *rr,
                                          size_t rdlength)
{
  (void)rdlength; /* Not needed */

  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,
                                         ARES_RR_NS_NSDNAME);
}

static ares_status_t ares_dns_parse_rr_cname(ares_buf_t *buf, ares_dns_rr_t *rr,
                                             size_t rdlength)
{
  (void)rdlength; /* Not needed */

  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,
                                         ARES_RR_CNAME_CNAME);
}

static ares_status_t ares_dns_parse_rr_soa(ares_buf_t *buf, ares_dns_rr_t *rr,
                                           size_t rdlength)
{
  ares_status_t status;

  (void)rdlength; /* Not needed */

  /* MNAME */
  status =
    ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr, ARES_RR_SOA_MNAME);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* RNAME */
  status =
    ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr, ARES_RR_SOA_RNAME);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* SERIAL */
  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_SERIAL);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* REFRESH */
  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_REFRESH);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* RETRY */
  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_RETRY);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* EXPIRE */
  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_EXPIRE);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* MINIMUM */
  return ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SOA_MINIMUM);
}

static ares_status_t ares_dns_parse_rr_ptr(ares_buf_t *buf, ares_dns_rr_t *rr,
                                           size_t rdlength)
{
  (void)rdlength; /* Not needed */

  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,
                                         ARES_RR_PTR_DNAME);
}

static ares_status_t ares_dns_parse_rr_hinfo(ares_buf_t *buf, ares_dns_rr_t *rr,
                                             size_t rdlength)
{
  ares_status_t status;
  size_t        orig_len = ares_buf_len(buf);

  (void)rdlength; /* Not needed */

  /* CPU */
  status = ares_dns_parse_and_set_dns_str(
    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), rr,
    ARES_RR_HINFO_CPU, ARES_TRUE);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* OS */
  status = ares_dns_parse_and_set_dns_str(
    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), rr,
    ARES_RR_HINFO_OS, ARES_TRUE);

  return status;
}

static ares_status_t ares_dns_parse_rr_mx(ares_buf_t *buf, ares_dns_rr_t *rr,
                                          size_t rdlength)
{
  ares_status_t status;

  (void)rdlength; /* Not needed */

  /* PREFERENCE */
  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_MX_PREFERENCE);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* EXCHANGE */
  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,
                                         ARES_RR_MX_EXCHANGE);
}

static ares_status_t ares_dns_parse_rr_txt(ares_buf_t *buf, ares_dns_rr_t *rr,
                                           size_t rdlength)
{
  return ares_dns_parse_and_set_dns_abin(buf, rdlength, rr, ARES_RR_TXT_DATA,
                                         ARES_FALSE);
}

static ares_status_t ares_dns_parse_rr_sig(ares_buf_t *buf, ares_dns_rr_t *rr,
                                           size_t rdlength)
{
  ares_status_t  status;
  size_t         orig_len = ares_buf_len(buf);
  size_t         len;
  unsigned char *data;

  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SIG_TYPE_COVERED);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_SIG_ALGORITHM);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_SIG_LABELS);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SIG_ORIGINAL_TTL);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SIG_EXPIRATION);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_parse_and_set_be32(buf, rr, ARES_RR_SIG_INCEPTION);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SIG_KEY_TAG);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,
                                           ARES_RR_SIG_SIGNERS_NAME);
  if (status != ARES_SUCCESS) {
    return status;
  }

  len = ares_dns_rr_remaining_len(buf, orig_len, rdlength);
  if (len == 0) {
    return ARES_EBADRESP;
  }

  status = ares_buf_fetch_bytes_dup(buf, len, ARES_FALSE, &data);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_rr_set_bin_own(rr, ARES_RR_SIG_SIGNATURE, data, len);
  if (status != ARES_SUCCESS) {
    ares_free(data);
    return status;
  }

  return ARES_SUCCESS;
}

static ares_status_t ares_dns_parse_rr_aaaa(ares_buf_t *buf, ares_dns_rr_t *rr,
                                            size_t rdlength)
{
  struct ares_in6_addr addr;
  ares_status_t        status;

  (void)rdlength; /* Not needed */

  status = ares_buf_fetch_bytes(buf, (unsigned char *)&addr, sizeof(addr));
  if (status != ARES_SUCCESS) {
    return status;
  }

  return ares_dns_rr_set_addr6(rr, ARES_RR_AAAA_ADDR, &addr);
}

static ares_status_t ares_dns_parse_rr_srv(ares_buf_t *buf, ares_dns_rr_t *rr,
                                           size_t rdlength)
{
  ares_status_t status;

  (void)rdlength; /* Not needed */

  /* PRIORITY */
  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SRV_PRIORITY);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* WEIGHT */
  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SRV_WEIGHT);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* PORT */
  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SRV_PORT);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* TARGET */
  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,
                                         ARES_RR_SRV_TARGET);
}

static ares_status_t ares_dns_parse_rr_naptr(ares_buf_t *buf, ares_dns_rr_t *rr,
                                             size_t rdlength)
{
  ares_status_t status;
  size_t        orig_len = ares_buf_len(buf);

  /* ORDER */
  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_NAPTR_ORDER);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* PREFERENCE */
  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_NAPTR_PREFERENCE);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* FLAGS */
  status = ares_dns_parse_and_set_dns_str(
    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), rr,
    ARES_RR_NAPTR_FLAGS, ARES_TRUE);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* SERVICES */
  status = ares_dns_parse_and_set_dns_str(
    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), rr,
    ARES_RR_NAPTR_SERVICES, ARES_TRUE);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* REGEXP */
  status = ares_dns_parse_and_set_dns_str(
    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), rr,
    ARES_RR_NAPTR_REGEXP, ARES_TRUE);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* REPLACEMENT */
  return ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr,
                                         ARES_RR_NAPTR_REPLACEMENT);
}

static ares_status_t ares_dns_parse_rr_opt(ares_buf_t *buf, ares_dns_rr_t *rr,
                                           size_t         rdlength,
                                           unsigned short raw_class,
                                           unsigned int   raw_ttl)
{
  ares_status_t  status;
  size_t         orig_len = ares_buf_len(buf);
  unsigned short rcode_high;

  status = ares_dns_rr_set_u16(rr, ARES_RR_OPT_UDP_SIZE, raw_class);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* First 8 bits of TTL are an extended RCODE, and they go in the higher order
   * after the original 4-bit rcode */
  rcode_high             = (unsigned short)((raw_ttl >> 20) & 0x0FF0);
  rr->parent->raw_rcode |= rcode_high;

  status = ares_dns_rr_set_u8(rr, ARES_RR_OPT_VERSION,
                              (unsigned char)(raw_ttl >> 16) & 0xFF);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_rr_set_u16(rr, ARES_RR_OPT_FLAGS,
                               (unsigned short)(raw_ttl & 0xFFFF));
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Parse options */
  while (ares_dns_rr_remaining_len(buf, orig_len, rdlength)) {
    unsigned short opt = 0;
    unsigned short len = 0;
    unsigned char *val = NULL;

    /* Fetch be16 option */
    status = ares_buf_fetch_be16(buf, &opt);
    if (status != ARES_SUCCESS) {
      return status;
    }

    /* Fetch be16 length */
    status = ares_buf_fetch_be16(buf, &len);
    if (status != ARES_SUCCESS) {
      return status;
    }

    if (len) {
      status = ares_buf_fetch_bytes_dup(buf, len, ARES_TRUE, &val);
      if (status != ARES_SUCCESS) {
        return status;
      }
    }

    status = ares_dns_rr_set_opt_own(rr, ARES_RR_OPT_OPTIONS, opt, val, len);
    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  return ARES_SUCCESS;
}

static ares_status_t ares_dns_parse_rr_tlsa(ares_buf_t *buf, ares_dns_rr_t *rr,
                                            size_t rdlength)
{
  ares_status_t  status;
  size_t         orig_len = ares_buf_len(buf);
  size_t         len;
  unsigned char *data;

  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_TLSA_CERT_USAGE);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_TLSA_SELECTOR);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_TLSA_MATCH);
  if (status != ARES_SUCCESS) {
    return status;
  }

  len = ares_dns_rr_remaining_len(buf, orig_len, rdlength);
  if (len == 0) {
    return ARES_EBADRESP;
  }

  status = ares_buf_fetch_bytes_dup(buf, len, ARES_FALSE, &data);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_rr_set_bin_own(rr, ARES_RR_TLSA_DATA, data, len);
  if (status != ARES_SUCCESS) {
    ares_free(data);
    return status;
  }

  return ARES_SUCCESS;
}

static ares_status_t ares_dns_parse_rr_svcb(ares_buf_t *buf, ares_dns_rr_t *rr,
                                            size_t rdlength)
{
  ares_status_t status;
  size_t        orig_len = ares_buf_len(buf);

  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_SVCB_PRIORITY);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status =
    ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr, ARES_RR_SVCB_TARGET);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Parse params */
  while (ares_dns_rr_remaining_len(buf, orig_len, rdlength)) {
    unsigned short opt = 0;
    unsigned short len = 0;
    unsigned char *val = NULL;

    /* Fetch be16 option */
    status = ares_buf_fetch_be16(buf, &opt);
    if (status != ARES_SUCCESS) {
      return status;
    }

    /* Fetch be16 length */
    status = ares_buf_fetch_be16(buf, &len);
    if (status != ARES_SUCCESS) {
      return status;
    }

    if (len) {
      status = ares_buf_fetch_bytes_dup(buf, len, ARES_TRUE, &val);
      if (status != ARES_SUCCESS) {
        return status;
      }
    }

    status = ares_dns_rr_set_opt_own(rr, ARES_RR_SVCB_PARAMS, opt, val, len);
    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  return ARES_SUCCESS;
}

static ares_status_t ares_dns_parse_rr_https(ares_buf_t *buf, ares_dns_rr_t *rr,
                                             size_t rdlength)
{
  ares_status_t status;
  size_t        orig_len = ares_buf_len(buf);

  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_HTTPS_PRIORITY);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status =
    ares_dns_parse_and_set_dns_name(buf, ARES_FALSE, rr, ARES_RR_HTTPS_TARGET);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Parse params */
  while (ares_dns_rr_remaining_len(buf, orig_len, rdlength)) {
    unsigned short opt = 0;
    unsigned short len = 0;
    unsigned char *val = NULL;

    /* Fetch be16 option */
    status = ares_buf_fetch_be16(buf, &opt);
    if (status != ARES_SUCCESS) {
      return status;
    }

    /* Fetch be16 length */
    status = ares_buf_fetch_be16(buf, &len);
    if (status != ARES_SUCCESS) {
      return status;
    }

    if (len) {
      status = ares_buf_fetch_bytes_dup(buf, len, ARES_TRUE, &val);
      if (status != ARES_SUCCESS) {
        return status;
      }
    }

    status = ares_dns_rr_set_opt_own(rr, ARES_RR_HTTPS_PARAMS, opt, val, len);
    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  return ARES_SUCCESS;
}

static ares_status_t ares_dns_parse_rr_uri(ares_buf_t *buf, ares_dns_rr_t *rr,
                                           size_t rdlength)
{
  char         *name = NULL;
  ares_status_t status;
  size_t        orig_len = ares_buf_len(buf);
  size_t        remaining_len;

  /* PRIORITY */
  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_URI_PRIORITY);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* WEIGHT */
  status = ares_dns_parse_and_set_be16(buf, rr, ARES_RR_URI_WEIGHT);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* TARGET -- not in string format, rest of buffer, required to be
   * non-zero length */
  remaining_len = ares_dns_rr_remaining_len(buf, orig_len, rdlength);
  if (remaining_len == 0) {
    status = ARES_EBADRESP;
    return status;
  }

  /* NOTE: Not in DNS string format */
  status = ares_buf_fetch_str_dup(buf, remaining_len, &name);
  if (status != ARES_SUCCESS) {
    return status;
  }

  if (!ares_str_isprint(name, remaining_len)) {
    ares_free(name);
    return ARES_EBADRESP;
  }

  status = ares_dns_rr_set_str_own(rr, ARES_RR_URI_TARGET, name);
  if (status != ARES_SUCCESS) {
    ares_free(name);
    return status;
  }
  name = NULL;

  return ARES_SUCCESS;
}

static ares_status_t ares_dns_parse_rr_caa(ares_buf_t *buf, ares_dns_rr_t *rr,
                                           size_t rdlength)
{
  unsigned char *data     = NULL;
  size_t         data_len = 0;
  ares_status_t  status;
  size_t         orig_len = ares_buf_len(buf);

  /* CRITICAL */
  status = ares_dns_parse_and_set_u8(buf, rr, ARES_RR_CAA_CRITICAL);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Tag */
  status = ares_dns_parse_and_set_dns_str(
    buf, ares_dns_rr_remaining_len(buf, orig_len, rdlength), rr,
    ARES_RR_CAA_TAG, ARES_FALSE);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Value - binary! (remaining buffer */
  data_len = ares_dns_rr_remaining_len(buf, orig_len, rdlength);
  if (data_len == 0) {
    status = ARES_EBADRESP;
    return status;
  }
  status = ares_buf_fetch_bytes_dup(buf, data_len, ARES_TRUE, &data);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_rr_set_bin_own(rr, ARES_RR_CAA_VALUE, data, data_len);
  if (status != ARES_SUCCESS) {
    ares_free(data);
    return status;
  }
  data = NULL;

  return ARES_SUCCESS;
}

static ares_status_t ares_dns_parse_rr_raw_rr(ares_buf_t    *buf,
                                              ares_dns_rr_t *rr,
                                              size_t         rdlength,
                                              unsigned short raw_type)
{
  ares_status_t  status;
  unsigned char *bytes = NULL;

  if (rdlength == 0) {
    return ARES_SUCCESS;
  }

  status = ares_buf_fetch_bytes_dup(buf, rdlength, ARES_FALSE, &bytes);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Can't fail */
  status = ares_dns_rr_set_u16(rr, ARES_RR_RAW_RR_TYPE, raw_type);
  if (status != ARES_SUCCESS) {
    ares_free(bytes);
    return status;
  }

  status = ares_dns_rr_set_bin_own(rr, ARES_RR_RAW_RR_DATA, bytes, rdlength);
  if (status != ARES_SUCCESS) {
    ares_free(bytes);
    return status;
  }

  return ARES_SUCCESS;
}

static ares_status_t ares_dns_parse_header(ares_buf_t *buf, unsigned int flags,
                                           ares_dns_record_t **dnsrec,
                                           unsigned short     *qdcount,
                                           unsigned short     *ancount,
                                           unsigned short     *nscount,
                                           unsigned short     *arcount)
{
  ares_status_t     status = ARES_EBADRESP;
  unsigned short    u16;
  unsigned short    id;
  unsigned short    dns_flags = 0;
  ares_dns_opcode_t opcode;
  unsigned short    rcode;

  (void)flags; /* currently unused */

  if (buf == NULL || dnsrec == NULL || qdcount == NULL || ancount == NULL ||
      nscount == NULL || arcount == NULL) {
    return ARES_EFORMERR;
  }

  *dnsrec = NULL;

  /*
   *  RFC 1035 4.1.1. Header section format.
   *  and Updated by RFC 2065 to add AD and CD bits.
   *                                  1  1  1  1  1  1
   *    0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   *  |                      ID                       |
   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   *  |QR|   Opcode  |AA|TC|RD|RA| Z|AD|CD|   RCODE   |
   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   *  |                    QDCOUNT                    |
   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   *  |                    ANCOUNT                    |
   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   *  |                    NSCOUNT                    |
   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   *  |                    ARCOUNT                    |
   *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   */

  /* ID */
  status = ares_buf_fetch_be16(buf, &id);
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  /* Flags */
  status = ares_buf_fetch_be16(buf, &u16);
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  /* QR */
  if (u16 & 0x8000) {
    dns_flags |= ARES_FLAG_QR;
  }

  /* OPCODE */
  opcode = (u16 >> 11) & 0xf;

  /* AA */
  if (u16 & 0x400) {
    dns_flags |= ARES_FLAG_AA;
  }

  /* TC */
  if (u16 & 0x200) {
    dns_flags |= ARES_FLAG_TC;
  }

  /* RD */
  if (u16 & 0x100) {
    dns_flags |= ARES_FLAG_RD;
  }

  /* RA */
  if (u16 & 0x80) {
    dns_flags |= ARES_FLAG_RA;
  }

  /* Z -- unused */

  /* AD */
  if (u16 & 0x20) {
    dns_flags |= ARES_FLAG_AD;
  }

  /* CD */
  if (u16 & 0x10) {
    dns_flags |= ARES_FLAG_CD;
  }

  /* RCODE */
  rcode = u16 & 0xf;

  /* QDCOUNT */
  status = ares_buf_fetch_be16(buf, qdcount);
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  /* ANCOUNT */
  status = ares_buf_fetch_be16(buf, ancount);
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  /* NSCOUNT */
  status = ares_buf_fetch_be16(buf, nscount);
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  /* ARCOUNT */
  status = ares_buf_fetch_be16(buf, arcount);
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  status = ares_dns_record_create(dnsrec, id, dns_flags, opcode,
                                  ARES_RCODE_NOERROR /* Temporary */);
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  (*dnsrec)->raw_rcode = rcode;

  if (*ancount > 0) {
    status =
      ares_dns_record_rr_prealloc(*dnsrec, ARES_SECTION_ANSWER, *ancount);
    if (status != ARES_SUCCESS) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  if (*nscount > 0) {
    status =
      ares_dns_record_rr_prealloc(*dnsrec, ARES_SECTION_AUTHORITY, *nscount);
    if (status != ARES_SUCCESS) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  if (*arcount > 0) {
    status =
      ares_dns_record_rr_prealloc(*dnsrec, ARES_SECTION_ADDITIONAL, *arcount);
    if (status != ARES_SUCCESS) {
      goto fail; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  return ARES_SUCCESS;

fail:
  ares_dns_record_destroy(*dnsrec);
  *dnsrec  = NULL;
  *qdcount = 0;
  *ancount = 0;
  *nscount = 0;
  *arcount = 0;

  return status;
}

static ares_status_t
  ares_dns_parse_rr_data(ares_buf_t *buf, size_t rdlength, ares_dns_rr_t *rr,
                         ares_dns_rec_type_t type, unsigned short raw_type,
                         unsigned short raw_class, unsigned int raw_ttl)
{
  switch (type) {
    case ARES_REC_TYPE_A:
      return ares_dns_parse_rr_a(buf, rr, rdlength);
    case ARES_REC_TYPE_NS:
      return ares_dns_parse_rr_ns(buf, rr, rdlength);
    case ARES_REC_TYPE_CNAME:
      return ares_dns_parse_rr_cname(buf, rr, rdlength);
    case ARES_REC_TYPE_SOA:
      return ares_dns_parse_rr_soa(buf, rr, rdlength);
    case ARES_REC_TYPE_PTR:
      return ares_dns_parse_rr_ptr(buf, rr, rdlength);
    case ARES_REC_TYPE_HINFO:
      return ares_dns_parse_rr_hinfo(buf, rr, rdlength);
    case ARES_REC_TYPE_MX:
      return ares_dns_parse_rr_mx(buf, rr, rdlength);
    case ARES_REC_TYPE_TXT:
      return ares_dns_parse_rr_txt(buf, rr, rdlength);
    case ARES_REC_TYPE_SIG:
      return ares_dns_parse_rr_sig(buf, rr, rdlength);
    case ARES_REC_TYPE_AAAA:
      return ares_dns_parse_rr_aaaa(buf, rr, rdlength);
    case ARES_REC_TYPE_SRV:
      return ares_dns_parse_rr_srv(buf, rr, rdlength);
    case ARES_REC_TYPE_NAPTR:
      return ares_dns_parse_rr_naptr(buf, rr, rdlength);
    case ARES_REC_TYPE_ANY:
      return ARES_EBADRESP;
    case ARES_REC_TYPE_OPT:
      return ares_dns_parse_rr_opt(buf, rr, rdlength, raw_class, raw_ttl);
    case ARES_REC_TYPE_TLSA:
      return ares_dns_parse_rr_tlsa(buf, rr, rdlength);
    case ARES_REC_TYPE_SVCB:
      return ares_dns_parse_rr_svcb(buf, rr, rdlength);
    case ARES_REC_TYPE_HTTPS:
      return ares_dns_parse_rr_https(buf, rr, rdlength);
    case ARES_REC_TYPE_URI:
      return ares_dns_parse_rr_uri(buf, rr, rdlength);
    case ARES_REC_TYPE_CAA:
      return ares_dns_parse_rr_caa(buf, rr, rdlength);
    case ARES_REC_TYPE_RAW_RR:
      return ares_dns_parse_rr_raw_rr(buf, rr, rdlength, raw_type);
  }
  return ARES_EFORMERR;
}

static ares_status_t ares_dns_parse_qd(ares_buf_t        *buf,
                                       ares_dns_record_t *dnsrec)
{
  char               *name = NULL;
  unsigned short      u16;
  ares_status_t       status;
  ares_dns_rec_type_t type;
  ares_dns_class_t    qclass;
  /* The question section is used to carry the "question" in most queries,
   * i.e., the parameters that define what is being asked.  The section
   * contains QDCOUNT (usually 1) entries, each of the following format:
   *                                 1  1  1  1  1  1
   *   0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   * |                                               |
   * /                     QNAME                     /
   * /                                               /
   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   * |                     QTYPE                     |
   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   * |                     QCLASS                    |
   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   */

  /* Name */
  status = ares_dns_name_parse(buf, &name, ARES_FALSE);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  /* Type */
  status = ares_buf_fetch_be16(buf, &u16);
  if (status != ARES_SUCCESS) {
    goto done;
  }
  type = u16;

  /* Class */
  status = ares_buf_fetch_be16(buf, &u16);
  if (status != ARES_SUCCESS) {
    goto done;
  }
  qclass = u16;

  /* Add question */
  status = ares_dns_record_query_add(dnsrec, name, type, qclass);
  if (status != ARES_SUCCESS) {
    goto done;
  }

done:
  ares_free(name);
  return status;
}

static ares_status_t ares_dns_parse_rr(ares_buf_t *buf, unsigned int flags,
                                       ares_dns_section_t sect,
                                       ares_dns_record_t *dnsrec)
{
  char               *name = NULL;
  unsigned short      u16;
  unsigned short      raw_type;
  ares_status_t       status;
  ares_dns_rec_type_t type;
  ares_dns_class_t    qclass;
  unsigned int        ttl;
  size_t              rdlength;
  ares_dns_rr_t      *rr            = NULL;
  size_t              remaining_len = 0;
  size_t              processed_len = 0;
  ares_bool_t         namecomp;

  /* All RRs have the same top level format shown below:
   *                                 1  1  1  1  1  1
   *   0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   * |                                               |
   * /                                               /
   * /                      NAME                     /
   * |                                               |
   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   * |                      TYPE                     |
   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   * |                     CLASS                     |
   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   * |                      TTL                      |
   * |                                               |
   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   * |                   RDLENGTH                    |
   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
   * /                     RDATA                     /
   * /                                               /
   * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   */

  /* Name */
  status = ares_dns_name_parse(buf, &name, ARES_FALSE);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  /* Type */
  status = ares_buf_fetch_be16(buf, &u16);
  if (status != ARES_SUCCESS) {
    goto done;
  }
  type     = u16;
  raw_type = u16; /* Only used for raw rr data */

  /* Class */
  status = ares_buf_fetch_be16(buf, &u16);
  if (status != ARES_SUCCESS) {
    goto done;
  }
  qclass = u16;

  /* TTL */
  status = ares_buf_fetch_be32(buf, &ttl);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  /* Length */
  status = ares_buf_fetch_be16(buf, &u16);
  if (status != ARES_SUCCESS) {
    goto done;
  }
  rdlength = u16;

  if (!ares_dns_rec_type_isvalid(type, ARES_FALSE)) {
    type = ARES_REC_TYPE_RAW_RR;
  }

  namecomp = ares_dns_rec_allow_name_comp(type);
  if (sect == ARES_SECTION_ANSWER &&
      (flags &
       (namecomp ? ARES_DNS_PARSE_AN_BASE_RAW : ARES_DNS_PARSE_AN_EXT_RAW))) {
    type = ARES_REC_TYPE_RAW_RR;
  }
  if (sect == ARES_SECTION_AUTHORITY &&
      (flags &
       (namecomp ? ARES_DNS_PARSE_NS_BASE_RAW : ARES_DNS_PARSE_NS_EXT_RAW))) {
    type = ARES_REC_TYPE_RAW_RR;
  }
  if (sect == ARES_SECTION_ADDITIONAL &&
      (flags &
       (namecomp ? ARES_DNS_PARSE_AR_BASE_RAW : ARES_DNS_PARSE_AR_EXT_RAW))) {
    type = ARES_REC_TYPE_RAW_RR;
  }

  /* Pull into another buffer for safety */
  if (rdlength > ares_buf_len(buf)) {
    status = ARES_EBADRESP;
    goto done;
  }

  /* Add the base rr */
  status =
    ares_dns_record_rr_add(&rr, dnsrec, sect, name, type,
                           type == ARES_REC_TYPE_OPT ? ARES_CLASS_IN : qclass,
                           type == ARES_REC_TYPE_OPT ? 0 : ttl);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  /* Record the current remaining length in the buffer so we can tell how
   * much was processed */
  remaining_len = ares_buf_len(buf);

  /* Fill in the data for the rr */
  status = ares_dns_parse_rr_data(buf, rdlength, rr, type, raw_type,
                                  (unsigned short)qclass, ttl);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  /* Determine how many bytes were processed */
  processed_len = remaining_len - ares_buf_len(buf);

  /* If too many bytes were processed, error! */
  if (processed_len > rdlength) {
    status = ARES_EBADRESP;
    goto done;
  }

  /* If too few bytes were processed, consume the unprocessed data for this
   * record as the parser may not have wanted/needed to use it */
  if (processed_len < rdlength) {
    ares_buf_consume(buf, rdlength - processed_len);
  }


done:
  ares_free(name);
  return status;
}

static ares_status_t ares_dns_parse_buf(ares_buf_t *buf, unsigned int flags,
                                        ares_dns_record_t **dnsrec)
{
  ares_status_t  status;
  unsigned short qdcount;
  unsigned short ancount;
  unsigned short nscount;
  unsigned short arcount;
  unsigned short i;

  if (buf == NULL || dnsrec == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* Maximum DNS packet size is 64k, even over TCP */
  if (ares_buf_len(buf) > 0xFFFF) {
    return ARES_EFORMERR;
  }

  /* All communications inside of the domain protocol are carried in a single
   * format called a message.  The top level format of message is divided
   * into 5 sections (some of which are empty in certain cases) shown below:
   *
   * +---------------------+
   * |        Header       |
   * +---------------------+
   * |       Question      | the question for the name server
   * +---------------------+
   * |        Answer       | RRs answering the question
   * +---------------------+
   * |      Authority      | RRs pointing toward an authority
   * +---------------------+
   * |      Additional     | RRs holding additional information
   * +---------------------+
   */

  /* Parse header */
  status = ares_dns_parse_header(buf, flags, dnsrec, &qdcount, &ancount,
                                 &nscount, &arcount);
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  /* Must have questions */
  if (qdcount == 0) {
    status = ARES_EBADRESP;
    goto fail;
  }

  /* XXX: this should be controlled by a flag in case we want to allow
   *      multiple questions.  I think mDNS allows this */
  if (qdcount > 1) {
    status = ARES_EBADRESP;
    goto fail;
  }

  /* Parse questions */
  for (i = 0; i < qdcount; i++) {
    status = ares_dns_parse_qd(buf, *dnsrec);
    if (status != ARES_SUCCESS) {
      goto fail;
    }
  }

  /* Parse Answers */
  for (i = 0; i < ancount; i++) {
    status = ares_dns_parse_rr(buf, flags, ARES_SECTION_ANSWER, *dnsrec);
    if (status != ARES_SUCCESS) {
      goto fail;
    }
  }

  /* Parse Authority */
  for (i = 0; i < nscount; i++) {
    status = ares_dns_parse_rr(buf, flags, ARES_SECTION_AUTHORITY, *dnsrec);
    if (status != ARES_SUCCESS) {
      goto fail;
    }
  }

  /* Parse Additional */
  for (i = 0; i < arcount; i++) {
    status = ares_dns_parse_rr(buf, flags, ARES_SECTION_ADDITIONAL, *dnsrec);
    if (status != ARES_SUCCESS) {
      goto fail;
    }
  }

  /* Finalize rcode now that if we have OPT it is processed */
  if (!ares_dns_rcode_isvalid((*dnsrec)->raw_rcode)) {
    (*dnsrec)->rcode = ARES_RCODE_SERVFAIL;
  } else {
    (*dnsrec)->rcode = (ares_dns_rcode_t)(*dnsrec)->raw_rcode;
  }

  return ARES_SUCCESS;

fail:
  ares_dns_record_destroy(*dnsrec);
  *dnsrec = NULL;
  return status;
}

ares_status_t ares_dns_parse(const unsigned char *buf, size_t buf_len,
                             unsigned int flags, ares_dns_record_t **dnsrec)
{
  ares_buf_t   *parser = NULL;
  ares_status_t status;

  if (buf == NULL || buf_len == 0 || dnsrec == NULL) {
    return ARES_EFORMERR;
  }

  parser = ares_buf_create_const(buf, buf_len);
  if (parser == NULL) {
    return ARES_ENOMEM;
  }

  status = ares_dns_parse_buf(parser, flags, dnsrec);
  ares_buf_destroy(parser);

  return status;
}
                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/cares/src/lib/record/ares_dns_private.h                                            0000664 0000000 0000000 00000023067 14746647661 0023131 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES_DNS_PRIVATE_H
#define __ARES_DNS_PRIVATE_H

ares_status_t        ares_dns_record_duplicate_ex(ares_dns_record_t      **dest,
                                                  const ares_dns_record_t *src);
ares_bool_t          ares_dns_rec_allow_name_comp(ares_dns_rec_type_t type);
ares_bool_t          ares_dns_opcode_isvalid(ares_dns_opcode_t opcode);
ares_bool_t          ares_dns_rcode_isvalid(ares_dns_rcode_t rcode);
ares_bool_t          ares_dns_flags_arevalid(unsigned short flags);
ares_bool_t          ares_dns_rec_type_isvalid(ares_dns_rec_type_t type,
                                               ares_bool_t         is_query);
ares_bool_t          ares_dns_class_isvalid(ares_dns_class_t    qclass,
                                            ares_dns_rec_type_t type,
                                            ares_bool_t         is_query);
ares_bool_t          ares_dns_section_isvalid(ares_dns_section_t sect);
ares_status_t        ares_dns_rr_set_str_own(ares_dns_rr_t    *dns_rr,
                                             ares_dns_rr_key_t key, char *val);
ares_status_t        ares_dns_rr_set_bin_own(ares_dns_rr_t    *dns_rr,
                                             ares_dns_rr_key_t key, unsigned char *val,
                                             size_t len);
ares_status_t        ares_dns_rr_set_abin_own(ares_dns_rr_t          *dns_rr,
                                              ares_dns_rr_key_t       key,
                                              ares_dns_multistring_t *strs);
ares_status_t        ares_dns_rr_set_opt_own(ares_dns_rr_t    *dns_rr,
                                             ares_dns_rr_key_t key, unsigned short opt,
                                             unsigned char *val, size_t val_len);
ares_status_t        ares_dns_record_rr_prealloc(ares_dns_record_t *dnsrec,
                                                 ares_dns_section_t sect, size_t cnt);
ares_dns_rr_t       *ares_dns_get_opt_rr(ares_dns_record_t *rec);
const ares_dns_rr_t *ares_dns_get_opt_rr_const(const ares_dns_record_t *rec);
void                 ares_dns_record_ttl_decrement(ares_dns_record_t *dnsrec,
                                                   unsigned int       ttl_decrement);

/* Same as ares_dns_write() but appends to an existing buffer object */
ares_status_t        ares_dns_write_buf(const ares_dns_record_t *dnsrec,
                                        ares_buf_t              *buf);

/* Same as ares_dns_write_buf(), but prepends a 16bit length */
ares_status_t        ares_dns_write_buf_tcp(const ares_dns_record_t *dnsrec,
                                            ares_buf_t              *buf);

/*! Create a DNS record object for a query. The arguments are the same as
 *  those for ares_create_query().
 *
 *  \param[out] dnsrec       DNS record object to create.
 *  \param[in]  name         NUL-terminated name for the query.
 *  \param[in]  dnsclass     Class for the query.
 *  \param[in]  type         Type for the query.
 *  \param[in]  id           Identifier for the query.
 *  \param[in]  flags        Flags for the query.
 *  \param[in]  max_udp_size Maximum size of a UDP packet for EDNS.
 *  \return ARES_SUCCESS on success, otherwise an error code.
 */
ares_status_t
  ares_dns_record_create_query(ares_dns_record_t **dnsrec, const char *name,
                               ares_dns_class_t    dnsclass,
                               ares_dns_rec_type_t type, unsigned short id,
                               ares_dns_flags_t flags, size_t max_udp_size);

/*! Convert the RCODE and ANCOUNT from a DNS query reply into a status code.
 *
 *  \param[in] rcode   The RCODE from the reply.
 *  \param[in] ancount The ANCOUNT from the reply.
 *  \return An appropriate status code.
 */
ares_status_t ares_dns_query_reply_tostatus(ares_dns_rcode_t rcode,
                                            size_t           ancount);

struct ares_dns_qd {
  char               *name;
  ares_dns_rec_type_t qtype;
  ares_dns_class_t    qclass;
};

typedef struct {
  struct in_addr addr;
} ares_dns_a_t;

typedef struct {
  char *nsdname;
} ares_dns_ns_t;

typedef struct {
  char *cname;
} ares_dns_cname_t;

typedef struct {
  char        *mname;
  char        *rname;
  unsigned int serial;
  unsigned int refresh;
  unsigned int retry;
  unsigned int expire;
  unsigned int minimum;
} ares_dns_soa_t;

typedef struct {
  char *dname;
} ares_dns_ptr_t;

typedef struct {
  char *cpu;
  char *os;
} ares_dns_hinfo_t;

typedef struct {
  unsigned short preference;
  char          *exchange;
} ares_dns_mx_t;

typedef struct {
  ares_dns_multistring_t *strs;
} ares_dns_txt_t;

typedef struct {
  unsigned short type_covered;
  unsigned char  algorithm;
  unsigned char  labels;
  unsigned int   original_ttl;
  unsigned int   expiration;
  unsigned int   inception;
  unsigned short key_tag;
  char          *signers_name;
  unsigned char *signature;
  size_t         signature_len;
} ares_dns_sig_t;

typedef struct {
  struct ares_in6_addr addr;
} ares_dns_aaaa_t;

typedef struct {
  unsigned short priority;
  unsigned short weight;
  unsigned short port;
  char          *target;
} ares_dns_srv_t;

typedef struct {
  unsigned short order;
  unsigned short preference;
  char          *flags;
  char          *services;
  char          *regexp;
  char          *replacement;
} ares_dns_naptr_t;

typedef struct {
  unsigned short opt;
  unsigned char *val;
  size_t         val_len;
} ares_dns_optval_t;

typedef struct {
  unsigned short udp_size; /*!< taken from class */
  unsigned char  version;  /*!< taken from bits 8-16 of ttl */
  unsigned short flags;    /*!< Flags, remaining 16 bits, though only
                            *   1 currently defined */
  ares_array_t  *options;  /*!< Type is ares_dns_optval_t */
} ares_dns_opt_t;

typedef struct {
  unsigned char  cert_usage;
  unsigned char  selector;
  unsigned char  match;
  unsigned char *data;
  size_t         data_len;
} ares_dns_tlsa_t;

typedef struct {
  unsigned short priority;
  char          *target;
  ares_array_t  *params; /*!< Type is ares_dns_optval_t */
} ares_dns_svcb_t;

typedef struct {
  unsigned short priority;
  unsigned short weight;
  char          *target;
} ares_dns_uri_t;

typedef struct {
  unsigned char  critical;
  char          *tag;
  unsigned char *value;
  size_t         value_len;
} ares_dns_caa_t;

/*! Raw, unparsed RR data */
typedef struct {
  unsigned short type;   /*!< Not ares_rec_type_t because it likely isn't one
                          *   of those values since it wasn't parsed */
  unsigned char *data;   /*!< Raw RR data */
  size_t         length; /*!< Length of raw RR data */
} ares_dns_raw_rr_t;

/*! DNS RR data structure */
struct ares_dns_rr {
  ares_dns_record_t  *parent;
  char               *name;
  ares_dns_rec_type_t type;
  ares_dns_class_t    rclass;
  unsigned int        ttl;

  union {
    ares_dns_a_t      a;
    ares_dns_ns_t     ns;
    ares_dns_cname_t  cname;
    ares_dns_soa_t    soa;
    ares_dns_ptr_t    ptr;
    ares_dns_hinfo_t  hinfo;
    ares_dns_mx_t     mx;
    ares_dns_txt_t    txt;
    ares_dns_sig_t    sig;
    ares_dns_aaaa_t   aaaa;
    ares_dns_srv_t    srv;
    ares_dns_naptr_t  naptr;
    ares_dns_opt_t    opt;
    ares_dns_tlsa_t   tlsa;
    ares_dns_svcb_t   svcb;
    ares_dns_svcb_t   https; /*!< https is a type of svcb, so this is right */
    ares_dns_uri_t    uri;
    ares_dns_caa_t    caa;
    ares_dns_raw_rr_t raw_rr;
  } r;
};

/*! DNS data structure */
struct ares_dns_record {
  unsigned short    id;            /*!< DNS query id */
  unsigned short    flags;         /*!< One or more ares_dns_flags_t */
  ares_dns_opcode_t opcode;        /*!< DNS Opcode */
  ares_dns_rcode_t  rcode;         /*!< DNS RCODE */
  unsigned short    raw_rcode;     /*!< Raw rcode, used to ultimately form real
                                    *   rcode after reading OPT record if it
                                    *   exists */
  unsigned int      ttl_decrement; /*!< Special case to apply to writing out
                                    *   this record, where it will decrement
                                    *   the ttl of any resource records by
                                    *   this amount.  Used for cache */

  ares_array_t     *qd;            /*!< Type is ares_dns_qd_t */
  ares_array_t     *an;            /*!< Type is ares_dns_rr_t */
  ares_array_t     *ns;            /*!< Type is ares_dns_rr_t */
  ares_array_t     *ar;            /*!< Type is ares_dns_rr_t */
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/cares/src/lib/record/ares_dns_record.c                                             0000664 0000000 0000000 00000115257 14746647661 0022733 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include <limits.h>
#ifdef HAVE_STDINT_H
#  include <stdint.h>
#endif

static void ares_dns_rr_free(ares_dns_rr_t *rr);

static void ares_dns_qd_free_cb(void *arg)
{
  ares_dns_qd_t *qd = arg;
  if (qd == NULL) {
    return;
  }
  ares_free(qd->name);
}

static void ares_dns_rr_free_cb(void *arg)
{
  ares_dns_rr_t *rr = arg;
  if (rr == NULL) {
    return;
  }
  ares_dns_rr_free(rr);
}

ares_status_t ares_dns_record_create(ares_dns_record_t **dnsrec,
                                     unsigned short id, unsigned short flags,
                                     ares_dns_opcode_t opcode,
                                     ares_dns_rcode_t  rcode)
{
  if (dnsrec == NULL) {
    return ARES_EFORMERR;
  }

  *dnsrec = NULL;

  if (!ares_dns_opcode_isvalid(opcode) || !ares_dns_rcode_isvalid(rcode) ||
      !ares_dns_flags_arevalid(flags)) {
    return ARES_EFORMERR;
  }

  *dnsrec = ares_malloc_zero(sizeof(**dnsrec));
  if (*dnsrec == NULL) {
    return ARES_ENOMEM;
  }

  (*dnsrec)->id     = id;
  (*dnsrec)->flags  = flags;
  (*dnsrec)->opcode = opcode;
  (*dnsrec)->rcode  = rcode;
  (*dnsrec)->qd = ares_array_create(sizeof(ares_dns_qd_t), ares_dns_qd_free_cb);
  (*dnsrec)->an = ares_array_create(sizeof(ares_dns_rr_t), ares_dns_rr_free_cb);
  (*dnsrec)->ns = ares_array_create(sizeof(ares_dns_rr_t), ares_dns_rr_free_cb);
  (*dnsrec)->ar = ares_array_create(sizeof(ares_dns_rr_t), ares_dns_rr_free_cb);

  if ((*dnsrec)->qd == NULL || (*dnsrec)->an == NULL || (*dnsrec)->ns == NULL ||
      (*dnsrec)->ar == NULL) {
    ares_dns_record_destroy(*dnsrec);
    *dnsrec = NULL;
    return ARES_ENOMEM;
  }

  return ARES_SUCCESS;
}

unsigned short ares_dns_record_get_id(const ares_dns_record_t *dnsrec)
{
  if (dnsrec == NULL) {
    return 0;
  }
  return dnsrec->id;
}

ares_bool_t ares_dns_record_set_id(ares_dns_record_t *dnsrec, unsigned short id)
{
  if (dnsrec == NULL) {
    return ARES_FALSE;
  }
  dnsrec->id = id;
  return ARES_TRUE;
}

unsigned short ares_dns_record_get_flags(const ares_dns_record_t *dnsrec)
{
  if (dnsrec == NULL) {
    return 0;
  }
  return dnsrec->flags;
}

ares_dns_opcode_t ares_dns_record_get_opcode(const ares_dns_record_t *dnsrec)
{
  if (dnsrec == NULL) {
    return 0;
  }
  return dnsrec->opcode;
}

ares_dns_rcode_t ares_dns_record_get_rcode(const ares_dns_record_t *dnsrec)
{
  if (dnsrec == NULL) {
    return 0;
  }
  return dnsrec->rcode;
}

static void ares_dns_rr_free(ares_dns_rr_t *rr)
{
  ares_free(rr->name);

  switch (rr->type) {
    case ARES_REC_TYPE_A:
    case ARES_REC_TYPE_AAAA:
    case ARES_REC_TYPE_ANY:
      /* Nothing to free */
      break;

    case ARES_REC_TYPE_NS:
      ares_free(rr->r.ns.nsdname);
      break;

    case ARES_REC_TYPE_CNAME:
      ares_free(rr->r.cname.cname);
      break;

    case ARES_REC_TYPE_SOA:
      ares_free(rr->r.soa.mname);
      ares_free(rr->r.soa.rname);
      break;

    case ARES_REC_TYPE_PTR:
      ares_free(rr->r.ptr.dname);
      break;

    case ARES_REC_TYPE_HINFO:
      ares_free(rr->r.hinfo.cpu);
      ares_free(rr->r.hinfo.os);
      break;

    case ARES_REC_TYPE_MX:
      ares_free(rr->r.mx.exchange);
      break;

    case ARES_REC_TYPE_TXT:
      ares_dns_multistring_destroy(rr->r.txt.strs);
      break;

    case ARES_REC_TYPE_SIG:
      ares_free(rr->r.sig.signers_name);
      ares_free(rr->r.sig.signature);
      break;

    case ARES_REC_TYPE_SRV:
      ares_free(rr->r.srv.target);
      break;

    case ARES_REC_TYPE_NAPTR:
      ares_free(rr->r.naptr.flags);
      ares_free(rr->r.naptr.services);
      ares_free(rr->r.naptr.regexp);
      ares_free(rr->r.naptr.replacement);
      break;

    case ARES_REC_TYPE_OPT:
      ares_array_destroy(rr->r.opt.options);
      break;

    case ARES_REC_TYPE_TLSA:
      ares_free(rr->r.tlsa.data);
      break;

    case ARES_REC_TYPE_SVCB:
      ares_free(rr->r.svcb.target);
      ares_array_destroy(rr->r.svcb.params);
      break;

    case ARES_REC_TYPE_HTTPS:
      ares_free(rr->r.https.target);
      ares_array_destroy(rr->r.https.params);
      break;

    case ARES_REC_TYPE_URI:
      ares_free(rr->r.uri.target);
      break;

    case ARES_REC_TYPE_CAA:
      ares_free(rr->r.caa.tag);
      ares_free(rr->r.caa.value);
      break;

    case ARES_REC_TYPE_RAW_RR:
      ares_free(rr->r.raw_rr.data);
      break;
  }
}

void ares_dns_record_destroy(ares_dns_record_t *dnsrec)
{
  if (dnsrec == NULL) {
    return;
  }

  /* Free questions */
  ares_array_destroy(dnsrec->qd);

  /* Free answers */
  ares_array_destroy(dnsrec->an);

  /* Free authority */
  ares_array_destroy(dnsrec->ns);

  /* Free additional */
  ares_array_destroy(dnsrec->ar);

  ares_free(dnsrec);
}

size_t ares_dns_record_query_cnt(const ares_dns_record_t *dnsrec)
{
  if (dnsrec == NULL) {
    return 0;
  }
  return ares_array_len(dnsrec->qd);
}

ares_status_t ares_dns_record_query_add(ares_dns_record_t  *dnsrec,
                                        const char         *name,
                                        ares_dns_rec_type_t qtype,
                                        ares_dns_class_t    qclass)
{
  size_t         idx;
  ares_dns_qd_t *qd;
  ares_status_t  status;

  if (dnsrec == NULL || name == NULL ||
      !ares_dns_rec_type_isvalid(qtype, ARES_TRUE) ||
      !ares_dns_class_isvalid(qclass, qtype, ARES_TRUE)) {
    return ARES_EFORMERR;
  }

  idx    = ares_array_len(dnsrec->qd);
  status = ares_array_insert_last((void **)&qd, dnsrec->qd);
  if (status != ARES_SUCCESS) {
    return status;
  }

  qd->name = ares_strdup(name);
  if (qd->name == NULL) {
    ares_array_remove_at(dnsrec->qd, idx);
    return ARES_ENOMEM;
  }
  qd->qtype  = qtype;
  qd->qclass = qclass;
  return ARES_SUCCESS;
}

ares_status_t ares_dns_record_query_set_name(ares_dns_record_t *dnsrec,
                                             size_t idx, const char *name)
{
  char          *orig_name = NULL;
  ares_dns_qd_t *qd;

  if (dnsrec == NULL || idx >= ares_array_len(dnsrec->qd) || name == NULL) {
    return ARES_EFORMERR;
  }

  qd = ares_array_at(dnsrec->qd, idx);

  orig_name = qd->name;
  qd->name  = ares_strdup(name);
  if (qd->name == NULL) {
    qd->name = orig_name; /* LCOV_EXCL_LINE: OutOfMemory */
    return ARES_ENOMEM;   /* LCOV_EXCL_LINE: OutOfMemory */
  }

  ares_free(orig_name);
  return ARES_SUCCESS;
}

ares_status_t ares_dns_record_query_set_type(ares_dns_record_t  *dnsrec,
                                             size_t              idx,
                                             ares_dns_rec_type_t qtype)
{
  ares_dns_qd_t *qd;

  if (dnsrec == NULL || idx >= ares_array_len(dnsrec->qd) ||
      !ares_dns_rec_type_isvalid(qtype, ARES_TRUE)) {
    return ARES_EFORMERR;
  }

  qd        = ares_array_at(dnsrec->qd, idx);
  qd->qtype = qtype;

  return ARES_SUCCESS;
}

ares_status_t ares_dns_record_query_get(const ares_dns_record_t *dnsrec,
                                        size_t idx, const char **name,
                                        ares_dns_rec_type_t *qtype,
                                        ares_dns_class_t    *qclass)
{
  const ares_dns_qd_t *qd;
  if (dnsrec == NULL || idx >= ares_array_len(dnsrec->qd)) {
    return ARES_EFORMERR;
  }

  qd = ares_array_at(dnsrec->qd, idx);
  if (name != NULL) {
    *name = qd->name;
  }

  if (qtype != NULL) {
    *qtype = qd->qtype;
  }

  if (qclass != NULL) {
    *qclass = qd->qclass;
  }

  return ARES_SUCCESS;
}

size_t ares_dns_record_rr_cnt(const ares_dns_record_t *dnsrec,
                              ares_dns_section_t       sect)
{
  if (dnsrec == NULL || !ares_dns_section_isvalid(sect)) {
    return 0;
  }

  switch (sect) {
    case ARES_SECTION_ANSWER:
      return ares_array_len(dnsrec->an);
    case ARES_SECTION_AUTHORITY:
      return ares_array_len(dnsrec->ns);
    case ARES_SECTION_ADDITIONAL:
      return ares_array_len(dnsrec->ar);
  }

  return 0; /* LCOV_EXCL_LINE: DefensiveCoding */
}

ares_status_t ares_dns_record_rr_prealloc(ares_dns_record_t *dnsrec,
                                          ares_dns_section_t sect, size_t cnt)
{
  ares_array_t *arr = NULL;

  if (dnsrec == NULL || !ares_dns_section_isvalid(sect)) {
    return ARES_EFORMERR;
  }

  switch (sect) {
    case ARES_SECTION_ANSWER:
      arr = dnsrec->an;
      break;
    case ARES_SECTION_AUTHORITY:
      arr = dnsrec->ns;
      break;
    case ARES_SECTION_ADDITIONAL:
      arr = dnsrec->ar;
      break;
  }

  if (cnt < ares_array_len(arr)) {
    return ARES_EFORMERR;
  }

  return ares_array_set_size(arr, cnt);
}

ares_status_t ares_dns_record_rr_add(ares_dns_rr_t    **rr_out,
                                     ares_dns_record_t *dnsrec,
                                     ares_dns_section_t sect, const char *name,
                                     ares_dns_rec_type_t type,
                                     ares_dns_class_t rclass, unsigned int ttl)
{
  ares_dns_rr_t *rr  = NULL;
  ares_array_t  *arr = NULL;
  ares_status_t  status;
  size_t         idx;

  if (dnsrec == NULL || name == NULL || rr_out == NULL ||
      !ares_dns_section_isvalid(sect) ||
      !ares_dns_rec_type_isvalid(type, ARES_FALSE) ||
      !ares_dns_class_isvalid(rclass, type, ARES_FALSE)) {
    return ARES_EFORMERR;
  }

  *rr_out = NULL;

  switch (sect) {
    case ARES_SECTION_ANSWER:
      arr = dnsrec->an;
      break;
    case ARES_SECTION_AUTHORITY:
      arr = dnsrec->ns;
      break;
    case ARES_SECTION_ADDITIONAL:
      arr = dnsrec->ar;
      break;
  }

  idx    = ares_array_len(arr);
  status = ares_array_insert_last((void **)&rr, arr);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  rr->name = ares_strdup(name);
  if (rr->name == NULL) {
    ares_array_remove_at(arr, idx);
    return ARES_ENOMEM;
  }

  rr->parent = dnsrec;
  rr->type   = type;
  rr->rclass = rclass;
  rr->ttl    = ttl;

  *rr_out = rr;

  return ARES_SUCCESS;
}

ares_status_t ares_dns_record_rr_del(ares_dns_record_t *dnsrec,
                                     ares_dns_section_t sect, size_t idx)
{
  ares_array_t *arr = NULL;

  if (dnsrec == NULL || !ares_dns_section_isvalid(sect)) {
    return ARES_EFORMERR;
  }

  switch (sect) {
    case ARES_SECTION_ANSWER:
      arr = dnsrec->an;
      break;
    case ARES_SECTION_AUTHORITY:
      arr = dnsrec->ns;
      break;
    case ARES_SECTION_ADDITIONAL:
      arr = dnsrec->ar;
      break;
  }

  return ares_array_remove_at(arr, idx);
}

ares_dns_rr_t *ares_dns_record_rr_get(ares_dns_record_t *dnsrec,
                                      ares_dns_section_t sect, size_t idx)
{
  ares_array_t *arr = NULL;

  if (dnsrec == NULL || !ares_dns_section_isvalid(sect)) {
    return NULL;
  }

  switch (sect) {
    case ARES_SECTION_ANSWER:
      arr = dnsrec->an;
      break;
    case ARES_SECTION_AUTHORITY:
      arr = dnsrec->ns;
      break;
    case ARES_SECTION_ADDITIONAL:
      arr = dnsrec->ar;
      break;
  }

  return ares_array_at(arr, idx);
}

const ares_dns_rr_t *
  ares_dns_record_rr_get_const(const ares_dns_record_t *dnsrec,
                               ares_dns_section_t sect, size_t idx)
{
  return ares_dns_record_rr_get((void *)((size_t)dnsrec), sect, idx);
}

const char *ares_dns_rr_get_name(const ares_dns_rr_t *rr)
{
  if (rr == NULL) {
    return NULL;
  }
  return rr->name;
}

ares_dns_rec_type_t ares_dns_rr_get_type(const ares_dns_rr_t *rr)
{
  if (rr == NULL) {
    return 0;
  }
  return rr->type;
}

ares_dns_class_t ares_dns_rr_get_class(const ares_dns_rr_t *rr)
{
  if (rr == NULL) {
    return 0;
  }
  return rr->rclass;
}

unsigned int ares_dns_rr_get_ttl(const ares_dns_rr_t *rr)
{
  if (rr == NULL) {
    return 0;
  }
  return rr->ttl;
}

static void *ares_dns_rr_data_ptr(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,
                                  size_t **lenptr)
{
  if (dns_rr == NULL || dns_rr->type != ares_dns_rr_key_to_rec_type(key)) {
    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  switch (key) {
    case ARES_RR_A_ADDR:
      return &dns_rr->r.a.addr;

    case ARES_RR_NS_NSDNAME:
      return &dns_rr->r.ns.nsdname;

    case ARES_RR_CNAME_CNAME:
      return &dns_rr->r.cname.cname;

    case ARES_RR_SOA_MNAME:
      return &dns_rr->r.soa.mname;

    case ARES_RR_SOA_RNAME:
      return &dns_rr->r.soa.rname;

    case ARES_RR_SOA_SERIAL:
      return &dns_rr->r.soa.serial;

    case ARES_RR_SOA_REFRESH:
      return &dns_rr->r.soa.refresh;

    case ARES_RR_SOA_RETRY:
      return &dns_rr->r.soa.retry;

    case ARES_RR_SOA_EXPIRE:
      return &dns_rr->r.soa.expire;

    case ARES_RR_SOA_MINIMUM:
      return &dns_rr->r.soa.minimum;

    case ARES_RR_PTR_DNAME:
      return &dns_rr->r.ptr.dname;

    case ARES_RR_AAAA_ADDR:
      return &dns_rr->r.aaaa.addr;

    case ARES_RR_HINFO_CPU:
      return &dns_rr->r.hinfo.cpu;

    case ARES_RR_HINFO_OS:
      return &dns_rr->r.hinfo.os;

    case ARES_RR_MX_PREFERENCE:
      return &dns_rr->r.mx.preference;

    case ARES_RR_MX_EXCHANGE:
      return &dns_rr->r.mx.exchange;

    case ARES_RR_SIG_TYPE_COVERED:
      return &dns_rr->r.sig.type_covered;

    case ARES_RR_SIG_ALGORITHM:
      return &dns_rr->r.sig.algorithm;

    case ARES_RR_SIG_LABELS:
      return &dns_rr->r.sig.labels;

    case ARES_RR_SIG_ORIGINAL_TTL:
      return &dns_rr->r.sig.original_ttl;

    case ARES_RR_SIG_EXPIRATION:
      return &dns_rr->r.sig.expiration;

    case ARES_RR_SIG_INCEPTION:
      return &dns_rr->r.sig.inception;

    case ARES_RR_SIG_KEY_TAG:
      return &dns_rr->r.sig.key_tag;

    case ARES_RR_SIG_SIGNERS_NAME:
      return &dns_rr->r.sig.signers_name;

    case ARES_RR_SIG_SIGNATURE:
      if (lenptr == NULL) {
        return NULL;
      }
      *lenptr = &dns_rr->r.sig.signature_len;
      return &dns_rr->r.sig.signature;

    case ARES_RR_TXT_DATA:
      return &dns_rr->r.txt.strs;

    case ARES_RR_SRV_PRIORITY:
      return &dns_rr->r.srv.priority;

    case ARES_RR_SRV_WEIGHT:
      return &dns_rr->r.srv.weight;

    case ARES_RR_SRV_PORT:
      return &dns_rr->r.srv.port;

    case ARES_RR_SRV_TARGET:
      return &dns_rr->r.srv.target;

    case ARES_RR_NAPTR_ORDER:
      return &dns_rr->r.naptr.order;

    case ARES_RR_NAPTR_PREFERENCE:
      return &dns_rr->r.naptr.preference;

    case ARES_RR_NAPTR_FLAGS:
      return &dns_rr->r.naptr.flags;

    case ARES_RR_NAPTR_SERVICES:
      return &dns_rr->r.naptr.services;

    case ARES_RR_NAPTR_REGEXP:
      return &dns_rr->r.naptr.regexp;

    case ARES_RR_NAPTR_REPLACEMENT:
      return &dns_rr->r.naptr.replacement;

    case ARES_RR_OPT_UDP_SIZE:
      return &dns_rr->r.opt.udp_size;

    case ARES_RR_OPT_VERSION:
      return &dns_rr->r.opt.version;

    case ARES_RR_OPT_FLAGS:
      return &dns_rr->r.opt.flags;

    case ARES_RR_OPT_OPTIONS:
      return &dns_rr->r.opt.options;

    case ARES_RR_TLSA_CERT_USAGE:
      return &dns_rr->r.tlsa.cert_usage;

    case ARES_RR_TLSA_SELECTOR:
      return &dns_rr->r.tlsa.selector;

    case ARES_RR_TLSA_MATCH:
      return &dns_rr->r.tlsa.match;

    case ARES_RR_TLSA_DATA:
      if (lenptr == NULL) {
        return NULL;
      }
      *lenptr = &dns_rr->r.tlsa.data_len;
      return &dns_rr->r.tlsa.data;

    case ARES_RR_SVCB_PRIORITY:
      return &dns_rr->r.svcb.priority;

    case ARES_RR_SVCB_TARGET:
      return &dns_rr->r.svcb.target;

    case ARES_RR_SVCB_PARAMS:
      return &dns_rr->r.svcb.params;

    case ARES_RR_HTTPS_PRIORITY:
      return &dns_rr->r.https.priority;

    case ARES_RR_HTTPS_TARGET:
      return &dns_rr->r.https.target;

    case ARES_RR_HTTPS_PARAMS:
      return &dns_rr->r.https.params;

    case ARES_RR_URI_PRIORITY:
      return &dns_rr->r.uri.priority;

    case ARES_RR_URI_WEIGHT:
      return &dns_rr->r.uri.weight;

    case ARES_RR_URI_TARGET:
      return &dns_rr->r.uri.target;

    case ARES_RR_CAA_CRITICAL:
      return &dns_rr->r.caa.critical;

    case ARES_RR_CAA_TAG:
      return &dns_rr->r.caa.tag;

    case ARES_RR_CAA_VALUE:
      if (lenptr == NULL) {
        return NULL;
      }
      *lenptr = &dns_rr->r.caa.value_len;
      return &dns_rr->r.caa.value;

    case ARES_RR_RAW_RR_TYPE:
      return &dns_rr->r.raw_rr.type;

    case ARES_RR_RAW_RR_DATA:
      if (lenptr == NULL) {
        return NULL;
      }
      *lenptr = &dns_rr->r.raw_rr.length;
      return &dns_rr->r.raw_rr.data;
  }

  return NULL;
}

static const void *ares_dns_rr_data_ptr_const(const ares_dns_rr_t *dns_rr,
                                              ares_dns_rr_key_t    key,
                                              const size_t       **lenptr)
{
  /* We're going to cast off the const */
  return ares_dns_rr_data_ptr((void *)((size_t)dns_rr), key,
                              (void *)((size_t)lenptr));
}

const struct in_addr *ares_dns_rr_get_addr(const ares_dns_rr_t *dns_rr,
                                           ares_dns_rr_key_t    key)
{
  const struct in_addr *addr;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_INADDR) {
    return NULL;
  }

  addr = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);
  if (addr == NULL) {
    return NULL;
  }

  return addr;
}

const struct ares_in6_addr *ares_dns_rr_get_addr6(const ares_dns_rr_t *dns_rr,
                                                  ares_dns_rr_key_t    key)
{
  const struct ares_in6_addr *addr;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_INADDR6) {
    return NULL;
  }

  addr = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);
  if (addr == NULL) {
    return NULL;
  }

  return addr;
}

unsigned char ares_dns_rr_get_u8(const ares_dns_rr_t *dns_rr,
                                 ares_dns_rr_key_t    key)
{
  const unsigned char *u8;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U8) {
    return 0;
  }

  u8 = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);
  if (u8 == NULL) {
    return 0;
  }

  return *u8;
}

unsigned short ares_dns_rr_get_u16(const ares_dns_rr_t *dns_rr,
                                   ares_dns_rr_key_t    key)
{
  const unsigned short *u16;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U16) {
    return 0;
  }

  u16 = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);
  if (u16 == NULL) {
    return 0;
  }

  return *u16;
}

unsigned int ares_dns_rr_get_u32(const ares_dns_rr_t *dns_rr,
                                 ares_dns_rr_key_t    key)
{
  const unsigned int *u32;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U32) {
    return 0;
  }

  u32 = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);
  if (u32 == NULL) {
    return 0;
  }

  return *u32;
}

const unsigned char *ares_dns_rr_get_bin(const ares_dns_rr_t *dns_rr,
                                         ares_dns_rr_key_t key, size_t *len)
{
  unsigned char * const *bin     = NULL;
  size_t const          *bin_len = NULL;

  if ((ares_dns_rr_key_datatype(key) != ARES_DATATYPE_BIN &&
       ares_dns_rr_key_datatype(key) != ARES_DATATYPE_BINP &&
       ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) ||
      len == NULL) {
    return NULL;
  }

  /* Array of strings, return concatenated version */
  if (ares_dns_rr_key_datatype(key) == ARES_DATATYPE_ABINP) {
    ares_dns_multistring_t * const *strs =
      ares_dns_rr_data_ptr_const(dns_rr, key, NULL);

    if (strs == NULL) {
      return NULL;
    }

    return ares_dns_multistring_combined(*strs, len);
  }

  /* Not a multi-string, just straight binary data */
  bin = ares_dns_rr_data_ptr_const(dns_rr, key, &bin_len);
  if (bin == NULL) {
    return NULL;
  }

  /* Shouldn't be possible */
  if (bin_len == NULL) {
    return NULL;
  }
  *len = *bin_len;

  return *bin;
}

size_t ares_dns_rr_get_abin_cnt(const ares_dns_rr_t *dns_rr,
                                ares_dns_rr_key_t    key)
{
  ares_dns_multistring_t * const *strs;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) {
    return 0;
  }

  strs = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);
  if (strs == NULL) {
    return 0;
  }

  return ares_dns_multistring_cnt(*strs);
}

const unsigned char *ares_dns_rr_get_abin(const ares_dns_rr_t *dns_rr,
                                          ares_dns_rr_key_t key, size_t idx,
                                          size_t *len)
{
  ares_dns_multistring_t * const *strs;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) {
    return NULL;
  }

  strs = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);
  if (strs == NULL) {
    return NULL;
  }

  return ares_dns_multistring_get(*strs, idx, len);
}

ares_status_t ares_dns_rr_del_abin(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,
                                   size_t idx)
{
  ares_dns_multistring_t **strs;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) {
    return ARES_EFORMERR;
  }

  strs = ares_dns_rr_data_ptr(dns_rr, key, NULL);
  if (strs == NULL) {
    return ARES_EFORMERR;
  }

  return ares_dns_multistring_del(*strs, idx);
}

ares_status_t ares_dns_rr_add_abin(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,
                                   const unsigned char *val, size_t len)
{
  ares_status_t       status;
  ares_dns_datatype_t datatype = ares_dns_rr_key_datatype(key);
  ares_bool_t         is_nullterm =
    (datatype == ARES_DATATYPE_ABINP) ? ARES_TRUE : ARES_FALSE;
  size_t                   alloclen = is_nullterm ? len + 1 : len;
  unsigned char           *temp;
  ares_dns_multistring_t **strs;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) {
    return ARES_EFORMERR;
  }

  strs = ares_dns_rr_data_ptr(dns_rr, key, NULL);
  if (strs == NULL) {
    return ARES_EFORMERR;
  }

  if (*strs == NULL) {
    *strs = ares_dns_multistring_create();
    if (*strs == NULL) {
      return ARES_ENOMEM;
    }
  }

  temp = ares_malloc(alloclen);
  if (temp == NULL) {
    return ARES_ENOMEM;
  }

  memcpy(temp, val, len);

  /* NULL-term ABINP */
  if (is_nullterm) {
    temp[len] = 0;
  }

  status = ares_dns_multistring_add_own(*strs, temp, len);
  if (status != ARES_SUCCESS) {
    ares_free(temp);
  }

  return status;
}

const char *ares_dns_rr_get_str(const ares_dns_rr_t *dns_rr,
                                ares_dns_rr_key_t    key)
{
  char * const *str;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_STR &&
      ares_dns_rr_key_datatype(key) != ARES_DATATYPE_NAME) {
    return NULL;
  }

  str = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);
  if (str == NULL) {
    return NULL;
  }

  return *str;
}

size_t ares_dns_rr_get_opt_cnt(const ares_dns_rr_t *dns_rr,
                               ares_dns_rr_key_t    key)
{
  ares_array_t * const *opts;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {
    return 0;
  }

  opts = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);
  if (opts == NULL || *opts == NULL) {
    return 0;
  }

  return ares_array_len(*opts);
}

unsigned short ares_dns_rr_get_opt(const ares_dns_rr_t *dns_rr,
                                   ares_dns_rr_key_t key, size_t idx,
                                   const unsigned char **val, size_t *val_len)
{
  ares_array_t * const    *opts;
  const ares_dns_optval_t *opt;

  if (val) {
    *val = NULL;
  }
  if (val_len) {
    *val_len = 0;
  }

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {
    return 65535;
  }

  opts = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);
  if (opts == NULL || *opts == NULL) {
    return 65535;
  }

  opt = ares_array_at(*opts, idx);
  if (opt == NULL) {
    return 65535;
  }

  if (val) {
    *val = opt->val;
  }
  if (val_len) {
    *val_len = opt->val_len;
  }

  return opt->opt;
}

ares_bool_t ares_dns_rr_get_opt_byid(const ares_dns_rr_t *dns_rr,
                                     ares_dns_rr_key_t key, unsigned short opt,
                                     const unsigned char **val, size_t *val_len)
{
  ares_array_t * const    *opts;
  size_t                   i;
  size_t                   cnt;
  const ares_dns_optval_t *optptr = NULL;

  if (val) {
    *val = NULL;
  }
  if (val_len) {
    *val_len = 0;
  }

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {
    return ARES_FALSE;
  }

  opts = ares_dns_rr_data_ptr_const(dns_rr, key, NULL);
  if (opts == NULL || *opts == NULL) {
    return ARES_FALSE;
  }

  cnt = ares_array_len(*opts);
  for (i = 0; i < cnt; i++) {
    optptr = ares_array_at(*opts, i);
    if (optptr == NULL) {
      return ARES_FALSE;
    }
    if (optptr->opt == opt) {
      break;
    }
  }

  if (i >= cnt || optptr == NULL) {
    return ARES_FALSE;
  }

  if (val) {
    *val = optptr->val;
  }
  if (val_len) {
    *val_len = optptr->val_len;
  }
  return ARES_TRUE;
}

ares_status_t ares_dns_rr_set_addr(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,
                                   const struct in_addr *addr)
{
  struct in_addr *a;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_INADDR || addr == NULL) {
    return ARES_EFORMERR;
  }

  a = ares_dns_rr_data_ptr(dns_rr, key, NULL);
  if (a == NULL) {
    return ARES_EFORMERR;
  }

  memcpy(a, addr, sizeof(*a));
  return ARES_SUCCESS;
}

ares_status_t ares_dns_rr_set_addr6(ares_dns_rr_t              *dns_rr,
                                    ares_dns_rr_key_t           key,
                                    const struct ares_in6_addr *addr)
{
  struct ares_in6_addr *a;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_INADDR6 || addr == NULL) {
    return ARES_EFORMERR;
  }

  a = ares_dns_rr_data_ptr(dns_rr, key, NULL);
  if (a == NULL) {
    return ARES_EFORMERR;
  }

  memcpy(a, addr, sizeof(*a));
  return ARES_SUCCESS;
}

ares_status_t ares_dns_rr_set_u8(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,
                                 unsigned char val)
{
  unsigned char *u8;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U8) {
    return ARES_EFORMERR;
  }

  u8 = ares_dns_rr_data_ptr(dns_rr, key, NULL);
  if (u8 == NULL) {
    return ARES_EFORMERR;
  }

  *u8 = val;
  return ARES_SUCCESS;
}

ares_status_t ares_dns_rr_set_u16(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,
                                  unsigned short val)
{
  unsigned short *u16;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U16) {
    return ARES_EFORMERR;
  }

  u16 = ares_dns_rr_data_ptr(dns_rr, key, NULL);
  if (u16 == NULL) {
    return ARES_EFORMERR;
  }

  *u16 = val;
  return ARES_SUCCESS;
}

ares_status_t ares_dns_rr_set_u32(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,
                                  unsigned int val)
{
  unsigned int *u32;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U32) {
    return ARES_EFORMERR;
  }

  u32 = ares_dns_rr_data_ptr(dns_rr, key, NULL);
  if (u32 == NULL) {
    return ARES_EFORMERR;
  }

  *u32 = val;
  return ARES_SUCCESS;
}

ares_status_t ares_dns_rr_set_bin_own(ares_dns_rr_t    *dns_rr,
                                      ares_dns_rr_key_t key, unsigned char *val,
                                      size_t len)
{
  unsigned char **bin;
  size_t         *bin_len = NULL;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_BIN &&
      ares_dns_rr_key_datatype(key) != ARES_DATATYPE_BINP &&
      ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) {
    return ARES_EFORMERR;
  }

  if (ares_dns_rr_key_datatype(key) == ARES_DATATYPE_ABINP) {
    ares_dns_multistring_t **strs = ares_dns_rr_data_ptr(dns_rr, key, NULL);
    if (strs == NULL) {
      return ARES_EFORMERR;
    }

    if (*strs == NULL) {
      *strs = ares_dns_multistring_create();
      if (*strs == NULL) {
        return ARES_ENOMEM;
      }
    }

    /* Clear all existing entries as this is an override */
    ares_dns_multistring_clear(*strs);

    return ares_dns_multistring_add_own(*strs, val, len);
  }

  bin = ares_dns_rr_data_ptr(dns_rr, key, &bin_len);
  if (bin == NULL || bin_len == NULL) {
    return ARES_EFORMERR;
  }

  if (*bin) {
    ares_free(*bin);
  }
  *bin     = val;
  *bin_len = len;

  return ARES_SUCCESS;
}

ares_status_t ares_dns_rr_set_bin(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,
                                  const unsigned char *val, size_t len)
{
  ares_status_t       status;
  ares_dns_datatype_t datatype = ares_dns_rr_key_datatype(key);
  ares_bool_t         is_nullterm =
    (datatype == ARES_DATATYPE_BINP || datatype == ARES_DATATYPE_ABINP)
              ? ARES_TRUE
              : ARES_FALSE;
  size_t         alloclen = is_nullterm ? len + 1 : len;
  unsigned char *temp     = ares_malloc(alloclen);

  if (temp == NULL) {
    return ARES_ENOMEM;
  }

  memcpy(temp, val, len);

  /* NULL-term BINP */
  if (is_nullterm) {
    temp[len] = 0;
  }

  status = ares_dns_rr_set_bin_own(dns_rr, key, temp, len);
  if (status != ARES_SUCCESS) {
    ares_free(temp);
  }

  return status;
}

ares_status_t ares_dns_rr_set_str_own(ares_dns_rr_t    *dns_rr,
                                      ares_dns_rr_key_t key, char *val)
{
  char **str;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_STR &&
      ares_dns_rr_key_datatype(key) != ARES_DATATYPE_NAME) {
    return ARES_EFORMERR;
  }

  str = ares_dns_rr_data_ptr(dns_rr, key, NULL);
  if (str == NULL) {
    return ARES_EFORMERR;
  }

  if (*str) {
    ares_free(*str);
  }
  *str = val;

  return ARES_SUCCESS;
}

ares_status_t ares_dns_rr_set_str(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,
                                  const char *val)
{
  ares_status_t status;
  char         *temp = NULL;

  if (val != NULL) {
    temp = ares_strdup(val);
    if (temp == NULL) {
      return ARES_ENOMEM;
    }
  }

  status = ares_dns_rr_set_str_own(dns_rr, key, temp);
  if (status != ARES_SUCCESS) {
    ares_free(temp);
  }

  return status;
}

ares_status_t ares_dns_rr_set_abin_own(ares_dns_rr_t          *dns_rr,
                                       ares_dns_rr_key_t       key,
                                       ares_dns_multistring_t *strs)
{
  ares_dns_multistring_t **strs_ptr;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_ABINP) {
    return ARES_EFORMERR;
  }

  strs_ptr = ares_dns_rr_data_ptr(dns_rr, key, NULL);
  if (strs_ptr == NULL) {
    return ARES_EFORMERR;
  }

  if (*strs_ptr != NULL) {
    ares_dns_multistring_destroy(*strs_ptr);
  }
  *strs_ptr = strs;

  return ARES_SUCCESS;
}

static void ares_dns_opt_free_cb(void *arg)
{
  ares_dns_optval_t *opt = arg;
  if (opt == NULL) {
    return;
  }
  ares_free(opt->val);
}

ares_status_t ares_dns_rr_set_opt_own(ares_dns_rr_t    *dns_rr,
                                      ares_dns_rr_key_t key, unsigned short opt,
                                      unsigned char *val, size_t val_len)
{
  ares_array_t     **options;
  ares_dns_optval_t *optptr = NULL;
  size_t             idx;
  size_t             cnt;
  ares_status_t      status;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {
    return ARES_EFORMERR;
  }

  options = ares_dns_rr_data_ptr(dns_rr, key, NULL);
  if (options == NULL) {
    return ARES_EFORMERR;
  }

  if (*options == NULL) {
    *options =
      ares_array_create(sizeof(ares_dns_optval_t), ares_dns_opt_free_cb);
  }
  if (*options == NULL) {
    return ARES_ENOMEM;
  }

  cnt = ares_array_len(*options);
  for (idx = 0; idx < cnt; idx++) {
    optptr = ares_array_at(*options, idx);
    if (optptr == NULL) {
      return ARES_EFORMERR;
    }
    if (optptr->opt == opt) {
      break;
    }
  }

  /* Duplicate entry, replace */
  if (idx != cnt && optptr != NULL) {
    goto done;
  }

  status = ares_array_insert_last((void **)&optptr, *options);
  if (status != ARES_SUCCESS) {
    return status;
  }

done:
  ares_free(optptr->val);
  optptr->opt     = opt;
  optptr->val     = val;
  optptr->val_len = val_len;

  return ARES_SUCCESS;
}

ares_status_t ares_dns_rr_set_opt(ares_dns_rr_t *dns_rr, ares_dns_rr_key_t key,
                                  unsigned short opt, const unsigned char *val,
                                  size_t val_len)
{
  unsigned char *temp = NULL;
  ares_status_t  status;

  if (val != NULL) {
    temp = ares_malloc(val_len + 1);
    if (temp == NULL) {
      return ARES_ENOMEM;
    }
    memcpy(temp, val, val_len);
    temp[val_len] = 0;
  }

  status = ares_dns_rr_set_opt_own(dns_rr, key, opt, temp, val_len);
  if (status != ARES_SUCCESS) {
    ares_free(temp);
  }

  return status;
}

ares_status_t ares_dns_rr_del_opt_byid(ares_dns_rr_t    *dns_rr,
                                       ares_dns_rr_key_t key,
                                       unsigned short    opt)
{
  ares_array_t           **options;
  const ares_dns_optval_t *optptr;
  size_t                   idx;
  size_t                   cnt;

  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_OPT) {
    return ARES_EFORMERR;
  }

  options = ares_dns_rr_data_ptr(dns_rr, key, NULL);
  if (options == NULL) {
    return ARES_EFORMERR;
  }

  /* No options */
  if (*options == NULL) {
    return ARES_SUCCESS;
  }

  cnt = ares_array_len(*options);
  for (idx = 0; idx < cnt; idx++) {
    optptr = ares_array_at_const(*options, idx);
    if (optptr == NULL) {
      return ARES_ENOTFOUND;
    }
    if (optptr->opt == opt) {
      return ares_array_remove_at(*options, idx);
    }
  }

  return ARES_ENOTFOUND;
}

char *ares_dns_addr_to_ptr(const struct ares_addr *addr)
{
  ares_buf_t                *buf     = NULL;
  const unsigned char       *ptr     = NULL;
  size_t                     ptr_len = 0;
  size_t                     i;
  ares_status_t              status;
  static const unsigned char hexbytes[] = "0123456789abcdef";

  if (addr->family != AF_INET && addr->family != AF_INET6) {
    goto fail;
  }

  buf = ares_buf_create();
  if (buf == NULL) {
    goto fail;
  }

  if (addr->family == AF_INET) {
    ptr     = (const unsigned char *)&addr->addr.addr4;
    ptr_len = 4;
  } else {
    ptr     = (const unsigned char *)&addr->addr.addr6;
    ptr_len = 16;
  }

  for (i = ptr_len; i > 0; i--) {
    if (addr->family == AF_INET) {
      status = ares_buf_append_num_dec(buf, (size_t)ptr[i - 1], 0);
    } else {
      unsigned char c;

      c      = ptr[i - 1] & 0xF;
      status = ares_buf_append_byte(buf, hexbytes[c]);
      if (status != ARES_SUCCESS) {
        goto fail;
      }

      status = ares_buf_append_byte(buf, '.');
      if (status != ARES_SUCCESS) {
        goto fail;
      }

      c      = (ptr[i - 1] >> 4) & 0xF;
      status = ares_buf_append_byte(buf, hexbytes[c]);
    }
    if (status != ARES_SUCCESS) {
      goto fail;
    }

    status = ares_buf_append_byte(buf, '.');
    if (status != ARES_SUCCESS) {
      goto fail;
    }
  }

  if (addr->family == AF_INET) {
    status = ares_buf_append(buf, (const unsigned char *)"in-addr.arpa", 12);
  } else {
    status = ares_buf_append(buf, (const unsigned char *)"ip6.arpa", 8);
  }
  if (status != ARES_SUCCESS) {
    goto fail;
  }

  return ares_buf_finish_str(buf, NULL);

fail:
  ares_buf_destroy(buf);
  return NULL;
}

ares_dns_rr_t *ares_dns_get_opt_rr(ares_dns_record_t *rec)
{
  size_t i;
  for (i = 0; i < ares_dns_record_rr_cnt(rec, ARES_SECTION_ADDITIONAL); i++) {
    ares_dns_rr_t *rr = ares_dns_record_rr_get(rec, ARES_SECTION_ADDITIONAL, i);

    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {
      return rr;
    }
  }
  return NULL;
}

const ares_dns_rr_t *ares_dns_get_opt_rr_const(const ares_dns_record_t *rec)
{
  size_t i;
  for (i = 0; i < ares_dns_record_rr_cnt(rec, ARES_SECTION_ADDITIONAL); i++) {
    const ares_dns_rr_t *rr =
      ares_dns_record_rr_get_const(rec, ARES_SECTION_ADDITIONAL, i);

    if (ares_dns_rr_get_type(rr) == ARES_REC_TYPE_OPT) {
      return rr;
    }
  }
  return NULL;
}

/* Construct a DNS record for a name with given class and type. Used internally
 * by ares_search() and ares_create_query().
 */
ares_status_t
  ares_dns_record_create_query(ares_dns_record_t **dnsrec, const char *name,
                               ares_dns_class_t    dnsclass,
                               ares_dns_rec_type_t type, unsigned short id,
                               ares_dns_flags_t flags, size_t max_udp_size)
{
  ares_status_t  status;
  ares_dns_rr_t *rr = NULL;

  if (dnsrec == NULL) {
    return ARES_EFORMERR;
  }

  *dnsrec = NULL;

  /* Per RFC 7686, reject queries for ".onion" domain names with NXDOMAIN */
  if (ares_is_onion_domain(name)) {
    status = ARES_ENOTFOUND;
    goto done;
  }

  status = ares_dns_record_create(dnsrec, id, (unsigned short)flags,
                                  ARES_OPCODE_QUERY, ARES_RCODE_NOERROR);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  status = ares_dns_record_query_add(*dnsrec, name, type, dnsclass);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  /* max_udp_size > 0 indicates EDNS, so send OPT RR as an additional record */
  if (max_udp_size > 0) {
    /* max_udp_size must fit into a 16 bit unsigned integer field on the OPT
     * RR, so check here that it fits
     */
    if (max_udp_size > 65535) {
      status = ARES_EFORMERR;
      goto done;
    }

    status = ares_dns_record_rr_add(&rr, *dnsrec, ARES_SECTION_ADDITIONAL, "",
                                    ARES_REC_TYPE_OPT, ARES_CLASS_IN, 0);
    if (status != ARES_SUCCESS) {
      goto done;
    }

    status = ares_dns_rr_set_u16(rr, ARES_RR_OPT_UDP_SIZE,
                                 (unsigned short)max_udp_size);
    if (status != ARES_SUCCESS) {
      goto done;
    }

    status = ares_dns_rr_set_u8(rr, ARES_RR_OPT_VERSION, 0);
    if (status != ARES_SUCCESS) {
      goto done;
    }

    status = ares_dns_rr_set_u16(rr, ARES_RR_OPT_FLAGS, 0);
    if (status != ARES_SUCCESS) {
      goto done;
    }
  }

done:
  if (status != ARES_SUCCESS) {
    ares_dns_record_destroy(*dnsrec);
    *dnsrec = NULL;
  }
  return status;
}

ares_status_t ares_dns_record_duplicate_ex(ares_dns_record_t      **dest,
                                           const ares_dns_record_t *src)
{
  unsigned char *data     = NULL;
  size_t         data_len = 0;
  ares_status_t  status;

  if (dest == NULL || src == NULL) {
    return ARES_EFORMERR;
  }

  *dest = NULL;

  status = ares_dns_write(src, &data, &data_len);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_parse(data, data_len, 0, dest);
  ares_free(data);

  return status;
}

ares_dns_record_t *ares_dns_record_duplicate(const ares_dns_record_t *dnsrec)
{
  ares_dns_record_t *dest = NULL;

  ares_dns_record_duplicate_ex(&dest, dnsrec);
  return dest;
}
                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/cares/src/lib/record/ares_dns_write.c                                              0000664 0000000 0000000 00000105523 14746647661 0022602 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include <limits.h>
#ifdef HAVE_STDINT_H
#  include <stdint.h>
#endif


static ares_status_t ares_dns_write_header(const ares_dns_record_t *dnsrec,
                                           ares_buf_t              *buf)
{
  unsigned short u16;
  unsigned short opcode;
  unsigned short rcode;

  ares_status_t  status;

  /* ID */
  status = ares_buf_append_be16(buf, dnsrec->id);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* Flags */
  u16 = 0;

  /* QR */
  if (dnsrec->flags & ARES_FLAG_QR) {
    u16 |= 0x8000;
  }

  /* OPCODE */
  opcode   = (unsigned short)(dnsrec->opcode & 0xF);
  opcode <<= 11;
  u16     |= opcode;

  /* AA */
  if (dnsrec->flags & ARES_FLAG_AA) {
    u16 |= 0x400;
  }

  /* TC */
  if (dnsrec->flags & ARES_FLAG_TC) {
    u16 |= 0x200;
  }

  /* RD */
  if (dnsrec->flags & ARES_FLAG_RD) {
    u16 |= 0x100;
  }

  /* RA */
  if (dnsrec->flags & ARES_FLAG_RA) {
    u16 |= 0x80;
  }

  /* Z -- unused */

  /* AD */
  if (dnsrec->flags & ARES_FLAG_AD) {
    u16 |= 0x20;
  }

  /* CD */
  if (dnsrec->flags & ARES_FLAG_CD) {
    u16 |= 0x10;
  }

  /* RCODE */
  if (dnsrec->rcode > 15 && ares_dns_get_opt_rr_const(dnsrec) == NULL) {
    /* Must have OPT RR in order to write extended error codes */
    rcode = ARES_RCODE_SERVFAIL;
  } else {
    rcode = (unsigned short)(dnsrec->rcode & 0xF);
  }
  u16 |= rcode;

  status = ares_buf_append_be16(buf, u16);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* QDCOUNT */
  status = ares_buf_append_be16(
    buf, (unsigned short)ares_dns_record_query_cnt(dnsrec));
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* ANCOUNT */
  status = ares_buf_append_be16(
    buf, (unsigned short)ares_dns_record_rr_cnt(dnsrec, ARES_SECTION_ANSWER));
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* NSCOUNT */
  status = ares_buf_append_be16(buf, (unsigned short)ares_dns_record_rr_cnt(
                                       dnsrec, ARES_SECTION_AUTHORITY));
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* ARCOUNT */
  status = ares_buf_append_be16(buf, (unsigned short)ares_dns_record_rr_cnt(
                                       dnsrec, ARES_SECTION_ADDITIONAL));
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  return ARES_SUCCESS;
}

static ares_status_t ares_dns_write_questions(const ares_dns_record_t *dnsrec,
                                              ares_llist_t           **namelist,
                                              ares_buf_t              *buf)
{
  size_t i;

  for (i = 0; i < ares_dns_record_query_cnt(dnsrec); i++) {
    ares_status_t       status;
    const char         *name = NULL;
    ares_dns_rec_type_t qtype;
    ares_dns_class_t    qclass;

    status = ares_dns_record_query_get(dnsrec, i, &name, &qtype, &qclass);
    if (status != ARES_SUCCESS) {
      return status;
    }

    /* Name */
    status = ares_dns_name_write(buf, namelist, ARES_TRUE, name);
    if (status != ARES_SUCCESS) {
      return status;
    }

    /* Type */
    status = ares_buf_append_be16(buf, (unsigned short)qtype);
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* Class */
    status = ares_buf_append_be16(buf, (unsigned short)qclass);
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  return ARES_SUCCESS;
}

static ares_status_t ares_dns_write_rr_name(ares_buf_t          *buf,
                                            const ares_dns_rr_t *rr,
                                            ares_llist_t       **namelist,
                                            ares_bool_t       validate_hostname,
                                            ares_dns_rr_key_t key)
{
  const char *name;

  name = ares_dns_rr_get_str(rr, key);
  if (name == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  return ares_dns_name_write(buf, namelist, validate_hostname, name);
}

static ares_status_t ares_dns_write_rr_str(ares_buf_t          *buf,
                                           const ares_dns_rr_t *rr,
                                           ares_dns_rr_key_t    key)
{
  const char   *str;
  size_t        len;
  ares_status_t status;

  str = ares_dns_rr_get_str(rr, key);
  if (str == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  len = ares_strlen(str);
  if (len > 255) {
    return ARES_EFORMERR;
  }

  /* Write 1 byte length */
  status = ares_buf_append_byte(buf, (unsigned char)(len & 0xFF));
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  if (len == 0) {
    return ARES_SUCCESS;
  }

  /* Write string */
  return ares_buf_append(buf, (const unsigned char *)str, len);
}

static ares_status_t ares_dns_write_binstr(ares_buf_t          *buf,
                                           const unsigned char *bin,
                                           size_t               bin_len)
{
  const unsigned char *ptr;
  size_t               ptr_len;
  ares_status_t        status;

  /* split into possible multiple 255-byte or less length strings */
  ptr     = bin;
  ptr_len = bin_len;
  do {
    size_t len = ptr_len;
    if (len > 255) {
      len = 255;
    }

    /* Length */
    status = ares_buf_append_byte(buf, (unsigned char)(len & 0xFF));
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* String */
    if (len) {
      status = ares_buf_append(buf, ptr, len);
      if (status != ARES_SUCCESS) {
        return status; /* LCOV_EXCL_LINE: OutOfMemory */
      }
    }

    ptr     += len;
    ptr_len -= len;
  } while (ptr_len > 0);

  return ARES_SUCCESS;
}

static ares_status_t ares_dns_write_rr_abin(ares_buf_t          *buf,
                                            const ares_dns_rr_t *rr,
                                            ares_dns_rr_key_t    key)
{
  ares_status_t status = ARES_EFORMERR;
  size_t        i;
  size_t        cnt = ares_dns_rr_get_abin_cnt(rr, key);

  if (cnt == 0) {
    return ARES_EFORMERR;
  }

  for (i = 0; i < cnt; i++) {
    const unsigned char *bin;
    size_t               bin_len;

    bin = ares_dns_rr_get_abin(rr, key, i, &bin_len);

    status = ares_dns_write_binstr(buf, bin, bin_len);
    if (status != ARES_SUCCESS) {
      break;
    }
  }

  return status;
}

static ares_status_t ares_dns_write_rr_be32(ares_buf_t          *buf,
                                            const ares_dns_rr_t *rr,
                                            ares_dns_rr_key_t    key)
{
  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U32) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }
  return ares_buf_append_be32(buf, ares_dns_rr_get_u32(rr, key));
}

static ares_status_t ares_dns_write_rr_be16(ares_buf_t          *buf,
                                            const ares_dns_rr_t *rr,
                                            ares_dns_rr_key_t    key)
{
  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U16) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }
  return ares_buf_append_be16(buf, ares_dns_rr_get_u16(rr, key));
}

static ares_status_t ares_dns_write_rr_u8(ares_buf_t          *buf,
                                          const ares_dns_rr_t *rr,
                                          ares_dns_rr_key_t    key)
{
  if (ares_dns_rr_key_datatype(key) != ARES_DATATYPE_U8) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }
  return ares_buf_append_byte(buf, ares_dns_rr_get_u8(rr, key));
}

static ares_status_t ares_dns_write_rr_a(ares_buf_t          *buf,
                                         const ares_dns_rr_t *rr,
                                         ares_llist_t       **namelist)
{
  const struct in_addr *addr;
  (void)namelist;

  addr = ares_dns_rr_get_addr(rr, ARES_RR_A_ADDR);
  if (addr == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  return ares_buf_append(buf, (const unsigned char *)addr, sizeof(*addr));
}

static ares_status_t ares_dns_write_rr_ns(ares_buf_t          *buf,
                                          const ares_dns_rr_t *rr,
                                          ares_llist_t       **namelist)
{
  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,
                                ARES_RR_NS_NSDNAME);
}

static ares_status_t ares_dns_write_rr_cname(ares_buf_t          *buf,
                                             const ares_dns_rr_t *rr,
                                             ares_llist_t       **namelist)
{
  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,
                                ARES_RR_CNAME_CNAME);
}

static ares_status_t ares_dns_write_rr_soa(ares_buf_t          *buf,
                                           const ares_dns_rr_t *rr,
                                           ares_llist_t       **namelist)
{
  ares_status_t status;

  /* MNAME */
  status =
    ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE, ARES_RR_SOA_MNAME);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* RNAME */
  status =
    ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE, ARES_RR_SOA_RNAME);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* SERIAL */
  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_SERIAL);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* REFRESH */
  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_REFRESH);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* RETRY */
  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_RETRY);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* EXPIRE */
  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_EXPIRE);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* MINIMUM */
  return ares_dns_write_rr_be32(buf, rr, ARES_RR_SOA_MINIMUM);
}

static ares_status_t ares_dns_write_rr_ptr(ares_buf_t          *buf,
                                           const ares_dns_rr_t *rr,
                                           ares_llist_t       **namelist)
{
  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,
                                ARES_RR_PTR_DNAME);
}

static ares_status_t ares_dns_write_rr_hinfo(ares_buf_t          *buf,
                                             const ares_dns_rr_t *rr,
                                             ares_llist_t       **namelist)
{
  ares_status_t status;

  (void)namelist;

  /* CPU */
  status = ares_dns_write_rr_str(buf, rr, ARES_RR_HINFO_CPU);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* OS */
  return ares_dns_write_rr_str(buf, rr, ARES_RR_HINFO_OS);
}

static ares_status_t ares_dns_write_rr_mx(ares_buf_t          *buf,
                                          const ares_dns_rr_t *rr,
                                          ares_llist_t       **namelist)
{
  ares_status_t status;

  /* PREFERENCE */
  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_MX_PREFERENCE);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* EXCHANGE */
  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,
                                ARES_RR_MX_EXCHANGE);
}

static ares_status_t ares_dns_write_rr_txt(ares_buf_t          *buf,
                                           const ares_dns_rr_t *rr,
                                           ares_llist_t       **namelist)
{
  (void)namelist;
  return ares_dns_write_rr_abin(buf, rr, ARES_RR_TXT_DATA);
}

static ares_status_t ares_dns_write_rr_sig(ares_buf_t          *buf,
                                           const ares_dns_rr_t *rr,
                                           ares_llist_t       **namelist)
{
  ares_status_t        status;
  const unsigned char *data;
  size_t               len = 0;

  (void)namelist;

  /* TYPE COVERED */
  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SIG_TYPE_COVERED);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* ALGORITHM */
  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_SIG_ALGORITHM);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* LABELS */
  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_SIG_LABELS);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* ORIGINAL TTL */
  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SIG_ORIGINAL_TTL);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* EXPIRATION */
  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SIG_EXPIRATION);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* INCEPTION */
  status = ares_dns_write_rr_be32(buf, rr, ARES_RR_SIG_INCEPTION);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* KEY TAG */
  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SIG_KEY_TAG);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* SIGNERS NAME */
  status = ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,
                                  ARES_RR_SIG_SIGNERS_NAME);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* SIGNATURE -- binary, rest of buffer, required to be non-zero length */
  data = ares_dns_rr_get_bin(rr, ARES_RR_SIG_SIGNATURE, &len);
  if (data == NULL || len == 0) {
    return ARES_EFORMERR;
  }

  return ares_buf_append(buf, data, len);
}

static ares_status_t ares_dns_write_rr_aaaa(ares_buf_t          *buf,
                                            const ares_dns_rr_t *rr,
                                            ares_llist_t       **namelist)
{
  const struct ares_in6_addr *addr;
  (void)namelist;

  addr = ares_dns_rr_get_addr6(rr, ARES_RR_AAAA_ADDR);
  if (addr == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  return ares_buf_append(buf, (const unsigned char *)addr, sizeof(*addr));
}

static ares_status_t ares_dns_write_rr_srv(ares_buf_t          *buf,
                                           const ares_dns_rr_t *rr,
                                           ares_llist_t       **namelist)
{
  ares_status_t status;

  /* PRIORITY */
  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SRV_PRIORITY);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* WEIGHT */
  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SRV_WEIGHT);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* PORT */
  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SRV_PORT);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* TARGET */
  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,
                                ARES_RR_SRV_TARGET);
}

static ares_status_t ares_dns_write_rr_naptr(ares_buf_t          *buf,
                                             const ares_dns_rr_t *rr,
                                             ares_llist_t       **namelist)
{
  ares_status_t status;

  /* ORDER */
  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_NAPTR_ORDER);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* PREFERENCE */
  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_NAPTR_PREFERENCE);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* FLAGS */
  status = ares_dns_write_rr_str(buf, rr, ARES_RR_NAPTR_FLAGS);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* SERVICES */
  status = ares_dns_write_rr_str(buf, rr, ARES_RR_NAPTR_SERVICES);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* REGEXP */
  status = ares_dns_write_rr_str(buf, rr, ARES_RR_NAPTR_REGEXP);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* REPLACEMENT */
  return ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE,
                                ARES_RR_NAPTR_REPLACEMENT);
}

static ares_status_t ares_dns_write_rr_opt(ares_buf_t          *buf,
                                           const ares_dns_rr_t *rr,
                                           ares_llist_t       **namelist)
{
  size_t         len = ares_buf_len(buf);
  ares_status_t  status;
  unsigned int   ttl = 0;
  size_t         i;
  unsigned short rcode = (unsigned short)((rr->parent->rcode >> 4) & 0xFF);

  (void)namelist;

  /* Coverity reports on this even though its not possible when taken
   * into context */
  if (len == 0) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* We need to go back and overwrite the class and ttl that were emitted as
   * the OPT record overloads them for its own use (yes, very strange!) */
  status = ares_buf_set_length(buf, len - 2 /* RDLENGTH */
                                      - 4   /* TTL */
                                      - 2 /* CLASS */);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Class -> UDP Size */
  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_OPT_UDP_SIZE);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* TTL -> rcode (u8) << 24 | version (u8) << 16 | flags (u16) */
  ttl |= (unsigned int)rcode << 24;
  ttl |= (unsigned int)ares_dns_rr_get_u8(rr, ARES_RR_OPT_VERSION) << 16;
  ttl |= (unsigned int)ares_dns_rr_get_u16(rr, ARES_RR_OPT_FLAGS);

  status = ares_buf_append_be32(buf, ttl);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* Now go back to real end */
  status = ares_buf_set_length(buf, len);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Append Options */
  for (i = 0; i < ares_dns_rr_get_opt_cnt(rr, ARES_RR_OPT_OPTIONS); i++) {
    unsigned short       opt;
    size_t               val_len;
    const unsigned char *val;

    opt = ares_dns_rr_get_opt(rr, ARES_RR_OPT_OPTIONS, i, &val, &val_len);

    /* BE16 option */
    status = ares_buf_append_be16(buf, opt);
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* BE16 length */
    status = ares_buf_append_be16(buf, (unsigned short)(val_len & 0xFFFF));
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* Value */
    if (val && val_len) {
      status = ares_buf_append(buf, val, val_len);
      if (status != ARES_SUCCESS) {
        return status; /* LCOV_EXCL_LINE: OutOfMemory */
      }
    }
  }

  return ARES_SUCCESS;
}

static ares_status_t ares_dns_write_rr_tlsa(ares_buf_t          *buf,
                                            const ares_dns_rr_t *rr,
                                            ares_llist_t       **namelist)
{
  ares_status_t        status;
  const unsigned char *data;
  size_t               len = 0;

  (void)namelist;

  /* CERT_USAGE */
  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_TLSA_CERT_USAGE);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* SELECTOR */
  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_TLSA_SELECTOR);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* MATCH */
  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_TLSA_MATCH);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* DATA -- binary, rest of buffer, required to be non-zero length */
  data = ares_dns_rr_get_bin(rr, ARES_RR_TLSA_DATA, &len);
  if (data == NULL || len == 0) {
    return ARES_EFORMERR;
  }

  return ares_buf_append(buf, data, len);
}

static ares_status_t ares_dns_write_rr_svcb(ares_buf_t          *buf,
                                            const ares_dns_rr_t *rr,
                                            ares_llist_t       **namelist)
{
  ares_status_t status;
  size_t        i;

  /* PRIORITY */
  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_SVCB_PRIORITY);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* TARGET */
  status =
    ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE, ARES_RR_SVCB_TARGET);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Append Params */
  for (i = 0; i < ares_dns_rr_get_opt_cnt(rr, ARES_RR_SVCB_PARAMS); i++) {
    unsigned short       opt;
    size_t               val_len;
    const unsigned char *val;

    opt = ares_dns_rr_get_opt(rr, ARES_RR_SVCB_PARAMS, i, &val, &val_len);

    /* BE16 option */
    status = ares_buf_append_be16(buf, opt);
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* BE16 length */
    status = ares_buf_append_be16(buf, (unsigned short)(val_len & 0xFFFF));
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* Value */
    if (val && val_len) {
      status = ares_buf_append(buf, val, val_len);
      if (status != ARES_SUCCESS) {
        return status; /* LCOV_EXCL_LINE: OutOfMemory */
      }
    }
  }
  return ARES_SUCCESS;
}

static ares_status_t ares_dns_write_rr_https(ares_buf_t          *buf,
                                             const ares_dns_rr_t *rr,
                                             ares_llist_t       **namelist)
{
  ares_status_t status;
  size_t        i;

  /* PRIORITY */
  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_HTTPS_PRIORITY);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* TARGET */
  status =
    ares_dns_write_rr_name(buf, rr, namelist, ARES_FALSE, ARES_RR_HTTPS_TARGET);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Append Params */
  for (i = 0; i < ares_dns_rr_get_opt_cnt(rr, ARES_RR_HTTPS_PARAMS); i++) {
    unsigned short       opt;
    size_t               val_len;
    const unsigned char *val;

    opt = ares_dns_rr_get_opt(rr, ARES_RR_HTTPS_PARAMS, i, &val, &val_len);

    /* BE16 option */
    status = ares_buf_append_be16(buf, opt);
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* BE16 length */
    status = ares_buf_append_be16(buf, (unsigned short)(val_len & 0xFFFF));
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* Value */
    if (val && val_len) {
      status = ares_buf_append(buf, val, val_len);
      if (status != ARES_SUCCESS) {
        return status; /* LCOV_EXCL_LINE: OutOfMemory */
      }
    }
  }
  return ARES_SUCCESS;
}

static ares_status_t ares_dns_write_rr_uri(ares_buf_t          *buf,
                                           const ares_dns_rr_t *rr,
                                           ares_llist_t       **namelist)
{
  ares_status_t status;
  const char   *target;

  (void)namelist;

  /* PRIORITY */
  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_URI_PRIORITY);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* WEIGHT */
  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_URI_WEIGHT);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* TARGET -- not in DNS string format, rest of buffer, required to be
   * non-zero length */
  target = ares_dns_rr_get_str(rr, ARES_RR_URI_TARGET);
  if (target == NULL || ares_strlen(target) == 0) {
    return ARES_EFORMERR;
  }

  return ares_buf_append(buf, (const unsigned char *)target,
                         ares_strlen(target));
}

static ares_status_t ares_dns_write_rr_caa(ares_buf_t          *buf,
                                           const ares_dns_rr_t *rr,
                                           ares_llist_t       **namelist)
{
  const unsigned char *data     = NULL;
  size_t               data_len = 0;
  ares_status_t        status;

  (void)namelist;

  /* CRITICAL */
  status = ares_dns_write_rr_u8(buf, rr, ARES_RR_CAA_CRITICAL);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* Tag */
  status = ares_dns_write_rr_str(buf, rr, ARES_RR_CAA_TAG);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* Value - binary! (remaining buffer */
  data = ares_dns_rr_get_bin(rr, ARES_RR_CAA_VALUE, &data_len);
  if (data == NULL || data_len == 0) {
    return ARES_EFORMERR;
  }

  return ares_buf_append(buf, data, data_len);
}

static ares_status_t ares_dns_write_rr_raw_rr(ares_buf_t          *buf,
                                              const ares_dns_rr_t *rr,
                                              ares_llist_t       **namelist)
{
  size_t               len = ares_buf_len(buf);
  ares_status_t        status;
  const unsigned char *data     = NULL;
  size_t               data_len = 0;

  (void)namelist;

  /* Coverity reports on this even though its not possible when taken
   * into context */
  if (len == 0) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* We need to go back and overwrite the type that was emitted by the parent
   * function */
  status = ares_buf_set_length(buf, len - 2 /* RDLENGTH */
                                      - 4   /* TTL */
                                      - 2   /* CLASS */
                                      - 2 /* TYPE */);
  if (status != ARES_SUCCESS) {
    return status;
  }

  status = ares_dns_write_rr_be16(buf, rr, ARES_RR_RAW_RR_TYPE);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* Now go back to real end */
  status = ares_buf_set_length(buf, len);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* Output raw data */
  data = ares_dns_rr_get_bin(rr, ARES_RR_RAW_RR_DATA, &data_len);
  if (data == NULL) {
    return ARES_EFORMERR;
  }

  if (data_len == 0) {
    return ARES_SUCCESS;
  }

  return ares_buf_append(buf, data, data_len);
}

static ares_status_t ares_dns_write_rr(const ares_dns_record_t *dnsrec,
                                       ares_llist_t           **namelist,
                                       ares_dns_section_t       section,
                                       ares_buf_t              *buf)
{
  size_t i;

  for (i = 0; i < ares_dns_record_rr_cnt(dnsrec, section); i++) {
    const ares_dns_rr_t *rr;
    ares_dns_rec_type_t  type;
    ares_bool_t          allow_compress;
    ares_llist_t       **namelistptr = NULL;
    size_t               pos_len;
    ares_status_t        status;
    size_t               rdlength;
    size_t               end_length;
    unsigned int         ttl;

    rr = ares_dns_record_rr_get_const(dnsrec, section, i);
    if (rr == NULL) {
      return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    type           = ares_dns_rr_get_type(rr);
    allow_compress = ares_dns_rec_allow_name_comp(type);
    if (allow_compress) {
      namelistptr = namelist;
    }

    /* Name */
    status =
      ares_dns_name_write(buf, namelist, ARES_TRUE, ares_dns_rr_get_name(rr));
    if (status != ARES_SUCCESS) {
      return status;
    }

    /* Type */
    status = ares_buf_append_be16(buf, (unsigned short)type);
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* Class */
    status =
      ares_buf_append_be16(buf, (unsigned short)ares_dns_rr_get_class(rr));
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* TTL */
    ttl = ares_dns_rr_get_ttl(rr);
    if (rr->parent->ttl_decrement > ttl) {
      ttl = 0;
    } else {
      ttl -= rr->parent->ttl_decrement;
    }
    status = ares_buf_append_be32(buf, ttl);
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* Length */
    pos_len = ares_buf_len(buf); /* Save to write real length later */
    status  = ares_buf_append_be16(buf, 0);
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    /* Data */
    switch (type) {
      case ARES_REC_TYPE_A:
        status = ares_dns_write_rr_a(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_NS:
        status = ares_dns_write_rr_ns(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_CNAME:
        status = ares_dns_write_rr_cname(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_SOA:
        status = ares_dns_write_rr_soa(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_PTR:
        status = ares_dns_write_rr_ptr(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_HINFO:
        status = ares_dns_write_rr_hinfo(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_MX:
        status = ares_dns_write_rr_mx(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_TXT:
        status = ares_dns_write_rr_txt(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_SIG:
        status = ares_dns_write_rr_sig(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_AAAA:
        status = ares_dns_write_rr_aaaa(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_SRV:
        status = ares_dns_write_rr_srv(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_NAPTR:
        status = ares_dns_write_rr_naptr(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_ANY:
        status = ARES_EFORMERR;
        break;
      case ARES_REC_TYPE_OPT:
        status = ares_dns_write_rr_opt(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_TLSA:
        status = ares_dns_write_rr_tlsa(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_SVCB:
        status = ares_dns_write_rr_svcb(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_HTTPS:
        status = ares_dns_write_rr_https(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_URI:
        status = ares_dns_write_rr_uri(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_CAA:
        status = ares_dns_write_rr_caa(buf, rr, namelistptr);
        break;
      case ARES_REC_TYPE_RAW_RR:
        status = ares_dns_write_rr_raw_rr(buf, rr, namelistptr);
        break;
    }

    if (status != ARES_SUCCESS) {
      return status;
    }

    /* Back off write pointer, write real length, then go back to proper
     * position */
    end_length = ares_buf_len(buf);
    rdlength   = end_length - pos_len - 2;

    status = ares_buf_set_length(buf, pos_len);
    if (status != ARES_SUCCESS) {
      return status;
    }

    status = ares_buf_append_be16(buf, (unsigned short)(rdlength & 0xFFFF));
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    status = ares_buf_set_length(buf, end_length);
    if (status != ARES_SUCCESS) {
      return status;
    }
  }

  return ARES_SUCCESS;
}

ares_status_t ares_dns_write_buf(const ares_dns_record_t *dnsrec,
                                 ares_buf_t              *buf)
{
  ares_llist_t *namelist = NULL;
  size_t        orig_len;
  ares_status_t status;

  if (dnsrec == NULL || buf == NULL) {
    return ARES_EFORMERR;
  }

  orig_len = ares_buf_len(buf);

  status = ares_dns_write_header(dnsrec, buf);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  status = ares_dns_write_questions(dnsrec, &namelist, buf);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  status = ares_dns_write_rr(dnsrec, &namelist, ARES_SECTION_ANSWER, buf);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  status = ares_dns_write_rr(dnsrec, &namelist, ARES_SECTION_AUTHORITY, buf);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  status = ares_dns_write_rr(dnsrec, &namelist, ARES_SECTION_ADDITIONAL, buf);
  if (status != ARES_SUCCESS) {
    goto done;
  }

done:
  ares_llist_destroy(namelist);
  if (status != ARES_SUCCESS) {
    ares_buf_set_length(buf, orig_len);
  }

  return status;
}

ares_status_t ares_dns_write_buf_tcp(const ares_dns_record_t *dnsrec,
                                     ares_buf_t              *buf)
{
  ares_status_t status;
  size_t        orig_len;
  size_t        msg_len;
  size_t        len;

  if (dnsrec == NULL || buf == NULL) {
    return ARES_EFORMERR;
  }

  orig_len = ares_buf_len(buf);

  /* Write placeholder for length */
  status = ares_buf_append_be16(buf, 0);
  if (status != ARES_SUCCESS) {
    goto done; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* Write message */
  status = ares_dns_write_buf(dnsrec, buf);
  if (status != ARES_SUCCESS) {
    goto done; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  len     = ares_buf_len(buf);
  msg_len = len - orig_len - 2;
  if (msg_len > 65535) {
    status = ARES_EBADQUERY;
    goto done;
  }

  /* Now we need to overwrite the length, so we jump back to the original
   * message length, overwrite the section and jump back */
  ares_buf_set_length(buf, orig_len);
  status = ares_buf_append_be16(buf, (unsigned short)(msg_len & 0xFFFF));
  if (status != ARES_SUCCESS) {
    goto done; /* LCOV_EXCL_LINE: UntestablePath */
  }
  ares_buf_set_length(buf, len);

done:
  if (status != ARES_SUCCESS) {
    ares_buf_set_length(buf, orig_len);
  }
  return status;
}

ares_status_t ares_dns_write(const ares_dns_record_t *dnsrec,
                             unsigned char **buf, size_t *buf_len)
{
  ares_buf_t   *b = NULL;
  ares_status_t status;

  if (buf == NULL || buf_len == NULL || dnsrec == NULL) {
    return ARES_EFORMERR;
  }

  *buf     = NULL;
  *buf_len = 0;

  b = ares_buf_create();
  if (b == NULL) {
    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  status = ares_dns_write_buf(dnsrec, b);

  if (status != ARES_SUCCESS) {
    ares_buf_destroy(b);
    return status;
  }

  *buf = ares_buf_finish_bin(b, buf_len);
  return status;
}

void ares_dns_record_ttl_decrement(ares_dns_record_t *dnsrec,
                                   unsigned int       ttl_decrement)
{
  if (dnsrec == NULL) {
    return;
  }
  dnsrec->ttl_decrement = ttl_decrement;
}
                                                                                                                                                                             node-23.7.0/deps/cares/src/lib/str/                                                                 0000775 0000000 0000000 00000000000 14746647661 0016752 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/str/ares_buf.c                                                       0000664 0000000 0000000 00000107637 14746647661 0020722 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"
#include "ares_buf.h"
#include <limits.h>
#ifdef HAVE_STDINT_H
#  include <stdint.h>
#endif

struct ares_buf {
  const unsigned char *data;          /*!< pointer to start of data buffer */
  size_t               data_len;      /*!< total size of data in buffer */

  unsigned char       *alloc_buf;     /*!< Pointer to allocated data buffer,
                                       *   not used for const buffers */
  size_t               alloc_buf_len; /*!< Size of allocated data buffer */

  size_t               offset;        /*!< Current working offset in buffer */
  size_t               tag_offset;    /*!< Tagged offset in buffer. Uses
                                       *   SIZE_MAX if not set. */
};

ares_buf_t *ares_buf_create(void)
{
  ares_buf_t *buf = ares_malloc_zero(sizeof(*buf));
  if (buf == NULL) {
    return NULL;
  }

  buf->tag_offset = SIZE_MAX;
  return buf;
}

ares_buf_t *ares_buf_create_const(const unsigned char *data, size_t data_len)
{
  ares_buf_t *buf;

  if (data == NULL || data_len == 0) {
    return NULL;
  }

  buf = ares_buf_create();
  if (buf == NULL) {
    return NULL;
  }

  buf->data     = data;
  buf->data_len = data_len;

  return buf;
}

void ares_buf_destroy(ares_buf_t *buf)
{
  if (buf == NULL) {
    return;
  }
  ares_free(buf->alloc_buf);
  ares_free(buf);
}

static ares_bool_t ares_buf_is_const(const ares_buf_t *buf)
{
  if (buf == NULL) {
    return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  if (buf->data != NULL && buf->alloc_buf == NULL) {
    return ARES_TRUE;
  }

  return ARES_FALSE;
}

void ares_buf_reclaim(ares_buf_t *buf)
{
  size_t prefix_size;
  size_t data_size;

  if (buf == NULL) {
    return;
  }

  if (ares_buf_is_const(buf)) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* Silence coverity.  All lengths are zero so would bail out later but
   * coverity doesn't know this */
  if (buf->alloc_buf == NULL) {
    return;
  }

  if (buf->tag_offset != SIZE_MAX && buf->tag_offset < buf->offset) {
    prefix_size = buf->tag_offset;
  } else {
    prefix_size = buf->offset;
  }

  if (prefix_size == 0) {
    return;
  }

  data_size = buf->data_len - prefix_size;

  memmove(buf->alloc_buf, buf->alloc_buf + prefix_size, data_size);
  buf->data      = buf->alloc_buf;
  buf->data_len  = data_size;
  buf->offset   -= prefix_size;
  if (buf->tag_offset != SIZE_MAX) {
    buf->tag_offset -= prefix_size;
  }
}

static ares_status_t ares_buf_ensure_space(ares_buf_t *buf, size_t needed_size)
{
  size_t         remaining_size;
  size_t         alloc_size;
  unsigned char *ptr;

  if (buf == NULL) {
    return ARES_EFORMERR;
  }

  if (ares_buf_is_const(buf)) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* When calling ares_buf_finish_str() we end up adding a null terminator,
   * so we want to ensure the size is always sufficient for this as we don't
   * want an ARES_ENOMEM at that point */
  needed_size++;

  /* No need to do an expensive move operation, we have enough to just append */
  remaining_size = buf->alloc_buf_len - buf->data_len;
  if (remaining_size >= needed_size) {
    return ARES_SUCCESS;
  }

  /* See if just moving consumed data frees up enough space */
  ares_buf_reclaim(buf);

  remaining_size = buf->alloc_buf_len - buf->data_len;
  if (remaining_size >= needed_size) {
    return ARES_SUCCESS;
  }

  alloc_size = buf->alloc_buf_len;

  /* Not yet started */
  if (alloc_size == 0) {
    alloc_size = 16; /* Always shifts 1, so ends up being 32 minimum */
  }

  /* Increase allocation by powers of 2 */
  do {
    alloc_size     <<= 1;
    remaining_size   = alloc_size - buf->data_len;
  } while (remaining_size < needed_size);

  ptr = ares_realloc(buf->alloc_buf, alloc_size);
  if (ptr == NULL) {
    return ARES_ENOMEM;
  }

  buf->alloc_buf     = ptr;
  buf->alloc_buf_len = alloc_size;
  buf->data          = ptr;

  return ARES_SUCCESS;
}

ares_status_t ares_buf_set_length(ares_buf_t *buf, size_t len)
{
  if (buf == NULL || ares_buf_is_const(buf)) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  if (len >= buf->alloc_buf_len - buf->offset) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  buf->data_len = len + buf->offset;
  return ARES_SUCCESS;
}

ares_status_t ares_buf_append(ares_buf_t *buf, const unsigned char *data,
                              size_t data_len)
{
  ares_status_t status;

  if (data == NULL && data_len != 0) {
    return ARES_EFORMERR;
  }

  if (data_len == 0) {
    return ARES_SUCCESS;
  }

  status = ares_buf_ensure_space(buf, data_len);
  if (status != ARES_SUCCESS) {
    return status;
  }

  memcpy(buf->alloc_buf + buf->data_len, data, data_len);
  buf->data_len += data_len;
  return ARES_SUCCESS;
}

ares_status_t ares_buf_append_byte(ares_buf_t *buf, unsigned char b)
{
  return ares_buf_append(buf, &b, 1);
}

ares_status_t ares_buf_append_be16(ares_buf_t *buf, unsigned short u16)
{
  ares_status_t status;

  status = ares_buf_append_byte(buf, (unsigned char)((u16 >> 8) & 0xff));
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  status = ares_buf_append_byte(buf, (unsigned char)(u16 & 0xff));
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  return ARES_SUCCESS;
}

ares_status_t ares_buf_append_be32(ares_buf_t *buf, unsigned int u32)
{
  ares_status_t status;

  status = ares_buf_append_byte(buf, ((unsigned char)(u32 >> 24) & 0xff));
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  status = ares_buf_append_byte(buf, ((unsigned char)(u32 >> 16) & 0xff));
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  status = ares_buf_append_byte(buf, ((unsigned char)(u32 >> 8) & 0xff));
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  status = ares_buf_append_byte(buf, ((unsigned char)u32 & 0xff));
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  return ARES_SUCCESS;
}

unsigned char *ares_buf_append_start(ares_buf_t *buf, size_t *len)
{
  ares_status_t status;

  if (len == NULL || *len == 0) {
    return NULL;
  }

  status = ares_buf_ensure_space(buf, *len);
  if (status != ARES_SUCCESS) {
    return NULL;
  }

  /* -1 for possible null terminator for ares_buf_finish_str() */
  *len = buf->alloc_buf_len - buf->data_len - 1;
  return buf->alloc_buf + buf->data_len;
}

void ares_buf_append_finish(ares_buf_t *buf, size_t len)
{
  if (buf == NULL) {
    return;
  }

  buf->data_len += len;
}

unsigned char *ares_buf_finish_bin(ares_buf_t *buf, size_t *len)
{
  unsigned char *ptr = NULL;
  if (buf == NULL || len == NULL || ares_buf_is_const(buf)) {
    return NULL;
  }

  ares_buf_reclaim(buf);

  /* We don't want to return NULL except on failure, may be zero-length */
  if (buf->alloc_buf == NULL && ares_buf_ensure_space(buf, 1) != ARES_SUCCESS) {
    return NULL; /* LCOV_EXCL_LINE: OutOfMemory */
  }
  ptr  = buf->alloc_buf;
  *len = buf->data_len;
  ares_free(buf);
  return ptr;
}

char *ares_buf_finish_str(ares_buf_t *buf, size_t *len)
{
  char  *ptr;
  size_t mylen;

  ptr = (char *)ares_buf_finish_bin(buf, &mylen);
  if (ptr == NULL) {
    return NULL;
  }

  if (len != NULL) {
    *len = mylen;
  }

  /* NOTE: ensured via ares_buf_ensure_space() that there is always at least
   *       1 extra byte available for this specific use-case */
  ptr[mylen] = 0;

  return ptr;
}

void ares_buf_tag(ares_buf_t *buf)
{
  if (buf == NULL) {
    return;
  }

  buf->tag_offset = buf->offset;
}

ares_status_t ares_buf_tag_rollback(ares_buf_t *buf)
{
  if (buf == NULL || buf->tag_offset == SIZE_MAX) {
    return ARES_EFORMERR;
  }

  buf->offset     = buf->tag_offset;
  buf->tag_offset = SIZE_MAX;
  return ARES_SUCCESS;
}

ares_status_t ares_buf_tag_clear(ares_buf_t *buf)
{
  if (buf == NULL || buf->tag_offset == SIZE_MAX) {
    return ARES_EFORMERR;
  }

  buf->tag_offset = SIZE_MAX;
  return ARES_SUCCESS;
}

const unsigned char *ares_buf_tag_fetch(const ares_buf_t *buf, size_t *len)
{
  if (buf == NULL || buf->tag_offset == SIZE_MAX || len == NULL) {
    return NULL;
  }

  *len = buf->offset - buf->tag_offset;
  return buf->data + buf->tag_offset;
}

size_t ares_buf_tag_length(const ares_buf_t *buf)
{
  if (buf == NULL || buf->tag_offset == SIZE_MAX) {
    return 0;
  }
  return buf->offset - buf->tag_offset;
}

ares_status_t ares_buf_tag_fetch_bytes(const ares_buf_t *buf,
                                       unsigned char *bytes, size_t *len)
{
  size_t               ptr_len = 0;
  const unsigned char *ptr     = ares_buf_tag_fetch(buf, &ptr_len);

  if (ptr == NULL || bytes == NULL || len == NULL) {
    return ARES_EFORMERR;
  }

  if (*len < ptr_len) {
    return ARES_EFORMERR;
  }

  *len = ptr_len;

  if (ptr_len > 0) {
    memcpy(bytes, ptr, ptr_len);
  }
  return ARES_SUCCESS;
}

ares_status_t ares_buf_tag_fetch_constbuf(const ares_buf_t *buf,
                                          ares_buf_t      **newbuf)
{
  size_t               ptr_len = 0;
  const unsigned char *ptr     = ares_buf_tag_fetch(buf, &ptr_len);

  if (ptr == NULL || newbuf == NULL) {
    return ARES_EFORMERR;
  }

  *newbuf = ares_buf_create_const(ptr, ptr_len);
  if (*newbuf == NULL) {
    return ARES_ENOMEM;
  }
  return ARES_SUCCESS;
}

ares_status_t ares_buf_tag_fetch_string(const ares_buf_t *buf, char *str,
                                        size_t len)
{
  size_t        out_len;
  ares_status_t status;
  size_t        i;

  if (str == NULL || len == 0) {
    return ARES_EFORMERR;
  }

  /* Space for NULL terminator */
  out_len = len - 1;

  status = ares_buf_tag_fetch_bytes(buf, (unsigned char *)str, &out_len);
  if (status != ARES_SUCCESS) {
    return status;
  }

  /* NULL terminate */
  str[out_len] = 0;

  /* Validate string is printable */
  for (i = 0; i < out_len; i++) {
    if (!ares_isprint(str[i])) {
      return ARES_EBADSTR;
    }
  }

  return ARES_SUCCESS;
}

ares_status_t ares_buf_tag_fetch_strdup(const ares_buf_t *buf, char **str)
{
  size_t               ptr_len = 0;
  const unsigned char *ptr     = ares_buf_tag_fetch(buf, &ptr_len);

  if (ptr == NULL || str == NULL) {
    return ARES_EFORMERR;
  }

  if (!ares_str_isprint((const char *)ptr, ptr_len)) {
    return ARES_EBADSTR;
  }

  *str = ares_malloc(ptr_len + 1);
  if (*str == NULL) {
    return ARES_ENOMEM;
  }

  if (ptr_len > 0) {
    memcpy(*str, ptr, ptr_len);
  }
  (*str)[ptr_len] = 0;
  return ARES_SUCCESS;
}

static const unsigned char *ares_buf_fetch(const ares_buf_t *buf, size_t *len)
{
  if (len != NULL) {
    *len = 0;
  }

  if (buf == NULL || len == NULL || buf->data == NULL) {
    return NULL;
  }

  *len = buf->data_len - buf->offset;
  if (*len == 0) {
    return NULL;
  }

  return buf->data + buf->offset;
}

ares_status_t ares_buf_consume(ares_buf_t *buf, size_t len)
{
  size_t remaining_len = ares_buf_len(buf);

  if (remaining_len < len) {
    return ARES_EBADRESP;
  }

  buf->offset += len;
  return ARES_SUCCESS;
}

ares_status_t ares_buf_fetch_be16(ares_buf_t *buf, unsigned short *u16)
{
  size_t               remaining_len;
  const unsigned char *ptr = ares_buf_fetch(buf, &remaining_len);
  unsigned int         u32;

  if (buf == NULL || u16 == NULL || remaining_len < sizeof(*u16)) {
    return ARES_EBADRESP;
  }

  /* Do math in an unsigned int in order to prevent warnings due to automatic
   * conversion by the compiler from short to int during shifts */
  u32  = ((unsigned int)(ptr[0]) << 8 | (unsigned int)ptr[1]);
  *u16 = (unsigned short)(u32 & 0xFFFF);

  return ares_buf_consume(buf, sizeof(*u16));
}

ares_status_t ares_buf_fetch_be32(ares_buf_t *buf, unsigned int *u32)
{
  size_t               remaining_len;
  const unsigned char *ptr = ares_buf_fetch(buf, &remaining_len);

  if (buf == NULL || u32 == NULL || remaining_len < sizeof(*u32)) {
    return ARES_EBADRESP;
  }

  *u32 = ((unsigned int)(ptr[0]) << 24 | (unsigned int)(ptr[1]) << 16 |
          (unsigned int)(ptr[2]) << 8 | (unsigned int)(ptr[3]));

  return ares_buf_consume(buf, sizeof(*u32));
}

ares_status_t ares_buf_fetch_bytes(ares_buf_t *buf, unsigned char *bytes,
                                   size_t len)
{
  size_t               remaining_len;
  const unsigned char *ptr = ares_buf_fetch(buf, &remaining_len);

  if (buf == NULL || bytes == NULL || len == 0 || remaining_len < len) {
    return ARES_EBADRESP;
  }

  memcpy(bytes, ptr, len);
  return ares_buf_consume(buf, len);
}

ares_status_t ares_buf_fetch_bytes_dup(ares_buf_t *buf, size_t len,
                                       ares_bool_t     null_term,
                                       unsigned char **bytes)
{
  size_t               remaining_len;
  const unsigned char *ptr = ares_buf_fetch(buf, &remaining_len);

  if (buf == NULL || bytes == NULL || len == 0 || remaining_len < len) {
    return ARES_EBADRESP;
  }

  *bytes = ares_malloc(null_term ? len + 1 : len);
  if (*bytes == NULL) {
    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  memcpy(*bytes, ptr, len);
  if (null_term) {
    (*bytes)[len] = 0;
  }
  return ares_buf_consume(buf, len);
}

ares_status_t ares_buf_fetch_str_dup(ares_buf_t *buf, size_t len, char **str)
{
  size_t               remaining_len;
  size_t               i;
  const unsigned char *ptr = ares_buf_fetch(buf, &remaining_len);

  if (buf == NULL || str == NULL || len == 0 || remaining_len < len) {
    return ARES_EBADRESP;
  }

  /* Validate string is printable */
  for (i = 0; i < len; i++) {
    if (!ares_isprint(ptr[i])) {
      return ARES_EBADSTR;
    }
  }

  *str = ares_malloc(len + 1);
  if (*str == NULL) {
    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  memcpy(*str, ptr, len);
  (*str)[len] = 0;

  return ares_buf_consume(buf, len);
}

ares_status_t ares_buf_fetch_bytes_into_buf(ares_buf_t *buf, ares_buf_t *dest,
                                            size_t len)
{
  size_t               remaining_len;
  const unsigned char *ptr = ares_buf_fetch(buf, &remaining_len);
  ares_status_t        status;

  if (buf == NULL || dest == NULL || len == 0 || remaining_len < len) {
    return ARES_EBADRESP;
  }

  status = ares_buf_append(dest, ptr, len);
  if (status != ARES_SUCCESS) {
    return status;
  }

  return ares_buf_consume(buf, len);
}

static ares_bool_t ares_is_whitespace(unsigned char c,
                                      ares_bool_t   include_linefeed)
{
  switch (c) {
    case '\r':
    case '\t':
    case ' ':
    case '\v':
    case '\f':
      return ARES_TRUE;
    case '\n':
      return include_linefeed;
    default:
      break;
  }
  return ARES_FALSE;
}

size_t ares_buf_consume_whitespace(ares_buf_t *buf,
                                   ares_bool_t include_linefeed)
{
  size_t               remaining_len = 0;
  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);
  size_t               i;

  if (ptr == NULL) {
    return 0;
  }

  for (i = 0; i < remaining_len; i++) {
    if (!ares_is_whitespace(ptr[i], include_linefeed)) {
      break;
    }
  }

  if (i > 0) {
    ares_buf_consume(buf, i);
  }
  return i;
}

size_t ares_buf_consume_nonwhitespace(ares_buf_t *buf)
{
  size_t               remaining_len = 0;
  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);
  size_t               i;

  if (ptr == NULL) {
    return 0;
  }

  for (i = 0; i < remaining_len; i++) {
    if (ares_is_whitespace(ptr[i], ARES_TRUE)) {
      break;
    }
  }

  if (i > 0) {
    ares_buf_consume(buf, i);
  }
  return i;
}

size_t ares_buf_consume_line(ares_buf_t *buf, ares_bool_t include_linefeed)
{
  size_t               remaining_len = 0;
  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);
  size_t               i;

  if (ptr == NULL) {
    return 0;
  }

  for (i = 0; i < remaining_len; i++) {
    if (ptr[i] == '\n') {
      goto done;
    }
  }

done:
  if (include_linefeed && i < remaining_len && ptr[i] == '\n') {
    i++;
  }

  if (i > 0) {
    ares_buf_consume(buf, i);
  }
  return i;
}

size_t ares_buf_consume_until_charset(ares_buf_t          *buf,
                                      const unsigned char *charset, size_t len,
                                      ares_bool_t require_charset)
{
  size_t               remaining_len = 0;
  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);
  size_t               pos;
  ares_bool_t          found = ARES_FALSE;

  if (ptr == NULL || charset == NULL || len == 0) {
    return 0;
  }

  /* Optimize for single character searches */
  if (len == 1) {
    const unsigned char *p = memchr(ptr, charset[0], remaining_len);
    if (p != NULL) {
      found = ARES_TRUE;
      pos   = (size_t)(p - ptr);
    } else {
      pos = remaining_len;
    }
    goto done;
  }

  for (pos = 0; pos < remaining_len; pos++) {
    size_t j;
    for (j = 0; j < len; j++) {
      if (ptr[pos] == charset[j]) {
        found = ARES_TRUE;
        goto done;
      }
    }
  }

done:
  if (require_charset && !found) {
    return SIZE_MAX;
  }

  if (pos > 0) {
    ares_buf_consume(buf, pos);
  }
  return pos;
}

size_t ares_buf_consume_until_seq(ares_buf_t *buf, const unsigned char *seq,
                                  size_t len, ares_bool_t require_seq)
{
  size_t               remaining_len = 0;
  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);
  const unsigned char *p;
  size_t               consume_len = 0;

  if (ptr == NULL || seq == NULL || len == 0) {
    return 0;
  }

  p = ares_memmem(ptr, remaining_len, seq, len);
  if (require_seq && p == NULL) {
    return SIZE_MAX;
  }

  if (p != NULL) {
    consume_len = (size_t)(p - ptr);
  } else {
    consume_len = remaining_len;
  }

  if (consume_len > 0) {
    ares_buf_consume(buf, consume_len);
  }

  return consume_len;
}

size_t ares_buf_consume_charset(ares_buf_t *buf, const unsigned char *charset,
                                size_t len)
{
  size_t               remaining_len = 0;
  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);
  size_t               i;

  if (ptr == NULL || charset == NULL || len == 0) {
    return 0;
  }

  for (i = 0; i < remaining_len; i++) {
    size_t j;
    for (j = 0; j < len; j++) {
      if (ptr[i] == charset[j]) {
        break;
      }
    }
    /* Not found */
    if (j == len) {
      break;
    }
  }

  if (i > 0) {
    ares_buf_consume(buf, i);
  }
  return i;
}

static void ares_buf_destroy_cb(void *arg)
{
  ares_buf_t **buf = arg;
  ares_buf_destroy(*buf);
}

static ares_bool_t ares_buf_split_isduplicate(ares_array_t        *arr,
                                              const unsigned char *val,
                                              size_t               len,
                                              ares_buf_split_t     flags)
{
  size_t i;
  size_t num = ares_array_len(arr);

  for (i = 0; i < num; i++) {
    ares_buf_t         **bufptr = ares_array_at(arr, i);
    const ares_buf_t    *buf    = *bufptr;
    size_t               plen   = 0;
    const unsigned char *ptr    = ares_buf_peek(buf, &plen);

    /* Can't be duplicate if lengths mismatch */
    if (plen != len) {
      continue;
    }

    if (flags & ARES_BUF_SPLIT_CASE_INSENSITIVE) {
      if (ares_memeq_ci(ptr, val, len)) {
        return ARES_TRUE;
      }
    } else {
      if (ares_memeq(ptr, val, len)) {
        return ARES_TRUE;
      }
    }
  }

  return ARES_FALSE;
}

ares_status_t ares_buf_split(ares_buf_t *buf, const unsigned char *delims,
                             size_t delims_len, ares_buf_split_t flags,
                             size_t max_sections, ares_array_t **arr)
{
  ares_status_t status = ARES_SUCCESS;
  ares_bool_t   first  = ARES_TRUE;

  if (buf == NULL || delims == NULL || delims_len == 0 || arr == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  *arr = ares_array_create(sizeof(ares_buf_t *), ares_buf_destroy_cb);
  if (*arr == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  while (ares_buf_len(buf)) {
    size_t               len = 0;
    const unsigned char *ptr;

    if (first) {
      /* No delimiter yet, just tag the start */
      ares_buf_tag(buf);
    } else {
      if (flags & ARES_BUF_SPLIT_KEEP_DELIMS) {
        /* tag then eat delimiter so its first byte in buffer */
        ares_buf_tag(buf);
        ares_buf_consume(buf, 1);
      } else {
        /* throw away delimiter */
        ares_buf_consume(buf, 1);
        ares_buf_tag(buf);
      }
    }

    if (max_sections && ares_array_len(*arr) >= max_sections - 1) {
      ares_buf_consume(buf, ares_buf_len(buf));
    } else {
      ares_buf_consume_until_charset(buf, delims, delims_len, ARES_FALSE);
    }

    ptr = ares_buf_tag_fetch(buf, &len);

    /* Shouldn't be possible */
    if (ptr == NULL) {
      status = ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
      goto done;
    }

    if (flags & ARES_BUF_SPLIT_LTRIM) {
      size_t i;
      for (i = 0; i < len; i++) {
        if (!ares_is_whitespace(ptr[i], ARES_TRUE)) {
          break;
        }
      }
      ptr += i;
      len -= i;
    }

    if (flags & ARES_BUF_SPLIT_RTRIM) {
      while (len > 0 && ares_is_whitespace(ptr[len - 1], ARES_TRUE)) {
        len--;
      }
    }

    if (len != 0 || flags & ARES_BUF_SPLIT_ALLOW_BLANK) {
      ares_buf_t *data;

      if (!(flags & ARES_BUF_SPLIT_NO_DUPLICATES) ||
          !ares_buf_split_isduplicate(*arr, ptr, len, flags)) {
        /* Since we don't allow const buffers of 0 length, and user wants
         * 0-length buffers, swap what we do here */
        if (len) {
          data = ares_buf_create_const(ptr, len);
        } else {
          data = ares_buf_create();
        }

        if (data == NULL) {
          status = ARES_ENOMEM;
          goto done;
        }

        status = ares_array_insertdata_last(*arr, &data);
        if (status != ARES_SUCCESS) {
          ares_buf_destroy(data);
          goto done;
        }
      }
    }

    first = ARES_FALSE;
  }

done:
  if (status != ARES_SUCCESS) {
    ares_array_destroy(*arr);
    *arr = NULL;
  }

  return status;
}

static void ares_free_split_array(void *arg)
{
  void **ptr = arg;
  ares_free(*ptr);
}

ares_status_t ares_buf_split_str_array(ares_buf_t          *buf,
                                       const unsigned char *delims,
                                       size_t               delims_len,
                                       ares_buf_split_t     flags,
                                       size_t max_sections, ares_array_t **arr)
{
  ares_status_t status;
  ares_array_t *split = NULL;
  size_t        i;
  size_t        len;

  if (arr == NULL) {
    return ARES_EFORMERR;
  }

  *arr = NULL;

  status = ares_buf_split(buf, delims, delims_len, flags, max_sections, &split);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  *arr = ares_array_create(sizeof(char *), ares_free_split_array);
  if (*arr == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  len = ares_array_len(split);
  for (i = 0; i < len; i++) {
    ares_buf_t **bufptr = ares_array_at(split, i);
    ares_buf_t  *lbuf   = *bufptr;
    char        *str    = NULL;

    status = ares_buf_fetch_str_dup(lbuf, ares_buf_len(lbuf), &str);
    if (status != ARES_SUCCESS) {
      goto done;
    }

    status = ares_array_insertdata_last(*arr, &str);
    if (status != ARES_SUCCESS) {
      ares_free(str);
      goto done;
    }
  }

done:
  ares_array_destroy(split);
  if (status != ARES_SUCCESS) {
    ares_array_destroy(*arr);
    *arr = NULL;
  }
  return status;
}

ares_status_t ares_buf_split_str(ares_buf_t *buf, const unsigned char *delims,
                                 size_t delims_len, ares_buf_split_t flags,
                                 size_t max_sections, char ***strs,
                                 size_t *nstrs)
{
  ares_status_t status;
  ares_array_t *arr = NULL;

  if (strs == NULL || nstrs == NULL) {
    return ARES_EFORMERR;
  }

  *strs  = NULL;
  *nstrs = 0;

  status = ares_buf_split_str_array(buf, delims, delims_len, flags,
                                    max_sections, &arr);

  if (status != ARES_SUCCESS) {
    goto done;
  }

done:
  if (status == ARES_SUCCESS) {
    *strs = ares_array_finish(arr, nstrs);
  } else {
    ares_array_destroy(arr);
  }
  return status;
}

ares_bool_t ares_buf_begins_with(const ares_buf_t    *buf,
                                 const unsigned char *data, size_t data_len)
{
  size_t               remaining_len = 0;
  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);

  if (ptr == NULL || data == NULL || data_len == 0) {
    return ARES_FALSE;
  }

  if (data_len > remaining_len) {
    return ARES_FALSE;
  }

  if (memcmp(ptr, data, data_len) != 0) {
    return ARES_FALSE;
  }

  return ARES_TRUE;
}

size_t ares_buf_len(const ares_buf_t *buf)
{
  if (buf == NULL) {
    return 0;
  }

  return buf->data_len - buf->offset;
}

const unsigned char *ares_buf_peek(const ares_buf_t *buf, size_t *len)
{
  return ares_buf_fetch(buf, len);
}

ares_status_t ares_buf_replace(ares_buf_t *buf, const unsigned char *srch,
                               size_t srch_size, const unsigned char *rplc,
                               size_t rplc_size)
{
  size_t        processed_len = 0;
  ares_status_t status;

  if (buf->alloc_buf == NULL || srch == NULL || srch_size == 0 ||
      (rplc == NULL && rplc_size != 0)) {
    return ARES_EFORMERR;
  }

  while (1) {
    unsigned char *ptr           = buf->alloc_buf + buf->offset + processed_len;
    size_t         remaining_len = buf->data_len - buf->offset - processed_len;
    size_t         found_offset  = 0;
    size_t         move_data_len;

    /* Find pattern */
    ptr = ares_memmem(ptr, remaining_len, srch, srch_size);
    if (ptr == NULL) {
      break;
    }

    /* Store the offset this was found because our actual pointer might be
     * switched out from under us by the call to ensure_space() if the
     * replacement pattern is larger than the search pattern */
    found_offset   = (size_t)(ptr - (size_t)(buf->alloc_buf + buf->offset));
    if (rplc_size > srch_size) {
      status = ares_buf_ensure_space(buf, rplc_size - srch_size);
      if (status != ARES_SUCCESS) {
        return status;
      }
    }

    /* Impossible, but silence clang */
    if (buf->alloc_buf == NULL) {
      return ARES_ENOMEM;
    }

    /* Recalculate actual pointer */
    ptr = buf->alloc_buf + buf->offset + found_offset;

    /* Move the data */
    move_data_len = buf->data_len - buf->offset - found_offset - srch_size;
    memmove(ptr + rplc_size,
            ptr + srch_size,
            move_data_len);

    /* Copy in the replacement data */
    if (rplc != NULL && rplc_size > 0) {
      memcpy(ptr, rplc, rplc_size);
    }

    if (rplc_size > srch_size) {
      buf->data_len += rplc_size - srch_size;
    } else {
      buf->data_len -= srch_size - rplc_size;
    }

    processed_len = found_offset + rplc_size;
  }

  return ARES_SUCCESS;
}

ares_status_t ares_buf_peek_byte(const ares_buf_t *buf, unsigned char *b)
{
  size_t               remaining_len = 0;
  const unsigned char *ptr           = ares_buf_fetch(buf, &remaining_len);

  if (buf == NULL || b == NULL) {
    return ARES_EFORMERR;
  }

  if (remaining_len == 0) {
    return ARES_EBADRESP;
  }
  *b = ptr[0];
  return ARES_SUCCESS;
}

size_t ares_buf_get_position(const ares_buf_t *buf)
{
  if (buf == NULL) {
    return 0;
  }
  return buf->offset;
}

ares_status_t ares_buf_set_position(ares_buf_t *buf, size_t idx)
{
  if (buf == NULL) {
    return ARES_EFORMERR;
  }

  if (idx > buf->data_len) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  buf->offset = idx;
  return ARES_SUCCESS;
}

static ares_status_t
  ares_buf_parse_dns_binstr_int(ares_buf_t *buf, size_t remaining_len,
                                unsigned char **bin, size_t *bin_len,
                                ares_bool_t validate_printable)
{
  unsigned char len;
  ares_status_t status = ARES_EBADRESP;
  ares_buf_t   *binbuf = NULL;

  if (buf == NULL) {
    return ARES_EFORMERR;
  }

  if (remaining_len == 0) {
    return ARES_EBADRESP;
  }

  binbuf = ares_buf_create();
  if (binbuf == NULL) {
    return ARES_ENOMEM;
  }

  status = ares_buf_fetch_bytes(buf, &len, 1);
  if (status != ARES_SUCCESS) {
    goto done; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  remaining_len--;

  if (len > remaining_len) {
    status = ARES_EBADRESP;
    goto done;
  }

  if (len) {
    /* When used by the _str() parser, it really needs to be validated to
     * be a valid printable ascii string.  Do that here */
    if (validate_printable && ares_buf_len(buf) >= len) {
      size_t      mylen;
      const char *data = (const char *)ares_buf_peek(buf, &mylen);
      if (!ares_str_isprint(data, len)) {
        status = ARES_EBADSTR;
        goto done;
      }
    }

    if (bin != NULL) {
      status = ares_buf_fetch_bytes_into_buf(buf, binbuf, len);
    } else {
      status = ares_buf_consume(buf, len);
    }
  }

done:
  if (status != ARES_SUCCESS) {
    ares_buf_destroy(binbuf);
  } else {
    if (bin != NULL) {
      size_t mylen = 0;
      /* NOTE: we use ares_buf_finish_str() here as we guarantee NULL
       *       Termination even though we are technically returning binary data.
       */
      *bin     = (unsigned char *)ares_buf_finish_str(binbuf, &mylen);
      *bin_len = mylen;
    }
  }

  return status;
}

ares_status_t ares_buf_parse_dns_binstr(ares_buf_t *buf, size_t remaining_len,
                                        unsigned char **bin, size_t *bin_len)
{
  return ares_buf_parse_dns_binstr_int(buf, remaining_len, bin, bin_len,
                                       ARES_FALSE);
}

ares_status_t ares_buf_parse_dns_str(ares_buf_t *buf, size_t remaining_len,
                                     char **str)
{
  size_t len;

  return ares_buf_parse_dns_binstr_int(buf, remaining_len,
                                       (unsigned char **)str, &len, ARES_TRUE);
}

ares_status_t ares_buf_append_num_dec(ares_buf_t *buf, size_t num, size_t len)
{
  size_t i;
  size_t mod;

  if (len == 0) {
    len = ares_count_digits(num);
  }

  mod = ares_pow(10, len);

  for (i = len; i > 0; i--) {
    size_t        digit = (num % mod);
    ares_status_t status;

    mod /= 10;

    /* Silence coverity.  Shouldn't be possible since we calculate it above */
    if (mod == 0) {
      return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
    }

    digit  /= mod;
    status  = ares_buf_append_byte(buf, '0' + (unsigned char)(digit & 0xFF));
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }
  return ARES_SUCCESS;
}

ares_status_t ares_buf_append_num_hex(ares_buf_t *buf, size_t num, size_t len)
{
  size_t                     i;
  static const unsigned char hexbytes[] = "0123456789ABCDEF";

  if (len == 0) {
    len = ares_count_hexdigits(num);
  }

  for (i = len; i > 0; i--) {
    ares_status_t status;
    status = ares_buf_append_byte(buf, hexbytes[(num >> ((i - 1) * 4)) & 0xF]);
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }
  return ARES_SUCCESS;
}

ares_status_t ares_buf_append_str(ares_buf_t *buf, const char *str)
{
  return ares_buf_append(buf, (const unsigned char *)str, ares_strlen(str));
}

static ares_status_t ares_buf_hexdump_line(ares_buf_t *buf, size_t idx,
                                           const unsigned char *data,
                                           size_t               len)
{
  size_t        i;
  ares_status_t status;

  /* Address */
  status = ares_buf_append_num_hex(buf, idx, 6);
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  /* | */
  status = ares_buf_append_str(buf, " | ");
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  for (i = 0; i < 16; i++) {
    if (i >= len) {
      status = ares_buf_append_str(buf, "  ");
    } else {
      status = ares_buf_append_num_hex(buf, data[i], 2);
    }
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }

    status = ares_buf_append_byte(buf, ' ');
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  /* | */
  status = ares_buf_append_str(buf, " | ");
  if (status != ARES_SUCCESS) {
    return status; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  for (i = 0; i < 16; i++) {
    if (i >= len) {
      break;
    }
    status = ares_buf_append_byte(buf, ares_isprint(data[i]) ? data[i] : '.');
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  return ares_buf_append_byte(buf, '\n');
}

ares_status_t ares_buf_hexdump(ares_buf_t *buf, const unsigned char *data,
                               size_t len)
{
  size_t i;

  /* Each line is 16 bytes */
  for (i = 0; i < len; i += 16) {
    ares_status_t status;
    status = ares_buf_hexdump_line(buf, i, data + i, len - i);
    if (status != ARES_SUCCESS) {
      return status; /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  return ARES_SUCCESS;
}

ares_status_t ares_buf_load_file(const char *filename, ares_buf_t *buf)
{
  FILE          *fp        = NULL;
  unsigned char *ptr       = NULL;
  size_t         len       = 0;
  size_t         ptr_len   = 0;
  long           ftell_len = 0;
  ares_status_t  status;

  if (filename == NULL || buf == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  fp = fopen(filename, "rb");
  if (fp == NULL) {
    int error = errno;
    switch (error) {
      case ENOENT:
      case ESRCH:
        status = ARES_ENOTFOUND;
        goto done;
      default:
        DEBUGF(fprintf(stderr, "fopen() failed with error: %d %s\n", error,
                       strerror(error)));
        DEBUGF(fprintf(stderr, "Error opening file: %s\n", filename));
        status = ARES_EFILE;
        goto done;
    }
  }

  /* Get length portably, fstat() is POSIX, not C */
  if (fseek(fp, 0, SEEK_END) != 0) {
    status = ARES_EFILE; /* LCOV_EXCL_LINE: DefensiveCoding */
    goto done;           /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ftell_len = ftell(fp);
  if (ftell_len < 0) {
    status = ARES_EFILE; /* LCOV_EXCL_LINE: DefensiveCoding */
    goto done;           /* LCOV_EXCL_LINE: DefensiveCoding */
  }
  len = (size_t)ftell_len;

  if (fseek(fp, 0, SEEK_SET) != 0) {
    status = ARES_EFILE; /* LCOV_EXCL_LINE: DefensiveCoding */
    goto done;           /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  if (len == 0) {
    status = ARES_SUCCESS; /* LCOV_EXCL_LINE: DefensiveCoding */
    goto done;             /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* Read entire data into buffer */
  ptr_len = len;
  ptr     = ares_buf_append_start(buf, &ptr_len);
  if (ptr == NULL) {
    status = ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
    goto done;            /* LCOV_EXCL_LINE: OutOfMemory */
  }

  ptr_len = fread(ptr, 1, len, fp);
  if (ptr_len != len) {
    status = ARES_EFILE; /* LCOV_EXCL_LINE: DefensiveCoding */
    goto done;           /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  ares_buf_append_finish(buf, len);
  status = ARES_SUCCESS;

done:
  if (fp != NULL) {
    fclose(fp);
  }
  return status;
}
                                                                                                 node-23.7.0/deps/cares/src/lib/str/ares_str.c                                                       0000664 0000000 0000000 00000024450 14746647661 0020745 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 1998 Massachusetts Institute of Technology
 * Copyright (c) The c-ares project and its contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"
#include "ares_str.h"

#ifdef HAVE_STDINT_H
#  include <stdint.h>
#endif

size_t ares_strnlen(const char *str, size_t maxlen) {
  const char *p = NULL;
  if (str == NULL) {
    return 0;
  }
#ifdef HAVE_STRNLEN
  (void)p;
  return strnlen(str, maxlen);
#else
  if ((p = memchr(str, 0, maxlen)) == NULL) {
    return maxlen;
  } else {
    return (size_t)(p - str);
  }
#endif /* HAVE_STRNLEN */
}

size_t ares_strlen(const char *str)
{
  if (str == NULL) {
    return 0;
  }

  return strlen(str);
}

char *ares_strdup(const char *s1)
{
  size_t len;
  char  *out;

  if (s1 == NULL) {
    return NULL;
  }

  len = ares_strlen(s1);

  /* Don't see how this is possible */
  if (len == SIZE_MAX) {
    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  out = ares_malloc(len + 1);
  if (out == NULL) {
    return NULL;
  }

  if (len) {
    memcpy(out, s1, len);
  }

  out[len] = 0;
  return out;
}

size_t ares_strcpy(char *dest, const char *src, size_t dest_size)
{
  size_t len = 0;

  if (dest == NULL || dest_size == 0) {
    return 0; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  len = ares_strlen(src);

  if (len >= dest_size) {
    len = dest_size - 1;
  }

  if (len) {
    memcpy(dest, src, len);
  }

  dest[len] = 0;
  return len;
}

ares_bool_t ares_str_isnum(const char *str)
{
  size_t i;

  if (str == NULL || *str == 0) {
    return ARES_FALSE;
  }

  for (i = 0; str[i] != 0; i++) {
    if (!ares_isdigit(str[i])) {
      return ARES_FALSE;
    }
  }
  return ARES_TRUE;
}

ares_bool_t ares_str_isalnum(const char *str)
{
  size_t i;

  if (str == NULL || *str == 0) {
    return ARES_FALSE;
  }

  for (i = 0; str[i] != 0; i++) {
    if (!ares_isdigit(str[i]) && !ares_isalpha(str[i])) {
      return ARES_FALSE;
    }
  }
  return ARES_TRUE;
}

void ares_str_rtrim(char *str)
{
  size_t len;
  size_t i;

  if (str == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  len = ares_strlen(str);
  for (i = len; i > 0; i--) {
    if (!ares_isspace(str[i - 1])) {
      break;
    }
  }
  str[i] = 0;
}

void ares_str_ltrim(char *str)
{
  size_t i;
  size_t len;

  if (str == NULL) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  for (i = 0; str[i] != 0 && ares_isspace(str[i]); i++) {
    /* Do nothing */
  }

  if (i == 0) {
    return;
  }

  len = ares_strlen(str);
  if (i != len) {
    memmove(str, str + i, len - i);
  }
  str[len - i] = 0;
}

void ares_str_trim(char *str)
{
  ares_str_ltrim(str);
  ares_str_rtrim(str);
}

/* tolower() is locale-specific.  Use a lookup table fast conversion that only
 * operates on ASCII */
static const unsigned char ares_tolower_lookup[] = {
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
  0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
  0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
  0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33,
  0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40,
  0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
  0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
  0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74,
  0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81,
  0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E,
  0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B,
  0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8,
  0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5,
  0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2,
  0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
  0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC,
  0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9,
  0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6,
  0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

unsigned char ares_tolower(unsigned char c)
{
  return ares_tolower_lookup[c];
}

void ares_str_lower(char *str)
{
  size_t i;

  if (str == NULL) {
    return;
  }

  for (i = 0; str[i] != 0; i++) {
    str[i] = (char)ares_tolower((unsigned char)str[i]);
  }
}

unsigned char *ares_memmem(const unsigned char *big, size_t big_len,
                           const unsigned char *little, size_t little_len)
{
  unsigned char *ptr;

  if (big == NULL || little == NULL || big_len == 0 || little_len == 0) {
    return NULL;
  }

#ifdef HAVE_MEMMEM
  ptr = memmem(big, big_len, little, little_len);
  return ptr;
#else
  while (1) {
    ptr = memchr(big, little[0], big_len);
    if (ptr == NULL) {
      break;
    }

    big_len -= (size_t)(ptr - big);
    big      = ptr;
    if (big_len < little_len) {
      break;
    }

    if (memcmp(big, little, little_len) == 0) {
      return ptr;
    }

    big++;
    big_len--;
  }

  return NULL;
#endif
}

ares_bool_t ares_memeq(const unsigned char *ptr, const unsigned char *val,
                       size_t len)
{
  return memcmp(ptr, val, len) == 0 ? ARES_TRUE : ARES_FALSE;
}

ares_bool_t ares_memeq_ci(const unsigned char *ptr, const unsigned char *val,
                          size_t len)
{
  size_t i;
  for (i = 0; i < len; i++) {
    if (ares_tolower_lookup[ptr[i]] != ares_tolower_lookup[val[i]]) {
      return ARES_FALSE;
    }
  }
  return ARES_TRUE;
}

ares_bool_t ares_is_hostname(const char *str)
{
  size_t i;

  if (str == NULL) {
    return ARES_FALSE; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  for (i = 0; str[i] != 0; i++) {
    if (!ares_is_hostnamech(str[i])) {
      return ARES_FALSE;
    }
  }
  return ARES_TRUE;
}

ares_bool_t ares_str_isprint(const char *str, size_t len)
{
  size_t i;

  if (str == NULL && len != 0) {
    return ARES_FALSE;
  }

  for (i = 0; i < len; i++) {
    if (!ares_isprint(str[i])) {
      return ARES_FALSE;
    }
  }
  return ARES_TRUE;
}

int ares_strcmp(const char *a, const char *b)
{
  if (a == NULL && b == NULL) {
    return 0;
  }

  if (a != NULL && b == NULL) {
    if (*a == 0) {
      return 0;
    }
    return 1;
  }

  if (a == NULL && b != NULL) {
    if (*b == 0) {
      return 0;
    }
    return -1;
  }

  return strcmp(a, b);
}

int ares_strncmp(const char *a, const char *b, size_t n)
{
  if (n == 0) {
    return 0;
  }

  if (a == NULL && b == NULL) {
    return 0;
  }

  if (a != NULL && b == NULL) {
    if (*a == 0) {
      return 0;
    }
    return 1;
  }

  if (a == NULL && b != NULL) {
    if (*b == 0) {
      return 0;
    }
    return -1;
  }

  return strncmp(a, b, n);
}

int ares_strcasecmp(const char *a, const char *b)
{
  if (a == NULL && b == NULL) {
    return 0;
  }

  if (a != NULL && b == NULL) {
    if (*a == 0) {
      return 0;
    }
    return 1;
  }

  if (a == NULL && b != NULL) {
    if (*b == 0) {
      return 0;
    }
    return -1;
  }

#if defined(HAVE_STRCASECMP)
  return strcasecmp(a, b);
#elif defined(HAVE_STRCMPI)
  return strcmpi(a, b);
#elif defined(HAVE_STRICMP)
  return stricmp(a, b);
#else
  {
    size_t i;

    for (i = 0; i < (size_t)-1; i++) {
      int c1 = ares_tolower(a[i]);
      int c2 = ares_tolower(b[i]);
      if (c1 != c2) {
        return c1 - c2;
      }
      if (!c1) {
        break;
      }
    }
  }
  return 0;
#endif
}

int ares_strncasecmp(const char *a, const char *b, size_t n)
{
  if (n == 0) {
    return 0;
  }

  if (a == NULL && b == NULL) {
    return 0;
  }

  if (a != NULL && b == NULL) {
    if (*a == 0) {
      return 0;
    }
    return 1;
  }

  if (a == NULL && b != NULL) {
    if (*b == 0) {
      return 0;
    }
    return -1;
  }

#if defined(HAVE_STRNCASECMP)
  return strncasecmp(a, b, n);
#elif defined(HAVE_STRNCMPI)
  return strncmpi(a, b, n);
#elif defined(HAVE_STRNICMP)
  return strnicmp(a, b, n);
#else
  {
    size_t i;

    for (i = 0; i < n; i++) {
      int c1 = ares_tolower(a[i]);
      int c2 = ares_tolower(b[i]);
      if (c1 != c2) {
        return c1 - c2;
      }
      if (!c1) {
        break;
      }
    }
  }
  return 0;
#endif
}

ares_bool_t ares_strcaseeq(const char *a, const char *b)
{
  return ares_strcasecmp(a, b) == 0 ? ARES_TRUE : ARES_FALSE;
}

ares_bool_t ares_strcaseeq_max(const char *a, const char *b, size_t n)
{
  return ares_strncasecmp(a, b, n) == 0 ? ARES_TRUE : ARES_FALSE;
}

ares_bool_t ares_streq(const char *a, const char *b)
{
  return ares_strcmp(a, b) == 0 ? ARES_TRUE : ARES_FALSE;
}

ares_bool_t ares_streq_max(const char *a, const char *b, size_t n)
{
  return ares_strncmp(a, b, n) == 0 ? ARES_TRUE : ARES_FALSE;
}

void ares_free_array(void *arrp, size_t nmembers, void (*freefunc)(void *))
{
  size_t i;
  void **arr = arrp;

  if (arr == NULL) {
    return;
  }

  if (freefunc != NULL) {
    if (nmembers == SIZE_MAX) {
      for (i = 0; arr[i] != NULL; i++) {
        freefunc(arr[i]);
      }
    } else {
      for (i = 0; i < nmembers; i++) {
        freefunc(arr[i]);
      }
    }
  }

  ares_free(arr);
}
                                                                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/str/ares_strsplit.c                                                  0000664 0000000 0000000 00000005142 14746647661 0022016 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2018 John Schember
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"

void ares_strsplit_free(char **elms, size_t num_elm)
{
  ares_free_array(elms, num_elm, ares_free);
}

char **ares_strsplit_duplicate(char **elms, size_t num_elm)
{
  size_t i;
  char **out;

  if (elms == NULL || num_elm == 0) {
    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  out = ares_malloc_zero(sizeof(*elms) * num_elm);
  if (out == NULL) {
    return NULL; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  for (i = 0; i < num_elm; i++) {
    out[i] = ares_strdup(elms[i]);
    if (out[i] == NULL) {
      ares_strsplit_free(out, num_elm); /* LCOV_EXCL_LINE: OutOfMemory */
      return NULL;                      /* LCOV_EXCL_LINE: OutOfMemory */
    }
  }

  return out;
}

char **ares_strsplit(const char *in, const char *delms, size_t *num_elm)
{
  ares_status_t status;
  ares_buf_t   *buf = NULL;
  char        **out = NULL;

  if (in == NULL || delms == NULL || num_elm == NULL) {
    return NULL; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  *num_elm = 0;

  buf = ares_buf_create_const((const unsigned char *)in, ares_strlen(in));
  if (buf == NULL) {
    return NULL;
  }

  status = ares_buf_split_str(
    buf, (const unsigned char *)delms, ares_strlen(delms),
    ARES_BUF_SPLIT_NO_DUPLICATES | ARES_BUF_SPLIT_CASE_INSENSITIVE, 0, &out,
    num_elm);
  if (status != ARES_SUCCESS) {
    goto done;
  }

done:
  ares_buf_destroy(buf);
  if (status != ARES_SUCCESS) {
    out = NULL;
  }

  return out;
}
                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/cares/src/lib/str/ares_strsplit.h                                                  0000664 0000000 0000000 00000004153 14746647661 0022024 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2018 John Schember
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef HEADER_CARES_STRSPLIT_H
#define HEADER_CARES_STRSPLIT_H

/* Split a string on delms skipping empty or duplicate elements.
 *
 * param in String to split.
 * param delms String of characters to treat as a delimiter.
 *             Each character in the string is a delimiter so
 *             there can be multiple delimiters to split on.
 *             E.g. ", " will split on all comma's and spaces.
 *             Duplicate (case-insensitive) entries are removed.
 * param num_elm Return parameter of the number of elements
 *               in the result array.
 *
 * returns an allocated array of allocated string elements.
 *
 */
char **ares_strsplit(const char *in, const char *delms, size_t *num_elm);

/* Frees the result returned from ares_strsplit(). */
void   ares_strsplit_free(char **elms, size_t num_elm);

/* Duplicate the array */
char **ares_strsplit_duplicate(char **elms, size_t num_elm);

#endif /* HEADER_CARES_STRSPLIT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/cares/src/lib/thirdparty/                                                          0000775 0000000 0000000 00000000000 14746647661 0020334 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/thirdparty/apple/                                                    0000775 0000000 0000000 00000000000 14746647661 0021435 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/thirdparty/apple/dnsinfo.h                                           0000664 0000000 0000000 00000006664 14746647661 0023262 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright (c) 2004-2006, 2008, 2009, 2011 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __DNSINFO_H__
#define __DNSINFO_H__

/*
 * These routines provide access to the systems DNS configuration
 */

#include <Availability.h>
#include <sys/cdefs.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <AvailabilityMacros.h>

#define	DNSINFO_VERSION		20111104

#define DEFAULT_SEARCH_ORDER    200000   /* search order for the "default" resolver domain name */

#define	DNS_PTR(type, name)				\
	union {						\
		type		name;			\
		uint64_t	_ ## name ## _p;	\
	}

#define	DNS_VAR(type, name)				\
	type	name


#pragma pack(4)
typedef struct {
	struct in_addr	address;
	struct in_addr	mask;
} dns_sortaddr_t;
#pragma pack()


#pragma pack(4)
typedef struct {
	DNS_PTR(char *,			domain);	/* domain */
	DNS_VAR(int32_t,		n_nameserver);	/* # nameserver */
	DNS_PTR(struct sockaddr **,	nameserver);
	DNS_VAR(uint16_t,		port);		/* port (in host byte order) */
	DNS_VAR(int32_t,		n_search);	/* # search */
	DNS_PTR(char **,		search);
	DNS_VAR(int32_t,		n_sortaddr);	/* # sortaddr */
	DNS_PTR(dns_sortaddr_t **,	sortaddr);
	DNS_PTR(char *,			options);	/* options */
	DNS_VAR(uint32_t,		timeout);	/* timeout */
	DNS_VAR(uint32_t,		search_order);	/* search_order */
	DNS_VAR(uint32_t,		if_index);
	DNS_VAR(uint32_t,		flags);
#if MAC_OS_X_VERSION_MIN_REQUIRED < 1080 /* MacOS 10.8 */
	DNS_VAR(uint32_t,		reserved[6]);
#else
	DNS_VAR(uint32_t,		reach_flags);	/* SCNetworkReachabilityFlags */
	DNS_VAR(uint32_t,		reserved[5]);
#endif
} dns_resolver_t;
#pragma pack()


#define DNS_RESOLVER_FLAGS_SCOPED	1		/* configuration is for scoped questions */


#pragma pack(4)
typedef struct {
	DNS_VAR(int32_t,		n_resolver);		/* resolver configurations */
	DNS_PTR(dns_resolver_t **,	resolver);
	DNS_VAR(int32_t,		n_scoped_resolver);	/* "scoped" resolver configurations */
	DNS_PTR(dns_resolver_t **,	scoped_resolver);
	DNS_VAR(uint32_t,		reserved[5]);
} dns_config_t;
#pragma pack()


__BEGIN_DECLS

/*
 * DNS configuration access APIs
 */
const char *
dns_configuration_notify_key    (void)				__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_2_0);

dns_config_t *
dns_configuration_copy		(void)				__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_2_0);

void
dns_configuration_free		(dns_config_t	*config)	__OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_2_0);

#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
void
_dns_configuration_ack		(dns_config_t	*config,
				 const char	*bundle_id)	__OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_6_0);
#endif

__END_DECLS

#endif	/* __DNSINFO_H__ */
                                                                            node-23.7.0/deps/cares/src/lib/util/                                                                0000775 0000000 0000000 00000000000 14746647661 0017117 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/cares/src/lib/util/ares_iface_ips.c                                                0000664 0000000 0000000 00000036575 14746647661 0022237 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"

#ifdef USE_WINSOCK
#  include <winsock2.h>
#  include <ws2tcpip.h>
#  if defined(HAVE_IPHLPAPI_H)
#    include <iphlpapi.h>
#  endif
#  if defined(HAVE_NETIOAPI_H)
#    include <netioapi.h>
#  endif
#endif

#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>
#endif
#ifdef HAVE_SYS_SOCKET_H
#  include <sys/socket.h>
#endif
#ifdef HAVE_NET_IF_H
#  include <net/if.h>
#endif
#ifdef HAVE_IFADDRS_H
#  include <ifaddrs.h>
#endif
#ifdef HAVE_SYS_IOCTL_H
#  include <sys/ioctl.h>
#endif
#ifdef HAVE_NETINET_IN_H
#  include <netinet/in.h>
#endif
#ifdef HAVE_NETDB_H
#  include <netdb.h>
#endif


static ares_status_t ares_iface_ips_enumerate(ares_iface_ips_t *ips,
                                              const char       *name);

typedef struct {
  char                 *name;
  struct ares_addr      addr;
  unsigned char         netmask;
  unsigned int          ll_scope;
  ares_iface_ip_flags_t flags;
} ares_iface_ip_t;

struct ares_iface_ips {
  ares_array_t         *ips; /*!< Type is ares_iface_ip_t */
  ares_iface_ip_flags_t enum_flags;
};

static void ares_iface_ip_free_cb(void *arg)
{
  ares_iface_ip_t *ip = arg;
  if (ip == NULL) {
    return;
  }
  ares_free(ip->name);
}

static ares_iface_ips_t *ares_iface_ips_alloc(ares_iface_ip_flags_t flags)
{
  ares_iface_ips_t *ips = ares_malloc_zero(sizeof(*ips));
  if (ips == NULL) {
    return NULL; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  ips->enum_flags = flags;
  ips->ips = ares_array_create(sizeof(ares_iface_ip_t), ares_iface_ip_free_cb);
  if (ips->ips == NULL) {
    ares_free(ips); /* LCOV_EXCL_LINE: OutOfMemory */
    return NULL;    /* LCOV_EXCL_LINE: OutOfMemory */
  }
  return ips;
}

void ares_iface_ips_destroy(ares_iface_ips_t *ips)
{
  if (ips == NULL) {
    return;
  }

  ares_array_destroy(ips->ips);
  ares_free(ips);
}

ares_status_t ares_iface_ips(ares_iface_ips_t    **ips,
                             ares_iface_ip_flags_t flags, const char *name)
{
  ares_status_t status;

  if (ips == NULL) {
    return ARES_EFORMERR;
  }

  *ips = ares_iface_ips_alloc(flags);
  if (*ips == NULL) {
    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  status = ares_iface_ips_enumerate(*ips, name);
  if (status != ARES_SUCCESS) {
    /* LCOV_EXCL_START: UntestablePath */
    ares_iface_ips_destroy(*ips);
    *ips = NULL;
    return status;
    /* LCOV_EXCL_STOP */
  }

  return ARES_SUCCESS;
}

static ares_status_t
  ares_iface_ips_add(ares_iface_ips_t *ips, ares_iface_ip_flags_t flags,
                     const char *name, const struct ares_addr *addr,
                     unsigned char netmask, unsigned int ll_scope)
{
  ares_iface_ip_t *ip;
  ares_status_t    status;

  if (ips == NULL || name == NULL || addr == NULL) {
    return ARES_EFORMERR; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  /* Don't want loopback */
  if (flags & ARES_IFACE_IP_LOOPBACK &&
      !(ips->enum_flags & ARES_IFACE_IP_LOOPBACK)) {
    return ARES_SUCCESS;
  }

  /* Don't want offline */
  if (flags & ARES_IFACE_IP_OFFLINE &&
      !(ips->enum_flags & ARES_IFACE_IP_OFFLINE)) {
    return ARES_SUCCESS;
  }

  /* Check for link-local */
  if (ares_addr_is_linklocal(addr)) {
    flags |= ARES_IFACE_IP_LINKLOCAL;
  }
  if (flags & ARES_IFACE_IP_LINKLOCAL &&
      !(ips->enum_flags & ARES_IFACE_IP_LINKLOCAL)) {
    return ARES_SUCCESS;
  }

  /* Set address flag based on address provided */
  if (addr->family == AF_INET) {
    flags |= ARES_IFACE_IP_V4;
  }

  if (addr->family == AF_INET6) {
    flags |= ARES_IFACE_IP_V6;
  }

  /* If they specified either v4 or v6 validate flags otherwise assume they
   * want to enumerate both */
  if (ips->enum_flags & (ARES_IFACE_IP_V4 | ARES_IFACE_IP_V6)) {
    if (flags & ARES_IFACE_IP_V4 && !(ips->enum_flags & ARES_IFACE_IP_V4)) {
      return ARES_SUCCESS;
    }
    if (flags & ARES_IFACE_IP_V6 && !(ips->enum_flags & ARES_IFACE_IP_V6)) {
      return ARES_SUCCESS;
    }
  }

  status = ares_array_insert_last((void **)&ip, ips->ips);
  if (status != ARES_SUCCESS) {
    return status;
  }

  ip->flags   = flags;
  ip->netmask = netmask;
  if (flags & ARES_IFACE_IP_LINKLOCAL) {
    ip->ll_scope = ll_scope;
  }
  memcpy(&ip->addr, addr, sizeof(*addr));
  ip->name = ares_strdup(name);
  if (ip->name == NULL) {
    ares_array_remove_last(ips->ips);
    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
  }

  return ARES_SUCCESS;
}

size_t ares_iface_ips_cnt(const ares_iface_ips_t *ips)
{
  if (ips == NULL) {
    return 0;
  }
  return ares_array_len(ips->ips);
}

const char *ares_iface_ips_get_name(const ares_iface_ips_t *ips, size_t idx)
{
  const ares_iface_ip_t *ip;

  if (ips == NULL) {
    return NULL;
  }

  ip = ares_array_at_const(ips->ips, idx);
  if (ip == NULL) {
    return NULL;
  }

  return ip->name;
}

const struct ares_addr *ares_iface_ips_get_addr(const ares_iface_ips_t *ips,
                                                size_t                  idx)
{
  const ares_iface_ip_t *ip;

  if (ips == NULL) {
    return NULL;
  }

  ip = ares_array_at_const(ips->ips, idx);
  if (ip == NULL) {
    return NULL;
  }

  return &ip->addr;
}

ares_iface_ip_flags_t ares_iface_ips_get_flags(const ares_iface_ips_t *ips,
                                               size_t                  idx)
{
  const ares_iface_ip_t *ip;

  if (ips == NULL) {
    return 0;
  }

  ip = ares_array_at_const(ips->ips, idx);
  if (ip == NULL) {
    return 0;
  }

  return ip->flags;
}

unsigned char ares_iface_ips_get_netmask(const ares_iface_ips_t *ips,
                                         size_t                  idx)
{
  const ares_iface_ip_t *ip;

  if (ips == NULL) {
    return 0;
  }

  ip = ares_array_at_const(ips->ips, idx);
  if (ip == NULL) {
    return 0;
  }

  return ip->netmask;
}

unsigned int ares_iface_ips_get_ll_scope(const ares_iface_ips_t *ips,
                                         size_t                  idx)
{
  const ares_iface_ip_t *ip;

  if (ips == NULL) {
    return 0;
  }

  ip = ares_array_at_const(ips->ips, idx);
  if (ip == NULL) {
    return 0;
  }

  return ip->ll_scope;
}


#ifdef USE_WINSOCK

#  if 0
static char *wcharp_to_charp(const wchar_t *in)
{
  char *out;
  int   len;

  len = WideCharToMultiByte(CP_UTF8, 0, in, -1, NULL, 0, NULL, NULL);
  if (len == -1) {
    return NULL;
  }

  out = ares_malloc_zero((size_t)len + 1);

  if (WideCharToMultiByte(CP_UTF8, 0, in, -1, out, len, NULL, NULL) == -1) {
    ares_free(out);
    return NULL;
  }

  return out;
}
#  endif

static ares_bool_t name_match(const char *name, const char *adapter_name,
                              unsigned int ll_scope)
{
  if (name == NULL || *name == 0) {
    return ARES_TRUE;
  }

  if (ares_strcaseeq(name, adapter_name)) {
    return ARES_TRUE;
  }

  if (ares_str_isnum(name) && (unsigned int)atoi(name) == ll_scope) {
    return ARES_TRUE;
  }

  return ARES_FALSE;
}

static ares_status_t ares_iface_ips_enumerate(ares_iface_ips_t *ips,
                                              const char       *name)
{
  ULONG myflags = GAA_FLAG_INCLUDE_PREFIX /*|GAA_FLAG_INCLUDE_ALL_INTERFACES */;
  ULONG outBufLen = 0;
  DWORD retval;
  IP_ADAPTER_ADDRESSES *addresses = NULL;
  IP_ADAPTER_ADDRESSES *address   = NULL;
  ares_status_t         status    = ARES_SUCCESS;

  /* Get necessary buffer size */
  GetAdaptersAddresses(AF_UNSPEC, myflags, NULL, NULL, &outBufLen);
  if (outBufLen == 0) {
    status = ARES_EFILE;
    goto done;
  }

  addresses = ares_malloc_zero(outBufLen);
  if (addresses == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  retval =
    GetAdaptersAddresses(AF_UNSPEC, myflags, NULL, addresses, &outBufLen);
  if (retval != ERROR_SUCCESS) {
    status = ARES_EFILE;
    goto done;
  }

  for (address = addresses; address != NULL; address = address->Next) {
    IP_ADAPTER_UNICAST_ADDRESS *ipaddr     = NULL;
    ares_iface_ip_flags_t       addrflag   = 0;
    char                        ifname[64] = "";

#  if defined(HAVE_CONVERTINTERFACEINDEXTOLUID) && \
    defined(HAVE_CONVERTINTERFACELUIDTONAMEA)
    /* Retrieve name from interface index.
     * address->AdapterName appears to be a GUID/UUID of some sort, not a name.
     * address->FriendlyName is user-changeable.
     * That said, this doesn't appear to help us out on systems that don't
     * have if_nametoindex() or if_indextoname() as they don't have these
     * functions either! */
    NET_LUID luid;
    ConvertInterfaceIndexToLuid(address->IfIndex, &luid);
    ConvertInterfaceLuidToNameA(&luid, ifname, sizeof(ifname));
#  else
    ares_strcpy(ifname, address->AdapterName, sizeof(ifname));
#  endif

    if (address->OperStatus != IfOperStatusUp) {
      addrflag |= ARES_IFACE_IP_OFFLINE;
    }

    if (address->IfType == IF_TYPE_SOFTWARE_LOOPBACK) {
      addrflag |= ARES_IFACE_IP_LOOPBACK;
    }

    for (ipaddr = address->FirstUnicastAddress; ipaddr != NULL;
         ipaddr = ipaddr->Next) {
      struct ares_addr addr;

      if (ipaddr->Address.lpSockaddr->sa_family == AF_INET) {
        const struct sockaddr_in *sockaddr_in =
          (const struct sockaddr_in *)((void *)ipaddr->Address.lpSockaddr);
        addr.family = AF_INET;
        memcpy(&addr.addr.addr4, &sockaddr_in->sin_addr,
               sizeof(addr.addr.addr4));
      } else if (ipaddr->Address.lpSockaddr->sa_family == AF_INET6) {
        const struct sockaddr_in6 *sockaddr_in6 =
          (const struct sockaddr_in6 *)((void *)ipaddr->Address.lpSockaddr);
        addr.family = AF_INET6;
        memcpy(&addr.addr.addr6, &sockaddr_in6->sin6_addr,
               sizeof(addr.addr.addr6));
      } else {
        /* Unknown */
        continue;
      }

      /* Sometimes windows may use numerics to indicate a DNS server's adapter,
       * which corresponds to the index rather than the name.  Check and
       * validate both. */
      if (!name_match(name, ifname, address->Ipv6IfIndex)) {
        continue;
      }

      status = ares_iface_ips_add(ips, addrflag, ifname, &addr,
                                  ipaddr->OnLinkPrefixLength /* netmask */,
                                  address->Ipv6IfIndex /* ll_scope */);

      if (status != ARES_SUCCESS) {
        goto done;
      }
    }
  }

done:
  ares_free(addresses);
  return status;
}

#elif defined(HAVE_GETIFADDRS)

static unsigned char count_addr_bits(const unsigned char *addr, size_t addr_len)
{
  size_t        i;
  unsigned char count = 0;

  for (i = 0; i < addr_len; i++) {
    count += ares_count_bits_u8(addr[i]);
  }
  return count;
}

static ares_status_t ares_iface_ips_enumerate(ares_iface_ips_t *ips,
                                              const char       *name)
{
  struct ifaddrs *ifap   = NULL;
  struct ifaddrs *ifa    = NULL;
  ares_status_t   status = ARES_SUCCESS;

  if (getifaddrs(&ifap) != 0) {
    status = ARES_EFILE;
    goto done;
  }

  for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
    ares_iface_ip_flags_t addrflag = 0;
    struct ares_addr      addr;
    unsigned char         netmask  = 0;
    unsigned int          ll_scope = 0;

    if (ifa->ifa_addr == NULL) {
      continue;
    }

    if (!(ifa->ifa_flags & IFF_UP)) {
      addrflag |= ARES_IFACE_IP_OFFLINE;
    }

    if (ifa->ifa_flags & IFF_LOOPBACK) {
      addrflag |= ARES_IFACE_IP_LOOPBACK;
    }

    if (ifa->ifa_addr->sa_family == AF_INET) {
      const struct sockaddr_in *sockaddr_in =
        (const struct sockaddr_in *)((void *)ifa->ifa_addr);
      addr.family = AF_INET;
      memcpy(&addr.addr.addr4, &sockaddr_in->sin_addr, sizeof(addr.addr.addr4));
      /* netmask */
      sockaddr_in = (struct sockaddr_in *)((void *)ifa->ifa_netmask);
      netmask     = count_addr_bits((const void *)&sockaddr_in->sin_addr, 4);
    } else if (ifa->ifa_addr->sa_family == AF_INET6) {
      const struct sockaddr_in6 *sockaddr_in6 =
        (const struct sockaddr_in6 *)((void *)ifa->ifa_addr);
      addr.family = AF_INET6;
      memcpy(&addr.addr.addr6, &sockaddr_in6->sin6_addr,
             sizeof(addr.addr.addr6));
      /* netmask */
      sockaddr_in6 = (struct sockaddr_in6 *)((void *)ifa->ifa_netmask);
      netmask = count_addr_bits((const void *)&sockaddr_in6->sin6_addr, 16);
#  ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
      ll_scope = sockaddr_in6->sin6_scope_id;
#  endif
    } else {
      /* unknown */
      continue;
    }

    /* Name mismatch */
    if (name != NULL && !ares_strcaseeq(ifa->ifa_name, name)) {
      continue;
    }

    status = ares_iface_ips_add(ips, addrflag, ifa->ifa_name, &addr, netmask,
                                ll_scope);
    if (status != ARES_SUCCESS) {
      goto done;
    }
  }

done:
  freeifaddrs(ifap);
  return status;
}

#else

static ares_status_t ares_iface_ips_enumerate(ares_iface_ips_t *ips,
                                              const char       *name)
{
  (void)ips;
  (void)name;
  return ARES_ENOTIMP;
}

#endif


unsigned int ares_os_if_nametoindex(const char *name)
{
#ifdef HAVE_IF_NAMETOINDEX
  if (name == NULL) {
    return 0;
  }
  return if_nametoindex(name);
#else
  ares_status_t     status;
  ares_iface_ips_t *ips = NULL;
  size_t            i;
  unsigned int      index = 0;

  if (name == NULL) {
    return 0;
  }

  status =
    ares_iface_ips(&ips, ARES_IFACE_IP_V6 | ARES_IFACE_IP_LINKLOCAL, name);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  for (i = 0; i < ares_iface_ips_cnt(ips); i++) {
    if (ares_iface_ips_get_flags(ips, i) & ARES_IFACE_IP_LINKLOCAL) {
      index = ares_iface_ips_get_ll_scope(ips, i);
      goto done;
    }
  }

done:
  ares_iface_ips_destroy(ips);
  return index;
#endif
}

const char *ares_os_if_indextoname(unsigned int index, char *name, size_t name_len)
{
#ifdef HAVE_IF_INDEXTONAME
  if (name_len < IF_NAMESIZE) {
    return NULL;
  }
  return if_indextoname(index, name);
#else
  ares_status_t     status;
  ares_iface_ips_t *ips = NULL;
  size_t            i;
  const char       *ptr = NULL;

  if (name == NULL || name_len < IF_NAMESIZE) {
    goto done;
  }

  if (index == 0) {
    goto done;
  }

  status =
    ares_iface_ips(&ips, ARES_IFACE_IP_V6 | ARES_IFACE_IP_LINKLOCAL, NULL);
  if (status != ARES_SUCCESS) {
    goto done;
  }

  for (i = 0; i < ares_iface_ips_cnt(ips); i++) {
    if (ares_iface_ips_get_flags(ips, i) & ARES_IFACE_IP_LINKLOCAL &&
        ares_iface_ips_get_ll_scope(ips, i) == index) {
      ares_strcpy(name, ares_iface_ips_get_name(ips, i), name_len);
      ptr = name;
      goto done;
    }
  }

done:
  ares_iface_ips_destroy(ips);
  return ptr;
#endif
}
                                                                                                                                   node-23.7.0/deps/cares/src/lib/util/ares_iface_ips.h                                                0000664 0000000 0000000 00000013132 14746647661 0022224 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__IFACE_IPS_H
#define __ARES__IFACE_IPS_H

/*! Flags for interface ip addresses. */
typedef enum {
  ARES_IFACE_IP_V4 = 1 << 0,        /*!< IPv4 address. During enumeration if
                                     *   this flag is set ARES_IFACE_IP_V6
                                     *   is not, will only enumerate v4
                                     *   addresses. */
  ARES_IFACE_IP_V6 = 1 << 1,        /*!< IPv6 address. During enumeration if
                                     *   this flag is set ARES_IFACE_IP_V4
                                     *   is not, will only enumerate v6
                                     *   addresses. */
  ARES_IFACE_IP_LOOPBACK  = 1 << 2, /*!< Loopback adapter */
  ARES_IFACE_IP_OFFLINE   = 1 << 3, /*!< Adapter offline */
  ARES_IFACE_IP_LINKLOCAL = 1 << 4, /*!< Link-local ip address */
  /*! Default, enumerate all ips for online interfaces, including loopback */
  ARES_IFACE_IP_DEFAULT = (ARES_IFACE_IP_V4 | ARES_IFACE_IP_V6 |
                           ARES_IFACE_IP_LOOPBACK | ARES_IFACE_IP_LINKLOCAL)
} ares_iface_ip_flags_t;

struct ares_iface_ips;

/*! Opaque pointer for holding enumerated interface ip addresses */
typedef struct ares_iface_ips ares_iface_ips_t;

/*! Destroy ip address enumeration created by ares_iface_ips().
 *
 *  \param[in]  ips   Initialized IP address enumeration structure
 */
void                          ares_iface_ips_destroy(ares_iface_ips_t *ips);

/*! Enumerate ip addresses on interfaces
 *
 *  \param[out]  ips   Returns initialized ip address structure
 *  \param[in]   flags Flags for enumeration
 *  \param[in]   name  Interface name to enumerate, or NULL to enumerate all
 *  \return ARES_ENOMEM on out of memory, ARES_ENOTIMP if not supported on
 *          the system, ARES_SUCCESS on success
 */
ares_status_t                 ares_iface_ips(ares_iface_ips_t    **ips,
                                             ares_iface_ip_flags_t flags, const char *name);

/*! Count of ips enumerated
 *
 * \param[in]  ips   Initialized IP address enumeration structure
 * \return count
 */
size_t                        ares_iface_ips_cnt(const ares_iface_ips_t *ips);

/*! Retrieve interface name
 *
 * \param[in]  ips   Initialized IP address enumeration structure
 * \param[in]  idx   Index of entry to pull
 * \return interface name
 */
const char *ares_iface_ips_get_name(const ares_iface_ips_t *ips, size_t idx);

/*! Retrieve interface address
 *
 * \param[in]  ips   Initialized IP address enumeration structure
 * \param[in]  idx   Index of entry to pull
 * \return interface address
 */
const struct ares_addr *ares_iface_ips_get_addr(const ares_iface_ips_t *ips,
                                                size_t                  idx);

/*! Retrieve interface address flags
 *
 * \param[in]  ips   Initialized IP address enumeration structure
 * \param[in]  idx   Index of entry to pull
 * \return interface address flags
 */
ares_iface_ip_flags_t   ares_iface_ips_get_flags(const ares_iface_ips_t *ips,
                                                 size_t                  idx);

/*! Retrieve interface address netmask
 *
 * \param[in]  ips   Initialized IP address enumeration structure
 * \param[in]  idx   Index of entry to pull
 * \return interface address netmask
 */
unsigned char           ares_iface_ips_get_netmask(const ares_iface_ips_t *ips,
                                                   size_t                  idx);

/*! Retrieve interface ipv6 link local scope
 *
 * \param[in]  ips   Initialized IP address enumeration structure
 * \param[in]  idx   Index of entry to pull
 * \return interface ipv6 link local scope
 */
unsigned int            ares_iface_ips_get_ll_scope(const ares_iface_ips_t *ips,
                                                    size_t                  idx);


/*! Retrieve the interface index (aka link local scope) from the interface
 *  name.
 *
 * \param[in] name  Interface name
 * \return 0 on failure, index otherwise
 */
unsigned int            ares_os_if_nametoindex(const char *name);

/*! Retrieves the interface name from the index (aka link local scope)
 *
 * \param[in] index  Interface index (> 0)
 * \param[in] name   Buffer to hold name
 * \param[in] name_len Length of provided buffer, must be at least IF_NAMESIZE
 * \return NULL on failure, or pointer to name on success
 */
const char             *ares_os_if_indextoname(unsigned int index, char *name,
                                               size_t name_len);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/cares/src/lib/util/ares_math.c                                                     0000664 0000000 0000000 00000007702 14746647661 0021234 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

/* Uses public domain code snippets from
 * http://graphics.stanford.edu/~seander/bithacks.html */

static unsigned int ares_round_up_pow2_u32(unsigned int n)
{
  /* NOTE: if already a power of 2, will return itself, not the next */
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n++;
  return n;
}

static ares_int64_t ares_round_up_pow2_u64(ares_int64_t n)
{
  /* NOTE: if already a power of 2, will return itself, not the next */
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n |= n >> 32;
  n++;
  return n;
}

ares_bool_t ares_is_64bit(void)
{
#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable : 4127)
#endif

  return (sizeof(size_t) == 4) ? ARES_FALSE : ARES_TRUE;

#ifdef _MSC_VER
#  pragma warning(pop)
#endif
}

size_t ares_round_up_pow2(size_t n)
{
  if (ares_is_64bit()) {
    return (size_t)ares_round_up_pow2_u64((ares_int64_t)n);
  }

  return (size_t)ares_round_up_pow2_u32((unsigned int)n);
}

size_t ares_log2(size_t n)
{
  static const unsigned char tab32[32] = { 0,  1,  28, 2,  29, 14, 24, 3,
                                           30, 22, 20, 15, 25, 17, 4,  8,
                                           31, 27, 13, 23, 21, 19, 16, 7,
                                           26, 12, 18, 6,  11, 5,  10, 9 };
  static const unsigned char tab64[64] = {
    63, 0,  58, 1,  59, 47, 53, 2,  60, 39, 48, 27, 54, 33, 42, 3,
    61, 51, 37, 40, 49, 18, 28, 20, 55, 30, 34, 11, 43, 14, 22, 4,
    62, 57, 46, 52, 38, 26, 32, 41, 50, 36, 17, 19, 29, 10, 13, 21,
    56, 45, 25, 31, 35, 16, 9,  12, 44, 24, 15, 8,  23, 7,  6,  5
  };

  if (!ares_is_64bit()) {
    return tab32[(n * 0x077CB531) >> 27];
  }

  return tab64[(n * 0x07EDD5E59A4E28C2) >> 58];
}

/* x^y */
size_t ares_pow(size_t x, size_t y)
{
  size_t res = 1;

  while (y > 0) {
    /* If y is odd, multiply x with result */
    if (y & 1) {
      res = res * x;
    }

    /* y must be even now */
    y = y >> 1; /* y /= 2; */
    x = x * x;  /* x^2 */
  }

  return res;
}

size_t ares_count_digits(size_t n)
{
  size_t digits;

  for (digits = 0; n > 0; digits++) {
    n /= 10;
  }
  if (digits == 0) {
    digits = 1;
  }

  return digits;
}

size_t ares_count_hexdigits(size_t n)
{
  size_t digits;

  for (digits = 0; n > 0; digits++) {
    n /= 16;
  }
  if (digits == 0) {
    digits = 1;
  }

  return digits;
}

unsigned char ares_count_bits_u8(unsigned char x)
{
  /* Implementation obtained from:
   * http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetTable */
#define B2(n) n, n + 1, n + 1, n + 2
#define B4(n) B2(n), B2(n + 1), B2(n + 1), B2(n + 2)
#define B6(n) B4(n), B4(n + 1), B4(n + 1), B4(n + 2)
  static const unsigned char lookup[256] = { B6(0), B6(1), B6(1), B6(2) };
  return lookup[x];
}
                                                              node-23.7.0/deps/cares/src/lib/util/ares_math.h                                                     0000664 0000000 0000000 00000003316 14746647661 0021236 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES_MATH_H
#define __ARES_MATH_H

#ifdef _MSC_VER
typedef __int64          ares_int64_t;
typedef unsigned __int64 ares_uint64_t;
#else
typedef long long          ares_int64_t;
typedef unsigned long long ares_uint64_t;
#endif

ares_bool_t   ares_is_64bit(void);
size_t        ares_round_up_pow2(size_t n);
size_t        ares_log2(size_t n);
size_t        ares_pow(size_t x, size_t y);
size_t        ares_count_digits(size_t n);
size_t        ares_count_hexdigits(size_t n);
unsigned char ares_count_bits_u8(unsigned char x);

#endif
                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/cares/src/lib/util/ares_rand.c                                                     0000664 0000000 0000000 00000025257 14746647661 0021234 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"
#include <stdlib.h>

/* Older MacOS versions require including AvailabilityMacros.h before
 * sys/random.h */
#ifdef HAVE_AVAILABILITYMACROS_H
#  include <AvailabilityMacros.h>
#endif

#ifdef HAVE_SYS_RANDOM_H
#  include <sys/random.h>
#endif


typedef enum {
  ARES_RAND_OS   = 1 << 0, /* OS-provided such as RtlGenRandom or arc4random */
  ARES_RAND_FILE = 1 << 1, /* OS file-backed random number generator */
  ARES_RAND_RC4  = 1 << 2  /* Internal RC4 based PRNG */
} ares_rand_backend;

#define ARES_RC4_KEY_LEN 32 /* 256 bits */

typedef struct ares_rand_rc4 {
  unsigned char S[256];
  size_t        i;
  size_t        j;
} ares_rand_rc4;

static unsigned int ares_u32_from_ptr(void *addr)
{
  /* LCOV_EXCL_START: FallbackCode */
  if (ares_is_64bit()) {
    return (unsigned int)((((ares_uint64_t)addr >> 32) & 0xFFFFFFFF) |
                          ((ares_uint64_t)addr & 0xFFFFFFFF));
  }
  return (unsigned int)((size_t)addr & 0xFFFFFFFF);
  /* LCOV_EXCL_STOP */
}

/* initialize an rc4 key as the last possible fallback. */
static void ares_rc4_generate_key(ares_rand_rc4 *rc4_state, unsigned char *key,
                                  size_t key_len)
{
  /* LCOV_EXCL_START: FallbackCode */
  size_t         i;
  size_t         len = 0;
  unsigned int   data;
  ares_timeval_t tv;

  if (key_len != ARES_RC4_KEY_LEN) {
    return;
  }

#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  /* For fuzzing, random should be deterministic */
  srand(0);
#else
  /* Randomness is hard to come by.  Maybe the system randomizes heap and stack
   * addresses. Maybe the current timestamp give us some randomness. Use
   * rc4_state (heap), &i (stack), and ares_tvnow()
   */
  data = ares_u32_from_ptr(rc4_state);
  memcpy(key + len, &data, sizeof(data));
  len += sizeof(data);

  data = ares_u32_from_ptr(&i);
  memcpy(key + len, &data, sizeof(data));
  len += sizeof(data);

  ares_tvnow(&tv);
  data = (unsigned int)((tv.sec | tv.usec) & 0xFFFFFFFF);
  memcpy(key + len, &data, sizeof(data));
  len += sizeof(data);

  srand(ares_u32_from_ptr(rc4_state) | ares_u32_from_ptr(&i) |
        (unsigned int)((tv.sec | tv.usec) & 0xFFFFFFFF));
#endif

  for (i = len; i < key_len; i++) {
    key[i] = (unsigned char)(rand() % 256); /* LCOV_EXCL_LINE */
  }
  /* LCOV_EXCL_STOP */
}

#define ARES_SWAP_BYTE(a, b)           \
  do {                                 \
    unsigned char swapByte = *(a);     \
    *(a)                   = *(b);     \
    *(b)                   = swapByte; \
  } while (0)

static void ares_rc4_init(ares_rand_rc4 *rc4_state)
{
  /* LCOV_EXCL_START: FallbackCode */
  unsigned char key[ARES_RC4_KEY_LEN];
  size_t        i;
  size_t        j;

  ares_rc4_generate_key(rc4_state, key, sizeof(key));

  for (i = 0; i < sizeof(rc4_state->S); i++) {
    rc4_state->S[i] = i & 0xFF;
  }

  for (i = 0, j = 0; i < 256; i++) {
    j = (j + rc4_state->S[i] + key[i % sizeof(key)]) % 256;
    ARES_SWAP_BYTE(&rc4_state->S[i], &rc4_state->S[j]);
  }

  rc4_state->i = 0;
  rc4_state->j = 0;
  /* LCOV_EXCL_STOP */
}

/* Just outputs the key schedule, no need to XOR with any data since we have
 * none */
static void ares_rc4_prng(ares_rand_rc4 *rc4_state, unsigned char *buf,
                          size_t len)
{
  /* LCOV_EXCL_START: FallbackCode */
  unsigned char *S = rc4_state->S;
  size_t         i = rc4_state->i;
  size_t         j = rc4_state->j;
  size_t         cnt;

  for (cnt = 0; cnt < len; cnt++) {
    i = (i + 1) % 256;
    j = (j + S[i]) % 256;

    ARES_SWAP_BYTE(&S[i], &S[j]);
    buf[cnt] = S[(S[i] + S[j]) % 256];
  }

  rc4_state->i = i;
  rc4_state->j = j;
  /* LCOV_EXCL_STOP */
}

struct ares_rand_state {
  ares_rand_backend type;
  ares_rand_backend bad_backends;

  union {
    FILE         *rand_file;
    ares_rand_rc4 rc4;
  } state;

  /* Since except for RC4, random data will likely result in a syscall, lets
   * pre-pull 256 bytes at a time.  Every query will pull 2 bytes off this so
   * that means we should only need a syscall every 128 queries. 256bytes
   * appears to be a sweet spot that may be able to be served without
   * interruption */
  unsigned char cache[256];
  size_t        cache_remaining;
};

/* Define RtlGenRandom = SystemFunction036.  This is in advapi32.dll.  There is
 * no need to dynamically load this, other software used widely does not.
 * http://blogs.msdn.com/michael_howard/archive/2005/01/14/353379.aspx
 * https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom
 */
#ifdef _WIN32
BOOLEAN WINAPI SystemFunction036(PVOID RandomBuffer, ULONG RandomBufferLength);
#  ifndef RtlGenRandom
#    define RtlGenRandom(a, b) SystemFunction036(a, b)
#  endif
#endif


static ares_bool_t ares_init_rand_engine(ares_rand_state *state)
{
  state->cache_remaining = 0;

#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  /* For fuzzing, random should be deterministic */
  state->bad_backends |= ARES_RAND_OS | ARES_RAND_FILE;
#endif

#if defined(HAVE_ARC4RANDOM_BUF) || defined(HAVE_GETRANDOM) || defined(_WIN32)
  if (!(state->bad_backends & ARES_RAND_OS)) {
    state->type = ARES_RAND_OS;
    return ARES_TRUE;
  }
#endif

#if defined(CARES_RANDOM_FILE)
  /* LCOV_EXCL_START: FallbackCode */
  if (!(state->bad_backends & ARES_RAND_FILE)) {
    state->type            = ARES_RAND_FILE;
    state->state.rand_file = fopen(CARES_RANDOM_FILE, "rb");
    if (state->state.rand_file) {
      setvbuf(state->state.rand_file, NULL, _IONBF, 0);
      return ARES_TRUE;
    }
  }
  /* LCOV_EXCL_STOP */

  /* Fall-Thru on failure to RC4 */
#endif

  /* LCOV_EXCL_START: FallbackCode */
  state->type = ARES_RAND_RC4;
  ares_rc4_init(&state->state.rc4);
  /* LCOV_EXCL_STOP */

  /* Currently cannot fail */
  return ARES_TRUE; /* LCOV_EXCL_LINE: UntestablePath */
}

ares_rand_state *ares_init_rand_state(void)
{
  ares_rand_state *state = NULL;

  state = ares_malloc_zero(sizeof(*state));
  if (!state) {
    return NULL;
  }

  if (!ares_init_rand_engine(state)) {
    ares_free(state); /* LCOV_EXCL_LINE: UntestablePath */
    return NULL;      /* LCOV_EXCL_LINE: UntestablePath */
  }

  return state;
}

static void ares_clear_rand_state(ares_rand_state *state)
{
  if (!state) {
    return; /* LCOV_EXCL_LINE: DefensiveCoding */
  }

  switch (state->type) {
    case ARES_RAND_OS:
      break;
    /* LCOV_EXCL_START: FallbackCode */
    case ARES_RAND_FILE:
      fclose(state->state.rand_file);
      break;
    case ARES_RAND_RC4:
      break;
      /* LCOV_EXCL_STOP */
  }
}

static void ares_reinit_rand(ares_rand_state *state)
{
  /* LCOV_EXCL_START: UntestablePath */
  ares_clear_rand_state(state);
  ares_init_rand_engine(state);
  /* LCOV_EXCL_STOP */
}

void ares_destroy_rand_state(ares_rand_state *state)
{
  if (!state) {
    return;
  }

  ares_clear_rand_state(state);
  ares_free(state);
}

static void ares_rand_bytes_fetch(ares_rand_state *state, unsigned char *buf,
                                  size_t len)
{
  while (1) {
    size_t bytes_read = 0;

    switch (state->type) {
      case ARES_RAND_OS:
#ifdef _WIN32
        RtlGenRandom(buf, (ULONG)len);
        return;
#elif defined(HAVE_ARC4RANDOM_BUF)
        arc4random_buf(buf, len);
        return;
#elif defined(HAVE_GETRANDOM)
        while (1) {
          size_t  n = len - bytes_read;
          /* getrandom() on Linux always succeeds and is never
           * interrupted by a signal when requesting <= 256 bytes.
           */
          ssize_t rv = getrandom(buf + bytes_read, n > 256 ? 256 : n, 0);
          if (rv <= 0) {
            /* We need to fall back to another backend */
            if (errno == ENOSYS) {
              state->bad_backends |= ARES_RAND_OS;
              break;
            }
            continue; /* Just retry. */
          }

          bytes_read += (size_t)rv;
          if (bytes_read == len) {
            return;
          }
        }
        break;
#else
        /* Shouldn't be possible to be here */
        break;
#endif

        /* LCOV_EXCL_START: FallbackCode */

      case ARES_RAND_FILE:
        while (1) {
          size_t rv = fread(buf + bytes_read, 1, len - bytes_read,
                            state->state.rand_file);
          if (rv == 0) {
            break; /* critical error, will reinit rand state */
          }

          bytes_read += rv;
          if (bytes_read == len) {
            return;
          }
        }
        break;

      case ARES_RAND_RC4:
        ares_rc4_prng(&state->state.rc4, buf, len);
        return;

        /* LCOV_EXCL_STOP */
    }

    /* If we didn't return before we got here, that means we had a critical rand
     * failure and need to reinitialized */
    ares_reinit_rand(state); /* LCOV_EXCL_LINE: UntestablePath */
  }
}

void ares_rand_bytes(ares_rand_state *state, unsigned char *buf, size_t len)
{
  /* See if we need to refill the cache to serve the request, but if len is
   * excessive, we're not going to update our cache or serve from cache */
  if (len > state->cache_remaining && len < sizeof(state->cache)) {
    size_t fetch_size = sizeof(state->cache) - state->cache_remaining;
    ares_rand_bytes_fetch(state, state->cache, fetch_size);
    state->cache_remaining = sizeof(state->cache);
  }

  /* Serve from cache */
  if (len <= state->cache_remaining) {
    size_t offset = sizeof(state->cache) - state->cache_remaining;
    memcpy(buf, state->cache + offset, len);
    state->cache_remaining -= len;
    return;
  }

  /* Serve direct due to excess size of request */
  ares_rand_bytes_fetch(state, buf, len);
}

unsigned short ares_generate_new_id(ares_rand_state *state)
{
  unsigned short r = 0;

  ares_rand_bytes(state, (unsigned char *)&r, sizeof(r));
  return r;
}
                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/cares/src/lib/util/ares_rand.h                                                     0000664 0000000 0000000 00000003006 14746647661 0021225 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES_RAND_H
#define __ARES_RAND_H

struct ares_rand_state;
typedef struct ares_rand_state ares_rand_state;

ares_rand_state               *ares_init_rand_state(void);
void                           ares_destroy_rand_state(ares_rand_state *state);
void ares_rand_bytes(ares_rand_state *state, unsigned char *buf, size_t len);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/cares/src/lib/util/ares_threads.c                                                  0000664 0000000 0000000 00000032243 14746647661 0021733 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#include "ares_private.h"

#ifdef CARES_THREADS
#  ifdef _WIN32

struct ares_thread_mutex {
  CRITICAL_SECTION mutex;
};

ares_thread_mutex_t *ares_thread_mutex_create(void)
{
  ares_thread_mutex_t *mut = ares_malloc_zero(sizeof(*mut));
  if (mut == NULL) {
    return NULL;
  }

  InitializeCriticalSection(&mut->mutex);
  return mut;
}

void ares_thread_mutex_destroy(ares_thread_mutex_t *mut)
{
  if (mut == NULL) {
    return;
  }
  DeleteCriticalSection(&mut->mutex);
  ares_free(mut);
}

void ares_thread_mutex_lock(ares_thread_mutex_t *mut)
{
  if (mut == NULL) {
    return;
  }
  EnterCriticalSection(&mut->mutex);
}

void ares_thread_mutex_unlock(ares_thread_mutex_t *mut)
{
  if (mut == NULL) {
    return;
  }
  LeaveCriticalSection(&mut->mutex);
}

struct ares_thread_cond {
  CONDITION_VARIABLE cond;
};

ares_thread_cond_t *ares_thread_cond_create(void)
{
  ares_thread_cond_t *cond = ares_malloc_zero(sizeof(*cond));
  if (cond == NULL) {
    return NULL;
  }
  InitializeConditionVariable(&cond->cond);
  return cond;
}

void ares_thread_cond_destroy(ares_thread_cond_t *cond)
{
  if (cond == NULL) {
    return;
  }
  ares_free(cond);
}

void ares_thread_cond_signal(ares_thread_cond_t *cond)
{
  if (cond == NULL) {
    return;
  }
  WakeConditionVariable(&cond->cond);
}

void ares_thread_cond_broadcast(ares_thread_cond_t *cond)
{
  if (cond == NULL) {
    return;
  }
  WakeAllConditionVariable(&cond->cond);
}

ares_status_t ares_thread_cond_wait(ares_thread_cond_t  *cond,
                                    ares_thread_mutex_t *mut)
{
  if (cond == NULL || mut == NULL) {
    return ARES_EFORMERR;
  }

  SleepConditionVariableCS(&cond->cond, &mut->mutex, INFINITE);
  return ARES_SUCCESS;
}

ares_status_t ares_thread_cond_timedwait(ares_thread_cond_t  *cond,
                                         ares_thread_mutex_t *mut,
                                         unsigned long        timeout_ms)
{
  if (cond == NULL || mut == NULL) {
    return ARES_EFORMERR;
  }

  if (!SleepConditionVariableCS(&cond->cond, &mut->mutex, timeout_ms)) {
    return ARES_ETIMEOUT;
  }

  return ARES_SUCCESS;
}

struct ares_thread {
  HANDLE thread;
  DWORD  id;

  void *(*func)(void *arg);
  void *arg;
  void *rv;
};

/* Wrap for pthread compatibility */
static DWORD WINAPI ares_thread_func(LPVOID lpParameter)
{
  ares_thread_t *thread = lpParameter;

  thread->rv = thread->func(thread->arg);
  return 0;
}

ares_status_t ares_thread_create(ares_thread_t    **thread,
                                 ares_thread_func_t func, void *arg)
{
  ares_thread_t *thr = NULL;

  if (func == NULL || thread == NULL) {
    return ARES_EFORMERR;
  }

  thr = ares_malloc_zero(sizeof(*thr));
  if (thr == NULL) {
    return ARES_ENOMEM;
  }

  thr->func   = func;
  thr->arg    = arg;
  thr->thread = CreateThread(NULL, 0, ares_thread_func, thr, 0, &thr->id);
  if (thr->thread == NULL) {
    ares_free(thr);
    return ARES_ESERVFAIL;
  }

  *thread = thr;
  return ARES_SUCCESS;
}

ares_status_t ares_thread_join(ares_thread_t *thread, void **rv)
{
  ares_status_t status = ARES_SUCCESS;

  if (thread == NULL) {
    return ARES_EFORMERR;
  }

  if (WaitForSingleObject(thread->thread, INFINITE) != WAIT_OBJECT_0) {
    status = ARES_ENOTFOUND;
  } else {
    CloseHandle(thread->thread);
  }

  if (status == ARES_SUCCESS && rv != NULL) {
    *rv = thread->rv;
  }
  ares_free(thread);

  return status;
}

#  else /* !WIN32 == PTHREAD */
#    include <pthread.h>

/* for clock_gettime() */
#    ifdef HAVE_TIME_H
#      include <time.h>
#    endif

/* for gettimeofday() */
#    ifdef HAVE_SYS_TIME_H
#      include <sys/time.h>
#    endif

struct ares_thread_mutex {
  pthread_mutex_t mutex;
};

ares_thread_mutex_t *ares_thread_mutex_create(void)
{
  pthread_mutexattr_t  attr;
  ares_thread_mutex_t *mut = ares_malloc_zero(sizeof(*mut));
  if (mut == NULL) {
    return NULL;
  }

  if (pthread_mutexattr_init(&attr) != 0) {
    ares_free(mut); /* LCOV_EXCL_LINE: UntestablePath */
    return NULL;    /* LCOV_EXCL_LINE: UntestablePath */
  }

  if (pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE) != 0) {
    goto fail; /* LCOV_EXCL_LINE: UntestablePath */
  }

  if (pthread_mutex_init(&mut->mutex, &attr) != 0) {
    goto fail; /* LCOV_EXCL_LINE: UntestablePath */
  }

  pthread_mutexattr_destroy(&attr);
  return mut;

/* LCOV_EXCL_START: UntestablePath */
fail:
  pthread_mutexattr_destroy(&attr);
  ares_free(mut);
  return NULL;
  /* LCOV_EXCL_STOP */
}

void ares_thread_mutex_destroy(ares_thread_mutex_t *mut)
{
  if (mut == NULL) {
    return;
  }
  pthread_mutex_destroy(&mut->mutex);
  ares_free(mut);
}

void ares_thread_mutex_lock(ares_thread_mutex_t *mut)
{
  if (mut == NULL) {
    return;
  }
  pthread_mutex_lock(&mut->mutex);
}

void ares_thread_mutex_unlock(ares_thread_mutex_t *mut)
{
  if (mut == NULL) {
    return;
  }
  pthread_mutex_unlock(&mut->mutex);
}

struct ares_thread_cond {
  pthread_cond_t cond;
};

ares_thread_cond_t *ares_thread_cond_create(void)
{
  ares_thread_cond_t *cond = ares_malloc_zero(sizeof(*cond));
  if (cond == NULL) {
    return NULL;
  }
  pthread_cond_init(&cond->cond, NULL);
  return cond;
}

void ares_thread_cond_destroy(ares_thread_cond_t *cond)
{
  if (cond == NULL) {
    return;
  }
  pthread_cond_destroy(&cond->cond);
  ares_free(cond);
}

void ares_thread_cond_signal(ares_thread_cond_t *cond)
{
  if (cond == NULL) {
    return;
  }
  pthread_cond_signal(&cond->cond);
}

void ares_thread_cond_broadcast(ares_thread_cond_t *cond)
{
  if (cond == NULL) {
    return;
  }
  pthread_cond_broadcast(&cond->cond);
}

ares_status_t ares_thread_cond_wait(ares_thread_cond_t  *cond,
                                    ares_thread_mutex_t *mut)
{
  if (cond == NULL || mut == NULL) {
    return ARES_EFORMERR;
  }

  pthread_cond_wait(&cond->cond, &mut->mutex);
  return ARES_SUCCESS;
}

static void ares_timespec_timeout(struct timespec *ts, unsigned long add_ms)
{
#    if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_REALTIME)
  clock_gettime(CLOCK_REALTIME, ts);
#    elif defined(HAVE_GETTIMEOFDAY)
  struct timeval tv;
  gettimeofday(&tv, NULL);
  ts->tv_sec  = tv.tv_sec;
  ts->tv_nsec = tv.tv_usec * 1000;
#    else
#      error cannot determine current system time
#    endif

  ts->tv_sec  += (time_t)(add_ms / 1000);
  ts->tv_nsec += (long)((add_ms % 1000) * 1000000);

  /* Normalize if needed */
  if (ts->tv_nsec >= 1000000000) {
    ts->tv_sec  += ts->tv_nsec / 1000000000;
    ts->tv_nsec %= 1000000000;
  }
}

ares_status_t ares_thread_cond_timedwait(ares_thread_cond_t  *cond,
                                         ares_thread_mutex_t *mut,
                                         unsigned long        timeout_ms)
{
  struct timespec ts;

  if (cond == NULL || mut == NULL) {
    return ARES_EFORMERR;
  }

  ares_timespec_timeout(&ts, timeout_ms);

  if (pthread_cond_timedwait(&cond->cond, &mut->mutex, &ts) != 0) {
    return ARES_ETIMEOUT;
  }

  return ARES_SUCCESS;
}

struct ares_thread {
  pthread_t thread;
};

ares_status_t ares_thread_create(ares_thread_t    **thread,
                                 ares_thread_func_t func, void *arg)
{
  ares_thread_t *thr = NULL;

  if (func == NULL || thread == NULL) {
    return ARES_EFORMERR;
  }

  thr = ares_malloc_zero(sizeof(*thr));
  if (thr == NULL) {
    return ARES_ENOMEM; /* LCOV_EXCL_LINE: OutOfMemory */
  }
  if (pthread_create(&thr->thread, NULL, func, arg) != 0) {
    ares_free(thr);        /* LCOV_EXCL_LINE: UntestablePath */
    return ARES_ESERVFAIL; /* LCOV_EXCL_LINE: UntestablePath */
  }

  *thread = thr;
  return ARES_SUCCESS;
}

ares_status_t ares_thread_join(ares_thread_t *thread, void **rv)
{
  void         *ret    = NULL;
  ares_status_t status = ARES_SUCCESS;

  if (thread == NULL) {
    return ARES_EFORMERR;
  }

  if (pthread_join(thread->thread, &ret) != 0) {
    status = ARES_ENOTFOUND;
  }
  ares_free(thread);

  if (status == ARES_SUCCESS && rv != NULL) {
    *rv = ret;
  }
  return status;
}

#  endif

ares_bool_t ares_threadsafety(void)
{
  return ARES_TRUE;
}

#else /* !CARES_THREADS */

/* NoOp */
ares_thread_mutex_t *ares_thread_mutex_create(void)
{
  return NULL;
}

void ares_thread_mutex_destroy(ares_thread_mutex_t *mut)
{
  (void)mut;
}

void ares_thread_mutex_lock(ares_thread_mutex_t *mut)
{
  (void)mut;
}

void ares_thread_mutex_unlock(ares_thread_mutex_t *mut)
{
  (void)mut;
}

ares_thread_cond_t *ares_thread_cond_create(void)
{
  return NULL;
}

void ares_thread_cond_destroy(ares_thread_cond_t *cond)
{
  (void)cond;
}

void ares_thread_cond_signal(ares_thread_cond_t *cond)
{
  (void)cond;
}

void ares_thread_cond_broadcast(ares_thread_cond_t *cond)
{
  (void)cond;
}

ares_status_t ares_thread_cond_wait(ares_thread_cond_t  *cond,
                                    ares_thread_mutex_t *mut)
{
  (void)cond;
  (void)mut;
  return ARES_ENOTIMP;
}

ares_status_t ares_thread_cond_timedwait(ares_thread_cond_t  *cond,
                                         ares_thread_mutex_t *mut,
                                         unsigned long        timeout_ms)
{
  (void)cond;
  (void)mut;
  (void)timeout_ms;
  return ARES_ENOTIMP;
}

ares_status_t ares_thread_create(ares_thread_t    **thread,
                                 ares_thread_func_t func, void *arg)
{
  (void)thread;
  (void)func;
  (void)arg;
  return ARES_ENOTIMP;
}

ares_status_t ares_thread_join(ares_thread_t *thread, void **rv)
{
  (void)thread;
  (void)rv;
  return ARES_ENOTIMP;
}

ares_bool_t ares_threadsafety(void)
{
  return ARES_FALSE;
}
#endif


ares_status_t ares_channel_threading_init(ares_channel_t *channel)
{
  ares_status_t status = ARES_SUCCESS;

  /* Threading is optional! */
  if (!ares_threadsafety()) {
    return ARES_SUCCESS;
  }

  channel->lock = ares_thread_mutex_create();
  if (channel->lock == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  channel->cond_empty = ares_thread_cond_create();
  if (channel->cond_empty == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

done:
  if (status != ARES_SUCCESS) {
    ares_channel_threading_destroy(channel);
  }
  return status;
}

void ares_channel_threading_destroy(ares_channel_t *channel)
{
  ares_thread_mutex_destroy(channel->lock);
  channel->lock = NULL;
  ares_thread_cond_destroy(channel->cond_empty);
  channel->cond_empty = NULL;
}

void ares_channel_lock(const ares_channel_t *channel)
{
  ares_thread_mutex_lock(channel->lock);
}

void ares_channel_unlock(const ares_channel_t *channel)
{
  ares_thread_mutex_unlock(channel->lock);
}

/* Must not be holding a channel lock already, public function only */
ares_status_t ares_queue_wait_empty(ares_channel_t *channel, int timeout_ms)
{
  ares_status_t  status = ARES_SUCCESS;
  ares_timeval_t tout;

  if (!ares_threadsafety()) {
    return ARES_ENOTIMP;
  }

  if (channel == NULL) {
    return ARES_EFORMERR;
  }

  if (timeout_ms >= 0) {
    ares_tvnow(&tout);
    tout.sec  += (ares_int64_t)(timeout_ms / 1000);
    tout.usec += (unsigned int)(timeout_ms % 1000) * 1000;
  }

  ares_thread_mutex_lock(channel->lock);
  while (ares_llist_len(channel->all_queries)) {
    if (timeout_ms < 0) {
      ares_thread_cond_wait(channel->cond_empty, channel->lock);
    } else {
      ares_timeval_t tv_remaining;
      ares_timeval_t tv_now;
      unsigned long  tms;

      ares_tvnow(&tv_now);
      ares_timeval_remaining(&tv_remaining, &tv_now, &tout);
      tms =
        (unsigned long)((tv_remaining.sec * 1000) + (tv_remaining.usec / 1000));
      if (tms == 0) {
        status = ARES_ETIMEOUT;
      } else {
        status =
          ares_thread_cond_timedwait(channel->cond_empty, channel->lock, tms);
      }

      /* If there was a timeout, don't loop.  Otherwise, make sure this wasn't
       * a spurious wakeup by looping and checking the condition. */
      if (status == ARES_ETIMEOUT) {
        break;
      }
    }
  }
  ares_thread_mutex_unlock(channel->lock);
  return status;
}

void ares_queue_notify_empty(ares_channel_t *channel)
{
  if (channel == NULL) {
    return;
  }

  /* We are guaranteed to be holding a channel lock already */
  if (ares_llist_len(channel->all_queries)) {
    return;
  }

  /* Notify all waiters of the conditional */
  ares_thread_cond_broadcast(channel->cond_empty);
}
                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/cares/src/lib/util/ares_threads.h                                                  0000664 0000000 0000000 00000005003 14746647661 0021732 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2023 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES__THREADS_H
#define __ARES__THREADS_H

struct ares_thread_mutex;
typedef struct ares_thread_mutex ares_thread_mutex_t;

ares_thread_mutex_t             *ares_thread_mutex_create(void);
void ares_thread_mutex_destroy(ares_thread_mutex_t *mut);
void ares_thread_mutex_lock(ares_thread_mutex_t *mut);
void ares_thread_mutex_unlock(ares_thread_mutex_t *mut);


struct ares_thread_cond;
typedef struct ares_thread_cond ares_thread_cond_t;

ares_thread_cond_t             *ares_thread_cond_create(void);
void          ares_thread_cond_destroy(ares_thread_cond_t *cond);
void          ares_thread_cond_signal(ares_thread_cond_t *cond);
void          ares_thread_cond_broadcast(ares_thread_cond_t *cond);
ares_status_t ares_thread_cond_wait(ares_thread_cond_t  *cond,
                                    ares_thread_mutex_t *mut);
ares_status_t ares_thread_cond_timedwait(ares_thread_cond_t  *cond,
                                         ares_thread_mutex_t *mut,
                                         unsigned long        timeout_ms);


struct ares_thread;
typedef struct ares_thread ares_thread_t;

typedef void *(*ares_thread_func_t)(void *arg);
ares_status_t ares_thread_create(ares_thread_t    **thread,
                                 ares_thread_func_t func, void *arg);
ares_status_t ares_thread_join(ares_thread_t *thread, void **rv);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/cares/src/lib/util/ares_time.h                                                     0000664 0000000 0000000 00000004063 14746647661 0021243 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad House
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef __ARES_TIME_H
#define __ARES_TIME_H

/*! struct timeval on some systems like Windows doesn't support 64bit time so
 *  therefore can't be used due to Y2K38 issues.  Make our own that does have
 *  64bit time. */
typedef struct {
  ares_int64_t sec;  /*!< Seconds */
  unsigned int usec; /*!< Microseconds. Can't be negative. */
} ares_timeval_t;

/* return true if now is exactly check time or later */
ares_bool_t ares_timedout(const ares_timeval_t *now,
                          const ares_timeval_t *check);

void        ares_tvnow(ares_timeval_t *now);
void        ares_timeval_remaining(ares_timeval_t       *remaining,
                                   const ares_timeval_t *now,
                                   const ares_timeval_t *tout);
void ares_timeval_diff(ares_timeval_t *tvdiff, const ares_timeval_t *tvstart,
                       const ares_timeval_t *tvstop);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/cares/src/lib/util/ares_timeval.c                                                  0000664 0000000 0000000 00000006512 14746647661 0021742 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2008 Daniel Stenberg
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */

#include "ares_private.h"

#if defined(_WIN32) && !defined(MSDOS)

void ares_tvnow(ares_timeval_t *now)
{
  /* QueryPerformanceCounters() has been around since Windows 2000, though
   * significant fixes were made in later versions.  Documentation states
   * 1 microsecond or better resolution with a rollover not less than 100 years.
   * This differs from GetTickCount{64}() which has a resolution between 10 and
   * 16 ms. */
  LARGE_INTEGER freq;
  LARGE_INTEGER current;

  /* Not sure how long it takes to get the frequency, I see it recommended to
   * cache it */
  QueryPerformanceFrequency(&freq);
  QueryPerformanceCounter(&current);

  now->sec = current.QuadPart / freq.QuadPart;
  /* We want to prevent overflows so we get the remainder, then multiply to
   * microseconds before dividing */
  now->usec = (unsigned int)(((current.QuadPart % freq.QuadPart) * 1000000) /
                             freq.QuadPart);
}

#elif defined(HAVE_CLOCK_GETTIME_MONOTONIC)

void ares_tvnow(ares_timeval_t *now)
{
  /* clock_gettime() is guaranteed to be increased monotonically when the
   * monotonic clock is queried. Time starting point is unspecified, it
   * could be the system start-up time, the Epoch, or something else,
   * in any case the time starting point does not change once that the
   * system has started up. */
  struct timespec tsnow;

  if (clock_gettime(CLOCK_MONOTONIC, &tsnow) == 0) {
    now->sec  = (ares_int64_t)tsnow.tv_sec;
    now->usec = (unsigned int)(tsnow.tv_nsec / 1000);
  } else {
    /* LCOV_EXCL_START: FallbackCode */
    struct timeval tv;
    (void)gettimeofday(&tv, NULL);
    now->sec  = (ares_int64_t)tv.tv_sec;
    now->usec = (unsigned int)tv.tv_usec;
    /* LCOV_EXCL_STOP */
  }
}

#elif defined(HAVE_GETTIMEOFDAY)

void ares_tvnow(ares_timeval_t *now)
{
  /* gettimeofday() is not granted to be increased monotonically, due to
   * clock drifting and external source time synchronization it can jump
   * forward or backward in time. */
  struct timeval tv;

  (void)gettimeofday(&tv, NULL);
  now->sec  = (ares_int64_t)tv.tv_sec;
  now->usec = (unsigned int)tv.tv_usec;
}

#else

#  error missing sub-second time retrieval function

#endif
                                                                                                                                                                                      node-23.7.0/deps/cares/src/lib/util/ares_uri.c                                                      0000664 0000000 0000000 00000107114 14746647661 0021100 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* MIT License
 *
 * Copyright (c) 2024 Brad house
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * SPDX-License-Identifier: MIT
 */


#include "ares_private.h"
#include "ares_uri.h"
#ifdef HAVE_STDINT_H
#  include <stdint.h>
#endif

struct ares_uri {
  char                scheme[16];
  char               *username;
  char               *password;
  unsigned short      port;
  char                host[256];
  char               *path;
  ares_htable_dict_t *query;
  char               *fragment;
};

/* RFC3986 character set notes:
 *    gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
 *    sub-delims  = "!" / "$" / "&" / "'" / "(" / ")"
 *                / "*" / "+" / "," / ";" / "="
 *    reserved    = gen-delims / sub-delims
 *    unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
 *    authority   = [ userinfo "@" ] host [ ":" port ]
 *    userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )
 *    NOTE: Use of the format "user:password" in the userinfo field is
 *          deprecated.  Applications should not render as clear text any data
 *          after the first colon (":") character found within a userinfo
 *          subcomponent unless the data after the colon is the empty string
 *           (indicating no password).
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    query       = *( pchar / "/" / "?" )
 *    fragment    = *( pchar / "/" / "?" )
 *
 *   NOTE: Due to ambiguity, "+" in a query must be percent-encoded, as old
 *         URLs used that for spaces.
 */


static ares_bool_t ares_uri_chis_subdelim(char x)
{
  switch (x) {
    case '!':
      return ARES_TRUE;
    case '$':
      return ARES_TRUE;
    case '&':
      return ARES_TRUE;
    case '\'':
      return ARES_TRUE;
    case '(':
      return ARES_TRUE;
    case ')':
      return ARES_TRUE;
    case '*':
      return ARES_TRUE;
    case '+':
      return ARES_TRUE;
    case ',':
      return ARES_TRUE;
    case ';':
      return ARES_TRUE;
    case '=':
      return ARES_TRUE;
    default:
      break;
  }
  return ARES_FALSE;
}

/* These don't actually appear to be referenced in any logic */
#if 0
static ares_bool_t ares_uri_chis_gendelim(char x)
{
  switch (x) {
    case ':':
      return ARES_TRUE;
    case '/':
      return ARES_TRUE;
    case '?':
      return ARES_TRUE;
    case '#':
      return ARES_TRUE;
    case '[':
      return ARES_TRUE;
    case ']':
      return ARES_TRUE;
    case '@':
      return ARES_TRUE;
    default:
      break;
  }
  return ARES_FALSE;
}


static ares_bool_t ares_uri_chis_reserved(char x)
{
  return ares_uri_chis_gendelim(x) || ares_uri_chis_subdelim(x);
}
#endif

static ares_bool_t ares_uri_chis_unreserved(char x)
{
  switch (x) {
    case '-':
      return ARES_TRUE;
    case '.':
      return ARES_TRUE;
    case '_':
      return ARES_TRUE;
    case '~':
      return ARES_TRUE;
    default:
      break;
  }
  return ares_isalpha(x) || ares_isdigit(x);
}

static ares_bool_t ares_uri_chis_scheme(char x)
{
  switch (x) {
    case '+':
      return ARES_TRUE;
    case '-':
      return ARES_TRUE;
    case '.':
      return ARES_TRUE;
    default:
      break;
  }
  return ares_isalpha(x) || ares_isdigit(x);
}

static ares_bool_t ares_uri_chis_authority(char x)
{
  /* This one here isn't well defined.  We are going to include the valid
   * characters of the subfields plus known delimiters */
  return ares_uri_chis_unreserved(x) || ares_uri_chis_subdelim(x) || x == '%' ||
         x == '[' || x == ']' || x == '@' || x == ':';
}

static ares_bool_t ares_uri_chis_userinfo(char x)
{
  /* NOTE: we don't include ':' here since we are using that as our
   *       username/password delimiter */
  return ares_uri_chis_unreserved(x) || ares_uri_chis_subdelim(x);
}

static ares_bool_t ares_uri_chis_path(char x)
{
  switch (x) {
    case ':':
      return ARES_TRUE;
    case '@':
      return ARES_TRUE;
    /* '/' isn't in the spec as a path character since its technically a
     * delimiter but we're not splitting on '/' so we accept it as valid */
    case '/':
      return ARES_TRUE;
    default:
      break;
  }
  return ares_uri_chis_unreserved(x) || ares_uri_chis_subdelim(x);
}

static ares_bool_t ares_uri_chis_path_enc(char x)
{
  return ares_uri_chis_path(x) || x == '%';
}

static ares_bool_t ares_uri_chis_query(char x)
{
  switch (x) {
    case '/':
      return ARES_TRUE;
    case '?':
      return ARES_TRUE;
    default:
      break;
  }

  /* Exclude & and = used as delimiters, they're valid characters in the
   * set, just not for the individual pieces */
  return ares_uri_chis_path(x) && x != '&' && x != '=';
}

static ares_bool_t ares_uri_chis_query_enc(char x)
{
  return ares_uri_chis_query(x) || x == '%';
}

static ares_bool_t ares_uri_chis_fragment(char x)
{
  switch (x) {
    case '/':
      return ARES_TRUE;
    case '?':
      return ARES_TRUE;
    default:
      break;
  }
  return ares_uri_chis_path(x);
}

static ares_bool_t ares_uri_chis_fragment_enc(char x)
{
  return ares_uri_chis_fragment(x) || x == '%';
}

ares_uri_t *ares_uri_create(void)
{
  ares_uri_t *uri = ares_malloc_zero(sizeof(*uri));

  if (uri == NULL) {
    return NULL;
  }

  uri->query = ares_htable_dict_create();
  if (uri->query == NULL) {
    ares_free(uri);
    return NULL;
  }

  return uri;
}

void ares_uri_destroy(ares_uri_t *uri)
{
  if (uri == NULL) {
    return;
  }

  ares_free(uri->username);
  ares_free(uri->password);
  ares_free(uri->path);
  ares_free(uri->fragment);
  ares_htable_dict_destroy(uri->query);
  ares_free(uri);
}

static ares_bool_t ares_uri_scheme_is_valid(const char *uri)
{
  size_t i;

  if (ares_strlen(uri) == 0) {
    return ARES_FALSE;
  }

  if (!ares_isalpha(*uri)) {
    return ARES_FALSE;
  }

  for (i = 0; uri[i] != 0; i++) {
    if (!ares_uri_chis_scheme(uri[i])) {
      return ARES_FALSE;
    }
  }
  return ARES_TRUE;
}

static ares_bool_t ares_uri_str_isvalid(const char *str, size_t max_len,
                                        ares_bool_t (*ischr)(char))
{
  size_t i;

  if (str == NULL) {
    return ARES_FALSE;
  }

  for (i = 0; i != max_len && str[i] != 0; i++) {
    if (!ischr(str[i])) {
      return ARES_FALSE;
    }
  }
  return ARES_TRUE;
}

ares_status_t ares_uri_set_scheme(ares_uri_t *uri, const char *scheme)
{
  if (uri == NULL) {
    return ARES_EFORMERR;
  }

  if (!ares_uri_scheme_is_valid(scheme)) {
    return ARES_EBADSTR;
  }

  ares_strcpy(uri->scheme, scheme, sizeof(uri->scheme));
  ares_str_lower(uri->scheme);

  return ARES_SUCCESS;
}

const char *ares_uri_get_scheme(const ares_uri_t *uri)
{
  if (uri == NULL) {
    return NULL;
  }

  return uri->scheme;
}

static ares_status_t ares_uri_set_username_own(ares_uri_t *uri, char *username)
{
  if (uri == NULL) {
    return ARES_EFORMERR;
  }

  if (username != NULL && (!ares_str_isprint(username, ares_strlen(username)) ||
                           ares_strlen(username) == 0)) {
    return ARES_EBADSTR;
  }


  ares_free(uri->username);
  uri->username = username;
  return ARES_SUCCESS;
}

ares_status_t ares_uri_set_username(ares_uri_t *uri, const char *username)
{
  ares_status_t status;
  char         *temp = NULL;

  if (uri == NULL) {
    return ARES_EFORMERR;
  }

  if (username != NULL) {
    temp = ares_strdup(username);
    if (temp == NULL) {
      return ARES_ENOMEM;
    }
  }

  status = ares_uri_set_username_own(uri, temp);
  if (status != ARES_SUCCESS) {
    ares_free(temp);
  }

  return status;
}

const char *ares_uri_get_username(const ares_uri_t *uri)
{
  if (uri == NULL) {
    return NULL;
  }

  return uri->username;
}

static ares_status_t ares_uri_set_password_own(ares_uri_t *uri, char *password)
{
  if (uri == NULL) {
    return ARES_EFORMERR;
  }

  if (password != NULL && !ares_str_isprint(password, ares_strlen(password))) {
    return ARES_EBADSTR;
  }

  ares_free(uri->password);
  uri->password = password;
  return ARES_SUCCESS;
}

ares_status_t ares_uri_set_password(ares_uri_t *uri, const char *password)
{
  ares_status_t status;
  char         *temp = NULL;

  if (uri == NULL) {
    return ARES_EFORMERR;
  }

  if (password != NULL) {
    temp = ares_strdup(password);
    if (temp == NULL) {
      return ARES_ENOMEM;
    }
  }

  status = ares_uri_set_password_own(uri, temp);
  if (status != ARES_SUCCESS) {
    ares_free(temp);
  }

  return status;
}

const char *ares_uri_get_password(const ares_uri_t *uri)
{
  if (uri == NULL) {
    return NULL;
  }

  return uri->password;
}

ares_status_t ares_uri_set_host(ares_uri_t *uri, const char *host)
{
  struct ares_addr addr;
  size_t           addrlen;
  char             hoststr[256];
  char            *ll_scope;

  if (uri == NULL || ares_strlen(host) == 0 ||
      ares_strlen(host) >= sizeof(hoststr)) {
    return ARES_EFORMERR;
  }

  ares_strcpy(hoststr, host, sizeof(hoststr));

  /* Look for '%' which could be a link-local scope for ipv6 addresses and
   * parse it off */
  ll_scope = strchr(hoststr, '%');
  if (ll_scope != NULL) {
    *ll_scope = 0;
    ll_scope++;
    if (!ares_str_isalnum(ll_scope)) {
      return ARES_EBADNAME;
    }
  }

  /* If its an IP address, normalize it */
  memset(&addr, 0, sizeof(addr));
  addr.family = AF_UNSPEC;
  if (ares_dns_pton(hoststr, &addr, &addrlen) != NULL) {
    char ipaddr[INET6_ADDRSTRLEN];
    ares_inet_ntop(addr.family, &addr.addr, ipaddr, sizeof(ipaddr));
    /* Only IPv6 is allowed to have a scope */
    if (ll_scope != NULL && addr.family != AF_INET6) {
      return ARES_EBADNAME;
    }

    if (ll_scope != NULL) {
      snprintf(uri->host, sizeof(uri->host), "%s%%%s", ipaddr, ll_scope);
    } else {
      ares_strcpy(uri->host, ipaddr, sizeof(uri->host));
    }
    return ARES_SUCCESS;
  }

  /* If its a hostname, make sure its a valid charset */
  if (!ares_is_hostname(host)) {
    return ARES_EBADNAME;
  }

  ares_strcpy(uri->host, host, sizeof(uri->host));
  return ARES_SUCCESS;
}

const char *ares_uri_get_host(const ares_uri_t *uri)
{
  if (uri == NULL) {
    return NULL;
  }

  return uri->host;
}

ares_status_t ares_uri_set_port(ares_uri_t *uri, unsigned short port)
{
  if (uri == NULL) {
    return ARES_EFORMERR;
  }
  uri->port = port;
  return ARES_SUCCESS;
}

unsigned short ares_uri_get_port(const ares_uri_t *uri)
{
  if (uri == NULL) {
    return 0;
  }
  return uri->port;
}

/* URI spec says path normalization is a requirement */
static char *ares_uri_path_normalize(const char *path)
{
  ares_status_t status;
  ares_array_t *arr     = NULL;
  ares_buf_t   *outpath = NULL;
  ares_buf_t   *inpath  = NULL;
  ares_ssize_t  i;
  size_t        j;
  size_t        len;

  inpath =
    ares_buf_create_const((const unsigned char *)path, ares_strlen(path));
  if (inpath == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  outpath = ares_buf_create();
  if (outpath == NULL) {
    status = ARES_ENOMEM;
    goto done;
  }

  status = ares_buf_split_str_array(inpath, (const unsigned char *)"/", 1,
                                    ARES_BUF_SPLIT_TRIM, 0, &arr);
  if (status != ARES_SUCCESS) {
    return NULL;
  }

  for (i = 0; i < (ares_ssize_t)ares_array_len(arr); i++) {
    const char **strptr = ares_array_at(arr, (size_t)i);
    const char  *str    = *strptr;

    if (ares_streq(str, ".")) {
      ares_array_remove_at(arr, (size_t)i);
      i--;
    } else if (ares_streq(str, "..")) {
      if (i != 0) {
        ares_array_remove_at(arr, (size_t)i - 1);
        i--;
      }
      ares_array_remove_at(arr, (size_t)i);
      i--;
    }
  }

  status = ares_buf_append_byte(outpath, '/');
  if (status != ARES_SUCCESS) {
    goto done;
  }

  len = ares_array_len(arr);
  for (j = 0; j < len; j++) {
    const char **strptr = ares_array_at(arr, j);
    const char  *str    = *strptr;
    status              = ares_buf_append_str(outpath, str);
    if (status != ARES_SUCCESS) {
      goto done;
    }

    /* Path separator, but on the last entry, we need to check if it was
     * originally terminated or not because they have different meanings */
    if (j != len - 1 || path[ares_strlen(path) - 1] == '/') {
      status = ares_buf_append_byte(outpath, '/');
      if (status != ARES_SUCCESS) {
        goto done;
      }
    }
  }

done:
  ares_array_destroy(arr);
  ares_buf_destroy(inpath);
  if (status != ARES_SUCCESS) {
    ares_buf_destroy(outpath);
    return NULL;
  }

  return ares_buf_finish_str(outpath, NULL);
}

ares_status_t ares_uri_set_path(ares_uri_t *uri, const char *path)
{
  char *temp = NULL;

  if (uri == NULL) {
    return ARES_EFORMERR;
  }

  if (path != NULL && !ares_str_isprint(path, ares_strlen(path))) {
    return ARES_EBADSTR;
  }

  if (path != NULL) {
    temp = ares_uri_path_normalize(path);
    if (temp == NULL) {
      return ARES_ENOMEM;
    }
  }

  ares_free(uri->path);
  uri->path = temp;

  return ARES_SUCCESS;
}

const char *ares_uri_get_path(const ares_uri_t *uri)
{
  if (uri == NULL) {
    return NULL;
  }

  return uri->path;
}

ares_status_t ares_uri_set_query_key(ares_uri_t *uri, const char *key,
                                     const char *val)
{
  if (uri == NULL || key == NULL || *key == 0) {
    return ARES_EFORMERR;
  }

  if (!ares_str_isprint(key, ares_strlen(key)) ||
      (val != NULL && !ares_str_isprint(val, ares_strlen(val)))) {
    return ARES_EBADSTR;
  }

  if (!ares_htable_dict_insert(uri->query, key, val)) {
    return ARES_ENOMEM;
  }
  return ARES_SUCCESS;
}

ares_status_t ares_uri_del_query_key(ares_uri_t *uri, const char *key)
{
  if (uri == NULL || key == NULL || *key == 0 ||
      !ares_str_isprint(key, ares_strlen(key))) {
    return ARES_EFORMERR;
  }

  if (!ares_htable_dict_remove(uri->query, key)) {
    return ARES_ENOTFOUND;
  }

  return ARES_SUCCESS;
}

const char *ares_uri_get_query_key(const ares_uri_t *uri, const char *key)
{
  if (uri == NULL || key == NULL || *key == 0 ||
      !ares_str_isprint(key, ares_strlen(key))) {
    return NULL;
  }

  return ares_htable_dict_get_direct(uri->query, key);
}

char **ares_uri_get_query_keys(const ares_uri_t *uri, size_t *num)
{
  if (uri == NULL || num == NULL) {
    return NULL;
  }

  return ares_htable_dict_keys(uri->query, num);
}

static ares_status_t ares_uri_set_fragment_own(ares_uri_t *uri, char *fragment)
{
  if (uri == NULL) {
    return ARES_EFORMERR;
  }

  if (fragment != NULL && !ares_str_isprint(fragment, ares_strlen(fragment))) {
    return ARES_EBADSTR;
  }

  ares_free(uri->fragment);
  uri->fragment = fragment;
  return ARES_SUCCESS;
}

ares_status_t ares_uri_set_fragment(ares_uri_t *uri, const char *fragment)
{
  ares_status_t status;
  char         *temp = NULL;

  if (uri == NULL) {
    return ARES_EFORMERR;
  }

  if (fragment != NULL) {
    temp = ares_strdup(fragment);
    if (temp == NULL) {
      return ARES_ENOMEM;
    }
  }

  status = ares_uri_set_fragment_own(uri, temp);
  if (status != ARES_SUCCESS) {
    ares_free(temp);
  }

  return status;
}

const char *ares_uri_get_fragment(const ares_uri_t *uri)
{
  if (uri == NULL) {
    return NULL;
  }
  return uri->fragment;
}

static ares_status_t ares_uri_encode_buf(ares_buf_t *buf, const char *str,
                                         ares_bool_t (*ischr)(char))
{
  size_t i;

  if 