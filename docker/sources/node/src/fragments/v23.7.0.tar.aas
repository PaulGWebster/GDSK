 found
 */
U_CFUNC UBool U_EXPORT2
ucase_addStringCaseClosure(const UChar *s, int32_t length, const USetAdder *sa);

#ifdef __cplusplus
U_NAMESPACE_BEGIN

/**
 * Iterator over characters with more than one code point in the full default Case_Folding.
 */
class U_COMMON_API FullCaseFoldingIterator {
public:
    /** Constructor. */
    FullCaseFoldingIterator();
    /**
     * Returns the next (cp, full) pair where "full" is cp's full default Case_Folding.
     * Returns a negative cp value at the end of the iteration.
     */
    UChar32 next(UnicodeString &full);
private:
    FullCaseFoldingIterator(const FullCaseFoldingIterator &) = delete;  // no copy
    FullCaseFoldingIterator &operator=(const FullCaseFoldingIterator &) = delete;  // no assignment

    const char16_t *unfold;
    int32_t unfoldRows;
    int32_t unfoldRowWidth;
    int32_t unfoldStringWidth;
    int32_t currentRow;
    int32_t rowCpIndex;
};

/**
 * Fast case mapping data for ASCII/Latin.
 * Linear arrays of delta bytes: 0=no mapping; EXC=exception.
 * Deltas must not cross the ASCII boundary, or else they cannot be easily used
 * in simple UTF-8 code.
 */
namespace LatinCase {

/** Case mapping/folding data for code points up to U+017F. */
constexpr char16_t LIMIT = 0x180;
/** U+017F case-folds and uppercases crossing the ASCII boundary. */
constexpr char16_t LONG_S = 0x17f;
/** Exception: Complex mapping, or too-large delta. */
constexpr int8_t EXC = -0x80;

/** Deltas for lowercasing for most locales, and default case folding. */
extern const int8_t TO_LOWER_NORMAL[LIMIT];
/** Deltas for lowercasing for tr/az/lt, and Turkic case folding. */
extern const int8_t TO_LOWER_TR_LT[LIMIT];

/** Deltas for uppercasing for most locales. */
extern const int8_t TO_UPPER_NORMAL[LIMIT];
/** Deltas for uppercasing for tr/az. */
extern const int8_t TO_UPPER_TR[LIMIT];

}  // namespace LatinCase

U_NAMESPACE_END
#endif

/** @return UCASE_NONE, UCASE_LOWER, UCASE_UPPER, UCASE_TITLE */
U_CAPI int32_t U_EXPORT2
ucase_getType(UChar32 c);

/** @return like ucase_getType() but also sets UCASE_IGNORABLE if c is case-ignorable */
U_CAPI int32_t U_EXPORT2
ucase_getTypeOrIgnorable(UChar32 c);

U_CAPI UBool U_EXPORT2
ucase_isSoftDotted(UChar32 c);

U_CAPI UBool U_EXPORT2
ucase_isCaseSensitive(UChar32 c);

/* string case mapping functions */

U_CDECL_BEGIN

/**
 * Iterator function for string case mappings, which need to look at the
 * context (surrounding text) of a given character for conditional mappings.
 *
 * The iterator only needs to go backward or forward away from the
 * character in question. It does not use any indexes on this interface.
 * It does not support random access or an arbitrary change of
 * iteration direction.
 *
 * The code point being case-mapped itself is never returned by
 * this iterator.
 *
 * @param context A pointer to the iterator's working data.
 * @param dir If <0 then start iterating backward from the character;
 *            if >0 then start iterating forward from the character;
 *            if 0 then continue iterating in the current direction.
 * @return Next code point, or <0 when the iteration is done.
 */
typedef UChar32 U_CALLCONV
UCaseContextIterator(void *context, int8_t dir);

/**
 * Sample struct which may be used by some implementations of
 * UCaseContextIterator.
 */
struct UCaseContext {
    void *p;
    int32_t start, index, limit;
    int32_t cpStart, cpLimit;
    int8_t dir;
    int8_t b1, b2, b3;
};
typedef struct UCaseContext UCaseContext;

U_CDECL_END

#define UCASECONTEXT_INITIALIZER { NULL,  0, 0, 0,  0, 0,  0,  0, 0, 0 }

enum {
    /**
     * For string case mappings, a single character (a code point) is mapped
     * either to itself (in which case in-place mapping functions do nothing),
     * or to another single code point, or to a string.
     * Aside from the string contents, these are indicated with a single int32_t
     * value as follows:
     *
     * Mapping to self: Negative values (~self instead of -self to support U+0000)
     *
     * Mapping to another code point: Positive values >UCASE_MAX_STRING_LENGTH
     *
     * Mapping to a string: The string length (0..UCASE_MAX_STRING_LENGTH) is
     * returned. Note that the string result may indeed have zero length.
     */
    UCASE_MAX_STRING_LENGTH=0x1f
};

/**
 * Get the full lowercase mapping for c.
 *
 * @param csp Case mapping properties.
 * @param c Character to be mapped.
 * @param iter Character iterator, used for context-sensitive mappings.
 *             See UCaseContextIterator for details.
 *             If iter==NULL then a context-independent result is returned.
 * @param context Pointer to be passed into iter.
 * @param pString If the mapping result is a string, then the pointer is
 *                written to *pString.
 * @param caseLocale Case locale value from ucase_getCaseLocale().
 * @return Output code point or string length, see UCASE_MAX_STRING_LENGTH.
 *
 * @see UCaseContextIterator
 * @see UCASE_MAX_STRING_LENGTH
 * @internal
 */
U_CAPI int32_t U_EXPORT2
ucase_toFullLower(UChar32 c,
                  UCaseContextIterator *iter, void *context,
                  const UChar **pString,
                  int32_t caseLocale);

U_CAPI int32_t U_EXPORT2
ucase_toFullUpper(UChar32 c,
                  UCaseContextIterator *iter, void *context,
                  const UChar **pString,
                  int32_t caseLocale);

U_CAPI int32_t U_EXPORT2
ucase_toFullTitle(UChar32 c,
                  UCaseContextIterator *iter, void *context,
                  const UChar **pString,
                  int32_t caseLocale);

U_CAPI int32_t U_EXPORT2
ucase_toFullFolding(UChar32 c,
                    const UChar **pString,
                    uint32_t options);

U_CFUNC int32_t U_EXPORT2
ucase_hasBinaryProperty(UChar32 c, UProperty which);


U_CDECL_BEGIN

/**
 * @internal
 */
typedef int32_t U_CALLCONV
UCaseMapFull(UChar32 c,
             UCaseContextIterator *iter, void *context,
             const UChar **pString,
             int32_t caseLocale);

U_CDECL_END

/* for icuexportdata -------------------------------------------------------- */

struct UCaseProps {
    void *mem;  // TODO: was unused, and type UDataMemory -- remove
    const int32_t *indexes;
    const uint16_t *exceptions;
    const uint16_t *unfold;

    UTrie2 trie;
    uint8_t formatVersion[4];
};

U_CAPI const struct UCaseProps * U_EXPORT2
ucase_getSingleton(int32_t *pExceptionsLength, int32_t *pUnfoldLength);

/* file definitions --------------------------------------------------------- */

#define UCASE_DATA_NAME "ucase"
#define UCASE_DATA_TYPE "icu"

/* format "cAsE" */
#define UCASE_FMT_0 0x63
#define UCASE_FMT_1 0x41
#define UCASE_FMT_2 0x53
#define UCASE_FMT_3 0x45

/* indexes into indexes[] */
enum {
    UCASE_IX_INDEX_TOP,
    UCASE_IX_LENGTH,
    UCASE_IX_TRIE_SIZE,
    UCASE_IX_EXC_LENGTH,
    UCASE_IX_UNFOLD_LENGTH,

    UCASE_IX_MAX_FULL_LENGTH=15,
    UCASE_IX_TOP=16
};

/* definitions for 16-bit case properties word ------------------------------ */

U_CFUNC const UTrie2 * U_EXPORT2
ucase_getTrie(void);

/* 2-bit constants for types of cased characters */
#define UCASE_TYPE_MASK     3
enum {
    UCASE_NONE,
    UCASE_LOWER,
    UCASE_UPPER,
    UCASE_TITLE
};

#define UCASE_GET_TYPE(props) ((props)&UCASE_TYPE_MASK)
#define UCASE_GET_TYPE_AND_IGNORABLE(props) ((props)&7)

#define UCASE_IS_UPPER_OR_TITLE(props) ((props)&2)

#define UCASE_IGNORABLE         4
#define UCASE_EXCEPTION         8
#define UCASE_SENSITIVE         0x10

#define UCASE_HAS_EXCEPTION(props) ((props)&UCASE_EXCEPTION)

#define UCASE_DOT_MASK      0x60
enum {
    UCASE_NO_DOT=0,         /* normal characters with cc=0 */
    UCASE_SOFT_DOTTED=0x20, /* soft-dotted characters with cc=0 */
    UCASE_ABOVE=0x40,       /* "above" accents with cc=230 */
    UCASE_OTHER_ACCENT=0x60 /* other accent character (0<cc!=230) */
};

/* no exception: bits 15..7 are a 9-bit signed case mapping delta */
#define UCASE_DELTA_SHIFT   7
#define UCASE_DELTA_MASK    0xff80
#define UCASE_MAX_DELTA     0xff
#define UCASE_MIN_DELTA     (-UCASE_MAX_DELTA-1)

#if U_SIGNED_RIGHT_SHIFT_IS_ARITHMETIC
#   define UCASE_GET_DELTA(props) ((int16_t)(props)>>UCASE_DELTA_SHIFT)
#else
#   define UCASE_GET_DELTA(props) (int16_t)(((props)&0x8000) ? (((props)>>UCASE_DELTA_SHIFT)|0xfe00) : ((uint16_t)(props)>>UCASE_DELTA_SHIFT))
#endif

/* exception: bits 15..4 are an unsigned 12-bit index into the exceptions array */
#define UCASE_EXC_SHIFT     4
#define UCASE_EXC_MASK      0xfff0
#define UCASE_MAX_EXCEPTIONS ((UCASE_EXC_MASK>>UCASE_EXC_SHIFT)+1)

/* definitions for 16-bit main exceptions word ------------------------------ */

/* first 8 bits indicate values in optional slots */
enum {
    UCASE_EXC_LOWER,
    UCASE_EXC_FOLD,
    UCASE_EXC_UPPER,
    UCASE_EXC_TITLE,
    UCASE_EXC_DELTA,
    UCASE_EXC_5,            /* reserved */
    UCASE_EXC_CLOSURE,
    UCASE_EXC_FULL_MAPPINGS,
    UCASE_EXC_ALL_SLOTS     /* one past the last slot */
};

/* each slot is 2 uint16_t instead of 1 */
#define UCASE_EXC_DOUBLE_SLOTS      0x100

enum {
    UCASE_EXC_NO_SIMPLE_CASE_FOLDING=0x200,
    UCASE_EXC_DELTA_IS_NEGATIVE=0x400,
    UCASE_EXC_SENSITIVE=0x800
};

/* UCASE_EXC_DOT_MASK=UCASE_DOT_MASK<<UCASE_EXC_DOT_SHIFT */
#define UCASE_EXC_DOT_SHIFT     7

/* normally stored in the main word, but pushed out for larger exception indexes */
#define UCASE_EXC_DOT_MASK      0x3000
enum {
    UCASE_EXC_NO_DOT=0,
    UCASE_EXC_SOFT_DOTTED=0x1000,
    UCASE_EXC_ABOVE=0x2000,         /* "above" accents with cc=230 */
    UCASE_EXC_OTHER_ACCENT=0x3000   /* other character (0<cc!=230) */
};

/* complex/conditional mappings */
#define UCASE_EXC_CONDITIONAL_SPECIAL   0x4000
#define UCASE_EXC_CONDITIONAL_FOLD      0x8000

/* definitions for lengths word for full case mappings */
#define UCASE_FULL_LOWER    0xf
#define UCASE_FULL_FOLDING  0xf0
#define UCASE_FULL_UPPER    0xf00
#define UCASE_FULL_TITLE    0xf000

/* maximum lengths */
#define UCASE_FULL_MAPPINGS_MAX_LENGTH (4*0xf)
#define UCASE_CLOSURE_MAX_LENGTH 0xf

/* constants for reverse case folding ("unfold") data */
enum {
    UCASE_UNFOLD_ROWS,
    UCASE_UNFOLD_ROW_WIDTH,
    UCASE_UNFOLD_STRING_WIDTH
};

#endif
                      node-23.7.0/deps/icu-small/source/common/ucase_props_data.h                                         0000664 0000000 0000000 00000205050 14746647661 0023655 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright (C) 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
// Copyright (C) 1999-2016, International Business Machines
// Corporation and others.  All Rights Reserved.
//
// file name: ucase_props_data.h
//
// machine-generated by: icu/tools/unicode/c/genprops/casepropsbuilder.cpp

#ifdef INCLUDED_FROM_UCASE_CPP

static const UVersionInfo ucase_props_dataVersion={0x10,0,0,0};

static const int32_t ucase_props_indexes[UCASE_IX_TOP]={0x10,0x78bc,0x6888,0x688,0x172,0,0,0,0,0,0,0,0,0,0,3};

static const uint16_t ucase_props_trieIndex[13372]={
0x363,0x36b,0x373,0x37b,0x389,0x391,0x399,0x3a1,0x3a9,0x3b1,0x3b8,0x3c0,0x3c8,0x3d0,0x3d8,0x3e0,
0x3e6,0x3ee,0x3f6,0x3fe,0x406,0x40e,0x416,0x41e,0x426,0x42e,0x436,0x43e,0x446,0x44e,0x456,0x45e,
0x466,0x46e,0x476,0x47e,0x486,0x48e,0x496,0x49e,0x49a,0x4a2,0x4a7,0x4af,0x4b6,0x4be,0x4c6,0x4ce,
0x4d6,0x4de,0x4e6,0x4ee,0x382,0x38a,0x4f3,0x4fb,0x500,0x508,0x510,0x518,0x517,0x51f,0x524,0x52c,
0x534,0x53b,0x53f,0x382,0x546,0x363,0x556,0x54e,0x55e,0x560,0x568,0x570,0x574,0x575,0x57d,0x585,
0x58d,0x575,0x595,0x59a,0x58d,0x575,0x5a2,0x5aa,0x574,0x5b2,0x5ba,0x5c2,0x5ca,0x382,0x5d2,0x382,
0x5da,0x5dc,0x5e4,0x5c2,0x574,0x5b2,0x5eb,0x5c2,0x5f3,0x5f5,0x57d,0x5c2,0x574,0x382,0x5fd,0x382,
0x382,0x603,0x60a,0x382,0x382,0x60e,0x616,0x382,0x61a,0x621,0x382,0x628,0x630,0x637,0x63f,0x382,
0x382,0x644,0x64c,0x654,0x65c,0x664,0x66b,0x673,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x67b,0x382,0x382,0x68b,0x68b,0x683,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x693,0x699,0x581,0x581,0x382,0x69f,0x6a7,0x382,
0x6af,0x382,0x6b7,0x382,0x6be,0x6c4,0x382,0x382,0x382,0x6cc,0x382,0x382,0x382,0x382,0x382,0x382,
0x6d3,0x382,0x6da,0x6e2,0x382,0x6ea,0x6f2,0x382,0x5b1,0x6f6,0x6fe,0x704,0x5f3,0x70c,0x382,0x713,
0x382,0x718,0x382,0x71e,0x726,0x72a,0x732,0x73a,0x742,0x747,0x74a,0x752,0x762,0x75a,0x772,0x76a,
0x3a9,0x77a,0x3a9,0x782,0x785,0x3a9,0x78d,0x3a9,0x795,0x79d,0x7a5,0x7ad,0x7b5,0x7bd,0x7c5,0x7cd,
0x7d5,0x7dc,0x382,0x7e4,0x7ec,0x382,0x7f4,0x7fc,0x804,0x80c,0x814,0x81c,0x824,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x827,0x82d,0x833,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x83b,0x83f,0x843,0x84b,0x3a9,0x3a9,0x3a9,0x853,0x85b,0x862,0x382,0x867,0x382,0x382,0x382,0x86f,
0x382,0x6b4,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x573,0x877,0x382,0x382,0x87e,0x382,0x382,0x886,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x88e,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x71e,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x894,0x382,0x89c,0x8a1,0x8a9,0x382,0x382,0x8b1,0x8b9,0x8c1,0x3a9,0x8c6,0x8ce,0x8d4,0x8db,0x8e3,
0x8eb,0x8f2,0x382,0x382,0x382,0x382,0x8f9,0x901,0x382,0x909,0x910,0x382,0x55e,0x915,0x91d,0x6be,
0x382,0x923,0x92b,0x92f,0x382,0x937,0x93f,0x947,0x382,0x94d,0x951,0x959,0x969,0x961,0x382,0x971,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x979,0x382,0x382,0x382,0x382,0x981,0x55e,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x986,0x98e,0x992,0x382,0x382,0x382,0x382,0x365,0x36b,0x99a,0x9a2,0x9a9,0x519,0x382,0x382,0x9b1,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0xe0c,0xe0c,0xe24,0xe64,0xea4,0xee0,0xf20,0xf60,0xf98,0xfd8,0x1018,0x1058,0x1098,0x10d8,0x1118,0x1158,
0x1198,0x11d8,0x1218,0x1258,0x1268,0x129c,0x12d8,0x1318,0x1358,0x1398,0xe08,0x13cc,0x1400,0x1440,0x145c,0x1490,
0x9e1,0xa1f,0xa5f,0xa9e,0x188,0x188,0xad9,0x188,0x188,0x188,0x188,0x188,0xb11,0xb3a,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0xb7a,0x188,0xbba,0x188,0xbe0,0xc1b,0xc5a,0xc9a,0xcd4,0xd0b,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,
0xd4b,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x9b8,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x9c0,0x382,0x382,0x382,0x9c3,0x382,0x382,0x382,
0x382,0x9cb,0x9d1,0x9d5,0x382,0x382,0x9d9,0x9dd,0x9e3,0x382,0x382,0x382,0x9ea,0x9ee,0x9f6,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0xa06,0x9fe,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0xa0e,
0xa12,0x382,0x382,0x382,0x382,0x382,0xa1a,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0xa22,0xa26,0xa2e,0xa32,0x382,0xa39,0xa3e,0xa45,0xa4c,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0xa52,0x382,0xa56,0x382,0x382,0xa5e,0x382,0xa66,0x382,0x382,0x382,0x574,
0xa68,0xa6f,0xa73,0x5f3,0xa7b,0xa83,0x382,0xa8b,0xa92,0x382,0xa98,0x5f3,0xa9d,0xaa5,0x382,0x382,
0xaaa,0x574,0x382,0x382,0x382,0x365,0xab2,0x5f3,0x5f5,0xaba,0xac1,0x382,0xa8d,0xac9,0x58d,0x382,
0xa68,0xad1,0x382,0x382,0xad9,0xae1,0x382,0x382,0x382,0x382,0x382,0x382,0xae5,0xaed,0x382,0x382,
0xaf5,0x4dd,0x382,0x382,0xafd,0x382,0x382,0xb03,0xb0b,0x382,0x382,0x382,0x382,0x382,0x382,0xb10,
0x382,0x382,0x382,0xb18,0xb20,0x382,0x382,0xb28,0xb30,0x382,0x382,0x382,0xb33,0x9c0,0xb3b,0xb3f,
0xb47,0x382,0xb4e,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0xb55,
0x382,0x382,0x981,0xb5d,0x382,0x382,0x382,0xb63,0xb6b,0x382,0xb6f,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0xb75,0x5f3,0xb7b,0xb83,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0xb8a,0xb92,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x519,0xb9a,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0xb9e,0x382,0xba4,0x5b1,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x55e,0xb77,0x382,0x382,0x382,0x382,0x382,0x382,0xb18,0xb20,0x382,0x382,
0x382,0x382,0x382,0x382,0x6b4,0x382,0xbaa,0x382,0x382,0xbb2,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0xbb7,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0xbbf,0x5b1,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x8b9,0xbc7,0xbce,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0xbd5,0xbdd,0xbe3,0x382,0x382,0x382,0x382,0xbeb,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0xbf3,0xbfb,0xc00,0xc06,0xc0e,
0xc16,0xc1e,0xbf7,0xc26,0xc2e,0xc36,0xc3d,0xbf8,0xbf3,0xbfb,0xbf6,0xc06,0xbf9,0xbf4,0xc45,0xbf7,
0xc4d,0xc55,0xc5d,0xc64,0xc50,0xc58,0xc60,0xc67,0xc53,0xc6f,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x8b9,0xc77,0x8b9,0xc7e,0xc85,0xc8d,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0xc9d,0xca5,0x382,0x382,0x382,0x382,0x382,0x382,0xc95,0xcad,0xcc0,0xcb3,0xcb8,0x382,
0x382,0x382,0x382,0xcc8,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0xad5,
0x382,0xa37,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0xcd0,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0xcd5,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0xcd9,0x382,0xce1,0xce9,0xcf0,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0xbef,0xcf8,0xcf8,0xcfe,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0xa8d,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x574,0x8b9,0x8b9,0x8b9,0x382,
0x382,0x382,0x382,0x8b9,0x8b9,0x8b9,0x8b9,0x8b9,0x8b9,0x8b9,0xd06,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,
0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x382,0x362,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,4,0,0,0,0,0,0,4,0,0,0,0,0,
0,0,0,0,0,0,4,0,0,0,0,0,0,0x1012,0x1012,0x1012,
0x1012,0x1012,0x1012,0x1012,0x1012,0xa,0x5a,0x7a,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0xba,
0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0,0,0,4,0,4,0xf011,0xf011,0xf011,
0xf011,0xf011,0xf011,0xf011,0xf011,0xf9,0xf031,0x149,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0x189,
0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,4,0,1,0,
0,4,0,4,0,0,0,0,4,0x1c9,0,4,4,0,1,0,
0,0,0,0,0x1012,0x1012,0x1012,0x1012,0x1012,0x1fa,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,
0x5a,0x5a,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0,0x1012,0x1012,0x1012,0x1012,
0x1012,0x1012,0x1012,0x239,0xf011,0xf011,0xf011,0xf011,0xf011,0x2d9,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,
0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0,0xf011,0xf011,0xf011,0xf011,
0xf011,0xf011,0xf011,0x3c91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x31a,0xff91,0x92,0xff91,
0x92,0xff91,0x31a,0xffb1,0x33a,0x389,0x92,0xff91,0x92,0xff91,0x92,0xff91,1,0x92,0xff91,0x92,
0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x3d9,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0xc392,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x459,
0x6191,0x6912,0x92,0xff91,0x92,0xff91,0x6712,0x92,0xff91,0x6692,0x6692,0x92,0xff91,1,0x2792,0x6512,
0x6592,0x92,0xff91,0x6692,0x6792,0x3091,0x6992,0x6892,0x92,0xff91,0x5191,0x489,0x6992,0x6a92,0x4111,0x6b12,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x6d12,0x92,0xff91,0x6d12,1,1,0x92,0xff91,0x6d12,0x92,
0xff91,0x6c92,0x6c92,0x92,0xff91,0x92,0xff91,0x6d92,0x92,0xff91,1,0,0x92,0xff91,1,0x1c11,
0,0,0,0,0x4aa,0x4db,0x519,0x54a,0x57b,0x5b9,0x5ea,0x61b,0x659,0x92,0xff91,0x92,
0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0xd891,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x689,0x70a,0x73b,0x779,0x92,0xff91,0xcf92,0xe412,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0xbf12,1,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,1,1,1,1,
1,1,0x7aa,0x92,0xff91,0xae92,0x7ca,0x7e9,0x7e9,0x92,0xff91,0x9e92,0x2292,0x2392,0x92,0xff91,
0x92,0xffb1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x809,0x829,0x849,0x9711,0x9911,1,0x9991,0x9991,
1,0x9b11,1,0x9a91,0x869,1,1,1,0x9991,0x889,1,0x9891,0x8a9,0x8c9,0x8e9,1,
0x97b1,0x9691,0x8e9,0x909,0x929,1,1,0x9691,1,0x949,0x9591,1,1,0x9511,1,1,
1,1,1,1,1,0x969,1,1,0x9311,1,0x989,0x9311,1,1,1,0x9a9,
0x9311,0xdd91,0x9391,0x9391,0xdc91,1,1,1,1,1,0x9291,1,0,1,1,1,
1,1,1,1,1,0x9c9,0x9e9,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,5,5,0x25,5,5,5,5,5,
5,4,4,4,0x14,4,0x14,4,5,5,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,5,5,5,5,5,4,4,4,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,0x54,0x54,0x44,0x44,0x44,0x44,0x44,0xa0c,
0x54,0x44,0x54,0x44,0x54,0x44,0x44,0x44,0x44,0x44,0x44,0x54,0x44,0x64,0x64,0x64,
0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,
0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x74,0x64,0x64,0x64,0x64,0x64,0x64,
0x64,0x64,0x64,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0x54,0x44,0x44,0xa1d,0x44,0x64,
0x64,0x64,0x44,0x44,0x44,0x64,0x64,4,0x44,0x44,0x44,0x64,0x64,0x64,0x64,0x44,
0x64,0x64,0x64,0x44,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0x44,0x44,0x44,
0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x92,0xff91,0x92,0xff91,4,4,0x92,0xff91,
0,0,5,0x4111,0x4111,0x4111,0,0x3a12,0,0,0,0,4,4,0x1312,4,
0x1292,0x1292,0x1292,0,0x2012,0,0x1f92,0x1f92,0xa69,0x1012,0xb3a,0x1012,0x1012,0xb7a,0x1012,0x1012,
0xbba,0xc0a,0xc5a,0x1012,0xc9a,0x1012,0x1012,0x1012,0xcda,0xd1a,0,0xd5a,0x1012,0x1012,0xd9a,0x1012,
0x1012,0xdda,0x1012,0x1012,0xed11,0xed91,0xed91,0xed91,0xe19,0xf011,0xee9,0xf011,0xf011,0xf29,0xf011,0xf011,
0xf69,0xfb9,0x1009,0xf011,0x1049,0xf011,0xf011,0xf011,0x1089,0x10c9,0x1109,0x1139,0xf011,0xf011,0x1179,0xf011,
0xf011,0x11b9,0xf011,0xf011,0xe011,0xe091,0xe091,0x412,0x11f9,0x1229,2,2,2,0x1279,0x12a9,0xfc11,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x12d9,0x1309,0x391,0xc631,0x133a,0x1389,0,0x92,
0xff91,0xfc92,0x92,0xff91,1,0xbf12,0xbf12,0xbf12,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,
0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x2812,0x1012,0x1012,0x13ba,0x1012,0x13fa,0x1012,0x1012,0x1012,
0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x143a,0x1012,0x1012,0x147a,0x14ba,0x1012,0x1012,0x1012,0x1012,0x1012,
0x1012,0x1012,0x150a,0x1012,0x1012,0x1012,0x1012,0x1012,0xf011,0xf011,0x1549,0xf011,0x1589,0xf011,0xf011,0xf011,
0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0x15c9,0xf011,0xf011,0x1609,0x1649,0xf011,0xf011,0xf011,0xf011,0xf011,
0xf011,0xf011,0x1699,0xf011,0xf011,0xf011,0xf011,0xf011,0xd811,0xd811,0xd811,0xd811,0xd811,0xd811,0xd831,0xd811,
0xd831,0xd811,0xd811,0xd811,0xd811,0xd811,0xd811,0xd811,0x92,0xff91,0x16da,0x1719,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0,0x44,0x44,0x44,0x44,0x44,
4,4,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x792,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,
0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0xf891,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,
0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,
0x1812,0x1812,0x1812,0,0,4,0,0,0,0,0,4,1,0xe811,0xe811,0xe811,
0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,
0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0x1759,
1,0,0,0,0,0,0,0,0,0x64,0x44,0x44,0x44,0x44,0x64,0x44,
0x44,0x44,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0x44,0x64,0x64,0x64,0x64,0x64,0x64,
0x44,0x44,0x64,0x44,0x44,0x64,0x64,0x44,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,
0x64,0x64,0x64,0x64,0x64,0x64,0,0x64,0,0x64,0x64,0,0x44,0x64,0,0x64,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,
0,0,0,0,0,0,0,0,4,4,4,4,4,4,0,0,
0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
0x64,0x64,0x64,0,4,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,
0,0,0,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0x64,0x64,0x44,
0x44,0x44,0x44,0x44,0x64,0x44,0x44,0x64,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x64,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,4,0,0x44,0x44,0x44,0x44,0x64,
0x44,4,4,0x44,0x44,0,0x64,0x44,0x44,0x64,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x44,0x64,0x44,0x44,0x64,0x44,0x44,0x64,0x64,0x64,0x44,0x64,0x64,0x44,0x64,0x44,
0x44,0x44,0x64,0x44,0x64,0x44,0x64,0x44,0x64,0x44,0x44,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,4,4,4,4,4,4,4,4,4,4,4,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,0x44,
0x44,0x44,0x64,0x44,4,4,0,0,0,0,4,0,0,0x64,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0x44,0x44,0x44,0x44,4,0x44,0x44,0x44,0x44,0x44,
4,0x44,0x44,0x44,4,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0x64,0x64,0x64,0,0,0,0,0,0,0,0,
4,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0x44,
0x44,0x64,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0x44,4,0x64,0x44,0x44,0x64,0x44,
0x44,0x64,0x44,0x44,0x44,0x64,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0x44,0x64,0x44,
0x44,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,0,0,0,
0,4,0x44,0x44,0x44,0x44,0x44,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0x44,0x44,
0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,4,4,4,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,4,0,0x64,0,0,0,
0,4,4,4,4,4,4,4,4,0,0,0,0,0x64,0,0,
0,0x44,0x64,0x44,0x44,4,4,4,0,0,0,0,0,0,0,0,
0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,
0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x64,0,0,0,0,4,4,4,4,0,0,0,0,0,0,0,
0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0x44,0,0,4,4,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,4,4,0,0,0,0,4,4,0,0,4,
4,0x64,0,0,0,4,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,4,0,0,0,4,0,0,
0,0,0,0,0,0,0,0,0,4,4,4,4,4,0,4,
4,0,0,0,0,0x64,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x64,0,0,4,0,4,4,4,4,0,0,0,
0,0,0,0,0,0x64,0,0,0,0,0,0,0,4,4,0,
0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,
0,0,0,0,0,0x64,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,0,0,0,4,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x64,0,4,4,
4,0,0,0,0,0,4,4,4,0,4,4,4,0x64,0,0,
0,0,0,0,0,0x64,0x64,0,0,0,0,0,0,0,0,0,
0,0,4,0,0,0,0,0,4,0x64,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x64,
0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0x64,0,
0,0,0,0,0,0,4,4,4,0,4,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,
4,4,4,4,0x64,0x64,0x64,0,0,0,0,0,0,0,4,4,
0x64,0x64,0x64,0x64,4,4,4,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,4,0,0,4,4,4,4,
0x64,0x64,0x64,4,4,0,0,0,0,0,0,0,0,0,4,0,
0x64,0x64,0x64,0x64,4,4,4,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x64,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0x64,0,0x64,0,0x64,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0x64,0x64,4,0x64,4,4,4,4,4,0x64,0x64,0x64,0x64,4,0,
0x64,4,0x44,0x44,0x64,0,0x44,0x44,0,0,0,0,0,4,4,4,
4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,
0,0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,
4,0,4,4,4,4,4,0x64,0,0x64,0x64,0,0,4,4,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,4,0,0,0,0,4,4,
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,
0,0,4,0,0,4,4,0,0,0,0,0,0,0x64,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,
0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,
0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,
0x179a,0x179a,0,0x179a,0,0,0,0,0,0x179a,0,0,0x17b9,0x17e9,0x1819,0x1849,
0x1879,0x18a9,0x18d9,0x1909,0x1939,0x1969,0x1999,0x19c9,0x19f9,0x1a29,0x1a59,0x1a89,0x1ab9,0x1ae9,0x1b19,0x1b49,
0x1b79,0x1ba9,0x1bd9,0x1c09,0x1c39,0x1c69,0x1c99,0x1cc9,0x1cf9,0x1d29,0x1d59,0x1d89,0x1db9,0x1de9,0x1e19,0x1e49,
0x1e79,0x1ea9,0x1ed9,0x1f09,0x1f39,0x1f69,0x1f99,0,5,0x1fc9,0x1ff9,0x2029,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x205a,0x205a,0x205a,0x205a,
0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x207a,0x207a,0x207a,0x207a,
0x207a,0x207a,0,0,0x2099,0x20c9,0x20f9,0x2129,0x2159,0x2189,0,0,0x205a,0x205a,0x205a,0x205a,
0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,
0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0x205a,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,
0x64,0x60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,4,4,0x60,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4,4,0,4,4,4,4,4,4,4,0,0,0,0,0,0,
0,0,4,0,0,4,4,4,4,4,4,4,4,4,0x64,4,
0,0,0,4,0,0,0,0,0,0x44,0,0,0,0,0,0,
0,0,0,0,0,0,0,4,4,4,4,4,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0x64,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4,4,4,0,0,0,0,4,4,0,0,0,0,0,0,0,
0,0,4,0,0,0,0,0,0,0x64,0x44,0x64,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0x44,0x64,0,0,4,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,
4,4,4,4,4,4,4,0,0x64,0,4,0,0,4,4,4,
4,4,4,4,4,0,0,0,0,0,0,4,4,0x44,0x44,0x44,
0x44,0x44,0x44,0x44,0x44,0,0,0x64,0,0,0,0,0,0,0,4,
0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x64,0x64,0x64,
0x64,0x64,0x64,0x44,0x44,0x64,4,0x64,0x64,0x44,0x44,0x64,0x64,0x44,0x44,0x44,
0x44,0x44,0x64,0x44,0x44,0x44,0x44,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x64,0,4,4,
4,4,4,0,4,0,0,0,0,0,4,0,0x60,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0x44,0x64,0x44,0x44,0x44,
0x44,0x44,0x44,0x44,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,4,4,4,4,0,0,4,4,0x60,0x64,4,4,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0x64,0,4,4,0,0,0,4,0,4,4,4,0x60,0x60,
0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
4,4,4,4,0,0,4,0x64,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4,4,4,4,4,4,0,0,0x21b9,0x21e9,0x2219,0x2249,0x2279,0x22c9,0x2319,0x2349,
0x2379,0x92,0xff91,0,0,0,0,0,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,
0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,0x23aa,
0x23aa,0x23aa,0x23aa,0,0,0x23aa,0x23aa,0x23aa,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x44,0x44,0x44,0,0x64,0x64,0x64,0x64,
0x64,0x64,0x44,0x44,0x64,0x64,0x64,0x64,0x44,0,0x64,0x64,0x64,0x64,0x64,0x64,
0x64,0,0,0,0,0x64,0,0,0,0,0,0,0x44,0,0,0,
0x44,0x44,0,0,0,0,0,0,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0x25,5,5,5,5,5,
5,5,5,1,1,1,1,1,1,1,1,1,1,1,1,1,
5,0x23c9,1,1,1,0x23e9,1,1,5,5,5,5,0x25,5,5,5,
0x25,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,0x2409,1,1,1,1,1,1,1,0x21,1,
1,1,1,5,5,5,5,5,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x64,0x64,
0x64,0x64,0x64,0x44,0x64,0x64,0x44,0x64,0x44,0x44,0x64,0x44,0x44,0x44,0x44,0x44,
0x44,0x44,0x64,0x44,0x44,0x64,0x64,0x64,0x64,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xffb1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x242a,0x2469,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x24a9,0x2529,0x25a9,0x2629,0x26a9,0x2729,
1,1,0x275a,1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xffb1,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x411,0x411,0x411,0x411,0x411,0x411,0x411,0x411,0xfc12,0xfc12,0xfc12,0xfc12,
0xfc12,0xfc12,0xfc12,0xfc12,0x411,0x411,0x411,0x411,0x411,0x411,0,0,0xfc12,0xfc12,0xfc12,0xfc12,
0xfc12,0xfc12,0,0,0x411,0x411,0x411,0x411,0x411,0x411,0x411,0x411,0xfc12,0xfc12,0xfc12,0xfc12,
0xfc12,0xfc12,0xfc12,0xfc12,0x411,0x411,0x411,0x411,0x411,0x411,0x411,0x411,0xfc12,0xfc12,0xfc12,0xfc12,
0xfc12,0xfc12,0xfc12,0xfc12,0x411,0x411,0x411,0x411,0x411,0x411,0,0,0xfc12,0xfc12,0xfc12,0xfc12,
0xfc12,0xfc12,0,0,0x27a9,0x411,0x2829,0x411,0x28d9,0x411,0x2989,0x411,0,0xfc12,0,0xfc12,
0,0xfc12,0,0xfc12,0x411,0x411,0x411,0x411,0x411,0x411,0x411,0x411,0xfc12,0xfc12,0xfc12,0xfc12,
0xfc12,0xfc12,0xfc12,0xfc12,0x2511,0x2511,0x2b11,0x2b11,0x2b11,0x2b11,0x3211,0x3211,0x4011,0x4011,0x3811,0x3811,
0x3f11,0x3f11,0,0,0x2a39,0x2aa9,0x2b19,0x2b89,0x2bf9,0x2c69,0x2cd9,0x2d49,0x2dbb,0x2e2b,0x2e9b,0x2f0b,
0x2f7b,0x2feb,0x305b,0x30cb,0x3139,0x31a9,0x3219,0x3289,0x32f9,0x3369,0x33d9,0x3449,0x34bb,0x352b,0x359b,0x360b,
0x367b,0x36eb,0x375b,0x37cb,0x3839,0x38a9,0x3919,0x3989,0x39f9,0x3a69,0x3ad9,0x3b49,0x3bbb,0x3c2b,0x3c9b,0x3d0b,
0x3d7b,0x3deb,0x3e5b,0x3ecb,0x411,0x411,0x3f39,0x3fb9,0x4029,0,0x40a9,0x4129,0xfc12,0xfc12,0xdb12,0xdb12,
0x41db,4,0x4249,4,4,4,0x4299,0x4319,0x4389,0,0x4409,0x4489,0xd512,0xd512,0xd512,0xd512,
0x453b,4,4,4,0x411,0x411,0x45a9,0x4659,0,0,0x4719,0x4799,0xfc12,0xfc12,0xce12,0xce12,
0,4,4,4,0x411,0x411,0x4849,0x48f9,0x49b9,0x391,0x4a39,0x4ab9,0xfc12,0xfc12,0xc812,0xc812,
0xfc92,4,4,4,0,0,0x4b69,0x4be9,0x4c59,0,0x4cd9,0x4d59,0xc012,0xc012,0xc112,0xc112,
0x4e0b,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,
4,4,4,4,0,0,0,0,0,0,0,0,4,4,0,0,
0,0,0,0,4,0,0,4,0,0,4,4,4,4,4,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4,4,4,4,4,0,4,4,4,4,4,4,4,4,4,4,
0,0x25,0,0,0,0,0,0,0,0,0,0,0,0,0,5,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x44,0x44,0x64,0x64,0x44,0x44,0x44,0x44,0x64,0x64,0x64,0x44,0x44,4,4,4,
4,0x44,4,4,4,0x64,0x64,0x44,0x64,0x44,0x64,0x64,0x64,0x64,0x64,0x64,
0x44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,2,0,0,0,0,2,0,0,1,2,2,2,1,1,
2,2,2,1,0,2,0,0,0,2,2,2,2,2,0,0,
0,0,0,0,2,0,0x4e7a,0,2,0,0x4eba,0x4efa,2,2,0,1,
2,2,0xe12,2,1,0,0,0,0,1,0,0,1,1,2,2,
0,0,0,0,0,2,1,1,0x21,0x21,0,0,0,0,0xf211,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,0x812,
0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,0xf811,
0,0,0,0x92,0xff91,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,0xd12,
0xd12,0xd12,0xd12,0xd12,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,
0xf311,0xf311,0xf311,0xf311,0xf311,0xf311,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x1812,0x1812,0x1812,0x1812,
0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,
0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0x1812,0xe811,0xe811,0xe811,0xe811,
0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,
0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0xe811,0x92,0xff91,0x4f3a,0x4f5a,
0x4f7a,0x4f99,0x4fb9,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x4fda,0x4ffa,0x501a,0x503a,1,0x92,0xff91,
1,0x92,0xff91,1,1,1,1,1,0x25,5,0x505a,0x505a,0x92,0xff91,0x92,0xff91,
1,0,0,0,0,0,0,0x92,0xff91,0x92,0xff91,0x44,0x44,0x44,0x92,0xff91,
0,0,0,0,0,0,0,0,0,0,0,0,0x5079,0x5079,0x5079,0x5079,
0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,
0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0x5079,0,0x5079,
0,0,0,0,0,0x5079,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0x64,0x44,0x44,0x44,0x44,
0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0,0,0,
0,0,0,0,0,0,0x64,0x64,0x64,0x64,0x60,0x60,0,4,4,4,
4,4,0,0,0,0,0,4,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0x64,0x64,4,4,4,4,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x509a,0x50d9,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0,0x44,4,4,4,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
0x44,0x44,0,4,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
5,5,0x44,0x44,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x44,0x44,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,1,1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,5,1,1,1,1,1,1,1,
1,0x92,0xff91,0x92,0xff91,0x511a,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
4,4,4,0x92,0xff91,0x513a,1,0,0x92,0xff91,0x92,0xff91,0x1811,1,0x92,0xff91,
0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x515a,0x517a,0x519a,0x51ba,0x515a,1,
0x51da,0x51fa,0x521a,0x523a,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x92,0xff91,
0xe812,0x525a,0x527a,0x92,0xff91,0x92,0xff91,0x529a,0x92,0xff91,0,0,0x92,0xff91,0,1,
0,1,0x92,0xff91,0x92,0xff91,0x92,0xff91,0x52ba,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,
5,0x92,0xff91,0,5,5,1,0,0,0,0,0,0,0,4,0,
0,0,0x64,0,0,0,0,4,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,
0,0,0,0,0x64,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x64,4,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
0x44,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,0,0,0,0,0,
0,0,0,4,0,0,0,0,0,0,4,4,4,4,4,0x64,
0x64,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,
4,4,0,0x60,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0x64,0,0,4,4,4,4,0,0,
4,4,0,0,0x60,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,4,4,4,4,4,4,0,0,4,4,0,
0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,4,
0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,
0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x44,0,0x44,0x44,
0x64,0,0,0x44,0x44,0,0,0,0,0,0x44,0x44,0,0x44,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,4,
4,0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,0x52d9,1,1,1,1,1,1,1,4,
5,5,5,5,1,1,1,1,1,1,1,1,1,5,4,4,
0,0,0,0,0x52f9,0x5329,0x5359,0x5389,0x53b9,0x53e9,0x5419,0x5449,0x5479,0x54a9,0x54d9,0x5509,
0x5539,0x5569,0x5599,0x55c9,0x5bf9,0x5c29,0x5c59,0x5c89,0x5cb9,0x5ce9,0x5d19,0x5d49,0x5d79,0x5da9,0x5dd9,0x5e09,
0x5e39,0x5e69,0x5e99,0x5ec9,0x5ef9,0x5f29,0x5f59,0x5f89,0x5fb9,0x5fe9,0x6019,0x6049,0x6079,0x60a9,0x60d9,0x6109,
0x6139,0x6169,0x6199,0x61c9,0x55f9,0x5629,0x5659,0x5689,0x56b9,0x56e9,0x5719,0x5749,0x5779,0x57a9,0x57d9,0x5809,
0x5839,0x5869,0x5899,0x58c9,0x58f9,0x5929,0x5959,0x5989,0x59b9,0x59e9,0x5a19,0x5a49,0x5a79,0x5aa9,0x5ad9,0x5b09,
0x5b39,0x5b69,0x5b99,0x5bc9,0,0,0,0,0,4,0,0,4,0,0,0,
0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x61f9,0x6279,0x62f9,0x6379,0x6429,0x64d9,0x6569,0,0,0,0,0,
0,0,0,0,0,0,0,0x6609,0x6689,0x6709,0x6789,0x6809,0,0,0,0,
0,0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,0,0,0,4,0,0,0,0,
0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x64,
0x64,0x64,0x64,0x64,0x64,0x64,0x44,0x44,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,4,0,0,4,0,0,
0,0,0,0,0,0,0,0,0,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,
0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,
0x1012,0x1012,0x1012,0,0,0,4,0,4,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,
0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,
0xf011,0xf011,0xf011,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0x64,0,0,
0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,0x1412,0x1412,0x1412,0x1412,
0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,
0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0xec11,0xec11,0xec11,0xec11,
0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,
0xec11,0xec11,0xec11,0xec11,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,
0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0x1412,0,0,0,0,0xec11,0xec11,0xec11,0xec11,
0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,
0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0xec11,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,
0x1392,0x1392,0x1392,0,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0,0x1392,0x1392,0,0xec91,
0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0,0xec91,0xec91,0xec91,0xec91,0xec91,
0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0xec91,0,0xec91,0xec91,0xec91,0xec91,0xec91,
0xec91,0xec91,0,0xec91,0xec91,0,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,
5,5,5,0,0,0,0,0,5,4,4,5,5,5,0,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0,4,4,4,0,4,4,0,
0,0,0,0,4,0x64,4,0x44,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x44,0x64,0x64,0,0,0,0,0x64,0,0,0,0,0,0x44,0x64,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,
0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,
0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0x2012,0,0,0,0,0,
0,0,0,0,0,0,0,0,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,
0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,
0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0xe011,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,4,0,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,
0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0,0,0,0x44,0x44,0x44,
0x44,0x44,0,4,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,
0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0x44,0x44,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,4,0x64,0x64,0x64,0,0,0,0,0,0,0x64,0x64,
0x44,0x44,0x44,0x64,0x44,0x64,0x64,0x64,0x64,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0x44,0x64,0x44,0x64,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,
4,4,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x64,0,0,4,
4,0,0,0,0,0,0,0,0,0,0,0x64,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
4,4,4,0,0,0x64,0x64,0,0,4,0,0,0,0,4,0,
0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
4,4,4,4,0,4,4,4,4,4,4,0x64,0x64,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,
4,4,4,0,0x60,0,0,0,0,0,0,0,0,4,0x64,4,
4,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,4,4,4,0,0,4,0x60,0x64,4,
0,0,0,0,0,0,4,0,0,0,0,4,4,4,4,4,
4,0x64,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,
0,0,0,0,0,0x60,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,
0x44,0,0,0,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,0,0,
0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,
0,0,0x64,0x60,0x64,0,4,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0x64,4,4,0,0x64,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0x44,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,4,4,4,4,4,4,0,4,0,
0,0,0,4,4,0,0x64,0x64,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,4,4,4,4,0,0,0,0,0,0,
4,4,0,0x64,0x64,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,0,
0,4,0,0x64,0,0,0,0,0,0,0,0,0,0,0,4,
0,4,0,0,4,4,4,4,4,4,0x60,0x64,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,4,0,4,0,0,4,4,
4,4,0,4,4,4,4,0x64,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
4,4,4,4,4,4,4,4,0,0x64,0x64,0,0,0,0,0,
0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,
0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,0x1012,
0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,
0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,0xf011,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,4,4,0x60,0x64,0,
0,0,0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
4,4,4,4,0,0,4,4,0,0,0,0,0,4,4,4,
4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
0x64,4,4,4,4,0,0,4,4,4,4,0,0,0,0,0,
0,0,0,0x64,0,0,0,0,0,0,0,0,0,4,4,4,
4,4,4,0,0,4,4,4,0,0,0,0,0,0,0,0,
0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,0,
4,0x64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,4,4,4,4,4,4,4,0,4,4,4,4,
4,4,0,0x64,4,4,4,4,4,4,4,4,0,0,4,4,
4,4,4,4,4,0,4,4,0,4,4,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,
4,4,4,0,0,0,4,0,4,4,0,4,4,4,0x64,4,
0x64,0x64,0,4,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,
0,4,0,0x64,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,4,4,4,4,4,0,0,0,0,0,4,0x60,0x64,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,4,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,
0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,
4,4,0,0,0,4,4,0x64,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x64,0x64,0x64,0x64,0x64,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,0,4,4,0,0,0,
0,0,0,0,0,0,0,0,0x60,0x60,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
0,4,4,4,4,4,4,4,0,4,4,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,4,0x64,0,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,0,0,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0x60,0x60,0x64,0x64,0x64,0,0,
0,0x60,0x60,0x60,0x60,0x60,0x60,4,4,4,4,4,4,4,4,0x64,
0x64,0x64,0x64,0x64,0x64,0x64,0x64,0,0,0x44,0x44,0x44,0x44,0x44,0x64,0x64,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0x44,0x44,0x44,0x44,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x44,0x44,
0x44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,1,1,1,1,1,1,1,1,0x21,0x21,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,
1,1,1,1,1,0,0x21,0x21,1,1,1,1,1,1,1,1,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,
1,1,0x21,0x21,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,2,0,2,2,0,0,2,0,0,2,2,0,
0,2,2,2,2,0,2,2,2,2,2,2,2,2,1,1,
1,1,0,1,0,1,0x21,0x21,1,1,1,1,0,1,1,1,
1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,1,1,1,1,2,2,0,2,
2,2,2,0,0,2,2,2,2,2,2,2,2,0,2,2,
2,2,2,2,2,0,1,1,1,1,1,1,1,1,0x21,0x21,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
2,2,0,2,2,2,2,0,2,2,2,2,2,0,2,0,
0,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,
1,1,0x21,0x21,1,1,1,1,1,1,1,1,1,1,1,1,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,1,1,1,1,1,1,0,0,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,0,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,0,1,1,1,1,1,1,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,
1,1,1,1,1,1,2,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,4,0,0,0,0,4,4,4,4,4,4,4,4,4,
4,4,4,4,4,0,0,0,0,0,0,0,0,4,0,0,
0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,
4,4,4,4,0,4,4,4,4,4,4,4,4,4,4,4,
4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0x44,0x44,0x44,0x44,
0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0,0,0x44,
0x44,0x44,0x44,0x44,1,1,1,1,1,1,1,1,1,1,0,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x21,1,
1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x44,0x44,0,0x44,0x44,0,0x44,0x44,0x44,0x44,0x44,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0x25,5,5,5,5,5,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x44,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,0x25,0x25,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x44,0x44,0x44,0x44,0x44,0x44,0x44,4,4,4,4,4,4,4,0,0,
0,0,0,0,0,0,0,0,0,0,0,4,0x64,0x64,0x64,0x44,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0x44,0x64,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0,0,0,0,0,
0,0,0,0,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,
0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,
0x1112,0x1112,0x1112,0x1112,0x1112,0x1112,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,
0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,0xef11,
0xef11,0xef11,0xef11,0xef11,0x44,0x44,0x44,0x44,0x44,0x44,0x64,4,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0
};

static const uint16_t ucase_props_exceptions[1672]={
0xc850,0x20,2,0x130,0x131,0x4810,0x20,0x841,0x6b,1,0x212a,0x841,0x73,1,0x17f,0x5c50,
0x20,2,0x130,0x131,0x844,0x4b,1,0x212a,0x844,0x53,1,0x17f,0x806,0x3bc,0x39c,0x841,
0xe5,1,0x212b,0x8c0,1,0x2220,0x73,0x73,0x53,0x53,0x53,0x73,0x1e9e,0x844,0xc5,1,
0x212b,0x4810,1,0xce50,0xc7,2,0x49,0x131,0x844,0x49,2,0x69,0x130,0x880,0x2220,0x2bc,
0x6e,0x2bc,0x4e,0x2bc,0x4e,0x806,0x73,0x53,0x810,0xa641,0x809,0x1c6,0x1c5,0x80d,0x1c6,0x1c4,
0x1c5,0x80c,0x1c4,0x1c5,0x809,0x1c9,0x1c8,0x80d,0x1c9,0x1c7,0x1c8,0x80c,0x1c7,0x1c8,0x809,0x1cc,
0x1cb,0x80d,0x1cc,0x1ca,0x1cb,0x80c,0x1ca,0x1cb,0x880,0x2220,0x6a,0x30c,0x4a,0x30c,0x4a,0x30c,
0x809,0x1f3,0x1f2,0x80d,0x1f3,0x1f1,0x1f2,0x80c,0x1f1,0x1f2,0x810,0x2a2b,0x810,0x2a28,0x810,0x2a3f,
0x810,0x2a1f,0x810,0x2a1c,0x810,0x2a1e,0x810,0xa54f,0x810,0xa54b,0x810,0xa567,0x810,0xa528,0x810,0xa544,
0x810,0x29f7,0x810,0xa541,0x810,0x29fd,0x810,0x29e7,0x810,0xa543,0x810,0xa52a,0x1810,0xa515,0x810,0xa512,
0x6800,0x3846,0x3b9,0x399,1,0x1fbe,0x8c0,1,0x3330,0x3b9,0x308,0x301,0x399,0x308,0x301,0x399,
0x308,0x301,0x1fd3,0x841,0x3b2,1,0x3d0,0x841,0x3b5,1,0x3f5,0x841,0x3b8,2,0x3d1,0x3f4,
0x841,0x3b9,2,0x345,0x1fbe,0x841,0x3ba,1,0x3f0,0x841,0x3bc,1,0xb5,0x841,0x3c0,1,
0x3d6,0x841,0x3c1,1,0x3f1,0x4850,0x20,1,0x3c2,0x841,0x3c6,1,0x3d5,0x841,0x3c9,1,
0x2126,0x8c0,1,0x3330,0x3c5,0x308,0x301,0x3a5,0x308,0x301,0x3a5,0x308,0x301,0x1fe3,0x844,0x392,
1,0x3d0,0x844,0x395,1,0x3f5,0x844,0x398,2,0x3d1,0x3f4,0x844,0x399,2,0x345,0x1fbe,
0x844,0x39a,1,0x3f0,0x844,0x39c,1,0xb5,0x844,0x3a0,1,0x3d6,0x844,0x3a1,1,0x3f1,
0x806,0x3c3,0x3a3,0x844,0x3a3,1,0x3c2,0x844,0x3a6,1,0x3d5,0x844,0x3a9,1,0x2126,0x806,
0x3b2,0x392,0x846,0x3b8,0x398,1,0x3f4,0x806,0x3c6,0x3a6,0x806,0x3c0,0x3a0,0x806,0x3ba,0x39a,
0x806,0x3c1,0x3a1,0x841,0x3b8,2,0x398,0x3d1,0x806,0x3b5,0x395,0x841,0x432,1,0x1c80,0x841,
0x434,1,0x1c81,0x841,0x43e,1,0x1c82,0x841,0x441,1,0x1c83,0x841,0x442,2,0x1c84,0x1c85,
0x841,0x44a,1,0x1c86,0x844,0x412,1,0x1c80,0x844,0x414,1,0x1c81,0x844,0x41e,1,0x1c82,
0x844,0x421,1,0x1c83,0x844,0x422,2,0x1c84,0x1c85,0x844,0x42a,1,0x1c86,0x841,0x463,1,
0x1c87,0x844,0x462,1,0x1c87,0x4880,0x20,0x565,0x582,0x810,0x1c60,0x80c,0x1c90,0x10d0,0x80c,0x1c91,
0x10d1,0x80c,0x1c92,0x10d2,0x80c,0x1c93,0x10d3,0x80c,0x1c94,0x10d4,0x80c,0x1c95,0x10d5,0x80c,0x1c96,0x10d6,
0x80c,0x1c97,0x10d7,0x80c,0x1c98,0x10d8,0x80c,0x1c99,0x10d9,0x80c,0x1c9a,0x10da,0x80c,0x1c9b,0x10db,0x80c,
0x1c9c,0x10dc,0x80c,0x1c9d,0x10dd,0x80c,0x1c9e,0x10de,0x80c,0x1c9f,0x10df,0x80c,0x1ca0,0x10e0,0x80c,0x1ca1,
0x10e1,0x80c,0x1ca2,0x10e2,0x80c,0x1ca3,0x10e3,0x80c,0x1ca4,0x10e4,0x80c,0x1ca5,0x10e5,0x80c,0x1ca6,0x10e6,
0x80c,0x1ca7,0x10e7,0x80c,0x1ca8,0x10e8,0x80c,0x1ca9,0x10e9,0x80c,0x1caa,0x10ea,0x80c,0x1cab,0x10eb,0x80c,
0x1cac,0x10ec,0x80c,0x1cad,0x10ed,0x80c,0x1cae,0x10ee,0x80c,0x1caf,0x10ef,0x80c,0x1cb0,0x10f0,0x80c,0x1cb1,
0x10f1,0x80c,0x1cb2,0x10f2,0x80c,0x1cb3,0x10f3,0x80c,0x1cb4,0x10f4,0x80c,0x1cb5,0x10f5,0x80c,0x1cb6,0x10f6,
0x80c,0x1cb7,0x10f7,0x80c,0x1cb8,0x10f8,0x80c,0x1cb9,0x10f9,0x80c,0x1cba,0x10fa,0x80c,0x1cbd,0x10fd,0x80c,
0x1cbe,0x10fe,0x80c,0x1cbf,0x10ff,0xa10,0x97d0,0xa10,8,0x806,0x13f0,0x13f0,0x806,0x13f1,0x13f1,0x806,
0x13f2,0x13f2,0x806,0x13f3,0x13f3,0x806,0x13f4,0x13f4,0x806,0x13f5,0x13f5,0x806,0x432,0x412,0x806,0x434,
0x414,0x806,0x43e,0x41e,0x806,0x441,0x421,0x846,0x442,0x422,1,0x1c85,0x846,0x442,0x422,1,
0x1c84,0x806,0x44a,0x42a,0x806,0x463,0x462,0x806,0xa64b,0xa64a,0xc10,0xbc0,0x810,0x8a04,0x810,0xee6,
0x810,0x8a38,0x841,0x1e61,1,0x1e9b,0x844,0x1e60,1,0x1e9b,0x880,0x2220,0x68,0x331,0x48,0x331,
0x48,0x331,0x880,0x2220,0x74,0x308,0x54,0x308,0x54,0x308,0x880,0x2220,0x77,0x30a,0x57,0x30a,
0x57,0x30a,0x880,0x2220,0x79,0x30a,0x59,0x30a,0x59,0x30a,0x880,0x2220,0x61,0x2be,0x41,0x2be,
0x41,0x2be,0x806,0x1e61,0x1e60,0xc90,0x1dbf,0x20,0x73,0x73,0x880,0x2220,0x3c5,0x313,0x3a5,0x313,
0x3a5,0x313,0x880,0x3330,0x3c5,0x313,0x300,0x3a5,0x313,0x300,0x3a5,0x313,0x300,0x880,0x3330,0x3c5,
0x313,0x301,0x3a5,0x313,0x301,0x3a5,0x313,0x301,0x880,0x3330,0x3c5,0x313,0x342,0x3a5,0x313,0x342,
0x3a5,0x313,0x342,0x890,8,0x220,0x1f00,0x3b9,0x1f08,0x399,0x890,8,0x220,0x1f01,0x3b9,0x1f09,
0x399,0x890,8,0x220,0x1f02,0x3b9,0x1f0a,0x399,0x890,8,0x220,0x1f03,0x3b9,0x1f0b,0x399,0x890,
8,0x220,0x1f04,0x3b9,0x1f0c,0x399,0x890,8,0x220,0x1f05,0x3b9,0x1f0d,0x399,0x890,8,0x220,
0x1f06,0x3b9,0x1f0e,0x399,0x890,8,0x220,0x1f07,0x3b9,0x1f0f,0x399,0xc90,8,0x220,0x1f00,0x3b9,
0x1f08,0x399,0xc90,8,0x220,0x1f01,0x3b9,0x1f09,0x399,0xc90,8,0x220,0x1f02,0x3b9,0x1f0a,0x399,
0xc90,8,0x220,0x1f03,0x3b9,0x1f0b,0x399,0xc90,8,0x220,0x1f04,0x3b9,0x1f0c,0x399,0xc90,8,
0x220,0x1f05,0x3b9,0x1f0d,0x399,0xc90,8,0x220,0x1f06,0x3b9,0x1f0e,0x399,0xc90,8,0x220,0x1f07,
0x3b9,0x1f0f,0x399,0x890,8,0x220,0x1f20,0x3b9,0x1f28,0x399,0x890,8,0x220,0x1f21,0x3b9,0x1f29,
0x399,0x890,8,0x220,0x1f22,0x3b9,0x1f2a,0x399,0x890,8,0x220,0x1f23,0x3b9,0x1f2b,0x399,0x890,
8,0x220,0x1f24,0x3b9,0x1f2c,0x399,0x890,8,0x220,0x1f25,0x3b9,0x1f2d,0x399,0x890,8,0x220,
0x1f26,0x3b9,0x1f2e,0x399,0x890,8,0x220,0x1f27,0x3b9,0x1f2f,0x399,0xc90,8,0x220,0x1f20,0x3b9,
0x1f28,0x399,0xc90,8,0x220,0x1f21,0x3b9,0x1f29,0x399,0xc90,8,0x220,0x1f22,0x3b9,0x1f2a,0x399,
0xc90,8,0x220,0x1f23,0x3b9,0x1f2b,0x399,0xc90,8,0x220,0x1f24,0x3b9,0x1f2c,0x399,0xc90,8,
0x220,0x1f25,0x3b9,0x1f2d,0x399,0xc90,8,0x220,0x1f26,0x3b9,0x1f2e,0x399,0xc90,8,0x220,0x1f27,
0x3b9,0x1f2f,0x399,0x890,8,0x220,0x1f60,0x3b9,0x1f68,0x399,0x890,8,0x220,0x1f61,0x3b9,0x1f69,
0x399,0x890,8,0x220,0x1f62,0x3b9,0x1f6a,0x399,0x890,8,0x220,0x1f63,0x3b9,0x1f6b,0x399,0x890,
8,0x220,0x1f64,0x3b9,0x1f6c,0x399,0x890,8,0x220,0x1f65,0x3b9,0x1f6d,0x399,0x890,8,0x220,
0x1f66,0x3b9,0x1f6e,0x399,0x890,8,0x220,0x1f67,0x3b9,0x1f6f,0x399,0xc90,8,0x220,0x1f60,0x3b9,
0x1f68,0x399,0xc90,8,0x220,0x1f61,0x3b9,0x1f69,0x399,0xc90,8,0x220,0x1f62,0x3b9,0x1f6a,0x399,
0xc90,8,0x220,0x1f63,0x3b9,0x1f6b,0x399,0xc90,8,0x220,0x1f64,0x3b9,0x1f6c,0x399,0xc90,8,
0x220,0x1f65,0x3b9,0x1f6d,0x399,0xc90,8,0x220,0x1f66,0x3b9,0x1f6e,0x399,0xc90,8,0x220,0x1f67,
0x3b9,0x1f6f,0x399,0x880,0x2220,0x1f70,0x3b9,0x1fba,0x399,0x1fba,0x345,0x890,9,0x220,0x3b1,0x3b9,
0x391,0x399,0x880,0x2220,0x3ac,0x3b9,0x386,0x399,0x386,0x345,0x880,0x2220,0x3b1,0x342,0x391,0x342,
0x391,0x342,0x880,0x3330,0x3b1,0x342,0x3b9,0x391,0x342,0x399,0x391,0x342,0x345,0xc90,9,0x220,
0x3b1,0x3b9,0x391,0x399,0x846,0x3b9,0x399,1,0x345,0x880,0x2220,0x1f74,0x3b9,0x1fca,0x399,0x1fca,
0x345,0x890,9,0x220,0x3b7,0x3b9,0x397,0x399,0x880,0x2220,0x3ae,0x3b9,0x389,0x399,0x389,0x345,
0x880,0x2220,0x3b7,0x342,0x397,0x342,0x397,0x342,0x880,0x3330,0x3b7,0x342,0x3b9,0x397,0x342,0x399,
0x397,0x342,0x345,0xc90,9,0x220,0x3b7,0x3b9,0x397,0x399,0x880,0x3330,0x3b9,0x308,0x300,0x399,
0x308,0x300,0x399,0x308,0x300,0x882,0x390,0x3330,0x3b9,0x308,0x301,0x399,0x308,0x301,0x399,0x308,
0x301,0x880,0x2220,0x3b9,0x342,0x399,0x342,0x399,0x342,0x880,0x3330,0x3b9,0x308,0x342,0x399,0x308,
0x342,0x399,0x308,0x342,0x880,0x3330,0x3c5,0x308,0x300,0x3a5,0x308,0x300,0x3a5,0x308,0x300,0x882,
0x3b0,0x3330,0x3c5,0x308,0x301,0x3a5,0x308,0x301,0x3a5,0x308,0x301,0x880,0x2220,0x3c1,0x313,0x3a1,
0x313,0x3a1,0x313,0x880,0x2220,0x3c5,0x342,0x3a5,0x342,0x3a5,0x342,0x880,0x3330,0x3c5,0x308,0x342,
0x3a5,0x308,0x342,0x3a5,0x308,0x342,0x880,0x2220,0x1f7c,0x3b9,0x1ffa,0x399,0x1ffa,0x345,0x890,9,
0x220,0x3c9,0x3b9,0x3a9,0x399,0x880,0x2220,0x3ce,0x3b9,0x38f,0x399,0x38f,0x345,0x880,0x2220,0x3c9,
0x342,0x3a9,0x342,0x3a9,0x342,0x880,0x3330,0x3c9,0x342,0x3b9,0x3a9,0x342,0x399,0x3a9,0x342,0x345,
0xc90,9,0x220,0x3c9,0x3b9,0x3a9,0x399,0xc50,0x1d5d,1,0x3a9,0xc50,0x20bf,1,0x4b,0xc50,
0x2046,1,0xc5,0xc10,0x29f7,0xc10,0xee6,0xc10,0x29e7,0xc10,0x2a2b,0xc10,0x2a28,0xc10,0x2a1c,0xc10,
0x29fd,0xc10,0x2a1f,0xc10,0x2a1e,0xc10,0x2a3f,0xc10,0x1c60,0x841,0xa64b,1,0x1c88,0x844,0xa64a,1,
0x1c88,0xc10,0x8a04,0xc10,0xa528,0xc10,0xa544,0xc10,0xa54f,0xc10,0xa54b,0xc10,0xa541,0xc10,0xa512,0xc10,
0xa52a,0xc10,0xa515,0x810,0x3a0,0xc10,0xa543,0xc10,0x8a38,0xc10,0xa567,0xc10,0xa641,0xc10,0x3a0,0x806,
0x13a0,0x13a0,0x806,0x13a1,0x13a1,0x806,0x13a2,0x13a2,0x806,0x13a3,0x13a3,0x806,0x13a4,0x13a4,0x806,0x13a5,
0x13a5,0x806,0x13a6,0x13a6,0x806,0x13a7,0x13a7,0x806,0x13a8,0x13a8,0x806,0x13a9,0x13a9,0x806,0x13aa,0x13aa,
0x806,0x13ab,0x13ab,0x806,0x13ac,0x13ac,0x806,0x13ad,0x13ad,0x806,0x13ae,0x13ae,0x806,0x13af,0x13af,0x806,
0x13b0,0x13b0,0x806,0x13b1,0x13b1,0x806,0x13b2,0x13b2,0x806,0x13b3,0x13b3,0x806,0x13b4,0x13b4,0x806,0x13b5,
0x13b5,0x806,0x13b6,0x13b6,0x806,0x13b7,0x13b7,0x806,0x13b8,0x13b8,0x806,0x13b9,0x13b9,0x806,0x13ba,0x13ba,
0x806,0x13bb,0x13bb,0x806,0x13bc,0x13bc,0x806,0x13bd,0x13bd,0x806,0x13be,0x13be,0x806,0x13bf,0x13bf,0x806,
0x13c0,0x13c0,0x806,0x13c1,0x13c1,0x806,0x13c2,0x13c2,0x806,0x13c3,0x13c3,0x806,0x13c4,0x13c4,0x806,0x13c5,
0x13c5,0x806,0x13c6,0x13c6,0x806,0x13c7,0x13c7,0x806,0x13c8,0x13c8,0x806,0x13c9,0x13c9,0x806,0x13ca,0x13ca,
0x806,0x13cb,0x13cb,0x806,0x13cc,0x13cc,0x806,0x13cd,0x13cd,0x806,0x13ce,0x13ce,0x806,0x13cf,0x13cf,0x806,
0x13d0,0x13d0,0x806,0x13d1,0x13d1,0x806,0x13d2,0x13d2,0x806,0x13d3,0x13d3,0x806,0x13d4,0x13d4,0x806,0x13d5,
0x13d5,0x806,0x13d6,0x13d6,0x806,0x13d7,0x13d7,0x806,0x13d8,0x13d8,0x806,0x13d9,0x13d9,0x806,0x13da,0x13da,
0x806,0x13db,0x13db,0x806,0x13dc,0x13dc,0x806,0x13dd,0x13dd,0x806,0x13de,0x13de,0x806,0x13df,0x13df,0x806,
0x13e0,0x13e0,0x806,0x13e1,0x13e1,0x806,0x13e2,0x13e2,0x806,0x13e3,0x13e3,0x806,0x13e4,0x13e4,0x806,0x13e5,
0x13e5,0x806,0x13e6,0x13e6,0x806,0x13e7,0x13e7,0x806,0x13e8,0x13e8,0x806,0x13e9,0x13e9,0x806,0x13ea,0x13ea,
0x806,0x13eb,0x13eb,0x806,0x13ec,0x13ec,0x806,0x13ed,0x13ed,0x806,0x13ee,0x13ee,0x806,0x13ef,0x13ef,0x880,
0x2220,0x66,0x66,0x46,0x46,0x46,0x66,0x880,0x2220,0x66,0x69,0x46,0x49,0x46,0x69,0x880,
0x2220,0x66,0x6c,0x46,0x4c,0x46,0x6c,0x880,0x3330,0x66,0x66,0x69,0x46,0x46,0x49,0x46,
0x66,0x69,0x880,0x3330,0x66,0x66,0x6c,0x46,0x46,0x4c,0x46,0x66,0x6c,0x882,0xfb06,0x2220,
0x73,0x74,0x53,0x54,0x53,0x74,0x8c0,1,0x2220,0x73,0x74,0x53,0x54,0x53,0x74,0xfb05,
0x880,0x2220,0x574,0x576,0x544,0x546,0x544,0x576,0x880,0x2220,0x574,0x565,0x544,0x535,0x544,0x565,
0x880,0x2220,0x574,0x56b,0x544,0x53b,0x544,0x56b,0x880,0x2220,0x57e,0x576,0x54e,0x546,0x54e,0x576,
0x880,0x2220,0x574,0x56d,0x544,0x53d,0x544,0x56d
};

static const uint16_t ucase_props_unfold[370]={
0x49,5,3,0,0,0x61,0x2be,0,0x1e9a,0,0x66,0x66,0,0xfb00,0,0x66,
0x66,0x69,0xfb03,0,0x66,0x66,0x6c,0xfb04,0,0x66,0x69,0,0xfb01,0,0x66,0x6c,
0,0xfb02,0,0x68,0x331,0,0x1e96,0,0x69,0x307,0,0x130,0,0x6a,0x30c,0,
0x1f0,0,0x73,0x73,0,0xdf,0x1e9e,0x73,0x74,0,0xfb05,0xfb06,0x74,0x308,0,0x1e97,
0,0x77,0x30a,0,0x1e98,0,0x79,0x30a,0,0x1e99,0,0x2bc,0x6e,0,0x149,0,
0x3ac,0x3b9,0,0x1fb4,0,0x3ae,0x3b9,0,0x1fc4,0,0x3b1,0x342,0,0x1fb6,0,0x3b1,
0x342,0x3b9,0x1fb7,0,0x3b1,0x3b9,0,0x1fb3,0x1fbc,0x3b7,0x342,0,0x1fc6,0,0x3b7,0x342,
0x3b9,0x1fc7,0,0x3b7,0x3b9,0,0x1fc3,0x1fcc,0x3b9,0x308,0x300,0x1fd2,0,0x3b9,0x308,0x301,
0x390,0x1fd3,0x3b9,0x308,0x342,0x1fd7,0,0x3b9,0x342,0,0x1fd6,0,0x3c1,0x313,0,0x1fe4,
0,0x3c5,0x308,0x300,0x1fe2,0,0x3c5,0x308,0x301,0x3b0,0x1fe3,0x3c5,0x308,0x342,0x1fe7,0,
0x3c5,0x313,0,0x1f50,0,0x3c5,0x313,0x300,0x1f52,0,0x3c5,0x313,0x301,0x1f54,0,0x3c5,
0x313,0x342,0x1f56,0,0x3c5,0x342,0,0x1fe6,0,0x3c9,0x342,0,0x1ff6,0,0x3c9,0x342,
0x3b9,0x1ff7,0,0x3c9,0x3b9,0,0x1ff3,0x1ffc,0x3ce,0x3b9,0,0x1ff4,0,0x565,0x582,0,
0x587,0,0x574,0x565,0,0xfb14,0,0x574,0x56b,0,0xfb15,0,0x574,0x56d,0,0xfb17,
0,0x574,0x576,0,0xfb13,0,0x57e,0x576,0,0xfb16,0,0x1f00,0x3b9,0,0x1f80,0x1f88,
0x1f01,0x3b9,0,0x1f81,0x1f89,0x1f02,0x3b9,0,0x1f82,0x1f8a,0x1f03,0x3b9,0,0x1f83,0x1f8b,0x1f04,
0x3b9,0,0x1f84,0x1f8c,0x1f05,0x3b9,0,0x1f85,0x1f8d,0x1f06,0x3b9,0,0x1f86,0x1f8e,0x1f07,0x3b9,
0,0x1f87,0x1f8f,0x1f20,0x3b9,0,0x1f90,0x1f98,0x1f21,0x3b9,0,0x1f91,0x1f99,0x1f22,0x3b9,0,
0x1f92,0x1f9a,0x1f23,0x3b9,0,0x1f93,0x1f9b,0x1f24,0x3b9,0,0x1f94,0x1f9c,0x1f25,0x3b9,0,0x1f95,
0x1f9d,0x1f26,0x3b9,0,0x1f96,0x1f9e,0x1f27,0x3b9,0,0x1f97,0x1f9f,0x1f60,0x3b9,0,0x1fa0,0x1fa8,
0x1f61,0x3b9,0,0x1fa1,0x1fa9,0x1f62,0x3b9,0,0x1fa2,0x1faa,0x1f63,0x3b9,0,0x1fa3,0x1fab,0x1f64,
0x3b9,0,0x1fa4,0x1fac,0x1f65,0x3b9,0,0x1fa5,0x1fad,0x1f66,0x3b9,0,0x1fa6,0x1fae,0x1f67,0x3b9,
0,0x1fa7,0x1faf,0x1f70,0x3b9,0,0x1fb2,0,0x1f74,0x3b9,0,0x1fc2,0,0x1f7c,0x3b9,0,
0x1ff2,0
};

static const UCaseProps ucase_props_singleton={
  nullptr,
  ucase_props_indexes,
  ucase_props_exceptions,
  ucase_props_unfold,
  {
    ucase_props_trieIndex,
    ucase_props_trieIndex+3468,
    nullptr,
    3468,
    9904,
    0x188,
    0xe08,
    0x0,
    0x0,
    0xe0800,
    0x3438,
    nullptr, 0, false, false, 0, nullptr
  },
  { 4,0,0,0 }
};

#endif  // INCLUDED_FROM_UCASE_CPP
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/icu-small/source/common/ucasemap.cpp                                               0000664 0000000 0000000 00000111623 14746647661 0022474 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
*******************************************************************************
*
*   Copyright (C) 2005-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
*******************************************************************************
*   file name:  ucasemap.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2005may06
*   created by: Markus W. Scherer
*
*   Case mapping service object and functions using it.
*/

#include "unicode/utypes.h"
#include "unicode/brkiter.h"
#include "unicode/bytestream.h"
#include "unicode/casemap.h"
#include "unicode/edits.h"
#include "unicode/stringoptions.h"
#include "unicode/stringpiece.h"
#include "unicode/ubrk.h"
#include "unicode/uloc.h"
#include "unicode/ustring.h"
#include "unicode/ucasemap.h"
#if !UCONFIG_NO_BREAK_ITERATION
#include "unicode/utext.h"
#endif
#include "unicode/utf.h"
#include "unicode/utf8.h"
#include "unicode/utf16.h"
#include "bytesinkutil.h"
#include "cmemory.h"
#include "cstring.h"
#include "uassert.h"
#include "ucase.h"
#include "ucasemap_imp.h"

U_NAMESPACE_USE

/* UCaseMap service object -------------------------------------------------- */

UCaseMap::UCaseMap(const char *localeID, uint32_t opts, UErrorCode *pErrorCode) :
#if !UCONFIG_NO_BREAK_ITERATION
        iter(nullptr),
#endif
        caseLocale(UCASE_LOC_UNKNOWN), options(opts) {
    ucasemap_setLocale(this, localeID, pErrorCode);
}

UCaseMap::~UCaseMap() {
#if !UCONFIG_NO_BREAK_ITERATION
    delete iter;
#endif
}

U_CAPI UCaseMap * U_EXPORT2
ucasemap_open(const char *locale, uint32_t options, UErrorCode *pErrorCode) {
    if(U_FAILURE(*pErrorCode)) {
        return nullptr;
    }
    UCaseMap *csm = new UCaseMap(locale, options, pErrorCode);
    if(csm==nullptr) {
        *pErrorCode = U_MEMORY_ALLOCATION_ERROR;
        return nullptr;
    } else if (U_FAILURE(*pErrorCode)) {
        delete csm;
        return nullptr;
    }
    return csm;
}

U_CAPI void U_EXPORT2
ucasemap_close(UCaseMap *csm) {
    delete csm;
}

U_CAPI const char * U_EXPORT2
ucasemap_getLocale(const UCaseMap *csm) {
    return csm->locale;
}

U_CAPI uint32_t U_EXPORT2
ucasemap_getOptions(const UCaseMap *csm) {
    return csm->options;
}

U_CAPI void U_EXPORT2
ucasemap_setLocale(UCaseMap *csm, const char *locale, UErrorCode *pErrorCode) {
    if(U_FAILURE(*pErrorCode)) {
        return;
    }
    if (locale != nullptr && *locale == 0) {
        csm->locale[0] = 0;
        csm->caseLocale = UCASE_LOC_ROOT;
        return;
    }

    int32_t length=uloc_getName(locale, csm->locale, (int32_t)sizeof(csm->locale), pErrorCode);
    if(*pErrorCode==U_BUFFER_OVERFLOW_ERROR || length==sizeof(csm->locale)) {
        *pErrorCode=U_ZERO_ERROR;
        /* we only really need the language code for case mappings */
        length=uloc_getLanguage(locale, csm->locale, (int32_t)sizeof(csm->locale), pErrorCode);
    }
    if(length==sizeof(csm->locale)) {
        *pErrorCode=U_BUFFER_OVERFLOW_ERROR;
    }
    if(U_SUCCESS(*pErrorCode)) {     
        csm->caseLocale = ucase_getCaseLocale(csm->locale);
    } else {
        csm->locale[0]=0;
        csm->caseLocale = UCASE_LOC_ROOT;
    }
}

U_CAPI void U_EXPORT2
ucasemap_setOptions(UCaseMap *csm, uint32_t options, UErrorCode *pErrorCode) {
    if(U_FAILURE(*pErrorCode)) {
        return;
    }
    csm->options=options;
}

/* UTF-8 string case mappings ----------------------------------------------- */

/* TODO(markus): Move to a new, separate utf8case.cpp file. */

namespace {

/* append a full case mapping result, see UCASE_MAX_STRING_LENGTH */
inline UBool
appendResult(int32_t cpLength, int32_t result, const char16_t *s,
             ByteSink &sink, uint32_t options, icu::Edits *edits, UErrorCode &errorCode) {
    U_ASSERT(U_SUCCESS(errorCode));

    /* decode the result */
    if(result<0) {
        /* (not) original code point */
        if(edits!=nullptr) {
            edits->addUnchanged(cpLength);
        }
        if((options & U_OMIT_UNCHANGED_TEXT) == 0) {
            ByteSinkUtil::appendCodePoint(cpLength, ~result, sink);
        }
    } else {
        if(result<=UCASE_MAX_STRING_LENGTH) {
            // string: "result" is the UTF-16 length
            return ByteSinkUtil::appendChange(cpLength, s, result, sink, edits, errorCode);
        } else {
            ByteSinkUtil::appendCodePoint(cpLength, result, sink, edits);
        }
    }
    return true;
}

// See unicode/utf8.h U8_APPEND_UNSAFE().
inline uint8_t getTwoByteLead(UChar32 c) { return static_cast<uint8_t>((c >> 6) | 0xc0); }
inline uint8_t getTwoByteTrail(UChar32 c) { return static_cast<uint8_t>((c & 0x3f) | 0x80); }

UChar32 U_CALLCONV
utf8_caseContextIterator(void *context, int8_t dir) {
    UCaseContext* csc = static_cast<UCaseContext*>(context);
    UChar32 c;

    if(dir<0) {
        /* reset for backward iteration */
        csc->index=csc->cpStart;
        csc->dir=dir;
    } else if(dir>0) {
        /* reset for forward iteration */
        csc->index=csc->cpLimit;
        csc->dir=dir;
    } else {
        /* continue current iteration direction */
        dir=csc->dir;
    }

    if(dir<0) {
        if(csc->start<csc->index) {
            U8_PREV((const uint8_t *)csc->p, csc->start, csc->index, c);
            return c;
        }
    } else {
        if(csc->index<csc->limit) {
            U8_NEXT((const uint8_t *)csc->p, csc->index, csc->limit, c);
            return c;
        }
    }
    return U_SENTINEL;
}

/**
 * caseLocale >= 0: Lowercases [srcStart..srcLimit[ but takes context [0..srcLength[ into account.
 * caseLocale < 0: Case-folds [srcStart..srcLimit[.
 */
void toLower(int32_t caseLocale, uint32_t options,
             const uint8_t *src, UCaseContext *csc, int32_t srcStart, int32_t srcLimit,
             icu::ByteSink &sink, icu::Edits *edits, UErrorCode &errorCode) {
    const int8_t *latinToLower;
    if (caseLocale == UCASE_LOC_ROOT ||
            (caseLocale >= 0 ?
                !(caseLocale == UCASE_LOC_TURKISH || caseLocale == UCASE_LOC_LITHUANIAN) :
                (options & _FOLD_CASE_OPTIONS_MASK) == U_FOLD_CASE_DEFAULT)) {
        latinToLower = LatinCase::TO_LOWER_NORMAL;
    } else {
        latinToLower = LatinCase::TO_LOWER_TR_LT;
    }
    const UTrie2 *trie = ucase_getTrie();
    int32_t prev = srcStart;
    int32_t srcIndex = srcStart;
    for (;;) {
        // fast path for simple cases
        int32_t cpStart;
        UChar32 c;
        for (;;) {
            if (U_FAILURE(errorCode) || srcIndex >= srcLimit) {
                c = U_SENTINEL;
                break;
            }
            uint8_t lead = src[srcIndex++];
            if (lead <= 0x7f) {
                int8_t d = latinToLower[lead];
                if (d == LatinCase::EXC) {
                    cpStart = srcIndex - 1;
                    c = lead;
                    break;
                }
                if (d == 0) { continue; }
                ByteSinkUtil::appendUnchanged(src + prev, srcIndex - 1 - prev,
                                              sink, options, edits, errorCode);
                char ascii = static_cast<char>(lead + d);
                sink.Append(&ascii, 1);
                if (edits != nullptr) {
                    edits->addReplace(1, 1);
                }
                prev = srcIndex;
                continue;
            } else if (lead < 0xe3) {
                uint8_t t;
                if (0xc2 <= lead && lead <= 0xc5 && srcIndex < srcLimit &&
                        (t = src[srcIndex] - 0x80) <= 0x3f) {
                    // U+0080..U+017F
                    ++srcIndex;
                    c = ((lead - 0xc0) << 6) | t;
                    int8_t d = latinToLower[c];
                    if (d == LatinCase::EXC) {
                        cpStart = srcIndex - 2;
                        break;
                    }
                    if (d == 0) { continue; }
                    ByteSinkUtil::appendUnchanged(src + prev, srcIndex - 2 - prev,
                                                  sink, options, edits, errorCode);
                    ByteSinkUtil::appendTwoBytes(c + d, sink);
                    if (edits != nullptr) {
                        edits->addReplace(2, 2);
                    }
                    prev = srcIndex;
                    continue;
                }
            } else if ((lead <= 0xe9 || lead == 0xeb || lead == 0xec) &&
                    (srcIndex + 2) <= srcLimit &&
                    U8_IS_TRAIL(src[srcIndex]) && U8_IS_TRAIL(src[srcIndex + 1])) {
                // most of CJK: no case mappings
                srcIndex += 2;
                continue;
            }
            cpStart = --srcIndex;
            U8_NEXT(src, srcIndex, srcLimit, c);
            if (c < 0) {
                // ill-formed UTF-8
                continue;
            }
            uint16_t props = UTRIE2_GET16(trie, c);
            if (UCASE_HAS_EXCEPTION(props)) { break; }
            int32_t delta;
            if (!UCASE_IS_UPPER_OR_TITLE(props) || (delta = UCASE_GET_DELTA(props)) == 0) {
                continue;
            }
            ByteSinkUtil::appendUnchanged(src + prev, cpStart - prev,
                                          sink, options, edits, errorCode);
            ByteSinkUtil::appendCodePoint(srcIndex - cpStart, c + delta, sink, edits);
            prev = srcIndex;
        }
        if (c < 0) {
            break;
        }
        // slow path
        const char16_t *s;
        if (caseLocale >= 0) {
            csc->cpStart = cpStart;
            csc->cpLimit = srcIndex;
            c = ucase_toFullLower(c, utf8_caseContextIterator, csc, &s, caseLocale);
        } else {
            c = ucase_toFullFolding(c, &s, options);
        }
        if (c >= 0) {
            ByteSinkUtil::appendUnchanged(src + prev, cpStart - prev,
                                          sink, options, edits, errorCode);
            appendResult(srcIndex - cpStart, c, s, sink, options, edits, errorCode);
            prev = srcIndex;
        }
    }
    ByteSinkUtil::appendUnchanged(src + prev, srcIndex - prev,
                                  sink, options, edits, errorCode);
}

void toUpper(int32_t caseLocale, uint32_t options,
             const uint8_t *src, UCaseContext *csc, int32_t srcLength,
             icu::ByteSink &sink, icu::Edits *edits, UErrorCode &errorCode) {
    const int8_t *latinToUpper;
    if (caseLocale == UCASE_LOC_TURKISH) {
        latinToUpper = LatinCase::TO_UPPER_TR;
    } else {
        latinToUpper = LatinCase::TO_UPPER_NORMAL;
    }
    const UTrie2 *trie = ucase_getTrie();
    int32_t prev = 0;
    int32_t srcIndex = 0;
    for (;;) {
        // fast path for simple cases
        int32_t cpStart;
        UChar32 c;
        for (;;) {
            if (U_FAILURE(errorCode) || srcIndex >= srcLength) {
                c = U_SENTINEL;
                break;
            }
            uint8_t lead = src[srcIndex++];
            if (lead <= 0x7f) {
                int8_t d = latinToUpper[lead];
                if (d == LatinCase::EXC) {
                    cpStart = srcIndex - 1;
                    c = lead;
                    break;
                }
                if (d == 0) { continue; }
                ByteSinkUtil::appendUnchanged(src + prev, srcIndex - 1 - prev,
                                              sink, options, edits, errorCode);
                char ascii = static_cast<char>(lead + d);
                sink.Append(&ascii, 1);
                if (edits != nullptr) {
                    edits->addReplace(1, 1);
                }
                prev = srcIndex;
                continue;
            } else if (lead < 0xe3) {
                uint8_t t;
                if (0xc2 <= lead && lead <= 0xc5 && srcIndex < srcLength &&
                        (t = src[srcIndex] - 0x80) <= 0x3f) {
                    // U+0080..U+017F
                    ++srcIndex;
                    c = ((lead - 0xc0) << 6) | t;
                    int8_t d = latinToUpper[c];
                    if (d == LatinCase::EXC) {
                        cpStart = srcIndex - 2;
                        break;
                    }
                    if (d == 0) { continue; }
                    ByteSinkUtil::appendUnchanged(src + prev, srcIndex - 2 - prev,
                                                  sink, options, edits, errorCode);
                    ByteSinkUtil::appendTwoBytes(c + d, sink);
                    if (edits != nullptr) {
                        edits->addReplace(2, 2);
                    }
                    prev = srcIndex;
                    continue;
                }
            } else if ((lead <= 0xe9 || lead == 0xeb || lead == 0xec) &&
                    (srcIndex + 2) <= srcLength &&
                    U8_IS_TRAIL(src[srcIndex]) && U8_IS_TRAIL(src[srcIndex + 1])) {
                // most of CJK: no case mappings
                srcIndex += 2;
                continue;
            }
            cpStart = --srcIndex;
            U8_NEXT(src, srcIndex, srcLength, c);
            if (c < 0) {
                // ill-formed UTF-8
                continue;
            }
            uint16_t props = UTRIE2_GET16(trie, c);
            if (UCASE_HAS_EXCEPTION(props)) { break; }
            int32_t delta;
            if (UCASE_GET_TYPE(props) != UCASE_LOWER || (delta = UCASE_GET_DELTA(props)) == 0) {
                continue;
            }
            ByteSinkUtil::appendUnchanged(src + prev, cpStart - prev,
                                          sink, options, edits, errorCode);
            ByteSinkUtil::appendCodePoint(srcIndex - cpStart, c + delta, sink, edits);
            prev = srcIndex;
        }
        if (c < 0) {
            break;
        }
        // slow path
        csc->cpStart = cpStart;
        csc->cpLimit = srcIndex;
        const char16_t *s;
        c = ucase_toFullUpper(c, utf8_caseContextIterator, csc, &s, caseLocale);
        if (c >= 0) {
            ByteSinkUtil::appendUnchanged(src + prev, cpStart - prev,
                                          sink, options, edits, errorCode);
            appendResult(srcIndex - cpStart, c, s, sink, options, edits, errorCode);
            prev = srcIndex;
        }
    }
    ByteSinkUtil::appendUnchanged(src + prev, srcIndex - prev,
                                  sink, options, edits, errorCode);
}

}  // namespace

#if !UCONFIG_NO_BREAK_ITERATION

namespace {

constexpr uint8_t ACUTE_BYTE0 = u8"\u0301"[0];

constexpr uint8_t ACUTE_BYTE1 = u8"\u0301"[1];

/**
 * Input: c is a letter I with or without acute accent.
 * start is the index in src after c, and is less than segmentLimit.
 * If a plain i/I is followed by a plain j/J,
 * or an i/I with acute (precomposed or decomposed) is followed by a j/J with acute,
 * then we output accordingly.
 *
 * @return the src index after the titlecased sequence, or the start index if no Dutch IJ
 */
int32_t maybeTitleDutchIJ(const uint8_t *src, UChar32 c, int32_t start, int32_t segmentLimit,
                          ByteSink &sink, uint32_t options, icu::Edits *edits, UErrorCode &errorCode) {
    U_ASSERT(start < segmentLimit);

    int32_t index = start;
    bool withAcute = false;

    // If the conditions are met, then the following variables tell us what to output.
    int32_t unchanged1 = 0;  // code units before the j, or the whole sequence (0..3)
    bool doTitleJ = false;  // true if the j needs to be titlecased
    int32_t unchanged2 = 0;  // after the j (0 or 1)

    // next character after the first letter
    UChar32 c2;
    c2 = src[index++];

    // Is the first letter an i/I with accent?
    if (c == u'I') {
        if (c2 == ACUTE_BYTE0 && index < segmentLimit && src[index++] == ACUTE_BYTE1) {
            withAcute = true;
            unchanged1 = 2;  // ACUTE is 2 code units in UTF-8
            if (index == segmentLimit) { return start; }
            c2 = src[index++];
        }
    } else {  // Í
        withAcute = true;
    }

    // Is the next character a j/J?
    if (c2 == u'j') {
        doTitleJ = true;
    } else if (c2 == u'J') {
        ++unchanged1;
    } else {
        return start;
    }

    // A plain i/I must be followed by a plain j/J.
    // An i/I with acute must be followed by a j/J with acute.
    if (withAcute) {
        if ((index + 1) >= segmentLimit || src[index++] != ACUTE_BYTE0 || src[index++] != ACUTE_BYTE1) {
            return start;
        }
        if (doTitleJ) {
            unchanged2 = 2;  // ACUTE is 2 code units in UTF-8
        } else {
            unchanged1 = unchanged1 + 2;    // ACUTE is 2 code units in UTF-8
        }
    }

    // There must not be another combining mark.
    if (index < segmentLimit) {
        int32_t cp;
        int32_t i = index;
        U8_NEXT(src, i, segmentLimit, cp);
        uint32_t typeMask = U_GET_GC_MASK(cp);
        if ((typeMask & U_GC_M_MASK) != 0) {
            return start;
        }
    }

    // Output the rest of the Dutch IJ.
    ByteSinkUtil::appendUnchanged(src + start, unchanged1, sink, options, edits, errorCode);
    start += unchanged1;
    if (doTitleJ) {
        ByteSinkUtil::appendCodePoint(1, u'J', sink, edits);
        ++start;
    }
    ByteSinkUtil::appendUnchanged(src + start, unchanged2, sink, options, edits, errorCode);

    U_ASSERT(start + unchanged2 == index);
    return index;
}

}  // namespace

U_CFUNC void U_CALLCONV
ucasemap_internalUTF8ToTitle(
        int32_t caseLocale, uint32_t options, BreakIterator *iter,
        const uint8_t *src, int32_t srcLength,
        ByteSink &sink, icu::Edits *edits,
        UErrorCode &errorCode) {
    if (!ustrcase_checkTitleAdjustmentOptions(options, errorCode)) {
        return;
    }

    /* set up local variables */
    UCaseContext csc=UCASECONTEXT_INITIALIZER;
    csc.p=(void *)src;
    csc.limit=srcLength;
    int32_t prev=0;
    UBool isFirstIndex=true;

    /* titlecasing loop */
    while(prev<srcLength) {
        /* find next index where to titlecase */
        int32_t index;
        if(isFirstIndex) {
            isFirstIndex=false;
            index=iter->first();
        } else {
            index=iter->next();
        }
        if(index==UBRK_DONE || index>srcLength) {
            index=srcLength;
        }

        /*
         * Segment [prev..index[ into 3 parts:
         * a) skipped characters (copy as-is) [prev..titleStart[
         * b) first letter (titlecase)              [titleStart..titleLimit[
         * c) subsequent characters (lowercase)                 [titleLimit..index[
         */
        if(prev<index) {
            /* find and copy skipped characters [prev..titleStart[ */
            int32_t titleStart=prev;
            int32_t titleLimit=prev;
            UChar32 c;
            U8_NEXT(src, titleLimit, index, c);
            if ((options&U_TITLECASE_NO_BREAK_ADJUSTMENT)==0) {
                // Adjust the titlecasing index to the next cased character,
                // or to the next letter/number/symbol/private use.
                // Stop with titleStart<titleLimit<=index
                // if there is a character to be titlecased,
                // or else stop with titleStart==titleLimit==index.
                UBool toCased = (options&U_TITLECASE_ADJUST_TO_CASED) != 0;
                while (toCased ? UCASE_NONE==ucase_getType(c) : !ustrcase_isLNS(c)) {
                    titleStart=titleLimit;
                    if(titleLimit==index) {
                        break;
                    }
                    U8_NEXT(src, titleLimit, index, c);
                }
                if (prev < titleStart) {
                    if (!ByteSinkUtil::appendUnchanged(src+prev, titleStart-prev,
                                                       sink, options, edits, errorCode)) {
                        return;
                    }
                }
            }

            if(titleStart<titleLimit) {
                /* titlecase c which is from [titleStart..titleLimit[ */
                if(c>=0) {
                    csc.cpStart=titleStart;
                    csc.cpLimit=titleLimit;
                    const char16_t *s;
                    c=ucase_toFullTitle(c, utf8_caseContextIterator, &csc, &s, caseLocale);
                    if (!appendResult(titleLimit-titleStart, c, s, sink, options, edits, errorCode)) {
                        return;
                    }
                } else {
                    // Malformed UTF-8.
                    if (!ByteSinkUtil::appendUnchanged(src+titleStart, titleLimit-titleStart,
                                                       sink, options, edits, errorCode)) {
                        return;
                    }
                }

                /* Special case Dutch IJ titlecasing */
                if (titleLimit < index &&
                    caseLocale == UCASE_LOC_DUTCH) {
                    if (c < 0) {
                        c = ~c;
                    }

                    if (c == u'I' || c == u'Í') {
                        titleLimit = maybeTitleDutchIJ(src, c, titleLimit, index, sink, options, edits, errorCode);
                    }
                }

                /* lowercase [titleLimit..index[ */
                if(titleLimit<index) {
                    if((options&U_TITLECASE_NO_LOWERCASE)==0) {
                        /* Normal operation: Lowercase the rest of the word. */
                        toLower(caseLocale, options,
                                src, &csc, titleLimit, index,
                                sink, edits, errorCode);
                        if(U_FAILURE(errorCode)) {
                            return;
                        }
                    } else {
                        /* Optionally just copy the rest of the word unchanged. */
                        if (!ByteSinkUtil::appendUnchanged(src+titleLimit, index-titleLimit,
                                                           sink, options, edits, errorCode)) {
                            return;
                        }
                    }
                }
            }
        }

        prev=index;
    }
}

#endif

U_NAMESPACE_BEGIN
namespace GreekUpper {

UBool isFollowedByCasedLetter(const uint8_t *s, int32_t i, int32_t length) {
    while (i < length) {
        UChar32 c;
        U8_NEXT(s, i, length, c);
        int32_t type = ucase_getTypeOrIgnorable(c);
        if ((type & UCASE_IGNORABLE) != 0) {
            // Case-ignorable, continue with the loop.
        } else if (type != UCASE_NONE) {
            return true;  // Followed by cased letter.
        } else {
            return false;  // Uncased and not case-ignorable.
        }
    }
    return false;  // Not followed by cased letter.
}

// Keep this consistent with the UTF-16 version in ustrcase.cpp and the Java version in CaseMap.java.
void toUpper(uint32_t options,
             const uint8_t *src, int32_t srcLength,
             ByteSink &sink, Edits *edits,
             UErrorCode &errorCode) {
    uint32_t state = 0;
    for (int32_t i = 0; i < srcLength;) {
        int32_t nextIndex = i;
        UChar32 c;
        U8_NEXT(src, nextIndex, srcLength, c);
        uint32_t nextState = 0;
        int32_t type = ucase_getTypeOrIgnorable(c);
        if ((type & UCASE_IGNORABLE) != 0) {
            // c is case-ignorable
            nextState |= (state & AFTER_CASED);
        } else if (type != UCASE_NONE) {
            // c is cased
            nextState |= AFTER_CASED;
        }
        uint32_t data = getLetterData(c);
        if (data > 0) {
            uint32_t upper = data & UPPER_MASK;
            // Add a dialytika to this iota or ypsilon vowel
            // if we removed a tonos from the previous vowel,
            // and that previous vowel did not also have (or gain) a dialytika.
            // Adding one only to the final vowel in a longer sequence
            // (which does not occur in normal writing) would require lookahead.
            // Set the same flag as for preserving an existing dialytika.
            if ((data & HAS_VOWEL) != 0 &&
                (state & (AFTER_VOWEL_WITH_PRECOMPOSED_ACCENT | AFTER_VOWEL_WITH_COMBINING_ACCENT)) !=
                    0 &&
                (upper == 0x399 || upper == 0x3A5)) {
                data |= (state & AFTER_VOWEL_WITH_PRECOMPOSED_ACCENT) != 0 ? HAS_DIALYTIKA
                                                                           : HAS_COMBINING_DIALYTIKA;
            }
            int32_t numYpogegrammeni = 0;  // Map each one to a trailing, spacing, capital iota.
            if ((data & HAS_YPOGEGRAMMENI) != 0) {
                numYpogegrammeni = 1;
            }
            const UBool hasPrecomposedAccent = (data & HAS_ACCENT) != 0;
            // Skip combining diacritics after this Greek letter.
            int32_t nextNextIndex = nextIndex;
            while (nextIndex < srcLength) {
                UChar32 c2;
                U8_NEXT(src, nextNextIndex, srcLength, c2);
                uint32_t diacriticData = getDiacriticData(c2);
                if (diacriticData != 0) {
                    data |= diacriticData;
                    if ((diacriticData & HAS_YPOGEGRAMMENI) != 0) {
                        ++numYpogegrammeni;
                    }
                    nextIndex = nextNextIndex;
                } else {
                    break;  // not a Greek diacritic
                }
            }
            if ((data & HAS_VOWEL_AND_ACCENT_AND_DIALYTIKA) == HAS_VOWEL_AND_ACCENT) {
                nextState |= hasPrecomposedAccent ? AFTER_VOWEL_WITH_PRECOMPOSED_ACCENT
                                                  : AFTER_VOWEL_WITH_COMBINING_ACCENT;
            }
            // Map according to Greek rules.
            UBool addTonos = false;
            if (upper == 0x397 &&
                    (data & HAS_ACCENT) != 0 &&
                    numYpogegrammeni == 0 &&
                    (state & AFTER_CASED) == 0 &&
                    !isFollowedByCasedLetter(src, nextIndex, srcLength)) {
                // Keep disjunctive "or" with (only) a tonos.
                // We use the same "word boundary" conditions as for the Final_Sigma test.
                if (hasPrecomposedAccent) {
                    upper = 0x389;  // Preserve the precomposed form.
                } else {
                    addTonos = true;
                }
            } else if ((data & HAS_DIALYTIKA) != 0) {
                // Preserve a vowel with dialytika in precomposed form if it exists.
                if (upper == 0x399) {
                    upper = 0x3AA;
                    data &= ~HAS_EITHER_DIALYTIKA;
                } else if (upper == 0x3A5) {
                    upper = 0x3AB;
                    data &= ~HAS_EITHER_DIALYTIKA;
                }
            }

            UBool change;
            if (edits == nullptr && (options & U_OMIT_UNCHANGED_TEXT) == 0) {
                change = true;  // common, simple usage
            } else {
                // Find out first whether we are changing the text.
                U_ASSERT(0x370 <= upper && upper <= 0x3ff);  // 2-byte UTF-8, main Greek block
                change = (i + 2) > nextIndex ||
                        src[i] != getTwoByteLead(upper) || src[i + 1] != getTwoByteTrail(upper) ||
                        numYpogegrammeni > 0;
                int32_t i2 = i + 2;
                if ((data & HAS_EITHER_DIALYTIKA) != 0) {
                    change |= (i2 + 2) > nextIndex ||
                            src[i2] != static_cast<uint8_t>(u8"\u0308"[0]) ||
                            src[i2 + 1] != static_cast<uint8_t>(u8"\u0308"[1]);
                    i2 += 2;
                }
                if (addTonos) {
                    change |= (i2 + 2) > nextIndex ||
                            src[i2] != static_cast<uint8_t>(u8"\u0301"[0]) ||
                            src[i2 + 1] != static_cast<uint8_t>(u8"\u0301"[1]);
                    i2 += 2;
                }
                int32_t oldLength = nextIndex - i;
                int32_t newLength = (i2 - i) + numYpogegrammeni * 2;  // 2 bytes per U+0399
                change |= oldLength != newLength;
                if (change) {
                    if (edits != nullptr) {
                        edits->addReplace(oldLength, newLength);
                    }
                } else {
                    if (edits != nullptr) {
                        edits->addUnchanged(oldLength);
                    }
                    // Write unchanged text?
                    change = (options & U_OMIT_UNCHANGED_TEXT) == 0;
                }
            }

            if (change) {
                ByteSinkUtil::appendTwoBytes(upper, sink);
                if ((data & HAS_EITHER_DIALYTIKA) != 0) {
                    sink.AppendU8(u8"\u0308", 2);  // restore or add a dialytika
                }
                if (addTonos) {
                    sink.AppendU8(u8"\u0301", 2);
                }
                while (numYpogegrammeni > 0) {
                    sink.AppendU8(u8"\u0399", 2);
                    --numYpogegrammeni;
                }
            }
        } else if(c>=0) {
            const char16_t *s;
            c=ucase_toFullUpper(c, nullptr, nullptr, &s, UCASE_LOC_GREEK);
            if (!appendResult(nextIndex - i, c, s, sink, options, edits, errorCode)) {
                return;
            }
        } else {
            // Malformed UTF-8.
            if (!ByteSinkUtil::appendUnchanged(src+i, nextIndex-i,
                                               sink, options, edits, errorCode)) {
                return;
            }
        }
        i = nextIndex;
        state = nextState;
    }
}

}  // namespace GreekUpper
U_NAMESPACE_END

static void U_CALLCONV
ucasemap_internalUTF8ToLower(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITERATOR_UNUSED
                             const uint8_t *src, int32_t srcLength,
                             icu::ByteSink &sink, icu::Edits *edits,
                             UErrorCode &errorCode) {
    UCaseContext csc=UCASECONTEXT_INITIALIZER;
    csc.p=(void *)src;
    csc.limit=srcLength;
    toLower(
        caseLocale, options,
        src, &csc, 0, srcLength,
        sink, edits, errorCode);
}

static void U_CALLCONV
ucasemap_internalUTF8ToUpper(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITERATOR_UNUSED
                             const uint8_t *src, int32_t srcLength,
                             icu::ByteSink &sink, icu::Edits *edits,
                             UErrorCode &errorCode) {
    if (caseLocale == UCASE_LOC_GREEK) {
        GreekUpper::toUpper(options, src, srcLength, sink, edits, errorCode);
    } else {
        UCaseContext csc=UCASECONTEXT_INITIALIZER;
        csc.p=(void *)src;
        csc.limit=srcLength;
        toUpper(
            caseLocale, options,
            src, &csc, srcLength,
            sink, edits, errorCode);
    }
}

static void U_CALLCONV
ucasemap_internalUTF8Fold(int32_t /* caseLocale */, uint32_t options, UCASEMAP_BREAK_ITERATOR_UNUSED
                          const uint8_t *src, int32_t srcLength,
                          icu::ByteSink &sink, icu::Edits *edits,
                          UErrorCode &errorCode) {
    toLower(
        -1, options,
        src, nullptr, 0, srcLength,
        sink, edits, errorCode);
}

void
ucasemap_mapUTF8(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITERATOR_PARAM
                 const char *src, int32_t srcLength,
                 UTF8CaseMapper *stringCaseMapper,
                 icu::ByteSink &sink, icu::Edits *edits,
                 UErrorCode &errorCode) {
    /* check argument values */
    if (U_FAILURE(errorCode)) {
        return;
    }
    if ((src == nullptr && srcLength != 0) || srcLength < -1) {
        errorCode = U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }

    // Get the string length.
    if (srcLength == -1) {
        srcLength = static_cast<int32_t>(uprv_strlen(src));
    }

    if (edits != nullptr && (options & U_EDITS_NO_RESET) == 0) {
        edits->reset();
    }
    stringCaseMapper(caseLocale, options, UCASEMAP_BREAK_ITERATOR
                     reinterpret_cast<const uint8_t*>(src), srcLength, sink, edits, errorCode);
    sink.Flush();
    if (U_SUCCESS(errorCode)) {
        if (edits != nullptr) {
            edits->copyErrorTo(errorCode);
        }
    }
}

int32_t
ucasemap_mapUTF8(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITERATOR_PARAM
                 char *dest, int32_t destCapacity,
                 const char *src, int32_t srcLength,
                 UTF8CaseMapper *stringCaseMapper,
                 icu::Edits *edits,
                 UErrorCode &errorCode) {
    /* check argument values */
    if(U_FAILURE(errorCode)) {
        return 0;
    }
    if( destCapacity<0 ||
        (dest==nullptr && destCapacity>0) ||
        (src==nullptr && srcLength!=0) || srcLength<-1
    ) {
        errorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }

    /* get the string length */
    if(srcLength==-1) {
        srcLength = static_cast<int32_t>(uprv_strlen(src));
    }

    /* check for overlapping source and destination */
    if( dest!=nullptr &&
        ((src>=dest && src<(dest+destCapacity)) ||
         (dest>=src && dest<(src+srcLength)))
    ) {
        errorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }

    if (edits != nullptr && (options & U_EDITS_NO_RESET) == 0) {
        edits->reset();
    }
    int32_t reslen = ByteSinkUtil::viaByteSinkToTerminatedChars(
        dest, destCapacity,
        [&](ByteSink& sink, UErrorCode& status) {
            stringCaseMapper(caseLocale, options, UCASEMAP_BREAK_ITERATOR
                             reinterpret_cast<const uint8_t*>(src), srcLength, sink, edits, status);
        },
        errorCode);
    if (U_SUCCESS(errorCode) && edits != nullptr) {
        edits->copyErrorTo(errorCode);
    }
    return reslen;
}

/* public API functions */

U_CAPI int32_t U_EXPORT2
ucasemap_utf8ToLower(const UCaseMap *csm,
                     char *dest, int32_t destCapacity,
                     const char *src, int32_t srcLength,
                     UErrorCode *pErrorCode) {
    return ucasemap_mapUTF8(
        csm->caseLocale, csm->options, UCASEMAP_BREAK_ITERATOR_NULL
        dest, destCapacity,
        src, srcLength,
        ucasemap_internalUTF8ToLower, nullptr, *pErrorCode);
}

U_CAPI int32_t U_EXPORT2
ucasemap_utf8ToUpper(const UCaseMap *csm,
                     char *dest, int32_t destCapacity,
                     const char *src, int32_t srcLength,
                     UErrorCode *pErrorCode) {
    return ucasemap_mapUTF8(
        csm->caseLocale, csm->options, UCASEMAP_BREAK_ITERATOR_NULL
        dest, destCapacity,
        src, srcLength,
        ucasemap_internalUTF8ToUpper, nullptr, *pErrorCode);
}

U_CAPI int32_t U_EXPORT2
ucasemap_utf8FoldCase(const UCaseMap *csm,
                      char *dest, int32_t destCapacity,
                      const char *src, int32_t srcLength,
                      UErrorCode *pErrorCode) {
    return ucasemap_mapUTF8(
        UCASE_LOC_ROOT, csm->options, UCASEMAP_BREAK_ITERATOR_NULL
        dest, destCapacity,
        src, srcLength,
        ucasemap_internalUTF8Fold, nullptr, *pErrorCode);
}

U_NAMESPACE_BEGIN

void CaseMap::utf8ToLower(
        const char *locale, uint32_t options,
        StringPiece src, ByteSink &sink, Edits *edits,
        UErrorCode &errorCode) {
    ucasemap_mapUTF8(
        ustrcase_getCaseLocale(locale), options, UCASEMAP_BREAK_ITERATOR_NULL
        src.data(), src.length(),
        ucasemap_internalUTF8ToLower, sink, edits, errorCode);
}

void CaseMap::utf8ToUpper(
        const char *locale, uint32_t options,
        StringPiece src, ByteSink &sink, Edits *edits,
        UErrorCode &errorCode) {
    ucasemap_mapUTF8(
        ustrcase_getCaseLocale(locale), options, UCASEMAP_BREAK_ITERATOR_NULL
        src.data(), src.length(),
        ucasemap_internalUTF8ToUpper, sink, edits, errorCode);
}

void CaseMap::utf8Fold(
        uint32_t options,
        StringPiece src, ByteSink &sink, Edits *edits,
        UErrorCode &errorCode) {
    ucasemap_mapUTF8(
        UCASE_LOC_ROOT, options, UCASEMAP_BREAK_ITERATOR_NULL
        src.data(), src.length(),
        ucasemap_internalUTF8Fold, sink, edits, errorCode);
}

int32_t CaseMap::utf8ToLower(
        const char *locale, uint32_t options,
        const char *src, int32_t srcLength,
        char *dest, int32_t destCapacity, Edits *edits,
        UErrorCode &errorCode) {
    return ucasemap_mapUTF8(
        ustrcase_getCaseLocale(locale), options, UCASEMAP_BREAK_ITERATOR_NULL
        dest, destCapacity,
        src, srcLength,
        ucasemap_internalUTF8ToLower, edits, errorCode);
}

int32_t CaseMap::utf8ToUpper(
        const char *locale, uint32_t options,
        const char *src, int32_t srcLength,
        char *dest, int32_t destCapacity, Edits *edits,
        UErrorCode &errorCode) {
    return ucasemap_mapUTF8(
        ustrcase_getCaseLocale(locale), options, UCASEMAP_BREAK_ITERATOR_NULL
        dest, destCapacity,
        src, srcLength,
        ucasemap_internalUTF8ToUpper, edits, errorCode);
}

int32_t CaseMap::utf8Fold(
        uint32_t options,
        const char *src, int32_t srcLength,
        char *dest, int32_t destCapacity, Edits *edits,
        UErrorCode &errorCode) {
    return ucasemap_mapUTF8(
        UCASE_LOC_ROOT, options, UCASEMAP_BREAK_ITERATOR_NULL
        dest, destCapacity,
        src, srcLength,
        ucasemap_internalUTF8Fold, edits, errorCode);
}

U_NAMESPACE_END
                                                                                                             node-23.7.0/deps/icu-small/source/common/ucasemap_imp.h                                             0000664 0000000 0000000 00000023337 14746647661 0023012 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2017 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html

// ucasemap_imp.h
// created: 2017feb08 Markus W. Scherer

#ifndef __UCASEMAP_IMP_H__
#define __UCASEMAP_IMP_H__

#include "unicode/utypes.h"
#include "unicode/ucasemap.h"
#include "unicode/uchar.h"
#include "ucase.h"

/**
 * Bit mask for the titlecasing iterator options bit field.
 * Currently only 3 out of 8 values are used:
 * 0 (words), U_TITLECASE_WHOLE_STRING, U_TITLECASE_SENTENCES.
 * See stringoptions.h.
 * @internal
 */
#define U_TITLECASE_ITERATOR_MASK 0xe0

/**
 * Bit mask for the titlecasing index adjustment options bit set.
 * Currently two bits are defined:
 * U_TITLECASE_NO_BREAK_ADJUSTMENT, U_TITLECASE_ADJUST_TO_CASED.
 * See stringoptions.h.
 * @internal
 */
#define U_TITLECASE_ADJUSTMENT_MASK 0x600

/**
 * Internal API, used by u_strcasecmp() etc.
 * Compare strings case-insensitively,
 * in code point order or code unit order.
 */
U_CFUNC int32_t
u_strcmpFold(const UChar *s1, int32_t length1,
             const UChar *s2, int32_t length2,
             uint32_t options,
             UErrorCode *pErrorCode);

/**
 * Internal API, used for detecting length of
 * shared prefix case-insensitively.
 * @param s1            input string 1
 * @param length1       length of string 1, or -1 (NULL terminated)
 * @param s2            input string 2
 * @param length2       length of string 2, or -1 (NULL terminated)
 * @param options       compare options
 * @param matchLen1     (output) length of partial prefix match in s1
 * @param matchLen2     (output) length of partial prefix match in s2
 * @param pErrorCode    receives error status
 */
U_CAPI void
u_caseInsensitivePrefixMatch(const UChar *s1, int32_t length1,
                             const UChar *s2, int32_t length2,
                             uint32_t options,
                             int32_t *matchLen1, int32_t *matchLen2,
                             UErrorCode *pErrorCode);

#ifdef __cplusplus

U_NAMESPACE_BEGIN

class BreakIterator;        // unicode/brkiter.h
class ByteSink;
class Locale;               // unicode/locid.h

/** Returns true if the options are valid. Otherwise false, and sets an error. */
inline UBool ustrcase_checkTitleAdjustmentOptions(uint32_t options, UErrorCode &errorCode) {
    if (U_FAILURE(errorCode)) { return false; }
    if ((options & U_TITLECASE_ADJUSTMENT_MASK) == U_TITLECASE_ADJUSTMENT_MASK) {
        // Both options together.
        errorCode = U_ILLEGAL_ARGUMENT_ERROR;
        return false;
    }
    return true;
}

inline UBool ustrcase_isLNS(UChar32 c) {
    // Letter, number, symbol,
    // or a private use code point because those are typically used as letters or numbers.
    // Consider modifier letters only if they are cased.
    const uint32_t LNS = (U_GC_L_MASK|U_GC_N_MASK|U_GC_S_MASK|U_GC_CO_MASK) & ~U_GC_LM_MASK;
    int gc = u_charType(c);
    return (U_MASK(gc) & LNS) != 0 || (gc == U_MODIFIER_LETTER && ucase_getType(c) != UCASE_NONE);
}

#if !UCONFIG_NO_BREAK_ITERATION

/** Returns nullptr if error. Pass in either locale or locID, not both. */
U_CFUNC
BreakIterator *ustrcase_getTitleBreakIterator(
        const Locale *locale, const char *locID, uint32_t options, BreakIterator *iter,
        LocalPointer<BreakIterator> &ownedIter, UErrorCode &errorCode);

#endif

U_NAMESPACE_END

#include "unicode/unistr.h"  // for UStringCaseMapper

/*
 * Internal string casing functions implementing
 * ustring.h/ustrcase.cpp and UnicodeString case mapping functions.
 */

struct UCaseMap : public icu::UMemory {
    /** Implements most of ucasemap_open(). */
    UCaseMap(const char *localeID, uint32_t opts, UErrorCode *pErrorCode);
    ~UCaseMap();

#if !UCONFIG_NO_BREAK_ITERATION
    icu::BreakIterator *iter;  /* We adopt the iterator, so we own it. */
#endif
    char locale[32];
    int32_t caseLocale;
    uint32_t options;
};

#if UCONFIG_NO_BREAK_ITERATION
#   define UCASEMAP_BREAK_ITERATOR_PARAM
#   define UCASEMAP_BREAK_ITERATOR_UNUSED
#   define UCASEMAP_BREAK_ITERATOR
#   define UCASEMAP_BREAK_ITERATOR_NULL
#else
#   define UCASEMAP_BREAK_ITERATOR_PARAM icu::BreakIterator *iter,
#   define UCASEMAP_BREAK_ITERATOR_UNUSED icu::BreakIterator *,
#   define UCASEMAP_BREAK_ITERATOR iter,
#   define UCASEMAP_BREAK_ITERATOR_NULL NULL,
#endif

U_CFUNC int32_t
ustrcase_getCaseLocale(const char *locale);

// TODO: swap src / dest if approved for new public api
/** Implements UStringCaseMapper. */
U_CFUNC int32_t U_CALLCONV
ustrcase_internalToLower(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITERATOR_PARAM
                         char16_t *dest, int32_t destCapacity,
                         const char16_t *src, int32_t srcLength,
                         icu::Edits *edits,
                         UErrorCode &errorCode);

/** Implements UStringCaseMapper. */
U_CFUNC int32_t U_CALLCONV
ustrcase_internalToUpper(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITERATOR_PARAM
                         char16_t *dest, int32_t destCapacity,
                         const char16_t *src, int32_t srcLength,
                         icu::Edits *edits,
                         UErrorCode &errorCode);

#if !UCONFIG_NO_BREAK_ITERATION

/** Implements UStringCaseMapper. */
U_CFUNC int32_t U_CALLCONV
ustrcase_internalToTitle(int32_t caseLocale, uint32_t options,
                         icu::BreakIterator *iter,
                         char16_t *dest, int32_t destCapacity,
                         const char16_t *src, int32_t srcLength,
                         icu::Edits *edits,
                         UErrorCode &errorCode);

#endif

/** Implements UStringCaseMapper. */
U_CFUNC int32_t U_CALLCONV
ustrcase_internalFold(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITERATOR_PARAM
                      char16_t *dest, int32_t destCapacity,
                      const char16_t *src, int32_t srcLength,
                      icu::Edits *edits,
                      UErrorCode &errorCode);

/**
 * Common string case mapping implementation for ucasemap_toXyz() and UnicodeString::toXyz().
 * Implements argument checking.
 */
U_CFUNC int32_t
ustrcase_map(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITERATOR_PARAM
             char16_t *dest, int32_t destCapacity,
             const char16_t *src, int32_t srcLength,
             UStringCaseMapper *stringCaseMapper,
             icu::Edits *edits,
             UErrorCode &errorCode);

/**
 * Common string case mapping implementation for old-fashioned u_strToXyz() functions
 * that allow the source string to overlap the destination buffer.
 * Implements argument checking and internally works with an intermediate buffer if necessary.
 */
U_CFUNC int32_t
ustrcase_mapWithOverlap(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITERATOR_PARAM
                        char16_t *dest, int32_t destCapacity,
                        const char16_t *src, int32_t srcLength,
                        UStringCaseMapper *stringCaseMapper,
                        UErrorCode &errorCode);

/**
 * UTF-8 string case mapping function type, used by ucasemap_mapUTF8().
 * UTF-8 version of UStringCaseMapper.
 * All error checking must be done.
 * The UCaseMap must be fully initialized, with locale and/or iter set as needed.
 */
typedef void U_CALLCONV
UTF8CaseMapper(int32_t caseLocale, uint32_t options,
#if !UCONFIG_NO_BREAK_ITERATION
               icu::BreakIterator *iter,
#endif
               const uint8_t *src, int32_t srcLength,
               icu::ByteSink &sink, icu::Edits *edits,
               UErrorCode &errorCode);

#if !UCONFIG_NO_BREAK_ITERATION

/** Implements UTF8CaseMapper. */
U_CFUNC void U_CALLCONV
ucasemap_internalUTF8ToTitle(int32_t caseLocale, uint32_t options,
        icu::BreakIterator *iter,
        const uint8_t *src, int32_t srcLength,
        icu::ByteSink &sink, icu::Edits *edits,
        UErrorCode &errorCode);

#endif

void
ucasemap_mapUTF8(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITERATOR_PARAM
                 const char *src, int32_t srcLength,
                 UTF8CaseMapper *stringCaseMapper,
                 icu::ByteSink &sink, icu::Edits *edits,
                 UErrorCode &errorCode);

/**
 * Implements argument checking and buffer handling
 * for UTF-8 string case mapping as a common function.
 */
int32_t
ucasemap_mapUTF8(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_ITERATOR_PARAM
                 char *dest, int32_t destCapacity,
                 const char *src, int32_t srcLength,
                 UTF8CaseMapper *stringCaseMapper,
                 icu::Edits *edits,
                 UErrorCode &errorCode);

U_NAMESPACE_BEGIN
namespace GreekUpper {

// Data bits.
static const uint32_t UPPER_MASK = 0x3ff;
static const uint32_t HAS_VOWEL = 0x1000;
static const uint32_t HAS_YPOGEGRAMMENI = 0x2000;
static const uint32_t HAS_ACCENT = 0x4000;
static const uint32_t HAS_DIALYTIKA = 0x8000;
// Further bits during data building and processing, not stored in the data map.
static const uint32_t HAS_COMBINING_DIALYTIKA = 0x10000;
static const uint32_t HAS_OTHER_GREEK_DIACRITIC = 0x20000;

static const uint32_t HAS_VOWEL_AND_ACCENT = HAS_VOWEL | HAS_ACCENT;
static const uint32_t HAS_VOWEL_AND_ACCENT_AND_DIALYTIKA =
        HAS_VOWEL_AND_ACCENT | HAS_DIALYTIKA;
static const uint32_t HAS_EITHER_DIALYTIKA = HAS_DIALYTIKA | HAS_COMBINING_DIALYTIKA;

// State bits.
static const uint32_t AFTER_CASED = 1;
static const uint32_t AFTER_VOWEL_WITH_COMBINING_ACCENT = 2;
static const uint32_t AFTER_VOWEL_WITH_PRECOMPOSED_ACCENT = 4;

uint32_t getLetterData(UChar32 c);

/**
 * Returns a non-zero value for each of the Greek combining diacritics
 * listed in The Unicode Standard, version 8, chapter 7.2 Greek,
 * plus some perispomeni look-alikes.
 */
uint32_t getDiacriticData(UChar32 c);

}  // namespace GreekUpper
U_NAMESPACE_END

#endif  // __cplusplus

#endif  // __UCASEMAP_IMP_H__
                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/icu-small/source/common/ucasemap_titlecase_brkiter.cpp                             0000664 0000000 0000000 00000010201 14746647661 0026241 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
*******************************************************************************
*   Copyright (C) 2011, International Business Machines
*   Corporation and others.  All Rights Reserved.
*******************************************************************************
*   file name:  ucasemap_titlecase_brkiter.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2011jun02
*   created by: Markus W. Scherer
*
*   Titlecasing functions that are based on BreakIterator
*   were moved here to break dependency cycles among parts of the common library.
*/

#include "unicode/utypes.h"

#if !UCONFIG_NO_BREAK_ITERATION

#include "unicode/brkiter.h"
#include "unicode/ubrk.h"
#include "unicode/casemap.h"
#include "unicode/ucasemap.h"
#include "cmemory.h"
#include "ucase.h"
#include "ucasemap_imp.h"

U_NAMESPACE_BEGIN

void CaseMap::utf8ToTitle(
        const char *locale, uint32_t options, BreakIterator *iter,
        StringPiece src, ByteSink &sink, Edits *edits,
        UErrorCode &errorCode) {
    if (U_FAILURE(errorCode)) {
        return;
    }
    UText utext = UTEXT_INITIALIZER;
    utext_openUTF8(&utext, src.data(), src.length(), &errorCode);
    LocalPointer<BreakIterator> ownedIter;
    iter = ustrcase_getTitleBreakIterator(nullptr, locale, options, iter, ownedIter, errorCode);
    if (iter == nullptr) {
        utext_close(&utext);
        return;
    }
    iter->setText(&utext, errorCode);
    ucasemap_mapUTF8(
        ustrcase_getCaseLocale(locale), options, iter,
        src.data(), src.length(),
        ucasemap_internalUTF8ToTitle, sink, edits, errorCode);
    utext_close(&utext);
}

int32_t CaseMap::utf8ToTitle(
        const char *locale, uint32_t options, BreakIterator *iter,
        const char *src, int32_t srcLength,
        char *dest, int32_t destCapacity, Edits *edits,
        UErrorCode &errorCode) {
    if (U_FAILURE(errorCode)) {
        return 0;
    }
    UText utext=UTEXT_INITIALIZER;
    utext_openUTF8(&utext, src, srcLength, &errorCode);
    LocalPointer<BreakIterator> ownedIter;
    iter = ustrcase_getTitleBreakIterator(nullptr, locale, options, iter, ownedIter, errorCode);
    if(iter==nullptr) {
        utext_close(&utext);
        return 0;
    }
    iter->setText(&utext, errorCode);
    int32_t length=ucasemap_mapUTF8(
        ustrcase_getCaseLocale(locale), options, iter,
        dest, destCapacity,
        src, srcLength,
        ucasemap_internalUTF8ToTitle, edits, errorCode);
    utext_close(&utext);
    return length;
}

U_NAMESPACE_END

U_NAMESPACE_USE

U_CAPI const UBreakIterator * U_EXPORT2
ucasemap_getBreakIterator(const UCaseMap *csm) {
    return reinterpret_cast<UBreakIterator *>(csm->iter);
}

U_CAPI void U_EXPORT2
ucasemap_setBreakIterator(UCaseMap *csm, UBreakIterator *iterToAdopt, UErrorCode *pErrorCode) {
    if(U_FAILURE(*pErrorCode)) {
        return;
    }
    delete csm->iter;
    csm->iter=reinterpret_cast<BreakIterator *>(iterToAdopt);
}

U_CAPI int32_t U_EXPORT2
ucasemap_utf8ToTitle(UCaseMap *csm,
                     char *dest, int32_t destCapacity,
                     const char *src, int32_t srcLength,
                     UErrorCode *pErrorCode) {
    if (U_FAILURE(*pErrorCode)) {
        return 0;
    }
    UText utext=UTEXT_INITIALIZER;
    utext_openUTF8(&utext, src, srcLength, pErrorCode);
    if (U_FAILURE(*pErrorCode)) {
        return 0;
    }
    if(csm->iter==nullptr) {
        LocalPointer<BreakIterator> ownedIter;
        BreakIterator *iter = ustrcase_getTitleBreakIterator(
            nullptr, csm->locale, csm->options, nullptr, ownedIter, *pErrorCode);
        if (iter == nullptr) {
            utext_close(&utext);
            return 0;
        }
        csm->iter = ownedIter.orphan();
    }
    csm->iter->setText(&utext, *pErrorCode);
    int32_t length=ucasemap_mapUTF8(
            csm->caseLocale, csm->options, csm->iter,
            dest, destCapacity,
            src, srcLength,
            ucasemap_internalUTF8ToTitle, nullptr, *pErrorCode);
    utext_close(&utext);
    return length;
}

#endif  // !UCONFIG_NO_BREAK_ITERATION
                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/icu-small/source/common/ucat.cpp                                                   0000664 0000000 0000000 00000004202 14746647661 0021624 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
**********************************************************************
* Copyright (c) 2003, International Business Machines
* Corporation and others.  All Rights Reserved.
**********************************************************************
* Author: Alan Liu
* Created: March 19 2003
* Since: ICU 2.6
**********************************************************************
*/
#include "unicode/ucat.h"
#include "unicode/ustring.h"
#include "cstring.h"
#include "uassert.h"

/* Separator between set_num and msg_num */
static const char SEPARATOR = '%';

/* Maximum length of a set_num/msg_num key, incl. terminating zero.
 * Longest possible key is "-2147483648%-2147483648" */
#define MAX_KEY_LEN (24)

/**
 * Fill in buffer with a set_num/msg_num key string, given the numeric
 * values. Numeric values must be >= 0. Buffer must be of length
 * MAX_KEY_LEN or more.
 */
static char*
_catkey(char* buffer, int32_t set_num, int32_t msg_num) {
    int32_t i = 0;
    i = T_CString_integerToString(buffer, set_num, 10);
    buffer[i++] = SEPARATOR;
    T_CString_integerToString(buffer+i, msg_num, 10);
    return buffer;
}

U_CAPI u_nl_catd U_EXPORT2
u_catopen(const char* name, const char* locale, UErrorCode* ec) {
    return (u_nl_catd) ures_open(name, locale, ec);
}

U_CAPI void U_EXPORT2
u_catclose(u_nl_catd catd) {
    ures_close((UResourceBundle*) catd); /* may be nullptr */
}

U_CAPI const char16_t* U_EXPORT2
u_catgets(u_nl_catd catd, int32_t set_num, int32_t msg_num,
          const char16_t* s,
          int32_t* len, UErrorCode* ec) {

    char key[MAX_KEY_LEN];
    const char16_t* result;

    if (ec == nullptr || U_FAILURE(*ec)) {
        goto ERROR;
    }

    result = ures_getStringByKey((const UResourceBundle*) catd,
                                 _catkey(key, set_num, msg_num),
                                 len, ec);
    if (U_FAILURE(*ec)) {
        goto ERROR;
    }

    return result;

 ERROR:
    /* In case of any failure, return s */
    if (len != nullptr) {
        *len = u_strlen(s);
    }
    return s;
}

/*eof*/
                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/icu-small/source/common/uchar.cpp                                                  0000664 0000000 0000000 00000051772 14746647661 0022010 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
********************************************************************************
*   Copyright (C) 1996-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
********************************************************************************
*
* File UCHAR.C
*
* Modification History:
*
*   Date        Name        Description
*   04/02/97    aliu        Creation.
*   4/15/99     Madhu       Updated all the function definitions for C Implementation
*   5/20/99     Madhu       Added the function u_getVersion()
*   8/19/1999   srl         Upgraded scripts to Unicode3.0 
*   11/11/1999  weiv        added u_isalnum(), cleaned comments
*   01/11/2000  helena      Renamed u_getVersion to u_getUnicodeVersion.
*   06/20/2000  helena      OS/400 port changes; mostly typecast.
******************************************************************************
*/

#include "unicode/utypes.h"
#include "unicode/uchar.h"
#include "unicode/ucptrie.h"
#include "unicode/uscript.h"
#include "unicode/udata.h"
#include "uassert.h"
#include "cmemory.h"
#include "ucln_cmn.h"
#include "utrie2.h"
#include "udataswp.h"
#include "uprops.h"
#include "ustr_imp.h"

/* uchar_props_data.h is machine-generated by genprops --csource */
#define INCLUDED_FROM_UCHAR_C
#include "uchar_props_data.h"

/* constants and macros for access to the data ------------------------------ */

/* getting a uint32_t properties word from the data */
#define GET_PROPS(c, result) ((result)=UTRIE2_GET16(&propsTrie, c))

/* API functions ------------------------------------------------------------ */

/* Gets the Unicode character's general category.*/
U_CAPI int8_t U_EXPORT2
u_charType(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return (int8_t)GET_CATEGORY(props);
}

/* Enumerate all code points with their general categories. */
struct _EnumTypeCallback {
    UCharEnumTypeRange *enumRange;
    const void *context;
};

static uint32_t U_CALLCONV
_enumTypeValue(const void *context, uint32_t value) {
    (void)context;
    return GET_CATEGORY(value);
}

static UBool U_CALLCONV
_enumTypeRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {
    /* just cast the value to UCharCategory */
    return static_cast<const _EnumTypeCallback*>(context)->
        enumRange(static_cast<const _EnumTypeCallback*>(context)->context,
                  start, end + 1, static_cast<UCharCategory>(value));
}

U_CAPI void U_EXPORT2
u_enumCharTypes(UCharEnumTypeRange *enumRange, const void *context) {
    struct _EnumTypeCallback callback;

    if(enumRange==nullptr) {
        return;
    }

    callback.enumRange=enumRange;
    callback.context=context;
    utrie2_enum(&propsTrie, _enumTypeValue, _enumTypeRange, &callback);
}

/* Checks if ch is a lower case letter.*/
U_CAPI UBool U_EXPORT2
u_islower(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return GET_CATEGORY(props)==U_LOWERCASE_LETTER;
}

/* Checks if ch is an upper case letter.*/
U_CAPI UBool U_EXPORT2
u_isupper(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return GET_CATEGORY(props)==U_UPPERCASE_LETTER;
}

/* Checks if ch is a title case letter; usually upper case letters.*/
U_CAPI UBool U_EXPORT2
u_istitle(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return GET_CATEGORY(props)==U_TITLECASE_LETTER;
}

/* Checks if ch is a decimal digit. */
U_CAPI UBool U_EXPORT2
u_isdigit(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return GET_CATEGORY(props)==U_DECIMAL_DIGIT_NUMBER;
}

U_CAPI UBool U_EXPORT2
u_isxdigit(UChar32 c) {
    uint32_t props;

    /* check ASCII and Fullwidth ASCII a-fA-F */
    if(
        (c<=0x66 && c>=0x41 && (c<=0x46 || c>=0x61)) ||
        (c>=0xff21 && c<=0xff46 && (c<=0xff26 || c>=0xff41))
    ) {
        return true;
    }

    GET_PROPS(c, props);
    return GET_CATEGORY(props)==U_DECIMAL_DIGIT_NUMBER;
}

/* Checks if the Unicode character is a letter.*/
U_CAPI UBool U_EXPORT2
u_isalpha(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return (CAT_MASK(props)&U_GC_L_MASK)!=0;
}

U_CAPI UBool U_EXPORT2
u_isUAlphabetic(UChar32 c) {
    return (u_getUnicodeProperties(c, 1)&U_MASK(UPROPS_ALPHABETIC))!=0;
}

/* Checks if c is a letter or a decimal digit */
U_CAPI UBool U_EXPORT2
u_isalnum(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return (CAT_MASK(props)&(U_GC_L_MASK|U_GC_ND_MASK))!=0;
}

/**
 * Checks if c is alphabetic, or a decimal digit; implements UCHAR_POSIX_ALNUM.
 * @internal
 */
U_CFUNC UBool
u_isalnumPOSIX(UChar32 c) {
    return u_isUAlphabetic(c) || u_isdigit(c);
}

/* Checks if ch is a unicode character with assigned character type.*/
U_CAPI UBool U_EXPORT2
u_isdefined(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return GET_CATEGORY(props)!=0;
}

/* Checks if the Unicode character is a base form character that can take a diacritic.*/
U_CAPI UBool U_EXPORT2
u_isbase(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return (CAT_MASK(props)&(U_GC_L_MASK|U_GC_N_MASK|U_GC_MC_MASK|U_GC_ME_MASK))!=0;
}

/* Checks if the Unicode character is a control character.*/
U_CAPI UBool U_EXPORT2
u_iscntrl(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return (CAT_MASK(props)&(U_GC_CC_MASK|U_GC_CF_MASK|U_GC_ZL_MASK|U_GC_ZP_MASK))!=0;
}

U_CAPI UBool U_EXPORT2
u_isISOControl(UChar32 c) {
    return (uint32_t)c<=0x9f && (c<=0x1f || c>=0x7f);
}

/* Some control characters that are used as space. */
#define IS_THAT_CONTROL_SPACE(c) \
    (c<=0x9f && ((c>=TAB && c<=CR) || (c>=0x1c && c <=0x1f) || c==0x85))

/* Java has decided that U+0085 New Line is not whitespace any more. */
#define IS_THAT_ASCII_CONTROL_SPACE(c) \
    (c<=0x1f && c>=TAB && (c<=CR || c>=0x1c))

/* Checks if the Unicode character is a space character.*/
U_CAPI UBool U_EXPORT2
u_isspace(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return (CAT_MASK(props)&U_GC_Z_MASK)!=0 || IS_THAT_CONTROL_SPACE(c);
}

U_CAPI UBool U_EXPORT2
u_isJavaSpaceChar(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return (CAT_MASK(props)&U_GC_Z_MASK)!=0;
}

/* Checks if the Unicode character is a whitespace character.*/
U_CAPI UBool U_EXPORT2
u_isWhitespace(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return ((CAT_MASK(props)&U_GC_Z_MASK)!=0 &&
               c!=NBSP && c!=FIGURESP && c!=NNBSP) || /* exclude no-break spaces */
           IS_THAT_ASCII_CONTROL_SPACE(c);
}

U_CAPI UBool U_EXPORT2
u_isblank(UChar32 c) {
    if((uint32_t)c<=0x9f) {
        return c==9 || c==0x20; /* TAB or SPACE */
    } else {
        /* Zs */
        uint32_t props;
        GET_PROPS(c, props);
        return GET_CATEGORY(props)==U_SPACE_SEPARATOR;
    }
}

U_CAPI UBool U_EXPORT2
u_isUWhiteSpace(UChar32 c) {
    return (u_getUnicodeProperties(c, 1)&U_MASK(UPROPS_WHITE_SPACE))!=0;
}

/* Checks if the Unicode character is printable.*/
U_CAPI UBool U_EXPORT2
u_isprint(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    /* comparing ==0 returns false for the categories mentioned */
    return (CAT_MASK(props)&U_GC_C_MASK)==0;
}

/**
 * Checks if c is in \p{graph}\p{blank} - \p{cntrl}.
 * Implements UCHAR_POSIX_PRINT.
 * @internal
 */
U_CFUNC UBool
u_isprintPOSIX(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    /*
     * The only cntrl character in graph+blank is TAB (in blank).
     * Here we implement (blank-TAB)=Zs instead of calling u_isblank().
     */
    return (GET_CATEGORY(props)==U_SPACE_SEPARATOR) || u_isgraphPOSIX(c);
}

U_CAPI UBool U_EXPORT2
u_isgraph(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    /* comparing ==0 returns false for the categories mentioned */
    return (CAT_MASK(props)&
            (U_GC_CC_MASK|U_GC_CF_MASK|U_GC_CS_MASK|U_GC_CN_MASK|U_GC_Z_MASK))
           ==0;
}

/**
 * Checks if c is in
 * [^\p{space}\p{gc=Control}\p{gc=Surrogate}\p{gc=Unassigned}]
 * with space=\p{Whitespace} and Control=Cc.
 * Implements UCHAR_POSIX_GRAPH.
 * @internal
 */
U_CFUNC UBool
u_isgraphPOSIX(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    /* \p{space}\p{gc=Control} == \p{gc=Z}\p{Control} */
    /* comparing ==0 returns false for the categories mentioned */
    return (CAT_MASK(props)&
            (U_GC_CC_MASK|U_GC_CS_MASK|U_GC_CN_MASK|U_GC_Z_MASK))
           ==0;
}

U_CAPI UBool U_EXPORT2
u_ispunct(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return (CAT_MASK(props)&U_GC_P_MASK)!=0;
}

/*Checks if the Unicode character can be ignorable in a Java or Unicode identifier.*/
U_CAPI UBool U_EXPORT2
u_isIDIgnorable(UChar32 c) {
    if(c<=0x9f) {
        return u_isISOControl(c) && !IS_THAT_ASCII_CONTROL_SPACE(c);
    } else {
        uint32_t props;
        GET_PROPS(c, props);
        return GET_CATEGORY(props)==U_FORMAT_CHAR;
    }
}

/*Checks if the Unicode character can start a Java identifier.*/
U_CAPI UBool U_EXPORT2
u_isJavaIDStart(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return (CAT_MASK(props)&(U_GC_L_MASK|U_GC_SC_MASK|U_GC_PC_MASK))!=0;
}

/*Checks if the Unicode character can be a Java identifier part other than starting the
 * identifier.
 */
U_CAPI UBool U_EXPORT2
u_isJavaIDPart(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return (CAT_MASK(props)&
            (U_GC_ND_MASK|U_GC_NL_MASK|
             U_GC_L_MASK|
             U_GC_SC_MASK|U_GC_PC_MASK|
             U_GC_MC_MASK|U_GC_MN_MASK)
           )!=0 ||
           u_isIDIgnorable(c);
}

U_CAPI int32_t U_EXPORT2
u_charDigitValue(UChar32 c) {
    uint32_t props;
    int32_t value;
    GET_PROPS(c, props);
    value=(int32_t)GET_NUMERIC_TYPE_VALUE(props)-UPROPS_NTV_DECIMAL_START;
    if(value<=9) {
        return value;
    } else {
        return -1;
    }
}

U_CAPI double U_EXPORT2
u_getNumericValue(UChar32 c) {
    uint32_t props;
    int32_t ntv;
    GET_PROPS(c, props);
    ntv=(int32_t)GET_NUMERIC_TYPE_VALUE(props);

    if(ntv==UPROPS_NTV_NONE) {
        return U_NO_NUMERIC_VALUE;
    } else if(ntv<UPROPS_NTV_DIGIT_START) {
        /* decimal digit */
        return ntv-UPROPS_NTV_DECIMAL_START;
    } else if(ntv<UPROPS_NTV_NUMERIC_START) {
        /* other digit */
        return ntv-UPROPS_NTV_DIGIT_START;
    } else if(ntv<UPROPS_NTV_FRACTION_START) {
        /* small integer */
        return ntv-UPROPS_NTV_NUMERIC_START;
    } else if(ntv<UPROPS_NTV_LARGE_START) {
        /* fraction */
        int32_t numerator=(ntv>>4)-12;
        int32_t denominator=(ntv&0xf)+1;
        return (double)numerator/denominator;
    } else if(ntv<UPROPS_NTV_BASE60_START) {
        /* large, single-significant-digit integer */
        double numValue;
        int32_t mant=(ntv>>5)-14;
        int32_t exp=(ntv&0x1f)+2;
        numValue=mant;

        /* multiply by 10^exp without math.h */
        while(exp>=4) {
            numValue*=10000.;
            exp-=4;
        }
        switch(exp) {
        case 3:
            numValue*=1000.;
            break;
        case 2:
            numValue*=100.;
            break;
        case 1:
            numValue*=10.;
            break;
        case 0:
        default:
            break;
        }

        return numValue;
    } else if(ntv<UPROPS_NTV_FRACTION20_START) {
        /* sexagesimal (base 60) integer */
        int32_t numValue=(ntv>>2)-0xbf;
        int32_t exp=(ntv&3)+1;

        switch(exp) {
        case 4:
            numValue*=60*60*60*60;
            break;
        case 3:
            numValue*=60*60*60;
            break;
        case 2:
            numValue*=60*60;
            break;
        case 1:
            numValue*=60;
            break;
        case 0:
        default:
            break;
        }

        return numValue;
    } else if(ntv<UPROPS_NTV_FRACTION32_START) {
        // fraction-20 e.g. 3/80
        int32_t frac20=ntv-UPROPS_NTV_FRACTION20_START;  // 0..0x17
        int32_t numerator=2*(frac20&3)+1;
        int32_t denominator=20<<(frac20>>2);
        return (double)numerator/denominator;
    } else if(ntv<UPROPS_NTV_RESERVED_START) {
        // fraction-32 e.g. 3/64
        int32_t frac32=ntv-UPROPS_NTV_FRACTION32_START;  // 0..15
        int32_t numerator=2*(frac32&3)+1;
        int32_t denominator=32<<(frac32>>2);
        return (double)numerator/denominator;
    } else {
        /* reserved */
        return U_NO_NUMERIC_VALUE;
    }
}

U_CAPI int32_t U_EXPORT2
u_digit(UChar32 ch, int8_t radix) {
    int8_t value;
    if((uint8_t)(radix-2)<=(36-2)) {
        value=(int8_t)u_charDigitValue(ch);
        if(value<0) {
            /* ch is not a decimal digit, try latin letters */
            if(ch>=0x61 && ch<=0x7A) {
                value=(int8_t)(ch-0x57);  /* ch - 'a' + 10 */
            } else if(ch>=0x41 && ch<=0x5A) {
                value=(int8_t)(ch-0x37);  /* ch - 'A' + 10 */
            } else if(ch>=0xFF41 && ch<=0xFF5A) {
                value=(int8_t)(ch-0xFF37);  /* fullwidth ASCII a-z */
            } else if(ch>=0xFF21 && ch<=0xFF3A) {
                value=(int8_t)(ch-0xFF17);  /* fullwidth ASCII A-Z */
            }
        }
    } else {
        value=-1;   /* invalid radix */
    }
    return (int8_t)((value<radix) ? value : -1);
}

U_CAPI UChar32 U_EXPORT2
u_forDigit(int32_t digit, int8_t radix) {
    if((uint8_t)(radix-2)>(36-2) || (uint32_t)digit>=(uint32_t)radix) {
        return 0;
    } else if(digit<10) {
        return (UChar32)(0x30+digit);
    } else {
        return (UChar32)((0x61-10)+digit);
    }
}

/* miscellaneous, and support for uprops.cpp -------------------------------- */

U_CAPI void U_EXPORT2
u_getUnicodeVersion(UVersionInfo versionArray) {
    if(versionArray!=nullptr) {
        uprv_memcpy(versionArray, dataVersion, U_MAX_VERSION_LENGTH);
    }
}

U_CFUNC uint32_t
u_getMainProperties(UChar32 c) {
    uint32_t props;
    GET_PROPS(c, props);
    return props;
}

U_CFUNC uint32_t
u_getUnicodeProperties(UChar32 c, int32_t column) {
    U_ASSERT(column>=0);
    if(column>=propsVectorsColumns) {
        return 0;
    } else {
        uint16_t vecIndex=UTRIE2_GET16(&propsVectorsTrie, c);
        return propsVectors[vecIndex+column];
    }
}

U_CFUNC int32_t
uprv_getMaxValues(int32_t column) {
    switch(column) {
    case 0:
        return indexes[UPROPS_MAX_VALUES_INDEX];
    case 2:
        return indexes[UPROPS_MAX_VALUES_2_INDEX];
    case UPROPS_MAX_VALUES_OTHER_INDEX:
        return indexes[column];
    default:
        return 0;
    }
}

U_CAPI void U_EXPORT2
u_charAge(UChar32 c, UVersionInfo versionArray) {
    if(versionArray!=nullptr) {
        uint32_t version=u_getUnicodeProperties(c, 0)>>UPROPS_AGE_SHIFT;
        versionArray[0]=(uint8_t)(version>>2);
        versionArray[1]=(uint8_t)(version&3);
        versionArray[2]=versionArray[3]=0;
    }
}

U_CAPI UScriptCode U_EXPORT2
uscript_getScript(UChar32 c, UErrorCode *pErrorCode) {
    if(pErrorCode==nullptr || U_FAILURE(*pErrorCode)) {
        return USCRIPT_INVALID_CODE;
    }
    if((uint32_t)c>0x10ffff) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return USCRIPT_INVALID_CODE;
    }
    uint32_t scriptX=u_getUnicodeProperties(c, 0)&UPROPS_SCRIPT_X_MASK;
    uint32_t codeOrIndex=scriptX&UPROPS_MAX_SCRIPT;
    if(scriptX<UPROPS_SCRIPT_X_WITH_COMMON) {
        return (UScriptCode)codeOrIndex;
    } else if(scriptX<UPROPS_SCRIPT_X_WITH_INHERITED) {
        return USCRIPT_COMMON;
    } else if(scriptX<UPROPS_SCRIPT_X_WITH_OTHER) {
        return USCRIPT_INHERITED;
    } else {
        return (UScriptCode)scriptExtensions[codeOrIndex];
    }
}

U_CAPI UBool U_EXPORT2
uscript_hasScript(UChar32 c, UScriptCode sc) UPRV_NO_SANITIZE_UNDEFINED {
    uint32_t scriptX=u_getUnicodeProperties(c, 0)&UPROPS_SCRIPT_X_MASK;
    uint32_t codeOrIndex=scriptX&UPROPS_MAX_SCRIPT;
    if(scriptX<UPROPS_SCRIPT_X_WITH_COMMON) {
        return sc==(UScriptCode)codeOrIndex;
    }

    const uint16_t *scx=scriptExtensions+codeOrIndex;
    if(scriptX>=UPROPS_SCRIPT_X_WITH_OTHER) {
        scx=scriptExtensions+scx[1];
    }
    uint32_t sc32=sc;
    if(sc32>0x7fff) {
        /* Guard against bogus input that would make us go past the Script_Extensions terminator. */
        return false;
    }
    while(sc32>*scx) {
        ++scx;
    }
    return sc32==(*scx&0x7fff);
}

U_CAPI int32_t U_EXPORT2
uscript_getScriptExtensions(UChar32 c,
                            UScriptCode *scripts, int32_t capacity,
                            UErrorCode *pErrorCode) {
    if(pErrorCode==nullptr || U_FAILURE(*pErrorCode)) {
        return 0;
    }
    if(capacity<0 || (capacity>0 && scripts==nullptr)) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }
    uint32_t scriptX=u_getUnicodeProperties(c, 0)&UPROPS_SCRIPT_X_MASK;
    uint32_t codeOrIndex=scriptX&UPROPS_MAX_SCRIPT;
    if(scriptX<UPROPS_SCRIPT_X_WITH_COMMON) {
        if(capacity==0) {
            *pErrorCode=U_BUFFER_OVERFLOW_ERROR;
        } else {
            scripts[0]=(UScriptCode)codeOrIndex;
        }
        return 1;
    }

    const uint16_t *scx=scriptExtensions+codeOrIndex;
    if(scriptX>=UPROPS_SCRIPT_X_WITH_OTHER) {
        scx=scriptExtensions+scx[1];
    }
    int32_t length=0;
    uint16_t sx;
    do {
        sx=*scx++;
        if(length<capacity) {
            scripts[length]=(UScriptCode)(sx&0x7fff);
        }
        ++length;
    } while(sx<0x8000);
    if(length>capacity) {
        *pErrorCode=U_BUFFER_OVERFLOW_ERROR;
    }
    return length;
}

U_CAPI UBlockCode U_EXPORT2
ublock_getCode(UChar32 c) {
    // We store Block values indexed by the code point shifted right 4 bits
    // and use a "small" UCPTrie=CodePointTrie for minimal data size.
    // This works because blocks have xxx0..xxxF ranges.
    uint32_t c4 = c;  // unsigned so that shifting right does not worry the compiler
    // Shift unless out of range, in which case we fetch the trie's error value.
    if (c4 <= 0x10ffff) {
        c4 >>= 4;
    }
    return (UBlockCode)ucptrie_get(&block_trie, c4);
}

/* property starts for UnicodeSet ------------------------------------------- */

static UBool U_CALLCONV
_enumPropertyStartsRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {
    /* add the start code point to the USet */
    const USetAdder* sa = static_cast<const USetAdder*>(context);
    sa->add(sa->set, start);
    (void)end;
    (void)value;
    return true;
}

#define USET_ADD_CP_AND_NEXT(sa, cp) sa->add(sa->set, cp); sa->add(sa->set, cp+1)

U_CFUNC void U_EXPORT2
uchar_addPropertyStarts(const USetAdder *sa, UErrorCode *pErrorCode) {
    if(U_FAILURE(*pErrorCode)) {
        return;
    }

    /* add the start code point of each same-value range of the main trie */
    utrie2_enum(&propsTrie, nullptr, _enumPropertyStartsRange, sa);

    /* add code points with hardcoded properties, plus the ones following them */

    /* add for u_isblank() */
    USET_ADD_CP_AND_NEXT(sa, TAB);

    /* add for IS_THAT_CONTROL_SPACE() */
    sa->add(sa->set, CR+1); /* range TAB..CR */
    sa->add(sa->set, 0x1c);
    sa->add(sa->set, 0x1f+1);
    USET_ADD_CP_AND_NEXT(sa, 0x85);  // NEXT LINE (NEL)

    /* add for u_isIDIgnorable() what was not added above */
    sa->add(sa->set, 0x7f); /* range DEL..NBSP-1, NBSP added below */
    sa->add(sa->set, HAIRSP);
    sa->add(sa->set, RLM+1);
    sa->add(sa->set, 0x206a);  // INHIBIT SYMMETRIC SWAPPING
    sa->add(sa->set, 0x206f+1);  // NOMINAL DIGIT SHAPES
    USET_ADD_CP_AND_NEXT(sa, ZWNBSP);

    /* add no-break spaces for u_isWhitespace() what was not added above */
    USET_ADD_CP_AND_NEXT(sa, NBSP);
    USET_ADD_CP_AND_NEXT(sa, FIGURESP);
    USET_ADD_CP_AND_NEXT(sa, NNBSP);

    /* add for u_digit() */
    sa->add(sa->set, u'a');
    sa->add(sa->set, u'z'+1);
    sa->add(sa->set, u'A');
    sa->add(sa->set, u'Z'+1);
    // fullwidth
    sa->add(sa->set, u'ａ');
    sa->add(sa->set, u'ｚ'+1);
    sa->add(sa->set, u'Ａ');
    sa->add(sa->set, u'Ｚ'+1);

    /* add for u_isxdigit() */
    sa->add(sa->set, u'f'+1);
    sa->add(sa->set, u'F'+1);
    // fullwidth
    sa->add(sa->set, u'ｆ'+1);
    sa->add(sa->set, u'Ｆ'+1);

    /* add for UCHAR_DEFAULT_IGNORABLE_CODE_POINT what was not added above */
    sa->add(sa->set, 0x2060); /* range 2060..206f */
    sa->add(sa->set, 0xfff0);
    sa->add(sa->set, 0xfffb+1);
    sa->add(sa->set, 0xe0000);
    sa->add(sa->set, 0xe0fff+1);

    /* add for UCHAR_GRAPHEME_BASE and others */
    USET_ADD_CP_AND_NEXT(sa, CGJ);
}

U_CFUNC void U_EXPORT2
upropsvec_addPropertyStarts(const USetAdder *sa, UErrorCode *pErrorCode) {
    if(U_FAILURE(*pErrorCode)) {
        return;
    }

    /* add the start code point of each same-value range of the properties vectors trie */
    utrie2_enum(&propsVectorsTrie, nullptr, _enumPropertyStartsRange, sa);
}

U_CFUNC void U_EXPORT2
ublock_addPropertyStarts(const USetAdder *sa, UErrorCode & /*errorCode*/) {
    // Add the start code point of each same-value range of the trie.
    // We store Block values indexed by the code point shifted right 4 bits;
    // see ublock_getCode().
    UChar32 start = 0, end;
    uint32_t value;
    while (start < 0x11000 &&  // limit: (max code point + 1) >> 4
            (end = ucptrie_getRange(&block_trie, start, UCPMAP_RANGE_NORMAL, 0,
                                    nullptr, nullptr, &value)) >= 0) {
        sa->add(sa->set, start << 4);
        start = end + 1;
    }
}
      node-23.7.0/deps/icu-small/source/common/uchar_props_data.h                                         0000664 0000000 0000000 00001321400 14746647661 0023656 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright (C) 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
// Copyright (C) 1999-2016, International Business Machines
// Corporation and others.  All Rights Reserved.
//
// file name: uchar_props_data.h
//
// machine-generated by: icu/tools/unicode/c/genprops/corepropsbuilder.cpp

#ifdef INCLUDED_FROM_UCHAR_C

static const UVersionInfo dataVersion={0x10,0,0,0};

static const uint16_t propsTrie_index[23796]={
0x4a3,0x4ab,0x4b3,0x4bb,0x4d3,0x4db,0x4e3,0x4eb,0x4f3,0x4fb,0x501,0x509,0x511,0x519,0x521,0x529,
0x52f,0x537,0x53f,0x547,0x54a,0x552,0x55a,0x562,0x56a,0x572,0x56e,0x576,0x57e,0x586,0x58b,0x593,
0x59b,0x5a3,0x5a7,0x5af,0x5b7,0x5bf,0x5c7,0x5cf,0x5cb,0x5d3,0x5d8,0x5e0,0x5e6,0x5ee,0x5f6,0x5fe,
0x606,0x60e,0x616,0x61e,0x623,0x62b,0x62e,0x636,0x63e,0x646,0x64c,0x654,0x653,0x65b,0x663,0x66b,
0x67b,0x673,0x683,0x68b,0x691,0x60e,0x6a1,0x699,0x6b1,0x6b3,0x6bb,0x6a9,0x6cb,0x6d1,0x6d9,0x6c3,
0x6e9,0x6ef,0x6f7,0x6e1,0x707,0x70d,0x715,0x6ff,0x725,0x72b,0x733,0x71d,0x743,0x74b,0x753,0x73b,
0x763,0x769,0x771,0x75b,0x781,0x787,0x78f,0x779,0x79f,0x7a4,0x7ac,0x797,0x7bc,0x7c3,0x7cb,0x7b4,
0x64f,0x7d3,0x7db,0x4c3,0x7e3,0x7ea,0x7f2,0x4c3,0x7fa,0x802,0x80a,0x80f,0x817,0x81e,0x826,0x4c3,
0x60e,0x82e,0x836,0x83e,0x846,0x59b,0x856,0x84e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x85e,0x60e,0x866,0x86a,0x872,0x60e,0x878,0x60e,0x87e,0x886,0x88e,0x59b,0x59b,0x896,
0x89e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x8a3,0x8ab,0x60e,0x60e,0x8b3,0x8bb,0x8c3,0x8cb,0x8d3,0x60e,0x8db,0x8e3,0x8eb,
0x8fb,0x60e,0x903,0x905,0x90d,0x8f3,0x60e,0x910,0x924,0x918,0x920,0x92c,0x60e,0x934,0x93a,0x942,
0x94a,0x60e,0x95a,0x962,0x96a,0x952,0x97a,0x4c3,0x982,0x985,0x98d,0x972,0x99d,0x995,0x60e,0x9a4,
0x60e,0x9b3,0x9ac,0x9bb,0x9c3,0x9c7,0x9cf,0x9d7,0x543,0x9df,0x9e2,0x9e8,0x9ef,0x9e2,0x56a,0x56a,
0x4f3,0x4f3,0x4f3,0x4f3,0x9f7,0x4f3,0x4f3,0x4f3,0xa07,0xa0f,0xa17,0xa1f,0xa27,0xa2b,0xa33,0x9ff,
0xa4b,0xa53,0xa3b,0xa43,0xa5b,0xa63,0xa6b,0xa73,0xa8b,0xa7b,0xa83,0xa93,0xa9b,0xaaa,0xaaf,0xaa2,
0xab7,0xab7,0xab7,0xab7,0xab7,0xab7,0xab7,0xab7,0xabf,0xac7,0x942,0xaca,0xad2,0xad9,0xade,0xae6,
0x942,0xaec,0xaf4,0xb04,0xb07,0x942,0x942,0xafc,0x942,0x942,0x942,0x942,0x942,0xb16,0xb1e,0xb0e,
0x942,0x942,0x942,0xb23,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0xb29,0xb31,0x942,0xb39,0xb40,
0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0xab7,0xab7,0xab7,0xab7,0xb48,0xab7,0xb4f,0xb56,
0xab7,0xab7,0xab7,0xab7,0xab7,0xab7,0xab7,0xab7,0x942,0xb5e,0xb65,0xb69,0xb6f,0x942,0x942,0x942,
0x59b,0x5a3,0x543,0xb77,0x4f3,0x4f3,0x4f3,0xb7f,0x543,0xb87,0x60e,0xb8d,0xb9d,0xb95,0xb95,0x56a,
0xba5,0xbad,0xbb5,0x4c3,0xbbd,0x942,0x942,0xbc4,0x942,0x942,0x942,0x942,0x942,0x942,0xae9,0xbc9,
0xbd9,0xbd1,0x64f,0x60e,0xbe1,0x89e,0x60e,0xbe9,0xbf1,0xbf5,0x60e,0x60e,0xbfa,0x60e,0x942,0xc01,
0xc09,0xc11,0xc17,0x942,0xc11,0xc1f,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,
0xc27,0x60e,0x60e,0x60e,0xc2f,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0xc35,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xc3a,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x942,0x942,
0xc42,0xc49,0xc4b,0x60e,0xc53,0xc59,0xc61,0xc69,0xc6e,0x60e,0x60e,0xc72,0x60e,0x60e,0x60e,0xc78,
0xc7f,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xc86,0x60e,0xc8d,0xc93,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xc9b,0x60e,0x60e,0x60e,0xca3,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xca5,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xcac,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0xcb3,0x60e,0x60e,0x60e,0xcba,0xcc2,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xcc7,0xccc,0x60e,0x60e,0xcd4,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xcd8,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xcdd,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xcdb,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xce5,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0xceb,0xcf3,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xcf9,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0xd00,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0xd05,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0xd0a,0x60e,0x60e,0x60e,0xc46,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0xce7,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0xd10,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0xd18,0xd1f,0xd23,0x60e,0x60e,0x60e,0xcdf,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0xd32,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0xd2a,0x942,0xd3a,0x9bb,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0xd3f,0xd47,0x4f3,0xd57,0xd4f,0x60e,0x60e,0xd5f,0xd67,0xd77,0x4f3,0xd7c,0xd84,0xd8a,0xd91,0xd6f,
0xd99,0xda1,0x60e,0xda9,0xdb9,0xdbc,0xdb1,0xdc4,0x663,0xdcc,0xdd3,0x904,0x6b1,0xde3,0xddb,0xdeb,
0x60e,0xdf3,0xdfb,0xe03,0x60e,0xe0b,0xe13,0xe1b,0xe23,0xe2b,0xe2f,0xe37,0x543,0x543,0x60e,0xe3f,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xe47,0xe53,0xe4b,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,
0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0x60e,0x60e,0x60e,0xe6b,0x60e,0xce0,0xe72,0xe77,
0x60e,0x60e,0x60e,0xe7f,0x60e,0x60e,0x90f,0x4c3,0xe95,0xe85,0xe8d,0x60e,0x60e,0xe9d,0xea5,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xeaa,0x946,0x60e,0xeb2,0x60e,0xeb8,0xebc,
0xec4,0xecc,0xed3,0xedb,0x60e,0x60e,0x60e,0xee1,0xef9,0x4b3,0xf01,0xf09,0xf0e,0x924,0xee9,0xef1,
0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,
0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,
0x130c,0x130c,0x134c,0x138c,0x13cc,0x1404,0x1444,0x1484,0x14bc,0x14fc,0x1528,0x1568,0x15a8,0x15b8,0x15f8,0x162c,
0x166c,0x169c,0x16dc,0x171c,0x172c,0x1760,0x1798,0x17d8,0x1818,0x1858,0x188c,0x18b8,0x18f8,0x1930,0x194c,0x198c,
0xa80,0xac0,0xb00,0xb40,0xb80,0xbab,0xbeb,0x1db,0xc0e,0xa40,0xa40,0xa40,0xc46,0xc86,0x1db,0x1db,
0xcc6,0xd06,0xa40,0xa40,0xa40,0xd2f,0xd6f,0xd8f,0xa40,0xdb5,0xdf5,0xe35,0xe75,0xeb5,0xef5,0xf35,
0xf75,0xfac,0x1db,0x1db,0xfd0,0x1004,0x1db,0x102c,0x1db,0x1db,0x1db,0x1db,0x1059,0x1db,0x1db,0x1db,
0x1db,0x1db,0x1db,0x1db,0x106d,0x1db,0x10a5,0x10e5,0x1db,0x10f0,0x1db,0x1db,0x1db,0x1126,0xa40,0x1166,
0x1db,0x1db,0x11a6,0x1db,0x11c9,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0x1209,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,
0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x1249,
0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,
0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x700,0x1249,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0xf16,0xf1d,0xf25,0x4c3,0x60e,0x60e,0x60e,0xf2d,0xf3d,0xf35,0xf54,0xf45,0xf4c,0xf5c,0xbc9,0xf64,
0x4c3,0x4c3,0x4c3,0x4c3,0x904,0x60e,0xf6c,0xf74,0x60e,0xf7c,0xf84,0xf88,0xf90,0x60e,0xf98,0x4c3,
0x59b,0x5a5,0xfa0,0x60e,0xfa4,0xfac,0xfbc,0xfb4,0x60e,0xfc4,0x60e,0xfcb,0xfdb,0xfd3,0x60e,0xfe3,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xb9d,0x910,0xfe6,0xff6,0xfee,0x4c3,0x4c3,
0x1006,0xffe,0x1009,0x1011,0x924,0x1019,0x4c3,0x1021,0x1029,0x1031,0x4c3,0x4c3,0x60e,0x1041,0x1049,0x1039,
0x1059,0x1060,0x1051,0x1068,0x1070,0x4c3,0x1080,0x1078,0x60e,0x1083,0x108b,0x1093,0x109b,0x10a3,0x4c3,0x4c3,
0x60e,0x60e,0x10ab,0x4c3,0x59b,0x10b3,0x543,0x10bb,0x60e,0x10c3,0x10da,0x10cb,0x10d2,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x10e2,0x60e,0x10ea,0x10f7,0x10ef,0x10ff,0x1107,0x110e,0x101d,0x1116,0x101d,0x111e,0xb9d,
0x112e,0x644,0x1136,0x1126,0x99d,0x113e,0x1146,0x114c,0x1164,0x1154,0x115c,0x1168,0x99d,0x1178,0x1170,0x1180,
0x1198,0x1188,0x1190,0x4c3,0x119f,0x11a7,0x666,0x11af,0x11bf,0x11c5,0x11cd,0x11b7,0x11dd,0x11e1,0x11e9,0x11d5,
0x60e,0x11f1,0x11f9,0x10ee,0x60e,0x1201,0x1209,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x60e,0x1211,0x1219,0x4c3,
0x60e,0x1221,0x1229,0x1231,0x60e,0x1241,0x1239,0x1249,0x1261,0x1251,0x1259,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x60e,0x1269,0x4c3,0x4c3,0x4c3,0x59b,0x543,0x1271,0x1281,0x1287,0x1279,0x4c3,0x4c3,0x1297,0x129b,0x128f,
0x12b3,0x12a3,0x12ab,0x60e,0x12c1,0x12bb,0x60e,0x905,0x12c9,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x60e,0x12d1,
0x12e7,0x12ec,0x12d9,0x12e1,0x12fc,0x12f4,0x4c3,0x4c3,0x130b,0x130f,0x1303,0x1327,0x1317,0x131f,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x132b,0x133b,0x1340,0x1333,0x4c3,0x4c3,0x1348,0x1358,0x1350,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x90f,0x4c3,0x4c3,0x4c3,
0x1368,0x1370,0x1378,0x1360,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x1380,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x101d,0x60e,0x60e,0x1388,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x1390,0x1398,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xf2d,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x1259,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x655,0x13a0,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x905,0x924,0xddf,0x60e,0x924,0x13a4,0x13a9,0x60e,0x13b1,
0x13b9,0x13c1,0xfe4,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x13d1,0x13c9,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x59b,0x543,0x13d9,0x4c3,0x4c3,0x4c3,0x60e,0x60e,
0x13e1,0x13e6,0x13ec,0x4c3,0x4c3,0x13f4,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x13fc,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x910,0x1402,0x10ab,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x140a,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x1412,0x1417,0x141e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xe4b,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x60e,
0x60e,0x60e,0x1424,0x1429,0x1431,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x1439,0x942,0x942,0x942,
0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0xbc4,0x4c3,0x4c3,0x56a,0x1449,0x1450,
0x942,0x942,0x942,0x1441,0x4c3,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0xae9,0x942,0x1457,0x942,
0x145e,0x1466,0x146c,0x942,0xaf4,0x942,0x942,0x1474,0x4c3,0x4c3,0x4c3,0x147c,0x147c,0x942,0x942,0x1484,
0x148c,0x4c3,0x4c3,0x4c3,0x4c3,0x149c,0x14a3,0x14a8,0x14ae,0x14b6,0x14be,0x14c6,0x14a0,0x14ce,0x14d6,0x14de,
0x14e3,0x14b5,0x149c,0x14a3,0x149f,0x14ae,0x14eb,0x149d,0x14ee,0x14a0,0x14f6,0x14fe,0x1506,0x150d,0x14f9,0x1501,
0x1509,0x1510,0x14fc,0x1518,0x1494,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,
0x942,0x942,0x942,0x942,0x942,0x56a,0x1528,0x56a,0x152f,0x1536,0x1520,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x1545,0x154d,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x153d,0x1555,0x9e2,0x1565,0x155d,0x4c3,0x4c3,0x4c3,0x60e,0x1575,0x156d,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x101d,0x157d,0x60e,0x1585,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x101d,0x158d,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x101d,0x1595,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x159d,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x15a5,0x4c3,0x59b,0x15b5,0x15ad,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x15bd,0x15cd,0x15c5,0x4c3,0x4c3,0x15dd,0x15d5,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x15ed,0x15f5,0x15fd,0x1605,0x160d,0x1615,0x4c3,0x15e5,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x942,0x161d,0x942,0x942,0xbc4,0x1455,0x1625,0xae9,0x162d,0x942,0x942,
0x942,0x942,0xaeb,0x4c3,0x1635,0x163d,0x1641,0x1649,0x1651,0x4c3,0x4c3,0x4c3,0x4c3,0x942,0x942,0x942,
0x942,0x942,0x942,0x942,0x1659,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,
0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x942,0x1642,0x1661,0x942,0x942,0x942,
0x1669,0x942,0x942,0xae8,0x1670,0x161d,0x942,0x1678,0x942,0x1680,0x1685,0x168d,0x4c3,0x942,0x942,0x942,
0x942,0x942,0x942,0x942,0x942,0x942,0x942,0xbc4,0x1695,0x169d,0x942,0x16a4,0x16ac,0x942,0x942,0x942,
0x942,0x16b4,0x942,0x942,0x1439,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x16bc,0x60e,0x60e,0x16c3,0x60e,0x60e,0x60e,0x16cb,0x60e,0x16d3,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0xcb7,0x60e,0x60e,0x16db,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x16e3,0x16eb,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xc46,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x16f2,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x16f9,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x1700,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x4c3,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x90f,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0xfa4,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x1708,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x1710,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xfa4,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x60e,0x60e,0x60e,0x60e,0x1714,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xfa4,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x68b,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,
0x60e,0x60e,0x60e,0x60e,0x60e,0x60e,0xfe4,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x1724,0x171c,0x171c,0x171c,0x4c3,0x4c3,0x4c3,
0x4c3,0x56a,0x56a,0x56a,0x56a,0x56a,0x56a,0x56a,0x172c,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,
0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0x4c3,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,
0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0xe63,0x1734,0x4a2,0x4a2,0x4a2,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xc,0x17,0x17,0x17,
0x19,0x17,0x17,0x17,0x14,0x15,0x17,0x18,0x17,0x13,0x17,0x17,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0x18,0x18,0x18,0x17,0x17,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,0x14,0x17,0x15,0x1a,0x16,0x1a,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,0x14,0x18,0x15,0x18,0xf,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xc,0x17,0x19,0x19,
0x19,0x19,0x1b,0x17,0x1a,0x1b,5,0x1c,0x18,0x10,0x1b,0x1a,0x1b,0x18,0x34b,0x38b,
0x1a,2,0x17,0x17,0x1a,0x30b,5,0x1d,0x34cb,0x344b,0x3ccb,0x17,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,0x18,1,1,1,1,1,1,1,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,0x18,2,2,2,2,2,2,2,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,2,1,2,1,2,1,2,1,2,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,
2,1,2,2,2,1,1,2,1,2,1,1,2,1,1,1,
2,2,1,1,1,1,2,1,1,2,1,1,1,2,2,2,
1,1,2,1,1,2,1,2,1,2,1,1,2,1,2,2,
1,2,1,1,2,1,1,1,2,1,2,1,1,2,2,5,
1,2,2,2,5,5,5,5,1,3,2,1,3,2,1,3,
2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,
2,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,2,1,3,2,1,2,1,1,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
2,2,2,2,2,2,1,1,2,1,1,2,2,1,2,1,
1,1,1,2,1,2,1,2,1,2,1,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,5,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,0x1a,0x1a,0x1a,0x1a,4,4,
4,4,4,4,4,4,4,4,4,4,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,4,4,4,4,4,0x1a,0x1a,0x1a,
0x1a,0x1a,0x1a,0x1a,4,0x1a,4,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,1,2,1,2,4,0x1a,1,2,
0,0,4,2,2,2,0x17,1,0,0,0,0,0x1a,0x1a,1,0x17,
1,1,1,0,1,0,1,1,2,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,
1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,
1,2,2,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,2,2,2,2,
1,2,0x18,1,2,1,1,2,2,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,0x1b,6,
6,6,6,6,7,7,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,1,2,1,
2,1,2,1,2,1,2,1,2,1,2,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,0,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,0,0,4,0x17,0x17,0x17,0x17,0x17,0x17,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,0x17,0x13,0,0,0x1b,0x1b,0x19,0,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,0x13,6,0x17,6,6,0x17,6,6,0x17,6,
0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,0,0,0,0,5,5,5,5,0x17,0x17,0,0,0,
0,0,0,0,0,0,0,0,0x10,0x10,0x10,0x10,0x10,0x10,0x18,0x18,
0x18,0x17,0x17,0x19,0x17,0x17,0x1b,0x1b,6,6,6,6,6,6,6,6,
6,6,6,0x17,0x10,0x17,0x17,0x17,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,4,5,5,5,5,5,5,5,
5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0x17,0x17,0x17,0x17,5,5,6,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0x17,5,6,6,
6,6,6,6,6,0x10,0x1b,6,6,6,6,6,6,4,4,6,
6,0x1b,6,6,6,6,5,5,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,5,5,5,0x1b,0x1b,5,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,0x17,0x17,0,0x10,5,6,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,0,0,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,6,6,6,6,6,6,6,6,6,6,6,5,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,
4,4,0x1b,0x17,0x17,0x17,4,0,0,6,0x19,0x19,6,6,6,6,
4,6,6,6,4,6,6,6,6,6,0,0,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,6,6,6,6,4,6,6,6,6,6,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,6,6,6,0,0,0x17,0,5,5,5,5,
5,5,5,5,5,5,5,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0x1a,5,5,5,
5,5,5,0,0x10,0x10,0,0,0,0,0,6,6,6,6,6,
6,6,6,6,6,6,0x10,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,5,5,5,5,5,5,5,5,5,4,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,5,5,6,6,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,
0x1c9,0x209,0x249,0x289,0x17,4,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,6,6,6,8,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,6,8,6,5,8,8,8,6,6,6,
6,6,6,6,6,8,8,8,8,6,8,8,5,6,6,6,
6,6,6,6,5,5,5,5,5,5,5,5,5,5,6,6,
0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,0x19,0x19,
0x37cb,0x35cb,0x3fcb,0x34cb,0x3ccb,0x94b,0x1b,0x19,5,0x17,6,0,5,6,8,8,
0,5,5,5,5,5,5,5,5,0,0,5,5,0,0,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
5,5,5,5,5,0,5,0,0,0,5,5,5,5,0,0,
6,5,8,8,8,6,6,6,6,0,0,8,8,0,0,8,
8,6,5,0,0,0,0,0,0,0,0,8,0,0,0,0,
5,5,0,5,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
0x1c9,0x209,0x249,0x289,6,6,5,5,5,6,0x17,0,0,0,0,0,
0,0,0,0,0,6,6,8,0,5,5,5,5,5,5,0,
0,0,0,5,5,0,0,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0,5,5,5,5,5,5,5,0,5,5,
0,5,5,0,5,5,0,0,6,0,8,8,8,6,6,0,
0,0,0,6,6,0,0,6,6,6,0,0,0,6,0,0,
0,0,0,0,0,5,5,5,5,0,5,0,5,5,6,6,
0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x19,0,0,
0,0,0,0,0,5,6,6,6,6,6,6,0,6,6,8,
0,5,5,5,5,5,5,5,5,5,0,5,5,5,0,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
5,5,5,5,5,0,5,5,0,5,5,5,5,5,0,0,
6,5,8,8,8,6,6,6,6,6,0,6,6,8,0,8,
8,6,0,0,5,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
0x1c9,0x209,0x249,0x289,0x1b,5,0x34cb,0x344b,0x3ccb,0x37cb,0x35cb,0x3fcb,0,0,0,0,
0,0,0,0,0,6,8,8,0,5,5,5,5,5,5,5,
5,0,0,5,5,0,0,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0,5,5,5,5,5,5,5,0,5,5,
0,5,5,5,5,5,0,0,6,5,8,6,8,6,6,6,
6,0,0,8,8,0,0,8,8,6,0,0,0,0,0,0,
0,6,6,8,0,0,0,0,5,5,0,5,0,0,0,0,
0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x7cb,0x1e4b,0x784b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x19,0x1b,0,0,0,0,0,0,0,6,5,
0,5,5,5,5,5,5,0,0,0,5,5,5,0,5,5,
5,5,0,0,0,5,5,0,5,0,5,5,0,0,0,5,
5,0,0,0,5,5,5,0,0,0,5,5,5,5,5,5,
5,5,5,5,5,5,0,0,0,0,8,8,6,8,8,0,
0,0,8,8,8,0,8,8,8,6,0,0,5,0,0,0,
0,0,0,8,0,0,0,0,0,0,0,0,5,5,6,6,
0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,
0,0,0,0x17,0x54b,0x58b,0x5cb,0x60b,0x58b,0x5cb,0x60b,0x1b,6,8,8,8,
6,5,5,5,5,5,5,5,5,0,5,5,5,0,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
6,5,6,6,6,8,8,8,8,0,6,6,6,0,6,6,
6,6,0,0,0,0,0,0,0,6,6,0,5,5,5,0,
0,5,0,0,5,5,6,6,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,
0x1c9,0x209,0x249,0x289,0,5,5,8,0,0,0,0,0,0,0,0,
0,0,0,0,5,6,8,8,0x17,5,5,5,5,5,5,5,
5,0,5,5,5,0,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,
0,5,5,5,5,5,0,0,6,5,8,6,8,8,8,8,
8,0,6,8,8,0,8,8,6,6,0,0,0,0,0,0,
0,8,8,0,0,0,0,0,0,5,5,0,5,5,6,6,
0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x7cb,0x1e4b,0x784b,0x34cb,
0x344b,0x3ccb,0x37cb,0x35cb,0x3fcb,0x1b,5,5,5,5,5,5,6,6,8,8,
5,5,5,5,5,5,5,5,5,0,5,5,5,0,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,6,6,5,8,8,
8,6,6,6,6,0,8,8,8,0,8,8,8,6,5,0x1b,
0,0,0,0,5,5,5,8,0xcc0b,0xca0b,0xcb4b,0xc90b,0x364b,0xc94b,0x350b,5,
0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,
0,0,8,8,0x17,0,0,0,0,0,0,0,0,0,0,0,
0,6,8,8,0,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,0,0,0,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,
5,5,5,5,5,5,5,5,0,5,0,0,5,5,5,5,
5,5,5,0,0,0,6,0,0,0,0,8,8,8,6,6,
6,0,6,0,8,8,8,8,8,8,8,8,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,6,5,5,
6,6,6,6,6,6,6,0,0,0,0,0x19,5,5,5,5,
5,5,4,6,6,6,6,6,6,6,6,0x17,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,0,0,0,0,0,5,5,0,
5,0,5,5,5,5,5,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0,5,0,5,
5,5,5,5,5,5,5,5,5,6,5,5,6,6,6,6,
6,6,6,6,6,5,0,0,5,5,5,5,5,0,4,0,
6,6,6,6,6,6,6,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0,0,5,5,5,5,5,0x1b,0x1b,0x1b,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x1b,0x17,0x1b,0x1b,0x1b,
6,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0x344b,0x3c4b,0x444b,0x4c4b,0x544b,0x5c4b,0x644b,0x6c4b,0x744b,0x2c4b,0x1b,6,0x1b,6,
0x1b,6,0x14,0x15,0x14,0x15,8,8,5,5,5,5,5,5,5,5,
0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0,0,0,0,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,8,6,6,6,6,
6,0x17,6,6,5,5,5,5,5,6,6,6,6,6,6,6,
6,6,6,6,0,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,0x1b,0x17,0x17,0x17,0x17,0x17,0x1b,0x1b,0x1b,
0x1b,0x17,0x17,0,0,0,0,0,5,5,5,5,5,5,5,5,
5,5,5,8,8,6,6,6,6,8,6,6,6,6,6,6,
8,6,6,8,8,6,6,5,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0x17,0x17,0x17,0x17,0x17,0x17,5,5,5,5,5,5,8,8,
6,6,5,5,5,5,6,6,6,5,8,8,8,5,5,8,
8,8,8,8,8,8,5,5,5,6,6,6,6,5,5,5,
5,5,5,5,5,5,5,5,5,5,6,8,8,6,6,8,
8,8,8,8,8,6,5,8,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,8,8,8,6,0x1b,0x1b,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,0x17,4,2,2,2,1,1,1,1,1,1,0,1,
0,0,0,0,0,1,0,0,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,5,5,5,5,5,5,5,5,
5,0,5,5,5,5,0,0,5,5,5,5,5,5,5,0,
5,0,5,5,5,5,0,0,5,5,5,5,5,5,5,5,
5,0,5,5,5,5,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0,5,5,5,5,0,0,
5,5,5,5,5,5,5,0,5,0,5,5,5,5,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0,5,5,5,5,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,0,0,6,6,6,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
0x17,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,
0x16cb,0x194b,0x1bcb,0x1e4b,0x788b,0,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0,0,0,0,0,0,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
2,2,2,2,2,2,0,0,0x13,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0x1b,0x17,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0xc,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,0x14,0x15,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,0x17,0x17,0x17,0x98a,0x9ca,0xa0a,5,5,5,
5,5,5,5,5,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,
6,8,0,0,0,0,0,0,0,0,0,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,
8,0x17,0x17,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,0,5,5,5,0,6,6,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
6,6,8,6,6,6,6,6,6,6,8,8,8,8,8,8,
8,8,6,8,8,6,6,6,6,6,6,6,6,6,6,6,
0x17,0x17,0x17,4,0x17,0x17,0x17,0x19,5,6,0,0,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,0x54b,0x58b,0x5cb,0x60b,
0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,6,5,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0x17,0x17,0x17,0x17,
0x17,0x17,0x13,0x17,0x17,0x17,0x17,6,6,6,0x10,6,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,5,5,5,4,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,
0,0,0,0,5,5,5,5,5,6,6,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,
6,6,6,8,8,8,8,6,6,8,8,8,0,0,0,0,
8,8,6,8,8,8,8,8,8,6,6,6,0,0,0,0,
0x1b,0,0,0,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0x30b,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,
6,8,8,6,0,0,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,4,
0x17,0x17,0x17,0x17,0x17,0x17,0,0,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,7,6,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,8,6,8,
6,6,6,6,6,6,6,0,6,8,6,8,8,6,6,6,
6,6,6,6,6,8,8,8,8,8,8,6,6,6,6,6,
6,6,6,6,6,0,0,6,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,0,0,0,0,0,0,0x17,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,6,6,6,6,6,6,6,6,6,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x17,0x17,0x17,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,6,6,6,6,8,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,6,8,6,6,6,6,6,8,
6,8,8,8,8,8,6,8,8,5,5,5,5,5,5,5,
5,0,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,
0x17,0x17,0x17,0x17,5,8,6,6,6,6,8,8,6,6,8,6,
6,6,5,5,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,
5,5,5,5,6,6,8,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,6,8,6,6,8,8,8,6,8,6,
6,6,8,8,0,0,0,0,0,0,0,0,0x17,0x17,0x17,0x17,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,5,5,5,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,5,5,5,
8,8,8,8,8,8,8,8,6,6,6,6,6,6,6,6,
8,8,6,6,0,0,0,0x17,0x17,0x17,0x17,0x17,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,4,4,4,4,4,4,0x17,0x17,2,2,2,2,
2,2,2,2,2,1,2,0,0,0,0,0,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,0,0,1,1,1,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,0,6,6,6,0x17,
6,6,6,6,6,6,6,6,6,6,6,6,6,8,6,6,
6,6,6,6,6,5,5,5,5,6,5,5,5,5,5,5,
6,5,5,8,6,6,5,0,0,0,0,0,2,2,2,2,
2,2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,4,4,4,2,2,2,2,2,
2,2,2,2,2,2,2,2,4,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,4,4,4,4,4,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,
2,2,2,2,1,1,1,1,1,0x1a,0x1a,0x1a,0,0,2,2,
2,0,2,2,1,1,1,1,3,0x1a,0x1a,0,2,2,2,2,
2,2,2,2,1,1,1,1,1,1,1,1,2,2,2,2,
2,2,0,0,1,1,1,1,1,1,0,0,2,2,2,2,
2,2,2,2,1,1,1,1,1,1,1,1,2,2,2,2,
2,2,2,2,1,1,1,1,1,1,1,1,2,2,2,2,
2,2,0,0,1,1,1,1,1,1,0,0,2,2,2,2,
2,2,2,2,0,1,0,1,0,1,0,1,2,2,2,2,
2,2,2,2,1,1,1,1,1,1,1,1,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,
2,2,2,2,3,3,3,3,3,3,3,3,2,2,2,2,
2,2,2,2,3,3,3,3,3,3,3,3,2,2,2,2,
2,0,2,2,1,1,1,1,3,0x1a,2,0x1a,0x1a,0x1a,2,2,
2,0,2,2,1,1,1,1,3,0x1a,0x1a,0x1a,2,2,2,2,
0,0,2,2,1,1,1,1,0,0x1a,0x1a,0x1a,0x16,0x17,0x17,0x17,
0x18,0x14,0x15,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x18,0x17,
0x16,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0xc,0x10,0x10,0x10,0x10,
0x10,0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x2cb,4,0,0,
0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x18,0x18,0x18,0x14,0x15,4,0xc,0xc,0xc,0xc,
0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x10,0x10,0x10,0x10,0x10,0x13,0x13,0x13,0x13,
0x13,0x13,0x17,0x17,0x1c,0x1d,0x14,0x1c,0x1c,0x1d,0x14,0x1c,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,0xd,0xe,0x10,0x10,0x10,0x10,0x10,0xc,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,0x17,0x1c,0x1d,0x17,0x17,0x17,0x17,0x16,0x2cb,0x30b,0x34b,0x38b,
0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x18,0x18,0x18,0x14,0x15,0,4,4,4,4,
4,4,4,4,4,4,4,4,4,0,0,0,0x19,0x19,0x19,0x19,
0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,
0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,6,6,6,6,
6,6,6,6,6,6,6,6,6,7,7,7,7,6,7,7,
7,6,6,6,6,6,6,6,6,6,6,6,6,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,
1,0x1b,1,0x1b,1,0x1b,1,1,1,1,0x1b,2,1,1,1,1,
2,5,5,5,5,2,0x1b,0x1b,2,2,1,1,0x18,0x18,0x18,0x18,
0x18,1,2,2,2,2,0x1b,0x18,0x1b,0x1b,2,0x1b,0x358b,0x360b,0x364b,0x348b,
0x388b,0x350b,0x390b,0x3d0b,0x410b,0x354b,0x454b,0x35cb,0x3dcb,0x45cb,0x4dcb,0x58b,0x1b,0x1b,1,0x1b,
0x1b,0x1b,0x1b,1,0x1b,0x1b,2,1,1,1,2,2,1,1,1,2,
0x1b,1,0x1b,0x1b,0x18,1,1,1,1,1,0x1b,0x1b,0x58a,0x5ca,0x60a,0x64a,
0x68a,0x6ca,0x70a,0x74a,0x78a,0x7ca,0x80a,0x84a,0x11ca,0x1e4a,0x980a,0x784a,0x58a,0x5ca,0x60a,0x64a,
0x68a,0x6ca,0x70a,0x74a,0x78a,0x7ca,0x80a,0x84a,0x11ca,0x1e4a,0x980a,0x784a,0x784a,0x984a,0x788a,1,
2,0x6ca,0x11ca,0x988a,0x78ca,0x54b,0x1b,0x1b,0,0,0,0,0x18,0x18,0x18,0x18,
0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x18,0x1b,0x1b,0x18,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x1b,0x1b,0x18,0x1b,
0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x14,0x15,0x14,0x15,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x14,0x15,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x2cb,0x80b,0x84b,0x88b,0x8cb,0x90b,
0x94b,0x98b,0x9cb,0xa0b,0xa4b,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x2cb,
0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x80b,0x84b,0x88b,0x8cb,0x90b,0x94b,
0x98b,0x9cb,0xa0b,0xa4b,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x80b,0x84b,
0x88b,0x8cb,0x90b,0x94b,0x98b,0x9cb,0xa0b,0xa4b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x14,0x15,0x14,0x15,
0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,
0x48b,0x4cb,0x50b,0x7cb,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x30b,0x34b,
0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x7cb,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x14,0x15,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,
0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x14,0x15,0x14,0x15,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x14,0x15,0x18,0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,
0x18,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,1,2,1,1,
1,2,2,1,2,1,2,1,2,1,1,1,1,2,1,2,
2,1,2,2,2,2,2,2,4,4,1,1,1,2,1,2,
2,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,1,2,1,2,6,6,6,1,2,
0,0,0,0,0,0x17,0x17,0x17,0x17,0x344b,0x17,0x17,2,2,2,2,
2,2,0,2,0,0,0,0,0,2,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,
0,0,0,4,0x17,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,6,5,5,5,5,5,5,5,0,5,5,5,5,
5,5,5,0,5,5,5,5,5,5,5,0,5,5,5,5,
5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,
0,0,0,0,0x17,0x17,0x1c,0x1d,0x1c,0x1d,0x17,0x17,0x17,0x1c,0x1d,0x17,
0x1c,0x1d,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x13,0x17,0x17,0x13,0x17,
0x1c,0x1d,0x17,0x17,0x1c,0x1d,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x17,0x17,
0x17,0x17,0x17,4,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x13,0x13,
0x17,0x17,0x17,0x17,0x13,0x17,0x14,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,0x1b,0x1b,0x17,0x17,0x17,0x14,0x15,0x14,0x15,0x14,0x15,0x14,
0x15,0x13,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,6,6,
6,6,8,8,0x13,4,4,4,4,4,0x1b,0x1b,0x7ca,0xa4a,0xcca,4,
5,0x17,0x1b,0x1b,0xc,0x17,0x17,0x17,0x1b,4,5,0x54a,0x14,0x15,0x14,0x15,
0x14,0x15,0x14,0x15,0x14,0x15,0x1b,0x1b,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,
0x13,0x14,0x15,0x15,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,0,0,6,6,0x1a,
0x1a,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x17,
4,4,4,5,0,0,0,0,0,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,0,0x1b,0x1b,0x58b,0x5cb,0x60b,0x64b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,
0,0,0,0x1b,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1b,0xa8b,0xacb,0xb0b,
0xb4b,0xb8b,0xbcb,0xc0b,0xc4b,0xc8b,0xccb,0xd0b,0xd4b,0xd8b,0xdcb,0xe0b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0xe4b,0xe8b,0xecb,
0xf0b,0xf4b,0xf8b,0xfcb,0x100b,0x104b,0x108b,0x10cb,0x110b,0x114b,0x118b,0x11cb,5,5,5,5,
5,0x685,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x5c5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x685,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0x705,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0x585,5,5,0x705,5,5,5,0x7885,
5,0x605,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0x5c5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0x785,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0x5c5,5,5,5,5,5,5,5,
0x685,5,0x645,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x7b85,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,0x7985,0x7c5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,0x7845,5,5,5,5,5,5,5,5,0x605,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0x685,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0x1e45,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0x5c5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0x5c5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0x7985,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0x7905,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0x5c5,5,0x745,5,0x6c5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0x7c5,5,0x7845,
0xa45,0xcc5,5,5,5,5,5,5,0xf45,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0x605,0x605,0x605,
0x605,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x645,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0x585,5,5,5,5,5,5,5,0x585,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0x585,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0x785,0xa45,5,5,5,5,5,5,5,5,
5,5,5,5,0x585,0x5c5,0x605,5,0x5c5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0x705,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x7c5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0x745,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0x705,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0x545,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0x785,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0x1e45,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0x8005,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0x79c5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0x645,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x7885,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0x5c5,5,5,5,5,0x5c5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0x785,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0x7845,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0x6c5,5,5,5,5,5,0x1e45,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0x6c5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,4,5,5,
5,5,5,5,5,5,5,5,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,
0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,4,0x17,0x17,0x17,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,2,1,2,1,2,4,4,6,6,1,2,1,2,
1,2,1,2,1,2,1,2,1,2,5,6,7,7,7,0x17,
6,6,6,6,6,6,6,6,6,6,0x17,4,5,5,5,5,
5,5,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x54a,6,6,0x17,0x17,
0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,0,0x1a,0x1a,0x1a,0x1a,
0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
0x1a,0x1a,0x1a,4,4,4,4,4,4,4,4,4,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,
4,1,2,5,4,4,2,5,5,5,5,5,0x1a,0x1a,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,2,2,1,2,
1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
4,2,2,2,2,2,2,2,2,1,2,1,2,1,1,2,
1,2,1,2,1,2,1,2,4,0x1a,0x1a,1,2,1,2,5,
1,2,1,2,2,2,1,2,1,2,1,2,1,2,1,2,
1,2,1,1,1,1,1,2,1,1,1,1,1,2,1,2,
1,2,1,2,1,2,1,2,1,1,1,1,2,1,2,1,
1,2,0,0,1,2,0,2,0,2,1,2,1,2,1,2,
1,0,0,0,5,5,6,5,5,5,6,5,5,5,5,6,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,8,8,6,6,8,0x1b,0x1b,0x1b,0x1b,
6,0,0,0,0x34cb,0x344b,0x3ccb,0x37cb,0x35cb,0x3fcb,0x1b,0x1b,0x19,0x1b,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0x17,0x17,0x17,0x17,0,0,0,0,
0,0,0,0,8,8,8,8,6,6,0,0,0,0,0,0,
0,0,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0,8,8,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,8,8,8,8,8,8,8,8,8,8,8,8,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,5,5,5,5,5,5,0x17,0x17,0x17,5,0x17,5,5,6,
5,5,5,5,5,5,6,6,6,6,6,6,6,6,0x17,0x17,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,6,6,6,6,6,6,6,6,6,6,6,8,8,
0,0,0,0,0,0,0,0,0,0,0,0x17,8,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,4,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0x17,0x17,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,
8,8,6,6,6,6,8,8,6,6,8,8,5,5,5,5,
5,6,4,5,5,5,5,5,5,5,5,5,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,5,5,5,5,5,0,5,5,5,5,
5,5,5,5,5,6,6,6,6,6,6,8,8,6,6,8,
8,6,6,0,0,0,0,0,0,0,0,0,5,5,5,6,
5,5,5,5,5,5,5,5,6,8,0,0,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0x17,0x17,0x17,0x17,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,4,5,5,5,
5,5,5,0x1b,0x1b,0x1b,5,8,6,8,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,6,5,6,6,
6,5,5,6,6,5,5,5,5,5,6,6,5,6,5,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,5,5,4,0x17,0x17,5,5,5,5,
5,5,5,5,5,5,5,8,6,6,8,8,0x17,0x17,5,4,
4,8,6,0,0,0,0,0,0,0,0,0,0,5,5,5,
5,5,5,0,0,5,5,5,5,5,5,0,0,5,5,5,
5,5,5,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,0,5,5,5,5,5,5,5,0,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,0x1a,4,4,4,4,2,2,2,2,
2,2,2,2,2,4,0x1a,0x1a,0,0,0,0,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,5,5,5,8,
8,6,8,8,6,8,8,0x17,8,6,0,0,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,5,5,5,5,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0,0,0,0,5,5,5,5,
5,5,5,0,0,0,0,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0x12,0x12,0x12,0x12,
0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x11,0x11,0x11,0x11,
0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,5,5,5,5,
5,5,5,5,5,5,5,0x605,5,5,5,5,5,5,5,0x7c5,
5,5,5,5,0x5c5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0x6c5,5,0x6c5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0x7c5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0x18,5,5,
5,5,5,5,5,5,5,5,5,5,5,0,5,5,5,5,
5,0,5,0,5,5,0,5,5,0,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,2,2,2,2,2,2,2,0,0,0,0,0,
0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,
0,5,6,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0x15,0x14,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0,0,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0x1b,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,0x19,0x1b,0x1b,0x1b,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x14,0x15,0x17,0,0,0,0,0,0,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
0x17,0x13,0x13,0x16,0x16,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,0x15,0x14,
0x15,0x17,0x17,0x14,0x15,0x17,0x17,0x17,0x17,0x16,0x16,0x16,0x17,0x17,0x17,0,
0x17,0x17,0x17,0x17,0x13,0x14,0x15,0x14,0x15,0x14,0x15,0x17,0x17,0x17,0x18,0x13,
0x18,0x18,0x18,0,0x17,0x19,0x17,0x17,0,0,0,0,5,5,5,5,
5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0,0,0x10,0,0,5,5,5,5,5,5,0,0,5,5,
5,5,5,5,0,0,5,5,5,5,5,5,0,0,5,5,
5,0,0,0,0x19,0x19,0x18,0x1a,0x1b,0x19,0x19,0,0x1b,0x18,0x18,0x18,
0x18,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0x10,0x10,0x10,
0x1b,0x1b,0,0,0,0x17,0x17,0x17,0x19,0x17,0x17,0x17,0x14,0x15,0x17,0x18,
0x17,0x13,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,
0x18,0x18,0x18,0x17,0x1a,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0x14,
0x18,0x15,0x18,0x14,0x15,0x17,0x14,0x15,0x17,0x17,5,5,5,5,5,5,
5,5,5,5,4,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,4,4,5,5,5,5,5,5,5,5,
5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
0,0,0,0,0xb00b,0xb80b,0x784b,0x804b,0x884b,0x904b,0x984b,0xa04b,0xa84b,0xb04b,0xb84b,0x788b,
0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,0xb08b,0xb88b,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x17,0x17,0x17,0,0,0,0,0x58b,0x5cb,0x60b,0x64b,0x68b,
0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,
0x900b,0x980b,0xa00b,0xa80b,0x7ca,0x7ca,0x7ca,0x7ca,0x7ca,0xcca,0x11ca,0x11ca,0x11ca,0x11ca,0x1e4a,0x880a,
0x980a,0x980a,0x980a,0x980a,0x980a,0x784a,0x984a,0x68a,0x11ca,0x344b,0x344b,0x388b,0x3ccb,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x54b,0x34cb,0x1b,0x1b,0x1b,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,
0x34ca,0x344a,0x58a,0x68a,0x11ca,0x980a,0x984a,0x988a,0x68a,0x7ca,0x11ca,0x1e4a,0x980a,0x784a,0x984a,0x68a,
0x7ca,0x11ca,0x1e4a,0x980a,0x784a,0x788a,0x988a,0x7ca,0x58a,0x58a,0x58a,0x5ca,0x5ca,0x5ca,0x5ca,0x68a,
0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
6,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,
0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0,0,0,0,
0x58b,0x68b,0x7cb,0x11cb,0,0,0,0,0,0,0,0,0,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0x1bca,5,5,5,5,5,5,5,5,0xb80a,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,6,6,6,6,6,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0x17,
5,5,5,5,0,0,0,0,5,5,5,5,5,5,5,5,
0x17,0x58a,0x5ca,0x7ca,0xa4a,0x1e4a,0,0,0,0,0,0,0,0,0,0,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,0,0,0,0,2,2,2,2,2,2,2,2,
5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0,0,0,0,0,0,0,0,0,0,0,0x17,1,1,1,1,
1,1,1,1,1,1,1,0,1,1,1,1,2,2,0,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,
2,2,2,2,2,2,0,2,2,0,0,0,1,1,1,1,
1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,
1,1,0,2,2,2,2,2,2,2,2,2,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,4,0,4,4,4,4,4,4,
4,4,4,0,0,0,0,0,4,4,4,4,4,4,0,4,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,
5,0,0,0,5,0,0,5,5,5,5,5,5,5,0,0,
5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0,0x17,0x58b,0x5cb,0x60b,0x7cb,
0xa4b,0x1e4b,0x784b,0x788b,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,0x1b,0x1b,0x58b,0x5cb,0x60b,
0x64b,0x68b,0x7cb,0xa4b,0,0,0,0,0,0,0,0x58b,0x5cb,0x60b,0x64b,0x64b,
0x68b,0x7cb,0xa4b,0x1e4b,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,0,5,5,0,0,0,0,0,0x58b,
0x68b,0x7cb,0xa4b,0x1e4b,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0x58b,0x7cb,0xa4b,0x1e4b,0x5cb,0x60b,
0,0,0,0x17,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
0,0,0,0x17,0xa04b,0xa84b,0xb04b,0xb84b,0x788b,0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,0xb08b,
0xb88b,0x78cb,0x80cb,0x88cb,0x90cb,0x98cb,0xa0cb,0xa8cb,0xb0cb,0xb8cb,0x36cb,0x354b,0x34cb,0x348b,0x46cb,0x344b,
0x4ecb,0x388b,0x3ccb,0x454b,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,
0x5ecb,0x344b,5,5,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,
0xf4b,0x11cb,0x144b,0x16cb,0,0,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,0x784b,
0x804b,0x884b,0x904b,0x984b,0x30b,0x34b,0x38b,0x3cb,0x7cb,0xa4b,0x1e4b,0x784b,0x344b,0,0,0,
0,0,0,0,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,
0,0,0,0,5,6,6,6,0,6,6,0,0,0,0,0,
6,6,6,6,5,5,5,5,0,5,5,5,0,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,0,0,6,6,6,0,0,0,0,6,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0x58b,0x11cb,0x17,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0x58b,0x7cb,0xa4b,
5,5,5,5,5,6,6,0,0,0,0,0x58b,0x68b,0x7cb,0xa4b,0x1e4b,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,0x1b,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0,0,0,0x17,0x17,0x17,0x17,0x17,0x17,0x17,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0,0,0x58b,0x5cb,0x60b,0x64b,0x7cb,0xa4b,0x1e4b,0x784b,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
0,0,0,0,0x58b,0x5cb,0x60b,0x64b,0x7cb,0xa4b,0x1e4b,0x784b,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,
0,0,0,0,0,0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,
0,0,0,0,0,0x58b,0x5cb,0x60b,0x64b,0x7cb,0xa4b,0x1e4b,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,
0,0,0,0,0,0,0x58b,0x68b,0x7cb,0x11cb,0x1e4b,0x784b,5,5,5,5,
6,6,6,6,0,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,1,1,1,1,
1,1,0,0,0,6,6,6,6,6,0x13,4,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,
0,0,0,0,0,0,0x18,0x18,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0x249,0x289,5,5,5,5,4,5,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,
0x50b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,
0xa80b,0xb00b,0xb80b,0x344b,0x34cb,0x348b,0x388b,0,5,5,5,5,5,5,5,5,
5,5,0,6,6,0x13,0,0,5,5,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,6,6,6,6,0,0,5,5,
5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0x58b,0x5cb,0x60b,0x64b,0x68b,0x7cb,0xa4b,
0xccb,0x1e4b,0x344b,5,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,
6,6,6,6,6,6,6,6,6,0x58b,0x7cb,0xa4b,0x1e4b,0x17,0x17,0x17,
0x17,0x17,0,0,0,0,0,0,5,5,6,6,6,6,0x17,0x17,
0x17,0x17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,5,5,5,5,5,0x58b,0x5cb,0x60b,
0x64b,0x7cb,0xa4b,0x1e4b,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x784b,0x49,0x89,
0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,6,5,5,6,6,5,0,0,
0,0,0,0,0,0,0,6,8,6,8,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,0x17,
0x17,0x17,0x17,0x17,0x17,0x17,0,0,0,0,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,
0x48b,0x4cb,0x50b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,8,8,8,6,6,6,6,8,
8,6,6,0x17,0x17,0x10,0x17,0x17,0x17,0x17,6,0,0,0,0,0,
0,0,0,0,0,0x10,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
5,5,5,5,5,5,5,6,6,6,6,6,8,6,6,6,
6,6,6,6,6,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,
0x17,0x17,0x17,0x17,5,8,8,5,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,6,0x17,0x17,5,0,0,0,0,0,0,0,0,0,
8,5,5,5,5,0x17,0x17,0x17,0x17,6,6,6,6,0x17,8,6,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,5,0x17,5,0x17,0x17,0x17,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,8,8,8,6,6,6,6,6,6,6,6,6,8,
0,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,
0x16cb,0x194b,0x1bcb,0x1e4b,0x784b,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,6,
6,6,8,8,6,8,6,6,0x17,0x17,0x17,0x17,0x17,0x17,6,5,
5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,0,5,0,5,5,5,5,0,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,
5,5,5,5,5,0x17,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,6,
6,6,6,6,6,6,6,0,0,0,0,0,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,5,5,8,8,
0,0,6,6,6,6,6,6,6,0,0,0,6,6,6,6,
6,0,0,0,0,0,0,0,0,0,0,0,6,6,8,8,
0,5,5,5,5,5,5,5,5,0,0,5,5,0,0,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
5,5,5,5,5,0,5,5,0,5,5,5,5,5,0,6,
6,5,8,8,6,8,8,8,8,0,0,8,8,0,0,8,
8,8,0,0,5,0,0,0,0,0,0,8,0,0,0,0,
0,5,5,5,0,6,6,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,5,
0,0,5,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,0,5,8,8,8,6,
6,6,6,6,6,0,8,0,0,8,0,8,8,8,8,0,
8,8,6,8,6,5,6,5,0x17,0x17,0,0x17,0x17,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,8,8,8,6,6,6,6,
6,6,6,6,8,8,6,6,6,8,6,5,5,5,5,0x17,
0x17,0x17,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x17,0x17,
0,0x17,6,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,8,8,8,6,6,6,6,6,6,8,6,8,
8,8,8,6,6,8,6,6,5,5,0x17,5,0,0,0,0,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,8,8,8,6,6,6,6,0,0,8,8,8,8,
6,6,8,6,6,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,5,5,5,5,
6,6,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,8,8,8,6,6,6,6,6,6,6,6,8,
8,6,8,6,6,0x17,0x17,0x17,5,0,0,0,0,0,0,0,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,
0x17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x49,0x89,
0xc9,0x109,0x149,0x189,5,5,5,5,5,5,5,5,5,5,5,6,
8,6,8,8,6,6,6,6,6,6,8,6,5,0x17,0,0,
0,0,0,0,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,8,8,6,6,6,6,8,6,6,6,6,6,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x7cb,0xa4b,
0x17,0x17,0x17,0x1b,5,5,5,5,5,5,5,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,
0,6,8,6,5,5,5,5,5,5,5,5,5,5,5,5,
8,8,8,6,6,6,6,6,6,6,6,6,8,6,6,0x17,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x7cb,0xa4b,
0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0,0,0,0,0,0,0,0,0,
0,0,0,5,8,5,8,6,0x17,0x17,0x17,0,0,0,0,0,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0,5,5,5,5,5,5,5,0,0,5,0,0,
5,5,5,5,5,5,5,5,0,5,5,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,8,
8,8,0,8,8,0,0,6,6,8,6,5,6,5,0x17,5,
8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,0,0,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,8,8,8,
6,6,6,6,0,0,6,6,8,8,8,8,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,
6,6,6,6,6,8,5,6,6,6,6,0x17,0x17,0x17,0x17,0x17,
0x17,0x17,0x17,6,0,0,0,0,0,0,0,0,5,6,6,6,
6,6,6,8,8,6,6,6,5,5,5,5,5,6,6,6,
6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0x17,0x17,0x17,0,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,
6,6,6,6,6,6,6,6,6,6,6,8,6,6,0x17,0x17,
0x17,5,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5,0x17,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0,5,0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x58b,0x5cb,
0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,
0x1e4b,0,0,0,0x17,0x17,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,
6,6,6,6,6,6,6,0,6,6,6,6,6,6,8,6,
6,6,6,6,6,6,6,6,0,8,6,6,6,6,6,6,
6,8,6,6,8,6,6,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0,0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,5,6,0,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,5,5,5,5,
5,5,5,0,5,5,0,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,
6,6,6,0,0,0,6,0,6,6,0,6,5,5,5,5,
5,5,5,5,5,5,8,8,8,8,8,0,6,6,0,8,
8,6,8,6,5,0,0,0,0,0,0,0,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
5,5,0,5,5,0,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,
6,8,8,0x17,0x17,0,0,0,0,0,0,0,6,8,6,0x17,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,6,0,0,0,0,0,6,6,5,8,
5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,8,8,6,6,6,6,6,0,0,0,8,8,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x19,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,0x17,
0xcd0b,0xcc0b,0xcb0b,0xd00b,0xca0b,0xcf0b,0xcb4b,0xd04b,0xc90b,0x37cb,0x37cb,0x364b,0x35cb,0xc94b,0x3fcb,0x350b,
0x34cb,0x344b,0x344b,0x3ccb,0xcd0b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x19,0x19,0x19,
0x34ca,0x354a,0x34ca,0x34ca,0x344a,0x348a,0x388a,0xf4a,0x11ca,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0,
0x17,0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,0,0,0,0,
0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x64a,
0x68a,0x6ca,0x70a,0x74a,0x78a,0x58a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x58a,0x5ca,
0x60a,0x64a,0x68a,0x5ca,0x60a,0x60a,0x64a,0x68a,0x6ca,0x70a,0x74a,0x78a,0x58a,0x5ca,0x60a,0x60a,
0x64a,0x68a,0xc08a,0xc18a,0x58a,0x5ca,0x60a,0x60a,0x64a,0x68a,0x60a,0x60a,0x64a,0x64a,0x64a,0x64a,
0x6ca,0x70a,0x70a,0x70a,0x74a,0x74a,0x78a,0x78a,0x78a,0x78a,0x5ca,0x60a,0x64a,0x68a,0x6ca,0x58a,
0x5ca,0x60a,0x64a,0x64a,0x68a,0x68a,0x5ca,0x60a,0x58a,0x5ca,0x348a,0x388a,0x454a,0x348a,0x388a,0x35ca,
5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0x17,0x17,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
6,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,0,
6,6,6,6,6,6,6,6,6,6,8,8,8,6,6,6,
0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0,0,6,6,6,6,6,0x17,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,6,6,6,6,6,6,6,0x17,0x17,0x17,0x17,0x17,
0x1b,0x1b,0x1b,0x1b,4,4,4,4,0x17,0x1b,0,0,0,0,0,0,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0x7cb,
0x1e4b,0x788b,0x790b,0x798b,0x7a0b,0x7a8b,0,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,
0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,
4,0x17,0x17,0x17,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0,4,4,4,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0x54b,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0x80b,
0x84b,0x88b,0x8cb,0x90b,0x94b,0x98b,0x9cb,0xa0b,0x58b,0x5cb,0x60b,0x17,0x17,0x17,0x17,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,0,
0,0,0,6,5,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
8,8,8,8,8,8,8,8,0,0,0,0,0,0,0,6,
6,6,6,4,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,0x17,4,6,0,0,0,0,0,0,0,0,0,0,0,
8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,4,4,4,4,0,4,4,4,
4,4,4,4,0,4,4,0,5,5,5,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,0,
0,5,0,0,0,0,0,0,0,0,0,0,5,5,5,5,
0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,0,0,
0x1b,6,6,0x17,0x10,0x10,0x10,0x10,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,0,0,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,0,0,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,8,8,6,
6,6,0x1b,0x1b,0x1b,8,8,8,8,8,8,0x10,0x10,0x10,0x10,0x10,
0x10,0x10,0x10,6,6,6,6,6,6,6,6,0x1b,0x1b,6,6,6,
6,6,6,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,6,6,6,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,6,6,6,0x1b,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x54b,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0x80b,0x84b,0x88b,0x8cb,0x90b,
0x94b,0x98b,0x9cb,0xa0b,0,0,0,0,0,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,
0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,0xccb,0xf4b,0x11cb,0x144b,0x16cb,
0x194b,0x1bcb,0x58b,0x5cb,0x60b,0x64b,0x68b,0x58b,0x68b,0,0,0,0,0,0,0,
0x249,0x289,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x49,0x89,0xc9,0x109,
0x149,0x189,0x1c9,0x209,0x249,0x289,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,
2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,1,0,1,1,0,0,1,0,0,1,1,0,
0,1,1,1,1,0,1,1,1,1,1,1,1,1,2,2,
2,2,0,2,0,2,2,2,2,2,2,2,0,2,2,2,
2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,2,2,2,2,1,1,0,1,
1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,
1,1,1,1,1,0,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,0,
0,0,1,1,1,1,1,1,1,0,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,2,2,2,2,2,2,0,0,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,0x18,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,0x18,2,2,2,2,2,2,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,0x18,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,0x18,2,2,2,2,2,2,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
2,2,2,0x18,2,2,2,2,2,2,1,2,0,0,0x49,0x89,
0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,
0,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,0x1b,0x1b,0x1b,0x1b,6,6,6,6,6,
6,6,6,6,6,6,6,6,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,6,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,6,0x1b,0x1b,0x17,
0x17,0x17,0x17,0x17,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,6,6,6,6,6,6,6,6,0,6,6,6,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,0,0,6,
6,6,6,6,2,2,2,2,2,2,2,2,2,2,5,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,0,0,0,0,0,0,2,2,2,2,2,2,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,6,6,0,6,6,0,6,6,6,6,6,0,
0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,
4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,5,0x1b,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,0,0,0,6,6,6,6,6,6,6,4,4,4,4,4,
4,4,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
6,6,6,6,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0x19,5,5,5,5,5,5,5,5,5,5,5,4,
6,6,6,6,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,6,6,5,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,
0,0,0,0x17,5,5,5,5,5,5,5,0,5,5,5,5,
0,5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,0,5,5,5,5,5,0,0,0x58b,0x5cb,0x60b,0x64b,0x68b,
0x6cb,0x70b,0x74b,0x78b,6,6,6,6,6,6,6,0,0,0,0,0,
0,0,0,0,2,2,2,2,6,6,6,6,6,6,6,4,
0,0,0,0,0x49,0x89,0xc9,0x109,0x149,0x189,0x1c9,0x209,0x249,0x289,0,0,
0,0,0x17,0x17,1,1,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,
0xccb,0xf4b,0x11cb,0x144b,0x78cb,0x794b,0x814b,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,
0x1b,0x34cb,0x344b,0x3ccb,0x19,0x58b,0x5cb,0x788b,0x78cb,0,0,0,0,0,0,0,
0,0,0,0,0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,
0x784b,0x804b,0x884b,0x904b,0x984b,0xa04b,0xa84b,0xb04b,0xb84b,0x788b,0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,
0xb08b,0xb88b,0x78cb,0x80cb,0x984b,0xa04b,0xa84b,0xb04b,0xb84b,0x788b,0x808b,0x888b,0x908b,0x988b,0xa08b,0xa88b,
0xb08b,0xb88b,0x1b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0x900b,0xa00b,0x804b,0x788b,
0x344b,0x354b,0,0,0,0x58b,0x5cb,0x60b,0x64b,0x68b,0x6cb,0x70b,0x74b,0x78b,0x7cb,0xa4b,
0xccb,0xf4b,0x11cb,0x144b,0x16cb,0x194b,0x1bcb,0x1e4b,0x800b,0x880b,0x900b,0x980b,0xa00b,0xa80b,0xb00b,0xb80b,
0x784b,0x804b,0x884b,0x904b,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x18,0x18,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,5,5,5,5,0,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,0,5,5,0,5,0,0,5,0,5,5,5,
5,5,5,5,5,5,5,0,5,5,5,5,0,5,0,5,
0,0,0,0,0,0,5,0,0,0,0,5,0,5,0,5,
0,5,5,5,0,5,5,0,5,0,0,5,0,5,0,5,
0,5,0,5,0,5,5,0,5,0,0,5,5,5,5,0,
5,5,5,5,5,5,5,0,5,5,5,5,0,5,5,5,
5,0,5,0,5,5,5,5,5,5,5,5,5,5,0,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0,0,0,0,0,5,5,5,0,5,5,5,5,5,0,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x2cb,0x2cb,0x30b,0x34b,0x38b,0x3cb,0x40b,0x44b,0x48b,0x4cb,0x50b,0x54b,
0x54b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,
0,0,0,0,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1a,
0x1a,0x1a,0x1a,0x1a,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,
0x1b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0,0,0,0,0x1b,0x1b,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,
0,0,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,0x1b,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0x1b,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0,0,0,0,0,0,0,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1b,0x1b,0x1b,0,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
5,0x705,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x645,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x645,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,0x685,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0xcc5,
5,5,5,5,5,5,5,5,0xf45,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,0xf45,5,5,5,5,5,5,5,
5,5,5,5,5,5,0x6c5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,0x605,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,0x605,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x605,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x605,
5,5,5,5,5,5,5,5,5,5,5,5,5,0x645,5,5,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x785,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
0,0x10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0,0,
0,0,0,0
};

static const UTrie2 propsTrie={
    propsTrie_index,
    propsTrie_index+4748,
    nullptr,
    4748,
    19048,
    0xa40,
    0x130c,
    0x0,
    0x0,
    0x110000,
    0x5cf0,
    nullptr, 0, false, false, 0, nullptr
};

static const uint16_t propsVectorsTrie_index[32324]={
0x51d,0x525,0x52d,0x535,0x54d,0x555,0x55d,0x565,0x56d,0x575,0x57d,0x585,0x58d,0x595,0x59d,0x5a5,
0x5ac,0x5b4,0x5bc,0x5c4,0x5cc,0x5d4,0x5dc,0x5e4,0x5ec,0x5f4,0x5fc,0x604,0x60c,0x614,0x61c,0x624,
0x62c,0x634,0x63b,0x643,0x64b,0x653,0x65b,0x663,0x66b,0x673,0x678,0x680,0x687,0x68f,0x697,0x69f,
0x6a7,0x6af,0x6b7,0x6bf,0x6c6,0x6ce,0x6d6,0x6de,0x6e6,0x6ee,0x6f6,0x6fe,0x706,0x70e,0x716,0x71e,
0x1b20,0x726,0x72e,0x736,0x73c,0x1c5c,0x1e3e,0x1ca0,0x1553,0x1559,0x1561,0x154b,0x744,0x74a,0x752,0x75a,
0x762,0x768,0x770,0x778,0x780,0x786,0x78e,0x796,0x79e,0x7a4,0x7ac,0x7b4,0x7bc,0x7c4,0x7cc,0x7d3,
0x7db,0x7e1,0x7e9,0x7f1,0x7f9,0x7ff,0x807,0x80f,0x817,0x15b0,0x81f,0x827,0x82f,0x836,0x83e,0x846,
0x84e,0x852,0x85a,0x53d,0x862,0x86a,0x872,0x53d,0x16c2,0x16ca,0x87a,0x882,0x88a,0x892,0x89a,0x53d,
0x174e,0x1746,0x173e,0x1a39,0x1a31,0x1571,0x8a2,0x1569,0x1650,0x1650,0x1652,0x158d,0x158e,0x1581,0x1583,0x1585,
0x1708,0x170a,0x8aa,0x170a,0x8b2,0x8b7,0x8bf,0x170f,0x8c5,0x170a,0x8cb,0x8d3,0x8db,0x1700,0x1700,0x8e3,
0x1766,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,
0x1767,0x1767,0x1767,0x175e,0x8eb,0x1756,0x1756,0x8f3,0x8fb,0x903,0x90b,0x913,0x171f,0x1717,0x91b,0x923,
0x92b,0x1727,0x172f,0x933,0x1736,0x93b,0x1ac0,0x93f,0x947,0x94f,0x957,0x95c,0x1967,0x964,0x96b,0x18d3,
0x973,0x1af8,0x97b,0x983,0x98b,0x993,0x99b,0x53d,0x19bf,0x19c4,0x9a3,0x19b7,0x1a90,0x1a88,0x1b8c,0x9ab,
0x1a58,0x9b3,0x9bb,0x1a75,0x9c3,0x9c7,0x9cf,0x9d7,0x18db,0x18bb,0x18cb,0x18c3,0x1943,0x193b,0x198f,0x19e1,
0x15a6,0x15a6,0x15a6,0x15a6,0x1596,0x15a6,0x15a6,0x15a8,0x9df,0x1579,0x9e3,0x9eb,0x1579,0x9f3,0x9fb,0xa03,
0x139e,0x1396,0x13d6,0xa0b,0xa13,0x13be,0x12fc,0xa1b,0x13ae,0x13b6,0x13ce,0x159e,0xa23,0x13e6,0x13ed,0x13f5,
0x147c,0x1484,0x148c,0x1494,0x149c,0x14a3,0x14ab,0x14b3,0x13fd,0x1405,0x1408,0x140a,0x16f8,0x1852,0x1858,0x199f,
0x1408,0x1315,0x131d,0x15c0,0x15c5,0x15c8,0x15ce,0x13c6,0x15d6,0x15d6,0x1412,0x13de,0x1416,0x141e,0x1426,0x142e,
0x1436,0x143e,0x1446,0x144e,0x1860,0x18ab,0x1a0b,0x1b6c,0x1456,0x145c,0x1464,0x146c,0x13a6,0x1474,0x1868,0x186f,
0x176f,0x176f,0x176f,0x176f,0x176f,0x176f,0x176f,0x176f,0x1873,0x1873,0x1873,0x1873,0x187b,0x1873,0x1882,0x1889,
0x1891,0x1873,0x1873,0x1895,0x1873,0x1873,0x189b,0x1873,0x18b3,0x19a7,0x19fb,0x1325,0x132b,0x1cd6,0x1cde,0x1d86,
0x1957,0x194b,0x194f,0x19af,0x1913,0x1913,0x1913,0xa2b,0x191b,0xa33,0x196f,0xa3a,0xa42,0xa4a,0xa4a,0x1aa0,
0x190b,0x1a03,0x1333,0x133b,0xa52,0x177f,0x177f,0xa5a,0x1787,0x1787,0x1787,0x1787,0x1787,0x1787,0xa62,0xa68,
0x1603,0x15b8,0xa70,0x1669,0xa78,0x1687,0x168f,0x1697,0xa80,0xa85,0x165a,0x1661,0xa8a,0x1777,0x1987,0xa92,
0xa9a,0x169f,0x16a6,0x160b,0x16b6,0x16ba,0x1671,0x1675,0x167d,0x167d,0x167f,0x161b,0x1623,0x1623,0x1624,0x16ae,
0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,
0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,
0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,
0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,
0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,
0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,
0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,
0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,
0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,
0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,
0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,
0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,
0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x178f,0x1792,0x18f3,0x18f3,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1648,0x1a98,0x1e76,
0x17a2,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,
0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,0x17a8,
0x17a8,0x17a8,0x17a8,0x17a8,0xaa2,0x179a,0xaaa,0x1b3c,0x1a65,0x1a65,0x1a65,0x1a65,0x1a65,0x1a65,0x1a65,0x1a65,
0x1a60,0xab2,0x1a1b,0x1a13,0x1a1d,0x1b34,0x1b34,0xaba,0x1903,0x1997,0x1a25,0x1a29,0x19f3,0x1b84,0xac2,0xaca,
0x195f,0xad2,0x19cc,0xada,0x1a7d,0x1a80,0xae2,0x1ab0,0x1a49,0x1a50,0xaea,0xaf2,0x1ae4,0x1ae8,0xafa,0xb02,
0x1a41,0xb0a,0xb12,0x1ab8,0x1b28,0x1b2c,0xb1a,0xb22,0xb2a,0xb32,0x1cce,0xb3a,0x1d8e,0x1d8e,0x1b00,0xb42,
0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,
0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,
0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,
0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,
0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,
0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,
0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,
0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,
0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,
0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,
0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,
0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,
0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,
0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,
0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,
0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,
0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,
0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,
0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,
0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,
0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,
0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0x16f0,0x16ea,0x16eb,0x16ec,0x16ed,0x16ee,0x16ef,0xb4a,0xb51,0xb54,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,
0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,
0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,
0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,
0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,
0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,
0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,
0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,
0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,
0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,
0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,
0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,
0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x15de,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,
0x1631,0x1639,0x18a3,0x1343,0x197f,0x197f,0x1347,0x134e,0xb5c,0xb64,0xb6c,0x14d3,0x14da,0x14e2,0xb74,0x14ea,
0x153b,0x153b,0x14bb,0x14c3,0x14f2,0x1532,0x1533,0x1543,0x14fa,0x14ff,0x1507,0x150f,0xb7c,0x1517,0xb84,0x14cb,
0xb8c,0x1613,0xb94,0xb9c,0x151f,0x1525,0x152a,0xba4,0xbac,0x15f3,0x15fb,0x15e6,0x15eb,0xbb4,0xbbc,0xbc4,
0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,0x16d2,
0x14f4,0x14f4,0x1534,0x1574,0x15b4,0x15f4,0x1634,0x1674,0x16b0,0x16f0,0x1730,0x1770,0x17b0,0x17f0,0x1830,0x1870,
0x18b0,0x18ec,0x192c,0x196c,0x19ac,0x19e0,0x1a1c,0x1a5c,0x1a9c,0x1adc,0x1b18,0x1b58,0x1b98,0x1bd8,0x1c18,0x1c58,
0xa80,0xac0,0xb00,0xb40,0xb80,0xbab,0xbeb,0x1432,0xc0e,0xa40,0xa40,0xa40,0xc46,0xc86,0x1332,0x1332,
0xcc6,0xd06,0xa40,0xa40,0xa40,0xd2f,0xd6f,0xd8f,0xa40,0xdb5,0xdf5,0xe35,0xe75,0xeb5,0xf75,0xef5,
0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,
0x1272,0x1272,0x1272,0x1272,0x1005,0x12b2,0x103d,0x107d,0x12f2,0x1088,0x1372,0x1372,0x1372,0x10be,0x10f1,0x1131,
0x13b2,0x13b2,0x1171,0x13f2,0x1194,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,
0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x10f1,0x11b2,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xf35,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xf35,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xf35,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xf35,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xf35,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xf35,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xf35,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xf35,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xf35,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xf35,
0xfb5,0xfc5,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,
0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xa40,0xf35,
0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,
0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x11f2,
0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,
0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x1232,0x11f2,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0xbcc,0xbd3,0xbdb,0x53d,0x18e3,0x18e3,0x18e3,0xbe3,0xbeb,0xbee,0x1933,0x1923,0xbf6,0xbfe,0xc02,0xc06,
0x53d,0x53d,0x53d,0x53d,0xc0e,0x1a6d,0xc16,0xc1e,0x182f,0xc26,0xc2c,0xc30,0xc38,0x1977,0xc40,0x53d,
0x1827,0x181a,0x181f,0x18eb,0xc48,0xc50,0xc54,0xc5a,0x1d0e,0xc62,0x1d5e,0xc69,0xc6d,0xc75,0x1f88,0xc7d,
0x1cf6,0x1cf6,0x1cf6,0x1cf6,0x1cf6,0x1cf6,0x1cf6,0x1cf6,0x1cf6,0xc85,0xc8d,0xc95,0xc9d,0xca1,0x53d,0x53d,
0xca9,0xcac,0xcb4,0x1d26,0xcbc,0xcc4,0x53d,0xccc,0xcd4,0xcdc,0x53d,0x53d,0x1c64,0xce4,0xcec,0x1dc5,
0xcf4,0xcfb,0xd03,0x1b44,0x1d1e,0x53d,0x1cfe,0xd0b,0x1b08,0xd13,0xd1b,0xd23,0xd2b,0xd33,0x53d,0x53d,
0x1af0,0x1af0,0xd3b,0x53d,0x1d9e,0xd43,0x1d96,0xd4b,0x1eb7,0xd53,0x1f68,0xd5b,0xd62,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0xd6a,0x1efd,0xd72,0xd7a,0xd7c,0x1ebf,0xd84,0xd8b,0xd92,0xd9a,0xd9e,0xda5,0xdad,
0x1b94,0x1b96,0xdb5,0xdbc,0x1b18,0x1b10,0xdc4,0xdca,0x1c7c,0xdd2,0xdda,0xdde,0x1c8c,0x1c90,0x1c84,0xde6,
0xdee,0x1d46,0xdf6,0x53d,0xdfe,0xe06,0x1d2e,0xe0e,0xe16,0xe1c,0xe24,0xe2c,0xe34,0xe39,0xe41,0xe49,
0x1e2a,0x1e22,0xe51,0xe59,0x1d56,0x1d4e,0xe61,0x53d,0x53d,0x53d,0x53d,0x53d,0x1d7e,0xe69,0xe71,0x53d,
0x1d6e,0x1d66,0xe79,0xe81,0x1c98,0xe89,0xe91,0xe98,0xea0,0xea8,0xeb0,0x53d,0x53d,0x53d,0x53d,0x53d,
0x1e9f,0xeb8,0x53d,0x53d,0x53d,0x1d3e,0x1d36,0xec0,0xec8,0xece,0xed6,0x53d,0x53d,0xede,0xee2,0xeea,
0x1e5e,0x1e56,0xef2,0x1e4e,0x1e46,0xefa,0x1d76,0xf02,0xf0a,0x53d,0x53d,0x53d,0x53d,0x53d,0x1f80,0xf12,
0xf1a,0xf1f,0xf27,0xf2e,0xf33,0xf39,0x53d,0x53d,0xf41,0xf45,0xf4d,0xf55,0xf5b,0xf63,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0xf6b,0xf73,0xf78,0xf80,0x53d,0x53d,0xf87,0x1ed7,0xf8f,
0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,
0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d4,0x19d9,0xf97,0x53d,0x53d,0x53d,
0x19d4,0x19d4,0x19d4,0xf9f,0x1da6,0x1da6,0x1da6,0x1da6,0x1da6,0x1da6,0xfa7,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0xfab,0x1f25,0x1f25,0xfaf,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ac8,
0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1aca,0x1ac8,0x1ad2,
0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ad5,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1ac8,0x1adc,0xfb7,0x1f60,0x1f60,
0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,
0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0xfbf,0x1dcd,0x1dcd,
0x1dcd,0x1dcd,0x1dcd,0x1dcd,0x1dcd,0x1dcd,0x1dcd,0x1dcd,0x1dcd,0x1dcd,0x1dcd,0x1dcd,0x1dd2,0x1dcd,0x1dcd,0x1dcd,
0xfc7,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x1f70,0xfcf,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x1b9e,0x1b9e,0x1b9e,0x1b9e,0x1b9e,0x1b9e,0x1b9e,0x1b9e,0x1b9e,0x1b9e,
0x1b9e,0x1b9e,0x1b9e,0x1b9e,0x1b9e,0x1b9e,0x1b9e,0xfd7,0xfdf,0xfe7,0x1f2d,0xfeb,0xff3,0xff8,0x1cee,0x1ce6,
0x1000,0x1008,0x1010,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x1f78,0x1018,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x1eaf,0x1ea7,0x1020,0x53d,0x53d,0x53d,0x1c74,0x1c74,
0x1028,0x1c6c,0x1030,0x53d,0x53d,0x1038,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,
0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,
0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,
0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,
0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1040,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,
0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e36,0x1f15,0x1f15,
0x1f15,0x1f15,0x1f15,0x1f15,0x1f15,0x1f15,0x1f15,0x1f15,0x1f15,0x1f15,0x1f15,0x1f15,0x1048,0x104e,0x1056,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x105a,0x1c54,
0x1e86,0x1e86,0x1e86,0x1e86,0x1e86,0x1e86,0x1e86,0x1e87,0x1062,0x1067,0x106e,0x1e8f,0x1e8f,0x1e8f,0x1e8f,0x1e8f,
0x1e8f,0x1e8f,0x1e8f,0x1e8f,0x1e8f,0x1e8f,0x1072,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x1d06,
0x1d06,0x1d06,0x107a,0x107f,0x1087,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x1f55,0x1f55,0x1f55,0x1f55,0x1f55,0x1f55,0x1f58,0x108f,0x1f55,0x1f55,0x1f55,
0x1f55,0x1f55,0x1f55,0x1f55,0x1f55,0x1f55,0x1f55,0x1f55,0x1f55,0x1f55,0x1097,0x53d,0x53d,0x1f35,0x109f,0x10a6,
0x1f1d,0x1f1d,0x1f1d,0x10ad,0x53d,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x17b8,0x10b5,0x17b8,0x10bd,0x17b9,
0x17b0,0x17c1,0x17c7,0x17cf,0x10c5,0x192b,0x192b,0x10cd,0x53d,0x53d,0x53d,0x10d5,0x10dd,0x18f3,0x18f3,0x10e5,
0x10ed,0x53d,0x53d,0x53d,0x53d,0x1800,0x1807,0x10f5,0x180a,0x10fd,0x1105,0x110d,0x1804,0x1115,0x111d,0x1125,
0x1809,0x1811,0x1800,0x1807,0x1803,0x180a,0x1812,0x1801,0x1808,0x1804,0x112c,0x17d7,0x17df,0x17e6,0x17ed,0x17da,
0x17e2,0x17e9,0x17f0,0x1134,0x17f8,0x1dae,0x1dae,0x1dae,0x1dae,0x1dae,0x1dae,0x1dae,0x1dae,0x1dae,0x1dae,0x1dae,
0x1dae,0x1dae,0x1dae,0x1dae,0x1dae,0x1dfa,0x1db6,0x1dfa,0x1dbd,0x113c,0x1144,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x114c,0x1154,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x115c,0x1164,0x1f3d,0x116c,0x1171,0x53d,0x53d,0x53d,0x1edf,0x1179,0x1181,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x1185,0x118a,0x1ee7,0x1192,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x119a,0x119f,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x11a6,0x11ab,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x11b3,0x1d16,0x1d16,0x1d16,0x1d16,0x1d16,0x1d16,0x11bb,0x53d,0x1e1a,0x1e12,0x11c3,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x11cb,0x1e97,0x11d0,0x53d,0x53d,0x11d8,0x11d9,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x11e1,0x11e9,0x11f1,0x11f9,0x1201,0x1209,0x53d,0x1210,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x1218,0x1cb7,0x121e,0x1cb7,0x1226,0x122b,0x1233,0x53d,0x1dda,0x1e02,0x1e0a,
0x1e66,0x1de2,0x1ec7,0x1dea,0x1e6e,0x1ecf,0x1ecf,0x12cd,0x12d5,0x12dd,0x1f05,0x12e5,0x12ed,0x1eef,0x1eef,0x1eef,
0x1eef,0x123b,0x1eef,0x1ef5,0x1243,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,
0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,0x127a,
0x127a,0x127a,0x127a,0x127a,0x12f4,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,0x53d,
0x53d,0x53d,0x53d,0x53d,0x124a,0x19e9,0x1252,0x19eb,0x19eb,0x1256,0x125e,0x1266,0x126e,0x1b54,0x1aa8,0x1b5c,
0x1b64,0x1b4c,0x1276,0x127a,0x1281,0x1289,0x128d,0x1295,0x129d,0x127a,0x127a,0x127a,0x127a,0x1bc5,0x1bcd,0x1bc5,
0x1bd3,0x1bdb,0x1ba6,0x1be3,0x1beb,0x1bc5,0x1bf3,0x1bfb,0x1c02,0x1c0a,0x1bae,0x1bc5,0x1c0f,0x1bb6,0x1bbd,0x1c17,
0x1c1d,0x1cbf,0x1cc6,0x1ca8,0x1c24,0x1c2c,0x1c34,0x1c3c,0x1cb0,0x1bc5,0x1c44,0x12a5,0x12ad,0x1b7c,0x1b7c,0x1b7c,
0x12b5,0x1cb7,0x1cb7,0x12bd,0x12c5,0x1304,0x184a,0x184a,0x184a,0x1305,0x1305,0x1305,0x1305,0x18fb,0x18fb,0x18fb,
0x18fb,0x18fb,0x18fb,0x18fb,0x130d,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,
0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,
0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,
0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,0x1305,
0x1305,0x1305,0x1305,0x1305,0x1305,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,
0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,
0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,
0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x1842,0x134e,0x1b74,0x1b74,0x1b74,
0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,
0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,
0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,
0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1356,0x1c4c,0x1c4c,0x1c4c,0x1c4c,0x1c4c,0x1c4c,0x135e,0x1df2,0x1df2,
0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1366,0x1e7e,0x1e7e,
0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,
0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x136e,0x1f4d,0x1f4d,
0x1f4d,0x1f4d,0x1f4d,0x1f4d,0x1f4d,0x1f4d,0x1f4d,0x1f4d,0x1f4d,0x1f4d,0x1f4d,0x1f4d,0x1f4d,0x1f4d,0x1f4d,0x1f4d,
0x1372,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,
0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,
0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,
0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,
0x134e,0x1837,0x1837,0x1837,0x1837,0x1837,0x1837,0x1837,0x1837,0x1837,0x1837,0x1837,0x1837,0x1837,0x1837,0x1837,
0x1837,0x137a,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,
0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,
0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,
0x1382,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,
0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x138a,0x1f45,0x1f45,0x1f45,0x1f45,
0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,
0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,
0x1f45,0x138e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,
0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,
0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,
0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,0x134e,
0x134e,0x1382,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,
0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,
0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,
0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,
0x16e2,0x16da,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,
0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,
0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,
0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,0x16e2,
0x16e2,0x16e2,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,
0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,
0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,
0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,0x183f,
0x183f,0x183f,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,
0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,
0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,
0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,0x1b74,
0x1b74,0x1b74,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,0x1df2,
0x1df2,0x1df2,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,
0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,
0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,
0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,0x1e32,
0x1e32,0x1e32,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,
0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,
0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,
0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,0x1e7e,
0x1e7e,0x1e7e,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,
0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,
0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,
0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,0x1f0d,
0x1f0d,0x1f0d,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,
0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,
0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,
0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,0x1f45,
0x1f45,0x1f45,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,
0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,
0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,
0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,0x1f60,
0x1f60,0x1f60,0x51c,0x51c,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0xf3,0xff,0xf9,
0xf9,0xfc,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
0x12,0x12,0x12,0x12,0x43e,0x438,0x41d,0x405,0x411,0x40e,0x405,0x420,0x40b,0x417,0x405,0x42f,
0x423,0x41a,0x43b,0x414,0x402,0x402,0x402,0x402,0x402,0x402,0x402,0x402,0x402,0x402,0x426,0x423,
0x429,0x429,0x429,0x438,0x405,0x44a,0x44a,0x44a,0x44a,0x44a,0x44a,0x444,0x444,0x444,0x444,0x444,
0x444,0x444,0x444,0x444,0x444,0x444,0x444,0x444,0x444,0x444,0x444,0x444,0x444,0x444,0x444,0x40b,
0x411,0x417,0x435,0x3ff,0x432,0x447,0x447,0x447,0x447,0x447,0x447,0x441,0x441,0x441,0x441,0x441,
0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x441,0x40b,
0x42c,0x408,0x429,0x12,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x12,0x12,0x12,0x12,0x12,0x102,0x12,0x12,0x12,0x12,0x12,0x12,
0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
0x12,0x12,0x12,0x12,0x4b,0x30f,0x40e,0x411,0x315,0x411,0x405,0x306,0x2fa,0xa5,0x366,0xcc,
0x429,0x2d6,0x309,0x3fc,0x312,0x33f,0x2e8,0x2e8,0x2fd,0x84,0x306,0x384,0x2fa,0x2e8,0x366,0xcc,
0x2e2,0x2e2,0x2e2,0x30f,0x23d,0x23d,0x23d,0x23d,0x23d,0x23d,0x37b,0x23d,0x23d,0x23d,0x23d,0x23d,
0x23d,0x23d,0x23d,0x23d,0x37b,0x23d,0x23d,0x23d,0x23d,0x23d,0x23d,0x336,0x37b,0x23d,0x23d,0x23d,
0x23d,0x23d,0x37b,0x375,0x378,0x378,0x237,0x237,0x237,0x237,0x375,0x237,0x378,0x378,0x378,0x237,
0x378,0x378,0x237,0x237,0x375,0x237,0x378,0x378,0x237,0x237,0x237,0x336,0x375,0x378,0x378,0x237,
0x378,0x237,0x375,0x237,0x23d,0x378,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,
0x23d,0x237,0x23d,0x237,0x23a,0x375,0x23d,0x378,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x378,
0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x37b,0x375,0x23d,0x237,0x23d,0x378,
0x23d,0x237,0x23d,0x237,0x23d,0x375,0x372,0x36f,0x23d,0x237,0x23d,0x237,0x375,0x23d,0x237,0x23d,
0x237,0x23d,0x237,0x372,0x36f,0x37b,0x375,0x23d,0x378,0x23d,0x237,0x23d,0x378,0x37e,0x37b,0x375,
0x23d,0x378,0x23d,0x237,0x23d,0x237,0x37b,0x375,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,
0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x37b,0x375,0x23d,0x237,0x23d,0x378,
0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x23d,0x237,0x23d,
0x237,0x23d,0x237,0x22b,0x216,0x225,0x225,0x222,0x225,0x222,0x225,0x225,0x222,0x225,0x225,0x225,
0x222,0x21c,0x225,0x23a,0x225,0x225,0x222,0x225,0x225,0x222,0x225,0x225,0x225,0x222,0x222,0x222,
0x225,0x225,0x222,0x225,0x23d,0x237,0x225,0x222,0x225,0x222,0x225,0x225,0x222,0x225,0x21c,0x21c,
0x225,0x222,0x225,0x23d,0x237,0x225,0x225,0x225,0x222,0x225,0x222,0x225,0x225,0x210,0x21c,0x21f,
0x225,0x222,0x21c,0x210,0x219,0x219,0x219,0x219,0x231,0x231,0x22b,0x231,0x231,0x22b,0x231,0x231,
0x22b,0x23d,0x378,0x23d,0x378,0x23d,0x378,0x23d,0x378,0x23d,0x378,0x23d,0x378,0x23d,0x378,0x23d,
0x378,0x222,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x225,0x222,0x23d,0x237,0x23d,0x237,0x23d,0x237,
0x23d,0x237,0x23d,0x237,0x237,0x231,0x231,0x22b,0x23d,0x237,0x738,0x738,0x74a,0x747,0x23d,0x237,
0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,
0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x74a,0x747,0x74a,0x747,0x738,0x735,0x74a,0x747,
0x8eb,0x9b4,0x744,0x741,0x744,0x741,0x74a,0x747,0x74a,0x747,0x74a,0x747,0x74a,0x747,0x74a,0x747,
0x74a,0x747,0x74a,0x747,0x9b1,0x9b1,0x9b1,0xabf,0xabf,0xabf,0xac2,0xac2,0xabf,0xac2,0xac2,0xabf,
0xabf,0xac2,0xbac,0xbaf,0xbaf,0xbaf,0xbaf,0xbac,0xbaf,0xbac,0xbaf,0xbac,0xbaf,0xbac,0xbaf,0xbac,
0x216,0x360,0x216,0x228,0x228,0x216,0x228,0x228,0x216,0x234,0x216,0x228,0x216,0x216,0x216,0x216,
0x216,0x360,0x216,0x228,0x216,0x216,0x216,0x216,0x228,0x228,0x216,0x216,0x216,0x216,0x216,0x216,
0x216,0x216,0x228,0x216,0x216,0x216,0x216,0x21c,0x216,0x216,0x216,0x216,0x21c,0x216,0x216,0x216,
0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x228,0x216,0x216,0x216,0x216,0x216,0x216,
0x216,0x216,0x228,0x216,0x219,0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x21c,0x216,
0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x216,0x73b,0x73b,0x73b,0x73b,0x73b,0x9b1,0x9b1,
0x240,0x240,0x240,0x240,0x240,0x240,0x240,0x240,0x240,0x96,0x96,0x9c,0x28b,0x96,0x96,0x96,
0x93,0x93,0x6c,0x6c,0x2f7,0x6c,0x96,0x38a,0x99,0x38a,0x38a,0x38a,0x99,0x38d,0x96,0x96,
0x303,0x9f,0x6c,0x6c,0x6c,0x6c,0x6c,0x28e,0x2fa,0x387,0x2fa,0x2fa,0x72,0x2fa,0x6c,0x7d7,
0x240,0x240,0x240,0x240,0x240,0x6c,0x6c,0x6c,0x6c,0x6c,0x6e7,0x6e7,0x6d5,0x6cc,0x6d2,0x963,
0x963,0x963,0x963,0x963,0x963,0x963,0x963,0x963,0x963,0x963,0x963,0x963,0x963,0x963,0x963,0x963,
0x5ee,0x5f1,0x5f4,0x5fa,0x5fd,0x600,0x603,0x606,0x609,0x5f7,0x60c,0x60f,0x612,0x615,0x61b,0x5eb,
0x618,0x61e,0x5df,0x621,0x5eb,0x5df,0x5e5,0x5df,0x5df,0x5df,0x5df,0x5eb,0x5df,0x5df,0x5df,0x5df,
0x624,0x5e5,0x5e5,0x62a,0x62d,0x627,0x5eb,0x5eb,0x5eb,0x5df,0x5df,0x5df,0x5df,0x630,0x627,0x5df,
0x633,0x636,0x5e5,0x5df,0x5e5,0x5eb,0x5e5,0x5df,0x5eb,0x5eb,0x5df,0x5df,0x5df,0x5df,0x5df,0x5df,
0x5e8,0x5e8,0x639,0x5e8,0x5e8,0x63c,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x846,0x957,
0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xa3b,0xb7c,0xb76,0xb76,0xb76,0xb79,0xa3e,0xa44,0xa3e,
0x5e2,0x5e2,0x849,0x95d,0x95d,0x95d,0x95d,0x95d,0x95d,0x95d,0x95d,0x95d,0x95d,0x95d,0x95d,0x95d,
0xc8a,0xc87,0xc8a,0xc87,0x291,0x2b2,0xc8a,0xc87,0,0,0x19e,0xb9a,0xb9a,0xb9a,0x4e,0x119d,
0,0,0,0,0x198,0x6f,0x1b6,0x78,0x1b6,0x1b6,0x1b6,0,0x1b6,0,0x1b6,0x1b6,
0x1b3,0x35d,0x35d,0x35d,0x35d,0x35d,0x35d,0x35d,0x35d,0x35d,0x35d,0x35d,0x35d,0x35d,0x35d,0x35d,
0x35d,0x35d,0,0x35d,0x35d,0x35d,0x35d,0x35d,0x35d,0x35d,0x1b6,0x1b6,0x1b3,0x1b3,0x1b3,0x1b3,
0x1b3,0x35a,0x35a,0x35a,0x35a,0x35a,0x35a,0x35a,0x35a,0x35a,0x35a,0x35a,0x35a,0x35a,0x35a,0x35a,
0x35a,0x35a,0x1b0,0x35a,0x35a,0x35a,0x35a,0x35a,0x35a,0x35a,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0xc8d,
0x1b9,0x1b9,0x1bc,0x1ad,0x1ad,0x1b9,0x1aa,0x70e,0x8e8,0x8e5,0x1a1,0x70b,0x1a1,0x70b,0x1a1,0x70b,
0x1a1,0x70b,0x165,0x162,0x165,0x162,0x165,0x162,0x165,0x162,0x165,0x162,0x165,0x162,0x165,0x162,
0x1b9,0x1b9,0x1aa,0x1a4,0x870,0x86d,0x8e2,0x993,0x990,0x999,0x993,0x990,0xab3,0xab6,0xab6,0xab6,
0x6f6,0x354,0x17d,0x180,0x17d,0x17d,0x17d,0x180,0x17d,0x17d,0x17d,0x17d,0x180,0x6f6,0x180,0x17d,
0x351,0x351,0x351,0x351,0x351,0x351,0x351,0x351,0x351,0x354,0x351,0x351,0x351,0x351,0x351,0x351,
0x351,0x351,0x351,0x351,0x351,0x351,0x351,0x351,0x351,0x351,0x351,0x351,0x351,0x351,0x351,0x351,
0x34b,0x34b,0x34b,0x34b,0x34b,0x34b,0x34b,0x34b,0x34b,0x34e,0x34b,0x34b,0x34b,0x34b,0x34b,0x34b,
0x34b,0x34b,0x34b,0x34b,0x34b,0x34b,0x34b,0x34b,0x34b,0x34b,0x34b,0x34b,0x6f0,0x34e,0x177,0x17a,
0x177,0x177,0x177,0x17a,0x177,0x177,0x177,0x177,0x17a,0x6f0,0x17a,0x177,0x171,0x16b,0x171,0x16b,
0x171,0x16b,0x171,0x16b,0x171,0x16b,0x171,0x16b,0x171,0x16b,0x171,0x16b,0x171,0x16b,0x171,0x16b,
0x171,0x16b,0x174,0x16e,0x171,0x16b,0x171,0x16b,0x171,0x16b,0x171,0x16b,0x171,0x16b,0x168,0x5d9,
0x5dc,0x5ca,0x5ca,0xdd7,0x7fe,0x7fe,0x8dc,0x8d9,0x6f3,0x6ed,0x6f3,0x6ed,0x17d,0x177,0x17d,0x177,
0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x177,
0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x177,
0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x177,0x17d,0x180,0x17a,0x17d,
0x177,0x8dc,0x8d9,0x17d,0x177,0x8dc,0x8d9,0x17d,0x177,0x8dc,0x8d9,0xb94,0x180,0x17a,0x180,0x17a,
0x17d,0x177,0x180,0x17a,0x17d,0x177,0x180,0x17a,0x180,0x17a,0x180,0x17a,0x17d,0x177,0x180,0x17a,
0x180,0x17a,0x180,0x17a,0x17d,0x177,0x180,0x17a,0x6f6,0x6f0,0x180,0x17a,0x180,0x17a,0x180,0x17a,
0x180,0x17a,0xa95,0xa92,0x180,0x17a,0xb97,0xb94,0xb97,0xb94,0xb97,0xb94,0x8d6,0x8d3,0x8d6,0x8d3,
0x8d6,0x8d3,0x8d6,0x8d3,0x8d6,0x8d3,0x8d6,0x8d3,0x8d6,0x8d3,0x8d6,0x8d3,0xb97,0xb94,0xb97,0xb94,
0xc7b,0xc78,0xc7b,0xc78,0xc7b,0xc78,0xc7b,0xc78,0xc7b,0xc78,0xc7b,0xc78,0xc7b,0xc78,0xc7b,0xc78,
0xdfe,0xdfb,0xfc0,0xfbd,0x1191,0x118e,0x118b,0x1188,0x118b,0x1188,0x1191,0x118e,0,0x14d,0x14d,0x14d,
0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,
0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,0x14d,0,0,0x150,0x13e,0x13e,0x13e,0x144,0x13e,0x141,
0x1557,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,
0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,0x14a,
0x14a,0x14a,0x14a,0x147,0x1557,0x2b5,0x6e4,0,0,0x1182,0x1182,0x108c,0,0x69f,0x69f,0x69f,
0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0xb58,0x69f,
0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x69f,0x594,0x594,0x594,0x594,
0x59a,0x594,0x594,0x594,0x594,0x594,0xc09,0x594,0x594,0x594,0x1e0,0x594,0x1d7,0x594,0x594,0x1e3,
0x6a2,0xb5b,0xab9,0xb5e,0,0,0,0,0,0,0,0,0x1f2,0x1f2,0x1f2,0x1f2,
0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,
0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0x1f2,0,0,0,0,0x1563,0x1f2,0x1f2,0x1f2,0x1dd,
0x1da,0,0,0,0,0,0,0,0,0,0,0,0x97e,0x97e,0x97e,0x97e,
0x1089,0x1179,0xc63,0xc63,0xc63,0xc60,0xc60,0xa6e,0x297,0x978,0x975,0x975,0xa20,0xa20,0xa20,0xa20,
0xa20,0xa20,0xd92,0xd92,0xd92,0xd92,0xd92,0x294,0x114c,0x174c,0xa74,0x29a,0xfb4,0x132,0x135,0x135,
0x135,0x135,0x135,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,
0x132,0x132,0x132,0x132,0x132,0x132,0x132,0xc66,0xc66,0xc66,0xc66,0xc66,0x29d,0x132,0x132,0x132,
0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x5d0,0x5d0,0x5d0,0x5d0,0x5d0,0x5d0,0x5d0,0x5d0,0x843,
0x843,0x843,0xa20,0xa26,0xa23,0xb4f,0xb4f,0xb4f,0xb4f,0xb4f,0xb4f,0x104a,0x2b8,0x2b8,0x2b8,0x2b8,
0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x2b8,0x117,0x114,0x111,0x10e,0x8cd,0x8cd,0x5cd,0x132,0x132,0x13b,
0x132,0x123,0x123,0x123,0x123,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,
0x132,0x132,0x132,0x132,0x132,0x132,0x120,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,
0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x120,0x132,0x132,0x132,0x132,0x132,0x132,
0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,
0x6e1,0x6e1,0x132,0x132,0x132,0x132,0x132,0x6e1,0x135,0x132,0x135,0x132,0x132,0x132,0x132,0x132,
0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x6e1,0x132,0x132,0x132,0x135,0x2bb,0x132,0x570,0x570,
0x570,0x570,0x570,0x570,0x570,0x108,0x10e,0x573,0x573,0x570,0x570,0x570,0x570,0x138,0x138,0x570,
0x570,0x10e,0x573,0x573,0x573,0x570,0x97b,0x97b,0x11a,0x11a,0x11a,0x11a,0x11a,0x11a,0x11a,0x11a,
0x11a,0x11a,0x6e1,0x6e1,0x6e1,0x6de,0x6de,0x97b,0x7a7,0x7a7,0x7a7,0x7a1,0x7a1,0x7a1,0x7a1,0x7a1,
0x7a1,0x7a1,0x7a1,0x79e,0x7a1,0x79e,0,0x7aa,0x7a4,0x831,0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,
0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,
0x7a4,0x7a4,0x7a4,0x7a4,0x7a4,0x9c0,0x9c0,0x9c0,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,
0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x837,0x834,0x834,0x834,0x834,0x834,0x834,0x834,0x834,
0x834,0x834,0x834,0,0,0x9c0,0x9c0,0x9c0,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,
0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,
0xa71,0xa71,0xa71,0xa71,0xa71,0xa71,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,
0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0xc66,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,
0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,
0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x7ad,0x83a,0x83a,
0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x83a,0x8f1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0xbd3,0xbd3,0xbd3,0xbd3,0xbd3,0xbd3,0xbd3,0xbd3,
0xbd3,0xbd3,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,
0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,0xbd6,
0xbd9,0xbd9,0xbd9,0xc1e,0xc1e,0xc1e,0xc1e,0xc1e,0xc1e,0xc1e,0xc1e,0xc1e,0xbdc,0xbdc,0xbcd,0xbcd,
0xbd0,0xbe2,0xbdf,0,0,0x15f0,0x157b,0x157b,0xf78,0xf78,0xf78,0xf78,0xea9,0xf78,0xf78,0xf78,
0xea9,0xf78,0xf78,0xf78,0xf78,0xf75,0,0,0xea6,0xea6,0xea6,0xea6,0xea6,0xea6,0xea3,0xeac,
0xea6,0xeac,0xea6,0xea6,0xea6,0xeac,0xeac,0,0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,
0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,0x100b,
0x100b,0x1068,0x1068,0x1068,0,0,0x1008,0,0x14c7,0x14c7,0x14c7,0x14c7,0x14c7,0x14c7,0x14c7,0x14c7,
0x14c7,0x14c7,0x14c7,0,0,0,0,0,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,
0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0x1740,0x1746,0x1746,0x1746,0x1746,0x1746,0x1746,0,
0x174f,0x174f,0,0,0,0,0,0x18ea,0x17c1,0x17c1,0x17c1,0x17c1,0x17c1,0x17c1,0x17c1,0x17c1,
0x1185,0x576,0x159,0x159,0,0x15f,0x15f,0x15f,0x15f,0x15f,0x15f,0x15f,0x15f,0,0,0x15f,
0x15f,0,0,0x15f,0x15f,0x546,0x546,0x546,0x546,0x546,0x546,0x546,0x546,0x546,0x546,0x546,
0x546,0,0x546,0x546,0x546,0x546,0x546,0x546,0x546,0,0x546,0,0,0,0x546,0x546,
0x546,0x546,0,0,0x579,0x981,0x576,0x159,0x159,0x576,0x576,0x576,0x576,0,0,0x159,
0x159,0,0,0x15c,0x15c,0x64b,0xa77,0,0,0,0,0,0,0,0,0x576,
0,0,0,0,0x543,0x543,0,0x543,0x15f,0x15f,0x576,0x576,0,0,0x2c1,0x2c1,
0x2c1,0x2c1,0x2c1,0x2c1,0x2c1,0x2c1,0x2c1,0x2c1,0x546,0x546,0x156,0x156,0x153,0x153,0x153,0x153,
0x153,0x156,0x153,0xdf2,0x14c1,0x14be,0x15e7,0,0,0xa2c,0x588,0x9a8,0,0x1cb,0x1cb,0x1cb,
0x1cb,0x1cb,0x1cb,0,0,0,0,0x1cb,0x1cb,0,0,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,
0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,0x1cb,
0x1cb,0,0x1cb,0x1c8,0,0x1cb,0x1c8,0,0x1cb,0x1cb,0,0,0x58b,0,0x1c5,0x1c5,
0x1c5,0x588,0x588,0,0,0,0,0x588,0x588,0,0,0x588,0x588,0x591,0,0,
0,0xd9e,0,0,0,0,0,0,0,0x1c8,0x1c8,0x1c8,0x1cb,0,0x1c8,0,
0,0,0,0,0,0,0x2c4,0x2c4,0x2c4,0x2c4,0x2c4,0x2c4,0x2c4,0x2c4,0x2c4,0x2c4,
0x588,0x58e,0x1cb,0x1cb,0x1cb,0xd9e,0x1560,0,0,0,0,0,0,0,0,0,
0,0x582,0x582,0x1bf,0,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x1c2,0x9a5,0x1c2,0,0x1c2,
0x1c2,0x1c2,0,0x1c2,0x1c2,0x552,0x552,0x552,0x552,0x552,0x552,0x552,0x552,0x552,0x552,0x552,
0x552,0,0x552,0x552,0x552,0x552,0x552,0x552,0x552,0,0x552,0x552,0,0x552,0x552,0x552,
0x552,0x552,0,0,0x585,0x1c2,0x1bf,0x1bf,0x1bf,0x582,0x582,0x582,0x582,0x582,0,0x582,
0x582,0x1bf,0,0x1bf,0x1bf,0x651,0,0,0x1c2,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x1c2,0x9a5,0xa29,0xa29,0,0,0x2c7,0x2c7,
0x2c7,0x2c7,0x2c7,0x2c7,0x2c7,0x2c7,0x2c7,0x2c7,0x109e,0x9a2,0,0,0,0,0,0,
0,0x13d7,0x1518,0x151e,0x1518,0x151b,0x151b,0x151b,0,0x5af,0x255,0x255,0,0x25b,0x25b,0x25b,
0x25b,0x25b,0x25b,0x25b,0x25b,0,0,0x25b,0x25b,0,0,0x25b,0x25b,0x55b,0x55b,0x55b,
0x55b,0x55b,0x55b,0x55b,0x55b,0x55b,0x55b,0x55b,0x55b,0,0x55b,0x55b,0x55b,0x55b,0x55b,0x55b,
0x55b,0,0x55b,0x55b,0,0xa1d,0x55b,0x55b,0x55b,0x55b,0,0,0x5b2,0x25b,0x5af,0x5af,
0x255,0x5af,0x5af,0x5af,0xdad,0,0,0x255,0x258,0,0,0x258,0x258,0x657,0,0,
0,0,0,0,0,0x170d,0x5af,0x5af,0,0,0,0,0x558,0x558,0,0x55b,
0x25b,0x25b,0xdad,0xdad,0,0,0x252,0x252,0x252,0x252,0x252,0x252,0x252,0x252,0x252,0x252,
0x24f,0xa1d,0xfde,0xfde,0xfde,0xfde,0xfde,0xfde,0,0,0,0,0,0,0,0,
0,0,0x5b5,0x264,0,0x264,0x264,0x264,0x264,0x264,0x264,0,0,0,0x264,0x264,
0x264,0,0x264,0x264,0x267,0x264,0,0,0,0x264,0x264,0,0x264,0,0x264,0x264,
0,0,0,0x264,0x264,0,0,0,0x264,0x264,0x264,0,0,0,0x264,0x264,
0x264,0x264,0x264,0x264,0x264,0x264,0xacb,0x264,0x264,0x264,0,0,0,0,0x5b5,0x25e,
0x5b5,0x25e,0x25e,0,0,0,0x25e,0x25e,0x25e,0,0x261,0x261,0x261,0x5b8,0,0,
0xcd2,0,0,0,0,0,0,0x5b5,0,0,0,0,0,0,0,0,
0,0,0xb19,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2cd,0x2ca,0x2ca,0x2ca,0x9fc,
0x9c3,0x9c3,0x9c3,0x9c3,0x9c3,0x9c6,0x9c3,0,0,0,0,0,0x12f0,0x26d,0x26d,0x26d,
0x15ed,0x270,0x270,0x270,0x270,0x270,0x270,0x270,0x270,0,0x270,0x270,0x270,0,0x270,0x270,
0x270,0x55e,0x55e,0x55e,0x55e,0x55e,0x55e,0x55e,0x55e,0x55e,0x55e,0x55e,0x55e,0,0x55e,0x55e,
0x55e,0x55e,0x55e,0x55e,0x55e,0x55e,0x55e,0x55e,0x12cf,0x55e,0x55e,0x55e,0x55e,0x55e,0,0,
0x17c7,0xcd8,0x5bb,0x5bb,0x5bb,0x26d,0x26d,0x26d,0x26d,0,0x5bb,0x5bb,0x5be,0,0x5bb,0x5bb,
0x5bb,0x65a,0,0,0,0,0,0,0,0x5bb,0x5bb,0,0xd7a,0xd7a,0x13da,0,
0,0x176d,0,0,0x270,0x270,0xdb0,0xdb0,0,0,0x26a,0x26a,0x26a,0x26a,0x26a,0x26a,
0x26a,0x26a,0x26a,0x26a,0,0,0,0,0,0,0,0x1635,0xcd5,0xcd5,0xcd5,0xcd5,
0xcd5,0xcd5,0xcd5,0xcd5,0x1416,0x12e4,0x1f5,0x1f5,0x1566,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,
0x1fb,0,0x1fb,0x1fb,0x1fb,0,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,
0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,
0,0x1fb,0x1fb,0x1fb,0x1fb,0x1fb,0,0,0xa2f,0x9ab,0x1f5,0x59d,0x5a0,0x1f5,0x59d,0x1f5,
0x1f5,0,0x59d,0x5a0,0x5a0,0,0x5a0,0x5a0,0x59d,0x5a3,0,0,0,0,0,0,
0,0x59d,0x59d,0,0,0,0,0,0,0x1755,0x1f8,0,0x1fb,0x1fb,0xc0c,0xc0c,
0,0,0x2d0,0x2d0,0x2d0,0x2d0,0x2d0,0x2d0,0x2d0,0x2d0,0x2d0,0x2d0,0,0xb9d,0xb9d,0x17ee,
0,0,0,0,0,0,0,0,0,0,0,0,0x1521,0x12e7,0x246,0x246,
0x16c5,0x24c,0x24c,0x24c,0x24c,0x24c,0x24c,0x24c,0x24c,0,0x24c,0x24c,0x24c,0,0x24c,0x24c,
0x24c,0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x246,0x5ac,0x5ac,0x5ac,
0xda1,0,0x246,0x246,0x246,0,0x249,0x249,0x249,0x654,0xfdb,0x141c,0,0,0,0,
0x141f,0x141f,0x141f,0x5ac,0x141c,0x141c,0x141c,0x141c,0x141c,0x141c,0x141c,0x1377,0x24c,0x24c,0xda1,0xda1,
0,0,0x243,0x243,0x243,0x243,0x243,0x243,0x243,0x243,0x243,0x243,0xcb4,0xcb4,0xcb4,0xcb4,
0xcb4,0xcb4,0x141c,0x141c,0x141c,0xcb7,0xcba,0xcba,0xcba,0xcba,0xcba,0xcba,0,0x1710,0x792,0x792,
0,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x798,0x798,0x79b,0x79b,0x79b,
0x79b,0x79b,0x79b,0,0,0,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x798,0x79b,
0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0,0x79b,0x79b,0x79b,0x79b,0x79b,
0x79b,0x79b,0x79b,0x79b,0,0x79b,0,0,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0x79b,0,
0,0,0x82e,0,0,0,0,0x82b,0x792,0x792,0x82b,0x82b,0x82b,0,0x82b,0,
0x792,0x792,0x795,0x792,0x795,0x795,0x795,0x828,0,0,0,0,0,0,0x11c4,0x11c4,
0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0x11c4,0,0,0x792,0x78f,0x78c,0,0,0,
0,0,0,0,0,0,0,0,0,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,
0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,
0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x27f,0x5c1,0x27f,0x27c,0x5c1,0x5c1,0x5c1,0x5c1,
0x5c1,0x5c1,0x5c7,0,0,0,0,0x2a,0x285,0x285,0x285,0x285,0x285,0x27f,0x282,0x5c4,
0x5c4,0x5c4,0x5c4,0x5c4,0x5c4,0x5c1,0x5c4,0x273,0x279,0x279,0x279,0x279,0x279,0x279,0x279,0x279,
0x279,0x279,0x276,0x276,0,0,0,0,0,0x207,0x207,0,0x207,0,0x161d,0x207,
0x207,0x161d,0x207,0,0x161d,0x207,0x161d,0x161d,0x161d,0x161d,0x161d,0x161d,0x207,0x207,0x207,0x207,
0x161d,0x207,0x207,0x207,0x207,0x207,0x207,0x207,0x161d,0x207,0x207,0x207,0,0x207,0,0x207,
0x161d,0x161d,0x207,0x207,0x161d,0x207,0x207,0x207,0x207,0x5a6,0x207,0x201,0x5a6,0x5a6,0x5a6,0x5a6,
0x5a6,0x5a6,0x168f,0x5a6,0x5a6,0x207,0,0,0x20d,0x20d,0x20d,0x20d,0x20d,0,0x20a,0,
0x5a9,0x5a9,0x5a9,0x5a9,0x5a9,0x5a6,0x1833,0,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,0x1fe,
0x1fe,0x1fe,0,0,0x204,0x204,0x10a1,0x10a1,0x68d,0x68d,0x68d,0x68a,0x68d,0x68d,0x68d,0x68d,
0,0x68d,0x68d,0x68d,0x68d,0x68a,0x68d,0x68d,0x68d,0x68d,0x68a,0x68d,0x68d,0x68d,0x68d,0x68a,
0x68d,0x68d,0x68d,0x68d,0x68a,0x68d,0x68d,0x68d,0x68d,0x68d,0x68d,0x68d,0x68d,0x68d,0x68d,0x68d,
0x68d,0x68a,0x7b6,0xce4,0xce4,0,0,0,0,0x6a8,0x6a8,0x6a5,0x6a8,0x6a5,0x6a5,0x6ba,
0x6a5,0x6ba,0x6a8,0x6a8,0x6a8,0x6a8,0x6a8,0x684,0x6a8,0x6a5,0x6b4,0x6b4,0x6b7,0x666,0x6b1,0x6b1,
0x68d,0x68d,0x68d,0x68d,0xfe4,0x1053,0x1053,0x1053,0x6a8,0x6a8,0x6a8,0x6a5,0x6a8,0x6a8,0x83d,0x6a8,
0,0x6a8,0x6a8,0x6a8,0x6a8,0x6a5,0x6a8,0x6a8,0x6a8,0x6a8,0x6a5,0x6a8,0x6a8,0x6a8,0x6a8,0x6a5,
0x6a8,0x6a8,0x6a8,0x6a8,0x6a5,0x6a8,0x83d,0x83d,0x83d,0x6a8,0x6a8,0x6a8,0x6a8,0x6a8,0x6a8,0x6a8,
0x83d,0x6a5,0x83d,0x83d,0x83d,0,0x7b3,0x7b3,0x7b0,0x7b0,0x7b0,0x7b0,0x7b0,0x7b0,0x840,0x7b0,
0x7b0,0x7b0,0x7b0,0x7b0,0x7b0,0,0xcdb,0x7b0,0xace,0xace,0xcde,0xce1,0xcdb,0xddd,0xddd,0xddd,
0xddd,0xfe1,0xfe1,0,0,0,0,0,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0,0x109b,
0,0,0,0,0,0x109b,0,0,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,
0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0xa9b,
0x705,0,0x705,0x705,0x705,0x705,0,0,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0,
0x705,0,0x705,0x705,0x705,0x705,0,0,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0xa9b,
0x705,0,0x705,0x705,0x705,0x705,0,0,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,
0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0xa9b,0x705,0,0x705,0x705,
0x705,0x705,0,0,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0,0x705,0,0x705,0x705,
0x705,0x705,0,0,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0xa9b,0x705,0x705,0x705,0x705,
0x705,0x705,0x705,0,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,
0x705,0x705,0x705,0xa9b,0x705,0,0x705,0x705,0x705,0x705,0,0,0x705,0x705,0x705,0x705,
0x705,0x705,0x705,0xa9b,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,
0x705,0x705,0x705,0x705,0x705,0x705,0x705,0,0,0x1050,0x1050,0xb52,0xa98,0x6ff,0x708,0x6fc,
0x6fc,0x6fc,0x6fc,0x708,0x708,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x702,0x6f9,0x6f9,
0x6f9,0x6f9,0x6f9,0x6f9,0x6f9,0x6f9,0x6f9,0x6f9,0x6f9,0,0,0,0xa9b,0xa9b,0xa9b,0xa9b,
0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa98,0xa98,0xa98,0xa98,
0xa98,0xa98,0xa98,0xa98,0xa98,0xa98,0,0,0,0,0,0,0x6ea,0x6ea,0x6ea,0x6ea,
0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,
0x6ea,0x1365,0,0,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0,0,0x783,0x786,0x786,0x786,
0x786,0x786,0x786,0x786,0x786,0x786,0x786,0x786,0x786,0x786,0x786,0x786,0x786,0x786,0x786,0x786,
0x786,0x786,0x786,0x786,0x786,0x786,0x786,0x780,0x77d,0,0,0,0x789,0x789,0x789,0x789,
0x789,0x789,0x789,0x789,0x789,0x789,0x789,0x7c5,0x7c5,0x7c5,0x789,0x789,0x789,0x11be,0x11be,0x11be,
0x11be,0x11be,0x11be,0x11be,0x11be,0,0,0,0,0,0,0,0x8f4,0x8f4,0x8f4,0x8f4,
0x8f4,0x8f4,0x8f4,0x8f4,0x8f4,0x8f4,0x8f4,0x8f4,0x8f4,0x1773,0x8f4,0x8f4,0x8f4,0x8f4,0x945,0x945,
0x948,0x17ca,0,0,0,0,0,0,0,0,0,0x1773,0x8f7,0x8f7,0x8f7,0x8f7,
0x8f7,0x8f7,0x8f7,0x8f7,0x8f7,0x8f7,0x8f7,0x8f7,0x8f7,0x8f7,0x8f7,0x8f7,0x8f7,0x8f7,0x94b,0x94b,
0x94e,0x900,0x900,0,0,0,0,0,0,0,0,0,0x8fa,0x8fa,0x8fa,0x8fa,
0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x8fa,0x951,0x951,
0,0,0,0,0,0,0,0,0,0,0,0,0x8fd,0x8fd,0x8fd,0x8fd,
0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0x8fd,0,0x8fd,0x8fd,0x8fd,0,0x954,0x954,
0,0,0,0,0,0,0,0,0,0,0,0,0x726,0x726,0x726,0x726,
0x726,0x726,0x801,0x726,0x726,0x80d,0x80d,0x80d,0x80d,0x80d,0x807,0x807,0x80d,0x80a,0x810,0x804,
0x732,0x732,0x720,0x72c,0x71a,0x714,0x71d,0x717,0x72c,0xa32,0,0,0x723,0x723,0x723,0x723,
0x723,0x723,0x723,0x723,0x723,0x723,0,0,0,0,0,0,0x9ae,0x9ae,0x9ae,0x9ae,
0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0,0,0,0,0,0,0x750,0x750,0x7cb,0x7ce,
0x756,0x7c8,0x753,0x750,0x759,0x768,0x75c,0x81c,0x81c,0x81c,0x74d,0x17c4,0x75f,0x75f,0x75f,0x75f,
0x75f,0x75f,0x75f,0x75f,0x75f,0x75f,0,0,0,0,0,0,0x762,0x762,0x762,0x762,
0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,
0x762,0x762,0x762,0x762,0x1572,0,0,0,0,0,0,0,0x762,0x762,0x762,0x762,
0x762,0x762,0x762,0x762,0x762,0x816,0xcbd,0,0,0,0,0,0xe25,0xe25,0xe25,0xe25,
0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,
0xe25,0xe25,0,0,0,0,0,0,0,0,0,0,0x9d5,0x9d5,0x9d5,0x9d5,
0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,
0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x9d5,0x11c7,0x11c7,0,0xa35,0xa35,0xa35,0x9d2,
0x9d2,0x9d2,0x9d2,0xa35,0xa35,0x9d2,0x9d2,0x9d2,0,0,0,0,0x9d2,0x9d2,0xa35,0x9d2,
0x9d2,0x9d2,0x9d2,0x9d2,0x9d2,0xa38,0xa38,0xa38,0,0,0,0,0x9cc,0,0,0,
0x9d8,0x9d8,0x9cf,0x9cf,0x9cf,0x9cf,0x9cf,0x9cf,0x9cf,0x9cf,0x9cf,0x9cf,0x9e7,0x9e7,0x9e7,0x9e7,
0x9e7,0x9e7,0x9e7,0x9e7,0x9e7,0x9e7,0x9e7,0x9e7,0x9e7,0x9e7,0x9e7,0x9e7,0x9e7,0x9e7,0,0,
0x9e7,0x9e7,0x9e7,0x9e7,0x9e7,0,0,0,0,0,0,0,0,0,0,0,
0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xe2b,0xe2b,0,0,0,0,
0xafb,0xafb,0xafb,0xafb,0xafb,0xafe,0xafe,0xafe,0xafb,0xafb,0xafe,0xafb,0xafb,0xafb,0xafb,0xafb,
0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0,0,0,0,0,0,0xaf8,0xaf8,0xaf8,0xaf8,
0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xaf8,0xe28,0,0,0,0xaf5,0xaf5,0xad7,0xad7,0xad7,0xad7,
0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,0xad7,
0xad7,0xad7,0xad7,0xb61,0xb61,0xad4,0xad4,0xb61,0,0,0xad1,0xad1,0xe5b,0xe5b,0xe5b,0xe5b,
0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,
0xe5b,0xe58,0xf5a,0xe58,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0,0xf63,0xe55,0xf5a,0xe55,
0xe55,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xf5a,0xe58,0xe58,0xe58,0xe58,0xe58,0xe58,0xf5a,
0xf5a,0xf60,0xf60,0xf60,0xf60,0xf60,0xf60,0xf60,0xf60,0,0,0xf5d,0xe52,0xe52,0xe52,0xe52,
0xe52,0xe52,0xe52,0xe52,0xe52,0xe52,0,0,0,0,0,0,0xe52,0xe52,0xe52,0xe52,
0xe52,0xe52,0xe52,0xe52,0xe52,0xe52,0,0,0,0,0,0,0xe4f,0xe4f,0xe4f,0xe4f,
0xe4f,0xe4f,0xe4f,0xe5e,0xe61,0xe61,0xe61,0xe61,0xe4f,0xe4f,0,0,0x12d8,0x12d8,0x12d8,0x12d8,
0x12d8,0x12d8,0x12d8,0x12d8,0x12d8,0x12d8,0x12d8,0x12d8,0x12d8,0x12d8,0x12d2,0x170a,0x170a,0x17be,0x17be,0x17be,
0x17be,0x17be,0x17be,0x17be,0x17be,0x17be,0x17be,0x17be,0x17b8,0x17b8,0x17b8,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0xbc1,0xbc1,0xc0f,0xc12,
0xc1b,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0x177c,0,0x1872,0x1872,0xbbb,0xbbb,0xbbb,0xbbb,
0xbbb,0xbbb,0xbbb,0xbbb,0xbbb,0xbbb,0xbca,0xbca,0xbb5,0xbb8,0xbca,0xbca,0xff0,0xff0,0xff0,0xff0,
0xff0,0xff0,0x105c,0xfed,0x1059,0x1059,0xfed,0xfed,0xfed,0x1059,0xfed,0x1059,0x1059,0x1059,0x105f,0x105f,
0,0,0,0,0,0,0,0,0xfea,0xfea,0xfea,0xfea,0xd0b,0xd0b,0xd0b,0xd0b,
0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xd08,0xdbc,0xdbc,0xdbc,0xdbc,0xdbc,0xdbc,0xdbc,0xdbc,
0xd08,0xd08,0xdc2,0xdbf,0,0,0,0xd0e,0xd0e,0xd02,0xd02,0xd02,0xd05,0xd05,0xd05,0xd05,
0xd05,0xd05,0xd05,0xd05,0xd05,0xd05,0,0,0,0xd0b,0xd0b,0xd0b,0xd32,0xd32,0xd32,0xd32,
0xd32,0xd32,0xd32,0xd32,0xd32,0xd32,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0x1410,0x1410,0x1410,0x1410,
0x1410,0x1410,0x1410,0x1410,0x1410,0x1866,0x1863,0,0,0,0,0,0x155d,0x155d,0x155d,0x155d,
0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,
0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0x155d,0,0,0x155d,0x155d,0x155d,0x10bc,0x10bc,0x10bc,0x10bc,
0x10bc,0x10bc,0x10bc,0x10bc,0,0,0,0,0,0,0,0,0xf8a,0xf87,0xf8a,0xedf,
0xf87,0xf8d,0xf8d,0xf90,0xf8d,0xf90,0xf93,0xf87,0xf90,0xf90,0xf87,0xf87,0xf90,0xee2,0xf87,0xf87,
0xf87,0xf87,0xf87,0xf87,0xf87,0xee8,0xee5,0xedc,0xedc,0xf8d,0xedc,0xedc,0xedc,0xedc,0xeeb,0x1107,
0x1143,0x1104,0x1104,0x14fd,0x1344,0x1344,0x1674,0,0,0,0,0,0x1b3,0x1b3,0x1b3,0x1b3,
0x1b3,0x1b3,0x1b3,0x1b3,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b3,0x1b3,0x1b3,0x1b3,
0x1b3,0x1b3,0,0,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0,0,0x1b3,0x1b3,0x1b3,0x1b3,
0x1b3,0x1b3,0x1b3,0x1b3,0,0x1b6,0,0x1b6,0,0x1b6,0,0x1b6,0x1b3,0x1b3,0x1b3,0x1b3,
0x1b3,0x1b3,0x1b3,0x1b3,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b3,0x1a7,0x1b3,0x1a7,
0x1b3,0x1a7,0x1b3,0x1a7,0x1b3,0x1a7,0x1b3,0x1a7,0x1b3,0x1a7,0,0,0x1b3,0x1b3,0x1b3,0x1b3,
0x1b3,0x1b3,0x1b3,0x1b3,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b6,0x1b3,0x1b3,0x1b3,0x1b3,
0x1b3,0,0x1b3,0x1b3,0x1b6,0x1b6,0x1b6,0x1ad,0x1b6,0x198,0x1a7,0x198,0x198,0x195,0x1b3,0x1b3,
0x1b3,0,0x1b3,0x1b3,0x1b6,0x1ad,0x1b6,0x1ad,0x1b6,0x195,0x195,0x195,0x1b3,0x1b3,0x1b3,0x1a7,
0,0,0x1b3,0x1b3,0x1b6,0x1b6,0x1b6,0x1ad,0,0x195,0x195,0x195,0x1b3,0x1b3,0x1b3,0x1a7,
0x1b3,0x1b3,0x1b3,0x1b3,0x1b6,0x1b6,0x1b6,0x1ad,0x1b6,0x195,0x195,0x195,0,0,0x1b3,0x1b3,
0x1b3,0,0x1b3,0x1b3,0x1b6,0x1ad,0x1b6,0x1ad,0x1b6,0x19b,0x198,0,0x88e,0x891,0x891,0x891,
0xc21,9,0x1149,0x1149,0x1149,0x1149,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x3f,0x8ee,0,0,
0x2e8,0x3f,0x3f,0x3f,0x3f,0x3f,0x57,0x69,0x57,0x63,0x5d,0x366,0x3c,0x2e5,0x2e5,0x2e5,
0x2e5,0x3c,0x3c,0x3c,0x3c,0x3c,0x54,0x66,0x54,0x60,0x5a,0,0xac5,0xac5,0xac5,0xac5,
0xac5,0xfd5,0xfd5,0xfd5,0xfd5,0xfd5,0xfd5,0xfd5,0xfd5,0,0,0,0x561,0x564,0x7fb,0x7fb,
0x93c,0x942,0x942,0x93f,0x93f,0x93f,0x93f,0xb4c,0xc03,0xc03,0xc03,0xc03,0xdd4,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x21f,0x21f,0x21f,0x73e,
0xba0,0xc93,0xc93,0xc93,0xc93,0xf0c,0x1353,0x1353,0,0,0,0,0x336,0x336,0x336,0x336,
0x336,0x336,0x336,0x336,0x336,0x336,0xd2,0xd2,0xcf,0xcf,0xcf,0xcf,0xa86,0xa83,0xa86,0xa83,
0xa83,0xa7a,0xa7a,0xa7a,0xa7a,0xa7a,0xa7a,0xdf8,0xdf5,0xdf8,0xdf5,0xf42,0xf45,0xf45,0x1092,0x108f,
0,0,0,0,0,0xa8c,0xa89,0xa89,0xa7d,0xa7a,0xa80,0xa7d,0xa9e,0xa9e,0xa9e,0xa9e,
0xa9e,0xa9e,0,0x1095,0,0,0,0,0,0x1095,0,0,0xb01,0xb01,0xb01,0xb01,
0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0x10ad,0x10ad,
0,0,0,0,0,0,0,0xb04,0xfe7,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0x1056,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,
0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0,
0,0,0,0,0,0,0,0,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0,
0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0,
0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0xa9b,0,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,
0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,
0x7dd,0x7dd,0,0x7dd,0x7dd,0x7dd,0x7dd,0x7e0,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,
0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7e0,0,0,0,0,
0,0,0,0,0,0,0,0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,
0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x7f2,0x7f2,0x7f5,0x7f5,0x7f2,0x7f2,0x7f2,0x7f2,0x7f2,0x7f2,0x7f2,0x7f2,0x1851,0x1851,0x184e,0x184e,
0,0x4d1,0x4cb,0x4d1,0x4cb,0x4d1,0x4cb,0x4d1,0x4cb,0x4d1,0x4cb,0x4cb,0x4ce,0x4cb,0x4ce,0x4cb,
0x4ce,0x4cb,0x4ce,0x4cb,0x4ce,0x4cb,0x4ce,0x4cb,0x4ce,0x4cb,0x4ce,0x4cb,0x4ce,0x4cb,0x4ce,0x4cb,
0x4cb,0x4cb,0x4cb,0x4d1,0x4cb,0x4d1,0x4cb,0x4d1,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4cb,0x4d1,0x4cb,
0x4cb,0x4cb,0x4cb,0x4cb,0x4ce,0x924,0x924,0,0,0x645,0x645,0x519,0x519,0x4d4,0x4d7,0x921,
0,0,0,0,0,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,
0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,0x4a7,
0x4a7,0xd71,0x1506,0x15db,0,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,
0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0,0x525,0x525,0x531,0x531,0x531,0x531,0x531,0x531,
0x531,0x531,0x531,0x531,0x531,0x531,0x531,0x531,0xd77,0xd77,0xd77,0xd77,0x18e7,0x18e7,0,0,
0,0,0,0,0,0,0,0x1851,0x927,0x927,0x927,0x927,0x927,0x927,0x927,0x927,
0x927,0x927,0x927,0x927,0x927,0x927,0x927,0x927,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,
0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,
0x4b9,0x4b9,0x4b9,0x4b9,0x4b9,0xa17,0xa17,0,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,
0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0,0,0,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,
0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x92d,0x7e9,0x7e9,0x7e9,0x92d,0x7e9,0,
0,0,0,0,0,0,0,0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,
0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xd14,0xd14,0xd14,0xd14,0xd14,0xd14,0xd14,0xd14,
0xd14,0xd14,0xd1a,0xd1a,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,
0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xf84,0xf84,0xec1,0xeca,0xec4,0xec4,0xec4,0xeca,
0,0,0,0,0,0,0,0,0x1761,0x175b,0x1629,0x1626,0x1629,0x1629,0x1629,0x16bf,
0x16bc,0x16bf,0x16bc,0x186c,0x186c,0x1869,0,0,0x1761,0x175b,0,0x175b,0,0x175b,0x1761,0x175b,
0x1761,0x175b,0x186c,0x1869,0x186c,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0x1758,0x1758,0x1758,0x16b6,0x16b3,0x11a3,
0x10aa,0x10aa,0xfd2,0xc93,0xc93,0xc93,0xc93,0xc93,0xaf2,0xaf2,0xaf2,0xaef,0xaef,0xb6d,0xb6d,0xaef,
0xaec,0xaec,0xaec,0xaec,0x1713,0,0,0,0xef1,0xef1,0xef1,0xef4,0xef4,0xef4,0xef7,0xef7,
0xefa,0xef7,0,0,0,0,0,0,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,
0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe5,0xbe5,0xbeb,0xbeb,
0,0,0,0,0,0,0,0,0xd4d,0xd4d,0xd4d,0xd4d,0xdcb,0x148e,0,0,
0,0,0,0,0,0,0xd53,0xd53,0xd4a,0xd4a,0xd4a,0xd4a,0xd4a,0xd4a,0xd4a,0xd4a,
0xd4a,0xd4a,0,0,0,0,0,0,0xd47,0xd47,0xd47,0xd47,0xd47,0xd47,0xd47,0xdc5,
0xdc5,0xdc5,0xdc5,0xdc5,0xdc5,0xdc5,0xdc5,0xdc5,0xdc5,0xdc5,0xd44,0xdc8,0,0,0,0,
0,0,0,0,0,0,0,0xd41,0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,
0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,0xf33,
0xf33,0xf33,0xf33,0xf33,0xf33,0,0,0,0xf57,0xe37,0xe37,0xe37,0xe37,0xe37,0xe37,0xe3a,
0xe46,0xe46,0xe37,0xe37,0xe37,0xe37,0,0xefd,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,0xe3d,
0xe3d,0xe3d,0,0,0,0,0xe37,0xe37,0x11b2,0x11b2,0x11b2,0x11b2,0x11b2,0x12ea,0x11b8,0x11b5,
0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0x11ac,0x11ac,0x11ac,0x11ac,0x11ac,0x11ac,0x11ac,0x11ac,
0x11ac,0x11ac,0x11b5,0x11b5,0x11b5,0x11b5,0x11b5,0,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,
0xcf3,0xdb3,0xdb3,0xdb3,0xdb3,0xdb3,0xdb3,0xced,0xced,0xdb3,0xdb3,0xced,0xced,0xdb3,0xdb3,0,
0,0,0,0,0,0,0,0,0xcf0,0xcf0,0xcf0,0xdb3,0xcf0,0xcf0,0xcf0,0xcf0,
0xcf0,0xcf0,0xcf0,0xcf0,0xdb3,0xced,0,0,0xcea,0xcea,0xcea,0xcea,0xcea,0xcea,0xcea,0xcea,
0xcea,0xcea,0,0,0xce7,0xcf6,0xcf6,0xcf6,0xeb8,0xf81,0xeb8,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0xeb5,0xeb5,0xebb,0xeaf,0xeb2,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,0x10c5,
0x10c5,0x10c5,0x10c5,0x10c2,0x1125,0x1125,0x10c2,0x10c2,0x10cb,0x10cb,0x10c5,0x10c8,0x10c8,0x10c2,0x1128,0,
0,0,0,0,0,0,0,0,0,0xfc9,0xfc9,0xfc9,0xfc9,0xfc9,0xfc9,0,
0,0xfc9,0xfc9,0xfc9,0xfc9,0xfc9,0xfc9,0,0,0xfc9,0xfc9,0xfc9,0xfc9,0xfc9,0xfc9,0,
0,0,0,0,0,0,0,0,0xfc9,0xfc9,0xfc9,0xfc9,0xfc9,0xfc9,0xfc9,0,
0xfc9,0xfc9,0xfc9,0xfc9,0xfc9,0xfc9,0xfc9,0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,
0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x136e,0x136e,0x136e,0x136e,0x11a0,0x119a,0x1626,0x1626,
0x16b9,0x16c2,0x16a7,0x16a7,0,0,0,0,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,
0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0xe6d,0xe6d,0xe6d,0xe67,0xe67,0xf66,0xe67,0xe67,
0xf66,0xe67,0xe67,0xe70,0xe6a,0xf69,0,0,0xe64,0xe64,0xe64,0xe64,0xe64,0xe64,0xe64,0xe64,
0xe64,0xe64,0,0,0,0,0,0,0x69c,0x69c,0x69c,0x69c,0,0,0,0,
0,0,0,0,0,0,0,0,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,
0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0,0,0,0,0xe0a,
0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,
0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0xe0a,0,0,0,0,
0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0,0,0,0,0,0,0,0,0,
0,0,0,0x147,0x147,0x147,0x147,0x147,0,0,0,0,0,0x711,0x597,0x1e9,
0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1ef,0x1e6,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,
0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0,0x1e9,0,
0x1e9,0x1e9,0,0x1e9,0x1e9,0,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1e9,0x1ec,
0x12c,0x126,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,
0xfb1,0xfb1,0x1743,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x12c,0x126,0x12c,0x126,0x12c,0x12c,0x126,
0x126,0x126,0x126,0x129,0x126,0x126,0x129,0x126,0x129,0x129,0x129,0x126,0x129,0x129,0x129,0x129,
0,0,0x129,0x129,0x129,0x129,0x126,0x126,0x129,0x126,0x126,0x126,0x126,0x129,0x126,0x126,
0x126,0x126,0x126,0x129,0x129,0x129,0x126,0x126,0,0,0,0,0,0,0,0x1743,
0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,
0x95a,0x95a,0x95a,0x95a,0x95a,0x95a,0x95a,0x95a,0x95a,0x95a,0x95a,0x95a,0x95a,0x95a,0x95a,0x95a,
0xb1f,0xb1f,0xb2e,0xb28,0xb25,0xb31,0xb31,0xb2b,0xb1c,0xb22,0,0,0,0,0,0,
0x456,0x47a,0x477,0x47a,0x477,0x930,0x930,0xa0e,0xa08,0x459,0x459,0x459,0x459,0x48f,0x48f,0x48f,
0x47d,0x480,0x495,0,0x486,0x483,0x498,0x498,0x471,0x465,0x453,0x465,0x453,0x465,0x453,0x45c,
0x45c,0x489,0x489,0x48c,0x489,0x489,0x489,0,0x489,0x46e,0x46b,0x45c,0,0,0,0,
0x11d,0x12f,0x11d,0x8d0,0x11d,0,0x11d,0x12f,0x11d,0x12f,0x11d,0x12f,0x11d,0x12f,0x11d,0x12f,
0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x12c,
0x126,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x12c,0x126,0x12c,0x126,0x12c,0x126,0,0,0x1b,
0,0x3ed,0x3cc,0x3ba,0x3c3,0x3c0,0x3ba,0x3cf,0x3bd,0x3b7,0x3ba,0x3db,0x3d2,0x3c9,0x3ea,0x3ba,
0x3e7,0x3e7,0x3e7,0x3e7,0x3e7,0x3e7,0x3e7,0x3e7,0x3e7,0x3e7,0x3d5,0x3d8,0x3db,0x3db,0x3db,0x3ed,
0x39c,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,
0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0x399,0,
0,0,0x399,0x399,0x399,0x399,0x399,0x399,0,0,0x399,0x399,0x399,0x399,0x399,0x399,
0,0,0x399,0x399,0x399,0x399,0x399,0x399,0,0,0x399,0x399,0x399,0,0,0,
0x3c0,0x3c3,0x3db,0x3de,0x3ba,0x3c3,0x3c3,0,0x393,0x396,0x396,0x396,0x396,0x393,0x393,0,
9,9,9,9,9,9,9,9,9,0x6c3,0x6c3,0x6c3,0x6bd,0x2d9,0x288,0x288,
0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0,0x9db,0x9db,0x9db,
0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,
0x9db,0x9db,0x9db,0,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,
0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0,0x9db,0x9db,0,0x9db,0x9db,0x9db,0x9db,0x9db,
0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0,0,0x9db,0x9db,0x9db,0x9db,
0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0,0,0x9db,0x9db,0x9db,0x9db,
0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,
0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0,0,0,0,0,0x9f3,0x9f3,0x9f9,0,
0,0,0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,
0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0x9f0,0,0,0,0x9f6,
0x9f6,0x9f6,0x9f6,0x9f6,0x9f6,0x9f6,0x9f6,0x9f6,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,
0xaa7,0xaa7,0xaa7,0x1197,0x1197,0x1413,0x1413,0,0xc24,0xc24,0xc24,0xc24,0xc24,0xc24,0xc24,0xc24,
0xc24,0xc24,0xc24,0xc24,0x16a4,0,0,0,0x1197,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,
0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,
0xc2a,0xc2a,0xc2a,0xc2a,0xc2a,0xd7d,0,0,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,
0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,0xd29,
0xd29,0xd29,0xd29,0xd29,0xd29,0,0,0,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,
0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x1347,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,
0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,0x12bd,
0x12bd,0x12bd,0x12bd,0x12bd,0,0,0,0,0x873,0x873,0x873,0x873,0,0,0,0,
0,0,0,0,0,0x14c4,0x14c4,0x14c4,0x86a,0x86a,0x86a,0x86a,0x86a,0x86a,0x86a,0x86a,
0x86a,0x86a,0x86a,0x86a,0x86a,0x86a,0x86a,0x86a,0x86a,0x86a,0x86a,0,0,0,0,0,
0x11df,0x11df,0x11df,0x11df,0x11df,0x11df,0x11df,0x11df,0x11df,0x11df,0x11df,0x11df,0x11df,0x11df,0x11df,0x11df,
0x11df,0x11df,0x11df,0x11df,0x11df,0x11df,0x12f9,0x12f9,0x12f9,0x12f9,0x12f9,0,0,0,0,0,
0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,
0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0x9ed,0,0x9ea,
0xb0a,0xb0a,0xb0a,0xb0a,0,0,0,0,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,
0xb07,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0,0,0,0,0,0,0,0,0,0,
0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,
0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0x9e1,0,0,
0x9de,0x9de,0x9de,0x9de,0x9de,0x9de,0x9de,0x9de,0x9de,0x9de,0,0,0,0,0,0,
0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,0x146a,
0x146a,0x146a,0x146a,0x146a,0,0,0,0,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,
0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,0x1467,
0x1467,0x1467,0x1467,0x1467,0,0,0,0,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,
0,0,0,0,0,0,0,0,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,
0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0,0,0,0,0,0,0,0,
0,0,0,0x127e,0x17a3,0x17a3,0x17a3,0x17a3,0x17a3,0x17a3,0x17a3,0x17a3,0x17a3,0x17a3,0x17a3,0,
0x17a3,0x17a3,0x17a3,0x17a3,0x17a3,0x17a3,0x17a3,0,0x17a3,0x17a3,0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,
0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,
0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0x17a0,0,0x17a0,
0x17a0,0,0,0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c3,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,
0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0,0,0,0,0,0,0,0,
0,0,0,0,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,
0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0,0,0,0,0,
0,0,0,0,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,
0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0,0,0,0,0,0,
0,0,0,0,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1764,0x176a,0x176a,0x1767,0x1767,0x1767,0,0x1767,0x1767,0x1767,0x1767,0x1767,
0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,
0x1767,0x1767,0x1767,0x1767,0x1767,0,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0x1767,0,
0,0,0,0,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0,0,0x9c9,0,0x9c9,0x9c9,
0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,
0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0x9c9,0,0x9c9,0x9c9,0,0,0,0x9c9,0,0,0x9c9,
0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,
0xe79,0xe79,0xe79,0xe79,0xe79,0xe79,0,0xe76,0xe73,0xe73,0xe73,0xe73,0xe73,0xe73,0xe73,0xe73,
0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,
0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0x1230,0,
0,0,0,0,0,0,0,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,0x122d,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x13bf,0x13bf,0x13bf,0x13bf,0x13bf,0x13bf,0x13bf,0x13bf,0x13bf,0x13bf,0x13bf,0x13bf,0x13bf,0x13bf,0x13bf,0x13bf,
0x13bf,0x13bf,0x13bf,0,0x13bf,0x13bf,0,0,0,0,0,0x13bc,0x13bc,0x13bc,0x13bc,0x13bc,
0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,
0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,0xbf4,0xbee,0xbee,0xbee,0xbee,0xe4c,0xe4c,0,0,0,0xbf1,
0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,
0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0xd2f,0,0,0,0,0,0xd2c,
0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,
0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0x10dd,0,0,0,0,0x1392,0x1392,0x10dd,0x10dd,
0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,
0,0,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,
0xae6,0xb64,0xb64,0xb64,0,0xb64,0xb64,0,0,0,0,0,0xb64,0xb64,0xb64,0xb64,
0xae6,0xae6,0xae6,0xae6,0,0xae6,0xae6,0xae6,0,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,
0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,0xae6,
0x1578,0x1578,0,0,0xb67,0xb67,0xb67,0,0,0,0,0xb6a,0xae0,0xae0,0xae0,0xae0,
0xae0,0xae0,0xae0,0xae0,0x1575,0,0,0,0,0,0,0,0xae3,0xae3,0xae3,0xae3,
0xae3,0xae3,0xae9,0xae9,0xae0,0,0,0,0,0,0,0,0x11f1,0x11f1,0x11f1,0x11f1,
0x11f1,0x12fc,0x12fc,0,0,0,0,0x11e8,0x11e8,0x11e8,0x11e8,0x11e8,0x11ee,0x11ee,0x12c0,0x11ee,
0x11ee,0x11ee,0x11eb,0,0,0,0,0,0,0,0,0,0xe82,0xe82,0xe82,0xe82,
0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,
0xe82,0xe82,0,0,0,0xe7c,0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,0xe7f,0xea0,0xea0,0xea0,0xea0,
0xea0,0xea0,0xea0,0xea0,0xea0,0xea0,0xea0,0xea0,0xea0,0xea0,0xea0,0xea0,0xea0,0xea0,0xea0,0xea0,
0xea0,0xea0,0,0,0xe9d,0xe9d,0xe9d,0xe9d,0xe9d,0xe9d,0xe9d,0xe9d,0xe9a,0xe9a,0xe9a,0xe9a,
0xe9a,0xe9a,0xe9a,0xe9a,0xe9a,0xe9a,0xe9a,0xe9a,0xe9a,0xe9a,0xe9a,0xe9a,0xe9a,0xe9a,0xe9a,0,
0,0,0,0,0xe97,0xe97,0xe97,0xe97,0xe97,0xe97,0xe97,0xe97,0x11fa,0x11fa,0x11fa,0x11fa,
0x11fa,0x11fa,0x11fa,0x11fa,0x11fa,0x11fa,0x11fa,0x11fa,0x11fa,0x11fa,0x11fa,0x11fa,0x11fa,0x11fa,0,0,
0,0,0,0,0,0x11f7,0x11f7,0x11f7,0x11f7,0,0,0,0,0,0,0,
0,0,0,0,0,0x11f4,0x11f4,0x11f4,0x11f4,0x11f4,0x11f4,0x11f4,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0xe49,0xe49,0xe49,0xe49,
0xe49,0xe49,0xe49,0xe49,0xe49,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x1380,0x1380,0x1380,0x1380,
0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x137d,0x137d,0x137d,0x137d,
0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0,
0,0,0,0,0,0,0x137a,0x137a,0x137a,0x137a,0x137a,0x137a,0x15bd,0x15bd,0x15c0,0x15c0,
0x1608,0x1608,0x1608,0x1608,0,0,0,0,0,0,0,0,0x15ba,0x15ba,0x15ba,0x15ba,
0x15ba,0x15ba,0x15ba,0x15ba,0x15ba,0x15ba,0,0,0,0,0,0,0x1887,0x1887,0x1887,0x1887,
0x1887,0x1887,0,0,0,0x18f3,0x18f6,0x18f0,0x18f0,0x18f0,0x1878,0x188a,0x1881,0x1881,0x1881,0x1881,
0x1881,0x1881,0x1881,0x1881,0x1881,0x1881,0x1881,0x1881,0x1881,0x1881,0x1881,0x1881,0x1881,0x1881,0,0,
0,0,0,0,0,0,0x187b,0x187b,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,
0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,
0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0xdef,0,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,
0x16f5,0x16f5,0,0x1725,0x1725,0x16f2,0,0,0x16f5,0x16f5,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0x1860,0x1860,0x1860,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x18ea,0x182d,0x182d,0x182d,
0x15cc,0x15cc,0x15cc,0x15cc,0x15cc,0x15cc,0x15cc,0x15cf,0,0,0,0,0,0,0,0,
0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,0x15c6,
0x15c6,0x15c6,0x160b,0x160b,0x160b,0x160b,0x160b,0x160b,0x160b,0x160b,0x160b,0x160b,0x160b,0x15c3,0x15c3,0x15c3,
0x15c3,0x15c9,0x15c9,0x15c9,0x15c9,0x15c9,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x1791,0x1791,0x1791,0x1791,0x1791,0x1791,0x1791,0x1791,
0x1791,0x1791,0x1791,0x1791,0x1791,0x1791,0x1791,0x1791,0x1791,0x1791,0x17d6,0x17d6,0x17d6,0x17d6,0x1794,0x1794,
0x1794,0x1794,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,
0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16da,0x16d7,0x16d7,0x16d7,0x16d7,0x16d7,0x16d7,0x16d7,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,
0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0x1653,0,0,0,0,0,
0,0,0,0,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1065,0x1005,0x1005,0xff6,0xff6,0xff6,
0xff6,0xff6,0,0,0,0,0xff3,0xff3,0xff3,0xff3,0xff3,0xff3,0xff3,0xff3,0xff3,0xff3,
0xff3,0xff3,0xff3,0xff3,0xff3,0xff3,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,0xff9,
0x17d0,0x1782,0x1782,0x17cd,0x17cd,0x1782,0,0,0,0,0,0,0,0,0,0x12f3,
0xe91,0xe91,0x17d3,0,0,0,0,0,0,0,0,0,0,0x1584,0,0,
0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,0x10f8,
0x10f8,0,0,0,0,0,0,0,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,0x10f5,
0x10f5,0x10f5,0,0,0,0,0,0,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x112b,
0x112b,0x112b,0x112b,0x112b,0x10d4,0x112b,0x112e,0x112e,0x112b,0x112b,0x112b,0x1131,0x1131,0,0x10d1,0x10d1,
0x10d1,0x10d1,0x10d1,0x10d1,0x10d1,0x10d1,0x10d1,0x10d1,0x10ce,0x10da,0x10da,0x10da,0x1581,0x157e,0x157e,0x16c8,
0,0,0,0,0,0,0,0,0x128a,0x128a,0x128a,0x128a,0x128a,0x128a,0x128a,0x128a,
0x128a,0x128a,0x128a,0x128a,0x128a,0x128a,0x128a,0x128a,0x128a,0x128a,0x128a,0x1332,0x1284,0x1287,0x128a,0,
0,0,0,0,0,0,0,0,0,0x11c1,0x11c1,0x11c1,0x11c1,0x11c1,0x11c1,0x11c1,
0x11c1,0x11c1,0x11c1,0x11c1,0x11c1,0x11c1,0x11c1,0x11c1,0x11c1,0x11c1,0x11c1,0x11c1,0x11c1,0,0,0,
0,0,0,0,0,0,0,0,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,
0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0,0x1269,0x1269,0x1269,0x1269,0x1269,
0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0x1803,0x183c,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0,
0x13c2,0,0x13c2,0x13c2,0x13c2,0x13c2,0,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,
0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,0x13c2,
0x13c2,0x13c5,0,0,0,0,0,0,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,
0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123c,0x123c,0x123c,0x1314,0x1314,0x1314,0x1314,0x1314,
0x1314,0x1317,0x131a,0,0,0,0,0,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,0x1239,
0x1239,0x1239,0,0,0,0,0,0,0x13ec,0x134a,0x120f,0x12c3,0,0x1218,0x1218,0x1218,
0x1218,0x1218,0x1218,0x1218,0x1218,0,0,0x1218,0x1218,0,0,0x1218,0x1218,0x1218,0x1218,0x1218,
0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,0,0x1218,0x1218,0x1218,0x1218,0x1218,0x1218,
0x1218,0,0x1218,0x1218,0,0x1218,0x1218,0x1218,0x1218,0x1218,0,0x160e,0x134d,0x1215,0x1308,0x120f,
0x1308,0x120f,0x120f,0x120f,0x120f,0,0,0x120f,0x120f,0,0,0x1212,0x1212,0x130e,0,0,
0x138f,0,0,0,0,0,0,0x1308,0,0,0,0,0,0x121e,0x121b,0x121b,
0x1218,0x1218,0x120f,0x120f,0,0,0x130b,0x130b,0x130b,0x130b,0x130b,0x130b,0x130b,0,0,0,
0x130b,0x130b,0x130b,0x130b,0x130b,0,0,0,0,0,0,0,0,0,0,0,
0x18d5,0x18d5,0x18d5,0x18d8,0x18d5,0x18d8,0x18d5,0x18d5,0x18d5,0x18d5,0,0x18d5,0,0,0x18d8,0,
0x18d5,0x18d8,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,
0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0x18cf,0,0x18cc,0x1908,0x18c9,0x18c9,0x1908,
0x1908,0x1908,0x1908,0x1908,0x1908,0,0x1908,0,0,0x190b,0,0x190b,0x190b,0x1908,0x18c9,0,
0x18c9,0x18c9,0x1914,0x1914,0x1917,0x18d2,0x1911,0x18db,0x18de,0x18de,0,0x18c6,0x18c6,0,0,0,
0,0,0,0,0,0x190e,0x190e,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x145e,0x145e,0x14ac,0x14a6,0x14a6,0x145e,0x14a9,0x1461,0x1461,0x1461,0x1461,0x1464,
0x1464,0x1458,0x1455,0x1452,0x145b,0x145b,0x145b,0x145b,0x145b,0x145b,0x145b,0x145b,0x145b,0x145b,0x16d1,0x1458,
0,0x1452,0x15f3,0x164d,0x16d4,0x16d4,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1329,0x1275,0x132f,0x132c,0x127b,0x127b,0x126f,0x127b,0,0,0,0,
0,0,0,0,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0x1272,0,0,
0,0,0,0,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,
0x12ae,0x12ae,0x12ae,0x133b,0x12a8,0x12a8,0x133b,0x133b,0x133b,0x133b,0,0,0x12a8,0x12a8,0x12ab,0x12ab,
0x133b,0x133b,0x12a8,0x1341,0x133e,0x129f,0x12b1,0x12b1,0x12a2,0x12a2,0x12a5,0x12a5,0x12a5,0x12b1,0x13cb,0x13cb,
0x13cb,0x13cb,0x13cb,0x13cb,0x13cb,0x13cb,0x13cb,0x13cb,0x13cb,0x13cb,0x13cb,0x13cb,0x13c8,0x13c8,0x13c8,0x13c8,
0x13fb,0x13fb,0,0,0x1335,0x1299,0x1299,0x128d,0x1296,0,0,0,0,0,0,0,
0,0,0,0,0x1290,0x1290,0x1290,0x1290,0x1290,0x1290,0x1290,0x1290,0x1290,0x1290,0,0,
0,0,0,0,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,0x1422,
0x1422,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x113a,
0x10fe,0x113a,0x10fe,0x10fe,0x113a,0x113a,0x113a,0x113a,0x113a,0x113a,0x1140,0x113d,0x1647,0x1785,0,0,
0,0,0,0,0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0x10fb,0,0,
0,0,0,0,0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,0x186f,
0x186f,0x186f,0x186f,0x186f,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,
0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x13b6,0x1587,0,0,0x13f5,0x13b3,0x13f5,
0x13b0,0x13b0,0x13f5,0x13f5,0x13f5,0x13f5,0x13b3,0x13f5,0x13f5,0x13f5,0x13f5,0x13f8,0,0,0,0,
0x13ad,0x13ad,0x13ad,0x13ad,0x13ad,0x13ad,0x13ad,0x13ad,0x13ad,0x13ad,0x13aa,0x13aa,0x13b9,0x13b9,0x13b9,0x13aa,
0x1788,0x1788,0x1788,0x1788,0x1788,0x1788,0x1788,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1590,0x1590,0x1590,0x15f6,
0x15f6,0x15f6,0x15f6,0x15f6,0x15f6,0x15f6,0x15f6,0x15f6,0x1590,0x15fc,0x15f9,0x158d,0,0,0,0,
0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1245,0x1242,0x1242,0x1242,0x1242,0x1242,0x1242,
0x1242,0x1242,0x1242,0,0,0,0,0,0,0,0,0,0,0,0,0x124b,
0x16e9,0x16e9,0x16e9,0x16e9,0x16e9,0x16e9,0x16e9,0,0,0x16e9,0,0,0x16e9,0x16e9,0x16e9,0x16e9,
0x16e9,0x16e9,0x16e9,0x16e9,0,0x16e9,0x16e9,0,0x16e9,0x16e9,0x16e9,0x16e9,0x16e9,0x16e9,0x16e9,0x16e9,
0x16e9,0x16e9,0x16e9,0x16e9,0x16e9,0x16e9,0x16e9,0x16e9,0x1719,0x16e3,0x16e3,0x16e3,0x16e3,0x16e3,0,0x16e3,
0x16e6,0,0,0x1719,0x1719,0x171f,0x1722,0x16ec,0x16e3,0x16ec,0x16e3,0x171c,0x16ef,0x16dd,0x16ef,0,
0,0,0,0,0,0,0,0,0x16e0,0x16e0,0x16e0,0x16e0,0x16e0,0x16e0,0x16e0,0x16e0,
0x16e0,0x16e0,0,0,0,0,0,0,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,
0,0,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,
0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1668,0x1665,0x1665,0x1665,0x1698,0x1698,0x1698,0x1698,
0,0,0x1698,0x1698,0x1665,0x1665,0x1665,0x1665,0x169b,0x1668,0x1662,0x1668,0x1665,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x14e8,0x14eb,0x14fa,0x14fa,0x14eb,0x14ee,0x14e8,0x153f,
0,0,0,0,0,0,0,0,0x14df,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x14dc,
0x14dc,0x1530,0x1530,0x1530,0x14df,0x14df,0x14df,0x14df,0x14d6,0x14d9,0x14d9,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x1770,0x1770,0x1770,0x1770,0x1770,0x1770,0x1770,0x1770,
0x1770,0x1770,0x1770,0x1770,0x1770,0x1770,0x1770,0x1770,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,
0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,
0x129c,0,0,0,0,0,0,0,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,0x17eb,
0x17eb,0x17eb,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x18bd,0x18b7,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,0x18ba,
0x18ba,0x18ba,0,0,0,0,0,0,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,
0x1440,0,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,
0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x1440,0x143d,0x149d,0x149d,0x149d,0x149d,
0x149d,0x149d,0x149d,0,0x149d,0x149d,0x149d,0x149d,0x149d,0x149d,0x143d,0x14a0,0x1440,0x1443,0x1443,0x1437,
0x1434,0x1434,0,0,0,0,0,0,0,0,0,0,0x143a,0x143a,0x143a,0x143a,
0x143a,0x143a,0x143a,0x143a,0x143a,0x143a,0x1431,0x1431,0x1431,0x1431,0x1431,0x1431,0x1431,0x1431,0x1431,0x1431,
0x1431,0x1431,0x1431,0x1431,0x1431,0,0,0,0x1446,0x1449,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,
0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0x144f,0,0,0x14a3,0x14a3,
0x14a3,0x14a3,0x14a3,0x14a3,0x14a3,0x14a3,0x14a3,0x14a3,0x14a3,0x14a3,0x14a3,0x14a3,0,0x144c,0x14a3,0x14a3,
0x14a3,0x14a3,0x14a3,0x14a3,0x14a3,0x144c,0x14a3,0x14a3,0x144c,0x14a3,0x14a3,0,0,0,0,0,
0,0,0,0,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0,0x14cd,0x14cd,0,0x14cd,
0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,
0x14cd,0x14cd,0x14cd,0x14cd,0x14cd,0x1527,0x1527,0x1527,0x1527,0x1527,0x1527,0,0,0,0x1527,0,
0x1527,0x1527,0,0x1527,0x1527,0x1527,0x152a,0x1527,0x152d,0x152d,0x14d0,0x1527,0,0,0,0,
0,0,0,0,0x14ca,0x14ca,0x14ca,0x14ca,0x14ca,0x14ca,0x14ca,0x14ca,0x14ca,0x14ca,0,0,
0,0,0,0,0x159c,0x159c,0x159c,0x159c,0x159c,0x159c,0,0x159c,0x159c,0,0x159c,0x159c,
0x159c,0x159c,0x159c,0x159c,0x159c,0x159c,0x159c,0x159c,0x159c,0x159c,0x159c,0x159c,0x159c,0x159c,0x159c,0x159c,
0x159c,0x159c,0x159c,0x159c,0x159c,0x159c,0x1599,0x1599,0x1599,0x1599,0x1599,0,0x15ff,0x15ff,0,0x1599,
0x1599,0x15ff,0x1599,0x1602,0x159c,0,0,0,0,0,0,0,0x1596,0x1596,0x1596,0x1596,
0x1596,0x1596,0x1596,0x1596,0x1596,0x1596,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x15a5,0x15a5,0x15a5,0x15a5,
0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a5,0x15a2,0x1605,
0x1605,0x159f,0x159f,0x15a8,0x15a8,0,0,0,0,0,0,0,0x183f,0x183f,0x1812,0x180c,
0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0,0x180f,0x180f,
0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,0x180f,
0x180f,0x180f,0x180f,0x180f,0x180c,0x180c,0x183f,0x183f,0x183f,0x183f,0x183f,0,0,0,0x180c,0x180c,
0x183f,0x1842,0x1845,0x1815,0x1815,0x1806,0x1806,0x1806,0x1806,0x1806,0x1806,0x1806,0x1806,0x1806,0x1806,0x1806,
0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x1809,0x18ed,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x16cb,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x1632,0x162c,0x162c,0x162c,
0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0,0,
0,0,0,0,0,0,0,0,0,0,0,0x162f,0x11e5,0x11e5,0x11e5,0x11e5,
0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,
0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x1383,0,0,0,0,0,0,0xbfa,0xbfa,0xbfa,0x11e5,
0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0,0xbf7,0xbf7,0xbf7,0xbf7,
0x11e2,0,0,0,0,0,0,0,0,0,0,0,0x1383,0x1383,0x1383,0x1383,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x178e,0x178e,0x178e,0x178e,
0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178b,0x178b,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x1836,0x17fd,0x17fd,0x17fd,
0x17fd,0x17fd,0x17fd,0x1839,0x1839,0x1839,0x1839,0x1839,0x1839,0x1839,0x1839,0x1839,0x1839,0x1839,0x1839,0x1839,
0x1839,0x1839,0,0,0,0,0,0,0,0,0,0,0x1875,0x1875,0x1875,0x1875,
0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,
0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0,0,0,0,0,0x13a1,0x13a1,0x13a1,0x13a1,
0x13a1,0x13a1,0x13a1,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x18f9,0x18fc,0x18fc,0x18fc,
0x18fc,0x18fc,0x18fc,0x18fc,0x18fc,0x18f9,0x1893,0x1893,0x1893,0x18f9,0x18f9,0x18ff,0x1890,0x1890,0x1890,0x1890,
0x1890,0x1890,0x1890,0x1890,0x1890,0x1890,0,0,0,0,0,0,0x100e,0x100e,0x100e,0x100e,
0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,
0x100e,0x100e,0x100e,0x100e,0x100e,0,0,0,0,0,0,0,0x1254,0x1254,0x1254,0x1254,
0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,
0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0x1254,0,0x1251,0x1251,0x1251,0x1251,
0x1251,0x1251,0x1251,0x1251,0x1251,0x1251,0,0,0,0,0x1257,0x1257,0x179a,0x179a,0x179a,0x179a,
0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,
0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0,0x1797,0x1797,0x1797,0x1797,
0x1797,0x1797,0x1797,0x1797,0x1797,0x1797,0,0,0,0,0,0,0x11fd,0x11fd,0x11fd,0x11fd,
0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0x11fd,0,0,
0x12ff,0x12ff,0x12ff,0x12ff,0x12ff,0x1200,0,0,0,0,0,0,0,0,0,0,
0x11d3,0x11d3,0x11d6,0x11d6,0x11d9,0x11ca,0,0,0,0,0,0,0,0,0,0,
0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0x11d0,0,0x11ca,0x11ca,0x11ca,0x11ca,0x11ca,
0x11ca,0x11ca,0,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,
0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0,0,0,0,0,0x11d3,0x11d3,0x11d3,
0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x189f,0x189f,0x189f,0x18a2,0x189f,0x189f,0x189f,0x18a2,0x18a5,0x18a5,0x18a5,0x18a8,0x18a8,0x1899,0x18ab,0x18ab,
0x189c,0x189c,0x189c,0x189c,0x189c,0x189c,0x189c,0x189c,0x189c,0x189c,0,0,0,0,0,0,
0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,
0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ab,0x15ae,0x15b7,0x15ab,0x15ab,0,0,0,0,0,
0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x1644,0x1644,0x1644,0x1644,0x1644,0x1644,0,0,0,0,0x1692,
0x10b6,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,
0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0x1641,0,0,0,0,0,0,0,0x111c,
0x111c,0x111c,0x111c,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,0x10b9,
0x147f,0x1512,0x1680,0x1683,0x172b,0,0,0,0,0,0,0,0,0,0,0,
0x1728,0x1728,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x15e1,0x15e1,0x15e1,
0x15e1,0x15e1,0x168c,0x168c,0x168c,0x168c,0x168c,0x168c,0,0,0,0,0,0,0,0,
0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,
0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0x18e4,0x1704,0x1704,0x1704,0x1704,0x1704,0x1704,0x1704,0x1704,
0x1704,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x17b5,0x17b5,0x17b5,0x17b5,0,0x17b5,0x17b5,0x17b5,
0x17b5,0x17b5,0x17b5,0x17b5,0,0x17b5,0x17b5,0,0x17b2,0x17b2,0x17b2,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0x1827,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x1686,0x1686,0x1686,0,
0,0x182a,0,0,0,0,0,0,0,0,0,0,0x1689,0x1689,0x1689,0x1689,
0,0,0,0,0,0,0,0,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,
0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,
0x150f,0x150f,0x150f,0x150f,0,0,0,0,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,
0x1206,0x1206,0x1206,0,0,0,0,0,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,
0x1206,0x1206,0x1206,0x1206,0x1206,0,0,0,0,0,0,0,0x1206,0x1206,0x1206,0x1206,
0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0,0,0x1203,0x1302,0x1305,0x1209,0x12b4,0x12b4,0x12b4,0x12b4,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x1857,0x1857,0x1857,0x1857,
0x1857,0x1857,0x1857,0x1857,0x1857,0x1857,0x1857,0x1857,0x1857,0x1857,0x1857,0x1857,0x185a,0x185a,0x185a,0x185a,
0x185a,0x185a,0x185a,0x185a,0x185a,0x185a,0,0,0,0,0,0,0x1854,0x1854,0x1854,0x1854,
0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,
0,0,0,0,0,0,0,0,0,0,0,0,0x17bb,0x17bb,0x17bb,0x17bb,
0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0,0,0x17bb,0x17bb,0x17bb,0x17bb,
0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0,
0,0,0,0,0,0,0,0,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,
0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,
0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0,0,0,0,0,0,
0,0,0,0,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0,0,0xc2d,0x852,0x852,
0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,
0x852,0x852,0x852,0x852,0x1359,0x1359,0x1359,0x1359,0x1359,0x1359,0x1359,0x1359,0x1359,0x1731,0x1731,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0xaaa,0xaaa,0xb55,0xb55,0xb55,0xaaa,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,
0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0x17df,0,0,0,0,0,0,0,0,
0,0,0,0,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,
0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0,0,0,0,0,0,0,0,
0,0,0,0,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,
0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0,0,0,0,0,
0,0,0,0,0xbfd,0xbfd,0xbfd,0xbfd,0xbfd,0xbfd,0xbfd,0xbfd,0xbfd,0xbfd,0xbfd,0xbfd,
0xbfd,0xbfd,0xbfd,0xbfd,0xbfd,0xbfd,0x15d2,0x15d2,0x15d2,0x15d2,0x15d2,0x1545,0x1545,0,0,0,
0,0,0,0,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,
0x861,0x861,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x85e,0x85e,0x85e,0x85e,0x861,0x861,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x861,0,0x861,0x861,0,0,0x861,0,0,0x861,0x861,0,0,0x861,0x861,0x861,
0x861,0,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x85e,0x85e,0x85e,0x85e,0,0x85e,
0,0x85e,0x85e,0x85e,0x85e,0x969,0x85e,0x85e,0,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x85e,0x85e,0x85e,0x85e,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,
0x861,0x861,0x861,0x861,0x85e,0x85e,0x85e,0x85e,0x861,0x861,0,0x861,0x861,0x861,0x861,0,
0,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0,0x861,0x861,0x861,0x861,0x861,0x861,
0x861,0,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x861,0x861,0,0x861,
0x861,0x861,0x861,0,0x861,0x861,0x861,0x861,0x861,0,0x861,0,0,0,0x861,0x861,
0x861,0x861,0x861,0x861,0x861,0,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x85e,0x85e,0x85e,0x85e,0xa50,0xa50,0,0,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,
0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,
0x85e,0x85e,0x85e,0x858,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0xb88,0xb85,0,0,0x85b,0x85b,
0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,
0x1386,0x1386,0x1386,0x1386,0x13e9,0x1386,0x1386,0x1389,0x138c,0x1389,0x1389,0x1386,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,
0,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175e,0x175b,0x175b,0x175b,0x175b,0x175b,
0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0x175b,0,
0,0,0,0,0,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0x17f1,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x148b,0x148b,0x148b,0x148b,0x148b,0x148b,0x148b,0,0x148b,0x148b,0x148b,0x148b,0x148b,0x148b,0x148b,0x148b,
0x148b,0x148b,0x148b,0x148b,0x148b,0x148b,0x148b,0x148b,0x148b,0,0,0x148b,0x148b,0x148b,0x148b,0x148b,
0x148b,0x148b,0,0x148b,0x148b,0,0x148b,0x148b,0x148b,0x148b,0x148b,0,0,0,0,0,
0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,
0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e8,0x17e8,0x17e8,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0x1830,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,
0x165c,0,0,0,0x1695,0x1695,0x1695,0x1695,0x1695,0x1695,0x1695,0x165c,0x165c,0x165c,0x165c,0x165c,
0x165f,0x165f,0,0,0x1659,0x1659,0x1659,0x1659,0x1659,0x1659,0x1659,0x1659,0x1659,0x1659,0,0,
0,0,0x165c,0x1656,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x179d,0x179d,0x179d,0x179d,0x179d,0x179d,0x179d,0x179d,0x179d,0x179d,0x179d,0x179d,
0x179d,0x179d,0x179d,0x179d,0x179d,0x179d,0x17d9,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,
0x1671,0x1671,0x1671,0x1671,0x169e,0x169e,0x169e,0x169e,0x166e,0x166e,0x166e,0x166e,0x166e,0x166e,0x166e,0x166e,
0x166e,0x166e,0,0,0,0,0,0x166b,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,
0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x181b,0x1848,0x1848,0x1848,0x1848,0x1818,0x1818,0x1818,0x1818,
0x1818,0x1818,0x1818,0x1818,0x1818,0x1818,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,
0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x18b4,0x1902,0x1905,0x18b4,0x18b1,0x18b1,0x18b1,
0x18b1,0x18b1,0x18b1,0x18b1,0x18b1,0x18b1,0x18b1,0,0,0,0,0x18ae,0x1752,0x1752,0x1752,0x1752,
0x1752,0x1752,0x1752,0,0x1752,0x1752,0x1752,0x1752,0,0x1752,0x1752,0,0x1752,0x1752,0x1752,0x1752,
0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0x1752,0,0x1224,0x1224,0x1224,0x1224,
0x1224,0,0,0x1221,0x1221,0x1221,0x1221,0x1221,0x1221,0x1221,0x1221,0x1221,0x1311,0x1311,0x1311,0x1311,
0x1311,0x1311,0x1311,0,0,0,0,0,0,0,0,0,0x142b,0x142b,0x142b,0x142b,
0x149a,0x149a,0x149a,0x1494,0x1497,0x1497,0x1497,0x164a,0,0,0,0,0x1428,0x1428,0x1428,0x1428,
0x1428,0x1428,0x1428,0x1428,0x1428,0x1428,0,0,0,0,0x1425,0x1425,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0x1545,0x1545,0x1545,
0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x154b,0x1545,0x1545,0x1545,
0x154b,0x1545,0x1545,0x1545,0x1545,0,0,0,0,0,0,0,0,0,0,0,
0,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,
0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,
0x1611,0x1611,0,0,0x1086,0x1086,0x1086,0x1086,0,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,
0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,
0x1086,0x1086,0x1086,0x1086,0,0x1086,0x1086,0,0x1086,0,0,0x1086,0,0x1086,0x1086,0x1086,
0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0,0x1086,0x1086,0x1086,0x1086,0,0x1086,0,0x1086,
0,0,0,0,0,0,0x1086,0,0,0,0,0x1086,0,0x1086,0,0x1086,
0,0x1086,0x1086,0x1086,0,0x1086,0x1086,0,0x1086,0,0,0x1086,0,0x1086,0,0x1086,
0,0x1086,0,0x1086,0,0x1086,0x1086,0,0x1086,0,0,0x1086,0x1086,0x1086,0x1086,0,
0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0,0x1086,0x1086,0x1086,0x1086,0,0x1086,0x1086,0x1086,
0x1086,0,0x1086,0,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0,0x1086,
0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,
0,0,0,0,0,0x1086,0x1086,0x1086,0,0x1086,0x1086,0x1086,0x1086,0x1086,0,0x1086,
0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,0x1086,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x1080,0x1080,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0,0,0,0,
0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,
0,0,0,0,0,0,0,0,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,
0x1152,0x1152,0,0,0,0,0,0,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,
0,0,0,0,0,0,0,0,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,
0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0,0,0x16a4,0x16a4,0x1854,0x1854,
0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0,0,0,0,0x1854,0x1854,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0x16a4,0x16a4,0x16a4,0x16a4,
0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0,
0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x1854,0x1854,0x1854,0x1854,
0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x16aa,0x16aa,0x16aa,0x16aa,
0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0x16aa,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0x693,0x693,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,
0xc27,0xc27,0xc27,0xc27,3,3,3,3,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,
0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,3,3,3,3,
3,3,3,3,3,3,3,3,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,
0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,3,3,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,
0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0x1155,3,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,
0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0x1023,3,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,
0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0xf9c,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,
0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,3,3,
3,3,3,3,3,3,3,3,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,0x1470,
0x1470,0x1470,0x1470,0x1470,0x1470,0x16a4,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,
0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,0xfa2,
0xfa2,0xfa2,0xfa2,0xfa2,0xf36,0x1029,0x1029,3,3,3,3,3,3,3,3,3,
3,3,3,3,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,
0xf24,0xf24,0xf24,0xf24,0xf24,0xf24,0x1029,0x1029,0x1029,0x1029,0x1029,0x1029,0x1029,0x1029,0x1029,0x1479,
3,3,3,3,0xf21,0xf21,0xf21,0xf21,0xf21,0xf21,0xf21,0xf21,0xf21,3,3,3,
3,3,3,3,0x1041,0x1041,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,0x1026,0x1023,0x1023,0x1023,0x1023,0x1023,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,
0x12c9,0x1155,0x1155,0x1155,0x13ce,0x1473,0x1473,0x14b2,0x14b2,0x167a,0x16f8,0x16f8,3,3,3,3,
0x181e,0x17a6,0x17a6,0x17a6,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x12c6,
0x12c6,3,3,3,0x1155,0x1155,0x1155,0x1155,0x1473,0x1473,0x1473,0x1500,0x1500,0x15d5,0x167a,0x16f8,
0x16f8,3,3,3,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,
0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0x17e2,0x17e2,0x17e2,3,3,3,3,0x17e2,
0x17e2,0x17e2,0x17e2,0x17e2,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,
0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1548,0x1548,0x1548,0x1548,0x17e2,3,3,
3,3,3,3,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,
3,3,3,3,0x17a6,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,
0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,3,3,3,3,3,3,3,3,
3,3,3,3,0x1548,0x1548,0x1548,0x1548,0x1548,0x1548,0x1548,0x1548,0x1548,0x1548,0x1548,0x1548,
0x1548,0x1548,3,3,0x167a,0x167a,0x167a,0x167a,0x16f8,0x181e,0x181e,0x181e,0x167a,0x167a,0x167a,0x17a6,
0x17a6,3,3,3,0x167a,0x167a,0x167a,0x16f8,0x16f8,0x16f8,0x16f8,0x181e,0x181e,0x18e1,3,3,
3,3,3,0x18e1,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,
0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x17a9,0x17a9,0x17a9,0x18e1,3,3,3,3,3,
3,3,0x181e,0x181e,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x17a6,0x17a6,0x17a6,0x181e,0x181e,
0x18e1,3,3,0x18e1,0x17a6,0x17a6,0x17a6,0x17a6,0x17a6,0x17a6,0x17a6,0x17a6,0x181e,0x18e1,3,3,
3,3,3,3,0x17a9,0x17a9,0x17a9,0x17a9,0x17a9,0x17a9,0x17a9,0x1821,0x1821,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,0x693,0x693,
0x172e,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
0x564,0x564,0x564,0x564,0x564,0x564,0x564,0x564,0x564,0x564,0x564,0x564,0x564,0x561,0x561,0x561,
9,0x84f,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
9,9,9,9,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,
0xa41,0xa41,0xa41,0xa41,9,9,9,9,9,9,9,9,9,9,9,9,
9,9,9,9,0xa5,0xa5,0xa5,0xa5,0xa5,0x6d8,0x6d8,0x185d,0x185d,0x185d,0xc,0xc,
0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,
0xc,0xc,0xc,0xc,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xc,
0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,
0xc,0xc,0xc,0xc,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,
0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0xc,0xc,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,
0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,
0x116a,0x116a,0xc,0x16ad,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x1173,0x12ba,0x1176,0x146d,
0x1407,0x14bb,0x14bb,0x14bb,0x14bb,0x14bb,0x1551,0x154e,0x1554,0x154e,0x1554,0x161a,0x16ad,0x16ad,0x16ad,0x173d,
0x173d,0x1734,0x1737,0x1734,0x1737,0x1734,0x1737,0x1734,0x1737,0x173a,0xc,0xc,0xc,0xc,0xc,0xc,
0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,
0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x91e,0x91e,0x91e,0x91e,
0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0xf2d,0xf2d,0xf2d,0xf,0xf,0xb3a,0xb3a,0xb3a,0xb3a,
0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,
0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,
0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0x17ac,0x17ac,0x17ac,
0x17ac,0x1824,0xf,0xf,0xf,0xf,0xf,0xf,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,
0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,
0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0xf,0xf,0x13d4,0x13d4,0xf,0xf,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,
0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,
0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,
0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0xf,0xf,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,
0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,
0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xf,0xf,0x693,0x693,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,
0x1701,0x1701,0x1701,0xf,0xf,0xf,0xf,0xf,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,
0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,
0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0x306,0x306,0x309,0xa5,0x348,0x31b,0x31b,0x31e,
0xf6,0xf6,0x15,0x15,0x15,0x15,0x15,0x7d1,0x312,0xb4,0x33c,0x345,0xe7,0x312,0xc0,0xc0,
0xa5,0xcc,0xcc,0x306,0xf0,0xed,0x318,0x75,0x45,0x45,0x48,0x48,0x48,0x48,0x48,0x4b,
0x48,0x48,0x48,0x18,0x10b,0x56d,0x105,0x105,0x32a,0xc6,0xc3,0x327,0x324,0x321,0x336,0xbd,
0x330,0x333,0xc9,0xcc,0x32d,0x32d,0xc9,0xcc,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0xa5,0x102c,0x102c,0x102c,
0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0x36,0x36,0x90,0x2eb,0x24,0x2dc,0x36,0x8d,
0x24,0x2eb,0x87,0x90,0x90,0x90,0x87,0x87,0x90,0x90,0x90,0x300,0x24,0x90,0x2ee,0x24,
0x81,0x90,0x90,0x90,0x90,0x90,0x24,0x24,0x3f,0x2dc,0x2e8,0x24,0x90,0x24,0x357,0x2d,
0x90,0x51,0x22e,0x369,0x90,0x90,0x7e,0x87,0x90,0x90,0x213,0x90,0x87,0x8a,0x8a,0x8a,
0x8a,0x6cf,0x6c6,0x960,0xa50,0x8a3,0x8a6,0x8a6,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x27,
0x42,0x390,0x2a,0x65d,0x6c0,0x6c9,0x6c9,0x6c9,0x897,0x897,0xa4a,0xa4a,0xa4a,0xa4a,0xde0,0xde3,
0xde3,0xf9f,0x1146,0x115b,0x115e,0x115e,0x1350,0x14b5,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,
0x2f1,0x2f1,0x30,0x906,0x906,0x906,0x906,0x906,0x906,0x906,0x906,0x906,0x906,0x906,0x906,0x906,
0x906,0x906,0x906,0x906,0x906,0x906,0x906,0xa02,0x8a0,0x89d,0x89d,0x89d,0x89d,0x8a6,0x8a3,0x8a3,
0x8a3,0x8a3,0x894,0x89d,0xa47,0xb7f,0xba0,0xc2a,0xde6,0xde6,0xde6,0x2e2,0x2e2,0x33,0x33,0x33,
0x33,0x33,0x33,0x2e2,0x2e2,0x2e2,0x2e2,0x39,0x7b,0xa5,0xa5,0xa5,0xdb,0xb1,0xa8,0x8c7,
0x6db,0x6db,0x6d8,0x6d8,0x6d8,0x6d8,0x8ac,0x903,0x8ac,0x8ac,0x8b8,0x96f,0x966,0xa53,0xa5f,0x8b5,
0xa5f,0xa5f,0xb0d,0xa5f,0xa5c,0xb10,0xa5f,0x89a,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,
0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0xa2,0xa5,0xa5,0xa5,
0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,
0xa5,0xcf,0xcf,0xcf,0xcf,0xcf,0xd2,0xa5,0xcf,0xcf,0xa5,0xa5,0xa5,0xa5,0xcf,0xcf,
0x309,0x309,0xa5,0xa5,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,
0xcf,0xd2,0xd2,0xd2,0xcf,0xcf,0x336,0xcf,0x336,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,
0xa5,0xcf,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xcf,0xcf,0xa5,0x309,0xa5,0xa5,0xa5,0x6d8,
0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,
0x8b8,0x8b8,0x8b8,0x8b8,0xa5,0x6d8,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xde,0xd5,0xde,0xd5,
0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0x306,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0x49e,0x49e,
0xa5,0xa5,0xa5,0xa5,0xcf,0xcf,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0x4a4,0x4a1,0xa5,
0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,
0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,
0xa5,0xa5,0xa5,0x6d8,0x8b8,0x6d8,0x6d8,0x6d8,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,
0x306,0x306,0x306,0x306,0xa5,0xa5,0xa5,0xa5,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,
0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0xa5,0xa5,0x306,0x306,0x306,0x306,0x8ac,0x8ac,
0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x336,0x336,0xa5,0x306,0x306,0x306,0x306,0x306,
0x306,0x306,0xa5,0xa5,0xa5,0xa5,0xcf,0xcf,0xcf,0xcf,0x336,0x336,0xcf,0xcf,0x336,0x336,
0xa5,0xa5,0xa5,0xa5,0x336,0x336,0xcf,0xcf,0x336,0x336,0xa5,0xa5,0xa5,0xa5,0x336,0x336,
0x306,0xa5,0xcf,0x336,0xa5,0xa5,0x306,0x336,0x336,0x336,0xcf,0xcf,0xa5,0xa5,0xa5,0xa5,
0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0x336,0x306,0x336,0x306,0xa5,0xcf,
0xcf,0xcf,0xcf,0xcf,0xcf,0xa5,0xa5,0x306,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,
0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x918,0x918,0x8b8,0xae,0xae,0xae,0xae,0xa5,0x336,0x336,0xa5,
0xa5,0x306,0xa5,0xa5,0xa5,0xa5,0x306,0x306,0xa5,0xa5,0xa5,0xa5,0xa14,0xa14,0x8a9,0x8a9,
0xa56,0x6d8,0xae,0xae,0x30c,0xba,0x30c,0xae,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,
0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0x49b,0x49b,0x49b,0x49b,0x49b,0x49b,0x49b,0x49b,
0xa5,0xae,0xae,0xae,0xa5,0xa5,0xa5,0xa5,0x336,0xa5,0x336,0xa5,0xa5,0xa5,0xa5,0xa5,
0x49b,0x49b,0x49b,0x49b,0x49b,0x49b,0x49b,0x49b,0x49b,0x49b,0x49b,0x49b,0xa5,0xa5,0xa5,0xa5,
0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0x336,0x336,0xcf,0x336,0x306,0x306,0xa5,0x306,
0x30c,0x306,0x306,0xa5,0x306,0x336,0xcf,0x336,0x6d8,0x6d8,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,
0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0xa53,0xb37,0x1170,0xae,0xae,0xae,0xae,0x102c,0xa5,0xa5,
0xae,0xae,0x1032,0x1032,0xba,0xba,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,
0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0x102c,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,
0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0x309,0xa5,0xa5,
0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0x102c,0xa5,0x102c,0xa5,
0xa5,0xa5,0xa5,0x102c,0x102c,0x102c,0xa5,0xf27,0xa5,0xa5,0xa5,0xb7,0xb7,0xb7,0xb7,0xfab,
0xfab,0xa5,0xab,0xab,0xae,0xa5,0xa5,0xa5,0x8b2,0x8af,0x8b2,0x8af,0x8b2,0x8af,0x8b2,0x8af,
0x8b2,0x8af,0x8b2,0x8af,0x8b2,0x8af,0x2d9,0x2d9,0x2d9,0x2d9,0x2d9,0x2d9,0x2d9,0x2d9,0x2d9,0x2d9,
0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,
0x102c,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0x102c,
0x336,0xcf,0x336,0x336,0xd2,0xcf,0xcf,0x336,0x336,0xd2,0xcf,0x336,0xd2,0xcf,0xcf,0x336,
0xcf,0x336,0xea,0xe1,0xcf,0x336,0xcf,0xcf,0xcf,0xcf,0x336,0xcf,0xcf,0x336,0x336,0x336,
0x336,0xcf,0xcf,0x336,0xd2,0x336,0xd2,0x336,0x336,0x336,0x336,0x336,0x342,0xe4,0x336,0xe4,
0xe4,0xcf,0xcf,0xcf,0x336,0x336,0x336,0x336,0xcf,0xcf,0xcf,0xcf,0x336,0x336,0xcf,0xcf,
0xcf,0xd2,0xcf,0xcf,0xd2,0xcf,0xcf,0xd2,0x336,0xd2,0xcf,0xcf,0x336,0xcf,0xcf,0xcf,
0xcf,0xcf,0x336,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,
0x339,0x336,0xd2,0xcf,0x336,0x336,0x336,0x336,0xcf,0xcf,0x336,0x336,0xcf,0xd2,0x339,0x339,
0xd2,0xd2,0xcf,0xcf,0xd2,0xd2,0xcf,0xcf,0xd2,0xd2,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,
0xd2,0xd2,0x336,0x336,0xd2,0xd2,0x336,0x336,0xd2,0xd2,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,
0xcf,0xcf,0xcf,0xcf,0xcf,0x336,0xcf,0xcf,0xcf,0x336,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,
0xcf,0x336,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xd2,0xd2,0xd2,0xd2,0xcf,0xcf,0xcf,0xcf,
0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0x336,0xcf,0xcf,0xcf,0xcf,
0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,
0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xd2,0xd2,0xd2,0xd2,
0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xd2,0xd2,0xd2,0xd2,0xcf,0xd8,0xcf,0xcf,0x8b8,0x8b8,
0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x12c,0x12c,0x12c,0x12c,
0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,
0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x11d,0x11d,0x11d,0x11d,0x11d,0x11d,
0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,
0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x879,0x879,0x879,0x879,
0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x879,0x12c,0x12c,0x2d3,0x12c,
0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x11d,0x11d,0x8ca,0x9ff,0x1743,0x1743,0x129,0x12f,0x12c,0x126,
0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,
0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x12c,0x126,0x12c,0x126,
0x12c,0x126,0x12c,0x126,0x12c,0x126,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,
0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x12c,0x126,
0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x12c,0x126,0xfb1,0xfb1,0xfb1,0xfb1,0xfb1,0xfb1,
0xfb1,0xfb1,0xfb1,0xfb1,0xfb1,0xfb1,0xfb1,0xfb1,0x12c,0x126,0x12c,0x126,0x12c,0x126,0x129,0x12f,
0x129,0x12f,0x12c,0x126,0x12c,0x126,0x12c,0x126,0x12c,0x126,0x12c,0x126,0x12c,0x126,0x12c,0x126,
0x129,0x12c,0x126,0x129,0x12c,0x126,0x129,0x12f,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,
0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x129,
0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,
0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x126,0x126,0x126,0x126,0x126,0x126,0x126,
0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x129,0x129,0x129,0x129,0x129,0x129,0x129,
0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0x126,0x12c,0x2ac,0x2af,0x1743,0x1743,0x1743,0x1743,
0x1743,0x1743,0x1743,0x1743,0x1743,0x1743,0x1743,0x1743,0x1743,0x1743,0x1743,0x1743,0x129,0x126,0x129,0x129,
0x129,0x129,0x129,0x129,0x126,0x129,0x126,0x126,0x129,0x129,0x126,0x126,0x129,0x129,0x126,0x129,
0x126,0x129,0x126,0x126,0x129,0x126,0x126,0x129,0x126,0x129,0x126,0x126,0x129,0x126,0x129,0x129,
0x126,0x126,0x126,0x129,0x126,0x126,0x126,0x126,0x126,0x129,0x126,0x126,0x126,0x126,0x126,0x126,
0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,0x126,
0x129,0x129,0x126,0x126,0x129,0x126,0x129,0x126,0x126,0x126,0x126,0x126,0x12c,0x12c,0x126,0x12c,
0x126,0x12c,0x126,0x12c,0x126,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x12c,0x126,0x129,0x12f,0x12c,
0x126,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x12c,
0x126,0x12c,0x126,0x12c,0x126,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,
0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,
0x12f,0x12c,0x126,0x129,0x12f,0x12c,0x126,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,
0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,
0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x129,0x12f,0x12c,0x12c,0x12c,0x12c,
0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,
0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12f,0x12f,0x12f,0x12f,
0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,
0x12f,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x12c,0x189,0x189,0x57c,0x57c,
0x2a0,0x2a3,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x2be,0x183,0xc84,0xc81,0xfc6,
0xfc6,0xfc6,0xfc6,0xfc6,0x12cc,0xf3c,0xf3c,0xc00,0xc00,0xb46,0xc00,0xc00,0xf48,0x57c,0x57c,0x186,
0x98d,0x189,0x189,0x189,0x189,0x189,0x189,0x189,0x189,0x189,0x189,0x189,0x189,0x189,0x189,0x189,
0x189,0x54c,0x54c,0x54c,0x54c,0x54c,0x54c,0x54c,0x54c,0x54c,0x54c,0x54c,0x54c,0x54f,0x54c,0x54c,
0x54c,0x54c,0x54c,0x54c,0x54c,0x54f,0x54c,0x54c,0x54f,0x54c,0x54c,0x54c,0x54c,0x54c,0x104d,0xfc3,
0x57f,0x189,0x186,0x186,0x186,0x57c,0x57c,0x57c,0x57c,0x57c,0x57c,0x57c,0x57c,0x186,0x186,0x186,
0x186,0x64e,0xe04,0xfc3,0x189,0x5d3,0x5d6,0x567,0x567,0xf48,0x104d,0x104d,0x549,0x549,0x549,0x549,
0x549,0x549,0x549,0x549,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,0x192,
0x192,0x192,0x192,0x192,0x192,0x18c,0x18c,0x18c,0x18c,0x18c,0x18c,0x8df,0x8df,0xaa4,0xaa4,0x2a6,
0xaa1,0x1098,0x1098,0x1098,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,
0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,0x18f,
0x18f,0x18f,0x18f,0x18f,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b6,0x1b6,0x1b6,0x1b6,
0x1b6,0x1b6,0x1b6,0x1b6,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b3,0x1b6,0x1b6,0x1b6,0x1b6,
0x1b6,0x1b6,0x1b6,0x1b6,0x1d1,0x1d1,0x1d1,0xe0d,0xe0d,0xe0d,0xe0d,0xe0d,0x1ce,0x1ce,0x1ce,0x1ce,
0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,
0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0x1ce,0xe0a,0xe0a,
0xe0a,0xe0a,0xe0a,0xe0a,0x1d4,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,
0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,
0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x1d1,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,
0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x237,0x237,
0x237,0x237,0x22b,0x660,0xc99,0xc99,0xcb1,0xc99,0x36c,0x36c,0x36c,0x36c,0x36c,0x36c,0x36c,0x36c,
0x36c,0x36c,0x36c,0x36c,0x231,0x231,0x231,0x231,0x363,0x363,0x363,0x363,0x363,0x363,0x363,0x363,
0x363,0x363,0x22b,0x22b,0x22b,0x22b,0x22b,0x22b,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,
0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,
0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0x23d,0x237,0xc9c,0xc99,0xc9c,0xc99,0xc9c,0xc99,
0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x1044,0x555,0x555,0x555,0x555,0x555,0x555,
0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x555,0x1044,0x1524,0x1524,0xcba,0x5ac,0x246,
0x49e,0x4aa,0x4aa,0x4aa,0x4aa,0x4aa,0x4aa,0x4aa,0x4aa,0x4aa,0x648,0x648,0x648,0x648,0x642,0x642,
0x50a,0x51f,0x51f,0x51f,0x51f,0x51c,0x459,0x504,0x7e3,0x7e3,0x7e3,0x91b,0x939,0x936,0x7f8,0x2a9,
0x2df,0x2df,0x2df,0x2df,0x2df,0x2df,0x2df,0x2df,0x2df,0x2df,0x2df,0x2df,0x2df,0x2df,0x2df,0x2df,
0x2df,0x2df,0x2df,0x2df,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,
0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,
0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2dc,0x2f4,0x2f4,0x2f4,0x2f4,0x2f4,0x2f4,0x2f4,0x2f4,0x2f4,0x2f4,
0x2f4,0x2f4,0x2f4,0x2f4,0x2f4,0x2f4,0x2f4,0x2f4,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,
0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x2f1,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,
0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,
0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x306,0x381,0x381,0x381,0x381,0x381,0x381,0x381,0x381,
0x381,0x381,0x381,0x381,0x381,0x381,0x381,0x381,0x381,0x381,0x381,0x381,0x381,0x381,0x381,0x381,
0x381,0x381,0x381,0x381,0x381,0x381,0x381,0x381,0x909,0x3b1,0x3a8,0x3a5,0x3ab,0x3ae,0x39f,0x3a2,
0x3a2,0x3a2,0x3a2,0x3a2,0x3a2,0x3a2,0x3a2,0x3a2,0x3b4,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,
0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,
0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x39f,0x63f,0x63f,0x3ba,0x3f9,0x3f9,0x3f9,
0x3f9,0x3f9,0x3f9,0x3f3,0x3f3,0x3f3,0x3f3,0x3f3,0x3f3,0x3f3,0x3f3,0x3f3,0x3f3,0x3f3,0x3f3,0x3f3,
0x3f3,0x3f3,0x3f3,0x3f3,0x3f3,0x3f3,0x3f3,0x3bd,0x3db,0x3b7,0x3e1,0x3e4,0x3de,0x3f6,0x3f6,0x3f6,
0x3f6,0x3f6,0x3f6,0x3f0,0x3f0,0x3f0,0x3f0,0x3f0,0x3f0,0x3f0,0x3f0,0x3f0,0x3f0,0x3f0,0x3f0,0x3f0,
0x3f0,0x3f0,0x3f0,0x3f0,0x3f0,0x3f0,0x3f0,0x3bd,0x3db,0x3b7,0x3db,0x90c,0x3c6,0x4fe,0x501,0x507,
0x44d,0x4b3,0x534,0x4b0,0x53a,0x537,0x540,0x53d,0x4fb,0x4f8,0x4fb,0x4f8,0x4f5,0x4f2,0x49e,0x507,
0x4f5,0x4f2,0x4f5,0x4f2,0x4f5,0x4f2,0x4f5,0x4f2,0x50d,0x513,0x516,0x510,0x4bc,0x4bc,0x4bc,0x4bc,
0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,
0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0x4bc,0xa1a,0xa1a,0xb40,0x450,0x56a,0x567,0x56a,0x567,
0xd8c,0xd89,0xd8c,0x12de,0x12db,0x12de,0x12db,0x12de,0x12db,0x12de,0x13e6,0x13e3,0x462,0x474,0x474,0x492,
0x492,0x468,0x456,0x468,0x456,0x468,0x456,0x468,0x456,0x468,0x456,0x468,0x528,0x528,0x528,0x528,
0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x45f,0x45f,0x45f,
0x45f,0x45f,0x45f,0xa0b,0xa0b,0xa0b,0xa0b,0x52e,0x52e,0x52e,0x52e,0x52e,0x45f,0x45f,0x45f,0x45f,
0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,
0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0x45f,0xa0b,0xa0b,
0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,
0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,
0x4ad,0x4ad,0x4b6,0x4b6,0x4ad,0x4b6,0x4ad,0x4b6,0x4b6,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,0x4ad,
0x4ad,0x4ad,0x4ad,0x4b6,0x4ad,0x4b6,0x4ad,0x4b6,0x4b6,0x4ad,0x4ad,0x4b6,0x4b6,0x4b6,0x4ad,0x4ad,
0x4ad,0x4ad,0x110d,0x110d,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,
0x91e,0x91e,0x91e,0x91e,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,
0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,
0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0x4b6,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,
0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xb3d,0xd74,0xd74,0xd74,0xd74,
0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,
0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,0x4bf,
0x4bf,0x4bf,0xf33,0xf33,0xf33,0xf33,0xf33,0x4c8,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,
0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,
0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c5,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,
0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,0x4c2,
0x4c2,0x4c2,0x4c2,0x4c2,0x4ce,0x4cb,0x4ce,0x4d1,0x4cb,0x4ce,0x4cb,0x4ce,0x4cb,0x4ce,0x4cb,0x4cb,
0x4cb,0x4cb,0x4cb,0x4cb,0x4ce,0x4ce,0x4cb,0x4ce,0x4ce,0x4cb,0x4ce,0x4ce,0x4cb,0x4ce,0x4ce,0x4cb,
0x4ce,0x4ce,0x4cb,0x4cb,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,
0xa0b,0xa0b,0xa0b,0xa0b,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,
0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,0x4da,
0x4da,0x4da,0x4da,0x16a1,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,
0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,0x4dd,
0x4dd,0x4dd,0x4dd,0x4dd,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x933,0x4e6,0x4e0,0x4e6,
0x4e0,0x4e6,0x4e0,0x4e6,0x4e0,0x4e6,0x4e0,0x4e0,0x4e3,0x4e0,0x4e3,0x4e0,0x4e3,0x4e0,0x4e3,0x4e0,
0x4e3,0x4e0,0x4e3,0x4e0,0x4e3,0x4e0,0x4e3,0x4e0,0x4e3,0x4e0,0x4e3,0x4e0,0x4e3,0x4e0,0x4e3,0x4e6,
0x4e0,0x4e3,0x4e0,0x4e3,0x4e0,0x4e3,0x4e0,0x4e0,0x4e0,0x4e0,0x4e0,0x4e0,0x4e3,0x4e3,0x4e0,0x4e3,
0x4e3,0x4e0,0x4e3,0x4e3,0x4e0,0x4e3,0x4e3,0x4e0,0x4e3,0x4e3,0x4e0,0x4e0,0x4e0,0x4e0,0x4e0,0x4e6,
0x4e0,0x4e6,0x4e0,0x4e6,0x4e0,0x4e0,0x4e0,0x4e0,0x4e0,0x4e0,0x4e6,0x4e0,0x4e0,0x4e0,0x4e0,0x4e0,
0x4e3,0x4e6,0x4e6,0x4e3,0x4e3,0x4e3,0x4e3,0x4ef,0x522,0x4e9,0x4ec,0x92a,0x528,0x528,0x528,0x528,
0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,
0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0xf39,0xf39,0xf39,0xf39,
0xf03,0xf03,0xf03,0xf03,0xf03,0xf03,0xf03,0xf03,0xa0b,0x915,0x915,0x915,0x915,0x915,0x915,0x915,
0x915,0x915,0x915,0x915,0x915,0x915,0x915,0x915,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,
0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,0x528,
0x528,0x528,0x528,0x528,0x528,0x528,0x528,0xa0b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,
0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,
0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x52b,0x915,0x915,0x915,0x915,0x915,0x915,0x915,
0x915,0x915,0x915,0x915,0x915,0x915,0x915,0x915,0x68d,0x669,0x669,0x669,0x669,0x663,0x669,0x669,
0x67e,0x669,0x669,0x678,0x675,0x67b,0x67b,0x67b,0x67b,0x67b,0x67e,0x663,0x66f,0x663,0x663,0x663,
0x6ab,0x6ab,0x663,0x663,0x663,0x663,0x663,0x663,0x681,0x681,0x681,0x681,0x681,0x681,0x681,0x681,
0x681,0x681,0x663,0x663,0x663,0x663,0x663,0x663,0x663,0x663,0x663,0x663,0x666,0x6b1,0x663,0x6b1,
0x663,0x6ae,0x672,0x66c,0x672,0x66c,0x687,0x687,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,
0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,
0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x690,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,
0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,
0x696,0x696,0x696,0x696,0x696,0x696,0x693,0x693,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,
0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,
0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x696,0x699,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,
0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,
0x69c,0x69c,0x69c,0x69c,0x699,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,
0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,0x69c,
0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,
0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x6d8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,
0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,
0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,0x6ea,
0x705,0x705,0x705,0x705,0x705,0x705,0x705,0xa9b,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,
0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,
0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0xa9b,0x705,0x705,0x705,0x705,
0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x705,0x72c,0x72c,0x72c,0x72f,
0x72f,0x72c,0x72c,0x72c,0x729,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,
0x813,0x813,0x726,0x801,0x801,0x801,0x801,0x801,0x801,0x801,0x726,0x726,0x72c,0x72c,0x72c,0x72c,
0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,
0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x72c,0x762,0x762,0x762,0x762,
0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,
0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x765,
0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,
0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x819,0x819,0x762,
0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,
0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x762,0x7d4,0x7d4,0x7d4,0x7d4,0x7d4,0x7d4,0x7d4,0x7d4,
0x7d4,0x7d4,0x77a,0x77a,0x76b,0x76b,0x76b,0x76b,0x774,0x774,0x774,0x774,0x774,0x774,0x771,0x771,
0x81f,0x81f,0xccf,0xccf,0xccf,0xccf,0xda4,0xda4,0x774,0x774,0xccf,0x774,0x774,0x774,0x777,0x774,
0xccf,0x774,0x774,0xcc6,0x76e,0x81f,0x81f,0x81f,0x81f,0x771,0x81f,0xda4,0xda4,0xda4,0x81f,0x822,
0x76e,0x825,0xdaa,0xcc9,0xcc9,0xda4,0xda4,0xccf,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,
0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,
0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x774,0x789,0x789,0x789,0x789,0x789,0x789,0x789,0x789,
0x789,0x789,0x789,0x789,0x789,0x789,0x789,0x789,0x789,0x789,0x789,0x789,0x789,0x789,0x789,0x789,
0x789,0x789,0x789,0x789,0x789,0x789,0x789,0x789,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,
0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7b9,0x7bf,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0xe25,
0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe22,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,
0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,
0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7bc,0x7c2,0x7c2,0x7c2,0x7c2,
0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,
0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7c2,0x7da,0x7da,0x7da,0x7da,
0x7da,0x7da,0x7da,0x7da,0x7da,0x7da,0x7da,0x7da,0x7da,0x7da,0x7da,0x7da,0x7da,0x7da,0x7da,0x7da,
0x7da,0x7da,0x7da,0x7da,0x1035,0x1035,0x1035,0x16fe,0x16fe,0x16fe,0x16fe,0x16fe,0x7dd,0x7dd,0x7dd,0x7dd,
0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,
0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7dd,0x7e0,0x7e0,0x7e0,0x7e0,
0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,
0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e0,0x7e6,0x7e6,0x7e6,0x7e6,
0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,
0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x7e6,0x1701,0x1701,
0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x7e9,0x7e9,0x92d,0x92d,0x7e9,0x7e9,0x7e9,0x7e9,
0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x92d,0x7e9,0x7e9,0x7e9,
0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7e9,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,
0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ef,0x7ec,0x7ec,
0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,
0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,0x7ec,
0x855,0x855,0x855,0x855,0x855,0x885,0x885,0x88b,0x88b,0x88b,0x852,0x852,0x852,0x888,0x888,0x888,
0x888,0x888,0x888,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x84c,0x88b,0x88b,0x88b,0x88b,0x88b,
0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,
0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,
0x852,0x852,0x855,0x855,0x88b,0x88b,0x88b,0x852,0x852,0x88b,0x88b,0x88b,0x88b,0x88b,0x88b,0x88b,
0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,
0x852,0x852,0x852,0x852,0x852,0x852,0x88b,0x88b,0x88b,0x88b,0x852,0x852,0x852,0x852,0x852,0x852,
0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x855,0x855,0x855,0x855,0x855,0x855,0x852,0x852,0x852,
0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,
0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x852,0x1359,0x1359,0x861,0x858,0x85e,0x85e,
0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x858,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x861,0x861,
0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,
0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x858,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x858,0x85e,0x85e,
0x85e,0x85e,0x85e,0x85e,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,
0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x858,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,
0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,0x85b,
0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,
0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,
0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x861,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,0x85e,
0x85e,0x85e,0x85e,0x85e,0x861,0x861,0x861,0x861,0x867,0x867,0x867,0x867,0x867,0x867,0x98a,0x98a,
0x864,0x864,0x864,0x864,0x864,0x864,0x864,0x864,0x864,0x864,0x864,0x864,0x864,0x864,0x864,0x864,
0x864,0x864,0x864,0x864,0x864,0x864,0x864,0x864,0x864,0x864,0x987,0x987,0x9e4,0x9e4,0x9e4,0x9e4,
0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x867,0x867,0x867,0x867,
0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,
0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x867,0x876,0x876,0x876,0x876,
0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x876,
0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x876,0x11bb,0x87c,0x87c,0x87c,0x87c,
0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,
0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87c,0x87f,0x87f,0x87f,0x87f,
0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,
0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x87f,0x1701,
0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x17ac,0x17ac,0x882,0x882,0x882,0x882,0x882,0x882,0x882,0x882,
0x882,0x882,0x882,0x882,0x882,0x882,0x882,0x882,0x882,0x882,0x882,0x882,0x882,0x882,0x882,0x882,
0x882,0x882,0x882,0x882,0x882,0x882,0x882,0x882,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,
0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8ac,0x8b8,
0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x96c,
0x972,0xa53,0xa53,0xa53,0xa53,0xa53,0xa53,0xa53,0xa53,0xa53,0xa53,0xa53,0xb91,0xb91,0xb91,0xb91,
0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0x8ac,0xa11,0xa11,0xa11,0xa11,0xa11,0xa11,
0x96c,0x96c,0xa53,0xb34,0xa53,0xa53,0xa53,0xa53,0xa53,0xa53,0xa53,0xa53,0xa53,0xc36,0xf18,0xf18,
0xa65,0xa65,0xa65,0xa65,0xa65,0xa6b,0xa68,0xb91,0xb91,0xb91,0xb91,0x107d,0xc51,0x107d,0xfae,0xfae,
0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,
0x8b8,0x8b8,0x912,0x90f,0x912,0x90f,0x912,0x90f,0xd68,0xd65,0xc57,0xc54,0x8b8,0x8b8,0x8b8,0x8b8,
0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,
0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8be,
0x8bb,0x912,0x90f,0x8be,0x8bb,0x8be,0x8bb,0x8be,0x8bb,0x8be,0x8bb,0x8be,0x8bb,0x8be,0x8bb,0x8be,
0x8bb,0x8be,0x8bb,0x8be,0x8bb,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,
0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,
0x8be,0x8bb,0x8be,0x8bb,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,
0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,
0x8be,0x8bb,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,
0x8c4,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,
0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8c4,0x8c4,0x8c4,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,
0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,
0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8b8,0x8c1,0x8b8,0x8b8,0x8b8,0x91e,0x91e,0x91e,0x91e,
0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,
0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x91e,0x96c,0xa11,0xa53,0xa53,
0xa53,0xa53,0xa53,0xa53,0xa53,0xa53,0xb34,0xb34,0xa53,0xa53,0xa53,0xa53,0xa53,0xa53,0xb8e,0xc36,
0xc36,0xc36,0xc36,0xc36,0xc36,0xc36,0xc36,0xc36,0xc36,0xf2a,0xf2a,0xf1b,0x96c,0x96c,0x96c,0x96c,
0x96c,0x96c,0x96c,0x96c,0x96c,0x96c,0x96c,0x96c,0x96c,0x96c,0xa53,0xa53,0xa53,0xa53,0xa53,0xa53,
0xb8e,0xb8e,0xb8e,0xb8e,0xb8e,0xb8e,0xb8e,0xd6e,0xd6e,0xc36,0xc36,0xc36,0x9b1,0x9b1,0x9b1,0x9b1,
0x9b1,0x9b1,0x996,0x996,0x996,0x996,0x996,0x984,0x9bd,0x9bd,0x9bd,0x9b7,0x9bd,0x9bd,0x9bd,0x9bd,
0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x9b7,0x9bd,0x9bd,0x9bd,0x9bd,0x99f,0x99f,0x9ba,0x9ba,
0x9ba,0x9ba,0x99c,0x99c,0x99c,0x99c,0x99c,0x9b1,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,
0xabc,0xabc,0xabc,0xabc,0xa8f,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0x9bd,0x9bd,0x9bd,0x9bd,
0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x9b7,0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,
0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x9bd,0x99f,0x99f,0x99f,0x9ae,0x9ae,0x9ae,0x9ae,
0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,
0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9ae,0x9b1,0x9b1,0x9b1,0x9b1,
0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,
0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9b1,0x9db,0x9db,0x9db,0x9db,
0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,
0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9db,0x9e4,0x9e4,0x9e4,0x9e4,
0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,
0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0x9e4,0xa05,0xa05,0xa05,0xa05,
0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,
0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa05,0xa41,0xa41,0xa41,0xa41,
0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,
0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xa41,0xb16,0xb16,0xb16,0xb16,
0xb16,0xb16,0xb16,0xb16,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,0xa4d,
0xa4d,0xa4d,0xa4d,0xb8b,0xb8b,0xb8b,0xb8b,0xc33,0xc33,0xc33,0xc33,0xc33,0xa62,0xa62,0xa62,0xa62,
0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa62,0xa5f,0xa5f,0xa5f,0xa5f,0xa5f,0xa5f,
0xa5f,0xa5f,0xa5c,0xb13,0xc42,0xc39,0xc4e,0xc36,0xa59,0xa59,0xc36,0xc36,0xa86,0xa83,0xa86,0xa83,
0xa86,0xa83,0xa86,0xa83,0xa86,0xa83,0xa86,0xa83,0xa86,0xa83,0xa86,0xa83,0xa86,0xa83,0xa86,0xa83,
0xa86,0xa83,0xa86,0xa83,0xa86,0xa83,0xa86,0xa83,0xa86,0xa83,0xa86,0xa83,0xa9e,0xa9e,0xa9e,0xa9e,
0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,
0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xa9e,0xaad,0xaad,0xaad,0xaad,
0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,
0xaad,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaa7,0xaaa,0xaaa,0xaaa,0xaaa,
0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,
0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaaa,0xaad,0xaad,0xaad,0xaad,
0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,
0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xaad,0xac8,0xac8,0xac8,0xac8,
0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,
0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xac8,0xab0,0xabc,0xabc,0xabc,0xabc,
0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,
0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xabc,0xac8,0xac8,0xac8,0xac8,0xac8,0xadd,0xadd,0xadd,0xadd,
0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0x1779,0xada,0xada,0xada,0xada,
0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,
0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0xada,0x1776,0xadd,0xadd,0xadd,0xadd,
0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,
0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xadd,0xaf2,0xaf2,0xb6d,0xaf2,
0xaf2,0xaf2,0xb70,0xaf2,0xaf2,0xaf2,0xaf2,0xb6d,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,
0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xaf2,0xafb,0xafb,0xafb,0xafb,
0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,
0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xafb,0xb01,0xb01,0xb01,0xb01,
0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,
0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb01,0xb0a,0xb0a,0xb0a,0xb0a,
0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,
0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb0a,0xb3a,0xb3a,0xb3a,0xb3a,
0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,
0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb3a,0xb43,0xb43,0xb43,0xb43,
0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xb43,0xd77,0xd77,0xd77,0xd77,
0xd77,0xd77,0xd77,0xd77,0xd77,0xd77,0xd77,0xd77,0xd77,0xd77,0xd77,0xd77,0xb73,0xb73,0xb49,0xb49,
0xc06,0xc06,0xc06,0xc06,0xc06,0xc06,0xc06,0xd89,0xd89,0xd8c,0xd8f,0xd89,0xd80,0xd83,0xd83,0xd86,
0xd86,0xd86,0xd86,0xd86,0xd86,0xd86,0xd86,0xd86,0xd86,0xd86,0xd86,0xd86,0xb82,0xb82,0xca2,0xc9f,
0xca2,0xc9f,0xca2,0xc9f,0xca2,0xc9f,0xca2,0xc9f,0xca2,0xc9f,0xca2,0xc9f,0xc90,0xc90,0xc96,0xc90,
0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,0xb91,0xb91,0xb91,0xb8e,
0xb8e,0xb8e,0xb8e,0xb8e,0xdec,0x102c,0x102c,0x102c,0x102c,0xfa5,0xfa5,0xfa5,0x102f,0xfa8,0xfa8,0x102f,
0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x1404,0x1404,0x1404,0x1404,0x14b8,0xb8e,0xb8e,0xb8e,0xb8e,
0xc36,0xc36,0xc36,0xc36,0xc36,0xc36,0xc36,0xc36,0xc36,0xc36,0xc36,0xc36,0xc51,0xc51,0xc51,0xc51,
0xc51,0xc51,0xc51,0xc51,0xc51,0xc51,0xc51,0xc51,0xc51,0xc51,0xc51,0xc51,0xba9,0xba6,0xba9,0xba9,
0xba9,0xba6,0xba6,0xba9,0xbac,0xbaf,0xbac,0xbaf,0xbac,0xc96,0xc96,0xc96,0xe10,0xc90,0xc96,0xc90,
0xba0,0xba3,0xba0,0xba6,0xc99,0xc99,0xc99,0xc99,0xcab,0xcae,0xe10,0xe10,0xbb2,0xbb5,0xbb5,0xbb5,
0xbb5,0xbb5,0xbb5,0xbb5,0xbb5,0xbb5,0xbb5,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,0xc18,
0xbb5,0xbb5,0xbb5,0xbb5,0xbb5,0xbb5,0xbb5,0xbb5,0xbb5,0x177f,0x177f,0x1872,0xc0f,0xc0f,0xc0f,0xc0f,
0xbbe,0xbc4,0xbc7,0xbc4,0xbc7,0xbc4,0xbc7,0xbc4,0xbc7,0xbc4,0xbc7,0xbc4,0xbc4,0xbc4,0xbc7,0xbc4,
0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,0xbc4,
0xbc4,0xbc4,0xbc4,0xbc4,0xc15,0xc0f,0xc0f,0xc0f,0xc0f,0xc0f,0xc0f,0xc12,0xc0f,0xc12,0xbbe,0xbbe,
0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,
0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,0xbe8,
0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,
0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,0xbfa,
0xbfa,0xbfa,0xbfa,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,0x11e5,
0x11e5,0x11e5,0x11e5,0x11e5,0xd86,0xd86,0xd86,0xd86,0xd86,0xd86,0xd86,0x12d5,0x12d5,0x12d5,0x12d5,0x12d5,
0x12d5,0x12d5,0x12d5,0x12d5,0x12d5,0x12d5,0x12d5,0x12d5,0x12d5,0x12db,0x1515,0x1515,0x1542,0x1515,0x17dc,0x1482,
0x1047,0xf3f,0xc06,0xc06,0xc27,0xc27,0xc27,0xc27,0xd6b,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,
0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,
0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc27,0xc96,0xc90,0xc96,0xc90,
0xc96,0xc90,0xc96,0xc90,0xc33,0xc30,0xc30,0xca8,0xca5,0xfd8,0xfd2,0x1371,0xfcf,0xfcc,0x10a7,0x10a4,
0x11a0,0x11a0,0x11a6,0x11a0,0x11a6,0x11a0,0x11a6,0x11a0,0x11a6,0x11a0,0x11a6,0x11a0,0xc51,0xc51,0xc51,0xc51,
0xc51,0xc36,0xc36,0xc51,0xc51,0xc51,0xc51,0xc51,0xc51,0x116a,0x116a,0x116a,0xd6e,0xc36,0xc36,0xc36,
0xc36,0xf27,0xf18,0xf18,0xf18,0xf18,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0xc48,0xc48,0xc45,0xc3c,
0xc45,0xc3c,0xc45,0xc3c,0xc45,0xc3c,0xc4b,0xc4b,0xc4b,0xc4b,0xc5d,0xc5a,0xd5f,0xeee,0x1077,0x1074,
0x1074,0x1077,0x1071,0x1071,0x1071,0x1077,0x107a,0x107a,0x12b7,0x116d,0x116d,0x116a,0xc3f,0xc3f,0xc3f,0xc3f,
0xf2a,0xf2a,0xf1b,0xf1b,0xf1b,0xf18,0xf18,0xf18,0xf18,0xf1b,0x102c,0xf1b,0xf1b,0xf1b,0xf18,0xf1b,
0xf2a,0xf18,0xf18,0xf18,0xf1b,0xf1b,0xf18,0xf18,0xf1b,0xf18,0xf18,0xf1b,0xfba,0xfb7,0xc75,0xc6f,
0xc75,0xc6f,0xc75,0xc6f,0xc75,0xc6f,0xc75,0xc6f,0xc75,0xc6f,0xc72,0xdda,0xd95,0xd95,0xd95,0xc6c,
0x1119,0x1119,0x1119,0x1119,0x1119,0x1119,0x1119,0x1119,0xd9b,0xd9b,0xc69,0xc7e,0xc75,0xc6f,0xc75,0xc6f,
0xc75,0xc6f,0xc75,0xc6f,0xc75,0xc6f,0xc75,0xc6f,0xc75,0xc6f,0xc75,0xc6f,0xc75,0xc6f,0xc75,0xc6f,
0xc75,0xc6f,0xc75,0xc6f,0xc75,0xc6f,0xc75,0xc6f,0xc75,0xc6f,0xc75,0xc6f,0x118b,0x1188,0x118b,0x1188,
0x1194,0x1194,0x13e0,0x1119,0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,
0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,0xc96,0xc90,
0xc96,0xc90,0xc96,0xc90,0xcae,0xc90,0xc90,0xc90,0xc90,0xc90,0xc90,0xc90,0xc90,0xc96,0xc90,0xc96,
0xc90,0xc96,0xc96,0xc90,0xccf,0xccf,0xda4,0xcc6,0xcc9,0xda4,0xda4,0xccc,0xccc,0xccc,0xccc,0xccc,
0xccc,0xda7,0xccf,0xccc,0xcc3,0xcc3,0xcc3,0xcc3,0xcc3,0xcc3,0xcc3,0xcc3,0xcc3,0xcc3,0xe19,0xe19,
0xe16,0xf4e,0xcc0,0xcc0,0xda4,0xccf,0xcc6,0xccc,0xccc,0xccf,0xccf,0xcc6,0xcc6,0xccc,0xccc,0xccc,
0xccc,0xccc,0xccf,0xccf,0xccf,0xda4,0xda4,0xda4,0xda4,0xccf,0xccf,0xccf,0xccf,0xccf,0xccf,0xccf,
0xccf,0xccf,0xccf,0xccf,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,
0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,0xcf3,
0xcf3,0xcf3,0xcf3,0xcf3,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcf9,0xcfc,0xcfc,
0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,
0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xcfc,0xdb6,0xdb6,0xdb6,0xdb6,0xdb6,0xdb9,0xdb9,0xdb9,0xd62,0xcff,
0xd47,0xd47,0xd47,0xd47,0xd47,0xd47,0xd47,0xd47,0xd47,0xd47,0xd47,0xd47,0xd47,0xd47,0xd47,0xd47,
0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,
0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,0xd0b,
0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd1d,0xd11,0xd23,0xd20,
0xd1a,0xd1a,0xd1a,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,
0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,0xd17,
0xd17,0xd17,0xd17,0xd17,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,
0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,0xd26,
0xd26,0xd26,0xd26,0xd26,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,
0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd35,0xd38,0xd38,0xd38,0xd3b,
0xd38,0xd38,0xd3e,0xd3e,0xd4d,0xd4d,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,
0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,0xd50,
0xd50,0xd50,0xd50,0xd50,0xd4d,0xd4d,0xd4d,0xd4d,0xd4d,0xd4d,0xd4d,0xd4d,0xd4d,0xd4d,0xd4d,0xd4d,
0xd5c,0xd59,0xdce,0xdce,0xdce,0xdce,0xd59,0xd59,0xdce,0xdce,0xdd1,0x1122,0x111f,0x111f,0xd5c,0xd5c,
0xd56,0xd56,0xd56,0xd56,0xd56,0xd56,0xd56,0xd56,0xd56,0xd56,0x10bf,0x10bf,0x10bf,0x10bf,0x10bf,0x10bf,
0xdce,0xdce,0xd59,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,
0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,0xd5c,
0xd74,0xd74,0xd74,0xd74,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0x1110,0x13d4,0x13d4,0x13d4,
0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,
0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,
0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,0xd98,
0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf09,0xf09,0xf09,0xde9,0x1545,
0x101a,0xf15,0x101a,0x101a,0x101a,0x101a,0x101a,0x101a,0x101a,0x101a,0x101a,0x101a,0x101a,0xf15,0x101a,0xf15,
0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,0xf4b,
0xf4b,0xf96,0xe07,0xf00,0xe07,0xe07,0xe07,0xe07,0xe01,0xe01,0xe01,0xe07,0x1368,0x136b,0x155a,0x15ea,
0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,
0xe1f,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe1c,0xe13,0xe13,0xe13,0xe1c,0xe19,0x12ed,0x11af,0x11b5,0x11b5,
0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,
0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,0xe25,
0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,
0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,
0xe34,0xe34,0xe34,0xe31,0xe31,0xe31,0xe2e,0xe2e,0xe2e,0xe2e,0xe31,0xe2e,0xe2e,0xe2e,0xe34,0xe31,
0xe34,0xe31,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,
0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe34,0xe31,0xe31,
0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0xe2e,0x1800,
0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163b,0x163e,0x1638,0x17f7,0x17f7,0x17f7,0x17fa,0x17f4,0x17fa,0x17f4,
0xf51,0xf51,0xf51,0xe40,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,
0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,0xe43,
0xe43,0xe43,0xe43,0xf54,0xe40,0xe40,0xf51,0xf51,0xf51,0xf51,0xe40,0xe40,0xf51,0xf51,0xe40,0xe40,
0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,
0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,0xe49,
0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,
0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,0xe5b,
0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,
0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,0xe6d,
0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,
0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,0xe82,
0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8e,0xe8b,0xe8b,0xe8b,0xe8b,
0xe88,0xe88,0xe88,0xf6c,0xf6c,0xf6c,0xf6c,0xe88,0xe88,0xf72,0xf6f,0xe85,0xe85,0xe94,0xe91,0xe91,
0xf6c,0xf6c,0xe88,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,
0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8b,0xe8e,0xe8b,0xe8e,0xe8b,0xe8b,0xe8b,
0xea9,0xea9,0xea9,0xea9,0xea9,0xea9,0xea9,0xea9,0xea9,0xea9,0xea9,0xea9,0xea9,0xea9,0xea9,0xea9,
0xea9,0xea9,0xea9,0xea9,0xea9,0xea9,0xf78,0xf78,0xf7b,0xf7b,0xea9,0xf78,0xf78,0xf78,0xf78,0xf78,
0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,
0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,0xeb5,
0xf7e,0xeb5,0xf7e,0xf7e,0xf7e,0xebe,0xebe,0xf7e,0xf7e,0xebe,0xeb5,0xebe,0xebe,0xeb5,0xf7e,0xf81,
0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,
0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,0xec7,
0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,
0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xed0,0xecd,0xed3,
0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,
0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed9,0xed6,0xed6,0xed6,
0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0xf03,0xf03,0xf03,0xf03,0x101d,0x1011,
0xf0f,0x101d,0x101d,0x101d,0x101d,0x101d,0x101d,0x101d,0x101d,0x101d,0x101d,0x1470,0x1470,0x1470,0x1470,0x1470,
0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0x114f,0x114f,0x16a4,0x16a4,0x16a4,
0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,0xf06,
0x101a,0x101a,0xf15,0x101a,0x101a,0x101a,0xf15,0x101a,0x101a,0x101a,0xf0f,0xf0f,0xf0f,0xf0f,0xf0f,0x1014,
0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0xf12,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0xf12,
0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x106e,0x106e,0x1614,0x16a4,0x16a4,0x16a4,
0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0x1017,0xf12,0x1017,0xf12,0xf12,0x1017,0x1017,0xf12,
0xf1b,0xf1b,0xfa5,0xf18,0xfa5,0xfa5,0xfa5,0xfa5,0xf18,0xf18,0xf2a,0xf18,0xf18,0xf18,0xf18,0xf18,
0xf18,0xf1b,0xf2a,0xf2a,0xf1b,0xf2a,0xf18,0xf1b,0xf1b,0xf1e,0xf2a,0xf18,0xf18,0xf2a,0xf1b,0xf1b,
0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,
0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,0xf30,
0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,
0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,0xf99,
0xfcf,0xfcc,0xfcf,0xfcc,0xfcf,0xfcc,0xfcf,0xfcc,0xfcf,0xfcc,0x10a7,0x11a6,0x11a6,0x11a6,0x1419,0x1569,
0x11a6,0x11a6,0x1374,0x1374,0x1374,0x136e,0x1374,0x136e,0x156f,0x156c,0x1623,0x1620,0x1623,0x1620,0x1623,0x1620,
0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,
0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,0xff0,
0xffc,0x1062,0xffc,0x1002,0x1002,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,
0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,0xfff,
0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x1062,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,
0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,
0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x100e,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1020,0x1020,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1020,0x1023,0x1023,0x1023,0x1020,0x1023,0x1020,0x1023,0x1020,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1026,0x1023,0x1023,0x1023,0x1023,0x1020,0x1023,0x1020,0x1020,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1020,
0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,0x1020,
0x1020,0x1020,0x1152,0x1152,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,
0x1155,0x13ce,0x13ce,0x13ce,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1155,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1155,0x13ce,0x13ce,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1026,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1152,0x1152,0x1155,0x1155,0x1023,0x1023,0x1026,0x1026,
0x1026,0x12c6,0x1023,0x1026,0x1023,0x1023,0x1026,0x1164,0x1164,0x1155,0x1155,0x13ce,0x13ce,0x13ce,0x13ce,0x13ce,
0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1155,0x1155,0x1155,
0x12c6,0x1155,0x1155,0x1155,0x13ce,0x13ce,0x13ce,0x13fe,0x13fe,0x13fe,0x13fe,0x13fe,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1155,0x1023,0x1155,0x1026,0x1026,
0x1023,0x1023,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1026,0x1026,
0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,0x1026,
0x1026,0x1023,0x1023,0x1023,0x1026,0x1023,0x1023,0x1023,0x1023,0x1026,0x1026,0x1026,0x1023,0x1026,0x1026,0x1026,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1026,0x1023,0x1026,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x12c6,0x1023,0x1023,0x1023,0x1023,0x1155,0x1155,0x13ce,0x106b,0x106b,0x106b,0x106b,
0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1155,0x13ce,0x13ce,0x13ce,0x13ce,0x1356,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1155,0x1155,0x1155,0x1155,
0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1164,0x1164,0x1155,0x1155,0x1155,0x1155,0x1476,0x1155,
0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,
0x1155,0x1155,0x1155,0x1155,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1155,0x1023,0x1023,0x1023,0x1023,0x1023,
0x110a,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1023,0x110a,0x1023,0x1023,0x1023,0x110a,0x1023,0x110a,0x1023,0x110a,0x1023,0x110a,0x1023,0x1023,0x1023,0x110a,
0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x110a,0x110a,0x1023,0x1023,0x1023,0x1023,0x110a,0x1023,0x110a,0x110a,
0x1023,0x1023,0x1023,0x1023,0x110a,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1023,0x12c6,0x12c6,0x13ce,0x13ce,0x1026,0x1026,0x1026,0x1023,0x1023,0x1023,0x1026,0x1026,0x1026,0x1026,0x1026,
0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,
0x1023,0x1023,0x1023,0x1026,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1023,0x1023,0x1023,0x1023,0x1026,0x1026,0x1026,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,0x1023,
0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,
0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,0x1038,
0x103e,0x103b,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,
0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,
0x1083,0x117f,0x1083,0x1083,0x1083,0x1083,0x1083,0x1083,0x1083,0x1083,0x1083,0x1083,0x1083,0x117c,0x117c,0x117c,
0x117c,0x117c,0x117f,0x135f,0x135f,0x1746,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x140d,0x16b0,0x16b0,
0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,
0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,0x10b0,
0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,
0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x10b3,0x1641,
0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,
0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,0x10b6,
0x112b,0x112b,0x112b,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,
0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,0x10d7,
0x1137,0x10ec,0x10ef,0x10ef,0x10ec,0x10f2,0x10f2,0x10e0,0x10e3,0x13ef,0x13f2,0x13f2,0x13f2,0x125d,0x16ce,0x1716,
0x10e6,0x10e6,0x10e6,0x10e6,0x10e6,0x10e6,0x10e6,0x10e6,0x10e6,0x10e6,0x125a,0x1398,0x139b,0x1395,0x139e,0x139e,
0x1134,0x1134,0x10e9,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,
0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,0x10ec,
0x10ec,0x10ec,0x10ec,0x10e9,0x10e9,0x10e9,0x1134,0x1134,0x1134,0x1134,0x1134,0x1134,0x1134,0x1134,0x1134,0x10e9,
0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,
0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,0x1101,
0x1485,0x1485,0x140a,0x13dd,0x1116,0x1116,0x1116,0x1116,0x1116,0x1116,0x1113,0x1113,0x1113,0x1113,0x1113,0x1113,
0x1116,0x1116,0x1116,0x1116,0x1116,0x1116,0x1116,0x1116,0x1116,0x1116,0x1116,0x1116,0x1116,0x1116,0x1116,0x12e1,
0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,
0x1155,0x1155,0x1155,0x1155,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1155,0x1155,0x1155,0x1155,
0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,
0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1161,0x1161,0x1161,0x1158,0x1158,0x1158,0x1152,0x1152,0x1152,0x1152,
0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,
0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1152,0x1155,0x1155,0x1155,0x1155,
0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1164,0x1155,0x1155,0x1155,
0x1155,0x12c9,0x12c9,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1473,0x1155,0x1155,0x1155,
0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,
0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x1155,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,
0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,0x11a0,
0x11a0,0x11a0,0x11a0,0x1167,0x11a9,0x11a9,0x11a9,0x11a9,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,
0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,
0x116a,0x116a,0x154e,0x154e,0x154e,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,
0x116a,0x1617,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x116a,0x14b8,0x154e,0x154e,0x154e,0x154e,0x154e,
0x154e,0x154e,0x154e,0x154e,0x154e,0x154e,0x154e,0x154e,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,
0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x12f6,0x12f6,0x12f6,0x12f6,0x12f6,0x12f6,0x12f6,0x11d9,
0x11d9,0x11cd,0x11ca,0x11ca,0x11ca,0x11ca,0x11ca,0x11ca,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,
0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,
0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11d3,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,
0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,
0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11dc,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,
0x11e8,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,
0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x11f1,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,
0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,
0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x1206,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,
0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,
0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x120c,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,
0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,
0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x1224,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,
0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,0x122a,
0x122a,0x122a,0x122a,0x122a,0x122a,0x1227,0x1227,0x1227,0x1236,0x1236,0x1236,0x1236,0x1236,0x1236,0x1236,0x1236,
0x1236,0x1236,0x1236,0x1236,0x1236,0x1236,0x1236,0x1236,0x1236,0x1236,0x1236,0x1236,0x1236,0x1236,0x1236,0x1233,
0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x1233,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,
0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,
0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x123f,0x1314,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,
0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,
0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x1248,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,
0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,
0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x124e,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,0x1269,
0x1269,0x1269,0x1269,0x1269,0x1266,0x1266,0x1266,0x131d,0x131d,0x131d,0x1266,0x1266,0x131d,0x1326,0x1320,0x1323,
0x126c,0x126c,0x1263,0x126c,0x126c,0x1260,0x1491,0x1803,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,
0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x1329,0x1275,0x1275,0x1329,0x1329,0x1329,0x1329,0x1329,
0x1329,0x1275,0x1329,0x1278,0x1278,0x1329,0x1278,0x1329,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,
0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,
0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x127b,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,
0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,
0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1281,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,
0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1293,0x1293,0x1293,0x1335,0x1335,0x1335,0x1335,0x1335,
0x1335,0x1335,0x1335,0x1293,0x1293,0x1335,0x1293,0x1338,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,
0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,
0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x1296,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,
0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,
0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x129c,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,
0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,
0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x12ae,0x154e,0x154e,0x154e,0x154e,0x154e,0x154e,0x154e,0x154e,
0x154e,0x154e,0x154e,0x154e,0x135c,0x135c,0x135c,0x135c,0x154e,0x154e,0x154e,0x154e,0x154e,0x154e,0x154e,0x154e,
0x154e,0x154e,0x154e,0x154e,0x154e,0x154e,0x154e,0x1617,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,
0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,
0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x1362,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,
0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,
0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x137d,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,
0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,
0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1380,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,
0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,
0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1383,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,
0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,
0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,
0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x1386,
0x1386,0x1386,0x1386,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,
0x13e9,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,0x13e9,0x1386,0x1386,0x1386,0x1386,0x1386,0x1386,
0x1386,0x1386,0x1386,0x1386,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,
0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,0x1392,
0x1392,0x1392,0x1392,0x1392,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,
0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,
0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a7,0x13a4,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,
0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x13a1,0x14af,0x14af,0x14af,0x14af,0x14af,0x14af,0x14af,0x14af,
0x14af,0x14af,0x14af,0x14af,0x16fb,0x167a,0x167a,0x167d,0x13ce,0x13ce,0x13ce,0x13ce,0x13ce,0x13ce,0x13ce,0x13ce,
0x13d1,0x1476,0x1476,0x1476,0x1476,0x1476,0x1476,0x1503,0x13ce,0x13ce,0x13ce,0x13ce,0x13ce,0x1473,0x1473,0x1473,
0x1473,0x1473,0x1473,0x1473,0x1473,0x1473,0x1473,0x1473,0x1473,0x1473,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,
0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x13ce,0x15d5,0x15d5,0x167a,0x167a,0x167a,0x167a,0x167a,
0x167a,0x167a,0x167a,0x16f8,0x17a6,0x167d,0x167d,0x167d,0x1500,0x1503,0x1503,0x1503,0x1503,0x1503,0x1503,0x1503,
0x1503,0x1503,0x1503,0x1503,0x1503,0x1503,0x1500,0x1500,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,
0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,
0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13d4,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,
0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,
0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x13e9,0x1473,0x1473,0x1473,0x1473,0x1473,0x1473,0x1476,0x1473,
0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1476,0x1503,0x1503,0x1476,0x1476,0x1476,0x1476,0x1476,
0x1476,0x1476,0x1473,0x1401,0x1476,0x1476,0x1476,0x167a,0x1473,0x1473,0x1473,0x1473,0x1473,0x1473,0x1401,0x1473,
0x1473,0x1473,0x1473,0x1473,0x1500,0x15d5,0x15d5,0x15d5,0x1473,0x1473,0x1473,0x1473,0x1473,0x1473,0x1473,0x1473,
0x1473,0x1473,0x1473,0x1473,0x1473,0x1473,0x1473,0x1500,0x142e,0x142e,0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,
0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,
0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,0x142b,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,
0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,
0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x142e,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,
0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x145e,0x145e,0x145e,
0x14a6,0x14a6,0x14a6,0x14a6,0x14a6,0x14a6,0x14a6,0x14a6,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,
0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,
0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x1461,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,
0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,
0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x147c,0x1704,0x1704,0x1704,0x1704,0x1704,
0x1704,0x1704,0x1704,0x1704,0x1704,0x1704,0x1704,0x1704,0x16b0,0x16b0,0x16b0,0x16b0,0x16b0,0x16b0,0x16b0,0x16b0,
0x1746,0x1749,0x17c1,0x17c1,0x17c1,0x17c1,0x17c1,0x17c1,0x17c1,0x17c1,0x17c1,0x15e4,0x1488,0x1488,0x1488,0x1488,
0x1488,0x1488,0x1488,0x1488,0x1488,0x1488,0x1488,0x1488,0x14df,0x14df,0x14df,0x14df,0x1650,0x1650,0x14e2,0x14e2,
0x14e2,0x14e2,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x1530,0x14dc,
0x1533,0x1536,0x14d3,0x14e5,0x14e5,0x158a,0x14d6,0x14d6,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,
0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,
0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14df,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,
0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x1539,0x153f,0x153c,0x153c,0x153c,
0x153c,0x14f1,0x14f7,0x153c,0x153c,0x153c,0x153c,0x14ee,0x14f4,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,0x153c,
0x153c,0x153c,0x153c,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,
0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x14f4,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,
0x1500,0x1500,0x1500,0x1500,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x167a,0x16f8,0x15d5,0x15d5,0x15d5,0x15d5,0x16fb,
0x16f8,0x17a6,0x15d5,0x167a,0x15d5,0x15d5,0x15d5,0x15d5,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x1500,0x15d5,
0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,
0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x15d5,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,
0x1509,0x1509,0x1509,0x15de,0x15de,0x15de,0x15de,0x15de,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,
0x1701,0x1701,0x1701,0x1701,0x1701,0x17ac,0x17ac,0x17ac,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,
0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,
0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x1509,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,
0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,
0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x150c,0x17af,0x150f,0x150f,0x150f,0x150f,
0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,
0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x150f,0x1545,0x1545,0x1545,0x1545,
0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,
0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1545,0x1593,0x1593,0x1593,0x1593,
0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,
0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x1593,0x15b1,0x15b1,0x15b1,0x15b1,
0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,
0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b1,0x15b4,0x15b4,0x15b4,0x15b4,
0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,
0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15b4,0x15bd,0x15bd,0x15bd,0x15bd,
0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,
0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15bd,0x15cf,0x15cf,0x15cf,0x15cf,
0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,
0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cf,0x15cc,0x15cc,0x15cc,0x15d5,0x15d5,0x15d5,0x16f8,
0x16f8,0x167a,0x167a,0x167a,0x167a,0x167a,0x167a,0x16f8,0x16f8,0x16f8,0x167a,0x167a,0x15d5,0x15d5,0x15d5,0x15d5,
0x15d5,0x15d8,0x15d8,0x15d5,0x15d8,0x15d8,0x167a,0x167d,0x167a,0x167a,0x167a,0x167a,0x1611,0x1611,0x1611,0x1611,
0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,
0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x1611,0x162c,0x162c,0x162c,0x162c,
0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x1677,0x1677,0x162c,0x1677,
0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x162c,0x1632,0x1632,0x1632,0x165c,0x165c,0x165c,0x165c,
0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,
0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x165c,0x1671,0x1671,0x1671,0x1671,
0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,
0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x1671,0x16a4,0x16a4,0x16a4,0x16a4,
0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,
0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x16a4,0x1854,
0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,
0x1854,0x1854,0x1854,0x1854,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,
0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,0x16f5,
0x16f5,0x16f5,0x16f5,0x16f5,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x17a6,0x17a6,0x17a6,
0x17a6,0x181e,0x181e,0x181e,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x16f8,0x17a6,0x17a6,0x17a6,0x17a6,0x181e,
0x181e,0x181e,0x18e1,0x181e,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,
0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,0x1701,
0x1701,0x1701,0x1701,0x1701,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,
0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,0x1707,
0x1707,0x1707,0x1707,0x1707,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,
0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,0x1731,
0x1731,0x1731,0x1731,0x1731,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,
0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,0x178e,
0x178e,0x178e,0x178e,0x178e,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,
0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,0x179a,
0x179a,0x179a,0x179a,0x179a,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,
0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,0x17bb,
0x17bb,0x17bb,0x17bb,0x17bb,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,
0x17e8,0x17e8,0x17e8,0x17e8,0x17e8,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,0x17e5,
0x17e5,0x17e5,0x17e5,0x17e5,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,
0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,0x1824,
0x1824,0x1824,0x1824,0x1824,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,
0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,0x184b,
0x184b,0x184b,0x184b,0x184b,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,
0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,
0x1854,0x1854,0x1854,0x1854,0x1854,0x1854,0x1857,0x1857,0x1857,0x1857,0x1857,0x1857,0x1857,0x1857,0x1857,0x1857,
0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,
0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,0x1875,
0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x187e,0x1884,0x1884,0x1884,0x1884,0x188d,0x1884,
0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,0x1887,
0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,
0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x1896,0x18f9,0x18f9,
0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,
0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,0x189f,
0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,
0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,0x18bd,
0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c3,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,
0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,0x18c0,
0,0,0,0
};

static const UTrie2 propsVectorsTrie={
    propsVectorsTrie_index,
    propsVectorsTrie_index+5236,
    nullptr,
    5236,
    27088,
    0xa40,
    0x14f4,
    0x0,
    0x0,
    0x110000,
    0x7e40,
    nullptr, 0, false, false, 0, nullptr
};

static const uint32_t propsVectors[6426]={
0x67,0,0,0x67,0,0xe00000,0x67,0,0x1600000,0x67,0x80000,0x20,0x67,0x20000000,0,0x5067,
0,0xe00000,0x5000000,0,0x900020,0x5000000,0x80000,0xc4918820,0x5000000,0x80000,0xc5c18020,0x5000000,0x80000,0xc5e18820,0x5000000,0x180000,
0xc0918820,0x5000000,0x4000000,0x4100000,0x5000000,0x4000000,0x4200000,0x5000000,0x4000000,0x5500000,0x5000000,0x4000000,0x5600000,0x5000000,0x4000000,0xc200000,
0x5000000,0x4000000,0xc8100003,0x5000000,0x4000000,0xc8100006,0x5000000,0x4000000,0xc8200002,0x5000000,0x4000000,0xc8200006,0x5000000,0x4000000,0xc820000e,0x5000000,
0x4000000,0xc820000f,0x5000000,0x4000000,0xc9600002,0x5000000,0x4000001,0xc8445801,0x5000000,0x4000001,0xc8445802,0x5000000,0x4000001,0xc8c4000b,0x5000000,0x4000010,
0xc9071401,0x5000000,0x4000020,0x4200000,0x5000000,0x4000020,0xc820000e,0x5000000,0x4000020,0xc820000f,0x5000000,0x4000020,0xc881000e,0x5000000,0x4000020,0xc881000f,
0x5000000,0x4000020,0xc941000e,0x5000000,0x4000020,0xc941000f,0x5000000,0x4000022,0xc820000e,0x5000000,0x4000022,0xc820000f,0x5000000,0x4000400,0x4200400,0x5000000,
0x4000400,0xc8200001,0x5000000,0x4000400,0xc8200002,0x5000000,0x6800000,0x10201c00,0x5000000,0x6800010,0xc8201001,0x5000000,0x6800020,0x10201c00,0x5000000,0x7c00000,
0x10200000,0x5000000,0x7c00020,0x10200000,0x5000000,0x7c00100,0xc8220402,0x5000000,0x7c00120,0xc8220405,0x5000000,0x7c00120,0xc8230402,0x5000000,0x7c00120,0xc8250402,
0x5000000,0x7c00120,0xc8250405,0x5000000,0x7c00500,0x10220400,0x5000000,0x7c00500,0x10230400,0x5000000,0x7c00500,0x10530400,0x5000000,0x7c00500,0xfc230400,0x5000000,
0x7c00d00,0x10230400,0x5000000,0x24000000,0x4100000,0x5000000,0x24000000,0x4200000,0x5000000,0x24000000,0x4810000,0x5000000,0x24000000,0x4b00000,0x5000000,0x24000000,
0x4e00000,0x5000000,0x24000000,0x5410000,0x5000000,0x24000000,0x5500000,0x5000000,0x24000000,0x5710000,0x5000000,0x24000000,0x6800000,0x5000000,0x24000000,0xc8200002,
0x5000000,0x24000000,0xc9500002,0x5000000,0x24000002,0x4400000,0x5000000,0x24000006,0xc8c0000b,0x5000000,0x24000008,0x5410000,0x5000000,0x24000008,0x5710000,0x5000000,
0x24000020,0x4200000,0x5000000,0x24000020,0x4200001,0x5000000,0x24000020,0x4810000,0x5000000,0x24000020,0x4f00000,0x5000000,0x24000020,0x5001400,0x5000000,0x24000020,
0x5410000,0x5000000,0x24000020,0x5600000,0x5000000,0x24000020,0xc8200002,0x5000000,0x24000020,0xc9500002,0x5000000,0x24000022,0x5600000,0x5000000,0x2c000010,0x5248000,
0x5000000,0x2c000010,0xc9248002,0x5000000,0x40000001,0x4440020,0x5000000,0x40000001,0x463b020,0x5000000,0x40000001,0x4643020,0x5000000,0x40000001,0x4a5a040,0x5000000,
0x40000001,0x516a8a0,0x5000000,0x40000001,0x5d3b020,0x5000000,0x40080000,0xc4918820,0x5000000,0x80000000,0x5329960,0x5000001,0x2882000,0xc4962460,0x5000002,0x4000000,
0x4200000,0x5000002,0x4000000,0x5329400,0x5000002,0x4000000,0x5329800,0x5000002,0x4000000,0x5500000,0x5000002,0x6800000,0xfd329800,0x5000002,0x7000100,0xc8230408,
0x5000002,0x7c00100,0x8230400,0x5000002,0x7c00100,0xc8230402,0x5000002,0x7c00100,0xc8230404,0x5000002,0x7c00100,0xc8230407,0x5000002,0x7c00100,0xc8230408,0x5000002,
0x7c00100,0xc8230409,0x5000002,0x7c00100,0xfc230400,0x5000002,0x7c00100,0xfc230401,0x5000002,0x7c00500,0xfc230400,0x5000002,0x7d00100,0xc0230400,0x5000003,0x4000000,
0x4200400,0x5000003,0x4000000,0x4201000,0x5000003,0x4000000,0x4270000,0x5000003,0x7c00100,0xc8220402,0x5000003,0x7c00100,0xfc220400,0x5000003,0x7c00100,0xfc250400,
0x5000003,0x7c00500,0xfc230400,0x5000004,0x4000000,0x4200000,0x5000004,0x4000000,0x5500000,0x5000004,0x6800100,0xfc962540,0x5000004,0x6800100,0xfc962541,0x5000004,
0x7c00100,0xfc230400,0x5000007,0x7c00100,0x80220400,0x5000007,0x7c00100,0x80250400,0x5000008,0x4000000,0xc200000,0x5000008,0x7c00100,0x8220400,0x5000008,0x7c00100,
0x8220401,0x5000008,0x7c00100,0x8250400,0x5000008,0x7c00100,0x8250401,0x5000008,0x7c00100,0xfc220400,0x5000008,0x7c00100,0xfc220401,0x5000008,0x7c00100,0xfc250400,
0x5000008,0x7c00100,0xfc250401,0x500000a,0x4000000,0x4200000,0x500000a,0x6800100,0xfc962540,0x500000a,0x7c00100,0xfc230400,0x500000c,0x7c00100,0x8230400,0x500000c,
0x7c00100,0x8250400,0x500000c,0x7c00100,0xfc230400,0x500000e,0x4000400,0xc8200001,0x500000e,0x4000400,0xc8200002,0x500000e,0x4000400,0xc8500001,0x500000e,0x7000500,
0xc8220402,0x500000e,0x7c00100,0x8250400,0x500000e,0x7c00100,0x18220400,0x500000e,0x7c00100,0xc8220401,0x500000e,0x7c00100,0xc8220402,0x500000e,0x7c00100,0xc8250401,
0x500000e,0x7c00100,0xfc220400,0x500000e,0x7c00100,0xfc220401,0x500000e,0x7c00100,0xfc250401,0x500000e,0x7c00120,0xc8220402,0x500000e,0x7c00120,0xc8250402,0x500000f,
0x6800100,0xfc962540,0x500000f,0x7c00100,0xfc230400,0x5000010,0x6800100,0xfc962540,0x5000010,0x7c00100,0xc8230401,0x5000010,0x7c00100,0xfc230400,0x5000012,0x7c00100,
0xa230500,0x5000012,0x7c00100,0xa330520,0x5000012,0x7c80100,0xc6330520,0x5000013,0x4000000,0x4200000,0x5000013,0x4000000,0xf8201000,0x5000013,0x4000000,0xf8230400,
0x5000013,0x4000002,0x4400000,0x5000013,0x4000010,0x4200000,0x5000013,0x4000020,0xc8200005,0x5000013,0x7c00100,0xca633801,0x5000013,0x7c00100,0xca633802,0x5000013,
0x7c00100,0xca633805,0x5000013,0x7c00100,0xfe633800,0x5000015,0x6800100,0xfc962540,0x5000015,0x7c00100,0x8230400,0x5000015,0x7c00100,0xfc230400,0x5000018,0x6800000,
0xfd329800,0x5000018,0x7800100,0xc9830142,0x5000018,0x7c00100,0xc9830002,0x5000018,0x7c00100,0xfd830000,0x5000018,0x7c00900,0xfd830000,0x5000018,0x7e00100,0xfd830000,
0x5000019,0x7c00100,0x8220400,0x5000019,0x7c00100,0x8250400,0x5000019,0x7c00100,0x10220400,0x5000019,0x7c00100,0x10230400,0x5000019,0x7c00100,0x18220400,0x5000019,
0x7c00100,0x18230400,0x5000019,0x7c00100,0x20220400,0x5000019,0x7c00100,0x20250400,0x5000019,0x7c00100,0x30220400,0x5000019,0x7c00100,0xc8220402,0x5000019,0x7c00100,
0xc8250401,0x5000019,0x7c00100,0xc8250402,0x5000019,0x7c00100,0xfc220400,0x5000019,0x7c00100,0xfc220401,0x5000019,0x7c00100,0xfc250400,0x5000019,0x7c00100,0xfc250401,
0x5000019,0x7c00500,0xc822040f,0x500001a,0x6800000,0xfd329800,0x500001a,0x6800100,0xfc962540,0x500001a,0x6800100,0xfc962541,0x500001a,0x7c00100,0xfc230400,0x500001f,
0x4000000,0x4200000,0x500001f,0x6800000,0xfd329800,0x500001f,0x6800100,0xfc962540,0x500001f,0x6800100,0xfc962541,0x500001f,0x7c00100,0xfc230400,0x5000023,0x6800100,
0xfc962540,0x5000023,0x6800100,0xfc962541,0x5000023,0x7c00100,0xfc230400,0x5000023,0x7c00100,0xfc230401,0x5000024,0x6800000,0xfd329800,0x5000024,0x6800100,0xfc962540,
0x5000024,0x7c00100,0xfc230400,0x5000026,0x4000000,0x4200000,0x5000026,0x4000010,0x4400000,0x5000026,0x6800000,0xfd329800,0x5000026,0x7800100,0xc9830142,0x5000026,
0x7c00100,0xfd830000,0x5000026,0x7c00900,0xfd830000,0x5000026,0x7e00100,0xfd830000,0x5000067,0x1000,0,0x5000410,0x7c00500,0xfc230400,0x500041b,0x4000400,
0x4200400,0x500048e,0x7c00500,0xc8230401,0x50004a1,0x4000010,0x4b00000,0x50004a1,0x4000010,0x5071400,0x50004ad,0xc000010,0x4b48000,0x50004b5,0x7c00900,0x8230400,
0x50004e2,0xc000010,0x4448000,0x50004f7,0xc000010,0x4448000,0x500052f,0x4000000,0x4200000,0x500059b,0x4000000,0x4e00000,0x50005f8,0x24000000,0x14810000,0x50005f8,
0x24000000,0x15410000,0x5000c90,0x4000400,0xf8200000,0x5000c9f,0xc000010,0x5049400,0x5000cc3,0x6800000,0xfd329800,0x5000cc7,0xc000010,0x4b48000,0x5000d12,0x6800000,
0xfd329800,0x5000d17,0x6800000,0xfd329800,0x5000d1b,0x6800000,0xfd329800,0x5000d1f,0x6800000,0xfd329800,0x5000d23,0x4000000,0x4200000,0x5000d23,0x6800000,0xfd329800,
0x5000d28,0x6800000,0xfd329800,0x5000dfc,0x7c00100,0xc8230408,0x5001000,0x80004,0xc4418820,0x5001000,0x4000000,0x4100000,0x5001000,0x4000000,0xc8100002,0x5001000,
0x4000000,0xc8100003,0x5001000,0x4000000,0xc8100006,0x5001000,0x4000000,0xc810000e,0x5001000,0x4000000,0xc810000f,0x5001000,0x4000000,0xc9500002,0x5001000,0x4000000,
0xc9600002,0x5001000,0x4000100,0xc8120403,0x5001000,0x4000100,0xc8150403,0x5001000,0x4000400,0x4200400,0x5001000,0x4000400,0xc8100002,0x5001000,0x4000400,0xc8500002,
0x5001000,0x7c00120,0xc8120405,0x5001000,0x7c00d00,0x10130400,0x5001000,0x24000000,0x4100000,0x5001000,0x24000000,0x4200000,0x5001000,0x24000000,0x4e00000,0x5001000,
0x24000000,0x5400000,0x5001000,0x24000000,0x5500000,0x5001000,0x24000000,0x5600000,0x5001000,0x24000000,0xc8200002,0x5001000,0x24000000,0xc8f00002,0x5001000,0x24000000,
0xf8401000,0x5001000,0x24000002,0x4100000,0x5001000,0x24000002,0x4370000,0x5001000,0x24000002,0x4470000,0x5001000,0x24000006,0xf8400000,0x5001000,0x24000008,0x5710000,
0x5001000,0x24000008,0x5712c00,0x5001000,0x24000008,0xf9712c00,0x5001000,0x24000020,0x4100000,0x5001000,0x24000020,0x4100001,0x5001000,0x24000020,0x5500000,0x5001000,
0x24000020,0x5600000,0x5001000,0x24000020,0xc8100002,0x5001000,0x24000020,0xc9500002,0x5001000,0x2c000010,0xc8f0ac02,0x5001008,0x7c00100,0xfc220400,0x5001008,0x7c00100,
0xfc220401,0x5001008,0x7c00100,0xfc250400,0x5001008,0x7c00100,0xfc250401,0x500100e,0x7c00100,0xc8250401,0x500100e,0x7c00100,0xfc220400,0x500100e,0x7c00100,0xfc250400,
0x5001019,0x7c00100,0x10220400,0x5001019,0x7c00100,0xc8120402,0x5001019,0x7c00100,0xc812040f,0x5001019,0x7c00100,0xc8150401,0x5001019,0x7c00100,0xc8150402,0x5001019,
0x7c00100,0xc8220402,0x5001019,0x7c00100,0xc8250402,0x5001019,0x7c00100,0xfc220400,0x5001019,0x7c00100,0xfc220401,0x5001019,0x7c00100,0xfc250400,0x5001019,0x7d00100,
0xc0220402,0x5001067,0,0,0x5001400,0x6800c00,0xf8101000,0x5001417,0x4000400,0xc8100002,0x5001417,0x7c00500,0x10130400,0x5001419,0x7c00500,0x10130400,
0x5002000,0x4000000,0x5600000,0x5002000,0x4000000,0xc820000a,0x5002000,0x4000020,0xc820000a,0x5002012,0x7c00100,0xc8e3040a,0x5002012,0x7c80100,0xc4e3040a,0x5002016,
0x7c00100,0xc8e30c0a,0x5002016,0x7c00100,0xca530c0a,0x5002581,0x4000008,0xc881000a,0x5002581,0x4000008,0xc941000a,0x5002581,0x4000010,0xc887000a,0x5002581,0x6800004,
0xc920000a,0x5002581,0xc000010,0xc884800a,0x5002599,0x7c00d00,0xca530c0a,0x5003000,0x4000000,0xc8810011,0x5003000,0x4000000,0xc8e00011,0x5003000,0x4000000,0xc9410011,
0x5003000,0x4000000,0xc9500011,0x5003000,0x4000000,0xc9600011,0x5003000,0x4000001,0xc8445811,0x5003000,0x4000006,0xc8e70011,0x5003000,0x4000008,0xc8e00011,0x5003000,
0x4000008,0xc8e02c11,0x5003000,0x4000010,0xc8871411,0x5003000,0x4000010,0xc9271011,0x5003000,0x4000010,0xc9271411,0x5003000,0x4000020,0xc8e00011,0x5003000,0x4000400,
0xc8e00011,0x5003000,0x4000420,0xc8e00011,0x5003000,0x6800000,0xc8e01c11,0x5003000,0x6800040,0xc8e29811,0x5003000,0xc000010,0xc880ac11,0x5003000,0xc000010,0xc8b48011,
0x5003019,0x7c00100,0xc8e20411,0x5003019,0x7c00100,0xc8e50411,0x5003019,0x7c00140,0xc8e20411,0x5003019,0x7c00140,0xc8e50411,0x5004000,0x4000400,0xc8200002,0x5004000,
0x6800000,0xfc201c00,0x5004000,0x68000c0,0xfd329800,0x5004000,0x24000000,0x4200000,0x5004000,0x24000000,0x4810000,0x5004000,0x24000000,0x5410000,0x5004000,0x24000000,
0x5500000,0x5004000,0x24000000,0x5600000,0x5004000,0x24000000,0x5b00000,0x5004000,0x24000000,0x6410000,0x5004000,0x24000006,0xf8d70000,0x5004000,0x24000008,0x5714000,
0x5004000,0x24000008,0xf9713c00,0x5004000,0x24000010,0x5071400,0x5004000,0x24000010,0xf9071000,0x5004000,0x24000020,0x4200000,0x5004000,0x24000020,0x4400000,0x5004000,
0x24000020,0x5600000,0x5004000,0x24000400,0x4200000,0x5004000,0x24000420,0x4200000,0x5004000,0x2c000010,0x4b48000,0x5004000,0x2c000010,0xf900ac00,0x5004000,0x44000001,
0x5a45800,0x5004019,0x7c00100,0xfc220400,0x5004019,0x7c00100,0xfc250400,0x5004019,0x7c001c0,0xfc220400,0x5004019,0x7c001c0,0xfc250400,0x5005000,0x4000000,0x4e00000,
0x5005000,0x4000000,0x14e00000,0x5005000,0x4000000,0xc881000c,0x5005000,0x4000000,0xc8810010,0x5005000,0x4000000,0xc8e00002,0x5005000,0x4000000,0xc8e0000c,0x5005000,
0x4000000,0xc8e0000d,0x5005000,0x4000000,0xc8e00010,0x5005000,0x4000000,0xc941000c,0x5005000,0x4000000,0xc9410010,0x5005000,0x4000000,0xc950000c,0x5005000,0x4000000,
0xc960000c,0x5005000,0x4000002,0xc8e7000c,0x5005000,0x4000002,0xc8e70010,0x5005000,0x4000008,0xc8810010,0x5005000,0x4000008,0xc9410010,0x5005000,0x4000010,0xc887140c,
0x5005000,0x4000010,0xc8e7000c,0x5005000,0x4000010,0xc927100c,0x5005000,0x4000010,0xc927140c,0x5005000,0x4000020,0xc8e0000c,0x5005000,0x4000026,0xc8e7000c,0x5005000,
0x6800000,0xc8e01c02,0x5005000,0x6800000,0xc8e01c10,0x5005000,0xc000010,0xc880ac0c,0x5005000,0xc000010,0xc8b4800c,0x5005000,0x24000000,0x4200000,0x5005000,0x24000000,
0x4e00000,0x5005000,0x24100000,0xc0810001,0x5005000,0x24100000,0xc1410001,0x5005005,0x7c00100,0xfce30400,0x5005011,0x7c00300,0x10e30000,0x5005011,0x7c00300,0xc8e30001,
0x5005011,0x7c00300,0xfce30000,0x5005011,0x7c00900,0xfd230400,0x5005011,0x7c40300,0xfce30000,0x5005012,0x4000000,0xc8e00002,0x5005012,0x4000000,0xc8e00003,0x5005012,
0x7c00100,0xa130480,0x5005012,0x7c00100,0xc8e30402,0x5005012,0x7c80100,0xc4e30402,0x5005012,0x7c80100,0xc6130480,0x5005014,0x7c00100,0xfce30000,0x5005014,0x7c00100,
0xfce30001,0x5005014,0x7c00100,0xfe530000,0x5005014,0x7c00900,0xfd230000,0x5005014,0x7c00900,0xfd230001,0x5005016,0x4000000,0xc8e00c03,0x5005016,0x4000000,0xc8e00c0d,
0x5005016,0x7c00100,0xfce30c00,0x5005016,0x7c00100,0xfce30c01,0x5005016,0x7c00100,0xfe530c00,0x5005016,0x7c00900,0xfd230c00,0x5005016,0x7c00900,0xfd230c01,0x5005581,
0x6800004,0xf9200000,0x5005581,0x24000000,0x4810000,0x5005581,0x24000000,0x5410000,0x5005581,0x24000008,0x4810000,0x5005581,0x24000008,0x5410000,0x5005587,0x24000010,
0x4870000,0x500558e,0x2c000010,0x4848000,0x5005596,0x4000000,0x4e00000,0x5005596,0x24000000,0x4e00000,0x5005596,0x24000002,0x4e00000,0x5005596,0x24000002,0x5200000,
0x5005596,0x24000008,0x4810000,0x5005596,0x24000008,0x5410000,0x5005596,0x24000008,0xc810000,0x5005599,0x7000400,0xc9200c02,0x5005599,0x7c00900,0x10930c00,0x5005599,
0x7c00900,0x10e30c00,0x5005599,0x7c00d00,0xfe530c00,0x500559b,0x4000000,0x4e00000,0x500559b,0x4000000,0xc8e00002,0x500559b,0x4000000,0xc8e00003,0x500559b,0x4000000,
0xc8e0000d,0x500559b,0x4000000,0xc8e0000f,0x500559b,0x7c00300,0xfce30000,0x500559c,0x24000000,0x4810000,0x500559c,0x24000000,0x5410000,0x50055a4,0x24000000,0x4810000,
0x50055a4,0x24000000,0x5410000,0x5008004,0x7c00100,0xc8230401,0x5008004,0x7c00100,0xfc230400,0x500800a,0x7c00100,0xc8230401,0x500800a,0x7c00100,0xfc230400,0x500800a,
0x7c00100,0xfc230401,0x500800f,0x7c00100,0xfc230400,0x500801a,0x7c00100,0xfc230400,0x500801f,0x7c00100,0xc8230401,0x500801f,0x7c00100,0xfc230400,0x5008024,0x7c00100,
0xfc230400,0x5010001,0x2000,0x14962460,0x5010001,0x2802020,0x10962460,0x5010001,0x2802400,0x10962460,0x5010001,0x2802400,0x10c62460,0x5010001,0x2880000,0xc6a65620,
0x5010002,0x2802100,0x20962460,0x5010002,0x2802400,0x20962460,0x5010004,0x2802100,0xfc962460,0x5010004,0x2802400,0xfc962460,0x501000a,0x2802100,0xfc962460,0x501000a,
0x2802400,0xfc962460,0x501000f,0x2802100,0xfc962460,0x501000f,0x2802400,0xfc962460,0x5010010,0x2802100,0xfc962460,0x5010010,0x2802400,0xfc962460,0x5010010,0x2802900,
0xfc962460,0x5010010,0x2806400,0xfc962460,0x5010013,0x2802500,0x20962460,0x5010013,0x2802500,0x30962460,0x5010013,0x2802500,0xfc962460,0x5010015,0x2802100,0xfc962460,
0x5010015,0x2802100,0xfc962461,0x5010015,0x2806400,0xfc962460,0x5010018,0x2802100,0xfd862460,0x5010018,0x2802400,0xfd862460,0x501001a,0x2802100,0xfc962460,0x501001f,
0x2802100,0xfc962460,0x501001f,0x2802400,0xfc962460,0x5010023,0x2802100,0xfc962460,0x5010023,0x2806400,0xfc962460,0x5010024,0x2802100,0xfc962460,0x5010024,0x2802100,
0xfc962461,0x5010026,0x2802100,0xfd862460,0x5010026,0x2802400,0xfd862460,0x5010026,0x2806500,0xfd862460,0x501089a,0x2802400,0x18962460,0x50108be,0x2802100,0xfc962460,
0x50108be,0x2802500,0xfc962460,0x50108c9,0x2802400,0x8962460,0x50108d6,0x2802400,0x8962460,0x5010c94,0x2802400,0x8962460,0x5010c98,0x2802400,0x18962460,0x5011001,
0x2802400,0x10962460,0x5011001,0x2802400,0x10c62460,0x5011001,0x2802400,0x20962460,0x5011001,0x2802400,0xc8962461,0x5011001,0x2802400,0xfc962460,0x501181d,0x2802400,
0xfc962460,0x5011825,0x2802400,0xfc962460,0x501182d,0x2802400,0xfc962460,0x501182f,0x2802400,0xfc962460,0x5011831,0x2802400,0xfc962460,0x5011836,0x2802400,0xfc962460,
0x5011841,0x2802400,0x20962460,0x5011847,0x2802400,0xfc962460,0x501184b,0x2802400,0xfc962460,0x5011854,0x2802400,0xfc962460,0x501185e,0x2802400,0xfc962460,0x5011861,
0x2802400,0xfc962460,0x5011865,0x2802400,0xfc962460,0x5011868,0x2802400,0x20962460,0x5011868,0x2802400,0xfc962460,0x501186a,0x2802400,0x10962460,0x501186c,0x2802400,
0xfc962460,0x501186f,0x2802400,0xfc962460,0x5011873,0x2802400,0x10962460,0x5011873,0x2802400,0xfc962460,0x5011875,0x2802400,0xfc962460,0x501187a,0x2802400,0xfc962460,
0x501187e,0x2802400,0xfc962460,0x5011881,0x2802400,0xfc962460,0x5011884,0x2802400,0xfc962460,0x501188a,0x2802400,0xfc962460,0x501188a,0x2802500,0xfc962460,0x5012599,
0x3802500,0xc926246a,0x5015012,0x2802400,0x18962460,0x5015999,0x2802400,0xfc962460,0x50159ad,0x2802400,0x10962460,0x5018004,0x2806400,0xfc962460,0x501800a,0x2806400,
0xfc962460,0x501800f,0x2806400,0xfc962460,0x501801a,0x2806400,0xfc962460,0x501801f,0x2806400,0xfc962460,0x5018024,0x2806400,0xfc962460,0x8000000,0x4000000,0x5600000,
0x8000019,0x7c00100,0xc8220401,0x8000027,0x4000000,0x4200000,0x8000027,0x4000000,0x4400000,0x8000027,0x4000000,0x4500000,0x8000027,0x4000000,0x4810000,0x8000027,
0x4000000,0x4b00000,0x8000027,0x4000000,0x5410000,0x8000027,0x4000000,0xc8c0000b,0x8000027,0x4000000,0xf8400000,0x8000027,0x4000010,0x4b00000,0x8000027,0x4000010,
0x4c00000,0x8000027,0x6800000,0xfd329800,0x8000027,0x6800100,0xfc462540,0x8000027,0x6800400,0xfc962540,0x8000027,0x7c00100,0xc8230401,0x8000027,0x7c00100,0xfc230400,
0x8000067,0,0x1900000,0x8000067,0x1000,0,0x8001067,0,0,0x8005012,0x7c00100,0xfdf304c1,0x8005012,0x7c00100,0xfe0304e1,0x8010013,
0x2802400,0x20962460,0x8010013,0x2802500,0x20962460,0x8010027,0x2802100,0xc8962461,0x8010027,0x2802100,0xfc962460,0x8010027,0x2802400,0x10962460,0x8010027,0x2802400,
0x20962460,0x8010027,0x2802400,0xfc962460,0x8010027,0x2802500,0xfc962460,0x8010027,0x2806400,0xfc962460,0x8010027,0x2902100,0xc0962462,0x9000000,0x4000000,0x4700000,
0x9001000,0x4000000,0x5600000,0xc000000,0,0x4918820,0xc000000,0x4000000,0x4200000,0xc000000,0x4000000,0x5600000,0xc000000,0x4000400,0x4200400,0xc000000,
0x7c00100,0xc8220405,0xc000000,0x7c00500,0x10230400,0xc000000,0x7c00500,0xfc230400,0xc000000,0x24000000,0x4200000,0xc000000,0x2c000010,0xc9248002,0xc000002,0x4000000,
0xf8200000,0xc000002,0x7c00100,0xfc230400,0xc000003,0x4000006,0xf8400400,0xc000005,0x4000400,0x4200400,0xc000006,0x7c00100,0x40250400,0xc000008,0x7c00100,0xfc220400,
0xc000008,0x7c00100,0xfc220401,0xc000008,0x7c00100,0xfc250400,0xc000008,0x7c00100,0xfc250401,0xc00000b,0x4000000,0x4200000,0xc00000b,0x4000010,0x4200000,0xc00000b,
0x4000010,0x4400000,0xc00000b,0x6800000,0x8200000,0xc00000b,0x7c00100,0xfc230400,0xc00000b,0xc000010,0x4248000,0xc00000e,0x7c00100,0x8220400,0xc00000e,0x7c00100,
0x10220400,0xc000013,0x7c00100,0xca633801,0xc000017,0x4000000,0x4200000,0xc000017,0x4000000,0x5600000,0xc000017,0x4000000,0xc400000,0xc000017,0x4000010,0x4400000,
0xc000017,0x4000010,0x5200000,0xc000017,0x6800000,0xfd329800,0xc000017,0x6800100,0xfd862540,0xc000017,0x7c00100,0x9830000,0xc000017,0x7c00100,0xfd830000,0xc000017,
0x7d00100,0xc1830000,0xc000017,0xc000010,0x4448000,0xc000019,0x7c00100,0x8220400,0xc000019,0x7c00100,0x8250400,0xc000019,0x7c00100,0x10220400,0xc000019,0x7c00100,
0x18250400,0xc000019,0x7c00100,0x20220400,0xc000019,0x7c00100,0x20250400,0xc000019,0x7c00100,0xfc220401,0xc000019,0x7c00100,0xfc250401,0xc00001b,0x80000,0xc4c18820,
0xc00001b,0x4000000,0x84200000,0xc00001b,0x4000006,0x84500000,0xc00001b,0x4000010,0x84400000,0xc00001b,0x4000010,0x84b70000,0xc00001b,0x4000800,0x84200000,0xc00001b,
0x6800000,0x81329800,0xc00001b,0x7c00100,0x80230400,0xc00001b,0x7c00900,0x80230400,0xc00001b,0xc000010,0x84b48000,0xc00001c,0x4000000,0x4200000,0xc00001c,0x6800100,
0xfd862400,0xc00001c,0x6800100,0xfd862540,0xc00001c,0x7c00100,0xfd830000,0xc00001c,0x7c00100,0xfd830001,0xc00001c,0xc000010,0x4448000,0xc00001d,0x4000000,0x84810000,
0xc00001d,0x4000000,0x85410000,0xc00001d,0x4000001,0x84445800,0xc00001d,0x7c00100,0x80230400,0xc000020,0x7c00100,0x80230400,0xc000021,0x4000000,0x4200000,0xc000021,
0x6800100,0x30962540,0xc000021,0x6800100,0xfc962540,0xc000021,0x6800100,0xfc962541,0xc000021,0x7c00100,0x30230400,0xc000021,0x7c00100,0xfc230400,0xc000022,0x4000000,
0x44200000,0xc000022,0x4000010,0x44200000,0xc000022,0x7c00100,0x40230400,0xc000022,0xc000010,0x44248000,0xc000022,0x80000000,0x44218560,0xc000025,0x7c00100,0xfc230400,
0xc000027,0x4000000,0x4200000,0xc000027,0x4000000,0x4400000,0xc000027,0x7c00100,0xfc230400,0xc000028,0x4000000,0x44200000,0xc000028,0x7c00100,0x40230400,0xc000028,
0xc000010,0x44248000,0xc00002e,0x24000000,0x14200000,0xc000532,0x4000010,0x84400000,0xc000537,0x4000010,0x84400000,0xc000537,0x4000010,0x84b70000,0xc000537,0xc000010,
0x84b48000,0xc00055f,0x4000001,0xc8c41c0b,0xc000d2d,0x6800000,0xfd329800,0xc001000,0x4000400,0x4500400,0xc005005,0x7c00100,0xfce30400,0xc005011,0x4020000,0x4e00000,
0xc005011,0x4020000,0xc8e00002,0xc005011,0x7c00300,0xc8e30002,0xc005011,0x7c40300,0xfce30000,0xc005029,0x4000000,0x44e00000,0xc005029,0x7c00100,0x40e30400,0xc005029,
0x7c00900,0x41230400,0xc00557f,0x4008000,0x4e00000,0xc00557f,0x4010000,0x4e00000,0xc00559b,0x4000000,0x4e00000,0xc010001,0x2000,0x14962460,0xc010008,0x2000,
0xc962460,0xc010017,0x2802100,0xfd862460,0xc010017,0x2802400,0x9862460,0xc010017,0x2802400,0x11862460,0xc010017,0x2802400,0x19862460,0xc010017,0x2802400,0xfd862460,
0xc010017,0x2806400,0xfd862460,0xc010017,0x2882000,0xc5862460,0xc01001b,0x2802100,0xa0962460,0xc01001b,0x3c02100,0x80962460,0xc01001b,0x12882000,0xc4962460,0xc01001c,
0x2802100,0xfd862460,0xc01001c,0x2802400,0xfd862460,0xc01001c,0x2806400,0xfd862460,0xc010021,0x2802100,0x30962460,0xc010021,0x2802100,0xfc962460,0xc010021,0x2806400,
0xfc962460,0xc010022,0x2802100,0x40962460,0xc010022,0x2802400,0x50962460,0xc010022,0x2802500,0x40962460,0xc010025,0x2802500,0xfc962460,0xc010027,0x2802100,0xfc962460,
0xc010027,0x2802400,0xfc962460,0xc0108be,0x2802100,0xfc962460,0xc011001,0x2802400,0x10962460,0xc011001,0x2802400,0x10c62460,0xd000000,0x80000,0xc4918820,0xd000000,
0x180000,0xc0918820,0xd000000,0x4000000,0x14200000,0xd000000,0x4000000,0xc8200001,0xd000000,0x4000020,0xc8200005,0xd000000,0x6800020,0xc9329805,0xd000000,0x7c00120,
0xc8220405,0xd000000,0x7c00120,0xc8250405,0xd000009,0x7c00100,0x80220400,0xd000009,0x7c00100,0x80250400,0xd00000d,0x7c00100,0x80230400,0xd00000e,0x7c00120,0xc8220402,
0xd00000e,0x7c00120,0xc8250402,0xd00001e,0x4000000,0x84200000,0xd00001e,0x7c00100,0x80230400,0xd000067,0x1000,0,0xd005011,0x7c00300,0xc8e30001,0xd005011,
0x7c40300,0xfce30000,0xd010000,0x82000,0xc4962460,0xd010000,0x2802000,0x10962460,0xd010000,0x2802400,0x10962460,0xd010001,0x2802400,0x10962460,0xe000000,0x80000,
0xc5e18820,0xe000000,0x80020,0xc4218820,0xe000000,0x4000000,0x4200000,0xe000000,0x4000000,0x5600000,0xe000000,0x4000001,0xc8445802,0xe000000,0x4000020,0x4200000,
0xe000000,0x4000020,0xc8200005,0xe000000,0x7c00120,0xc8220405,0xe000000,0x7c00120,0xc8250405,0xe000000,0x24000000,0x4100000,0xe000000,0x24000000,0x4200000,0xe000000,
0x24000000,0x4810000,0xe000000,0x24000000,0x5410000,0xe000000,0x24000000,0xc9500002,0xe000000,0x24000020,0x4200000,0xe000000,0x24000020,0x4810000,0xe000000,0x24000020,
0x5410000,0xe000000,0x24000020,0xc8200001,0xe000000,0x24000020,0xc8200002,0xe000000,0x2c000010,0xc9248002,0xe000002,0x4000000,0xc9500008,0xe000002,0x7c00100,0x8230400,
0xe000002,0x7c00100,0x10230400,0xe000008,0x7c00100,0x8220400,0xe000008,0x7c00100,0x8250400,0xe000008,0x7c00100,0xfc220400,0xe000008,0x7c00100,0xfc250400,0xe00000c,
0x7c00100,0xfc230400,0xe00000e,0x4000020,0x4200000,0xe00000e,0x7c00100,0x8220400,0xe00000e,0x7c00100,0x8250400,0xe000019,0x7c00100,0x20250400,0xe000019,0x7c00100,
0xc822040f,0xe000025,0x7c00100,0xfc230400,0xe00002a,0x7c00100,0x80230400,0xe00002b,0x7c00100,0x80230400,0xe00002c,0x7c00100,0x80230400,0xe00002d,0x7c00100,0x80230400,
0xe000533,0xc000010,0x84448000,0xe000562,0x24000000,0x4200000,0xe001000,0x4000000,0x14100000,0xe003000,0x4000000,0xc8810011,0xe003000,0x4000000,0xc9410011,0xe004000,
0x24000020,0x4810000,0xe004000,0x24000020,0x5410000,0xe005000,0x4000000,0xc8e00003,0xe005000,0x24000020,0x4200000,0xe005011,0x7c00100,0x11230400,0xe005011,0x7c00300,
0xc8e30001,0xe005014,0x7c00100,0xc8e30010,0xe005014,0x7c00100,0xfe530000,0xe005016,0x7c00100,0xa530c00,0xe005016,0x7c00100,0xc8e30c10,0xe005029,0x4000000,0x44e00000,
0xe005596,0x24000000,0x14e00000,0xe005599,0x4000002,0xf9200c00,0xe0055af,0x4000000,0x4e00000,0xe0055af,0x7c00100,0x11230400,0xe010001,0x2000,0x14962460,0xe010001,
0x2802000,0x10962460,0xe010001,0x2802020,0x10962460,0xe01002a,0x2802100,0x80962460,0xe01002a,0x2806400,0x80962460,0xe01002b,0x2802100,0x80962460,0xe01002b,0x2806400,
0x80962460,0xe01002c,0x2802100,0x80962460,0xe01002d,0x2802100,0x80962460,0xe011001,0x2882000,0xc4c62460,0xe011001,0x12882000,0xc4962460,0xe011818,0x2802100,0x8962460,
0x10000000,0x4000000,0xc8200002,0x10000000,0x4000400,0x4200400,0x10000000,0x6800000,0x20201c00,0x10000000,0x7c00120,0xc8220405,0x10000000,0x24000000,0x4200000,0x10000000,
0x24000002,0x4200000,0x10000000,0x24000020,0x4200000,0x10000002,0x4000000,0x4200000,0x10000002,0x4000000,0x5071400,0x10000002,0x7c00100,0xfc230400,0x10000002,0x80000000,
0x5329960,0x10000004,0x7c00100,0xfc230400,0x10000008,0x7c00100,0x10220400,0x10000009,0x7c00100,0x80220400,0x10000009,0x7c00100,0x80250400,0x1000000a,0x7c00100,0xfc230400,
0x1000000e,0x7c00100,0x8220400,0x1000000e,0x7c00100,0x8250400,0x1000000e,0x7c00100,0x10220400,0x1000000e,0x7c00100,0xc8250402,0x1000000e,0x7c00500,0xc822040e,0x1000000e,
0x7c00500,0xc822040f,0x1000000f,0x4000000,0x5600000,0x1000000f,0x7c00100,0xfc230400,0x10000010,0x6800100,0xfc962540,0x10000015,0x7c00100,0xfc230400,0x10000017,0x4000000,
0x4200000,0x10000019,0x7c00100,0x10220400,0x10000019,0x7c00100,0x20220400,0x10000019,0x7c00500,0x10220400,0x10000019,0x7c00500,0xc822040e,0x10000019,0x7c00500,0xc822040f,
0x10000022,0x7c00100,0x40230400,0x10000023,0x4000000,0x4200000,0x10000023,0x4000000,0x5600000,0x1000002f,0x7c00100,0x80230400,0x10000030,0x4000000,0x44200000,0x10000030,
0x6800000,0x41329800,0x10000030,0x6800100,0x40962540,0x10000030,0x7c00100,0x40230400,0x10000030,0xc000010,0x44b48000,0x10000031,0x7c00100,0x80230400,0x10000032,0x6800000,
0x81329800,0x10000032,0x7c00100,0x80230400,0x10000033,0x7c00100,0x80230400,0x10000034,0x7c00100,0x41830000,0x10000035,0x4000010,0x84400000,0x10000035,0x7c00100,0x80230400,
0x100005fe,0x4000000,0x84200000,0x10000601,0x4000000,0x84400000,0x10000604,0x4000000,0x84200000,0x10000604,0x4000000,0x84400000,0x10000d23,0x4000000,0x4200000,0x10000dfc,
0x4000000,0x14200000,0x10001000,0x4000000,0x14200000,0x10005000,0x4000000,0x14200000,0x10005000,0x4000000,0xc8810010,0x10005000,0x4000000,0xc8e0000d,0x10005000,0x4000000,
0xc9410010,0x10005000,0x24000000,0x4200000,0x10005000,0x24000000,0x4e00000,0x10005012,0x4000000,0xc8e00002,0x10005012,0x4000000,0xc8e00003,0x1000801f,0x7c00100,0xfc230400,
0x10010002,0x2802100,0x20962460,0x10010002,0x2802400,0x20962460,0x10010002,0x2802500,0x20962460,0x1001000f,0x2802100,0xfc962460,0x10010010,0x2802100,0xfc962460,0x10010015,
0x2802400,0xfc962460,0x10010017,0x2802400,0x19862460,0x10010030,0x2802100,0x40962460,0x10010030,0x2802400,0x40962460,0x10011001,0x2802400,0x10962460,0x10011001,0x2802400,
0x10c62460,0x10011001,0x12882000,0xc4962460,0x1001188b,0x2802400,0x10c62460,0x11000000,0x4000000,0x4200000,0x11000000,0x4000000,0x5600000,0x11000000,0x4000400,0x14200400,
0x11000000,0x7c00120,0xc8220405,0x11000000,0x24000000,0x4200000,0x11000000,0x24000000,0x4e00000,0x11000000,0x24000000,0x5710000,0x11000000,0x24000000,0xc200000,0x11000000,
0x24000000,0xc400000,0x11000000,0x24000000,0x1d710000,0x11000000,0x24000020,0x4200000,0x11000000,0x24000020,0x4810000,0x11000000,0x24000020,0x5410000,0x11000002,0x4000000,
0x5500000,0x11000002,0x7c00100,0xfc230400,0x11000002,0xc000010,0x4b48000,0x11000004,0x7c00100,0xfc230400,0x11000007,0x4000000,0x84200000,0x11000007,0x4000000,0x84400000,
0x11000007,0x4000000,0x84b00000,0x11000007,0x7c00100,0x80220400,0x11000007,0x7c00100,0x80250400,0x11000007,0xc000010,0x84448000,0x11000007,0xc000010,0x84b48000,0x11000008,
0x7c00100,0xc822040f,0x11000008,0x7c00100,0xfc220400,0x11000008,0x7c00100,0xfc250400,0x1100000b,0x4000000,0x4200000,0x1100000b,0x7c00100,0xfc230400,0x1100000c,0x7c00100,
0x8220400,0x1100000c,0x7c00100,0xc822040f,0x1100000c,0x7c00100,0xfc230400,0x1100000e,0x4000000,0x4200000,0x1100000e,0x4000000,0xc200000,0x1100000e,0x7c00100,0x8230400,
0x1100000e,0x7c00100,0xc822040f,0x1100000e,0x7c00100,0xfc220400,0x1100000e,0x7c00100,0xfc250400,0x11000013,0x4000000,0xcb00000,0x11000019,0x7c00100,0x10220400,0x11000019,
0x7c00100,0x20220400,0x11000019,0x7c00100,0x20250400,0x11000019,0x7c00100,0xc822040e,0x11000019,0x7c00100,0xc822040f,0x11000023,0x7c00100,0xfc230400,0x11000027,0x4000000,
0x4500000,0x11000037,0x4000000,0x84200000,0x11000037,0x6800100,0x80962540,0x11000037,0x7c00100,0x80230400,0x11000038,0x7c00100,0x80220400,0x11000038,0x7c00100,0x80250400,
0x11000039,0x4000000,0x84200000,0x11000039,0x4000000,0x84400000,0x11000039,0x7c00100,0x80230400,0x11000039,0xc000010,0x84448000,0x1100003a,0x4000000,0x44200000,0x1100003a,
0x6800100,0x40962540,0x1100003a,0x7c00100,0x40230400,0x1100003b,0x4000000,0x45800000,0x1100003b,0x6800000,0x41329800,0x1100003b,0x7c00100,0x41830000,0x1100003b,0x7e00100,
0x41830000,0x1100003c,0x7c00100,0x40230400,0x1100003c,0x7c00100,0xc823040f,0x1100003d,0x4000010,0x84400000,0x1100003d,0x7c00100,0x80230400,0x11000564,0x24000000,0xc400000,
0x1100056a,0x24000000,0xc400000,0x11000571,0x24000006,0x4400000,0x110005b2,0x4000400,0xc200000,0x11000d23,0x6800000,0xfd329800,0x11005000,0x4000000,0xc8810010,0x11005000,
0x4000000,0xc8870010,0x11005000,0x4000000,0xc8f00010,0x11005000,0x4000000,0xc9270010,0x11005000,0x4000000,0xc9271010,0x11005000,0x4000000,0xc9410010,0x11005000,0xc000010,
0xc8848010,0x11005000,0xc000010,0xc8b48010,0x11005000,0x24000000,0x4200000,0x11005000,0x24000000,0x4e00000,0x11005011,0x7c00300,0xc8e30001,0x11005011,0x7c40300,0xfce30000,
0x11005012,0x4000000,0xc8e00003,0x1100559b,0x4000000,0x4e00000,0x1100800a,0x7c00100,0xfc230400,0x11010001,0x2802000,0x18962460,0x11010001,0x2802020,0x10962460,0x11010002,
0x2802100,0x20962460,0x1101000b,0x2802400,0xfc962460,0x1101000e,0x2802000,0x18962460,0x11010013,0x2802000,0x28962460,0x11010013,0x2802100,0x28962460,0x11010013,0x2802100,
0x30962460,0x11010037,0x2802100,0x80962460,0x11010039,0x2802100,0x80962460,0x11010039,0x2802400,0x80962460,0x11010039,0x2806400,0x80962460,0x1101003a,0x2802100,0x40962460,
0x1101003a,0x2806400,0x40962460,0x1101088a,0x2802000,0x18962460,0x11011001,0x2802000,0x10962460,0x11011001,0x2802000,0x10c62460,0x11011863,0x2802000,0x20962460,0x14000000,
0x4000000,0x4200000,0x14000000,0x4000400,0x4200400,0x14000000,0x7c00120,0xc8220405,0x14000000,0x7c00120,0xc8250405,0x14000000,0x7c00500,0xfc230400,0x14000000,0x24000000,
0x4200000,0x14000000,0x24000020,0x4200000,0x14000008,0x7c00100,0xfc220400,0x14000008,0x7c00100,0xfc250400,0x1400000e,0x7c00100,0xfc220400,0x14000015,0x7c00100,0xfc230400,
0x14000019,0x7c00100,0x8220400,0x14000019,0x7c00100,0x8250400,0x14000019,0x7c00100,0x10220400,0x14000019,0x7c00100,0x10250400,0x14000019,0x7c00100,0x20220400,0x14000019,
0x7c00100,0x20250400,0x1400003e,0x4000000,0x44400000,0x1400003e,0x4000000,0x44e00000,0x1400003e,0x4000010,0x44400000,0x1400003e,0x6800000,0x42d29800,0x1400003e,0x6800100,
0x40962540,0x1400003e,0x6800100,0x40962541,0x1400003e,0x7c00100,0x42b30400,0x1400003e,0x7c00100,0x42b30401,0x1400003e,0xc000010,0x44448000,0x14000057,0x4000000,0x44200000,
0x14000057,0x4000010,0x45071400,0x14000057,0x6800000,0x41329800,0x14000057,0x7c00100,0x40230400,0x14000057,0x7c00100,0x48230400,0x14000057,0x7c00500,0x40230400,0x14000057,
0x7c00900,0x48230400,0x14000057,0xc000010,0x44b48000,0x1400005a,0x4000000,0x84500000,0x1400005a,0x7c00100,0x80230400,0x1400005a,0xc000010,0x84b48000,0x1400005b,0x4000000,
0x84200000,0x1400005b,0x4000010,0x84400000,0x1400005b,0x7c00100,0x80230400,0x14000065,0x4000010,0x84400000,0x14000065,0x7c00100,0x80230400,0x1400559b,0x4000000,0x4200000,
0x1400800a,0x7c00100,0xfc230400,0x14010001,0x2802020,0x10962460,0x14010001,0x2802400,0x10962460,0x14010013,0x2802500,0x20962460,0x14010015,0x2802100,0xfc962460,0x1401003e,
0x2802100,0x40962460,0x1401003e,0x2802100,0x40962461,0x1401003e,0x2802400,0x40962460,0x1401003e,0x2802400,0x50962460,0x1401003e,0x2806400,0x42f62460,0x14010057,0x2802400,
0x40962460,0x15000000,0x80020,0xc4218820,0x15000000,0x4000000,0x4200000,0x15000000,0x4000000,0x4e00000,0x15000000,0x4000000,0xc200000,0x15000000,0x4000000,0x14200000,
0x15000000,0x4000400,0x4200400,0x15000000,0x7c00500,0xfc230400,0x15000000,0x24000000,0x4200000,0x15000000,0x24000000,0x4400000,0x15000000,0x24000000,0x4810000,0x15000000,
0x24000000,0x4e00000,0x15000000,0x24000000,0x5400000,0x15000000,0x24000000,0x5410000,0x15000000,0x24000000,0x5710000,0x15000000,0x24000000,0xc400000,0x15000000,0x24000002,
0x4200000,0x15000000,0x24000020,0x4200000,0x15000000,0x24000020,0x4810000,0x15000000,0x24000020,0x5410000,0x15000000,0x24000500,0xc230400,0x15000000,0x2c000010,0xcb48000,
0x15000002,0x4000000,0x5500000,0x15000002,0x4000020,0x4200000,0x15000002,0x7c00100,0xfc230400,0x15000008,0x4000000,0x4200000,0x15000008,0x4000000,0xc200000,0x15000008,
0x7c00100,0x8220400,0x15000008,0x7c00100,0x8230400,0x15000008,0x7c00100,0x8250400,0x15000008,0x7c00100,0xfc220400,0x15000008,0x7c00100,0xfc250400,0x15000008,0x7c00500,
0xfc230400,0x1500000a,0x7c00100,0xfc230400,0x1500000a,0x7c00500,0xfc230400,0x1500000e,0x7c00100,0x8220400,0x1500000e,0x7c00100,0x8250400,0x1500000e,0x7c00100,0x10250400,
0x15000019,0x7c00100,0x8220400,0x15000019,0x7c00100,0x8230400,0x15000019,0x7c00100,0x8250400,0x15000019,0x7c00100,0x10220400,0x15000019,0x7c00100,0x10250400,0x15000019,
0x7c00100,0x18220400,0x15000019,0x7c00100,0x18250400,0x15000019,0x7c00100,0x20220400,0x15000019,0x7c00100,0x20250400,0x15000019,0x7c00100,0xc822040e,0x15000019,0x7c00100,
0xc822040f,0x15000019,0x7c00100,0xfc250400,0x1500001a,0x4000000,0x4200000,0x1500001a,0x4000000,0x5500000,0x1500001a,0x7c00100,0xfc230400,0x1500001b,0x7c00100,0x80230400,
0x1500001c,0x4000000,0x5800000,0x1500001c,0x6800000,0xfd329800,0x1500001c,0x6800100,0xfd862400,0x1500001c,0x6800100,0xfd862540,0x1500001c,0x6800500,0xfd862400,0x1500001c,
0x7c00100,0xfd830000,0x15000023,0x7c00100,0xfc230400,0x15000024,0x4000000,0x4200000,0x15000024,0x7c00100,0xfc230400,0x15000027,0x4000000,0x4200000,0x15000027,0x4000000,
0x4400000,0x15000027,0x4000000,0x4500000,0x15000027,0x7c00100,0xfc230400,0x15000042,0x4000000,0x44e00000,0x15000042,0x6800000,0x42d29800,0x15000042,0x6800100,0x40962540,
0x15000042,0x7c00100,0x40430400,0x15000042,0x7c00100,0x42d30400,0x15000042,0xc000010,0x44448000,0x1500004f,0x6800000,0x41329800,0x1500004f,0x7c00100,0x40230400,0x1500004f,
0xc000010,0x44448000,0x15000052,0x4000010,0x44400000,0x15000052,0x6800000,0x41329800,0x15000052,0x6800100,0x40962540,0x15000052,0x7c00100,0x40230400,0x15000052,0xc000010,
0x44448000,0x15000063,0x4000010,0x44400000,0x15000063,0x6800000,0x41329800,0x15000063,0x7c00100,0x40230400,0x15000063,0x7c00100,0x48230400,0x15000063,0x7c00900,0x40230400,
0x15000063,0xc000010,0x44448000,0x15000063,0xc000010,0x44b48000,0x15000068,0x7c00100,0x80230400,0x1500006b,0x7c00100,0x80230400,0x1500006c,0x4000000,0x84200000,0x1500006c,
0x7c00100,0x80230400,0x1500006d,0x6800000,0x41329800,0x1500006d,0x7c00100,0x40230400,0x1500006d,0x7c00500,0x40230400,0x1500006d,0x7c00d00,0x40230400,0x1500006d,0xc000010,
0x44448000,0x1500006e,0x4000000,0x84200000,0x1500006e,0x6800100,0x80962540,0x1500006e,0x7c00100,0x80230400,0x1500006f,0x6800000,0x41329800,0x1500006f,0x6800100,0x40962540,
0x1500006f,0x7c00100,0x40230400,0x1500006f,0xc000010,0x44448000,0x15000071,0x6800000,0x41329800,0x15000071,0x6800100,0x40962540,0x15000071,0x7c00100,0x40230400,0x15000573,
0x24000000,0x84400000,0x150005f3,0x4000400,0x4400000,0x15004000,0x24000020,0x4810000,0x15004000,0x24000020,0x5410000,0x15005000,0x4000000,0x4e00000,0x15005000,0x24000000,
0x4200000,0x15005005,0x7c00100,0xfce30400,0x15005011,0x7c40300,0xfce30000,0x1500559b,0x4000000,0x4e00000,0x15008024,0x7c00100,0x8230400,0x15010001,0x2802000,0x8962460,
0x15010001,0x2802000,0x10962460,0x15010001,0x2802000,0x18962460,0x15010001,0x2802100,0x18962460,0x15010001,0x2802400,0x10962460,0x15010001,0x2802400,0x10c62460,0x15010001,
0x2802400,0x18962460,0x15010002,0x2802100,0x20962460,0x15010008,0x2000,0xc962460,0x15010008,0x2802100,0x8962460,0x15010008,0x2802400,0x20962460,0x15010010,0x2802100,
0x20962460,0x1501001a,0x2802100,0x20962460,0x1501001c,0x2802100,0xfd862460,0x1501001c,0x2802500,0xfd862460,0x1501001c,0x2806400,0xfd862460,0x1501001f,0x2802100,0x20962460,
0x15010024,0x2802100,0x20962460,0x15010042,0x2802100,0x40962460,0x1501004f,0x2802100,0x40962460,0x1501004f,0x2802400,0x40962460,0x15010052,0x2802100,0x40962460,0x15010052,
0x2802400,0x40962460,0x15010052,0x2802d00,0x40962460,0x1501006e,0x2802100,0x80962460,0x1501006e,0x2806400,0x80962460,0x1501006f,0x2806400,0x40962460,0x15010071,0x2802100,
0x40962460,0x15010071,0x2806400,0x40962460,0x1501096e,0x2802000,0x10962460,0x15010c98,0x2802400,0x18962460,0x15010c98,0x2802400,0x20962460,0x16000000,0x4000000,0x4200000,
0x16000000,0x4000000,0x5500000,0x16000000,0x4000000,0x5600000,0x16000000,0x4000000,0xc8100006,0x16000000,0x4000000,0xc8200003,0x16000000,0x24000000,0x4200000,0x16000002,
0x4000000,0x4200000,0x16000004,0x4000000,0x5600000,0x16000007,0x7c00100,0x80220400,0x16000007,0x7c00100,0x80250400,0x16000008,0x7c00100,0xfc220400,0x16000008,0x7c00100,
0xfc250400,0x1600000a,0x4000000,0xc200000,0x1600000a,0x6800100,0x8962540,0x1600000a,0x7c00100,0x8230400,0x16000012,0x7c00100,0xa230500,0x16000012,0x7c00100,0xa330520,
0x16000019,0x7c00100,0x8250400,0x1600001c,0x4000000,0x5800000,0x1600001c,0x6800100,0xfd862400,0x1600001c,0x6800500,0xfd862400,0x1600001c,0x7c00100,0xfd830000,0x1600001c,
0x7c00900,0xfd830000,0x16000028,0x4000002,0x44400000,0x16000028,0x7c00100,0x40230400,0x1600003b,0x6800000,0x41329800,0x1600003b,0x7c00100,0x41830000,0x16000047,0x7c00100,
0x80230400,0x16000047,0x7c00100,0x80830400,0x16000047,0x7c00100,0x81430400,0x1600004e,0x4000000,0x44e00000,0x1600004e,0x4000010,0x44400000,0x1600004e,0x6800000,0x42d29800,
0x1600004e,0x6800100,0x40962540,0x1600004e,0x7c00100,0x42b30400,0x1600004e,0xc000010,0x44448000,0x16000058,0x7c00100,0x80230400,0x1600005b,0x4000000,0x84200000,0x1600006a,
0x4000000,0x45800000,0x1600006a,0x6800000,0x41329800,0x1600006a,0x6800100,0x41862400,0x1600006a,0x6800100,0x41862540,0x1600006a,0x7c00100,0x41830000,0x1600006a,0x7c00900,
0x41830000,0x1600006a,0xc000010,0x45848000,0x16000073,0x6800000,0x41329800,0x16000073,0x6800100,0x40962540,0x16000073,0x6800400,0x40962540,0x16000073,0x7c00100,0x40230400,
0x16000073,0xc000010,0x44448000,0x16000074,0x4000000,0x84200000,0x16000074,0x4000010,0x84400000,0x16000074,0x7c00100,0x80230400,0x16000075,0x4000000,0x84400000,0x16000075,
0x4000010,0x84400000,0x16000075,0x7c00100,0x80230400,0x16000078,0x4000000,0x84200000,0x16000078,0x6800100,0x80962540,0x16000078,0x7c00100,0x80230400,0x16000078,0x7c00100,
0x80230401,0x16000078,0xc000010,0x84448000,0x16000078,0x80000000,0x85329960,0x1600007a,0x4000000,0x84200000,0x1600007a,0x7c00100,0x80230400,0x1600007d,0x4000000,0x84200000,
0x1600007d,0x7c00100,0x80230400,0x1600007e,0x4000000,0x84200000,0x1600007e,0x4000010,0x84200000,0x1600007e,0x7c00100,0x80230400,0x1600007e,0xc000010,0x84248000,0x1600007f,
0x4000000,0x45800000,0x1600007f,0x4000010,0x45800000,0x1600007f,0x7c00100,0x41830000,0x1600007f,0x7c00500,0x41830000,0x1600007f,0x7c00900,0x41830000,0x1600007f,0x7e00100,
0x41830000,0x16000082,0x4000000,0x44200000,0x16000082,0x4000010,0x44400000,0x16000082,0x7c00100,0x40230400,0x16000082,0xc000010,0x44448000,0x16000083,0x4000010,0x44400000,
0x16000083,0x7c00100,0x40230400,0x16000083,0xc000010,0x44448000,0x16000085,0x4000000,0x84200000,0x16000085,0x7c00100,0x80230400,0x16000539,0x7c00100,0x8230400,0x1600053b,
0x4000400,0xc200000,0x1600053e,0x6800400,0x8962540,0x1600053e,0x7c00100,0x8230400,0x16000548,0x7c00100,0x8230400,0x1600054a,0x7c00100,0x8230400,0x16000575,0x24000000,
0xc400000,0x160005b4,0x4000000,0x4200000,0x160005c4,0x4000000,0x4200000,0x160005d3,0x4000000,0x4200000,0x160005de,0x4000000,0x5500000,0x160005f6,0x7c00900,0x60430400,
0x16000df1,0x7c00100,0x8230400,0x16001000,0x4000000,0x4100000,0x16001000,0x4000000,0xc8100002,0x16001000,0x4000000,0xc8100003,0x16001000,0x4000000,0xc8100006,0x16001000,
0x4000000,0xc810000d,0x16001000,0x4000100,0x4150400,0x16001000,0x4000100,0xc815040d,0x16001000,0x24000000,0x4100000,0x16001000,0x24000000,0x4e00000,0x16001000,0x24000000,
0x6800000,0x16005000,0x4000000,0xc8e00002,0x16005000,0x4000000,0xc8e0000d,0x16005000,0x24000000,0x4100000,0x16005000,0x24000000,0x4e00000,0x16005011,0x7c00300,0xc8e30001,
0x16005011,0x7c40300,0xfce30000,0x16005012,0x7c00100,0xa130480,0x16005014,0x4000000,0xc8e0000d,0x1600559b,0x4000000,0xc8e00003,0x1600800a,0x7c00100,0xfc230400,0x16010001,
0x2802400,0x10962460,0x16010007,0x2802400,0x80962460,0x16010007,0x2802400,0x90962460,0x1601000a,0x2802100,0x20962460,0x1601000a,0x2802400,0x8962460,0x1601001c,0x2802100,
0xfd862460,0x1601004e,0x2802100,0x40962460,0x1601004e,0x2802400,0x40962460,0x1601004e,0x2806400,0x42f62460,0x1601006a,0x2802100,0x41862460,0x1601006a,0x2802400,0x40962460,
0x1601006a,0x2802400,0x41862460,0x1601006a,0x2806400,0x41862460,0x16010073,0x2802100,0x40962460,0x16010073,0x2806400,0x40962460,0x16010078,0x2802100,0x80962460,0x16010078,
0x2802400,0x80962460,0x16010078,0x2806400,0x80962460,0x1601007e,0x2802000,0x80962460,0x1601007e,0x2802100,0x80962460,0x1601007e,0x2802400,0x80962460,0x1601007f,0x2802100,
0x41862460,0x1601007f,0x2802400,0x41862460,0x16010082,0x2802400,0x40962460,0x16010939,0x2802400,0x8962460,0x1601093a,0x2802400,0x8962460,0x1601093e,0x2802400,0x8962460,
0x16010940,0x2802400,0x8962460,0x16010942,0x2802400,0x8962460,0x16010ded,0x2802400,0x8962460,0x18000000,0x4000000,0x4200000,0x18000000,0x4000000,0x4e00000,0x18000000,
0x4000000,0x5600000,0x18000000,0x4000000,0x6703580,0x18000000,0x24000000,0x4200000,0x18000000,0x24000000,0x4e00000,0x18000000,0x24000000,0x5710000,0x18000000,0x24000020,
0x4200000,0x18000002,0x4000000,0x14200000,0x18000002,0x7c00100,0xfc230400,0x18000008,0x7c00100,0x8220400,0x18000008,0x7c00100,0x8250400,0x18000008,0x7c00100,0xfc220400,
0x18000008,0x7c00100,0xfc250400,0x1800000a,0x6800100,0xfc962540,0x1800000a,0x7c00100,0xfc230400,0x1800000b,0x7c00100,0xfc230400,0x18000019,0x7c00100,0x8220400,0x18000019,
0x7c00100,0x8250400,0x18000019,0x7c00100,0x10220400,0x18000019,0x7c00100,0xc822040e,0x18000019,0x7c00100,0xfc250400,0x1800001a,0x7c00100,0xfc230560,0x1800001f,0x4000000,
0x4200000,0x18000027,0x4000000,0x4c00000,0x18000027,0x7c00100,0xfc230400,0x1800003c,0x4000000,0x44400000,0x1800003f,0x4000000,0x44200000,0x1800003f,0x6800100,0x40962540,
0x1800003f,0x7c00100,0x42d30400,0x18000041,0x4000000,0x84e00000,0x18000041,0x4000010,0x84e00000,0x18000041,0x6800000,0x82d29800,0x18000041,0x6800100,0x80962540,0x18000041,
0x7c00100,0x82b30400,0x18000041,0x7c00100,0x82c30400,0x18000041,0xc000010,0x84448000,0x18000054,0x4000010,0x44200000,0x18000054,0x7c00100,0x40230400,0x18000082,0x7c00100,
0x40230400,0x18001000,0x4000000,0x4100000,0x18001000,0x4000000,0xc810000d,0x18001000,0x4000100,0x4150400,0x18001000,0x4000100,0xc815040d,0x18005000,0x4000000,0x4100000,
0x18005000,0x4000000,0x4200000,0x18005000,0x4000000,0x4e00000,0x18005000,0x4000000,0x6800000,0x18005000,0x4000000,0xc8e0000d,0x18005000,0x24000000,0x4200000,0x18005000,
0x24000000,0x4e00000,0x18005000,0x24000000,0x6800000,0x18005005,0x7c00100,0xfce30400,0x18005011,0x7c40300,0xfce30000,0x18005014,0x7c00100,0x8e30000,0x18005016,0x7c00100,
0x8e30c00,0x1800559b,0x4000000,0xc8e00003,0x1800801a,0x7c00100,0xfc230400,0x18010001,0x2802400,0x10c62460,0x18010002,0x2802100,0x20962460,0x1801000a,0x2802100,0xfc962460,
0x1801000b,0x2802400,0xfc962460,0x18010027,0x2802100,0xfc962460,0x1801003c,0x2806000,0x40962460,0x1801003f,0x2802100,0x40962460,0x1801003f,0x2802400,0x40962460,0x1801003f,
0x2806400,0x42e62460,0x18010041,0x2802100,0x80962460,0x18010041,0x2806400,0x82f62460,0x18010054,0x2802000,0x40962460,0x19000000,0x4000000,0x4200000,0x19000000,0x4000000,
0xc820000f,0x19000000,0x24000000,0x4200000,0x19000000,0x24000000,0x4400000,0x19000000,0x24000000,0xc200000,0x19000000,0x24000002,0x4300000,0x19000000,0x24000020,0x4200000,
0x19000002,0x4000020,0x4200000,0x19000002,0x7c00100,0xfc230400,0x19000002,0x7c00120,0xc8230405,0x19000002,0x80000000,0x5329960,0x19000003,0x4000000,0x5600000,0x19000007,
0x7c00100,0x80220400,0x19000007,0x7c00100,0x80250400,0x1900000c,0x7c00100,0xfc220400,0x1900000c,0x7c00100,0xfc230400,0x1900000c,0x7c00100,0xfc250400,0x1900000f,0x4000000,
0x4200000,0x19000018,0x7c00100,0xfd830000,0x19000019,0x7c00100,0xfc220400,0x19000019,0x7c00100,0xfc250400,0x19000019,0x7c00500,0xc822040f,0x1900003c,0x7c00100,0x40230400,
0x19000056,0x7c00100,0x80230400,0x1900005c,0x6800100,0x40962540,0x1900005c,0x7c00100,0x40230400,0x1900005c,0x7c00500,0x40230400,0x19000071,0x4000000,0x44200000,0x19000071,
0x7c00100,0x40230400,0x19000073,0x6800100,0x40962540,0x19000073,0x7c00100,0x40230400,0x19000073,0x7c00900,0x40230400,0x19000073,0xc000010,0x44448000,0x19000076,0x4000000,
0x44400000,0x19000076,0x6800000,0x41329800,0x19000076,0x6800100,0x40962540,0x19000076,0x7c00100,0x40230400,0x19000076,0xc000010,0x44448000,0x1900008d,0x7c00100,0x80230400,
0x19000097,0x4000000,0x84200000,0x19000097,0x4000000,0x84400000,0x19000097,0x6800000,0x81329800,0x19000097,0x6800100,0x80962540,0x19000097,0x7c00100,0x80230400,0x19000097,
0x7c00100,0x80230560,0x19000097,0xc000010,0x84448000,0x19000098,0x6800000,0x81329800,0x19000098,0x7c00100,0x80230400,0x19000099,0x6800000,0x81329800,0x19000099,0x6800100,
0x80962540,0x19000099,0x7c00100,0x80230400,0x1900053e,0x7c00100,0x8230400,0x19000555,0x7c00100,0x8230400,0x19005000,0x4000000,0x4e00000,0x19005011,0x7c00300,0xc8e30001,
0x19005011,0x7c40300,0xfce30000,0x19010002,0x2802400,0x20962460,0x19010002,0x2802500,0x20962460,0x19010008,0x2802100,0x8962460,0x1901005c,0x2802500,0x40962460,0x19010071,
0x2802100,0x40962460,0x19010071,0x2806400,0x40962460,0x19010073,0x2802100,0x40962460,0x19010073,0x2806400,0x40962460,0x19010076,0x2802100,0x40962460,0x19010076,0x2802100,
0x40962461,0x19010076,0x2806400,0x40962460,0x19010097,0x2802100,0x80962460,0x19010097,0x2806400,0x80962460,0x19010099,0x2802100,0x80962460,0x19010099,0x2802400,0x80962460,
0x19010099,0x2806400,0x80962460,0x19010957,0x2802400,0x8962460,0x1a000000,0x4000000,0x5600000,0x1b000000,0x80000,0xc4918820,0x1b000cab,0x80000,0xc4918820,0x1c000000,
0x4000000,0x4100000,0x1c000000,0x4000000,0x4200000,0x1c000000,0x4000000,0x4e00000,0x1c000000,0x4000000,0x5200000,0x1c000000,0x4000000,0x5500000,0x1c000000,0x4000000,
0x5600000,0x1c000000,0x4000000,0x5710000,0x1c000000,0x4000000,0x6800000,0x1c000000,0x4000400,0x4200400,0x1c000000,0x24000000,0x4200000,0x1c000000,0x24000000,0x4400000,
0x1c000000,0x24000000,0x4e00000,0x1c000000,0x24000002,0x4400000,0x1c000000,0x24000008,0x5410000,0x1c000000,0x80000000,0x5329960,0x1c000002,0x7c00100,0x8230400,0x1c000002,
0x7c00100,0xfc230400,0x1c000003,0x4000000,0x4200000,0x1c000004,0x7c00100,0x8230400,0x1c000008,0x7c00100,0x8220400,0x1c000008,0x7c00100,0x8250400,0x1c000008,0x7c00100,
0xfc220400,0x1c000008,0x7c00100,0xfc250400,0x1c000008,0x7c00500,0xc822040f,0x1c00000e,0x4000000,0x4200000,0x1c00000e,0x7c00100,0x8220400,0x1c00000e,0x7c00100,0x8250400,
0x1c000019,0x7c00100,0x8220400,0x1c000019,0x7c00100,0x8230400,0x1c000019,0x7c00100,0x8250400,0x1c000019,0x7c00500,0xc822040f,0x1c00001c,0x6800000,0xfd329800,0x1c00001c,
0x6800500,0xfd862400,0x1c00001c,0x7c00100,0x9830000,0x1c00001c,0x7c00100,0xfd830000,0x1c00001c,0x7c00900,0x9830000,0x1c00001e,0x7c00100,0x80230400,0x1c000020,0x7c00100,
0x80230400,0x1c000021,0x4000000,0x4200000,0x1c000021,0x6800000,0x9329800,0x1c000030,0x7c00100,0x40230400,0x1c00004b,0x4000000,0x84200000,0x1c00004b,0x4000010,0x84400000,
0x1c00004b,0x6800000,0x81329800,0x1c00004b,0x7c00100,0x80230400,0x1c00004b,0x7c00900,0x80230400,0x1c00004b,0xc000010,0x84448000,0x1c000053,0x7c00100,0x80230400,0x1c000059,
0x7c00100,0x80230400,0x1c000065,0x4000010,0x84400000,0x1c000065,0x7c00100,0x80230400,0x1c000079,0x4000000,0x84200000,0x1c000079,0x4000000,0x84f00000,0x1c000079,0x4000010,
0x84400000,0x1c000079,0x7c00100,0x80230400,0x1c00007b,0x4000000,0x84200000,0x1c00007b,0x4000010,0x84200000,0x1c00007b,0x7c00100,0x80230400,0x1c000086,0x7c00100,0x80230400,
0x1c000086,0xc000010,0x84448000,0x1c000087,0x4000000,0x84200000,0x1c000087,0x7c00100,0x80230400,0x1c000087,0xc000010,0x84448000,0x1c000088,0x7c00100,0x80230400,0x1c000089,
0x6800100,0x80962540,0x1c000089,0x6800100,0x80962541,0x1c000089,0x7c00100,0x80430400,0x1c000089,0x7c00100,0x82b30400,0x1c000089,0x7c00100,0x82d30400,0x1c000089,0x7c00900,
0x80430400,0x1c00008c,0x4000000,0x84200000,0x1c00008c,0x7c00100,0x80230400,0x1c00008e,0x4000000,0x84200000,0x1c00008e,0x7c00100,0x80230400,0x1c00008f,0x4000000,0x84200000,
0x1c00008f,0x7c00100,0x80230400,0x1c000090,0x4000000,0x84200000,0x1c000090,0x7c00100,0x80230400,0x1c000091,0x6800000,0x81329800,0x1c000091,0x6800100,0x80962540,0x1c000091,
0x7c00100,0x80230400,0x1c000092,0x4000000,0x84200000,0x1c000092,0x6800000,0x81329800,0x1c000092,0x7c00100,0x80220400,0x1c000092,0x7c00100,0x80230400,0x1c000092,0x7c00100,
0x80250400,0x1c000095,0x6800000,0xa1329800,0x1c000095,0x7c00100,0xa0230400,0x1c000095,0xc000010,0x84448000,0x1c000097,0x7c00100,0x80230400,0x1c000097,0xc000010,0x84248000,
0x1c00009d,0x4000000,0x84200000,0x1c00009d,0x4000010,0x84200000,0x1c00009d,0x6800100,0x80962540,0x1c00009d,0x7c00100,0x80230400,0x1c00009d,0xc000010,0x84448000,0x1c00009e,
0x4000000,0x84200000,0x1c00009e,0x6800000,0x81329800,0x1c00009e,0x6800100,0x80962540,0x1c00009e,0x6800100,0x80962541,0x1c00009e,0x7c00100,0x80230400,0x1c00009f,0x4000000,
0x84200000,0x1c00009f,0x7c00100,0x80230400,0x1c0000a0,0x4000000,0x84200000,0x1c0000a0,0x4000000,0x84500000,0x1c0000a0,0x7c00100,0x80230400,0x1c0000a3,0x4000000,0x84200000,
0x1c0000a3,0x6800000,0x81329800,0x1c0000a3,0x6800100,0x80962540,0x1c0000a3,0x7c00100,0x80230400,0x1c0000a3,0xc000010,0x84448000,0x1c0000a5,0x7c00100,0x80230400,0x1c0000a6,
0x4000000,0x84500000,0x1c0000a6,0x4000010,0x84b00000,0x1c0000a6,0x4000800,0x84200000,0x1c0000a6,0x6800100,0x80962540,0x1c0000a6,0x6800100,0x80962541,0x1c0000a6,0x7c00100,
0x80230400,0x1c0000a6,0xc000010,0x84448000,0x1c00045d,0x80000,0xc4918820,0x1c00045d,0x2c000010,0x84448000,0x1c00057c,0x24000010,0x4400000,0x1c000606,0x4000000,0xc200000,
0x1c000e0a,0x4000010,0x84400000,0x1c000e0c,0x6800100,0xfc962540,0x1c005000,0x4000000,0x4e00000,0x1c005000,0x4000000,0x6800000,0x1c00800a,0x7c00100,0x8230400,0x1c008024,
0x7c00100,0x8230400,0x1c010001,0x2400,0x4962460,0x1c010001,0x2802100,0x10962460,0x1c010001,0x2802400,0x8962460,0x1c010001,0x2802400,0x10962460,0x1c010001,0x2802400,
0x10c62460,0x1c010002,0x2802100,0x20962460,0x1c010015,0x2802100,0x8962460,0x1c01001a,0x2802100,0x8962460,0x1c01001c,0x2802500,0x9862460,0x1c01001c,0x2802500,0xfd862460,
0x1c010024,0x2802100,0x8962460,0x1c010041,0x2806000,0x80c62460,0x1c01004b,0x2802400,0x80962460,0x1c010059,0x2802100,0x80962460,0x1c010079,0x2802400,0x80962460,0x1c010086,
0x2802400,0x80962460,0x1c010087,0x2802000,0x80962460,0x1c010087,0x2802100,0x80962460,0x1c010089,0x2802100,0x80962460,0x1c010089,0x2802400,0x80962460,0x1c010089,0x2806400,
0x82f62460,0x1c01008c,0x2802400,0x80962460,0x1c010091,0x2802100,0x80962460,0x1c010091,0x2802400,0x80962460,0x1c010091,0x2806400,0x80962460,0x1c01009d,0x2802100,0x80962460,
0x1c01009d,0x2802400,0x80962460,0x1c01009d,0x2802900,0x80962460,0x1c01009d,0x2806400,0x80962460,0x1c01009e,0x2802100,0x80962460,0x1c01009e,0x2802400,0x80962460,0x1c01009e,
0x2806400,0x80962460,0x1c0100a0,0x2802400,0x80962460,0x1c0100a3,0x2802100,0x80962460,0x1c0100a3,0x2806400,0x80962460,0x1c0100a6,0x2802100,0x80962460,0x1c0100a6,0x2802400,
0x80962460,0x1c0100a6,0x2806400,0x80962460,0x1c010955,0x2802400,0x8962460,0x1c010a06,0x2802400,0x8962460,0x1c010e0c,0x2802100,0xfc962460,0x1c010e0c,0x2802400,0xfc962460,
0x20000000,0x4000000,0x5500000,0x20000000,0x4000000,0x24200000,0x20000000,0x4000000,0x24e00000,0x20000000,0x4000000,0x34200000,0x20000000,0x24000000,0x24200000,0x20000002,
0x7c00100,0x20230400,0x20000006,0x7c00100,0x40220400,0x20000006,0x7c00100,0x40250400,0x2000000a,0x4000000,0x2c500000,0x2000000a,0x7c00100,0x28230400,0x20000019,0x7c00100,
0x20220400,0x20000019,0x7c00100,0x20230400,0x20000019,0x7c00100,0x20250400,0x2000001a,0x7c00100,0x8230400,0x2000004c,0x4000000,0x84200000,0x2000004c,0x7c00100,0x80220400,
0x2000004c,0x7c00100,0x80250400,0x20000065,0x7c00100,0x80230400,0x20000070,0x4000000,0x84200000,0x20000070,0x4000010,0x84400000,0x20000070,0xc000010,0x84448000,0x20000089,
0x7c00100,0x82d30400,0x2000008d,0x4000000,0x84200000,0x20000097,0x4000000,0x84400000,0x20000097,0x4000000,0x84500000,0x20000097,0x7c00100,0x80230400,0x20000097,0xc000010,
0x84448000,0x2000009c,0x7c00100,0x80230400,0x2000009c,0x7c00100,0x80830400,0x2000009c,0x7c00100,0x81430400,0x200000a1,0x4000000,0x85800000,0x200000a1,0x6800000,0x81329800,
0x200000a1,0x6800100,0x81862400,0x200000a1,0x6800100,0x81862540,0x200000a1,0x7c00100,0x81830000,0x200000a1,0xc000010,0x84448000,0x200000a2,0x4000000,0x84200000,0x200000a2,
0x7c00100,0x80230400,0x200000a4,0x7c00100,0x80230400,0x200000a4,0xc000010,0x84448000,0x200000a6,0x7c00100,0x80230400,0x200000a6,0xc000010,0x84448000,0x20005000,0x4000000,
0x4e00000,0x20005000,0x4000000,0x6800000,0x20005011,0x7c40300,0xfce30000,0x2000800f,0x7c00100,0x20230400,0x20008024,0x7c00100,0x20230400,0x20010002,0x2802500,0x20962460,
0x20010008,0x2802100,0x28962460,0x20010008,0x2802400,0x30962460,0x20010008,0x2802400,0x30c62460,0x20010070,0x2802000,0x80962460,0x20010089,0x2802100,0x80962460,0x20010097,
0x2802000,0x80962460,0x20010097,0x2802400,0x80962460,0x200100a1,0x2802100,0x81862460,0x200100a1,0x2806400,0x81862460,0x200100a6,0x2802100,0x80962460,0x20015000,0x4000000,
0x6902460,0x24000000,0x4000000,0x4e00000,0x24000000,0x24000000,0x4200000,0x24000000,0x24000000,0x4400000,0x24000000,0x80000000,0x5329960,0x24000002,0x7c00100,0xfc230400,
0x24000008,0x7c00100,0x8220400,0x2400000e,0x4000000,0x4200000,0x24000015,0x7c00100,0xfc230400,0x24000019,0x7c00100,0x10250400,0x2400001a,0x4000000,0x4200000,0x2400001a,
0x7c00100,0xfc230400,0x2400001b,0x4000000,0x84500000,0x240000a7,0x4000000,0x45400000,0x240000a7,0x6800000,0x41329800,0x240000a7,0x7c00100,0x40220400,0x240000a7,0x7c00100,
0x40250400,0x240000a8,0x4000000,0x84200000,0x240000a8,0x4000000,0x84400000,0x240000a8,0x4000010,0x84400000,0x240000a8,0x6800000,0x81329800,0x240000a8,0x6800100,0x80962540,
0x240000a8,0x7c00100,0x80230400,0x240000a8,0xc000010,0x84448000,0x240000a9,0x4000000,0x84500000,0x240000a9,0x4000010,0x84b00000,0x240000a9,0x6800100,0x80962540,0x240000a9,
0x7c00100,0x80230400,0x240000aa,0x4000000,0x44200000,0x240000aa,0x4000000,0x44400000,0x240000aa,0x4000010,0x44400000,0x240000aa,0x6800000,0x41329800,0x240000aa,0x6800100,
0x40962540,0x240000aa,0x7c00100,0x40230400,0x240000aa,0xc000010,0x44448000,0x240000ab,0x7c00100,0x40220400,0x240000ab,0x7c00100,0x40250400,0x24000496,0x24000000,0x4400000,
0x24001000,0x4000000,0x4100000,0x24005000,0x4000000,0x4e00000,0x24005000,0x4000000,0x6800000,0x24005000,0x4000000,0xc8e0000d,0x2400509a,0x7c00300,0x80e30000,0x2400509a,
0x7c00900,0x81230400,0x24010001,0x2802400,0x10962460,0x24010002,0x2802000,0x20962460,0x24010002,0x2802100,0x20962460,0x24010038,0x2802100,0x80962460,0x2401006f,0x2802100,
0x40962460,0x2401009d,0x2802100,0x80962460,0x240100a7,0x2802100,0x40962460,0x240100a7,0x2802400,0x40962460,0x240100a7,0x2802c00,0x40962460,0x240100a8,0x2802100,0x80962460,
0x240100a8,0x2806400,0x80962460,0x240100a9,0x2802100,0x80962460,0x240100aa,0x2802100,0x40962460,0x240100aa,0x2802400,0x40962460,0x240100aa,0x2806400,0x40962460,0x28000000,
0x4000000,0x4200000,0x28000000,0x4000000,0x4e00000,0x28000000,0x4000000,0x5600000,0x28000000,0x24000000,0x4200000,0x28000000,0x24000000,0x4400000,0x28000004,0x4000000,
0x4200000,0x28000004,0x7c00100,0x8230400,0x2800001e,0x7c00100,0x80230400,0x28000022,0x7c00100,0x40230400,0x280000af,0x6800000,0x81329800,0x280000af,0x7c00100,0x80230400,
0x280000af,0x7c00100,0x80230560,0x280000b0,0x4000000,0x84400000,0x280000b0,0x4000000,0x84500000,0x280000b0,0x4000010,0x84400000,0x280000b0,0x6800100,0x80962540,0x280000b0,
0x7c00100,0x80230400,0x280000b0,0x7c00100,0x80230560,0x280000b0,0xc000010,0x84448000,0x280000b1,0x4000000,0x84200000,0x280000b1,0x4000000,0x84400000,0x280000b1,0x4000000,
0x84500000,0x280000b1,0x6800100,0x80962540,0x280000b1,0x7c00100,0x80230400,0x280000b1,0x7c00100,0x80230560,0x280000b1,0xc000010,0x84448000,0x2800055b,0x6800400,0x8962540,
0x28005000,0x4000000,0x4e00000,0x28005000,0x4000000,0x6800000,0x28005005,0x7c00100,0x8e30400,0x28005011,0x7c40300,0xfce30000,0x28005014,0x7c00100,0x8e30000,0x28005096,
0x7c00300,0x80e30000,0x28005096,0x7c00900,0x81230400,0x28010001,0x2802400,0x10962460,0x2801000f,0x2802100,0xfc962460,0x2801000f,0x2802400,0xfc962460,0x2801000f,0x2802900,
0xfc962460,0x2801001a,0x2802100,0xfc962460,0x2801001a,0x2806400,0x8962460,0x280100af,0x2802100,0x80962460,0x280100af,0x2802400,0x80962460,0x280100af,0x2806400,0x80962460,
0x280100b0,0x2802100,0x80962460,0x280100b0,0x2802800,0x80962460,0x280100b0,0x2806400,0x80962460,0x280100b1,0x2802000,0x80962460,0x280100b1,0x2802100,0x80962460,0x280100b1,
0x2806400,0x80962460,0x2801095c,0x2802400,0x10962460,0x2c000000,0x4000000,0x4200000,0x2c000000,0x4000000,0x4e00000,0x2c000000,0x4000000,0x5500000,0x2c000000,0x24000000,
0x4200000,0x2c000000,0x24000000,0x4400000,0x2c000000,0x24000010,0x4400000,0x2c000003,0x7c00100,0x10220400,0x2c00000a,0x7c00100,0x8230400,0x2c00000c,0x7c00100,0xfc230400,
0x2c000010,0x4000000,0x4200000,0x2c000013,0x7c00100,0xfe633800,0x2c000015,0x4000000,0x4500000,0x2c000019,0x7c00100,0x10220400,0x2c000019,0x7c00100,0x20220400,0x2c000019,
0x7c00100,0x20250400,0x2c00001b,0x7c00100,0x80230400,0x2c000039,0x4000000,0x84200000,0x2c000039,0x7c00100,0x80230400,0x2c000057,0x4000000,0x45600000,0x2c000076,0x6800100,
0x40962540,0x2c000076,0x7c00100,0x40230400,0x2c000078,0x80000000,0x85329960,0x2c0000a1,0x7c00100,0x81830000,0x2c0000b0,0x7c00100,0x80230400,0x2c0000b2,0x4000000,0x84200000,
0x2c0000b2,0x6800100,0x80962540,0x2c0000b2,0x7c00100,0x80230400,0x2c0000b3,0x6800000,0x41329800,0x2c0000b3,0x6800100,0x40962540,0x2c0000b3,0x7c00100,0x40230400,0x2c0000b4,
0x6800100,0x80962540,0x2c0000b4,0x7c00100,0x80430400,0x2c0000b4,0x7c00100,0x82d30400,0x2c0000b4,0xc000010,0x84448000,0x2c0000b5,0x4000000,0x84200000,0x2c0000b5,0x4000010,
0x84400000,0x2c0000b5,0x7c00100,0x80220400,0x2c0000b5,0x7c00100,0x80250400,0x2c0000b5,0xc000010,0x84448000,0x2c0000b6,0x6800000,0x41329800,0x2c0000b6,0x7c00100,0x40230400,
0x2c0000b6,0x7c00500,0x40230400,0x2c0000b7,0x4000000,0x84200000,0x2c0000b7,0x7c00100,0x80230400,0x2c0000b7,0xc000010,0x84248000,0x2c0000b8,0x4000000,0x84200000,0x2c0000b8,
0x7c00100,0x80230400,0x2c005000,0x4000000,0x4200000,0x2c005000,0x4000000,0x4e00000,0x2c005000,0x4000000,0x6800000,0x2c005005,0x7c00100,0xfce30400,0x2c005011,0x7c40300,
0xfce30000,0x2c00509a,0x7c00300,0x80e30000,0x2c010002,0x2802000,0x20962460,0x2c010004,0x2802000,0xfc962460,0x2c01000a,0x2802100,0x8962460,0x2c010024,0x2802100,0xfc962460,
0x2c010057,0x2802000,0x40962460,0x2c0100aa,0x2802000,0x40962460,0x2c0100b2,0x2802100,0x80962460,0x2c0100b2,0x2802400,0x80962460,0x2c0100b2,0x2806400,0x80962460,0x2c0100b3,
0x2802100,0x40962460,0x2c0100b3,0x2806400,0x40962460,0x2c0100b4,0x2802100,0x80962460,0x2c0100b6,0x2802500,0x40962460,0x2c0100b7,0x2802400,0x80962460,0x2c010921,0x2802400,
0xfc962460,0x30000000,0x4000000,0x4200000,0x30000000,0x4000000,0xc820000f,0x30000000,0x24000000,0x4200000,0x30000000,0x24000010,0x4400000,0x30000018,0x7c00100,0xfd830000,
0x30000019,0x7c00100,0x10220400,0x30000019,0x7c00100,0x10250400,0x30000019,0x7c00100,0xfc220400,0x30000019,0x7c00100,0xfc250400,0x30000023,0x4000000,0x4200000,0x30000023,
0x4000000,0x4400000,0x30000023,0x4000000,0x5500000,0x30000024,0x4000000,0x4500000,0x30000047,0,0x84818820,0x30000047,0,0x84c18820,0x30000047,0,
0x85418820,0x3000005c,0x6800100,0x40962540,0x3000005c,0x7c00100,0x40230400,0x30000099,0x7c00100,0x80230400,0x300000a7,0x7c00100,0x40230400,0x300000aa,0x7c00100,0x40230400,
0x300000b0,0x7c00100,0x80230560,0x300000b9,0x7c00100,0x80230400,0x300000ba,0x4000000,0x44200000,0x300000ba,0x6800000,0x41329800,0x300000ba,0x7c00100,0x40230400,0x300000ba,
0x7c00900,0x40230400,0x300000bb,0x4000000,0x84500000,0x300000bb,0x6800100,0x80962540,0x300000bb,0x7c00100,0x80230400,0x300000bc,0x4000000,0x45600000,0x300000bc,0x6800000,
0x41329800,0x300000bc,0x7c00100,0x40230400,0x30000549,0x7c00100,0x80230400,0x30000d23,0x4000000,0x4200000,0x30005000,0x4000000,0x4e00000,0x30005000,0x4000000,0x6800000,
0x30005011,0x4000000,0x5200000,0x30005011,0x7c00900,0x9230400,0x30005014,0x7c00100,0xfe530000,0x30005016,0x7c00100,0xfe530c00,0x3000509a,0x7c00300,0x80e30000,0x30010018,
0x2806400,0xfd862460,0x3001005c,0x2802100,0x40962460,0x300100ba,0x2802400,0x40962460,0x300100bb,0x2802100,0x80962460,0x300100bb,0x2806400,0x80962460,0x300100bc,0x2802400,
0x40962460,0x3100559b,0x4000000,0xc8e0000d,0x34000000,0x4000000,0x4200000,0x34000000,0x4000400,0x4200000,0x34000000,0x6800000,0xc9329805,0x34000000,0x24000000,0x4200000,
0x34000002,0x7c00100,0xfc230400,0x34000019,0x7c00100,0x8220400,0x34000019,0x7c00100,0x8250400,0x34000019,0x7c00100,0x10220400,0x34000019,0x7c00100,0xfc220400,0x34000019,
0x7c00100,0xfc250400,0x34000019,0x7c00500,0xc822040f,0x3400001a,0x7c00100,0x18230400,0x34000076,0x7c00100,0x40230400,0x34000083,0x7c00100,0x40230400,0x34000097,0x6800100,
0x80962540,0x340000aa,0x4000010,0x44400000,0x340000aa,0x7c00100,0x40230400,0x340000bd,0x4000000,0x84200000,0x340000bd,0x7c00100,0x80230400,0x340000be,0x4000000,0x84400000,
0x340000be,0x6800000,0x82d29800,0x340000be,0x6800100,0x80962540,0x340000be,0x6800100,0x80962541,0x340000be,0x7c00100,0x82b30400,0x340000be,0x7c00100,0x82c30560,0x340000be,
0xc000010,0x84448000,0x340000c0,0x4000002,0x84400000,0x340000c0,0x7c00100,0x80230400,0x34005000,0x4000000,0x4e00000,0x34005000,0x4000000,0x6800000,0x34005005,0x7c00100,
0xfce30400,0x34005011,0x7c40300,0xfce30000,0x3400509a,0x7c00300,0x80e30000,0x340050bf,0x7c00300,0x80230000,0x34010001,0x2802100,0x10962460,0x3401001f,0x2802c00,0xfc962460,
0x34010021,0x2802100,0x10962460,0x3401003a,0x2806400,0x40962460,0x34010097,0x2802100,0x80962460,0x340100be,0x2802100,0x80962460,0x340100be,0x2802400,0x80962460,0x340100be,
0x2806400,0x80962460,0x340100be,0x2806400,0x82f62460,0x340100c0,0x2802100,0x80962460,0x34015011,0x2802500,0xfc962460,0x340150bf,0x2802200,0x80c62460,0x38000000,0x4000000,
0x5500000,0x38000000,0x4000000,0x14200000,0x38000000,0x24000000,0x5410000,0x38000000,0x24000000,0x6410000,0x38000000,0x24000002,0x4400000,0x38000000,0x2c000010,0x4b48000,
0x38000002,0x4000000,0x4200000,0x38000002,0x4000000,0x14200000,0x38000002,0x7c00100,0xfc230400,0x38000002,0x7c00500,0xfc230400,0x38000002,0xc000010,0x4b48000,0x38000002,
0x80000000,0x5329960,0x3800000b,0x7c00100,0xfc230400,0x38000015,0x7c00100,0xfc230400,0x38000019,0x7c00100,0xc822040f,0x38000019,0x7c00100,0xfc220400,0x38000019,0x7c00100,
0xfc230400,0x38000019,0x7c00100,0xfc250400,0x38000019,0x7c00500,0x20220400,0x38000019,0x7c00500,0xc822040f,0x38000019,0x7c00d00,0xc823040f,0x38000024,0x7c00100,0xfc230400,
0x38000028,0x7c00100,0x40230400,0x3800002a,0x7c00100,0x80230400,0x38000038,0x7c00100,0x80220400,0x38000038,0x7c00100,0x80250400,0x3800003e,0x7c00100,0x42b30400,0x3800003e,
0xc000010,0x44448000,0x38000041,0x7c00100,0x82b30400,0x38000099,0x4000000,0x84200000,0x380000a1,0x7c00100,0x81830000,0x380000c1,0x4000000,0x84200000,0x380000c1,0x7c00100,
0x80230400,0x380000c2,0x7c00100,0x80230400,0x380000c2,0xc000010,0x84248000,0x380000c3,0x6800000,0x81329800,0x380000c3,0x7c00100,0x80230400,0x380000c4,0x7c00100,0x80230400,
0x380000c5,0x7c00100,0x80220400,0x380000c5,0x7c00100,0x80250400,0x38005000,0x4000000,0x4e00000,0x38005000,0x4000000,0x6800000,0x38005011,0x7c40300,0xfce30000,0x38005014,
0x7c00100,0xfce30000,0x38005016,0x7c00100,0xfce30c00,0x38005016,0x7c00500,0x20230c00,0x38010001,0x2802100,0x20962460,0x38010001,0x2802400,0x10962460,0x38010001,0x2802400,
0x20962460,0x38010002,0x2802400,0x20962460,0x3801001b,0x12882000,0xc4962460,0x38010024,0x2802400,0xfc962460,0x3801002a,0x2806400,0x80962460,0x38010041,0x2802100,0x80962460,
0x38010041,0x2806400,0x80962460,0x38010078,0x2802100,0x80962460,0x380100c2,0x2802400,0x80962460,0x380100c4,0x2802400,0x80962460,0x38010874,0x2802400,0x50962460,0x3c000000,
0x4000000,0x4200000,0x3c000000,0x4000000,0x4e00000,0x3c000008,0x7c00500,0xc822040e,0x3c000008,0x7c00500,0xc822040f,0x3c00000a,0x4000000,0x4500000,0x3c000015,0x6800100,
0xfc962540,0x3c000019,0x7c00100,0xfc220400,0x3c000047,0,0x84818820,0x3c000047,0,0x84c18820,0x3c000047,0,0x85418820,0x3c000047,0x7c00100,0x80230400,
0x3c000047,0x7c00100,0x81430400,0x3c00009d,0x7c00100,0x80230400,0x3c0000c6,0x4000000,0x84e00000,0x3c0000c6,0x6800000,0x82d29800,0x3c0000c6,0x6800100,0x80962540,0x3c0000c6,
0x7c00100,0x82b30400,0x3c0000c6,0x7c00100,0x82c30560,0x3c0000c6,0xc000010,0x84448000,0x3c0000c7,0x6800000,0x81329800,0x3c0000c7,0x7c00100,0x80230400,0x3c005000,0x4000000,
0x4e00000,0x3c005000,0x4000000,0x6800000,0x3c005011,0x7c40300,0xfce30000,0x3c005014,0x7c00100,0xfe530000,0x3c005016,0x7c00100,0xfe530c00,0x3c010002,0x2802400,0x20962460,
0x3c010008,0x2802100,0xfc962460,0x3c010018,0x2802000,0xfd862460,0x3c010047,0x2802000,0x80962460,0x3c010047,0x2802400,0x80962460,0x3c01009d,0x2802100,0x80962460,0x3c0100c6,
0x2802100,0x80962460,0x3c0100c6,0x2806400,0x80962460,0x3c0100c6,0x2806400,0x82f62460,0x3c0100c7,0x2802000,0x80962460,0x3d005011,0x7c40300,0xfce30000,0x3d00557f,0x4000000,
0x4e00000,0x3d00557f,0x4008000,0x4e00000,0x40000000,0x4000000,0x4200000,0x40000000,0x4000000,0xc8200005,0x40000000,0x6800000,0xc9329805,0x40000000,0x24000000,0x4200000,
0x40000002,0x7c00100,0x20230400,0x40000008,0x7c00100,0x20220400,0x40000008,0x7c00100,0x20250400,0x40000019,0x7c00100,0x20220400,0x40000019,0x7c00100,0x20250400,0x4000001c,
0x6800000,0x21329800,0x4000003e,0xc000010,0x44448000,0x40000047,0x7c00100,0x80230400,0x400000c9,0x4000002,0x84400000,0x400000c9,0x4000020,0x84200000,0x400000c9,0x6800000,
0x81329800,0x400000c9,0x7c00100,0x80220400,0x400000c9,0x7c00100,0x80230400,0x400000c9,0x7c00100,0x80250400,0x400000c9,0x7c00900,0x80230400,0x400000c9,0x7c00d00,0x80230400,
0x400000ca,0x6800000,0x82d29800,0x400000ca,0x6800100,0x80962540,0x400000ca,0x7c00100,0x82d30400,0x400000cb,0x4000000,0x84200000,0x400000cb,0x6800000,0x81329800,0x400000cb,
0x7c00100,0x80230400,0x400000cb,0x7c00100,0x80230520,0x400000cb,0x7c00100,0x80230521,0x400000cb,0x7c00500,0x80230400,0x400000cb,0xc000010,0x84448000,0x400000cc,0x4000000,
0x84200000,0x400000cc,0x6800000,0x81329800,0x400000cc,0x7c00100,0x80230400,0x400000cd,0x4000000,0x84200000,0x400000cd,0x6800000,0x81329800,0x400000cd,0x7c00100,0x80230400,
0x400000ce,0x7c00100,0x80230400,0x400000ce,0x7c00100,0x80230401,0x400000cf,0x4000000,0x84e00000,0x400000cf,0x6800100,0x80962540,0x400000cf,0x7c00100,0x80e30400,0x400000cf,
0x7c00100,0x82b30400,0x400000cf,0x7c00100,0x82c30560,0x400000cf,0x7c00100,0x82d30400,0x400000cf,0x7c00100,0x82d30401,0x400000cf,0x7c00d00,0x80e30400,0x400000cf,0xc000010,
0x84e48000,0x40005000,0x4000000,0x4e00000,0x400050bf,0x7c00300,0x80230000,0x4000559b,0x4000000,0x4e00000,0x40010002,0x2802100,0x20962460,0x400100c6,0x2802400,0x80962460,
0x400100c9,0x2802400,0x80962460,0x400100c9,0x2802500,0x80962460,0x400100c9,0x2802c00,0x80962460,0x400100ca,0x2802100,0x80962460,0x400100ca,0x2802100,0x80962461,0x400100ca,
0x2806400,0x80962460,0x400100cc,0x2802400,0x80962460,0x400100cc,0x2802c00,0x80962460,0x400100cf,0x2802100,0x80962460,0x400100cf,0x2802100,0x80962461,0x400100cf,0x2802400,
0x80962460,0x400100cf,0x2802c00,0x80962460,0x400100cf,0x2806400,0x80962460,0x400100cf,0x2806400,0x82f62460};

static const int32_t countPropsVectors=6426;
static const int32_t propsVectorsColumns=3;
static const uint16_t scriptExtensions[526]={
7,0xc,0xd,0xe,0x11,0x19,0x33,0x38,0x59,0x68,0x6c,0x75,0x87,0x88,0xa0,0x80b3,
4,8,0xa,0x19,0x26,0x83,0x80c4,5,0x8019,0x19,0x8083,0x19,0x8026,6,7,8,
0xe,0x19,0x34,0x59,0x80cd,6,8,0xe,0x19,0x34,0xab,0xcd,0x80ce,6,8,0x19,
0x803c,0x19,0x22,0x26,0x38,0x80cd,6,7,8,0xd,0xe,0x19,0x22,0x3c,0x9f,0xab,
0x80ce,7,0xd,0x16,0x19,0x38,0x8088,8,0xe,0x19,0x8059,7,0x13,0x19,0x22,0x34,
0x3c,0x59,0x87,0x80ce,3,8,0xd,0xe,0x13,0x19,0x22,0x34,0x59,0x8087,0x19,0x22,
0x8087,6,8,0x19,0x80ab,6,0x19,0x8034,0x19,0x80cd,0xb,0x8019,8,0x19,0x80ce,0xe,
0x19,0x59,0x80ce,0x19,0x8022,6,0x16,0x19,0x22,0x8087,6,0x19,0x22,0x8087,0x19,0x22,
0x80cd,6,0x19,0x8022,6,0xd,0x19,0x26,0x9f,0x80cd,0x800e,0x19,0x9f,0x80ce,7,0x800e,
0xe,0x8e,8,0x8059,8,0x92,8,0x8038,8,0x96,8,0x8019,3,0xc,0x8038,3,
0x9c,2,0x22,0x25,0x57,0xb6,0xc0,0x80c9,2,0x22,0x8025,2,0xa8,2,0x22,0x25,
0x57,0xa7,0xb6,0xc0,0x80c9,2,0x22,0x54,0x79,0x7b,0xa7,0xb6,0xb7,0x80c2,2,0x8022,
2,0x25,0x80c0,2,0xc0,2,0x80b6,2,0xc5,4,0xa,0xf,0x10,0x15,0x19,0x1a,
0x1f,0x23,0x24,0x89,0x97,0x809e,4,0xa,0xf,0x10,0x15,0x19,0x1a,0x1f,0x23,0x24,
0x89,0x809e,4,0xa,0xf,0x10,0x15,0x1a,0x1f,0x21,0x23,0x24,0x3a,0x89,0x91,0x99,
0x9e,0xa0,0xaf,0xb2,0xb3,0xbb,0x80cc,4,0xa,0xf,0x10,0x15,0x1a,0x1f,0x21,0x23,
0x24,0x30,0x3a,0x89,0x91,0x99,0x9e,0xa0,0xaf,0xb2,0xb3,0xbb,0xca,0x80cc,0xa,0x78,
0xa0,0x80b2,0xa,0x10e,4,0x3a,0x8076,4,0x114,0x10,0x80a4,0x10,0x119,0xf,0x809d,0xf,
0x11d,0x23,0x8089,0x23,0x121,0x15,0xbb,0x80cf,0x15,0x125,0x1c,0x34,0x8076,0x1c,0x12a,0xc,
0x19,0x8038,0x8020,0x2a,0x2b,0x2c,0x802d,0x1b,0x805a,0x800a,4,0xa,0x15,0x8089,4,0x800a,
0xa,0x8097,0xa,0x15,0x1a,0x1f,0x23,0x8024,0xa,0x80bb,4,0xa,0x15,0x1a,0x1f,0x21,
0x24,0x89,0x9e,0xbb,0x80cf,0xa,0x8089,0xa,0x15,0x89,0x80cf,0x8004,8,0x19,0x8022,0x19,
0x1b,0x805a,2,0x80a7,0xc,0x38,0x4c,0x58,0x68,0x806b,0xe,0x4c,0x56,0x8068,0xa,0x19,
0x8089,7,0x8019,0x58,0x8075,0xc,0x4c,0x68,0x6c,0x75,0x78,0x807e,2,0x4c,0x80a7,0x11,
0x809a,5,0x11,0x12,0x14,0x16,0x8029,5,0x11,0x12,0x14,0x16,0x1b,0x8029,5,0x11,
0x12,0x14,0x16,0x1b,0x29,0x805a,5,0x11,0x12,0x14,0x8016,0x8011,5,0x11,0x12,0x14,
0x16,0x1b,0x27,0x8029,5,0x11,0x12,0x14,0x16,0x1b,0x27,0x29,0x8083,5,0x8011,0x11,
0x14,0x8016,0x11,0x8019,0xa,0xf,0x10,0x15,0x1a,0x78,0x91,0x97,0x99,0x9d,0x9e,0xa0,
0xa3,0xb2,0xbb,0x80cf,0xa,0xf,0x10,0x15,0x78,0x91,0x97,0x99,0x9d,0x9e,0xa0,0xa3,
0xb2,0xbb,0x80cf,0xa,0xf,0x10,0x78,0x91,0x99,0x9d,0x9e,0xa0,0xa3,0x80b2,0xa,0xf,
0x10,0x78,0x91,0x97,0x99,0x9d,0x9e,0xa0,0xa3,0x80b2,4,0xa,0x80cf,0xa,0x1ea,0xa,
0x8023,0xa,0x1ef,0x19,0x1c,0x804f,0x37,0x804e,2,0x8057,2,0x8025,2,0x1fa,0x2f,0x31,
0x8053,0x2f,0x31,0x80c1,0x2f,0x8031,2,0x8007,0x79,0x80c2,0x79,0x208,0x89,0x121};

static const uint16_t block_trieIndex[817]={
0,0x40,0x80,0xc0,0x100,0x140,0x180,0x1c0,0x200,0x240,0x280,0x2c0,0x300,0x340,0x340,0x340,
0x340,0x340,0x340,0x364,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,
0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x384,0x3c4,0x3fb,0x43b,0x47b,0x47b,0x47b,0x47b,0x47b,
0x47b,0x47b,0x47b,0x47b,0x47b,0x480,0x4c0,0x500,0x540,0x540,0x540,0x540,0x540,0x540,0x570,0x5a5,
0x2df,0x2f9,0x2f9,0x309,0x329,0,0x10,0x20,0x30,0x40,0x50,0x60,0x70,0x80,0x90,0xa0,
0xb0,0xc0,0xd0,0xe0,0xf0,0x100,0x110,0x120,0x130,0x140,0x150,0x160,0x170,0x180,0x190,0x1a0,
0x1b0,0x1c0,0x1d0,0x1e0,0x1f0,0x200,0x210,0x220,0x230,0x240,0x250,0x260,0x270,0x280,0x290,0x2a0,
0x2b0,0x2c0,0x2d0,0x2e0,0x2f0,0x300,0x310,0x320,0x330,0x340,0x350,0x360,0x370,0x340,0x350,0x360,
0x370,0x340,0x350,0x360,0x370,0x364,0x374,0x384,0x394,0x384,0x394,0x3a4,0x3b4,0x384,0x394,0x3a4,
0x3b4,0x384,0x394,0x3a4,0x3b4,0x384,0x394,0x3a4,0x3b4,0x384,0x394,0x3a4,0x3b4,0x384,0x394,0x3a4,
0x3b4,0x384,0x394,0x3a4,0x3b4,0x384,0x394,0x3a4,0x3b4,0x3c4,0x3d4,0x3e4,0x3f4,0x3fb,0x40b,0x41b,
0x42b,0x43b,0x44b,0x45b,0x46b,0x47b,0x48b,0x49b,0x4ab,0x47b,0x48b,0x49b,0x4ab,0x47b,0x48b,0x49b,
0x4ab,0x47b,0x48b,0x49b,0x4ab,0x47b,0x48b,0x49b,0x4ab,0x480,0x490,0x4a0,0x4b0,0x4c0,0x4d0,0x4e0,
0x4f0,0x500,0x510,0x520,0x530,0x540,0x550,0x560,0x570,0x540,0x550,0x560,0x570,0x540,0x550,0x560,
0x570,0x540,0x550,0x560,0x570,0x540,0x550,0x560,0x570,0x540,0x550,0x560,0x570,0x570,0x580,0x590,
0x5a0,0x5a5,0x5b5,0x5c5,0x5d5,0x5e5,0x5f5,0x605,0x615,0x625,0x635,0x645,0x64d,0x65d,0x66d,0x67d,
0x68d,0x69d,0x6ad,0x6b7,0x6c7,0x6d7,0x6e7,0x6f7,0x707,0x717,0x725,0x735,0x745,0x755,0x765,0x775,
0x785,0x795,0x7a5,0x7b0,0x7c0,0x7d0,0x7d0,0x7d0,0x7d0,0x7e0,0x7eb,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,
0x7f0,0x7f0,0x7f0,0x7f0,0x7f7,0x807,0x807,0x807,0x807,0x814,0x81a,0x81a,0x81a,0x81a,0x81a,0x81a,
0x81a,0x81a,0x81a,0x81a,0x81a,0x82a,0x82a,0x832,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,
0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,
0x7f0,0x842,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x852,0x852,0x85e,0x86e,0x7f0,0x87a,0x886,0x896,
0x8a6,0x8a6,0x8a6,0x8a6,0x8a6,0x8a6,0x8a6,0x8a6,0x8a6,0x8a6,0x8a6,0x8a6,0x8a6,0x8a6,0x8a6,0x8a6,
0x8b6,0x8b6,0x8b6,0x8c6,0x8c6,0x8d6,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,
0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x8de,0x8ee,0x8fe,0x905,0x7f0,0x7f0,0x7f0,0x7f0,
0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x915,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,
0x7f0,0x7f0,0x925,0x925,0x929,0x939,0x949,0x959,0x969,0x979,0x989,0x989,0x989,0x989,0x999,0x999,
0x99e,0x7f0,0x7f0,0x7f0,0x7f0,0x9ae,0x9be,0x9ce,0x9d5,0x7f0,0x9e5,0x9f5,0x7f0,0xa05,0xa15,0xa25,
0x7f0,0x7f0,0xa2e,0xa3e,0xa4e,0x7f0,0xa5e,0xa6e,0xa7e,0xa8e,0xa8e,0xa8e,0xa9e,0xaae,0xabe,0xace,
0xade,0xaee,0x7f0,0x7f0,0x7f0,0x7f0,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,
0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,
0xafe,0xafe,0xafe,0xafe,0xafe,0xafe,0xb00,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,
0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb10,0xb1c,0xb2a,0xb2c,0xb2c,0xb2c,0xb2c,0xb2c,0xb2c,0xb2c,
0xb2c,0xb2c,0xb2c,0xb2c,0xb2c,0xb2c,0xb2c,0xb31,0xb3c,0xb3c,0xb3c,0xb3c,0xb3c,0xb3c,0xb3c,0xb3c,
0xb3c,0xb3c,0xb3c,0xb3c,0xb3c,0xb3c,0xb3c,0xb3c,0xb3c,0xb3d,0xb4c,0xb4c,0xb56,0x7f0,0x7f0,0x7f0,
0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0xb66,0xb66,0xb74,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0xb84,0xb84,
0xb84,0xb84,0xb84,0xb84,0xb84,0xb84,0xb84,0xb84,0xb84,0xb84,0xb84,0xb84,0xb84,0xb84,0xb84,0xb84,
0xb84,0xb8f,0xb94,0xb94,0xb94,0xb94,0xb94,0xb94,0xb94,0xb94,0xb94,0xb94,0xb94,0xb94,0xb99,0x7f0,
0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,
0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0xba9,
0xbb9,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,
0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0x7f0,0xbc9,
0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,
0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbc9,0xbd9,
0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,
0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0xbd9,0x45,
0x65,0x79,0x89,0x89,0xa9,0xb5,0xd5,0xf5,0x115,0x131,0x150,0x168,0x179,0x196,0x1b6,0x1d6,
0x1d6,0x1d6,0x1d6,0x1d6,0x1f0,0x209,0x21e,0x23e,0x25b,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,
0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,
0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,0x27f,0x25f,0x25f,0x25f,0x25f,0x25f,0x25f,
0x25f,0x29f,0x29f,0x29f,0x29f,0x29f,0x29f,0x29f,0x29f,0x2bf,0x2bf,0x2bf,0x2bf,0x2bf,0x2bf,0x2bf,
0x2bf
};

static const uint16_t block_trieData[3051]={
1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,
3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,
4,4,4,4,4,5,5,5,5,5,5,6,6,6,6,6,
7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,
9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
0x61,0x61,0x61,0xa,0xa,0xa,0xa,0xa,0xa,0xb,0xb,0xb,0xb,0xb,0xb,0xb,
0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,
0xd,0xd,0xd,0xd,0xd,0x80,0x80,0x80,0xe,0xe,0xe,0xe,0x92,0x92,0x92,0x92,
0xac,0xac,0xac,0xac,0xc6,0xc6,0x117,0x135,0x135,0x135,0xd2,0xd2,0xd2,0xd2,0xd2,0xd2,
0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,
0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,
0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,
0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,
0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,
0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x86,0x86,0x20,0x20,0x20,0x20,0x20,0x20,
0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,
0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x22,0x22,0x23,0x23,0x23,0x23,0x23,0x23,
0x62,0x62,0x63,0x63,0x64,0x64,0x65,0x65,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,
0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0xad,0xad,0xad,0xad,0xad,
0x6f,0x6f,0x6f,0x6f,0x6f,0x70,0x70,0x70,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x71,0x71,
0x81,0x81,0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xe0,0xe0,0xe0,0xe0,0xe0,
0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x9b,0x9b,0x9b,0x9b,0xc7,0xc7,0xc7,0xc7,
0x9c,0x9c,0x9c,0x9c,0x9c,0x9d,0x9d,0x9d,0x109,0x11b,0x11b,0x11b,0xdb,0xaf,0xaf,0xaf,
0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x8d,0x8d,0x8d,0x8d,0x83,0x83,0x83,0x83,
0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,
0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,
0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x29,0x29,0x29,0x2a,0x2a,0x2a,0x2b,0x2b,0x2b,
0x2c,0x2c,0x2c,0x2c,0x2c,0x2d,0x2d,0x2d,0x2d,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,
0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,
0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
0x31,0x31,0x31,0x31,0x32,0x32,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x35,0x35,0x36,0x36,0x36,0x36,0x36,0x36,
0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x66,0x66,0x66,0x67,
0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,
0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,
0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,
0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,
0x88,0x88,0x88,0x88,0x88,0x88,0x94,0x94,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
0x87,0x87,0x87,0x90,0x90,0x90,0x90,0x90,0x85,0x85,0x85,0x85,0x85,0x85,0x9e,0x9e,
0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,
0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0,0x3c,
0x3d,0x3d,0x3d,0x3d,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
0x40,0x40,0x40,0x41,0x41,0x41,0x41,0x41,0x41,0x42,0x43,0x43,0x82,0x82,0x82,0x6b,
0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
0x74,0x74,0x74,0x74,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,
0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,
0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,
0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,
0x47,0x47,0x47,0x47,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,
0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,
0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,
0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48,
0x48,0x48,0x48,0x48,0x49,0x49,0x49,0x49,0xb0,0xb0,0xb0,0x9f,0x9f,0x9f,0x9f,0x9f,
0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0xa0,
0xa0,0xa0,0xa0,0xa0,0xa0,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0x8a,0x8a,0x95,0x95,0x95,
0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x8f,0x8f,0x8f,0xb2,0x96,
0x96,0x96,0x96,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xb3,0xb3,0xa2,0xa2,0xa2,0xa3,0xa3,
0xa3,0xb4,0xb4,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xee,0xee,0xa4,0xa4,0xa4,0xa4,0xa4,
0xa4,0xb6,0xb6,0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,0xd5,0xd5,0xc8,0xc8,0xc8,0xe7,0xe7,
0xe7,0xe7,0xff,0xff,0xff,0xff,0xff,0xb8,0xb8,0xb8,0xb8,0x4a,0x4a,0x4a,0x4a,0x4a,
0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,
0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,
0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,
0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0xb9,0xb9,0xb9,0xb9,0xb9,
0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,
0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,
0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,
0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x4c,0x4c,0x4c,0x4c,0x4c,
0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,
0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,
0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,
0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,
0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,
0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,
0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,
0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,
0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,
0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,
0x50,0x50,0x50,0x50,0x50,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,
0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,
0x51,0x51,0x51,0x51,0x51,0x6c,0x91,0x52,0x53,0x53,0x54,0x54,0x55,0x55,0x55,0x55,
0x55,0x55,0x55,0x55,0x55,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,
0x57,0x57,0x57,0x57,0x56,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x76,0x76,0x76,
0x76,0x76,0x76,0x76,0x76,0x77,0x77,0x77,0x77,0x7f,0x7f,0x7f,0x7f,0x7f,0xa5,0xa5,
0xa5,0xa5,0xa6,0xa6,0xa6,0,0,0,0,0,0,0,0,0xa7,0xa7,0xa8,
0xa8,0xa8,0xa8,0xdf,0xdf,0x58,0x58,0x58,0x59,0x59,0xf1,0xf1,0xf1,0x78,0x78,0x8c,
0x8c,0x8c,0x8c,0,0,0x5a,0x5a,0x5a,0x5a,0x5a,0x79,0x79,0x79,0x7a,0x7a,0x7a,
0x10f,0x10f,0x10f,0x10f,0x10f,0xe2,0xe2,0xe2,0xde,0xde,0xde,0xde,0x13f,0x13f,0x13f,0x13f,
0x13f,0x151,0x151,0x151,0x151,0xe8,0xe8,0xe8,0xe8,0xe8,0xe8,0xe8,0xe8,0xe8,0xe8,0xe8,
0xe8,0xe8,0xe8,0xe8,0xe8,0x139,0x139,0x139,0x139,0,0,0,0,0x7b,0x7b,0x7b,
0x7b,0xba,0xba,0xf4,0xf4,0xef,0xef,0xef,0,0,0,0x102,0x102,0x97,0x97,0xa9,
0xa9,0,0,0,0,0xd7,0xd7,0xd6,0xd6,0xd6,0xd6,0xd6,0xd6,0x89,0x89,0x89,
0x89,0x89,0x89,0xbb,0xbb,0xf0,0xf0,0,0,0xea,0xea,0xea,0xea,0xbc,0xbc,0xbc,
0xbc,0xbd,0xbd,0xbe,0xbe,0xf6,0xf6,0xf6,0,0,0,0,0,0xbf,0xbf,0xbf,
0xbf,0xbf,0,0,0,0x104,0x104,0x104,0x104,0x104,0x104,0x104,0x104,0x11d,0x11d,0x11d,
0x11d,0x14a,0x14a,0x14a,0x14a,0x14a,0,0,0,0,0,0,0,0xc0,0xc0,0x134,
0x134,0x134,0x134,0x141,0x141,0x141,0x141,0x122,0x122,0x122,0x123,0x123,0x123,0x123,0x13b,0x13b,
0x13b,0x13b,0x12d,0x12d,0x12d,0x125,0x125,0xc9,0xc9,0xc9,0xc9,0xc9,0xc9,0xc9,0xc9,0xc1,
0xc1,0xc1,0xc1,0xc1,0xda,0xda,0xda,0xd4,0xd4,0xd4,0xd4,0xd4,0xe9,0xe9,0xe9,0xd9,
0xd9,0xd9,0xd9,0xd9,0xd9,0xf9,0xf9,0xe5,0xe5,0xe5,0xe5,0xe5,0,0,0,0x103,
0x103,0x103,0xe6,0xe6,0xe6,0xe6,0xe6,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0x152,
0x152,0x152,0x152,0x152,0x152,0x152,0x152,0x10e,0x10e,0x10e,0x10e,0x10e,0x10e,0x10e,0x10e,0xfb,
0xfb,0xfb,0xfb,0xfb,0xfb,0,0,0,0,0,0,0,0,0xf8,0xf8,0xf8,
0xf8,0xf8,0xf8,0xf8,0xf8,0xec,0xec,0xec,0xec,0xec,0xec,0x10d,0x10d,0xdc,0xdc,0xdc,
0xdc,0xdc,0x14d,0x14d,0x14d,0xfd,0xfd,0xfd,0xfd,0xfd,0,0,0,0,0,0,
0,0,0,0,0,0x11a,0x11a,0x11a,0x11a,0x11a,0,0,0,0,0,0xfc,
0xfc,0xfc,0xfc,0xfc,0xfc,0x12f,0x12f,0x12f,0x12f,0x12f,0x12f,0,0,0,0,0x126,
0x126,0x126,0x126,0x126,0x126,0x118,0x118,0x118,0x118,0x118,0x116,0x116,0x116,0x116,0x116,0x116,
0x13e,0xf5,0xf5,0xf5,0xf5,0x144,0x144,0x144,0x144,0x144,0x144,0,0,0,0,0,
0,0x14f,0x14f,0x14f,0x14f,0x108,0x108,0x108,0x108,0x108,0x108,0x108,0x10c,0x10c,0x10c,0x10c,
0x10c,0,0,0,0,0x114,0x114,0x114,0x114,0x114,0x114,0x11c,0x11c,0x11c,0x11c,0x11c,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x11f,0x11f,
0x146,0x146,0x146,0x146,0x146,0x146,0,0,0,0,0,0x131,0x12b,0x12b,0x12b,0x12b,
0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98,
0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x101,0x101,0x101,0x101,0x101,0x101,0x101,0x101,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0x136,0x136,0x136,0x136,0x136,0x136,0x136,0xc2,0xc2,0xc2,0xc2,0xc2,0xc2,0xc2,0xc2,0xc2,
0xc2,0xc2,0xc2,0xc2,0xc2,0xc2,0xc2,0x124,0x124,0x124,0x149,0x149,0x149,0x149,0x149,0x149,
0x149,0x149,0x149,0x149,0x149,0x149,0x149,0x149,0x149,0x149,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,
0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0,0,0,0,0,0,
0,0,0x14b,0x14b,0x14b,0x14b,0,0,0,0,0,0,0,0,0,0,
0,0,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,
0xca,0xca,0xed,0xed,0xed,0x13c,0x13c,0x13c,0x13c,0x13c,0x13c,0xdd,0xdd,0xdd,0xf3,0xf3,
0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,0,0,0,0,0,0,0,0x14c,0x14c,
0x14c,0x14c,0,0,0,0,0,0,0,0,0x121,0x121,0x121,0x121,0x121,0x121,
0,0,0,0,0,0,0xd8,0xd8,0xd8,0xd8,0xd8,0xd8,0xd8,0xd8,0xd8,0xd8,
0,0,0,0,0x10b,0x10b,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,
0x110,0x110,0x110,0x110,0x110,0x110,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,0x111,
0x111,0x111,0x111,0x111,0x111,0x111,0x130,0x130,0x130,0x130,0x130,0x130,0x130,0x130,0x130,0x130,
0x130,0x130,0x130,0x130,0x130,0x130,0x133,0x133,0x133,0x133,0x133,0x133,0x133,0x133,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0x138,0xcb,0xcb,
0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0x113,0x113,
0x113,0x129,0x129,0x129,0x129,0x115,0x115,0x115,0x115,0x115,0x115,0x115,0x115,0x115,0x115,0x115,
0x115,0x115,0x115,0x115,0x115,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xf7,
0,0,0,0,0,0x150,0x150,0x150,0x150,0x150,0x150,0x150,0x150,0x150,0x150,0x150,
0x150,0x150,0x150,0x150,0x150,0,0,0,0,0x140,0x140,0x140,0x140,0x140,0x140,0x140,
0x140,0x140,0x140,0x140,0x140,0x140,0,0,0,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x7e,0x7e,0x7e,0x7e,0x7e,0,0,
0,0,0,0,0,0x145,0x145,0x120,0x120,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x9a,
0x9a,0,0,0,0,0,0,0,0,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,
0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x106,0x106,0x106,0x106,0x106,0x106,0x106,
0x106,0x106,0x106,0x106,0x106,0x106,0x106,0x106,0x106,0,0,0,0,0,0x13a,0x13a,
0x13a,0x13a,0x13a,0x13a,0x13a,0x13a,0x13a,0x13a,0x13a,0x13a,0x13a,0x13a,0x13a,0x13a,0x10a,0x10a,
0x10a,0x143,0x143,0x143,0x143,0x143,0x143,0,0,0,0,0,0,0,0x127,0x127,
0x127,0x127,0x127,0,0,0,0,0,0,0,0,0,0,0,0x13d,0x13d,
0x13d,0x12c,0x12c,0x12c,0x12c,0,0,0,0,0,0,0,0,0,0,0,
0,0,0x147,0x147,0x147,0,0,0,0,0,0,0,0,0,0,0,
0,0,0x14e,0x14e,0x14e,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0x137,0x137,0xeb,0xeb,0xeb,0xeb,0xeb,0xeb,0xeb,0xeb,0xeb,0xeb,0xeb,
0xeb,0xeb,0xeb,0,0,0x107,0x107,0x107,0x107,0x107,0x107,0,0,0,0,0,
0,0,0,0,0,0x11e,0x11e,0x11e,0x11e,0x11e,0,0,0,0,0x128,0x128,
0x128,0x128,0x128,0,0,0,0,0,0,0,0,0,0,0,0xd3,0xd3,
0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xaa,0xaa,
0xaa,0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xc3,0xc3,
0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc4,0xc4,
0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xcd,0xcd,
0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xce,0xce,
0xce,0xce,0xce,0xf2,0xf2,0xf2,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xd0,0xd0,
0xd0,0xd0,0xd0,0xd0,0xd0,0xd0,0xe3,0xe3,0xe3,0xe3,0xe3,0xe3,0xe3,0xe3,0xfa,0xfa,
0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0x105,0x105,
0x105,0x105,0x105,0x105,0x105,0x105,0x105,0x105,0x105,0x105,0x105,0x105,0x105,0x105,0x119,0x119,
0x119,0x119,0x119,0x119,0x119,0x12a,0x12a,0x12a,0x12a,0x12a,0x12a,0x12a,0x12a,0x12a,0x132,0x132,
0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x132,0x5e,0x5e,
0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0,0,
0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,
0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0x100,0x100,0x100,0x100,
0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x112,0x112,0x112,0x112,
0x112,0x112,0x112,0x112,0x112,0x112,0x112,0x112,0x112,0x112,0x112,0x112,0x148,0x148,0x148,0x148,
0x148,0x148,0x148,0x148,0x148,0x148,0x148,0x148,0x148,0x148,0x148,0x148,0,0,0,0,
0,0,0,0,0,0,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,
0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0x12e,0x12e,0x12e,0x12e,0x12e,0x12e,0x12e,0x12e,0x12e,0x12e,0x12e,0x12e,
0x12e,0x12e,0x12e,0x12e,0x142,0x142,0x142,0x142,0x142,0x142,0x142,0x142,0x142,0x142,0x142,0x142,
0x142,0x142,0x142,0x142,0,0,0,0,0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,
0x60,0,0,0,0,0,0,0,0,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,
0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0,0x6d,0x6d,0x6d,0x6d,0x6d,0x6d,0x6d,
0x6d,0x6d,0x6d,0x6d,0x6d,0x6d,0x6d,0x6d,0x6d,0x6e,0x6e,0x6e,0x6e,0x6e,0x6e,0x6e,
0x6e,0x6e,0x6e,0x6e,0x6e,0x6e,0x6e,0x6e,0x6e,0,0
};

static const UCPTrie block_trie={
    block_trieIndex,
    { block_trieData },
    817, 3051,
    0x11000, 0x11,
    1, 0,
    0, 0,
    0x25f, 0x7f0,
    0x0,
};

static const int32_t indexes[UPROPS_INDEX_COUNT]={0x2e8e,0x2e8e,0x2e8e,0x2e8e,0x6db4,3,0x86ce,0x87d5,0x8f67,0x8f67,0x50cf,0x2f75a31,0x152,0,0,0};

#endif  // INCLUDED_FROM_UCHAR_C
                                                                                                                                                                                                                                                                node-23.7.0/deps/icu-small/source/common/ucharstrie.cpp                                             0000664 0000000 0000000 00000031000 14746647661 0023035 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
*******************************************************************************
*   Copyright (C) 2010-2011, International Business Machines
*   Corporation and others.  All Rights Reserved.
*******************************************************************************
*   file name:  ucharstrie.h
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2010nov14
*   created by: Markus W. Scherer
*/

#include "unicode/utypes.h"
#include "unicode/appendable.h"
#include "unicode/ucharstrie.h"
#include "unicode/uobject.h"
#include "unicode/utf16.h"
#include "cmemory.h"
#include "uassert.h"

U_NAMESPACE_BEGIN

UCharsTrie::~UCharsTrie() {
    uprv_free(ownedArray_);
}

UStringTrieResult
UCharsTrie::current() const {
    const char16_t *pos=pos_;
    if(pos==nullptr) {
        return USTRINGTRIE_NO_MATCH;
    } else {
        int32_t node;
        return (remainingMatchLength_<0 && (node=*pos)>=kMinValueLead) ?
                valueResult(node) : USTRINGTRIE_NO_VALUE;
    }
}

UStringTrieResult
UCharsTrie::firstForCodePoint(UChar32 cp) {
    return cp<=0xffff ?
        first(cp) :
        (USTRINGTRIE_HAS_NEXT(first(U16_LEAD(cp))) ?
            next(U16_TRAIL(cp)) :
            USTRINGTRIE_NO_MATCH);
}

UStringTrieResult
UCharsTrie::nextForCodePoint(UChar32 cp) {
    return cp<=0xffff ?
        next(cp) :
        (USTRINGTRIE_HAS_NEXT(next(U16_LEAD(cp))) ?
            next(U16_TRAIL(cp)) :
            USTRINGTRIE_NO_MATCH);
}

UStringTrieResult
UCharsTrie::branchNext(const char16_t *pos, int32_t length, int32_t uchar) {
    // Branch according to the current unit.
    if(length==0) {
        length=*pos++;
    }
    ++length;
    // The length of the branch is the number of units to select from.
    // The data structure encodes a binary search.
    while(length>kMaxBranchLinearSubNodeLength) {
        if(uchar<*pos++) {
            length>>=1;
            pos=jumpByDelta(pos);
        } else {
            length=length-(length>>1);
            pos=skipDelta(pos);
        }
    }
    // Drop down to linear search for the last few units.
    // length>=2 because the loop body above sees length>kMaxBranchLinearSubNodeLength>=3
    // and divides length by 2.
    do {
        if(uchar==*pos++) {
            UStringTrieResult result;
            int32_t node=*pos;
            if(node&kValueIsFinal) {
                // Leave the final value for getValue() to read.
                result=USTRINGTRIE_FINAL_VALUE;
            } else {
                // Use the non-final value as the jump delta.
                ++pos;
                // int32_t delta=readValue(pos, node);
                int32_t delta;
                if(node<kMinTwoUnitValueLead) {
                    delta=node;
                } else if(node<kThreeUnitValueLead) {
                    delta=((node-kMinTwoUnitValueLead)<<16)|*pos++;
                } else {
                    delta=(pos[0]<<16)|pos[1];
                    pos+=2;
                }
                // end readValue()
                pos+=delta;
                node=*pos;
                result= node>=kMinValueLead ? valueResult(node) : USTRINGTRIE_NO_VALUE;
            }
            pos_=pos;
            return result;
        }
        --length;
        pos=skipValue(pos);
    } while(length>1);
    if(uchar==*pos++) {
        pos_=pos;
        int32_t node=*pos;
        return node>=kMinValueLead ? valueResult(node) : USTRINGTRIE_NO_VALUE;
    } else {
        stop();
        return USTRINGTRIE_NO_MATCH;
    }
}

UStringTrieResult
UCharsTrie::nextImpl(const char16_t *pos, int32_t uchar) {
    int32_t node=*pos++;
    for(;;) {
        if(node<kMinLinearMatch) {
            return branchNext(pos, node, uchar);
        } else if(node<kMinValueLead) {
            // Match the first of length+1 units.
            int32_t length=node-kMinLinearMatch;  // Actual match length minus 1.
            if(uchar==*pos++) {
                remainingMatchLength_=--length;
                pos_=pos;
                return (length<0 && (node=*pos)>=kMinValueLead) ?
                        valueResult(node) : USTRINGTRIE_NO_VALUE;
            } else {
                // No match.
                break;
            }
        } else if(node&kValueIsFinal) {
            // No further matching units.
            break;
        } else {
            // Skip intermediate value.
            pos=skipNodeValue(pos, node);
            node&=kNodeTypeMask;
        }
    }
    stop();
    return USTRINGTRIE_NO_MATCH;
}

UStringTrieResult
UCharsTrie::next(int32_t uchar) {
    const char16_t *pos=pos_;
    if(pos==nullptr) {
        return USTRINGTRIE_NO_MATCH;
    }
    int32_t length=remainingMatchLength_;  // Actual remaining match length minus 1.
    if(length>=0) {
        // Remaining part of a linear-match node.
        if(uchar==*pos++) {
            remainingMatchLength_=--length;
            pos_=pos;
            int32_t node;
            return (length<0 && (node=*pos)>=kMinValueLead) ?
                    valueResult(node) : USTRINGTRIE_NO_VALUE;
        } else {
            stop();
            return USTRINGTRIE_NO_MATCH;
        }
    }
    return nextImpl(pos, uchar);
}

UStringTrieResult
UCharsTrie::next(ConstChar16Ptr ptr, int32_t sLength) {
    const char16_t *s=ptr;
    if(sLength<0 ? *s==0 : sLength==0) {
        // Empty input.
        return current();
    }
    const char16_t *pos=pos_;
    if(pos==nullptr) {
        return USTRINGTRIE_NO_MATCH;
    }
    int32_t length=remainingMatchLength_;  // Actual remaining match length minus 1.
    for(;;) {
        // Fetch the next input unit, if there is one.
        // Continue a linear-match node without rechecking sLength<0.
        int32_t uchar;
        if(sLength<0) {
            for(;;) {
                if((uchar=*s++)==0) {
                    remainingMatchLength_=length;
                    pos_=pos;
                    int32_t node;
                    return (length<0 && (node=*pos)>=kMinValueLead) ?
                            valueResult(node) : USTRINGTRIE_NO_VALUE;
                }
                if(length<0) {
                    remainingMatchLength_=length;
                    break;
                }
                if(uchar!=*pos) {
                    stop();
                    return USTRINGTRIE_NO_MATCH;
                }
                ++pos;
                --length;
            }
        } else {
            for(;;) {
                if(sLength==0) {
                    remainingMatchLength_=length;
                    pos_=pos;
                    int32_t node;
                    return (length<0 && (node=*pos)>=kMinValueLead) ?
                            valueResult(node) : USTRINGTRIE_NO_VALUE;
                }
                uchar=*s++;
                --sLength;
                if(length<0) {
                    remainingMatchLength_=length;
                    break;
                }
                if(uchar!=*pos) {
                    stop();
                    return USTRINGTRIE_NO_MATCH;
                }
                ++pos;
                --length;
            }
        }
        int32_t node=*pos++;
        for(;;) {
            if(node<kMinLinearMatch) {
                UStringTrieResult result=branchNext(pos, node, uchar);
                if(result==USTRINGTRIE_NO_MATCH) {
                    return USTRINGTRIE_NO_MATCH;
                }
                // Fetch the next input unit, if there is one.
                if(sLength<0) {
                    if((uchar=*s++)==0) {
                        return result;
                    }
                } else {
                    if(sLength==0) {
                        return result;
                    }
                    uchar=*s++;
                    --sLength;
                }
                if(result==USTRINGTRIE_FINAL_VALUE) {
                    // No further matching units.
                    stop();
                    return USTRINGTRIE_NO_MATCH;
                }
                pos=pos_;  // branchNext() advanced pos and wrote it to pos_ .
                node=*pos++;
            } else if(node<kMinValueLead) {
                // Match length+1 units.
                length=node-kMinLinearMatch;  // Actual match length minus 1.
                if(uchar!=*pos) {
                    stop();
                    return USTRINGTRIE_NO_MATCH;
                }
                ++pos;
                --length;
                break;
            } else if(node&kValueIsFinal) {
                // No further matching units.
                stop();
                return USTRINGTRIE_NO_MATCH;
            } else {
                // Skip intermediate value.
                pos=skipNodeValue(pos, node);
                node&=kNodeTypeMask;
            }
        }
    }
}

const char16_t *
UCharsTrie::findUniqueValueFromBranch(const char16_t *pos, int32_t length,
                                      UBool haveUniqueValue, int32_t &uniqueValue) {
    while(length>kMaxBranchLinearSubNodeLength) {
        ++pos;  // ignore the comparison unit
        if(nullptr==findUniqueValueFromBranch(jumpByDelta(pos), length>>1, haveUniqueValue, uniqueValue)) {
            return nullptr;
        }
        length=length-(length>>1);
        pos=skipDelta(pos);
    }
    do {
        ++pos;  // ignore a comparison unit
        // handle its value
        int32_t node=*pos++;
        UBool isFinal = static_cast<UBool>(node >> 15);
        node&=0x7fff;
        int32_t value=readValue(pos, node);
        pos=skipValue(pos, node);
        if(isFinal) {
            if(haveUniqueValue) {
                if(value!=uniqueValue) {
                    return nullptr;
                }
            } else {
                uniqueValue=value;
                haveUniqueValue=true;
            }
        } else {
            if(!findUniqueValue(pos+value, haveUniqueValue, uniqueValue)) {
                return nullptr;
            }
            haveUniqueValue=true;
        }
    } while(--length>1);
    return pos+1;  // ignore the last comparison unit
}

UBool
UCharsTrie::findUniqueValue(const char16_t *pos, UBool haveUniqueValue, int32_t &uniqueValue) {
    int32_t node=*pos++;
    for(;;) {
        if(node<kMinLinearMatch) {
            if(node==0) {
                node=*pos++;
            }
            pos=findUniqueValueFromBranch(pos, node+1, haveUniqueValue, uniqueValue);
            if(pos==nullptr) {
                return false;
            }
            haveUniqueValue=true;
            node=*pos++;
        } else if(node<kMinValueLead) {
            // linear-match node
            pos+=node-kMinLinearMatch+1;  // Ignore the match units.
            node=*pos++;
        } else {
            UBool isFinal = static_cast<UBool>(node >> 15);
            int32_t value;
            if(isFinal) {
                value=readValue(pos, node&0x7fff);
            } else {
                value=readNodeValue(pos, node);
            }
            if(haveUniqueValue) {
                if(value!=uniqueValue) {
                    return false;
                }
            } else {
                uniqueValue=value;
                haveUniqueValue=true;
            }
            if(isFinal) {
                return true;
            }
            pos=skipNodeValue(pos, node);
            node&=kNodeTypeMask;
        }
    }
}

int32_t
UCharsTrie::getNextUChars(Appendable &out) const {
    const char16_t *pos=pos_;
    if(pos==nullptr) {
        return 0;
    }
    if(remainingMatchLength_>=0) {
        out.appendCodeUnit(*pos);  // Next unit of a pending linear-match node.
        return 1;
    }
    int32_t node=*pos++;
    if(node>=kMinValueLead) {
        if(node&kValueIsFinal) {
            return 0;
        } else {
            pos=skipNodeValue(pos, node);
            node&=kNodeTypeMask;
        }
    }
    if(node<kMinLinearMatch) {
        if(node==0) {
            node=*pos++;
        }
        out.reserveAppendCapacity(++node);
        getNextBranchUChars(pos, node, out);
        return node;
    } else {
        // First unit of the linear-match node.
        out.appendCodeUnit(*pos);
        return 1;
    }
}

void
UCharsTrie::getNextBranchUChars(const char16_t *pos, int32_t length, Appendable &out) {
    while(length>kMaxBranchLinearSubNodeLength) {
        ++pos;  // ignore the comparison unit
        getNextBranchUChars(jumpByDelta(pos), length>>1, out);
        length=length-(length>>1);
        pos=skipDelta(pos);
    }
    do {
        out.appendCodeUnit(*pos++);
        pos=skipValue(pos);
    } while(--length>1);
    out.appendCodeUnit(*pos);
}

U_NAMESPACE_END
node-23.7.0/deps/icu-small/source/common/ucharstriebuilder.cpp                                      0000664 0000000 0000000 00000033614 14746647661 0024421 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
*******************************************************************************
*   Copyright (C) 2010-2012, International Business Machines
*   Corporation and others.  All Rights Reserved.
*******************************************************************************
*   file name:  ucharstriebuilder.h
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2010nov14
*   created by: Markus W. Scherer
*/

#include "unicode/utypes.h"
#include "unicode/ucharstrie.h"
#include "unicode/ucharstriebuilder.h"
#include "unicode/unistr.h"
#include "unicode/ustring.h"
#include "cmemory.h"
#include "uarrsort.h"
#include "uassert.h"
#include "uhash.h"
#include "ustr_imp.h"

U_NAMESPACE_BEGIN

/*
 * Note: This builder implementation stores (string, value) pairs with full copies
 * of the 16-bit-unit sequences, until the UCharsTrie is built.
 * It might(!) take less memory if we collected the data in a temporary, dynamic trie.
 */

class UCharsTrieElement : public UMemory {
public:
    // Use compiler's default constructor, initializes nothing.

    void setTo(const UnicodeString &s, int32_t val, UnicodeString &strings, UErrorCode &errorCode);

    UnicodeString getString(const UnicodeString &strings) const {
        int32_t length=strings[stringOffset];
        return strings.tempSubString(stringOffset+1, length);
    }
    int32_t getStringLength(const UnicodeString &strings) const {
        return strings[stringOffset];
    }

    char16_t charAt(int32_t index, const UnicodeString &strings) const {
        return strings[stringOffset+1+index];
    }

    int32_t getValue() const { return value; }

    int32_t compareStringTo(const UCharsTrieElement &o, const UnicodeString &strings) const;

private:
    // The first strings unit contains the string length.
    // (Compared with a stringLength field here, this saves 2 bytes per string.)
    int32_t stringOffset;
    int32_t value;
};

void
UCharsTrieElement::setTo(const UnicodeString &s, int32_t val,
                         UnicodeString &strings, UErrorCode &errorCode) {
    if(U_FAILURE(errorCode)) {
        return;
    }
    int32_t length=s.length();
    if(length>0xffff) {
        // Too long: We store the length in 1 unit.
        errorCode=U_INDEX_OUTOFBOUNDS_ERROR;
        return;
    }
    stringOffset=strings.length();
    strings.append(static_cast<char16_t>(length));
    value=val;
    strings.append(s);
}

int32_t
UCharsTrieElement::compareStringTo(const UCharsTrieElement &other, const UnicodeString &strings) const {
    return getString(strings).compare(other.getString(strings));
}

UCharsTrieBuilder::UCharsTrieBuilder(UErrorCode & /*errorCode*/)
        : elements(nullptr), elementsCapacity(0), elementsLength(0),
          uchars(nullptr), ucharsCapacity(0), ucharsLength(0) {}

UCharsTrieBuilder::~UCharsTrieBuilder() {
    delete[] elements;
    uprv_free(uchars);
}

UCharsTrieBuilder &
UCharsTrieBuilder::add(const UnicodeString &s, int32_t value, UErrorCode &errorCode) {
    if(U_FAILURE(errorCode)) {
        return *this;
    }
    if(ucharsLength>0) {
        // Cannot add elements after building.
        errorCode=U_NO_WRITE_PERMISSION;
        return *this;
    }
    if(elementsLength==elementsCapacity) {
        int32_t newCapacity;
        if(elementsCapacity==0) {
            newCapacity=1024;
        } else {
            newCapacity=4*elementsCapacity;
        }
        UCharsTrieElement *newElements=new UCharsTrieElement[newCapacity];
        if(newElements==nullptr) {
            errorCode=U_MEMORY_ALLOCATION_ERROR;
            return *this;
        }
        if(elementsLength>0) {
            uprv_memcpy(newElements, elements, (size_t)elementsLength*sizeof(UCharsTrieElement));
        }
        delete[] elements;
        elements=newElements;
        elementsCapacity=newCapacity;
    }
    elements[elementsLength++].setTo(s, value, strings, errorCode);
    if(U_SUCCESS(errorCode) && strings.isBogus()) {
        errorCode=U_MEMORY_ALLOCATION_ERROR;
    }
    return *this;
}

U_CDECL_BEGIN

static int32_t U_CALLCONV
compareElementStrings(const void *context, const void *left, const void *right) {
    const UnicodeString *strings=static_cast<const UnicodeString *>(context);
    const UCharsTrieElement *leftElement=static_cast<const UCharsTrieElement *>(left);
    const UCharsTrieElement *rightElement=static_cast<const UCharsTrieElement *>(right);
    return leftElement->compareStringTo(*rightElement, *strings);
}

U_CDECL_END

UCharsTrie *
UCharsTrieBuilder::build(UStringTrieBuildOption buildOption, UErrorCode &errorCode) {
    buildUChars(buildOption, errorCode);
    UCharsTrie *newTrie=nullptr;
    if(U_SUCCESS(errorCode)) {
        newTrie=new UCharsTrie(uchars, uchars+(ucharsCapacity-ucharsLength));
        if(newTrie==nullptr) {
            errorCode=U_MEMORY_ALLOCATION_ERROR;
        } else {
            uchars=nullptr;  // The new trie now owns the array.
            ucharsCapacity=0;
        }
    }
    return newTrie;
}

UnicodeString &
UCharsTrieBuilder::buildUnicodeString(UStringTrieBuildOption buildOption, UnicodeString &result,
                                      UErrorCode &errorCode) {
    buildUChars(buildOption, errorCode);
    if(U_SUCCESS(errorCode)) {
        result.setTo(false, uchars+(ucharsCapacity-ucharsLength), ucharsLength);
    }
    return result;
}

void
UCharsTrieBuilder::buildUChars(UStringTrieBuildOption buildOption, UErrorCode &errorCode) {
    if(U_FAILURE(errorCode)) {
        return;
    }
    if(uchars!=nullptr && ucharsLength>0) {
        // Already built.
        return;
    }
    if(ucharsLength==0) {
        if(elementsLength==0) {
            errorCode=U_INDEX_OUTOFBOUNDS_ERROR;
            return;
        }
        if(strings.isBogus()) {
            errorCode=U_MEMORY_ALLOCATION_ERROR;
            return;
        }
        uprv_sortArray(elements, elementsLength, static_cast<int32_t>(sizeof(UCharsTrieElement)),
                      compareElementStrings, &strings,
                      false,  // need not be a stable sort
                      &errorCode);
        if(U_FAILURE(errorCode)) {
            return;
        }
        // Duplicate strings are not allowed.
        UnicodeString prev=elements[0].getString(strings);
        for(int32_t i=1; i<elementsLength; ++i) {
            UnicodeString current=elements[i].getString(strings);
            if(prev==current) {
                errorCode=U_ILLEGAL_ARGUMENT_ERROR;
                return;
            }
            prev.fastCopyFrom(current);
        }
    }
    // Create and char16_t-serialize the trie for the elements.
    ucharsLength=0;
    int32_t capacity=strings.length();
    if(capacity<1024) {
        capacity=1024;
    }
    if(ucharsCapacity<capacity) {
        uprv_free(uchars);
        uchars=static_cast<char16_t *>(uprv_malloc(capacity*2));
        if(uchars==nullptr) {
            errorCode=U_MEMORY_ALLOCATION_ERROR;
            ucharsCapacity=0;
            return;
        }
        ucharsCapacity=capacity;
    }
    StringTrieBuilder::build(buildOption, elementsLength, errorCode);
    if(uchars==nullptr) {
        errorCode=U_MEMORY_ALLOCATION_ERROR;
    }
}

int32_t
UCharsTrieBuilder::getElementStringLength(int32_t i) const {
    return elements[i].getStringLength(strings);
}

char16_t
UCharsTrieBuilder::getElementUnit(int32_t i, int32_t unitIndex) const {
    return elements[i].charAt(unitIndex, strings);
}

int32_t
UCharsTrieBuilder::getElementValue(int32_t i) const {
    return elements[i].getValue();
}

int32_t
UCharsTrieBuilder::getLimitOfLinearMatch(int32_t first, int32_t last, int32_t unitIndex) const {
    const UCharsTrieElement &firstElement=elements[first];
    const UCharsTrieElement &lastElement=elements[last];
    int32_t minStringLength=firstElement.getStringLength(strings);
    while(++unitIndex<minStringLength &&
            firstElement.charAt(unitIndex, strings)==
            lastElement.charAt(unitIndex, strings)) {}
    return unitIndex;
}

int32_t
UCharsTrieBuilder::countElementUnits(int32_t start, int32_t limit, int32_t unitIndex) const {
    int32_t length=0;  // Number of different units at unitIndex.
    int32_t i=start;
    do {
        char16_t unit=elements[i++].charAt(unitIndex, strings);
        while(i<limit && unit==elements[i].charAt(unitIndex, strings)) {
            ++i;
        }
        ++length;
    } while(i<limit);
    return length;
}

int32_t
UCharsTrieBuilder::skipElementsBySomeUnits(int32_t i, int32_t unitIndex, int32_t count) const {
    do {
        char16_t unit=elements[i++].charAt(unitIndex, strings);
        while(unit==elements[i].charAt(unitIndex, strings)) {
            ++i;
        }
    } while(--count>0);
    return i;
}

int32_t
UCharsTrieBuilder::indexOfElementWithNextUnit(int32_t i, int32_t unitIndex, char16_t unit) const {
    while(unit==elements[i].charAt(unitIndex, strings)) {
        ++i;
    }
    return i;
}

UCharsTrieBuilder::UCTLinearMatchNode::UCTLinearMatchNode(const char16_t *units, int32_t len, Node *nextNode)
        : LinearMatchNode(len, nextNode), s(units) {
    hash=hash*37u+ustr_hashUCharsN(units, len);
}

bool
UCharsTrieBuilder::UCTLinearMatchNode::operator==(const Node &other) const {
    if(this==&other) {
        return true;
    }
    if(!LinearMatchNode::operator==(other)) {
        return false;
    }
    const UCTLinearMatchNode &o=static_cast<const UCTLinearMatchNode &>(other);
    return 0==u_memcmp(s, o.s, length);
}

void
UCharsTrieBuilder::UCTLinearMatchNode::write(StringTrieBuilder &builder) {
    UCharsTrieBuilder &b=(UCharsTrieBuilder &)builder;
    next->write(builder);
    b.write(s, length);
    offset=b.writeValueAndType(hasValue, value, b.getMinLinearMatch()+length-1);
}

StringTrieBuilder::Node *
UCharsTrieBuilder::createLinearMatchNode(int32_t i, int32_t unitIndex, int32_t length,
                                         Node *nextNode) const {
    return new UCTLinearMatchNode(
            elements[i].getString(strings).getBuffer()+unitIndex,
            length,
            nextNode);
}

UBool
UCharsTrieBuilder::ensureCapacity(int32_t length) {
    if(uchars==nullptr) {
        return false;  // previous memory allocation had failed
    }
    if(length>ucharsCapacity) {
        int32_t newCapacity=ucharsCapacity;
        do {
            newCapacity*=2;
        } while(newCapacity<=length);
        char16_t *newUChars=static_cast<char16_t *>(uprv_malloc(newCapacity*2));
        if(newUChars==nullptr) {
            // unable to allocate memory
            uprv_free(uchars);
            uchars=nullptr;
            ucharsCapacity=0;
            return false;
        }
        u_memcpy(newUChars+(newCapacity-ucharsLength),
                 uchars+(ucharsCapacity-ucharsLength), ucharsLength);
        uprv_free(uchars);
        uchars=newUChars;
        ucharsCapacity=newCapacity;
    }
    return true;
}

int32_t
UCharsTrieBuilder::write(int32_t unit) {
    int32_t newLength=ucharsLength+1;
    if(ensureCapacity(newLength)) {
        ucharsLength=newLength;
        uchars[ucharsCapacity - ucharsLength] = static_cast<char16_t>(unit);
    }
    return ucharsLength;
}

int32_t
UCharsTrieBuilder::write(const char16_t *s, int32_t length) {
    int32_t newLength=ucharsLength+length;
    if(ensureCapacity(newLength)) {
        ucharsLength=newLength;
        u_memcpy(uchars+(ucharsCapacity-ucharsLength), s, length);
    }
    return ucharsLength;
}

int32_t
UCharsTrieBuilder::writeElementUnits(int32_t i, int32_t unitIndex, int32_t length) {
    return write(elements[i].getString(strings).getBuffer()+unitIndex, length);
}

int32_t
UCharsTrieBuilder::writeValueAndFinal(int32_t i, UBool isFinal) {
    if(0<=i && i<=UCharsTrie::kMaxOneUnitValue) {
        return write(i|(isFinal<<15));
    }
    char16_t intUnits[3];
    int32_t length;
    if(i<0 || i>UCharsTrie::kMaxTwoUnitValue) {
        intUnits[0] = static_cast<char16_t>(UCharsTrie::kThreeUnitValueLead);
        intUnits[1] = static_cast<char16_t>(static_cast<uint32_t>(i) >> 16);
        intUnits[2] = static_cast<char16_t>(i);
        length=3;
    // } else if(i<=UCharsTrie::kMaxOneUnitValue) {
    //     intUnits[0]=(char16_t)(i);
    //     length=1;
    } else {
        intUnits[0] = static_cast<char16_t>(UCharsTrie::kMinTwoUnitValueLead + (i >> 16));
        intUnits[1] = static_cast<char16_t>(i);
        length=2;
    }
    intUnits[0] = static_cast<char16_t>(intUnits[0] | (isFinal << 15));
    return write(intUnits, length);
}

int32_t
UCharsTrieBuilder::writeValueAndType(UBool hasValue, int32_t value, int32_t node) {
    if(!hasValue) {
        return write(node);
    }
    char16_t intUnits[3];
    int32_t length;
    if(value<0 || value>UCharsTrie::kMaxTwoUnitNodeValue) {
        intUnits[0] = static_cast<char16_t>(UCharsTrie::kThreeUnitNodeValueLead);
        intUnits[1] = static_cast<char16_t>(static_cast<uint32_t>(value) >> 16);
        intUnits[2] = static_cast<char16_t>(value);
        length=3;
    } else if(value<=UCharsTrie::kMaxOneUnitNodeValue) {
        intUnits[0] = static_cast<char16_t>((value + 1) << 6);
        length=1;
    } else {
        intUnits[0] = static_cast<char16_t>(UCharsTrie::kMinTwoUnitNodeValueLead + ((value >> 10) & 0x7fc0));
        intUnits[1] = static_cast<char16_t>(value);
        length=2;
    }
    intUnits[0] |= static_cast<char16_t>(node);
    return write(intUnits, length);
}

int32_t
UCharsTrieBuilder::writeDeltaTo(int32_t jumpTarget) {
    int32_t i=ucharsLength-jumpTarget;
    U_ASSERT(i>=0);
    if(i<=UCharsTrie::kMaxOneUnitDelta) {
        return write(i);
    }
    char16_t intUnits[3];
    int32_t length;
    if(i<=UCharsTrie::kMaxTwoUnitDelta) {
        intUnits[0] = static_cast<char16_t>(UCharsTrie::kMinTwoUnitDeltaLead + (i >> 16));
        length=1;
    } else {
        intUnits[0] = static_cast<char16_t>(UCharsTrie::kThreeUnitDeltaLead);
        intUnits[1] = static_cast<char16_t>(i >> 16);
        length=2;
    }
    intUnits[length++] = static_cast<char16_t>(i);
    return write(intUnits, length);
}

U_NAMESPACE_END
                                                                                                                    node-23.7.0/deps/icu-small/source/common/ucharstrieiterator.cpp                                     0000664 0000000 0000000 00000016446 14746647661 0024630 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
*******************************************************************************
*   Copyright (C) 2010-2011, International Business Machines
*   Corporation and others.  All Rights Reserved.
*******************************************************************************
*   file name:  ucharstrieiterator.h
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2010nov15
*   created by: Markus W. Scherer
*/

#include "unicode/utypes.h"
#include "unicode/ucharstrie.h"
#include "unicode/unistr.h"
#include "uvectr32.h"

U_NAMESPACE_BEGIN

UCharsTrie::Iterator::Iterator(ConstChar16Ptr trieUChars, int32_t maxStringLength,
                               UErrorCode &errorCode)
        : uchars_(trieUChars),
          pos_(uchars_), initialPos_(uchars_),
          remainingMatchLength_(-1), initialRemainingMatchLength_(-1),
          skipValue_(false),
          maxLength_(maxStringLength), value_(0), stack_(nullptr) {
    if(U_FAILURE(errorCode)) {
        return;
    }
    // stack_ is a pointer so that it's easy to turn ucharstrie.h into
    // a public API header for which we would want it to depend only on
    // other public headers.
    // Unlike UCharsTrie itself, its Iterator performs memory allocations anyway
    // via the UnicodeString and UVector32 implementations, so this additional
    // cost is minimal.
    stack_=new UVector32(errorCode);
    if(stack_==nullptr) {
        errorCode=U_MEMORY_ALLOCATION_ERROR;
    }
}

UCharsTrie::Iterator::Iterator(const UCharsTrie &trie, int32_t maxStringLength,
                               UErrorCode &errorCode)
        : uchars_(trie.uchars_), pos_(trie.pos_), initialPos_(trie.pos_),
          remainingMatchLength_(trie.remainingMatchLength_),
          initialRemainingMatchLength_(trie.remainingMatchLength_),
          skipValue_(false),
          maxLength_(maxStringLength), value_(0), stack_(nullptr) {
    if(U_FAILURE(errorCode)) {
        return;
    }
    stack_=new UVector32(errorCode);
    if(U_FAILURE(errorCode)) {
        return;
    }
    if(stack_==nullptr) {
        errorCode=U_MEMORY_ALLOCATION_ERROR;
        return;
    }
    int32_t length=remainingMatchLength_;  // Actual remaining match length minus 1.
    if(length>=0) {
        // Pending linear-match node, append remaining UChars to str_.
        ++length;
        if(maxLength_>0 && length>maxLength_) {
            length=maxLength_;  // This will leave remainingMatchLength>=0 as a signal.
        }
        str_.append(pos_, length);
        pos_+=length;
        remainingMatchLength_-=length;
    }
}

UCharsTrie::Iterator::~Iterator() {
    delete stack_;
}

UCharsTrie::Iterator &
UCharsTrie::Iterator::reset() {
    pos_=initialPos_;
    remainingMatchLength_=initialRemainingMatchLength_;
    skipValue_=false;
    int32_t length=remainingMatchLength_+1;  // Remaining match length.
    if(maxLength_>0 && length>maxLength_) {
        length=maxLength_;
    }
    str_.truncate(length);
    pos_+=length;
    remainingMatchLength_-=length;
    stack_->setSize(0);
    return *this;
}

UBool
UCharsTrie::Iterator::hasNext() const { return pos_!=nullptr || !stack_->isEmpty(); }

UBool
UCharsTrie::Iterator::next(UErrorCode &errorCode) {
    if(U_FAILURE(errorCode)) {
        return false;
    }
    const char16_t *pos=pos_;
    if(pos==nullptr) {
        if(stack_->isEmpty()) {
            return false;
        }
        // Pop the state off the stack and continue with the next outbound edge of
        // the branch node.
        int32_t stackSize=stack_->size();
        int32_t length=stack_->elementAti(stackSize-1);
        pos=uchars_+stack_->elementAti(stackSize-2);
        stack_->setSize(stackSize-2);
        str_.truncate(length&0xffff);
        length = static_cast<int32_t>(static_cast<uint32_t>(length) >> 16);
        if(length>1) {
            pos=branchNext(pos, length, errorCode);
            if(pos==nullptr) {
                return true;  // Reached a final value.
            }
        } else {
            str_.append(*pos++);
        }
    }
    if(remainingMatchLength_>=0) {
        // We only get here if we started in a pending linear-match node
        // with more than maxLength remaining units.
        return truncateAndStop();
    }
    for(;;) {
        int32_t node=*pos++;
        if(node>=kMinValueLead) {
            if(skipValue_) {
                pos=skipNodeValue(pos, node);
                node&=kNodeTypeMask;
                skipValue_=false;
            } else {
                // Deliver value for the string so far.
                UBool isFinal = static_cast<UBool>(node >> 15);
                if(isFinal) {
                    value_=readValue(pos, node&0x7fff);
                } else {
                    value_=readNodeValue(pos, node);
                }
                if(isFinal || (maxLength_>0 && str_.length()==maxLength_)) {
                    pos_=nullptr;
                } else {
                    // We cannot skip the value right here because it shares its
                    // lead unit with a match node which we have to evaluate
                    // next time.
                    // Instead, keep pos_ on the node lead unit itself.
                    pos_=pos-1;
                    skipValue_=true;
                }
                return true;
            }
        }
        if(maxLength_>0 && str_.length()==maxLength_) {
            return truncateAndStop();
        }
        if(node<kMinLinearMatch) {
            if(node==0) {
                node=*pos++;
            }
            pos=branchNext(pos, node+1, errorCode);
            if(pos==nullptr) {
                return true;  // Reached a final value.
            }
        } else {
            // Linear-match node, append length units to str_.
            int32_t length=node-kMinLinearMatch+1;
            if(maxLength_>0 && str_.length()+length>maxLength_) {
                str_.append(pos, maxLength_-str_.length());
                return truncateAndStop();
            }
            str_.append(pos, length);
            pos+=length;
        }
    }
}

// Branch node, needs to take the first outbound edge and push state for the rest.
const char16_t *
UCharsTrie::Iterator::branchNext(const char16_t *pos, int32_t length, UErrorCode &errorCode) {
    while(length>kMaxBranchLinearSubNodeLength) {
        ++pos;  // ignore the comparison unit
        // Push state for the greater-or-equal edge.
        stack_->addElement(static_cast<int32_t>(skipDelta(pos) - uchars_), errorCode);
        stack_->addElement(((length-(length>>1))<<16)|str_.length(), errorCode);
        // Follow the less-than edge.
        length>>=1;
        pos=jumpByDelta(pos);
    }
    // List of key-value pairs where values are either final values or jump deltas.
    // Read the first (key, value) pair.
    char16_t trieUnit=*pos++;
    int32_t node=*pos++;
    UBool isFinal = static_cast<UBool>(node >> 15);
    int32_t value=readValue(pos, node&=0x7fff);
    pos=skipValue(pos, node);
    stack_->addElement(static_cast<int32_t>(pos - uchars_), errorCode);
    stack_->addElement(((length-1)<<16)|str_.length(), errorCode);
    str_.append(trieUnit);
    if(isFinal) {
        pos_=nullptr;
        value_=value;
        return nullptr;
    } else {
        return pos+value;
    }
}

U_NAMESPACE_END
                                                                                                                                                                                                                          node-23.7.0/deps/icu-small/source/common/uchriter.cpp                                               0000664 0000000 0000000 00000017465 14746647661 0022534 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
* Copyright (C) 1998-2012, International Business Machines Corporation and
* others. All Rights Reserved.
******************************************************************************
*/

#include "utypeinfo.h"  // for 'typeid' to work

#include "unicode/uchriter.h"
#include "unicode/ustring.h"
#include "unicode/utf16.h"
#include "ustr_imp.h"

U_NAMESPACE_BEGIN

UOBJECT_DEFINE_RTTI_IMPLEMENTATION(UCharCharacterIterator)

UCharCharacterIterator::UCharCharacterIterator()
  : CharacterIterator(),
  text(nullptr)
{
    // never default construct!
}

UCharCharacterIterator::UCharCharacterIterator(ConstChar16Ptr textPtr,
                                               int32_t length)
  : CharacterIterator(textPtr != nullptr ? (length >= 0 ? length : u_strlen(textPtr)) : 0),
  text(textPtr)
{
}

UCharCharacterIterator::UCharCharacterIterator(ConstChar16Ptr textPtr,
                                               int32_t length,
                                               int32_t position)
  : CharacterIterator(textPtr != nullptr ? (length >= 0 ? length : u_strlen(textPtr)) : 0, position),
  text(textPtr)
{
}

UCharCharacterIterator::UCharCharacterIterator(ConstChar16Ptr textPtr,
                                               int32_t length,
                                               int32_t textBegin,
                                               int32_t textEnd,
                                               int32_t position)
  : CharacterIterator(textPtr != nullptr ? (length >= 0 ? length : u_strlen(textPtr)) : 0,
                      textBegin, textEnd, position),
  text(textPtr)
{
}

UCharCharacterIterator::UCharCharacterIterator(const UCharCharacterIterator& that)
: CharacterIterator(that),
  text(that.text)
{
}

UCharCharacterIterator&
UCharCharacterIterator::operator=(const UCharCharacterIterator& that) {
    CharacterIterator::operator=(that);
    text = that.text;
    return *this;
}

UCharCharacterIterator::~UCharCharacterIterator() {
}

bool
UCharCharacterIterator::operator==(const ForwardCharacterIterator& that) const {
    if (this == &that) {
        return true;
    }
    if (typeid(*this) != typeid(that)) {
        return false;
    }

    const UCharCharacterIterator&    realThat = static_cast<const UCharCharacterIterator&>(that);

    return text == realThat.text
        && textLength == realThat.textLength
        && pos == realThat.pos
        && begin == realThat.begin
        && end == realThat.end;
}

int32_t
UCharCharacterIterator::hashCode() const {
    return ustr_hashUCharsN(text, textLength) ^ pos ^ begin ^ end;
}

UCharCharacterIterator*
UCharCharacterIterator::clone() const {
    return new UCharCharacterIterator(*this);
}

char16_t
UCharCharacterIterator::first() {
    pos = begin;
    if(pos < end) {
        return text[pos];
    } else {
        return DONE;
    }
}

char16_t
UCharCharacterIterator::firstPostInc() {
    pos = begin;
    if(pos < end) {
        return text[pos++];
    } else {
        return DONE;
    }
}

char16_t
UCharCharacterIterator::last() {
    pos = end;
    if(pos > begin) {
        return text[--pos];
    } else {
        return DONE;
    }
}

char16_t
UCharCharacterIterator::setIndex(int32_t position) {
    if(position < begin) {
        pos = begin;
    } else if(position > end) {
        pos = end;
    } else {
        pos = position;
    }
    if(pos < end) {
        return text[pos];
    } else {
        return DONE;
    }
}

char16_t
UCharCharacterIterator::current() const {
    if (pos >= begin && pos < end) {
        return text[pos];
    } else {
        return DONE;
    }
}

char16_t
UCharCharacterIterator::next() {
    if (pos + 1 < end) {
        return text[++pos];
    } else {
        /* make current() return DONE */
        pos = end;
        return DONE;
    }
}

char16_t
UCharCharacterIterator::nextPostInc() {
    if (pos < end) {
        return text[pos++];
    } else {
        return DONE;
    }
}

UBool
UCharCharacterIterator::hasNext() {
    return pos < end;
}

char16_t
UCharCharacterIterator::previous() {
    if (pos > begin) {
        return text[--pos];
    } else {
        return DONE;
    }
}

UBool
UCharCharacterIterator::hasPrevious() {
    return pos > begin;
}

UChar32
UCharCharacterIterator::first32() {
    pos = begin;
    if(pos < end) {
        int32_t i = pos;
        UChar32 c;
        U16_NEXT(text, i, end, c);
        return c;
    } else {
        return DONE;
    }
}

UChar32
UCharCharacterIterator::first32PostInc() {
    pos = begin;
    if(pos < end) {
        UChar32 c;
        U16_NEXT(text, pos, end, c);
        return c;
    } else {
        return DONE;
    }
}

UChar32
UCharCharacterIterator::last32() {
    pos = end;
    if(pos > begin) {
        UChar32 c;
        U16_PREV(text, begin, pos, c);
        return c;
    } else {
        return DONE;
    }
}

UChar32
UCharCharacterIterator::setIndex32(int32_t position) {
    if(position < begin) {
        position = begin;
    } else if(position > end) {
        position = end;
    }
    if(position < end) {
        U16_SET_CP_START(text, begin, position);
        int32_t i = this->pos = position;
        UChar32 c;
        U16_NEXT(text, i, end, c);
        return c;
    } else {
        this->pos = position;
        return DONE;
    }
}

UChar32
UCharCharacterIterator::current32() const {
    if (pos >= begin && pos < end) {
        UChar32 c;
        U16_GET(text, begin, pos, end, c);
        return c;
    } else {
        return DONE;
    }
}

UChar32
UCharCharacterIterator::next32() {
    if (pos < end) {
        U16_FWD_1(text, pos, end);
        if(pos < end) {
            int32_t i = pos;
            UChar32 c;
            U16_NEXT(text, i, end, c);
            return c;
        }
    }
    /* make current() return DONE */
    pos = end;
    return DONE;
}

UChar32
UCharCharacterIterator::next32PostInc() {
    if (pos < end) {
        UChar32 c;
        U16_NEXT(text, pos, end, c);
        return c;
    } else {
        return DONE;
    }
}

UChar32
UCharCharacterIterator::previous32() {
    if (pos > begin) {
        UChar32 c;
        U16_PREV(text, begin, pos, c);
        return c;
    } else {
        return DONE;
    }
}

int32_t
UCharCharacterIterator::move(int32_t delta, CharacterIterator::EOrigin origin) {
    switch(origin) {
    case kStart:
        pos = begin + delta;
        break;
    case kCurrent:
        pos += delta;
        break;
    case kEnd:
        pos = end + delta;
        break;
    default:
        break;
    }

    if(pos < begin) {
        pos = begin;
    } else if(pos > end) {
        pos = end;
    }

    return pos;
}

int32_t
UCharCharacterIterator::move32(int32_t delta, CharacterIterator::EOrigin origin) {
    // this implementation relies on the "safe" version of the UTF macros
    // (or the trustworthiness of the caller)
    switch(origin) {
    case kStart:
        pos = begin;
        if(delta > 0) {
            U16_FWD_N(text, pos, end, delta);
        }
        break;
    case kCurrent:
        if(delta > 0) {
            U16_FWD_N(text, pos, end, delta);
        } else {
            U16_BACK_N(text, begin, pos, -delta);
        }
        break;
    case kEnd:
        pos = end;
        if(delta < 0) {
            U16_BACK_N(text, begin, pos, -delta);
        }
        break;
    default:
        break;
    }

    return pos;
}

void UCharCharacterIterator::setText(ConstChar16Ptr newText,
                                     int32_t      newTextLength) {
    text = newText;
    if (newText == nullptr || newTextLength < 0) {
        newTextLength = 0;
    }
    end = textLength = newTextLength;
    pos = begin = 0;
}

void
UCharCharacterIterator::getText(UnicodeString& result) {
    result = UnicodeString(text, textLength);
}

U_NAMESPACE_END
                                                                                                                                                                                                           node-23.7.0/deps/icu-small/source/common/ucln.h                                                     0000664 0000000 0000000 00000006205 14746647661 0021303 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
* Copyright (C) 2001-2013, International Business Machines
*                Corporation and others. All Rights Reserved.
*
******************************************************************************
*   file name:  ucln.h
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2001July05
*   created by: George Rhoten
*/

#ifndef __UCLN_H__
#define __UCLN_H__

#include "unicode/utypes.h"

/** These are the functions used to register a library's memory cleanup
 * functions.  Each library should define a single library register function
 * to call this API.  In the i18n library, it is ucln_i18n_registerCleanup().
 *
 * None of the cleanup functions should use a mutex to clean up an API's
 * allocated memory because a cleanup function is not meant to be thread safe,
 * and plenty of data cannot be reference counted in order to make sure that
 * no one else needs the allocated data.
 *
 * In order to make a cleanup function get called when u_cleanup is called,
 * You should add your function to the library specific cleanup function.
 * If the cleanup function is not in the common library, the code that
 * allocates the memory should call the library specific cleanup function.
 * For instance, in the i18n library, any memory allocated statically must
 * call ucln_i18n_registerCleanup() from the ucln_in.h header.  These library
 * cleanup functions are needed in order to prevent a circular dependency
 * between the common library and any other library.
 *
 * The order of the cleanup is very important.  In general, an API that
 * depends on a second API should be cleaned up before the second API.
 * For instance, the default converter in ustring depends upon the converter
 * API.  So the default converter should be closed before the converter API
 * has its cache flushed.  This will prevent any memory leaks due to
 * reference counting.
 *
 * Please see common/ucln_cmn.{h,c} and i18n/ucln_in.{h,c} for examples.
 */

/**
 * Data Type for cleanup function selector. These roughly correspond to libraries.
 */
typedef enum ECleanupLibraryType {
    UCLN_START = -1,
    UCLN_UPLUG,     /* ICU plugins */
    UCLN_CUSTOM,    /* Custom is for anyone else. */
    UCLN_CTESTFW,
    UCLN_TOOLUTIL,
    UCLN_LAYOUTEX,
    UCLN_LAYOUT,
    UCLN_IO,
    UCLN_I18N,
    UCLN_COMMON /* This must be the last one to cleanup. */
} ECleanupLibraryType;

/**
 * Data type for cleanup function pointer
 */
U_CDECL_BEGIN
typedef UBool U_CALLCONV cleanupFunc(void);
typedef void U_CALLCONV initFunc(UErrorCode *);
U_CDECL_END

/**
 * Register a cleanup function
 * @param type which library to register for.
 * @param func the function pointer
 */
U_CAPI void U_EXPORT2 ucln_registerCleanup(ECleanupLibraryType type,
                                           cleanupFunc *func);

/**
 * Request cleanup for one specific library.
 * Not thread safe.
 * @param type which library to cleanup
 */
U_CAPI void U_EXPORT2 ucln_cleanupOne(ECleanupLibraryType type);

#endif
                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/icu-small/source/common/ucln_cmn.cpp                                               0000664 0000000 0000000 00000010200 14746647661 0022461 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
* Copyright (C) 2001-2014, International Business Machines
*                Corporation and others. All Rights Reserved.
******************************************************************************
*   file name:  ucln_cmn.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2001July05
*   created by: George Rhoten
*/

#include "unicode/utypes.h"
#include "unicode/uclean.h"
#include "cmemory.h"
#include "mutex.h"
#include "uassert.h"
#include "ucln.h"
#include "ucln_cmn.h"
#include "utracimp.h"
#include "umutex.h"

/**  Auto-client for UCLN_COMMON **/
#define UCLN_TYPE_IS_COMMON
#include "ucln_imp.h"

static cleanupFunc *gCommonCleanupFunctions[UCLN_COMMON_COUNT];
static cleanupFunc *gLibCleanupFunctions[UCLN_COMMON];


/************************************************
 The cleanup order is important in this function.
 Please be sure that you have read ucln.h
 ************************************************/
U_CAPI void U_EXPORT2
u_cleanup()
{
    UTRACE_ENTRY_OC(UTRACE_U_CLEANUP);
    icu::umtx_lock(nullptr);     /* Force a memory barrier, so that we are sure to see   */
    icu::umtx_unlock(nullptr);   /*   all state left around by any other threads.        */

    ucln_lib_cleanup();

    cmemory_cleanup();       /* undo any heap functions set by u_setMemoryFunctions(). */
    UTRACE_EXIT();           /* Must be before utrace_cleanup(), which turns off tracing. */
/*#if U_ENABLE_TRACING*/
    utrace_cleanup();
/*#endif*/
}

U_CAPI void U_EXPORT2 ucln_cleanupOne(ECleanupLibraryType libType) 
{
    if (gLibCleanupFunctions[libType])
    {
        gLibCleanupFunctions[libType]();
        gLibCleanupFunctions[libType] = nullptr;
    }
}

U_CFUNC void
ucln_common_registerCleanup(ECleanupCommonType type,
                            cleanupFunc *func)
{
    // Thread safety messiness: From ticket 10295, calls to registerCleanup() may occur
    // concurrently. Although such cases should be storing the same value, they raise errors
    // from the thread sanity checker. Doing the store within a mutex avoids those.
    // BUT that can trigger a recursive entry into std::call_once() in umutex.cpp when this code,
    // running from the call_once function, tries to grab the ICU global mutex, which
    // re-enters the mutex init path. So, work-around by special casing UCLN_COMMON_MUTEX, not
    // using the ICU global mutex for it.
    //
    // No other point in ICU uses std::call_once().

    U_ASSERT(UCLN_COMMON_START < type && type < UCLN_COMMON_COUNT);
    if (type == UCLN_COMMON_MUTEX) {
        gCommonCleanupFunctions[type] = func;
    } else if (UCLN_COMMON_START < type && type < UCLN_COMMON_COUNT)  {
        icu::Mutex m;     // See ticket 10295 for discussion.
        gCommonCleanupFunctions[type] = func;
    }
#if !UCLN_NO_AUTO_CLEANUP && (defined(UCLN_AUTO_ATEXIT) || defined(UCLN_AUTO_LOCAL))
    ucln_registerAutomaticCleanup();
#endif
}

// Note: ucln_registerCleanup() is called with the ICU global mutex locked.
//       Be aware if adding anything to the function.
//       See ticket 10295 for discussion.

U_CAPI void U_EXPORT2
ucln_registerCleanup(ECleanupLibraryType type,
                     cleanupFunc *func)
{
    U_ASSERT(UCLN_START < type && type < UCLN_COMMON);
    if (UCLN_START < type && type < UCLN_COMMON)
    {
        gLibCleanupFunctions[type] = func;
    }
}

U_CFUNC UBool ucln_lib_cleanup() {
    int32_t libType = UCLN_START;
    int32_t commonFunc = UCLN_COMMON_START;

    for (libType++; libType<UCLN_COMMON; libType++) {
        ucln_cleanupOne(static_cast<ECleanupLibraryType>(libType));
    }

    for (commonFunc++; commonFunc<UCLN_COMMON_COUNT; commonFunc++) {
        if (gCommonCleanupFunctions[commonFunc])
        {
            gCommonCleanupFunctions[commonFunc]();
            gCommonCleanupFunctions[commonFunc] = nullptr;
        }
    }
#if !UCLN_NO_AUTO_CLEANUP && (defined(UCLN_AUTO_ATEXIT) || defined(UCLN_AUTO_LOCAL))
    ucln_unRegisterAutomaticCleanup();
#endif
    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/icu-small/source/common/ucln_cmn.h                                                 0000664 0000000 0000000 00000004666 14746647661 0022151 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
* Copyright (C) 2001-2016, International Business Machines
*                Corporation and others. All Rights Reserved.
******************************************************************************
*   file name:  ucln_cmn.h
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2001July05
*   created by: George Rhoten
*/

#ifndef __UCLN_CMN_H__
#define __UCLN_CMN_H__

#include "unicode/utypes.h"
#include "ucln.h"

/* These are the cleanup functions for various APIs. */
/* @return true if cleanup complete successfully.*/
U_CFUNC UBool utrace_cleanup(void);

U_CFUNC UBool ucln_lib_cleanup(void);

/*
Please keep the order of enums declared in same order
as the cleanup functions are suppose to be called. */
typedef enum ECleanupCommonType {
    UCLN_COMMON_START = -1,
    UCLN_COMMON_NUMPARSE_UNISETS,
    UCLN_COMMON_USPREP,
    UCLN_COMMON_BREAKITERATOR,
    UCLN_COMMON_RBBI,
    UCLN_COMMON_SERVICE,
    UCLN_COMMON_LOCALE_KEY_TYPE,
    UCLN_COMMON_LOCALE,
    UCLN_COMMON_LOCALE_ALIAS,
    UCLN_COMMON_LOCALE_KNOWN_CANONICALIZED,
    UCLN_COMMON_LOCALE_AVAILABLE,
    UCLN_COMMON_LIKELY_SUBTAGS,
    UCLN_COMMON_LOCALE_DISTANCE,
    UCLN_COMMON_ULOC,
    UCLN_COMMON_CURRENCY,
    UCLN_COMMON_LOADED_NORMALIZER2,
    UCLN_COMMON_NORMALIZER2,
    UCLN_COMMON_CHARACTERPROPERTIES,
    UCLN_COMMON_USET,
    UCLN_COMMON_UNAMES,
    UCLN_COMMON_UPROPS,
    UCLN_COMMON_EMOJIPROPS,
    UCLN_COMMON_UCNV,
    UCLN_COMMON_UCNV_IO,
    UCLN_COMMON_UDATA,
    UCLN_COMMON_PUTIL,
    UCLN_COMMON_UINIT,

    /*
       Unified caches caches collation stuff. Collation data structures
       contain resource bundles which means that unified cache cleanup
       must happen before resource bundle clean up.
    */
    UCLN_COMMON_UNIFIED_CACHE,
    UCLN_COMMON_URES,
    UCLN_COMMON_MUTEX,    // Mutexes should be the last to be cleaned up.
    UCLN_COMMON_COUNT /* This must be last */
} ECleanupCommonType;

/* Main library cleanup registration function. */
/* See common/ucln.h for details on adding a cleanup function. */
/* Note: the global mutex must not be held when calling this function. */
U_CFUNC void U_EXPORT2 ucln_common_registerCleanup(ECleanupCommonType type,
                                                   cleanupFunc *func);

#endif
                                                                          node-23.7.0/deps/icu-small/source/common/ucln_imp.h                                                 0000664 0000000 0000000 00000012141 14746647661 0022144 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
* Copyright (C) 2009-2011, International Business Machines
*                Corporation and others. All Rights Reserved.
*
******************************************************************************
*   file name:  ucln_imp.h
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   This file contains the platform specific implementation of per-library cleanup.
*
*/


#ifndef __UCLN_IMP_H__
#define __UCLN_IMP_H__

#include "ucln.h"
#include <stdlib.h>

/**
 * Auto cleanup of ICU libraries
 * There are several methods in per library cleanup of icu libraries:
 * 1) Compiler/Platform based cleanup:
 *   a) Windows MSVC uses DllMain()
 *   b) GCC uses destructor function attribute
 *   c) Sun Studio, AIX VA, and HP-UX aCC uses a linker option to set the exit function
 * 2) Using atexit()
 * 3) Implementing own automatic cleanup functions
 *
 * For option 1, ensure that UCLN_NO_AUTO_CLEANUP is set to 0 by using --enable-auto-cleanup
 * configure option or by otherwise setting UCLN_NO_AUTO_CLEANUP to 0
 * For option 2, follow option 1 and also define UCLN_AUTO_ATEXIT
 * For option 3, follow option 1 and also define UCLN_AUTO_LOCAL (see below for more information)
 */

#if !UCLN_NO_AUTO_CLEANUP

/*
 * The following declarations are for when UCLN_AUTO_LOCAL or UCLN_AUTO_ATEXIT
 * are defined. They are commented out because they are static and will be defined
 * later. The information is still here to provide some guidance for the developer
 * who chooses to use UCLN_AUTO_LOCAL.
 */
/**
 * Give the library an opportunity to register an automatic cleanup.
 * This may be called more than once.
 */
/*static void ucln_registerAutomaticCleanup();*/
/**
 * Unregister an automatic cleanup, if possible. Called from cleanup.
 */
/*static void ucln_unRegisterAutomaticCleanup();*/

#ifdef UCLN_TYPE_IS_COMMON
#   define UCLN_CLEAN_ME_UP u_cleanup()
#else
#   define UCLN_CLEAN_ME_UP ucln_cleanupOne(UCLN_TYPE)
#endif

/* ------------ automatic cleanup: registration. Choose ONE ------- */
#if defined(UCLN_AUTO_LOCAL)
/* To use:
 *  1. define UCLN_AUTO_LOCAL,
 *  2. create ucln_local_hook.c containing implementations of
 *           static void ucln_registerAutomaticCleanup()
 *           static void ucln_unRegisterAutomaticCleanup()
 */
#include "ucln_local_hook.c"

#elif defined(UCLN_AUTO_ATEXIT)
/*
 * Use the ANSI C 'atexit' function. Note that this mechanism does not
 * guarantee the order of cleanup relative to other users of ICU!
 */
static UBool gAutoCleanRegistered = false;

static void ucln_atexit_handler()
{
    UCLN_CLEAN_ME_UP;
}

static void ucln_registerAutomaticCleanup()
{
    if(!gAutoCleanRegistered) {
        gAutoCleanRegistered = true;
        atexit(&ucln_atexit_handler);
    }
}

static void ucln_unRegisterAutomaticCleanup () {
}
/* ------------end of automatic cleanup: registration. ------- */

#elif defined (UCLN_FINI)
/**
 * If UCLN_FINI is defined, it is the (versioned, etc) name of a cleanup
 * entrypoint. Add a stub to call ucln_cleanupOne
 * Used on AIX, Solaris, and HP-UX
 */
U_CAPI void U_EXPORT2 UCLN_FINI (void);

U_CAPI void U_EXPORT2 UCLN_FINI ()
{
    /* This function must be defined, if UCLN_FINI is defined, else link error. */
     UCLN_CLEAN_ME_UP;
}

/* Windows: DllMain */
#elif U_PLATFORM_HAS_WIN32_API
/* 
 * ICU's own DllMain.
 */

/* these are from putil.c */
/* READ READ READ READ!    Are you getting compilation errors from windows.h?
          Any source file which includes this (ucln_imp.h) header MUST 
          be defined with language extensions ON. */
#ifndef WIN32_LEAN_AND_MEAN
#   define WIN32_LEAN_AND_MEAN
#endif
#   define VC_EXTRALEAN
#   define NOUSER
#   define NOSERVICE
#   define NOIME
#   define NOMCX
#   include <windows.h>
/*
 * This is a stub DllMain function with icu specific process handling code.
 */
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    BOOL status = true;

    switch(fdwReason) {
        case DLL_PROCESS_ATTACH:
             /* ICU does not trap process attach, but must pass these through properly. */
            /* ICU specific process attach could go here */
            break;

        case DLL_PROCESS_DETACH:
            /* Here is the one we actually care about. */

            UCLN_CLEAN_ME_UP;

            break;

        case DLL_THREAD_ATTACH:
            /* ICU does not trap thread attach, but must pass these through properly. */
            /* ICU specific thread attach could go here */
            break;

        case DLL_THREAD_DETACH:
            /* ICU does not trap thread detach, but must pass these through properly. */
            /* ICU specific thread detach could go here */
            break;

    }
    return status;
}

#elif defined(__GNUC__)
/* GCC - use __attribute((destructor)) */
static void ucln_destructor()   __attribute__((destructor)) ;

static void ucln_destructor() 
{
    UCLN_CLEAN_ME_UP;
}

#endif

#endif /* UCLN_NO_AUTO_CLEANUP */

#else
#error This file can only be included once.
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/icu-small/source/common/ucmndata.cpp                                               0000664 0000000 0000000 00000032562 14746647661 0022476 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 1999-2011, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************/


/*------------------------------------------------------------------------------
 *
 *   UCommonData   An abstract interface for dealing with ICU Common Data Files.
 *                 ICU Common Data Files are a grouping of a number of individual
 *                 data items (resources, converters, tables, anything) into a
 *                 single file or dll.  The combined format includes a table of
 *                 contents for locating the individual items by name.
 *
 *                 Two formats for the table of contents are supported, which is
 *                 why there is an abstract interface involved.
 *
 */

#include "unicode/utypes.h"
#include "unicode/udata.h"
#include "cstring.h"
#include "ucmndata.h"
#include "udatamem.h"

#if defined(UDATA_DEBUG) || defined(UDATA_DEBUG_DUMP)
#   include <stdio.h>
#endif

U_CFUNC uint16_t
udata_getHeaderSize(const DataHeader *udh) {
    if(udh==nullptr) {
        return 0;
    } else if(udh->info.isBigEndian==U_IS_BIG_ENDIAN) {
        /* same endianness */
        return udh->dataHeader.headerSize;
    } else {
        /* opposite endianness */
        uint16_t x=udh->dataHeader.headerSize;
        return (uint16_t)((x<<8)|(x>>8));
    }
}

U_CFUNC uint16_t
udata_getInfoSize(const UDataInfo *info) {
    if(info==nullptr) {
        return 0;
    } else if(info->isBigEndian==U_IS_BIG_ENDIAN) {
        /* same endianness */
        return info->size;
    } else {
        /* opposite endianness */
        uint16_t x=info->size;
        return (uint16_t)((x<<8)|(x>>8));
    }
}

/*-----------------------------------------------------------------------------*
 *                                                                             *
 *  Pointer TOCs.   TODO: This form of table-of-contents should be removed     *
 *                  because DLLs must be relocated on loading to correct the   *
 *                  pointer values and this operation makes shared memory      *
 *                  mapping of the data much less likely to work.              *
 *                                                                             *
 *-----------------------------------------------------------------------------*/
typedef struct {
    const char       *entryName;
    const DataHeader *pHeader;
} PointerTOCEntry;


typedef struct  {
    uint32_t          count;
    uint32_t          reserved;
    /**
     * Variable-length array declared with length 1 to disable bounds checkers.
     * The actual array length is in the count field.
     */
    PointerTOCEntry   entry[1];
}  PointerTOC;


/* definition of OffsetTOC struct types moved to ucmndata.h */

/*-----------------------------------------------------------------------------*
 *                                                                             *
 *    entry point lookup implementations                                       *
 *                                                                             *
 *-----------------------------------------------------------------------------*/

#ifndef MIN
#define MIN(a,b) (((a)<(b)) ? (a) : (b))
#endif

/**
 * Compare strings where we know the shared prefix length,
 * and advance the prefix length as we find that the strings share even more characters.
 */
static int32_t
strcmpAfterPrefix(const char *s1, const char *s2, int32_t *pPrefixLength) {
    int32_t pl=*pPrefixLength;
    int32_t cmp=0;
    s1+=pl;
    s2+=pl;
    for(;;) {
        int32_t c1 = static_cast<uint8_t>(*s1++);
        int32_t c2 = static_cast<uint8_t>(*s2++);
        cmp=c1-c2;
        if(cmp!=0 || c1==0) {  /* different or done */
            break;
        }
        ++pl;  /* increment shared same-prefix length */
    }
    *pPrefixLength=pl;
    return cmp;
}

static int32_t
offsetTOCPrefixBinarySearch(const char *s, const char *names,
                            const UDataOffsetTOCEntry *toc, int32_t count) {
    int32_t start=0;
    int32_t limit=count;
    /*
     * Remember the shared prefix between s, start and limit,
     * and don't compare that shared prefix again.
     * The shared prefix should get longer as we narrow the [start, limit[ range.
     */
    int32_t startPrefixLength=0;
    int32_t limitPrefixLength=0;
    if(count==0) {
        return -1;
    }
    /*
     * Prime the prefix lengths so that we don't keep prefixLength at 0 until
     * both the start and limit indexes have moved.
     * At the same time, we find if s is one of the start and (limit-1) names,
     * and if not, exclude them from the actual binary search.
     */
    if(0==strcmpAfterPrefix(s, names+toc[0].nameOffset, &startPrefixLength)) {
        return 0;
    }
    ++start;
    --limit;
    if(0==strcmpAfterPrefix(s, names+toc[limit].nameOffset, &limitPrefixLength)) {
        return limit;
    }
    while(start<limit) {
        int32_t i=(start+limit)/2;
        int32_t prefixLength=MIN(startPrefixLength, limitPrefixLength);
        int32_t cmp=strcmpAfterPrefix(s, names+toc[i].nameOffset, &prefixLength);
        if(cmp<0) {
            limit=i;
            limitPrefixLength=prefixLength;
        } else if(cmp==0) {
            return i;
        } else {
            start=i+1;
            startPrefixLength=prefixLength;
        }
    }
    return -1;
}

static int32_t
pointerTOCPrefixBinarySearch(const char *s, const PointerTOCEntry *toc, int32_t count) {
    int32_t start=0;
    int32_t limit=count;
    /*
     * Remember the shared prefix between s, start and limit,
     * and don't compare that shared prefix again.
     * The shared prefix should get longer as we narrow the [start, limit[ range.
     */
    int32_t startPrefixLength=0;
    int32_t limitPrefixLength=0;
    if(count==0) {
        return -1;
    }
    /*
     * Prime the prefix lengths so that we don't keep prefixLength at 0 until
     * both the start and limit indexes have moved.
     * At the same time, we find if s is one of the start and (limit-1) names,
     * and if not, exclude them from the actual binary search.
     */
    if(0==strcmpAfterPrefix(s, toc[0].entryName, &startPrefixLength)) {
        return 0;
    }
    ++start;
    --limit;
    if(0==strcmpAfterPrefix(s, toc[limit].entryName, &limitPrefixLength)) {
        return limit;
    }
    while(start<limit) {
        int32_t i=(start+limit)/2;
        int32_t prefixLength=MIN(startPrefixLength, limitPrefixLength);
        int32_t cmp=strcmpAfterPrefix(s, toc[i].entryName, &prefixLength);
        if(cmp<0) {
            limit=i;
            limitPrefixLength=prefixLength;
        } else if(cmp==0) {
            return i;
        } else {
            start=i+1;
            startPrefixLength=prefixLength;
        }
    }
    return -1;
}

U_CDECL_BEGIN
static uint32_t U_CALLCONV
offsetTOCEntryCount(const UDataMemory *pData) {
    int32_t          retVal=0;
    const UDataOffsetTOC *toc = (UDataOffsetTOC *)pData->toc;
    if (toc != nullptr) {
        retVal = toc->count;
    }
    return retVal;
}

static const DataHeader * U_CALLCONV
offsetTOCLookupFn(const UDataMemory *pData,
                  const char *tocEntryName,
                  int32_t *pLength,
                  UErrorCode *pErrorCode) {
    (void)pErrorCode;
    const UDataOffsetTOC  *toc = (UDataOffsetTOC *)pData->toc;
    if(toc!=nullptr) {
        const char *base=(const char *)toc;
        int32_t number, count=(int32_t)toc->count;

        /* perform a binary search for the data in the common data's table of contents */
#if defined (UDATA_DEBUG_DUMP)
        /* list the contents of the TOC each time .. not recommended */
        for(number=0; number<count; ++number) {
            fprintf(stderr, "\tx%d: %s\n", number, &base[toc->entry[number].nameOffset]);
        }
#endif
        number=offsetTOCPrefixBinarySearch(tocEntryName, base, toc->entry, count);
        if(number>=0) {
            /* found it */
            const UDataOffsetTOCEntry *entry=toc->entry+number;
#ifdef UDATA_DEBUG
            fprintf(stderr, "%s: Found.\n", tocEntryName);
#endif
            if((number+1) < count) {
                *pLength = (int32_t)(entry[1].dataOffset - entry->dataOffset);
            } else {
                *pLength = -1;
            }
            return (const DataHeader *)(base+entry->dataOffset);
        } else {
#ifdef UDATA_DEBUG
            fprintf(stderr, "%s: Not found.\n", tocEntryName);
#endif
            return nullptr;
        }
    } else {
#ifdef UDATA_DEBUG
        fprintf(stderr, "returning header\n");
#endif

        return pData->pHeader;
    }
}


static uint32_t U_CALLCONV pointerTOCEntryCount(const UDataMemory *pData) {
    const PointerTOC *toc = (PointerTOC *)pData->toc;
    return toc != nullptr ? toc->count : 0;
}

static const DataHeader * U_CALLCONV pointerTOCLookupFn(const UDataMemory *pData,
                   const char *name,
                   int32_t *pLength,
                   UErrorCode *pErrorCode) {
    (void)pErrorCode;
    if(pData->toc!=nullptr) {
        const PointerTOC *toc = (PointerTOC *)pData->toc;
        int32_t number, count=(int32_t)toc->count;

#if defined (UDATA_DEBUG_DUMP)
        /* list the contents of the TOC each time .. not recommended */
        for(number=0; number<count; ++number) {
            fprintf(stderr, "\tx%d: %s\n", number, toc->entry[number].entryName);
        }
#endif
        number=pointerTOCPrefixBinarySearch(name, toc->entry, count);
        if(number>=0) {
            /* found it */
#ifdef UDATA_DEBUG
            fprintf(stderr, "%s: Found.\n", toc->entry[number].entryName);
#endif
            *pLength=-1;
            return UDataMemory_normalizeDataPointer(toc->entry[number].pHeader);
        } else {
#ifdef UDATA_DEBUG
            fprintf(stderr, "%s: Not found.\n", name);
#endif
            return nullptr;
        }
    } else {
        return pData->pHeader;
    }
}
U_CDECL_END


static const commonDataFuncs CmnDFuncs = {offsetTOCLookupFn,  offsetTOCEntryCount};
static const commonDataFuncs ToCPFuncs = {pointerTOCLookupFn, pointerTOCEntryCount};



/*----------------------------------------------------------------------*
 *                                                                      *
 *  checkCommonData   Validate the format of a common data file.        *
 *                    Fill in the virtual function ptr based on TOC type *
 *                    If the data is invalid, close the UDataMemory     *
 *                    and set the appropriate error code.               *
 *                                                                      *
 *----------------------------------------------------------------------*/
U_CFUNC void udata_checkCommonData(UDataMemory *udm, UErrorCode *err) {
    if (U_FAILURE(*err)) {
        return;
    }

    if(udm==nullptr || udm->pHeader==nullptr) {
      *err=U_INVALID_FORMAT_ERROR;
    } else if(!(udm->pHeader->dataHeader.magic1==0xda &&
        udm->pHeader->dataHeader.magic2==0x27 &&
        udm->pHeader->info.isBigEndian==U_IS_BIG_ENDIAN &&
        udm->pHeader->info.charsetFamily==U_CHARSET_FAMILY)
        ) {
        /* header not valid */
        *err=U_INVALID_FORMAT_ERROR;
    }
    else if (udm->pHeader->info.dataFormat[0]==0x43 &&
        udm->pHeader->info.dataFormat[1]==0x6d &&
        udm->pHeader->info.dataFormat[2]==0x6e &&
        udm->pHeader->info.dataFormat[3]==0x44 &&
        udm->pHeader->info.formatVersion[0]==1
        ) {
        /* dataFormat="CmnD" */
        udm->vFuncs = &CmnDFuncs;
        udm->toc=(const char *)udm->pHeader+udata_getHeaderSize(udm->pHeader);
    }
    else if(udm->pHeader->info.dataFormat[0]==0x54 &&
        udm->pHeader->info.dataFormat[1]==0x6f &&
        udm->pHeader->info.dataFormat[2]==0x43 &&
        udm->pHeader->info.dataFormat[3]==0x50 &&
        udm->pHeader->info.formatVersion[0]==1
        ) {
        /* dataFormat="ToCP" */
        udm->vFuncs = &ToCPFuncs;
        udm->toc=(const char *)udm->pHeader+udata_getHeaderSize(udm->pHeader);
    }
    else {
        /* dataFormat not recognized */
        *err=U_INVALID_FORMAT_ERROR;
    }

    if (U_FAILURE(*err)) {
        /* If the data is no good and we memory-mapped it ourselves,
         *  close the memory mapping so it doesn't leak.  Note that this has
         *  no effect on non-memory mapped data, other than clearing fields in udm.
         */
        udata_close(udm);
    }
}

/*
 * TODO: Add a udata_swapPackageHeader() function that swaps an ICU .dat package
 * header but not its sub-items.
 * This function will be needed for automatic runtime swapping.
 * Sub-items should not be swapped to limit the swapping to the parts of the
 * package that are actually used.
 *
 * Since lengths of items are implicit in the order and offsets of their
 * ToC entries, and since offsets are relative to the start of the ToC,
 * a swapped version may need to generate a different data structure
 * with pointers to the original data items and with their lengths
 * (-1 for the last one if it is not known), and maybe even pointers to the
 * swapped versions of the items.
 * These pointers to swapped versions would establish a cache;
 * instead, each open data item could simply own the storage for its swapped
 * data. This fits better with the current design.
 *
 * markus 2003sep18 Jitterbug 2235
 */
                                                                                                                                              node-23.7.0/deps/icu-small/source/common/ucmndata.h                                                 0000664 0000000 0000000 00000006364 14746647661 0022144 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 1999-2011, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************/


/*----------------------------------------------------------------------------------
 *
 *   UCommonData   An abstract interface for dealing with ICU Common Data Files.
 *                 ICU Common Data Files are a grouping of a number of individual
 *                 data items (resources, converters, tables, anything) into a
 *                 single file or dll.  The combined format includes a table of
 *                 contents for locating the individual items by name.
 *
 *                 Two formats for the table of contents are supported, which is
 *                 why there is an abstract interface involved.
 *
 *                 These functions are part of the ICU internal implementation, and
 *                 are not intended to be used directly by applications.
 */

#ifndef __UCMNDATA_H__
#define __UCMNDATA_H__

#include "unicode/udata.h"
#include "umapfile.h"


#define COMMON_DATA_NAME U_ICUDATA_NAME

typedef struct  {
    uint16_t    headerSize;
    uint8_t     magic1;
    uint8_t     magic2;
} MappedData;


typedef struct  {
    MappedData  dataHeader;
    UDataInfo   info;
} DataHeader;

typedef struct {
    uint32_t nameOffset;
    uint32_t dataOffset;
} UDataOffsetTOCEntry;

typedef struct {
    uint32_t count;
    /**
     * Variable-length array declared with length 1 to disable bounds checkers.
     * The actual array length is in the count field.
     */
    UDataOffsetTOCEntry entry[1];
} UDataOffsetTOC;

/**
 * Get the header size from a const DataHeader *udh.
 * Handles opposite-endian data.
 *
 * @internal
 */
U_CFUNC uint16_t
udata_getHeaderSize(const DataHeader *udh);

/**
 * Get the UDataInfo.size from a const UDataInfo *info.
 * Handles opposite-endian data.
 *
 * @internal
 */
U_CFUNC uint16_t
udata_getInfoSize(const UDataInfo *info);

U_CDECL_BEGIN
/*
 *  "Virtual" functions for data lookup.
 *  To call one, given a UDataMemory *p, the code looks like this:
 *     p->vFuncs.Lookup(p, tocEntryName, pErrorCode);
 *          (I sure do wish this was written in C++, not C)
 */

typedef const DataHeader *
(U_CALLCONV * LookupFn)(const UDataMemory *pData,
                        const char *tocEntryName,
                        int32_t *pLength,
                        UErrorCode *pErrorCode);

typedef uint32_t
(U_CALLCONV * NumEntriesFn)(const UDataMemory *pData);

U_CDECL_END

typedef struct {
    LookupFn      Lookup;
    NumEntriesFn  NumEntries; 
} commonDataFuncs;


/*
 *  Functions to check whether a UDataMemory refers to memory containing 
 *     a recognizable header and table of contents a Common Data Format
 *
 *     If a valid header and TOC are found,
 *         set the CommonDataFuncs function dispatch vector in the UDataMemory
 *             to point to the right functions for the TOC type.
 *     otherwise
 *         set an errorcode.
 */
U_CFUNC void udata_checkCommonData(UDataMemory *pData, UErrorCode *pErrorCode);

#endif
                                                                                                                                                                                                                                                                            node-23.7.0/deps/icu-small/source/common/ucnv.cpp                                                   0000664 0000000 0000000 00000273464 14746647661 0021665 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 1998-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*
*  ucnv.c:
*  Implements APIs for the ICU's codeset conversion library;
*  mostly calls through internal functions;
*  created by Bertrand A. Damiba
*
* Modification History:
*
*   Date        Name        Description
*   04/04/99    helena      Fixed internal header inclusion.
*   05/09/00    helena      Added implementation to handle fallback mappings.
*   06/20/2000  helena      OS/400 port changes; mostly typecast.
*/

#include "unicode/utypes.h"

#if !UCONFIG_NO_CONVERSION

#include <memory>

#include "unicode/ustring.h"
#include "unicode/ucnv.h"
#include "unicode/ucnv_err.h"
#include "unicode/uset.h"
#include "unicode/utf.h"
#include "unicode/utf16.h"
#include "putilimp.h"
#include "cmemory.h"
#include "cstring.h"
#include "uassert.h"
#include "utracimp.h"
#include "ustr_imp.h"
#include "ucnv_imp.h"
#include "ucnv_cnv.h"
#include "ucnv_bld.h"

/* size of intermediate and preflighting buffers in ucnv_convert() */
#define CHUNK_SIZE 1024

typedef struct UAmbiguousConverter {
    const char *name;
    const char16_t variant5c;
} UAmbiguousConverter;

static const UAmbiguousConverter ambiguousConverters[]={
    { "ibm-897_P100-1995", 0xa5 },
    { "ibm-942_P120-1999", 0xa5 },
    { "ibm-943_P130-1999", 0xa5 },
    { "ibm-946_P100-1995", 0xa5 },
    { "ibm-33722_P120-1999", 0xa5 },
    { "ibm-1041_P100-1995", 0xa5 },
    /*{ "ibm-54191_P100-2006", 0xa5 },*/
    /*{ "ibm-62383_P100-2007", 0xa5 },*/
    /*{ "ibm-891_P100-1995", 0x20a9 },*/
    { "ibm-944_P100-1995", 0x20a9 },
    { "ibm-949_P110-1999", 0x20a9 },
    { "ibm-1363_P110-1997", 0x20a9 },
    { "ISO_2022,locale=ko,version=0", 0x20a9 },
    { "ibm-1088_P100-1995", 0x20a9 }
};

/*Calls through createConverter */
U_CAPI UConverter* U_EXPORT2
ucnv_open (const char *name,
                       UErrorCode * err)
{
    UConverter *r;

    if (err == nullptr || U_FAILURE (*err)) {
        return nullptr;
    }

    r =  ucnv_createConverter(nullptr, name, err);
    return r;
}

U_CAPI UConverter* U_EXPORT2 
ucnv_openPackage   (const char *packageName, const char *converterName, UErrorCode * err)
{
    return ucnv_createConverterFromPackage(packageName, converterName,  err);
}

/*Extracts the char16_t* to a char* and calls through createConverter */
U_CAPI UConverter*   U_EXPORT2
ucnv_openU (const char16_t * name,
                         UErrorCode * err)
{
    char asciiName[UCNV_MAX_CONVERTER_NAME_LENGTH];

    if (err == nullptr || U_FAILURE(*err))
        return nullptr;
    if (name == nullptr)
        return ucnv_open (nullptr, err);
    if (u_strlen(name) >= UCNV_MAX_CONVERTER_NAME_LENGTH)
    {
        *err = U_ILLEGAL_ARGUMENT_ERROR;
        return nullptr;
    }
    return ucnv_open(u_austrcpy(asciiName, name), err);
}

/* Copy the string that is represented by the UConverterPlatform enum
 * @param platformString An output buffer
 * @param platform An enum representing a platform
 * @return the length of the copied string.
 */
static int32_t
ucnv_copyPlatformString(char *platformString, UConverterPlatform pltfrm)
{
    switch (pltfrm)
    {
    case UCNV_IBM:
        uprv_strcpy(platformString, "ibm-");
        return 4;
    case UCNV_UNKNOWN:
        break;
    }

    /* default to empty string */
    *platformString = 0;
    return 0;
}

/*Assumes a $platform-#codepage.$CONVERTER_FILE_EXTENSION scheme and calls
 *through createConverter*/
U_CAPI UConverter*   U_EXPORT2
ucnv_openCCSID (int32_t codepage,
                UConverterPlatform platform,
                UErrorCode * err)
{
    char myName[UCNV_MAX_CONVERTER_NAME_LENGTH];
    int32_t myNameLen;

    if (err == nullptr || U_FAILURE (*err))
        return nullptr;

    /* ucnv_copyPlatformString could return "ibm-" or "cp" */
    myNameLen = ucnv_copyPlatformString(myName, platform);
    T_CString_integerToString(myName + myNameLen, codepage, 10);

    return ucnv_createConverter(nullptr, myName, err);
}

/* Creating a temporary stack-based object that can be used in one thread, 
and created from a converter that is shared across threads.
*/

U_CAPI UConverter* U_EXPORT2
ucnv_safeClone(const UConverter* cnv, void *stackBuffer, int32_t *pBufferSize, UErrorCode *status)
{
    UConverter *localConverter, *allocatedConverter;
    int32_t stackBufferSize;
    int32_t bufferSizeNeeded;
    UErrorCode cbErr;
    UConverterToUnicodeArgs toUArgs = {
        sizeof(UConverterToUnicodeArgs),
            true,
            nullptr,
            nullptr,
            nullptr,
            nullptr,
            nullptr,
            nullptr
    };
    UConverterFromUnicodeArgs fromUArgs = {
        sizeof(UConverterFromUnicodeArgs),
            true,
            nullptr,
            nullptr,
            nullptr,
            nullptr,
            nullptr,
            nullptr
    };

    UTRACE_ENTRY_OC(UTRACE_UCNV_CLONE);

    if (status == nullptr || U_FAILURE(*status)){
        UTRACE_EXIT_STATUS(status? *status: U_ILLEGAL_ARGUMENT_ERROR);
        return nullptr;
    }

    if (cnv == nullptr) {
        *status = U_ILLEGAL_ARGUMENT_ERROR;
        UTRACE_EXIT_STATUS(*status);
        return nullptr;
    }

    UTRACE_DATA3(UTRACE_OPEN_CLOSE, "clone converter %s at %p into stackBuffer %p",
                                    ucnv_getName(cnv, status), cnv, stackBuffer);

    if (cnv->sharedData->impl->safeClone != nullptr) {
        /* call the custom safeClone function for sizing */
        bufferSizeNeeded = 0;
        cnv->sharedData->impl->safeClone(cnv, nullptr, &bufferSizeNeeded, status);
        if (U_FAILURE(*status)) {
            UTRACE_EXIT_STATUS(*status);
            return nullptr;
        }
    }
    else
    {
        /* inherent sizing */
        bufferSizeNeeded = sizeof(UConverter);
    }

    if (pBufferSize == nullptr) {
        stackBufferSize = 1;
        pBufferSize = &stackBufferSize;
    } else {
        stackBufferSize = *pBufferSize;
        if (stackBufferSize <= 0){ /* 'preflighting' request - set needed size into *pBufferSize */
            *pBufferSize = bufferSizeNeeded;
            UTRACE_EXIT_VALUE(bufferSizeNeeded);
            return nullptr;
        }
    }

    /* Adjust (if necessary) the stackBuffer pointer to be aligned correctly for a UConverter.
     * TODO(Jira ICU-20736) Redo this using std::align() once g++4.9 compatibility is no longer needed.
     */
    if (stackBuffer) {
        uintptr_t p = reinterpret_cast<uintptr_t>(stackBuffer);
        uintptr_t aligned_p = (p + alignof(UConverter) - 1) & ~(alignof(UConverter) - 1);
        ptrdiff_t pointerAdjustment = aligned_p - p;
        if (bufferSizeNeeded + pointerAdjustment <= stackBufferSize) {
            stackBuffer = reinterpret_cast<void *>(aligned_p);
            stackBufferSize -= static_cast<int32_t>(pointerAdjustment);
        } else {
            /* prevent using the stack buffer but keep the size > 0 so that we do not just preflight */
            stackBufferSize = 1;
        }
    }

    /* Now, see if we must allocate any memory */
    if (stackBufferSize < bufferSizeNeeded || stackBuffer == nullptr)
    {
        /* allocate one here...*/
        localConverter = allocatedConverter = (UConverter *) uprv_malloc (bufferSizeNeeded);

        if(localConverter == nullptr) {
            *status = U_MEMORY_ALLOCATION_ERROR;
            UTRACE_EXIT_STATUS(*status);
            return nullptr;
        }
        // If pBufferSize was nullptr as the input, pBufferSize is set to &stackBufferSize in this function.
        if (pBufferSize != &stackBufferSize) {
            *status = U_SAFECLONE_ALLOCATED_WARNING;
        }

        /* record the fact that memory was allocated */
        *pBufferSize = bufferSizeNeeded;
    } else {
        /* just use the stack buffer */
        localConverter = (UConverter*) stackBuffer;
        allocatedConverter = nullptr;
    }

    uprv_memset(localConverter, 0, bufferSizeNeeded);

    /* Copy initial state */
    uprv_memcpy(localConverter, cnv, sizeof(UConverter));
    localConverter->isCopyLocal = localConverter->isExtraLocal = false;

    /* copy the substitution string */
    if (cnv->subChars == (uint8_t *)cnv->subUChars) {
        localConverter->subChars = (uint8_t *)localConverter->subUChars;
    } else {
        localConverter->subChars = (uint8_t *)uprv_malloc(UCNV_ERROR_BUFFER_LENGTH * U_SIZEOF_UCHAR);
        if (localConverter->subChars == nullptr) {
            uprv_free(allocatedConverter);
            UTRACE_EXIT_STATUS(*status);
            return nullptr;
        }
        uprv_memcpy(localConverter->subChars, cnv->subChars, UCNV_ERROR_BUFFER_LENGTH * U_SIZEOF_UCHAR);
    }

    /* now either call the safeclone fcn or not */
    if (cnv->sharedData->impl->safeClone != nullptr) {
        /* call the custom safeClone function */
        localConverter = cnv->sharedData->impl->safeClone(cnv, localConverter, pBufferSize, status);
    }

    if(localConverter==nullptr || U_FAILURE(*status)) {
        if (allocatedConverter != nullptr && allocatedConverter->subChars != (uint8_t *)allocatedConverter->subUChars) {
            uprv_free(allocatedConverter->subChars);
        }
        uprv_free(allocatedConverter);
        UTRACE_EXIT_STATUS(*status);
        return nullptr;
    }

    /* increment refcount of shared data if needed */
    if (cnv->sharedData->isReferenceCounted) {
        ucnv_incrementRefCount(cnv->sharedData);
    }

    if(localConverter == (UConverter*)stackBuffer) {
        /* we're using user provided data - set to not destroy */
        localConverter->isCopyLocal = true;
    }

    /* allow callback functions to handle any memory allocation */
    toUArgs.converter = fromUArgs.converter = localConverter;
    cbErr = U_ZERO_ERROR;
    cnv->fromCharErrorBehaviour(cnv->toUContext, &toUArgs, nullptr, 0, UCNV_CLONE, &cbErr);
    cbErr = U_ZERO_ERROR;
    cnv->fromUCharErrorBehaviour(cnv->fromUContext, &fromUArgs, nullptr, 0, 0, UCNV_CLONE, &cbErr);

    UTRACE_EXIT_PTR_STATUS(localConverter, *status);
    return localConverter;
}

U_CAPI UConverter* U_EXPORT2
ucnv_clone(const UConverter* cnv, UErrorCode *status)
{
    return ucnv_safeClone(cnv, nullptr, nullptr, status);
}

/*Decreases the reference counter in the shared immutable section of the object
 *and frees the mutable part*/

U_CAPI void  U_EXPORT2
ucnv_close (UConverter * converter)
{
    UErrorCode errorCode = U_ZERO_ERROR;

    UTRACE_ENTRY_OC(UTRACE_UCNV_CLOSE);

    if (converter == nullptr)
    {
        UTRACE_EXIT();
        return;
    }

    UTRACE_DATA3(UTRACE_OPEN_CLOSE, "close converter %s at %p, isCopyLocal=%b",
        ucnv_getName(converter, &errorCode), converter, converter->isCopyLocal);

    /* In order to speed up the close, only call the callbacks when they have been changed.
    This performance check will only work when the callbacks are set within a shared library
    or from user code that statically links this code. */
    /* first, notify the callback functions that the converter is closed */
    if (converter->fromCharErrorBehaviour != UCNV_TO_U_DEFAULT_CALLBACK) {
        UConverterToUnicodeArgs toUArgs = {
            sizeof(UConverterToUnicodeArgs),
                true,
                nullptr,
                nullptr,
                nullptr,
                nullptr,
                nullptr,
                nullptr
        };

        toUArgs.converter = converter;
        errorCode = U_ZERO_ERROR;
        converter->fromCharErrorBehaviour(converter->toUContext, &toUArgs, nullptr, 0, UCNV_CLOSE, &errorCode);
    }
    if (converter->fromUCharErrorBehaviour != UCNV_FROM_U_DEFAULT_CALLBACK) {
        UConverterFromUnicodeArgs fromUArgs = {
            sizeof(UConverterFromUnicodeArgs),
                true,
                nullptr,
                nullptr,
                nullptr,
                nullptr,
                nullptr,
                nullptr
        };
        fromUArgs.converter = converter;
        errorCode = U_ZERO_ERROR;
        converter->fromUCharErrorBehaviour(converter->fromUContext, &fromUArgs, nullptr, 0, 0, UCNV_CLOSE, &errorCode);
    }

    if (converter->sharedData->impl->close != nullptr) {
        converter->sharedData->impl->close(converter);
    }

    if (converter->subChars != (uint8_t *)converter->subUChars) {
        uprv_free(converter->subChars);
    }

    if (converter->sharedData->isReferenceCounted) {
        ucnv_unloadSharedDataIfReady(converter->sharedData);
    }

    if(!converter->isCopyLocal){
        uprv_free(converter);
    }

    UTRACE_EXIT();
}

/*returns a single Name from the list, will return nullptr if out of bounds
 */
U_CAPI const char*   U_EXPORT2
ucnv_getAvailableName (int32_t n)
{
    if (0 <= n && n <= 0xffff) {
        UErrorCode err = U_ZERO_ERROR;
        const char *name = ucnv_bld_getAvailableConverter((uint16_t)n, &err);
        if (U_SUCCESS(err)) {
            return name;
        }
    }
    return nullptr;
}

U_CAPI int32_t   U_EXPORT2
ucnv_countAvailable ()
{
    UErrorCode err = U_ZERO_ERROR;
    return ucnv_bld_countAvailableConverters(&err);
}

U_CAPI void    U_EXPORT2
ucnv_getSubstChars (const UConverter * converter,
                    char *mySubChar,
                    int8_t * len,
                    UErrorCode * err)
{
    if (U_FAILURE (*err))
        return;

    if (converter->subCharLen <= 0) {
        /* Unicode string or empty string from ucnv_setSubstString(). */
        *len = 0;
        return;
    }

    if (*len < converter->subCharLen) /*not enough space in subChars */
    {
        *err = U_INDEX_OUTOFBOUNDS_ERROR;
        return;
    }

    uprv_memcpy (mySubChar, converter->subChars, converter->subCharLen);   /*fills in the subchars */
    *len = converter->subCharLen; /*store # of bytes copied to buffer */
}

U_CAPI void    U_EXPORT2
ucnv_setSubstChars (UConverter * converter,
                    const char *mySubChar,
                    int8_t len,
                    UErrorCode * err)
{
    if (U_FAILURE (*err))
        return;
    
    /*Makes sure that the subChar is within the codepages char length boundaries */
    if ((len > converter->sharedData->staticData->maxBytesPerChar)
     || (len < converter->sharedData->staticData->minBytesPerChar))
    {
        *err = U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }
    
    uprv_memcpy (converter->subChars, mySubChar, len); /*copies the subchars */
    converter->subCharLen = len;  /*sets the new len */

    /*
    * There is currently (2001Feb) no separate API to set/get subChar1.
    * In order to always have subChar written after it is explicitly set,
    * we set subChar1 to 0.
    */
    converter->subChar1 = 0;
}

U_CAPI void U_EXPORT2
ucnv_setSubstString(UConverter *cnv,
                    const char16_t *s,
                    int32_t length,
                    UErrorCode *err) {
    alignas(UConverter) char cloneBuffer[U_CNV_SAFECLONE_BUFFERSIZE];
    char chars[UCNV_ERROR_BUFFER_LENGTH];

    UConverter *clone;
    uint8_t *subChars;
    int32_t cloneSize, length8;

    /* Let the following functions check all arguments. */
    cloneSize = sizeof(cloneBuffer);
    clone = ucnv_safeClone(cnv, cloneBuffer, &cloneSize, err);
    ucnv_setFromUCallBack(clone, UCNV_FROM_U_CALLBACK_STOP, nullptr, nullptr, nullptr, err);
    length8 = ucnv_fromUChars(clone, chars, (int32_t)sizeof(chars), s, length, err);
    ucnv_close(clone);
    if (U_FAILURE(*err)) {
        return;
    }

    if (cnv->sharedData->impl->writeSub == nullptr
#if !UCONFIG_NO_LEGACY_CONVERSION
        || (cnv->sharedData->staticData->conversionType == UCNV_MBCS &&
         ucnv_MBCSGetType(cnv) != UCNV_EBCDIC_STATEFUL)
#endif
    ) {
        /* The converter is not stateful. Store the charset bytes as a fixed string. */
        subChars = (uint8_t *)chars;
    } else {
        /*
         * The converter has a non-default writeSub() function, indicating
         * that it is stateful.
         * Store the Unicode string for on-the-fly conversion for correct
         * state handling.
         */
        if (length > UCNV_ERROR_BUFFER_LENGTH) {
            /*
             * Should not occur. The converter should output at least one byte
             * per char16_t, which means that ucnv_fromUChars() should catch all
             * overflows.
             */
            *err = U_BUFFER_OVERFLOW_ERROR;
            return;
        }
        subChars = (uint8_t *)s;
        if (length < 0) {
            length = u_strlen(s);
        }
        length8 = length * U_SIZEOF_UCHAR;
    }

    /*
     * For storing the substitution string, select either the small buffer inside
     * UConverter or allocate a subChars buffer.
     */
    if (length8 > UCNV_MAX_SUBCHAR_LEN) {
        /* Use a separate buffer for the string. Outside UConverter to not make it too large. */
        if (cnv->subChars == (uint8_t *)cnv->subUChars) {
            /* Allocate a new buffer for the string. */
            cnv->subChars = (uint8_t *)uprv_malloc(UCNV_ERROR_BUFFER_LENGTH * U_SIZEOF_UCHAR);
            if (cnv->subChars == nullptr) {
                cnv->subChars = (uint8_t *)cnv->subUChars;
                *err = U_MEMORY_ALLOCATION_ERROR;
                return;
            }
            uprv_memset(cnv->subChars, 0, UCNV_ERROR_BUFFER_LENGTH * U_SIZEOF_UCHAR);
        }
    }

    /* Copy the substitution string into the UConverter or its subChars buffer. */
    if (length8 == 0) {
        cnv->subCharLen = 0;
    } else {
        uprv_memcpy(cnv->subChars, subChars, length8);
        if (subChars == (uint8_t *)chars) {
            cnv->subCharLen = (int8_t)length8;
        } else /* subChars == s */ {
            cnv->subCharLen = (int8_t)-length;
        }
    }

    /* See comment in ucnv_setSubstChars(). */
    cnv->subChar1 = 0;
}

/*resets the internal states of a converter
 *goal : have the same behaviour than a freshly created converter
 */
static void _reset(UConverter *converter, UConverterResetChoice choice,
                   UBool callCallback) {
    if(converter == nullptr) {
        return;
    }

    if(callCallback) {
        /* first, notify the callback functions that the converter is reset */
        UErrorCode errorCode;

        if(choice<=UCNV_RESET_TO_UNICODE && converter->fromCharErrorBehaviour != UCNV_TO_U_DEFAULT_CALLBACK) {
            UConverterToUnicodeArgs toUArgs = {
                sizeof(UConverterToUnicodeArgs),
                true,
                nullptr,
                nullptr,
                nullptr,
                nullptr,
                nullptr,
                nullptr
            };
            toUArgs.converter = converter;
            errorCode = U_ZERO_ERROR;
            converter->fromCharErrorBehaviour(converter->toUContext, &toUArgs, nullptr, 0, UCNV_RESET, &errorCode);
        }
        if(choice!=UCNV_RESET_TO_UNICODE && converter->fromUCharErrorBehaviour != UCNV_FROM_U_DEFAULT_CALLBACK) {
            UConverterFromUnicodeArgs fromUArgs = {
                sizeof(UConverterFromUnicodeArgs),
                true,
                nullptr,
                nullptr,
                nullptr,
                nullptr,
                nullptr,
                nullptr
            };
            fromUArgs.converter = converter;
            errorCode = U_ZERO_ERROR;
            converter->fromUCharErrorBehaviour(converter->fromUContext, &fromUArgs, nullptr, 0, 0, UCNV_RESET, &errorCode);
        }
    }

    /* now reset the converter itself */
    if(choice<=UCNV_RESET_TO_UNICODE) {
        converter->toUnicodeStatus = converter->sharedData->toUnicodeStatus;
        converter->mode = 0;
        converter->toULength = 0;
        converter->invalidCharLength = converter->UCharErrorBufferLength = 0;
        converter->preToULength = 0;
    }
    if(choice!=UCNV_RESET_TO_UNICODE) {
        converter->fromUnicodeStatus = 0;
        converter->fromUChar32 = 0;
        converter->invalidUCharLength = converter->charErrorBufferLength = 0;
        converter->preFromUFirstCP = U_SENTINEL;
        converter->preFromULength = 0;
    }

    if (converter->sharedData->impl->reset != nullptr) {
        /* call the custom reset function */
        converter->sharedData->impl->reset(converter, choice);
    }
}

U_CAPI void  U_EXPORT2
ucnv_reset(UConverter *converter)
{
    _reset(converter, UCNV_RESET_BOTH, true);
}

U_CAPI void  U_EXPORT2
ucnv_resetToUnicode(UConverter *converter)
{
    _reset(converter, UCNV_RESET_TO_UNICODE, true);
}

U_CAPI void  U_EXPORT2
ucnv_resetFromUnicode(UConverter *converter)
{
    _reset(converter, UCNV_RESET_FROM_UNICODE, true);
}

U_CAPI int8_t   U_EXPORT2
ucnv_getMaxCharSize (const UConverter * converter)
{
    return converter->maxBytesPerUChar;
}


U_CAPI int8_t   U_EXPORT2
ucnv_getMinCharSize (const UConverter * converter)
{
    return converter->sharedData->staticData->minBytesPerChar;
}

U_CAPI const char*   U_EXPORT2
ucnv_getName (const UConverter * converter, UErrorCode * err)
     
{
    if (U_FAILURE (*err))
        return nullptr;
    if(converter->sharedData->impl->getName){
        const char* temp= converter->sharedData->impl->getName(converter);
        if(temp)
            return temp;
    }
    return converter->sharedData->staticData->name;
}

U_CAPI int32_t U_EXPORT2
ucnv_getCCSID(const UConverter * converter,
              UErrorCode * err)
{
    int32_t ccsid;
    if (U_FAILURE (*err))
        return -1;

    ccsid = converter->sharedData->staticData->codepage;
    if (ccsid == 0) {
        /* Rare case. This is for cases like gb18030,
        which doesn't have an IBM canonical name, but does have an IBM alias. */
        const char *standardName = ucnv_getStandardName(ucnv_getName(converter, err), "IBM", err);
        if (U_SUCCESS(*err) && standardName) {
            const char *ccsidStr = uprv_strchr(standardName, '-');
            if (ccsidStr) {
                ccsid = (int32_t)atol(ccsidStr+1);  /* +1 to skip '-' */
            }
        }
    }
    return ccsid;
}


U_CAPI UConverterPlatform   U_EXPORT2
ucnv_getPlatform (const UConverter * converter,
                                      UErrorCode * err)
{
    if (U_FAILURE (*err))
        return UCNV_UNKNOWN;

    return (UConverterPlatform)converter->sharedData->staticData->platform;
}

U_CAPI void U_EXPORT2
    ucnv_getToUCallBack (const UConverter * converter,
                         UConverterToUCallback *action,
                         const void **context)
{
    *action = converter->fromCharErrorBehaviour;
    *context = converter->toUContext;
}

U_CAPI void U_EXPORT2
    ucnv_getFromUCallBack (const UConverter * converter,
                           UConverterFromUCallback *action,
                           const void **context)
{
    *action = converter->fromUCharErrorBehaviour;
    *context = converter->fromUContext;
}

U_CAPI void    U_EXPORT2
ucnv_setToUCallBack (UConverter * converter,
                            UConverterToUCallback newAction,
                            const void* newContext,
                            UConverterToUCallback *oldAction,
                            const void** oldContext,
                            UErrorCode * err)
{
    if (U_FAILURE (*err))
        return;
    if (oldAction) *oldAction = converter->fromCharErrorBehaviour;
    converter->fromCharErrorBehaviour = newAction;
    if (oldContext) *oldContext = converter->toUContext;
    converter->toUContext = newContext;
}

U_CAPI void  U_EXPORT2
ucnv_setFromUCallBack (UConverter * converter,
                            UConverterFromUCallback newAction,
                            const void* newContext,
                            UConverterFromUCallback *oldAction,
                            const void** oldContext,
                            UErrorCode * err)
{
    if (U_FAILURE (*err))
        return;
    if (oldAction) *oldAction = converter->fromUCharErrorBehaviour;
    converter->fromUCharErrorBehaviour = newAction;
    if (oldContext) *oldContext = converter->fromUContext;
    converter->fromUContext = newContext;
}

static void
_updateOffsets(int32_t *offsets, int32_t length,
               int32_t sourceIndex, int32_t errorInputLength) {
    int32_t *limit;
    int32_t delta, offset;

    if(sourceIndex>=0) {
        /*
         * adjust each offset by adding the previous sourceIndex
         * minus the length of the input sequence that caused an
         * error, if any
         */
        delta=sourceIndex-errorInputLength;
    } else {
        /*
         * set each offset to -1 because this conversion function
         * does not handle offsets
         */
        delta=-1;
    }

    limit=offsets+length;
    if(delta==0) {
        /* most common case, nothing to do */
    } else if(delta>0) {
        /* add the delta to each offset (but not if the offset is <0) */
        while(offsets<limit) {
            offset=*offsets;
            if(offset>=0) {
                *offsets=offset+delta;
            }
            ++offsets;
        }
    } else /* delta<0 */ {
        /*
         * set each offset to -1 because this conversion function
         * does not handle offsets
         * or the error input sequence started in a previous buffer
         */
        while(offsets<limit) {
            *offsets++=-1;
        }
    }
}

/* ucnv_fromUnicode --------------------------------------------------------- */

/*
 * Implementation note for m:n conversions
 *
 * While collecting source units to find the longest match for m:n conversion,
 * some source units may need to be stored for a partial match.
 * When a second buffer does not yield a match on all of the previously stored
 * source units, then they must be "replayed", i.e., fed back into the converter.
 *
 * The code relies on the fact that replaying will not nest -
 * converting a replay buffer will not result in a replay.
 * This is because a replay is necessary only after the _continuation_ of a
 * partial match failed, but a replay buffer is converted as a whole.
 * It may result in some of its units being stored again for a partial match,
 * but there will not be a continuation _during_ the replay which could fail.
 *
 * It is conceivable that a callback function could call the converter
 * recursively in a way that causes another replay to be stored, but that
 * would be an error in the callback function.
 * Such violations will cause assertion failures in a debug build,
 * and wrong output, but they will not cause a crash.
 */

static void
_fromUnicodeWithCallback(UConverterFromUnicodeArgs *pArgs, UErrorCode *err) {
    UConverterFromUnicode fromUnicode;
    UConverter *cnv;
    const char16_t *s;
    char *t;
    int32_t *offsets;
    int32_t sourceIndex;
    int32_t errorInputLength;
    UBool converterSawEndOfInput, calledCallback;

    /* variables for m:n conversion */
    char16_t replay[UCNV_EXT_MAX_UCHARS];
    const char16_t *realSource, *realSourceLimit;
    int32_t realSourceIndex;
    UBool realFlush;

    cnv=pArgs->converter;
    s=pArgs->source;
    t=pArgs->target;
    offsets=pArgs->offsets;

    /* get the converter implementation function */
    sourceIndex=0;
    if(offsets==nullptr) {
        fromUnicode=cnv->sharedData->impl->fromUnicode;
    } else {
        fromUnicode=cnv->sharedData->impl->fromUnicodeWithOffsets;
        if(fromUnicode==nullptr) {
            /* there is no WithOffsets implementation */
            fromUnicode=cnv->sharedData->impl->fromUnicode;
            /* we will write -1 for each offset */
            sourceIndex=-1;
        }
    }

    if(cnv->preFromULength>=0) {
        /* normal mode */
        realSource=nullptr;

        /* avoid compiler warnings - not otherwise necessary, and the values do not matter */
        realSourceLimit=nullptr;
        realFlush=false;
        realSourceIndex=0;
    } else {
        /*
         * Previous m:n conversion stored source units from a partial match
         * and failed to consume all of them.
         * We need to "replay" them from a temporary buffer and convert them first.
         */
        realSource=pArgs->source;
        realSourceLimit=pArgs->sourceLimit;
        realFlush=pArgs->flush;
        realSourceIndex=sourceIndex;

        uprv_memcpy(replay, cnv->preFromU, -cnv->preFromULength*U_SIZEOF_UCHAR);
        pArgs->source=replay;
        pArgs->sourceLimit=replay-cnv->preFromULength;
        pArgs->flush=false;
        sourceIndex=-1;

        cnv->preFromULength=0;
    }

    /*
     * loop for conversion and error handling
     *
     * loop {
     *   convert
     *   loop {
     *     update offsets
     *     handle end of input
     *     handle errors/call callback
     *   }
     * }
     */
    for(;;) {
        if(U_SUCCESS(*err)) {
            /* convert */
            fromUnicode(pArgs, err);

            /*
             * set a flag for whether the converter
             * successfully processed the end of the input
             *
             * need not check cnv->preFromULength==0 because a replay (<0) will cause
             * s<sourceLimit before converterSawEndOfInput is checked
             */
            converterSawEndOfInput=
                static_cast<UBool>(U_SUCCESS(*err) &&
                        pArgs->flush && pArgs->source==pArgs->sourceLimit &&
                        cnv->fromUChar32==0);
        } else {
            /* handle error from ucnv_convertEx() */
            converterSawEndOfInput=false;
        }

        /* no callback called yet for this iteration */
        calledCallback=false;

        /* no sourceIndex adjustment for conversion, only for callback output */
        errorInputLength=0;

        /*
         * loop for offsets and error handling
         *
         * iterates at most 3 times:
         * 1. to clean up after the conversion function
         * 2. after the callback
         * 3. after the callback again if there was truncated input
         */
        for(;;) {
            /* update offsets if we write any */
            if(offsets!=nullptr) {
                int32_t length = static_cast<int32_t>(pArgs->target - t);
                if(length>0) {
                    _updateOffsets(offsets, length, sourceIndex, errorInputLength);

                    /*
                     * if a converter handles offsets and updates the offsets
                     * pointer at the end, then pArgs->offset should not change
                     * here;
                     * however, some converters do not handle offsets at all
                     * (sourceIndex<0) or may not update the offsets pointer
                     */
                    pArgs->offsets=offsets+=length;
                }

                if(sourceIndex>=0) {
                    sourceIndex += static_cast<int32_t>(pArgs->source - s);
                }
            }

            if(cnv->preFromULength<0) {
                /*
                 * switch the source to new replay units (cannot occur while replaying)
                 * after offset handling and before end-of-input and callback handling
                 */
                if(realSource==nullptr) {
                    realSource=pArgs->source;
                    realSourceLimit=pArgs->sourceLimit;
                    realFlush=pArgs->flush;
                    realSourceIndex=sourceIndex;

                    uprv_memcpy(replay, cnv->preFromU, -cnv->preFromULength*U_SIZEOF_UCHAR);
                    pArgs->source=replay;
                    pArgs->sourceLimit=replay-cnv->preFromULength;
                    pArgs->flush=false;
                    if((sourceIndex+=cnv->preFromULength)<0) {
                        sourceIndex=-1;
                    }

                    cnv->preFromULength=0;
                } else {
                    /* see implementation note before _fromUnicodeWithCallback() */
                    U_ASSERT(realSource==nullptr);
                    *err=U_INTERNAL_PROGRAM_ERROR;
                }
            }

            /* update pointers */
            s=pArgs->source;
            t=pArgs->target;

            if(U_SUCCESS(*err)) {
                if(s<pArgs->sourceLimit) {
                    /*
                     * continue with the conversion loop while there is still input left
                     * (continue converting by breaking out of only the inner loop)
                     */
                    break;
                } else if(realSource!=nullptr) {
                    /* switch back from replaying to the real source and continue */
                    pArgs->source=realSource;
                    pArgs->sourceLimit=realSourceLimit;
                    pArgs->flush=realFlush;
                    sourceIndex=realSourceIndex;

                    realSource=nullptr;
                    break;
                } else if(pArgs->flush && cnv->fromUChar32!=0) {
                    /*
                     * the entire input stream is consumed
                     * and there is a partial, truncated input sequence left
                     */

                    /* inject an error and continue with callback handling */
                    *err=U_TRUNCATED_CHAR_FOUND;
                    calledCallback=false; /* new error condition */
                } else {
                    /* input consumed */
                    if(pArgs->flush) {
                        /*
                         * return to the conversion loop once more if the flush
                         * flag is set and the conversion function has not
                         * successfully processed the end of the input yet
                         *
                         * (continue converting by breaking out of only the inner loop)
                         */
                        if(!converterSawEndOfInput) {
                            break;
                        }

                        /* reset the converter without calling the callback function */
                        _reset(cnv, UCNV_RESET_FROM_UNICODE, false);
                    }

                    /* done successfully */
                    return;
                }
            }

            /* U_FAILURE(*err) */
            {
                UErrorCode e;

                if( calledCallback ||
                    (e=*err)==U_BUFFER_OVERFLOW_ERROR ||
                    (e!=U_INVALID_CHAR_FOUND &&
                     e!=U_ILLEGAL_CHAR_FOUND &&
                     e!=U_TRUNCATED_CHAR_FOUND)
                ) {
                    /*
                     * the callback did not or cannot resolve the error:
                     * set output pointers and return
                     *
                     * the check for buffer overflow is redundant but it is
                     * a high-runner case and hopefully documents the intent
                     * well
                     *
                     * if we were replaying, then the replay buffer must be
                     * copied back into the UConverter
                     * and the real arguments must be restored
                     */
                    if(realSource!=nullptr) {
                        int32_t length;

                        U_ASSERT(cnv->preFromULength==0);

                        length = static_cast<int32_t>(pArgs->sourceLimit - pArgs->source);
                        if(length>0) {
                            u_memcpy(cnv->preFromU, pArgs->source, length);
                            cnv->preFromULength = static_cast<int8_t>(-length);
                        }

                        pArgs->source=realSource;
                        pArgs->sourceLimit=realSourceLimit;
                        pArgs->flush=realFlush;
                    }

                    return;
                }
            }

            /* callback handling */
            {
                UChar32 codePoint;

                /* get and write the code point */
                codePoint=cnv->fromUChar32;
                errorInputLength=0;
                U16_APPEND_UNSAFE(cnv->invalidUCharBuffer, errorInputLength, codePoint);
                cnv->invalidUCharLength = static_cast<int8_t>(errorInputLength);

                /* set the converter state to deal with the next character */
                cnv->fromUChar32=0;

                /* call the callback function */
                cnv->fromUCharErrorBehaviour(cnv->fromUContext, pArgs,
                    cnv->invalidUCharBuffer, errorInputLength, codePoint,
                    *err==U_INVALID_CHAR_FOUND ? UCNV_UNASSIGNED : UCNV_ILLEGAL,
                    err);
            }

            /*
             * loop back to the offset handling
             *
             * this flag will indicate after offset handling
             * that a callback was called;
             * if the callback did not resolve the error, then we return
             */
            calledCallback=true;
        }
    }
}

/*
 * Output the fromUnicode overflow buffer.
 * Call this function if(cnv->charErrorBufferLength>0).
 * @return true if overflow
 */
static UBool
ucnv_outputOverflowFromUnicode(UConverter *cnv,
                               char **target, const char *targetLimit,
                               int32_t **pOffsets,
                               UErrorCode *err) {
    int32_t *offsets;
    char *overflow, *t;
    int32_t i, length;

    t=*target;
    if(pOffsets!=nullptr) {
        offsets=*pOffsets;
    } else {
        offsets=nullptr;
    }

    overflow = reinterpret_cast<char*>(cnv->charErrorBuffer);
    length=cnv->charErrorBufferLength;
    i=0;
    while(i<length) {
        if(t==targetLimit) {
            /* the overflow buffer contains too much, keep the rest */
            int32_t j=0;

            do {
                overflow[j++]=overflow[i++];
            } while(i<length);

            cnv->charErrorBufferLength = static_cast<int8_t>(j);
            *target=t;
            if(offsets!=nullptr) {
                *pOffsets=offsets;
            }
            *err=U_BUFFER_OVERFLOW_ERROR;
            return true;
        }

        /* copy the overflow contents to the target */
        *t++=overflow[i++];
        if(offsets!=nullptr) {
            *offsets++=-1; /* no source index available for old output */
        }
    }

    /* the overflow buffer is completely copied to the target */
    cnv->charErrorBufferLength=0;
    *target=t;
    if(offsets!=nullptr) {
        *pOffsets=offsets;
    }
    return false;
}

U_CAPI void U_EXPORT2
ucnv_fromUnicode(UConverter *cnv,
                 char **target, const char *targetLimit,
                 const char16_t **source, const char16_t *sourceLimit,
                 int32_t *offsets,
                 UBool flush,
                 UErrorCode *err) {
    UConverterFromUnicodeArgs args;
    const char16_t *s;
    char *t;

    /* check parameters */
    if(err==nullptr || U_FAILURE(*err)) {
        return;
    }

    if(cnv==nullptr || target==nullptr || source==nullptr) {
        *err=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }

    s=*source;
    t=*target;

    if ((const void *)U_MAX_PTR(sourceLimit) == (const void *)sourceLimit) {
        /*
        Prevent code from going into an infinite loop in case we do hit this
        limit. The limit pointer is expected to be on a char16_t * boundary.
        This also prevents the next argument check from failing.
        */
        sourceLimit = (const char16_t *)(((const char *)sourceLimit) - 1);
    }

    /*
     * All these conditions should never happen.
     *
     * 1) Make sure that the limits are >= to the address source or target
     *
     * 2) Make sure that the buffer sizes do not exceed the number range for
     * int32_t because some functions use the size (in units or bytes)
     * rather than comparing pointers, and because offsets are int32_t values.
     *
     * size_t is guaranteed to be unsigned and large enough for the job.
     *
     * Return with an error instead of adjusting the limits because we would
     * not be able to maintain the semantics that either the source must be
     * consumed or the target filled (unless an error occurs).
     * An adjustment would be targetLimit=t+0x7fffffff; for example.
     *
     * 3) Make sure that the user didn't incorrectly cast a char16_t * pointer
     * to a char * pointer and provide an incomplete char16_t code unit.
     */
    if (sourceLimit<s || targetLimit<t ||
        ((size_t)(sourceLimit-s)>(size_t)0x3fffffff && sourceLimit>s) ||
        ((size_t)(targetLimit-t)>(size_t)0x7fffffff && targetLimit>t) ||
        (((const char *)sourceLimit-(const char *)s) & 1) != 0)
    {
        *err=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }
    
    /* output the target overflow buffer */
    if( cnv->charErrorBufferLength>0 &&
        ucnv_outputOverflowFromUnicode(cnv, target, targetLimit, &offsets, err)
    ) {
        /* U_BUFFER_OVERFLOW_ERROR */
        return;
    }
    /* *target may have moved, therefore stop using t */

    if(!flush && s==sourceLimit && cnv->preFromULength>=0) {
        /* the overflow buffer is emptied and there is no new input: we are done */
        return;
    }

    /*
     * Do not simply return with a buffer overflow error if
     * !flush && t==targetLimit
     * because it is possible that the source will not generate any output.
     * For example, the skip callback may be called;
     * it does not output anything.
     */

    /* prepare the converter arguments */
    args.converter=cnv;
    args.flush=flush;
    args.offsets=offsets;
    args.source=s;
    args.sourceLimit=sourceLimit;
    args.target=*target;
    args.targetLimit=targetLimit;
    args.size=sizeof(args);

    _fromUnicodeWithCallback(&args, err);

    *source=args.source;
    *target=args.target;
}

/* ucnv_toUnicode() --------------------------------------------------------- */

static void
_toUnicodeWithCallback(UConverterToUnicodeArgs *pArgs, UErrorCode *err) {
    UConverterToUnicode toUnicode;
    UConverter *cnv;
    const char *s;
    char16_t *t;
    int32_t *offsets;
    int32_t sourceIndex;
    int32_t errorInputLength;
    UBool converterSawEndOfInput, calledCallback;

    /* variables for m:n conversion */
    char replay[UCNV_EXT_MAX_BYTES];
    const char *realSource, *realSourceLimit;
    int32_t realSourceIndex;
    UBool realFlush;

    cnv=pArgs->converter;
    s=pArgs->source;
    t=pArgs->target;
    offsets=pArgs->offsets;

    /* get the converter implementation function */
    sourceIndex=0;
    if(offsets==nullptr) {
        toUnicode=cnv->sharedData->impl->toUnicode;
    } else {
        toUnicode=cnv->sharedData->impl->toUnicodeWithOffsets;
        if(toUnicode==nullptr) {
            /* there is no WithOffsets implementation */
            toUnicode=cnv->sharedData->impl->toUnicode;
            /* we will write -1 for each offset */
            sourceIndex=-1;
        }
    }

    if(cnv->preToULength>=0) {
        /* normal mode */
        realSource=nullptr;

        /* avoid compiler warnings - not otherwise necessary, and the values do not matter */
        realSourceLimit=nullptr;
        realFlush=false;
        realSourceIndex=0;
    } else {
        /*
         * Previous m:n conversion stored source units from a partial match
         * and failed to consume all of them.
         * We need to "replay" them from a temporary buffer and convert them first.
         */
        realSource=pArgs->source;
        realSourceLimit=pArgs->sourceLimit;
        realFlush=pArgs->flush;
        realSourceIndex=sourceIndex;

        uprv_memcpy(replay, cnv->preToU, -cnv->preToULength);
        pArgs->source=replay;
        pArgs->sourceLimit=replay-cnv->preToULength;
        pArgs->flush=false;
        sourceIndex=-1;

        cnv->preToULength=0;
    }

    /*
     * loop for conversion and error handling
     *
     * loop {
     *   convert
     *   loop {
     *     update offsets
     *     handle end of input
     *     handle errors/call callback
     *   }
     * }
     */
    for(;;) {
        if(U_SUCCESS(*err)) {
            /* convert */
            toUnicode(pArgs, err);

            /*
             * set a flag for whether the converter
             * successfully processed the end of the input
             *
             * need not check cnv->preToULength==0 because a replay (<0) will cause
             * s<sourceLimit before converterSawEndOfInput is checked
             */
            converterSawEndOfInput=
                static_cast<UBool>(U_SUCCESS(*err) &&
                        pArgs->flush && pArgs->source==pArgs->sourceLimit &&
                        cnv->toULength==0);
        } else {
            /* handle error from getNextUChar() or ucnv_convertEx() */
            converterSawEndOfInput=false;
        }

        /* no callback called yet for this iteration */
        calledCallback=false;

        /* no sourceIndex adjustment for conversion, only for callback output */
        errorInputLength=0;

        /*
         * loop for offsets and error handling
         *
         * iterates at most 3 times:
         * 1. to clean up after the conversion function
         * 2. after the callback
         * 3. after the callback again if there was truncated input
         */
        for(;;) {
            /* update offsets if we write any */
            if(offsets!=nullptr) {
                int32_t length = static_cast<int32_t>(pArgs->target - t);
                if(length>0) {
                    _updateOffsets(offsets, length, sourceIndex, errorInputLength);

                    /*
                     * if a converter handles offsets and updates the offsets
                     * pointer at the end, then pArgs->offset should not change
                     * here;
                     * however, some converters do not handle offsets at all
                     * (sourceIndex<0) or may not update the offsets pointer
                     */
                    pArgs->offsets=offsets+=length;
                }

                if(sourceIndex>=0) {
                    sourceIndex += static_cast<int32_t>(pArgs->source - s);
                }
            }

            if(cnv->preToULength<0) {
                /*
                 * switch the source to new replay units (cannot occur while replaying)
                 * after offset handling and before end-of-input and callback handling
                 */
                if(realSource==nullptr) {
                    realSource=pArgs->source;
                    realSourceLimit=pArgs->sourceLimit;
                    realFlush=pArgs->flush;
                    realSourceIndex=sourceIndex;

                    uprv_memcpy(replay, cnv->preToU, -cnv->preToULength);
                    pArgs->source=replay;
                    pArgs->sourceLimit=replay-cnv->preToULength;
                    pArgs->flush=false;
                    if((sourceIndex+=cnv->preToULength)<0) {
                        sourceIndex=-1;
                    }

                    cnv->preToULength=0;
                } else {
                    /* see implementation note before _fromUnicodeWithCallback() */
                    U_ASSERT(realSource==nullptr);
                    *err=U_INTERNAL_PROGRAM_ERROR;
                }
            }

            /* update pointers */
            s=pArgs->source;
            t=pArgs->target;

            if(U_SUCCESS(*err)) {
                if(s<pArgs->sourceLimit) {
                    /*
                     * continue with the conversion loop while there is still input left
                     * (continue converting by breaking out of only the inner loop)
                     */
                    break;
                } else if(realSource!=nullptr) {
                    /* switch back from replaying to the real source and continue */
                    pArgs->source=realSource;
                    pArgs->sourceLimit=realSourceLimit;
                    pArgs->flush=realFlush;
                    sourceIndex=realSourceIndex;

                    realSource=nullptr;
                    break;
                } else if(pArgs->flush && cnv->toULength>0) {
                    /*
                     * the entire input stream is consumed
                     * and there is a partial, truncated input sequence left
                     */

                    /* inject an error and continue with callback handling */
                    *err=U_TRUNCATED_CHAR_FOUND;
                    calledCallback=false; /* new error condition */
                } else {
                    /* input consumed */
                    if(pArgs->flush) {
                        /*
                         * return to the conversion loop once more if the flush
                         * flag is set and the conversion function has not
                         * successfully processed the end of the input yet
                         *
                         * (continue converting by breaking out of only the inner loop)
                         */
                        if(!converterSawEndOfInput) {
                            break;
                        }

                        /* reset the converter without calling the callback function */
                        _reset(cnv, UCNV_RESET_TO_UNICODE, false);
                    }

                    /* done successfully */
                    return;
                }
            }

            /* U_FAILURE(*err) */
            {
                UErrorCode e;

                if( calledCallback ||
                    (e=*err)==U_BUFFER_OVERFLOW_ERROR ||
                    (e!=U_INVALID_CHAR_FOUND &&
                     e!=U_ILLEGAL_CHAR_FOUND &&
                     e!=U_TRUNCATED_CHAR_FOUND &&
                     e!=U_ILLEGAL_ESCAPE_SEQUENCE &&
                     e!=U_UNSUPPORTED_ESCAPE_SEQUENCE)
                ) {
                    /*
                     * the callback did not or cannot resolve the error:
                     * set output pointers and return
                     *
                     * the check for buffer overflow is redundant but it is
                     * a high-runner case and hopefully documents the intent
                     * well
                     *
                     * if we were replaying, then the replay buffer must be
                     * copied back into the UConverter
                     * and the real arguments must be restored
                     */
                    if(realSource!=nullptr) {
                        int32_t length;

                        U_ASSERT(cnv->preToULength==0);

                        length = static_cast<int32_t>(pArgs->sourceLimit - pArgs->source);
                        if(length>0) {
                            uprv_memcpy(cnv->preToU, pArgs->source, length);
                            cnv->preToULength = static_cast<int8_t>(-length);
                        }

                        pArgs->source=realSource;
                        pArgs->sourceLimit=realSourceLimit;
                        pArgs->flush=realFlush;
                    }

                    return;
                }
            }

            /* copy toUBytes[] to invalidCharBuffer[] */
            errorInputLength=cnv->invalidCharLength=cnv->toULength;
            if(errorInputLength>0) {
                uprv_memcpy(cnv->invalidCharBuffer, cnv->toUBytes, errorInputLength);
            }

            /* set the converter state to deal with the next character */
            cnv->toULength=0;

            /* call the callback function */
            if(cnv->toUCallbackReason==UCNV_ILLEGAL && *err==U_INVALID_CHAR_FOUND) {
                cnv->toUCallbackReason = UCNV_UNASSIGNED;
            }
            cnv->fromCharErrorBehaviour(cnv->toUContext, pArgs,
                cnv->invalidCharBuffer, errorInputLength,
                cnv->toUCallbackReason,
                err);
            cnv->toUCallbackReason = UCNV_ILLEGAL; /* reset to default value */

            /*
             * loop back to the offset handling
             *
             * this flag will indicate after offset handling
             * that a callback was called;
             * if the callback did not resolve the error, then we return
             */
            calledCallback=true;
        }
    }
}

/*
 * Output the toUnicode overflow buffer.
 * Call this function if(cnv->UCharErrorBufferLength>0).
 * @return true if overflow
 */
static UBool
ucnv_outputOverflowToUnicode(UConverter *cnv,
                             char16_t **target, const char16_t *targetLimit,
                             int32_t **pOffsets,
                             UErrorCode *err) {
    int32_t *offsets;
    char16_t *overflow, *t;
    int32_t i, length;

    t=*target;
    if(pOffsets!=nullptr) {
        offsets=*pOffsets;
    } else {
        offsets=nullptr;
    }

    overflow=cnv->UCharErrorBuffer;
    length=cnv->UCharErrorBufferLength;
    i=0;
    while(i<length) {
        if(t==targetLimit) {
            /* the overflow buffer contains too much, keep the rest */
            int32_t j=0;

            do {
                overflow[j++]=overflow[i++];
            } while(i<length);

            cnv->UCharErrorBufferLength = static_cast<int8_t>(j);
            *target=t;
            if(offsets!=nullptr) {
                *pOffsets=offsets;
            }
            *err=U_BUFFER_OVERFLOW_ERROR;
            return true;
        }

        /* copy the overflow contents to the target */
        *t++=overflow[i++];
        if(offsets!=nullptr) {
            *offsets++=-1; /* no source index available for old output */
        }
    }

    /* the overflow buffer is completely copied to the target */
    cnv->UCharErrorBufferLength=0;
    *target=t;
    if(offsets!=nullptr) {
        *pOffsets=offsets;
    }
    return false;
}

U_CAPI void U_EXPORT2
ucnv_toUnicode(UConverter *cnv,
               char16_t **target, const char16_t *targetLimit,
               const char **source, const char *sourceLimit,
               int32_t *offsets,
               UBool flush,
               UErrorCode *err) {
    UConverterToUnicodeArgs args;
    const char *s;
    char16_t *t;

    /* check parameters */
    if(err==nullptr || U_FAILURE(*err)) {
        return;
    }

    if(cnv==nullptr || target==nullptr || source==nullptr) {
        *err=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }

    s=*source;
    t=*target;

    if ((const void *)U_MAX_PTR(targetLimit) == (const void *)targetLimit) {
        /*
        Prevent code from going into an infinite loop in case we do hit this
        limit. The limit pointer is expected to be on a char16_t * boundary.
        This also prevents the next argument check from failing.
        */
        targetLimit = (const char16_t *)(((const char *)targetLimit) - 1);
    }

    /*
     * All these conditions should never happen.
     *
     * 1) Make sure that the limits are >= to the address source or target
     *
     * 2) Make sure that the buffer sizes do not exceed the number range for
     * int32_t because some functions use the size (in units or bytes)
     * rather than comparing pointers, and because offsets are int32_t values.
     *
     * size_t is guaranteed to be unsigned and large enough for the job.
     *
     * Return with an error instead of adjusting the limits because we would
     * not be able to maintain the semantics that either the source must be
     * consumed or the target filled (unless an error occurs).
     * An adjustment would be sourceLimit=t+0x7fffffff; for example.
     *
     * 3) Make sure that the user didn't incorrectly cast a char16_t * pointer
     * to a char * pointer and provide an incomplete char16_t code unit.
     */
    if (sourceLimit<s || targetLimit<t ||
        ((size_t)(sourceLimit-s)>(size_t)0x7fffffff && sourceLimit>s) ||
        ((size_t)(targetLimit-t)>(size_t)0x3fffffff && targetLimit>t) ||
        (((const char *)targetLimit-(const char *)t) & 1) != 0
    ) {
        *err=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }
    
    /* output the target overflow buffer */
    if( cnv->UCharErrorBufferLength>0 &&
        ucnv_outputOverflowToUnicode(cnv, target, targetLimit, &offsets, err)
    ) {
        /* U_BUFFER_OVERFLOW_ERROR */
        return;
    }
    /* *target may have moved, therefore stop using t */

    if(!flush && s==sourceLimit && cnv->preToULength>=0) {
        /* the overflow buffer is emptied and there is no new input: we are done */
        return;
    }

    /*
     * Do not simply return with a buffer overflow error if
     * !flush && t==targetLimit
     * because it is possible that the source will not generate any output.
     * For example, the skip callback may be called;
     * it does not output anything.
     */

    /* prepare the converter arguments */
    args.converter=cnv;
    args.flush=flush;
    args.offsets=offsets;
    args.source=s;
    args.sourceLimit=sourceLimit;
    args.target=*target;
    args.targetLimit=targetLimit;
    args.size=sizeof(args);

    _toUnicodeWithCallback(&args, err);

    *source=args.source;
    *target=args.target;
}

/* ucnv_to/fromUChars() ----------------------------------------------------- */

U_CAPI int32_t U_EXPORT2
ucnv_fromUChars(UConverter *cnv,
                char *dest, int32_t destCapacity,
                const char16_t *src, int32_t srcLength,
                UErrorCode *pErrorCode) {
    const char16_t *srcLimit;
    char *originalDest, *destLimit;
    int32_t destLength;

    /* check arguments */
    if(pErrorCode==nullptr || U_FAILURE(*pErrorCode)) {
        return 0;
    }

    if( cnv==nullptr ||
        destCapacity<0 || (destCapacity>0 && dest==nullptr) ||
        srcLength<-1 || (srcLength!=0 && src==nullptr)
    ) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }

    /* initialize */
    ucnv_resetFromUnicode(cnv);
    originalDest=dest;
    if(srcLength==-1) {
        srcLength=u_strlen(src);
    }
    if(srcLength>0) {
        srcLimit=src+srcLength;
        destCapacity=pinCapacity(dest, destCapacity);
        destLimit=dest+destCapacity;

        /* perform the conversion */
        ucnv_fromUnicode(cnv, &dest, destLimit, &src, srcLimit, nullptr, true, pErrorCode);
        destLength=(int32_t)(dest-originalDest);

        /* if an overflow occurs, then get the preflighting length */
        if(*pErrorCode==U_BUFFER_OVERFLOW_ERROR) {
            char buffer[1024];

            destLimit=buffer+sizeof(buffer);
            do {
                dest=buffer;
                *pErrorCode=U_ZERO_ERROR;
                ucnv_fromUnicode(cnv, &dest, destLimit, &src, srcLimit, nullptr, true, pErrorCode);
                destLength+=(int32_t)(dest-buffer);
            } while(*pErrorCode==U_BUFFER_OVERFLOW_ERROR);
        }
    } else {
        destLength=0;
    }

    return u_terminateChars(originalDest, destCapacity, destLength, pErrorCode);
}

U_CAPI int32_t U_EXPORT2
ucnv_toUChars(UConverter *cnv,
              char16_t *dest, int32_t destCapacity,
              const char *src, int32_t srcLength,
              UErrorCode *pErrorCode) {
    const char *srcLimit;
    char16_t *originalDest, *destLimit;
    int32_t destLength;

    /* check arguments */
    if(pErrorCode==nullptr || U_FAILURE(*pErrorCode)) {
        return 0;
    }

    if( cnv==nullptr ||
        destCapacity<0 || (destCapacity>0 && dest==nullptr) ||
        srcLength<-1 || (srcLength!=0 && src==nullptr))
    {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }

    /* initialize */
    ucnv_resetToUnicode(cnv);
    originalDest=dest;
    if(srcLength==-1) {
        srcLength=(int32_t)uprv_strlen(src);
    }
    if(srcLength>0) {
        srcLimit=src+srcLength;
        destCapacity=pinCapacity(dest, destCapacity);
        destLimit=dest+destCapacity;

        /* perform the conversion */
        ucnv_toUnicode(cnv, &dest, destLimit, &src, srcLimit, nullptr, true, pErrorCode);
        destLength=(int32_t)(dest-originalDest);

        /* if an overflow occurs, then get the preflighting length */
        if(*pErrorCode==U_BUFFER_OVERFLOW_ERROR)
        {
            char16_t buffer[1024];

            destLimit=buffer+UPRV_LENGTHOF(buffer);
            do {
                dest=buffer;
                *pErrorCode=U_ZERO_ERROR;
                ucnv_toUnicode(cnv, &dest, destLimit, &src, srcLimit, nullptr, true, pErrorCode);
                destLength+=(int32_t)(dest-buffer);
            }
            while(*pErrorCode==U_BUFFER_OVERFLOW_ERROR);
        }
    } else {
        destLength=0;
    }

    return u_terminateUChars(originalDest, destCapacity, destLength, pErrorCode);
}

/* ucnv_getNextUChar() ------------------------------------------------------ */

U_CAPI UChar32 U_EXPORT2
ucnv_getNextUChar(UConverter *cnv,
                  const char **source, const char *sourceLimit,
                  UErrorCode *err) {
    UConverterToUnicodeArgs args;
    char16_t buffer[U16_MAX_LENGTH];
    const char *s;
    UChar32 c;
    int32_t i, length;

    /* check parameters */
    if(err==nullptr || U_FAILURE(*err)) {
        return 0xffff;
    }

    if(cnv==nullptr || source==nullptr) {
        *err=U_ILLEGAL_ARGUMENT_ERROR;
        return 0xffff;
    }

    s=*source;
    if(sourceLimit<s) {
        *err=U_ILLEGAL_ARGUMENT_ERROR;
        return 0xffff;
    }

    /*
     * Make sure that the buffer sizes do not exceed the number range for
     * int32_t because some functions use the size (in units or bytes)
     * rather than comparing pointers, and because offsets are int32_t values.
     *
     * size_t is guaranteed to be unsigned and large enough for the job.
     *
     * Return with an error instead of adjusting the limits because we would
     * not be able to maintain the semantics that either the source must be
     * consumed or the target filled (unless an error occurs).
     * An adjustment would be sourceLimit=t+0x7fffffff; for example.
     */
    if(((size_t)(sourceLimit-s)>(size_t)0x7fffffff && sourceLimit>s)) {
        *err=U_ILLEGAL_ARGUMENT_ERROR;
        return 0xffff;
    }

    c=U_SENTINEL;

    /* flush the target overflow buffer */
    if(cnv->UCharErrorBufferLength>0) {
        char16_t *overflow;

        overflow=cnv->UCharErrorBuffer;
        i=0;
        length=cnv->UCharErrorBufferLength;
        U16_NEXT(overflow, i, length, c);

        /* move the remaining overflow contents up to the beginning */
        if((cnv->UCharErrorBufferLength=(int8_t)(length-i))>0) {
            uprv_memmove(cnv->UCharErrorBuffer, cnv->UCharErrorBuffer+i,
                         cnv->UCharErrorBufferLength*U_SIZEOF_UCHAR);
        }

        if(!U16_IS_LEAD(c) || i<length) {
            return c;
        }
        /*
         * Continue if the overflow buffer contained only a lead surrogate,
         * in case the converter outputs single surrogates from complete
         * input sequences.
         */
    }

    /*
     * flush==true is implied for ucnv_getNextUChar()
     *
     * do not simply return even if s==sourceLimit because the converter may
     * not have seen flush==true before
     */

    /* prepare the converter arguments */
    args.converter=cnv;
    args.flush=true;
    args.offsets=nullptr;
    args.source=s;
    args.sourceLimit=sourceLimit;
    args.target=buffer;
    args.targetLimit=buffer+1;
    args.size=sizeof(args);

    if(c<0) {
        /*
         * call the native getNextUChar() implementation if we are
         * at a character boundary (toULength==0)
         *
         * unlike with _toUnicode(), getNextUChar() implementations must set
         * U_TRUNCATED_CHAR_FOUND for truncated input,
         * in addition to setting toULength/toUBytes[]
         */
        if(cnv->toULength==0 && cnv->sharedData->impl->getNextUChar!=nullptr) {
            c=cnv->sharedData->impl->getNextUChar(&args, err);
            *source=s=args.source;
            if(*err==U_INDEX_OUTOFBOUNDS_ERROR) {
                /* reset the converter without calling the callback function */
                _reset(cnv, UCNV_RESET_TO_UNICODE, false);
                return 0xffff; /* no output */
            } else if(U_SUCCESS(*err) && c>=0) {
                return c;
            /*
             * else fall through to use _toUnicode() because
             *   UCNV_GET_NEXT_UCHAR_USE_TO_U: the native function did not want to handle it after all
             *   U_FAILURE: call _toUnicode() for callback handling (do not output c)
             */
            }
        }

        /* convert to one char16_t in buffer[0], or handle getNextUChar() errors */
        _toUnicodeWithCallback(&args, err);

        if(*err==U_BUFFER_OVERFLOW_ERROR) {
            *err=U_ZERO_ERROR;
        }

        i=0;
        length=(int32_t)(args.target-buffer);
    } else {
        /* write the lead surrogate from the overflow buffer */
        buffer[0]=(char16_t)c;
        args.target=buffer+1;
        i=0;
        length=1;
    }

    /* buffer contents starts at i and ends before length */

    if(U_FAILURE(*err)) {
        c=0xffff; /* no output */
    } else if(length==0) {
        /* no input or only state changes */
        *err=U_INDEX_OUTOFBOUNDS_ERROR;
        /* no need to reset explicitly because _toUnicodeWithCallback() did it */
        c=0xffff; /* no output */
    } else {
        c=buffer[0];
        i=1;
        if(!U16_IS_LEAD(c)) {
            /* consume c=buffer[0], done */
        } else {
            /* got a lead surrogate, see if a trail surrogate follows */
            char16_t c2;

            if(cnv->UCharErrorBufferLength>0) {
                /* got overflow output from the conversion */
                if(U16_IS_TRAIL(c2=cnv->UCharErrorBuffer[0])) {
                    /* got a trail surrogate, too */
                    c=U16_GET_SUPPLEMENTARY(c, c2);

                    /* move the remaining overflow contents up to the beginning */
                    if((--cnv->UCharErrorBufferLength)>0) {
                        uprv_memmove(cnv->UCharErrorBuffer, cnv->UCharErrorBuffer+1,
                                     cnv->UCharErrorBufferLength*U_SIZEOF_UCHAR);
                    }
                } else {
                    /* c is an unpaired lead surrogate, just return it */
                }
            } else if(args.source<sourceLimit) {
                /* convert once more, to buffer[1] */
                args.targetLimit=buffer+2;
                _toUnicodeWithCallback(&args, err);
                if(*err==U_BUFFER_OVERFLOW_ERROR) {
                    *err=U_ZERO_ERROR;
                }

                length=(int32_t)(args.target-buffer);
                if(U_SUCCESS(*err) && length==2 && U16_IS_TRAIL(c2=buffer[1])) {
                    /* got a trail surrogate, too */
                    c=U16_GET_SUPPLEMENTARY(c, c2);
                    i=2;
                }
            }
        }
    }

    /*
     * move leftover output from buffer[i..length[
     * into the beginning of the overflow buffer
     */
    if(i<length) {
        /* move further overflow back */
        int32_t delta=length-i;
        if((length=cnv->UCharErrorBufferLength)>0) {
            uprv_memmove(cnv->UCharErrorBuffer+delta, cnv->UCharErrorBuffer,
                         length*U_SIZEOF_UCHAR);
        }
        cnv->UCharErrorBufferLength=(int8_t)(length+delta);

        cnv->UCharErrorBuffer[0]=buffer[i++];
        if(delta>1) {
            cnv->UCharErrorBuffer[1]=buffer[i];
        }
    }

    *source=args.source;
    return c;
}

/* ucnv_convert() and siblings ---------------------------------------------- */

U_CAPI void U_EXPORT2
ucnv_convertEx(UConverter *targetCnv, UConverter *sourceCnv,
               char **target, const char *targetLimit,
               const char **source, const char *sourceLimit,
               char16_t *pivotStart, char16_t **pivotSource,
               char16_t **pivotTarget, const char16_t *pivotLimit,
               UBool reset, UBool flush,
               UErrorCode *pErrorCode) {
    char16_t pivotBuffer[CHUNK_SIZE];
    const char16_t *myPivotSource;
    char16_t *myPivotTarget;
    const char *s;
    char *t;

    UConverterToUnicodeArgs toUArgs;
    UConverterFromUnicodeArgs fromUArgs;
    UConverterConvert convert;

    /* error checking */
    if(pErrorCode==nullptr || U_FAILURE(*pErrorCode)) {
        return;
    }

    if( targetCnv==nullptr || sourceCnv==nullptr ||
        source==nullptr || *source==nullptr ||
        target==nullptr || *target==nullptr || targetLimit==nullptr
    ) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }

    s=*source;
    t=*target;
    if((sourceLimit!=nullptr && sourceLimit<s) || targetLimit<t) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }

    /*
     * Make sure that the buffer sizes do not exceed the number range for
     * int32_t. See ucnv_toUnicode() for a more detailed comment.
     */
    if(
        (sourceLimit!=nullptr && ((size_t)(sourceLimit-s)>(size_t)0x7fffffff && sourceLimit>s)) ||
        ((size_t)(targetLimit-t)>(size_t)0x7fffffff && targetLimit>t)
    ) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }
    
    if(pivotStart==nullptr) {
        if(!flush) {
            /* streaming conversion requires an explicit pivot buffer */
            *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
            return;
        }

        /* use the stack pivot buffer */
        myPivotSource=myPivotTarget=pivotStart=pivotBuffer;
        pivotSource=(char16_t **)&myPivotSource;
        pivotTarget=&myPivotTarget;
        pivotLimit=pivotBuffer+CHUNK_SIZE;
    } else if(  pivotStart>=pivotLimit ||
                pivotSource==nullptr || *pivotSource==nullptr ||
                pivotTarget==nullptr || *pivotTarget==nullptr ||
                pivotLimit==nullptr
    ) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }

    if(sourceLimit==nullptr) {
        /* get limit of single-byte-NUL-terminated source string */
        sourceLimit=uprv_strchr(*source, 0);
    }

    if(reset) {
        ucnv_resetToUnicode(sourceCnv);
        ucnv_resetFromUnicode(targetCnv);
        *pivotSource=*pivotTarget=pivotStart;
    } else if(targetCnv->charErrorBufferLength>0) {
        /* output the targetCnv overflow buffer */
        if(ucnv_outputOverflowFromUnicode(targetCnv, target, targetLimit, nullptr, pErrorCode)) {
            /* U_BUFFER_OVERFLOW_ERROR */
            return;
        }
        /* *target has moved, therefore stop using t */

        if( !flush &&
            targetCnv->preFromULength>=0 && *pivotSource==*pivotTarget &&
            sourceCnv->UCharErrorBufferLength==0 && sourceCnv->preToULength>=0 && s==sourceLimit
        ) {
            /* the fromUnicode overflow buffer is emptied and there is no new input: we are done */
            return;
        }
    }

    /* Is direct-UTF-8 conversion available? */
    if( sourceCnv->sharedData->staticData->conversionType==UCNV_UTF8 &&
        targetCnv->sharedData->impl->fromUTF8!=nullptr
    ) {
        convert=targetCnv->sharedData->impl->fromUTF8;
    } else if( targetCnv->sharedData->staticData->conversionType==UCNV_UTF8 &&
               sourceCnv->sharedData->impl->toUTF8!=nullptr
    ) {
        convert=sourceCnv->sharedData->impl->toUTF8;
    } else {
        convert=nullptr;
    }

    /*
     * If direct-UTF-8 conversion is available, then we use a smaller
     * pivot buffer for error handling and partial matches
     * so that we quickly return to direct conversion.
     *
     * 32 is large enough for UCNV_EXT_MAX_UCHARS and UCNV_ERROR_BUFFER_LENGTH.
     *
     * We could reduce the pivot buffer size further, at the cost of
     * buffer overflows from callbacks.
     * The pivot buffer should not be smaller than the maximum number of
     * fromUnicode extension table input UChars
     * (for m:n conversion, see
     * targetCnv->sharedData->mbcs.extIndexes[UCNV_EXT_COUNT_UCHARS])
     * or 2 for surrogate pairs.
     *
     * Too small a buffer can cause thrashing between pivoting and direct
     * conversion, with function call overhead outweighing the benefits
     * of direct conversion.
     */
    if(convert!=nullptr && (pivotLimit-pivotStart)>32) {
        pivotLimit=pivotStart+32;
    }

    /* prepare the converter arguments */
    fromUArgs.converter=targetCnv;
    fromUArgs.flush=false;
    fromUArgs.offsets=nullptr;
    fromUArgs.target=*target;
    fromUArgs.targetLimit=targetLimit;
    fromUArgs.size=sizeof(fromUArgs);

    toUArgs.converter=sourceCnv;
    toUArgs.flush=flush;
    toUArgs.offsets=nullptr;
    toUArgs.source=s;
    toUArgs.sourceLimit=sourceLimit;
    toUArgs.targetLimit=pivotLimit;
    toUArgs.size=sizeof(toUArgs);

    /*
     * TODO: Consider separating this function into two functions,
     * extracting exactly the conversion loop,
     * for readability and to reduce the set of visible variables.
     *
     * Otherwise stop using s and t from here on.
     */
    s=t=nullptr;

    /*
     * conversion loop
     *
     * The sequence of steps in the loop may appear backward,
     * but the principle is simple:
     * In the chain of
     *   source - sourceCnv overflow - pivot - targetCnv overflow - target
     * empty out later buffers before refilling them from earlier ones.
     *
     * The targetCnv overflow buffer is flushed out only once before the loop.
     */
    for(;;) {
        /*
         * if(pivot not empty or error or replay or flush fromUnicode) {
         *   fromUnicode(pivot -> target);
         * }
         *
         * For pivoting conversion; and for direct conversion for
         * error callback handling and flushing the replay buffer.
         */
        if( *pivotSource<*pivotTarget ||
            U_FAILURE(*pErrorCode) ||
            targetCnv->preFromULength<0 ||
            fromUArgs.flush
        ) {
            fromUArgs.source=*pivotSource;
            fromUArgs.sourceLimit=*pivotTarget;
            _fromUnicodeWithCallback(&fromUArgs, pErrorCode);
            if(U_FAILURE(*pErrorCode)) {
                /* target overflow, or conversion error */
                *pivotSource=(char16_t *)fromUArgs.source;
                break;
            }

            /*
             * _fromUnicodeWithCallback() must have consumed the pivot contents
             * (*pivotSource==*pivotTarget) since it returned with U_SUCCESS()
             */
        }

        /* The pivot buffer is empty; reset it so we start at pivotStart. */
        *pivotSource=*pivotTarget=pivotStart;

        /*
         * if(sourceCnv overflow buffer not empty) {
         *     move(sourceCnv overflow buffer -> pivot);
         *     continue;
         * }
         */
        /* output the sourceCnv overflow buffer */
        if(sourceCnv->UCharErrorBufferLength>0) {
            if(ucnv_outputOverflowToUnicode(sourceCnv, pivotTarget, pivotLimit, nullptr, pErrorCode)) {
                /* U_BUFFER_OVERFLOW_ERROR */
                *pErrorCode=U_ZERO_ERROR;
            }
            continue;
        }

        /*
         * check for end of input and break if done
         *
         * Checking both flush and fromUArgs.flush ensures that the converters
         * have been called with the flush flag set if the ucnv_convertEx()
         * caller set it.
         */
        if( toUArgs.source==sourceLimit &&
            sourceCnv->preToULength>=0 && sourceCnv->toULength==0 &&
            (!flush || fromUArgs.flush)
        ) {
            /* done successfully */
            break;
        }

        /*
         * use direct conversion if available
         * but not if continuing a partial match
         * or flushing the toUnicode replay buffer
         */
        if(convert!=nullptr && targetCnv->preFromUFirstCP<0 && sourceCnv->preToULength==0) {
            if(*pErrorCode==U_USING_DEFAULT_WARNING) {
                /* remove a warning that may be set by this function */
                *pErrorCode=U_ZERO_ERROR;
            }
            convert(&fromUArgs, &toUArgs, pErrorCode);
            if(*pErrorCode==U_BUFFER_OVERFLOW_ERROR) {
                break;
            } else if(U_FAILURE(*pErrorCode)) {
                if(sourceCnv->toULength>0) {
                    /*
                     * Fall through to calling _toUnicodeWithCallback()
                     * for callback handling.
                     *
                     * The pivot buffer will be reset with
                     *   *pivotSource=*pivotTarget=pivotStart;
                     * which indicates a toUnicode error to the caller
                     * (*pivotSource==pivotStart shows no pivot UChars consumed).
                     */
                } else {
                    /*
                     * Indicate a fromUnicode error to the caller
                     * (*pivotSource>pivotStart shows some pivot UChars consumed).
                     */
                    *pivotSource=*pivotTarget=pivotStart+1;
                    /*
                     * Loop around to calling _fromUnicodeWithCallbacks()
                     * for callback handling.
                     */
                    continue;
                }
            } else if(*pErrorCode==U_USING_DEFAULT_WARNING) {
                /*
                 * No error, but the implementation requested to temporarily
                 * fall back to pivoting.
                 */
                *pErrorCode=U_ZERO_ERROR;
            /*
             * The following else branches are almost identical to the end-of-input
             * handling in _toUnicodeWithCallback().
             * Avoid calling it just for the end of input.
             */
            } else if(flush && sourceCnv->toULength>0) { /* flush==toUArgs.flush */
                /*
                 * the entire input stream is consumed
                 * and there is a partial, truncated input sequence left
                 */

                /* inject an error and continue with callback handling */
                *pErrorCode=U_TRUNCATED_CHAR_FOUND;
            } else {
                /* input consumed */
                if(flush) {
                    /* reset the converters without calling the callback functions */
                    _reset(sourceCnv, UCNV_RESET_TO_UNICODE, false);
                    _reset(targetCnv, UCNV_RESET_FROM_UNICODE, false);
                }

                /* done successfully */
                break;
            }
        }
        
        /*
         * toUnicode(source -> pivot);
         *
         * For pivoting conversion; and for direct conversion for
         * error callback handling, continuing partial matches
         * and flushing the replay buffer.
         *
         * The pivot buffer is empty and reset.
         */
        toUArgs.target=pivotStart; /* ==*pivotTarget */
        /* toUArgs.targetLimit=pivotLimit; already set before the loop */
        _toUnicodeWithCallback(&toUArgs, pErrorCode);
        *pivotTarget=toUArgs.target;
        if(*pErrorCode==U_BUFFER_OVERFLOW_ERROR) {
            /* pivot overflow: continue with the conversion loop */
            *pErrorCode=U_ZERO_ERROR;
        } else if(U_FAILURE(*pErrorCode) || (!flush && *pivotTarget==pivotStart)) {
            /* conversion error, or there was nothing left to convert */
            break;
        }
        /*
         * else:
         * _toUnicodeWithCallback() wrote into the pivot buffer,
         * continue with fromUnicode conversion.
         *
         * Set the fromUnicode flush flag if we flush and if toUnicode has
         * processed the end of the input.
         */
        if( flush && toUArgs.source==sourceLimit &&
            sourceCnv->preToULength>=0 &&
            sourceCnv->UCharErrorBufferLength==0
        ) {
            fromUArgs.flush=true;
        }
    }

    /*
     * The conversion loop is exited when one of the following is true:
     * - the entire source text has been converted successfully to the target buffer
     * - a target buffer overflow occurred
     * - a conversion error occurred
     */

    *source=toUArgs.source;
    *target=fromUArgs.target;

    /* terminate the target buffer if possible */
    if(flush && U_SUCCESS(*pErrorCode)) {
        if(*target!=targetLimit) {
            **target=0;
            if(*pErrorCode==U_STRING_NOT_TERMINATED_WARNING) {
                *pErrorCode=U_ZERO_ERROR;
            }
        } else {
            *pErrorCode=U_STRING_NOT_TERMINATED_WARNING;
        }
    }
}

/* internal implementation of ucnv_convert() etc. with preflighting */
static int32_t
ucnv_internalConvert(UConverter *outConverter, UConverter *inConverter,
                     char *target, int32_t targetCapacity,
                     const char *source, int32_t sourceLength,
                     UErrorCode *pErrorCode) {
    char16_t pivotBuffer[CHUNK_SIZE];
    char16_t *pivot, *pivot2;

    char *myTarget;
    const char *sourceLimit;
    const char *targetLimit;
    int32_t targetLength=0;

    /* set up */
    if(sourceLength<0) {
        sourceLimit=uprv_strchr(source, 0);
    } else {
        sourceLimit=source+sourceLength;
    }

    /* if there is no input data, we're done */
    if(source==sourceLimit) {
        return u_terminateChars(target, targetCapacity, 0, pErrorCode);
    }

    pivot=pivot2=pivotBuffer;
    myTarget=target;
    targetLength=0;

    if(targetCapacity>0) {
        /* perform real conversion */
        targetLimit=target+targetCapacity;
        ucnv_convertEx(outConverter, inConverter,
                       &myTarget, targetLimit,
                       &source, sourceLimit,
                       pivotBuffer, &pivot, &pivot2, pivotBuffer+CHUNK_SIZE,
                       false,
                       true,
                       pErrorCode);
        targetLength = static_cast<int32_t>(myTarget - target);
    }

    /*
     * If the output buffer is exhausted (or we are only "preflighting"), we need to stop writing
     * to it but continue the conversion in order to store in targetCapacity
     * the number of bytes that was required.
     */
    if(*pErrorCode==U_BUFFER_OVERFLOW_ERROR || targetCapacity==0)
    {
        char targetBuffer[CHUNK_SIZE];

        targetLimit=targetBuffer+CHUNK_SIZE;
        do {
            *pErrorCode=U_ZERO_ERROR;
            myTarget=targetBuffer;
            ucnv_convertEx(outConverter, inConverter,
                           &myTarget, targetLimit,
                           &source, sourceLimit,
                           pivotBuffer, &pivot, &pivot2, pivotBuffer+CHUNK_SIZE,
                           false,
                           true,
                           pErrorCode);
            targetLength += static_cast<int32_t>(myTarget - targetBuffer);
        } while(*pErrorCode==U_BUFFER_OVERFLOW_ERROR);

        /* done with preflighting, set warnings and errors as appropriate */
        return u_terminateChars(target, targetCapacity, targetLength, pErrorCode);
    }

    /* no need to call u_terminateChars() because ucnv_convertEx() took care of that */
    return targetLength;
}

U_CAPI int32_t U_EXPORT2
ucnv_convert(const char *toConverterName, const char *fromConverterName,
             char *target, int32_t targetCapacity,
             const char *source, int32_t sourceLength,
             UErrorCode *pErrorCode) {
    UConverter in, out; /* stack-allocated */
    UConverter *inConverter, *outConverter;
    int32_t targetLength;

    if(pErrorCode==nullptr || U_FAILURE(*pErrorCode)) {
        return 0;
    }

    if( source==nullptr || sourceLength<-1 ||
        targetCapacity<0 || (targetCapacity>0 && target==nullptr)
    ) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }

    /* if there is no input data, we're done */
    if(sourceLength==0 || (sourceLength<0 && *source==0)) {
        return u_terminateChars(target, targetCapacity, 0, pErrorCode);
    }

    /* create the converters */
    inConverter=ucnv_createConverter(&in, fromConverterName, pErrorCode);
    if(U_FAILURE(*pErrorCode)) {
        return 0;
    }

    outConverter=ucnv_createConverter(&out, toConverterName, pErrorCode);
    if(U_FAILURE(*pErrorCode)) {
        ucnv_close(inConverter);
        return 0;
    }

    targetLength=ucnv_internalConvert(outConverter, inConverter,
                                      target, targetCapacity,
                                      source, sourceLength,
                                      pErrorCode);

    ucnv_close(inConverter);
    ucnv_close(outConverter);

    return targetLength;
}

/* @internal */
static int32_t
ucnv_convertAlgorithmic(UBool convertToAlgorithmic,
                        UConverterType algorithmicType,
                        UConverter *cnv,
                        char *target, int32_t targetCapacity,
                        const char *source, int32_t sourceLength,
                        UErrorCode *pErrorCode) {
    UConverter algoConverterStatic; /* stack-allocated */
    UConverter *algoConverter, *to, *from;
    int32_t targetLength;

    if(pErrorCode==nullptr || U_FAILURE(*pErrorCode)) {
        return 0;
    }

    if( cnv==nullptr || source==nullptr || sourceLength<-1 ||
        targetCapacity<0 || (targetCapacity>0 && target==nullptr)
    ) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }

    /* if there is no input data, we're done */
    if(sourceLength==0 || (sourceLength<0 && *source==0)) {
        return u_terminateChars(target, targetCapacity, 0, pErrorCode);
    }

    /* create the algorithmic converter */
    algoConverter=ucnv_createAlgorithmicConverter(&algoConverterStatic, algorithmicType,
                                                  "", 0, pErrorCode);
    if(U_FAILURE(*pErrorCode)) {
        return 0;
    }

    /* reset the other converter */
    if(convertToAlgorithmic) {
        /* cnv->Unicode->algo */
        ucnv_resetToUnicode(cnv);
        to=algoConverter;
        from=cnv;
    } else {
        /* algo->Unicode->cnv */
        ucnv_resetFromUnicode(cnv);
        from=algoConverter;
        to=cnv;
    }

    targetLength=ucnv_internalConvert(to, from,
                                      target, targetCapacity,
                                      source, sourceLength,
                                      pErrorCode);

    ucnv_close(algoConverter);

    return targetLength;
}

U_CAPI int32_t U_EXPORT2
ucnv_toAlgorithmic(UConverterType algorithmicType,
                   UConverter *cnv,
                   char *target, int32_t targetCapacity,
                   const char *source, int32_t sourceLength,
                   UErrorCode *pErrorCode) {
    return ucnv_convertAlgorithmic(true, algorithmicType, cnv,
                                   target, targetCapacity,
                                   source, sourceLength,
                                   pErrorCode);
}

U_CAPI int32_t U_EXPORT2
ucnv_fromAlgorithmic(UConverter *cnv,
                     UConverterType algorithmicType,
                     char *target, int32_t targetCapacity,
                     const char *source, int32_t sourceLength,
                     UErrorCode *pErrorCode) UPRV_NO_SANITIZE_UNDEFINED {

    if(algorithmicType<0 || UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES<=algorithmicType) {
        *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }
    return ucnv_convertAlgorithmic(false, algorithmicType, cnv,
                                   target, targetCapacity,
                                   source, sourceLength,
                                   pErrorCode);
}

U_CAPI UConverterType  U_EXPORT2
ucnv_getType(const UConverter* converter)
{
    int8_t type = converter->sharedData->staticData->conversionType;
#if !UCONFIG_NO_LEGACY_CONVERSION
    if(type == UCNV_MBCS) {
        return ucnv_MBCSGetType(converter);
    }
#endif
    return (UConverterType)type;
}

U_CAPI void  U_EXPORT2
ucnv_getStarters(const UConverter* converter, 
                 UBool starters[256],
                 UErrorCode* err)
{
    if (err == nullptr || U_FAILURE(*err)) {
        return;
    }

    if(converter->sharedData->impl->getStarters != nullptr) {
        converter->sharedData->impl->getStarters(converter, starters, err);
    } else {
        *err = U_ILLEGAL_ARGUMENT_ERROR;
    }
}

static const UAmbiguousConverter *ucnv_getAmbiguous(const UConverter *cnv)
{
    UErrorCode errorCode;
    const char *name;
    int32_t i;

    if(cnv==nullptr) {
        return nullptr;
    }

    errorCode=U_ZERO_ERROR;
    name=ucnv_getName(cnv, &errorCode);
    if(U_FAILURE(errorCode)) {
        return nullptr;
    }

    for(i=0; i<UPRV_LENGTHOF(ambiguousConverters); ++i)
    {
        if(0==uprv_strcmp(name, ambiguousConverters[i].name))
        {
            return ambiguousConverters+i;
        }
    }

    return nullptr;
}

U_CAPI void  U_EXPORT2
ucnv_fixFileSeparator(const UConverter *cnv, 
                      char16_t* source,
                      int32_t sourceLength) {
    const UAmbiguousConverter *a;
    int32_t i;
    char16_t variant5c;

    if(cnv==nullptr || source==nullptr || sourceLength<=0 || (a=ucnv_getAmbiguous(cnv))==nullptr)
    {
        return;
    }

    variant5c=a->variant5c;
    for(i=0; i<sourceLength; ++i) {
        if(source[i]==variant5c) {
            source[i]=0x5c;
        }
    }
}

U_CAPI UBool  U_EXPORT2
ucnv_isAmbiguous(const UConverter *cnv) {
    return ucnv_getAmbiguous(cnv)!=nullptr;
}

U_CAPI void  U_EXPORT2
ucnv_setFallback(UConverter *cnv, UBool usesFallback)
{
    cnv->useFallback = usesFallback;
}

U_CAPI UBool  U_EXPORT2
ucnv_usesFallback(const UConverter *cnv)
{
    return cnv->useFallback;
}

U_CAPI void  U_EXPORT2
ucnv_getInvalidChars (const UConverter * converter,
                      char *errBytes,
                      int8_t * len,
                      UErrorCode * err)
{
    if (err == nullptr || U_FAILURE(*err))
    {
        return;
    }
    if (len == nullptr || errBytes == nullptr || converter == nullptr)
    {
        *err = U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }
    if (*len < converter->invalidCharLength)
    {
        *err = U_INDEX_OUTOFBOUNDS_ERROR;
        return;
    }
    if ((*len = converter->invalidCharLength) > 0)
    {
        uprv_memcpy (errBytes, converter->invalidCharBuffer, *len);
    }
}

U_CAPI void  U_EXPORT2
ucnv_getInvalidUChars (const UConverter * converter,
                       char16_t *errChars,
                       int8_t * len,
                       UErrorCode * err)
{
    if (err == nullptr || U_FAILURE(*err))
    {
        return;
    }
    if (len == nullptr || errChars == nullptr || converter == nullptr)
    {
        *err = U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }
    if (*len < converter->invalidUCharLength)
    {
        *err = U_INDEX_OUTOFBOUNDS_ERROR;
        return;
    }
    if ((*len = converter->invalidUCharLength) > 0)
    {
        u_memcpy (errChars, converter->invalidUCharBuffer, *len);
    }
}

#define SIG_MAX_LEN 5

U_CAPI const char* U_EXPORT2
ucnv_detectUnicodeSignature( const char* source,
                             int32_t sourceLength,
                             int32_t* signatureLength,
                             UErrorCode* pErrorCode) {
    int32_t dummy;

    /* initial 0xa5 bytes: make sure that if we read <SIG_MAX_LEN
     * bytes we don't misdetect something 
     */
    char start[SIG_MAX_LEN]={ '\xa5', '\xa5', '\xa5', '\xa5', '\xa5' };
    int i = 0;

    if((pErrorCode==nullptr) || U_FAILURE(*pErrorCode)){
        return nullptr;
    }
    
    if(source == nullptr || sourceLength < -1){
        *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
        return nullptr;
    }

    if(signatureLength == nullptr) {
        signatureLength = &dummy;
    }

    if(sourceLength==-1){
        sourceLength=(int32_t)uprv_strlen(source);
    }

    
    while(i<sourceLength&& i<SIG_MAX_LEN){
        start[i]=source[i];
        i++;
    }

    if(start[0] == '\xFE' && start[1] == '\xFF') {
        *signatureLength=2;
        return  "UTF-16BE";
    } else if(start[0] == '\xFF' && start[1] == '\xFE') {
        if(start[2] == '\x00' && start[3] =='\x00') {
            *signatureLength=4;
            return "UTF-32LE";
        } else {
            *signatureLength=2;
            return  "UTF-16LE";
        }
    } else if(start[0] == '\xEF' && start[1] == '\xBB' && start[2] == '\xBF') {
        *signatureLength=3;
        return  "UTF-8";
    } else if(start[0] == '\x00' && start[1] == '\x00' && 
              start[2] == '\xFE' && start[3]=='\xFF') {
        *signatureLength=4;
        return  "UTF-32BE";
    } else if(start[0] == '\x0E' && start[1] == '\xFE' && start[2] == '\xFF') {
        *signatureLength=3;
        return "SCSU";
    } else if(start[0] == '\xFB' && start[1] == '\xEE' && start[2] == '\x28') {
        *signatureLength=3;
        return "BOCU-1";
    } else if(start[0] == '\x2B' && start[1] == '\x2F' && start[2] == '\x76') {
        /*
         * UTF-7: Initial U+FEFF is encoded as +/v8  or  +/v9  or  +/v+  or  +/v/
         * depending on the second UTF-16 code unit.
         * Detect the entire, closed Unicode mode sequence +/v8- for only U+FEFF
         * if it occurs.
         *
         * So far we have +/v
         */
        if(start[3] == '\x38' && start[4] == '\x2D') {
            /* 5 bytes +/v8- */
            *signatureLength=5;
            return "UTF-7";
        } else if(start[3] == '\x38' || start[3] == '\x39' || start[3] == '\x2B' || start[3] == '\x2F') {
            /* 4 bytes +/v8  or  +/v9  or  +/v+  or  +/v/ */
            *signatureLength=4;
            return "UTF-7";
        }
    }else if(start[0]=='\xDD' && start[1]== '\x73'&& start[2]=='\x66' && start[3]=='\x73'){
        *signatureLength=4;
        return "UTF-EBCDIC";
    }


    /* no known Unicode signature byte sequence recognized */
    *signatureLength=0;
    return nullptr;
}

U_CAPI int32_t U_EXPORT2
ucnv_fromUCountPending(const UConverter* cnv, UErrorCode* status)
{
    if(status == nullptr || U_FAILURE(*status)){
        return -1;
    }
    if(cnv == nullptr){
        *status = U_ILLEGAL_ARGUMENT_ERROR;
        return -1;
    }

    if(cnv->preFromUFirstCP >= 0){
        return U16_LENGTH(cnv->preFromUFirstCP)+cnv->preFromULength ;
    }else if(cnv->preFromULength < 0){
        return -cnv->preFromULength ;
    }else if(cnv->fromUChar32 > 0){
        return 1;
    }
    return 0; 

}

U_CAPI int32_t U_EXPORT2
ucnv_toUCountPending(const UConverter* cnv, UErrorCode* status){

    if(status == nullptr || U_FAILURE(*status)){
        return -1;
    }
    if(cnv == nullptr){
        *status = U_ILLEGAL_ARGUMENT_ERROR;
        return -1;
    }

    if(cnv->preToULength > 0){
        return cnv->preToULength ;
    }else if(cnv->preToULength < 0){
        return -cnv->preToULength;
    }else if(cnv->toULength > 0){
        return cnv->toULength;
    }
    return 0;
}

U_CAPI UBool U_EXPORT2
ucnv_isFixedWidth(UConverter *cnv, UErrorCode *status){
    if (U_FAILURE(*status)) {
        return false;
    }

    if (cnv == nullptr) {
        *status = U_ILLEGAL_ARGUMENT_ERROR;
        return false;
    }

    switch (ucnv_getType(cnv)) {
        case UCNV_SBCS:
        case UCNV_DBCS:
        case UCNV_UTF32_BigEndian:
        case UCNV_UTF32_LittleEndian:
        case UCNV_UTF32:
        case UCNV_US_ASCII:
            return true;
        default:
            return false;
    }
}
#endif

/*
 * Hey, Emacs, please set the following:
 *
 * Local Variables:
 * indent-tabs-mode: nil
 * End:
 *
 */
                                                                                                                                                                                                            node-23.7.0/deps/icu-small/source/common/ucnv2022.cpp                                               0000664 0000000 0000000 00000467732 14746647661 0022176 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
**********************************************************************
*   Copyright (C) 2000-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
**********************************************************************
*   file name:  ucnv2022.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2000feb03
*   created by: Markus W. Scherer
*
*   Change history:
*
*   06/29/2000  helena  Major rewrite of the callback APIs.
*   08/08/2000  Ram     Included support for ISO-2022-JP-2
*                       Changed implementation of toUnicode
*                       function
*   08/21/2000  Ram     Added support for ISO-2022-KR
*   08/29/2000  Ram     Seperated implementation of EBCDIC to
*                       ucnvebdc.c
*   09/20/2000  Ram     Added support for ISO-2022-CN
*                       Added implementations for getNextUChar()
*                       for specific 2022 country variants.
*   10/31/2000  Ram     Implemented offsets logic functions
*/

#include "unicode/utypes.h"

#if !UCONFIG_NO_CONVERSION && !UCONFIG_NO_LEGACY_CONVERSION

#include "unicode/ucnv.h"
#include "unicode/uset.h"
#include "unicode/ucnv_err.h"
#include "unicode/ucnv_cb.h"
#include "unicode/utf16.h"
#include "ucnv_imp.h"
#include "ucnv_bld.h"
#include "ucnv_cnv.h"
#include "ucnvmbcs.h"
#include "cstring.h"
#include "cmemory.h"
#include "uassert.h"

#ifdef U_ENABLE_GENERIC_ISO_2022
/*
 * I am disabling the generic ISO-2022 converter after proposing to do so on
 * the icu mailing list two days ago.
 *
 * Reasons:
 * 1. It does not fully support the ISO-2022/ECMA-35 specification with all of
 *    its designation sequences, single shifts with return to the previous state,
 *    switch-with-no-return to UTF-16BE or similar, etc.
 *    This is unlike the language-specific variants like ISO-2022-JP which
 *    require a much smaller repertoire of ISO-2022 features.
 *    These variants continue to be supported.
 * 2. I believe that no one is really using the generic ISO-2022 converter
 *    but rather always one of the language-specific variants.
 *    Note that ICU's generic ISO-2022 converter has always output one escape
 *    sequence followed by UTF-8 for the whole stream.
 * 3. Switching between subcharsets is extremely slow, because each time
 *    the previous converter is closed and a new one opened,
 *    without any kind of caching, least-recently-used list, etc.
 * 4. The code is currently buggy, and given the above it does not seem
 *    reasonable to spend the time on maintenance.
 * 5. ISO-2022 subcharsets should normally be used with 7-bit byte encodings.
 *    This means, for example, that when ISO-8859-7 is designated, the following
 *    ISO-2022 bytes 00..7f should be interpreted as ISO-8859-7 bytes 80..ff.
 *    The ICU ISO-2022 converter does not handle this - and has no information
 *    about which subconverter would have to be shifted vs. which is designed
 *    for 7-bit ISO-2022.
 *
 * Markus Scherer 2003-dec-03
 */
#endif

#if !UCONFIG_ONLY_HTML_CONVERSION
static const char SHIFT_IN_STR[]  = "\x0F";
// static const char SHIFT_OUT_STR[] = "\x0E";
#endif

#define CR      0x0D
#define LF      0x0A
#define H_TAB   0x09
#define V_TAB   0x0B
#define SPACE   0x20

enum {
    HWKANA_START=0xff61,
    HWKANA_END=0xff9f
};

/*
 * 94-character sets with native byte values A1..FE are encoded in ISO 2022
 * as bytes 21..7E. (Subtract 0x80.)
 * 96-character sets with native byte values A0..FF are encoded in ISO 2022
 * as bytes 20..7F. (Subtract 0x80.)
 * Do not encode C1 control codes with native bytes 80..9F
 * as bytes 00..1F (C0 control codes).
 */
enum {
    GR94_START=0xa1,
    GR94_END=0xfe,
    GR96_START=0xa0,
    GR96_END=0xff
};

/*
 * ISO 2022 control codes must not be converted from Unicode
 * because they would mess up the byte stream.
 * The bit mask 0x0800c000 has bits set at bit positions 0xe, 0xf, 0x1b
 * corresponding to SO, SI, and ESC.
 */
#define IS_2022_CONTROL(c) (((c)<0x20) && (((uint32_t)1<<(c))&0x0800c000)!=0)

/* for ISO-2022-JP and -CN implementations */
typedef enum  {
        /* shared values */
        INVALID_STATE=-1,
        ASCII = 0,

        SS2_STATE=0x10,
        SS3_STATE,

        /* JP */
        ISO8859_1 = 1 ,
        ISO8859_7 = 2 ,
        JISX201  = 3,
        JISX208 = 4,
        JISX212 = 5,
        GB2312  =6,
        KSC5601 =7,
        HWKANA_7BIT=8,    /* Halfwidth Katakana 7 bit */

        /* CN */
        /* the first few enum constants must keep their values because they correspond to myConverterArray[] */
        GB2312_1=1,
        ISO_IR_165=2,
        CNS_11643=3,

        /*
         * these are used in StateEnum and ISO2022State variables,
         * but CNS_11643 must be used to index into myConverterArray[]
         */
        CNS_11643_0=0x20,
        CNS_11643_1,
        CNS_11643_2,
        CNS_11643_3,
        CNS_11643_4,
        CNS_11643_5,
        CNS_11643_6,
        CNS_11643_7
} StateEnum;

/* is the StateEnum charset value for a DBCS charset? */
#if UCONFIG_ONLY_HTML_CONVERSION
#define IS_JP_DBCS(cs) (JISX208==(cs))
#else
#define IS_JP_DBCS(cs) (JISX208<=(cs) && (cs)<=KSC5601)
#endif

#define CSM(cs) ((uint16_t)1<<(cs))

/*
 * Each of these charset masks (with index x) contains a bit for a charset in exact correspondence
 * to whether that charset is used in the corresponding version x of ISO_2022,locale=ja,version=x
 *
 * Note: The converter uses some leniency:
 * - The escape sequence ESC ( I for half-width 7-bit Katakana is recognized in
 *   all versions, not just JIS7 and JIS8.
 * - ICU does not distinguish between different versions of JIS X 0208.
 */
#if UCONFIG_ONLY_HTML_CONVERSION
enum { MAX_JA_VERSION=0 };
#else
enum { MAX_JA_VERSION=4 };
#endif
static const uint16_t jpCharsetMasks[MAX_JA_VERSION+1]={
    CSM(ASCII)|CSM(JISX201)|CSM(JISX208)|CSM(HWKANA_7BIT),
#if !UCONFIG_ONLY_HTML_CONVERSION
    CSM(ASCII)|CSM(JISX201)|CSM(JISX208)|CSM(HWKANA_7BIT)|CSM(JISX212),
    CSM(ASCII)|CSM(JISX201)|CSM(JISX208)|CSM(HWKANA_7BIT)|CSM(JISX212)|CSM(GB2312)|CSM(KSC5601)|CSM(ISO8859_1)|CSM(ISO8859_7),
    CSM(ASCII)|CSM(JISX201)|CSM(JISX208)|CSM(HWKANA_7BIT)|CSM(JISX212)|CSM(GB2312)|CSM(KSC5601)|CSM(ISO8859_1)|CSM(ISO8859_7),
    CSM(ASCII)|CSM(JISX201)|CSM(JISX208)|CSM(HWKANA_7BIT)|CSM(JISX212)|CSM(GB2312)|CSM(KSC5601)|CSM(ISO8859_1)|CSM(ISO8859_7)
#endif
};

typedef enum {
        ASCII1=0,
        LATIN1,
        SBCS,
        DBCS,
        MBCS,
        HWKANA
}Cnv2022Type;

typedef struct ISO2022State {
    int8_t cs[4];       /* charset number for SI (G0)/SO (G1)/SS2 (G2)/SS3 (G3) */
    int8_t g;           /* 0..3 for G0..G3 (SI/SO/SS2/SS3) */
    int8_t prevG;       /* g before single shift (SS2 or SS3) */
} ISO2022State;

#define UCNV_OPTIONS_VERSION_MASK 0xf
#define UCNV_2022_MAX_CONVERTERS 10

typedef struct{
    UConverterSharedData *myConverterArray[UCNV_2022_MAX_CONVERTERS];
    UConverter *currentConverter;
    Cnv2022Type currentType;
    ISO2022State toU2022State, fromU2022State;
    uint32_t key;
    uint32_t version;
#ifdef U_ENABLE_GENERIC_ISO_2022
    UBool isFirstBuffer;
#endif
    UBool isEmptySegment;
    char name[30];
    char locale[3];
}UConverterDataISO2022;

/* Protos */
/* ISO-2022 ----------------------------------------------------------------- */

/*Forward declaration */
U_CFUNC void U_CALLCONV
ucnv_fromUnicode_UTF8(UConverterFromUnicodeArgs * args,
                      UErrorCode * err);
U_CFUNC void U_CALLCONV
ucnv_fromUnicode_UTF8_OFFSETS_LOGIC(UConverterFromUnicodeArgs * args,
                                    UErrorCode * err);

#define ESC_2022 0x1B /*ESC*/

typedef enum
{
        INVALID_2022 = -1, /*Doesn't correspond to a valid iso 2022 escape sequence*/
        VALID_NON_TERMINAL_2022 = 0, /*so far corresponds to a valid iso 2022 escape sequence*/
        VALID_TERMINAL_2022 = 1, /*corresponds to a valid iso 2022 escape sequence*/
        VALID_MAYBE_TERMINAL_2022 = 2 /*so far matches one iso 2022 escape sequence, but by adding more characters might match another escape sequence*/
} UCNV_TableStates_2022;

/*
* The way these state transition arrays work is:
* ex : ESC$B is the sequence for JISX208
*      a) First Iteration: char is ESC
*          i) Get the value of ESC from normalize_esq_chars_2022[] with int value of ESC as index
*             int x = normalize_esq_chars_2022[27] which is equal to 1
*         ii) Search for this value in escSeqStateTable_Key_2022[]
*             value of x is stored at escSeqStateTable_Key_2022[0]
*        iii) Save this index as offset
*         iv) Get state of this sequence from escSeqStateTable_Value_2022[]
*             escSeqStateTable_Value_2022[offset], which is VALID_NON_TERMINAL_2022
*     b) Switch on this state and continue to next char
*          i) Get the value of $ from normalize_esq_chars_2022[] with int value of $ as index
*             which is normalize_esq_chars_2022[36] == 4
*         ii) x is currently 1(from above)
*               x<<=5 -- x is now 32
*               x+=normalize_esq_chars_2022[36]
*               now x is 36
*        iii) Search for this value in escSeqStateTable_Key_2022[]
*             value of x is stored at escSeqStateTable_Key_2022[2], so offset is 2
*         iv) Get state of this sequence from escSeqStateTable_Value_2022[]
*             escSeqStateTable_Value_2022[offset], which is VALID_NON_TERMINAL_2022
*     c) Switch on this state and continue to next char
*        i)  Get the value of B from normalize_esq_chars_2022[] with int value of B as index
*        ii) x is currently 36 (from above)
*            x<<=5 -- x is now 1152
*            x+=normalize_esq_chars_2022[66]
*            now x is 1161
*       iii) Search for this value in escSeqStateTable_Key_2022[]
*            value of x is stored at escSeqStateTable_Key_2022[21], so offset is 21
*        iv) Get state of this sequence from escSeqStateTable_Value_2022[21]
*            escSeqStateTable_Value_2022[offset], which is VALID_TERMINAL_2022
*         v) Get the converter name form escSeqStateTable_Result_2022[21] which is JISX208
*/


/*Below are the 3 arrays depicting a state transition table*/
static const int8_t normalize_esq_chars_2022[256] = {
/*       0      1       2       3       4      5       6        7       8       9           */

         0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,1      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,4      ,7      ,29      ,0
        ,2     ,24     ,26     ,27     ,0      ,3      ,23     ,6      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,5      ,8      ,9      ,10     ,11     ,12
        ,13    ,14     ,15     ,16     ,17     ,18     ,19     ,20     ,25     ,28
        ,0     ,0      ,21     ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,22    ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0      ,0
        ,0     ,0      ,0      ,0      ,0      ,0
};

#ifdef U_ENABLE_GENERIC_ISO_2022
/*
 * When the generic ISO-2022 converter is completely removed, not just disabled
 * per #ifdef, then the following state table and the associated tables that are
 * dimensioned with MAX_STATES_2022 should be trimmed.
 *
 * Especially, VALID_MAYBE_TERMINAL_2022 will not be used any more, and all of
 * the associated escape sequences starting with ESC ( B should be removed.
 * This includes the ones with key values 1097 and all of the ones above 1000000.
 *
 * For the latter, the tables can simply be truncated.
 * For the former, since the tables must be kept parallel, it is probably best
 * to simply duplicate an adjacent table cell, parallel in all tables.
 *
 * It may make sense to restructure the tables, especially by using small search
 * tables for the variants instead of indexing them parallel to the table here.
 */
#endif

#define MAX_STATES_2022 74
static const int32_t escSeqStateTable_Key_2022[MAX_STATES_2022] = {
/*   0           1           2           3           4           5           6           7           8           9           */

     1          ,34         ,36         ,39         ,55         ,57         ,60         ,61         ,1093       ,1096
    ,1097       ,1098       ,1099       ,1100       ,1101       ,1102       ,1103       ,1104       ,1105       ,1106
    ,1109       ,1154       ,1157       ,1160       ,1161       ,1176       ,1178       ,1179       ,1254       ,1257
    ,1768       ,1773       ,1957       ,35105      ,36933      ,36936      ,36937      ,36938      ,36939      ,36940
    ,36942      ,36943      ,36944      ,36945      ,36946      ,36947      ,36948      ,37640      ,37642      ,37644
    ,37646      ,37711      ,37744      ,37745      ,37746      ,37747      ,37748      ,40133      ,40136      ,40138
    ,40139      ,40140      ,40141      ,1123363    ,35947624   ,35947625   ,35947626   ,35947627   ,35947629   ,35947630
    ,35947631   ,35947635   ,35947636   ,35947638
};

#ifdef U_ENABLE_GENERIC_ISO_2022

static const char* const escSeqStateTable_Result_2022[MAX_STATES_2022] = {
 /*  0                      1                        2                      3                   4                   5                        6                      7                       8                       9    */

     nullptr                   ,nullptr                   ,nullptr                   ,nullptr               ,nullptr               ,nullptr                   ,nullptr                   ,nullptr                   ,"latin1"               ,"latin1"
    ,"latin1"               ,"ibm-865"              ,"ibm-865"              ,"ibm-865"          ,"ibm-865"          ,"ibm-865"              ,"ibm-865"              ,"JISX0201"             ,"JISX0201"             ,"latin1"
    ,"latin1"               ,nullptr                   ,"JISX-208"             ,"ibm-5478"         ,"JISX-208"         ,nullptr                   ,nullptr                   ,nullptr                   ,nullptr                   ,"UTF8"
    ,"ISO-8859-1"           ,"ISO-8859-7"           ,"JIS-X-208"            ,nullptr               ,"ibm-955"          ,"ibm-367"              ,"ibm-952"              ,"ibm-949"              ,"JISX-212"             ,"ibm-1383"
    ,"ibm-952"              ,"ibm-964"              ,"ibm-964"              ,"ibm-964"          ,"ibm-964"          ,"ibm-964"              ,"ibm-964"              ,"ibm-5478"         ,"ibm-949"              ,"ISO-IR-165"
    ,"CNS-11643-1992,1"     ,"CNS-11643-1992,2"     ,"CNS-11643-1992,3"     ,"CNS-11643-1992,4" ,"CNS-11643-1992,5" ,"CNS-11643-1992,6"     ,"CNS-11643-1992,7"     ,"UTF16_PlatformEndian" ,"UTF16_PlatformEndian" ,"UTF16_PlatformEndian"
    ,"UTF16_PlatformEndian" ,"UTF16_PlatformEndian" ,"UTF16_PlatformEndian" ,nullptr               ,"latin1"           ,"ibm-912"              ,"ibm-913"              ,"ibm-914"              ,"ibm-813"              ,"ibm-1089"
    ,"ibm-920"              ,"ibm-915"              ,"ibm-915"              ,"latin1"
};

#endif

static const int8_t escSeqStateTable_Value_2022[MAX_STATES_2022] = {
/*          0                           1                         2                             3                           4                           5                               6                        7                          8                           9       */
     VALID_NON_TERMINAL_2022    ,VALID_NON_TERMINAL_2022    ,VALID_NON_TERMINAL_2022    ,VALID_NON_TERMINAL_2022     ,VALID_NON_TERMINAL_2022   ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_NON_TERMINAL_2022    ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022
    ,VALID_MAYBE_TERMINAL_2022  ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022
    ,VALID_TERMINAL_2022        ,VALID_NON_TERMINAL_2022    ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_NON_TERMINAL_2022    ,VALID_NON_TERMINAL_2022    ,VALID_NON_TERMINAL_2022    ,VALID_NON_TERMINAL_2022    ,VALID_TERMINAL_2022
    ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_NON_TERMINAL_2022    ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022
    ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022
    ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022
    ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_NON_TERMINAL_2022    ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022
    ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022        ,VALID_TERMINAL_2022
};

/* Type def for refactoring changeState_2022 code*/
typedef enum{
#ifdef U_ENABLE_GENERIC_ISO_2022
    ISO_2022=0,
#endif
    ISO_2022_JP=1,
#if !UCONFIG_ONLY_HTML_CONVERSION
    ISO_2022_KR=2,
    ISO_2022_CN=3
#endif
} Variant2022;

/*********** ISO 2022 Converter Protos ***********/
static void U_CALLCONV
_ISO2022Open(UConverter *cnv, UConverterLoadArgs *pArgs, UErrorCode *errorCode);

static void U_CALLCONV
 _ISO2022Close(UConverter *converter);

static void U_CALLCONV
_ISO2022Reset(UConverter *converter, UConverterResetChoice choice);

U_CDECL_BEGIN
static const char * U_CALLCONV
_ISO2022getName(const UConverter* cnv);
U_CDECL_END

static void  U_CALLCONV
_ISO_2022_WriteSub(UConverterFromUnicodeArgs *args, int32_t offsetIndex, UErrorCode *err);

U_CDECL_BEGIN
static UConverter * U_CALLCONV
_ISO_2022_SafeClone(const UConverter *cnv, void *stackBuffer, int32_t *pBufferSize, UErrorCode *status);

U_CDECL_END

#ifdef U_ENABLE_GENERIC_ISO_2022
static void U_CALLCONV
T_UConverter_toUnicode_ISO_2022_OFFSETS_LOGIC(UConverterToUnicodeArgs* args, UErrorCode* err);
#endif

namespace {

/*const UConverterSharedData _ISO2022Data;*/
extern const UConverterSharedData _ISO2022JPData;

#if !UCONFIG_ONLY_HTML_CONVERSION
extern const UConverterSharedData _ISO2022KRData;
extern const UConverterSharedData _ISO2022CNData;
#endif

}  // namespace

/*************** Converter implementations ******************/

/* The purpose of this function is to get around gcc compiler warnings. */
static inline void
fromUWriteUInt8(UConverter *cnv,
                 const char *bytes, int32_t length,
                 uint8_t **target, const char *targetLimit,
                 int32_t **offsets,
                 int32_t sourceIndex,
                 UErrorCode *pErrorCode)
{
    char* targetChars = reinterpret_cast<char*>(*target);
    ucnv_fromUWriteBytes(cnv, bytes, length, &targetChars, targetLimit,
                         offsets, sourceIndex, pErrorCode);
    *target = reinterpret_cast<uint8_t*>(targetChars);

}

static inline void
setInitialStateToUnicodeKR(UConverter* /*converter*/, UConverterDataISO2022 *myConverterData){
    if(myConverterData->version == 1) {
        UConverter *cnv = myConverterData->currentConverter;

        cnv->toUnicodeStatus=0;     /* offset */
        cnv->mode=0;                /* state */
        cnv->toULength=0;           /* byteIndex */
    }
}

static inline void
setInitialStateFromUnicodeKR(UConverter* converter,UConverterDataISO2022 *myConverterData){
   /* in ISO-2022-KR the designator sequence appears only once
    * in a file so we append it only once
    */
    if( converter->charErrorBufferLength==0){

        converter->charErrorBufferLength = 4;
        converter->charErrorBuffer[0] = 0x1b;
        converter->charErrorBuffer[1] = 0x24;
        converter->charErrorBuffer[2] = 0x29;
        converter->charErrorBuffer[3] = 0x43;
    }
    if(myConverterData->version == 1) {
        UConverter *cnv = myConverterData->currentConverter;

        cnv->fromUChar32=0;
        cnv->fromUnicodeStatus=1;   /* prevLength */
    }
}

static void U_CALLCONV
_ISO2022Open(UConverter *cnv, UConverterLoadArgs *pArgs, UErrorCode *errorCode){

    char myLocale[7]={' ',' ',' ',' ',' ',' ', '\0'};

    cnv->extraInfo = uprv_malloc (sizeof (UConverterDataISO2022));
    if(cnv->extraInfo != nullptr) {
        UConverterNamePieces stackPieces;
        UConverterLoadArgs stackArgs=UCNV_LOAD_ARGS_INITIALIZER;
        UConverterDataISO2022* myConverterData = static_cast<UConverterDataISO2022*>(cnv->extraInfo);
        uint32_t version;

        stackArgs.onlyTestIsLoadable = pArgs->onlyTestIsLoadable;

        uprv_memset(myConverterData, 0, sizeof(UConverterDataISO2022));
        myConverterData->currentType = ASCII1;
        cnv->fromUnicodeStatus =false;
        if(pArgs->locale){
            uprv_strncpy(myLocale, pArgs->locale, sizeof(myLocale)-1);
        }
        version = pArgs->options & UCNV_OPTIONS_VERSION_MASK;
        myConverterData->version = version;
        if(myLocale[0]=='j' && (myLocale[1]=='a'|| myLocale[1]=='p') &&
            (myLocale[2]=='_' || myLocale[2]=='\0'))
        {
            /* open the required converters and cache them */
            if(version>MAX_JA_VERSION) {
                // ICU 55 fails to open a converter for an unsupported version.
                // Previously, it fell back to version 0, but that would yield
                // unexpected behavior.
                *errorCode = U_MISSING_RESOURCE_ERROR;
                return;
            }
            if(jpCharsetMasks[version]&CSM(ISO8859_7)) {
                myConverterData->myConverterArray[ISO8859_7] =
                    ucnv_loadSharedData("ISO8859_7", &stackPieces, &stackArgs, errorCode);
            }
            myConverterData->myConverterArray[JISX208] =
                ucnv_loadSharedData("Shift-JIS", &stackPieces, &stackArgs, errorCode);
            if(jpCharsetMasks[version]&CSM(JISX212)) {
                myConverterData->myConverterArray[JISX212] =
                    ucnv_loadSharedData("jisx-212", &stackPieces, &stackArgs, errorCode);
            }
            if(jpCharsetMasks[version]&CSM(GB2312)) {
                myConverterData->myConverterArray[GB2312] =
                    ucnv_loadSharedData("ibm-5478", &stackPieces, &stackArgs, errorCode);   /* gb_2312_80-1 */
            }
            if(jpCharsetMasks[version]&CSM(KSC5601)) {
                myConverterData->myConverterArray[KSC5601] =
                    ucnv_loadSharedData("ksc_5601", &stackPieces, &stackArgs, errorCode);
            }

            /* set the function pointers to appropriate functions */
            cnv->sharedData = const_cast<UConverterSharedData*>(&_ISO2022JPData);
            uprv_strcpy(myConverterData->locale,"ja");

            (void)uprv_strcpy(myConverterData->name,"ISO_2022,locale=ja,version=");
            size_t len = uprv_strlen(myConverterData->name);
            myConverterData->name[len] = static_cast<char>(myConverterData->version + static_cast<int>('0'));
            myConverterData->name[len+1]='\0';
        }
#if !UCONFIG_ONLY_HTML_CONVERSION
        else if(myLocale[0]=='k' && (myLocale[1]=='o'|| myLocale[1]=='r') &&
            (myLocale[2]=='_' || myLocale[2]=='\0'))
        {
            if(version>1) {
                // ICU 55 fails to open a converter for an unsupported version.
                // Previously, it fell back to version 0, but that would yield
                // unexpected behavior.
                *errorCode = U_MISSING_RESOURCE_ERROR;
                return;
            }
            const char *cnvName;
            if(version==1) {
                cnvName="icu-internal-25546";
            } else {
                cnvName="ibm-949";
                myConverterData->version=version=0;
            }
            if(pArgs->onlyTestIsLoadable) {
                ucnv_canCreateConverter(cnvName, errorCode);  /* errorCode carries result */
                uprv_free(cnv->extraInfo);
                cnv->extraInfo=nullptr;
                return;
            } else {
                myConverterData->currentConverter=ucnv_open(cnvName, errorCode);
                if (U_FAILURE(*errorCode)) {
                    _ISO2022Close(cnv);
                    return;
                }

                if(version==1) {
                    (void)uprv_strcpy(myConverterData->name,"ISO_2022,locale=ko,version=1");
                    uprv_memcpy(cnv->subChars, myConverterData->currentConverter->subChars, 4);
                    cnv->subCharLen = myConverterData->currentConverter->subCharLen;
                }else{
                    (void)uprv_strcpy(myConverterData->name,"ISO_2022,locale=ko,version=0");
                }

                /* initialize the state variables */
                setInitialStateToUnicodeKR(cnv, myConverterData);
                setInitialStateFromUnicodeKR(cnv, myConverterData);

                /* set the function pointers to appropriate functions */
                cnv->sharedData = const_cast<UConverterSharedData*>(&_ISO2022KRData);
                uprv_strcpy(myConverterData->locale,"ko");
            }
        }
        else if(((myLocale[0]=='z' && myLocale[1]=='h') || (myLocale[0]=='c'&& myLocale[1]=='n'))&&
            (myLocale[2]=='_' || myLocale[2]=='\0'))
        {
            if(version>2) {
                // ICU 55 fails to open a converter for an unsupported version.
                // Previously, it fell back to version 0, but that would yield
                // unexpected behavior.
                *errorCode = U_MISSING_RESOURCE_ERROR;
                return;
            }

            /* open the required converters and cache them */
            myConverterData->myConverterArray[GB2312_1] =
                ucnv_loadSharedData("ibm-5478", &stackPieces, &stackArgs, errorCode);
            if(version==1) {
                myConverterData->myConverterArray[ISO_IR_165] =
                    ucnv_loadSharedData("iso-ir-165", &stackPieces, &stackArgs, errorCode);
            }
            myConverterData->myConverterArray[CNS_11643] =
                ucnv_loadSharedData("cns-11643-1992", &stackPieces, &stackArgs, errorCode);


            /* set the function pointers to appropriate functions */
            cnv->sharedData = const_cast<UConverterSharedData*>(&_ISO2022CNData);
            uprv_strcpy(myConverterData->locale,"cn");

            if (version==0){
                myConverterData->version = 0;
                (void)uprv_strcpy(myConverterData->name,"ISO_2022,locale=zh,version=0");
            }else if (version==1){
                myConverterData->version = 1;
                (void)uprv_strcpy(myConverterData->name,"ISO_2022,locale=zh,version=1");
            }else {
                myConverterData->version = 2;
                (void)uprv_strcpy(myConverterData->name,"ISO_2022,locale=zh,version=2");
            }
        }
#endif  // !UCONFIG_ONLY_HTML_CONVERSION
        else{
#ifdef U_ENABLE_GENERIC_ISO_2022
            myConverterData->isFirstBuffer = true;

            /* append the UTF-8 escape sequence */
            cnv->charErrorBufferLength = 3;
            cnv->charErrorBuffer[0] = 0x1b;
            cnv->charErrorBuffer[1] = 0x25;
            cnv->charErrorBuffer[2] = 0x42;

            cnv->sharedData=(UConverterSharedData*)&_ISO2022Data;
            /* initialize the state variables */
            uprv_strcpy(myConverterData->name,"ISO_2022");
#else
            *errorCode = U_MISSING_RESOURCE_ERROR;
            // Was U_UNSUPPORTED_ERROR but changed in ICU 55 to a more standard
            // data loading error code.
            return;
#endif
        }

        cnv->maxBytesPerUChar=cnv->sharedData->staticData->maxBytesPerChar;

        if(U_FAILURE(*errorCode) || pArgs->onlyTestIsLoadable) {
            _ISO2022Close(cnv);
        }
    } else {
        *errorCode = U_MEMORY_ALLOCATION_ERROR;
    }
}


static void U_CALLCONV
_ISO2022Close(UConverter *converter) {
    UConverterDataISO2022* myData = static_cast<UConverterDataISO2022*>(converter->extraInfo);
    UConverterSharedData **array = myData->myConverterArray;
    int32_t i;

    if (converter->extraInfo != nullptr) {
        /*close the array of converter pointers and free the memory*/
        for (i=0; i<UCNV_2022_MAX_CONVERTERS; i++) {
            if(array[i]!=nullptr) {
                ucnv_unloadSharedDataIfReady(array[i]);
            }
        }

        ucnv_close(myData->currentConverter);

        if(!converter->isExtraLocal){
            uprv_free (converter->extraInfo);
            converter->extraInfo = nullptr;
        }
    }
}

static void U_CALLCONV
_ISO2022Reset(UConverter *converter, UConverterResetChoice choice) {
    UConverterDataISO2022* myConverterData = static_cast<UConverterDataISO2022*>(converter->extraInfo);
    if(choice<=UCNV_RESET_TO_UNICODE) {
        uprv_memset(&myConverterData->toU2022State, 0, sizeof(ISO2022State));
        myConverterData->key = 0;
        myConverterData->isEmptySegment = false;
    }
    if(choice!=UCNV_RESET_TO_UNICODE) {
        uprv_memset(&myConverterData->fromU2022State, 0, sizeof(ISO2022State));
    }
#ifdef U_ENABLE_GENERIC_ISO_2022
    if(myConverterData->locale[0] == 0){
        if(choice<=UCNV_RESET_TO_UNICODE) {
            myConverterData->isFirstBuffer = true;
            myConverterData->key = 0;
            if (converter->mode == UCNV_SO){
                ucnv_close (myConverterData->currentConverter);
                myConverterData->currentConverter=nullptr;
            }
            converter->mode = UCNV_SI;
        }
        if(choice!=UCNV_RESET_TO_UNICODE) {
            /* re-append UTF-8 escape sequence */
            converter->charErrorBufferLength = 3;
            converter->charErrorBuffer[0] = 0x1b;
            converter->charErrorBuffer[1] = 0x28;
            converter->charErrorBuffer[2] = 0x42;
        }
    }
    else
#endif
    {
        /* reset the state variables */
        if(myConverterData->locale[0] == 'k'){
            if(choice<=UCNV_RESET_TO_UNICODE) {
                setInitialStateToUnicodeKR(converter, myConverterData);
            }
            if(choice!=UCNV_RESET_TO_UNICODE) {
                setInitialStateFromUnicodeKR(converter, myConverterData);
            }
        }
    }
}

U_CDECL_BEGIN

static const char * U_CALLCONV
_ISO2022getName(const UConverter* cnv){
    if(cnv->extraInfo){
        UConverterDataISO2022* myData= (UConverterDataISO2022*)cnv->extraInfo;
        return myData->name;
    }
    return nullptr;
}

U_CDECL_END


/*************** to unicode *******************/
/****************************************************************************
 * Recognized escape sequences are
 * <ESC>(B  ASCII
 * <ESC>.A  ISO-8859-1
 * <ESC>.F  ISO-8859-7
 * <ESC>(J  JISX-201
 * <ESC>(I  JISX-201
 * <ESC>$B  JISX-208
 * <ESC>$@  JISX-208
 * <ESC>$(D JISX-212
 * <ESC>$A  GB2312
 * <ESC>$(C KSC5601
 */
static const int8_t nextStateToUnicodeJP[MAX_STATES_2022]= {
/*      0                1               2               3               4               5               6               7               8               9    */
    INVALID_STATE   ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,SS2_STATE      ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE
    ,ASCII          ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,JISX201        ,HWKANA_7BIT    ,JISX201        ,INVALID_STATE
    ,INVALID_STATE  ,INVALID_STATE  ,JISX208        ,GB2312         ,JISX208        ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE
    ,ISO8859_1      ,ISO8859_7      ,JISX208        ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,KSC5601        ,JISX212        ,INVALID_STATE
    ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE
    ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE
    ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE
    ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE
};

#if !UCONFIG_ONLY_HTML_CONVERSION
/*************** to unicode *******************/
static const int8_t nextStateToUnicodeCN[MAX_STATES_2022]= {
/*      0                1               2               3               4               5               6               7               8               9    */
     INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,SS2_STATE      ,SS3_STATE      ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE
    ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE
    ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE
    ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE
    ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,GB2312_1       ,INVALID_STATE  ,ISO_IR_165
    ,CNS_11643_1    ,CNS_11643_2    ,CNS_11643_3    ,CNS_11643_4    ,CNS_11643_5    ,CNS_11643_6    ,CNS_11643_7    ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE
    ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE
    ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE  ,INVALID_STATE
};
#endif


static UCNV_TableStates_2022
getKey_2022(char c,int32_t* key,int32_t* offset){
    int32_t togo;
    int32_t low = 0;
    int32_t hi = MAX_STATES_2022;
    int32_t oldmid=0;

    togo = normalize_esq_chars_2022[static_cast<uint8_t>(c)];
    if(togo == 0) {
        /* not a valid character anywhere in an escape sequence */
        *key = 0;
        *offset = 0;
        return INVALID_2022;
    }
    togo = (*key << 5) + togo;

    while (hi != low)  /*binary search*/{

        int32_t mid = (hi+low) >> 1; /*Finds median*/

        if (mid == oldmid)
            break;

        if (escSeqStateTable_Key_2022[mid] > togo){
            hi = mid;
        }
        else if (escSeqStateTable_Key_2022[mid] < togo){
            low = mid;
        }
        else /*we found it*/{
            *key = togo;
            *offset = mid;
            return static_cast<UCNV_TableStates_2022>(escSeqStateTable_Value_2022[mid]);
        }
        oldmid = mid;

    }

    *key = 0;
    *offset = 0;
    return INVALID_2022;
}

/*runs through a state machine to determine the escape sequence - codepage correspondence
 */
static void
changeState_2022(UConverter* _this,
                const char** source,
                const char* sourceLimit,
                Variant2022 var,
                UErrorCode* err){
    UCNV_TableStates_2022 value;
    UConverterDataISO2022* myData2022 = static_cast<UConverterDataISO2022*>(_this->extraInfo);
    uint32_t key = myData2022->key;
    int32_t offset = 0;
    int8_t initialToULength = _this->toULength;
    char c;

    value = VALID_NON_TERMINAL_2022;
    while (*source < sourceLimit) {
        c = *(*source)++;
        _this->toUBytes[_this->toULength++] = static_cast<uint8_t>(c);
        value = getKey_2022(c, reinterpret_cast<int32_t*>(&key), &offset);

        switch (value){

        case VALID_NON_TERMINAL_2022 :
            /* continue with the loop */
            break;

        case VALID_TERMINAL_2022:
            key = 0;
            goto DONE;

        case INVALID_2022:
            goto DONE;

        case VALID_MAYBE_TERMINAL_2022:
#ifdef U_ENABLE_GENERIC_ISO_2022
            /* ESC ( B is ambiguous only for ISO_2022 itself */
            if(var == ISO_2022) {
                /* discard toUBytes[] for ESC ( B because this sequence is correct and complete */
                _this->toULength = 0;

                /* TODO need to indicate that ESC ( B was seen; if failure, then need to replay from source or from MBCS-style replay */

                /* continue with the loop */
                value = VALID_NON_TERMINAL_2022;
                break;
            } else
#endif
            {
                /* not ISO_2022 itself, finish here */
                value = VALID_TERMINAL_2022;
                key = 0;
                goto DONE;
            }
        }
    }

DONE:
    myData2022->key = key;

    if (value == VALID_NON_TERMINAL_2022) {
        /* indicate that the escape sequence is incomplete: key!=0 */
        return;
    } else if (value == INVALID_2022 ) {
        *err = U_ILLEGAL_ESCAPE_SEQUENCE;
    } else /* value == VALID_TERMINAL_2022 */ {
        switch(var){
#ifdef U_ENABLE_GENERIC_ISO_2022
        case ISO_2022:
        {
            const char *chosenConverterName = escSeqStateTable_Result_2022[offset];
            if(chosenConverterName == nullptr) {
                /* SS2 or SS3 */
                *err = U_UNSUPPORTED_ESCAPE_SEQUENCE;
                _this->toUCallbackReason = UCNV_UNASSIGNED;
                return;
            }

            _this->mode = UCNV_SI;
            ucnv_close(myData2022->currentConverter);
            myData2022->currentConverter = myUConverter = ucnv_open(chosenConverterName, err);
            if(U_SUCCESS(*err)) {
                myUConverter->fromCharErrorBehaviour = UCNV_TO_U_CALLBACK_STOP;
                _this->mode = UCNV_SO;
            }
            break;
        }
#endif
        case ISO_2022_JP:
            {
                StateEnum tempState = static_cast<StateEnum>(nextStateToUnicodeJP[offset]);
                switch(tempState) {
                case INVALID_STATE:
                    *err = U_UNSUPPORTED_ESCAPE_SEQUENCE;
                    break;
                case SS2_STATE:
                    if(myData2022->toU2022State.cs[2]!=0) {
                        if(myData2022->toU2022State.g<2) {
                            myData2022->toU2022State.prevG=myData2022->toU2022State.g;
                        }
                        myData2022->toU2022State.g=2;
                    } else {
                        /* illegal to have SS2 before a matching designator */
                        *err = U_ILLEGAL_ESCAPE_SEQUENCE;
                    }
                    break;
                /* case SS3_STATE: not used in ISO-2022-JP-x */
                case ISO8859_1:
                case ISO8859_7:
                    if((jpCharsetMasks[myData2022->version] & CSM(tempState)) == 0) {
                        *err = U_UNSUPPORTED_ESCAPE_SEQUENCE;
                    } else {
                        /* G2 charset for SS2 */
                        myData2022->toU2022State.cs[2] = static_cast<int8_t>(tempState);
                    }
                    break;
                default:
                    if((jpCharsetMasks[myData2022->version] & CSM(tempState)) == 0) {
                        *err = U_UNSUPPORTED_ESCAPE_SEQUENCE;
                    } else {
                        /* G0 charset */
                        myData2022->toU2022State.cs[0] = static_cast<int8_t>(tempState);
                    }
                    break;
                }
            }
            break;
#if !UCONFIG_ONLY_HTML_CONVERSION
        case ISO_2022_CN:
            {
                StateEnum tempState = static_cast<StateEnum>(nextStateToUnicodeCN[offset]);
                switch(tempState) {
                case INVALID_STATE:
                    *err = U_UNSUPPORTED_ESCAPE_SEQUENCE;
                    break;
                case SS2_STATE:
                    if(myData2022->toU2022State.cs[2]!=0) {
                        if(myData2022->toU2022State.g<2) {
                            myData2022->toU2022State.prevG=myData2022->toU2022State.g;
                        }
                        myData2022->toU2022State.g=2;
                    } else {
                        /* illegal to have SS2 before a matching designator */
                        *err = U_ILLEGAL_ESCAPE_SEQUENCE;
                    }
                    break;
                case SS3_STATE:
                    if(myData2022->toU2022State.cs[3]!=0) {
                        if(myData2022->toU2022State.g<2) {
                            myData2022->toU2022State.prevG=myData2022->toU2022State.g;
                        }
                        myData2022->toU2022State.g=3;
                    } else {
                        /* illegal to have SS3 before a matching designator */
                        *err = U_ILLEGAL_ESCAPE_SEQUENCE;
                    }
                    break;
                case ISO_IR_165:
                    if(myData2022->version==0) {
                        *err = U_UNSUPPORTED_ESCAPE_SEQUENCE;
                        break;
                    }
                    U_FALLTHROUGH;
                case GB2312_1:
                    U_FALLTHROUGH;
                case CNS_11643_1:
                    myData2022->toU2022State.cs[1] = static_cast<int8_t>(tempState);
                    break;
                case CNS_11643_2:
                    myData2022->toU2022State.cs[2] = static_cast<int8_t>(tempState);
                    break;
                default:
                    /* other CNS 11643 planes */
                    if(myData2022->version==0) {
                        *err = U_UNSUPPORTED_ESCAPE_SEQUENCE;
                    } else {
                        myData2022->toU2022State.cs[3] = static_cast<int8_t>(tempState);
                    }
                    break;
                }
            }
            break;
        case ISO_2022_KR:
            if(offset==0x30){
                /* nothing to be done, just accept this one escape sequence */
            } else {
                *err = U_UNSUPPORTED_ESCAPE_SEQUENCE;
            }
            break;
#endif  // !UCONFIG_ONLY_HTML_CONVERSION

        default:
            *err = U_ILLEGAL_ESCAPE_SEQUENCE;
            break;
        }
    }
    if(U_SUCCESS(*err)) {
        _this->toULength = 0;
    } else if(*err==U_ILLEGAL_ESCAPE_SEQUENCE) {
        if(_this->toULength>1) {
            /*
             * Ticket 5691: consistent illegal sequences:
             * - We include at least the first byte (ESC) in the illegal sequence.
             * - If any of the non-initial bytes could be the start of a character,
             *   we stop the illegal sequence before the first one of those.
             *   In escape sequences, all following bytes are "printable", that is,
             *   unless they are completely illegal (>7f in SBCS, outside 21..7e in DBCS),
             *   they are valid single/lead bytes.
             *   For simplicity, we always only report the initial ESC byte as the
             *   illegal sequence and back out all other bytes we looked at.
             */
            /* Back out some bytes. */
            int8_t backOutDistance=_this->toULength-1;
            int8_t bytesFromThisBuffer=_this->toULength-initialToULength;
            if(backOutDistance<=bytesFromThisBuffer) {
                /* same as initialToULength<=1 */
                *source-=backOutDistance;
            } else {
                /* Back out bytes from the previous buffer: Need to replay them. */
                _this->preToULength = static_cast<int8_t>(bytesFromThisBuffer - backOutDistance);
                /* same as -(initialToULength-1) */
                /* preToULength is negative! */
                uprv_memcpy(_this->preToU, _this->toUBytes+1, -_this->preToULength);
                *source-=bytesFromThisBuffer;
            }
            _this->toULength=1;
        }
    } else if(*err==U_UNSUPPORTED_ESCAPE_SEQUENCE) {
        _this->toUCallbackReason = UCNV_UNASSIGNED;
    }
}

#if !UCONFIG_ONLY_HTML_CONVERSION
/*Checks the characters of the buffer against valid 2022 escape sequences
*if the match we return a pointer to the initial start of the sequence otherwise
*we return sourceLimit
*/
/*for 2022 looks ahead in the stream
 *to determine the longest possible convertible
 *data stream
 */
static inline const char*
getEndOfBuffer_2022(const char** source,
                   const char* sourceLimit,
                   UBool /*flush*/){

    const char* mySource = *source;

#ifdef U_ENABLE_GENERIC_ISO_2022
    if (*source >= sourceLimit)
        return sourceLimit;

    do{

        if (*mySource == ESC_2022){
            int8_t i;
            int32_t key = 0;
            int32_t offset;
            UCNV_TableStates_2022 value = VALID_NON_TERMINAL_2022;

            /* Kludge: I could not
            * figure out the reason for validating an escape sequence
            * twice - once here and once in changeState_2022().
            * is it possible to have an ESC character in a ISO2022
            * byte stream which is valid in a code page? Is it legal?
            */
            for (i=0;
            (mySource+i < sourceLimit)&&(value == VALID_NON_TERMINAL_2022);
            i++) {
                value =  getKey_2022(*(mySource+i), &key, &offset);
            }
            if (value > 0 || *mySource==ESC_2022)
                return mySource;

            if ((value == VALID_NON_TERMINAL_2022)&&(!flush) )
                return sourceLimit;
        }
    }while (++mySource < sourceLimit);

    return sourceLimit;
#else
    while(mySource < sourceLimit && *mySource != ESC_2022) {
        ++mySource;
    }
    return mySource;
#endif
}
#endif

/* This inline function replicates code in _MBCSFromUChar32() function in ucnvmbcs.c
 * any future change in _MBCSFromUChar32() function should be reflected here.
 * @return number of bytes in *value; negative number if fallback; 0 if no mapping
 */
static inline int32_t
MBCS_FROM_UCHAR32_ISO2022(UConverterSharedData* sharedData,
                                         UChar32 c,
                                         uint32_t* value,
                                         UBool useFallback,
                                         int outputType)
{
    const int32_t *cx;
    const uint16_t *table;
    uint32_t stage2Entry;
    uint32_t myValue;
    int32_t length;
    const uint8_t *p;
    /*
     * TODO(markus): Use and require new, faster MBCS conversion table structures.
     * Use internal version of ucnv_open() that verifies that the new structures are available,
     * else U_INTERNAL_PROGRAM_ERROR.
     */
    /* BMP-only codepages are stored without stage 1 entries for supplementary code points */
    if(c<0x10000 || (sharedData->mbcs.unicodeMask&UCNV_HAS_SUPPLEMENTARY)) {
        table=sharedData->mbcs.fromUnicodeTable;
        stage2Entry=MBCS_STAGE_2_FROM_U(table, c);
        /* get the bytes and the length for the output */
        if(outputType==MBCS_OUTPUT_2){
            myValue=MBCS_VALUE_2_FROM_STAGE_2(sharedData->mbcs.fromUnicodeBytes, stage2Entry, c);
            if(myValue<=0xff) {
                length=1;
            } else {
                length=2;
            }
        } else /* outputType==MBCS_OUTPUT_3 */ {
            p=MBCS_POINTER_3_FROM_STAGE_2(sharedData->mbcs.fromUnicodeBytes, stage2Entry, c);
            myValue = (static_cast<uint32_t>(*p) << 16) | (static_cast<uint32_t>(p[1]) << 8) | p[2];
            if(myValue<=0xff) {
                length=1;
            } else if(myValue<=0xffff) {
                length=2;
            } else {
                length=3;
            }
        }
        /* is this code point assigned, or do we use fallbacks? */
        if((stage2Entry&(1<<(16+(c&0xf))))!=0) {
            /* assigned */
            *value=myValue;
            return length;
        } else if(FROM_U_USE_FALLBACK(useFallback, c) && myValue!=0) {
            /*
             * We allow a 0 byte output if the "assigned" bit is set for this entry.
             * There is no way with this data structure for fallback output
             * to be a zero byte.
             */
            *value=myValue;
            return -length;
        }
    }

    cx=sharedData->mbcs.extIndexes;
    if(cx!=nullptr) {
        return ucnv_extSimpleMatchFromU(cx, c, value, useFallback);
    }

    /* unassigned */
    return 0;
}

/* This inline function replicates code in _MBCSSingleFromUChar32() function in ucnvmbcs.c
 * any future change in _MBCSSingleFromUChar32() function should be reflected here.
 * @param retval pointer to output byte
 * @return 1 roundtrip byte  0 no mapping  -1 fallback byte
 */
static inline int32_t
MBCS_SINGLE_FROM_UCHAR32(UConverterSharedData* sharedData,
                                       UChar32 c,
                                       uint32_t* retval,
                                       UBool useFallback)
{
    const uint16_t *table;
    int32_t value;
    /* BMP-only codepages are stored without stage 1 entries for supplementary code points */
    if(c>=0x10000 && !(sharedData->mbcs.unicodeMask&UCNV_HAS_SUPPLEMENTARY)) {
        return 0;
    }
    /* convert the Unicode code point in c into codepage bytes (same as in _MBCSFromUnicodeWithOffsets) */
    table=sharedData->mbcs.fromUnicodeTable;
    /* get the byte for the output */
    value=MBCS_SINGLE_RESULT_FROM_U(table, (uint16_t *)sharedData->mbcs.fromUnicodeBytes, c);
    /* is this code point assigned, or do we use fallbacks? */
    *retval = static_cast<uint32_t>(value & 0xff);
    if(value>=0xf00) {
        return 1;  /* roundtrip */
    } else if(useFallback ? value>=0x800 : value>=0xc00) {
        return -1;  /* fallback taken */
    } else {
        return 0;  /* no mapping */
    }
}

/*
 * Check that the result is a 2-byte value with each byte in the range A1..FE
 * (strict EUC DBCS) before accepting it and subtracting 0x80 from each byte
 * to move it to the ISO 2022 range 21..7E.
 * Return 0 if out of range.
 */
static inline uint32_t
_2022FromGR94DBCS(uint32_t value) {
    if (static_cast<uint16_t>(value - 0xa1a1) <= (0xfefe - 0xa1a1) &&
        static_cast<uint8_t>(value - 0xa1) <= (0xfe - 0xa1)
    ) {
        return value - 0x8080;  /* shift down to 21..7e byte range */
    } else {
        return 0;  /* not valid for ISO 2022 */
    }
}

#if 0 /* 5691: Call sites now check for validity. They can just += 0x8080 after that. */
/*
 * This method does the reverse of _2022FromGR94DBCS(). Given the 2022 code point, it returns the
 * 2 byte value that is in the range A1..FE for each byte. Otherwise it returns the 2022 code point
 * unchanged. 
 */
static inline uint32_t
_2022ToGR94DBCS(uint32_t value) {
    uint32_t returnValue = value + 0x8080;
    if( (uint16_t)(returnValue - 0xa1a1) <= (0xfefe - 0xa1a1) &&
        (uint8_t)(returnValue - 0xa1) <= (0xfe - 0xa1)) {
        return returnValue;
    } else {
        return value;
    }
}
#endif

#ifdef U_ENABLE_GENERIC_ISO_2022

/**********************************************************************************
*  ISO-2022 Converter
*
*
*/

static void U_CALLCONV
T_UConverter_toUnicode_ISO_2022_OFFSETS_LOGIC(UConverterToUnicodeArgs* args,
                                                           UErrorCode* err){
    const char* mySourceLimit, *realSourceLimit;
    const char* sourceStart;
    const char16_t* myTargetStart;
    UConverter* saveThis;
    UConverterDataISO2022* myData;
    int8_t length;

    saveThis = args->converter;
    myData=((UConverterDataISO2022*)(saveThis->extraInfo));

    realSourceLimit = args->sourceLimit;
    while (args->source < realSourceLimit) {
        if(myData->key == 0) { /* are we in the middle of an escape sequence? */
            /*Find the end of the buffer e.g : Next Escape Seq | end of Buffer*/
            mySourceLimit = getEndOfBuffer_2022(&(args->source), realSourceLimit, args->flush);

            if(args->source < mySourceLimit) {
                if(myData->currentConverter==nullptr) {
                    myData->currentConverter = ucnv_open("ASCII",err);
                    if(U_FAILURE(*err)){
                        return;
                    }

                    myData->currentConverter->fromCharErrorBehaviour = UCNV_TO_U_CALLBACK_STOP;
                    saveThis->mode = UCNV_SO;
                }

                /* convert to before the ESC or until the end of the buffer */
                myData->isFirstBuffer=false;
                sourceStart = args->source;
                myTargetStart = args->target;
                args->converter = myData->currentConverter;
                ucnv_toUnicode(args->converter,
                    &args->target,
                    args->targetLimit,
                    &args->source,
                    mySourceLimit,
                    args->offsets,
                    (UBool)(args->flush && mySourceLimit == realSourceLimit),
                    err);
                args->converter = saveThis;

                if (*err == U_BUFFER_OVERFLOW_ERROR) {
                    /* move the overflow buffer */
                    length = saveThis->UCharErrorBufferLength = myData->currentConverter->UCharErrorBufferLength;
                    myData->currentConverter->UCharErrorBufferLength = 0;
                    if(length > 0) {
                        uprv_memcpy(saveThis->UCharErrorBuffer,
                                    myData->currentConverter->UCharErrorBuffer,
                                    length*U_SIZEOF_UCHAR);
                    }
                    return;
                }

                /*
                 * At least one of:
                 * -Error while converting
                 * -Done with entire buffer
                 * -Need to write offsets or update the current offset
                 *  (leave that up to the code in ucnv.c)
                 *
                 * or else we just stopped at an ESC byte and continue with changeState_2022()
                 */
                if (U_FAILURE(*err) ||
                    (args->source == realSourceLimit) ||
                    (args->offsets != nullptr && (args->target != myTargetStart || args->source != sourceStart) ||
                    (mySourceLimit < realSourceLimit && myData->currentConverter->toULength > 0))
                ) {
                    /* copy partial or error input for truncated detection and error handling */
                    if(U_FAILURE(*err)) {
                        length = saveThis->invalidCharLength = myData->currentConverter->invalidCharLength;
                        if(length > 0) {
                            uprv_memcpy(saveThis->invalidCharBuffer, myData->currentConverter->invalidCharBuffer, length);
                        }
                    } else {
                        length = saveThis->toULength = myData->currentConverter->toULength;
                        if(length > 0) {
                            uprv_memcpy(saveThis->toUBytes, myData->currentConverter->toUBytes, length);
                            if(args->source < mySourceLimit) {
                                *err = U_TRUNCATED_CHAR_FOUND; /* truncated input before ESC */
                            }
                        }
                    }
                    return;
                }
            }
        }

        sourceStart = args->source;
        changeState_2022(args->converter,
               &(args->source),
               realSourceLimit,
               ISO_2022,
               err);
        if (U_FAILURE(*err) || (args->source != sourceStart && args->offsets != nullptr)) {
            /* let the ucnv.c code update its current offset */
            return;
        }
    }
}

#endif

/*
 * To Unicode Callback helper function
 */
static void
toUnicodeCallback(UConverter *cnv,
                  const uint32_t sourceChar, const uint32_t targetUniChar,
                  UErrorCode* err){
    if(sourceChar>0xff){
        cnv->toUBytes[0] = static_cast<uint8_t>(sourceChar >> 8);
        cnv->toUBytes[1] = static_cast<uint8_t>(sourceChar);
        cnv->toULength = 2;
    }
    else{
        cnv->toUBytes[0] = static_cast<char>(sourceChar);
        cnv->toULength = 1;
    }

    if(targetUniChar == (missingCharMarker-1/*0xfffe*/)){
        *err = U_INVALID_CHAR_FOUND;
    }
    else{
        *err = U_ILLEGAL_CHAR_FOUND;
    }
}

/**************************************ISO-2022-JP*************************************************/

/************************************** IMPORTANT **************************************************
* The UConverter_fromUnicode_ISO2022_JP converter does not use ucnv_fromUnicode() functions for SBCS,DBCS and
* MBCS; instead, the values are obtained directly by calling _MBCSFromUChar32().
* The converter iterates over each Unicode codepoint
* to obtain the equivalent codepoints from the codepages supported. Since the source buffer is
* processed one char at a time it would make sense to reduce the extra processing a canned converter
* would do as far as possible.
*
* If the implementation of these macros or structure of sharedData struct change in the future, make
* sure that ISO-2022 is also changed.
***************************************************************************************************
*/

/***************************************************************************************************
* Rules for ISO-2022-jp encoding
* (i)   Escape sequences must be fully contained within a line they should not
*       span new lines or CRs
* (ii)  If the last character on a line is represented by two bytes then an ASCII or
*       JIS-Roman character escape sequence should follow before the line terminates
* (iii) If the first character on the line is represented by two bytes then a two
*       byte character escape sequence should precede it
* (iv)  If no escape sequence is encountered then the characters are ASCII
* (v)   Latin(ISO-8859-1) and Greek(ISO-8859-7) characters must be designated to G2,
*       and invoked with SS2 (ESC N).
* (vi)  If there is any G0 designation in text, there must be a switch to
*       ASCII or to JIS X 0201-Roman before a space character (but not
*       necessarily before "ESC 4/14 2/0" or "ESC N ' '") or control
*       characters such as tab or CRLF.
* (vi)  Supported encodings:
*          ASCII, JISX201, JISX208, JISX212, GB2312, KSC5601, ISO-8859-1,ISO-8859-7
*
*  source : RFC-1554
*
*          JISX201, JISX208,JISX212 : new .cnv data files created
*          KSC5601 : alias to ibm-949 mapping table
*          GB2312 : alias to ibm-1386 mapping table
*          ISO-8859-1 : Algorithmic implemented as LATIN1 case
*          ISO-8859-7 : alias to ibm-9409 mapping table
*/

/* preference order of JP charsets */
static const StateEnum jpCharsetPref[]={
    ASCII,
    JISX201,
    ISO8859_1,
    JISX208,
    ISO8859_7,
    JISX212,
    GB2312,
    KSC5601,
    HWKANA_7BIT
};

/*
 * The escape sequences must be in order of the enum constants like JISX201  = 3,
 * not in order of jpCharsetPref[]!
 */
static const char escSeqChars[][6] ={
    "\x1B\x28\x42",         /* <ESC>(B  ASCII       */
    "\x1B\x2E\x41",         /* <ESC>.A  ISO-8859-1  */
    "\x1B\x2E\x46",         /* <ESC>.F  ISO-8859-7  */
    "\x1B\x28\x4A",         /* <ESC>(J  JISX-201    */
    "\x1B\x24\x42",         /* <ESC>$B  JISX-208    */
    "\x1B\x24\x28\x44",     /* <ESC>$(D JISX-212    */
    "\x1B\x24\x41",         /* <ESC>$A  GB2312      */
    "\x1B\x24\x28\x43",     /* <ESC>$(C KSC5601     */
    "\x1B\x28\x49"          /* <ESC>(I  HWKANA_7BIT */

};
static  const int8_t escSeqCharsLen[] ={
    3, /* length of <ESC>(B  ASCII       */
    3, /* length of <ESC>.A  ISO-8859-1  */
    3, /* length of <ESC>.F  ISO-8859-7  */
    3, /* length of <ESC>(J  JISX-201    */
    3, /* length of <ESC>$B  JISX-208    */
    4, /* length of <ESC>$(D JISX-212    */
    3, /* length of <ESC>$A  GB2312      */
    4, /* length of <ESC>$(C KSC5601     */
    3  /* length of <ESC>(I  HWKANA_7BIT */
};

/*
* The iteration over various code pages works this way:
* i)   Get the currentState from myConverterData->currentState
* ii)  Check if the character is mapped to a valid character in the currentState
*      Yes ->  a) set the initIterState to currentState
*       b) remain in this state until an invalid character is found
*      No  ->  a) go to the next code page and find the character
* iii) Before changing the state increment the current state check if the current state
*      is equal to the intitIteration state
*      Yes ->  A character that cannot be represented in any of the supported encodings
*       break and return a U_INVALID_CHARACTER error
*      No  ->  Continue and find the character in next code page
*
*
* TODO: Implement a priority technique where the users are allowed to set the priority of code pages
*/

/* Map 00..7F to Unicode according to JIS X 0201. */
static inline uint32_t
jisx201ToU(uint32_t value) {
    if(value < 0x5c) {
        return value;
    } else if(value == 0x5c) {
        return 0xa5;
    } else if(value == 0x7e) {
        return 0x203e;
    } else /* value <= 0x7f */ {
        return value;
    }
}

/* Map Unicode to 00..7F according to JIS X 0201. Return U+FFFE if unmappable. */
static inline uint32_t
jisx201FromU(uint32_t value) {
    if(value<=0x7f) {
        if(value!=0x5c && value!=0x7e) {
            return value;
        }
    } else if(value==0xa5) {
        return 0x5c;
    } else if(value==0x203e) {
        return 0x7e;
    }
    return 0xfffe;
}

/*
 * Take a valid Shift-JIS byte pair, check that it is in the range corresponding
 * to JIS X 0208, and convert it to a pair of 21..7E bytes.
 * Return 0 if the byte pair is out of range.
 */
static inline uint32_t
_2022FromSJIS(uint32_t value) {
    uint8_t trail;

    if(value > 0xEFFC) {
        return 0;  /* beyond JIS X 0208 */
    }

    trail = static_cast<uint8_t>(value);

    value &= 0xff00;  /* lead byte */
    if(value <= 0x9f00) {
        value -= 0x7000;
    } else /* 0xe000 <= value <= 0xef00 */ {
        value -= 0xb000;
    }
    value <<= 1;

    if(trail <= 0x9e) {
        value -= 0x100;
        if(trail <= 0x7e) {
            value |= trail - 0x1f;
        } else {
            value |= trail - 0x20;
        }
    } else /* trail <= 0xfc */ {
        value |= trail - 0x7e;
    }
    return value;
}

/*
 * Convert a pair of JIS X 0208 21..7E bytes to Shift-JIS.
 * If either byte is outside 21..7E make sure that the result is not valid
 * for Shift-JIS so that the converter catches it.
 * Some invalid byte values already turn into equally invalid Shift-JIS
 * byte values and need not be tested explicitly.
 */
static inline void
_2022ToSJIS(uint8_t c1, uint8_t c2, char bytes[2]) {
    if(c1&1) {
        ++c1;
        if(c2 <= 0x5f) {
            c2 += 0x1f;
        } else if(c2 <= 0x7e) {
            c2 += 0x20;
        } else {
            c2 = 0;  /* invalid */
        }
    } else {
        if (static_cast<uint8_t>(c2 - 0x21) <= ((0x7e) - 0x21)) {
            c2 += 0x7e;
        } else {
            c2 = 0;  /* invalid */
        }
    }
    c1 >>= 1;
    if(c1 <= 0x2f) {
        c1 += 0x70;
    } else if(c1 <= 0x3f) {
        c1 += 0xb0;
    } else {
        c1 = 0;  /* invalid */
    }
    bytes[0] = static_cast<char>(c1);
    bytes[1] = static_cast<char>(c2);
}

/*
 * JIS X 0208 has fallbacks from Unicode half-width Katakana to full-width (DBCS)
 * Katakana.
 * Now that we use a Shift-JIS table for JIS X 0208 we need to hardcode these fallbacks
 * because Shift-JIS roundtrips half-width Katakana to single bytes.
 * These were the only fallbacks in ICU's jisx-208.ucm file.
 */
static const uint16_t hwkana_fb[HWKANA_END - HWKANA_START + 1] = {
    0x2123,  /* U+FF61 */
    0x2156,
    0x2157,
    0x2122,
    0x2126,
    0x2572,
    0x2521,
    0x2523,
    0x2525,
    0x2527,
    0x2529,
    0x2563,
    0x2565,
    0x2567,
    0x2543,
    0x213C,  /* U+FF70 */
    0x2522,
    0x2524,
    0x2526,
    0x2528,
    0x252A,
    0x252B,
    0x252D,
    0x252F,
    0x2531,
    0x2533,
    0x2535,
    0x2537,
    0x2539,
    0x253B,
    0x253D,
    0x253F,  /* U+FF80 */
    0x2541,
    0x2544,
    0x2546,
    0x2548,
    0x254A,
    0x254B,
    0x254C,
    0x254D,
    0x254E,
    0x254F,
    0x2552,
    0x2555,
    0x2558,
    0x255B,
    0x255E,
    0x255F,  /* U+FF90 */
    0x2560,
    0x2561,
    0x2562,
    0x2564,
    0x2566,
    0x2568,
    0x2569,
    0x256A,
    0x256B,
    0x256C,
    0x256D,
    0x256F,
    0x2573,
    0x212B,
    0x212C   /* U+FF9F */
};

static void U_CALLCONV
UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterFromUnicodeArgs* args, UErrorCode* err) {
    UConverter *cnv = args->converter;
    UConverterDataISO2022 *converterData;
    ISO2022State *pFromU2022State;
    uint8_t* target = reinterpret_cast<uint8_t*>(args->target);
    const uint8_t* targetLimit = reinterpret_cast<const uint8_t*>(args->targetLimit);
    const char16_t* source = args->source;
    const char16_t* sourceLimit = args->sourceLimit;
    int32_t* offsets = args->offsets;
    UChar32 sourceChar;
    char buffer[8];
    int32_t len, outLen;
    int8_t choices[10];
    int32_t choiceCount;
    uint32_t targetValue = 0;
    UBool useFallback;

    int32_t i;
    int8_t cs, g;

    /* set up the state */
    converterData = static_cast<UConverterDataISO2022*>(cnv->extraInfo);
    pFromU2022State   = &converterData->fromU2022State;

    choiceCount = 0;

    /* check if the last codepoint of previous buffer was a lead surrogate*/
    if((sourceChar = cnv->fromUChar32)!=0 && target< targetLimit) {
        goto getTrail;
    }

    while(source < sourceLimit) {
        if(target < targetLimit) {

            sourceChar  = *(source++);
            /*check if the char is a First surrogate*/
            if(U16_IS_SURROGATE(sourceChar)) {
                if(U16_IS_SURROGATE_LEAD(sourceChar)) {
getTrail:
                    /*look ahead to find the trail surrogate*/
                    if(source < sourceLimit) {
                        /* test the following code unit */
                        char16_t trail = *source;
                        if(U16_IS_TRAIL(trail)) {
                            source++;
                            sourceChar=U16_GET_SUPPLEMENTARY(sourceChar, trail);
                            cnv->fromUChar32=0x00;
                            /* convert this supplementary code point */
                            /* exit this condition tree */
                        } else {
                            /* this is an unmatched lead code unit (1st surrogate) */
                            /* callback(illegal) */
                            *err=U_ILLEGAL_CHAR_FOUND;
                            cnv->fromUChar32=sourceChar;
                            break;
                        }
                    } else {
                        /* no more input */
                        cnv->fromUChar32=sourceChar;
                        break;
                    }
                } else {
                    /* this is an unmatched trail code unit (2nd surrogate) */
                    /* callback(illegal) */
                    *err=U_ILLEGAL_CHAR_FOUND;
                    cnv->fromUChar32=sourceChar;
                    break;
                }
            }

            /* do not convert SO/SI/ESC */
            if(IS_2022_CONTROL(sourceChar)) {
                /* callback(illegal) */
                *err=U_ILLEGAL_CHAR_FOUND;
                cnv->fromUChar32=sourceChar;
                break;
            }

            /* do the conversion */

            if(choiceCount == 0) {
                uint16_t csm;

                /*
                 * The csm variable keeps track of which charsets are allowed
                 * and not used yet while building the choices[].
                 */
                csm = jpCharsetMasks[converterData->version];
                choiceCount = 0;

                /* JIS7/8: try single-byte half-width Katakana before JISX208 */
                if(converterData->version == 3 || converterData->version == 4) {
                    choices[choiceCount++] = static_cast<int8_t>(HWKANA_7BIT);
                }
                /* Do not try single-byte half-width Katakana for other versions. */
                csm &= ~CSM(HWKANA_7BIT);

                /* try the current G0 charset */
                choices[choiceCount++] = cs = pFromU2022State->cs[0];
                csm &= ~CSM(cs);

                /* try the current G2 charset */
                if((cs = pFromU2022State->cs[2]) != 0) {
                    choices[choiceCount++] = cs;
                    csm &= ~CSM(cs);
                }

                /* try all the other possible charsets */
                for(i = 0; i < UPRV_LENGTHOF(jpCharsetPref); ++i) {
                    cs = static_cast<int8_t>(jpCharsetPref[i]);
                    if(CSM(cs) & csm) {
                        choices[choiceCount++] = cs;
                        csm &= ~CSM(cs);
                    }
                }
            }

            cs = g = 0;
            /*
             * len==0: no mapping found yet
             * len<0: found a fallback result: continue looking for a roundtrip but no further fallbacks
             * len>0: found a roundtrip result, done
             */
            len = 0;
            /*
             * We will turn off useFallback after finding a fallback,
             * but we still get fallbacks from PUA code points as usual.
             * Therefore, we will also need to check that we don't overwrite
             * an early fallback with a later one.
             */
            useFallback = cnv->useFallback;

            for(i = 0; i < choiceCount && len <= 0; ++i) {
                uint32_t value;
                int32_t len2;
                int8_t cs0 = choices[i];
                switch(cs0) {
                case ASCII:
                    if(sourceChar <= 0x7f) {
                        targetValue = static_cast<uint32_t>(sourceChar);
                        len = 1;
                        cs = cs0;
                        g = 0;
                    }
                    break;
                case ISO8859_1:
                    if(GR96_START <= sourceChar && sourceChar <= GR96_END) {
                        targetValue = static_cast<uint32_t>(sourceChar) - 0x80;
                        len = 1;
                        cs = cs0;
                        g = 2;
                    }
                    break;
                case HWKANA_7BIT:
                    if (static_cast<uint32_t>(sourceChar - HWKANA_START) <= (HWKANA_END - HWKANA_START)) {
                        if(converterData->version==3) {
                            /* JIS7: use G1 (SO) */
                            /* Shift U+FF61..U+FF9F to bytes 21..5F. */
                            targetValue = static_cast<uint32_t>(sourceChar - (HWKANA_START - 0x21));
                            len = 1;
                            pFromU2022State->cs[1] = cs = cs0; /* do not output an escape sequence */
                            g = 1;
                        } else if(converterData->version==4) {
                            /* JIS8: use 8-bit bytes with any single-byte charset, see escape sequence output below */
                            /* Shift U+FF61..U+FF9F to bytes A1..DF. */
                            targetValue = static_cast<uint32_t>(sourceChar - (HWKANA_START - 0xa1));
                            len = 1;

                            cs = pFromU2022State->cs[0];
                            if(IS_JP_DBCS(cs)) {
                                /* switch from a DBCS charset to JISX201 */
                                cs = static_cast<int8_t>(JISX201);
                            }
                            /* else stay in the current G0 charset */
                            g = 0;
                        }
                        /* else do not use HWKANA_7BIT with other versions */
                    }
                    break;
                case JISX201:
                    /* G0 SBCS */
                    value = jisx201FromU(sourceChar);
                    if(value <= 0x7f) {
                        targetValue = value;
                        len = 1;
                        cs = cs0;
                        g = 0;
                        useFallback = false;
                    }
                    break;
                case JISX208:
                    /* G0 DBCS from Shift-JIS table */
                    len2 = MBCS_FROM_UCHAR32_ISO2022(
                                converterData->myConverterArray[cs0],
                                sourceChar, &value,
                                useFallback, MBCS_OUTPUT_2);
                    if(len2 == 2 || (len2 == -2 && len == 0)) {  /* only accept DBCS: abs(len)==2 */
                        value = _2022FromSJIS(value);
                        if(value != 0) {
                            targetValue = value;
                            len = len2;
                            cs = cs0;
                            g = 0;
                            useFallback = false;
                        }
                    } else if(len == 0 && useFallback &&
                              static_cast<uint32_t>(sourceChar - HWKANA_START) <= (HWKANA_END - HWKANA_START)) {
                        targetValue = hwkana_fb[sourceChar - HWKANA_START];
                        len = -2;
                        cs = cs0;
                        g = 0;
                        useFallback = false;
                    }
                    break;
                case ISO8859_7:
                    /* G0 SBCS forced to 7-bit output */
                    len2 = MBCS_SINGLE_FROM_UCHAR32(
                                converterData->myConverterArray[cs0],
                                sourceChar, &value,
                                useFallback);
                    if(len2 != 0 && !(len2 < 0 && len != 0) && GR96_START <= value && value <= GR96_END) {
                        targetValue = value - 0x80;
                        len = len2;
                        cs = cs0;
                        g = 2;
                        useFallback = false;
                    }
                    break;
                default:
                    /* G0 DBCS */
                    len2 = MBCS_FROM_UCHAR32_ISO2022(
                                converterData->myConverterArray[cs0],
                                sourceChar, &value,
                                useFallback, MBCS_OUTPUT_2);
                    if(len2 == 2 || (len2 == -2 && len == 0)) {  /* only accept DBCS: abs(len)==2 */
                        if(cs0 == KSC5601) {
                            /*
                             * Check for valid bytes for the encoding scheme.
                             * This is necessary because the sub-converter (windows-949)
                             * has a broader encoding scheme than is valid for 2022.
                             */
                            value = _2022FromGR94DBCS(value);
                            if(value == 0) {
                                break;
                            }
                        }
                        targetValue = value;
                        len = len2;
                        cs = cs0;
                        g = 0;
                        useFallback = false;
                    }
                    break;
                }
            }

            if(len != 0) {
                if(len < 0) {
                    len = -len;  /* fallback */
                }
                outLen = 0; /* count output bytes */

                /* write SI if necessary (only for JIS7) */
                if(pFromU2022State->g == 1 && g == 0) {
                    buffer[outLen++] = UCNV_SI;
                    pFromU2022State->g = 0;
                }

                /* write the designation sequence if necessary */
                if(cs != pFromU2022State->cs[g]) {
                    int32_t escLen = escSeqCharsLen[cs];
                    uprv_memcpy(buffer + outLen, escSeqChars[cs], escLen);
                    outLen += escLen;
                    pFromU2022State->cs[g] = cs;

                    /* invalidate the choices[] */
                    choiceCount = 0;
                }

                /* write the shift sequence if necessary */
                if(g != pFromU2022State->g) {
                    switch(g) {
                    /* case 0 handled before writing escapes */
                    case 1:
                        buffer[outLen++] = UCNV_SO;
                        pFromU2022State->g = 1;
                        break;
                    default: /* case 2 */
                        buffer[outLen++] = 0x1b;
                        buffer[outLen++] = 0x4e;
                        break;
                    /* no case 3: no SS3 in ISO-2022-JP-x */
                    }
                }

                /* write the output bytes */
                if(len == 1) {
                    buffer[outLen++] = static_cast<char>(targetValue);
                } else /* len == 2 */ {
                    buffer[outLen++] = static_cast<char>(targetValue >> 8);
                    buffer[outLen++] = static_cast<char>(targetValue);
                }
            } else {
                /*
                 * if we cannot find the character after checking all codepages
                 * then this is an error
                 */
                *err = U_INVALID_CHAR_FOUND;
                cnv->fromUChar32=sourceChar;
                break;
            }

            if(sourceChar == CR || sourceChar == LF) {
                /* reset the G2 state at the end of a line (conversion got us into ASCII or JISX201 already) */
                pFromU2022State->cs[2] = 0;
                choiceCount = 0;
            }

            /* output outLen>0 bytes in buffer[] */
            if(outLen == 1) {
                *target++ = buffer[0];
                if(offsets) {
                    *offsets++ = static_cast<int32_t>(source - args->source - 1); /* -1: known to be ASCII */
                }
            } else if(outLen == 2 && (target + 2) <= targetLimit) {
                *target++ = buffer[0];
                *target++ = buffer[1];
                if(offsets) {
                    int32_t sourceIndex = static_cast<int32_t>(source - args->source - U16_LENGTH(sourceChar));
                    *offsets++ = sourceIndex;
                    *offsets++ = sourceIndex;
                }
            } else {
                fromUWriteUInt8(
                    cnv,
                    buffer, outLen,
                    &target, reinterpret_cast<const char*>(targetLimit),
                    &offsets, static_cast<int32_t>(source - args->source - U16_LENGTH(sourceChar)),
                    err);
                if(U_FAILURE(*err)) {
                    break;
                }
            }
        } /* end if(myTargetIndex<myTargetLength) */
        else{
            *err =U_BUFFER_OVERFLOW_ERROR;
            break;
        }

    }/* end while(mySourceIndex<mySourceLength) */

    /*
     * the end of the input stream and detection of truncated input
     * are handled by the framework, but for ISO-2022-JP conversion
     * we need to be in ASCII mode at the very end
     *
     * conditions:
     *   successful
     *   in SO mode or not in ASCII mode
     *   end of input and no truncated input
     */
    if( U_SUCCESS(*err) &&
        (pFromU2022State->g!=0 || pFromU2022State->cs[0]!=ASCII) &&
        args->flush && source>=sourceLimit && cnv->fromUChar32==0
    ) {
        int32_t sourceIndex;

        outLen = 0;

        if(pFromU2022State->g != 0) {
            buffer[outLen++] = UCNV_SI;
            pFromU2022State->g = 0;
        }

        if(pFromU2022State->cs[0] != ASCII) {
            int32_t escLen = escSeqCharsLen[ASCII];
            uprv_memcpy(buffer + outLen, escSeqChars[ASCII], escLen);
            outLen += escLen;
            pFromU2022State->cs[0] = static_cast<int8_t>(ASCII);
        }

        /* get the source index of the last input character */
        /*
         * TODO this would be simpler and more reliable if we used a pair
         * of sourceIndex/prevSourceIndex like in ucnvmbcs.c
         * so that we could simply use the prevSourceIndex here;
         * this code gives an incorrect result for the rare case of an unmatched
         * trail surrogate that is alone in the last buffer of the text stream
         */
        sourceIndex = static_cast<int32_t>(source - args->source);
        if(sourceIndex>0) {
            --sourceIndex;
            if( U16_IS_TRAIL(args->source[sourceIndex]) &&
                (sourceIndex==0 || U16_IS_LEAD(args->source[sourceIndex-1]))
            ) {
                --sourceIndex;
            }
        } else {
            sourceIndex=-1;
        }

        fromUWriteUInt8(
            cnv,
            buffer, outLen,
            &target, reinterpret_cast<const char*>(targetLimit),
            &offsets, sourceIndex,
            err);
    }

    /*save the state and return */
    args->source = source;
    args->target = reinterpret_cast<char*>(target);
}

/*************** to unicode *******************/

static void U_CALLCONV
UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
                                               UErrorCode* err){
    char tempBuf[2];
    const char* mySource = const_cast<char*>(args->source);
    char16_t *myTarget = args->target;
    const char *mySourceLimit = args->sourceLimit;
    uint32_t targetUniChar = 0x0000;
    uint32_t mySourceChar = 0x0000;
    uint32_t tmpSourceChar = 0x0000;
    UConverterDataISO2022* myData;
    ISO2022State *pToU2022State;
    StateEnum cs;

    myData = static_cast<UConverterDataISO2022*>(args->converter->extraInfo);
    pToU2022State = &myData->toU2022State;

    if(myData->key != 0) {
        /* continue with a partial escape sequence */
        goto escape;
    } else if(args->converter->toULength == 1 && mySource < mySourceLimit && myTarget < args->targetLimit) {
        /* continue with a partial double-byte character */
        mySourceChar = args->converter->toUBytes[0];
        args->converter->toULength = 0;
        cs = static_cast<StateEnum>(pToU2022State->cs[pToU2022State->g]);
        targetUniChar = missingCharMarker;
        goto getTrailByte;
    }

    while(mySource < mySourceLimit){

        targetUniChar =missingCharMarker;

        if(myTarget < args->targetLimit){

            mySourceChar = static_cast<unsigned char>(*mySource++);

            switch(mySourceChar) {
            case UCNV_SI:
                if(myData->version==3) {
                    pToU2022State->g=0;
                    continue;
                } else {
                    /* only JIS7 uses SI/SO, not ISO-2022-JP-x */
                    myData->isEmptySegment = false;	/* reset this, we have a different error */
                    break;
                }

            case UCNV_SO:
                if(myData->version==3) {
                    /* JIS7: switch to G1 half-width Katakana */
                    pToU2022State->cs[1] = static_cast<int8_t>(HWKANA_7BIT);
                    pToU2022State->g=1;
                    continue;
                } else {
                    /* only JIS7 uses SI/SO, not ISO-2022-JP-x */
                    myData->isEmptySegment = false;	/* reset this, we have a different error */
                    break;
                }

            case ESC_2022:
                mySource--;
escape:
                {
                    const char * mySourceBefore = mySource;
                    int8_t toULengthBefore = args->converter->toULength;

                    changeState_2022(args->converter,&(mySource),
                        mySourceLimit, ISO_2022_JP,err);

                    /* If in ISO-2022-JP only and we successfully completed an escape sequence, but previous segment was empty, create an error */
                    if(myData->version==0 && myData->key==0 && U_SUCCESS(*err) && myData->isEmptySegment) {
                        *err = U_ILLEGAL_ESCAPE_SEQUENCE;
                        args->converter->toUCallbackReason = UCNV_IRREGULAR;
                        args->converter->toULength = static_cast<int8_t>(toULengthBefore + (mySource - mySourceBefore));
                    }
                }

                /* invalid or illegal escape sequence */
                if(U_FAILURE(*err)){
                    args->target = myTarget;
                    args->source = mySource;
                    myData->isEmptySegment = false;	/* Reset to avoid future spurious errors */
                    return;
                }
                /* If we successfully completed an escape sequence, we begin a new segment, empty so far */
                if(myData->key==0) {
                    myData->isEmptySegment = true;
                }
                continue;

            /* ISO-2022-JP does not use single-byte (C1) SS2 and SS3 */

            case CR:
            case LF:
                /* automatically reset to single-byte mode */
                if (static_cast<StateEnum>(pToU2022State->cs[0]) != ASCII &&
                    static_cast<StateEnum>(pToU2022State->cs[0]) != JISX201) {
                    pToU2022State->cs[0] = static_cast<int8_t>(ASCII);
                }
                pToU2022State->cs[2] = 0;
                pToU2022State->g = 0;
                U_FALLTHROUGH;
            default:
                /* convert one or two bytes */
                myData->isEmptySegment = false;
                cs = static_cast<StateEnum>(pToU2022State->cs[pToU2022State->g]);
                if (static_cast<uint8_t>(mySourceChar - 0xa1) <= (0xdf - 0xa1) && myData->version == 4 &&
                    !IS_JP_DBCS(cs)
                ) {
                    /* 8-bit halfwidth katakana in any single-byte mode for JIS8 */
                    targetUniChar = mySourceChar + (HWKANA_START - 0xa1);

                    /* return from a single-shift state to the previous one */
                    if(pToU2022State->g >= 2) {
                        pToU2022State->g=pToU2022State->prevG;
                    }
                } else switch(cs) {
                case ASCII:
                    if(mySourceChar <= 0x7f) {
                        targetUniChar = mySourceChar;
                    }
                    break;
                case ISO8859_1:
                    if(mySourceChar <= 0x7f) {
                        targetUniChar = mySourceChar + 0x80;
                    }
                    /* return from a single-shift state to the previous one */
                    pToU2022State->g=pToU2022State->prevG;
                    break;
                case ISO8859_7:
                    if(mySourceChar <= 0x7f) {
                        /* convert mySourceChar+0x80 to use a normal 8-bit table */
                        targetUniChar =
                            _MBCS_SINGLE_SIMPLE_GET_NEXT_BMP(
                                myData->myConverterArray[cs],
                                mySourceChar + 0x80);
                    }
                    /* return from a single-shift state to the previous one */
                    pToU2022State->g=pToU2022State->prevG;
                    break;
                case JISX201:
                    if(mySourceChar <= 0x7f) {
                        targetUniChar = jisx201ToU(mySourceChar);
                    }
                    break;
                case HWKANA_7BIT:
                    if (static_cast<uint8_t>(mySourceChar - 0x21) <= (0x5f - 0x21)) {
                        /* 7-bit halfwidth Katakana */
                        targetUniChar = mySourceChar + (HWKANA_START - 0x21);
                    }
                    break;
                default:
                    /* G0 DBCS */
                    if(mySource < mySourceLimit) {
                        int leadIsOk, trailIsOk;
                        uint8_t trailByte;
getTrailByte:
                        trailByte = static_cast<uint8_t>(*mySource);
                        /*
                         * Ticket 5691: consistent illegal sequences:
                         * - We include at least the first byte in the illegal sequence.
                         * - If any of the non-initial bytes could be the start of a character,
                         *   we stop the illegal sequence before the first one of those.
                         *
                         * In ISO-2022 DBCS, if the second byte is in the 21..7e range or is
                         * an ESC/SO/SI, we report only the first byte as the illegal sequence.
                         * Otherwise we convert or report the pair of bytes.
                         */
                        leadIsOk = static_cast<uint8_t>(mySourceChar - 0x21) <= (0x7e - 0x21);
                        trailIsOk = static_cast<uint8_t>(trailByte - 0x21) <= (0x7e - 0x21);
                        if (leadIsOk && trailIsOk) {
                            ++mySource;
                            tmpSourceChar = (mySourceChar << 8) | trailByte;
                            if(cs == JISX208) {
                                _2022ToSJIS(static_cast<uint8_t>(mySourceChar), trailByte, tempBuf);
                                mySourceChar = tmpSourceChar;
                            } else {
                                /* Copy before we modify tmpSourceChar so toUnicodeCallback() sees the correct bytes. */
                                mySourceChar = tmpSourceChar;
                                if (cs == KSC5601) {
                                    tmpSourceChar += 0x8080;  /* = _2022ToGR94DBCS(tmpSourceChar) */
                                }
                                tempBuf[0] = static_cast<char>(tmpSourceChar >> 8);
                                tempBuf[1] = static_cast<char>(tmpSourceChar);
                            }
                            targetUniChar = ucnv_MBCSSimpleGetNextUChar(myData->myConverterArray[cs], tempBuf, 2, false);
                        } else if (!(trailIsOk || IS_2022_CONTROL(trailByte))) {
                            /* report a pair of illegal bytes if the second byte is not a DBCS starter */
                            ++mySource;
                            /* add another bit so that the code below writes 2 bytes in case of error */
                            mySourceChar = 0x10000 | (mySourceChar << 8) | trailByte;
                        }
                    } else {
                        args->converter->toUBytes[0] = static_cast<uint8_t>(mySourceChar);
                        args->converter->toULength = 1;
                        goto endloop;
                    }
                }  /* End of inner switch */
                break;
            }  /* End of outer switch */
            if(targetUniChar < (missingCharMarker-1/*0xfffe*/)){
                if(args->offsets){
                    args->offsets[myTarget - args->target] = static_cast<int32_t>(mySource - args->source - (mySourceChar <= 0xff ? 1 : 2));
                }
                *(myTarget++) = static_cast<char16_t>(targetUniChar);
            }
            else if(targetUniChar > missingCharMarker){
                /* disassemble the surrogate pair and write to output*/
                targetUniChar-=0x0010000;
                *myTarget = static_cast<char16_t>(0xd800 + static_cast<char16_t>(targetUniChar >> 10));
                if(args->offsets){
                    args->offsets[myTarget - args->target] = static_cast<int32_t>(mySource - args->source - (mySourceChar <= 0xff ? 1 : 2));
                }
                ++myTarget;
                if(myTarget< args->targetLimit){
                    *myTarget = static_cast<char16_t>(0xdc00 + static_cast<char16_t>(targetUniChar & 0x3ff));
                    if(args->offsets){
                        args->offsets[myTarget - args->target] = static_cast<int32_t>(mySource - args->source - (mySourceChar <= 0xff ? 1 : 2));
                    }
                    ++myTarget;
                }else{
                    args->converter->UCharErrorBuffer[args->converter->UCharErrorBufferLength++]=
                                    static_cast<char16_t>(0xdc00 + static_cast<char16_t>(targetUniChar & 0x3ff));
                }

            }
            else{
                /* Call the callback function*/
                toUnicodeCallback(args->converter,mySourceChar,targetUniChar,err);
                break;
            }
        }
        else{    /* goes with "if(myTarget < args->targetLimit)"  way up near top of function */
            *err =U_BUFFER_OVERFLOW_ERROR;
            break;
        }
    }
endloop:
    args->target = myTarget;
    args->source = mySource;
}


#if !UCONFIG_ONLY_HTML_CONVERSION
/***************************************************************
*   Rules for ISO-2022-KR encoding
*   i) The KSC5601 designator sequence should appear only once in a file,
*      at the beginning of a line before any KSC5601 characters. This usually
*      means that it appears by itself on the first line of the file
*  ii) There are only 2 shifting sequences SO to shift into double byte mode
*      and SI to shift into single byte mode
*/
static void U_CALLCONV
UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterFromUnicodeArgs* args, UErrorCode* err){

    UConverter* saveConv = args->converter;
    UConverterDataISO2022* myConverterData = static_cast<UConverterDataISO2022*>(saveConv->extraInfo);
    args->converter=myConverterData->currentConverter;

    myConverterData->currentConverter->fromUChar32 = saveConv->fromUChar32;
    ucnv_MBCSFromUnicodeWithOffsets(args,err);
    saveConv->fromUChar32 = myConverterData->currentConverter->fromUChar32;

    if(*err == U_BUFFER_OVERFLOW_ERROR) {
        if(myConverterData->currentConverter->charErrorBufferLength > 0) {
            uprv_memcpy(
                saveConv->charErrorBuffer,
                myConverterData->currentConverter->charErrorBuffer,
                myConverterData->currentConverter->charErrorBufferLength);
        }
        saveConv->charErrorBufferLength = myConverterData->currentConverter->charErrorBufferLength;
        myConverterData->currentConverter->charErrorBufferLength = 0;
    }
    args->converter=saveConv;
}

static void U_CALLCONV
UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterFromUnicodeArgs* args, UErrorCode* err){

    const char16_t *source = args->source;
    const char16_t *sourceLimit = args->sourceLimit;
    unsigned char *target = reinterpret_cast<unsigned char*>(args->target);
    unsigned char *targetLimit = reinterpret_cast<unsigned char*>(const_cast<char*>(args->targetLimit));
    int32_t* offsets = args->offsets;
    uint32_t targetByteUnit = 0x0000;
    UChar32 sourceChar = 0x0000;
    UBool isTargetByteDBCS;
    UBool oldIsTargetByteDBCS;
    UConverterDataISO2022 *converterData;
    UConverterSharedData* sharedData;
    UBool useFallback;
    int32_t length =0;

    converterData = static_cast<UConverterDataISO2022*>(args->converter->extraInfo);
    /* if the version is 1 then the user is requesting
     * conversion with ibm-25546 pass the arguments to
     * MBCS converter and return
     */
    if(converterData->version==1){
        UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(args,err);
        return;
    }

    /* initialize data */
    sharedData = converterData->currentConverter->sharedData;
    useFallback = args->converter->useFallback;
    isTargetByteDBCS = static_cast<UBool>(args->converter->fromUnicodeStatus);
    oldIsTargetByteDBCS = isTargetByteDBCS;

    isTargetByteDBCS = static_cast<UBool>(args->converter->fromUnicodeStatus);
    if((sourceChar = args->converter->fromUChar32)!=0 && target <targetLimit) {
        goto getTrail;
    }
    while(source < sourceLimit){

        targetByteUnit = missingCharMarker;

        if(target < (unsigned char*) args->targetLimit){
            sourceChar = *source++;

            /* do not convert SO/SI/ESC */
            if(IS_2022_CONTROL(sourceChar)) {
                /* callback(illegal) */
                *err=U_ILLEGAL_CHAR_FOUND;
                args->converter->fromUChar32=sourceChar;
                break;
            }

            length = MBCS_FROM_UCHAR32_ISO2022(sharedData,sourceChar,&targetByteUnit,useFallback,MBCS_OUTPUT_2);
            if(length < 0) {
                length = -length;  /* fallback */
            }
            /* only DBCS or SBCS characters are expected*/
            /* DB characters with high bit set to 1 are expected */
            if( length > 2 || length==0 ||
                (length == 1 && targetByteUnit > 0x7f) ||
                (length == 2 &&
                    (static_cast<uint16_t>(targetByteUnit - 0xa1a1) > (0xfefe - 0xa1a1) ||
                    static_cast<uint8_t>(targetByteUnit - 0xa1) > (0xfe - 0xa1)))
            ) {
                targetByteUnit=missingCharMarker;
            }
            if (targetByteUnit != missingCharMarker){

                oldIsTargetByteDBCS = isTargetByteDBCS;
                isTargetByteDBCS = static_cast<UBool>(targetByteUnit > 0x00FF);
                  /* append the shift sequence */
                if (oldIsTargetByteDBCS != isTargetByteDBCS ){

                    if (isTargetByteDBCS)
                        *target++ = UCNV_SO;
                    else
                        *target++ = UCNV_SI;
                    if(offsets)
                        *(offsets++) = static_cast<int32_t>(source - args->source - 1);
                }
                /* write the targetUniChar  to target */
                if(targetByteUnit <= 0x00FF){
                    if( target < targetLimit){
                        *(target++) = static_cast<unsigned char>(targetByteUnit);
                        if(offsets){
                            *(offsets++) = static_cast<int32_t>(source - args->source - 1);
                        }

                    }else{
                        args->converter->charErrorBuffer[args->converter->charErrorBufferLength++] = static_cast<unsigned char>(targetByteUnit);
                        *err = U_BUFFER_OVERFLOW_ERROR;
                    }
                }else{
                    if(target < targetLimit){
                        *(target++) = static_cast<unsigned char>((targetByteUnit >> 8) - 0x80);
                        if(offsets){
                            *(offsets++) = static_cast<int32_t>(source - args->source - 1);
                        }
                        if(target < targetLimit){
                            *(target++) = static_cast<unsigned char>(targetByteUnit - 0x80);
                            if(offsets){
                                *(offsets++) = static_cast<int32_t>(source - args->source - 1);
                            }
                        }else{
                            args->converter->charErrorBuffer[args->converter->charErrorBufferLength++] = static_cast<unsigned char>(targetByteUnit - 0x80);
                            *err = U_BUFFER_OVERFLOW_ERROR;
                        }
                    }else{
                        args->converter->charErrorBuffer[args->converter->charErrorBufferLength++] = static_cast<unsigned char>((targetByteUnit >> 8) - 0x80);
                        args->converter->charErrorBuffer[args->converter->charErrorBufferLength++] = static_cast<unsigned char>(targetByteUnit - 0x80);
                        *err = U_BUFFER_OVERFLOW_ERROR;
                    }
                }

            }
            else{
                /* oops.. the code point is unassingned
                 * set the error and reason
                 */

                /*check if the char is a First surrogate*/
                if(U16_IS_SURROGATE(sourceChar)) {
                    if(U16_IS_SURROGATE_LEAD(sourceChar)) {
getTrail:
                        /*look ahead to find the trail surrogate*/
                        if(source <  sourceLimit) {
                            /* test the following code unit */
                            char16_t trail = *source;
                            if(U16_IS_TRAIL(trail)) {
                                source++;
                                sourceChar=U16_GET_SUPPLEMENTARY(sourceChar, trail);
                                *err = U_INVALID_CHAR_FOUND;
                                /* convert this surrogate code point */
                                /* exit this condition tree */
                            } else {
                                /* this is an unmatched lead code unit (1st surrogate) */
                                /* callback(illegal) */
                                *err=U_ILLEGAL_CHAR_FOUND;
                            }
                        } else {
                            /* no more input */
                            *err = U_ZERO_ERROR;
                        }
                    } else {
                        /* this is an unmatched trail code unit (2nd surrogate) */
                        /* callback(illegal) */
                        *err=U_ILLEGAL_CHAR_FOUND;
                    }
                } else {
                    /* callback(unassigned) for a BMP code point */
                    *err = U_INVALID_CHAR_FOUND;
                }

                args->converter->fromUChar32=sourceChar;
                break;
            }
        } /* end if(myTargetIndex<myTargetLength) */
        else{
            *err =U_BUFFER_OVERFLOW_ERROR;
            break;
        }

    }/* end while(mySourceIndex<mySourceLength) */

    /*
     * the end of the input stream and detection of truncated input
     * are handled by the framework, but for ISO-2022-KR conversion
     * we need to be in ASCII mode at the very end
     *
     * conditions:
     *   successful
     *   not in ASCII mode
     *   end of input and no truncated input
     */
    if( U_SUCCESS(*err) &&
        isTargetByteDBCS &&
        args->flush && source>=sourceLimit && args->converter->fromUChar32==0
    ) {
        int32_t sourceIndex;

        /* we are switching to ASCII */
        isTargetByteDBCS=false;

        /* get the source index of the last input character */
        /*
         * TODO this would be simpler and more reliable if we used a pair
         * of sourceIndex/prevSourceIndex like in ucnvmbcs.c
         * so that we could simply use the prevSourceIndex here;
         * this code gives an incorrect result for the rare case of an unmatched
         * trail surrogate that is alone in the last buffer of the text stream
         */
        sourceIndex = static_cast<int32_t>(source - args->source);
        if(sourceIndex>0) {
            --sourceIndex;
            if( U16_IS_TRAIL(args->source[sourceIndex]) &&
                (sourceIndex==0 || U16_IS_LEAD(args->source[sourceIndex-1]))
            ) {
                --sourceIndex;
            }
        } else {
            sourceIndex=-1;
        }

        fromUWriteUInt8(
            args->converter,
            SHIFT_IN_STR, 1,
            &target, reinterpret_cast<const char*>(targetLimit),
            &offsets, sourceIndex,
            err);
    }

    /*save the state and return */
    args->source = source;
    args->target = reinterpret_cast<char*>(target);
    args->converter->fromUnicodeStatus = static_cast<uint32_t>(isTargetByteDBCS);
}

/************************ To Unicode ***************************************/

static void U_CALLCONV
UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(UConverterToUnicodeArgs *args,
                                                            UErrorCode* err){
    char const* sourceStart;
    UConverterDataISO2022* myData = static_cast<UConverterDataISO2022*>(args->converter->extraInfo);

    UConverterToUnicodeArgs subArgs;
    int32_t minArgsSize;

    /* set up the subconverter arguments */
    if(args->size<sizeof(UConverterToUnicodeArgs)) {
        minArgsSize = args->size;
    } else {
        minArgsSize = static_cast<int32_t>(sizeof(UConverterToUnicodeArgs));
    }

    uprv_memcpy(&subArgs, args, minArgsSize);
    subArgs.size = static_cast<uint16_t>(minArgsSize);
    subArgs.converter = myData->currentConverter;

    /* remember the original start of the input for offsets */
    sourceStart = args->source;

    if(myData->key != 0) {
        /* continue with a partial escape sequence */
        goto escape;
    }

    while(U_SUCCESS(*err) && args->source < args->sourceLimit) {
        /*Find the end of the buffer e.g : Next Escape Seq | end of Buffer*/
        subArgs.source = args->source;
        subArgs.sourceLimit = getEndOfBuffer_2022(&(args->source), args->sourceLimit, args->flush);
        if(subArgs.source != subArgs.sourceLimit) {
            /*
             * get the current partial byte sequence
             *
             * it needs to be moved between the public and the subconverter
             * so that the conversion framework, which only sees the public
             * converter, can handle truncated and illegal input etc.
             */
            if(args->converter->toULength > 0) {
                uprv_memcpy(subArgs.converter->toUBytes, args->converter->toUBytes, args->converter->toULength);
            }
            subArgs.converter->toULength = args->converter->toULength;

            /*
             * Convert up to the end of the input, or to before the next escape character.
             * Does not handle conversion extensions because the preToU[] state etc.
             * is not copied.
             */
            ucnv_MBCSToUnicodeWithOffsets(&subArgs, err);

            if(args->offsets != nullptr && sourceStart != args->source) {
                /* update offsets to base them on the actual start of the input */
                int32_t *offsets = args->offsets;
                char16_t *target = args->target;
                int32_t delta = static_cast<int32_t>(args->source - sourceStart);
                while(target < subArgs.target) {
                    if(*offsets >= 0) {
                        *offsets += delta;
                    }
                    ++offsets;
                    ++target;
                }
            }
            args->source = subArgs.source;
            args->target = subArgs.target;
            args->offsets = subArgs.offsets;

            /* copy input/error/overflow buffers */
            if(subArgs.converter->toULength > 0) {
                uprv_memcpy(args->converter->toUBytes, subArgs.converter->toUBytes, subArgs.converter->toULength);
            }
            args->converter->toULength = subArgs.converter->toULength;

            if(*err == U_BUFFER_OVERFLOW_ERROR) {
                if(subArgs.converter->UCharErrorBufferLength > 0) {
                    uprv_memcpy(args->converter->UCharErrorBuffer, subArgs.converter->UCharErrorBuffer,
                                subArgs.converter->UCharErrorBufferLength);
                }
                args->converter->UCharErrorBufferLength=subArgs.converter->UCharErrorBufferLength;
                subArgs.converter->UCharErrorBufferLength = 0;
            }
        }

        if (U_FAILURE(*err) || (args->source == args->sourceLimit)) {
            return;
        }

escape:
        changeState_2022(args->converter,
               &(args->source),
               args->sourceLimit,
               ISO_2022_KR,
               err);
    }
}

static void U_CALLCONV
UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
                                                            UErrorCode* err){
    char tempBuf[2];
    const char* mySource = const_cast<char*>(args->source);
    char16_t *myTarget = args->target;
    const char *mySourceLimit = args->sourceLimit;
    UChar32 targetUniChar = 0x0000;
    char16_t mySourceChar = 0x0000;
    UConverterDataISO2022* myData;
    UConverterSharedData* sharedData ;
    UBool useFallback;

    myData = static_cast<UConverterDataISO2022*>(args->converter->extraInfo);
    if(myData->version==1){
        UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC_IBM(args,err);
        return;
    }

    /* initialize state */
    sharedData = myData->currentConverter->sharedData;
    useFallback = args->converter->useFallback;

    if(myData->key != 0) {
        /* continue with a partial escape sequence */
        goto escape;
    } else if(args->converter->toULength == 1 && mySource < mySourceLimit && myTarget < args->targetLimit) {
        /* continue with a partial double-byte character */
        mySourceChar = args->converter->toUBytes[0];
        args->converter->toULength = 0;
        goto getTrailByte;
    }

    while(mySource< mySourceLimit){

        if(myTarget < args->targetLimit){

            mySourceChar = static_cast<unsigned char>(*mySource++);

            if(mySourceChar==UCNV_SI){
                myData->toU2022State.g = 0;
                if (myData->isEmptySegment) {
                    myData->isEmptySegment = false;	/* we are handling it, reset to avoid future spurious errors */
                    *err = U_ILLEGAL_ESCAPE_SEQUENCE;
                    args->converter->toUCallbackReason = UCNV_IRREGULAR;
                    args->converter->toUBytes[0] = static_cast<uint8_t>(mySourceChar);
                    args->converter->toULength = 1;
                    args->target = myTarget;
                    args->source = mySource;
                    return;
                }
                /*consume the source */
                continue;
            }else if(mySourceChar==UCNV_SO){
                myData->toU2022State.g = 1;
                myData->isEmptySegment = true;	/* Begin a new segment, empty so far */
                /*consume the source */
                continue;
            }else if(mySourceChar==ESC_2022){
                mySource--;
escape:
                myData->isEmptySegment = false;	/* Any invalid ESC sequences will be detected separately, so just reset this */
                changeState_2022(args->converter,&(mySource),
                                mySourceLimit, ISO_2022_KR, err);
                if(U_FAILURE(*err)){
                    args->target = myTarget;
                    args->source = mySource;
                    return;
                }
                continue;
            }

            myData->isEmptySegment = false;	/* Any invalid char errors will be detected separately, so just reset this */
            if(myData->toU2022State.g == 1) {
                if(mySource < mySourceLimit) {
                    int leadIsOk, trailIsOk;
                    uint8_t trailByte;
getTrailByte:
                    targetUniChar = missingCharMarker;
                    trailByte = static_cast<uint8_t>(*mySource);
                    /*
                     * Ticket 5691: consistent illegal sequences:
                     * - We include at least the first byte in the illegal sequence.
                     * - If any of the non-initial bytes could be the start of a character,
                     *   we stop the illegal sequence before the first one of those.
                     *
                     * In ISO-2022 DBCS, if the second byte is in the 21..7e range or is
                     * an ESC/SO/SI, we report only the first byte as the illegal sequence.
                     * Otherwise we convert or report the pair of bytes.
                     */
                    leadIsOk = static_cast<uint8_t>(mySourceChar - 0x21) <= (0x7e - 0x21);
                    trailIsOk = static_cast<uint8_t>(trailByte - 0x21) <= (0x7e - 0x21);
                    if (leadIsOk && trailIsOk) {
                        ++mySource;
                        tempBuf[0] = static_cast<char>(mySourceChar + 0x80);
                        tempBuf[1] = static_cast<char>(trailByte + 0x80);
                        targetUniChar = ucnv_MBCSSimpleGetNextUChar(sharedData, tempBuf, 2, useFallback);
                        mySourceChar = (mySourceChar << 8) | trailByte;
                    } else if (!(trailIsOk || IS_2022_CONTROL(trailByte))) {
                        /* report a pair of illegal bytes if the second byte is not a DBCS starter */
                        ++mySource;
                        /* add another bit so that the code below writes 2 bytes in case of error */
                        mySourceChar = static_cast<char16_t>(0x10000 | (mySourceChar << 8) | trailByte);
                    }
                } else {
                    args->converter->toUBytes[0] = static_cast<uint8_t>(mySourceChar);
                    args->converter->toULength = 1;
                    break;
                }
            }
            else if(mySourceChar <= 0x7f) {
                targetUniChar = ucnv_MBCSSimpleGetNextUChar(sharedData, mySource - 1, 1, useFallback);
            } else {
                targetUniChar = 0xffff;
            }
            if(targetUniChar < 0xfffe){
                if(args->offsets) {
                    args->offsets[myTarget - args->target] = static_cast<int32_t>(mySource - args->source - (mySourceChar <= 0xff ? 1 : 2));
                }
                *(myTarget++) = static_cast<char16_t>(targetUniChar);
            }
            else {
                /* Call the callback function*/
                toUnicodeCallback(args->converter,mySourceChar,targetUniChar,err);
                break;
            }
        }
        else{
            *err =U_BUFFER_OVERFLOW_ERROR;
            break;
        }
    }
    args->target = myTarget;
    args->source = mySource;
}

/*************************** END ISO2022-KR *********************************/

/*************************** ISO-2022-CN *********************************
*
* Rules for ISO-2022-CN Encoding:
* i)   The designator sequence must appear once on a line before any instance
*      of character set it designates.
* ii)  If two lines contain characters from the same character set, both lines
*      must include the designator sequence.
* iii) Once the designator sequence is known, a shifting sequence has to be found
*      to invoke the  shifting
* iv)  All lines start in ASCII and end in ASCII.
* v)   Four shifting sequences are employed for this purpose:
*
*      Sequcence   ASCII Eq    Charsets
*      ----------  -------    ---------
*      SI           <SI>        US-ASCII
*      SO           <SO>        CNS-11643-1992 Plane 1, GB2312, ISO-IR-165
*      SS2          <ESC>N      CNS-11643-1992 Plane 2
*      SS3          <ESC>O      CNS-11643-1992 Planes 3-7
*
* vi)
*      SOdesignator  : ESC "$" ")" finalchar_for_SO
*      SS2designator : ESC "$" "*" finalchar_for_SS2
*      SS3designator : ESC "$" "+" finalchar_for_SS3
*
*      ESC $ ) A       Indicates the bytes following SO are Chinese
*       characters as defined in GB 2312-80, until
*       another SOdesignation appears
*
*
*      ESC $ ) E       Indicates the bytes following SO are as defined
*       in ISO-IR-165 (for details, see section 2.1),
*       until another SOdesignation appears
*
*      ESC $ ) G       Indicates the bytes following SO are as defined
*       in CNS 11643-plane-1, until another
*       SOdesignation appears
*
*      ESC $ * H       Indicates the two bytes immediately following
*       SS2 is a Chinese character as defined in CNS
*       11643-plane-2, until another SS2designation
*       appears
*       (Meaning <ESC>N must precede every 2 byte
*        sequence.)
*
*      ESC $ + I       Indicates the immediate two bytes following SS3
*       is a Chinese character as defined in CNS
*       11643-plane-3, until another SS3designation
*       appears
*       (Meaning <ESC>O must precede every 2 byte
*        sequence.)
*
*      ESC $ + J       Indicates the immediate two bytes following SS3
*       is a Chinese character as defined in CNS
*       11643-plane-4, until another SS3designation
*       appears
*       (In English: <ESC>O must precede every 2 byte
*        sequence.)
*
*      ESC $ + K       Indicates the immediate two bytes following SS3
*       is a Chinese character as defined in CNS
*       11643-plane-5, until another SS3designation
*       appears
*
*      ESC $ + L       Indicates the immediate two bytes following SS3
*       is a Chinese character as defined in CNS
*       11643-plane-6, until another SS3designation
*       appears
*
*      ESC $ + M       Indicates the immediate two bytes following SS3
*       is a Chinese character as defined in CNS
*       11643-plane-7, until another SS3designation
*       appears
*
*       As in ISO-2022-CN, each line starts in ASCII, and ends in ASCII, and
*       has its own designation information before any Chinese characters
*       appear
*
*/

/* The following are defined this way to make the strings truly readonly */
static const char GB_2312_80_STR[] = "\x1B\x24\x29\x41";
static const char ISO_IR_165_STR[] = "\x1B\x24\x29\x45";
static const char CNS_11643_1992_Plane_1_STR[] = "\x1B\x24\x29\x47";
static const char CNS_11643_1992_Plane_2_STR[] = "\x1B\x24\x2A\x48";
static const char CNS_11643_1992_Plane_3_STR[] = "\x1B\x24\x2B\x49";
static const char CNS_11643_1992_Plane_4_STR[] = "\x1B\x24\x2B\x4A";
static const char CNS_11643_1992_Plane_5_STR[] = "\x1B\x24\x2B\x4B";
static const char CNS_11643_1992_Plane_6_STR[] = "\x1B\x24\x2B\x4C";
static const char CNS_11643_1992_Plane_7_STR[] = "\x1B\x24\x2B\x4D";

/********************** ISO2022-CN Data **************************/
static const char* const escSeqCharsCN[10] ={
        SHIFT_IN_STR,                   /* 0 ASCII */
        GB_2312_80_STR,                 /* 1 GB2312_1 */
        ISO_IR_165_STR,                 /* 2 ISO_IR_165 */
        CNS_11643_1992_Plane_1_STR,
        CNS_11643_1992_Plane_2_STR,
        CNS_11643_1992_Plane_3_STR,
        CNS_11643_1992_Plane_4_STR,
        CNS_11643_1992_Plane_5_STR,
        CNS_11643_1992_Plane_6_STR,
        CNS_11643_1992_Plane_7_STR
};

static void U_CALLCONV
UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterFromUnicodeArgs* args, UErrorCode* err){
    UConverter *cnv = args->converter;
    UConverterDataISO2022 *converterData;
    ISO2022State *pFromU2022State;
    uint8_t* target = reinterpret_cast<uint8_t*>(args->target);
    const uint8_t* targetLimit = reinterpret_cast<const uint8_t*>(args->targetLimit);
    const char16_t* source = args->source;
    const char16_t* sourceLimit = args->sourceLimit;
    int32_t* offsets = args->offsets;
    UChar32 sourceChar;
    char buffer[8];
    int32_t len;
    int8_t choices[3];
    int32_t choiceCount;
    uint32_t targetValue = 0;
    UBool useFallback;

    /* set up the state */
    converterData = static_cast<UConverterDataISO2022*>(cnv->extraInfo);
    pFromU2022State   = &converterData->fromU2022State;

    choiceCount = 0;

    /* check if the last codepoint of previous buffer was a lead surrogate*/
    if((sourceChar = cnv->fromUChar32)!=0 && target< targetLimit) {
        goto getTrail;
    }

    while( source < sourceLimit){
        if(target < targetLimit){

            sourceChar  = *(source++);
            /*check if the char is a First surrogate*/
             if(U16_IS_SURROGATE(sourceChar)) {
                if(U16_IS_SURROGATE_LEAD(sourceChar)) {
getTrail:
                    /*look ahead to find the trail surrogate*/
                    if(source < sourceLimit) {
                        /* test the following code unit */
                        char16_t trail = *source;
                        if(U16_IS_TRAIL(trail)) {
                            source++;
                            sourceChar=U16_GET_SUPPLEMENTARY(sourceChar, trail);
                            cnv->fromUChar32=0x00;
                            /* convert this supplementary code point */
                            /* exit this condition tree */
                        } else {
                            /* this is an unmatched lead code unit (1st surrogate) */
                            /* callback(illegal) */
                            *err=U_ILLEGAL_CHAR_FOUND;
                            cnv->fromUChar32=sourceChar;
                            break;
                        }
                    } else {
                        /* no more input */
                        cnv->fromUChar32=sourceChar;
                        break;
                    }
                } else {
                    /* this is an unmatched trail code unit (2nd surrogate) */
                    /* callback(illegal) */
                    *err=U_ILLEGAL_CHAR_FOUND;
                    cnv->fromUChar32=sourceChar;
                    break;
                }
            }

            /* do the conversion */
            if(sourceChar <= 0x007f ){
                /* do not convert SO/SI/ESC */
                if(IS_2022_CONTROL(sourceChar)) {
                    /* callback(illegal) */
                    *err=U_ILLEGAL_CHAR_FOUND;
                    cnv->fromUChar32=sourceChar;
                    break;
                }

                /* US-ASCII */
                if(pFromU2022State->g == 0) {
                    buffer[0] = static_cast<char>(sourceChar);
                    len = 1;
                } else {
                    buffer[0] = UCNV_SI;
                    buffer[1] = static_cast<char>(sourceChar);
                    len = 2;
                    pFromU2022State->g = 0;
                    choiceCount = 0;
                }
                if(sourceChar == CR || sourceChar == LF) {
                    /* reset the state at the end of a line */
                    uprv_memset(pFromU2022State, 0, sizeof(ISO2022State));
                    choiceCount = 0;
                }
            }
            else{
                /* convert U+0080..U+10ffff */
                int32_t i;
                int8_t cs, g;

                if(choiceCount == 0) {
                    /* try the current SO/G1 converter first */
                    choices[0] = pFromU2022State->cs[1];

                    /* default to GB2312_1 if none is designated yet */
                    if(choices[0] == 0) {
                        choices[0] = GB2312_1;
                    }

                    if(converterData->version == 0) {
                        /* ISO-2022-CN */

                        /* try the other SO/G1 converter; a CNS_11643_1 lookup may result in any plane */
                        if(choices[0] == GB2312_1) {
                            choices[1] = static_cast<int8_t>(CNS_11643_1);
                        } else {
                            choices[1] = static_cast<int8_t>(GB2312_1);
                        }

                        choiceCount = 2;
                    } else if (converterData->version == 1) {
                        /* ISO-2022-CN-EXT */

                        /* try one of the other converters */
                        switch(choices[0]) {
                        case GB2312_1:
                            choices[1] = static_cast<int8_t>(CNS_11643_1);
                            choices[2] = static_cast<int8_t>(ISO_IR_165);
                            break;
                        case ISO_IR_165:
                            choices[1] = static_cast<int8_t>(GB2312_1);
                            choices[2] = static_cast<int8_t>(CNS_11643_1);
                            break;
                        default: /* CNS_11643_x */
                            choices[1] = static_cast<int8_t>(GB2312_1);
                            choices[2] = static_cast<int8_t>(ISO_IR_165);
                            break;
                        }

                        choiceCount = 3;
                    } else {
                        choices[0] = static_cast<int8_t>(CNS_11643_1);
                        choices[1] = static_cast<int8_t>(GB2312_1);
                    }
                }

                cs = g = 0;
                /*
                 * len==0: no mapping found yet
                 * len<0: found a fallback result: continue looking for a roundtrip but no further fallbacks
                 * len>0: found a roundtrip result, done
                 */
                len = 0;
                /*
                 * We will turn off useFallback after finding a fallback,
                 * but we still get fallbacks from PUA code points as usual.
                 * Therefore, we will also need to check that we don't overwrite
                 * an early fallback with a later one.
                 */
                useFallback = cnv->useFallback;

                for(i = 0; i < choiceCount && len <= 0; ++i) {
                    int8_t cs0 = choices[i];
                    if(cs0 > 0) {
                        uint32_t value;
                        int32_t len2;
                        if(cs0 >= CNS_11643_0) {
                            len2 = MBCS_FROM_UCHAR32_ISO2022(
                                        converterData->myConverterArray[CNS_11643],
                                        sourceChar,
                                        &value,
                                        useFallback,
                                        MBCS_OUTPUT_3);
                            if(len2 == 3 || (len2 == -3 && len == 0)) {
                                targetValue = value;
                                cs = static_cast<int8_t>(CNS_11643_0 + (value >> 16) - 0x80);
                                if(len2 >= 0) {
                                    len = 2;
                                } else {
                                    len = -2;
                                    useFallback = false;
                                }
                                if(cs == CNS_11643_1) {
                                    g = 1;
                                } else if(cs == CNS_11643_2) {
                                    g = 2;
                                } else /* plane 3..7 */ if(converterData->version == 1) {
                                    g = 3;
                                } else {
                                    /* ISO-2022-CN (without -EXT) does not support plane 3..7 */
                                    len = 0;
                                }
                            }
                        } else {
                            /* GB2312_1 or ISO-IR-165 */
                            U_ASSERT(cs0<UCNV_2022_MAX_CONVERTERS);
                            len2 = MBCS_FROM_UCHAR32_ISO2022(
                                        converterData->myConverterArray[cs0],
                                        sourceChar,
                                        &value,
                                        useFallback,
                                        MBCS_OUTPUT_2);
                            if(len2 == 2 || (len2 == -2 && len == 0)) {
                                targetValue = value;
                                len = len2;
                                cs = cs0;
                                g = 1;
                                useFallback = false;
                            }
                        }
                    }
                }

                if(len != 0) {
                    len = 0; /* count output bytes; it must have been abs(len) == 2 */

                    /* write the designation sequence if necessary */
                    if(cs != pFromU2022State->cs[g]) {
                        if(cs < CNS_11643) {
                            uprv_memcpy(buffer, escSeqCharsCN[cs], 4);
                        } else {
                            U_ASSERT(cs >= CNS_11643_1);
                            uprv_memcpy(buffer, escSeqCharsCN[CNS_11643 + (cs - CNS_11643_1)], 4);
                        }
                        len = 4;
                        pFromU2022State->cs[g] = cs;
                        if(g == 1) {
                            /* changing the SO/G1 charset invalidates the choices[] */
                            choiceCount = 0;
                        }
                    }

                    /* write the shift sequence if necessary */
                    if(g != pFromU2022State->g) {
                        switch(g) {
                        case 1:
                            buffer[len++] = UCNV_SO;

                            /* set the new state only if it is the locking shift SO/G1, not for SS2 or SS3 */
                            pFromU2022State->g = 1;
                            break;
                        case 2:
                            buffer[len++] = 0x1b;
                            buffer[len++] = 0x4e;
                            break;
                        default: /* case 3 */
                            buffer[len++] = 0x1b;
                            buffer[len++] = 0x4f;
                            break;
                        }
                    }

                    /* write the two output bytes */
                    buffer[len++] = static_cast<char>(targetValue >> 8);
                    buffer[len++] = static_cast<char>(targetValue);
                } else {
                    /* if we cannot find the character after checking all codepages
                     * then this is an error
                     */
                    *err = U_INVALID_CHAR_FOUND;
                    cnv->fromUChar32=sourceChar;
                    break;
                }
            }

            /* output len>0 bytes in buffer[] */
            if(len == 1) {
                *target++ = buffer[0];
                if(offsets) {
                    *offsets++ = static_cast<int32_t>(source - args->source - 1); /* -1: known to be ASCII */
                }
            } else if(len == 2 && (target + 2) <= targetLimit) {
                *target++ = buffer[0];
                *target++ = buffer[1];
                if(offsets) {
                    int32_t sourceIndex = static_cast<int32_t>(source - args->source - U16_LENGTH(sourceChar));
                    *offsets++ = sourceIndex;
                    *offsets++ = sourceIndex;
                }
            } else {
                fromUWriteUInt8(
                    cnv,
                    buffer, len,
                    &target, reinterpret_cast<const char*>(targetLimit),
                    &offsets, static_cast<int32_t>(source - args->source - U16_LENGTH(sourceChar)),
                    err);
                if(U_FAILURE(*err)) {
                    break;
                }
            }
        } /* end if(myTargetIndex<myTargetLength) */
        else{
            *err =U_BUFFER_OVERFLOW_ERROR;
            break;
        }

    }/* end while(mySourceIndex<mySourceLength) */

    /*
     * the end of the input stream and detection of truncated input
     * are handled by the framework, but for ISO-2022-CN conversion
     * we need to be in ASCII mode at the very end
     *
     * conditions:
     *   successful
     *   not in ASCII mode
     *   end of input and no truncated input
     */
    if( U_SUCCESS(*err) &&
        pFromU2022State->g!=0 &&
        args->flush && source>=sourceLimit && cnv->fromUChar32==0
    ) {
        int32_t sourceIndex;

        /* we are switching to ASCII */
        pFromU2022State->g=0;

        /* get the source index of the last input character */
        /*
         * TODO this would be simpler and more reliable if we used a pair
         * of sourceIndex/prevSourceIndex like in ucnvmbcs.c
         * so that we could simply use the prevSourceIndex here;
         * this code gives an incorrect result for the rare case of an unmatched
         * trail surrogate that is alone in the last buffer of the text stream
         */
        sourceIndex = static_cast<int32_t>(source - args->source);
        if(sourceIndex>0) {
            --sourceIndex;
            if( U16_IS_TRAIL(args->source[sourceIndex]) &&
                (sourceIndex==0 || U16_IS_LEAD(args->source[sourceIndex-1]))
            ) {
                --sourceIndex;
            }
        } else {
            sourceIndex=-1;
        }

        fromUWriteUInt8(
            cnv,
            SHIFT_IN_STR, 1,
            &target, reinterpret_cast<const char*>(targetLimit),
            &offsets, sourceIndex,
            err);
    }

    /*save the state and return */
    args->source = source;
    args->target = reinterpret_cast<char*>(target);
}


static void U_CALLCONV
UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,
                                               UErrorCode* err){
    char tempBuf[3];
    const char* mySource = const_cast<char*>(args->source);
    char16_t *myTarget = args->target;
    const char *mySourceLimit = args->sourceLimit;
    uint32_t targetUniChar = 0x0000;
    uint32_t mySourceChar = 0x0000;
    UConverterDataISO2022* myData;
    ISO2022State *pToU2022State;

    myData = static_cast<UConverterDataISO2022*>(args->converter->extraInfo);
    pToU2022State = &myData->toU2022State;

    if(myData->key != 0) {
        /* continue with a partial escape sequence */
        goto escape;
    } else if(args->converter->toULength == 1 && mySource < mySourceLimit && myTarget < args->targetLimit) {
        /* continue with a partial double-byte character */
        mySourceChar = args->converter->toUBytes[0];
        args->converter->toULength = 0;
        targetUniChar = missingCharMarker;
        goto getTrailByte;
    }

    while(mySource < mySourceLimit){

        targetUniChar =missingCharMarker;

        if(myTarget < args->targetLimit){

            mySourceChar = static_cast<unsigned char>(*mySource++);

            switch(mySourceChar){
            case UCNV_SI:
                pToU2022State->g=0;
                if (myData->isEmptySegment) {
                    myData->isEmptySegment = false;	/* we are handling it, reset to avoid future spurious errors */
                    *err = U_ILLEGAL_ESCAPE_SEQUENCE;
                    args->converter->toUCallbackReason = UCNV_IRREGULAR;
                    args->converter->toUBytes[0] = static_cast<uint8_t>(mySourceChar);
                    args->converter->toULength = 1;
                    args->target = myTarget;
                    args->source = mySource;
                    return;
                }
                continue;

            case UCNV_SO:
                if(pToU2022State->cs[1] != 0) {
                    pToU2022State->g=1;
                    myData->isEmptySegment = true;	/* Begin a new segment, empty so far */
                    continue;
                } else {
                    /* illegal to have SO before a matching designator */
                    myData->isEmptySegment = false;	/* Handling a different error, reset this to avoid future spurious errs */
                    break;
                }

            case ESC_2022:
                mySource--;
escape:
                {
                    const char * mySourceBefore = mySource;
                    int8_t toULengthBefore = args->converter->toULength;

                    changeState_2022(args->converter,&(mySource),
                        mySourceLimit, ISO_2022_CN,err);

                    /* After SO there must be at least one character before a designator (designator error handled separately) */
                    if(myData->key==0 && U_SUCCESS(*err) && myData->isEmptySegment) {
                        *err = U_ILLEGAL_ESCAPE_SEQUENCE;
                        args->converter->toUCallbackReason = UCNV_IRREGULAR;
                        args->converter->toULength = static_cast<int8_t>(toULengthBefore + (mySource - mySourceBefore));
                    }
                }

                /* invalid or illegal escape sequence */
                if(U_FAILURE(*err)){
                    args->target = myTarget;
                    args->source = mySource;
                    myData->isEmptySegment = false;	/* Reset to avoid future spurious errors */
                    return;
                }
                continue;

            /* ISO-2022-CN does not use single-byte (C1) SS2 and SS3 */

            case CR:
            case LF:
                uprv_memset(pToU2022State, 0, sizeof(ISO2022State));
                U_FALLTHROUGH;
            default:
                /* convert one or two bytes */
                myData->isEmptySegment = false;
                if(pToU2022State->g != 0) {
                    if(mySource < mySourceLimit) {
                        UConverterSharedData *cnv;
                        StateEnum tempState;
                        int32_t tempBufLen;
                        int leadIsOk, trailIsOk;
                        uint8_t trailByte;
getTrailByte:
                        trailByte = static_cast<uint8_t>(*mySource);
                        /*
                         * Ticket 5691: consistent illegal sequences:
                         * - We include at least the first byte in the illegal sequence.
                         * - If any of the non-initial bytes could be the start of a character,
                         *   we stop the illegal sequence before the first one of those.
                         *
                         * In ISO-2022 DBCS, if the second byte is in the 21..7e range or is
                         * an ESC/SO/SI, we report only the first byte as the illegal sequence.
                         * Otherwise we convert or report the pair of bytes.
                         */
                        leadIsOk = static_cast<uint8_t>(mySourceChar - 0x21) <= (0x7e - 0x21);
                        trailIsOk = static_cast<uint8_t>(trailByte - 0x21) <= (0x7e - 0x21);
                        if (leadIsOk && trailIsOk) {
                            ++mySource;
                            tempState = static_cast<StateEnum>(pToU2022State->cs[pToU2022State->g]);
                            if(tempState >= CNS_11643_0) {
                                cnv = myData->myConverterArray[CNS_11643];
                                tempBuf[0] = static_cast<char>(0x80 + (tempState - CNS_11643_0));
                                tempBuf[1] = static_cast<char>(mySourceChar);
                                tempBuf[2] = static_cast<char>(trailByte);
                                tempBufLen = 3;

                            }else{
                                U_ASSERT(tempState<UCNV_2022_MAX_CONVERTERS);
                                cnv = myData->myConverterArray[tempState];
                                tempBuf[0] = static_cast<char>(mySourceChar);
                                tempBuf[1] = static_cast<char>(trailByte);
                                tempBufLen = 2;
                            }
                            targetUniChar = ucnv_MBCSSimpleGetNextUChar(cnv, tempBuf, tempBufLen, false);
                            mySourceChar = (mySourceChar << 8) | trailByte;
                        } else if (!(trailIsOk || IS_2022_CONTROL(trailByte))) {
                            /* report a pair of illegal bytes if the second byte is not a DBCS starter */
                            ++mySource;
                            /* add another bit so that the code below writes 2 bytes in case of error */
                            mySourceChar = 0x10000 | (mySourceChar << 8) | trailByte;
                        }
                        if(pToU2022State->g>=2) {
                            /* return from a single-shift state to the previous one */
                            pToU2022State->g=pToU2022State->prevG;
                        }
                    } else {
                        args->converter->toUBytes[0] = static_cast<uint8_t>(mySourceChar);
                        args->converter->toULength = 1;
                        goto endloop;
                    }
                }
                else{
                    if(mySourceChar <= 0x7f) {
                        targetUniChar = static_cast<char16_t>(mySourceChar);
                    }
                }
                break;
            }
            if(targetUniChar < (missingCharMarker-1/*0xfffe*/)){
                if(args->offsets){
                    args->offsets[myTarget - args->target] = static_cast<int32_t>(mySource - args->source - (mySourceChar <= 0xff ? 1 : 2));
                }
                *(myTarget++) = static_cast<char16_t>(targetUniChar);
            }
            else if(targetUniChar > missingCharMarker){
                /* disassemble the surrogate pair and write to output*/
                targetUniChar-=0x0010000;
                *myTarget = static_cast<char16_t>(0xd800 + static_cast<char16_t>(targetUniChar >> 10));
                if(args->offsets){
                    args->offsets[myTarget - args->target] = static_cast<int32_t>(mySource - args->source - (mySourceChar <= 0xff ? 1 : 2));
                }
                ++myTarget;
                if(myTarget< args->targetLimit){
                    *myTarget = static_cast<char16_t>(0xdc00 + static_cast<char16_t>(targetUniChar & 0x3ff));
                    if(args->offsets){
                        args->offsets[myTarget - args->target] = static_cast<int32_t>(mySource - args->source - (mySourceChar <= 0xff ? 1 : 2));
                    }
                    ++myTarget;
                }else{
                    args->converter->UCharErrorBuffer[args->converter->UCharErrorBufferLength++]=
                                    static_cast<char16_t>(0xdc00 + static_cast<char16_t>(targetUniChar & 0x3ff));
                }

            }
            else{
                /* Call the callback function*/
                toUnicodeCallback(args->converter,mySourceChar,targetUniChar,err);
                break;
            }
        }
        else{
            *err =U_BUFFER_OVERFLOW_ERROR;
            break;
        }
    }
endloop:
    args->target = myTarget;
    args->source = mySource;
}
#endif /* #if !UCONFIG_ONLY_HTML_CONVERSION */

static void U_CALLCONV
_ISO_2022_WriteSub(UConverterFromUnicodeArgs *args, int32_t offsetIndex, UErrorCode *err) {
    UConverter *cnv = args->converter;
    UConverterDataISO2022* myConverterData = static_cast<UConverterDataISO2022*>(cnv->extraInfo);
    ISO2022State *pFromU2022State=&myConverterData->fromU2022State;
    char *p, *subchar;
    char buffer[8];
    int32_t length;

    subchar = reinterpret_cast<char*>(cnv->subChars);
    length=cnv->subCharLen; /* assume length==1 for most variants */

    p = buffer;
    switch(myConverterData->locale[0]){
    case 'j':
        {
            int8_t cs;

            if(pFromU2022State->g == 1) {
                /* JIS7: switch from G1 to G0 */
                pFromU2022State->g = 0;
                *p++ = UCNV_SI;
            }

            cs = pFromU2022State->cs[0];
            if(cs != ASCII && cs != JISX201) {
                /* not in ASCII or JIS X 0201: switch to ASCII */
                pFromU2022State->cs[0] = static_cast<int8_t>(ASCII);
                *p++ = '\x1b';
                *p++ = '\x28';
                *p++ = '\x42';
            }

            *p++ = subchar[0];
            break;
        }
    case 'c':
        if(pFromU2022State->g != 0) {
            /* not in ASCII mode: switch to ASCII */
            pFromU2022State->g = 0;
            *p++ = UCNV_SI;
        }
        *p++ = subchar[0];
        break;
    case 'k':
        if(myConverterData->version == 0) {
            if(length == 1) {
                if(args->converter->fromUnicodeStatus) {
                    /* in DBCS mode: switch to SBCS */
                    args->converter->fromUnicodeStatus = 0;
                    *p++ = UCNV_SI;
                }
                *p++ = subchar[0];
            } else /* length == 2*/ {
                if(!args->converter->fromUnicodeStatus) {
                    /* in SBCS mode: switch to DBCS */
                    args->converter->fromUnicodeStatus = 1;
                    *p++ = UCNV_SO;
                }
                *p++ = subchar[0];
                *p++ = subchar[1];
            }
            break;
        } else {
            /* save the subconverter's substitution string */
            uint8_t *currentSubChars = myConverterData->currentConverter->subChars;
            int8_t currentSubCharLen = myConverterData->currentConverter->subCharLen;

            /* set our substitution string into the subconverter */
            myConverterData->currentConverter->subChars = reinterpret_cast<uint8_t*>(subchar);
            myConverterData->currentConverter->subCharLen = static_cast<int8_t>(length);

            /* let the subconverter write the subchar, set/retrieve fromUChar32 state */
            args->converter = myConverterData->currentConverter;
            myConverterData->currentConverter->fromUChar32 = cnv->fromUChar32;
            ucnv_cbFromUWriteSub(args, 0, err);
            cnv->fromUChar32 = myConverterData->currentConverter->fromUChar32;
            args->converter = cnv;

            /* restore the subconverter's substitution string */
            myConverterData->currentConverter->subChars = currentSubChars;
            myConverterData->currentConverter->subCharLen = currentSubCharLen;

            if(*err == U_BUFFER_OVERFLOW_ERROR) {
                if(myConverterData->currentConverter->charErrorBufferLength > 0) {
                    uprv_memcpy(
                        cnv->charErrorBuffer,
                        myConverterData->currentConverter->charErrorBuffer,
                        myConverterData->currentConverter->charErrorBufferLength);
                }
                cnv->charErrorBufferLength = myConverterData->currentConverter->charErrorBufferLength;
                myConverterData->currentConverter->charErrorBufferLength = 0;
            }
            return;
        }
    default:
        /* not expected */
        break;
    }
    ucnv_cbFromUWriteBytes(args,
                           buffer, static_cast<int32_t>(p - buffer),
                           offsetIndex, err);
}

/*
 * Structure for cloning an ISO 2022 converter into a single memory block.
 */
struct cloneStruct
{
    UConverter cnv;
    UConverter currentConverter;
    UConverterDataISO2022 mydata;
};


U_CDECL_BEGIN

static UConverter * U_CALLCONV
_ISO_2022_SafeClone(
            const UConverter *cnv,
            void *stackBuffer,
            int32_t *pBufferSize,
            UErrorCode *status)
{
    struct cloneStruct * localClone;
    UConverterDataISO2022 *cnvData;
    int32_t i, size;

    if (U_FAILURE(*status)){
        return nullptr;
    }

    if (*pBufferSize == 0) { /* 'preflighting' request - set needed size into *pBufferSize */
        *pBufferSize = (int32_t)sizeof(struct cloneStruct);
        return nullptr;
    }

    cnvData = (UConverterDataISO2022 *)cnv->extraInfo;
    localClone = (struct cloneStruct *)stackBuffer;

    /* ucnv.c/ucnv_safeClone() copied the main UConverter already */

    uprv_memcpy(&localClone->mydata, cnvData, sizeof(UConverterDataISO2022));
    localClone->cnv.extraInfo = &localClone->mydata; /* set pointer to extra data */
    localClone->cnv.isExtraLocal = true;

    /* share the subconverters */

    if(cnvData->currentConverter != nullptr) {
        size = (int32_t)sizeof(UConverter);
        localClone->mydata.currentConverter =
            ucnv_safeClone(cnvData->currentConverter,
                            &localClone->currentConverter,
                            &size, status);
        if(U_FAILURE(*status)) {
            return nullptr;
        }
    }

    for(i=0; i<UCNV_2022_MAX_CONVERTERS; ++i) {
        if(cnvData->myConverterArray[i] != nullptr) {
            ucnv_incrementRefCount(cnvData->myConverterArray[i]);
        }
    }

    return &localClone->cnv;
}

U_CDECL_END

static void U_CALLCONV
_ISO_2022_GetUnicodeSet(const UConverter *cnv,
                    const USetAdder *sa,
                    UConverterUnicodeSet which,
                    UErrorCode *pErrorCode)
{
    int32_t i;
    UConverterDataISO2022* cnvData;

    if (U_FAILURE(*pErrorCode)) {
        return;
    }
#ifdef U_ENABLE_GENERIC_ISO_2022
    if (cnv->sharedData == &_ISO2022Data) {
        /* We use UTF-8 in this case */
        sa->addRange(sa->set, 0, 0xd7FF);
        sa->addRange(sa->set, 0xE000, 0x10FFFF);
        return;
    }
#endif

    cnvData = static_cast<UConverterDataISO2022*>(cnv->extraInfo);

    /* open a set and initialize it with code points that are algorithmically round-tripped */
    switch(cnvData->locale[0]){
    case 'j':
        /* include JIS X 0201 which is hardcoded */
        sa->add(sa->set, 0xa5);
        sa->add(sa->set, 0x203e);
        if(jpCharsetMasks[cnvData->version]&CSM(ISO8859_1)) {
            /* include Latin-1 for some variants of JP */
            sa->addRange(sa->set, 0, 0xff);
        } else {
            /* include ASCII for JP */
            sa->addRange(sa->set, 0, 0x7f);
        }
        if(cnvData->version==3 || cnvData->version==4 || which==UCNV_ROUNDTRIP_AND_FALLBACK_SET) {
            /*
             * Do not test (jpCharsetMasks[cnvData->version]&CSM(HWKANA_7BIT))!=0
             * because the bit is on for all JP versions although only versions 3 & 4 (JIS7 & JIS8)
             * use half-width Katakana.
             * This is because all ISO-2022-JP variants are lenient in that they accept (in toUnicode)
             * half-width Katakana via the ESC ( I sequence.
             * However, we only emit (fromUnicode) half-width Katakana according to the
             * definition of each variant.
             *
             * When including fallbacks,
             * we need to include half-width Katakana Unicode code points for all JP variants because
             * JIS X 0208 has hardcoded fallbacks for them (which map to full-width Katakana).
             */
            /* include half-width Katakana for JP */
            sa->addRange(sa->set, HWKANA_START, HWKANA_END);
        }
        break;
#if !UCONFIG_ONLY_HTML_CONVERSION
    case 'c':
    case 'z':
        /* include ASCII for CN */
        sa->addRange(sa->set, 0, 0x7f);
        break;
    case 'k':
        /* there is only one converter for KR, and it is not in the myConverterArray[] */
        cnvData->currentConverter->sharedData->impl->getUnicodeSet(
                cnvData->currentConverter, sa, which, pErrorCode);
        /* the loop over myConverterArray[] will simply not find another converter */
        break;
#endif
    default:
        break;
    }

#if 0  /* Replaced by ucnv_MBCSGetFilteredUnicodeSetForUnicode() until we implement ucnv_getUnicodeSet() with reverse fallbacks. */
            if( (cnvData->locale[0]=='c' || cnvData->locale[0]=='z') &&
                cnvData->version==0 && i==CNS_11643
            ) {
                /* special handling for non-EXT ISO-2022-CN: add only code points for CNS planes 1 and 2 */
                ucnv_MBCSGetUnicodeSetForBytes(
                        cnvData->myConverterArray[i],
                        sa, UCNV_ROUNDTRIP_SET,
                        0, 0x81, 0x82,
                        pErrorCode);
            }
#endif

    for (i=0; i<UCNV_2022_MAX_CONVERTERS; i++) {
        UConverterSetFilter filter;
        if(cnvData->myConverterArray[i]!=nullptr) {
            if(cnvData->locale[0]=='j' && i==JISX208) {
                /*
                 * Only add code points that map to Shift-JIS codes
                 * corresponding to JIS X 0208.
                 */
                filter=UCNV_SET_FILTER_SJIS;
#if !UCONFIG_ONLY_HTML_CONVERSION
            } else if( (cnvData->locale[0]=='c' || cnvData->locale[0]=='z') &&
                       cnvData->version==0 && i==CNS_11643) {
                /*
                 * Version-specific for CN:
                 * CN version 0 does not map CNS planes 3..7 although
                 * they are all available in the CNS conversion table;
                 * CN version 1 (-EXT) does map them all.
                 * The two versions create different Unicode sets.
                 */
                filter=UCNV_SET_FILTER_2022_CN;
            } else if(i==KSC5601) {
                /*
                 * Some of the KSC 5601 tables (convrtrs.txt has this aliases on multiple tables)
                 * are broader than GR94.
                 */
                filter=UCNV_SET_FILTER_GR94DBCS;
#endif
            } else {
                filter=UCNV_SET_FILTER_NONE;
            }
            ucnv_MBCSGetFilteredUnicodeSetForUnicode(cnvData->myConverterArray[i], sa, which, filter, pErrorCode);
        }
    }

    /*
     * ISO 2022 converters must not convert SO/SI/ESC despite what
     * sub-converters do by themselves.
     * Remove these characters from the set.
     */
    sa->remove(sa->set, 0x0e);
    sa->remove(sa->set, 0x0f);
    sa->remove(sa->set, 0x1b);

    /* ISO 2022 converters do not convert C1 controls either */
    sa->removeRange(sa->set, 0x80, 0x9f);
}

static const UConverterImpl _ISO2022Impl={
    UCNV_ISO_2022,

    nullptr,
    nullptr,

    _ISO2022Open,
    _ISO2022Close,
    _ISO2022Reset,

#ifdef U_ENABLE_GENERIC_ISO_2022
    T_UConverter_toUnicode_ISO_2022_OFFSETS_LOGIC,
    T_UConverter_toUnicode_ISO_2022_OFFSETS_LOGIC,
    ucnv_fromUnicode_UTF8,
    ucnv_fromUnicode_UTF8_OFFSETS_LOGIC,
#else
    nullptr,
    nullptr,
    nullptr,
    nullptr,
#endif
    nullptr,

    nullptr,
    _ISO2022getName,
    _ISO_2022_WriteSub,
    _ISO_2022_SafeClone,
    _ISO_2022_GetUnicodeSet,

    nullptr,
    nullptr
};
static const UConverterStaticData _ISO2022StaticData={
    sizeof(UConverterStaticData),
    "ISO_2022",
    2022,
    UCNV_IBM,
    UCNV_ISO_2022,
    1,
    3, /* max 3 bytes per char16_t from UTF-8 (4 bytes from surrogate _pair_) */
    { 0x1a, 0, 0, 0 },
    1,
    false,
    false,
    0,
    0,
    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
};
const UConverterSharedData _ISO2022Data=
        UCNV_IMMUTABLE_SHARED_DATA_INITIALIZER(&_ISO2022StaticData, &_ISO2022Impl);

/*************JP****************/
static const UConverterImpl _ISO2022JPImpl={
    UCNV_ISO_2022,

    nullptr,
    nullptr,

    _ISO2022Open,
    _ISO2022Close,
    _ISO2022Reset,

    UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC,
    UConverter_toUnicode_ISO_2022_JP_OFFSETS_LOGIC,
    UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC,
    UConverter_fromUnicode_ISO_2022_JP_OFFSETS_LOGIC,
    nullptr,

    nullptr,
    _ISO2022getName,
    _ISO_2022_WriteSub,
    _ISO_2022_SafeClone,
    _ISO_2022_GetUnicodeSet,

    nullptr,
    nullptr
};
static const UConverterStaticData _ISO2022JPStaticData={
    sizeof(UConverterStaticData),
    "ISO_2022_JP",
    0,
    UCNV_IBM,
    UCNV_ISO_2022,
    1,
    6, /* max 6 bytes per char16_t: 4-byte escape sequence + DBCS */
    { 0x1a, 0, 0, 0 },
    1,
    false,
    false,
    0,
    0,
    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
};

namespace {

const UConverterSharedData _ISO2022JPData=
        UCNV_IMMUTABLE_SHARED_DATA_INITIALIZER(&_ISO2022JPStaticData, &_ISO2022JPImpl);

}  // namespace

#if !UCONFIG_ONLY_HTML_CONVERSION
/************* KR ***************/
static const UConverterImpl _ISO2022KRImpl={
    UCNV_ISO_2022,

    nullptr,
    nullptr,

    _ISO2022Open,
    _ISO2022Close,
    _ISO2022Reset,

    UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC,
    UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC,
    UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC,
    UConverter_fromUnicode_ISO_2022_KR_OFFSETS_LOGIC,
    nullptr,

    nullptr,
    _ISO2022getName,
    _ISO_2022_WriteSub,
    _ISO_2022_SafeClone,
    _ISO_2022_GetUnicodeSet,

    nullptr,
    nullptr
};
static const UConverterStaticData _ISO2022KRStaticData={
    sizeof(UConverterStaticData),
    "ISO_2022_KR",
    0,
    UCNV_IBM,
    UCNV_ISO_2022,
    1,
    8, /* max 8 bytes per char16_t */
    { 0x1a, 0, 0, 0 },
    1,
    false,
    false,
    0,
    0,
    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
};

namespace {

const UConverterSharedData _ISO2022KRData=
        UCNV_IMMUTABLE_SHARED_DATA_INITIALIZER(&_ISO2022KRStaticData, &_ISO2022KRImpl);

}  // namespace

/*************** CN ***************/
static const UConverterImpl _ISO2022CNImpl={

    UCNV_ISO_2022,

    nullptr,
    nullptr,

    _ISO2022Open,
    _ISO2022Close,
    _ISO2022Reset,

    UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC,
    UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC,
    UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC,
    UConverter_fromUnicode_ISO_2022_CN_OFFSETS_LOGIC,
    nullptr,

    nullptr,
    _ISO2022getName,
    _ISO_2022_WriteSub,
    _ISO_2022_SafeClone,
    _ISO_2022_GetUnicodeSet,

    nullptr,
    nullptr
};
static const UConverterStaticData _ISO2022CNStaticData={
    sizeof(UConverterStaticData),
    "ISO_2022_CN",
    0,
    UCNV_IBM,
    UCNV_ISO_2022,
    1,
    8, /* max 8 bytes per char16_t: 4-byte CNS designator + 2 bytes for SS2/SS3 + DBCS */
    { 0x1a, 0, 0, 0 },
    1,
    false,
    false,
    0,
    0,
    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
};

namespace {

const UConverterSharedData _ISO2022CNData=
        UCNV_IMMUTABLE_SHARED_DATA_INITIALIZER(&_ISO2022CNStaticData, &_ISO2022CNImpl);

}  // namespace
#endif /* #if !UCONFIG_ONLY_HTML_CONVERSION */

#endif /* #if !UCONFIG_NO_LEGACY_CONVERSION */
                                      node-23.7.0/deps/icu-small/source/common/ucnv_bld.cpp                                               0000664 0000000 0000000 00000163264 14746647661 0022502 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
 ********************************************************************
 * COPYRIGHT:
 * Copyright (c) 1996-2016, International Business Machines Corporation and
 * others. All Rights Reserved.
 ********************************************************************
 *
 *  ucnv_bld.cpp:
 *
 *  Defines functions that are used in the creation/initialization/deletion
 *  of converters and related structures.
 *  uses uconv_io.h routines to access disk information
 *  is used by ucnv.h to implement public API create/delete/flushCache routines
 * Modification History:
 *
 *   Date        Name        Description
 *
 *   06/20/2000  helena      OS/400 port changes; mostly typecast.
 *   06/29/2000  helena      Major rewrite of the callback interface.
*/

#include "unicode/utypes.h"

#if !UCONFIG_NO_CONVERSION

#include "unicode/putil.h"
#include "unicode/udata.h"
#include "unicode/ucnv.h"
#include "unicode/uloc.h"
#include "mutex.h"
#include "putilimp.h"
#include "uassert.h"
#include "utracimp.h"
#include "ucnv_io.h"
#include "ucnv_bld.h"
#include "ucnvmbcs.h"
#include "ucnv_ext.h"
#include "ucnv_cnv.h"
#include "ucnv_imp.h"
#include "uhash.h"
#include "umutex.h"
#include "cstring.h"
#include "cmemory.h"
#include "ucln_cmn.h"
#include "ustr_cnv.h"


#if 0
#include <stdio.h>
extern void UCNV_DEBUG_LOG(char *what, char *who, void *p, int l);
#define UCNV_DEBUG_LOG(x,y,z) UCNV_DEBUG_LOG(x,y,z,__LINE__)
#else
# define UCNV_DEBUG_LOG(x,y,z)
#endif

static const UConverterSharedData * const
converterData[UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES]={
    nullptr, nullptr,

#if UCONFIG_NO_LEGACY_CONVERSION
    nullptr,
#else
    &_MBCSData,
#endif

    &_Latin1Data,
    &_UTF8Data, &_UTF16BEData, &_UTF16LEData,
#if UCONFIG_ONLY_HTML_CONVERSION
    nullptr, nullptr,
#else
    &_UTF32BEData, &_UTF32LEData,
#endif
    nullptr,

#if UCONFIG_NO_LEGACY_CONVERSION
    nullptr,
#else
    &_ISO2022Data,
#endif

#if UCONFIG_NO_LEGACY_CONVERSION || UCONFIG_ONLY_HTML_CONVERSION
    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
    nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
    nullptr,
#else
    &_LMBCSData1,&_LMBCSData2, &_LMBCSData3, &_LMBCSData4, &_LMBCSData5, &_LMBCSData6,
    &_LMBCSData8,&_LMBCSData11,&_LMBCSData16,&_LMBCSData17,&_LMBCSData18,&_LMBCSData19,
    &_HZData,
#endif

#if UCONFIG_ONLY_HTML_CONVERSION
    nullptr,
#else
    &_SCSUData,
#endif


#if UCONFIG_NO_LEGACY_CONVERSION || UCONFIG_ONLY_HTML_CONVERSION
    nullptr,
#else
    &_ISCIIData,
#endif

    &_ASCIIData,
#if UCONFIG_ONLY_HTML_CONVERSION
    nullptr, nullptr, &_UTF16Data, nullptr, nullptr, nullptr,
#else
    &_UTF7Data, &_Bocu1Data, &_UTF16Data, &_UTF32Data, &_CESU8Data, &_IMAPData,
#endif

#if UCONFIG_NO_LEGACY_CONVERSION || UCONFIG_ONLY_HTML_CONVERSION
    nullptr,
#else
    &_CompoundTextData
#endif
};

/* Please keep this in binary sorted order for getAlgorithmicTypeFromName.
   Also the name should be in lower case and all spaces, dashes and underscores
   removed
*/
static struct {
  const char *name;
  const UConverterType type;
} const cnvNameType[] = {
#if !UCONFIG_ONLY_HTML_CONVERSION
  { "bocu1", UCNV_BOCU1 },
  { "cesu8", UCNV_CESU8 },
#endif
#if !UCONFIG_NO_LEGACY_CONVERSION && !UCONFIG_ONLY_HTML_CONVERSION
  { "hz",UCNV_HZ },
#endif
#if !UCONFIG_ONLY_HTML_CONVERSION
  { "imapmailboxname", UCNV_IMAP_MAILBOX },
#endif
#if !UCONFIG_NO_LEGACY_CONVERSION && !UCONFIG_ONLY_HTML_CONVERSION
  { "iscii", UCNV_ISCII },
#endif
#if !UCONFIG_NO_LEGACY_CONVERSION
  { "iso2022", UCNV_ISO_2022 },
#endif
  { "iso88591", UCNV_LATIN_1 },
#if !UCONFIG_NO_LEGACY_CONVERSION && !UCONFIG_ONLY_HTML_CONVERSION
  { "lmbcs1", UCNV_LMBCS_1 },
  { "lmbcs11",UCNV_LMBCS_11 },
  { "lmbcs16",UCNV_LMBCS_16 },
  { "lmbcs17",UCNV_LMBCS_17 },
  { "lmbcs18",UCNV_LMBCS_18 },
  { "lmbcs19",UCNV_LMBCS_19 },
  { "lmbcs2", UCNV_LMBCS_2 },
  { "lmbcs3", UCNV_LMBCS_3 },
  { "lmbcs4", UCNV_LMBCS_4 },
  { "lmbcs5", UCNV_LMBCS_5 },
  { "lmbcs6", UCNV_LMBCS_6 },
  { "lmbcs8", UCNV_LMBCS_8 },
#endif
#if !UCONFIG_ONLY_HTML_CONVERSION
  { "scsu", UCNV_SCSU },
#endif
  { "usascii", UCNV_US_ASCII },
  { "utf16", UCNV_UTF16 },
  { "utf16be", UCNV_UTF16_BigEndian },
  { "utf16le", UCNV_UTF16_LittleEndian },
#if U_IS_BIG_ENDIAN
  { "utf16oppositeendian", UCNV_UTF16_LittleEndian },
  { "utf16platformendian", UCNV_UTF16_BigEndian },
#else
  { "utf16oppositeendian", UCNV_UTF16_BigEndian},
  { "utf16platformendian", UCNV_UTF16_LittleEndian },
#endif
#if !UCONFIG_ONLY_HTML_CONVERSION
  { "utf32", UCNV_UTF32 },
  { "utf32be", UCNV_UTF32_BigEndian },
  { "utf32le", UCNV_UTF32_LittleEndian },
#if U_IS_BIG_ENDIAN
  { "utf32oppositeendian", UCNV_UTF32_LittleEndian },
  { "utf32platformendian", UCNV_UTF32_BigEndian },
#else
  { "utf32oppositeendian", UCNV_UTF32_BigEndian },
  { "utf32platformendian", UCNV_UTF32_LittleEndian },
#endif
#endif
#if !UCONFIG_ONLY_HTML_CONVERSION
  { "utf7", UCNV_UTF7 },
#endif
  { "utf8", UCNV_UTF8 },
#if !UCONFIG_ONLY_HTML_CONVERSION
  { "x11compoundtext", UCNV_COMPOUND_TEXT}
#endif
};


/*initializes some global variables */
static UHashtable *SHARED_DATA_HASHTABLE = nullptr;
static icu::UMutex cnvCacheMutex;
/*  Note:  the global mutex is used for      */
/*         reference count updates.          */

static const char **gAvailableConverters = nullptr;
static uint16_t gAvailableConverterCount = 0;
static icu::UInitOnce gAvailableConvertersInitOnce {};

#if !U_CHARSET_IS_UTF8

/* This contains the resolved converter name. So no further alias lookup is needed again. */
static char gDefaultConverterNameBuffer[UCNV_MAX_CONVERTER_NAME_LENGTH + 1]; /* +1 for nullptr */
static const char *gDefaultConverterName = nullptr;

/*
If the default converter is an algorithmic converter, this is the cached value.
We don't cache a full UConverter and clone it because ucnv_clone doesn't have
less overhead than an algorithmic open. We don't cache non-algorithmic converters
because ucnv_flushCache must be able to unload the default converter and its table.
*/
static const UConverterSharedData *gDefaultAlgorithmicSharedData = nullptr;

/* Does gDefaultConverterName have a converter option and require extra parsing? */
static UBool gDefaultConverterContainsOption;

#endif  /* !U_CHARSET_IS_UTF8 */

static const char DATA_TYPE[] = "cnv";

/* ucnv_flushAvailableConverterCache. This is only called from ucnv_cleanup().
 *                       If it is ever to be called from elsewhere, synchronization
 *                       will need to be considered.
 */
static void
ucnv_flushAvailableConverterCache() {
    gAvailableConverterCount = 0;
    if (gAvailableConverters) {
        uprv_free(const_cast<char**>(gAvailableConverters));
        gAvailableConverters = nullptr;
    }
    gAvailableConvertersInitOnce.reset();
}

/* ucnv_cleanup - delete all storage held by the converter cache, except any  */
/*                in use by open converters.                                  */
/*                Not thread safe.                                            */
/*                Not supported API.                                          */
static UBool U_CALLCONV ucnv_cleanup() {
    ucnv_flushCache();
    if (SHARED_DATA_HASHTABLE != nullptr && uhash_count(SHARED_DATA_HASHTABLE) == 0) {
        uhash_close(SHARED_DATA_HASHTABLE);
        SHARED_DATA_HASHTABLE = nullptr;
    }

    /* Isn't called from flushCache because other threads may have preexisting references to the table. */
    ucnv_flushAvailableConverterCache();

#if !U_CHARSET_IS_UTF8
    gDefaultConverterName = nullptr;
    gDefaultConverterNameBuffer[0] = 0;
    gDefaultConverterContainsOption = false;
    gDefaultAlgorithmicSharedData = nullptr;
#endif

    return (SHARED_DATA_HASHTABLE == nullptr);
}

U_CAPI void U_EXPORT2
ucnv_enableCleanup() {
    ucln_common_registerCleanup(UCLN_COMMON_UCNV, ucnv_cleanup);
}

static UBool U_CALLCONV
isCnvAcceptable(void * /*context*/,
                const char * /*type*/, const char * /*name*/,
                const UDataInfo *pInfo) {
    return
        pInfo->size>=20 &&
        pInfo->isBigEndian==U_IS_BIG_ENDIAN &&
        pInfo->charsetFamily==U_CHARSET_FAMILY &&
        pInfo->sizeofUChar==U_SIZEOF_UCHAR &&
        pInfo->dataFormat[0]==0x63 &&   /* dataFormat="cnvt" */
        pInfo->dataFormat[1]==0x6e &&
        pInfo->dataFormat[2]==0x76 &&
        pInfo->dataFormat[3]==0x74 &&
        pInfo->formatVersion[0]==6;  /* Everything will be version 6 */
}

/**
 * Un flatten shared data from a UDATA..
 */
static UConverterSharedData*
ucnv_data_unFlattenClone(UConverterLoadArgs *pArgs, UDataMemory *pData, UErrorCode *status)
{
    /* UDataInfo info; -- necessary only if some converters have different formatVersion */
    const uint8_t* raw = static_cast<const uint8_t*>(udata_getMemory(pData));
    const UConverterStaticData* source = reinterpret_cast<const UConverterStaticData*>(raw);
    UConverterSharedData *data;
    UConverterType type = static_cast<UConverterType>(source->conversionType);

    if(U_FAILURE(*status))
        return nullptr;

    if (static_cast<uint16_t>(type) >= UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES ||
        converterData[type] == nullptr ||
        !converterData[type]->isReferenceCounted ||
        converterData[type]->referenceCounter != 1 ||
        source->structSize != sizeof(UConverterStaticData))
    {
        *status = U_INVALID_TABLE_FORMAT;
        return nullptr;
    }

    data = static_cast<UConverterSharedData*>(uprv_malloc(sizeof(UConverterSharedData)));
    if(data == nullptr) {
        *status = U_MEMORY_ALLOCATION_ERROR;
        return nullptr;
    }

    /* copy initial values from the static structure for this type */
    uprv_memcpy(data, converterData[type], sizeof(UConverterSharedData));

    data->staticData = source;

    data->sharedDataCached = false;

    /* fill in fields from the loaded data */
    data->dataMemory = (void*)pData; /* for future use */

    if(data->impl->load != nullptr) {
        data->impl->load(data, pArgs, raw + source->structSize, status);
        if(U_FAILURE(*status)) {
            uprv_free(data);
            return nullptr;
        }
    }
    return data;
}

/*Takes an alias name gets an actual converter file name
 *goes to disk and opens it.
 *allocates the memory and returns a new UConverter object
 */
static UConverterSharedData *createConverterFromFile(UConverterLoadArgs *pArgs, UErrorCode * err)
{
    UDataMemory *data;
    UConverterSharedData *sharedData;

    UTRACE_ENTRY_OC(UTRACE_UCNV_LOAD);

    if (U_FAILURE (*err)) {
        UTRACE_EXIT_STATUS(*err);
        return nullptr;
    }

    UTRACE_DATA2(UTRACE_OPEN_CLOSE, "load converter %s from package %s", pArgs->name, pArgs->pkg);

    data = udata_openChoice(pArgs->pkg, DATA_TYPE, pArgs->name, isCnvAcceptable, nullptr, err);
    if(U_FAILURE(*err))
    {
        UTRACE_EXIT_STATUS(*err);
        return nullptr;
    }

    sharedData = ucnv_data_unFlattenClone(pArgs, data, err);
    if(U_FAILURE(*err))
    {
        udata_close(data);
        UTRACE_EXIT_STATUS(*err);
        return nullptr;
    }

    /*
     * TODO Store pkg in a field in the shared data so that delta-only converters
     * can load base converters from the same package.
     * If the pkg name is longer than the field, then either do not load the converter
     * in the first place, or just set the pkg field to "".
     */

    UTRACE_EXIT_PTR_STATUS(sharedData, *err);
    return sharedData;
}

/*returns a converter type from a string
 */
static const UConverterSharedData *
getAlgorithmicTypeFromName(const char *realName)
{
    uint32_t mid, start, limit;
    uint32_t lastMid;
    int result;
    char strippedName[UCNV_MAX_CONVERTER_NAME_LENGTH];

    /* Lower case and remove ignoreable characters. */
    ucnv_io_stripForCompare(strippedName, realName);

    /* do a binary search for the alias */
    start = 0;
    limit = UPRV_LENGTHOF(cnvNameType);
    mid = limit;
    lastMid = UINT32_MAX;

    for (;;) {
        mid = (start + limit) / 2;
        if (lastMid == mid) {   /* Have we moved? */
            break;  /* We haven't moved, and it wasn't found. */
        }
        lastMid = mid;
        result = uprv_strcmp(strippedName, cnvNameType[mid].name);

        if (result < 0) {
            limit = mid;
        } else if (result > 0) {
            start = mid;
        } else {
            return converterData[cnvNameType[mid].type];
        }
    }

    return nullptr;
}

/*
* Based on the number of known converters, this determines how many times larger
* the shared data hash table should be. When on small platforms, or just a couple
* of converters are used, this number should be 2. When memory is plentiful, or
* when ucnv_countAvailable is ever used with a lot of available converters,
* this should be 4.
* Larger numbers reduce the number of hash collisions, but use more memory.
*/
#define UCNV_CACHE_LOAD_FACTOR 2

/* Puts the shared data in the static hashtable SHARED_DATA_HASHTABLE */
/*   Will always be called with the cnvCacheMutex already being held   */
/*     by the calling function.                                       */
/* Stores the shared data in the SHARED_DATA_HASHTABLE
 * @param data The shared data
 */
static void
ucnv_shareConverterData(UConverterSharedData * data)
{
    UErrorCode err = U_ZERO_ERROR;
    /*Lazy evaluates the Hashtable itself */
    /*void *sanity = nullptr;*/

    if (SHARED_DATA_HASHTABLE == nullptr)
    {
        SHARED_DATA_HASHTABLE = uhash_openSize(uhash_hashChars, uhash_compareChars, nullptr,
                            ucnv_io_countKnownConverters(&err)*UCNV_CACHE_LOAD_FACTOR,
                            &err);
        ucnv_enableCleanup();

        if (U_FAILURE(err))
            return;
    }

    /* ### check to see if the element is not already there! */

    /*
    sanity =   ucnv_getSharedConverterData (data->staticData->name);
    if(sanity != nullptr)
    {
    UCNV_DEBUG_LOG("put:overwrite!",data->staticData->name,sanity);
    }
    UCNV_DEBUG_LOG("put:chk",data->staticData->name,sanity);
    */

    /* Mark it shared */
    data->sharedDataCached = true;

    uhash_put(SHARED_DATA_HASHTABLE,
            (void*) data->staticData->name, /* Okay to cast away const as long as
            keyDeleter == nullptr */
            data,
            &err);
    UCNV_DEBUG_LOG("put", data->staticData->name,data);

}

/*  Look up a converter name in the shared data cache.                    */
/*    cnvCacheMutex must be held by the caller to protect the hash table. */
/* gets the shared data from the SHARED_DATA_HASHTABLE (might return nullptr if it isn't there)
 * @param name The name of the shared data
 * @return the shared data from the SHARED_DATA_HASHTABLE
 */
static UConverterSharedData *
ucnv_getSharedConverterData(const char *name)
{
    /*special case when no Table has yet been created we return nullptr */
    if (SHARED_DATA_HASHTABLE == nullptr)
    {
        return nullptr;
    }
    else
    {
        UConverterSharedData *rc;

        rc = static_cast<UConverterSharedData*>(uhash_get(SHARED_DATA_HASHTABLE, name));
        UCNV_DEBUG_LOG("get",name,rc);
        return rc;
    }
}

/*frees the string of memory blocks associates with a sharedConverter
 *if and only if the referenceCounter == 0
 */
/* Deletes (frees) the Shared data it's passed. first it checks the referenceCounter to
 * see if anyone is using it, if not it frees all the memory stemming from sharedConverterData and
 * returns true,
 * otherwise returns false
 * @param sharedConverterData The shared data
 * @return if not it frees all the memory stemming from sharedConverterData and
 * returns true, otherwise returns false
 */
static UBool
ucnv_deleteSharedConverterData(UConverterSharedData * deadSharedData)
{
    UTRACE_ENTRY_OC(UTRACE_UCNV_UNLOAD);
    UTRACE_DATA2(UTRACE_OPEN_CLOSE, "unload converter %s shared data %p", deadSharedData->staticData->name, deadSharedData);

    if (deadSharedData->referenceCounter > 0) {
        UTRACE_EXIT_VALUE((int32_t)false);
        return false;
    }

    if (deadSharedData->impl->unload != nullptr) {
        deadSharedData->impl->unload(deadSharedData);
    }

    if(deadSharedData->dataMemory != nullptr)
    {
        UDataMemory *data = (UDataMemory*)deadSharedData->dataMemory;
        udata_close(data);
    }

    uprv_free(deadSharedData);

    UTRACE_EXIT_VALUE((int32_t)true);
    return true;
}

/**
 * Load a non-algorithmic converter.
 * If pkg==nullptr, then this function must be called inside umtx_lock(&cnvCacheMutex).
 */
UConverterSharedData *
ucnv_load(UConverterLoadArgs *pArgs, UErrorCode *err) {
    UConverterSharedData *mySharedConverterData;

    if(err == nullptr || U_FAILURE(*err)) {
        return nullptr;
    }

    if(pArgs->pkg != nullptr && *pArgs->pkg != 0) {
        /* application-provided converters are not currently cached */
        return createConverterFromFile(pArgs, err);
    }

    mySharedConverterData = ucnv_getSharedConverterData(pArgs->name);
    if (mySharedConverterData == nullptr)
    {
        /*Not cached, we need to stream it in from file */
        mySharedConverterData = createConverterFromFile(pArgs, err);
        if (U_FAILURE (*err) || (mySharedConverterData == nullptr))
        {
            return nullptr;
        }
        else if (!pArgs->onlyTestIsLoadable)
        {
            /* share it with other library clients */
            ucnv_shareConverterData(mySharedConverterData);
        }
    }
    else
    {
        /* The data for this converter was already in the cache.            */
        /* Update the reference counter on the shared data: one more client */
        mySharedConverterData->referenceCounter++;
    }

    return mySharedConverterData;
}

/**
 * Unload a non-algorithmic converter.
 * It must be sharedData->isReferenceCounted
 * and this function must be called inside umtx_lock(&cnvCacheMutex).
 */
U_CAPI void
ucnv_unload(UConverterSharedData *sharedData) {
    if(sharedData != nullptr) {
        if (sharedData->referenceCounter > 0) {
            sharedData->referenceCounter--;
        }

        if((sharedData->referenceCounter <= 0)&&(sharedData->sharedDataCached == false)) {
            ucnv_deleteSharedConverterData(sharedData);
        }
    }
}

U_CFUNC void
ucnv_unloadSharedDataIfReady(UConverterSharedData *sharedData)
{
    if(sharedData != nullptr && sharedData->isReferenceCounted) {
        umtx_lock(&cnvCacheMutex);
        ucnv_unload(sharedData);
        umtx_unlock(&cnvCacheMutex);
    }
}

U_CFUNC void
ucnv_incrementRefCount(UConverterSharedData *sharedData)
{
    if(sharedData != nullptr && sharedData->isReferenceCounted) {
        umtx_lock(&cnvCacheMutex);
        sharedData->referenceCounter++;
        umtx_unlock(&cnvCacheMutex);
    }
}

/*
 * *pPieces must be initialized.
 * The name without options will be copied to pPieces->cnvName.
 * The locale and options will be copied to pPieces only if present in inName,
 * otherwise the existing values in pPieces remain.
 * *pArgs will be set to the pPieces values.
 */
static void
parseConverterOptions(const char *inName,
                      UConverterNamePieces *pPieces,
                      UConverterLoadArgs *pArgs,
                      UErrorCode *err)
{
    char *cnvName = pPieces->cnvName;
    char c;
    int32_t len = 0;

    pArgs->name=inName;
    pArgs->locale=pPieces->locale;
    pArgs->options=pPieces->options;

    /* copy the converter name itself to cnvName */
    while((c=*inName)!=0 && c!=UCNV_OPTION_SEP_CHAR) {
        if (++len>=UCNV_MAX_CONVERTER_NAME_LENGTH) {
            *err = U_ILLEGAL_ARGUMENT_ERROR;    /* bad name */
            pPieces->cnvName[0]=0;
            return;
        }
        *cnvName++=c;
        inName++;
    }
    *cnvName=0;
    pArgs->name=pPieces->cnvName;

    /* parse options. No more name copying should occur. */
    while((c=*inName)!=0) {
        if(c==UCNV_OPTION_SEP_CHAR) {
            ++inName;
        }

        /* inName is behind an option separator */
        if(uprv_strncmp(inName, "locale=", 7)==0) {
            /* do not modify locale itself in case we have multiple locale options */
            char *dest=pPieces->locale;

            /* copy the locale option value */
            inName+=7;
            len=0;
            while((c=*inName)!=0 && c!=UCNV_OPTION_SEP_CHAR) {
                ++inName;

                if(++len>=ULOC_FULLNAME_CAPACITY) {
                    *err=U_ILLEGAL_ARGUMENT_ERROR;    /* bad name */
                    pPieces->locale[0]=0;
                    return;
                }

                *dest++=c;
            }
            *dest=0;
        } else if(uprv_strncmp(inName, "version=", 8)==0) {
            /* copy the version option value into bits 3..0 of pPieces->options */
            inName+=8;
            c=*inName;
            if(c==0) {
                pArgs->options=(pPieces->options&=~UCNV_OPTION_VERSION);
                return;
            } else if (static_cast<uint8_t>(c - '0') < 10) {
                pArgs->options = pPieces->options = (pPieces->options & ~UCNV_OPTION_VERSION) | static_cast<uint32_t>(c - '0');
                ++inName;
            }
        } else if(uprv_strncmp(inName, "swaplfnl", 8)==0) {
            inName+=8;
            pArgs->options=(pPieces->options|=UCNV_OPTION_SWAP_LFNL);
        /* add processing for new options here with another } else if(uprv_strncmp(inName, "option-name=", XX)==0) { */
        } else {
            /* ignore any other options until we define some */
            while(((c = *inName++) != 0) && (c != UCNV_OPTION_SEP_CHAR)) {
            }
            if(c==0) {
                return;
            }
        }
    }
}

/*Logic determines if the converter is Algorithmic AND/OR cached
 *depending on that:
 * -we either go to get data from disk and cache it (Data=true, Cached=false)
 * -Get it from a Hashtable (Data=X, Cached=true)
 * -Call dataConverter initializer (Data=true, Cached=true)
 * -Call AlgorithmicConverter initializer (Data=false, Cached=true)
 */
U_CFUNC UConverterSharedData *
ucnv_loadSharedData(const char *converterName,
                    UConverterNamePieces *pPieces,
                    UConverterLoadArgs *pArgs,
                    UErrorCode * err) {
    UConverterNamePieces stackPieces;
    UConverterLoadArgs stackArgs;
    UConverterSharedData *mySharedConverterData = nullptr;
    UErrorCode internalErrorCode = U_ZERO_ERROR;
    UBool mayContainOption = true;
    UBool checkForAlgorithmic = true;

    if (U_FAILURE (*err)) {
        return nullptr;
    }

    if(pPieces == nullptr) {
        if(pArgs != nullptr) {
            /*
             * Bad: We may set pArgs pointers to stackPieces fields
             * which will be invalid after this function returns.
             */
            *err = U_INTERNAL_PROGRAM_ERROR;
            return nullptr;
        }
        pPieces = &stackPieces;
    }
    if(pArgs == nullptr) {
        uprv_memset(&stackArgs, 0, sizeof(stackArgs));
        stackArgs.size = (int32_t)sizeof(stackArgs);
        pArgs = &stackArgs;
    }

    pPieces->cnvName[0] = 0;
    pPieces->locale[0] = 0;
    pPieces->options = 0;

    pArgs->name = converterName;
    pArgs->locale = pPieces->locale;
    pArgs->options = pPieces->options;

    /* In case "name" is nullptr we want to open the default converter. */
    if (converterName == nullptr) {
#if U_CHARSET_IS_UTF8
        pArgs->name = "UTF-8";
        return (UConverterSharedData *)converterData[UCNV_UTF8];
#else
        /* Call ucnv_getDefaultName first to query the name from the OS. */
        pArgs->name = ucnv_getDefaultName();
        if (pArgs->name == nullptr) {
            *err = U_MISSING_RESOURCE_ERROR;
            return nullptr;
        }
        mySharedConverterData = (UConverterSharedData *)gDefaultAlgorithmicSharedData;
        checkForAlgorithmic = false;
        mayContainOption = gDefaultConverterContainsOption;
        /* the default converter name is already canonical */
#endif
    }
    else if(UCNV_FAST_IS_UTF8(converterName)) {
        /* fastpath for UTF-8 */
        pArgs->name = "UTF-8";
        return (UConverterSharedData *)converterData[UCNV_UTF8];
    }
    else {
        /* separate the converter name from the options */
        parseConverterOptions(converterName, pPieces, pArgs, err);
        if (U_FAILURE(*err)) {
            /* Very bad name used. */
            return nullptr;
        }

        /* get the canonical converter name */
        pArgs->name = ucnv_io_getConverterName(pArgs->name, &mayContainOption, &internalErrorCode);
        if (U_FAILURE(internalErrorCode) || pArgs->name == nullptr) {
            /*
            * set the input name in case the converter was added
            * without updating the alias table, or when there is no alias table
            */
            pArgs->name = pPieces->cnvName;
        } else if (internalErrorCode == U_AMBIGUOUS_ALIAS_WARNING) {
            *err = U_AMBIGUOUS_ALIAS_WARNING;
        }
    }

    /* separate the converter name from the options */
    if(mayContainOption && pArgs->name != pPieces->cnvName) {
        parseConverterOptions(pArgs->name, pPieces, pArgs, err);
    }

    /* get the shared data for an algorithmic converter, if it is one */
    if (checkForAlgorithmic) {
        mySharedConverterData = (UConverterSharedData *)getAlgorithmicTypeFromName(pArgs->name);
    }
    if (mySharedConverterData == nullptr)
    {
        /* it is a data-based converter, get its shared data.               */
        /* Hold the cnvCacheMutex through the whole process of checking the */
        /*   converter data cache, and adding new entries to the cache      */
        /*   to prevent other threads from modifying the cache during the   */
        /*   process.                                                       */
        pArgs->nestedLoads=1;
        pArgs->pkg=nullptr;

        umtx_lock(&cnvCacheMutex);
        mySharedConverterData = ucnv_load(pArgs, err);
        umtx_unlock(&cnvCacheMutex);
        if (U_FAILURE (*err) || (mySharedConverterData == nullptr))
        {
            return nullptr;
        }
    }

    return mySharedConverterData;
}

U_CAPI UConverter *
ucnv_createConverter(UConverter *myUConverter, const char *converterName, UErrorCode * err)
{
    UConverterNamePieces stackPieces;
    UConverterLoadArgs stackArgs=UCNV_LOAD_ARGS_INITIALIZER;
    UConverterSharedData *mySharedConverterData;

    UTRACE_ENTRY_OC(UTRACE_UCNV_OPEN);

    if(U_SUCCESS(*err)) {
        UTRACE_DATA1(UTRACE_OPEN_CLOSE, "open converter %s", converterName);

        mySharedConverterData = ucnv_loadSharedData(converterName, &stackPieces, &stackArgs, err);

        myUConverter = ucnv_createConverterFromSharedData(
            myUConverter, mySharedConverterData,
            &stackArgs,
            err);

        if(U_SUCCESS(*err)) {
            UTRACE_EXIT_PTR_STATUS(myUConverter, *err);
            return myUConverter;
        }
    }

    /* exit with error */
    UTRACE_EXIT_STATUS(*err);
    return nullptr;
}

U_CFUNC UBool
ucnv_canCreateConverter(const char *converterName, UErrorCode *err) {
    UConverter myUConverter;
    UConverterNamePieces stackPieces;
    UConverterLoadArgs stackArgs=UCNV_LOAD_ARGS_INITIALIZER;
    UConverterSharedData *mySharedConverterData;

    UTRACE_ENTRY_OC(UTRACE_UCNV_OPEN);

    if(U_SUCCESS(*err)) {
        UTRACE_DATA1(UTRACE_OPEN_CLOSE, "test if can open converter %s", converterName);

        stackArgs.onlyTestIsLoadable=true;
        mySharedConverterData = ucnv_loadSharedData(converterName, &stackPieces, &stackArgs, err);
        ucnv_createConverterFromSharedData(
            &myUConverter, mySharedConverterData,
            &stackArgs,
            err);
        ucnv_unloadSharedDataIfReady(mySharedConverterData);
    }

    UTRACE_EXIT_STATUS(*err);
    return U_SUCCESS(*err);
}

UConverter *
ucnv_createAlgorithmicConverter(UConverter *myUConverter,
                                UConverterType type,
                                const char *locale, uint32_t options,
                                UErrorCode *err) {
    UConverter *cnv;
    const UConverterSharedData *sharedData;
    UConverterLoadArgs stackArgs=UCNV_LOAD_ARGS_INITIALIZER;

    UTRACE_ENTRY_OC(UTRACE_UCNV_OPEN_ALGORITHMIC);
    UTRACE_DATA1(UTRACE_OPEN_CLOSE, "open algorithmic converter type %d", (int32_t)type);

    if(type<0 || UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES<=type) {
        *err = U_ILLEGAL_ARGUMENT_ERROR;
        UTRACE_EXIT_STATUS(U_ILLEGAL_ARGUMENT_ERROR);
        return nullptr;
    }

    sharedData = converterData[type];
    if(sharedData == nullptr || sharedData->isReferenceCounted) {
        /* not a valid type, or not an algorithmic converter */
        *err = U_ILLEGAL_ARGUMENT_ERROR;
        UTRACE_EXIT_STATUS(U_ILLEGAL_ARGUMENT_ERROR);
        return nullptr;
    }

    stackArgs.name = "";
    stackArgs.options = options;
    stackArgs.locale=locale;
    cnv = ucnv_createConverterFromSharedData(
            myUConverter, const_cast<UConverterSharedData*>(sharedData),
            &stackArgs, err);

    UTRACE_EXIT_PTR_STATUS(cnv, *err);
    return cnv;
}

U_CFUNC UConverter*
ucnv_createConverterFromPackage(const char *packageName, const char *converterName, UErrorCode * err)
{
    UConverter *myUConverter;
    UConverterSharedData *mySharedConverterData;
    UConverterNamePieces stackPieces;
    UConverterLoadArgs stackArgs=UCNV_LOAD_ARGS_INITIALIZER;

    UTRACE_ENTRY_OC(UTRACE_UCNV_OPEN_PACKAGE);

    if(U_FAILURE(*err)) {
        UTRACE_EXIT_STATUS(*err);
        return nullptr;
    }

    UTRACE_DATA2(UTRACE_OPEN_CLOSE, "open converter %s from package %s", converterName, packageName);

    /* first, get the options out of the converterName string */
    stackPieces.cnvName[0] = 0;
    stackPieces.locale[0] = 0;
    stackPieces.options = 0;
    parseConverterOptions(converterName, &stackPieces, &stackArgs, err);
    if (U_FAILURE(*err)) {
        /* Very bad name used. */
        UTRACE_EXIT_STATUS(*err);
        return nullptr;
    }
    stackArgs.nestedLoads=1;
    stackArgs.pkg=packageName;

    /* open the data, unflatten the shared structure */
    mySharedConverterData = createConverterFromFile(&stackArgs, err);

    if (U_FAILURE(*err)) {
        UTRACE_EXIT_STATUS(*err);
        return nullptr;
    }

    /* create the actual converter */
    myUConverter = ucnv_createConverterFromSharedData(nullptr, mySharedConverterData, &stackArgs, err);

    if (U_FAILURE(*err)) {
        ucnv_close(myUConverter);
        UTRACE_EXIT_STATUS(*err);
        return nullptr;
    }

    UTRACE_EXIT_PTR_STATUS(myUConverter, *err);
    return myUConverter;
}


U_CFUNC UConverter*
ucnv_createConverterFromSharedData(UConverter *myUConverter,
                                   UConverterSharedData *mySharedConverterData,
                                   UConverterLoadArgs *pArgs,
                                   UErrorCode *err)
{
    UBool isCopyLocal;

    if(U_FAILURE(*err)) {
        ucnv_unloadSharedDataIfReady(mySharedConverterData);
        return myUConverter;
    }
    if(myUConverter == nullptr)
    {
        myUConverter = (UConverter *) uprv_malloc (sizeof (UConverter));
        if(myUConverter == nullptr)
        {
            *err = U_MEMORY_ALLOCATION_ERROR;
            ucnv_unloadSharedDataIfReady(mySharedConverterData);
            return nullptr;
        }
        isCopyLocal = false;
    } else {
        isCopyLocal = true;
    }

    /* initialize the converter */
    uprv_memset(myUConverter, 0, sizeof(UConverter));
    myUConverter->isCopyLocal = isCopyLocal;
    /*myUConverter->isExtraLocal = false;*/ /* Set by the memset call */
    myUConverter->sharedData = mySharedConverterData;
    myUConverter->options = pArgs->options;
    if(!pArgs->onlyTestIsLoadable) {
        myUConverter->preFromUFirstCP = U_SENTINEL;
        myUConverter->fromCharErrorBehaviour = UCNV_TO_U_DEFAULT_CALLBACK;
        myUConverter->fromUCharErrorBehaviour = UCNV_FROM_U_DEFAULT_CALLBACK;
        myUConverter->toUnicodeStatus = mySharedConverterData->toUnicodeStatus;
        myUConverter->maxBytesPerUChar = mySharedConverterData->staticData->maxBytesPerChar;
        myUConverter->subChar1 = mySharedConverterData->staticData->subChar1;
        myUConverter->subCharLen = mySharedConverterData->staticData->subCharLen;
        myUConverter->subChars = (uint8_t *)myUConverter->subUChars;
        uprv_memcpy(myUConverter->subChars, mySharedConverterData->staticData->subChar, myUConverter->subCharLen);
        myUConverter->toUCallbackReason = UCNV_ILLEGAL; /* default reason to invoke (*fromCharErrorBehaviour) */
    }

    if(mySharedConverterData->impl->open != nullptr) {
        mySharedConverterData->impl->open(myUConverter, pArgs, err);
        if(U_FAILURE(*err) && !pArgs->onlyTestIsLoadable) {
            /* don't ucnv_close() if onlyTestIsLoadable because not fully initialized */
            ucnv_close(myUConverter);
            return nullptr;
        }
    }

    return myUConverter;
}

/*Frees all shared immutable objects that aren't referred to (reference count = 0)
 */
U_CAPI int32_t U_EXPORT2
ucnv_flushCache ()
{
    UConverterSharedData *mySharedData = nullptr;
    int32_t pos;
    int32_t tableDeletedNum = 0;
    const UHashElement *e;
    /*UErrorCode status = U_ILLEGAL_ARGUMENT_ERROR;*/
    int32_t i, remaining;

    UTRACE_ENTRY_OC(UTRACE_UCNV_FLUSH_CACHE);

    /* Close the default converter without creating a new one so that everything will be flushed. */
    u_flushDefaultConverter();

    /*if shared data hasn't even been lazy evaluated yet
    * return 0
    */
    if (SHARED_DATA_HASHTABLE == nullptr) {
        UTRACE_EXIT_VALUE((int32_t)0);
        return 0;
    }

    /*creates an enumeration to iterate through every element in the
    * table
    *
    * Synchronization:  holding cnvCacheMutex will prevent any other thread from
    *                   accessing or modifying the hash table during the iteration.
    *                   The reference count of an entry may be decremented by
    *                   ucnv_close while the iteration is in process, but this is
    *                   benign.  It can't be incremented (in ucnv_createConverter())
    *                   because the sequence of looking up in the cache + incrementing
    *                   is protected by cnvCacheMutex.
    */
    umtx_lock(&cnvCacheMutex);
    /*
     * double loop: A delta/extension-only converter has a pointer to its base table's
     * shared data; the first iteration of the outer loop may see the delta converter
     * before the base converter, and unloading the delta converter may get the base
     * converter's reference counter down to 0.
     */
    i = 0;
    do {
        remaining = 0;
        pos = UHASH_FIRST;
        while ((e = uhash_nextElement (SHARED_DATA_HASHTABLE, &pos)) != nullptr)
        {
            mySharedData = (UConverterSharedData *) e->value.pointer;
            /*deletes only if reference counter == 0 */
            if (mySharedData->referenceCounter == 0)
            {
                tableDeletedNum++;

                UCNV_DEBUG_LOG("del",mySharedData->staticData->name,mySharedData);

                uhash_removeElement(SHARED_DATA_HASHTABLE, e);
                mySharedData->sharedDataCached = false;
                ucnv_deleteSharedConverterData (mySharedData);
            } else {
                ++remaining;
            }
        }
    } while(++i == 1 && remaining > 0);
    umtx_unlock(&cnvCacheMutex);

    UTRACE_DATA1(UTRACE_INFO, "ucnv_flushCache() exits with %d converters remaining", remaining);

    UTRACE_EXIT_VALUE(tableDeletedNum);
    return tableDeletedNum;
}

/* available converters list --------------------------------------------------- */

static void U_CALLCONV initAvailableConvertersList(UErrorCode &errCode) {
    U_ASSERT(gAvailableConverterCount == 0);
    U_ASSERT(gAvailableConverters == nullptr);

    ucnv_enableCleanup();
    UEnumeration *allConvEnum = ucnv_openAllNames(&errCode);
    int32_t allConverterCount = uenum_count(allConvEnum, &errCode);
    if (U_FAILURE(errCode)) {
        return;
    }

    /* We can't have more than "*converterTable" converters to open */
    gAvailableConverters = static_cast<const char**>(uprv_malloc(allConverterCount * sizeof(char*)));
    if (!gAvailableConverters) {
        errCode = U_MEMORY_ALLOCATION_ERROR;
        return;
    }

    /* Open the default converter to make sure that it has first dibs in the hash table. */
    UErrorCode localStatus = U_ZERO_ERROR;
    UConverter tempConverter;
    ucnv_close(ucnv_createConverter(&tempConverter, nullptr, &localStatus));

    gAvailableConverterCount = 0;

    for (int32_t idx = 0; idx < allConverterCount; idx++) {
        localStatus = U_ZERO_ERROR;
        const char *converterName = uenum_next(allConvEnum, nullptr, &localStatus);
        if (ucnv_canCreateConverter(converterName, &localStatus)) {
            gAvailableConverters[gAvailableConverterCount++] = converterName;
        }
    }

    uenum_close(allConvEnum);
}


static UBool haveAvailableConverterList(UErrorCode *pErrorCode) {
    umtx_initOnce(gAvailableConvertersInitOnce, &initAvailableConvertersList, *pErrorCode);
    return U_SUCCESS(*pErrorCode);
}

U_CFUNC uint16_t
ucnv_bld_countAvailableConverters(UErrorCode *pErrorCode) {
    if (haveAvailableConverterList(pErrorCode)) {
        return gAvailableConverterCount;
    }
    return 0;
}

U_CFUNC const char *
ucnv_bld_getAvailableConverter(uint16_t n, UErrorCode *pErrorCode) {
    if (haveAvailableConverterList(pErrorCode)) {
        if (n < gAvailableConverterCount) {
            return gAvailableConverters[n];
        }
        *pErrorCode = U_INDEX_OUTOFBOUNDS_ERROR;
    }
    return nullptr;
}

/* default converter name --------------------------------------------------- */

#if !U_CHARSET_IS_UTF8
/*
Copy the canonical converter name.
ucnv_getDefaultName must be thread safe, which can call this function.

ucnv_setDefaultName calls this function and it doesn't have to be
thread safe because there is no reliable/safe way to reset the
converter in use in all threads. If you did reset the converter, you
would not be sure that retrieving a default converter for one string
would be the same type of default converter for a successive string.
Since the name is a returned via ucnv_getDefaultName without copying,
you shouldn't be modifying or deleting the string from a separate thread.
*/
static inline void
internalSetName(const char *name, UErrorCode *status) {
    UConverterNamePieces stackPieces;
    UConverterLoadArgs stackArgs=UCNV_LOAD_ARGS_INITIALIZER;
    int32_t length=(int32_t)(uprv_strlen(name));
    UBool containsOption = (UBool)(uprv_strchr(name, UCNV_OPTION_SEP_CHAR) != nullptr);
    const UConverterSharedData *algorithmicSharedData;

    stackArgs.name = name;
    if(containsOption) {
        stackPieces.cnvName[0] = 0;
        stackPieces.locale[0] = 0;
        stackPieces.options = 0;
        parseConverterOptions(name, &stackPieces, &stackArgs, status);
        if(U_FAILURE(*status)) {
            return;
        }
    }
    algorithmicSharedData = getAlgorithmicTypeFromName(stackArgs.name);

    umtx_lock(&cnvCacheMutex);

    gDefaultAlgorithmicSharedData = algorithmicSharedData;
    gDefaultConverterContainsOption = containsOption;
    uprv_memcpy(gDefaultConverterNameBuffer, name, length);
    gDefaultConverterNameBuffer[length]=0;

    /* gDefaultConverterName MUST be the last global var set by this function.  */
    /*    It is the variable checked in ucnv_getDefaultName() to see if initialization is required. */
    //    But there is nothing here preventing that from being reordered, either by the compiler
    //             or hardware. I'm adding the mutex to ucnv_getDefaultName for now. UMTX_CHECK is not enough.
    //             -- Andy
    gDefaultConverterName = gDefaultConverterNameBuffer;

    ucnv_enableCleanup();

    umtx_unlock(&cnvCacheMutex);
}
#endif

/*
 * In order to be really thread-safe, the get function would have to take
 * a buffer parameter and copy the current string inside a mutex block.
 * This implementation only tries to be really thread-safe while
 * setting the name.
 * It assumes that setting a pointer is atomic.
 */

U_CAPI const char*  U_EXPORT2
ucnv_getDefaultName() {
#if U_CHARSET_IS_UTF8
    return "UTF-8";
#else
    /* local variable to be thread-safe */
    const char *name;

    /*
    Concurrent calls to ucnv_getDefaultName must be thread safe,
    but ucnv_setDefaultName is not thread safe.
    */
    {
        icu::Mutex lock(&cnvCacheMutex);
        name = gDefaultConverterName;
    }
    if(name==nullptr) {
        UErrorCode errorCode = U_ZERO_ERROR;
        UConverter *cnv = nullptr;

        name = uprv_getDefaultCodepage();

        /* if the name is there, test it out and get the canonical name with options */
        if(name != nullptr) {
            cnv = ucnv_open(name, &errorCode);
            if(U_SUCCESS(errorCode) && cnv != nullptr) {
                name = ucnv_getName(cnv, &errorCode);
            }
        }

        if(name == nullptr || name[0] == 0
            || U_FAILURE(errorCode) || cnv == nullptr
            || uprv_strlen(name)>=sizeof(gDefaultConverterNameBuffer))
        {
            /* Panic time, let's use a fallback. */
#if (U_CHARSET_FAMILY == U_ASCII_FAMILY)
            name = "US-ASCII";
            /* there is no 'algorithmic' converter for EBCDIC */
#elif U_PLATFORM == U_PF_OS390
            name = "ibm-1047_P100-1995" UCNV_SWAP_LFNL_OPTION_STRING;
#else
            name = "ibm-37_P100-1995";
#endif
        }

        internalSetName(name, &errorCode);

        /* The close may make the current name go away. */
        ucnv_close(cnv);
    }

    return name;
#endif
}

#if U_CHARSET_IS_UTF8
U_CAPI void U_EXPORT2 ucnv_setDefaultName(const char *) {}
#else
/*
This function is not thread safe, and it can't be thread safe.
See internalSetName or the API reference for details.
*/
U_CAPI void U_EXPORT2
ucnv_setDefaultName(const char *converterName) {
    if(converterName==nullptr) {
        /* reset to the default codepage */
        gDefaultConverterName=nullptr;
    } else {
        UErrorCode errorCode = U_ZERO_ERROR;
        UConverter *cnv = nullptr;
        const char *name = nullptr;

        /* if the name is there, test it out and get the canonical name with options */
        cnv = ucnv_open(converterName, &errorCode);
        if(U_SUCCESS(errorCode) && cnv != nullptr) {
            name = ucnv_getName(cnv, &errorCode);
        }

        if(U_SUCCESS(errorCode) && name!=nullptr) {
            internalSetName(name, &errorCode);
        }
        /* else this converter is bad to use. Don't change it to a bad value. */

        /* The close may make the current name go away. */
        ucnv_close(cnv);

        /* reset the converter cache */
        u_flushDefaultConverter();
    }
}
#endif

/* data swapping ------------------------------------------------------------ */

/* most of this might belong more properly into ucnvmbcs.c, but that is so large */

#if !UCONFIG_NO_LEGACY_CONVERSION

U_CAPI int32_t U_EXPORT2
ucnv_swap(const UDataSwapper *ds,
          const void *inData, int32_t length, void *outData,
          UErrorCode *pErrorCode) {
    const UDataInfo *pInfo;
    int32_t headerSize;

    const uint8_t *inBytes;
    uint8_t *outBytes;

    uint32_t offset, count, staticDataSize;
    int32_t size;

    const UConverterStaticData *inStaticData;
    UConverterStaticData *outStaticData;

    const _MBCSHeader *inMBCSHeader;
    _MBCSHeader *outMBCSHeader;
    _MBCSHeader mbcsHeader;
    uint32_t mbcsHeaderLength;
    UBool noFromU=false;

    uint8_t outputType;

    int32_t maxFastUChar, mbcsIndexLength;

    const int32_t *inExtIndexes;
    int32_t extOffset;

    /* udata_swapDataHeader checks the arguments */
    headerSize=udata_swapDataHeader(ds, inData, length, outData, pErrorCode);
    if(pErrorCode==nullptr || U_FAILURE(*pErrorCode)) {
        return 0;
    }

    /* check data format and format version */
    pInfo=(const UDataInfo *)((const char *)inData+4);
    if(!(
        pInfo->dataFormat[0]==0x63 &&   /* dataFormat="cnvt" */
        pInfo->dataFormat[1]==0x6e &&
        pInfo->dataFormat[2]==0x76 &&
        pInfo->dataFormat[3]==0x74 &&
        pInfo->formatVersion[0]==6 &&
        pInfo->formatVersion[1]>=2
    )) {
        udata_printError(ds, "ucnv_swap(): data format %02x.%02x.%02x.%02x (format version %02x.%02x) is not recognized as an ICU .cnv conversion table\n",
                         pInfo->dataFormat[0], pInfo->dataFormat[1],
                         pInfo->dataFormat[2], pInfo->dataFormat[3],
                         pInfo->formatVersion[0], pInfo->formatVersion[1]);
        *pErrorCode=U_UNSUPPORTED_ERROR;
        return 0;
    }

    inBytes=(const uint8_t *)inData+headerSize;
    outBytes=(outData == nullptr) ? nullptr : (uint8_t *)outData+headerSize;

    /* read the initial UConverterStaticData structure after the UDataInfo header */
    inStaticData=(const UConverterStaticData *)inBytes;
    outStaticData=(UConverterStaticData *)outBytes;

    if(length<0) {
        staticDataSize=ds->readUInt32(inStaticData->structSize);
    } else {
        length-=headerSize;
        if( length<(int32_t)sizeof(UConverterStaticData) ||
            (uint32_t)length<(staticDataSize=ds->readUInt32(inStaticData->structSize))
        ) {
            udata_printError(ds, "ucnv_swap(): too few bytes (%d after header) for an ICU .cnv conversion table\n",
                             length);
            *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
            return 0;
        }
    }

    if(length>=0) {
        /* swap the static data */
        if(inStaticData!=outStaticData) {
            uprv_memcpy(outStaticData, inStaticData, staticDataSize);
        }

        ds->swapArray32(ds, &inStaticData->structSize, 4,
                           &outStaticData->structSize, pErrorCode);
        ds->swapArray32(ds, &inStaticData->codepage, 4,
                           &outStaticData->codepage, pErrorCode);

        ds->swapInvChars(ds, inStaticData->name, (int32_t)uprv_strlen(inStaticData->name),
                            outStaticData->name, pErrorCode);
        if(U_FAILURE(*pErrorCode)) {
            udata_printError(ds, "ucnv_swap(): error swapping converter name\n");
            return 0;
        }
    }

    inBytes+=staticDataSize;
    if (outBytes != nullptr) outBytes+=staticDataSize;
    if(length>=0) {
        length-=(int32_t)staticDataSize;
    }

    /* check for supported conversionType values */
    if(inStaticData->conversionType==UCNV_MBCS) {
        /* swap MBCS data */
        inMBCSHeader=(const _MBCSHeader *)inBytes;
        outMBCSHeader=(_MBCSHeader *)outBytes;

        if(0<=length && length<(int32_t)sizeof(_MBCSHeader)) {
            udata_printError(ds, "ucnv_swap(): too few bytes (%d after headers) for an ICU MBCS .cnv conversion table\n",
                                length);
            *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
            return 0;
        }
        if(inMBCSHeader->version[0]==4 && inMBCSHeader->version[1]>=1) {
            mbcsHeaderLength=MBCS_HEADER_V4_LENGTH;
        } else if(inMBCSHeader->version[0]==5 && inMBCSHeader->version[1]>=3 &&
                  ((mbcsHeader.options=ds->readUInt32(inMBCSHeader->options))&
                   MBCS_OPT_UNKNOWN_INCOMPATIBLE_MASK)==0
        ) {
            mbcsHeaderLength=mbcsHeader.options&MBCS_OPT_LENGTH_MASK;
            noFromU = (mbcsHeader.options & MBCS_OPT_NO_FROM_U) != 0;
        } else {
            udata_printError(ds, "ucnv_swap(): unsupported _MBCSHeader.version %d.%d\n",
                             inMBCSHeader->version[0], inMBCSHeader->version[1]);
            *pErrorCode=U_UNSUPPORTED_ERROR;
            return 0;
        }

        uprv_memcpy(mbcsHeader.version, inMBCSHeader->version, 4);
        mbcsHeader.countStates=         ds->readUInt32(inMBCSHeader->countStates);
        mbcsHeader.countToUFallbacks=   ds->readUInt32(inMBCSHeader->countToUFallbacks);
        mbcsHeader.offsetToUCodeUnits=  ds->readUInt32(inMBCSHeader->offsetToUCodeUnits);
        mbcsHeader.offsetFromUTable=    ds->readUInt32(inMBCSHeader->offsetFromUTable);
        mbcsHeader.offsetFromUBytes=    ds->readUInt32(inMBCSHeader->offsetFromUBytes);
        mbcsHeader.flags=               ds->readUInt32(inMBCSHeader->flags);
        mbcsHeader.fromUBytesLength=    ds->readUInt32(inMBCSHeader->fromUBytesLength);
        /* mbcsHeader.options have been read above */

        extOffset=(int32_t)(mbcsHeader.flags>>8);
        outputType=(uint8_t)mbcsHeader.flags;
        if(noFromU && outputType==MBCS_OUTPUT_1) {
            udata_printError(ds, "ucnv_swap(): unsupported combination of makeconv --small with SBCS\n");
            *pErrorCode=U_UNSUPPORTED_ERROR;
            return 0;
        }

        /* make sure that the output type is known */
        switch(outputType) {
        case MBCS_OUTPUT_1:
        case MBCS_OUTPUT_2:
        case MBCS_OUTPUT_3:
        case MBCS_OUTPUT_4:
        case MBCS_OUTPUT_3_EUC:
        case MBCS_OUTPUT_4_EUC:
        case MBCS_OUTPUT_2_SISO:
        case MBCS_OUTPUT_EXT_ONLY:
            /* OK */
            break;
        default:
            udata_printError(ds, "ucnv_swap(): unsupported MBCS output type 0x%x\n",
                             outputType);
            *pErrorCode=U_UNSUPPORTED_ERROR;
            return 0;
        }

        /* calculate the length of the MBCS data */

        /*
         * utf8Friendly MBCS files (mbcsHeader.version 4.3)
         * contain an additional mbcsIndex table:
         *   uint16_t[(maxFastUChar+1)>>6];
         * where maxFastUChar=((mbcsHeader.version[2]<<8)|0xff).
         */
        maxFastUChar=0;
        mbcsIndexLength=0;
        if( outputType!=MBCS_OUTPUT_EXT_ONLY && outputType!=MBCS_OUTPUT_1 &&
            mbcsHeader.version[1]>=3 && (maxFastUChar=mbcsHeader.version[2])!=0
        ) {
            maxFastUChar=(maxFastUChar<<8)|0xff;
            mbcsIndexLength=((maxFastUChar+1)>>6)*2;  /* number of bytes */
        }

        if(extOffset==0) {
            size=(int32_t)(mbcsHeader.offsetFromUBytes+mbcsIndexLength);
            if(!noFromU) {
                size+=(int32_t)mbcsHeader.fromUBytesLength;
            }

            /* avoid compiler warnings - not otherwise necessary, and the value does not matter */
            inExtIndexes=nullptr;
        } else {
            /* there is extension data after the base data, see ucnv_ext.h */
            if(length>=0 && length<(extOffset+UCNV_EXT_INDEXES_MIN_LENGTH*4)) {
                udata_printError(ds, "ucnv_swap(): too few bytes (%d after headers) for an ICU MBCS .cnv conversion table with extension data\n",
                                 length);
                *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
                return 0;
            }

            inExtIndexes=(const int32_t *)(inBytes+extOffset);
            size=extOffset+udata_readInt32(ds, inExtIndexes[UCNV_EXT_SIZE]);
        }

        if(length>=0) {
            if(length<size) {
                udata_printError(ds, "ucnv_swap(): too few bytes (%d after headers) for an ICU MBCS .cnv conversion table\n",
                                 length);
                *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
                return 0;
            }

            /* copy the data for inaccessible bytes */
            if(inBytes!=outBytes) {
                uprv_memcpy(outBytes, inBytes, size);
            }

            /* swap the MBCSHeader, except for the version field */
            count=mbcsHeaderLength*4;
            ds->swapArray32(ds, &inMBCSHeader->countStates, count-4,
                               &outMBCSHeader->countStates, pErrorCode);

            if(outputType==MBCS_OUTPUT_EXT_ONLY) {
                /*
                 * extension-only file,
                 * contains a base name instead of normal base table data
                 */

                /* swap the base name, between the header and the extension data */
                const char *inBaseName=(const char *)inBytes+count;
                char *outBaseName=(char *)outBytes+count;
                ds->swapInvChars(ds, inBaseName, (int32_t)uprv_strlen(inBaseName),
                                    outBaseName, pErrorCode);
            } else {
                /* normal file with base table data */

                /* swap the state table, 1kB per state */
                offset=count;
                count=mbcsHeader.countStates*1024;
                ds->swapArray32(ds, inBytes+offset, (int32_t)count,
                                   outBytes+offset, pErrorCode);

                /* swap the toUFallbacks[] */
                offset+=count;
                count=mbcsHeader.countToUFallbacks*8;
                ds->swapArray32(ds, inBytes+offset, (int32_t)count,
                                   outBytes+offset, pErrorCode);

                /* swap the unicodeCodeUnits[] */
                offset=mbcsHeader.offsetToUCodeUnits;
                count=mbcsHeader.offsetFromUTable-offset;
                ds->swapArray16(ds, inBytes+offset, (int32_t)count,
                                   outBytes+offset, pErrorCode);

                /* offset to the stage 1 table, independent of the outputType */
                offset=mbcsHeader.offsetFromUTable;

                if(outputType==MBCS_OUTPUT_1) {
                    /* SBCS: swap the fromU tables, all 16 bits wide */
                    count=(mbcsHeader.offsetFromUBytes-offset)+mbcsHeader.fromUBytesLength;
                    ds->swapArray16(ds, inBytes+offset, (int32_t)count,
                                       outBytes+offset, pErrorCode);
                } else {
                    /* otherwise: swap the stage tables separately */

                    /* stage 1 table: uint16_t[0x440 or 0x40] */
                    if(inStaticData->unicodeMask&UCNV_HAS_SUPPLEMENTARY) {
                        count=0x440*2; /* for all of Unicode */
                    } else {
                        count=0x40*2; /* only BMP */
                    }
                    ds->swapArray16(ds, inBytes+offset, (int32_t)count,
                                       outBytes+offset, pErrorCode);

                    /* stage 2 table: uint32_t[] */
                    offset+=count;
                    count=mbcsHeader.offsetFromUBytes-offset;
                    ds->swapArray32(ds, inBytes+offset, (int32_t)count,
                                       outBytes+offset, pErrorCode);

                    /* stage 3/result bytes: sometimes uint16_t[] or uint32_t[] */
                    offset=mbcsHeader.offsetFromUBytes;
                    count= noFromU ? 0 : mbcsHeader.fromUBytesLength;
                    switch(outputType) {
                    case MBCS_OUTPUT_2:
                    case MBCS_OUTPUT_3_EUC:
                    case MBCS_OUTPUT_2_SISO:
                        ds->swapArray16(ds, inBytes+offset, (int32_t)count,
                                           outBytes+offset, pErrorCode);
                        break;
                    case MBCS_OUTPUT_4:
                        ds->swapArray32(ds, inBytes+offset, (int32_t)count,
                                           outBytes+offset, pErrorCode);
                        break;
                    default:
                        /* just uint8_t[], nothing to swap */
                        break;
                    }

                    if(mbcsIndexLength!=0) {
                        offset+=count;
                        count=mbcsIndexLength;
                        ds->swapArray16(ds, inBytes+offset, (int32_t)count,
                                           outBytes+offset, pErrorCode);
                    }
                }
            }

            if(extOffset!=0) {
                /* swap the extension data */
                inBytes+=extOffset;
                outBytes+=extOffset;

                /* swap toUTable[] */
                offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_TO_U_INDEX]);
                length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_TO_U_LENGTH]);
                ds->swapArray32(ds, inBytes+offset, length*4, outBytes+offset, pErrorCode);

                /* swap toUUChars[] */
                offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_TO_U_UCHARS_INDEX]);
                length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_TO_U_UCHARS_LENGTH]);
                ds->swapArray16(ds, inBytes+offset, length*2, outBytes+offset, pErrorCode);

                /* swap fromUTableUChars[] */
                offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_UCHARS_INDEX]);
                length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_LENGTH]);
                ds->swapArray16(ds, inBytes+offset, length*2, outBytes+offset, pErrorCode);

                /* swap fromUTableValues[] */
                offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_VALUES_INDEX]);
                /* same length as for fromUTableUChars[] */
                ds->swapArray32(ds, inBytes+offset, length*4, outBytes+offset, pErrorCode);

                /* no need to swap fromUBytes[] */

                /* swap fromUStage12[] */
                offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_STAGE_12_INDEX]);
                length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_STAGE_12_LENGTH]);
                ds->swapArray16(ds, inBytes+offset, length*2, outBytes+offset, pErrorCode);

                /* swap fromUStage3[] */
                offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_STAGE_3_INDEX]);
                length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_STAGE_3_LENGTH]);
                ds->swapArray16(ds, inBytes+offset, length*2, outBytes+offset, pErrorCode);

                /* swap fromUStage3b[] */
                offset=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_STAGE_3B_INDEX]);
                length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_FROM_U_STAGE_3B_LENGTH]);
                ds->swapArray32(ds, inBytes+offset, length*4, outBytes+offset, pErrorCode);

                /* swap indexes[] */
                length=udata_readInt32(ds, inExtIndexes[UCNV_EXT_INDEXES_LENGTH]);
                ds->swapArray32(ds, inBytes, length*4, outBytes, pErrorCode);
            }
        }
    } else {
        udata_printError(ds, "ucnv_swap(): unknown conversionType=%d!=UCNV_MBCS\n",
                         inStaticData->conversionType);
        *pErrorCode=U_UNSUPPORTED_ERROR;
        return 0;
    }

    return headerSize+(int32_t)staticDataSize+size;
}

#endif /* #if !UCONFIG_NO_LEGACY_CONVERSION */

#endif
                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/icu-small/source/common/ucnv_bld.h                                                 0000664 0000000 0000000 00000026276 14746647661 0022150 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
**********************************************************************
*   Copyright (C) 1999-2015 International Business Machines
*   Corporation and others.  All Rights Reserved.
**********************************************************************
*
*
*  ucnv_bld.h:
*  Contains internal data structure definitions
* Created by Bertrand A. Damiba
*
*   Change history:
*
*   06/29/2000  helena      Major rewrite of the callback APIs.
*/

#ifndef UCNV_BLD_H
#define UCNV_BLD_H

#include "unicode/utypes.h"

#if !UCONFIG_NO_CONVERSION

#include "unicode/ucnv.h"
#include "unicode/ucnv_err.h"
#include "unicode/utf16.h"
#include "ucnv_cnv.h"
#include "ucnvmbcs.h"
#include "ucnv_ext.h"
#include "udataswp.h"

/* size of the overflow buffers in UConverter, enough for escaping callbacks */
#define UCNV_ERROR_BUFFER_LENGTH 32

/* at most 4 bytes per substitution character (part of .cnv file format! see UConverterStaticData) */
#define UCNV_MAX_SUBCHAR_LEN 4

/* at most 8 bytes per character in toUBytes[] (UTF-8 uses up to 6) */
#define UCNV_MAX_CHAR_LEN 8

/* converter options bits */
#define UCNV_OPTION_VERSION     0xf
#define UCNV_OPTION_SWAP_LFNL   0x10

#define UCNV_GET_VERSION(cnv) ((cnv)->options&UCNV_OPTION_VERSION)

U_CDECL_BEGIN /* We must declare the following as 'extern "C"' so that if ucnv
                 itself is compiled under C++, the linkage of the funcptrs will
                 work.
              */

union UConverterTable {
    UConverterMBCSTable mbcs;
};

typedef union UConverterTable UConverterTable;

struct UConverterImpl;
typedef struct UConverterImpl UConverterImpl;

/** values for the unicodeMask */
#define UCNV_HAS_SUPPLEMENTARY 1
#define UCNV_HAS_SURROGATES    2

typedef struct UConverterStaticData {   /* +offset: size */
    uint32_t structSize;                /* +0: 4 Size of this structure */

    char name
      [UCNV_MAX_CONVERTER_NAME_LENGTH]; /* +4: 60  internal name of the converter- invariant chars */

    int32_t codepage;               /* +64: 4 codepage # (now IBM-$codepage) */

    int8_t platform;                /* +68: 1 platform of the converter (only IBM now) */
    int8_t conversionType;          /* +69: 1 conversion type */

    int8_t minBytesPerChar;         /* +70: 1 Minimum # bytes per char in this codepage */
    int8_t maxBytesPerChar;         /* +71: 1 Maximum # bytes output per UChar in this codepage */

    uint8_t subChar[UCNV_MAX_SUBCHAR_LEN]; /* +72: 4  [note:  4 and 8 byte boundary] */
    int8_t subCharLen;              /* +76: 1 */

    uint8_t hasToUnicodeFallback;   /* +77: 1 UBool needs to be changed to UBool to be consistent across platform */
    uint8_t hasFromUnicodeFallback; /* +78: 1 */
    uint8_t unicodeMask;            /* +79: 1  bit 0: has supplementary  bit 1: has single surrogates */
    uint8_t subChar1;               /* +80: 1  single-byte substitution character for IBM MBCS (0 if none) */
    uint8_t reserved[19];           /* +81: 19 to round out the structure */
                                    /* total size: 100 */
} UConverterStaticData;

/*
 * Defines the UConverterSharedData struct,
 * the immutable, shared part of UConverter.
 */
struct UConverterSharedData {
    uint32_t structSize;            /* Size of this structure */
    uint32_t referenceCounter;      /* used to count number of clients, unused for static/immutable SharedData */

    const void *dataMemory;         /* from udata_openChoice() - for cleanup */

    const UConverterStaticData *staticData; /* pointer to the static (non changing) data. */

    UBool                sharedDataCached;   /* true:  shared data is in cache, don't destroy on ucnv_close() if 0 ref.  false: shared data isn't in the cache, do attempt to clean it up if the ref is 0 */
    /** If false, then referenceCounter is not used. Must not change after initialization. */
    UBool isReferenceCounted;

    const UConverterImpl *impl;     /* vtable-style struct of mostly function pointers */

    /*initial values of some members of the mutable part of object */
    uint32_t toUnicodeStatus;

    /*
     * Shared data structures currently come in two flavors:
     * - readonly for built-in algorithmic converters
     * - allocated for MBCS, with a pointer to an allocated UConverterTable
     *   which always has a UConverterMBCSTable
     *
     * To eliminate one allocation, I am making the UConverterMBCSTable
     * a member of the shared data.
     *
     * markus 2003-nov-07
     */
    UConverterMBCSTable mbcs;
};

/** UConverterSharedData initializer for static, non-reference-counted converters. */
#define UCNV_IMMUTABLE_SHARED_DATA_INITIALIZER(pStaticData, pImpl) \
    { \
        sizeof(UConverterSharedData), ~((uint32_t)0), \
        NULL, pStaticData, false, false, pImpl, \
        0, UCNV_MBCS_TABLE_INITIALIZER \
    }

/* Defines a UConverter, the lightweight mutable part the user sees */

struct UConverter {
    /*
     * Error function pointer called when conversion issues
     * occur during a ucnv_fromUnicode call
     */
    void (U_EXPORT2 *fromUCharErrorBehaviour) (const void *context,
                                     UConverterFromUnicodeArgs *args,
                                     const UChar *codeUnits,
                                     int32_t length,
                                     UChar32 codePoint,
                                     UConverterCallbackReason reason,
                                     UErrorCode *);
    /*
     * Error function pointer called when conversion issues
     * occur during a ucnv_toUnicode call
     */
    void (U_EXPORT2 *fromCharErrorBehaviour) (const void *context,
                                    UConverterToUnicodeArgs *args,
                                    const char *codeUnits,
                                    int32_t length,
                                    UConverterCallbackReason reason,
                                    UErrorCode *);

    /*
     * Pointer to additional data that depends on the converter type.
     * Used by ISO 2022, SCSU, GB 18030 converters, possibly more.
     */
    void *extraInfo;

    const void *fromUContext;
    const void *toUContext;

    /*
     * Pointer to charset bytes for substitution string if subCharLen>0,
     * or pointer to Unicode string (UChar *) if subCharLen<0.
     * subCharLen==0 is equivalent to using a skip callback.
     * If the pointer is !=subUChars then it is allocated with
     * UCNV_ERROR_BUFFER_LENGTH * U_SIZEOF_UCHAR bytes.
     * The subUChars field is declared as UChar[] not uint8_t[] to
     * guarantee alignment for UChars.
     */
    uint8_t *subChars;

    UConverterSharedData *sharedData;   /* Pointer to the shared immutable part of the converter object */

    uint32_t options; /* options flags from UConverterOpen, may contain additional bits */

    UBool sharedDataIsCached;  /* true:  shared data is in cache, don't destroy on ucnv_close() if 0 ref.  false: shared data isn't in the cache, do attempt to clean it up if the ref is 0 */
    UBool isCopyLocal;  /* true if UConverter is not owned and not released in ucnv_close() (stack-allocated, safeClone(), etc.) */
    UBool isExtraLocal; /* true if extraInfo is not owned and not released in ucnv_close() (stack-allocated, safeClone(), etc.) */

    UBool  useFallback;
    int8_t toULength;                   /* number of bytes in toUBytes */
    uint8_t toUBytes[UCNV_MAX_CHAR_LEN-1];/* more "toU status"; keeps the bytes of the current character */
    uint32_t toUnicodeStatus;           /* Used to internalize stream status information */
    int32_t mode;
    uint32_t fromUnicodeStatus;

    /*
     * More fromUnicode() status. Serves 3 purposes:
     * - keeps a lead surrogate between buffers (similar to toUBytes[])
     * - keeps a lead surrogate at the end of the stream,
     *   which the framework handles as truncated input
     * - if the fromUnicode() implementation returns to the framework
     *   (ucnv.c ucnv_fromUnicode()), then the framework calls the callback
     *   for this code point
     */
    UChar32 fromUChar32;

    /*
     * value for ucnv_getMaxCharSize()
     *
     * usually simply copied from the static data, but ucnvmbcs.c modifies
     * the value depending on the converter type and options
     */
    int8_t maxBytesPerUChar;

    int8_t subCharLen;                  /* length of the codepage specific character sequence */
    int8_t invalidCharLength;
    int8_t charErrorBufferLength;       /* number of valid bytes in charErrorBuffer */

    int8_t invalidUCharLength;
    int8_t UCharErrorBufferLength;      /* number of valid UChars in charErrorBuffer */

    uint8_t subChar1;                                   /* single-byte substitution character if different from subChar */
    UBool useSubChar1;
    char invalidCharBuffer[UCNV_MAX_CHAR_LEN];          /* bytes from last error/callback situation */
    uint8_t charErrorBuffer[UCNV_ERROR_BUFFER_LENGTH];  /* codepage output from Error functions */
    UChar subUChars[UCNV_MAX_SUBCHAR_LEN/U_SIZEOF_UCHAR]; /* see subChars documentation */

    UChar invalidUCharBuffer[U16_MAX_LENGTH];           /* UChars from last error/callback situation */
    UChar UCharErrorBuffer[UCNV_ERROR_BUFFER_LENGTH];   /* unicode output from Error functions */

    /* fields for conversion extension */

    /* store previous UChars/chars to continue partial matches */
    UChar32 preFromUFirstCP;                /* >=0: partial match */
    UChar preFromU[UCNV_EXT_MAX_UCHARS];
    char preToU[UCNV_EXT_MAX_BYTES];
    int8_t preFromULength, preToULength;    /* negative: replay */
    int8_t preToUFirstLength;               /* length of first character */

    /* new fields for ICU 4.0 */
    UConverterCallbackReason toUCallbackReason; /* (*fromCharErrorBehaviour) reason, set when error is detected */
};

U_CDECL_END /* end of UConverter */

#define CONVERTER_FILE_EXTENSION ".cnv"


/**
 * Return the number of all converter names.
 * @param pErrorCode The error code
 * @return the number of all converter names
 */
U_CFUNC uint16_t
ucnv_bld_countAvailableConverters(UErrorCode *pErrorCode);

/**
 * Return the (n)th converter name in mixed case, or NULL
 * if there is none (typically, if the data cannot be loaded).
 * 0<=index<ucnv_io_countAvailableConverters().
 * @param n The number specifies which converter name to get
 * @param pErrorCode The error code
 * @return the (n)th converter name in mixed case, or NULL if there is none.
 */
U_CFUNC const char *
ucnv_bld_getAvailableConverter(uint16_t n, UErrorCode *pErrorCode);

/**
 * Load a non-algorithmic converter.
 * If pkg==NULL, then this function must be called inside umtx_lock(&cnvCacheMutex).
 */
U_CAPI UConverterSharedData *
ucnv_load(UConverterLoadArgs *pArgs, UErrorCode *err);

/**
 * Unload a non-algorithmic converter.
 * It must be sharedData->isReferenceCounted
 * and this function must be called inside umtx_lock(&cnvCacheMutex).
 */
U_CAPI void
ucnv_unload(UConverterSharedData *sharedData);

/**
 * Swap ICU .cnv conversion tables. See udataswp.h.
 * @internal
 */
U_CAPI int32_t U_EXPORT2
ucnv_swap(const UDataSwapper *ds,
          const void *inData, int32_t length, void *outData,
          UErrorCode *pErrorCode);

U_CAPI void U_EXPORT2
ucnv_enableCleanup(void);

#endif

#endif /* _UCNV_BLD */
                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/icu-small/source/common/ucnv_cb.cpp                                                0000664 0000000 0000000 00000020037 14746647661 0022313 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
**********************************************************************
*   Copyright (C) 2000-2006, International Business Machines
*   Corporation and others.  All Rights Reserved.
**********************************************************************
 *  ucnv_cb.c:
 *  External APIs for the ICU's codeset conversion library
 *  Helena Shih
 *
 * Modification History:
 *
 *   Date        Name        Description
 *   7/28/2000   srl         Implementation
 */

/**
 * @name Character Conversion C API
 *
 */

#include "unicode/utypes.h"

#if !UCONFIG_NO_CONVERSION

#include "unicode/ucnv_cb.h"
#include "ucnv_bld.h"
#include "ucnv_cnv.h"
#include "cmemory.h"

/* need to update the offsets when the target moves. */
/* Note: Recursion may occur in the cb functions, be sure to update the offsets correctly
if you don't use ucnv_cbXXX functions.  Make sure you don't use the same callback within
the same call stack if the complexity arises. */
U_CAPI void  U_EXPORT2
ucnv_cbFromUWriteBytes (UConverterFromUnicodeArgs *args,
                       const char* source,
                       int32_t length,
                       int32_t offsetIndex,
                       UErrorCode * err)
{
    if(U_FAILURE(*err)) {
        return;
    }

    ucnv_fromUWriteBytes(
        args->converter,
        source, length,
        &args->target, args->targetLimit,
        &args->offsets, offsetIndex,
        err);
}

U_CAPI void  U_EXPORT2
ucnv_cbFromUWriteUChars(UConverterFromUnicodeArgs *args,
                             const char16_t** source,
                             const char16_t*  sourceLimit,
                             int32_t offsetIndex,
                             UErrorCode * err)
{
    /*
    This is a fun one.  Recursion can occur - we're basically going to
    just retry shoving data through the same converter. Note, if you got
    here through some kind of invalid sequence, you maybe should emit a
    reset sequence of some kind and/or call ucnv_reset().  Since this
    IS an actual conversion, take care that you've changed the callback
    or the data, or you'll get an infinite loop.

    Please set the err value to something reasonable before calling
    into this.
    */

    char *oldTarget;

    if(U_FAILURE(*err))
    {
        return;
    }

    oldTarget = args->target;

    ucnv_fromUnicode(args->converter,
        &args->target,
        args->targetLimit,
        source,
        sourceLimit,
        nullptr, /* no offsets */
        false, /* no flush */
        err);

    if(args->offsets)
    {
        while (args->target != oldTarget)  /* if it moved at all.. */
        {
            *(args->offsets)++ = offsetIndex;
            oldTarget++;
        }
    }

    /*
    Note, if you did something like used a Stop subcallback, things would get interesting.
    In fact, here's where we want to return the partially consumed in-source!
    */
    if(*err == U_BUFFER_OVERFLOW_ERROR)
    /* && (*source < sourceLimit && args->target >= args->targetLimit)
    -- S. Hrcek */
    {
        /* Overflowed the target.  Now, we'll write into the charErrorBuffer.
        It's a fixed size. If we overflow it... Hmm */
        char *newTarget;
        const char *newTargetLimit;
        UErrorCode err2 = U_ZERO_ERROR;

        int8_t errBuffLen;

        errBuffLen  = args->converter->charErrorBufferLength;

        /* start the new target at the first free slot in the errbuff.. */
        newTarget = (char *)(args->converter->charErrorBuffer + errBuffLen);

        newTargetLimit = (char *)(args->converter->charErrorBuffer +
            sizeof(args->converter->charErrorBuffer));

        if(newTarget >= newTargetLimit)
        {
            *err = U_INTERNAL_PROGRAM_ERROR;
            return;
        }

        /* We're going to tell the converter that the errbuff len is empty.
        This prevents the existing errbuff from being 'flushed' out onto
        itself.  If the errbuff is needed by the converter this time,
        we're hosed - we're out of space! */

        args->converter->charErrorBufferLength = 0;

        ucnv_fromUnicode(args->converter,
                         &newTarget,
                         newTargetLimit,
                         source,
                         sourceLimit,
                         nullptr,
                         false,
                         &err2);

        /* We can go ahead and overwrite the  length here. We know just how
        to recalculate it. */

        args->converter->charErrorBufferLength = (int8_t)(
            newTarget - (char*)args->converter->charErrorBuffer);

        if((newTarget >= newTargetLimit) || (err2 == U_BUFFER_OVERFLOW_ERROR))
        {
            /* now we're REALLY in trouble.
            Internal program error - callback shouldn't have written this much
            data!
            */
            *err = U_INTERNAL_PROGRAM_ERROR;
            return;
        }
        /*else {*/
            /* sub errs could be invalid/truncated/illegal chars or w/e.
            These might want to be passed on up.. But the problem is, we already
            need to pass U_BUFFER_OVERFLOW_ERROR. That has to override these
            other errs.. */

            /*
            if(U_FAILURE(err2))
            ??
            */
        /*}*/
    }
}

U_CAPI void  U_EXPORT2
ucnv_cbFromUWriteSub (UConverterFromUnicodeArgs *args,
                           int32_t offsetIndex,
                           UErrorCode * err)
{
    UConverter *converter;
    int32_t length;

    if(U_FAILURE(*err)) {
        return;
    }
    converter = args->converter;
    length = converter->subCharLen;

    if(length == 0) {
        return;
    }

    if(length < 0) {
        /*
         * Write/convert the substitution string. Its real length is -length.
         * Unlike the escape callback, we need not change the converter's
         * callback function because ucnv_setSubstString() verified that
         * the string can be converted, so we will not get a conversion error
         * and will not recurse.
         * At worst we should get a U_BUFFER_OVERFLOW_ERROR.
         */
        const char16_t *source = (const char16_t *)converter->subChars;
        ucnv_cbFromUWriteUChars(args, &source, source - length, offsetIndex, err);
        return;
    }

    if(converter->sharedData->impl->writeSub!=nullptr) {
        converter->sharedData->impl->writeSub(args, offsetIndex, err);
    }
    else if(converter->subChar1!=0 && (uint16_t)converter->invalidUCharBuffer[0]<=(uint16_t)0xffu) {
        /*
        TODO: Is this untestable because the MBCS converter has a writeSub function to call
        and the other converters don't use subChar1?
        */
        ucnv_cbFromUWriteBytes(args,
                               (const char *)&converter->subChar1, 1,
                               offsetIndex, err);
    }
    else {
        ucnv_cbFromUWriteBytes(args,
                               (const char *)converter->subChars, length,
                               offsetIndex, err);
    }
}

U_CAPI void  U_EXPORT2
ucnv_cbToUWriteUChars (UConverterToUnicodeArgs *args,
                            const char16_t* source,
                            int32_t length,
                            int32_t offsetIndex,
                            UErrorCode * err)
{
    if(U_FAILURE(*err)) {
        return;
    }

    ucnv_toUWriteUChars(
        args->converter,
        source, length,
        &args->target, args->targetLimit,
        &args->offsets, offsetIndex,
        err);
}

U_CAPI void  U_EXPORT2
ucnv_cbToUWriteSub (UConverterToUnicodeArgs *args,
                         int32_t offsetIndex,
                       UErrorCode * err)
{
    static const char16_t kSubstituteChar1 = 0x1A, kSubstituteChar = 0xFFFD;

    /* could optimize this case, just one uchar */
    if(args->converter->invalidCharLength == 1 && args->converter->subChar1 != 0) {
        ucnv_cbToUWriteUChars(args, &kSubstituteChar1, 1, offsetIndex, err);
    } else {
        ucnv_cbToUWriteUChars(args, &kSubstituteChar, 1, offsetIndex, err);
    }
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/icu-small/source/common/ucnv_cnv.cpp                                               0000664 0000000 0000000 00000011276 14746647661 0022522 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 1999-2004, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*
*   uconv_cnv.c:
*   Implements all the low level conversion functions
*   T_UnicodeConverter_{to,from}Unicode_$ConversionType
*
*   Change history:
*
*   06/29/2000  helena      Major rewrite of the callback APIs.
*/

#include "unicode/utypes.h"

#if !UCONFIG_NO_CONVERSION

#include "unicode/ucnv_err.h"
#include "unicode/ucnv.h"
#include "unicode/uset.h"
#include "ucnv_cnv.h"
#include "ucnv_bld.h"
#include "cmemory.h"

U_CFUNC void
ucnv_getCompleteUnicodeSet(const UConverter *cnv,
                   const USetAdder *sa,
                   UConverterUnicodeSet which,
                   UErrorCode *pErrorCode) {
    (void)cnv;
    (void)which;
    (void)pErrorCode;
    sa->addRange(sa->set, 0, 0x10ffff);
}

U_CFUNC void
ucnv_getNonSurrogateUnicodeSet(const UConverter *cnv,
                               const USetAdder *sa,
                               UConverterUnicodeSet which,
                               UErrorCode *pErrorCode) {
    (void)cnv;
    (void)which;
    (void)pErrorCode;
    sa->addRange(sa->set, 0, 0xd7ff);
    sa->addRange(sa->set, 0xe000, 0x10ffff);
}

U_CFUNC void
ucnv_fromUWriteBytes(UConverter *cnv,
                     const char *bytes, int32_t length,
                     char **target, const char *targetLimit,
                     int32_t **offsets,
                     int32_t sourceIndex,
                     UErrorCode *pErrorCode) {
    char *t=*target;
    int32_t *o;

    /* write bytes */
    if(offsets==nullptr || (o=*offsets)==nullptr) {
        while(length>0 && t<targetLimit) {
            *t++=*bytes++;
            --length;
        }
    } else {
        /* output with offsets */
        while(length>0 && t<targetLimit) {
            *t++=*bytes++;
            *o++=sourceIndex;
            --length;
        }
        *offsets=o;
    }
    *target=t;

    /* write overflow */
    if(length>0) {
        if(cnv!=nullptr) {
            t=(char *)cnv->charErrorBuffer;
            cnv->charErrorBufferLength=(int8_t)length;
            do {
                *t++=(uint8_t)*bytes++;
            } while(--length>0);
        }
        *pErrorCode=U_BUFFER_OVERFLOW_ERROR;
    }
}

U_CFUNC void
ucnv_toUWriteUChars(UConverter *cnv,
                    const char16_t *uchars, int32_t length,
                    char16_t **target, const char16_t *targetLimit,
                    int32_t **offsets,
                    int32_t sourceIndex,
                    UErrorCode *pErrorCode) {
    char16_t *t=*target;
    int32_t *o;

    /* write UChars */
    if(offsets==nullptr || (o=*offsets)==nullptr) {
        while(length>0 && t<targetLimit) {
            *t++=*uchars++;
            --length;
        }
    } else {
        /* output with offsets */
        while(length>0 && t<targetLimit) {
            *t++=*uchars++;
            *o++=sourceIndex;
            --length;
        }
        *offsets=o;
    }
    *target=t;

    /* write overflow */
    if(length>0) {
        if(cnv!=nullptr) {
            t=cnv->UCharErrorBuffer;
            cnv->UCharErrorBufferLength=(int8_t)length;
            do {
                *t++=*uchars++;
            } while(--length>0);
        }
        *pErrorCode=U_BUFFER_OVERFLOW_ERROR;
    }
}

U_CFUNC void
ucnv_toUWriteCodePoint(UConverter *cnv,
                       UChar32 c,
                       char16_t **target, const char16_t *targetLimit,
                       int32_t **offsets,
                       int32_t sourceIndex,
                       UErrorCode *pErrorCode) {
    char16_t *t;
    int32_t *o;

    t=*target;

    if(t<targetLimit) {
        if(c<=0xffff) {
            *t++=(char16_t)c;
            c=U_SENTINEL;
        } else /* c is a supplementary code point */ {
            *t++=U16_LEAD(c);
            c=U16_TRAIL(c);
            if(t<targetLimit) {
                *t++=(char16_t)c;
                c=U_SENTINEL;
            }
        }

        /* write offsets */
        if(offsets!=nullptr && (o=*offsets)!=nullptr) {
            *o++=sourceIndex;
            if((*target+1)<t) {
                *o++=sourceIndex;
            }
            *offsets=o;
        }
    }

    *target=t;

    /* write overflow from c */
    if(c>=0) {
        if(cnv!=nullptr) {
            int8_t i=0;
            U16_APPEND_UNSAFE(cnv->UCharErrorBuffer, i, c);
            cnv->UCharErrorBufferLength=i;
        }
        *pErrorCode=U_BUFFER_OVERFLOW_ERROR;
    }
}

#endif
                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/icu-small/source/common/ucnv_cnv.h                                                 0000664 0000000 0000000 00000031260 14746647661 0022162 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
**********************************************************************
*   Copyright (C) 1999-2011, International Business Machines
*   Corporation and others.  All Rights Reserved.
**********************************************************************
*
*   ucnv_cnv.h:
*   Definitions for converter implementations.
*
* Modification History:
*
*   Date        Name        Description
*   05/09/00    helena      Added implementation to handle fallback mappings.
*   06/29/2000  helena      Major rewrite of the callback APIs.
*/

#ifndef UCNV_CNV_H
#define UCNV_CNV_H

#include "unicode/utypes.h"

#if !UCONFIG_NO_CONVERSION

#include "unicode/ucnv.h"
#include "unicode/ucnv_err.h"
#include "unicode/uset.h"
#include "uset_imp.h"

U_CDECL_BEGIN

/* this is used in fromUnicode DBCS tables as an "unassigned" marker */
#define missingCharMarker 0xFFFF

/*
 * #define missingUCharMarker 0xfffe
 *
 * commented out because there are actually two values used in toUnicode tables:
 * U+fffe "unassigned"
 * U+ffff "illegal"
 */

/** Forward declaration, see ucnv_bld.h */
struct UConverterSharedData;
typedef struct UConverterSharedData UConverterSharedData;

/* function types for UConverterImpl ---------------------------------------- */

/* struct with arguments for UConverterLoad and ucnv_load() */
typedef struct {
    int32_t size;               /* sizeof(UConverterLoadArgs) */
    int32_t nestedLoads;        /* count nested ucnv_load() calls */
    UBool onlyTestIsLoadable;   /* input: don't actually load */
    UBool reserved0;            /* reserved - for good alignment of the pointers */
    int16_t reserved;           /* reserved - for good alignment of the pointers */
    uint32_t options;
    const char *pkg, *name, *locale;
} UConverterLoadArgs;

#define UCNV_LOAD_ARGS_INITIALIZER \
    { (int32_t)sizeof(UConverterLoadArgs), 0, false, false, 0, 0, NULL, NULL, NULL }

typedef void (*UConverterLoad) (UConverterSharedData *sharedData,
                                UConverterLoadArgs *pArgs,
                                const uint8_t *raw, UErrorCode *pErrorCode);
typedef void (*UConverterUnload) (UConverterSharedData *sharedData);

typedef void (*UConverterOpen) (UConverter *cnv, UConverterLoadArgs *pArgs, UErrorCode *pErrorCode);
typedef void (*UConverterClose) (UConverter *cnv);

typedef enum UConverterResetChoice {
    UCNV_RESET_BOTH,
    UCNV_RESET_TO_UNICODE,
    UCNV_RESET_FROM_UNICODE
} UConverterResetChoice;

typedef void (*UConverterReset) (UConverter *cnv, UConverterResetChoice choice);

/*
 * Converter implementation function(s) for ucnv_toUnicode().
 * If the toUnicodeWithOffsets function pointer is NULL,
 * then the toUnicode function will be used and the offsets will be set to -1.
 *
 * Must maintain state across buffers. Use toUBytes[toULength] for partial input
 * sequences; it will be checked in ucnv.c at the end of the input stream
 * to detect truncated input.
 * Some converters may need additional detection and may then set U_TRUNCATED_CHAR_FOUND.
 *
 * The toUnicodeWithOffsets must write exactly as many offset values as target
 * units. Write offset values of -1 for when the source index corresponding to
 * the output unit is not known (e.g., the character started in an earlier buffer).
 * The pArgs->offsets pointer need not be moved forward.
 *
 * At function return, either one of the following conditions must be true:
 * - U_BUFFER_OVERFLOW_ERROR and the target is full: target==targetLimit
 * - another error code with toUBytes[toULength] set to the offending input
 * - no error, and the source is consumed: source==sourceLimit
 *
 * The ucnv.c code will handle the end of the input (reset)
 * (reset, and truncation detection) and callbacks.
 */
typedef void (*UConverterToUnicode) (UConverterToUnicodeArgs *, UErrorCode *);

/*
 * Same rules as for UConverterToUnicode.
 * A lead surrogate is kept in fromUChar32 across buffers, and if an error
 * occurs, then the offending input code point must be put into fromUChar32
 * as well.
 */
typedef void (*UConverterFromUnicode) (UConverterFromUnicodeArgs *, UErrorCode *);

/*
 * Converter implementation function for ucnv_convertEx(), for direct conversion
 * between two charsets without pivoting through UTF-16.
 * The rules are the same as for UConverterToUnicode and UConverterFromUnicode.
 * In addition,
 * - The toUnicode side must behave and keep state exactly like the
 *   UConverterToUnicode implementation for the same source charset.
 * - A U_USING_DEFAULT_WARNING can be set to request to temporarily fall back
 *   to pivoting. When this function is called, the conversion framework makes
 *   sure that this warning is not set on input.
 * - Continuing a partial match and flushing the toUnicode replay buffer
 *   are handled by pivoting, using the toUnicode and fromUnicode functions.
 */
typedef void (*UConverterConvert) (UConverterFromUnicodeArgs *pFromUArgs,
                                   UConverterToUnicodeArgs *pToUArgs,
                                   UErrorCode *pErrorCode);

/*
 * Converter implementation function for ucnv_getNextUChar().
 * If the function pointer is NULL, then the toUnicode function will be used.
 *
 * Will be called at a character boundary (toULength==0).
 * May return with
 * - U_INDEX_OUTOFBOUNDS_ERROR if there was no output for the input
 *   (the return value will be ignored)
 * - U_TRUNCATED_CHAR_FOUND or another error code (never U_BUFFER_OVERFLOW_ERROR!)
 *   with toUBytes[toULength] set to the offending input
 *   (the return value will be ignored)
 * - return UCNV_GET_NEXT_UCHAR_USE_TO_U, without moving the source pointer,
 *   to indicate that the ucnv.c code shall call the toUnicode function instead
 * - return a real code point result
 *
 * Unless UCNV_GET_NEXT_UCHAR_USE_TO_U is returned, the source bytes must be consumed.
 *
 * The ucnv.c code will handle the end of the input (reset)
 * (except for truncation detection!) and callbacks.
 */
typedef UChar32 (*UConverterGetNextUChar) (UConverterToUnicodeArgs *, UErrorCode *);

typedef void (*UConverterGetStarters)(const UConverter* converter,
                                      UBool starters[256],
                                      UErrorCode *pErrorCode);

/* If this function pointer is null or if the function returns null
 * the name field in static data struct should be returned by 
 * ucnv_getName() API function
 */
typedef const char * (*UConverterGetName) (const UConverter *cnv);

/**
 * Write the codepage substitution character.
 * If this function is not set, then ucnv_cbFromUWriteSub() writes
 * the substitution character from UConverter.
 * For stateful converters, it is typically necessary to handle this
 * specifically for the converter in order to properly maintain the state.
 */
typedef void (*UConverterWriteSub) (UConverterFromUnicodeArgs *pArgs, int32_t offsetIndex, UErrorCode *pErrorCode);

/**
 * For converter-specific safeClone processing
 * If this function is not set, then ucnv_safeClone assumes that the converter has no private data that changes
 * after the converter is done opening.
 * If this function is set, then it is called just after a memcpy() of
 * converter data to the new, empty converter, and is expected to set up
 * the initial state of the converter.  It is not expected to increment the
 * reference counts of the standard data types such as the shared data.
 */
typedef UConverter * (*UConverterSafeClone) (const UConverter   *cnv, 
                                             void               *stackBuffer,
                                             int32_t            *pBufferSize, 
                                             UErrorCode         *status);

/**
 * Filters for some ucnv_getUnicodeSet() implementation code.
 */
typedef enum UConverterSetFilter {
    UCNV_SET_FILTER_NONE,
    UCNV_SET_FILTER_DBCS_ONLY,
    UCNV_SET_FILTER_2022_CN,
    UCNV_SET_FILTER_SJIS,
    UCNV_SET_FILTER_GR94DBCS,
    UCNV_SET_FILTER_HZ,
    UCNV_SET_FILTER_COUNT
} UConverterSetFilter;

/**
 * Fills the set of Unicode code points that can be converted by an ICU converter.
 * The API function ucnv_getUnicodeSet() clears the USet before calling
 * the converter's getUnicodeSet() implementation; the converter should only
 * add the appropriate code points to allow recursive use.
 * For example, the ISO-2022-JP converter will call each subconverter's
 * getUnicodeSet() implementation to consecutively add code points to
 * the same USet, which will result in a union of the sets of all subconverters.
 *
 * For more documentation, see ucnv_getUnicodeSet() in ucnv.h.
 */
typedef void (*UConverterGetUnicodeSet) (const UConverter *cnv,
                                         const USetAdder *sa,
                                         UConverterUnicodeSet which,
                                         UErrorCode *pErrorCode);

UBool CONVERSION_U_SUCCESS (UErrorCode err);

/**
 * UConverterImpl contains all the data and functions for a converter type.
 * Its function pointers work much like a C++ vtable.
 * Many converter types need to define only a subset of the functions;
 * when a function pointer is NULL, then a default action will be performed.
 *
 * Every converter type must implement toUnicode, fromUnicode, and getNextUChar,
 * otherwise the converter may crash.
 * Every converter type that has variable-length codepage sequences should
 * also implement toUnicodeWithOffsets and fromUnicodeWithOffsets for
 * correct offset handling.
 * All other functions may or may not be implemented - it depends only on
 * whether the converter type needs them.
 *
 * When open() fails, then close() will be called, if present.
 */
struct UConverterImpl {
    UConverterType type;

    UConverterLoad load;
    UConverterUnload unload;

    UConverterOpen open;
    UConverterClose close;
    UConverterReset reset;

    UConverterToUnicode toUnicode;
    UConverterToUnicode toUnicodeWithOffsets;
    UConverterFromUnicode fromUnicode;
    UConverterFromUnicode fromUnicodeWithOffsets;
    UConverterGetNextUChar getNextUChar;

    UConverterGetStarters getStarters;
    UConverterGetName getName;
    UConverterWriteSub writeSub;
    UConverterSafeClone safeClone;
    UConverterGetUnicodeSet getUnicodeSet;

    UConverterConvert toUTF8;
    UConverterConvert fromUTF8;
};

extern const UConverterSharedData
    _MBCSData, _Latin1Data,
    _UTF8Data, _UTF16BEData, _UTF16LEData, _UTF32BEData, _UTF32LEData,
    _ISO2022Data, 
    _LMBCSData1,_LMBCSData2, _LMBCSData3, _LMBCSData4, _LMBCSData5, _LMBCSData6,
    _LMBCSData8,_LMBCSData11,_LMBCSData16,_LMBCSData17,_LMBCSData18,_LMBCSData19,
    _HZData,_ISCIIData, _SCSUData, _ASCIIData,
    _UTF7Data, _Bocu1Data, _UTF16Data, _UTF32Data, _CESU8Data, _IMAPData, _CompoundTextData;

U_CDECL_END

/** Always use fallbacks from codepage to Unicode */
#define TO_U_USE_FALLBACK(useFallback) true
#define UCNV_TO_U_USE_FALLBACK(cnv) true

/** Use fallbacks from Unicode to codepage when cnv->useFallback or for private-use code points */
#define IS_PRIVATE_USE(c) ((uint32_t)((c)-0xe000)<0x1900 || (uint32_t)((c)-0xf0000)<0x20000)
#define FROM_U_USE_FALLBACK(useFallback, c) ((useFallback) || IS_PRIVATE_USE(c))
#define UCNV_FROM_U_USE_FALLBACK(cnv, c) FROM_U_USE_FALLBACK((cnv)->useFallback, c)

/**
 * Magic number for ucnv_getNextUChar(), returned by a
 * getNextUChar() implementation to indicate to use the converter's toUnicode()
 * instead of the native function.
 * @internal
 */
#define UCNV_GET_NEXT_UCHAR_USE_TO_U -9

U_CFUNC void
ucnv_getCompleteUnicodeSet(const UConverter *cnv,
                   const USetAdder *sa,
                   UConverterUnicodeSet which,
                   UErrorCode *pErrorCode);

U_CFUNC void
ucnv_getNonSurrogateUnicodeSet(const UConverter *cnv,
                               const USetAdder *sa,
                               UConverterUnicodeSet which,
                               UErrorCode *pErrorCode);

U_CFUNC void
ucnv_fromUWriteBytes(UConverter *cnv,
                     const char *bytes, int32_t length,
                     char **target, const char *targetLimit,
                     int32_t **offsets,
                     int32_t sourceIndex,
                     UErrorCode *pErrorCode);
U_CFUNC void
ucnv_toUWriteUChars(UConverter *cnv,
                    const UChar *uchars, int32_t length,
                    UChar **target, const UChar *targetLimit,
                    int32_t **offsets,
                    int32_t sourceIndex,
                    UErrorCode *pErrorCode);

U_CFUNC void
ucnv_toUWriteCodePoint(UConverter *cnv,
                       UChar32 c,
                       UChar **target, const UChar *targetLimit,
                       int32_t **offsets,
                       int32_t sourceIndex,
                       UErrorCode *pErrorCode);

#endif

#endif /* UCNV_CNV */
                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/icu-small/source/common/ucnv_ct.cpp                                                0000664 0000000 0000000 00000062267 14746647661 0022350 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
**********************************************************************
*   Copyright (C) 2010-2015, International Business Machines
*   Corporation and others.  All Rights Reserved.
**********************************************************************
*   file name:  ucnv_ct.c
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2010Dec09
*   created by: Michael Ow
*/

#include "unicode/utypes.h"

#if !UCONFIG_NO_CONVERSION && !UCONFIG_NO_LEGACY_CONVERSION && !UCONFIG_ONLY_HTML_CONVERSION

#include "unicode/ucnv.h"
#include "unicode/uset.h"
#include "unicode/ucnv_err.h"
#include "unicode/ucnv_cb.h"
#include "unicode/utf16.h"
#include "ucnv_imp.h"
#include "ucnv_bld.h"
#include "ucnv_cnv.h"
#include "ucnvmbcs.h"
#include "cstring.h"
#include "cmemory.h"

typedef enum {
    INVALID = -2,
    DO_SEARCH = -1,

    COMPOUND_TEXT_SINGLE_0 = 0,
    COMPOUND_TEXT_SINGLE_1 = 1,
    COMPOUND_TEXT_SINGLE_2 = 2,
    COMPOUND_TEXT_SINGLE_3 = 3,

    COMPOUND_TEXT_DOUBLE_1 = 4,
    COMPOUND_TEXT_DOUBLE_2 = 5,
    COMPOUND_TEXT_DOUBLE_3 = 6,
    COMPOUND_TEXT_DOUBLE_4 = 7,
    COMPOUND_TEXT_DOUBLE_5 = 8,
    COMPOUND_TEXT_DOUBLE_6 = 9,
    COMPOUND_TEXT_DOUBLE_7 = 10,

    COMPOUND_TEXT_TRIPLE_DOUBLE = 11,

    IBM_915 = 12,
    IBM_916 = 13,
    IBM_914 = 14,
    IBM_874 = 15,
    IBM_912 = 16,
    IBM_913 = 17,
    ISO_8859_14 = 18,
    IBM_923 = 19,
    NUM_OF_CONVERTERS = 20
} COMPOUND_TEXT_CONVERTERS;

#define SEARCH_LENGTH 12

static const uint8_t escSeqCompoundText[NUM_OF_CONVERTERS][5] = {
    /* Single */
    { 0x1B, 0x2D, 0x41, 0, 0 },
    { 0x1B, 0x2D, 0x4D, 0, 0 },
    { 0x1B, 0x2D, 0x46, 0, 0 },
    { 0x1B, 0x2D, 0x47, 0, 0 },

    /* Double */
    { 0x1B, 0x24, 0x29, 0x41, 0 },
    { 0x1B, 0x24, 0x29, 0x42, 0 },
    { 0x1B, 0x24, 0x29, 0x43, 0 },
    { 0x1B, 0x24, 0x29, 0x44, 0 },
    { 0x1B, 0x24, 0x29, 0x47, 0 },
    { 0x1B, 0x24, 0x29, 0x48, 0 },
    { 0x1B, 0x24, 0x29, 0x49, 0 },

    /* Triple/Double */
    { 0x1B, 0x25, 0x47, 0, 0 },

    /*IBM-915*/
    { 0x1B, 0x2D, 0x4C, 0, 0 },
    /*IBM-916*/
    { 0x1B, 0x2D, 0x48, 0, 0 },
    /*IBM-914*/
    { 0x1B, 0x2D, 0x44, 0, 0 },
    /*IBM-874*/
    { 0x1B, 0x2D, 0x54, 0, 0 },
    /*IBM-912*/
    { 0x1B, 0x2D, 0x42, 0, 0 },
    /* IBM-913 */
    { 0x1B, 0x2D, 0x43, 0, 0 },
    /* ISO-8859_14 */
    { 0x1B, 0x2D, 0x5F, 0, 0 },
    /* IBM-923 */
    { 0x1B, 0x2D, 0x62, 0, 0 },
};

#define ESC_START 0x1B

#define isASCIIRange(codepoint) \
        ((codepoint == 0x0000) || (codepoint == 0x0009) || (codepoint == 0x000A) || \
         (codepoint >= 0x0020 && codepoint <= 0x007f) || (codepoint >= 0x00A0 && codepoint <= 0x00FF))

#define isIBM915(codepoint) \
        ((codepoint >= 0x0401 && codepoint <= 0x045F) || (codepoint == 0x2116))

#define isIBM916(codepoint) \
        ((codepoint >= 0x05D0 && codepoint <= 0x05EA) || (codepoint == 0x2017) || (codepoint == 0x203E))

#define isCompoundS3(codepoint) \
        ((codepoint == 0x060C) || (codepoint == 0x061B) || (codepoint == 0x061F) || (codepoint >= 0x0621 && codepoint <= 0x063A) || \
         (codepoint >= 0x0640 && codepoint <= 0x0652) || (codepoint >= 0x0660 && codepoint <= 0x066D) || (codepoint == 0x200B) || \
         (codepoint >= 0x0FE70 && codepoint <= 0x0FE72) || (codepoint == 0x0FE74) || (codepoint >= 0x0FE76 && codepoint <= 0x0FEBE))

#define isCompoundS2(codepoint) \
        ((codepoint == 0x02BC) || (codepoint == 0x02BD) || (codepoint >= 0x0384 && codepoint <= 0x03CE) || (codepoint == 0x2015))

#define isIBM914(codepoint) \
        ((codepoint == 0x0100) || (codepoint == 0x0101) || (codepoint == 0x0112) || (codepoint == 0x0113) || (codepoint == 0x0116) || (codepoint == 0x0117) || \
         (codepoint == 0x0122) || (codepoint == 0x0123) || (codepoint >= 0x0128 && codepoint <= 0x012B) || (codepoint == 0x012E) || (codepoint == 0x012F) || \
         (codepoint >= 0x0136 && codepoint <= 0x0138) || (codepoint == 0x013B) || (codepoint == 0x013C) || (codepoint == 0x0145) || (codepoint ==  0x0146) || \
         (codepoint >= 0x014A && codepoint <= 0x014D) || (codepoint == 0x0156) || (codepoint == 0x0157) || (codepoint >= 0x0166 && codepoint <= 0x016B) || \
         (codepoint == 0x0172) || (codepoint == 0x0173))

#define isIBM874(codepoint) \
        ((codepoint >= 0x0E01 && codepoint <= 0x0E3A) || (codepoint >= 0x0E3F && codepoint <= 0x0E5B))

#define isIBM912(codepoint) \
        ((codepoint >= 0x0102 && codepoint <= 0x0107) || (codepoint >= 0x010C && codepoint <= 0x0111) || (codepoint >= 0x0118 && codepoint <= 0x011B) || \
         (codepoint == 0x0139) || (codepoint == 0x013A) || (codepoint == 0x013D) || (codepoint == 0x013E) || (codepoint >= 0x0141 && codepoint <= 0x0144) || \
         (codepoint == 0x0147) || (codepoint == 0x0147) || (codepoint == 0x0150) || (codepoint == 0x0151) || (codepoint == 0x0154) || (codepoint == 0x0155) || \
         (codepoint >= 0x0158 && codepoint <= 0x015B) || (codepoint == 0x015E) || (codepoint == 0x015F) || (codepoint >= 0x0160 && codepoint <= 0x0165) || \
         (codepoint == 0x016E) || (codepoint == 0x016F) || (codepoint == 0x0170) || (codepoint ==  0x0171) || (codepoint >= 0x0179 && codepoint <= 0x017E) || \
         (codepoint == 0x02C7) || (codepoint == 0x02D8) || (codepoint == 0x02D9) || (codepoint == 0x02DB) || (codepoint == 0x02DD))

#define isIBM913(codepoint) \
        ((codepoint >= 0x0108 && codepoint <= 0x010B) || (codepoint == 0x011C) || \
         (codepoint == 0x011D) || (codepoint == 0x0120) || (codepoint == 0x0121) || \
         (codepoint >= 0x0124 && codepoint <= 0x0127) || (codepoint == 0x0134) || (codepoint == 0x0135) || \
         (codepoint == 0x015C) || (codepoint == 0x015D) || (codepoint == 0x016C) || (codepoint ==  0x016D))

#define isCompoundS1(codepoint) \
        ((codepoint == 0x011E) || (codepoint == 0x011F) || (codepoint == 0x0130) || \
         (codepoint == 0x0131) || (codepoint >= 0x0218 && codepoint <= 0x021B))

#define isISO8859_14(codepoint) \
        ((codepoint >= 0x0174 && codepoint <= 0x0177) || (codepoint == 0x1E0A) || \
         (codepoint == 0x1E0B) || (codepoint == 0x1E1E) || (codepoint == 0x1E1F) || \
         (codepoint == 0x1E40) || (codepoint == 0x1E41) || (codepoint == 0x1E56) || \
         (codepoint == 0x1E57) || (codepoint == 0x1E60) || (codepoint == 0x1E61) || \
         (codepoint == 0x1E6A) || (codepoint == 0x1E6B) || (codepoint == 0x1EF2) || \
         (codepoint == 0x1EF3) || (codepoint >= 0x1E80 && codepoint <= 0x1E85))

#define isIBM923(codepoint) \
        ((codepoint == 0x0152) || (codepoint == 0x0153) || (codepoint == 0x0178) || (codepoint == 0x20AC))


typedef struct{
    UConverterSharedData *myConverterArray[NUM_OF_CONVERTERS];
    COMPOUND_TEXT_CONVERTERS state;
} UConverterDataCompoundText;

/*********** Compound Text Converter Protos ***********/
U_CDECL_BEGIN
static void U_CALLCONV
_CompoundTextOpen(UConverter *cnv, UConverterLoadArgs *pArgs, UErrorCode *errorCode);

static void U_CALLCONV
 _CompoundTextClose(UConverter *converter);

static void U_CALLCONV
_CompoundTextReset(UConverter *converter, UConverterResetChoice choice);

static const char* U_CALLCONV
_CompoundTextgetName(const UConverter* cnv);


static int32_t findNextEsc(const char *source, const char *sourceLimit) {
    int32_t length = static_cast<int32_t>(sourceLimit - source);
    int32_t i;
    for (i = 1; i < length; i++) {
        if (*(source + i) == 0x1B) {
            return i;
        }
    }

    return length;
}

static COMPOUND_TEXT_CONVERTERS getState(int codepoint) {
    COMPOUND_TEXT_CONVERTERS state = DO_SEARCH;

    if (isASCIIRange(codepoint)) {
        state = COMPOUND_TEXT_SINGLE_0;
    } else if (isIBM912(codepoint)) {
        state = IBM_912;
    }else if (isIBM913(codepoint)) {
        state = IBM_913;
    } else if (isISO8859_14(codepoint)) {
        state = ISO_8859_14;
    } else if (isIBM923(codepoint)) {
        state = IBM_923;
    } else if (isIBM874(codepoint)) {
        state = IBM_874;
    } else if (isIBM914(codepoint)) {
        state = IBM_914;
    } else if (isCompoundS2(codepoint)) {
        state = COMPOUND_TEXT_SINGLE_2;
    } else if (isCompoundS3(codepoint)) {
        state = COMPOUND_TEXT_SINGLE_3;
    } else if (isIBM916(codepoint)) {
        state = IBM_916;
    } else if (isIBM915(codepoint)) {
        state = IBM_915;
    } else if (isCompoundS1(codepoint)) {
        state = COMPOUND_TEXT_SINGLE_1;
    }

    return state;
}

static COMPOUND_TEXT_CONVERTERS findStateFromEscSeq(const char* source, const char* sourceLimit, const uint8_t* toUBytesBuffer, int32_t toUBytesBufferLength, UErrorCode *err) {
    COMPOUND_TEXT_CONVERTERS state = INVALID;
    UBool matchFound = false;
    int32_t i, n, offset = toUBytesBufferLength;

    for (i = 0; i < NUM_OF_CONVERTERS; i++) {
        matchFound = true;
        for (n = 0; escSeqCompoundText[i][n] != 0; n++) {
            if (n < toUBytesBufferLength) {
                if (toUBytesBuffer[n] != escSeqCompoundText[i][n]) {
                    matchFound = false;
                    break;
                }
            } else if ((source + (n - offset)) >= sourceLimit) {
                *err = U_TRUNCATED_CHAR_FOUND;
                matchFound = false;
                break;
            } else if (*(source + (n - offset)) != escSeqCompoundText[i][n]) {
                matchFound = false;
                break;
            }
        }

        if (matchFound) {
            break;
        }
    }

    if (matchFound) {
        state = (COMPOUND_TEXT_CONVERTERS)i;
    }

    return state;
}

static void U_CALLCONV
_CompoundTextOpen(UConverter *cnv, UConverterLoadArgs *pArgs, UErrorCode *errorCode){
    cnv->extraInfo = uprv_malloc (sizeof (UConverterDataCompoundText));
    if (cnv->extraInfo != nullptr) {
        UConverterDataCompoundText *myConverterData = (UConverterDataCompoundText *) cnv->extraInfo;

        UConverterNamePieces stackPieces;
        UConverterLoadArgs stackArgs=UCNV_LOAD_ARGS_INITIALIZER;

        myConverterData->myConverterArray[COMPOUND_TEXT_SINGLE_0] = nullptr;
        myConverterData->myConverterArray[COMPOUND_TEXT_SINGLE_1] = ucnv_loadSharedData("icu-internal-compound-s1", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[COMPOUND_TEXT_SINGLE_2] = ucnv_loadSharedData("icu-internal-compound-s2", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[COMPOUND_TEXT_SINGLE_3] = ucnv_loadSharedData("icu-internal-compound-s3", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[COMPOUND_TEXT_DOUBLE_1] = ucnv_loadSharedData("icu-internal-compound-d1", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[COMPOUND_TEXT_DOUBLE_2] = ucnv_loadSharedData("icu-internal-compound-d2", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[COMPOUND_TEXT_DOUBLE_3] = ucnv_loadSharedData("icu-internal-compound-d3", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[COMPOUND_TEXT_DOUBLE_4] = ucnv_loadSharedData("icu-internal-compound-d4", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[COMPOUND_TEXT_DOUBLE_5] = ucnv_loadSharedData("icu-internal-compound-d5", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[COMPOUND_TEXT_DOUBLE_6] = ucnv_loadSharedData("icu-internal-compound-d6", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[COMPOUND_TEXT_DOUBLE_7] = ucnv_loadSharedData("icu-internal-compound-d7", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[COMPOUND_TEXT_TRIPLE_DOUBLE] = ucnv_loadSharedData("icu-internal-compound-t", &stackPieces, &stackArgs, errorCode);

        myConverterData->myConverterArray[IBM_915] = ucnv_loadSharedData("ibm-915_P100-1995", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[IBM_916] = ucnv_loadSharedData("ibm-916_P100-1995", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[IBM_914] = ucnv_loadSharedData("ibm-914_P100-1995", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[IBM_874] = ucnv_loadSharedData("ibm-874_P100-1995", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[IBM_912] = ucnv_loadSharedData("ibm-912_P100-1995", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[IBM_913] = ucnv_loadSharedData("ibm-913_P100-2000", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[ISO_8859_14] = ucnv_loadSharedData("iso-8859_14-1998", &stackPieces, &stackArgs, errorCode);
        myConverterData->myConverterArray[IBM_923] = ucnv_loadSharedData("ibm-923_P100-1998", &stackPieces, &stackArgs, errorCode);

        if (U_FAILURE(*errorCode) || pArgs->onlyTestIsLoadable) {
            _CompoundTextClose(cnv);
            return;
        }

        myConverterData->state = (COMPOUND_TEXT_CONVERTERS)0;
    } else {
        *errorCode = U_MEMORY_ALLOCATION_ERROR;
    }
}


static void U_CALLCONV
_CompoundTextClose(UConverter *converter) {
    UConverterDataCompoundText* myConverterData = (UConverterDataCompoundText*)(converter->extraInfo);
    int32_t i;

    if (converter->extraInfo != nullptr) {
        /*close the array of converter pointers and free the memory*/
        for (i = 0; i < NUM_OF_CONVERTERS; i++) {
            if (myConverterData->myConverterArray[i] != nullptr) {
                ucnv_unloadSharedDataIfReady(myConverterData->myConverterArray[i]);
            }
        }

        uprv_free(converter->extraInfo);
        converter->extraInfo = nullptr;
    }
}

static void U_CALLCONV
_CompoundTextReset(UConverter *converter, UConverterResetChoice choice) {
    (void)converter;
    (void)choice;
}

static const char* U_CALLCONV
_CompoundTextgetName(const UConverter* cnv){
    (void)cnv;
    return "x11-compound-text";
}

static void U_CALLCONV
UConverter_fromUnicode_CompoundText_OFFSETS(UConverterFromUnicodeArgs* args, UErrorCode* err){
    UConverter *cnv = args->converter;
    uint8_t *target = (uint8_t *) args->target;
    const uint8_t *targetLimit = (const uint8_t *) args->targetLimit;
    const char16_t* source = args->source;
    const char16_t* sourceLimit = args->sourceLimit;
    /* int32_t* offsets = args->offsets; */
    UChar32 sourceChar;
    UBool useFallback = cnv->useFallback;
    uint8_t tmpTargetBuffer[7];
    int32_t tmpTargetBufferLength = 0;
    COMPOUND_TEXT_CONVERTERS currentState, tmpState;
    uint32_t pValue;
    int32_t pValueLength = 0;
    int32_t i, n, j;

    UConverterDataCompoundText *myConverterData = (UConverterDataCompoundText *) cnv->extraInfo;

    currentState = myConverterData->state;

    /* check if the last codepoint of previous buffer was a lead surrogate*/
    if((sourceChar = cnv->fromUChar32)!=0 && target< targetLimit) {
        goto getTrail;
    }

    while( source < sourceLimit){
        if(target < targetLimit){

            sourceChar  = *(source++);
            /*check if the char is a First surrogate*/
             if(U16_IS_SURROGATE(sourceChar)) {
                if(U16_IS_SURROGATE_LEAD(sourceChar)) {
getTrail:
                    /*look ahead to find the trail surrogate*/
                    if(source < sourceLimit) {
                        /* test the following code unit */
                        char16_t trail = *source;
                        if(U16_IS_TRAIL(trail)) {
                            source++;
                            sourceChar=U16_GET_SUPPLEMENTARY(sourceChar, trail);
                            cnv->fromUChar32=0x00;
                            /* convert this supplementary code point */
                            /* exit this condition tree */
                        } else {
                            /* this is an unmatched lead code unit (1st surrogate) */
                            /* callback(illegal) */
                            *err=U_ILLEGAL_CHAR_FOUND;
                            cnv->fromUChar32=sourceChar;
                            break;
                        }
                    } else {
                        /* no more input */
                        cnv->fromUChar32=sourceChar;
                        break;
                    }
                } else {
                    /* this is an unmatched trail code unit (2nd surrogate) */
                    /* callback(illegal) */
                    *err=U_ILLEGAL_CHAR_FOUND;
                    cnv->fromUChar32=sourceChar;
                    break;
                }
            }

             tmpTargetBufferLength = 0;
             tmpState = getState(sourceChar);

             if (tmpState != DO_SEARCH && currentState != tmpState) {
                 /* Get escape sequence if necessary */
                 currentState = tmpState;
                 for (i = 0; escSeqCompoundText[currentState][i] != 0; i++) {
                     tmpTargetBuffer[tmpTargetBufferLength++] = escSeqCompoundText[currentState][i];
                 }
             }

             if (tmpState == DO_SEARCH) {
                 /* Test all available converters */
                 for (i = 1; i < SEARCH_LENGTH; i++) {
                     pValueLength = ucnv_MBCSFromUChar32(myConverterData->myConverterArray[i], sourceChar, &pValue, useFallback);
                     if (pValueLength > 0) {
                         tmpState = (COMPOUND_TEXT_CONVERTERS)i;
                         if (currentState != tmpState) {
                             currentState = tmpState;
                             for (j = 0; escSeqCompoundText[currentState][j] != 0; j++) {
                                 tmpTargetBuffer[tmpTargetBufferLength++] = escSeqCompoundText[currentState][j];
                             }
                         }
                         for (n = (pValueLength - 1); n >= 0; n--) {
                             tmpTargetBuffer[tmpTargetBufferLength++] = (uint8_t)(pValue >> (n * 8));
                         }
                         break;
                     }
                 }
             } else if (tmpState == COMPOUND_TEXT_SINGLE_0) {
                 tmpTargetBuffer[tmpTargetBufferLength++] = (uint8_t)sourceChar;
             } else {
                 pValueLength = ucnv_MBCSFromUChar32(myConverterData->myConverterArray[currentState], sourceChar, &pValue, useFallback);
                 if (pValueLength > 0) {
                     for (n = (pValueLength - 1); n >= 0; n--) {
                         tmpTargetBuffer[tmpTargetBufferLength++] = (uint8_t)(pValue >> (n * 8));
                     }
                 }
             }

             for (i = 0; i < tmpTargetBufferLength; i++) {
                 if (target < targetLimit) {
                     *target++ = tmpTargetBuffer[i];
                 } else {
                     *err = U_BUFFER_OVERFLOW_ERROR;
                     break;
                 }
             }

             if (*err == U_BUFFER_OVERFLOW_ERROR) {
                 for (; i < tmpTargetBufferLength; i++) {
                     args->converter->charErrorBuffer[args->converter->charErrorBufferLength++] = tmpTargetBuffer[i];
                 }
             }
        } else {
            *err = U_BUFFER_OVERFLOW_ERROR;
            break;
        }
    }

    /*save the state and return */
    myConverterData->state = currentState;
    args->source = source;
    args->target = (char*)target;
}


static void U_CALLCONV
UConverter_toUnicode_CompoundText_OFFSETS(UConverterToUnicodeArgs *args,
                                               UErrorCode* err){
    const char *mySource = (char *) args->source;
    char16_t *myTarget = args->target;
    const char *mySourceLimit = args->sourceLimit;
    const char *tmpSourceLimit = mySourceLimit;
    uint32_t mySourceChar = 0x0000;
    COMPOUND_TEXT_CONVERTERS currentState, tmpState;
    int32_t sourceOffset = 0;
    UConverterDataCompoundText *myConverterData = (UConverterDataCompoundText *) args->converter->extraInfo;
    UConverterSharedData* savedSharedData = nullptr;

    UConverterToUnicodeArgs subArgs;
    int32_t minArgsSize;

    /* set up the subconverter arguments */
    if(args->size<sizeof(UConverterToUnicodeArgs)) {
        minArgsSize = args->size;
    } else {
        minArgsSize = (int32_t)sizeof(UConverterToUnicodeArgs);
    }

    uprv_memcpy(&subArgs, args, minArgsSize);
    subArgs.size = (uint16_t)minArgsSize;

    currentState = tmpState =  myConverterData->state;

    while(mySource < mySourceLimit){
        if(myTarget < args->targetLimit){
            if (args->converter->toULength > 0) {
                mySourceChar = args->converter->toUBytes[0];
            } else {
                mySourceChar = (uint8_t)*mySource;
            }

            if (mySourceChar == ESC_START) {
                tmpState = findStateFromEscSeq(mySource, mySourceLimit, args->converter->toUBytes, args->converter->toULength, err);

                if (*err == U_TRUNCATED_CHAR_FOUND) {
                    for (; mySource < mySourceLimit;) {
                        args->converter->toUBytes[args->converter->toULength++] = *mySource++;
                    }
                    *err = U_ZERO_ERROR;
                    break;
                } else if (tmpState == INVALID) {
                    if (args->converter->toULength == 0) {
                        mySource++; /* skip over the 0x1b byte */
                    }
                    *err = U_ILLEGAL_CHAR_FOUND;
                    break;
                }

                if (tmpState != currentState) {
                    currentState = tmpState;
                }

                sourceOffset = static_cast<int32_t>(uprv_strlen((char*)escSeqCompoundText[currentState]) - args->converter->toULength);

                mySource += sourceOffset;

                args->converter->toULength = 0;
            }

            if (currentState == COMPOUND_TEXT_SINGLE_0) {
                while (mySource < mySourceLimit) {
                    if (*mySource == ESC_START) {
                        break;
                    }
                    if (myTarget < args->targetLimit) {
                        *myTarget++ = 0x00ff&(*mySource++);
                    } else {
                        *err = U_BUFFER_OVERFLOW_ERROR;
                        break;
                    }
                }
            } else if (mySource < mySourceLimit){
                sourceOffset = findNextEsc(mySource, mySourceLimit);

                tmpSourceLimit = mySource + sourceOffset;

                subArgs.source = mySource;
                subArgs.sourceLimit = tmpSourceLimit;
                subArgs.target = myTarget;
                savedSharedData = subArgs.converter->sharedData;
                subArgs.converter->sharedData = myConverterData->myConverterArray[currentState];

                ucnv_MBCSToUnicodeWithOffsets(&subArgs, err);

                subArgs.converter->sharedData = savedSharedData;

                mySource = subArgs.source;
                myTarget = subArgs.target;

                if (U_FAILURE(*err)) {
                    if(*err == U_BUFFER_OVERFLOW_ERROR) {
                        if(subArgs.converter->UCharErrorBufferLength > 0) {
                            uprv_memcpy(args->converter->UCharErrorBuffer, subArgs.converter->UCharErrorBuffer,
                                        subArgs.converter->UCharErrorBufferLength);
                        }
                        args->converter->UCharErrorBufferLength=subArgs.converter->UCharErrorBufferLength;
                        subArgs.converter->UCharErrorBufferLength = 0;
                    }
                    break;
                }
            }
        } else {
            *err = U_BUFFER_OVERFLOW_ERROR;
            break;
        }
    }
    myConverterData->state = currentState;
    args->target = myTarget;
    args->source = mySource;
}

static void U_CALLCONV
_CompoundText_GetUnicodeSet(const UConverter *cnv,
                    const USetAdder *sa,
                    UConverterUnicodeSet which,
                    UErrorCode *pErrorCode) {
    UConverterDataCompoundText *myConverterData = (UConverterDataCompoundText *)cnv->extraInfo;
    int32_t i;

    for (i = 1; i < NUM_OF_CONVERTERS; i++) {
        ucnv_MBCSGetUnicodeSetForUnicode(myConverterData->myConverterArray[i], sa, which, pErrorCode);
    }
    sa->add(sa->set, 0x0000);
    sa->add(sa->set, 0x0009);
    sa->add(sa->set, 0x000A);
    sa->addRange(sa->set, 0x0020, 0x007F);
    sa->addRange(sa->set, 0x00A0, 0x00FF);
}
U_CDECL_END

static const UConverterImpl _CompoundTextImpl = {

    UCNV_COMPOUND_TEXT,

    nullptr,
    nullptr,

    _CompoundTextOpen,
    _CompoundTextClose,
    _CompoundTextReset,

    UConverter_toUnicode_CompoundText_OFFSETS,
    UConverter_toUnicode_CompoundText_OFFSETS,
    UConverter_fromUnicode_CompoundText_OFFSETS,
    UConverter_fromUnicode_CompoundText_OFFSETS,
    nullptr,

    nullptr,
    _CompoundTextgetName,
    nullptr,
    nullptr,
    _CompoundText_GetUnicodeSet,
    nullptr,
    nullptr
};

static const UConverterStaticData _CompoundTextStaticData = {
    sizeof(UConverterStaticData),
    "COMPOUND_TEXT",
    0,
    UCNV_IBM,
    UCNV_COMPOUND_TEXT,
    1,
    6,
    { 0xef, 0, 0, 0 },
    1,
    false,
    false,
    0,
    0,
    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
};
const UConverterSharedData _CompoundTextData =
        UCNV_IMMUTABLE_SHARED_DATA_INITIALIZER(&_CompoundTextStaticData, &_CompoundTextImpl);

#endif /* #if !UCONFIG_NO_LEGACY_CONVERSION */
                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/icu-small/source/common/ucnv_err.cpp                                               0000664 0000000 0000000 00000043741 14746647661 0022526 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
 *****************************************************************************
 *
 *   Copyright (C) 1998-2016, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *
 *****************************************************************************
 *
 *  ucnv_err.c
 *  Implements error behaviour functions called by T_UConverter_{from,to}Unicode
 *
 *
*   Change history:
*
*   06/29/2000  helena      Major rewrite of the callback APIs.
*/

#include "unicode/utypes.h"

#if !UCONFIG_NO_CONVERSION

#include "unicode/ucnv_err.h"
#include "unicode/ucnv_cb.h"
#include "ucnv_cnv.h"
#include "cmemory.h"
#include "unicode/ucnv.h"
#include "ustrfmt.h"

#define VALUE_STRING_LENGTH 48
/*Magic # 32 = 4(number of char in value string) * 8(max number of bytes per char for any converter) */
#define UNICODE_PERCENT_SIGN_CODEPOINT  0x0025
#define UNICODE_U_CODEPOINT             0x0055
#define UNICODE_X_CODEPOINT             0x0058
#define UNICODE_RS_CODEPOINT            0x005C
#define UNICODE_U_LOW_CODEPOINT         0x0075
#define UNICODE_X_LOW_CODEPOINT         0x0078
#define UNICODE_AMP_CODEPOINT           0x0026
#define UNICODE_HASH_CODEPOINT          0x0023
#define UNICODE_SEMICOLON_CODEPOINT     0x003B
#define UNICODE_PLUS_CODEPOINT          0x002B
#define UNICODE_LEFT_CURLY_CODEPOINT    0x007B
#define UNICODE_RIGHT_CURLY_CODEPOINT   0x007D
#define UNICODE_SPACE_CODEPOINT         0x0020
#define UCNV_PRV_ESCAPE_ICU         0
#define UCNV_PRV_ESCAPE_C           'C'
#define UCNV_PRV_ESCAPE_XML_DEC     'D'
#define UCNV_PRV_ESCAPE_XML_HEX     'X'
#define UCNV_PRV_ESCAPE_JAVA        'J'
#define UCNV_PRV_ESCAPE_UNICODE     'U'
#define UCNV_PRV_ESCAPE_CSS2        'S'
#define UCNV_PRV_STOP_ON_ILLEGAL    'i'

/*
 * IS_DEFAULT_IGNORABLE_CODE_POINT
 * This is to check if a code point has the default ignorable unicode property.
 * As such, this list needs to be updated if the ignorable code point list ever
 * changes.
 * To avoid dependency on other code, this list is hard coded here.
 * When an ignorable code point is found and is unmappable, the default callbacks
 * will ignore them.
 * For a list of the default ignorable code points, use this link:
 * https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5B%3ADI%3A%5D&abb=on&g=&i=
 *
 * This list should be sync with the one in CharsetCallback.java
 */
#define IS_DEFAULT_IGNORABLE_CODE_POINT(c) ( \
    (c == 0x00AD) || \
    (c == 0x034F) || \
    (c == 0x061C) || \
    (c == 0x115F) || \
    (c == 0x1160) || \
    (0x17B4 <= c && c <= 0x17B5) || \
    (0x180B <= c && c <= 0x180F) || \
    (0x200B <= c && c <= 0x200F) || \
    (0x202A <= c && c <= 0x202E) || \
    (0x2060 <= c && c <= 0x206F) || \
    (c == 0x3164) || \
    (0xFE00 <= c && c <= 0xFE0F) || \
    (c == 0xFEFF) || \
    (c == 0xFFA0) || \
    (0xFFF0 <= c && c <= 0xFFF8) || \
    (0x1BCA0 <= c && c <= 0x1BCA3) || \
    (0x1D173 <= c && c <= 0x1D17A) || \
    (0xE0000 <= c && c <= 0xE0FFF))


/*Function Pointer STOPS at the ILLEGAL_SEQUENCE */
U_CAPI void    U_EXPORT2
UCNV_FROM_U_CALLBACK_STOP (
                  const void *context,
                  UConverterFromUnicodeArgs *fromUArgs,
                  const char16_t* codeUnits,
                  int32_t length,
                  UChar32 codePoint,
                  UConverterCallbackReason reason,
                  UErrorCode * err)
{
    (void)context;
    (void)fromUArgs;
    (void)codeUnits;
    (void)length;
    if (reason == UCNV_UNASSIGNED && IS_DEFAULT_IGNORABLE_CODE_POINT(codePoint))
    {
        /*
         * Skip if the codepoint has unicode property of default ignorable.
         */
        *err = U_ZERO_ERROR;
    }
    /* the caller must have set the error code accordingly */
}


/*Function Pointer STOPS at the ILLEGAL_SEQUENCE */
U_CAPI void    U_EXPORT2
UCNV_TO_U_CALLBACK_STOP (
                   const void *context,
                   UConverterToUnicodeArgs *toUArgs,
                   const char* codePoints,
                   int32_t length,
                   UConverterCallbackReason reason,
                   UErrorCode * err)
{
    /* the caller must have set the error code accordingly */
    (void)context; (void)toUArgs; (void)codePoints; (void)length; (void)reason; (void)err;
}

U_CAPI void    U_EXPORT2
UCNV_FROM_U_CALLBACK_SKIP (                  
                  const void *context,
                  UConverterFromUnicodeArgs *fromUArgs,
                  const char16_t* codeUnits,
                  int32_t length,
                  UChar32 codePoint,
                  UConverterCallbackReason reason,
                  UErrorCode * err)
{
    (void)fromUArgs;
    (void)codeUnits;
    (void)length;
    if (reason <= UCNV_IRREGULAR)
    {
        if (reason == UCNV_UNASSIGNED && IS_DEFAULT_IGNORABLE_CODE_POINT(codePoint))
        {
            /*
             * Skip if the codepoint has unicode property of default ignorable.
             */
            *err = U_ZERO_ERROR;
        }
        else if (context == nullptr || (*((char*)context) == UCNV_PRV_STOP_ON_ILLEGAL && reason == UCNV_UNASSIGNED))
        {
            *err = U_ZERO_ERROR;
        }
        /* else the caller must have set the error code accordingly. */
    }
    /* else ignore the reset, close and clone calls. */
}

U_CAPI void    U_EXPORT2
UCNV_FROM_U_CALLBACK_SUBSTITUTE (
                  const void *context,
                  UConverterFromUnicodeArgs *fromArgs,
                  const char16_t* codeUnits,
                  int32_t length,
                  UChar32 codePoint,
                  UConverterCallbackReason reason,
                  UErrorCode * err)
{
    (void)codeUnits;
    (void)length;
    if (reason <= UCNV_IRREGULAR)
    {
        if (reason == UCNV_UNASSIGNED && IS_DEFAULT_IGNORABLE_CODE_POINT(codePoint))
        {
            /*
             * Skip if the codepoint has unicode property of default ignorable.
             */
            *err = U_ZERO_ERROR;
        }
        else if (context == nullptr || (*((char*)context) == UCNV_PRV_STOP_ON_ILLEGAL && reason == UCNV_UNASSIGNED))
        {
            *err = U_ZERO_ERROR;
            ucnv_cbFromUWriteSub(fromArgs, 0, err);
        }
        /* else the caller must have set the error code accordingly. */
    }
    /* else ignore the reset, close and clone calls. */
}

/*uses uprv_itou to get a unicode escape sequence of the offensive sequence,
 *uses a clean copy (resetted) of the converter, to convert that unicode
 *escape sequence to the target codepage (if conversion failure happens then
 *we revert to substituting with subchar)
 */
U_CAPI void    U_EXPORT2
UCNV_FROM_U_CALLBACK_ESCAPE (
                         const void *context,
                         UConverterFromUnicodeArgs *fromArgs,
                         const char16_t *codeUnits,
                         int32_t length,
                         UChar32 codePoint,
                         UConverterCallbackReason reason,
                         UErrorCode * err)
{

  char16_t valueString[VALUE_STRING_LENGTH];
  int32_t valueStringLength = 0;
  int32_t i = 0;

  const char16_t *myValueSource = nullptr;
  UErrorCode err2 = U_ZERO_ERROR;
  UConverterFromUCallback original = nullptr;
  const void *originalContext;

  UConverterFromUCallback ignoredCallback = nullptr;
  const void *ignoredContext;
  
  if (reason > UCNV_IRREGULAR)
  {
      return;
  }
  else if (reason == UCNV_UNASSIGNED && IS_DEFAULT_IGNORABLE_CODE_POINT(codePoint))
  {
      /*
       * Skip if the codepoint has unicode property of default ignorable.
       */
      *err = U_ZERO_ERROR;
      return;
  }

  ucnv_setFromUCallBack (fromArgs->converter,
                     (UConverterFromUCallback) UCNV_FROM_U_CALLBACK_SUBSTITUTE,
                     nullptr,
                     &original,
                     &originalContext,
                     &err2);
  
  if (U_FAILURE (err2))
  {
    *err = err2;
    return;
  } 
  if(context==nullptr)
  { 
      while (i < length)
      {
        valueString[valueStringLength++] = (char16_t) UNICODE_PERCENT_SIGN_CODEPOINT;  /* adding % */
        valueString[valueStringLength++] = (char16_t) UNICODE_U_CODEPOINT; /* adding U */
        valueStringLength += uprv_itou (valueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, (uint16_t)codeUnits[i++], 16, 4);
      }
  }
  else
  {
      switch(*((char*)context))
      {
      case UCNV_PRV_ESCAPE_JAVA:
          while (i < length)
          {
              valueString[valueStringLength++] = (char16_t) UNICODE_RS_CODEPOINT;    /* adding \ */
              valueString[valueStringLength++] = (char16_t) UNICODE_U_LOW_CODEPOINT; /* adding u */
              valueStringLength += uprv_itou (valueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, (uint16_t)codeUnits[i++], 16, 4);
          }
          break;

      case UCNV_PRV_ESCAPE_C:
          valueString[valueStringLength++] = (char16_t) UNICODE_RS_CODEPOINT;    /* adding \ */

          if(length==2){
              valueString[valueStringLength++] = (char16_t) UNICODE_U_CODEPOINT; /* adding U */
              valueStringLength += uprv_itou (valueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, codePoint, 16, 8);

          }
          else{
              valueString[valueStringLength++] = (char16_t) UNICODE_U_LOW_CODEPOINT; /* adding u */
              valueStringLength += uprv_itou (valueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, (uint16_t)codeUnits[0], 16, 4);
          }
          break;

      case UCNV_PRV_ESCAPE_XML_DEC:

          valueString[valueStringLength++] = (char16_t) UNICODE_AMP_CODEPOINT;   /* adding & */
          valueString[valueStringLength++] = (char16_t) UNICODE_HASH_CODEPOINT;  /* adding # */
          if(length==2){
              valueStringLength += uprv_itou (valueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, codePoint, 10, 0);
          }
          else{
              valueStringLength += uprv_itou (valueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, (uint16_t)codeUnits[0], 10, 0);
          }
          valueString[valueStringLength++] = (char16_t) UNICODE_SEMICOLON_CODEPOINT; /* adding ; */
          break;

      case UCNV_PRV_ESCAPE_XML_HEX:

          valueString[valueStringLength++] = (char16_t) UNICODE_AMP_CODEPOINT;   /* adding & */
          valueString[valueStringLength++] = (char16_t) UNICODE_HASH_CODEPOINT;  /* adding # */
          valueString[valueStringLength++] = (char16_t) UNICODE_X_LOW_CODEPOINT; /* adding x */
          if(length==2){
              valueStringLength += uprv_itou (valueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, codePoint, 16, 0);
          }
          else{
              valueStringLength += uprv_itou (valueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, (uint16_t)codeUnits[0], 16, 0);
          }
          valueString[valueStringLength++] = (char16_t) UNICODE_SEMICOLON_CODEPOINT; /* adding ; */
          break;

      case UCNV_PRV_ESCAPE_UNICODE:
          valueString[valueStringLength++] = (char16_t) UNICODE_LEFT_CURLY_CODEPOINT;    /* adding { */
          valueString[valueStringLength++] = (char16_t) UNICODE_U_CODEPOINT;    /* adding U */
          valueString[valueStringLength++] = (char16_t) UNICODE_PLUS_CODEPOINT; /* adding + */
          if (length == 2) {
              valueStringLength += uprv_itou (valueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, codePoint, 16, 4);
          } else {
              valueStringLength += uprv_itou (valueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, (uint16_t)codeUnits[0], 16, 4);
          }
          valueString[valueStringLength++] = (char16_t) UNICODE_RIGHT_CURLY_CODEPOINT;    /* adding } */
          break;

      case UCNV_PRV_ESCAPE_CSS2:
          valueString[valueStringLength++] = (char16_t) UNICODE_RS_CODEPOINT;    /* adding \ */
          valueStringLength += uprv_itou (valueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, codePoint, 16, 0);
          /* Always add space character, because the next character might be whitespace,
             which would erroneously be considered the termination of the escape sequence. */
          valueString[valueStringLength++] = (char16_t) UNICODE_SPACE_CODEPOINT;
          break;

      default:
          while (i < length)
          {
              valueString[valueStringLength++] = (char16_t) UNICODE_PERCENT_SIGN_CODEPOINT;  /* adding % */
              valueString[valueStringLength++] = (char16_t) UNICODE_U_CODEPOINT;             /* adding U */
              valueStringLength += uprv_itou (valueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, (uint16_t)codeUnits[i++], 16, 4);
          }
      }
  }  
  myValueSource = valueString;

  /* reset the error */
  *err = U_ZERO_ERROR;

  ucnv_cbFromUWriteUChars(fromArgs, &myValueSource, myValueSource+valueStringLength, 0, err);

  ucnv_setFromUCallBack (fromArgs->converter,
                         original,
                         originalContext,
                         &ignoredCallback,
                         &ignoredContext,
                         &err2);
  if (U_FAILURE (err2))
  {
      *err = err2;
      return;
  }
}



U_CAPI void  U_EXPORT2
UCNV_TO_U_CALLBACK_SKIP (
                 const void *context,
                 UConverterToUnicodeArgs *toArgs,
                 const char* codeUnits,
                 int32_t length,
                 UConverterCallbackReason reason,
                 UErrorCode * err)
{
    (void)toArgs;
    (void)codeUnits;
    (void)length;
    if (reason <= UCNV_IRREGULAR)
    {
        if (context == nullptr || (*((char*)context) == UCNV_PRV_STOP_ON_ILLEGAL && reason == UCNV_UNASSIGNED))
        {
            *err = U_ZERO_ERROR;
        }
        /* else the caller must have set the error code accordingly. */
    }
    /* else ignore the reset, close and clone calls. */
}

U_CAPI void    U_EXPORT2
UCNV_TO_U_CALLBACK_SUBSTITUTE (
                 const void *context,
                 UConverterToUnicodeArgs *toArgs,
                 const char* codeUnits,
                 int32_t length,
                 UConverterCallbackReason reason,
                 UErrorCode * err)
{
    (void)codeUnits;
    (void)length;
    if (reason <= UCNV_IRREGULAR)
    {
        if (context == nullptr || (*((char*)context) == UCNV_PRV_STOP_ON_ILLEGAL && reason == UCNV_UNASSIGNED))
        {
            *err = U_ZERO_ERROR;
            ucnv_cbToUWriteSub(toArgs,0,err);
        }
        /* else the caller must have set the error code accordingly. */
    }
    /* else ignore the reset, close and clone calls. */
}

/*uses uprv_itou to get a unicode escape sequence of the offensive sequence,
 *and uses that as the substitution sequence
 */
U_CAPI void   U_EXPORT2
UCNV_TO_U_CALLBACK_ESCAPE (
                 const void *context,
                 UConverterToUnicodeArgs *toArgs,
                 const char* codeUnits,
                 int32_t length,
                 UConverterCallbackReason reason,
                 UErrorCode * err)
{
    char16_t uniValueString[VALUE_STRING_LENGTH];
    int32_t valueStringLength = 0;
    int32_t i = 0;

    if (reason > UCNV_IRREGULAR)
    {
        return;
    }

    if(context==nullptr)
    {    
        while (i < length)
        {
            uniValueString[valueStringLength++] = (char16_t) UNICODE_PERCENT_SIGN_CODEPOINT; /* adding % */
            uniValueString[valueStringLength++] = (char16_t) UNICODE_X_CODEPOINT;    /* adding X */
            valueStringLength += uprv_itou (uniValueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, (uint8_t) codeUnits[i++], 16, 2);
        }
    }
    else
    {
        switch(*((char*)context))
        {
        case UCNV_PRV_ESCAPE_XML_DEC:
            while (i < length)
            {
                uniValueString[valueStringLength++] = (char16_t) UNICODE_AMP_CODEPOINT;   /* adding & */
                uniValueString[valueStringLength++] = (char16_t) UNICODE_HASH_CODEPOINT;  /* adding # */
                valueStringLength += uprv_itou (uniValueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, (uint8_t)codeUnits[i++], 10, 0);
                uniValueString[valueStringLength++] = (char16_t) UNICODE_SEMICOLON_CODEPOINT; /* adding ; */
            }
            break;

        case UCNV_PRV_ESCAPE_XML_HEX:
            while (i < length)
            {
                uniValueString[valueStringLength++] = (char16_t) UNICODE_AMP_CODEPOINT;   /* adding & */
                uniValueString[valueStringLength++] = (char16_t) UNICODE_HASH_CODEPOINT;  /* adding # */
                uniValueString[valueStringLength++] = (char16_t) UNICODE_X_LOW_CODEPOINT; /* adding x */
                valueStringLength += uprv_itou (uniValueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, (uint8_t)codeUnits[i++], 16, 0);
                uniValueString[valueStringLength++] = (char16_t) UNICODE_SEMICOLON_CODEPOINT; /* adding ; */
            }
            break;
        case UCNV_PRV_ESCAPE_C:
            while (i < length)
            {
                uniValueString[valueStringLength++] = (char16_t) UNICODE_RS_CODEPOINT;    /* adding \ */
                uniValueString[valueStringLength++] = (char16_t) UNICODE_X_LOW_CODEPOINT; /* adding x */
                valueStringLength += uprv_itou (uniValueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, (uint8_t)codeUnits[i++], 16, 2);
            }
            break;
        default:
            while (i < length)
            {
                uniValueString[valueStringLength++] = (char16_t) UNICODE_PERCENT_SIGN_CODEPOINT; /* adding % */
                uniValueString[valueStringLength++] = (char16_t) UNICODE_X_CODEPOINT;    /* adding X */
                uprv_itou (uniValueString + valueStringLength, VALUE_STRING_LENGTH - valueStringLength, (uint8_t) codeUnits[i++], 16, 2);
                valueStringLength += 2;
            }
        }
    }
    /* reset the error */
    *err = U_ZERO_ERROR;

    ucnv_cbToUWriteUChars(toArgs, uniValueString, valueStringLength, 0, err);
}

#endif
                               node-23.7.0/deps/icu-small/source/common/ucnv_ext.cpp                                               0000664 0000000 0000000 00000116513 14746647661 0022534 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 2003-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*   file name:  ucnv_ext.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2003jun13
*   created by: Markus W. Scherer
*
*   Conversion extensions
*/

#include "unicode/utypes.h"

#if !UCONFIG_NO_CONVERSION && !UCONFIG_NO_LEGACY_CONVERSION

#include "unicode/uset.h"
#include "unicode/ustring.h"
#include "ucnv_bld.h"
#include "ucnv_cnv.h"
#include "ucnv_ext.h"
#include "cmemory.h"
#include "uassert.h"

/* to Unicode --------------------------------------------------------------- */

/*
 * @return lookup value for the byte, if found; else 0
 */
static inline uint32_t
ucnv_extFindToU(const uint32_t *toUSection, int32_t length, uint8_t byte) {
    uint32_t word0, word;
    int32_t i, start, limit;

    /* check the input byte against the lowest and highest section bytes */
    start = static_cast<int32_t>(UCNV_EXT_TO_U_GET_BYTE(toUSection[0]));
    limit = static_cast<int32_t>(UCNV_EXT_TO_U_GET_BYTE(toUSection[length - 1]));
    if(byte<start || limit<byte) {
        return 0; /* the byte is out of range */
    }

    if(length==((limit-start)+1)) {
        /* direct access on a linear array */
        return UCNV_EXT_TO_U_GET_VALUE(toUSection[byte-start]); /* could be 0 */
    }

    /* word0 is suitable for <=toUSection[] comparison, word for <toUSection[] */
    word0=UCNV_EXT_TO_U_MAKE_WORD(byte, 0);

    /*
     * Shift byte once instead of each section word and add 0xffffff.
     * We will compare the shifted/added byte (bbffffff) against
     * section words which have byte values in the same bit position.
     * If and only if byte bb < section byte ss then bbffffff<ssvvvvvv
     * for all v=0..f
     * so we need not mask off the lower 24 bits of each section word.
     */
    word=word0|UCNV_EXT_TO_U_VALUE_MASK;

    /* binary search */
    start=0;
    limit=length;
    for(;;) {
        i=limit-start;
        if(i<=1) {
            break; /* done */
        }
        /* start<limit-1 */

        if(i<=4) {
            /* linear search for the last part */
            if(word0<=toUSection[start]) {
                break;
            }
            if(++start<limit && word0<=toUSection[start]) {
                break;
            }
            if(++start<limit && word0<=toUSection[start]) {
                break;
            }
            /* always break at start==limit-1 */
            ++start;
            break;
        }

        i=(start+limit)/2;
        if(word<toUSection[i]) {
            limit=i;
        } else {
            start=i;
        }
    }

    /* did we really find it? */
    if(start<limit && byte==UCNV_EXT_TO_U_GET_BYTE(word=toUSection[start])) {
        return UCNV_EXT_TO_U_GET_VALUE(word); /* never 0 */
    } else {
        return 0; /* not found */
    }
}

/*
 * true if not an SI/SO stateful converter,
 * or if the match length fits with the current converter state
 */
#define UCNV_EXT_TO_U_VERIFY_SISO_MATCH(sisoState, match) \
    ((sisoState)<0 || ((sisoState)==0) == (match==1))

/*
 * this works like ucnv_extMatchFromU() except
 * - the first character is in pre
 * - no trie is used
 * - the returned matchLength is not offset by 2
 */
static int32_t
ucnv_extMatchToU(const int32_t *cx, int8_t sisoState,
                 const char *pre, int32_t preLength,
                 const char *src, int32_t srcLength,
                 uint32_t *pMatchValue,
                 UBool /*useFallback*/, UBool flush) {
    const uint32_t *toUTable, *toUSection;

    uint32_t value, matchValue;
    int32_t i, j, idx, length, matchLength;
    uint8_t b;

    if(cx==nullptr || cx[UCNV_EXT_TO_U_LENGTH]<=0) {
        return 0; /* no extension data, no match */
    }

    /* initialize */
    toUTable=UCNV_EXT_ARRAY(cx, UCNV_EXT_TO_U_INDEX, uint32_t);
    idx=0;

    matchValue=0;
    i=j=matchLength=0;

    if(sisoState==0) {
        /* SBCS state of an SI/SO stateful converter, look at only exactly 1 byte */
        if(preLength>1) {
            return 0; /* no match of a DBCS sequence in SBCS mode */
        } else if(preLength==1) {
            srcLength=0;
        } else /* preLength==0 */ {
            if(srcLength>1) {
                srcLength=1;
            }
        }
        flush=true;
    }

    /* we must not remember fallback matches when not using fallbacks */

    /* match input units until there is a full match or the input is consumed */
    for(;;) {
        /* go to the next section */
        toUSection=toUTable+idx;

        /* read first pair of the section */
        value=*toUSection++;
        length=UCNV_EXT_TO_U_GET_BYTE(value);
        value=UCNV_EXT_TO_U_GET_VALUE(value);
        if( value!=0 &&
            (UCNV_EXT_TO_U_IS_ROUNDTRIP(value) ||
             TO_U_USE_FALLBACK(useFallback)) &&
            UCNV_EXT_TO_U_VERIFY_SISO_MATCH(sisoState, i+j)
        ) {
            /* remember longest match so far */
            matchValue=value;
            matchLength=i+j;
        }

        /* match pre[] then src[] */
        if(i<preLength) {
            b = static_cast<uint8_t>(pre[i++]);
        } else if(j<srcLength) {
            b = static_cast<uint8_t>(src[j++]);
        } else {
            /* all input consumed, partial match */
            if(flush || (length=(i+j))>UCNV_EXT_MAX_BYTES) {
                /*
                 * end of the entire input stream, stop with the longest match so far
                 * or: partial match must not be longer than UCNV_EXT_MAX_BYTES
                 * because it must fit into state buffers
                 */
                break;
            } else {
                /* continue with more input next time */
                return -length;
            }
        }

        /* search for the current char16_t */
        value=ucnv_extFindToU(toUSection, length, b);
        if(value==0) {
            /* no match here, stop with the longest match so far */
            break;
        } else {
            if(UCNV_EXT_TO_U_IS_PARTIAL(value)) {
                /* partial match, continue */
                idx = static_cast<int32_t>(UCNV_EXT_TO_U_GET_PARTIAL_INDEX(value));
            } else {
                if( (UCNV_EXT_TO_U_IS_ROUNDTRIP(value) ||
                     TO_U_USE_FALLBACK(useFallback)) &&
                    UCNV_EXT_TO_U_VERIFY_SISO_MATCH(sisoState, i+j)
                ) {
                    /* full match, stop with result */
                    matchValue=value;
                    matchLength=i+j;
                } else {
                    /* full match on fallback not taken, stop with the longest match so far */
                }
                break;
            }
        }
    }

    if(matchLength==0) {
        /* no match at all */
        return 0;
    }

    /* return result */
    *pMatchValue=UCNV_EXT_TO_U_MASK_ROUNDTRIP(matchValue);
    return matchLength;
}

static inline void
ucnv_extWriteToU(UConverter *cnv, const int32_t *cx,
                 uint32_t value,
                 char16_t **target, const char16_t *targetLimit,
                 int32_t **offsets, int32_t srcIndex,
                 UErrorCode *pErrorCode) {
    /* output the result */
    if(UCNV_EXT_TO_U_IS_CODE_POINT(value)) {
        /* output a single code point */
        ucnv_toUWriteCodePoint(
            cnv, UCNV_EXT_TO_U_GET_CODE_POINT(value),
            target, targetLimit,
            offsets, srcIndex,
            pErrorCode);
    } else {
        /* output a string - with correct data we have resultLength>0 */
        ucnv_toUWriteUChars(
            cnv,
            UCNV_EXT_ARRAY(cx, UCNV_EXT_TO_U_UCHARS_INDEX, char16_t)+
                UCNV_EXT_TO_U_GET_INDEX(value),
            UCNV_EXT_TO_U_GET_LENGTH(value),
            target, targetLimit,
            offsets, srcIndex,
            pErrorCode);
    }
}

/*
 * get the SI/SO toU state (state 0 is for SBCS, 1 for DBCS),
 * or 1 for DBCS-only,
 * or -1 if the converter is not SI/SO stateful
 *
 * Note: For SI/SO stateful converters getting here,
 * cnv->mode==0 is equivalent to firstLength==1.
 */
#define UCNV_SISO_STATE(cnv) \
    ((cnv)->sharedData->mbcs.outputType==MBCS_OUTPUT_2_SISO ? (int8_t)(cnv)->mode : \
     (cnv)->sharedData->mbcs.outputType==MBCS_OUTPUT_DBCS_ONLY ? 1 : -1)

/*
 * target<targetLimit; set error code for overflow
 */
U_CFUNC UBool
ucnv_extInitialMatchToU(UConverter *cnv, const int32_t *cx,
                        int32_t firstLength,
                        const char **src, const char *srcLimit,
                        char16_t **target, const char16_t *targetLimit,
                        int32_t **offsets, int32_t srcIndex,
                        UBool flush,
                        UErrorCode *pErrorCode) {
    uint32_t value = 0;  /* initialize output-only param to 0 to silence gcc */
    int32_t match;

    /* try to match */
    match=ucnv_extMatchToU(cx, (int8_t)UCNV_SISO_STATE(cnv),
                           (const char *)cnv->toUBytes, firstLength,
                           *src, (int32_t)(srcLimit-*src),
                           &value,
                           cnv->useFallback, flush);
    if(match>0) {
        /* advance src pointer for the consumed input */
        *src+=match-firstLength;

        /* write result to target */
        ucnv_extWriteToU(cnv, cx,
                         value,
                         target, targetLimit,
                         offsets, srcIndex,
                         pErrorCode);
        return true;
    } else if(match<0) {
        /* save state for partial match */
        const char *s;
        int32_t j;

        /* copy the first code point */
        s=(const char *)cnv->toUBytes;
        cnv->preToUFirstLength=(int8_t)firstLength;
        for(j=0; j<firstLength; ++j) {
            cnv->preToU[j]=*s++;
        }

        /* now copy the newly consumed input */
        s=*src;
        match=-match;
        for(; j<match; ++j) {
            cnv->preToU[j]=*s++;
        }
        *src=s; /* same as *src=srcLimit; because we reached the end of input */
        cnv->preToULength=(int8_t)match;
        return true;
    } else /* match==0 no match */ {
        return false;
    }
}

U_CFUNC UChar32
ucnv_extSimpleMatchToU(const int32_t *cx,
                       const char *source, int32_t length,
                       UBool useFallback) {
    uint32_t value = 0;  /* initialize output-only param to 0 to silence gcc */
    int32_t match;

    if(length<=0) {
        return 0xffff;
    }

    /* try to match */
    match=ucnv_extMatchToU(cx, -1,
                           source, length,
                           nullptr, 0,
                           &value,
                           useFallback, true);
    if(match==length) {
        /* write result for simple, single-character conversion */
        if(UCNV_EXT_TO_U_IS_CODE_POINT(value)) {
            return UCNV_EXT_TO_U_GET_CODE_POINT(value);
        }
    }

    /*
     * return no match because
     * - match>0 && value points to string: simple conversion cannot handle multiple code points
     * - match>0 && match!=length: not all input consumed, forbidden for this function
     * - match==0: no match found in the first place
     * - match<0: partial match, not supported for simple conversion (and flush==true)
     */
    return 0xfffe;
}

/*
 * continue partial match with new input
 * never called for simple, single-character conversion
 */
U_CFUNC void
ucnv_extContinueMatchToU(UConverter *cnv,
                         UConverterToUnicodeArgs *pArgs, int32_t srcIndex,
                         UErrorCode *pErrorCode) {
    uint32_t value = 0;  /* initialize output-only param to 0 to silence gcc */
    int32_t match, length;

    match=ucnv_extMatchToU(cnv->sharedData->mbcs.extIndexes, (int8_t)UCNV_SISO_STATE(cnv),
                           cnv->preToU, cnv->preToULength,
                           pArgs->source, (int32_t)(pArgs->sourceLimit-pArgs->source),
                           &value,
                           cnv->useFallback, pArgs->flush);
    if(match>0) {
        if(match>=cnv->preToULength) {
            /* advance src pointer for the consumed input */
            pArgs->source+=match-cnv->preToULength;
            cnv->preToULength=0;
        } else {
            /* the match did not use all of preToU[] - keep the rest for replay */
            length=cnv->preToULength-match;
            uprv_memmove(cnv->preToU, cnv->preToU+match, length);
            cnv->preToULength=(int8_t)-length;
        }

        /* write result */
        ucnv_extWriteToU(cnv, cnv->sharedData->mbcs.extIndexes,
                         value,
                         &pArgs->target, pArgs->targetLimit,
                         &pArgs->offsets, srcIndex,
                         pErrorCode);
    } else if(match<0) {
        /* save state for partial match */
        const char *s;
        int32_t j;

        /* just _append_ the newly consumed input to preToU[] */
        s=pArgs->source;
        match=-match;
        for(j=cnv->preToULength; j<match; ++j) {
            cnv->preToU[j]=*s++;
        }
        pArgs->source=s; /* same as *src=srcLimit; because we reached the end of input */
        cnv->preToULength=(int8_t)match;
    } else /* match==0 */ {
        /*
         * no match
         *
         * We need to split the previous input into two parts:
         *
         * 1. The first codepage character is unmappable - that's how we got into
         *    trying the extension data in the first place.
         *    We need to move it from the preToU buffer
         *    to the error buffer, set an error code,
         *    and prepare the rest of the previous input for 2.
         *
         * 2. The rest of the previous input must be converted once we
         *    come back from the callback for the first character.
         *    At that time, we have to try again from scratch to convert
         *    these input characters.
         *    The replay will be handled by the ucnv.c conversion code.
         */

        /* move the first codepage character to the error field */
        uprv_memcpy(cnv->toUBytes, cnv->preToU, cnv->preToUFirstLength);
        cnv->toULength=cnv->preToUFirstLength;

        /* move the rest up inside the buffer */
        length=cnv->preToULength-cnv->preToUFirstLength;
        if(length>0) {
            uprv_memmove(cnv->preToU, cnv->preToU+cnv->preToUFirstLength, length);
        }

        /* mark preToU for replay */
        cnv->preToULength=(int8_t)-length;

        /* set the error code for unassigned */
        *pErrorCode=U_INVALID_CHAR_FOUND;
    }
}

/* from Unicode ------------------------------------------------------------- */

// Use roundtrips, "good one-way" mappings, and some normal fallbacks.
static inline UBool
extFromUUseMapping(UBool useFallback, uint32_t value, UChar32 firstCP) {
    return
        ((value&UCNV_EXT_FROM_U_STATUS_MASK)!=0 ||
            FROM_U_USE_FALLBACK(useFallback, firstCP)) &&
        (value&UCNV_EXT_FROM_U_RESERVED_MASK)==0;
}

/*
 * @return index of the char16_t, if found; else <0
 */
static inline int32_t
ucnv_extFindFromU(const char16_t *fromUSection, int32_t length, char16_t u) {
    int32_t i, start, limit;

    /* binary search */
    start=0;
    limit=length;
    for(;;) {
        i=limit-start;
        if(i<=1) {
            break; /* done */
        }
        /* start<limit-1 */

        if(i<=4) {
            /* linear search for the last part */
            if(u<=fromUSection[start]) {
                break;
            }
            if(++start<limit && u<=fromUSection[start]) {
                break;
            }
            if(++start<limit && u<=fromUSection[start]) {
                break;
            }
            /* always break at start==limit-1 */
            ++start;
            break;
        }

        i=(start+limit)/2;
        if(u<fromUSection[i]) {
            limit=i;
        } else {
            start=i;
        }
    }

    /* did we really find it? */
    if(start<limit && u==fromUSection[start]) {
        return start;
    } else {
        return -1; /* not found */
    }
}

/*
 * @param cx pointer to extension data; if nullptr, returns 0
 * @param firstCP the first code point before all the other UChars
 * @param pre UChars that must match; !initialMatch: partial match with them
 * @param preLength length of pre, >=0
 * @param src UChars that can be used to complete a match
 * @param srcLength length of src, >=0
 * @param pMatchValue [out] output result value for the match from the data structure
 * @param useFallback "use fallback" flag, usually from cnv->useFallback
 * @param flush true if the end of the input stream is reached
 * @return >1: matched, return value=total match length (number of input units matched)
 *          1: matched, no mapping but request for <subchar1>
 *             (only for the first code point)
 *          0: no match
 *         <0: partial match, return value=negative total match length
 *             (partial matches are never returned for flush==true)
 *             (partial matches are never returned as being longer than UCNV_EXT_MAX_UCHARS)
 *         the matchLength is 2 if only firstCP matched, and >2 if firstCP and
 *         further code units matched
 */
static int32_t
ucnv_extMatchFromU(const int32_t *cx,
                   UChar32 firstCP,
                   const char16_t *pre, int32_t preLength,
                   const char16_t *src, int32_t srcLength,
                   uint32_t *pMatchValue,
                   UBool useFallback, UBool flush) {
    const uint16_t *stage12, *stage3;
    const uint32_t *stage3b;

    const char16_t *fromUTableUChars, *fromUSectionUChars;
    const uint32_t *fromUTableValues, *fromUSectionValues;

    uint32_t value, matchValue;
    int32_t i, j, idx, length, matchLength;
    char16_t c;

    if(cx==nullptr) {
        return 0; /* no extension data, no match */
    }

    /* trie lookup of firstCP */
    idx=firstCP>>10; /* stage 1 index */
    if(idx>=cx[UCNV_EXT_FROM_U_STAGE_1_LENGTH]) {
        return 0; /* the first code point is outside the trie */
    }

    stage12=UCNV_EXT_ARRAY(cx, UCNV_EXT_FROM_U_STAGE_12_INDEX, uint16_t);
    stage3=UCNV_EXT_ARRAY(cx, UCNV_EXT_FROM_U_STAGE_3_INDEX, uint16_t);
    idx=UCNV_EXT_FROM_U(stage12, stage3, idx, firstCP);

    stage3b=UCNV_EXT_ARRAY(cx, UCNV_EXT_FROM_U_STAGE_3B_INDEX, uint32_t);
    value=stage3b[idx];
    if(value==0) {
        return 0;
    }

    /*
     * Tests for (value&UCNV_EXT_FROM_U_RESERVED_MASK)==0:
     * Do not interpret values with reserved bits used, for forward compatibility,
     * and do not even remember intermediate results with reserved bits used.
     */

    if(UCNV_EXT_TO_U_IS_PARTIAL(value)) {
        /* partial match, enter the loop below */
        idx = static_cast<int32_t>(UCNV_EXT_FROM_U_GET_PARTIAL_INDEX(value));

        /* initialize */
        fromUTableUChars=UCNV_EXT_ARRAY(cx, UCNV_EXT_FROM_U_UCHARS_INDEX, char16_t);
        fromUTableValues=UCNV_EXT_ARRAY(cx, UCNV_EXT_FROM_U_VALUES_INDEX, uint32_t);

        matchValue=0;
        i=j=matchLength=0;

        /* we must not remember fallback matches when not using fallbacks */

        /* match input units until there is a full match or the input is consumed */
        for(;;) {
            /* go to the next section */
            fromUSectionUChars=fromUTableUChars+idx;
            fromUSectionValues=fromUTableValues+idx;

            /* read first pair of the section */
            length=*fromUSectionUChars++;
            value=*fromUSectionValues++;
            if(value!=0 && extFromUUseMapping(useFallback, value, firstCP)) {
                /* remember longest match so far */
                matchValue=value;
                matchLength=2+i+j;
            }

            /* match pre[] then src[] */
            if(i<preLength) {
                c=pre[i++];
            } else if(j<srcLength) {
                c=src[j++];
            } else {
                /* all input consumed, partial match */
                if(flush || (length=(i+j))>UCNV_EXT_MAX_UCHARS) {
                    /*
                     * end of the entire input stream, stop with the longest match so far
                     * or: partial match must not be longer than UCNV_EXT_MAX_UCHARS
                     * because it must fit into state buffers
                     */
                    break;
                } else {
                    /* continue with more input next time */
                    return -(2+length);
                }
            }

            /* search for the current char16_t */
            idx=ucnv_extFindFromU(fromUSectionUChars, length, c);
            if(idx<0) {
                /* no match here, stop with the longest match so far */
                break;
            } else {
                value=fromUSectionValues[idx];
                if(UCNV_EXT_FROM_U_IS_PARTIAL(value)) {
                    /* partial match, continue */
                    idx = static_cast<int32_t>(UCNV_EXT_FROM_U_GET_PARTIAL_INDEX(value));
                } else {
                    if(extFromUUseMapping(useFallback, value, firstCP)) {
                        /* full match, stop with result */
                        matchValue=value;
                        matchLength=2+i+j;
                    } else {
                        /* full match on fallback not taken, stop with the longest match so far */
                    }
                    break;
                }
            }
        }

        if(matchLength==0) {
            /* no match at all */
            return 0;
        }
    } else /* result from firstCP trie lookup */ {
        if(extFromUUseMapping(useFallback, value, firstCP)) {
            /* full match, stop with result */
            matchValue=value;
            matchLength=2;
        } else {
            /* fallback not taken */
            return 0;
        }
    }

    /* return result */
    if(matchValue==UCNV_EXT_FROM_U_SUBCHAR1) {
        return 1; /* assert matchLength==2 */
    }

    *pMatchValue=matchValue;
    return matchLength;
}

/*
 * @param value fromUnicode mapping table value; ignores roundtrip and reserved bits
 */
static inline void
ucnv_extWriteFromU(UConverter *cnv, const int32_t *cx,
                   uint32_t value,
                   char **target, const char *targetLimit,
                   int32_t **offsets, int32_t srcIndex,
                   UErrorCode *pErrorCode) {
    uint8_t buffer[1+UCNV_EXT_MAX_BYTES];
    const uint8_t *result;
    int32_t length, prevLength;

    length=UCNV_EXT_FROM_U_GET_LENGTH(value);
    value = UCNV_EXT_FROM_U_GET_DATA(value);

    /* output the result */
    if(length<=UCNV_EXT_FROM_U_MAX_DIRECT_LENGTH) {
        /*
         * Generate a byte array and then write it below.
         * This is not the fastest possible way, but it should be ok for
         * extension mappings, and it is much simpler.
         * Offset and overflow handling are only done once this way.
         */
        uint8_t *p=buffer+1; /* reserve buffer[0] for shiftByte below */
        switch(length) {
        case 3:
            *p++ = static_cast<uint8_t>(value >> 16);
            U_FALLTHROUGH;
        case 2:
            *p++ = static_cast<uint8_t>(value >> 8);
            U_FALLTHROUGH;
        case 1:
            *p++ = static_cast<uint8_t>(value);
            U_FALLTHROUGH;
        default:
            break; /* will never occur */
        }
        result=buffer+1;
    } else {
        result=UCNV_EXT_ARRAY(cx, UCNV_EXT_FROM_U_BYTES_INDEX, uint8_t)+value;
    }

    /* with correct data we have length>0 */

    if((prevLength=cnv->fromUnicodeStatus)!=0) {
        /* handle SI/SO stateful output */
        uint8_t shiftByte;

        if(prevLength>1 && length==1) {
            /* change from double-byte mode to single-byte */
            shiftByte = static_cast<uint8_t>(UCNV_SI);
            cnv->fromUnicodeStatus=1;
        } else if(prevLength==1 && length>1) {
            /* change from single-byte mode to double-byte */
            shiftByte = static_cast<uint8_t>(UCNV_SO);
            cnv->fromUnicodeStatus=2;
        } else {
            shiftByte=0;
        }

        if(shiftByte!=0) {
            /* prepend the shift byte to the result bytes */
            buffer[0]=shiftByte;
            if(result!=buffer+1) {
                uprv_memcpy(buffer+1, result, length);
            }
            result=buffer;
            ++length;
        }
    }

    ucnv_fromUWriteBytes(cnv, reinterpret_cast<const char*>(result), length,
                         target, targetLimit,
                         offsets, srcIndex,
                         pErrorCode);
}

/*
 * target<targetLimit; set error code for overflow
 */
U_CFUNC UBool
ucnv_extInitialMatchFromU(UConverter *cnv, const int32_t *cx,
                          UChar32 cp,
                          const char16_t **src, const char16_t *srcLimit,
                          char **target, const char *targetLimit,
                          int32_t **offsets, int32_t srcIndex,
                          UBool flush,
                          UErrorCode *pErrorCode) {
    uint32_t value = 0;  /* initialize output-only param to 0 to silence gcc */
    int32_t match;

    /* try to match */
    match=ucnv_extMatchFromU(cx, cp,
                             nullptr, 0,
                             *src, (int32_t)(srcLimit-*src),
                             &value,
                             cnv->useFallback, flush);

    /* reject a match if the result is a single byte for DBCS-only */
    if( match>=2 &&
        !(UCNV_EXT_FROM_U_GET_LENGTH(value)==1 &&
          cnv->sharedData->mbcs.outputType==MBCS_OUTPUT_DBCS_ONLY)
    ) {
        /* advance src pointer for the consumed input */
        *src+=match-2; /* remove 2 for the initial code point */

        /* write result to target */
        ucnv_extWriteFromU(cnv, cx,
                           value,
                           target, targetLimit,
                           offsets, srcIndex,
                           pErrorCode);
        return true;
    } else if(match<0) {
        /* save state for partial match */
        const char16_t *s;
        int32_t j;

        /* copy the first code point */
        cnv->preFromUFirstCP=cp;

        /* now copy the newly consumed input */
        s=*src;
        match=-match-2; /* remove 2 for the initial code point */
        for(j=0; j<match; ++j) {
            cnv->preFromU[j]=*s++;
        }
        *src=s; /* same as *src=srcLimit; because we reached the end of input */
        cnv->preFromULength=(int8_t)match;
        return true;
    } else if(match==1) {
        /* matched, no mapping but request for <subchar1> */
        cnv->useSubChar1=true;
        return false;
    } else /* match==0 no match */ {
        return false;
    }
}

/*
 * Used by ISO 2022 implementation.
 * @return number of bytes in *pValue; negative number if fallback; 0 for no mapping
 */
U_CFUNC int32_t
ucnv_extSimpleMatchFromU(const int32_t *cx,
                         UChar32 cp, uint32_t *pValue,
                         UBool useFallback) {
    uint32_t value;
    int32_t match;

    /* try to match */
    match=ucnv_extMatchFromU(cx,
                             cp,
                             nullptr, 0,
                             nullptr, 0,
                             &value,
                             useFallback, true);
    if(match>=2) {
        /* write result for simple, single-character conversion */
        int32_t length;
        int isRoundtrip;

        isRoundtrip=UCNV_EXT_FROM_U_IS_ROUNDTRIP(value);
        length=UCNV_EXT_FROM_U_GET_LENGTH(value);
        value = UCNV_EXT_FROM_U_GET_DATA(value);

        if(length<=UCNV_EXT_FROM_U_MAX_DIRECT_LENGTH) {
            *pValue=value;
            return isRoundtrip ? length : -length;
#if 0 /* not currently used */
        } else if(length==4) {
            /* de-serialize a 4-byte result */
            const uint8_t *result=UCNV_EXT_ARRAY(cx, UCNV_EXT_FROM_U_BYTES_INDEX, uint8_t)+value;
            *pValue=
                ((uint32_t)result[0]<<24)|
                ((uint32_t)result[1]<<16)|
                ((uint32_t)result[2]<<8)|
                result[3];
            return isRoundtrip ? 4 : -4;
#endif
        }
    }

    /*
     * return no match because
     * - match>1 && resultLength>4: result too long for simple conversion
     * - match==1: no match found, <subchar1> preferred
     * - match==0: no match found in the first place
     * - match<0: partial match, not supported for simple conversion (and flush==true)
     */
    return 0;
}

/*
 * continue partial match with new input, requires cnv->preFromUFirstCP>=0
 * never called for simple, single-character conversion
 */
U_CFUNC void
ucnv_extContinueMatchFromU(UConverter *cnv,
                           UConverterFromUnicodeArgs *pArgs, int32_t srcIndex,
                           UErrorCode *pErrorCode) {
    uint32_t value = 0;  /* initialize output-only param to 0 to silence gcc */
    int32_t match;

    match=ucnv_extMatchFromU(cnv->sharedData->mbcs.extIndexes,
                             cnv->preFromUFirstCP,
                             cnv->preFromU, cnv->preFromULength,
                             pArgs->source, (int32_t)(pArgs->sourceLimit-pArgs->source),
                             &value,
                             cnv->useFallback, pArgs->flush);
    if(match>=2) {
        match-=2; /* remove 2 for the initial code point */

        if(match>=cnv->preFromULength) {
            /* advance src pointer for the consumed input */
            pArgs->source+=match-cnv->preFromULength;
            cnv->preFromULength=0;
        } else {
            /* the match did not use all of preFromU[] - keep the rest for replay */
            int32_t length=cnv->preFromULength-match;
            u_memmove(cnv->preFromU, cnv->preFromU+match, length);
            cnv->preFromULength=(int8_t)-length;
        }

        /* finish the partial match */
        cnv->preFromUFirstCP=U_SENTINEL;

        /* write result */
        ucnv_extWriteFromU(cnv, cnv->sharedData->mbcs.extIndexes,
                           value,
                           &pArgs->target, pArgs->targetLimit,
                           &pArgs->offsets, srcIndex,
                           pErrorCode);
    } else if(match<0) {
        /* save state for partial match */
        const char16_t *s;
        int32_t j;

        /* just _append_ the newly consumed input to preFromU[] */
        s=pArgs->source;
        match=-match-2; /* remove 2 for the initial code point */
        for(j=cnv->preFromULength; j<match; ++j) {
            U_ASSERT(j>=0);
            cnv->preFromU[j]=*s++;
        }
        pArgs->source=s; /* same as *src=srcLimit; because we reached the end of input */
        cnv->preFromULength=(int8_t)match;
    } else /* match==0 or 1 */ {
        /*
         * no match
         *
         * We need to split the previous input into two parts:
         *
         * 1. The first code point is unmappable - that's how we got into
         *    trying the extension data in the first place.
         *    We need to move it from the preFromU buffer
         *    to the error buffer, set an error code,
         *    and prepare the rest of the previous input for 2.
         *
         * 2. The rest of the previous input must be converted once we
         *    come back from the callback for the first code point.
         *    At that time, we have to try again from scratch to convert
         *    these input characters.
         *    The replay will be handled by the ucnv.c conversion code.
         */

        if(match==1) {
            /* matched, no mapping but request for <subchar1> */
            cnv->useSubChar1=true;
        }

        /* move the first code point to the error field */
        cnv->fromUChar32=cnv->preFromUFirstCP;
        cnv->preFromUFirstCP=U_SENTINEL;

        /* mark preFromU for replay */
        cnv->preFromULength=-cnv->preFromULength;

        /* set the error code for unassigned */
        *pErrorCode=U_INVALID_CHAR_FOUND;
    }
}

static UBool
extSetUseMapping(UConverterUnicodeSet which, int32_t minLength, uint32_t value) {
    if(which==UCNV_ROUNDTRIP_SET) {
        // Add only code points for which the roundtrip flag is set.
        // Do not add any fallbacks, even if ucnv_fromUnicode() would use them
        // (fallbacks from PUA). See the API docs for ucnv_getUnicodeSet().
        //
        // By analogy, also do not add "good one-way" mappings.
        //
        // Do not add entries with reserved bits set.
        if(((value&(UCNV_EXT_FROM_U_ROUNDTRIP_FLAG|UCNV_EXT_FROM_U_RESERVED_MASK))!=
                UCNV_EXT_FROM_U_ROUNDTRIP_FLAG)) {
            return false;
        }
    } else /* UCNV_ROUNDTRIP_AND_FALLBACK_SET */ {
        // Do not add entries with reserved bits set.
        if((value&UCNV_EXT_FROM_U_RESERVED_MASK)!=0) {
            return false;
        }
    }
    // Do not add <subchar1> entries or other (future?) pseudo-entries
    // with an output length of 0.
    return UCNV_EXT_FROM_U_GET_LENGTH(value)>=minLength;
}

static void
ucnv_extGetUnicodeSetString(const UConverterSharedData *sharedData,
                            const int32_t *cx,
                            const USetAdder *sa,
   