 }
    return dest;
}

static void U_CALLCONV
unistrTextClose(UText *ut) {
    // Most of the work of close is done by the generic UText framework close.
    // All that needs to be done here is delete the UnicodeString if the UText
    //  owns it.  This occurs if the UText was created by cloning.
    if (ut->providerProperties & I32_FLAG(UTEXT_PROVIDER_OWNS_TEXT)) {
        UnicodeString *str = (UnicodeString *)ut->context;
        delete str;
        ut->context = nullptr;
    }
}


static int64_t U_CALLCONV
unistrTextLength(UText *t) {
    return ((const UnicodeString *)t->context)->length();
}


static UBool U_CALLCONV
unistrTextAccess(UText *ut, int64_t index, UBool  forward) {
    int32_t length  = ut->chunkLength;
    ut->chunkOffset = pinIndex(index, length);

    // Check whether request is at the start or end
    UBool retVal = (forward && index<length) || (!forward && index>0);
    return retVal;
}



static int32_t U_CALLCONV
unistrTextExtract(UText *t,
                  int64_t start, int64_t limit,
                  char16_t *dest, int32_t destCapacity,
                  UErrorCode *pErrorCode) {
    const UnicodeString *us=(const UnicodeString *)t->context;
    int32_t length=us->length();

    if(U_FAILURE(*pErrorCode)) {
        return 0;
    }
    if(destCapacity<0 || (dest==nullptr && destCapacity>0)) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
    }
    if(start<0 || start>limit) {
        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
        return 0;
    }

    int32_t start32 = start<length ? us->getChar32Start((int32_t)start) : length;
    int32_t limit32 = limit<length ? us->getChar32Start((int32_t)limit) : length;

    length=limit32-start32;
    if (destCapacity>0 && dest!=nullptr) {
        int32_t trimmedLength = length;
        if(trimmedLength>destCapacity) {
            trimmedLength=destCapacity;
        }
        us->extract(start32, trimmedLength, dest);
        t->chunkOffset = start32+trimmedLength;
    } else {
        t->chunkOffset = start32;
    }
    u_terminateUChars(dest, destCapacity, length, pErrorCode);
    return length;
}

static int32_t U_CALLCONV
unistrTextReplace(UText *ut,
                  int64_t start, int64_t limit,
                  const char16_t *src, int32_t length,
                  UErrorCode *pErrorCode) {
    UnicodeString *us=(UnicodeString *)ut->context;
    int32_t oldLength;

    if(U_FAILURE(*pErrorCode)) {
        return 0;
    }
    if(src==nullptr && length!=0) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
    }
    if(start>limit) {
        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
        return 0;
    }
    oldLength=us->length();
    int32_t start32 = pinIndex(start, oldLength);
    int32_t limit32 = pinIndex(limit, oldLength);
    if (start32 < oldLength) {
        start32 = us->getChar32Start(start32);
    }
    if (limit32 < oldLength) {
        limit32 = us->getChar32Start(limit32);
    }

    // replace
    us->replace(start32, limit32-start32, src, length);
    int32_t newLength = us->length();

    // Update the chunk description.
    ut->chunkContents    = us->getBuffer();
    ut->chunkLength      = newLength;
    ut->chunkNativeLimit = newLength;
    ut->nativeIndexingLimit = newLength;

    // Set iteration position to the point just following the newly inserted text.
    int32_t lengthDelta = newLength - oldLength;
    ut->chunkOffset = limit32 + lengthDelta;

    return lengthDelta;
}

static void U_CALLCONV
unistrTextCopy(UText *ut,
               int64_t start, int64_t limit,
               int64_t destIndex,
               UBool move,
               UErrorCode *pErrorCode) {
    UnicodeString *us=(UnicodeString *)ut->context;
    int32_t length=us->length();

    if(U_FAILURE(*pErrorCode)) {
        return;
    }
    int32_t start32 = pinIndex(start, length);
    int32_t limit32 = pinIndex(limit, length);
    int32_t destIndex32 = pinIndex(destIndex, length);

    if( start32>limit32 || (start32<destIndex32 && destIndex32<limit32)) {
        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
        return;
    }

    if(move) {
        // move: copy to destIndex, then remove original
        int32_t segLength=limit32-start32;
        us->copy(start32, limit32, destIndex32);
        if(destIndex32<start32) {
            start32+=segLength;
        }
        us->remove(start32, segLength);
    } else {
        // copy
        us->copy(start32, limit32, destIndex32);
    }

    // update chunk description, set iteration position.
    ut->chunkContents = us->getBuffer();
    if (move==false) {
        // copy operation, string length grows
        ut->chunkLength += limit32-start32;
        ut->chunkNativeLimit = ut->chunkLength;
        ut->nativeIndexingLimit = ut->chunkLength;
    }

    // Iteration position to end of the newly inserted text.
    ut->chunkOffset = destIndex32+limit32-start32;
    if (move && destIndex32>start32) {
        ut->chunkOffset = destIndex32;
    }

}

static const struct UTextFuncs unistrFuncs =
{
    sizeof(UTextFuncs),
    0, 0, 0,             // Reserved alignment padding
    unistrTextClone,
    unistrTextLength,
    unistrTextAccess,
    unistrTextExtract,
    unistrTextReplace,
    unistrTextCopy,
    nullptr,                // MapOffsetToNative,
    nullptr,                // MapIndexToUTF16,
    unistrTextClose,
    nullptr,                // spare 1
    nullptr,                // spare 2
    nullptr                 // spare 3
};



U_CDECL_END


U_CAPI UText * U_EXPORT2
utext_openUnicodeString(UText *ut, UnicodeString *s, UErrorCode *status) {
    ut = utext_openConstUnicodeString(ut, s, status);
    if (U_SUCCESS(*status)) {
        ut->providerProperties |= I32_FLAG(UTEXT_PROVIDER_WRITABLE);
    }
    return ut;
}



U_CAPI UText * U_EXPORT2
utext_openConstUnicodeString(UText *ut, const UnicodeString *s, UErrorCode *status) {
    if (U_SUCCESS(*status) && s->isBogus()) {
        // The UnicodeString is bogus, but we still need to detach the UText
        //   from whatever it was hooked to before, if anything.
        utext_openUChars(ut, nullptr, 0, status);
        *status = U_ILLEGAL_ARGUMENT_ERROR;
        return ut;
    }
    ut = utext_setup(ut, 0, status);
    //    note:  use the standard (writable) function table for UnicodeString.
    //           The flag settings disable writing, so having the functions in
    //           the table is harmless.
    if (U_SUCCESS(*status)) {
        ut->pFuncs              = &unistrFuncs;
        ut->context             = s;
        ut->providerProperties  = I32_FLAG(UTEXT_PROVIDER_STABLE_CHUNKS);
        ut->chunkContents       = s->getBuffer();
        ut->chunkLength         = s->length();
        ut->chunkNativeStart    = 0;
        ut->chunkNativeLimit    = ut->chunkLength;
        ut->nativeIndexingLimit = ut->chunkLength;
    }
    return ut;
}

//------------------------------------------------------------------------------
//
//     UText implementation for const char16_t * strings
//
//         Use of UText data members:
//            context    pointer to UnicodeString
//            a          length.  -1 if not yet known.
//
//         TODO:  support 64 bit lengths.
//
//------------------------------------------------------------------------------

U_CDECL_BEGIN


static UText * U_CALLCONV
ucstrTextClone(UText *dest, const UText * src, UBool deep, UErrorCode * status) {
    // First do a generic shallow clone.
    dest = shallowTextClone(dest, src, status);

    // For deep clones, make a copy of the string.
    //  The copied storage is owned by the newly created clone.
    //  A non-nullptr pointer in UText.p is the signal to the close() function to delete
    //    it.
    //
    if (deep && U_SUCCESS(*status)) {
        U_ASSERT(utext_nativeLength(dest) < INT32_MAX);
        int32_t  len = (int32_t)utext_nativeLength(dest);

        // The cloned string IS going to be NUL terminated, whether or not the original was.
        const char16_t *srcStr = (const char16_t *)src->context;
        char16_t *copyStr = (char16_t *)uprv_malloc((len+1) * sizeof(char16_t));
        if (copyStr == nullptr) {
            *status = U_MEMORY_ALLOCATION_ERROR;
        } else {
            int64_t i;
            for (i=0; i<len; i++) {
                copyStr[i] = srcStr[i];
            }
            copyStr[len] = 0;
            dest->context = copyStr;
            dest->providerProperties |= I32_FLAG(UTEXT_PROVIDER_OWNS_TEXT);
        }
    }
    return dest;
}


static void U_CALLCONV
ucstrTextClose(UText *ut) {
    // Most of the work of close is done by the generic UText framework close.
    // All that needs to be done here is delete the string if the UText
    //  owns it.  This occurs if the UText was created by cloning.
    if (ut->providerProperties & I32_FLAG(UTEXT_PROVIDER_OWNS_TEXT)) {
        char16_t *s = (char16_t *)ut->context;
        uprv_free(s);
        ut->context = nullptr;
    }
}



static int64_t U_CALLCONV
ucstrTextLength(UText *ut) {
    if (ut->a < 0) {
        // null terminated, we don't yet know the length. Scan for it.
        //    Access is not convenient for doing this
        //    because the current iteration position can't be changed.
        const char16_t  *str = (const char16_t *)ut->context;
        for (;;) {
            if (str[ut->chunkNativeLimit] == 0) {
                break;
            }
            ut->chunkNativeLimit++;
        }
        ut->a = ut->chunkNativeLimit;
        ut->chunkLength = (int32_t)ut->chunkNativeLimit;
        ut->nativeIndexingLimit = ut->chunkLength;
        ut->providerProperties &= ~I32_FLAG(UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE);
    }
    return ut->a;
}


static UBool U_CALLCONV
ucstrTextAccess(UText *ut, int64_t index, UBool  forward) {
    const char16_t *str   = (const char16_t *)ut->context;

    // pin the requested index to the bounds of the string,
    //  and set current iteration position.
    if (index<0) {
        index = 0;
    } else if (index < ut->chunkNativeLimit) {
        // The request data is within the chunk as it is known so far.
        // Put index on a code point boundary.
        U16_SET_CP_START(str, 0, index);
    } else if (ut->a >= 0) {
        // We know the length of this string, and the user is requesting something
        // at or beyond the length.  Pin the requested index to the length.
        index = ut->a;
    } else {
        // Null terminated string, length not yet known, and the requested index
        //  is beyond where we have scanned so far.
        //  Scan to 32 UChars beyond the requested index.  The strategy here is
        //  to avoid fully scanning a long string when the caller only wants to
        //  see a few characters at its beginning.
        int32_t scanLimit = (int32_t)index + 32;
        if ((index + 32)>INT32_MAX || (index + 32)<0 ) {   // note: int64 expression
            scanLimit = INT32_MAX;
        }

        int32_t chunkLimit = (int32_t)ut->chunkNativeLimit;
        for (; chunkLimit<scanLimit; chunkLimit++) {
            if (str[chunkLimit] == 0) {
                // We found the end of the string.  Remember it, pin the requested index to it,
                //  and bail out of here.
                ut->a = chunkLimit;
                ut->chunkLength = chunkLimit;
                ut->nativeIndexingLimit = chunkLimit;
                if (index >= chunkLimit) {
                    index = chunkLimit;
                } else {
                    U16_SET_CP_START(str, 0, index);
                }

                ut->chunkNativeLimit = chunkLimit;
                ut->providerProperties &= ~I32_FLAG(UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE);
                goto breakout;
            }
        }
        // We scanned through the next batch of UChars without finding the end.
        U16_SET_CP_START(str, 0, index);
        if (chunkLimit == INT32_MAX) {
            // Scanned to the limit of a 32 bit length.
            // Forceably trim the overlength string back so length fits in int32
            //  TODO:  add support for 64 bit strings.
            ut->a = chunkLimit;
            ut->chunkLength = chunkLimit;
            ut->nativeIndexingLimit = chunkLimit;
            if (index > chunkLimit) {
                index = chunkLimit;
            }
            ut->chunkNativeLimit = chunkLimit;
            ut->providerProperties &= ~I32_FLAG(UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE);
        } else {
            // The endpoint of a chunk must not be left in the middle of a surrogate pair.
            // If the current end is on a lead surrogate, back the end up by one.
            // It doesn't matter if the end char happens to be an unpaired surrogate,
            //    and it's simpler not to worry about it.
            if (U16_IS_LEAD(str[chunkLimit-1])) {
                --chunkLimit;
            }
            // Null-terminated chunk with end still unknown.
            // Update the chunk length to reflect what has been scanned thus far.
            // That the full length is still unknown is (still) flagged by
            //    ut->a being < 0.
            ut->chunkNativeLimit = chunkLimit;
            ut->nativeIndexingLimit = chunkLimit;
            ut->chunkLength = chunkLimit;
        }

    }
breakout:
    U_ASSERT(index<=INT32_MAX);
    ut->chunkOffset = (int32_t)index;

    // Check whether request is at the start or end
    UBool retVal = (forward && index<ut->chunkNativeLimit) || (!forward && index>0);
    return retVal;
}



static int32_t U_CALLCONV
ucstrTextExtract(UText *ut,
                  int64_t start, int64_t limit,
                  char16_t *dest, int32_t destCapacity,
                  UErrorCode *pErrorCode)
{
    if(U_FAILURE(*pErrorCode)) {
        return 0;
    }
    if(destCapacity<0 || (dest==nullptr && destCapacity>0) || start>limit) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }

    //const char16_t *s=(const char16_t *)ut->context;
    int32_t si, di;

    int32_t start32;
    int32_t limit32;

    // Access the start.  Does two things we need:
    //   Pins 'start' to the length of the string, if it came in out-of-bounds.
    //   Snaps 'start' to the beginning of a code point.
    ucstrTextAccess(ut, start, true);
    const char16_t *s=ut->chunkContents;
    start32 = ut->chunkOffset;

    int32_t strLength=(int32_t)ut->a;
    if (strLength >= 0) {
        limit32 = pinIndex(limit, strLength);
    } else {
        limit32 = pinIndex(limit, INT32_MAX);
    }
    di = 0;
    for (si=start32; si<limit32; si++) {
        if (strLength<0 && s[si]==0) {
            // Just hit the end of a null-terminated string.
            ut->a = si;               // set string length for this UText
            ut->chunkNativeLimit    = si;
            ut->chunkLength         = si;
            ut->nativeIndexingLimit = si;
            strLength               = si;
            limit32                 = si;
            break;
        }
        U_ASSERT(di>=0); /* to ensure di never exceeds INT32_MAX, which must not happen logically */
        if (di<destCapacity) {
            // only store if there is space.
            dest[di] = s[si];
        } else {
            if (strLength>=0) {
                // We have filled the destination buffer, and the string length is known.
                //  Cut the loop short.  There is no need to scan string termination.
                di = limit32 - start32;
                si = limit32;
                break;
            }
        }
        di++;
    }

    // If the limit index points to a lead surrogate of a pair,
    //   add the corresponding trail surrogate to the destination.
    if (si>0 && U16_IS_LEAD(s[si-1]) &&
            ((si<strLength || strLength<0)  && U16_IS_TRAIL(s[si])))
    {
        if (di<destCapacity) {
            // store only if there is space in the output buffer.
            dest[di++] = s[si];
        }
        si++;
    }

    // Put iteration position at the point just following the extracted text
    if (si <= ut->chunkNativeLimit) {
        ut->chunkOffset = si;
    } else {
        ucstrTextAccess(ut, si, true);
    }

    // Add a terminating NUL if space in the buffer permits,
    // and set the error status as required.
    u_terminateUChars(dest, destCapacity, di, pErrorCode);
    return di;
}

static const struct UTextFuncs ucstrFuncs =
{
    sizeof(UTextFuncs),
    0, 0, 0,           // Reserved alignment padding
    ucstrTextClone,
    ucstrTextLength,
    ucstrTextAccess,
    ucstrTextExtract,
    nullptr,              // Replace
    nullptr,              // Copy
    nullptr,              // MapOffsetToNative,
    nullptr,              // MapIndexToUTF16,
    ucstrTextClose,
    nullptr,              // spare 1
    nullptr,              // spare 2
    nullptr,              // spare 3
};

U_CDECL_END

static const char16_t gEmptyUString[] = {0};

U_CAPI UText * U_EXPORT2
utext_openUChars(UText *ut, const char16_t *s, int64_t length, UErrorCode *status) {
    if (U_FAILURE(*status)) {
        return nullptr;
    }
    if(s==nullptr && length==0) {
        s = gEmptyUString;
    }
    if (s==nullptr || length < -1 || length>INT32_MAX) {
        *status = U_ILLEGAL_ARGUMENT_ERROR;
        return nullptr;
    }
    ut = utext_setup(ut, 0, status);
    if (U_SUCCESS(*status)) {
        ut->pFuncs               = &ucstrFuncs;
        ut->context              = s;
        ut->providerProperties   = I32_FLAG(UTEXT_PROVIDER_STABLE_CHUNKS);
        if (length==-1) {
            ut->providerProperties |= I32_FLAG(UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE);
        }
        ut->a                    = length;
        ut->chunkContents        = s;
        ut->chunkNativeStart     = 0;
        ut->chunkNativeLimit     = length>=0? length : 0;
        ut->chunkLength          = (int32_t)ut->chunkNativeLimit;
        ut->chunkOffset          = 0;
        ut->nativeIndexingLimit  = ut->chunkLength;
    }
    return ut;
}


//------------------------------------------------------------------------------
//
//     UText implementation for text from ICU CharacterIterators
//
//         Use of UText data members:
//            context    pointer to the CharacterIterator
//            a          length of the full text.
//            p          pointer to  buffer 1
//            b          start index of local buffer 1 contents
//            q          pointer to buffer 2
//            c          start index of local buffer 2 contents
//            r          pointer to the character iterator if the UText owns it.
//                       Null otherwise.
//
//------------------------------------------------------------------------------
#define CIBufSize 16

U_CDECL_BEGIN
static void U_CALLCONV
charIterTextClose(UText *ut) {
    // Most of the work of close is done by the generic UText framework close.
    // All that needs to be done here is delete the CharacterIterator if the UText
    //  owns it.  This occurs if the UText was created by cloning.
    CharacterIterator *ci = (CharacterIterator *)ut->r;
    delete ci;
    ut->r = nullptr;
}

static int64_t U_CALLCONV
charIterTextLength(UText *ut) {
    return (int32_t)ut->a;
}

static UBool U_CALLCONV
charIterTextAccess(UText *ut, int64_t index, UBool  forward) {
    CharacterIterator *ci   = (CharacterIterator *)ut->context;

    int32_t clippedIndex = (int32_t)index;
    if (clippedIndex<0) {
        clippedIndex=0;
    } else if (clippedIndex>=ut->a) {
        clippedIndex=(int32_t)ut->a;
    }
    int32_t neededIndex = clippedIndex;
    if (!forward && neededIndex>0) {
        // reverse iteration, want the position just before what was asked for.
        neededIndex--;
    } else if (forward && neededIndex==ut->a && neededIndex>0) {
        // Forward iteration, don't ask for something past the end of the text.
        neededIndex--;
    }

    // Find the native index of the start of the buffer containing what we want.
    neededIndex -= neededIndex % CIBufSize;

    char16_t *buf = nullptr;
    UBool  needChunkSetup = true;
    int    i;
    if (ut->chunkNativeStart == neededIndex) {
        // The buffer we want is already the current chunk.
        needChunkSetup = false;
    } else if (ut->b == neededIndex) {
        // The first buffer (buffer p) has what we need.
        buf = (char16_t *)ut->p;
    } else if (ut->c == neededIndex) {
        // The second buffer (buffer q) has what we need.
        buf = (char16_t *)ut->q;
    } else {
        // Neither buffer already has what we need.
        // Load new data from the character iterator.
        // Use the buf that is not the current buffer.
        buf = (char16_t *)ut->p;
        if (ut->p == ut->chunkContents) {
            buf = (char16_t *)ut->q;
        }
        ci->setIndex(neededIndex);
        for (i=0; i<CIBufSize; i++) {
            buf[i] = ci->nextPostInc();
            if (i+neededIndex > ut->a) {
                break;
            }
        }
    }

    // We have a buffer with the data we need.
    // Set it up as the current chunk, if it wasn't already.
    if (needChunkSetup) {
        ut->chunkContents = buf;
        ut->chunkLength   = CIBufSize;
        ut->chunkNativeStart = neededIndex;
        ut->chunkNativeLimit = neededIndex + CIBufSize;
        if (ut->chunkNativeLimit > ut->a) {
            ut->chunkNativeLimit = ut->a;
            ut->chunkLength  = (int32_t)(ut->chunkNativeLimit)-(int32_t)(ut->chunkNativeStart);
        }
        ut->nativeIndexingLimit = ut->chunkLength;
        U_ASSERT(ut->chunkOffset>=0 && ut->chunkOffset<=CIBufSize);
    }
    ut->chunkOffset = clippedIndex - (int32_t)ut->chunkNativeStart;
    UBool success = (forward? ut->chunkOffset<ut->chunkLength : ut->chunkOffset>0);
    return success;
}

static UText * U_CALLCONV
charIterTextClone(UText *dest, const UText *src, UBool deep, UErrorCode * status) {
    if (U_FAILURE(*status)) {
        return nullptr;
    }

    if (deep) {
        // There is no CharacterIterator API for cloning the underlying text storage.
        *status = U_UNSUPPORTED_ERROR;
        return nullptr;
    } else {
        CharacterIterator *srcCI =(CharacterIterator *)src->context;
        srcCI = srcCI->clone();
        dest = utext_openCharacterIterator(dest, srcCI, status);
        if (U_FAILURE(*status)) {
            return dest;
        }
        // cast off const on getNativeIndex.
        //   For CharacterIterator based UTexts, this is safe, the operation is const.
        int64_t  ix = utext_getNativeIndex((UText *)src);
        utext_setNativeIndex(dest, ix);
        dest->r = srcCI;    // flags that this UText owns the CharacterIterator
    }
    return dest;
}

static int32_t U_CALLCONV
charIterTextExtract(UText *ut,
                  int64_t start, int64_t limit,
                  char16_t *dest, int32_t destCapacity,
                  UErrorCode *status)
{
    if(U_FAILURE(*status)) {
        return 0;
    }
    if(destCapacity<0 || (dest==nullptr && destCapacity>0) || start>limit) {
        *status=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }
    int32_t  length  = (int32_t)ut->a;
    int32_t  start32 = pinIndex(start, length);
    int32_t  limit32 = pinIndex(limit, length);
    int32_t  desti   = 0;
    int32_t  srci;
    int32_t  copyLimit;

    CharacterIterator *ci = (CharacterIterator *)ut->context;
    ci->setIndex32(start32);   // Moves ix to lead of surrogate pair, if needed.
    srci = ci->getIndex();
    copyLimit = srci;
    while (srci<limit32) {
        UChar32 c = ci->next32PostInc();
        int32_t  len = U16_LENGTH(c);
        U_ASSERT(desti+len>0); /* to ensure desti+len never exceeds MAX_INT32, which must not happen logically */
        if (desti+len <= destCapacity) {
            U16_APPEND_UNSAFE(dest, desti, c);
            copyLimit = srci+len;
        } else {
            desti += len;
            *status = U_BUFFER_OVERFLOW_ERROR;
        }
        srci += len;
    }

    charIterTextAccess(ut, copyLimit, true);

    u_terminateUChars(dest, destCapacity, desti, status);
    return desti;
}

static const struct UTextFuncs charIterFuncs =
{
    sizeof(UTextFuncs),
    0, 0, 0,             // Reserved alignment padding
    charIterTextClone,
    charIterTextLength,
    charIterTextAccess,
    charIterTextExtract,
    nullptr,                // Replace
    nullptr,                // Copy
    nullptr,                // MapOffsetToNative,
    nullptr,                // MapIndexToUTF16,
    charIterTextClose,
    nullptr,                // spare 1
    nullptr,                // spare 2
    nullptr                 // spare 3
};
U_CDECL_END


U_CAPI UText * U_EXPORT2
utext_openCharacterIterator(UText *ut, CharacterIterator *ci, UErrorCode *status) {
    if (U_FAILURE(*status)) {
        return nullptr;
    }

    if (ci->startIndex() > 0) {
        // No support for CharacterIterators that do not start indexing from zero.
        *status = U_UNSUPPORTED_ERROR;
        return nullptr;
    }

    // Extra space in UText for 2 buffers of CIBufSize UChars each.
    int32_t  extraSpace = 2 * CIBufSize * sizeof(char16_t);
    ut = utext_setup(ut, extraSpace, status);
    if (U_SUCCESS(*status)) {
        ut->pFuncs                = &charIterFuncs;
        ut->context              = ci;
        ut->providerProperties   = 0;
        ut->a                    = ci->endIndex();        // Length of text
        ut->p                    = ut->pExtra;            // First buffer
        ut->b                    = -1;                    // Native index of first buffer contents
        ut->q                    = (char16_t*)ut->pExtra+CIBufSize;  // Second buffer
        ut->c                    = -1;                    // Native index of second buffer contents

        // Initialize current chunk contents to be empty.
        //   First access will fault something in.
        //   Note:  The initial nativeStart and chunkOffset must sum to zero
        //          so that getNativeIndex() will correctly compute to zero
        //          if no call to Access() has ever been made.  They can't be both
        //          zero without Access() thinking that the chunk is valid.
        ut->chunkContents        = (char16_t *)ut->p;
        ut->chunkNativeStart     = -1;
        ut->chunkOffset          = 1;
        ut->chunkNativeLimit     = 0;
        ut->chunkLength          = 0;
        ut->nativeIndexingLimit  = ut->chunkOffset;  // enables native indexing
    }
    return ut;
}
                                                                                                                                        node-23.7.0/deps/icu-small/source/common/utf_impl.cpp                                               0000664 0000000 0000000 00000026607 14746647661 0022524 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 1999-2012, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*   file name:  utf_impl.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 1999sep13
*   created by: Markus W. Scherer
*
*   This file provides implementation functions for macros in the utfXX.h
*   that would otherwise be too long as macros.
*/

/* set import/export definitions */
#ifndef U_UTF8_IMPL
#   define U_UTF8_IMPL
#endif

#include "unicode/utypes.h"
#include "unicode/utf.h"
#include "unicode/utf8.h"
#include "uassert.h"

/*
 * Table of the number of utf8 trail bytes, indexed by the lead byte.
 * Used by the deprecated macro UTF8_COUNT_TRAIL_BYTES, defined in utf_old.h
 *
 * The current macro, U8_COUNT_TRAIL_BYTES, does _not_ use this table.
 *
 * Note that this table cannot be removed, even if UTF8_COUNT_TRAIL_BYTES were
 * changed to no longer use it. References to the table from expansions of UTF8_COUNT_TRAIL_BYTES
 * may exist in old client code that must continue to run with newer icu library versions.
 *
 * This table could be replaced on many machines by
 * a few lines of assembler code using an
 * "index of first 0-bit from msb" instruction and
 * one or two more integer instructions.
 *
 * For example, on an i386, do something like
 * - MOV AL, leadByte
 * - NOT AL         (8-bit, leave b15..b8==0..0, reverse only b7..b0)
 * - MOV AH, 0
 * - BSR BX, AX     (16-bit)
 * - MOV AX, 6      (result)
 * - JZ finish      (ZF==1 if leadByte==0xff)
 * - SUB AX, BX (result)
 * -finish:
 * (BSR: Bit Scan Reverse, scans for a 1-bit, starting from the MSB)
 */
U_CAPI const uint8_t
utf8_countTrailBytes[256]={
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

    // illegal C0 & C1
    // 2-byte lead bytes C2..DF
    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

    // 3-byte lead bytes E0..EF
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    // 4-byte lead bytes F0..F4
    // illegal F5..FF
    3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

static const UChar32
utf8_errorValue[6]={
    // Same values as UTF8_ERROR_VALUE_1, UTF8_ERROR_VALUE_2, UTF_ERROR_VALUE,
    // but without relying on the obsolete unicode/utf_old.h.
    0x15, 0x9f, 0xffff,
    0x10ffff
};

static UChar32
errorValue(int32_t count, int8_t strict) {
    if(strict>=0) {
        return utf8_errorValue[count];
    } else if(strict==-3) {
        return 0xfffd;
    } else {
        return U_SENTINEL;
    }
}

/*
 * Handle the non-inline part of the U8_NEXT() and U8_NEXT_FFFD() macros
 * and their obsolete sibling UTF8_NEXT_CHAR_SAFE().
 *
 * U8_NEXT() supports NUL-terminated strings indicated via length<0.
 *
 * The "strict" parameter controls the error behavior:
 * <0  "Safe" behavior of U8_NEXT():
 *     -1: All illegal byte sequences yield U_SENTINEL=-1.
 *     -2: Same as -1, except for lenient treatment of surrogate code points as legal.
 *         Some implementations use this for roundtripping of
 *         Unicode 16-bit strings that are not well-formed UTF-16, that is, they
 *         contain unpaired surrogates.
 *     -3: All illegal byte sequences yield U+FFFD.
 *  0  Obsolete "safe" behavior of UTF8_NEXT_CHAR_SAFE(..., false):
 *     All illegal byte sequences yield a positive code point such that this
 *     result code point would be encoded with the same number of bytes as
 *     the illegal sequence.
 * >0  Obsolete "strict" behavior of UTF8_NEXT_CHAR_SAFE(..., true):
 *     Same as the obsolete "safe" behavior, but non-characters are also treated
 *     like illegal sequences.
 *
 * Note that a UBool is the same as an int8_t.
 */
U_CAPI UChar32 U_EXPORT2
utf8_nextCharSafeBody(const uint8_t *s, int32_t *pi, int32_t length, UChar32 c, UBool strict) {
    // *pi is one after byte c.
    int32_t i=*pi;
    // length can be negative for NUL-terminated strings: Read and validate one byte at a time.
    if(i==length || c>0xf4) {
        // end of string, or not a lead byte
    } else if(c>=0xf0) {
        // Test for 4-byte sequences first because
        // U8_NEXT() handles shorter valid sequences inline.
        uint8_t t1=s[i], t2, t3;
        c&=7;
        if(U8_IS_VALID_LEAD4_AND_T1(c, t1) &&
                ++i!=length && (t2=s[i]-0x80)<=0x3f &&
                ++i!=length && (t3=s[i]-0x80)<=0x3f) {
            ++i;
            c=(c<<18)|((t1&0x3f)<<12)|(t2<<6)|t3;
            // strict: forbid non-characters like U+fffe
            if(strict<=0 || !U_IS_UNICODE_NONCHAR(c)) {
                *pi=i;
                return c;
            }
        }
    } else if(c>=0xe0) {
        c&=0xf;
        if(strict!=-2) {
            uint8_t t1=s[i], t2;
            if(U8_IS_VALID_LEAD3_AND_T1(c, t1) &&
                    ++i!=length && (t2=s[i]-0x80)<=0x3f) {
                ++i;
                c=(c<<12)|((t1&0x3f)<<6)|t2;
                // strict: forbid non-characters like U+fffe
                if(strict<=0 || !U_IS_UNICODE_NONCHAR(c)) {
                    *pi=i;
                    return c;
                }
            }
        } else {
            // strict=-2 -> lenient: allow surrogates
            uint8_t t1=s[i]-0x80, t2;
            if(t1<=0x3f && (c>0 || t1>=0x20) &&
                    ++i!=length && (t2=s[i]-0x80)<=0x3f) {
                *pi=i+1;
                return (c<<12)|(t1<<6)|t2;
            }
        }
    } else if(c>=0xc2) {
        uint8_t t1=s[i]-0x80;
        if(t1<=0x3f) {
            *pi=i+1;
            return ((c-0xc0)<<6)|t1;
        }
    }  // else 0x80<=c<0xc2 is not a lead byte

    /* error handling */
    c=errorValue(i-*pi, strict);
    *pi=i;
    return c;
}

U_CAPI int32_t U_EXPORT2
utf8_appendCharSafeBody(uint8_t *s, int32_t i, int32_t length, UChar32 c, UBool *pIsError) {
    if((uint32_t)(c)<=0x7ff) {
        if((i)+1<(length)) {
            (s)[(i)++]=(uint8_t)(((c)>>6)|0xc0);
            (s)[(i)++]=(uint8_t)(((c)&0x3f)|0x80);
            return i;
        }
    } else if((uint32_t)(c)<=0xffff) {
        /* Starting with Unicode 3.2, surrogate code points must not be encoded in UTF-8. */
        if((i)+2<(length) && !U_IS_SURROGATE(c)) {
            (s)[(i)++]=(uint8_t)(((c)>>12)|0xe0);
            (s)[(i)++]=(uint8_t)((((c)>>6)&0x3f)|0x80);
            (s)[(i)++]=(uint8_t)(((c)&0x3f)|0x80);
            return i;
        }
    } else if((uint32_t)(c)<=0x10ffff) {
        if((i)+3<(length)) {
            (s)[(i)++]=(uint8_t)(((c)>>18)|0xf0);
            (s)[(i)++]=(uint8_t)((((c)>>12)&0x3f)|0x80);
            (s)[(i)++]=(uint8_t)((((c)>>6)&0x3f)|0x80);
            (s)[(i)++]=(uint8_t)(((c)&0x3f)|0x80);
            return i;
        }
    }
    /* c>0x10ffff or not enough space, write an error value */
    if(pIsError!=nullptr) {
        *pIsError=true;
    } else {
        length-=i;
        if(length>0) {
            int32_t offset;
            if(length>3) {
                length=3;
            }
            s+=i;
            offset=0;
            c=utf8_errorValue[length-1];
            U8_APPEND_UNSAFE(s, offset, c);
            i=i+offset;
        }
    }
    return i;
}

U_CAPI UChar32 U_EXPORT2
utf8_prevCharSafeBody(const uint8_t *s, int32_t start, int32_t *pi, UChar32 c, UBool strict) {
    // *pi is the index of byte c.
    int32_t i=*pi;
    if(U8_IS_TRAIL(c) && i>start) {
        uint8_t b1=s[--i];
        if(U8_IS_LEAD(b1)) {
            if(b1<0xe0) {
                *pi=i;
                return ((b1-0xc0)<<6)|(c&0x3f);
            } else if(b1<0xf0 ? U8_IS_VALID_LEAD3_AND_T1(b1, c) : U8_IS_VALID_LEAD4_AND_T1(b1, c)) {
                // Truncated 3- or 4-byte sequence.
                *pi=i;
                return errorValue(1, strict);
            }
        } else if(U8_IS_TRAIL(b1) && i>start) {
            // Extract the value bits from the last trail byte.
            c&=0x3f;
            uint8_t b2=s[--i];
            if(0xe0<=b2 && b2<=0xf4) {
                if(b2<0xf0) {
                    b2&=0xf;
                    if(strict!=-2) {
                        if(U8_IS_VALID_LEAD3_AND_T1(b2, b1)) {
                            *pi=i;
                            c=(b2<<12)|((b1&0x3f)<<6)|c;
                            if(strict<=0 || !U_IS_UNICODE_NONCHAR(c)) {
                                return c;
                            } else {
                                // strict: forbid non-characters like U+fffe
                                return errorValue(2, strict);
                            }
                        }
                    } else {
                        // strict=-2 -> lenient: allow surrogates
                        b1-=0x80;
                        if((b2>0 || b1>=0x20)) {
                            *pi=i;
                            return (b2<<12)|(b1<<6)|c;
                        }
                    }
                } else if(U8_IS_VALID_LEAD4_AND_T1(b2, b1)) {
                    // Truncated 4-byte sequence.
                    *pi=i;
                    return errorValue(2, strict);
                }
            } else if(U8_IS_TRAIL(b2) && i>start) {
                uint8_t b3=s[--i];
                if(0xf0<=b3 && b3<=0xf4) {
                    b3&=7;
                    if(U8_IS_VALID_LEAD4_AND_T1(b3, b2)) {
                        *pi=i;
                        c=(b3<<18)|((b2&0x3f)<<12)|((b1&0x3f)<<6)|c;
                        if(strict<=0 || !U_IS_UNICODE_NONCHAR(c)) {
                            return c;
                        } else {
                            // strict: forbid non-characters like U+fffe
                            return errorValue(3, strict);
                        }
                    }
                }
            }
        }
    }
    return errorValue(0, strict);
}

U_CAPI int32_t U_EXPORT2
utf8_back1SafeBody(const uint8_t *s, int32_t start, int32_t i) {
    // Same as utf8_prevCharSafeBody(..., strict=-1) minus assembling code points.
    int32_t orig_i=i;
    uint8_t c=s[i];
    if(U8_IS_TRAIL(c) && i>start) {
        uint8_t b1=s[--i];
        if(U8_IS_LEAD(b1)) {
            if(b1<0xe0 ||
                    (b1<0xf0 ? U8_IS_VALID_LEAD3_AND_T1(b1, c) : U8_IS_VALID_LEAD4_AND_T1(b1, c))) {
                return i;
            }
        } else if(U8_IS_TRAIL(b1) && i>start) {
            uint8_t b2=s[--i];
            if(0xe0<=b2 && b2<=0xf4) {
                if(b2<0xf0 ? U8_IS_VALID_LEAD3_AND_T1(b2, b1) : U8_IS_VALID_LEAD4_AND_T1(b2, b1)) {
                    return i;
                }
            } else if(U8_IS_TRAIL(b2) && i>start) {
                uint8_t b3=s[--i];
                if(0xf0<=b3 && b3<=0xf4 && U8_IS_VALID_LEAD4_AND_T1(b3, b2)) {
                    return i;
                }
            }
        }
    }
    return orig_i;
}
                                                                                                                         node-23.7.0/deps/icu-small/source/common/util.cpp                                                   0000664 0000000 0000000 00000035020 14746647661 0021647 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
**********************************************************************
*   Copyright (c) 2001-2011, International Business Machines
*   Corporation and others.  All Rights Reserved.
**********************************************************************
*   Date        Name        Description
*   11/19/2001  aliu        Creation.
**********************************************************************
*/

#include "unicode/unimatch.h"
#include "unicode/utf16.h"
#include "patternprops.h"
#include "util.h"

// Define char16_t constants using hex for EBCDIC compatibility

static const char16_t BACKSLASH  = 0x005C; /*\*/
static const char16_t UPPER_U    = 0x0055; /*U*/
static const char16_t LOWER_U    = 0x0075; /*u*/
static const char16_t APOSTROPHE = 0x0027; // '\''
static const char16_t SPACE      = 0x0020; // ' '

// "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
static const char16_t DIGITS[] = {
    48,49,50,51,52,53,54,55,56,57,
    65,66,67,68,69,70,71,72,73,74,
    75,76,77,78,79,80,81,82,83,84,
    85,86,87,88,89,90
};

U_NAMESPACE_BEGIN

UnicodeString& ICU_Utility::appendNumber(UnicodeString& result, int32_t n,
                                     int32_t radix, int32_t minDigits) {
    if (radix < 2 || radix > 36) {
        // Bogus radix
        return result.append(static_cast<char16_t>(63)/*?*/);
    }
    // Handle negatives
    if (n < 0) {
        n = -n;
        result.append(static_cast<char16_t>(45)/*-*/);
    }
    // First determine the number of digits
    int32_t nn = n;
    int32_t r = 1;
    while (nn >= radix) {
        nn /= radix;
        r *= radix;
        --minDigits;
    }
    // Now generate the digits
    while (--minDigits > 0) {
        result.append(DIGITS[0]);
    }
    while (r > 0) {
        int32_t digit = n / r;
        result.append(DIGITS[digit]);
        n -= digit * r;
        r /= radix;
    }
    return result;
}

UBool ICU_Utility::isUnprintable(UChar32 c) {
    return !(c >= 0x20 && c <= 0x7E);
}

UBool ICU_Utility::shouldAlwaysBeEscaped(UChar32 c) {
    if (c < 0x20) {
        return true;  // C0 control codes
    } else if (c <= 0x7e) {
        return false;  // printable ASCII
    } else if (c <= 0x9f) {
        return true;  // C1 control codes
    } else if (c < 0xd800) {
        return false;  // most of the BMP
    } else if (c <= 0xdfff || (0xfdd0 <= c && c <= 0xfdef) || (c & 0xfffe) == 0xfffe) {
        return true;  // surrogate or noncharacter code points
    } else if (c <= 0x10ffff) {
        return false;  // all else
    } else {
        return true;  // not a code point
    }
}

UBool ICU_Utility::escapeUnprintable(UnicodeString& result, UChar32 c) {
    if (isUnprintable(c)) {
        escape(result, c);
        return true;
    }
    return false;
}

UnicodeString &ICU_Utility::escape(UnicodeString& result, UChar32 c) {
    result.append(BACKSLASH);
    if (c & ~0xFFFF) {
        result.append(UPPER_U);
        result.append(DIGITS[0xF&(c>>28)]);
        result.append(DIGITS[0xF&(c>>24)]);
        result.append(DIGITS[0xF&(c>>20)]);
        result.append(DIGITS[0xF&(c>>16)]);
    } else {
        result.append(LOWER_U);
    }
    result.append(DIGITS[0xF&(c>>12)]);
    result.append(DIGITS[0xF&(c>>8)]);
    result.append(DIGITS[0xF&(c>>4)]);
    result.append(DIGITS[0xF&c]);
    return result;
}

/**
 * Returns the index of a character, ignoring quoted text.
 * For example, in the string "abc'hide'h", the 'h' in "hide" will not be
 * found by a search for 'h'.
 */
// FOR FUTURE USE.  DISABLE FOR NOW for coverage reasons.
/*
int32_t ICU_Utility::quotedIndexOf(const UnicodeString& text,
                               int32_t start, int32_t limit,
                               char16_t charToFind) {
    for (int32_t i=start; i<limit; ++i) {
        char16_t c = text.charAt(i);
        if (c == BACKSLASH) {
            ++i;
        } else if (c == APOSTROPHE) {
            while (++i < limit
                   && text.charAt(i) != APOSTROPHE) {}
        } else if (c == charToFind) {
            return i;
        }
    }
    return -1;
}
*/

/**
 * Skip over a sequence of zero or more white space characters at pos.
 * @param advance if true, advance pos to the first non-white-space
 * character at or after pos, or str.length(), if there is none.
 * Otherwise leave pos unchanged.
 * @return the index of the first non-white-space character at or
 * after pos, or str.length(), if there is none.
 */
int32_t ICU_Utility::skipWhitespace(const UnicodeString& str, int32_t& pos,
                                    UBool advance) {
    int32_t p = pos;
    const char16_t* s = str.getBuffer();
    p = static_cast<int32_t>(PatternProps::skipWhiteSpace(s + p, str.length() - p) - s);
    if (advance) {
        pos = p;
    }
    return p;
}

/**
 * Skip over Pattern_White_Space in a Replaceable.
 * Skipping may be done in the forward or
 * reverse direction.  In either case, the leftmost index will be
 * inclusive, and the rightmost index will be exclusive.  That is,
 * given a range defined as [start, limit), the call
 * skipWhitespace(text, start, limit) will advance start past leading
 * whitespace, whereas the call skipWhitespace(text, limit, start),
 * will back up limit past trailing whitespace.
 * @param text the text to be analyzed
 * @param pos either the start or limit of a range of 'text', to skip
 * leading or trailing whitespace, respectively
 * @param stop either the limit or start of a range of 'text', to skip
 * leading or trailing whitespace, respectively
 * @return the new start or limit, depending on what was passed in to
 * 'pos'
 */
//?FOR FUTURE USE.  DISABLE FOR NOW for coverage reasons.
//?int32_t ICU_Utility::skipWhitespace(const Replaceable& text,
//?                                    int32_t pos, int32_t stop) {
//?    UChar32 c;
//?    UBool isForward = (stop >= pos);
//?
//?    if (!isForward) {
//?        --pos; // pos is a limit, so back up by one
//?    }
//?    
//?    while (pos != stop &&
//?           PatternProps::isWhiteSpace(c = text.char32At(pos))) {
//?        if (isForward) {
//?            pos += U16_LENGTH(c);
//?        } else {
//?            pos -= U16_LENGTH(c);
//?        }
//?    }
//?
//?    if (!isForward) {
//?        ++pos; // make pos back into a limit
//?    }
//?
//?    return pos;
//?}

/**
 * Parse a single non-whitespace character 'ch', optionally
 * preceded by whitespace.
 * @param id the string to be parsed
 * @param pos INPUT-OUTPUT parameter.  On input, pos[0] is the
 * offset of the first character to be parsed.  On output, pos[0]
 * is the index after the last parsed character.  If the parse
 * fails, pos[0] will be unchanged.
 * @param ch the non-whitespace character to be parsed.
 * @return true if 'ch' is seen preceded by zero or more
 * whitespace characters.
 */
UBool ICU_Utility::parseChar(const UnicodeString& id, int32_t& pos, char16_t ch) {
    int32_t start = pos;
    skipWhitespace(id, pos, true);
    if (pos == id.length() ||
        id.charAt(pos) != ch) {
        pos = start;
        return false;
    }
    ++pos;
    return true;
}

/**
 * Parse a pattern string within the given Replaceable and a parsing
 * pattern.  Characters are matched literally and case-sensitively
 * except for the following special characters:
 *
 * ~  zero or more Pattern_White_Space chars
 *
 * If end of pattern is reached with all matches along the way,
 * pos is advanced to the first unparsed index and returned.
 * Otherwise -1 is returned.
 * @param pat pattern that controls parsing
 * @param text text to be parsed, starting at index
 * @param index offset to first character to parse
 * @param limit offset after last character to parse
 * @return index after last parsed character, or -1 on parse failure.
 */
int32_t ICU_Utility::parsePattern(const UnicodeString& pat,
                                  const Replaceable& text,
                                  int32_t index,
                                  int32_t limit) {
    int32_t ipat = 0;

    // empty pattern matches immediately
    if (ipat == pat.length()) {
        return index;
    }

    UChar32 cpat = pat.char32At(ipat);

    while (index < limit) {
        UChar32 c = text.char32At(index);

        // parse \s*
        if (cpat == 126 /*~*/) {
            if (PatternProps::isWhiteSpace(c)) {
                index += U16_LENGTH(c);
                continue;
            } else {
                if (++ipat == pat.length()) {
                    return index; // success; c unparsed
                }
                // fall thru; process c again with next cpat
            }
        }

        // parse literal
        else if (c == cpat) {
            index += U16_LENGTH(c);
            ipat += U16_LENGTH(cpat);
            if (ipat == pat.length()) {
                return index; // success; c parsed
            }
            // fall thru; get next cpat
        }

        // match failure of literal
        else {
            return -1;
        }

        cpat = pat.char32At(ipat);
    }

    return -1; // text ended before end of pat
}

int32_t ICU_Utility::parseAsciiInteger(const UnicodeString& str, int32_t& pos) {
    int32_t result = 0;
    char16_t c;
    while (pos < str.length() && (c = str.charAt(pos)) >= u'0' && c <= u'9') {
        result = result * 10 + (c - u'0');
        pos++;
    }
    return result;
}

/**
 * Append a character to a rule that is being built up.  To flush
 * the quoteBuf to rule, make one final call with isLiteral == true.
 * If there is no final character, pass in (UChar32)-1 as c.
 * @param rule the string to append the character to
 * @param c the character to append, or (UChar32)-1 if none.
 * @param isLiteral if true, then the given character should not be
 * quoted or escaped.  Usually this means it is a syntactic element
 * such as > or $
 * @param escapeUnprintable if true, then unprintable characters
 * should be escaped using \uxxxx or \Uxxxxxxxx.  These escapes will
 * appear outside of quotes.
 * @param quoteBuf a buffer which is used to build up quoted
 * substrings.  The caller should initially supply an empty buffer,
 * and thereafter should not modify the buffer.  The buffer should be
 * cleared out by, at the end, calling this method with a literal
 * character.
 */
void ICU_Utility::appendToRule(UnicodeString& rule,
                               UChar32 c,
                               UBool isLiteral,
                               UBool escapeUnprintable,
                               UnicodeString& quoteBuf) {
    // If we are escaping unprintables, then escape them outside
    // quotes.  \u and \U are not recognized within quotes.  The same
    // logic applies to literals, but literals are never escaped.
    if (isLiteral ||
        (escapeUnprintable && ICU_Utility::isUnprintable(c))) {
        if (quoteBuf.length() > 0) {
            // We prefer backslash APOSTROPHE to double APOSTROPHE
            // (more readable, less similar to ") so if there are
            // double APOSTROPHEs at the ends, we pull them outside
            // of the quote.

            // If the first thing in the quoteBuf is APOSTROPHE
            // (doubled) then pull it out.
            while (quoteBuf.length() >= 2 &&
                   quoteBuf.charAt(0) == APOSTROPHE &&
                   quoteBuf.charAt(1) == APOSTROPHE) {
                rule.append(BACKSLASH).append(APOSTROPHE);
                quoteBuf.remove(0, 2);
            }
            // If the last thing in the quoteBuf is APOSTROPHE
            // (doubled) then remove and count it and add it after.
            int32_t trailingCount = 0;
            while (quoteBuf.length() >= 2 &&
                   quoteBuf.charAt(quoteBuf.length()-2) == APOSTROPHE &&
                   quoteBuf.charAt(quoteBuf.length()-1) == APOSTROPHE) {
                quoteBuf.truncate(quoteBuf.length()-2);
                ++trailingCount;
            }
            if (quoteBuf.length() > 0) {
                rule.append(APOSTROPHE);
                rule.append(quoteBuf);
                rule.append(APOSTROPHE);
                quoteBuf.truncate(0);
            }
            while (trailingCount-- > 0) {
                rule.append(BACKSLASH).append(APOSTROPHE);
            }
        }
        if (c != static_cast<UChar32>(-1)) {
            /* Since spaces are ignored during parsing, they are
             * emitted only for readability.  We emit one here
             * only if there isn't already one at the end of the
             * rule.
             */
            if (c == SPACE) {
                int32_t len = rule.length();
                if (len > 0 && rule.charAt(len-1) != c) {
                    rule.append(c);
                }
            } else if (!escapeUnprintable || !ICU_Utility::escapeUnprintable(rule, c)) {
                rule.append(c);
            }
        }
    }

    // Escape ' and '\' and don't begin a quote just for them
    else if (quoteBuf.length() == 0 &&
             (c == APOSTROPHE || c == BACKSLASH)) {
        rule.append(BACKSLASH);
        rule.append(c);
    }

    // Specials (printable ascii that isn't [0-9a-zA-Z]) and
    // whitespace need quoting.  Also append stuff to quotes if we are
    // building up a quoted substring already.
    else if (quoteBuf.length() > 0 ||
             (c >= 0x0021 && c <= 0x007E &&
              !((c >= 0x0030/*'0'*/ && c <= 0x0039/*'9'*/) ||
                (c >= 0x0041/*'A'*/ && c <= 0x005A/*'Z'*/) ||
                (c >= 0x0061/*'a'*/ && c <= 0x007A/*'z'*/))) ||
             PatternProps::isWhiteSpace(c)) {
        quoteBuf.append(c);
        // Double ' within a quote
        if (c == APOSTROPHE) {
            quoteBuf.append(c);
        }
    }
    
    // Otherwise just append
    else {
        rule.append(c);
    }
}

void ICU_Utility::appendToRule(UnicodeString& rule,
                               const UnicodeString& text,
                               UBool isLiteral,
                               UBool escapeUnprintable,
                               UnicodeString& quoteBuf) {
    for (int32_t i=0; i<text.length(); ++i) {
        appendToRule(rule, text[i], isLiteral, escapeUnprintable, quoteBuf);
    }
}

/**
 * Given a matcher reference, which may be null, append its
 * pattern as a literal to the given rule.
 */
void ICU_Utility::appendToRule(UnicodeString& rule,
                               const UnicodeMatcher* matcher,
                               UBool escapeUnprintable,
                               UnicodeString& quoteBuf) {
    if (matcher != nullptr) {
        UnicodeString pat;
        appendToRule(rule, matcher->toPattern(pat, escapeUnprintable),
                     true, escapeUnprintable, quoteBuf);
    }
}

U_NAMESPACE_END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/icu-small/source/common/util.h                                                     0000664 0000000 0000000 00000026425 14746647661 0021325 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
 **********************************************************************
 *   Copyright (c) 2001-2011, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 **********************************************************************
 *   Date        Name        Description
 *   11/19/2001  aliu        Creation.
 **********************************************************************
 */

#ifndef ICU_UTIL_H
#define ICU_UTIL_H

#include "charstr.h"
#include "unicode/unistr.h"
#include "unicode/uobject.h"
#include "unicode/utypes.h"
//--------------------------------------------------------------------
// class ICU_Utility
// i18n utility functions, scoped into the class ICU_Utility.
//--------------------------------------------------------------------

U_NAMESPACE_BEGIN

class UnicodeMatcher;

class U_COMMON_API ICU_Utility /* not : public UObject because all methods are static */ {
 public:

    /**
     * Append a number to the given UnicodeString in the given radix.
     * Standard digits '0'-'9' are used and letters 'A'-'Z' for
     * radices 11 through 36.
     * @param result the digits of the number are appended here
     * @param n the number to be converted to digits; may be negative.
     * If negative, a '-' is prepended to the digits.
     * @param radix a radix from 2 to 36 inclusive.
     * @param minDigits the minimum number of digits, not including
     * any '-', to produce.  Values less than 2 have no effect.  One
     * digit is always emitted regardless of this parameter.
     * @return a reference to result
     */
    static UnicodeString& appendNumber(UnicodeString& result, int32_t n,
                                       int32_t radix = 10,
                                       int32_t minDigits = 1);

    /** Returns a bogus UnicodeString by value. */
    static inline UnicodeString makeBogusString() {
        UnicodeString result;
        result.setToBogus();
        return result;
    }

    /**
     * Return true if the character is NOT printable ASCII.
     * The tab, newline and linefeed characters are considered unprintable.
     */
    static UBool isUnprintable(UChar32 c);

    /**
     * @return true for control codes and for surrogate and noncharacter code points
     */
    static UBool shouldAlwaysBeEscaped(UChar32 c);

    /**
     * Escapes one unprintable code point using \uxxxx notation for U+0000 to
     * U+FFFF and \Uxxxxxxxx for U+10000 and above.  If the character is
     * printable ASCII, then do nothing and return false.  Otherwise,
     * append the escaped notation and return true.
     */
    static UBool escapeUnprintable(UnicodeString& result, UChar32 c);

    /**
     * Escapes one code point using \uxxxx notation
     * for U+0000 to U+FFFF and \Uxxxxxxxx for U+10000 and above.
     * @return result
     */
    static UnicodeString &escape(UnicodeString& result, UChar32 c);

    /**
     * Returns the index of a character, ignoring quoted text.
     * For example, in the string "abc'hide'h", the 'h' in "hide" will not be
     * found by a search for 'h'.
     * @param text text to be searched
     * @param start the beginning index, inclusive; <code>0 <= start
     * <= limit</code>.
     * @param limit the ending index, exclusive; <code>start <= limit
     * <= text.length()</code>.
     * @param c character to search for
     * @return Offset of the first instance of c, or -1 if not found.
     */
//?FOR FUTURE USE.  DISABLE FOR NOW for coverage reasons.
//    static int32_t quotedIndexOf(const UnicodeString& text,
//                                 int32_t start, int32_t limit,
//                                 char16_t c);

    /**
     * Skip over a sequence of zero or more white space characters at pos.
     * @param advance if true, advance pos to the first non-white-space
     * character at or after pos, or str.length(), if there is none.
     * Otherwise leave pos unchanged.
     * @return the index of the first non-white-space character at or
     * after pos, or str.length(), if there is none.
     */
    static int32_t skipWhitespace(const UnicodeString& str, int32_t& pos,
                                  UBool advance = false);

    /**
     * Skip over Pattern_White_Space in a Replaceable.
     * Skipping may be done in the forward or
     * reverse direction.  In either case, the leftmost index will be
     * inclusive, and the rightmost index will be exclusive.  That is,
     * given a range defined as [start, limit), the call
     * skipWhitespace(text, start, limit) will advance start past leading
     * whitespace, whereas the call skipWhitespace(text, limit, start),
     * will back up limit past trailing whitespace.
     * @param text the text to be analyzed
     * @param pos either the start or limit of a range of 'text', to skip
     * leading or trailing whitespace, respectively
     * @param stop either the limit or start of a range of 'text', to skip
     * leading or trailing whitespace, respectively
     * @return the new start or limit, depending on what was passed in to
     * 'pos'
     */
//?FOR FUTURE USE.  DISABLE FOR NOW for coverage reasons.
//?    static int32_t skipWhitespace(const Replaceable& text,
//?                                  int32_t pos, int32_t stop);

    /**
     * Parse a single non-whitespace character 'ch', optionally
     * preceded by whitespace.
     * @param id the string to be parsed
     * @param pos INPUT-OUTPUT parameter.  On input, pos[0] is the
     * offset of the first character to be parsed.  On output, pos[0]
     * is the index after the last parsed character.  If the parse
     * fails, pos[0] will be unchanged.
     * @param ch the non-whitespace character to be parsed.
     * @return true if 'ch' is seen preceded by zero or more
     * whitespace characters.
     */
    static UBool parseChar(const UnicodeString& id, int32_t& pos, char16_t ch);

    /**
     * Parse a pattern string starting at offset pos.  Keywords are
     * matched case-insensitively.  Spaces may be skipped and may be
     * optional or required.  Integer values may be parsed, and if
     * they are, they will be returned in the given array.  If
     * successful, the offset of the next non-space character is
     * returned.  On failure, -1 is returned.
     * @param pattern must only contain lowercase characters, which
     * will match their uppercase equivalents as well.  A space
     * character matches one or more required spaces.  A '~' character
     * matches zero or more optional spaces.  A '#' character matches
     * an integer and stores it in parsedInts, which the caller must
     * ensure has enough capacity.
     * @param parsedInts array to receive parsed integers.  Caller
     * must ensure that parsedInts.length is >= the number of '#'
     * signs in 'pattern'.
     * @return the position after the last character parsed, or -1 if
     * the parse failed
     */
    static int32_t parsePattern(const UnicodeString& rule, int32_t pos, int32_t limit,
                                const UnicodeString& pattern, int32_t* parsedInts);
        
    /**
     * Parse a pattern string within the given Replaceable and a parsing
     * pattern.  Characters are matched literally and case-sensitively
     * except for the following special characters:
     *
     * ~  zero or more Pattern_White_Space chars
     *
     * If end of pattern is reached with all matches along the way,
     * pos is advanced to the first unparsed index and returned.
     * Otherwise -1 is returned.
     * @param pat pattern that controls parsing
     * @param text text to be parsed, starting at index
     * @param index offset to first character to parse
     * @param limit offset after last character to parse
     * @return index after last parsed character, or -1 on parse failure.
     */
    static int32_t parsePattern(const UnicodeString& pat,
                                const Replaceable& text,
                                int32_t index,
                                int32_t limit);

    /**
     * Parse an integer at pos, either of the form \d+ or of the form
     * 0x[0-9A-Fa-f]+ or 0[0-7]+, that is, in standard decimal, hex,
     * or octal format.
     * @param pos INPUT-OUTPUT parameter.  On input, the index of the first
     * character to parse.  On output, the index of the character after the
     * last parsed character.
     */
    static int32_t parseInteger(const UnicodeString& rule, int32_t& pos, int32_t limit);

    /**
     * Parse an integer at pos using only ASCII digits.
     * Base 10 only.
     * @param pos INPUT-OUTPUT parameter.  On input, the index of the first
     * character to parse.  On output, the index of the character after the
     * last parsed character.
     */
    static int32_t parseAsciiInteger(const UnicodeString& str, int32_t& pos);

    /**
     * Parse a Unicode identifier from the given string at the given
     * position.  Return the identifier, or an empty string if there
     * is no identifier.
     * @param str the string to parse
     * @param pos INPUT-OUTPUT parameter.  On INPUT, pos is the
     * first character to examine.  It must be less than str.length(),
     * and it must not point to a whitespace character.  That is, must
     * have pos < str.length() and
     * !UCharacter::isWhitespace(str.char32At(pos)).  On
     * OUTPUT, the position after the last parsed character.
     * @return the Unicode identifier, or an empty string if there is
     * no valid identifier at pos.
     */
    static UnicodeString parseUnicodeIdentifier(const UnicodeString& str, int32_t& pos);

    /**
     * Parse an unsigned 31-bit integer at the given offset.  Use
     * UCharacter.digit() to parse individual characters into digits.
     * @param text the text to be parsed
     * @param pos INPUT-OUTPUT parameter.  On entry, pos is the
     * offset within text at which to start parsing; it should point
     * to a valid digit.  On exit, pos is the offset after the last
     * parsed character.  If the parse failed, it will be unchanged on
     * exit.  Must be >= 0 on entry.
     * @param radix the radix in which to parse; must be >= 2 and <=
     * 36.
     * @return a non-negative parsed number, or -1 upon parse failure.
     * Parse fails if there are no digits, that is, if pos does not
     * point to a valid digit on entry, or if the number to be parsed
     * does not fit into a 31-bit unsigned integer.
     */
    static int32_t parseNumber(const UnicodeString& text,
                               int32_t& pos, int8_t radix);

    static void appendToRule(UnicodeString& rule,
                             UChar32 c,
                             UBool isLiteral,
                             UBool escapeUnprintable,
                             UnicodeString& quoteBuf);
    
    static void appendToRule(UnicodeString& rule,
                             const UnicodeString& text,
                             UBool isLiteral,
                             UBool escapeUnprintable,
                             UnicodeString& quoteBuf);

    static void appendToRule(UnicodeString& rule,
                             const UnicodeMatcher* matcher,
                             UBool escapeUnprintable,
                             UnicodeString& quoteBuf);

private:
    // do not instantiate
    ICU_Utility() = delete;
};

U_NAMESPACE_END

#endif
//eof
                                                                                                                                                                                                                                           node-23.7.0/deps/icu-small/source/common/util_props.cpp                                             0000664 0000000 0000000 00000015616 14746647661 0023103 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
**********************************************************************
*   Copyright (c) 2001-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
**********************************************************************
*   Date        Name        Description
*   11/19/2001  aliu        Creation.
**********************************************************************
*/

#include "unicode/uchar.h"
#include "unicode/utf16.h"
#include "patternprops.h"
#include "util.h"

U_NAMESPACE_BEGIN

/**
 * Parse an integer at pos, either of the form \d+ or of the form
 * 0x[0-9A-Fa-f]+ or 0[0-7]+, that is, in standard decimal, hex,
 * or octal format.
 * @param pos INPUT-OUTPUT parameter.  On input, the first
 * character to parse.  On output, the character after the last
 * parsed character.
 */
int32_t ICU_Utility::parseInteger(const UnicodeString& rule, int32_t& pos, int32_t limit) {
    int32_t count = 0;
    int32_t value = 0;
    int32_t p = pos;
    int8_t radix = 10;

    if (p < limit && rule.charAt(p) == 48 /*0*/) {
        if (p+1 < limit && (rule.charAt(p+1) == 0x78 /*x*/ || rule.charAt(p+1) == 0x58 /*X*/)) {
            p += 2;
            radix = 16;
        }
        else {
            p++;
            count = 1;
            radix = 8;
        }
    }

    while (p < limit) {
        int32_t d = u_digit(rule.charAt(p++), radix);
        if (d < 0) {
            --p;
            break;
        }
        ++count;
        int32_t v = (value * radix) + d;
        if (v <= value) {
            // If there are too many input digits, at some point
            // the value will go negative, e.g., if we have seen
            // "0x8000000" already and there is another '0', when
            // we parse the next 0 the value will go negative.
            return 0;
        }
        value = v;
    }
    if (count > 0) {
        pos = p;
    }
    return value;
}

/**
 * Parse a pattern string starting at offset pos.  Keywords are
 * matched case-insensitively.  Spaces may be skipped and may be
 * optional or required.  Integer values may be parsed, and if
 * they are, they will be returned in the given array.  If
 * successful, the offset of the next non-space character is
 * returned.  On failure, -1 is returned.
 * @param pattern must only contain lowercase characters, which
 * will match their uppercase equivalents as well.  A space
 * character matches one or more required spaces.  A '~' character
 * matches zero or more optional spaces.  A '#' character matches
 * an integer and stores it in parsedInts, which the caller must
 * ensure has enough capacity.
 * @param parsedInts array to receive parsed integers.  Caller
 * must ensure that parsedInts.length is >= the number of '#'
 * signs in 'pattern'.
 * @return the position after the last character parsed, or -1 if
 * the parse failed
 */
int32_t ICU_Utility::parsePattern(const UnicodeString& rule, int32_t pos, int32_t limit,
                              const UnicodeString& pattern, int32_t* parsedInts) {
    // TODO Update this to handle surrogates
    int32_t p;
    int32_t intCount = 0; // number of integers parsed
    for (int32_t i=0; i<pattern.length(); ++i) {
        char16_t cpat = pattern.charAt(i);
        char16_t c;
        switch (cpat) {
        case 32 /*' '*/:
            if (pos >= limit) {
                return -1;
            }
            c = rule.charAt(pos++);
            if (!PatternProps::isWhiteSpace(c)) {
                return -1;
            }
            // FALL THROUGH to skipWhitespace
            U_FALLTHROUGH;
        case 126 /*'~'*/:
            pos = skipWhitespace(rule, pos);
            break;
        case 35 /*'#'*/:
            p = pos;
            parsedInts[intCount++] = parseInteger(rule, p, limit);
            if (p == pos) {
                // Syntax error; failed to parse integer
                return -1;
            }
            pos = p;
            break;
        default:
            if (pos >= limit) {
                return -1;
            }
            c = static_cast<char16_t>(u_tolower(rule.charAt(pos++)));
            if (c != cpat) {
                return -1;
            }
            break;
        }
    }
    return pos;
}

/**
 * Parse a Unicode identifier from the given string at the given
 * position.  Return the identifier, or an empty string if there
 * is no identifier.
 * @param str the string to parse
 * @param pos INPUT-OUTPUT parameter.  On INPUT, pos is the
 * first character to examine.  It must be less than str.length(),
 * and it must not point to a whitespace character.  That is, must
 * have pos < str.length().  On
 * OUTPUT, the position after the last parsed character.
 * @return the Unicode identifier, or an empty string if there is
 * no valid identifier at pos.
 */
UnicodeString ICU_Utility::parseUnicodeIdentifier(const UnicodeString& str, int32_t& pos) {
    // assert(pos < str.length());
    UnicodeString buf;
    int p = pos;
    while (p < str.length()) {
        UChar32 ch = str.char32At(p);
        if (buf.length() == 0) {
            if (u_isIDStart(ch)) {
                buf.append(ch);
            } else {
                buf.truncate(0);
                return buf;
            }
        } else {
            if (u_isIDPart(ch)) {
                buf.append(ch);
            } else {
                break;
            }
        }
        p += U16_LENGTH(ch);
    }
    pos = p;
    return buf;
}

/**
 * Parse an unsigned 31-bit integer at the given offset.  Use
 * UCharacter.digit() to parse individual characters into digits.
 * @param text the text to be parsed
 * @param pos INPUT-OUTPUT parameter.  On entry, pos[0] is the
 * offset within text at which to start parsing; it should point
 * to a valid digit.  On exit, pos[0] is the offset after the last
 * parsed character.  If the parse failed, it will be unchanged on
 * exit.  Must be >= 0 on entry.
 * @param radix the radix in which to parse; must be >= 2 and <=
 * 36.
 * @return a non-negative parsed number, or -1 upon parse failure.
 * Parse fails if there are no digits, that is, if pos[0] does not
 * point to a valid digit on entry, or if the number to be parsed
 * does not fit into a 31-bit unsigned integer.
 */
int32_t ICU_Utility::parseNumber(const UnicodeString& text,
                                 int32_t& pos, int8_t radix) {
    // assert(pos[0] >= 0);
    // assert(radix >= 2);
    // assert(radix <= 36);
    int32_t n = 0;
    int32_t p = pos;
    while (p < text.length()) {
        UChar32 ch = text.char32At(p);
        int32_t d = u_digit(ch, radix);
        if (d < 0) {
            break;
        }
        int64_t update = radix*static_cast<int64_t>(n) + d;
        if (update > INT32_MAX) {
            return -1;
        }
        n = static_cast<int32_t>(update);
        ++p;
    }
    if (p == pos) {
        return -1;
    }
    pos = p;
    return n;
}

U_NAMESPACE_END

                                                                                                                  node-23.7.0/deps/icu-small/source/common/utrace.cpp                                                 0000664 0000000 0000000 00000037745 14746647661 0022175 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
*******************************************************************************
*   Copyright (C) 2003-2014, International Business Machines
*   Corporation and others.  All Rights Reserved.
*******************************************************************************
*   file name:  utrace.c
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*/

#include "unicode/utrace.h"
#include "utracimp.h"
#include "cstring.h"
#include "uassert.h"
#include "ucln_cmn.h"


static UTraceEntry     *pTraceEntryFunc = nullptr;
static UTraceExit      *pTraceExitFunc  = nullptr;
static UTraceData      *pTraceDataFunc  = nullptr;
static const void      *gTraceContext   = nullptr;

/**
 * \var utrace_level
 * Trace level variable. Negative for "off".
 */
static int32_t
utrace_level = UTRACE_ERROR;

U_CAPI void U_EXPORT2
utrace_entry(int32_t fnNumber) {
    if (pTraceEntryFunc != nullptr) {
        (*pTraceEntryFunc)(gTraceContext, fnNumber);
    }
}


static const char gExitFmt[]             = "Returns.";
static const char gExitFmtValue[]        = "Returns %d.";
static const char gExitFmtStatus[]       = "Returns.  Status = %d.";
static const char gExitFmtValueStatus[]  = "Returns %d.  Status = %d.";
static const char gExitFmtPtrStatus[]    = "Returns %d.  Status = %p.";

U_CAPI void U_EXPORT2
utrace_exit(int32_t fnNumber, int32_t returnType, ...) {
    if (pTraceExitFunc != nullptr) {
        va_list     args;
        const char *fmt;

        switch (returnType) {
        case 0:
            fmt = gExitFmt;
            break;
        case UTRACE_EXITV_I32:
            fmt = gExitFmtValue;
            break;
        case UTRACE_EXITV_STATUS:
            fmt = gExitFmtStatus;
            break;
        case UTRACE_EXITV_I32 | UTRACE_EXITV_STATUS:
            fmt = gExitFmtValueStatus;
            break;
        case UTRACE_EXITV_PTR | UTRACE_EXITV_STATUS:
            fmt = gExitFmtPtrStatus;
            break;
        default:
            UPRV_UNREACHABLE_EXIT;
        }

        va_start(args, returnType);
        (*pTraceExitFunc)(gTraceContext, fnNumber, fmt, args);
        va_end(args);
    }
}
 

 
U_CAPI void U_EXPORT2 
utrace_data(int32_t fnNumber, int32_t level, const char *fmt, ...) {
    if (pTraceDataFunc != nullptr) {
           va_list args;
           va_start(args, fmt ); 
           (*pTraceDataFunc)(gTraceContext, fnNumber, level, fmt, args);
           va_end(args);
    }
}


static void outputChar(char c, char *outBuf, int32_t *outIx, int32_t capacity, int32_t indent) {
    int32_t i;
    /* Check whether a start of line indenting is needed.  Three cases:
     *   1.  At the start of the first line  (output index == 0).
     *   2.  At the start of subsequent lines  (preceding char in buffer == '\n')
     *   3.  When preflighting buffer len (buffer capacity is exceeded), when
     *       a \n is output.  Ideally we wouldn't do the indent until the following char
     *       is received, but that won't work because there's no place to remember that
     *       the preceding char was \n.  Meaning that we may overstimate the
     *       buffer size needed.  No harm done.
     */
    if (*outIx==0 ||   /* case 1. */
        (c!='\n' && c!=0 && *outIx < capacity && outBuf[(*outIx)-1]=='\n') ||  /* case 2. */
        (c=='\n' && *outIx>=capacity))    /* case 3 */
    {
        /* At the start of a line.  Indent. */
        for(i=0; i<indent; i++) {
            if (*outIx < capacity) {
                outBuf[*outIx] = ' ';
            }
            (*outIx)++;
        }
    }

    if (*outIx < capacity) {
        outBuf[*outIx] = c;
    }
    if (c != 0) {
        /* NULs only appear as end-of-string terminators.  Move them to the output
         *  buffer, but do not update the length of the buffer, so that any
         *  following output will overwrite the NUL. */
        (*outIx)++;
    }
}

static void outputHexBytes(int64_t val, int32_t charsToOutput,
                           char *outBuf, int32_t *outIx, int32_t capacity) {
    static const char gHexChars[] = "0123456789abcdef";
    int32_t shiftCount;
    for  (shiftCount=(charsToOutput-1)*4; shiftCount >= 0; shiftCount-=4) {
        char c = gHexChars[(val >> shiftCount) & 0xf];
        outputChar(c, outBuf, outIx, capacity, 0);
    }
}

/* Output a pointer value in hex.  Work with any size of pointer   */
static void outputPtrBytes(void *val, char *outBuf, int32_t *outIx, int32_t capacity) {
    uint32_t  i;
    int32_t  incVal = 1;              /* +1 for big endian, -1 for little endian          */
    char* p = reinterpret_cast<char*>(&val); /* point to current byte to output in the ptr val  */

#if !U_IS_BIG_ENDIAN
    /* Little Endian.  Move p to most significant end of the value      */
    incVal = -1;
    p += sizeof(void *) - 1;
#endif

    /* Loop through the bytes of the ptr as it sits in memory, from 
     * most significant to least significant end                    */
    for (i=0; i<sizeof(void *); i++) {
        outputHexBytes(*p, 2, outBuf, outIx, capacity);
        p += incVal;
    }
}

static void outputString(const char *s, char *outBuf, int32_t *outIx, int32_t capacity, int32_t indent) {
    int32_t i = 0;
    char    c;
    if (s==nullptr) {
        s = "*NULL*";
    }
    do {
        c = s[i++];
        outputChar(c, outBuf, outIx, capacity, indent);
    } while (c != 0);
}
        


static void outputUString(const char16_t *s, int32_t len,
                          char *outBuf, int32_t *outIx, int32_t capacity, int32_t indent) {
    int32_t i = 0;
    char16_t   c;
    if (s==nullptr) {
        outputString(nullptr, outBuf, outIx, capacity, indent);
        return;
    }

    for (i=0; i<len || len==-1; i++) {
        c = s[i];
        outputHexBytes(c, 4, outBuf, outIx, capacity);
        outputChar(' ', outBuf, outIx, capacity, indent);
        if (len == -1 && c==0) {
            break;
        }
    }
}
        
U_CAPI int32_t U_EXPORT2
utrace_vformat(char *outBuf, int32_t capacity, int32_t indent, const char *fmt, va_list args) {
    int32_t   outIx  = 0;
    int32_t   fmtIx  = 0;
    char      fmtC;
    char      c;
    int32_t   intArg;
    int64_t   longArg = 0;
    char      *ptrArg;

    /*   Loop runs once for each character in the format string.
     */
    for (;;) {
        fmtC = fmt[fmtIx++];
        if (fmtC != '%') {
            /* Literal character, not part of a %sequence.  Just copy it to the output. */
            outputChar(fmtC, outBuf, &outIx, capacity, indent);
            if (fmtC == 0) {
                /* We hit the NUL that terminates the format string.
                 * This is the normal (and only) exit from the loop that
                 * interprets the format
                 */
                break;
            }
            continue;
        }

        /* We encountered a '%'.  Pick up the following format char */
        fmtC = fmt[fmtIx++];

        switch (fmtC) {
        case 'c':
            /* single 8 bit char   */
            c = (char)va_arg(args, int32_t);
            outputChar(c, outBuf, &outIx, capacity, indent);
            break;

        case 's':
            /* char * string, NUL terminated.  */
            ptrArg = va_arg(args, char *);
            outputString((const char *)ptrArg, outBuf, &outIx, capacity, indent);
            break;

        case 'S':
            /* char16_t * string, with length, len==-1 for NUL terminated. */
            ptrArg = va_arg(args, char *);             /* Ptr    */
            intArg = va_arg(args, int32_t);            /* Length */
            outputUString((const char16_t *)ptrArg, intArg, outBuf, &outIx, capacity, indent);
            break;

        case 'b':
            /*  8 bit int  */
            intArg = va_arg(args, int);
            outputHexBytes(intArg, 2, outBuf, &outIx, capacity);
            break;

        case 'h':
            /*  16 bit int  */
            intArg = va_arg(args, int);
            outputHexBytes(intArg, 4, outBuf, &outIx, capacity);
            break;

        case 'd':
            /*  32 bit int  */
            intArg = va_arg(args, int);
            outputHexBytes(intArg, 8, outBuf, &outIx, capacity);
            break;

        case 'l':
            /*  64 bit long  */
            longArg = va_arg(args, int64_t);
            outputHexBytes(longArg, 16, outBuf, &outIx, capacity);
            break;
            
        case 'p':
            /*  Pointers.   */
            ptrArg = va_arg(args, char *);
            outputPtrBytes(ptrArg, outBuf, &outIx, capacity);
            break;

        case 0:
            /* Single '%' at end of fmt string.  Output as literal '%'.   
             * Back up index into format string so that the terminating NUL will be
             * re-fetched in the outer loop, causing it to terminate.
             */
            outputChar('%', outBuf, &outIx, capacity, indent);
            fmtIx--;
            break;

        case 'v':
            {
                /* Vector of values, e.g. %vh */
                char     vectorType;
                int32_t  vectorLen;
                const char   *i8Ptr;
                int16_t  *i16Ptr;
                int32_t  *i32Ptr;
                int64_t  *i64Ptr;
                void     **ptrPtr;
                int32_t   charsToOutput = 0;
                int32_t   i;
                
                vectorType = fmt[fmtIx];    /* b, h, d, l, p, etc. */
                if (vectorType != 0) {
                    fmtIx++;
                }
                i8Ptr = (const char *)va_arg(args, void*);
                i16Ptr = (int16_t *)i8Ptr;
                i32Ptr = (int32_t *)i8Ptr;
                i64Ptr = (int64_t *)i8Ptr;
                ptrPtr = (void **)i8Ptr;
                vectorLen = va_arg(args, int32_t);
                if (ptrPtr == nullptr) {
                    outputString("*NULL* ", outBuf, &outIx, capacity, indent);
                } else {
                    for (i=0; i<vectorLen || vectorLen==-1; i++) { 
                        switch (vectorType) {
                        case 'b':
                            charsToOutput = 2;
                            longArg = *i8Ptr++;
                            break;
                        case 'h':
                            charsToOutput = 4;
                            longArg = *i16Ptr++;
                            break;
                        case 'd':
                            charsToOutput = 8;
                            longArg = *i32Ptr++;
                            break;
                        case 'l':
                            charsToOutput = 16;
                            longArg = *i64Ptr++;
                            break;
                        case 'p':
                            charsToOutput = 0;
                            outputPtrBytes(*ptrPtr, outBuf, &outIx, capacity);
                            longArg = *ptrPtr==nullptr? 0: 1;    /* test for nullptr terminated array. */
                            ptrPtr++;
                            break;
                        case 'c':
                            charsToOutput = 0;
                            outputChar(*i8Ptr, outBuf, &outIx, capacity, indent);
                            longArg = *i8Ptr;    /* for test for nullptr terminated array. */
                            i8Ptr++;
                            break;
                        case 's':
                            charsToOutput = 0;
                            outputString((const char *)*ptrPtr, outBuf, &outIx, capacity, indent);
                            outputChar('\n', outBuf, &outIx, capacity, indent);
                            longArg = *ptrPtr==nullptr? 0: 1;   /* for test for nullptr term. array. */
                            ptrPtr++;
                            break;

                        case 'S':
                            charsToOutput = 0;
                            outputUString((const char16_t *)*ptrPtr, -1, outBuf, &outIx, capacity, indent);
                            outputChar('\n', outBuf, &outIx, capacity, indent);
                            longArg = *ptrPtr==nullptr? 0: 1;   /* for test for nullptr term. array. */
                            ptrPtr++;
                            break;

                            
                        }
                        if (charsToOutput > 0) {
                            outputHexBytes(longArg, charsToOutput, outBuf, &outIx, capacity);
                            outputChar(' ', outBuf, &outIx, capacity, indent);
                        }
                        if (vectorLen == -1 && longArg == 0) {
                            break;
                        }
                    }
                }
                outputChar('[', outBuf, &outIx, capacity, indent);
                outputHexBytes(vectorLen, 8, outBuf, &outIx, capacity);
                outputChar(']', outBuf, &outIx, capacity, indent);
            }
            break;


        default:
            /* %. in format string, where . is some character not in the set
             *    of recognized format chars.  Just output it as if % wasn't there.
             *    (Covers "%%" outputting a single '%')
             */
             outputChar(fmtC, outBuf, &outIx, capacity, indent);
        }
    }
    outputChar(0, outBuf, &outIx, capacity, indent);  /* Make sure that output is NUL terminated   */
    return outIx + 1;     /* outIx + 1 because outIx does not increment when outputting final NUL. */
}




U_CAPI int32_t U_EXPORT2
utrace_format(char *outBuf, int32_t capacity,
                int32_t indent, const char *fmt,  ...) {
    int32_t retVal;
    va_list args;
    va_start(args, fmt ); 
    retVal = utrace_vformat(outBuf, capacity, indent, fmt, args);
    va_end(args);
    return retVal;
}


U_CAPI void U_EXPORT2
utrace_setFunctions(const void *context,
                    UTraceEntry *e, UTraceExit *x, UTraceData *d) {
    pTraceEntryFunc = e;
    pTraceExitFunc  = x;
    pTraceDataFunc  = d;
    gTraceContext   = context;
}


U_CAPI void U_EXPORT2
utrace_getFunctions(const void **context,
                    UTraceEntry **e, UTraceExit **x, UTraceData **d) {
    *e = pTraceEntryFunc;
    *x = pTraceExitFunc;
    *d = pTraceDataFunc;
    *context = gTraceContext;
}

U_CAPI void U_EXPORT2
utrace_setLevel(int32_t level) {
    if (level < UTRACE_OFF) {
        level = UTRACE_OFF;
    }
    if (level > UTRACE_VERBOSE) {
        level = UTRACE_VERBOSE;
    }
    utrace_level = level;
}

U_CAPI int32_t U_EXPORT2
utrace_getLevel() {
    return utrace_level;
}


U_CFUNC UBool 
utrace_cleanup() {
    pTraceEntryFunc = nullptr;
    pTraceExitFunc  = nullptr;
    pTraceDataFunc  = nullptr;
    utrace_level    = UTRACE_OFF;
    gTraceContext   = nullptr;
    return true;
}


static const char * const
trFnName[] = {
    "u_init",
    "u_cleanup",
    nullptr
};


static const char * const
trConvNames[] = {
    "ucnv_open",
    "ucnv_openPackage",
    "ucnv_openAlgorithmic",
    "ucnv_clone",
    "ucnv_close",
    "ucnv_flushCache",
    "ucnv_load",
    "ucnv_unload",
    nullptr
};

    
static const char * const
trCollNames[] = {
    "ucol_open",
    "ucol_close",
    "ucol_strcoll",
    "ucol_getSortKey",
    "ucol_getLocale",
    "ucol_nextSortKeyPart",
    "ucol_strcollIter",
    "ucol_openFromShortString",
    "ucol_strcollUTF8",
    nullptr
};


static const char* const
trResDataNames[] = {
    "resc",
    "bundle-open",
    "file-open",
    "res-open",
    nullptr
};

                
U_CAPI const char * U_EXPORT2
utrace_functionName(int32_t fnNumber) {
    if(UTRACE_FUNCTION_START <= fnNumber && fnNumber < UTRACE_FUNCTION_LIMIT) {
        return trFnName[fnNumber];
    } else if(UTRACE_CONVERSION_START <= fnNumber && fnNumber < UTRACE_CONVERSION_LIMIT) {
        return trConvNames[fnNumber - UTRACE_CONVERSION_START];
    } else if(UTRACE_COLLATION_START <= fnNumber && fnNumber < UTRACE_COLLATION_LIMIT){
        return trCollNames[fnNumber - UTRACE_COLLATION_START];
    } else if(UTRACE_UDATA_START <= fnNumber && fnNumber < UTRACE_RES_DATA_LIMIT){
        return trResDataNames[fnNumber - UTRACE_UDATA_START];
    } else {
        return "[BOGUS Trace Function Number]";
    }
}

                           node-23.7.0/deps/icu-small/source/common/utracimp.h                                                 0000664 0000000 0000000 00000034051 14746647661 0022166 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
*******************************************************************************
*
*   Copyright (C) 2003-2009, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
*******************************************************************************
*   file name:  utracimp.h
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2003aug06
*   created by: Markus W. Scherer
*
*   Internal header for ICU tracing/logging.
*
*
*   Various notes:
*   - using a trace level variable to only call trace functions
*     when the level is sufficient
*   - using the same variable for tracing on/off to never make a function
*     call when off
*   - the function number is put into a local variable by the entry macro
*     and used implicitly to avoid copy&paste/typing mistakes by the developer
*   - the application must call utrace_setFunctions() and pass in
*     implementations for the trace functions
*   - ICU trace macros call ICU functions that route through the function
*     pointers if they have been set;
*     this avoids an indirection at the call site
*     (which would cost more code for another check and for the indirection)
*
*   ### TODO Issues:
*   - Verify that va_list is portable among compilers for the same platform.
*     va_list should be portable because printf() would fail otherwise!
*   - Should enum values like UTraceLevel be passed into int32_t-type arguments,
*     or should enum types be used?
*/

#ifndef __UTRACIMP_H__
#define __UTRACIMP_H__

#include "unicode/utrace.h"
#include <stdarg.h>

U_CDECL_BEGIN

/** 
 *   Traced Function Exit return types.  
 *   Flags indicating the number and types of varargs included in a call
 *   to a UTraceExit function.
 *   Bits 0-3:  The function return type.  First variable param.
 *   Bit    4:  Flag for presence of U_ErrorCode status param.
 *   @internal
 */
typedef enum UTraceExitVal {
    /** The traced function returns no value  @internal */
    UTRACE_EXITV_NONE   = 0,
    /** The traced function returns an int32_t, or compatible, type.  @internal */
    UTRACE_EXITV_I32    = 1,
    /** The traced function returns a pointer  @internal */
    UTRACE_EXITV_PTR    = 2,
    /** The traced function returns a UBool  @internal */
    UTRACE_EXITV_BOOL   = 3,
    /** Mask to extract the return type values from a UTraceExitVal  @internal */
    UTRACE_EXITV_MASK   = 0xf,
    /** Bit indicating that the traced function includes a UErrorCode parameter  @internal */
    UTRACE_EXITV_STATUS = 0x10
} UTraceExitVal;

/**
 * Trace function for the entry point of a function.
 * Do not use directly, use UTRACE_ENTRY instead.
 * @param fnNumber The UTraceFunctionNumber for the current function.
 * @internal
 */
U_CAPI void U_EXPORT2
utrace_entry(int32_t fnNumber);

/**
 * Trace function for each exit point of a function.
 * Do not use directly, use UTRACE_EXIT* instead.
 * @param fnNumber The UTraceFunctionNumber for the current function.
 * @param returnType The type of the value returned by the function.
 * @param errorCode The UErrorCode value at function exit. See UTRACE_EXIT.
 * @internal
 */
U_CAPI void U_EXPORT2
utrace_exit(int32_t fnNumber, int32_t returnType, ...);


/**
 * Trace function used inside functions that have a UTRACE_ENTRY() statement.
 * Do not use directly, use UTRACE_DATAX() macros instead.
 *
 * @param utraceFnNumber The number of the current function, from the local
 *        variable of the same name.
 * @param level The trace level for this message.
 * @param fmt The trace format string.
 *
 * @internal
 */
U_CAPI void U_EXPORT2
utrace_data(int32_t utraceFnNumber, int32_t level, const char *fmt, ...);

U_CDECL_END

#if U_ENABLE_TRACING

/**
 * Boolean expression to see if ICU tracing is turned on
 * to at least the specified level.
 * @internal
 */
#define UTRACE_LEVEL(level) (utrace_getLevel()>=(level))

/**
  *  Flag bit in utraceFnNumber, the local variable added to each function 
  *  with tracing code to contains the function number.
  *
  *  Set the flag if the function's entry is traced, which will cause the
  *  function's exit to also be traced.  utraceFnNumber is uncoditionally 
  *  set at entry, whether or not the entry is traced, so that it will
  *  always be available for error trace output.
  *  @internal
  */            
#define UTRACE_TRACED_ENTRY 0x80000000

/**
 * Trace statement for the entry point of a function.
 * Stores the function number in a local variable.
 * In C code, must be placed immediately after the last variable declaration.
 * Must be matched with UTRACE_EXIT() at all function exit points.
 *
 * Tracing should start with UTRACE_ENTRY after checking for
 * U_FAILURE at function entry, so that if a function returns immediately
 * because of a pre-existing error condition, it does not show up in the trace,
 * consistent with ICU's error handling model.
 *
 * @param fnNumber The UTraceFunctionNumber for the current function.
 * @internal
 */
#define UTRACE_ENTRY(fnNumber) \
    int32_t utraceFnNumber=(fnNumber); \
UPRV_BLOCK_MACRO_BEGIN { \
    if(utrace_getLevel()>=UTRACE_INFO) { \
        utrace_entry(fnNumber); \
        utraceFnNumber |= UTRACE_TRACED_ENTRY; \
    } \
} UPRV_BLOCK_MACRO_END


/**
 * Trace statement for the entry point of open and close functions.
 * Produces trace output at a less verbose setting than plain UTRACE_ENTRY
 * Stores the function number in a local variable.
 * In C code, must be placed immediately after the last variable declaration.
 * Must be matched with UTRACE_EXIT() at all function exit points.
 *
 * @param fnNumber The UTraceFunctionNumber for the current function.
 * @internal
 */
#define UTRACE_ENTRY_OC(fnNumber) \
    int32_t utraceFnNumber=(fnNumber); \
UPRV_BLOCK_MACRO_BEGIN { \
    if(utrace_getLevel()>=UTRACE_OPEN_CLOSE) { \
        utrace_entry(fnNumber); \
        utraceFnNumber |= UTRACE_TRACED_ENTRY; \
    } \
} UPRV_BLOCK_MACRO_END

/**
 * Trace statement for each exit point of a function that has a UTRACE_ENTRY()
 * statement.
 *
 * @param errorCode The function's ICU UErrorCode value at function exit,
 *                  or U_ZERO_ERROR if the function does not use a UErrorCode.
 *                  0==U_ZERO_ERROR indicates success,
 *                  positive values an error (see u_errorName()),
 *                  negative values an informational status.
 *
 * @internal
 */
#define UTRACE_EXIT() UPRV_BLOCK_MACRO_BEGIN { \
    if(utraceFnNumber & UTRACE_TRACED_ENTRY) { \
        utrace_exit(utraceFnNumber & ~UTRACE_TRACED_ENTRY, UTRACE_EXITV_NONE); \
    } \
} UPRV_BLOCK_MACRO_END

/**
 * Trace statement for each exit point of a function that has a UTRACE_ENTRY()
 * statement, and that returns a value.
 *
 * @param val       The function's return value, int32_t or compatible type.
 *
 * @internal 
 */
#define UTRACE_EXIT_VALUE(val) UPRV_BLOCK_MACRO_BEGIN { \
    if(utraceFnNumber & UTRACE_TRACED_ENTRY) { \
        utrace_exit(utraceFnNumber & ~UTRACE_TRACED_ENTRY, UTRACE_EXITV_I32, val); \
    } \
} UPRV_BLOCK_MACRO_END

#define UTRACE_EXIT_STATUS(status) UPRV_BLOCK_MACRO_BEGIN { \
    if(utraceFnNumber & UTRACE_TRACED_ENTRY) { \
        utrace_exit(utraceFnNumber & ~UTRACE_TRACED_ENTRY, UTRACE_EXITV_STATUS, status); \
    } \
} UPRV_BLOCK_MACRO_END

#define UTRACE_EXIT_VALUE_STATUS(val, status) UPRV_BLOCK_MACRO_BEGIN { \
    if(utraceFnNumber & UTRACE_TRACED_ENTRY) { \
        utrace_exit(utraceFnNumber & ~UTRACE_TRACED_ENTRY, (UTRACE_EXITV_I32 | UTRACE_EXITV_STATUS), val, status); \
    } \
} UPRV_BLOCK_MACRO_END

#define UTRACE_EXIT_PTR_STATUS(ptr, status) UPRV_BLOCK_MACRO_BEGIN { \
    if(utraceFnNumber & UTRACE_TRACED_ENTRY) { \
        utrace_exit(utraceFnNumber & ~UTRACE_TRACED_ENTRY, (UTRACE_EXITV_PTR | UTRACE_EXITV_STATUS), ptr, status); \
    } \
} UPRV_BLOCK_MACRO_END

/**
 * Trace statement used inside functions that have a UTRACE_ENTRY() statement.
 * Takes no data arguments.
 * The number of arguments for this macro must match the number of inserts
 * in the format string. Vector inserts count as two arguments.
 * Calls utrace_data() if the level is high enough.
 * @internal
 */
#define UTRACE_DATA0(level, fmt) UPRV_BLOCK_MACRO_BEGIN { \
    if(UTRACE_LEVEL(level)) { \
        utrace_data(utraceFnNumber & ~UTRACE_TRACED_ENTRY, (level), (fmt)); \
    } \
} UPRV_BLOCK_MACRO_END

/**
 * Trace statement used inside functions that have a UTRACE_ENTRY() statement.
 * Takes one data argument.
 * The number of arguments for this macro must match the number of inserts
 * in the format string. Vector inserts count as two arguments.
 * Calls utrace_data() if the level is high enough.
 * @internal
 */
#define UTRACE_DATA1(level, fmt, a) UPRV_BLOCK_MACRO_BEGIN { \
    if(UTRACE_LEVEL(level)) { \
        utrace_data(utraceFnNumber & ~UTRACE_TRACED_ENTRY , (level), (fmt), (a)); \
    } \
} UPRV_BLOCK_MACRO_END

/**
 * Trace statement used inside functions that have a UTRACE_ENTRY() statement.
 * Takes two data arguments.
 * The number of arguments for this macro must match the number of inserts
 * in the format string. Vector inserts count as two arguments.
 * Calls utrace_data() if the level is high enough.
 * @internal
 */
#define UTRACE_DATA2(level, fmt, a, b) UPRV_BLOCK_MACRO_BEGIN { \
    if(UTRACE_LEVEL(level)) { \
        utrace_data(utraceFnNumber & ~UTRACE_TRACED_ENTRY , (level), (fmt), (a), (b)); \
    } \
} UPRV_BLOCK_MACRO_END

/**
 * Trace statement used inside functions that have a UTRACE_ENTRY() statement.
 * Takes three data arguments.
 * The number of arguments for this macro must match the number of inserts
 * in the format string. Vector inserts count as two arguments.
 * Calls utrace_data() if the level is high enough.
 * @internal
 */
#define UTRACE_DATA3(level, fmt, a, b, c) UPRV_BLOCK_MACRO_BEGIN { \
    if(UTRACE_LEVEL(level)) { \
        utrace_data(utraceFnNumber & ~UTRACE_TRACED_ENTRY, (level), (fmt), (a), (b), (c)); \
    } \
} UPRV_BLOCK_MACRO_END

/**
 * Trace statement used inside functions that have a UTRACE_ENTRY() statement.
 * Takes four data arguments.
 * The number of arguments for this macro must match the number of inserts
 * in the format string. Vector inserts count as two arguments.
 * Calls utrace_data() if the level is high enough.
 * @internal
 */
#define UTRACE_DATA4(level, fmt, a, b, c, d) UPRV_BLOCK_MACRO_BEGIN { \
    if(UTRACE_LEVEL(level)) { \
        utrace_data(utraceFnNumber & ~UTRACE_TRACED_ENTRY, (level), (fmt), (a), (b), (c), (d)); \
    } \
} UPRV_BLOCK_MACRO_END

/**
 * Trace statement used inside functions that have a UTRACE_ENTRY() statement.
 * Takes five data arguments.
 * The number of arguments for this macro must match the number of inserts
 * in the format string. Vector inserts count as two arguments.
 * Calls utrace_data() if the level is high enough.
 * @internal
 */
#define UTRACE_DATA5(level, fmt, a, b, c, d, e) UPRV_BLOCK_MACRO_BEGIN { \
    if(UTRACE_LEVEL(level)) { \
        utrace_data(utraceFnNumber & ~UTRACE_TRACED_ENTRY, (level), (fmt), (a), (b), (c), (d), (e)); \
    } \
} UPRV_BLOCK_MACRO_END

/**
 * Trace statement used inside functions that have a UTRACE_ENTRY() statement.
 * Takes six data arguments.
 * The number of arguments for this macro must match the number of inserts
 * in the format string. Vector inserts count as two arguments.
 * Calls utrace_data() if the level is high enough.
 * @internal
 */
#define UTRACE_DATA6(level, fmt, a, b, c, d, e, f) UPRV_BLOCK_MACRO_BEGIN { \
    if(UTRACE_LEVEL(level)) { \
        utrace_data(utraceFnNumber & ~UTRACE_TRACED_ENTRY, (level), (fmt), (a), (b), (c), (d), (e), (f)); \
    } \
} UPRV_BLOCK_MACRO_END

/**
 * Trace statement used inside functions that have a UTRACE_ENTRY() statement.
 * Takes seven data arguments.
 * The number of arguments for this macro must match the number of inserts
 * in the format string. Vector inserts count as two arguments.
 * Calls utrace_data() if the level is high enough.
 * @internal
 */
#define UTRACE_DATA7(level, fmt, a, b, c, d, e, f, g) UPRV_BLOCK_MACRO_BEGIN { \
    if(UTRACE_LEVEL(level)) { \
        utrace_data(utraceFnNumber & ~UTRACE_TRACED_ENTRY, (level), (fmt), (a), (b), (c), (d), (e), (f), (g)); \
    } \
} UPRV_BLOCK_MACRO_END

/**
 * Trace statement used inside functions that have a UTRACE_ENTRY() statement.
 * Takes eight data arguments.
 * The number of arguments for this macro must match the number of inserts
 * in the format string. Vector inserts count as two arguments.
 * Calls utrace_data() if the level is high enough.
 * @internal
 */
#define UTRACE_DATA8(level, fmt, a, b, c, d, e, f, g, h) UPRV_BLOCK_MACRO_BEGIN { \
    if(UTRACE_LEVEL(level)) { \
        utrace_data(utraceFnNumber & ~UTRACE_TRACED_ENTRY, (level), (fmt), (a), (b), (c), (d), (e), (f), (g), (h)); \
    } \
} UPRV_BLOCK_MACRO_END

/**
 * Trace statement used inside functions that have a UTRACE_ENTRY() statement.
 * Takes nine data arguments.
 * The number of arguments for this macro must match the number of inserts
 * in the format string. Vector inserts count as two arguments.
 * Calls utrace_data() if the level is high enough.
 * @internal
 */
#define UTRACE_DATA9(level, fmt, a, b, c, d, e, f, g, h, i) UPRV_BLOCK_MACRO_BEGIN { \
    if(UTRACE_LEVEL(level)) { \
        utrace_data(utraceFnNumber & ~UTRACE_TRACED_ENTRY, (level), (fmt), (a), (b), (c), (d), (e), (f), (g), (h), (i)); \
    } \
} UPRV_BLOCK_MACRO_END

#else

/*
 * When tracing is disabled, the following macros become empty
 */

#define UTRACE_LEVEL(level) 0
#define UTRACE_ENTRY(fnNumber)
#define UTRACE_ENTRY_OC(fnNumber)
#define UTRACE_EXIT()
#define UTRACE_EXIT_VALUE(val)
#define UTRACE_EXIT_STATUS(status)
#define UTRACE_EXIT_VALUE_STATUS(val, status)
#define UTRACE_EXIT_PTR_STATUS(ptr, status)
#define UTRACE_DATA0(level, fmt)
#define UTRACE_DATA1(level, fmt, a)
#define UTRACE_DATA2(level, fmt, a, b)
#define UTRACE_DATA3(level, fmt, a, b, c)
#define UTRACE_DATA4(level, fmt, a, b, c, d)
#define UTRACE_DATA5(level, fmt, a, b, c, d, e)
#define UTRACE_DATA6(level, fmt, a, b, c, d, e, f)
#define UTRACE_DATA7(level, fmt, a, b, c, d, e, f, g)
#define UTRACE_DATA8(level, fmt, a, b, c, d, e, f, g, h)
#define UTRACE_DATA9(level, fmt, a, b, c, d, e, f, g, h, i)

#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/icu-small/source/common/utrie.cpp                                                  0000664 0000000 0000000 00000113657 14746647661 0022037 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 2001-2012, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*   file name:  utrie.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2001oct20
*   created by: Markus W. Scherer
*
*   This is a common implementation of a "folded" trie.
*   It is a kind of compressed, serializable table of 16- or 32-bit values associated with
*   Unicode code points (0..0x10ffff).
*/

#ifdef UTRIE_DEBUG
#   include <stdio.h>
#endif

#include "unicode/utypes.h"
#include "cmemory.h"
#include "utrie.h"

/* miscellaneous ------------------------------------------------------------ */

#undef ABS
#define ABS(x) ((x)>=0 ? (x) : -(x))

static inline UBool
equal_uint32(const uint32_t *s, const uint32_t *t, int32_t length) {
    while(length>0 && *s==*t) {
        ++s;
        ++t;
        --length;
    }
    return length == 0;
}

/* Building a trie ----------------------------------------------------------*/

U_CAPI UNewTrie * U_EXPORT2
utrie_open(UNewTrie *fillIn,
           uint32_t *aliasData, int32_t maxDataLength,
           uint32_t initialValue, uint32_t leadUnitValue,
           UBool latin1Linear) {
    UNewTrie *trie;
    int32_t i, j;

    if( maxDataLength<UTRIE_DATA_BLOCK_LENGTH ||
        (latin1Linear && maxDataLength<1024)
    ) {
        return nullptr;
    }

    if(fillIn!=nullptr) {
        trie=fillIn;
    } else {
        trie=(UNewTrie *)uprv_malloc(sizeof(UNewTrie));
        if(trie==nullptr) {
            return nullptr;
        }
    }
    uprv_memset(trie, 0, sizeof(UNewTrie));
    trie->isAllocated = fillIn == nullptr;

    if(aliasData!=nullptr) {
        trie->data=aliasData;
        trie->isDataAllocated=false;
    } else {
        trie->data=(uint32_t *)uprv_malloc(maxDataLength*4);
        if(trie->data==nullptr) {
            uprv_free(trie);
            return nullptr;
        }
        trie->isDataAllocated=true;
    }

    /* preallocate and reset the first data block (block index 0) */
    j=UTRIE_DATA_BLOCK_LENGTH;

    if(latin1Linear) {
        /* preallocate and reset the first block (number 0) and Latin-1 (U+0000..U+00ff) after that */
        /* made sure above that maxDataLength>=1024 */

        /* set indexes to point to consecutive data blocks */
        i=0;
        do {
            /* do this at least for trie->index[0] even if that block is only partly used for Latin-1 */
            trie->index[i++]=j;
            j+=UTRIE_DATA_BLOCK_LENGTH;
        } while(i<(256>>UTRIE_SHIFT));
    }

    /* reset the initially allocated blocks to the initial value */
    trie->dataLength=j;
    while(j>0) {
        trie->data[--j]=initialValue;
    }

    trie->leadUnitValue=leadUnitValue;
    trie->indexLength=UTRIE_MAX_INDEX_LENGTH;
    trie->dataCapacity=maxDataLength;
    trie->isLatin1Linear=latin1Linear;
    trie->isCompacted=false;
    return trie;
}

U_CAPI UNewTrie * U_EXPORT2
utrie_clone(UNewTrie *fillIn, const UNewTrie *other, uint32_t *aliasData, int32_t aliasDataCapacity) {
    UNewTrie *trie;
    UBool isDataAllocated;

    /* do not clone if other is not valid or already compacted */
    if(other==nullptr || other->data==nullptr || other->isCompacted) {
        return nullptr;
    }

    /* clone data */
    if(aliasData!=nullptr && aliasDataCapacity>=other->dataCapacity) {
        isDataAllocated=false;
    } else {
        aliasDataCapacity=other->dataCapacity;
        aliasData=(uint32_t *)uprv_malloc(other->dataCapacity*4);
        if(aliasData==nullptr) {
            return nullptr;
        }
        isDataAllocated=true;
    }

    trie=utrie_open(fillIn, aliasData, aliasDataCapacity,
                    other->data[0], other->leadUnitValue,
                    other->isLatin1Linear);
    if(trie==nullptr) {
        uprv_free(aliasData);
    } else {
        uprv_memcpy(trie->index, other->index, sizeof(trie->index));
        uprv_memcpy(trie->data, other->data, (size_t)other->dataLength*4);
        trie->dataLength=other->dataLength;
        trie->isDataAllocated=isDataAllocated;
    }

    return trie;
}

U_CAPI void U_EXPORT2
utrie_close(UNewTrie *trie) {
    if(trie!=nullptr) {
        if(trie->isDataAllocated) {
            uprv_free(trie->data);
            trie->data=nullptr;
        }
        if(trie->isAllocated) {
            uprv_free(trie);
        }
    }
}

U_CAPI uint32_t * U_EXPORT2
utrie_getData(UNewTrie *trie, int32_t *pLength) {
    if(trie==nullptr || pLength==nullptr) {
        return nullptr;
    }

    *pLength=trie->dataLength;
    return trie->data;
}

static int32_t
utrie_allocDataBlock(UNewTrie *trie) {
    int32_t newBlock, newTop;

    newBlock=trie->dataLength;
    newTop=newBlock+UTRIE_DATA_BLOCK_LENGTH;
    if(newTop>trie->dataCapacity) {
        /* out of memory in the data array */
        return -1;
    }
    trie->dataLength=newTop;
    return newBlock;
}

/**
 * No error checking for illegal arguments.
 *
 * @return -1 if no new data block available (out of memory in data array)
 * @internal
 */
static int32_t
utrie_getDataBlock(UNewTrie *trie, UChar32 c) {
    int32_t indexValue, newBlock;

    c>>=UTRIE_SHIFT;
    indexValue=trie->index[c];
    if(indexValue>0) {
        return indexValue;
    }

    /* allocate a new data block */
    newBlock=utrie_allocDataBlock(trie);
    if(newBlock<0) {
        /* out of memory in the data array */
        return -1;
    }
    trie->index[c]=newBlock;

    /* copy-on-write for a block from a setRange() */
    uprv_memcpy(trie->data+newBlock, trie->data-indexValue, 4*UTRIE_DATA_BLOCK_LENGTH);
    return newBlock;
}

/**
 * @return true if the value was successfully set
 */
U_CAPI UBool U_EXPORT2
utrie_set32(UNewTrie *trie, UChar32 c, uint32_t value) {
    int32_t block;

    /* valid, uncompacted trie and valid c? */
    if(trie==nullptr || trie->isCompacted || (uint32_t)c>0x10ffff) {
        return false;
    }

    block=utrie_getDataBlock(trie, c);
    if(block<0) {
        return false;
    }

    trie->data[block+(c&UTRIE_MASK)]=value;
    return true;
}

U_CAPI uint32_t U_EXPORT2
utrie_get32(UNewTrie *trie, UChar32 c, UBool *pInBlockZero) {
    int32_t block;

    /* valid, uncompacted trie and valid c? */
    if(trie==nullptr || trie->isCompacted || (uint32_t)c>0x10ffff) {
        if(pInBlockZero!=nullptr) {
            *pInBlockZero=true;
        }
        return 0;
    }

    block=trie->index[c>>UTRIE_SHIFT];
    if(pInBlockZero!=nullptr) {
        *pInBlockZero = block == 0;
    }

    return trie->data[ABS(block)+(c&UTRIE_MASK)];
}

/**
 * @internal
 */
static void
utrie_fillBlock(uint32_t *block, UChar32 start, UChar32 limit,
                uint32_t value, uint32_t initialValue, UBool overwrite) {
    uint32_t *pLimit;

    pLimit=block+limit;
    block+=start;
    if(overwrite) {
        while(block<pLimit) {
            *block++=value;
        }
    } else {
        while(block<pLimit) {
            if(*block==initialValue) {
                *block=value;
            }
            ++block;
        }
    }
}

U_CAPI UBool U_EXPORT2
utrie_setRange32(UNewTrie *trie, UChar32 start, UChar32 limit, uint32_t value, UBool overwrite) {
    /*
     * repeat value in [start..limit[
     * mark index values for repeat-data blocks by setting bit 31 of the index values
     * fill around existing values if any, if(overwrite)
     */
    uint32_t initialValue;
    int32_t block, rest, repeatBlock;

    /* valid, uncompacted trie and valid indexes? */
    if( trie==nullptr || trie->isCompacted ||
        (uint32_t)start>0x10ffff || (uint32_t)limit>0x110000 || start>limit
    ) {
        return false;
    }
    if(start==limit) {
        return true; /* nothing to do */
    }

    initialValue=trie->data[0];
    if(start&UTRIE_MASK) {
        UChar32 nextStart;

        /* set partial block at [start..following block boundary[ */
        block=utrie_getDataBlock(trie, start);
        if(block<0) {
            return false;
        }

        nextStart=(start+UTRIE_DATA_BLOCK_LENGTH)&~UTRIE_MASK;
        if(nextStart<=limit) {
            utrie_fillBlock(trie->data+block, start&UTRIE_MASK, UTRIE_DATA_BLOCK_LENGTH,
                            value, initialValue, overwrite);
            start=nextStart;
        } else {
            utrie_fillBlock(trie->data+block, start&UTRIE_MASK, limit&UTRIE_MASK,
                            value, initialValue, overwrite);
            return true;
        }
    }

    /* number of positions in the last, partial block */
    rest=limit&UTRIE_MASK;

    /* round down limit to a block boundary */
    limit&=~UTRIE_MASK;

    /* iterate over all-value blocks */
    if(value==initialValue) {
        repeatBlock=0;
    } else {
        repeatBlock=-1;
    }
    while(start<limit) {
        /* get index value */
        block=trie->index[start>>UTRIE_SHIFT];
        if(block>0) {
            /* already allocated, fill in value */
            utrie_fillBlock(trie->data+block, 0, UTRIE_DATA_BLOCK_LENGTH, value, initialValue, overwrite);
        } else if(trie->data[-block]!=value && (block==0 || overwrite)) {
            /* set the repeatBlock instead of the current block 0 or range block */
            if(repeatBlock>=0) {
                trie->index[start>>UTRIE_SHIFT]=-repeatBlock;
            } else {
                /* create and set and fill the repeatBlock */
                repeatBlock=utrie_getDataBlock(trie, start);
                if(repeatBlock<0) {
                    return false;
                }

                /* set the negative block number to indicate that it is a repeat block */
                trie->index[start>>UTRIE_SHIFT]=-repeatBlock;
                utrie_fillBlock(trie->data+repeatBlock, 0, UTRIE_DATA_BLOCK_LENGTH, value, initialValue, true);
            }
        }

        start+=UTRIE_DATA_BLOCK_LENGTH;
    }

    if(rest>0) {
        /* set partial block at [last block boundary..limit[ */
        block=utrie_getDataBlock(trie, start);
        if(block<0) {
            return false;
        }

        utrie_fillBlock(trie->data+block, 0, rest, value, initialValue, overwrite);
    }

    return true;
}

static int32_t
_findSameIndexBlock(const int32_t *idx, int32_t indexLength,
                    int32_t otherBlock) {
    int32_t block, i;

    for(block=UTRIE_BMP_INDEX_LENGTH; block<indexLength; block+=UTRIE_SURROGATE_BLOCK_COUNT) {
        for(i=0; i<UTRIE_SURROGATE_BLOCK_COUNT; ++i) {
            if(idx[block+i]!=idx[otherBlock+i]) {
                break;
            }
        }
        if(i==UTRIE_SURROGATE_BLOCK_COUNT) {
            return block;
        }
    }
    return indexLength;
}

/*
 * Fold the normalization data for supplementary code points into
 * a compact area on top of the BMP-part of the trie index,
 * with the lead surrogates indexing this compact area.
 *
 * Duplicate the index values for lead surrogates:
 * From inside the BMP area, where some may be overridden with folded values,
 * to just after the BMP area, where they can be retrieved for
 * code point lookups.
 */
static void
utrie_fold(UNewTrie *trie, UNewTrieGetFoldedValue *getFoldedValue, UErrorCode *pErrorCode) {
    int32_t leadIndexes[UTRIE_SURROGATE_BLOCK_COUNT];
    int32_t *idx;
    uint32_t value;
    UChar32 c;
    int32_t indexLength, block;
#ifdef UTRIE_DEBUG
    int countLeadCUWithData=0;
#endif

    idx=trie->index;

    /* copy the lead surrogate indexes into a temporary array */
    uprv_memcpy(leadIndexes, idx+(0xd800>>UTRIE_SHIFT), 4*UTRIE_SURROGATE_BLOCK_COUNT);

    /*
     * set all values for lead surrogate code *units* to leadUnitValue
     * so that, by default, runtime lookups will find no data for associated
     * supplementary code points, unless there is data for such code points
     * which will result in a non-zero folding value below that is set for
     * the respective lead units
     *
     * the above saved the indexes for surrogate code *points*
     * fill the indexes with simplified code from utrie_setRange32()
     */
    if(trie->leadUnitValue==trie->data[0]) {
        block=0; /* leadUnitValue==initialValue, use all-initial-value block */
    } else {
        /* create and fill the repeatBlock */
        block=utrie_allocDataBlock(trie);
        if(block<0) {
            /* data table overflow */
            *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
            return;
        }
        utrie_fillBlock(trie->data+block, 0, UTRIE_DATA_BLOCK_LENGTH, trie->leadUnitValue, trie->data[0], true);
        block=-block; /* negative block number to indicate that it is a repeat block */
    }
    for(c=(0xd800>>UTRIE_SHIFT); c<(0xdc00>>UTRIE_SHIFT); ++c) {
        trie->index[c]=block;
    }

    /*
     * Fold significant index values into the area just after the BMP indexes.
     * In case the first lead surrogate has significant data,
     * its index block must be used first (in which case the folding is a no-op).
     * Later all folded index blocks are moved up one to insert the copied
     * lead surrogate indexes.
     */
    indexLength=UTRIE_BMP_INDEX_LENGTH;

    /* search for any index (stage 1) entries for supplementary code points */
    for(c=0x10000; c<0x110000;) {
        if(idx[c>>UTRIE_SHIFT]!=0) {
            /* there is data, treat the full block for a lead surrogate */
            c&=~0x3ff;

#ifdef UTRIE_DEBUG
            ++countLeadCUWithData;
            /* printf("supplementary data for lead surrogate U+%04lx\n", (long)(0xd7c0+(c>>10))); */
#endif

            /* is there an identical index block? */
            block=_findSameIndexBlock(idx, indexLength, c>>UTRIE_SHIFT);

            /*
             * get a folded value for [c..c+0x400[ and,
             * if different from the value for the lead surrogate code point,
             * set it for the lead surrogate code unit
             */
            value=getFoldedValue(trie, c, block+UTRIE_SURROGATE_BLOCK_COUNT);
            if(value!=utrie_get32(trie, U16_LEAD(c), nullptr)) {
                if(!utrie_set32(trie, U16_LEAD(c), value)) {
                    /* data table overflow */
                    *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
                    return;
                }

                /* if we did not find an identical index block... */
                if(block==indexLength) {
                    /* move the actual index (stage 1) entries from the supplementary position to the new one */
                    uprv_memmove(idx+indexLength,
                                 idx+(c>>UTRIE_SHIFT),
                                 4*UTRIE_SURROGATE_BLOCK_COUNT);
                    indexLength+=UTRIE_SURROGATE_BLOCK_COUNT;
                }
            }
            c+=0x400;
        } else {
            c+=UTRIE_DATA_BLOCK_LENGTH;
        }
    }
#ifdef UTRIE_DEBUG
    if(countLeadCUWithData>0) {
        printf("supplementary data for %d lead surrogates\n", countLeadCUWithData);
    }
#endif

    /*
     * index array overflow?
     * This is to guarantee that a folding offset is of the form
     * UTRIE_BMP_INDEX_LENGTH+n*UTRIE_SURROGATE_BLOCK_COUNT with n=0..1023.
     * If the index is too large, then n>=1024 and more than 10 bits are necessary.
     *
     * In fact, it can only ever become n==1024 with completely unfoldable data and
     * the additional block of duplicated values for lead surrogates.
     */
    if(indexLength>=UTRIE_MAX_INDEX_LENGTH) {
        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
        return;
    }

    /*
     * make space for the lead surrogate index block and
     * insert it between the BMP indexes and the folded ones
     */
    uprv_memmove(idx+UTRIE_BMP_INDEX_LENGTH+UTRIE_SURROGATE_BLOCK_COUNT,
                 idx+UTRIE_BMP_INDEX_LENGTH,
                 4*(indexLength-UTRIE_BMP_INDEX_LENGTH));
    uprv_memcpy(idx+UTRIE_BMP_INDEX_LENGTH,
                leadIndexes,
                4*UTRIE_SURROGATE_BLOCK_COUNT);
    indexLength+=UTRIE_SURROGATE_BLOCK_COUNT;

#ifdef UTRIE_DEBUG
    printf("trie index count: BMP %ld  all Unicode %ld  folded %ld\n",
           UTRIE_BMP_INDEX_LENGTH, (long)UTRIE_MAX_INDEX_LENGTH, indexLength);
#endif

    trie->indexLength=indexLength;
}

/*
 * Set a value in the trie index map to indicate which data block
 * is referenced and which one is not.
 * utrie_compact() will remove data blocks that are not used at all.
 * Set
 * - 0 if it is used
 * - -1 if it is not used
 */
static void
_findUnusedBlocks(UNewTrie *trie) {
    int32_t i;

    /* fill the entire map with "not used" */
    uprv_memset(trie->map, 0xff, (UTRIE_MAX_BUILD_TIME_DATA_LENGTH>>UTRIE_SHIFT)*4);

    /* mark each block that _is_ used with 0 */
    for(i=0; i<trie->indexLength; ++i) {
        trie->map[ABS(trie->index[i])>>UTRIE_SHIFT]=0;
    }

    /* never move the all-initial-value block 0 */
    trie->map[0]=0;
}

static int32_t
_findSameDataBlock(const uint32_t *data, int32_t dataLength,
                   int32_t otherBlock, int32_t step) {
    int32_t block;

    /* ensure that we do not even partially get past dataLength */
    dataLength-=UTRIE_DATA_BLOCK_LENGTH;

    for(block=0; block<=dataLength; block+=step) {
        if(equal_uint32(data+block, data+otherBlock, UTRIE_DATA_BLOCK_LENGTH)) {
            return block;
        }
    }
    return -1;
}

/*
 * Compact a folded build-time trie.
 *
 * The compaction
 * - removes blocks that are identical with earlier ones
 * - overlaps adjacent blocks as much as possible (if overlap==true)
 * - moves blocks in steps of the data granularity
 * - moves and overlaps blocks that overlap with multiple values in the overlap region
 *
 * It does not
 * - try to move and overlap blocks that are not already adjacent
 */
static void
utrie_compact(UNewTrie *trie, UBool overlap, UErrorCode *pErrorCode) {
    int32_t i, start, newStart, overlapStart;

    if(pErrorCode==nullptr || U_FAILURE(*pErrorCode)) {
        return;
    }

    /* valid, uncompacted trie? */
    if(trie==nullptr) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }
    if(trie->isCompacted) {
        return; /* nothing left to do */
    }

    /* compaction */

    /* initialize the index map with "block is used/unused" flags */
    _findUnusedBlocks(trie);

    /* if Latin-1 is preallocated and linear, then do not compact Latin-1 data */
    if(trie->isLatin1Linear && UTRIE_SHIFT<=8) {
        overlapStart=UTRIE_DATA_BLOCK_LENGTH+256;
    } else {
        overlapStart=UTRIE_DATA_BLOCK_LENGTH;
    }

    newStart=UTRIE_DATA_BLOCK_LENGTH;
    for(start=newStart; start<trie->dataLength;) {
        /*
         * start: index of first entry of current block
         * newStart: index where the current block is to be moved
         *           (right after current end of already-compacted data)
         */

        /* skip blocks that are not used */
        if(trie->map[start>>UTRIE_SHIFT]<0) {
            /* advance start to the next block */
            start+=UTRIE_DATA_BLOCK_LENGTH;

            /* leave newStart with the previous block! */
            continue;
        }

        /* search for an identical block */
        if( start>=overlapStart &&
            (i=_findSameDataBlock(trie->data, newStart, start,
                            overlap ? UTRIE_DATA_GRANULARITY : UTRIE_DATA_BLOCK_LENGTH))
             >=0
        ) {
            /* found an identical block, set the other block's index value for the current block */
            trie->map[start>>UTRIE_SHIFT]=i;

            /* advance start to the next block */
            start+=UTRIE_DATA_BLOCK_LENGTH;

            /* leave newStart with the previous block! */
            continue;
        }

        /* see if the beginning of this block can be overlapped with the end of the previous block */
        if(overlap && start>=overlapStart) {
            /* look for maximum overlap (modulo granularity) with the previous, adjacent block */
            for(i=UTRIE_DATA_BLOCK_LENGTH-UTRIE_DATA_GRANULARITY;
                i>0 && !equal_uint32(trie->data+(newStart-i), trie->data+start, i);
                i-=UTRIE_DATA_GRANULARITY) {}
        } else {
            i=0;
        }

        if(i>0) {
            /* some overlap */
            trie->map[start>>UTRIE_SHIFT]=newStart-i;

            /* move the non-overlapping indexes to their new positions */
            start+=i;
            for(i=UTRIE_DATA_BLOCK_LENGTH-i; i>0; --i) {
                trie->data[newStart++]=trie->data[start++];
            }
        } else if(newStart<start) {
            /* no overlap, just move the indexes to their new positions */
            trie->map[start>>UTRIE_SHIFT]=newStart;
            for(i=UTRIE_DATA_BLOCK_LENGTH; i>0; --i) {
                trie->data[newStart++]=trie->data[start++];
            }
        } else /* no overlap && newStart==start */ {
            trie->map[start>>UTRIE_SHIFT]=start;
            newStart+=UTRIE_DATA_BLOCK_LENGTH;
            start=newStart;
        }
    }

    /* now adjust the index (stage 1) table */
    for(i=0; i<trie->indexLength; ++i) {
        trie->index[i]=trie->map[ABS(trie->index[i])>>UTRIE_SHIFT];
    }

#ifdef UTRIE_DEBUG
    /* we saved some space */
    printf("compacting trie: count of 32-bit words %lu->%lu\n",
            (long)trie->dataLength, (long)newStart);
#endif

    trie->dataLength=newStart;
}

/* serialization ------------------------------------------------------------ */

/*
 * Default function for the folding value:
 * Just store the offset (16 bits) if there is any non-initial-value entry.
 *
 * The offset parameter is never 0.
 * Returning the offset itself is safe for UTRIE_SHIFT>=5 because
 * for UTRIE_SHIFT==5 the maximum index length is UTRIE_MAX_INDEX_LENGTH==0x8800
 * which fits into 16-bit trie values;
 * for higher UTRIE_SHIFT, UTRIE_MAX_INDEX_LENGTH decreases.
 *
 * Theoretically, it would be safer for all possible UTRIE_SHIFT including
 * those of 4 and lower to return offset>>UTRIE_SURROGATE_BLOCK_BITS
 * which would always result in a value of 0x40..0x43f
 * (start/end 1k blocks of supplementary Unicode code points).
 * However, this would be uglier, and would not work for some existing
 * binary data file formats.
 *
 * Also, we do not plan to change UTRIE_SHIFT because it would change binary
 * data file formats, and we would probably not make it smaller because of
 * the then even larger BMP index length even for empty tries.
 */
static uint32_t U_CALLCONV
defaultGetFoldedValue(UNewTrie *trie, UChar32 start, int32_t offset) {
    uint32_t value, initialValue;
    UChar32 limit;
    UBool inBlockZero;

    initialValue=trie->data[0];
    limit=start+0x400;
    while(start<limit) {
        value=utrie_get32(trie, start, &inBlockZero);
        if(inBlockZero) {
            start+=UTRIE_DATA_BLOCK_LENGTH;
        } else if(value!=initialValue) {
            return static_cast<uint32_t>(offset);
        } else {
            ++start;
        }
    }
    return 0;
}

U_CAPI int32_t U_EXPORT2
utrie_serialize(UNewTrie *trie, void *dt, int32_t capacity,
                UNewTrieGetFoldedValue *getFoldedValue,
                UBool reduceTo16Bits,
                UErrorCode *pErrorCode) {
    UTrieHeader *header;
    uint32_t *p;
    uint16_t *dest16;
    int32_t i, length;
    uint8_t* data = nullptr;

    /* argument check */
    if(pErrorCode==nullptr || U_FAILURE(*pErrorCode)) {
        return 0;
    }

    if(trie==nullptr || capacity<0 || (capacity>0 && dt==nullptr)) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }
    if(getFoldedValue==nullptr) {
        getFoldedValue=defaultGetFoldedValue;
    }

    data = (uint8_t*)dt;
    /* fold and compact if necessary, also checks that indexLength is within limits */
    if(!trie->isCompacted) {
        /* compact once without overlap to improve folding */
        utrie_compact(trie, false, pErrorCode);

        /* fold the supplementary part of the index array */
        utrie_fold(trie, getFoldedValue, pErrorCode);

        /* compact again with overlap for minimum data array length */
        utrie_compact(trie, true, pErrorCode);

        trie->isCompacted=true;
        if(U_FAILURE(*pErrorCode)) {
            return 0;
        }
    }

    /* is dataLength within limits? */
    if( (reduceTo16Bits ? (trie->dataLength+trie->indexLength) : trie->dataLength) >= UTRIE_MAX_DATA_LENGTH) {
        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
    }

    length=sizeof(UTrieHeader)+2*trie->indexLength;
    if(reduceTo16Bits) {
        length+=2*trie->dataLength;
    } else {
        length+=4*trie->dataLength;
    }

    if(length>capacity) {
        return length; /* preflighting */
    }

#ifdef UTRIE_DEBUG
    printf("**UTrieLengths(serialize)** index:%6ld  data:%6ld  serialized:%6ld\n",
           (long)trie->indexLength, (long)trie->dataLength, (long)length);
#endif

    /* set the header fields */
    header=(UTrieHeader *)data;
    data+=sizeof(UTrieHeader);

    header->signature=0x54726965; /* "Trie" */
    header->options=UTRIE_SHIFT | (UTRIE_INDEX_SHIFT<<UTRIE_OPTIONS_INDEX_SHIFT);

    if(!reduceTo16Bits) {
        header->options|=UTRIE_OPTIONS_DATA_IS_32_BIT;
    }
    if(trie->isLatin1Linear) {
        header->options|=UTRIE_OPTIONS_LATIN1_IS_LINEAR;
    }

    header->indexLength=trie->indexLength;
    header->dataLength=trie->dataLength;

    /* write the index (stage 1) array and the 16/32-bit data (stage 2) array */
    if(reduceTo16Bits) {
        /* write 16-bit index values shifted right by UTRIE_INDEX_SHIFT, after adding indexLength */
        p=(uint32_t *)trie->index;
        dest16=(uint16_t *)data;
        for(i=trie->indexLength; i>0; --i) {
            *dest16++=(uint16_t)((*p++ + trie->indexLength)>>UTRIE_INDEX_SHIFT);
        }

        /* write 16-bit data values */
        p=trie->data;
        for(i=trie->dataLength; i>0; --i) {
            *dest16++=(uint16_t)*p++;
        }
    } else {
        /* write 16-bit index values shifted right by UTRIE_INDEX_SHIFT */
        p=(uint32_t *)trie->index;
        dest16=(uint16_t *)data;
        for(i=trie->indexLength; i>0; --i) {
            *dest16++=(uint16_t)(*p++ >> UTRIE_INDEX_SHIFT);
        }

        /* write 32-bit data values */
        uprv_memcpy(dest16, trie->data, 4*(size_t)trie->dataLength);
    }

    return length;
}

/* inverse to defaultGetFoldedValue() */
U_CAPI int32_t U_EXPORT2
utrie_defaultGetFoldingOffset(uint32_t data) {
    return (int32_t)data;
}

U_CAPI int32_t U_EXPORT2
utrie_unserialize(UTrie *trie, const void *data, int32_t length, UErrorCode *pErrorCode) {
    const UTrieHeader *header;
    const uint16_t *p16;
    uint32_t options;

    if(pErrorCode==nullptr || U_FAILURE(*pErrorCode)) {
        return -1;
    }

    /* enough data for a trie header? */
    if(length<(int32_t)sizeof(UTrieHeader)) {
        *pErrorCode=U_INVALID_FORMAT_ERROR;
        return -1;
    }

    /* check the signature */
    header=(const UTrieHeader *)data;
    if(header->signature!=0x54726965) {
        *pErrorCode=U_INVALID_FORMAT_ERROR;
        return -1;
    }

    /* get the options and check the shift values */
    options=header->options;
    if( (options&UTRIE_OPTIONS_SHIFT_MASK)!=UTRIE_SHIFT ||
        ((options>>UTRIE_OPTIONS_INDEX_SHIFT)&UTRIE_OPTIONS_SHIFT_MASK)!=UTRIE_INDEX_SHIFT
    ) {
        *pErrorCode=U_INVALID_FORMAT_ERROR;
        return -1;
    }
    trie->isLatin1Linear = (options & UTRIE_OPTIONS_LATIN1_IS_LINEAR) != 0;

    /* get the length values */
    trie->indexLength=header->indexLength;
    trie->dataLength=header->dataLength;

    length-=(int32_t)sizeof(UTrieHeader);

    /* enough data for the index? */
    if(length<2*trie->indexLength) {
        *pErrorCode=U_INVALID_FORMAT_ERROR;
        return -1;
    }
    p16=(const uint16_t *)(header+1);
    trie->index=p16;
    p16+=trie->indexLength;
    length-=2*trie->indexLength;

    /* get the data */
    if(options&UTRIE_OPTIONS_DATA_IS_32_BIT) {
        if(length<4*trie->dataLength) {
            *pErrorCode=U_INVALID_FORMAT_ERROR;
            return -1;
        }
        trie->data32=(const uint32_t *)p16;
        trie->initialValue=trie->data32[0];
        length=(int32_t)sizeof(UTrieHeader)+2*trie->indexLength+4*trie->dataLength;
    } else {
        if(length<2*trie->dataLength) {
            *pErrorCode=U_INVALID_FORMAT_ERROR;
            return -1;
        }

        /* the "data16" data is used via the index pointer */
        trie->data32=nullptr;
        trie->initialValue=trie->index[trie->indexLength];
        length=(int32_t)sizeof(UTrieHeader)+2*trie->indexLength+2*trie->dataLength;
    }

    trie->getFoldingOffset=utrie_defaultGetFoldingOffset;

    return length;
}

U_CAPI int32_t U_EXPORT2
utrie_unserializeDummy(UTrie *trie,
                       void *data, int32_t length,
                       uint32_t initialValue, uint32_t leadUnitValue,
                       UBool make16BitTrie,
                       UErrorCode *pErrorCode) {
    uint16_t *p16;
    int32_t actualLength, latin1Length, i, limit;
    uint16_t block;

    if(pErrorCode==nullptr || U_FAILURE(*pErrorCode)) {
        return -1;
    }

    /* calculate the actual size of the dummy trie data */

    /* max(Latin-1, block 0) */
    latin1Length= 256; /*UTRIE_SHIFT<=8 ? 256 : UTRIE_DATA_BLOCK_LENGTH;*/

    trie->indexLength=UTRIE_BMP_INDEX_LENGTH+UTRIE_SURROGATE_BLOCK_COUNT;
    trie->dataLength=latin1Length;
    if(leadUnitValue!=initialValue) {
        trie->dataLength+=UTRIE_DATA_BLOCK_LENGTH;
    }

    actualLength=trie->indexLength*2;
    if(make16BitTrie) {
        actualLength+=trie->dataLength*2;
    } else {
        actualLength+=trie->dataLength*4;
    }

    /* enough space for the dummy trie? */
    if(length<actualLength) {
        *pErrorCode=U_BUFFER_OVERFLOW_ERROR;
        return actualLength;
    }

    trie->isLatin1Linear=true;
    trie->initialValue=initialValue;

    /* fill the index and data arrays */
    p16=(uint16_t *)data;
    trie->index=p16;

    if(make16BitTrie) {
        /* indexes to block 0 */
        block=(uint16_t)(trie->indexLength>>UTRIE_INDEX_SHIFT);
        limit=trie->indexLength;
        for(i=0; i<limit; ++i) {
            p16[i]=block;
        }

        if(leadUnitValue!=initialValue) {
            /* indexes for lead surrogate code units to the block after Latin-1 */
            block+=(uint16_t)(latin1Length>>UTRIE_INDEX_SHIFT);
            i=0xd800>>UTRIE_SHIFT;
            limit=0xdc00>>UTRIE_SHIFT;
            for(; i<limit; ++i) {
                p16[i]=block;
            }
        }

        trie->data32=nullptr;

        /* Latin-1 data */
        p16+=trie->indexLength;
        for(i=0; i<latin1Length; ++i) {
            p16[i]=(uint16_t)initialValue;
        }

        /* data for lead surrogate code units */
        if(leadUnitValue!=initialValue) {
            limit=latin1Length+UTRIE_DATA_BLOCK_LENGTH;
            for(/* i=latin1Length */; i<limit; ++i) {
                p16[i]=(uint16_t)leadUnitValue;
            }
        }
    } else {
        uint32_t *p32;

        /* indexes to block 0 */
        uprv_memset(p16, 0, trie->indexLength*2);

        if(leadUnitValue!=initialValue) {
            /* indexes for lead surrogate code units to the block after Latin-1 */
            block=(uint16_t)(latin1Length>>UTRIE_INDEX_SHIFT);
            i=0xd800>>UTRIE_SHIFT;
            limit=0xdc00>>UTRIE_SHIFT;
            for(; i<limit; ++i) {
                p16[i]=block;
            }
        }

        trie->data32=p32=(uint32_t *)(p16+trie->indexLength);

        /* Latin-1 data */
        for(i=0; i<latin1Length; ++i) {
            p32[i]=initialValue;
        }

        /* data for lead surrogate code units */
        if(leadUnitValue!=initialValue) {
            limit=latin1Length+UTRIE_DATA_BLOCK_LENGTH;
            for(/* i=latin1Length */; i<limit; ++i) {
                p32[i]=leadUnitValue;
            }
        }
    }

    trie->getFoldingOffset=utrie_defaultGetFoldingOffset;

    return actualLength;
}

/* enumeration -------------------------------------------------------------- */

/* default UTrieEnumValue() returns the input value itself */
static uint32_t U_CALLCONV
enumSameValue(const void * /*context*/, uint32_t value) {
    return value;
}

/**
 * Enumerate all ranges of code points with the same relevant values.
 * The values are transformed from the raw trie entries by the enumValue function.
 */
U_CAPI void U_EXPORT2
utrie_enum(const UTrie *trie,
           UTrieEnumValue *enumValue, UTrieEnumRange *enumRange, const void *context) {
    const uint32_t *data32;
    const uint16_t *idx;

    uint32_t value, prevValue, initialValue;
    UChar32 c, prev;
    int32_t l, i, j, block, prevBlock, nullBlock, offset;

    /* check arguments */
    if(trie==nullptr || trie->index==nullptr || enumRange==nullptr) {
        return;
    }
    if(enumValue==nullptr) {
        enumValue=enumSameValue;
    }

    idx=trie->index;
    data32=trie->data32;

    /* get the enumeration value that corresponds to an initial-value trie data entry */
    initialValue=enumValue(context, trie->initialValue);

    if(data32==nullptr) {
        nullBlock=trie->indexLength;
    } else {
        nullBlock=0;
    }

    /* set variables for previous range */
    prevBlock=nullBlock;
    prev=0;
    prevValue=initialValue;

    /* enumerate BMP - the main loop enumerates data blocks */
    for(i=0, c=0; c<=0xffff; ++i) {
        if(c==0xd800) {
            /* skip lead surrogate code _units_, go to lead surr. code _points_ */
            i=UTRIE_BMP_INDEX_LENGTH;
        } else if(c==0xdc00) {
            /* go back to regular BMP code points */
            i=c>>UTRIE_SHIFT;
        }

        block=idx[i]<<UTRIE_INDEX_SHIFT;
        if(block==prevBlock) {
            /* the block is the same as the previous one, and filled with value */
            c+=UTRIE_DATA_BLOCK_LENGTH;
        } else if(block==nullBlock) {
            /* this is the all-initial-value block */
            if(prevValue!=initialValue) {
                if(prev<c) {
                    if(!enumRange(context, prev, c, prevValue)) {
                        return;
                    }
                }
                prevBlock=nullBlock;
                prev=c;
                prevValue=initialValue;
            }
            c+=UTRIE_DATA_BLOCK_LENGTH;
        } else {
            prevBlock=block;
            for(j=0; j<UTRIE_DATA_BLOCK_LENGTH; ++j) {
                value=enumValue(context, data32!=nullptr ? data32[block+j] : idx[block+j]);
                if(value!=prevValue) {
                    if(prev<c) {
                        if(!enumRange(context, prev, c, prevValue)) {
                            return;
                        }
                    }
                    if(j>0) {
                        /* the block is not filled with all the same value */
                        prevBlock=-1;
                    }
                    prev=c;
                    prevValue=value;
                }
                ++c;
            }
        }
    }

    /* enumerate supplementary code points */
    for(l=0xd800; l<0xdc00;) {
        /* lead surrogate access */
        offset=idx[l>>UTRIE_SHIFT]<<UTRIE_INDEX_SHIFT;
        if(offset==nullBlock) {
            /* no entries for a whole block of lead surrogates */
            if(prevValue!=initialValue) {
                if(prev<c) {
                    if(!enumRange(context, prev, c, prevValue)) {
                        return;
                    }
                }
                prevBlock=nullBlock;
                prev=c;
                prevValue=initialValue;
            }

            l+=UTRIE_DATA_BLOCK_LENGTH;
            c+=UTRIE_DATA_BLOCK_LENGTH<<10;
            continue;
        }

        value= data32!=nullptr ? data32[offset+(l&UTRIE_MASK)] : idx[offset+(l&UTRIE_MASK)];

        /* enumerate trail surrogates for this lead surrogate */
        offset=trie->getFoldingOffset(value);
        if(offset<=0) {
            /* no data for this lead surrogate */
            if(prevValue!=initialValue) {
                if(prev<c) {
                    if(!enumRange(context, prev, c, prevValue)) {
                        return;
                    }
                }
                prevBlock=nullBlock;
                prev=c;
                prevValue=initialValue;
            }

            /* nothing else to do for the supplementary code points for this lead surrogate */
            c+=0x400;
        } else {
            /* enumerate code points for this lead surrogate */
            i=offset;
            offset+=UTRIE_SURROGATE_BLOCK_COUNT;
            do {
                /* copy of most of the body of the BMP loop */
                block=idx[i]<<UTRIE_INDEX_SHIFT;
                if(block==prevBlock) {
                    /* the block is the same as the previous one, and filled with value */
                    c+=UTRIE_DATA_BLOCK_LENGTH;
                } else if(block==nullBlock) {
                    /* this is the all-initial-value block */
                    if(prevValue!=initialValue) {
                        if(prev<c) {
                            if(!enumRange(context, prev, c, prevValue)) {
                                return;
                            }
                        }
                        prevBlock=nullBlock;
                        prev=c;
                        prevValue=initialValue;
                    }
                    c+=UTRIE_DATA_BLOCK_LENGTH;
                } else {
                    prevBlock=block;
                    for(j=0; j<UTRIE_DATA_BLOCK_LENGTH; ++j) {
                        value=enumValue(context, data32!=nullptr ? data32[block+j] : idx[block+j]);
                        if(value!=prevValue) {
                            if(prev<c) {
                                if(!enumRange(context, prev, c, prevValue)) {
                                    return;
                                }
                            }
                            if(j>0) {
                                /* the block is not filled with all the same value */
                                prevBlock=-1;
                            }
                            prev=c;
                            prevValue=value;
                        }
                        ++c;
                    }
                }
            } while(++i<offset);
        }

        ++l;
    }

    /* deliver last range */
    enumRange(context, prev, c, prevValue);
}
                                                                                 node-23.7.0/deps/icu-small/source/common/utrie.h                                                    0000664 0000000 0000000 00000074615 14746647661 0021504 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 2001-2011, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*   file name:  utrie.h
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2001nov08
*   created by: Markus W. Scherer
*/

#ifndef __UTRIE_H__
#define __UTRIE_H__

#include "unicode/utypes.h"
#include "unicode/utf16.h"

U_CDECL_BEGIN

/**
 * \file
 *
 * This is a common implementation of a "folded" trie.
 * It is a kind of compressed, serializable table of 16- or 32-bit values associated with
 * Unicode code points (0..0x10ffff).
 *
 * This implementation is optimized for getting values while walking forward
 * through a UTF-16 string.
 * Therefore, the simplest and fastest access macros are the
 * _FROM_LEAD() and _FROM_OFFSET_TRAIL() macros.
 *
 * The _FROM_BMP() macros are a little more complicated; they get values
 * even for lead surrogate code _points_, while the _FROM_LEAD() macros
 * get special "folded" values for lead surrogate code _units_ if
 * there is relevant data associated with them.
 * From such a folded value, an offset needs to be extracted to supply
 * to the _FROM_OFFSET_TRAIL() macros.
 *
 * Most of the more complex (and more convenient) functions/macros call a callback function
 * to get that offset from the folded value for a lead surrogate unit.
 */

/**
 * Trie constants, defining shift widths, index array lengths, etc.
 */
enum {
    /** Shift size for shifting right the input index. 1..9 */
    UTRIE_SHIFT=5,

    /** Number of data values in a stage 2 (data array) block. 2, 4, 8, .., 0x200 */
    UTRIE_DATA_BLOCK_LENGTH=1<<UTRIE_SHIFT,

    /** Mask for getting the lower bits from the input index. */
    UTRIE_MASK=UTRIE_DATA_BLOCK_LENGTH-1,

    /**
     * Lead surrogate code points' index displacement in the index array.
     * 0x10000-0xd800=0x2800
     */
    UTRIE_LEAD_INDEX_DISP=0x2800>>UTRIE_SHIFT,

    /**
     * Shift size for shifting left the index array values.
     * Increases possible data size with 16-bit index values at the cost
     * of compactability.
     * This requires blocks of stage 2 data to be aligned by UTRIE_DATA_GRANULARITY.
     * 0..UTRIE_SHIFT
     */
    UTRIE_INDEX_SHIFT=2,

    /** The alignment size of a stage 2 data block. Also the granularity for compaction. */
    UTRIE_DATA_GRANULARITY=1<<UTRIE_INDEX_SHIFT,

    /** Number of bits of a trail surrogate that are used in index table lookups. */
    UTRIE_SURROGATE_BLOCK_BITS=10-UTRIE_SHIFT,

    /**
     * Number of index (stage 1) entries per lead surrogate.
     * Same as number of index entries for 1024 trail surrogates,
     * ==0x400>>UTRIE_SHIFT
     */
    UTRIE_SURROGATE_BLOCK_COUNT=(1<<UTRIE_SURROGATE_BLOCK_BITS),

    /** Length of the BMP portion of the index (stage 1) array. */
    UTRIE_BMP_INDEX_LENGTH=0x10000>>UTRIE_SHIFT
};

/**
 * Length of the index (stage 1) array before folding.
 * Maximum number of Unicode code points (0x110000) shifted right by UTRIE_SHIFT.
 */
#define UTRIE_MAX_INDEX_LENGTH (0x110000>>UTRIE_SHIFT)

/**
 * Maximum length of the runtime data (stage 2) array.
 * Limited by 16-bit index values that are left-shifted by UTRIE_INDEX_SHIFT.
 */
#define UTRIE_MAX_DATA_LENGTH (0x10000<<UTRIE_INDEX_SHIFT)

/**
 * Maximum length of the build-time data (stage 2) array.
 * The maximum length is 0x110000+UTRIE_DATA_BLOCK_LENGTH+0x400.
 * (Number of Unicode code points + one all-initial-value block +
 *  possible duplicate entries for 1024 lead surrogates.)
 */
#define UTRIE_MAX_BUILD_TIME_DATA_LENGTH (0x110000+UTRIE_DATA_BLOCK_LENGTH+0x400)

/**
 * Number of bytes for a dummy trie.
 * A dummy trie is an empty runtime trie, used when a real data trie cannot
 * be loaded.
 * The number of bytes works for Latin-1-linear tries with 32-bit data
 * (worst case).
 *
 * Calculation:
 *   BMP index + 1 index block for lead surrogate code points +
 *   Latin-1-linear array + 1 data block for lead surrogate code points
 *
 * Latin-1: if(UTRIE_SHIFT<=8) { 256 } else { included in first data block }
 *
 * @see utrie_unserializeDummy
 */
#define UTRIE_DUMMY_SIZE ((UTRIE_BMP_INDEX_LENGTH+UTRIE_SURROGATE_BLOCK_COUNT)*2+(UTRIE_SHIFT<=8?256:UTRIE_DATA_BLOCK_LENGTH)*4+UTRIE_DATA_BLOCK_LENGTH*4)

/**
 * Runtime UTrie callback function.
 * Extract from a lead surrogate's data the
 * index array offset of the indexes for that lead surrogate.
 *
 * @param data data value for a surrogate from the trie, including the folding offset
 * @return offset>=UTRIE_BMP_INDEX_LENGTH, or 0 if there is no data for the lead surrogate
 */
typedef int32_t U_CALLCONV
UTrieGetFoldingOffset(uint32_t data);

/**
 * Run-time Trie structure.
 *
 * Either the data table is 16 bits wide and accessed via the index
 * pointer, with each index item increased by indexLength;
 * in this case, data32==NULL.
 *
 * Or the data table is 32 bits wide and accessed via the data32 pointer.
 */
struct UTrie {
    const uint16_t *index;
    const uint32_t *data32; /* NULL if 16b data is used via index */

    /**
     * This function is not used in _FROM_LEAD, _FROM_BMP, and _FROM_OFFSET_TRAIL macros.
     * If convenience macros like _GET16 or _NEXT32 are used, this function must be set.
     *
     * utrie_unserialize() sets a default function which simply returns
     * the lead surrogate's value itself - which is the inverse of the default
     * folding function used by utrie_serialize().
     *
     * @see UTrieGetFoldingOffset
     */
    UTrieGetFoldingOffset *getFoldingOffset;

    int32_t indexLength, dataLength;
    uint32_t initialValue;
    UBool isLatin1Linear;
};

#ifndef __UTRIE2_H__
typedef struct UTrie UTrie;
#endif

/** Internal trie getter from an offset (0 if c16 is a BMP/lead units) and a 16-bit unit */
#define _UTRIE_GET_RAW(trie, data, offset, c16) \
    (trie)->data[ \
        ((int32_t)((trie)->index[(offset)+((c16)>>UTRIE_SHIFT)])<<UTRIE_INDEX_SHIFT)+ \
        ((c16)&UTRIE_MASK) \
    ]

/** Internal trie getter from a pair of surrogates */
#define _UTRIE_GET_FROM_PAIR(trie, data, c, c2, result, resultType) UPRV_BLOCK_MACRO_BEGIN { \
    int32_t __offset; \
\
    /* get data for lead surrogate */ \
    (result)=_UTRIE_GET_RAW((trie), data, 0, (c)); \
    __offset=(trie)->getFoldingOffset(result); \
\
    /* get the real data from the folded lead/trail units */ \
    if(__offset>0) { \
        (result)=_UTRIE_GET_RAW((trie), data, __offset, (c2)&0x3ff); \
    } else { \
        (result)=(resultType)((trie)->initialValue); \
    } \
} UPRV_BLOCK_MACRO_END

/** Internal trie getter from a BMP code point, treating a lead surrogate as a normal code point */
#define _UTRIE_GET_FROM_BMP(trie, data, c16) \
    _UTRIE_GET_RAW(trie, data, 0xd800<=(c16) && (c16)<=0xdbff ? UTRIE_LEAD_INDEX_DISP : 0, c16)

/**
 * Internal trie getter from a code point.
 * Could be faster(?) but longer with
 *   if((c32)<=0xd7ff) { (result)=_UTRIE_GET_RAW(trie, data, 0, c32); }
 */
#define _UTRIE_GET(trie, data, c32, result, resultType) UPRV_BLOCK_MACRO_BEGIN { \
    if((uint32_t)(c32)<=0xffff) { \
        /* BMP code points */ \
        (result)=_UTRIE_GET_FROM_BMP(trie, data, c32); \
    } else if((uint32_t)(c32)<=0x10ffff) { \
        /* supplementary code point */ \
        UChar __lead16=U16_LEAD(c32); \
        _UTRIE_GET_FROM_PAIR(trie, data, __lead16, c32, result, resultType); \
    } else { \
        /* out of range */ \
        (result)=(resultType)((trie)->initialValue); \
    } \
} UPRV_BLOCK_MACRO_END

/** Internal next-post-increment: get the next code point (c, c2) and its data */
#define _UTRIE_NEXT(trie, data, src, limit, c, c2, result, resultType) UPRV_BLOCK_MACRO_BEGIN { \
    (c)=*(src)++; \
    if(!U16_IS_LEAD(c)) { \
        (c2)=0; \
        (result)=_UTRIE_GET_RAW((trie), data, 0, (c)); \
    } else if((src)!=(limit) && U16_IS_TRAIL((c2)=*(src))) { \
        ++(src); \
        _UTRIE_GET_FROM_PAIR((trie), data, (c), (c2), (result), resultType); \
    } else { \
        /* unpaired lead surrogate code point */ \
        (c2)=0; \
        (result)=_UTRIE_GET_RAW((trie), data, UTRIE_LEAD_INDEX_DISP, (c)); \
    } \
} UPRV_BLOCK_MACRO_END

/** Internal previous: get the previous code point (c, c2) and its data */
#define _UTRIE_PREVIOUS(trie, data, start, src, c, c2, result, resultType) UPRV_BLOCK_MACRO_BEGIN { \
    (c)=*--(src); \
    if(!U16_IS_SURROGATE(c)) { \
        (c2)=0; \
        (result)=_UTRIE_GET_RAW((trie), data, 0, (c)); \
    } else if(!U16_IS_SURROGATE_LEAD(c)) { \
        /* trail surrogate */ \
        if((start)!=(src) && U16_IS_LEAD((c2)=*((src)-1))) { \
            --(src); \
            (result)=(c); (c)=(c2); (c2)=(UChar)(result); /* swap c, c2 */ \
            _UTRIE_GET_FROM_PAIR((trie), data, (c), (c2), (result), resultType); \
        } else { \
            /* unpaired trail surrogate code point */ \
            (c2)=0; \
            (result)=_UTRIE_GET_RAW((trie), data, 0, (c)); \
        } \
    } else { \
        /* unpaired lead surrogate code point */ \
        (c2)=0; \
        (result)=_UTRIE_GET_RAW((trie), data, UTRIE_LEAD_INDEX_DISP, (c)); \
    } \
} UPRV_BLOCK_MACRO_END

/* Public UTrie API ---------------------------------------------------------*/

/**
 * Get a pointer to the contiguous part of the data array
 * for the Latin-1 range (U+0000..U+00ff).
 * Must be used only if the Latin-1 range is in fact linear
 * (trie->isLatin1Linear).
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @return (const uint16_t *) pointer to values for Latin-1 code points
 */
#define UTRIE_GET16_LATIN1(trie) ((trie)->index+(trie)->indexLength+UTRIE_DATA_BLOCK_LENGTH)

/**
 * Get a pointer to the contiguous part of the data array
 * for the Latin-1 range (U+0000..U+00ff).
 * Must be used only if the Latin-1 range is in fact linear
 * (trie->isLatin1Linear).
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @return (const uint32_t *) pointer to values for Latin-1 code points
 */
#define UTRIE_GET32_LATIN1(trie) ((trie)->data32+UTRIE_DATA_BLOCK_LENGTH)

/**
 * Get a 16-bit trie value from a BMP code point (UChar, <=U+ffff).
 * c16 may be a lead surrogate, which may have a value including a folding offset.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param c16 (UChar, in) the input BMP code point
 * @return (uint16_t) trie lookup result
 */
#define UTRIE_GET16_FROM_LEAD(trie, c16) _UTRIE_GET_RAW(trie, index, 0, c16)

/**
 * Get a 32-bit trie value from a BMP code point (UChar, <=U+ffff).
 * c16 may be a lead surrogate, which may have a value including a folding offset.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param c16 (UChar, in) the input BMP code point
 * @return (uint32_t) trie lookup result
 */
#define UTRIE_GET32_FROM_LEAD(trie, c16) _UTRIE_GET_RAW(trie, data32, 0, c16)

/**
 * Get a 16-bit trie value from a BMP code point (UChar, <=U+ffff).
 * Even lead surrogate code points are treated as normal code points,
 * with unfolded values that may differ from _FROM_LEAD() macro results for them.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param c16 (UChar, in) the input BMP code point
 * @return (uint16_t) trie lookup result
 */
#define UTRIE_GET16_FROM_BMP(trie, c16) _UTRIE_GET_FROM_BMP(trie, index, c16)

/**
 * Get a 32-bit trie value from a BMP code point (UChar, <=U+ffff).
 * Even lead surrogate code points are treated as normal code points,
 * with unfolded values that may differ from _FROM_LEAD() macro results for them.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param c16 (UChar, in) the input BMP code point
 * @return (uint32_t) trie lookup result
 */
#define UTRIE_GET32_FROM_BMP(trie, c16) _UTRIE_GET_FROM_BMP(trie, data32, c16)

/**
 * Get a 16-bit trie value from a code point.
 * Even lead surrogate code points are treated as normal code points,
 * with unfolded values that may differ from _FROM_LEAD() macro results for them.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param c32 (UChar32, in) the input code point
 * @param result (uint16_t, out) uint16_t variable for the trie lookup result
 */
#define UTRIE_GET16(trie, c32, result) _UTRIE_GET(trie, index, c32, result, uint16_t)

/**
 * Get a 32-bit trie value from a code point.
 * Even lead surrogate code points are treated as normal code points,
 * with unfolded values that may differ from _FROM_LEAD() macro results for them.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param c32 (UChar32, in) the input code point
 * @param result (uint32_t, out) uint32_t variable for the trie lookup result
 */
#define UTRIE_GET32(trie, c32, result) _UTRIE_GET(trie, data32, c32, result, uint32_t)

/**
 * Get the next code point (c, c2), post-increment src,
 * and get a 16-bit value from the trie.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param src (const UChar *, in/out) the source text pointer
 * @param limit (const UChar *, in) the limit pointer for the text, or NULL
 * @param c (UChar, out) variable for the BMP or lead code unit
 * @param c2 (UChar, out) variable for 0 or the trail code unit
 * @param result (uint16_t, out) uint16_t variable for the trie lookup result
 */
#define UTRIE_NEXT16(trie, src, limit, c, c2, result) _UTRIE_NEXT(trie, index, src, limit, c, c2, result, uint16_t)

/**
 * Get the next code point (c, c2), post-increment src,
 * and get a 32-bit value from the trie.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param src (const UChar *, in/out) the source text pointer
 * @param limit (const UChar *, in) the limit pointer for the text, or NULL
 * @param c (UChar, out) variable for the BMP or lead code unit
 * @param c2 (UChar, out) variable for 0 or the trail code unit
 * @param result (uint32_t, out) uint32_t variable for the trie lookup result
 */
#define UTRIE_NEXT32(trie, src, limit, c, c2, result) _UTRIE_NEXT(trie, data32, src, limit, c, c2, result, uint32_t)

/**
 * Get the previous code point (c, c2), pre-decrement src,
 * and get a 16-bit value from the trie.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param start (const UChar *, in) the start pointer for the text, or NULL
 * @param src (const UChar *, in/out) the source text pointer
 * @param c (UChar, out) variable for the BMP or lead code unit
 * @param c2 (UChar, out) variable for 0 or the trail code unit
 * @param result (uint16_t, out) uint16_t variable for the trie lookup result
 */
#define UTRIE_PREVIOUS16(trie, start, src, c, c2, result) _UTRIE_PREVIOUS(trie, index, start, src, c, c2, result, uint16_t)

/**
 * Get the previous code point (c, c2), pre-decrement src,
 * and get a 32-bit value from the trie.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param start (const UChar *, in) the start pointer for the text, or NULL
 * @param src (const UChar *, in/out) the source text pointer
 * @param c (UChar, out) variable for the BMP or lead code unit
 * @param c2 (UChar, out) variable for 0 or the trail code unit
 * @param result (uint32_t, out) uint32_t variable for the trie lookup result
 */
#define UTRIE_PREVIOUS32(trie, start, src, c, c2, result) _UTRIE_PREVIOUS(trie, data32, start, src, c, c2, result, uint32_t)

/**
 * Get a 16-bit trie value from a pair of surrogates.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param c (UChar, in) a lead surrogate
 * @param c2 (UChar, in) a trail surrogate
 * @param result (uint16_t, out) uint16_t variable for the trie lookup result
 */
#define UTRIE_GET16_FROM_PAIR(trie, c, c2, result) _UTRIE_GET_FROM_PAIR(trie, index, c, c2, result, uint16_t)

/**
 * Get a 32-bit trie value from a pair of surrogates.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param c (UChar, in) a lead surrogate
 * @param c2 (UChar, in) a trail surrogate
 * @param result (uint32_t, out) uint32_t variable for the trie lookup result
 */
#define UTRIE_GET32_FROM_PAIR(trie, c, c2, result) _UTRIE_GET_FROM_PAIR(trie, data32, c, c2, result, uint32_t)

/**
 * Get a 16-bit trie value from a folding offset (from the value of a lead surrogate)
 * and a trail surrogate.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param offset (int32_t, in) the folding offset from the value of a lead surrogate
 * @param c2 (UChar, in) a trail surrogate (only the 10 low bits are significant)
 * @return (uint16_t) trie lookup result
 */
#define UTRIE_GET16_FROM_OFFSET_TRAIL(trie, offset, c2) _UTRIE_GET_RAW(trie, index, offset, (c2)&0x3ff)

/**
 * Get a 32-bit trie value from a folding offset (from the value of a lead surrogate)
 * and a trail surrogate.
 *
 * @param trie (const UTrie *, in) a pointer to the runtime trie structure
 * @param offset (int32_t, in) the folding offset from the value of a lead surrogate
 * @param c2 (UChar, in) a trail surrogate (only the 10 low bits are significant)
 * @return (uint32_t) trie lookup result
 */
#define UTRIE_GET32_FROM_OFFSET_TRAIL(trie, offset, c2) _UTRIE_GET_RAW(trie, data32, offset, (c2)&0x3ff)

/* enumeration callback types */

/**
 * Callback from utrie_enum(), extracts a uint32_t value from a
 * trie value. This value will be passed on to the UTrieEnumRange function.
 *
 * @param context an opaque pointer, as passed into utrie_enum()
 * @param value a value from the trie
 * @return the value that is to be passed on to the UTrieEnumRange function
 */
typedef uint32_t U_CALLCONV
UTrieEnumValue(const void *context, uint32_t value);

/**
 * Callback from utrie_enum(), is called for each contiguous range
 * of code points with the same value as retrieved from the trie and
 * transformed by the UTrieEnumValue function.
 *
 * The callback function can stop the enumeration by returning false.
 *
 * @param context an opaque pointer, as passed into utrie_enum()
 * @param start the first code point in a contiguous range with value
 * @param limit one past the last code point in a contiguous range with value
 * @param value the value that is set for all code points in [start..limit[
 * @return false to stop the enumeration
 */
typedef UBool U_CALLCONV
UTrieEnumRange(const void *context, UChar32 start, UChar32 limit, uint32_t value);

/**
 * Enumerate efficiently all values in a trie.
 * For each entry in the trie, the value to be delivered is passed through
 * the UTrieEnumValue function.
 * The value is unchanged if that function pointer is NULL.
 *
 * For each contiguous range of code points with a given value,
 * the UTrieEnumRange function is called.
 *
 * @param trie a pointer to the runtime trie structure
 * @param enumValue a pointer to a function that may transform the trie entry value,
 *                  or NULL if the values from the trie are to be used directly
 * @param enumRange a pointer to a function that is called for each contiguous range
 *                  of code points with the same value
 * @param context an opaque pointer that is passed on to the callback functions
 */
U_CAPI void U_EXPORT2
utrie_enum(const UTrie *trie,
           UTrieEnumValue *enumValue, UTrieEnumRange *enumRange, const void *context);

/**
 * Unserialize a trie from 32-bit-aligned memory.
 * Inverse of utrie_serialize().
 * Fills the UTrie runtime trie structure with the settings for the trie data.
 *
 * @param trie a pointer to the runtime trie structure
 * @param data a pointer to 32-bit-aligned memory containing trie data
 * @param length the number of bytes available at data
 * @param pErrorCode an in/out ICU UErrorCode
 * @return the number of bytes at data taken up by the trie data
 */
U_CAPI int32_t U_EXPORT2
utrie_unserialize(UTrie *trie, const void *data, int32_t length, UErrorCode *pErrorCode);

/**
 * "Unserialize" a dummy trie.
 * A dummy trie is an empty runtime trie, used when a real data trie cannot
 * be loaded.
 *
 * The input memory is filled so that the trie always returns the initialValue,
 * or the leadUnitValue for lead surrogate code points.
 * The Latin-1 part is always set up to be linear.
 *
 * @param trie a pointer to the runtime trie structure
 * @param data a pointer to 32-bit-aligned memory to be filled with the dummy trie data
 * @param length the number of bytes available at data (recommended to use UTRIE_DUMMY_SIZE)
 * @param initialValue the initial value that is set for all code points
 * @param leadUnitValue the value for lead surrogate code _units_ that do not
 *                      have associated supplementary data
 * @param pErrorCode an in/out ICU UErrorCode
 *
 * @see UTRIE_DUMMY_SIZE
 * @see utrie_open
 */
U_CAPI int32_t U_EXPORT2
utrie_unserializeDummy(UTrie *trie,
                       void *data, int32_t length,
                       uint32_t initialValue, uint32_t leadUnitValue,
                       UBool make16BitTrie,
                       UErrorCode *pErrorCode);

/**
 * Default implementation for UTrie.getFoldingOffset, set automatically by
 * utrie_unserialize().
 * Simply returns the lead surrogate's value itself - which is the inverse
 * of the default folding function used by utrie_serialize().
 * Exported for static const UTrie structures.
 *
 * @see UTrieGetFoldingOffset
 */
U_CAPI int32_t U_EXPORT2
utrie_defaultGetFoldingOffset(uint32_t data);

/* Building a trie ----------------------------------------------------------*/

/**
 * Build-time trie structure.
 * Opaque definition, here only to make fillIn parameters possible
 * for utrie_open() and utrie_clone().
 */
struct UNewTrie {
    /**
     * Index values at build-time are 32 bits wide for easier processing.
     * Bit 31 is set if the data block is used by multiple index values (from utrie_setRange()).
     */
    int32_t index[UTRIE_MAX_INDEX_LENGTH+UTRIE_SURROGATE_BLOCK_COUNT];
    uint32_t *data;

    uint32_t leadUnitValue;
    int32_t indexLength, dataCapacity, dataLength;
    UBool isAllocated, isDataAllocated;
    UBool isLatin1Linear, isCompacted;

    /**
     * Map of adjusted indexes, used in utrie_compact().
     * Maps from original indexes to new ones.
     */
    int32_t map[UTRIE_MAX_BUILD_TIME_DATA_LENGTH>>UTRIE_SHIFT];
};

typedef struct UNewTrie UNewTrie;

/**
 * Build-time trie callback function, used with utrie_serialize().
 * This function calculates a lead surrogate's value including a folding offset
 * from the 1024 supplementary code points [start..start+1024[ .
 * It is U+10000 <= start <= U+10fc00 and (start&0x3ff)==0.
 *
 * The folding offset is provided by the caller.
 * It is offset=UTRIE_BMP_INDEX_LENGTH+n*UTRIE_SURROGATE_BLOCK_COUNT with n=0..1023.
 * Instead of the offset itself, n can be stored in 10 bits -
 * or fewer if it can be assumed that few lead surrogates have associated data.
 *
 * The returned value must be
 * - not zero if and only if there is relevant data
 *   for the corresponding 1024 supplementary code points
 * - such that UTrie.getFoldingOffset(UNewTrieGetFoldedValue(..., offset))==offset
 *
 * @return a folded value, or 0 if there is no relevant data for the lead surrogate.
 */
typedef uint32_t U_CALLCONV
UNewTrieGetFoldedValue(UNewTrie *trie, UChar32 start, int32_t offset);

/**
 * Open a build-time trie structure.
 * The size of the build-time data array is specified to avoid allocating a large
 * array in all cases. The array itself can also be passed in.
 *
 * Although the trie is never fully expanded to a linear array, especially when
 * utrie_setRange32() is used, the data array could be large during build time.
 * The maximum length is
 * UTRIE_MAX_BUILD_TIME_DATA_LENGTH=0x110000+UTRIE_DATA_BLOCK_LENGTH+0x400.
 * (Number of Unicode code points + one all-initial-value block +
 *  possible duplicate entries for 1024 lead surrogates.)
 * (UTRIE_DATA_BLOCK_LENGTH<=0x200 in all cases.)
 *
 * @param fillIn a pointer to a UNewTrie structure to be initialized (will not be released), or
 *               NULL if one is to be allocated
 * @param aliasData a pointer to a data array to be used (will not be released), or
 *                  NULL if one is to be allocated
 * @param maxDataLength the capacity of aliasData (if not NULL) or
 *                      the length of the data array to be allocated
 * @param initialValue the initial value that is set for all code points
 * @param leadUnitValue the value for lead surrogate code _units_ that do not
 *                      have associated supplementary data
 * @param latin1Linear a flag indicating whether the Latin-1 range is to be allocated and
 *                     kept in a linear, contiguous part of the data array
 * @return a pointer to the initialized fillIn or the allocated and initialized new UNewTrie
 */
U_CAPI UNewTrie * U_EXPORT2
utrie_open(UNewTrie *fillIn,
           uint32_t *aliasData, int32_t maxDataLength,
           uint32_t initialValue, uint32_t leadUnitValue,
           UBool latin1Linear);

/**
 * Clone a build-time trie structure with all entries.
 *
 * @param fillIn like in utrie_open()
 * @param other the build-time trie structure to clone
 * @param aliasData like in utrie_open(),
 *                  used if aliasDataLength>=(capacity of other's data array)
 * @param aliasDataLength the length of aliasData
 * @return a pointer to the initialized fillIn or the allocated and initialized new UNewTrie
 */
U_CAPI UNewTrie * U_EXPORT2
utrie_clone(UNewTrie *fillIn, const UNewTrie *other, uint32_t *aliasData, int32_t aliasDataLength);

/**
 * Close a build-time trie structure, and release memory
 * that was allocated by utrie_open() or utrie_clone().
 *
 * @param trie the build-time trie
 */
U_CAPI void U_EXPORT2
utrie_close(UNewTrie *trie);

/**
 * Get the data array of a build-time trie.
 * The data may be modified, but entries that are equal before
 * must still be equal after modification.
 *
 * @param trie the build-time trie
 * @param pLength (out) a pointer to a variable that receives the number
 *                of entries in the data array
 * @return the data array
 */
U_CAPI uint32_t * U_EXPORT2
utrie_getData(UNewTrie *trie, int32_t *pLength);

/**
 * Set a value for a code point.
 *
 * @param trie the build-time trie
 * @param c the code point
 * @param value the value
 * @return false if a failure occurred (illegal argument or data array overrun)
 */
U_CAPI UBool U_EXPORT2
utrie_set32(UNewTrie *trie, UChar32 c, uint32_t value);

/**
 * Get a value from a code point as stored in the build-time trie.
 *
 * @param trie the build-time trie
 * @param c the code point
 * @param pInBlockZero if not NULL, then *pInBlockZero is set to true
 *                     iff the value is retrieved from block 0;
 *                     block 0 is the all-initial-value initial block
 * @return the value
 */
U_CAPI uint32_t U_EXPORT2
utrie_get32(UNewTrie *trie, UChar32 c, UBool *pInBlockZero);

/**
 * Set a value in a range of code points [start..limit[.
 * All code points c with start<=c<limit will get the value if
 * overwrite is true or if the old value is 0.
 *
 * @param trie the build-time trie
 * @param start the first code point to get the value
 * @param limit one past the last code point to get the value
 * @param value the value
 * @param overwrite flag for whether old non-initial values are to be overwritten
 * @return false if a failure occurred (illegal argument or data array overrun)
 */
U_CAPI UBool U_EXPORT2
utrie_setRange32(UNewTrie *trie, UChar32 start, UChar32 limit, uint32_t value, UBool overwrite);

/**
 * Compact the build-time trie after all values are set, and then
 * serialize it into 32-bit aligned memory.
 *
 * After this, the trie can only be serizalized again and/or closed;
 * no further values can be added.
 *
 * @see utrie_unserialize()
 *
 * @param trie the build-time trie
 * @param data a pointer to 32-bit-aligned memory for the trie data
 * @param capacity the number of bytes available at data
 * @param getFoldedValue a callback function that calculates the value for
 *                       a lead surrogate from all of its supplementary code points
 *                       and the folding offset;
 *                       if NULL, then a default function is used which returns just
 *                       the input offset when there are any non-initial-value entries
 * @param reduceTo16Bits flag for whether the values are to be reduced to a
 *                       width of 16 bits for serialization and runtime
 * @param pErrorCode a UErrorCode argument; among other possible error codes:
 * - U_BUFFER_OVERFLOW_ERROR if the data storage block is too small for serialization
 * - U_MEMORY_ALLOCATION_ERROR if the trie data array is too small
 * - U_INDEX_OUTOFBOUNDS_ERROR if the index or data arrays are too long after compaction for serialization
 *
 * @return the number of bytes written for the trie
 */
U_CAPI int32_t U_EXPORT2
utrie_serialize(UNewTrie *trie, void *data, int32_t capacity,
                UNewTrieGetFoldedValue *getFoldedValue,
                UBool reduceTo16Bits,
                UErrorCode *pErrorCode);

/* serialization ------------------------------------------------------------ */

// UTrie signature values, in platform endianness and opposite endianness.
// The UTrie signature ASCII byte values spell "Trie".
#define UTRIE_SIG       0x54726965
#define UTRIE_OE_SIG    0x65697254

/**
 * Trie data structure in serialized form:
 *
 * UTrieHeader header;
 * uint16_t index[header.indexLength];
 * uint16_t data[header.dataLength];
 * @internal
 */
typedef struct UTrieHeader {
    /** "Trie" in big-endian US-ASCII (0x54726965) */
    uint32_t signature;

    /**
     * options bit field:
     *     9    1=Latin-1 data is stored linearly at data+UTRIE_DATA_BLOCK_LENGTH
     *     8    0=16-bit data, 1=32-bit data
     *  7..4    UTRIE_INDEX_SHIFT   // 0..UTRIE_SHIFT
     *  3..0    UTRIE_SHIFT         // 1..9
     */
    uint32_t options;

    /** indexLength is a multiple of UTRIE_SURROGATE_BLOCK_COUNT */
    int32_t indexLength;

    /** dataLength>=UTRIE_DATA_BLOCK_LENGTH */
    int32_t dataLength;
} UTrieHeader;

/**
 * Constants for use with UTrieHeader.options.
 * @internal
 */
enum {
    /** Mask to get the UTRIE_SHIFT value from options. */
    UTRIE_OPTIONS_SHIFT_MASK=0xf,

    /** Shift options right this much to get the UTRIE_INDEX_SHIFT value. */
    UTRIE_OPTIONS_INDEX_SHIFT=4,

    /** If set, then the data (stage 2) array is 32 bits wide. */
    UTRIE_OPTIONS_DATA_IS_32_BIT=0x100,

    /**
     * If set, then Latin-1 data (for U+0000..U+00ff) is stored in the data (stage 2) array
     * as a simple, linear array at data+UTRIE_DATA_BLOCK_LENGTH.
     */
    UTRIE_OPTIONS_LATIN1_IS_LINEAR=0x200
};

U_CDECL_END

#endif
                                                                                                                   node-23.7.0/deps/icu-small/source/common/utrie2.cpp                                                 0000664 0000000 0000000 00000051363 14746647661 0022114 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 2001-2014, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*   file name:  utrie2.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2008aug16 (starting from a copy of utrie.c)
*   created by: Markus W. Scherer
*
*   This is a common implementation of a Unicode trie.
*   It is a kind of compressed, serializable table of 16- or 32-bit values associated with
*   Unicode code points (0..0x10ffff).
*   This is the second common version of a Unicode trie (hence the name UTrie2).
*   See utrie2.h for a comparison.
*
*   This file contains only the runtime and enumeration code, for read-only access.
*   See utrie2_builder.c for the builder code.
*/
#include "unicode/utypes.h"
#ifdef UCPTRIE_DEBUG
#include "unicode/umutablecptrie.h"
#endif
#include "unicode/utf.h"
#include "unicode/utf8.h"
#include "unicode/utf16.h"
#include "cmemory.h"
#include "utrie2.h"
#include "utrie2_impl.h"
#include "uassert.h"

/* Public UTrie2 API implementation ----------------------------------------- */

static uint32_t
get32(const UNewTrie2 *trie, UChar32 c, UBool fromLSCP) {
    int32_t i2, block;

    if(c>=trie->highStart && (!U_IS_LEAD(c) || fromLSCP)) {
        return trie->data[trie->dataLength-UTRIE2_DATA_GRANULARITY];
    }

    if(U_IS_LEAD(c) && fromLSCP) {
        i2=(UTRIE2_LSCP_INDEX_2_OFFSET-(0xd800>>UTRIE2_SHIFT_2))+
            (c>>UTRIE2_SHIFT_2);
    } else {
        i2=trie->index1[c>>UTRIE2_SHIFT_1]+
            ((c>>UTRIE2_SHIFT_2)&UTRIE2_INDEX_2_MASK);
    }
    block=trie->index2[i2];
    return trie->data[block+(c&UTRIE2_DATA_MASK)];
}

U_CAPI uint32_t U_EXPORT2
utrie2_get32(const UTrie2 *trie, UChar32 c) {
    if(trie->data16!=nullptr) {
        return UTRIE2_GET16(trie, c);
    } else if(trie->data32!=nullptr) {
        return UTRIE2_GET32(trie, c);
    } else if((uint32_t)c>0x10ffff) {
        return trie->errorValue;
    } else {
        return get32(trie->newTrie, c, true);
    }
}

U_CAPI uint32_t U_EXPORT2
utrie2_get32FromLeadSurrogateCodeUnit(const UTrie2 *trie, UChar32 c) {
    if(!U_IS_LEAD(c)) {
        return trie->errorValue;
    }
    if(trie->data16!=nullptr) {
        return UTRIE2_GET16_FROM_U16_SINGLE_LEAD(trie, c);
    } else if(trie->data32!=nullptr) {
        return UTRIE2_GET32_FROM_U16_SINGLE_LEAD(trie, c);
    } else {
        return get32(trie->newTrie, c, false);
    }
}

static inline int32_t
u8Index(const UTrie2 *trie, UChar32 c, int32_t i) {
    int32_t idx=
        _UTRIE2_INDEX_FROM_CP(
            trie,
            trie->data32==nullptr ? trie->indexLength : 0,
            c);
    return (idx<<3)|i;
}

U_CAPI int32_t U_EXPORT2
utrie2_internalU8NextIndex(const UTrie2 *trie, UChar32 c,
                           const uint8_t *src, const uint8_t *limit) {
    int32_t i, length;
    i=0;
    /* support 64-bit pointers by avoiding cast of arbitrary difference */
    if((limit-src)<=7) {
        length=(int32_t)(limit-src);
    } else {
        length=7;
    }
    c=utf8_nextCharSafeBody(src, &i, length, c, -1);
    return u8Index(trie, c, i);
}

U_CAPI int32_t U_EXPORT2
utrie2_internalU8PrevIndex(const UTrie2 *trie, UChar32 c,
                           const uint8_t *start, const uint8_t *src) {
    int32_t i, length;
    /* support 64-bit pointers by avoiding cast of arbitrary difference */
    if((src-start)<=7) {
        i=length=(int32_t)(src-start);
    } else {
        i=length=7;
        start=src-7;
    }
    c=utf8_prevCharSafeBody(start, 0, &i, c, -1);
    i=length-i;  /* number of bytes read backward from src */
    return u8Index(trie, c, i);
}

U_CAPI UTrie2 * U_EXPORT2
utrie2_openFromSerialized(UTrie2ValueBits valueBits,
                          const void *data, int32_t length, int32_t *pActualLength,
                          UErrorCode *pErrorCode) {
    const UTrie2Header *header;
    const uint16_t *p16;
    int32_t actualLength;

    UTrie2 tempTrie;
    UTrie2 *trie;

    if(U_FAILURE(*pErrorCode)) {
        return nullptr;
    }

    if( length<=0 || (U_POINTER_MASK_LSB(data, 3)!=0) ||
        valueBits<0 || UTRIE2_COUNT_VALUE_BITS<=valueBits
    ) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return nullptr;
    }

    /* enough data for a trie header? */
    if(length<(int32_t)sizeof(UTrie2Header)) {
        *pErrorCode=U_INVALID_FORMAT_ERROR;
        return nullptr;
    }

    /* check the signature */
    header=(const UTrie2Header *)data;
    if(header->signature!=UTRIE2_SIG) {
        *pErrorCode=U_INVALID_FORMAT_ERROR;
        return nullptr;
    }

    /* get the options */
    if(valueBits!=(UTrie2ValueBits)(header->options&UTRIE2_OPTIONS_VALUE_BITS_MASK)) {
        *pErrorCode=U_INVALID_FORMAT_ERROR;
        return nullptr;
    }

    /* get the length values and offsets */
    uprv_memset(&tempTrie, 0, sizeof(tempTrie));
    tempTrie.indexLength=header->indexLength;
    tempTrie.dataLength=header->shiftedDataLength<<UTRIE2_INDEX_SHIFT;
    tempTrie.index2NullOffset=header->index2NullOffset;
    tempTrie.dataNullOffset=header->dataNullOffset;

    tempTrie.highStart=header->shiftedHighStart<<UTRIE2_SHIFT_1;
    tempTrie.highValueIndex=tempTrie.dataLength-UTRIE2_DATA_GRANULARITY;
    if(valueBits==UTRIE2_16_VALUE_BITS) {
        tempTrie.highValueIndex+=tempTrie.indexLength;
    }

    /* calculate the actual length */
    actualLength=(int32_t)sizeof(UTrie2Header)+tempTrie.indexLength*2;
    if(valueBits==UTRIE2_16_VALUE_BITS) {
        actualLength+=tempTrie.dataLength*2;
    } else {
        actualLength+=tempTrie.dataLength*4;
    }
    if(length<actualLength) {
        *pErrorCode=U_INVALID_FORMAT_ERROR;  /* not enough bytes */
        return nullptr;
    }

    /* allocate the trie */
    trie=(UTrie2 *)uprv_malloc(sizeof(UTrie2));
    if(trie==nullptr) {
        *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
        return nullptr;
    }
    uprv_memcpy(trie, &tempTrie, sizeof(tempTrie));
    trie->memory=(uint32_t *)data;
    trie->length=actualLength;
    trie->isMemoryOwned=false;
#ifdef UTRIE2_DEBUG
    trie->name="fromSerialized";
#endif

    /* set the pointers to its index and data arrays */
    p16=(const uint16_t *)(header+1);
    trie->index=p16;
    p16+=trie->indexLength;

    /* get the data */
    switch(valueBits) {
    case UTRIE2_16_VALUE_BITS:
        trie->data16=p16;
        trie->data32=nullptr;
        trie->initialValue=trie->index[trie->dataNullOffset];
        trie->errorValue=trie->data16[UTRIE2_BAD_UTF8_DATA_OFFSET];
        break;
    case UTRIE2_32_VALUE_BITS:
        trie->data16=nullptr;
        trie->data32=(const uint32_t *)p16;
        trie->initialValue=trie->data32[trie->dataNullOffset];
        trie->errorValue=trie->data32[UTRIE2_BAD_UTF8_DATA_OFFSET];
        break;
    default:
        *pErrorCode=U_INVALID_FORMAT_ERROR;
        return nullptr;
    }

    if(pActualLength!=nullptr) {
        *pActualLength=actualLength;
    }
    return trie;
}

U_CAPI UTrie2 * U_EXPORT2
utrie2_openDummy(UTrie2ValueBits valueBits,
                 uint32_t initialValue, uint32_t errorValue,
                 UErrorCode *pErrorCode) {
    UTrie2 *trie;
    UTrie2Header *header;
    uint32_t *p;
    uint16_t *dest16;
    int32_t indexLength, dataLength, length, i;
    int32_t dataMove;  /* >0 if the data is moved to the end of the index array */

    if(U_FAILURE(*pErrorCode)) {
        return nullptr;
    }

    if(valueBits<0 || UTRIE2_COUNT_VALUE_BITS<=valueBits) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return nullptr;
    }

    /* calculate the total length of the dummy trie data */
    indexLength=UTRIE2_INDEX_1_OFFSET;
    dataLength=UTRIE2_DATA_START_OFFSET+UTRIE2_DATA_GRANULARITY;
    length=(int32_t)sizeof(UTrie2Header)+indexLength*2;
    if(valueBits==UTRIE2_16_VALUE_BITS) {
        length+=dataLength*2;
    } else {
        length+=dataLength*4;
    }

    /* allocate the trie */
    trie=(UTrie2 *)uprv_malloc(sizeof(UTrie2));
    if(trie==nullptr) {
        *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
        return nullptr;
    }
    uprv_memset(trie, 0, sizeof(UTrie2));
    trie->memory=uprv_malloc(length);
    if(trie->memory==nullptr) {
        uprv_free(trie);
        *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
        return nullptr;
    }
    trie->length=length;
    trie->isMemoryOwned=true;

    /* set the UTrie2 fields */
    if(valueBits==UTRIE2_16_VALUE_BITS) {
        dataMove=indexLength;
    } else {
        dataMove=0;
    }

    trie->indexLength=indexLength;
    trie->dataLength=dataLength;
    trie->index2NullOffset=UTRIE2_INDEX_2_OFFSET;
    trie->dataNullOffset=(uint16_t)dataMove;
    trie->initialValue=initialValue;
    trie->errorValue=errorValue;
    trie->highStart=0;
    trie->highValueIndex=dataMove+UTRIE2_DATA_START_OFFSET;
#ifdef UTRIE2_DEBUG
    trie->name="dummy";
#endif

    /* set the header fields */
    header=(UTrie2Header *)trie->memory;

    header->signature=UTRIE2_SIG; /* "Tri2" */
    header->options=(uint16_t)valueBits;

    header->indexLength=(uint16_t)indexLength;
    header->shiftedDataLength=(uint16_t)(dataLength>>UTRIE2_INDEX_SHIFT);
    header->index2NullOffset=(uint16_t)UTRIE2_INDEX_2_OFFSET;
    header->dataNullOffset=(uint16_t)dataMove;
    header->shiftedHighStart=0;

    /* fill the index and data arrays */
    dest16=(uint16_t *)(header+1);
    trie->index=dest16;

    /* write the index-2 array values shifted right by UTRIE2_INDEX_SHIFT */
    for(i=0; i<UTRIE2_INDEX_2_BMP_LENGTH; ++i) {
        *dest16++=(uint16_t)(dataMove>>UTRIE2_INDEX_SHIFT);  /* null data block */
    }

    /* write UTF-8 2-byte index-2 values, not right-shifted */
    for(i=0; i<(0xc2-0xc0); ++i) {                                  /* C0..C1 */
        *dest16++=(uint16_t)(dataMove+UTRIE2_BAD_UTF8_DATA_OFFSET);
    }
    for(; i<(0xe0-0xc0); ++i) {                                     /* C2..DF */
        *dest16++=(uint16_t)dataMove;
    }

    /* write the 16/32-bit data array */
    switch(valueBits) {
    case UTRIE2_16_VALUE_BITS:
        /* write 16-bit data values */
        trie->data16=dest16;
        trie->data32=nullptr;
        for(i=0; i<0x80; ++i) {
            *dest16++=(uint16_t)initialValue;
        }
        for(; i<0xc0; ++i) {
            *dest16++=(uint16_t)errorValue;
        }
        /* highValue and reserved values */
        for(i=0; i<UTRIE2_DATA_GRANULARITY; ++i) {
            *dest16++=(uint16_t)initialValue;
        }
        break;
    case UTRIE2_32_VALUE_BITS:
        /* write 32-bit data values */
        p=(uint32_t *)dest16;
        trie->data16=nullptr;
        trie->data32=p;
        for(i=0; i<0x80; ++i) {
            *p++=initialValue;
        }
        for(; i<0xc0; ++i) {
            *p++=errorValue;
        }
        /* highValue and reserved values */
        for(i=0; i<UTRIE2_DATA_GRANULARITY; ++i) {
            *p++=initialValue;
        }
        break;
    default:
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return nullptr;
    }

    return trie;
}

U_CAPI void U_EXPORT2
utrie2_close(UTrie2 *trie) {
    if(trie!=nullptr) {
        if(trie->isMemoryOwned) {
            uprv_free(trie->memory);
        }
        if(trie->newTrie!=nullptr) {
            uprv_free(trie->newTrie->data);
#ifdef UCPTRIE_DEBUG
            umutablecptrie_close(trie->newTrie->t3);
#endif
            uprv_free(trie->newTrie);
        }
        uprv_free(trie);
    }
}

U_CAPI UBool U_EXPORT2
utrie2_isFrozen(const UTrie2 *trie) {
    return trie->newTrie==nullptr;
}

U_CAPI int32_t U_EXPORT2
utrie2_serialize(const UTrie2 *trie,
                 void *data, int32_t capacity,
                 UErrorCode *pErrorCode) {
    /* argument check */
    if(U_FAILURE(*pErrorCode)) {
        return 0;
    }

    if( trie==nullptr || trie->memory==nullptr || trie->newTrie!=nullptr ||
        capacity<0 || (capacity>0 && (data==nullptr || (U_POINTER_MASK_LSB(data, 3)!=0)))
    ) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }

    if(capacity>=trie->length) {
        uprv_memcpy(data, trie->memory, trie->length);
    } else {
        *pErrorCode=U_BUFFER_OVERFLOW_ERROR;
    }
    return trie->length;
}

/* enumeration -------------------------------------------------------------- */

#define MIN_VALUE(a, b) ((a)<(b) ? (a) : (b))

/* default UTrie2EnumValue() returns the input value itself */
static uint32_t U_CALLCONV
enumSameValue(const void * /*context*/, uint32_t value) {
    return value;
}

/**
 * Enumerate all ranges of code points with the same relevant values.
 * The values are transformed from the raw trie entries by the enumValue function.
 *
 * Currently requires start<limit and both start and limit must be multiples
 * of UTRIE2_DATA_BLOCK_LENGTH.
 *
 * Optimizations:
 * - Skip a whole block if we know that it is filled with a single value,
 *   and it is the same as we visited just before.
 * - Handle the null block specially because we know a priori that it is filled
 *   with a single value.
 */
static void
enumEitherTrie(const UTrie2 *trie,
               UChar32 start, UChar32 limit,
               UTrie2EnumValue *enumValue, UTrie2EnumRange *enumRange, const void *context) {
    const uint32_t *data32;
    const uint16_t *idx;

    uint32_t value, prevValue, initialValue;
    UChar32 c, prev, highStart;
    int32_t j, i2Block, prevI2Block, index2NullOffset, block, prevBlock, nullBlock;

    if(enumRange==nullptr) {
        return;
    }
    if(enumValue==nullptr) {
        enumValue=enumSameValue;
    }

    if(trie->newTrie==nullptr) {
        /* frozen trie */
        idx=trie->index;
        U_ASSERT(idx!=nullptr); /* the following code assumes trie->newTrie is not nullptr when idx is nullptr */
        data32=trie->data32;

        index2NullOffset=trie->index2NullOffset;
        nullBlock=trie->dataNullOffset;
    } else {
        /* unfrozen, mutable trie */
        idx=nullptr;
        data32=trie->newTrie->data;
        U_ASSERT(data32!=nullptr); /* the following code assumes idx is not nullptr when data32 is nullptr */

        index2NullOffset=trie->newTrie->index2NullOffset;
        nullBlock=trie->newTrie->dataNullOffset;
    }

    highStart=trie->highStart;

    /* get the enumeration value that corresponds to an initial-value trie data entry */
    initialValue=enumValue(context, trie->initialValue);

    /* set variables for previous range */
    prevI2Block=-1;
    prevBlock=-1;
    prev=start;
    prevValue=0;

    /* enumerate index-2 blocks */
    for(c=start; c<limit && c<highStart;) {
        /* Code point limit for iterating inside this i2Block. */
        UChar32 tempLimit=c+UTRIE2_CP_PER_INDEX_1_ENTRY;
        if(limit<tempLimit) {
            tempLimit=limit;
        }
        if(c<=0xffff) {
            if(!U_IS_SURROGATE(c)) {
                i2Block=c>>UTRIE2_SHIFT_2;
            } else if(U_IS_SURROGATE_LEAD(c)) {
                /*
                 * Enumerate values for lead surrogate code points, not code units:
                 * This special block has half the normal length.
                 */
                i2Block=UTRIE2_LSCP_INDEX_2_OFFSET;
                tempLimit=MIN_VALUE(0xdc00, limit);
            } else {
                /*
                 * Switch back to the normal part of the index-2 table.
                 * Enumerate the second half of the surrogates block.
                 */
                i2Block=0xd800>>UTRIE2_SHIFT_2;
                tempLimit=MIN_VALUE(0xe000, limit);
            }
        } else {
            /* supplementary code points */
            if(idx!=nullptr) {
                i2Block=idx[(UTRIE2_INDEX_1_OFFSET-UTRIE2_OMITTED_BMP_INDEX_1_LENGTH)+
                              (c>>UTRIE2_SHIFT_1)];
            } else {
                i2Block=trie->newTrie->index1[c>>UTRIE2_SHIFT_1];
            }
            if(i2Block==prevI2Block && (c-prev)>=UTRIE2_CP_PER_INDEX_1_ENTRY) {
                /*
                 * The index-2 block is the same as the previous one, and filled with prevValue.
                 * Only possible for supplementary code points because the linear-BMP index-2
                 * table creates unique i2Block values.
                 */
                c+=UTRIE2_CP_PER_INDEX_1_ENTRY;
                continue;
            }
        }
        prevI2Block=i2Block;
        if(i2Block==index2NullOffset) {
            /* this is the null index-2 block */
            if(prevValue!=initialValue) {
                if(prev<c && !enumRange(context, prev, c-1, prevValue)) {
                    return;
                }
                prevBlock=nullBlock;
                prev=c;
                prevValue=initialValue;
            }
            c+=UTRIE2_CP_PER_INDEX_1_ENTRY;
        } else {
            /* enumerate data blocks for one index-2 block */
            int32_t i2, i2Limit;
            i2=(c>>UTRIE2_SHIFT_2)&UTRIE2_INDEX_2_MASK;
            if((c>>UTRIE2_SHIFT_1)==(tempLimit>>UTRIE2_SHIFT_1)) {
                i2Limit=(tempLimit>>UTRIE2_SHIFT_2)&UTRIE2_INDEX_2_MASK;
            } else {
                i2Limit=UTRIE2_INDEX_2_BLOCK_LENGTH;
            }
            for(; i2<i2Limit; ++i2) {
                if(idx!=nullptr) {
                    block = static_cast<int32_t>(idx[i2Block + i2]) << UTRIE2_INDEX_SHIFT;
                } else {
                    block=trie->newTrie->index2[i2Block+i2];
                }
                if(block==prevBlock && (c-prev)>=UTRIE2_DATA_BLOCK_LENGTH) {
                    /* the block is the same as the previous one, and filled with prevValue */
                    c+=UTRIE2_DATA_BLOCK_LENGTH;
                    continue;
                }
                prevBlock=block;
                if(block==nullBlock) {
                    /* this is the null data block */
                    if(prevValue!=initialValue) {
                        if(prev<c && !enumRange(context, prev, c-1, prevValue)) {
                            return;
                        }
                        prev=c;
                        prevValue=initialValue;
                    }
                    c+=UTRIE2_DATA_BLOCK_LENGTH;
                } else {
                    for(j=0; j<UTRIE2_DATA_BLOCK_LENGTH; ++j) {
                        value=enumValue(context, data32!=nullptr ? data32[block+j] : idx[block+j]);
                        if(value!=prevValue) {
                            if(prev<c && !enumRange(context, prev, c-1, prevValue)) {
                                return;
                            }
                            prev=c;
                            prevValue=value;
                        }
                        ++c;
                    }
                }
            }
        }
    }

    if(c>limit) {
        c=limit;  /* could be higher if in the index2NullOffset */
    } else if(c<limit) {
        /* c==highStart<limit */
        uint32_t highValue;
        if(idx!=nullptr) {
            highValue=
                data32!=nullptr ?
                    data32[trie->highValueIndex] :
                    idx[trie->highValueIndex];
        } else {
            highValue=trie->newTrie->data[trie->newTrie->dataLength-UTRIE2_DATA_GRANULARITY];
        }
        value=enumValue(context, highValue);
        if(value!=prevValue) {
            if(prev<c && !enumRange(context, prev, c-1, prevValue)) {
                return;
            }
            prev=c;
            prevValue=value;
        }
        c=limit;
    }

    /* deliver last range */
    enumRange(context, prev, c-1, prevValue);
}

U_CAPI void U_EXPORT2
utrie2_enum(const UTrie2 *trie,
            UTrie2EnumValue *enumValue, UTrie2EnumRange *enumRange, const void *context) {
    enumEitherTrie(trie, 0, 0x110000, enumValue, enumRange, context);
}

U_CAPI void U_EXPORT2
utrie2_enumForLeadSurrogate(const UTrie2 *trie, UChar32 lead,
                            UTrie2EnumValue *enumValue, UTrie2EnumRange *enumRange,
                            const void *context) {
    if(!U16_IS_LEAD(lead)) {
        return;
    }
    lead=(lead-0xd7c0)<<10;   /* start code point */
    enumEitherTrie(trie, lead, lead+0x400, enumValue, enumRange, context);
}

/* C++ convenience wrappers ------------------------------------------------- */

U_NAMESPACE_BEGIN

uint16_t BackwardUTrie2StringIterator::previous16() {
    codePointLimit=codePointStart;
    if(start>=codePointStart) {
        codePoint=U_SENTINEL;
        return static_cast<uint16_t>(trie->errorValue);
    }
    uint16_t result;
    UTRIE2_U16_PREV16(trie, start, codePointStart, codePoint, result);
    return result;
}

uint16_t ForwardUTrie2StringIterator::next16() {
    codePointStart=codePointLimit;
    if(codePointLimit==limit) {
        codePoint=U_SENTINEL;
        return static_cast<uint16_t>(trie->errorValue);
    }
    uint16_t result;
    UTRIE2_U16_NEXT16(trie, codePointLimit, limit, codePoint, result);
    return result;
}

U_NAMESPACE_END
                                                                                                                                                                                                                                                                             node-23.7.0/deps/icu-small/source/common/utrie2.h                                                   0000664 0000000 0000000 00000111133 14746647661 0021551 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 2001-2014, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*   file name:  utrie2.h
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2008aug16 (starting from a copy of utrie.h)
*   created by: Markus W. Scherer
*/

#ifndef __UTRIE2_H__
#define __UTRIE2_H__

#include "unicode/utypes.h"
#include "unicode/utf8.h"
#include "putilimp.h"

U_CDECL_BEGIN

struct UTrie;  /* forward declaration */
#ifndef __UTRIE_H__
typedef struct UTrie UTrie;
#endif

/**
 * \file
 *
 * This is a common implementation of a Unicode trie.
 * It is a kind of compressed, serializable table of 16- or 32-bit values associated with
 * Unicode code points (0..0x10ffff). (A map from code points to integers.)
 *
 * This is the second common version of a Unicode trie (hence the name UTrie2).
 * Compared with UTrie version 1:
 * - Still splitting BMP code points 11:5 bits for index and data table lookups.
 * - Still separate data for lead surrogate code _units_ vs. code _points_,
 *   but the lead surrogate code unit values are not required any more
 *   for data lookup for supplementary code points.
 * - The "folding" mechanism is removed. In UTrie version 1, this somewhat
 *   hard-to-explain mechanism was meant to be used for optimized UTF-16
 *   processing, with application-specific encoding of indexing bits
 *   in the lead surrogate data for the associated supplementary code points.
 * - For the last single-value code point range (ending with U+10ffff),
 *   the starting code point ("highStart") and the value are stored.
 * - For supplementary code points U+10000..highStart-1 a three-table lookup
 *   (two index tables and one data table) is used. The first index
 *   is truncated, omitting both the BMP portion and the high range.
 * - There is a special small index for 2-byte UTF-8, and the initial data
 *   entries are designed for fast 1/2-byte UTF-8 lookup.
 *   Starting with ICU 60, C0 and C1 are not recognized as UTF-8 lead bytes any more at all,
 *   and the associated 2-byte indexes are unused.
 */

/**
 * Trie structure.
 * Use only with public API macros and functions.
 */
struct UTrie2;
typedef struct UTrie2 UTrie2;

/* Public UTrie2 API functions: read-only access ---------------------------- */

/**
 * Selectors for the width of a UTrie2 data value.
 */
enum UTrie2ValueBits {
    /** 16 bits per UTrie2 data value. */
    UTRIE2_16_VALUE_BITS,
    /** 32 bits per UTrie2 data value. */
    UTRIE2_32_VALUE_BITS,
    /** Number of selectors for the width of UTrie2 data values. */
    UTRIE2_COUNT_VALUE_BITS
};
typedef enum UTrie2ValueBits UTrie2ValueBits;

/**
 * Open a frozen trie from its serialized from, stored in 32-bit-aligned memory.
 * Inverse of utrie2_serialize().
 * The memory must remain valid and unchanged as long as the trie is used.
 * You must utrie2_close() the trie once you are done using it.
 *
 * @param valueBits selects the data entry size; results in an
 *                  U_INVALID_FORMAT_ERROR if it does not match the serialized form
 * @param data a pointer to 32-bit-aligned memory containing the serialized form of a UTrie2
 * @param length the number of bytes available at data;
 *               can be more than necessary
 * @param pActualLength receives the actual number of bytes at data taken up by the trie data;
 *                      can be NULL
 * @param pErrorCode an in/out ICU UErrorCode
 * @return the unserialized trie
 *
 * @see utrie2_open
 * @see utrie2_serialize
 */
U_CAPI UTrie2 * U_EXPORT2
utrie2_openFromSerialized(UTrie2ValueBits valueBits,
                          const void *data, int32_t length, int32_t *pActualLength,
                          UErrorCode *pErrorCode);

/**
 * Open a frozen, empty "dummy" trie.
 * A dummy trie is an empty trie, used when a real data trie cannot
 * be loaded. Equivalent to calling utrie2_open() and utrie2_freeze(),
 * but without internally creating and compacting/serializing the
 * builder data structure.
 *
 * The trie always returns the initialValue,
 * or the errorValue for out-of-range code points and illegal UTF-8.
 *
 * You must utrie2_close() the trie once you are done using it.
 *
 * @param valueBits selects the data entry size
 * @param initialValue the initial value that is set for all code points
 * @param errorValue the value for out-of-range code points and illegal UTF-8
 * @param pErrorCode an in/out ICU UErrorCode
 * @return the dummy trie
 *
 * @see utrie2_openFromSerialized
 * @see utrie2_open
 */
U_CAPI UTrie2 * U_EXPORT2
utrie2_openDummy(UTrie2ValueBits valueBits,
                 uint32_t initialValue, uint32_t errorValue,
                 UErrorCode *pErrorCode);

/**
 * Get a value from a code point as stored in the trie.
 * Easier to use than UTRIE2_GET16() and UTRIE2_GET32() but slower.
 * Easier to use because, unlike the macros, this function works on all UTrie2
 * objects, frozen or not, holding 16-bit or 32-bit data values.
 *
 * @param trie the trie
 * @param c the code point
 * @return the value
 */
U_CAPI uint32_t U_EXPORT2
utrie2_get32(const UTrie2 *trie, UChar32 c);

/* enumeration callback types */

/**
 * Callback from utrie2_enum(), extracts a uint32_t value from a
 * trie value. This value will be passed on to the UTrie2EnumRange function.
 *
 * @param context an opaque pointer, as passed into utrie2_enum()
 * @param value a value from the trie
 * @return the value that is to be passed on to the UTrie2EnumRange function
 */
typedef uint32_t U_CALLCONV
UTrie2EnumValue(const void *context, uint32_t value);

/**
 * Callback from utrie2_enum(), is called for each contiguous range
 * of code points with the same value as retrieved from the trie and
 * transformed by the UTrie2EnumValue function.
 *
 * The callback function can stop the enumeration by returning false.
 *
 * @param context an opaque pointer, as passed into utrie2_enum()
 * @param start the first code point in a contiguous range with value
 * @param end the last code point in a contiguous range with value (inclusive)
 * @param value the value that is set for all code points in [start..end]
 * @return false to stop the enumeration
 */
typedef UBool U_CALLCONV
UTrie2EnumRange(const void *context, UChar32 start, UChar32 end, uint32_t value);

/**
 * Enumerate efficiently all values in a trie.
 * Do not modify the trie during the enumeration.
 *
 * For each entry in the trie, the value to be delivered is passed through
 * the UTrie2EnumValue function.
 * The value is unchanged if that function pointer is NULL.
 *
 * For each contiguous range of code points with a given (transformed) value,
 * the UTrie2EnumRange function is called.
 *
 * @param trie a pointer to the trie
 * @param enumValue a pointer to a function that may transform the trie entry value,
 *                  or NULL if the values from the trie are to be used directly
 * @param enumRange a pointer to a function that is called for each contiguous range
 *                  of code points with the same (transformed) value
 * @param context an opaque pointer that is passed on to the callback functions
 */
U_CAPI void U_EXPORT2
utrie2_enum(const UTrie2 *trie,
            UTrie2EnumValue *enumValue, UTrie2EnumRange *enumRange, const void *context);

/* Building a trie ---------------------------------------------------------- */

/**
 * Open an empty, writable trie. At build time, 32-bit data values are used.
 * utrie2_freeze() takes a valueBits parameter
 * which determines the data value width in the serialized and frozen forms.
 * You must utrie2_close() the trie once you are done using it.
 *
 * @param initialValue the initial value that is set for all code points
 * @param errorValue the value for out-of-range code points and illegal UTF-8
 * @param pErrorCode an in/out ICU UErrorCode
 * @return a pointer to the allocated and initialized new trie
 */
U_CAPI UTrie2 * U_EXPORT2
utrie2_open(uint32_t initialValue, uint32_t errorValue, UErrorCode *pErrorCode);

/**
 * Clone a trie.
 * You must utrie2_close() the clone once you are done using it.
 *
 * @param other the trie to clone
 * @param pErrorCode an in/out ICU UErrorCode
 * @return a pointer to the new trie clone
 */
U_CAPI UTrie2 * U_EXPORT2
utrie2_clone(const UTrie2 *other, UErrorCode *pErrorCode);

/**
 * Clone a trie. The clone will be mutable/writable even if the other trie
 * is frozen. (See utrie2_freeze().)
 * You must utrie2_close() the clone once you are done using it.
 *
 * @param other the trie to clone
 * @param pErrorCode an in/out ICU UErrorCode
 * @return a pointer to the new trie clone
 */
U_CAPI UTrie2 * U_EXPORT2
utrie2_cloneAsThawed(const UTrie2 *other, UErrorCode *pErrorCode);

/**
 * Close a trie and release associated memory.
 *
 * @param trie the trie
 */
U_CAPI void U_EXPORT2
utrie2_close(UTrie2 *trie);

/**
 * Set a value for a code point.
 *
 * @param trie the unfrozen trie
 * @param c the code point
 * @param value the value
 * @param pErrorCode an in/out ICU UErrorCode; among other possible error codes:
 * - U_NO_WRITE_PERMISSION if the trie is frozen
 */
U_CAPI void U_EXPORT2
utrie2_set32(UTrie2 *trie, UChar32 c, uint32_t value, UErrorCode *pErrorCode);

/**
 * Set a value in a range of code points [start..end].
 * All code points c with start<=c<=end will get the value if
 * overwrite is true or if the old value is the initial value.
 *
 * @param trie the unfrozen trie
 * @param start the first code point to get the value
 * @param end the last code point to get the value (inclusive)
 * @param value the value
 * @param overwrite flag for whether old non-initial values are to be overwritten
 * @param pErrorCode an in/out ICU UErrorCode; among other possible error codes:
 * - U_NO_WRITE_PERMISSION if the trie is frozen
 */
U_CAPI void U_EXPORT2
utrie2_setRange32(UTrie2 *trie,
                  UChar32 start, UChar32 end,
                  uint32_t value, UBool overwrite,
                  UErrorCode *pErrorCode);

/**
 * Freeze a trie. Make it immutable (read-only) and compact it,
 * ready for serialization and for use with fast macros.
 * Functions to set values will fail after serializing.
 *
 * A trie can be frozen only once. If this function is called again with different
 * valueBits then it will set a U_ILLEGAL_ARGUMENT_ERROR.
 *
 * @param trie the trie
 * @param valueBits selects the data entry size; if smaller than 32 bits, then
 *                  the values stored in the trie will be truncated
 * @param pErrorCode an in/out ICU UErrorCode; among other possible error codes:
 * - U_INDEX_OUTOFBOUNDS_ERROR if the compacted index or data arrays are too long
 *                             for serialization
 *                             (the trie will be immutable and usable,
 *                             but not frozen and not usable with the fast macros)
 *
 * @see utrie2_cloneAsThawed
 */
U_CAPI void U_EXPORT2
utrie2_freeze(UTrie2 *trie, UTrie2ValueBits valueBits, UErrorCode *pErrorCode);

/**
 * Test if the trie is frozen. (See utrie2_freeze().)
 *
 * @param trie the trie
 * @return true if the trie is frozen, that is, immutable, ready for serialization
 *         and for use with fast macros
 */
U_CAPI UBool U_EXPORT2
utrie2_isFrozen(const UTrie2 *trie);

/**
 * Serialize a frozen trie into 32-bit aligned memory.
 * If the trie is not frozen, then the function returns with a U_ILLEGAL_ARGUMENT_ERROR.
 * A trie can be serialized multiple times.
 *
 * @param trie the frozen trie
 * @param data a pointer to 32-bit-aligned memory to be filled with the trie data,
 *             can be NULL if capacity==0
 * @param capacity the number of bytes available at data,
 *                 or 0 for preflighting
 * @param pErrorCode an in/out ICU UErrorCode; among other possible error codes:
 * - U_BUFFER_OVERFLOW_ERROR if the data storage block is too small for serialization
 * - U_ILLEGAL_ARGUMENT_ERROR if the trie is not frozen or the data and capacity
 *                            parameters are bad
 * @return the number of bytes written or needed for the trie
 *
 * @see utrie2_openFromSerialized()
 */
U_CAPI int32_t U_EXPORT2
utrie2_serialize(const UTrie2 *trie,
                 void *data, int32_t capacity,
                 UErrorCode *pErrorCode);

/* Public UTrie2 API: miscellaneous functions ------------------------------- */

/**
 * Build a UTrie2 (version 2) from a UTrie (version 1).
 * Enumerates all values in the UTrie and builds a UTrie2 with the same values.
 * The resulting UTrie2 will be frozen.
 *
 * @param trie1 the runtime UTrie structure to be enumerated
 * @param errorValue the value for out-of-range code points and illegal UTF-8
 * @param pErrorCode an in/out ICU UErrorCode
 * @return The frozen UTrie2 with the same values as the UTrie.
 */
U_CAPI UTrie2 * U_EXPORT2
utrie2_fromUTrie(const UTrie *trie1, uint32_t errorValue, UErrorCode *pErrorCode);

/* Public UTrie2 API macros ------------------------------------------------- */

/*
 * These macros provide fast data lookup from a frozen trie.
 * They will crash when used on an unfrozen trie.
 */

/**
 * Return a 16-bit trie value from a code point, with range checking.
 * Returns trie->errorValue if c is not in the range 0..U+10ffff.
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param c (UChar32, in) the input code point
 * @return (uint16_t) The code point's trie value.
 */
#define UTRIE2_GET16(trie, c) _UTRIE2_GET((trie), index, (trie)->indexLength, (c))

/**
 * Return a 32-bit trie value from a code point, with range checking.
 * Returns trie->errorValue if c is not in the range 0..U+10ffff.
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param c (UChar32, in) the input code point
 * @return (uint32_t) The code point's trie value.
 */
#define UTRIE2_GET32(trie, c) _UTRIE2_GET((trie), data32, 0, (c))

/**
 * UTF-16: Get the next code point (UChar32 c, out), post-increment src,
 * and get a 16-bit value from the trie.
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param src (const UChar *, in/out) the source text pointer
 * @param limit (const UChar *, in) the limit pointer for the text, or NULL if NUL-terminated
 * @param c (UChar32, out) variable for the code point
 * @param result (uint16_t, out) uint16_t variable for the trie lookup result
 */
#define UTRIE2_U16_NEXT16(trie, src, limit, c, result) _UTRIE2_U16_NEXT(trie, index, src, limit, c, result)

/**
 * UTF-16: Get the next code point (UChar32 c, out), post-increment src,
 * and get a 32-bit value from the trie.
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param src (const UChar *, in/out) the source text pointer
 * @param limit (const UChar *, in) the limit pointer for the text, or NULL if NUL-terminated
 * @param c (UChar32, out) variable for the code point
 * @param result (uint32_t, out) uint32_t variable for the trie lookup result
 */
#define UTRIE2_U16_NEXT32(trie, src, limit, c, result) _UTRIE2_U16_NEXT(trie, data32, src, limit, c, result)

/**
 * UTF-16: Get the previous code point (UChar32 c, out), pre-decrement src,
 * and get a 16-bit value from the trie.
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param start (const UChar *, in) the start pointer for the text
 * @param src (const UChar *, in/out) the source text pointer
 * @param c (UChar32, out) variable for the code point
 * @param result (uint16_t, out) uint16_t variable for the trie lookup result
 */
#define UTRIE2_U16_PREV16(trie, start, src, c, result) _UTRIE2_U16_PREV(trie, index, start, src, c, result)

/**
 * UTF-16: Get the previous code point (UChar32 c, out), pre-decrement src,
 * and get a 32-bit value from the trie.
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param start (const UChar *, in) the start pointer for the text
 * @param src (const UChar *, in/out) the source text pointer
 * @param c (UChar32, out) variable for the code point
 * @param result (uint32_t, out) uint32_t variable for the trie lookup result
 */
#define UTRIE2_U16_PREV32(trie, start, src, c, result) _UTRIE2_U16_PREV(trie, data32, start, src, c, result)

/**
 * UTF-8: Post-increment src and get a 16-bit value from the trie.
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param src (const char *, in/out) the source text pointer
 * @param limit (const char *, in) the limit pointer for the text (must not be NULL)
 * @param result (uint16_t, out) uint16_t variable for the trie lookup result
 */
#define UTRIE2_U8_NEXT16(trie, src, limit, result)\
    _UTRIE2_U8_NEXT(trie, data16, index, src, limit, result)

/**
 * UTF-8: Post-increment src and get a 32-bit value from the trie.
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param src (const char *, in/out) the source text pointer
 * @param limit (const char *, in) the limit pointer for the text (must not be NULL)
 * @param result (uint16_t, out) uint32_t variable for the trie lookup result
 */
#define UTRIE2_U8_NEXT32(trie, src, limit, result) \
    _UTRIE2_U8_NEXT(trie, data32, data32, src, limit, result)

/**
 * UTF-8: Pre-decrement src and get a 16-bit value from the trie.
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param start (const char *, in) the start pointer for the text
 * @param src (const char *, in/out) the source text pointer
 * @param result (uint16_t, out) uint16_t variable for the trie lookup result
 */
#define UTRIE2_U8_PREV16(trie, start, src, result) \
    _UTRIE2_U8_PREV(trie, data16, index, start, src, result)

/**
 * UTF-8: Pre-decrement src and get a 32-bit value from the trie.
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param start (const char *, in) the start pointer for the text
 * @param src (const char *, in/out) the source text pointer
 * @param result (uint16_t, out) uint32_t variable for the trie lookup result
 */
#define UTRIE2_U8_PREV32(trie, start, src, result) \
    _UTRIE2_U8_PREV(trie, data32, data32, start, src, result)

/* Public UTrie2 API: optimized UTF-16 access ------------------------------- */

/*
 * The following functions and macros are used for highly optimized UTF-16
 * text processing. The UTRIE2_U16_NEXTxy() macros do not depend on these.
 *
 * A UTrie2 stores separate values for lead surrogate code _units_ vs. code _points_.
 * UTF-16 text processing can be optimized by detecting surrogate pairs and
 * assembling supplementary code points only when there is non-trivial data
 * available.
 *
 * At build-time, use utrie2_enumForLeadSurrogate() to see if there
 * is non-trivial (non-initialValue) data for any of the supplementary
 * code points associated with a lead surrogate.
 * If so, then set a special (application-specific) value for the
 * lead surrogate code _unit_, with utrie2_set32ForLeadSurrogateCodeUnit().
 *
 * At runtime, use UTRIE2_GET16_FROM_U16_SINGLE_LEAD() or
 * UTRIE2_GET32_FROM_U16_SINGLE_LEAD() per code unit. If there is non-trivial
 * data and the code unit is a lead surrogate, then check if a trail surrogate
 * follows. If so, assemble the supplementary code point with
 * U16_GET_SUPPLEMENTARY() and look up its value with UTRIE2_GET16_FROM_SUPP()
 * or UTRIE2_GET32_FROM_SUPP(); otherwise reset the lead
 * surrogate's value or do a code point lookup for it.
 *
 * If there is only trivial data for lead and trail surrogates, then processing
 * can often skip them. For example, in normalization or case mapping
 * all characters that do not have any mappings are simply copied as is.
 */

/**
 * Get a value from a lead surrogate code unit as stored in the trie.
 *
 * @param trie the trie
 * @param c the code unit (U+D800..U+DBFF)
 * @return the value
 */
U_CAPI uint32_t U_EXPORT2
utrie2_get32FromLeadSurrogateCodeUnit(const UTrie2 *trie, UChar32 c);

/**
 * Enumerate the trie values for the 1024=0x400 code points
 * corresponding to a given lead surrogate.
 * For example, for the lead surrogate U+D87E it will enumerate the values
 * for [U+2F800..U+2FC00[.
 * Used by data builder code that sets special lead surrogate code unit values
 * for optimized UTF-16 string processing.
 *
 * Do not modify the trie during the enumeration.
 *
 * Except for the limited code point range, this functions just like utrie2_enum():
 * For each entry in the trie, the value to be delivered is passed through
 * the UTrie2EnumValue function.
 * The value is unchanged if that function pointer is NULL.
 *
 * For each contiguous range of code points with a given (transformed) value,
 * the UTrie2EnumRange function is called.
 *
 * @param trie a pointer to the trie
 * @param enumValue a pointer to a function that may transform the trie entry value,
 *                  or NULL if the values from the trie are to be used directly
 * @param enumRange a pointer to a function that is called for each contiguous range
 *                  of code points with the same (transformed) value
 * @param context an opaque pointer that is passed on to the callback functions
 */
U_CAPI void U_EXPORT2
utrie2_enumForLeadSurrogate(const UTrie2 *trie, UChar32 lead,
                            UTrie2EnumValue *enumValue, UTrie2EnumRange *enumRange,
                            const void *context);

/**
 * Set a value for a lead surrogate code unit.
 *
 * @param trie the unfrozen trie
 * @param lead the lead surrogate code unit (U+D800..U+DBFF)
 * @param value the value
 * @param pErrorCode an in/out ICU UErrorCode; among other possible error codes:
 * - U_NO_WRITE_PERMISSION if the trie is frozen
 */
U_CAPI void U_EXPORT2
utrie2_set32ForLeadSurrogateCodeUnit(UTrie2 *trie,
                                     UChar32 lead, uint32_t value,
                                     UErrorCode *pErrorCode);

/**
 * Return a 16-bit trie value from a UTF-16 single/lead code unit (<=U+ffff).
 * Same as UTRIE2_GET16() if c is a BMP code point except for lead surrogates,
 * but smaller and faster.
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param c (UChar32, in) the input code unit, must be 0<=c<=U+ffff
 * @return (uint16_t) The code unit's trie value.
 */
#define UTRIE2_GET16_FROM_U16_SINGLE_LEAD(trie, c) _UTRIE2_GET_FROM_U16_SINGLE_LEAD((trie), index, c)

/**
 * Return a 32-bit trie value from a UTF-16 single/lead code unit (<=U+ffff).
 * Same as UTRIE2_GET32() if c is a BMP code point except for lead surrogates,
 * but smaller and faster.
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param c (UChar32, in) the input code unit, must be 0<=c<=U+ffff
 * @return (uint32_t) The code unit's trie value.
 */
#define UTRIE2_GET32_FROM_U16_SINGLE_LEAD(trie, c) _UTRIE2_GET_FROM_U16_SINGLE_LEAD((trie), data32, c)

/**
 * Return a 16-bit trie value from a supplementary code point (U+10000..U+10ffff).
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param c (UChar32, in) the input code point, must be U+10000<=c<=U+10ffff
 * @return (uint16_t) The code point's trie value.
 */
#define UTRIE2_GET16_FROM_SUPP(trie, c) _UTRIE2_GET_FROM_SUPP((trie), index, c)

/**
 * Return a 32-bit trie value from a supplementary code point (U+10000..U+10ffff).
 *
 * @param trie (const UTrie2 *, in) a frozen trie
 * @param c (UChar32, in) the input code point, must be U+10000<=c<=U+10ffff
 * @return (uint32_t) The code point's trie value.
 */
#define UTRIE2_GET32_FROM_SUPP(trie, c) _UTRIE2_GET_FROM_SUPP((trie), data32, c)

U_CDECL_END

/* C++ convenience wrappers ------------------------------------------------- */

#ifdef __cplusplus

#include "unicode/uobject.h"
#include "unicode/utf.h"

U_NAMESPACE_BEGIN

// Use the Forward/Backward subclasses below.
class UTrie2StringIterator : public UMemory {
public:
    UTrie2StringIterator(const UTrie2 *t, const char16_t *p) :
        trie(t), codePointStart(p), codePointLimit(p), codePoint(U_SENTINEL) {}

    const UTrie2 *trie;
    const char16_t *codePointStart, *codePointLimit;
    UChar32 codePoint;
};

class BackwardUTrie2StringIterator : public UTrie2StringIterator {
public:
    BackwardUTrie2StringIterator(const UTrie2 *t, const char16_t *s, const char16_t *p) :
        UTrie2StringIterator(t, p), start(s) {}

    uint16_t previous16();

    const char16_t *start;
};

class ForwardUTrie2StringIterator : public UTrie2StringIterator {
public:
    // Iteration limit l can be nullptr.
    // In that case, the caller must detect c==0 and stop.
    ForwardUTrie2StringIterator(const UTrie2 *t, const char16_t *p, const char16_t *l) :
        UTrie2StringIterator(t, p), limit(l) {}

    uint16_t next16();

    const char16_t *limit;
};

U_NAMESPACE_END

#endif

/* Internal definitions ----------------------------------------------------- */

U_CDECL_BEGIN

/** Build-time trie structure. */
struct UNewTrie2;
typedef struct UNewTrie2 UNewTrie2;

/*
 * Trie structure definition.
 *
 * Either the data table is 16 bits wide and accessed via the index
 * pointer, with each index item increased by indexLength;
 * in this case, data32==NULL, and data16 is used for direct ASCII access.
 *
 * Or the data table is 32 bits wide and accessed via the data32 pointer.
 */
struct UTrie2 {
    /* protected: used by macros and functions for reading values */
    const uint16_t *index;
    const uint16_t *data16;     /* for fast UTF-8 ASCII access, if 16b data */
    const uint32_t *data32;     /* NULL if 16b data is used via index */

    int32_t indexLength, dataLength;
    uint16_t index2NullOffset;  /* 0xffff if there is no dedicated index-2 null block */
    uint16_t dataNullOffset;
    uint32_t initialValue;
    /** Value returned for out-of-range code points and illegal UTF-8. */
    uint32_t errorValue;

    /* Start of the last range which ends at U+10ffff, and its value. */
    UChar32 highStart;
    int32_t highValueIndex;

    /* private: used by builder and unserialization functions */
    void *memory;           /* serialized bytes; NULL if not frozen yet */
    int32_t length;         /* number of serialized bytes at memory; 0 if not frozen yet */
    UBool isMemoryOwned;    /* true if the trie owns the memory */
    UBool padding1;
    int16_t padding2;
    UNewTrie2 *newTrie;     /* builder object; NULL when frozen */

#ifdef UTRIE2_DEBUG
    const char *name;
#endif
};

/**
 * Trie constants, defining shift widths, index array lengths, etc.
 *
 * These are needed for the runtime macros but users can treat these as
 * implementation details and skip to the actual public API further below.
 */
enum {
    /** Shift size for getting the index-1 table offset. */
    UTRIE2_SHIFT_1=6+5,

    /** Shift size for getting the index-2 table offset. */
    UTRIE2_SHIFT_2=5,

    /**
     * Difference between the two shift sizes,
     * for getting an index-1 offset from an index-2 offset. 6=11-5
     */
    UTRIE2_SHIFT_1_2=UTRIE2_SHIFT_1-UTRIE2_SHIFT_2,

    /**
     * Number of index-1 entries for the BMP. 32=0x20
     * This part of the index-1 table is omitted from the serialized form.
     */
    UTRIE2_OMITTED_BMP_INDEX_1_LENGTH=0x10000>>UTRIE2_SHIFT_1,

    /** Number of code points per index-1 table entry. 2048=0x800 */
    UTRIE2_CP_PER_INDEX_1_ENTRY=1<<UTRIE2_SHIFT_1,

    /** Number of entries in an index-2 block. 64=0x40 */
    UTRIE2_INDEX_2_BLOCK_LENGTH=1<<UTRIE2_SHIFT_1_2,

    /** Mask for getting the lower bits for the in-index-2-block offset. */
    UTRIE2_INDEX_2_MASK=UTRIE2_INDEX_2_BLOCK_LENGTH-1,

    /** Number of entries in a data block. 32=0x20 */
    UTRIE2_DATA_BLOCK_LENGTH=1<<UTRIE2_SHIFT_2,

    /** Mask for getting the lower bits for the in-data-block offset. */
    UTRIE2_DATA_MASK=UTRIE2_DATA_BLOCK_LENGTH-1,

    /**
     * Shift size for shifting left the index array values.
     * Increases possible data size with 16-bit index values at the cost
     * of compactability.
     * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
     */
    UTRIE2_INDEX_SHIFT=2,

    /** The alignment size of a data block. Also the granularity for compaction. */
    UTRIE2_DATA_GRANULARITY=1<<UTRIE2_INDEX_SHIFT,

    /* Fixed layout of the first part of the index array. ------------------- */

    /**
     * The BMP part of the index-2 table is fixed and linear and starts at offset 0.
     * Length=2048=0x800=0x10000>>UTRIE2_SHIFT_2.
     */
    UTRIE2_INDEX_2_OFFSET=0,

    /**
     * The part of the index-2 table for U+D800..U+DBFF stores values for
     * lead surrogate code _units_ not code _points_.
     * Values for lead surrogate code _points_ are indexed with this portion of the table.
     * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
     */
    UTRIE2_LSCP_INDEX_2_OFFSET=0x10000>>UTRIE2_SHIFT_2,
    UTRIE2_LSCP_INDEX_2_LENGTH=0x400>>UTRIE2_SHIFT_2,

    /** Count the lengths of both BMP pieces. 2080=0x820 */
    UTRIE2_INDEX_2_BMP_LENGTH=UTRIE2_LSCP_INDEX_2_OFFSET+UTRIE2_LSCP_INDEX_2_LENGTH,

    /**
     * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
     * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
     */
    UTRIE2_UTF8_2B_INDEX_2_OFFSET=UTRIE2_INDEX_2_BMP_LENGTH,
    UTRIE2_UTF8_2B_INDEX_2_LENGTH=0x800>>6,  /* U+0800 is the first code point after 2-byte UTF-8 */

    /**
     * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
     * Variable length, for code points up to highStart, where the last single-value range starts.
     * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
     * (For 0x100000 supplementary code points U+10000..U+10ffff.)
     *
     * The part of the index-2 table for supplementary code points starts
     * after this index-1 table.
     *
     * Both the index-1 table and the following part of the index-2 table
     * are omitted completely if there is only BMP data.
     */
    UTRIE2_INDEX_1_OFFSET=UTRIE2_UTF8_2B_INDEX_2_OFFSET+UTRIE2_UTF8_2B_INDEX_2_LENGTH,
    UTRIE2_MAX_INDEX_1_LENGTH=0x100000>>UTRIE2_SHIFT_1,

    /*
     * Fixed layout of the first part of the data array. -----------------------
     * Starts with 4 blocks (128=0x80 entries) for ASCII.
     */

    /**
     * The illegal-UTF-8 data block follows the ASCII block, at offset 128=0x80.
     * Used with linear access for single bytes 0..0xbf for simple error handling.
     * Length 64=0x40, not UTRIE2_DATA_BLOCK_LENGTH.
     */
    UTRIE2_BAD_UTF8_DATA_OFFSET=0x80,

    /** The start of non-linear-ASCII data blocks, at offset 192=0xc0. */
    UTRIE2_DATA_START_OFFSET=0xc0
};

/* Internal functions and macros -------------------------------------------- */

/**
 * Internal function for part of the UTRIE2_U8_NEXTxx() macro implementations.
 * Do not call directly.
 * @internal
 */
U_CAPI int32_t U_EXPORT2
utrie2_internalU8NextIndex(const UTrie2 *trie, UChar32 c,
                           const uint8_t *src, const uint8_t *limit);

/**
 * Internal function for part of the UTRIE2_U8_PREVxx() macro implementations.
 * Do not call directly.
 * @internal
 */
U_CAPI int32_t U_EXPORT2
utrie2_internalU8PrevIndex(const UTrie2 *trie, UChar32 c,
                           const uint8_t *start, const uint8_t *src);


/** Internal low-level trie getter. Returns a data index. */
#define _UTRIE2_INDEX_RAW(offset, trieIndex, c) \
    (((int32_t)((trieIndex)[(offset)+((c)>>UTRIE2_SHIFT_2)]) \
    <<UTRIE2_INDEX_SHIFT)+ \
    ((c)&UTRIE2_DATA_MASK))

/** Internal trie getter from a UTF-16 single/lead code unit. Returns the data index. */
#define _UTRIE2_INDEX_FROM_U16_SINGLE_LEAD(trieIndex, c) _UTRIE2_INDEX_RAW(0, trieIndex, c)

/** Internal trie getter from a lead surrogate code point (D800..DBFF). Returns the data index. */
#define _UTRIE2_INDEX_FROM_LSCP(trieIndex, c) \
    _UTRIE2_INDEX_RAW(UTRIE2_LSCP_INDEX_2_OFFSET-(0xd800>>UTRIE2_SHIFT_2), trieIndex, c)

/** Internal trie getter from a BMP code point. Returns the data index. */
#define _UTRIE2_INDEX_FROM_BMP(trieIndex, c) \
    _UTRIE2_INDEX_RAW(U_IS_LEAD(c) ? UTRIE2_LSCP_INDEX_2_OFFSET-(0xd800>>UTRIE2_SHIFT_2) : 0, \
                      trieIndex, c)

/** Internal trie getter from a supplementary code point below highStart. Returns the data index. */
#define _UTRIE2_INDEX_FROM_SUPP(trieIndex, c) \
    (((int32_t)((trieIndex)[ \
        (trieIndex)[(UTRIE2_INDEX_1_OFFSET-UTRIE2_OMITTED_BMP_INDEX_1_LENGTH)+ \
                      ((c)>>UTRIE2_SHIFT_1)]+ \
        (((c)>>UTRIE2_SHIFT_2)&UTRIE2_INDEX_2_MASK)]) \
    <<UTRIE2_INDEX_SHIFT)+ \
    ((c)&UTRIE2_DATA_MASK))

/**
 * Internal trie getter from a code point, with checking that c is in 0..10FFFF.
 * Returns the data index.
 */
#define _UTRIE2_INDEX_FROM_CP(trie, asciiOffset, c) \
    ((uint32_t)(c)<0xd800 ? \
        _UTRIE2_INDEX_RAW(0, (trie)->index, c) : \
        (uint32_t)(c)<=0xffff ? \
            _UTRIE2_INDEX_RAW( \
                (c)<=0xdbff ? UTRIE2_LSCP_INDEX_2_OFFSET-(0xd800>>UTRIE2_SHIFT_2) : 0, \
                (trie)->index, c) : \
            (uint32_t)(c)>0x10ffff ? \
                (asciiOffset)+UTRIE2_BAD_UTF8_DATA_OFFSET : \
                (c)>=(trie)->highStart ? \
                    (trie)->highValueIndex : \
                    _UTRIE2_INDEX_FROM_SUPP((trie)->index, c))

/** Internal trie getter from a UTF-16 single/lead code unit. Returns the data. */
#define _UTRIE2_GET_FROM_U16_SINGLE_LEAD(trie, data, c) \
    (trie)->data[_UTRIE2_INDEX_FROM_U16_SINGLE_LEAD((trie)->index, c)]

/** Internal trie getter from a supplementary code point. Returns the data. */
#define _UTRIE2_GET_FROM_SUPP(trie, data, c) \
    (trie)->data[(c)>=(trie)->highStart ? (trie)->highValueIndex : \
                 _UTRIE2_INDEX_FROM_SUPP((trie)->index, c)]

/**
 * Internal trie getter from a code point, with checking that c is in 0..10FFFF.
 * Returns the data.
 */
#define _UTRIE2_GET(trie, data, asciiOffset, c) \
    (trie)->data[_UTRIE2_INDEX_FROM_CP(trie, asciiOffset, c)]

/** Internal next-post-increment: get the next code point (c) and its data. */
#define _UTRIE2_U16_NEXT(trie, data, src, limit, c, result) UPRV_BLOCK_MACRO_BEGIN { \
    { \
        uint16_t __c2; \
        (c)=*(src)++; \
        if(!U16_IS_LEAD(c)) { \
            (result)=_UTRIE2_GET_FROM_U16_SINGLE_LEAD(trie, data, c); \
        } else if((src)==(limit) || !U16_IS_TRAIL(__c2=*(src))) { \
            (result)=(trie)->data[_UTRIE2_INDEX_FROM_LSCP((trie)->index, c)]; \
        } else { \
            ++(src); \
            (c)=U16_GET_SUPPLEMENTARY((c), __c2); \
            (result)=_UTRIE2_GET_FROM_SUPP((trie), data, (c)); \
        } \
    } \
} UPRV_BLOCK_MACRO_END

/** Internal pre-decrement-previous: get the previous code point (c) and its data */
#define _UTRIE2_U16_PREV(trie, data, start, src, c, result) UPRV_BLOCK_MACRO_BEGIN { \
    { \
        uint16_t __c2; \
        (c)=*--(src); \
        if(!U16_IS_TRAIL(c) || (src)==(start) || !U16_IS_LEAD(__c2=*((src)-1))) { \
            (result)=(trie)->data[_UTRIE2_INDEX_FROM_BMP((trie)->index, c)]; \
        } else { \
            --(src); \
            (c)=U16_GET_SUPPLEMENTARY(__c2, (c)); \
            (result)=_UTRIE2_GET_FROM_SUPP((trie), data, (c)); \
        } \
    } \
} UPRV_BLOCK_MACRO_END

/** Internal UTF-8 next-post-increment: get the next code point's data. */
#define _UTRIE2_U8_NEXT(trie, ascii, data, src, limit, result) UPRV_BLOCK_MACRO_BEGIN { \
    uint8_t __lead=(uint8_t)*(src)++; \
    if(U8_IS_SINGLE(__lead)) { \
        (result)=(trie)->ascii[__lead]; \
    } else { \
        uint8_t __t1, __t2; \
        if( /* handle U+0800..U+FFFF inline */ \
            0xe0<=__lead && __lead<0xf0 && ((src)+1)<(limit) && \
            U8_IS_VALID_LEAD3_AND_T1(__lead, __t1=(uint8_t)*(src)) && \
            (__t2=(uint8_t)(*((src)+1)-0x80))<= 0x3f \
        ) { \
            (src)+=2; \
            (result)=(trie)->data[ \
                ((int32_t)((trie)->index[((__lead-0xe0)<<(12-UTRIE2_SHIFT_2))+ \
                                         ((__t1&0x3f)<<(6-UTRIE2_SHIFT_2))+(__t2>>UTRIE2_SHIFT_2)]) \
                <<UTRIE2_INDEX_SHIFT)+ \
                (__t2&UTRIE2_DATA_MASK)]; \
        } else if( /* handle U+0080..U+07FF inline */ \
            __lead<0xe0 && __lead>=0xc2 && (src)<(limit) && \
            (__t1=(uint8_t)(*(src)-0x80))<=0x3f \
        ) { \
            ++(src); \
            (result)=(trie)->data[ \
                (trie)->index[(UTRIE2_UTF8_2B_INDEX_2_OFFSET-0xc0)+__lead]+ \
                __t1]; \
        } else { \
            int32_t __index=utrie2_internalU8NextIndex((trie), __lead, (const uint8_t *)(src), \
                                                                       (const uint8_t *)(limit)); \
            (src)+=__index&7; \
            (result)=(trie)->data[__index>>3]; \
        } \
    } \
} UPRV_BLOCK_MACRO_END

/** Internal UTF-8 pre-decrement-previous: get the previous code point's data. */
#define _UTRIE2_U8_PREV(trie, ascii, data, start, src, result) UPRV_BLOCK_MACRO_BEGIN { \
    uint8_t __b=(uint8_t)*--(src); \
    if(U8_IS_SINGLE(__b)) { \
        (result)=(trie)->ascii[__b]; \
    } else { \
        int32_t __index=utrie2_internalU8PrevIndex((trie), __b, (const uint8_t *)(start), \
                                                                (const uint8_t *)(src)); \
        (src)-=__index&7; \
        (result)=(trie)->data[__index>>3]; \
    } \
} UPRV_BLOCK_MACRO_END

U_CDECL_END

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/icu-small/source/common/utrie2_builder.cpp                                         0000664 0000000 0000000 00000136062 14746647661 0023622 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 2001-2014, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*   file name:  utrie2_builder.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2008sep26 (split off from utrie2.c)
*   created by: Markus W. Scherer
*
*   This is a common implementation of a Unicode trie.
*   It is a kind of compressed, serializable table of 16- or 32-bit values associated with
*   Unicode code points (0..0x10ffff).
*   This is the second common version of a Unicode trie (hence the name UTrie2).
*   See utrie2.h for a comparison.
*
*   This file contains only the builder code.
*   See utrie2.c for the runtime and enumeration code.
*/
// #define UTRIE2_DEBUG
#ifdef UTRIE2_DEBUG
#   include <stdio.h>
#endif
// #define UCPTRIE_DEBUG

#include "unicode/utypes.h"
#ifdef UCPTRIE_DEBUG
#include "unicode/ucptrie.h"
#include "unicode/umutablecptrie.h"
#include "ucptrie_impl.h"
#endif
#include "cmemory.h"
#include "utrie2.h"
#include "utrie2_impl.h"

#include "utrie.h"  // for utrie2_fromUTrie()

/* Implementation notes ----------------------------------------------------- */

/*
 * The UTRIE2_SHIFT_1, UTRIE2_SHIFT_2, UTRIE2_INDEX_SHIFT and other values
 * have been chosen to minimize trie sizes overall.
 * Most of the code is flexible enough to work with a range of values,
 * within certain limits.
 *
 * Exception: Support for separate values for lead surrogate code _units_
 * vs. code _points_ was added after the constants were fixed,
 * and has not been tested nor particularly designed for different constant values.
 * (Especially the utrie2_enum() code that jumps to the special LSCP index-2
 * part and back.)
 *
 * Requires UTRIE2_SHIFT_2<=6. Otherwise 0xc0 which is the top of the ASCII-linear data
 * including the bad-UTF-8-data block is not a multiple of UTRIE2_DATA_BLOCK_LENGTH
 * and map[block>>UTRIE2_SHIFT_2] (used in reference counting and compaction
 * remapping) stops working.
 *
 * Requires UTRIE2_SHIFT_1>=10 because utrie2_enumForLeadSurrogate()
 * assumes that a single index-2 block is used for 0x400 code points
 * corresponding to one lead surrogate.
 *
 * Requires UTRIE2_SHIFT_1<=16. Otherwise one single index-2 block contains
 * more than one Unicode plane, and the split of the index-2 table into a BMP
 * part and a supplementary part, with a gap in between, would not work.
 *
 * Requires UTRIE2_INDEX_SHIFT>=1 not because of the code but because
 * there is data with more than 64k distinct values,
 * for example for Unihan collation with a separate collation weight per
 * Han character.
 */

/* Building a trie ----------------------------------------------------------*/

enum {
    /** The null index-2 block, following the gap in the index-2 table. */
    UNEWTRIE2_INDEX_2_NULL_OFFSET=UNEWTRIE2_INDEX_GAP_OFFSET+UNEWTRIE2_INDEX_GAP_LENGTH,

    /** The start of allocated index-2 blocks. */
    UNEWTRIE2_INDEX_2_START_OFFSET=UNEWTRIE2_INDEX_2_NULL_OFFSET+UTRIE2_INDEX_2_BLOCK_LENGTH,

    /**
     * The null data block.
     * Length 64=0x40 even if UTRIE2_DATA_BLOCK_LENGTH is smaller,
     * to work with 6-bit trail bytes from 2-byte UTF-8.
     */
    UNEWTRIE2_DATA_NULL_OFFSET=UTRIE2_DATA_START_OFFSET,

    /** The start of allocated data blocks. */
    UNEWTRIE2_DATA_START_OFFSET=UNEWTRIE2_DATA_NULL_OFFSET+0x40,

    /**
     * The start of data blocks for U+0800 and above.
     * Below, compaction uses a block length of 64 for 2-byte UTF-8.
     * From here on, compaction uses UTRIE2_DATA_BLOCK_LENGTH.
     * Data values for 0x780 code points beyond ASCII.
     */
    UNEWTRIE2_DATA_0800_OFFSET=UNEWTRIE2_DATA_START_OFFSET+0x780
};

/* Start with allocation of 16k data entries. */
#define UNEWTRIE2_INITIAL_DATA_LENGTH ((int32_t)1<<14)

/* Grow about 8x each time. */
#define UNEWTRIE2_MEDIUM_DATA_LENGTH ((int32_t)1<<17)

static int32_t
allocIndex2Block(UNewTrie2 *trie);

U_CAPI UTrie2 * U_EXPORT2
utrie2_open(uint32_t initialValue, uint32_t errorValue, UErrorCode *pErrorCode) {
    UTrie2 *trie;
    UNewTrie2 *newTrie;
    uint32_t *data;
    int32_t i, j;

    if(U_FAILURE(*pErrorCode)) {
        return nullptr;
    }

    trie=(UTrie2 *)uprv_malloc(sizeof(UTrie2));
    newTrie=(UNewTrie2 *)uprv_malloc(sizeof(UNewTrie2));
    data=(uint32_t *)uprv_malloc(UNEWTRIE2_INITIAL_DATA_LENGTH*4);
    if(trie==nullptr || newTrie==nullptr || data==nullptr) {
        uprv_free(trie);
        uprv_free(newTrie);
        uprv_free(data);
        *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
        return nullptr;
    }

    uprv_memset(trie, 0, sizeof(UTrie2));
    trie->initialValue=initialValue;
    trie->errorValue=errorValue;
    trie->highStart=0x110000;
    trie->newTrie=newTrie;
#ifdef UTRIE2_DEBUG
    trie->name="open";
#endif

    newTrie->data=data;
#ifdef UCPTRIE_DEBUG
    newTrie->t3=umutablecptrie_open(initialValue, errorValue, pErrorCode);
#endif
    newTrie->dataCapacity=UNEWTRIE2_INITIAL_DATA_LENGTH;
    newTrie->initialValue=initialValue;
    newTrie->errorValue=errorValue;
    newTrie->highStart=0x110000;
    newTrie->firstFreeBlock=0;  /* no free block in the list */
    newTrie->isCompacted=false;

    /*
     * preallocate and reset
     * - ASCII
     * - the bad-UTF-8-data block
     * - the null data block
     */
    for(i=0; i<0x80; ++i) {
        newTrie->data[i]=initialValue;
    }
    for(; i<0xc0; ++i) {
        newTrie->data[i]=errorValue;
    }
    for(i=UNEWTRIE2_DATA_NULL_OFFSET; i<UNEWTRIE2_DATA_START_OFFSET; ++i) {
        newTrie->data[i]=initialValue;
    }
    newTrie->dataNullOffset=UNEWTRIE2_DATA_NULL_OFFSET;
    newTrie->dataLength=UNEWTRIE2_DATA_START_OFFSET;

    /* set the index-2 indexes for the 2=0x80>>UTRIE2_SHIFT_2 ASCII data blocks */
    for(i=0, j=0; j<0x80; ++i, j+=UTRIE2_DATA_BLOCK_LENGTH) {
        newTrie->index2[i]=j;
        newTrie->map[i]=1;
    }
    /* reference counts for the bad-UTF-8-data block */
    for(; j<0xc0; ++i, j+=UTRIE2_DATA_BLOCK_LENGTH) {
        newTrie->map[i]=0;
    }
    /*
     * Reference counts for the null data block: all blocks except for the ASCII blocks.
     * Plus 1 so that we don't drop this block during compaction.
     * Plus as many as needed for lead surrogate code points.
     */
    /* i==newTrie->dataNullOffset */
    newTrie->map[i++]=
        (0x110000>>UTRIE2_SHIFT_2)-
        (0x80>>UTRIE2_SHIFT_2)+
        1+
        UTRIE2_LSCP_INDEX_2_LENGTH;
    j+=UTRIE2_DATA_BLOCK_LENGTH;
    for(; j<UNEWTRIE2_DATA_START_OFFSET; ++i, j+=UTRIE2_DATA_BLOCK_LENGTH) {
        newTrie->map[i]=0;
    }

    /*
     * set the remaining indexes in the BMP index-2 block
     * to the null data block
     */
    for(i=0x80>>UTRIE2_SHIFT_2; i<UTRIE2_INDEX_2_BMP_LENGTH; ++i) {
        newTrie->index2[i]=UNEWTRIE2_DATA_NULL_OFFSET;
    }

    /*
     * Fill the index gap with impossible values so that compaction
     * does not overlap other index-2 blocks with the gap.
     */
    for(i=0; i<UNEWTRIE2_INDEX_GAP_LENGTH; ++i) {
        newTrie->index2[UNEWTRIE2_INDEX_GAP_OFFSET+i]=-1;
    }

    /* set the indexes in the null index-2 block */
    for(i=0; i<UTRIE2_INDEX_2_BLOCK_LENGTH; ++i) {
        newTrie->index2[UNEWTRIE2_INDEX_2_NULL_OFFSET+i]=UNEWTRIE2_DATA_NULL_OFFSET;
    }
    newTrie->index2NullOffset=UNEWTRIE2_INDEX_2_NULL_OFFSET;
    newTrie->index2Length=UNEWTRIE2_INDEX_2_START_OFFSET;

    /* set the index-1 indexes for the linear index-2 block */
    for(i=0, j=0;
        i<UTRIE2_OMITTED_BMP_INDEX_1_LENGTH;
        ++i, j+=UTRIE2_INDEX_2_BLOCK_LENGTH
    ) {
        newTrie->index1[i]=j;
    }

    /* set the remaining index-1 indexes to the null index-2 block */
    for(; i<UNEWTRIE2_INDEX_1_LENGTH; ++i) {
        newTrie->index1[i]=UNEWTRIE2_INDEX_2_NULL_OFFSET;
    }

    /*
     * Preallocate and reset data for U+0080..U+07ff,
     * for 2-byte UTF-8 which will be compacted in 64-blocks
     * even if UTRIE2_DATA_BLOCK_LENGTH is smaller.
     */
    for(i=0x80; i<0x800; i+=UTRIE2_DATA_BLOCK_LENGTH) {
        utrie2_set32(trie, i, initialValue, pErrorCode);
    }

    return trie;
}

static UNewTrie2 *
cloneBuilder(const UNewTrie2 *other) {
    UNewTrie2 *trie;

    trie = static_cast<UNewTrie2*>(uprv_malloc(sizeof(UNewTrie2)));
    if(trie==nullptr) {
        return nullptr;
    }

    trie->data = static_cast<uint32_t*>(uprv_malloc(other->dataCapacity * 4));
    if(trie->data==nullptr) {
        uprv_free(trie);
        return nullptr;
    }
#ifdef UCPTRIE_DEBUG
    if(other->t3==nullptr) {
        trie->t3=nullptr;
    } else {
        UErrorCode errorCode=U_ZERO_ERROR;
        trie->t3=umutablecptrie_clone(other->t3, &errorCode);
    }
#endif
    trie->dataCapacity=other->dataCapacity;

    /* clone data */
    uprv_memcpy(trie->index1, other->index1, sizeof(trie->index1));
    uprv_memcpy(trie->index2, other->index2, (size_t)other->index2Length*4);
    trie->index2NullOffset=other->index2NullOffset;
    trie->index2Length=other->index2Length;

    uprv_memcpy(trie->data, other->data, (size_t)other->dataLength*4);
    trie->dataNullOffset=other->dataNullOffset;
    trie->dataLength=other->dataLength;

    /* reference counters */
    if(other->isCompacted) {
        trie->firstFreeBlock=0;
    } else {
        uprv_memcpy(trie->map, other->map, ((size_t)other->dataLength>>UTRIE2_SHIFT_2)*4);
        trie->firstFreeBlock=other->firstFreeBlock;
    }

    trie->initialValue=other->initialValue;
    trie->errorValue=other->errorValue;
    trie->highStart=other->highStart;
    trie->isCompacted=other->isCompacted;

    return trie;
}

U_CAPI UTrie2 * U_EXPORT2
utrie2_clone(const UTrie2 *other, UErrorCode *pErrorCode) {
    UTrie2 *trie;

    if(U_FAILURE(*pErrorCode)) {
        return nullptr;
    }
    if(other==nullptr || (other->memory==nullptr && other->newTrie==nullptr)) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return nullptr;
    }

    trie=(UTrie2 *)uprv_malloc(sizeof(UTrie2));
    if(trie==nullptr) {
        *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
        return nullptr;
    }
    uprv_memcpy(trie, other, sizeof(UTrie2));

    if(other->memory!=nullptr) {
        trie->memory=uprv_malloc(other->length);
        if(trie->memory!=nullptr) {
            trie->isMemoryOwned=true;
            uprv_memcpy(trie->memory, other->memory, other->length);

            /* make the clone's pointers point to its own memory */
            trie->index=(uint16_t *)trie->memory+(other->index-(uint16_t *)other->memory);
            if(other->data16!=nullptr) {
                trie->data16=(uint16_t *)trie->memory+(other->data16-(uint16_t *)other->memory);
            }
            if(other->data32!=nullptr) {
                trie->data32=(uint32_t *)trie->memory+(other->data32-(uint32_t *)other->memory);
            }
        }
    } else /* other->newTrie!=nullptr */ {
        trie->newTrie=cloneBuilder(other->newTrie);
    }

    if(trie->memory==nullptr && trie->newTrie==nullptr) {
        *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
        uprv_free(trie);
        trie=nullptr;
    }
    return trie;
}

typedef struct NewTrieAndStatus {
    UTrie2 *trie;
    UErrorCode errorCode;
    UBool exclusiveLimit;  /* rather than inclusive range end */
} NewTrieAndStatus;

static UBool U_CALLCONV
copyEnumRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {
    NewTrieAndStatus *nt=(NewTrieAndStatus *)context;
    if(value!=nt->trie->initialValue) {
        if(nt->exclusiveLimit) {
            --end;
        }
        if(start==end) {
            utrie2_set32(nt->trie, start, value, &nt->errorCode);
        } else {
            utrie2_setRange32(nt->trie, start, end, value, true, &nt->errorCode);
        }
        return U_SUCCESS(nt->errorCode);
    } else {
        return true;
    }
}

#ifdef UTRIE2_DEBUG
static long countInitial(const UTrie2 *trie) {
    uint32_t initialValue=trie->initialValue;
    int32_t length=trie->dataLength;
    long count=0;
    if(trie->data16!=nullptr) {
        for(int32_t i=0; i<length; ++i) {
            if(trie->data16[i]==initialValue) { ++count; }
        }
    } else {
        for(int32_t i=0; i<length; ++i) {
            if(trie->data32[i]==initialValue) { ++count; }
        }
    }
    return count;
}

static void
utrie_printLengths(const UTrie *trie) {
    long indexLength=trie->indexLength;
    long dataLength=(long)trie->dataLength;
    long totalLength=(long)sizeof(UTrieHeader)+indexLength*2+dataLength*(trie->data32!=nullptr ? 4 : 2);
    printf("**UTrieLengths** index:%6ld  data:%6ld  serialized:%6ld\n",
           indexLength, dataLength, totalLength);
}

static void
utrie2_printLengths(const UTrie2 *trie, const char *which) {
    long indexLength=trie->indexLength;
    long dataLength=(long)trie->dataLength;
    long totalLength=(long)sizeof(UTrie2Header)+indexLength*2+dataLength*(trie->data32!=nullptr ? 4 : 2);
    printf("**UTrie2Lengths(%s %s)** index:%6ld  data:%6ld  countInitial:%6ld  serialized:%6ld\n",
           which, trie->name, indexLength, dataLength, countInitial(trie), totalLength);
}
#endif

U_CAPI UTrie2 * U_EXPORT2
utrie2_cloneAsThawed(const UTrie2 *other, UErrorCode *pErrorCode) {
    NewTrieAndStatus context;
    char16_t lead;

    if(U_FAILURE(*pErrorCode)) {
        return nullptr;
    }
    if(other==nullptr || (other->memory==nullptr && other->newTrie==nullptr)) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return nullptr;
    }
    if(other->newTrie!=nullptr && !other->newTrie->isCompacted) {
        return utrie2_clone(other, pErrorCode);  /* clone an unfrozen trie */
    }

    /* Clone the frozen trie by enumerating it and building a new one. */
    context.trie=utrie2_open(other->initialValue, other->errorValue, pErrorCode);
    if(U_FAILURE(*pErrorCode)) {
        return nullptr;
    }
    context.exclusiveLimit=false;
    context.errorCode=*pErrorCode;
    utrie2_enum(other, nullptr, copyEnumRange, &context);
    *pErrorCode=context.errorCode;
    for(lead=0xd800; lead<0xdc00; ++lead) {
        uint32_t value;
        if(other->data32==nullptr) {
            value=UTRIE2_GET16_FROM_U16_SINGLE_LEAD(other, lead);
        } else {
            value=UTRIE2_GET32_FROM_U16_SINGLE_LEAD(other, lead);
        }
        if(value!=other->initialValue) {
            utrie2_set32ForLeadSurrogateCodeUnit(context.trie, lead, value, pErrorCode);
        }
    }
    if(U_FAILURE(*pErrorCode)) {
        utrie2_close(context.trie);
        context.trie=nullptr;
    }
    return context.trie;
}

/* Almost the same as utrie2_cloneAsThawed() but copies a UTrie and freezes the clone. */
U_CAPI UTrie2 * U_EXPORT2
utrie2_fromUTrie(const UTrie *trie1, uint32_t errorValue, UErrorCode *pErrorCode) {
    NewTrieAndStatus context;
    char16_t lead;

    if(U_FAILURE(*pErrorCode)) {
        return nullptr;
    }
    if(trie1==nullptr) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return nullptr;
    }
    context.trie=utrie2_open(trie1->initialValue, errorValue, pErrorCode);
    if(U_FAILURE(*pErrorCode)) {
        return nullptr;
    }
    context.exclusiveLimit=true;
    context.errorCode=*pErrorCode;
    utrie_enum(trie1, nullptr, copyEnumRange, &context);
    *pErrorCode=context.errorCode;
    for(lead=0xd800; lead<0xdc00; ++lead) {
        uint32_t value;
        if(trie1->data32==nullptr) {
            value=UTRIE_GET16_FROM_LEAD(trie1, lead);
        } else {
            value=UTRIE_GET32_FROM_LEAD(trie1, lead);
        }
        if(value!=trie1->initialValue) {
            utrie2_set32ForLeadSurrogateCodeUnit(context.trie, lead, value, pErrorCode);
        }
    }
    if(U_SUCCESS(*pErrorCode)) {
        utrie2_freeze(context.trie,
                      trie1->data32!=nullptr ? UTRIE2_32_VALUE_BITS : UTRIE2_16_VALUE_BITS,
                      pErrorCode);
    }
#ifdef UTRIE2_DEBUG
    if(U_SUCCESS(*pErrorCode)) {
        utrie_printLengths(trie1);
        utrie2_printLengths(context.trie, "fromUTrie");
    }
#endif
    if(U_FAILURE(*pErrorCode)) {
        utrie2_close(context.trie);
        context.trie=nullptr;
    }
    return context.trie;
}

static inline UBool
isInNullBlock(UNewTrie2 *trie, UChar32 c, UBool forLSCP) {
    int32_t i2, block;

    if(U_IS_LEAD(c) && forLSCP) {
        i2=(UTRIE2_LSCP_INDEX_2_OFFSET-(0xd800>>UTRIE2_SHIFT_2))+
            (c>>UTRIE2_SHIFT_2);
    } else {
        i2=trie->index1[c>>UTRIE2_SHIFT_1]+
            ((c>>UTRIE2_SHIFT_2)&UTRIE2_INDEX_2_MASK);
    }
    block=trie->index2[i2];
    return block == trie->dataNullOffset;
}

static int32_t
allocIndex2Block(UNewTrie2 *trie) {
    int32_t newBlock, newTop;

    newBlock=trie->index2Length;
    newTop=newBlock+UTRIE2_INDEX_2_BLOCK_LENGTH;
    if(newTop>UPRV_LENGTHOF(trie->index2)) {
        /*
         * Should never occur.
         * Either UTRIE2_MAX_BUILD_TIME_INDEX_LENGTH is incorrect,
         * or the code writes more values than should be possible.
         */
        return -1;
    }
    trie->index2Length=newTop;
    uprv_memcpy(trie->index2+newBlock, trie->index2+trie->index2NullOffset, UTRIE2_INDEX_2_BLOCK_LENGTH*4);
    return newBlock;
}

static int32_t
getIndex2Block(UNewTrie2 *trie, UChar32 c, UBool forLSCP) {
    int32_t i1, i2;

    if(U_IS_LEAD(c) && forLSCP) {
        return UTRIE2_LSCP_INDEX_2_OFFSET;
    }

    i1=c>>UTRIE2_SHIFT_1;
    i2=trie->index1[i1];
    if(i2==trie->index2NullOffset) {
        i2=allocIndex2Block(trie);
        if(i2<0) {
            return -1;  /* program error */
        }
        trie->index1[i1]=i2;
    }
    return i2;
}

static int32_t
allocDataBlock(UNewTrie2 *trie, int32_t copyBlock) {
    int32_t newBlock, newTop;

    if(trie->firstFreeBlock!=0) {
        /* get the first free block */
        newBlock=trie->firstFreeBlock;
        trie->firstFreeBlock=-trie->map[newBlock>>UTRIE2_SHIFT_2];
    } else {
        /* get a new block from the high end */
        newBlock=trie->dataLength;
        newTop=newBlock+UTRIE2_DATA_BLOCK_LENGTH;
        if(newTop>trie->dataCapacity) {
            /* out of memory in the data array */
            int32_t capacity;
            uint32_t *data;

            if(trie->dataCapacity<UNEWTRIE2_MEDIUM_DATA_LENGTH) {
                capacity=UNEWTRIE2_MEDIUM_DATA_LENGTH;
            } else if(trie->dataCapacity<UNEWTRIE2_MAX_DATA_LENGTH) {
                capacity=UNEWTRIE2_MAX_DATA_LENGTH;
            } else {
                /*
                 * Should never occur.
                 * Either UNEWTRIE2_MAX_DATA_LENGTH is incorrect,
                 * or the code writes more values than should be possible.
                 */
                return -1;
            }
            data = static_cast<uint32_t*>(uprv_malloc(capacity * 4));
            if(data==nullptr) {
                return -1;
            }
            uprv_memcpy(data, trie->data, (size_t)trie->dataLength*4);
            uprv_free(trie->data);
            trie->data=data;
            trie->dataCapacity=capacity;
        }
        trie->dataLength=newTop;
    }
    uprv_memcpy(trie->data+newBlock, trie->data+copyBlock, UTRIE2_DATA_BLOCK_LENGTH*4);
    trie->map[newBlock>>UTRIE2_SHIFT_2]=0;
    return newBlock;
}

/* call when the block's reference counter reaches 0 */
static void
releaseDataBlock(UNewTrie2 *trie, int32_t block) {
    /* put this block at the front of the free-block chain */
    trie->map[block>>UTRIE2_SHIFT_2]=-trie->firstFreeBlock;
    trie->firstFreeBlock=block;
}

static inline UBool
isWritableBlock(UNewTrie2 *trie, int32_t block) {
    return block != trie->dataNullOffset && 1 == trie->map[block >> UTRIE2_SHIFT_2];
}

static inline void
setIndex2Entry(UNewTrie2 *trie, int32_t i2, int32_t block) {
    int32_t oldBlock;
    ++trie->map[block>>UTRIE2_SHIFT_2];  /* increment first, in case block==oldBlock! */
    oldBlock=trie->index2[i2];
    if(0 == --trie->map[oldBlock>>UTRIE2_SHIFT_2]) {
        releaseDataBlock(trie, oldBlock);
    }
    trie->index2[i2]=block;
}

/**
 * No error checking for illegal arguments.
 *
 * @return -1 if no new data block available (out of memory in data array)
 * @internal
 */
static int32_t
getDataBlock(UNewTrie2 *trie, UChar32 c, UBool forLSCP) {
    int32_t i2, oldBlock, newBlock;

    i2=getIndex2Block(trie, c, forLSCP);
    if(i2<0) {
        return -1;  /* program error */
    }

    i2+=(c>>UTRIE2_SHIFT_2)&UTRIE2_INDEX_2_MASK;
    oldBlock=trie->index2[i2];
    if(isWritableBlock(trie, oldBlock)) {
        return oldBlock;
    }

    /* allocate a new data block */
    newBlock=allocDataBlock(trie, oldBlock);
    if(newBlock<0) {
        /* out of memory in the data array */
        return -1;
    }
    setIndex2Entry(trie, i2, newBlock);
    return newBlock;
}

/**
 * @return true if the value was successfully set
 */
static void
set32(UNewTrie2 *trie,
      UChar32 c, UBool forLSCP, uint32_t value,
      UErrorCode *pErrorCode) {
    int32_t block;

    if(trie==nullptr || trie->isCompacted) {
        *pErrorCode=U_NO_WRITE_PERMISSION;
        return;
    }
#ifdef UCPTRIE_DEBUG
    umutablecptrie_set(trie->t3, c, value, pErrorCode);
#endif

    block=getDataBlock(trie, c, forLSCP);
    if(block<0) {
        *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
        return;
    }

    trie->data[block+(c&UTRIE2_DATA_MASK)]=value;
}

U_CAPI void U_EXPORT2
utrie2_set32(UTrie2 *trie, UChar32 c, uint32_t value, UErrorCode *pErrorCode) {
    if(U_FAILURE(*pErrorCode)) {
        return;
    }
    if((uint32_t)c>0x10ffff) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }
    set32(trie->newTrie, c, true, value, pErrorCode);
}

U_CAPI void U_EXPORT2
utrie2_set32ForLeadSurrogateCodeUnit(UTrie2 *trie,
                                     UChar32 c, uint32_t value,
                                     UErrorCode *pErrorCode) {
    if(U_FAILURE(*pErrorCode)) {
        return;
    }
    if(!U_IS_LEAD(c)) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }
    set32(trie->newTrie, c, false, value, pErrorCode);
}

static void
writeBlock(uint32_t *block, uint32_t value) {
    uint32_t *limit=block+UTRIE2_DATA_BLOCK_LENGTH;
    while(block<limit) {
        *block++=value;
    }
}

/**
 * initialValue is ignored if overwrite=true
 * @internal
 */
static void
fillBlock(uint32_t *block, UChar32 start, UChar32 limit,
          uint32_t value, uint32_t initialValue, UBool overwrite) {
    uint32_t *pLimit;

    pLimit=block+limit;
    block+=start;
    if(overwrite) {
        while(block<pLimit) {
            *block++=value;
        }
    } else {
        while(block<pLimit) {
            if(*block==initialValue) {
                *block=value;
            }
            ++block;
        }
    }
}

U_CAPI void U_EXPORT2
utrie2_setRange32(UTrie2 *trie,
                  UChar32 start, UChar32 end,
                  uint32_t value, UBool overwrite,
                  UErrorCode *pErrorCode) {
    /*
     * repeat value in [start..end]
     * mark index values for repeat-data blocks by setting bit 31 of the index values
     * fill around existing values if any, if(overwrite)
     */
    UNewTrie2 *newTrie;
    int32_t block, rest, repeatBlock;
    UChar32 limit;

    if(U_FAILURE(*pErrorCode)) {
        return;
    }
    if((uint32_t)start>0x10ffff || (uint32_t)end>0x10ffff || start>end) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }
    newTrie=trie->newTrie;
    if(newTrie==nullptr || newTrie->isCompacted) {
        *pErrorCode=U_NO_WRITE_PERMISSION;
        return;
    }
#ifdef UCPTRIE_DEBUG
    umutablecptrie_setRange(newTrie->t3, start, end, value, pErrorCode);
#endif
    if(!overwrite && value==newTrie->initialValue) {
        return; /* nothing to do */
    }

    limit=end+1;
    if(start&UTRIE2_DATA_MASK) {
        UChar32 nextStart;

        /* set partial block at [start..following block boundary[ */
        block=getDataBlock(newTrie, start, true);
        if(block<0) {
            *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
            return;
        }

        nextStart=(start+UTRIE2_DATA_MASK)&~UTRIE2_DATA_MASK;
        if(nextStart<=limit) {
            fillBlock(newTrie->data+block, start&UTRIE2_DATA_MASK, UTRIE2_DATA_BLOCK_LENGTH,
                      value, newTrie->initialValue, overwrite);
            start=nextStart;
        } else {
            fillBlock(newTrie->data+block, start&UTRIE2_DATA_MASK, limit&UTRIE2_DATA_MASK,
                      value, newTrie->initialValue, overwrite);
            return;
        }
    }

    /* number of positions in the last, partial block */
    rest=limit&UTRIE2_DATA_MASK;

    /* round down limit to a block boundary */
    limit&=~UTRIE2_DATA_MASK;

    /* iterate over all-value blocks */
    if(value==newTrie->initialValue) {
        repeatBlock=newTrie->dataNullOffset;
    } else {
        repeatBlock=-1;
    }

    while(start<limit) {
        int32_t i2;
        UBool setRepeatBlock=false;

        if(value==newTrie->initialValue && isInNullBlock(newTrie, start, true)) {
            start+=UTRIE2_DATA_BLOCK_LENGTH; /* nothing to do */
            continue;
        }

        /* get index value */
        i2=getIndex2Block(newTrie, start, true);
        if(i2<0) {
            *pErrorCode=U_INTERNAL_PROGRAM_ERROR;
            return;
        }
        i2+=(start>>UTRIE2_SHIFT_2)&UTRIE2_INDEX_2_MASK;
        block=newTrie->index2[i2];
        if(isWritableBlock(newTrie, block)) {
            /* already allocated */
            if(overwrite && block>=UNEWTRIE2_DATA_0800_OFFSET) {
                /*
                 * We overwrite all values, and it's not a
                 * protected (ASCII-linear or 2-byte UTF-8) block:
                 * replace with the repeatBlock.
                 */
                setRepeatBlock=true;
            } else {
                /* !overwrite, or protected block: just write the values into this block */
                fillBlock(newTrie->data+block,
                          0, UTRIE2_DATA_BLOCK_LENGTH,
                          value, newTrie->initialValue, overwrite);
            }
        } else if(newTrie->data[block]!=value && (overwrite || block==newTrie->dataNullOffset)) {
            /*
             * Set the repeatBlock instead of the null block or previous repeat block:
             *
             * If !isWritableBlock() then all entries in the block have the same value
             * because it's the null block or a range block (the repeatBlock from a previous
             * call to utrie2_setRange32()).
             * No other blocks are used multiple times before compacting.
             *
             * The null block is the only non-writable block with the initialValue because
             * of the repeatBlock initialization above. (If value==initialValue, then
             * the repeatBlock will be the null data block.)
             *
             * We set our repeatBlock if the desired value differs from the block's value,
             * and if we overwrite any data or if the data is all initial values
             * (which is the same as the block being the null block, see above).
             */
            setRepeatBlock=true;
        }
        if(setRepeatBlock) {
            if(repeatBlock>=0) {
                setIndex2Entry(newTrie, i2, repeatBlock);
            } else {
                /* create and set and fill the repeatBlock */
                repeatBlock=getDataBlock(newTrie, start, true);
                if(repeatBlock<0) {
                    *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
                    return;
                }
                writeBlock(newTrie->data+repeatBlock, value);
            }
        }

        start+=UTRIE2_DATA_BLOCK_LENGTH;
    }

    if(rest>0) {
        /* set partial block at [last block boundary..limit[ */
        block=getDataBlock(newTrie, start, true);
        if(block<0) {
            *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
            return;
        }

        fillBlock(newTrie->data+block, 0, rest, value, newTrie->initialValue, overwrite);
    }
}

/* compaction --------------------------------------------------------------- */

static inline UBool
equal_int32(const int32_t *s, const int32_t *t, int32_t length) {
    while(length>0 && *s==*t) {
        ++s;
        ++t;
        --length;
    }
    return length == 0;
}

static inline UBool
equal_uint32(const uint32_t *s, const uint32_t *t, int32_t length) {
    while(length>0 && *s==*t) {
        ++s;
        ++t;
        --length;
    }
    return length == 0;
}

static int32_t
findSameIndex2Block(const int32_t *idx, int32_t index2Length, int32_t otherBlock) {
    int32_t block;

    /* ensure that we do not even partially get past index2Length */
    index2Length-=UTRIE2_INDEX_2_BLOCK_LENGTH;

    for(block=0; block<=index2Length; ++block) {
        if(equal_int32(idx+block, idx+otherBlock, UTRIE2_INDEX_2_BLOCK_LENGTH)) {
            return block;
        }
    }
    return -1;
}

static int32_t
findSameDataBlock(const uint32_t *data, int32_t dataLength, int32_t otherBlock, int32_t blockLength) {
    int32_t block;

    /* ensure that we do not even partially get past dataLength */
    dataLength-=blockLength;

    for(block=0; block<=dataLength; block+=UTRIE2_DATA_GRANULARITY) {
        if(equal_uint32(data+block, data+otherBlock, blockLength)) {
            return block;
        }
    }
    return -1;
}

/*
 * Find the start of the last range in the trie by enumerating backward.
 * Indexes for supplementary code points higher than this will be omitted.
 */
static UChar32
findHighStart(UNewTrie2 *trie, uint32_t highValue) {
    const uint32_t *data32;

    uint32_t value, initialValue;
    UChar32 c, prev;
    int32_t i1, i2, j, i2Block, prevI2Block, index2NullOffset, block, prevBlock, nullBlock;

    data32=trie->data;
    initialValue=trie->initialValue;

    index2NullOffset=trie->index2NullOffset;
    nullBlock=trie->dataNullOffset;

    /* set variables for previous range */
    if(highValue==initialValue) {
        prevI2Block=index2NullOffset;
        prevBlock=nullBlock;
    } else {
        prevI2Block=-1;
        prevBlock=-1;
    }
    prev=0x110000;

    /* enumerate index-2 blocks */
    i1=UNEWTRIE2_INDEX_1_LENGTH;
    c=prev;
    while(c>0) {
        i2Block=trie->index1[--i1];
        if(i2Block==prevI2Block) {
            /* the index-2 block is the same as the previous one, and filled with highValue */
            c-=UTRIE2_CP_PER_INDEX_1_ENTRY;
            continue;
        }
        prevI2Block=i2Block;
        if(i2Block==index2NullOffset) {
            /* this is the null index-2 block */
            if(highValue!=initialValue) {
                return c;
            }
            c-=UTRIE2_CP_PER_INDEX_1_ENTRY;
        } else {
            /* enumerate data blocks for one index-2 block */
            for(i2=UTRIE2_INDEX_2_BLOCK_LENGTH; i2>0;) {
                block=trie->index2[i2Block+ --i2];
                if(block==prevBlock) {
                    /* the block is the same as the previous one, and filled with highValue */
                    c-=UTRIE2_DATA_BLOCK_LENGTH;
                    continue;
                }
                prevBlock=block;
                if(block==nullBlock) {
                    /* this is the null data block */
                    if(highValue!=initialValue) {
                        return c;
                    }
                    c-=UTRIE2_DATA_BLOCK_LENGTH;
                } else {
                    for(j=UTRIE2_DATA_BLOCK_LENGTH; j>0;) {
                        value=data32[block+ --j];
                        if(value!=highValue) {
                            return c;
                        }
                        --c;
                    }
                }
            }
        }
    }

    /* deliver last range */
    return 0;
}

/*
 * Compact a build-time trie.
 *
 * The compaction
 * - removes blocks that are identical with earlier ones
 * - overlaps adjacent blocks as much as possible (if overlap==true)
 * - moves blocks in steps of the data granularity
 * - moves and overlaps blocks that overlap with multiple values in the overlap region
 *
 * It does not
 * - try to move and overlap blocks that are not already adjacent
 */
static void
compactData(UNewTrie2 *trie) {
#ifdef UTRIE2_DEBUG
    int32_t countSame=0, sumOverlaps=0;
#endif

    int32_t start, newStart, movedStart;
    int32_t blockLength, overlap;
    int32_t i, mapIndex, blockCount;

    /* do not compact linear-ASCII data */
    newStart=UTRIE2_DATA_START_OFFSET;
    for(start=0, i=0; start<newStart; start+=UTRIE2_DATA_BLOCK_LENGTH, ++i) {
        trie->map[i]=start;
    }

    /*
     * Start with a block length of 64 for 2-byte UTF-8,
     * then switch to UTRIE2_DATA_BLOCK_LENGTH.
     */
    blockLength=64;
    blockCount=blockLength>>UTRIE2_SHIFT_2;
    for(start=newStart; start<trie->dataLength;) {
        /*
         * start: index of first entry of current block
         * newStart: index where the current block is to be moved
         *           (right after current end of already-compacted data)
         */
        if(start==UNEWTRIE2_DATA_0800_OFFSET) {
            blockLength=UTRIE2_DATA_BLOCK_LENGTH;
            blockCount=1;
        }

        /* skip blocks that are not used */
        if(trie->map[start>>UTRIE2_SHIFT_2]<=0) {
            /* advance start to the next block */
            start+=blockLength;

            /* leave newStart with the previous block! */
            continue;
        }

        /* search for an identical block */
        if( (movedStart=findSameDataBlock(trie->data, newStart, start, blockLength))
             >=0
        ) {
#ifdef UTRIE2_DEBUG
            ++countSame;
#endif
            /* found an identical block, set the other block's index value for the current block */
            for(i=blockCount, mapIndex=start>>UTRIE2_SHIFT_2; i>0; --i) {
                trie->map[mapIndex++]=movedStart;
                movedStart+=UTRIE2_DATA_BLOCK_LENGTH;
            }

            /* advance start to the next block */
            start+=blockLength;

            /* leave newStart with the previous block! */
            continue;
        }

        /* see if the beginning of this block can be overlapped with the end of the previous block */
        /* look for maximum overlap (modulo granularity) with the previous, adjacent block */
        for(overlap=blockLength-UTRIE2_DATA_GRANULARITY;
            overlap>0 && !equal_uint32(trie->data+(newStart-overlap), trie->data+start, overlap);
            overlap-=UTRIE2_DATA_GRANULARITY) {}

#ifdef UTRIE2_DEBUG
            sumOverlaps+=overlap;
#endif
        if(overlap>0 || newStart<start) {
            /* some overlap, or just move the whole block */
            movedStart=newStart-overlap;
            for(i=blockCount, mapIndex=start>>UTRIE2_SHIFT_2; i>0; --i) {
                trie->map[mapIndex++]=movedStart;
                movedStart+=UTRIE2_DATA_BLOCK_LENGTH;
            }

            /* move the non-overlapping indexes to their new positions */
            start+=overlap;
            for(i=blockLength-overlap; i>0; --i) {
                trie->data[newStart++]=trie->data[start++];
            }
        } else /* no overlap && newStart==start */ {
            for(i=blockCount, mapIndex=start>>UTRIE2_SHIFT_2; i>0; --i) {
                trie->map[mapIndex++]=start;
                start+=UTRIE2_DATA_BLOCK_LENGTH;
            }
            newStart=start;
        }
    }

    /* now adjust the index-2 table */
    for(i=0; i<trie->index2Length; ++i) {
        if(i==UNEWTRIE2_INDEX_GAP_OFFSET) {
            /* Gap indexes are invalid (-1). Skip over the gap. */
            i+=UNEWTRIE2_INDEX_GAP_LENGTH;
        }
        trie->index2[i]=trie->map[trie->index2[i]>>UTRIE2_SHIFT_2];
    }
    trie->dataNullOffset=trie->map[trie->dataNullOffset>>UTRIE2_SHIFT_2];

    /* ensure dataLength alignment */
    while((newStart&(UTRIE2_DATA_GRANULARITY-1))!=0) {
        trie->data[newStart++]=trie->initialValue;
    }

#ifdef UTRIE2_DEBUG
    /* we saved some space */
    printf("compacting UTrie2: count of 32-bit data words %lu->%lu  countSame=%ld  sumOverlaps=%ld\n",
            (long)trie->dataLength, (long)newStart, (long)countSame, (long)sumOverlaps);
#endif

    trie->dataLength=newStart;
}

static void
compactIndex2(UNewTrie2 *trie) {
    int32_t i, start, newStart, movedStart, overlap;

    /* do not compact linear-BMP index-2 blocks */
    newStart=UTRIE2_INDEX_2_BMP_LENGTH;
    for(start=0, i=0; start<newStart; start+=UTRIE2_INDEX_2_BLOCK_LENGTH, ++i) {
        trie->map[i]=start;
    }

    /* Reduce the index table gap to what will be needed at runtime. */
    newStart+=UTRIE2_UTF8_2B_INDEX_2_LENGTH+((trie->highStart-0x10000)>>UTRIE2_SHIFT_1);

    for(start=UNEWTRIE2_INDEX_2_NULL_OFFSET; start<trie->index2Length;) {
        /*
         * start: index of first entry of current block
         * newStart: index where the current block is to be moved
         *           (right after current end of already-compacted data)
         */

        /* search for an identical block */
        if( (movedStart=findSameIndex2Block(trie->index2, newStart, start))
             >=0
        ) {
            /* found an identical block, set the other block's index value for the current block */
            trie->map[start>>UTRIE2_SHIFT_1_2]=movedStart;

            /* advance start to the next block */
            start+=UTRIE2_INDEX_2_BLOCK_LENGTH;

            /* leave newStart with the previous block! */
            continue;
        }

        /* see if the beginning of this block can be overlapped with the end of the previous block */
        /* look for maximum overlap with the previous, adjacent block */
        for(overlap=UTRIE2_INDEX_2_BLOCK_LENGTH-1;
            overlap>0 && !equal_int32(trie->index2+(newStart-overlap), trie->index2+start, overlap);
            --overlap) {}

        if(overlap>0 || newStart<start) {
            /* some overlap, or just move the whole block */
            trie->map[start>>UTRIE2_SHIFT_1_2]=newStart-overlap;

            /* move the non-overlapping indexes to their new positions */
            start+=overlap;
            for(i=UTRIE2_INDEX_2_BLOCK_LENGTH-overlap; i>0; --i) {
                trie->index2[newStart++]=trie->index2[start++];
            }
        } else /* no overlap && newStart==start */ {
            trie->map[start>>UTRIE2_SHIFT_1_2]=start;
            start+=UTRIE2_INDEX_2_BLOCK_LENGTH;
            newStart=start;
        }
    }

    /* now adjust the index-1 table */
    for(i=0; i<UNEWTRIE2_INDEX_1_LENGTH; ++i) {
        trie->index1[i]=trie->map[trie->index1[i]>>UTRIE2_SHIFT_1_2];
    }
    trie->index2NullOffset=trie->map[trie->index2NullOffset>>UTRIE2_SHIFT_1_2];

    /*
     * Ensure data table alignment:
     * Needs to be granularity-aligned for 16-bit trie
     * (so that dataMove will be down-shiftable),
     * and 2-aligned for uint32_t data.
     */
    while((newStart&((UTRIE2_DATA_GRANULARITY-1)|1))!=0) {
        /* Arbitrary value: 0x3fffc not possible for real data. */
        trie->index2[newStart++] = static_cast<int32_t>(0xffff) << UTRIE2_INDEX_SHIFT;
    }

#ifdef UTRIE2_DEBUG
    /* we saved some space */
    printf("compacting UTrie2: count of 16-bit index words %lu->%lu\n",
            (long)trie->index2Length, (long)newStart);
#endif

    trie->index2Length=newStart;
}

static void
compactTrie(UTrie2 *trie, UErrorCode *pErrorCode) {
    UNewTrie2 *newTrie;
    UChar32 highStart, suppHighStart;
    uint32_t highValue;

    newTrie=trie->newTrie;

    /* find highStart and round it up */
    highValue=utrie2_get32(trie, 0x10ffff);
    highStart=findHighStart(newTrie, highValue);
    highStart=(highStart+(UTRIE2_CP_PER_INDEX_1_ENTRY-1))&~(UTRIE2_CP_PER_INDEX_1_ENTRY-1);
    if(highStart==0x110000) {
        highValue=trie->errorValue;
    }

    /*
     * Set trie->highStart only after utrie2_get32(trie, highStart).
     * Otherwise utrie2_get32(trie, highStart) would try to read the highValue.
     */
    trie->highStart=newTrie->highStart=highStart;

#ifdef UTRIE2_DEBUG
    printf("UTrie2: highStart U+%06lx  highValue 0x%lx  initialValue 0x%lx\n",
            (long)highStart, (long)highValue, (long)trie->initialValue);
#endif

    if(highStart<0x110000) {
        /* Blank out [highStart..10ffff] to release associated data blocks. */
        suppHighStart= highStart<=0x10000 ? 0x10000 : highStart;
        utrie2_setRange32(trie, suppHighStart, 0x10ffff, trie->initialValue, true, pErrorCode);
        if(U_FAILURE(*pErrorCode)) {
            return;
        }
    }

    compactData(newTrie);
    if(highStart>0x10000) {
        compactIndex2(newTrie);
#ifdef UTRIE2_DEBUG
    } else {
        printf("UTrie2: highStart U+%04lx  count of 16-bit index words %lu->%lu\n",
                (long)highStart, (long)trie->newTrie->index2Length, (long)UTRIE2_INDEX_1_OFFSET);
#endif
    }

    /*
     * Store the highValue in the data array and round up the dataLength.
     * Must be done after compactData() because that assumes that dataLength
     * is a multiple of UTRIE2_DATA_BLOCK_LENGTH.
     */
    newTrie->data[newTrie->dataLength++]=highValue;
    while((newTrie->dataLength&(UTRIE2_DATA_GRANULARITY-1))!=0) {
        newTrie->data[newTrie->dataLength++]=trie->initialValue;
    }

    newTrie->isCompacted=true;
}

/* serialization ------------------------------------------------------------ */

/**
 * Maximum length of the runtime index array.
 * Limited by its own 16-bit index values, and by uint16_t UTrie2Header.indexLength.
 * (The actual maximum length is lower,
 * (0x110000>>UTRIE2_SHIFT_2)+UTRIE2_UTF8_2B_INDEX_2_LENGTH+UTRIE2_MAX_INDEX_1_LENGTH.)
 */
#define UTRIE2_MAX_INDEX_LENGTH 0xffff

/**
 * Maximum length of the runtime data array.
 * Limited by 16-bit index values that are left-shifted by UTRIE2_INDEX_SHIFT,
 * and by uint16_t UTrie2Header.shiftedDataLength.
 */
#define UTRIE2_MAX_DATA_LENGTH (0xffff<<UTRIE2_INDEX_SHIFT)

/* Compact and internally serialize the trie. */
U_CAPI void U_EXPORT2
utrie2_freeze(UTrie2 *trie, UTrie2ValueBits valueBits, UErrorCode *pErrorCode) {
    UNewTrie2 *newTrie;
    UTrie2Header *header;
    uint32_t *p;
    uint16_t *dest16;
    int32_t i, length;
    int32_t allIndexesLength;
    int32_t dataMove;  /* >0 if the data is moved to the end of the index array */
    UChar32 highStart;

    /* argument check */
    if(U_FAILURE(*pErrorCode)) {
        return;
    }
    if( trie==nullptr ||
        valueBits<0 || UTRIE2_COUNT_VALUE_BITS<=valueBits
    ) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }
    newTrie=trie->newTrie;
    if(newTrie==nullptr) {
        /* already frozen */
        UTrie2ValueBits frozenValueBits=
            trie->data16!=nullptr ? UTRIE2_16_VALUE_BITS : UTRIE2_32_VALUE_BITS;
        if(valueBits!=frozenValueBits) {
            *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        }
        return;
    }

    /* compact if necessary */
    if(!newTrie->isCompacted) {
        compactTrie(trie, pErrorCode);
        if(U_FAILURE(*pErrorCode)) {
            return;
        }
    }
    highStart=trie->highStart;

    if(highStart<=0x10000) {
        allIndexesLength=UTRIE2_INDEX_1_OFFSET;
    } else {
        allIndexesLength=newTrie->index2Length;
    }
    if(valueBits==UTRIE2_16_VALUE_BITS) {
        dataMove=allIndexesLength;
    } else {
        dataMove=0;
    }

    /* are indexLength and dataLength within limits? */
    if( /* for unshifted indexLength */
        allIndexesLength>UTRIE2_MAX_INDEX_LENGTH ||
        /* for unshifted dataNullOffset */
        (dataMove+newTrie->dataNullOffset)>0xffff ||
        /* for unshifted 2-byte UTF-8 index-2 values */
        (dataMove+UNEWTRIE2_DATA_0800_OFFSET)>0xffff ||
        /* for shiftedDataLength */
        (dataMove+newTrie->dataLength)>UTRIE2_MAX_DATA_LENGTH
    ) {
        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
        return;
    }

    /* calculate the total serialized length */
    length=sizeof(UTrie2Header)+allIndexesLength*2;
    if(valueBits==UTRIE2_16_VALUE_BITS) {
        length+=newTrie->dataLength*2;
    } else {
        length+=newTrie->dataLength*4;
    }

    trie->memory=uprv_malloc(length);
    if(trie->memory==nullptr) {
        *pErrorCode=U_MEMORY_ALLOCATION_ERROR;
        return;
    }
    trie->length=length;
    trie->isMemoryOwned=true;

    trie->indexLength=allIndexesLength;
    trie->dataLength=newTrie->dataLength;
    if(highStart<=0x10000) {
        trie->index2NullOffset=0xffff;
    } else {
        trie->index2NullOffset=static_cast<uint16_t>(UTRIE2_INDEX_2_OFFSET+newTrie->index2NullOffset);
    }
    trie->dataNullOffset=(uint16_t)(dataMove+newTrie->dataNullOffset);
    trie->highValueIndex=dataMove+trie->dataLength-UTRIE2_DATA_GRANULARITY;

    /* set the header fields */
    header=(UTrie2Header *)trie->memory;

    header->signature=UTRIE2_SIG; /* "Tri2" */
    header->options=(uint16_t)valueBits;

    header->indexLength=(uint16_t)trie->indexLength;
    header->shiftedDataLength=(uint16_t)(trie->dataLength>>UTRIE2_INDEX_SHIFT);
    header->index2NullOffset=trie->index2NullOffset;
    header->dataNullOffset=trie->dataNullOffset;
    header->shiftedHighStart=(uint16_t)(highStart>>UTRIE2_SHIFT_1);

    /* fill the index and data arrays */
    dest16=(uint16_t *)(header+1);
    trie->index=dest16;

    /* write the index-2 array values shifted right by UTRIE2_INDEX_SHIFT, after adding dataMove */
    p=(uint32_t *)newTrie->index2;
    for(i=UTRIE2_INDEX_2_BMP_LENGTH; i>0; --i) {
        *dest16++=(uint16_t)((dataMove + *p++)>>UTRIE2_INDEX_SHIFT);
    }

    /* write UTF-8 2-byte index-2 values, not right-shifted */
    for(i=0; i<(0xc2-0xc0); ++i) {                                  /* C0..C1 */
        *dest16++=(uint16_t)(dataMove+UTRIE2_BAD_UTF8_DATA_OFFSET);
    }
    for(; i<(0xe0-0xc0); ++i) {                                     /* C2..DF */
        *dest16++=(uint16_t)(dataMove+newTrie->index2[i<<(6-UTRIE2_SHIFT_2)]);
    }

    if(highStart>0x10000) {
        int32_t index1Length=(highStart-0x10000)>>UTRIE2_SHIFT_1;
        int32_t index2Offset=UTRIE2_INDEX_2_BMP_LENGTH+UTRIE2_UTF8_2B_INDEX_2_LENGTH+index1Length;

        /* write 16-bit index-1 values for supplementary code points */
        p=(uint32_t *)newTrie->index1+UTRIE2_OMITTED_BMP_INDEX_1_LENGTH;
        for(i=index1Length; i>0; --i) {
            *dest16++=(uint16_t)(UTRIE2_INDEX_2_OFFSET + *p++);
        }

        /*
         * write the index-2 array values for supplementary code points,
         * shifted right by UTRIE2_INDEX_SHIFT, after adding dataMove
         */
        p=(uint32_t *)newTrie->index2+index2Offset;
        for(i=newTrie->index2Length-index2Offset; i>0; --i) {
            *dest16++=(uint16_t)((dataMove + *p++)>>UTRIE2_INDEX_SHIFT);
        }
    }

    /* write the 16/32-bit data array */
    switch(valueBits) {
    case UTRIE2_16_VALUE_BITS:
        /* write 16-bit data values */
        trie->data16=dest16;
        trie->data32=nullptr;
        p=newTrie->data;
        for(i=newTrie->dataLength; i>0; --i) {
            *dest16++=(uint16_t)*p++;
        }
        break;
    case UTRIE2_32_VALUE_BITS:
        /* write 32-bit data values */
        trie->data16=nullptr;
        trie->data32=(uint32_t *)dest16;
        uprv_memcpy(dest16, newTrie->data, (size_t)newTrie->dataLength*4);
        break;
    default:
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }

#ifdef UTRIE2_DEBUG
    utrie2_printLengths(trie, "");
#endif

#ifdef UCPTRIE_DEBUG
    umutablecptrie_setName(newTrie->t3, trie->name);
    ucptrie_close(
        umutablecptrie_buildImmutable(
            newTrie->t3, UCPTRIE_TYPE_FAST, (UCPTrieValueWidth)valueBits, pErrorCode));
#endif
    /* Delete the UNewTrie2. */
    uprv_free(newTrie->data);
    uprv_free(newTrie);
    trie->newTrie=nullptr;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/icu-small/source/common/utrie2_impl.h                                              0000664 0000000 0000000 00000012414 14746647661 0022574 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 2001-2008, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*   file name:  utrie2_impl.h
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2008sep26 (split off from utrie2.c)
*   created by: Markus W. Scherer
*
*   Definitions needed for both runtime and builder code for UTrie2,
*   used by utrie2.c and utrie2_builder.c.
*/

#ifndef __UTRIE2_IMPL_H__
#define __UTRIE2_IMPL_H__

#ifdef UCPTRIE_DEBUG
#include "unicode/umutablecptrie.h"
#endif
#include "utrie2.h"

/* Public UTrie2 API implementation ----------------------------------------- */

/*
 * These definitions are mostly needed by utrie2.cpp,
 * but also by utrie2_serialize() and utrie2_swap().
 */

// UTrie2 signature values, in platform endianness and opposite endianness.
// The UTrie2 signature ASCII byte values spell "Tri2".
#define UTRIE2_SIG      0x54726932
#define UTRIE2_OE_SIG   0x32697254

/**
 * Trie data structure in serialized form:
 *
 * UTrie2Header header;
 * uint16_t index[header.index2Length];
 * uint16_t data[header.shiftedDataLength<<2];  -- or uint32_t data[...]
 * @internal
 */
typedef struct UTrie2Header {
    /** "Tri2" in big-endian US-ASCII (0x54726932) */
    uint32_t signature;

    /**
     * options bit field:
     * 15.. 4   reserved (0)
     *  3.. 0   UTrie2ValueBits valueBits
     */
    uint16_t options;

    /** UTRIE2_INDEX_1_OFFSET..UTRIE2_MAX_INDEX_LENGTH */
    uint16_t indexLength;

    /** (UTRIE2_DATA_START_OFFSET..UTRIE2_MAX_DATA_LENGTH)>>UTRIE2_INDEX_SHIFT */
    uint16_t shiftedDataLength;

    /** Null index and data blocks, not shifted. */
    uint16_t index2NullOffset, dataNullOffset;

    /**
     * First code point of the single-value range ending with U+10ffff,
     * rounded up and then shifted right by UTRIE2_SHIFT_1.
     */
    uint16_t shiftedHighStart;
} UTrie2Header;

/**
 * Constants for use with UTrie2Header.options.
 * @internal
 */
enum {
    /** Mask to get the UTrie2ValueBits valueBits from options. */
    UTRIE2_OPTIONS_VALUE_BITS_MASK=0xf
};

/* Building a trie ---------------------------------------------------------- */

/*
 * These definitions are mostly needed by utrie2_builder.c, but also by
 * utrie2_get32() and utrie2_enum().
 */

enum {
    /**
     * At build time, leave a gap in the index-2 table,
     * at least as long as the maximum lengths of the 2-byte UTF-8 index-2 table
     * and the supplementary index-1 table.
     * Round up to UTRIE2_INDEX_2_BLOCK_LENGTH for proper compacting.
     */
    UNEWTRIE2_INDEX_GAP_OFFSET=UTRIE2_INDEX_2_BMP_LENGTH,
    UNEWTRIE2_INDEX_GAP_LENGTH=
        ((UTRIE2_UTF8_2B_INDEX_2_LENGTH+UTRIE2_MAX_INDEX_1_LENGTH)+UTRIE2_INDEX_2_MASK)&
        ~UTRIE2_INDEX_2_MASK,

    /**
     * Maximum length of the build-time index-2 array.
     * Maximum number of Unicode code points (0x110000) shifted right by UTRIE2_SHIFT_2,
     * plus the part of the index-2 table for lead surrogate code points,
     * plus the build-time index gap,
     * plus the null index-2 block.
     */
    UNEWTRIE2_MAX_INDEX_2_LENGTH=
        (0x110000>>UTRIE2_SHIFT_2)+
        UTRIE2_LSCP_INDEX_2_LENGTH+
        UNEWTRIE2_INDEX_GAP_LENGTH+
        UTRIE2_INDEX_2_BLOCK_LENGTH,

    UNEWTRIE2_INDEX_1_LENGTH=0x110000>>UTRIE2_SHIFT_1
};

/**
 * Maximum length of the build-time data array.
 * One entry per 0x110000 code points, plus the illegal-UTF-8 block and the null block,
 * plus values for the 0x400 surrogate code units.
 */
#define UNEWTRIE2_MAX_DATA_LENGTH (0x110000+0x40+0x40+0x400)

/*
 * Build-time trie structure.
 *
 * Just using a boolean flag for "repeat use" could lead to data array overflow
 * because we would not be able to detect when a data block becomes unused.
 * It also leads to orphan data blocks that are kept through serialization.
 *
 * Need to use reference counting for data blocks,
 * and allocDataBlock() needs to look for a free block before increasing dataLength.
 *
 * This scheme seems like overkill for index-2 blocks since the whole index array is
 * preallocated anyway (unlike the growable data array).
 * Just allocating multiple index-2 blocks as needed.
 */
struct UNewTrie2 {
    int32_t index1[UNEWTRIE2_INDEX_1_LENGTH];
    int32_t index2[UNEWTRIE2_MAX_INDEX_2_LENGTH];
    uint32_t *data;
#ifdef UCPTRIE_DEBUG
    UMutableCPTrie *t3;
#endif

    uint32_t initialValue, errorValue;
    int32_t index2Length, dataCapacity, dataLength;
    int32_t firstFreeBlock;
    int32_t index2NullOffset, dataNullOffset;
    UChar32 highStart;
    UBool isCompacted;

    /**
     * Multi-purpose per-data-block table.
     *
     * Before compacting:
     *
     * Per-data-block reference counters/free-block list.
     *  0: unused
     * >0: reference counter (number of index-2 entries pointing here)
     * <0: next free data block in free-block list
     *
     * While compacting:
     *
     * Map of adjusted indexes, used in compactData() and compactIndex2().
     * Maps from original indexes to new ones.
     */
    int32_t map[UNEWTRIE2_MAX_DATA_LENGTH>>UTRIE2_SHIFT_2];
};

#endif
                                                                                                                                                                                                                                                    node-23.7.0/deps/icu-small/source/common/utrie_swap.cpp                                             0000664 0000000 0000000 00000025744 14746647661 0023070 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2018 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html

// utrie_swap.cpp
// created: 2018aug08 Markus W. Scherer

#include "unicode/utypes.h"
#include "cmemory.h"
#include "ucptrie_impl.h"
#include "udataswp.h"
#include "utrie.h"
#include "utrie2_impl.h"

// These functions for swapping different generations of ICU code point tries are here
// so that their implementation files need not depend on swapper code,
// need not depend on each other, and so that other swapper code
// need not depend on other trie code.

namespace {

constexpr int32_t ASCII_LIMIT = 0x80;

}  // namespace

U_CAPI int32_t U_EXPORT2
utrie_swap(const UDataSwapper *ds,
           const void *inData, int32_t length, void *outData,
           UErrorCode *pErrorCode) {
    const UTrieHeader *inTrie;
    UTrieHeader trie;
    int32_t size;
    UBool dataIs32;

    if(pErrorCode==nullptr || U_FAILURE(*pErrorCode)) {
        return 0;
    }
    if(ds==nullptr || inData==nullptr || (length>=0 && outData==nullptr)) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }

    /* setup and swapping */
    if(length>=0 && (uint32_t)length<sizeof(UTrieHeader)) {
        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
        return 0;
    }

    inTrie=(const UTrieHeader *)inData;
    trie.signature=ds->readUInt32(inTrie->signature);
    trie.options=ds->readUInt32(inTrie->options);
    trie.indexLength=udata_readInt32(ds, inTrie->indexLength);
    trie.dataLength=udata_readInt32(ds, inTrie->dataLength);

    if( trie.signature!=0x54726965 ||
        (trie.options&UTRIE_OPTIONS_SHIFT_MASK)!=UTRIE_SHIFT ||
        ((trie.options>>UTRIE_OPTIONS_INDEX_SHIFT)&UTRIE_OPTIONS_SHIFT_MASK)!=UTRIE_INDEX_SHIFT ||
        trie.indexLength<UTRIE_BMP_INDEX_LENGTH ||
        (trie.indexLength&(UTRIE_SURROGATE_BLOCK_COUNT-1))!=0 ||
        trie.dataLength<UTRIE_DATA_BLOCK_LENGTH ||
        (trie.dataLength&(UTRIE_DATA_GRANULARITY-1))!=0 ||
        ((trie.options&UTRIE_OPTIONS_LATIN1_IS_LINEAR)!=0 && trie.dataLength<(UTRIE_DATA_BLOCK_LENGTH+0x100))
    ) {
        *pErrorCode=U_INVALID_FORMAT_ERROR; /* not a UTrie */
        return 0;
    }

    dataIs32 = (trie.options & UTRIE_OPTIONS_DATA_IS_32_BIT) != 0;
    size=sizeof(UTrieHeader)+trie.indexLength*2+trie.dataLength*(dataIs32?4:2);

    if(length>=0) {
        UTrieHeader *outTrie;

        if(length<size) {
            *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
            return 0;
        }

        outTrie=(UTrieHeader *)outData;

        /* swap the header */
        ds->swapArray32(ds, inTrie, sizeof(UTrieHeader), outTrie, pErrorCode);

        /* swap the index and the data */
        if(dataIs32) {
            ds->swapArray16(ds, inTrie+1, trie.indexLength*2, outTrie+1, pErrorCode);
            ds->swapArray32(ds, (const uint16_t *)(inTrie+1)+trie.indexLength, trie.dataLength*4,
                                     (uint16_t *)(outTrie+1)+trie.indexLength, pErrorCode);
        } else {
            ds->swapArray16(ds, inTrie+1, (trie.indexLength+trie.dataLength)*2, outTrie+1, pErrorCode);
        }
    }

    return size;
}

U_CAPI int32_t U_EXPORT2
utrie2_swap(const UDataSwapper *ds,
            const void *inData, int32_t length, void *outData,
            UErrorCode *pErrorCode) {
    const UTrie2Header *inTrie;
    UTrie2Header trie;
    int32_t dataLength, size;
    UTrie2ValueBits valueBits;

    if(U_FAILURE(*pErrorCode)) {
        return 0;
    }
    if(ds==nullptr || inData==nullptr || (length>=0 && outData==nullptr)) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }

    /* setup and swapping */
    if(length>=0 && length<(int32_t)sizeof(UTrie2Header)) {
        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
        return 0;
    }

    inTrie=(const UTrie2Header *)inData;
    trie.signature=ds->readUInt32(inTrie->signature);
    trie.options=ds->readUInt16(inTrie->options);
    trie.indexLength=ds->readUInt16(inTrie->indexLength);
    trie.shiftedDataLength=ds->readUInt16(inTrie->shiftedDataLength);

    valueBits=(UTrie2ValueBits)(trie.options&UTRIE2_OPTIONS_VALUE_BITS_MASK);
    dataLength=(int32_t)trie.shiftedDataLength<<UTRIE2_INDEX_SHIFT;

    if( trie.signature!=UTRIE2_SIG ||
        valueBits<0 || UTRIE2_COUNT_VALUE_BITS<=valueBits ||
        trie.indexLength<UTRIE2_INDEX_1_OFFSET ||
        dataLength<UTRIE2_DATA_START_OFFSET
    ) {
        *pErrorCode=U_INVALID_FORMAT_ERROR; /* not a UTrie */
        return 0;
    }

    size=sizeof(UTrie2Header)+trie.indexLength*2;
    switch(valueBits) {
    case UTRIE2_16_VALUE_BITS:
        size+=dataLength*2;
        break;
    case UTRIE2_32_VALUE_BITS:
        size+=dataLength*4;
        break;
    default:
        *pErrorCode=U_INVALID_FORMAT_ERROR;
        return 0;
    }

    if(length>=0) {
        UTrie2Header *outTrie;

        if(length<size) {
            *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
            return 0;
        }

        outTrie=(UTrie2Header *)outData;

        /* swap the header */
        ds->swapArray32(ds, &inTrie->signature, 4, &outTrie->signature, pErrorCode);
        ds->swapArray16(ds, &inTrie->options, 12, &outTrie->options, pErrorCode);

        /* swap the index and the data */
        switch(valueBits) {
        case UTRIE2_16_VALUE_BITS:
            ds->swapArray16(ds, inTrie+1, (trie.indexLength+dataLength)*2, outTrie+1, pErrorCode);
            break;
        case UTRIE2_32_VALUE_BITS:
            ds->swapArray16(ds, inTrie+1, trie.indexLength*2, outTrie+1, pErrorCode);
            ds->swapArray32(ds, (const uint16_t *)(inTrie+1)+trie.indexLength, dataLength*4,
                                     (uint16_t *)(outTrie+1)+trie.indexLength, pErrorCode);
            break;
        default:
            *pErrorCode=U_INVALID_FORMAT_ERROR;
            return 0;
        }
    }

    return size;
}

U_CAPI int32_t U_EXPORT2
ucptrie_swap(const UDataSwapper *ds,
             const void *inData, int32_t length, void *outData,
             UErrorCode *pErrorCode) {
    const UCPTrieHeader *inTrie;
    UCPTrieHeader trie;
    int32_t dataLength, size;
    UCPTrieValueWidth valueWidth;

    if(U_FAILURE(*pErrorCode)) {
        return 0;
    }
    if(ds==nullptr || inData==nullptr || (length>=0 && outData==nullptr)) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return 0;
    }

    /* setup and swapping */
    if(length>=0 && length<(int32_t)sizeof(UCPTrieHeader)) {
        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
        return 0;
    }

    inTrie=(const UCPTrieHeader *)inData;
    trie.signature=ds->readUInt32(inTrie->signature);
    trie.options=ds->readUInt16(inTrie->options);
    trie.indexLength=ds->readUInt16(inTrie->indexLength);
    trie.dataLength = ds->readUInt16(inTrie->dataLength);

    UCPTrieType type = (UCPTrieType)((trie.options >> 6) & 3);
    valueWidth = (UCPTrieValueWidth)(trie.options & UCPTRIE_OPTIONS_VALUE_BITS_MASK);
    dataLength = ((int32_t)(trie.options & UCPTRIE_OPTIONS_DATA_LENGTH_MASK) << 4) | trie.dataLength;

    int32_t minIndexLength = type == UCPTRIE_TYPE_FAST ?
        UCPTRIE_BMP_INDEX_LENGTH : UCPTRIE_SMALL_INDEX_LENGTH;
    if( trie.signature!=UCPTRIE_SIG ||
        type > UCPTRIE_TYPE_SMALL ||
        (trie.options & UCPTRIE_OPTIONS_RESERVED_MASK) != 0 ||
        valueWidth > UCPTRIE_VALUE_BITS_8 ||
        trie.indexLength < minIndexLength ||
        dataLength < ASCII_LIMIT
    ) {
        *pErrorCode=U_INVALID_FORMAT_ERROR; /* not a UCPTrie */
        return 0;
    }

    size=sizeof(UCPTrieHeader)+trie.indexLength*2;
    switch(valueWidth) {
    case UCPTRIE_VALUE_BITS_16:
        size+=dataLength*2;
        break;
    case UCPTRIE_VALUE_BITS_32:
        size+=dataLength*4;
        break;
    case UCPTRIE_VALUE_BITS_8:
        size+=dataLength;
        break;
    default:
        *pErrorCode=U_INVALID_FORMAT_ERROR;
        return 0;
    }

    if(length>=0) {
        UCPTrieHeader *outTrie;

        if(length<size) {
            *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;
            return 0;
        }

        outTrie=(UCPTrieHeader *)outData;

        /* swap the header */
        ds->swapArray32(ds, &inTrie->signature, 4, &outTrie->signature, pErrorCode);
        ds->swapArray16(ds, &inTrie->options, 12, &outTrie->options, pErrorCode);

        /* swap the index */
        const uint16_t *inIndex=reinterpret_cast<const uint16_t *>(inTrie+1);
        uint16_t *outIndex=reinterpret_cast<uint16_t *>(outTrie+1);
        ds->swapArray16(ds, inIndex, trie.indexLength*2, outIndex, pErrorCode);

        /* swap the data */
        const uint16_t *inData=inIndex+trie.indexLength;
        uint16_t *outData=outIndex+trie.indexLength;
        switch(valueWidth) {
        case UCPTRIE_VALUE_BITS_16:
            ds->swapArray16(ds, inData, dataLength*2, outData, pErrorCode);
            break;
        case UCPTRIE_VALUE_BITS_32:
            ds->swapArray32(ds, inData, dataLength*4, outData, pErrorCode);
            break;
        case UCPTRIE_VALUE_BITS_8:
            if(inTrie!=outTrie) {
                uprv_memmove(outData, inData, dataLength);
            }
            break;
        default:
            *pErrorCode=U_INVALID_FORMAT_ERROR;
            return 0;
        }
    }

    return size;
}

namespace {

/**
 * Gets the trie version from 32-bit-aligned memory containing the serialized form
 * of a UTrie (version 1), a UTrie2 (version 2), or a UCPTrie (version 3).
 *
 * @param data a pointer to 32-bit-aligned memory containing the serialized form of a trie
 * @param length the number of bytes available at data;
 *               can be more than necessary (see return value)
 * @param anyEndianOk If false, only platform-endian serialized forms are recognized.
 *                    If true, opposite-endian serialized forms are recognized as well.
 * @return the trie version of the serialized form, or 0 if it is not
 *         recognized as a serialized trie
 */
int32_t
getVersion(const void *data, int32_t length, UBool anyEndianOk) {
    uint32_t signature;
    if(length<16 || data==nullptr || (U_POINTER_MASK_LSB(data, 3)!=0)) {
        return 0;
    }
    signature = *static_cast<const uint32_t*>(data);
    if(signature==UCPTRIE_SIG) {
        return 3;
    }
    if(anyEndianOk && signature==UCPTRIE_OE_SIG) {
        return 3;
    }
    if(signature==UTRIE2_SIG) {
        return 2;
    }
    if(anyEndianOk && signature==UTRIE2_OE_SIG) {
        return 2;
    }
    if(signature==UTRIE_SIG) {
        return 1;
    }
    if(anyEndianOk && signature==UTRIE_OE_SIG) {
        return 1;
    }
    return 0;
}

}  // namespace

U_CAPI int32_t U_EXPORT2
utrie_swapAnyVersion(const UDataSwapper *ds,
                     const void *inData, int32_t length, void *outData,
                     UErrorCode *pErrorCode) {
    if(U_FAILURE(*pErrorCode)) { return 0; }
    switch(getVersion(inData, length, true)) {
    case 1:
        return utrie_swap(ds, inData, length, outData, pErrorCode);
    case 2:
        return utrie2_swap(ds, inData, length, outData, pErrorCode);
    case 3:
        return ucptrie_swap(ds, inData, length, outData, pErrorCode);
    default:
        *pErrorCode=U_INVALID_FORMAT_ERROR;
        return 0;
    }
}
                            node-23.7.0/deps/icu-small/source/common/uts46.cpp                                                  0000664 0000000 0000000 00000160541 14746647661 0021666 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
*******************************************************************************
*   Copyright (C) 2010-2015, International Business Machines
*   Corporation and others.  All Rights Reserved.
*******************************************************************************
*   file name:  uts46.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2010mar09
*   created by: Markus W. Scherer
*/

#include "unicode/utypes.h"

#if !UCONFIG_NO_IDNA

#include "unicode/bytestream.h"
#include "unicode/idna.h"
#include "unicode/normalizer2.h"
#include "unicode/uscript.h"
#include "unicode/ustring.h"
#include "unicode/utf16.h"
#include "bytesinkutil.h"
#include "cmemory.h"
#include "cstring.h"
#include "punycode.h"
#include "ubidi_props.h"

// Note about tests for UIDNA_ERROR_DOMAIN_NAME_TOO_LONG:
//
// The domain name length limit is 255 octets in an internal DNS representation
// where the last ("root") label is the empty label
// represented by length byte 0 alone.
// In a conventional string, this translates to 253 characters, or 254
// if there is a trailing dot for the root label.

U_NAMESPACE_BEGIN

// Severe errors which usually result in a U+FFFD replacement character in the result string.
const uint32_t severeErrors=
    UIDNA_ERROR_LEADING_COMBINING_MARK|
    UIDNA_ERROR_DISALLOWED|
    UIDNA_ERROR_PUNYCODE|
    UIDNA_ERROR_LABEL_HAS_DOT|
    UIDNA_ERROR_INVALID_ACE_LABEL;

static inline UBool
isASCIIString(const UnicodeString &dest) {
    const char16_t *s=dest.getBuffer();
    const char16_t *limit=s+dest.length();
    while(s<limit) {
        if(*s++>0x7f) {
            return false;
        }
    }
    return true;
}

static UBool
isASCIIOkBiDi(const char16_t *s, int32_t length);

static UBool
isASCIIOkBiDi(const char *s, int32_t length);

// IDNA class default implementations -------------------------------------- ***

IDNA::~IDNA() {}

void
IDNA::labelToASCII_UTF8(StringPiece label, ByteSink &dest,
                        IDNAInfo &info, UErrorCode &errorCode) const {
    if(U_SUCCESS(errorCode)) {
        UnicodeString destString;
        labelToASCII(UnicodeString::fromUTF8(label), destString,
                     info, errorCode).toUTF8(dest);
    }
}

void
IDNA::labelToUnicodeUTF8(StringPiece label, ByteSink &dest,
                         IDNAInfo &info, UErrorCode &errorCode) const {
    if(U_SUCCESS(errorCode)) {
        UnicodeString destString;
        labelToUnicode(UnicodeString::fromUTF8(label), destString,
                       info, errorCode).toUTF8(dest);
    }
}

void
IDNA::nameToASCII_UTF8(StringPiece name, ByteSink &dest,
                       IDNAInfo &info, UErrorCode &errorCode) const {
    if(U_SUCCESS(errorCode)) {
        UnicodeString destString;
        nameToASCII(UnicodeString::fromUTF8(name), destString,
                    info, errorCode).toUTF8(dest);
    }
}

void
IDNA::nameToUnicodeUTF8(StringPiece name, ByteSink &dest,
                        IDNAInfo &info, UErrorCode &errorCode) const {
    if(U_SUCCESS(errorCode)) {
        UnicodeString destString;
        nameToUnicode(UnicodeString::fromUTF8(name), destString,
                      info, errorCode).toUTF8(dest);
    }
}

// UTS46 class declaration ------------------------------------------------- ***

class UTS46 : public IDNA {
public:
    UTS46(uint32_t options, UErrorCode &errorCode);
    virtual ~UTS46();

    virtual UnicodeString &
    labelToASCII(const UnicodeString &label, UnicodeString &dest,
                 IDNAInfo &info, UErrorCode &errorCode) const override;

    virtual UnicodeString &
    labelToUnicode(const UnicodeString &label, UnicodeString &dest,
                   IDNAInfo &info, UErrorCode &errorCode) const override;

    virtual UnicodeString &
    nameToASCII(const UnicodeString &name, UnicodeString &dest,
                IDNAInfo &info, UErrorCode &errorCode) const override;

    virtual UnicodeString &
    nameToUnicode(const UnicodeString &name, UnicodeString &dest,
                  IDNAInfo &info, UErrorCode &errorCode) const override;

    virtual void
    labelToASCII_UTF8(StringPiece label, ByteSink &dest,
                      IDNAInfo &info, UErrorCode &errorCode) const override;

    virtual void
    labelToUnicodeUTF8(StringPiece label, ByteSink &dest,
                       IDNAInfo &info, UErrorCode &errorCode) const override;

    virtual void
    nameToASCII_UTF8(StringPiece name, ByteSink &dest,
                     IDNAInfo &info, UErrorCode &errorCode) const override;

    virtual void
    nameToUnicodeUTF8(StringPiece name, ByteSink &dest,
                      IDNAInfo &info, UErrorCode &errorCode) const override;

private:
    UnicodeString &
    process(const UnicodeString &src,
            UBool isLabel, UBool toASCII,
            UnicodeString &dest,
            IDNAInfo &info, UErrorCode &errorCode) const;

    void
    processUTF8(StringPiece src,
                UBool isLabel, UBool toASCII,
                ByteSink &dest,
                IDNAInfo &info, UErrorCode &errorCode) const;

    UnicodeString &
    processUnicode(const UnicodeString &src,
                   int32_t labelStart, int32_t mappingStart,
                   UBool isLabel, UBool toASCII,
                   UnicodeString &dest,
                   IDNAInfo &info, UErrorCode &errorCode) const;

    // returns the new dest.length()
    int32_t
    mapDevChars(UnicodeString &dest, int32_t labelStart, int32_t mappingStart,
                UErrorCode &errorCode) const;

    // returns the new label length
    int32_t
    processLabel(UnicodeString &dest,
                 int32_t labelStart, int32_t labelLength,
                 UBool toASCII,
                 IDNAInfo &info, UErrorCode &errorCode) const;
    int32_t
    markBadACELabel(UnicodeString &dest,
                    int32_t labelStart, int32_t labelLength,
                    UBool toASCII, IDNAInfo &info, UErrorCode &errorCode) const;

    void
    checkLabelBiDi(const char16_t *label, int32_t labelLength, IDNAInfo &info) const;

    UBool
    isLabelOkContextJ(const char16_t *label, int32_t labelLength) const;

    void
    checkLabelContextO(const char16_t *label, int32_t labelLength, IDNAInfo &info) const;

    const Normalizer2 &uts46Norm2;  // uts46.nrm
    uint32_t options;
};

IDNA *
IDNA::createUTS46Instance(uint32_t options, UErrorCode &errorCode) {
    if(U_SUCCESS(errorCode)) {
        IDNA *idna=new UTS46(options, errorCode);
        if(idna==nullptr) {
            errorCode=U_MEMORY_ALLOCATION_ERROR;
        } else if(U_FAILURE(errorCode)) {
            delete idna;
            idna=nullptr;
        }
        return idna;
    } else {
        return nullptr;
    }
}

// UTS46 implementation ---------------------------------------------------- ***

UTS46::UTS46(uint32_t opt, UErrorCode &errorCode)
        : uts46Norm2(*Normalizer2::getInstance(nullptr, "uts46", UNORM2_COMPOSE, errorCode)),
          options(opt) {}

UTS46::~UTS46() {}

UnicodeString &
UTS46::labelToASCII(const UnicodeString &label, UnicodeString &dest,
                    IDNAInfo &info, UErrorCode &errorCode) const {
    return process(label, true, true, dest, info, errorCode);
}

UnicodeString &
UTS46::labelToUnicode(const UnicodeString &label, UnicodeString &dest,
                      IDNAInfo &info, UErrorCode &errorCode) const {
    return process(label, true, false, dest, info, errorCode);
}

UnicodeString &
UTS46::nameToASCII(const UnicodeString &name, UnicodeString &dest,
                   IDNAInfo &info, UErrorCode &errorCode) const {
    process(name, false, true, dest, info, errorCode);
    if( dest.length()>=254 && (info.errors&UIDNA_ERROR_DOMAIN_NAME_TOO_LONG)==0 &&
        isASCIIString(dest) &&
        (dest.length()>254 || dest[253]!=0x2e)
    ) {
        info.errors|=UIDNA_ERROR_DOMAIN_NAME_TOO_LONG;
    }
    return dest;
}

UnicodeString &
UTS46::nameToUnicode(const UnicodeString &name, UnicodeString &dest,
                     IDNAInfo &info, UErrorCode &errorCode) const {
    return process(name, false, false, dest, info, errorCode);
}

void
UTS46::labelToASCII_UTF8(StringPiece label, ByteSink &dest,
                         IDNAInfo &info, UErrorCode &errorCode) const {
    processUTF8(label, true, true, dest, info, errorCode);
}

void
UTS46::labelToUnicodeUTF8(StringPiece label, ByteSink &dest,
                          IDNAInfo &info, UErrorCode &errorCode) const {
    processUTF8(label, true, false, dest, info, errorCode);
}

void
UTS46::nameToASCII_UTF8(StringPiece name, ByteSink &dest,
                        IDNAInfo &info, UErrorCode &errorCode) const {
    processUTF8(name, false, true, dest, info, errorCode);
}

void
UTS46::nameToUnicodeUTF8(StringPiece name, ByteSink &dest,
                         IDNAInfo &info, UErrorCode &errorCode) const {
    processUTF8(name, false, false, dest, info, errorCode);
}

// UTS #46 data for ASCII characters.
// The normalizer (using uts46.nrm) maps uppercase ASCII letters to lowercase
// and passes through all other ASCII characters.
// If UIDNA_USE_STD3_RULES is set, then non-LDH characters are disallowed
// using this data.
// The ASCII fastpath also uses this data.
// Values: -1=disallowed  0==valid  1==mapped (lowercase)
static const int8_t asciiData[128]={
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    // 002D..002E; valid  #  HYPHEN-MINUS..FULL STOP
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0, -1,
    // 0030..0039; valid  #  DIGIT ZERO..DIGIT NINE
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1,
    // 0041..005A; mapped  #  LATIN CAPITAL LETTER A..LATIN CAPITAL LETTER Z
    -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1,
    // 0061..007A; valid  #  LATIN SMALL LETTER A..LATIN SMALL LETTER Z
    -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1
};

UnicodeString &
UTS46::process(const UnicodeString &src,
               UBool isLabel, UBool toASCII,
               UnicodeString &dest,
               IDNAInfo &info, UErrorCode &errorCode) const {
    // uts46Norm2.normalize() would do all of this error checking and setup,
    // but with the ASCII fastpath we do not always call it, and do not
    // call it first.
    if(U_FAILURE(errorCode)) {
        dest.setToBogus();
        return dest;
    }
    const char16_t *srcArray=src.getBuffer();
    if(&dest==&src || srcArray==nullptr) {
        errorCode=U_ILLEGAL_ARGUMENT_ERROR;
        dest.setToBogus();
        return dest;
    }
    // Arguments are fine, reset output values.
    dest.remove();
    info.reset();
    int32_t srcLength=src.length();
    if(srcLength==0) {
        info.errors|=UIDNA_ERROR_EMPTY_LABEL;
        return dest;
    }
    char16_t *destArray=dest.getBuffer(srcLength);
    if(destArray==nullptr) {
        errorCode=U_MEMORY_ALLOCATION_ERROR;
        return dest;
    }
    // ASCII fastpath
    UBool disallowNonLDHDot=(options&UIDNA_USE_STD3_RULES)!=0;
    int32_t labelStart=0;
    int32_t i;
    for(i=0;; ++i) {
        if(i==srcLength) {
            if(toASCII) {
                if((i-labelStart)>63) {
                    info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
                }
                // There is a trailing dot if labelStart==i.
                if(!isLabel && i>=254 && (i>254 || labelStart<i)) {
                    info.errors|=UIDNA_ERROR_DOMAIN_NAME_TOO_LONG;
                }
            }
            info.errors|=info.labelErrors;
            dest.releaseBuffer(i);
            return dest;
        }
        char16_t c=srcArray[i];
        if(c>0x7f) {
            break;
        }
        int cData=asciiData[c];
        if(cData>0) {
            destArray[i]=c+0x20;  // Lowercase an uppercase ASCII letter.
        } else if(cData<0 && disallowNonLDHDot) {
            break;  // Replacing with U+FFFD can be complicated for toASCII.
        } else {
            destArray[i]=c;
            if(c==0x2d) {  // hyphen
                if(i==(labelStart+3) && srcArray[i-1]==0x2d) {
                    // "??--..." is Punycode or forbidden.
                    ++i;  // '-' was copied to dest already
                    break;
                }
                if(i==labelStart) {
                    // label starts with "-"
                    info.labelErrors|=UIDNA_ERROR_LEADING_HYPHEN;
                }
                if((i+1)==srcLength || srcArray[i+1]==0x2e) {
                    // label ends with "-"
                    info.labelErrors|=UIDNA_ERROR_TRAILING_HYPHEN;
                }
            } else if(c==0x2e) {  // dot
                if(isLabel) {
                    // Replacing with U+FFFD can be complicated for toASCII.
                    ++i;  // '.' was copied to dest already
                    break;
                }
                if(i==labelStart) {
                    info.labelErrors|=UIDNA_ERROR_EMPTY_LABEL;
                }
                if(toASCII && (i-labelStart)>63) {
                    info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
                }
                info.errors|=info.labelErrors;
                info.labelErrors=0;
                labelStart=i+1;
            }
        }
    }
    info.errors|=info.labelErrors;
    dest.releaseBuffer(i);
    processUnicode(src, labelStart, i, isLabel, toASCII, dest, info, errorCode);
    if( info.isBiDi && U_SUCCESS(errorCode) && (info.errors&severeErrors)==0 &&
        (!info.isOkBiDi || (labelStart>0 && !isASCIIOkBiDi(dest.getBuffer(), labelStart)))
    ) {
        info.errors|=UIDNA_ERROR_BIDI;
    }
    return dest;
}

void
UTS46::processUTF8(StringPiece src,
                   UBool isLabel, UBool toASCII,
                   ByteSink &dest,
                   IDNAInfo &info, UErrorCode &errorCode) const {
    if(U_FAILURE(errorCode)) {
        return;
    }
    const char *srcArray=src.data();
    int32_t srcLength=src.length();
    if(srcArray==nullptr && srcLength!=0) {
        errorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return;
    }
    // Arguments are fine, reset output values.
    info.reset();
    if(srcLength==0) {
        info.errors|=UIDNA_ERROR_EMPTY_LABEL;
        dest.Flush();
        return;
    }
    UnicodeString destString;
    int32_t labelStart=0;
    if(srcLength<=256) {  // length of stackArray[]
        // ASCII fastpath
        char stackArray[256];
        int32_t destCapacity;
        char *destArray=dest.GetAppendBuffer(srcLength, srcLength+20,
                                             stackArray, UPRV_LENGTHOF(stackArray), &destCapacity);
        UBool disallowNonLDHDot=(options&UIDNA_USE_STD3_RULES)!=0;
        int32_t i;
        for(i=0;; ++i) {
            if(i==srcLength) {
                if(toASCII) {
                    if((i-labelStart)>63) {
                        info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
                    }
                    // There is a trailing dot if labelStart==i.
                    if(!isLabel && i>=254 && (i>254 || labelStart<i)) {
                        info.errors|=UIDNA_ERROR_DOMAIN_NAME_TOO_LONG;
                    }
                }
                info.errors|=info.labelErrors;
                dest.Append(destArray, i);
                dest.Flush();
                return;
            }
            char c=srcArray[i];
            if (static_cast<int8_t>(c) < 0) { // (uint8_t)c>0x7f
                break;
            }
            int cData = asciiData[static_cast<int>(c)]; // Cast: gcc warns about indexing with a char.
            if(cData>0) {
                destArray[i]=c+0x20;  // Lowercase an uppercase ASCII letter.
            } else if(cData<0 && disallowNonLDHDot) {
                break;  // Replacing with U+FFFD can be complicated for toASCII.
            } else {
                destArray[i]=c;
                if(c==0x2d) {  // hyphen
                    if(i==(labelStart+3) && srcArray[i-1]==0x2d) {
                        // "??--..." is Punycode or forbidden.
                        break;
                    }
                    if(i==labelStart) {
                        // label starts with "-"
                        info.labelErrors|=UIDNA_ERROR_LEADING_HYPHEN;
                    }
                    if((i+1)==srcLength || srcArray[i+1]==0x2e) {
                        // label ends with "-"
                        info.labelErrors|=UIDNA_ERROR_TRAILING_HYPHEN;
                    }
                } else if(c==0x2e) {  // dot
                    if(isLabel) {
                        break;  // Replacing with U+FFFD can be complicated for toASCII.
                    }
                    if(i==labelStart) {
                        info.labelErrors|=UIDNA_ERROR_EMPTY_LABEL;
                    }
                    if(toASCII && (i-labelStart)>63) {
                        info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
                    }
                    info.errors|=info.labelErrors;
                    info.labelErrors=0;
                    labelStart=i+1;
                }
            }
        }
        info.errors|=info.labelErrors;
        // Convert the processed ASCII prefix of the current label to UTF-16.
        int32_t mappingStart=i-labelStart;
        destString=UnicodeString::fromUTF8(StringPiece(destArray+labelStart, mappingStart));
        // Output the previous ASCII labels and process the rest of src in UTF-16.
        dest.Append(destArray, labelStart);
        processUnicode(UnicodeString::fromUTF8(StringPiece(src, labelStart)), 0, mappingStart,
                       isLabel, toASCII,
                       destString, info, errorCode);
    } else {
        // src is too long for the ASCII fastpath implementation.
        processUnicode(UnicodeString::fromUTF8(src), 0, 0,
                       isLabel, toASCII,
                       destString, info, errorCode);
    }
    destString.toUTF8(dest);  // calls dest.Flush()
    if(toASCII && !isLabel) {
        // length==labelStart==254 means that there is a trailing dot (ok) and
        // destString is empty (do not index at 253-labelStart).
        int32_t length=labelStart+destString.length();
        if( length>=254 && isASCIIString(destString) &&
            (length>254 ||
             (labelStart<254 && destString[253-labelStart]!=0x2e))
        ) {
            info.errors|=UIDNA_ERROR_DOMAIN_NAME_TOO_LONG;
        }
    }
    if( info.isBiDi && U_SUCCESS(errorCode) && (info.errors&severeErrors)==0 &&
        (!info.isOkBiDi || (labelStart>0 && !isASCIIOkBiDi(srcArray, labelStart)))
    ) {
        info.errors|=UIDNA_ERROR_BIDI;
    }
}

UnicodeString &
UTS46::processUnicode(const UnicodeString &src,
                      int32_t labelStart, int32_t mappingStart,
                      UBool isLabel, UBool toASCII,
                      UnicodeString &dest,
                      IDNAInfo &info, UErrorCode &errorCode) const {
    if(mappingStart==0) {
        uts46Norm2.normalize(src, dest, errorCode);
    } else {
        uts46Norm2.normalizeSecondAndAppend(dest, src.tempSubString(mappingStart), errorCode);
    }
    if(U_FAILURE(errorCode)) {
        return dest;
    }
    UBool doMapDevChars=
        toASCII ? (options&UIDNA_NONTRANSITIONAL_TO_ASCII)==0 :
                  (options&UIDNA_NONTRANSITIONAL_TO_UNICODE)==0;
    const char16_t *destArray=dest.getBuffer();
    int32_t destLength=dest.length();
    int32_t labelLimit=labelStart;
    while(labelLimit<destLength) {
        char16_t c=destArray[labelLimit];
        if(c==0x2e && !isLabel) {
            int32_t labelLength=labelLimit-labelStart;
            int32_t newLength=processLabel(dest, labelStart, labelLength,
                                            toASCII, info, errorCode);
            info.errors|=info.labelErrors;
            info.labelErrors=0;
            if(U_FAILURE(errorCode)) {
                return dest;
            }
            destArray=dest.getBuffer();
            destLength+=newLength-labelLength;
            labelLimit=labelStart+=newLength+1;
            continue;
        } else if(c<0xdf) {
            // pass
        } else if(c<=0x200d && (c==0xdf || c==0x3c2 || c>=0x200c)) {
            info.isTransDiff=true;
            if(doMapDevChars) {
                destLength=mapDevChars(dest, labelStart, labelLimit, errorCode);
                if(U_FAILURE(errorCode)) {
                    return dest;
                }
                destArray=dest.getBuffer();
                // All deviation characters have been mapped, no need to check for them again.
                doMapDevChars=false;
                // Do not increment labelLimit in case c was removed.
                continue;
            }
        } else if(U16_IS_SURROGATE(c)) {
            if(U16_IS_SURROGATE_LEAD(c) ?
                    (labelLimit+1)==destLength || !U16_IS_TRAIL(destArray[labelLimit+1]) :
                    labelLimit==labelStart || !U16_IS_LEAD(destArray[labelLimit-1])) {
                // Map an unpaired surrogate to U+FFFD before normalization so that when
                // that removes characters we do not turn two unpaired ones into a pair.
                info.labelErrors|=UIDNA_ERROR_DISALLOWED;
                dest.setCharAt(labelLimit, 0xfffd);
                destArray=dest.getBuffer();
            }
        }
        ++labelLimit;
    }
    // Permit an empty label at the end (0<labelStart==labelLimit==destLength is ok)
    // but not an empty label elsewhere nor a completely empty domain name.
    // processLabel() sets UIDNA_ERROR_EMPTY_LABEL when labelLength==0.
    if(0==labelStart || labelStart<labelLimit) {
        processLabel(dest, labelStart, labelLimit-labelStart,
                      toASCII, info, errorCode);
        info.errors|=info.labelErrors;
    }
    return dest;
}

int32_t
UTS46::mapDevChars(UnicodeString &dest, int32_t labelStart, int32_t mappingStart,
                   UErrorCode &errorCode) const {
    if(U_FAILURE(errorCode)) {
        return 0;
    }
    int32_t length=dest.length();
    char16_t *s=dest.getBuffer(dest[mappingStart]==0xdf ? length+1 : length);
    if(s==nullptr) {
        errorCode=U_MEMORY_ALLOCATION_ERROR;
        return length;
    }
    int32_t capacity=dest.getCapacity();
    UBool didMapDevChars=false;
    int32_t readIndex=mappingStart, writeIndex=mappingStart;
    do {
        char16_t c=s[readIndex++];
        switch(c) {
        case 0xdf:
            // Map sharp s to ss.
            didMapDevChars=true;
            s[writeIndex++]=0x73;  // Replace sharp s with first s.
            // Insert second s and account for possible buffer reallocation.
            if(writeIndex==readIndex) {
                if(length==capacity) {
                    dest.releaseBuffer(length);
                    s=dest.getBuffer(length+1);
                    if(s==nullptr) {
                        errorCode=U_MEMORY_ALLOCATION_ERROR;
                        return length;
                    }
                    capacity=dest.getCapacity();
                }
                u_memmove(s+writeIndex+1, s+writeIndex, length-writeIndex);
                ++readIndex;
            }
            s[writeIndex++]=0x73;
            ++length;
            break;
        case 0x3c2:  // Map final sigma to nonfinal sigma.
            didMapDevChars=true;
            s[writeIndex++]=0x3c3;
            break;
        case 0x200c:  // Ignore/remove ZWNJ.
        case 0x200d:  // Ignore/remove ZWJ.
            didMapDevChars=true;
            --length;
            break;
        default:
            // Only really necessary if writeIndex was different from readIndex.
            s[writeIndex++]=c;
            break;
        }
    } while(writeIndex<length);
    dest.releaseBuffer(length);
    if(didMapDevChars) {
        // Mapping deviation characters might have resulted in an un-NFC string.
        // We could use either the NFC or the UTS #46 normalizer.
        // By using the UTS #46 normalizer again, we avoid having to load a second .nrm data file.
        UnicodeString normalized;
        uts46Norm2.normalize(dest.tempSubString(labelStart), normalized, errorCode);
        if(U_SUCCESS(errorCode)) {
            dest.replace(labelStart, 0x7fffffff, normalized);
            if(dest.isBogus()) {
                errorCode=U_MEMORY_ALLOCATION_ERROR;
            }
            return dest.length();
        }
    }
    return length;
}

// Replace the label in dest with the label string, if the label was modified.
// If &label==&dest then the label was modified in-place and labelLength
// is the new label length, different from label.length().
// If &label!=&dest then labelLength==label.length().
// Returns labelLength (= the new label length).
static int32_t
replaceLabel(UnicodeString &dest, int32_t destLabelStart, int32_t destLabelLength,
             const UnicodeString &label, int32_t labelLength, UErrorCode &errorCode) {
    if(U_FAILURE(errorCode)) {
        return 0;
    }
    if(&label!=&dest) {
        dest.replace(destLabelStart, destLabelLength, label);
        if(dest.isBogus()) {
            errorCode=U_MEMORY_ALLOCATION_ERROR;
            return 0;
        }
    }
    return labelLength;
}

int32_t
UTS46::processLabel(UnicodeString &dest,
                    int32_t labelStart, int32_t labelLength,
                    UBool toASCII,
                    IDNAInfo &info, UErrorCode &errorCode) const {
    if(U_FAILURE(errorCode)) {
        return 0;
    }
    UnicodeString fromPunycode;
    UnicodeString *labelString;
    const char16_t *label=dest.getBuffer()+labelStart;
    int32_t destLabelStart=labelStart;
    int32_t destLabelLength=labelLength;
    UBool wasPunycode;
    if(labelLength>=4 && label[0]==0x78 && label[1]==0x6e && label[2]==0x2d && label[3]==0x2d) {
        // Label starts with "xn--", try to un-Punycode it.
        // In IDNA2008, labels like "xn--" (decodes to an empty string) and
        // "xn--ASCII-" (decodes to just "ASCII") fail the round-trip validation from
        // comparing the ToUnicode input with the back-to-ToASCII output.
        // They are alternate encodings of the respective ASCII labels.
        // Ignore "xn---" here: It will fail Punycode.decode() which logically comes before
        // the round-trip verification.
        if(labelLength==4 || (labelLength>5 && label[labelLength-1]==u'-')) {
            info.labelErrors|=UIDNA_ERROR_INVALID_ACE_LABEL;
            return markBadACELabel(dest, labelStart, labelLength, toASCII, info, errorCode);
        }
        wasPunycode=true;
        char16_t *unicodeBuffer=fromPunycode.getBuffer(-1);  // capacity==-1: most labels should fit
        if(unicodeBuffer==nullptr) {
            // Should never occur if we used capacity==-1 which uses the internal buffer.
            errorCode=U_MEMORY_ALLOCATION_ERROR;
            return labelLength;
        }
        UErrorCode punycodeErrorCode=U_ZERO_ERROR;
        int32_t unicodeLength=u_strFromPunycode(label+4, labelLength-4,
                                                unicodeBuffer, fromPunycode.getCapacity(),
                                                nullptr, &punycodeErrorCode);
        if(punycodeErrorCode==U_BUFFER_OVERFLOW_ERROR) {
            fromPunycode.releaseBuffer(0);
            unicodeBuffer=fromPunycode.getBuffer(unicodeLength);
            if(unicodeBuffer==nullptr) {
                errorCode=U_MEMORY_ALLOCATION_ERROR;
                return labelLength;
            }
            punycodeErrorCode=U_ZERO_ERROR;
            unicodeLength=u_strFromPunycode(label+4, labelLength-4,
                                            unicodeBuffer, fromPunycode.getCapacity(),
                                            nullptr, &punycodeErrorCode);
        }
        fromPunycode.releaseBuffer(unicodeLength);
        if(U_FAILURE(punycodeErrorCode)) {
            info.labelErrors|=UIDNA_ERROR_PUNYCODE;
            return markBadACELabel(dest, labelStart, labelLength, toASCII, info, errorCode);
        }
        // Check for NFC, and for characters that are not
        // valid or deviation characters according to the normalizer.
        // If there is something wrong, then the string will change.
        // Note that the normalizer passes through non-LDH ASCII and deviation characters.
        // Deviation characters are ok in Punycode even in transitional processing.
        // In the code further below, if we find non-LDH ASCII and we have UIDNA_USE_STD3_RULES
        // then we will set UIDNA_ERROR_INVALID_ACE_LABEL there too.
        UBool isValid=uts46Norm2.isNormalized(fromPunycode, errorCode);
        if(U_FAILURE(errorCode)) {
            return labelLength;
        }
        // Unicode 15.1 UTS #46:
        // Added an additional condition in 4.1 Validity Criteria to
        // disallow labels such as xn--xn---epa., which do not round-trip.
        // --> Validity Criteria new criterion 4:
        // If not CheckHyphens, the label must not begin with “xn--”.
        if(!isValid || fromPunycode.startsWith(UnicodeString::readOnlyAlias(u"xn--"))) {
            info.labelErrors|=UIDNA_ERROR_INVALID_ACE_LABEL;
            return markBadACELabel(dest, labelStart, labelLength, toASCII, info, errorCode);
        }
        labelString=&fromPunycode;
        label=fromPunycode.getBuffer();
        labelStart=0;
        labelLength=fromPunycode.length();
    } else {
        wasPunycode=false;
        labelString=&dest;
    }
    // Validity check
    if(labelLength==0) {
        info.labelErrors|=UIDNA_ERROR_EMPTY_LABEL;
        return replaceLabel(dest, destLabelStart, destLabelLength,
                            *labelString, labelLength, errorCode);
    }
    // labelLength>0
    if(labelLength>=4 && label[2]==0x2d && label[3]==0x2d) {
        // label starts with "??--"
        info.labelErrors|=UIDNA_ERROR_HYPHEN_3_4;
    }
    if(label[0]==0x2d) {
        // label starts with "-"
        info.labelErrors|=UIDNA_ERROR_LEADING_HYPHEN;
    }
    if(label[labelLength-1]==0x2d) {
        // label ends with "-"
        info.labelErrors|=UIDNA_ERROR_TRAILING_HYPHEN;
    }
    // If the label was not a Punycode label, then it was the result of
    // mapping, normalization and label segmentation.
    // If the label was in Punycode, then we mapped it again above
    // and checked its validity.
    // Now we handle the STD3 restriction to LDH characters (if set)
    // and we look for U+FFFD which indicates disallowed characters
    // in a non-Punycode label or U+FFFD itself in a Punycode label.
    // We also check for dots which can come from the input to a single-label function.
    // Ok to cast away const because we own the UnicodeString.
    char16_t* s = const_cast<char16_t*>(label);
    const char16_t *limit=label+labelLength;
    char16_t oredChars=0;
    // If we enforce STD3 rules, then ASCII characters other than LDH and dot are disallowed.
    UBool disallowNonLDHDot=(options&UIDNA_USE_STD3_RULES)!=0;
    do {
        char16_t c=*s;
        if(c<=0x7f) {
            if(c==0x2e) {
                info.labelErrors|=UIDNA_ERROR_LABEL_HAS_DOT;
                *s=0xfffd;
            } else if(disallowNonLDHDot && asciiData[c]<0) {
                info.labelErrors|=UIDNA_ERROR_DISALLOWED;
                *s=0xfffd;
            }
        } else {
            oredChars|=c;
            if(c==0xfffd) {
                info.labelErrors|=UIDNA_ERROR_DISALLOWED;
            }
        }
        ++s;
    } while(s<limit);
    // Check for a leading combining mark after other validity checks
    // so that we don't report UIDNA_ERROR_DISALLOWED for the U+FFFD from here.
    UChar32 c;
    int32_t cpLength=0;
    // "Unsafe" is ok because unpaired surrogates were mapped to U+FFFD.
    U16_NEXT_UNSAFE(label, cpLength, c);
    if((U_GET_GC_MASK(c)&U_GC_M_MASK)!=0) {
        info.labelErrors|=UIDNA_ERROR_LEADING_COMBINING_MARK;
        labelString->replace(labelStart, cpLength, static_cast<char16_t>(0xfffd));
        label=labelString->getBuffer()+labelStart;
        labelLength+=1-cpLength;
        if(labelString==&dest) {
            destLabelLength=labelLength;
        }
    }
    if((info.labelErrors&severeErrors)==0) {
        // Do contextual checks only if we do not have U+FFFD from a severe error
        // because U+FFFD can make these checks fail.
        if((options&UIDNA_CHECK_BIDI)!=0 && (!info.isBiDi || info.isOkBiDi)) {
            checkLabelBiDi(label, labelLength, info);
        }
        if( (options&UIDNA_CHECK_CONTEXTJ)!=0 && (oredChars&0x200c)==0x200c &&
            !isLabelOkContextJ(label, labelLength)
        ) {
            info.labelErrors|=UIDNA_ERROR_CONTEXTJ;
        }
        if((options&UIDNA_CHECK_CONTEXTO)!=0 && oredChars>=0xb7) {
            checkLabelContextO(label, labelLength, info);
        }
        if(toASCII) {
            if(wasPunycode) {
                // Leave a Punycode label unchanged if it has no severe errors.
                if(destLabelLength>63) {
                    info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
                }
                return destLabelLength;
            } else if(oredChars>=0x80) {
                // Contains non-ASCII characters.
                UnicodeString punycode;
                char16_t *buffer=punycode.getBuffer(63);  // 63==maximum DNS label length
                if(buffer==nullptr) {
                    errorCode=U_MEMORY_ALLOCATION_ERROR;
                    return destLabelLength;
                }
                buffer[0]=0x78;  // Write "xn--".
                buffer[1]=0x6e;
                buffer[2]=0x2d;
                buffer[3]=0x2d;
                int32_t punycodeLength=u_strToPunycode(label, labelLength,
                                                      buffer+4, punycode.getCapacity()-4,
                                                      nullptr, &errorCode);
                if(errorCode==U_BUFFER_OVERFLOW_ERROR) {
                    errorCode=U_ZERO_ERROR;
                    punycode.releaseBuffer(4);
                    buffer=punycode.getBuffer(4+punycodeLength);
                    if(buffer==nullptr) {
                        errorCode=U_MEMORY_ALLOCATION_ERROR;
                        return destLabelLength;
                    }
                    punycodeLength=u_strToPunycode(label, labelLength,
                                                  buffer+4, punycode.getCapacity()-4,
                                                  nullptr, &errorCode);
                }
                punycodeLength+=4;
                punycode.releaseBuffer(punycodeLength);
                if(U_FAILURE(errorCode)) {
                    return destLabelLength;
                }
                if(punycodeLength>63) {
                    info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
                }
                return replaceLabel(dest, destLabelStart, destLabelLength,
                                    punycode, punycodeLength, errorCode);
            } else {
                // all-ASCII label
                if(labelLength>63) {
                    info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
                }
            }
        }
    } else {
        // If a Punycode label has severe errors,
        // then leave it but make sure it does not look valid.
        if(wasPunycode) {
            info.labelErrors|=UIDNA_ERROR_INVALID_ACE_LABEL;
            return markBadACELabel(dest, destLabelStart, destLabelLength, toASCII, info, errorCode);
        }
    }
    return replaceLabel(dest, destLabelStart, destLabelLength,
                        *labelString, labelLength, errorCode);
}

// Make sure an ACE label does not look valid.
// Append U+FFFD if the label has only LDH characters.
// If UIDNA_USE_STD3_RULES, also replace disallowed ASCII characters with U+FFFD.
int32_t
UTS46::markBadACELabel(UnicodeString &dest,
                       int32_t labelStart, int32_t labelLength,
                       UBool toASCII, IDNAInfo &info, UErrorCode &errorCode) const {
    if(U_FAILURE(errorCode)) {
        return 0;
    }
    UBool disallowNonLDHDot=(options&UIDNA_USE_STD3_RULES)!=0;
    UBool isASCII=true;
    UBool onlyLDH=true;
    const char16_t *label=dest.getBuffer()+labelStart;
    const char16_t *limit=label+labelLength;
    // Start after the initial "xn--".
    // Ok to cast away const because we own the UnicodeString.
    for(char16_t *s=const_cast<char16_t *>(label+4); s<limit; ++s) {
        char16_t c=*s;
        if(c<=0x7f) {
            if(c==0x2e) {
                info.labelErrors|=UIDNA_ERROR_LABEL_HAS_DOT;
                *s=0xfffd;
                isASCII=onlyLDH=false;
            } else if(asciiData[c]<0) {
                onlyLDH=false;
                if(disallowNonLDHDot) {
                    *s=0xfffd;
                    isASCII=false;
                }
            }
        } else {
            isASCII=onlyLDH=false;
        }
    }
    if(onlyLDH) {
        dest.insert(labelStart + labelLength, static_cast<char16_t>(0xfffd));
        if(dest.isBogus()) {
            errorCode=U_MEMORY_ALLOCATION_ERROR;
            return 0;
        }
        ++labelLength;
    } else {
        if(toASCII && isASCII && labelLength>63) {
            info.labelErrors|=UIDNA_ERROR_LABEL_TOO_LONG;
        }
    }
    return labelLength;
}

const uint32_t L_MASK=U_MASK(U_LEFT_TO_RIGHT);
const uint32_t R_AL_MASK=U_MASK(U_RIGHT_TO_LEFT)|U_MASK(U_RIGHT_TO_LEFT_ARABIC);
const uint32_t L_R_AL_MASK=L_MASK|R_AL_MASK;

const uint32_t R_AL_AN_MASK=R_AL_MASK|U_MASK(U_ARABIC_NUMBER);

const uint32_t EN_AN_MASK=U_MASK(U_EUROPEAN_NUMBER)|U_MASK(U_ARABIC_NUMBER);
const uint32_t R_AL_EN_AN_MASK=R_AL_MASK|EN_AN_MASK;
const uint32_t L_EN_MASK=L_MASK|U_MASK(U_EUROPEAN_NUMBER);

const uint32_t ES_CS_ET_ON_BN_NSM_MASK=
    U_MASK(U_EUROPEAN_NUMBER_SEPARATOR)|
    U_MASK(U_COMMON_NUMBER_SEPARATOR)|
    U_MASK(U_EUROPEAN_NUMBER_TERMINATOR)|
    U_MASK(U_OTHER_NEUTRAL)|
    U_MASK(U_BOUNDARY_NEUTRAL)|
    U_MASK(U_DIR_NON_SPACING_MARK);
const uint32_t L_EN_ES_CS_ET_ON_BN_NSM_MASK=L_EN_MASK|ES_CS_ET_ON_BN_NSM_MASK;
const uint32_t R_AL_AN_EN_ES_CS_ET_ON_BN_NSM_MASK=R_AL_MASK|EN_AN_MASK|ES_CS_ET_ON_BN_NSM_MASK;

// We scan the whole label and check both for whether it contains RTL characters
// and whether it passes the BiDi Rule.
// In a BiDi domain name, all labels must pass the BiDi Rule, but we might find
// that a domain name is a BiDi domain name (has an RTL label) only after
// processing several earlier labels.
void
UTS46::checkLabelBiDi(const char16_t *label, int32_t labelLength, IDNAInfo &info) const {
    // IDNA2008 BiDi rule
    // Get the directionality of the first character.
    UChar32 c;
    int32_t i=0;
    U16_NEXT_UNSAFE(label, i, c);
    uint32_t firstMask=U_MASK(u_charDirection(c));
    // 1. The first character must be a character with BIDI property L, R
    // or AL.  If it has the R or AL property, it is an RTL label; if it
    // has the L property, it is an LTR label.
    if((firstMask&~L_R_AL_MASK)!=0) {
        info.isOkBiDi=false;
    }
    // Get the directionality of the last non-NSM character.
    uint32_t lastMask;
    for(;;) {
        if(i>=labelLength) {
            lastMask=firstMask;
            break;
        }
        U16_PREV_UNSAFE(label, labelLength, c);
        UCharDirection dir=u_charDirection(c);
        if(dir!=U_DIR_NON_SPACING_MARK) {
            lastMask=U_MASK(dir);
            break;
        }
    }
    // 3. In an RTL label, the end of the label must be a character with
    // BIDI property R, AL, EN or AN, followed by zero or more
    // characters with BIDI property NSM.
    // 6. In an LTR label, the end of the label must be a character with
    // BIDI property L or EN, followed by zero or more characters with
    // BIDI property NSM.
    if( (firstMask&L_MASK)!=0 ?
            (lastMask&~L_EN_MASK)!=0 :
            (lastMask&~R_AL_EN_AN_MASK)!=0
    ) {
        info.isOkBiDi=false;
    }
    // Add the directionalities of the intervening characters.
    uint32_t mask=firstMask|lastMask;
    while(i<labelLength) {
        U16_NEXT_UNSAFE(label, i, c);
        mask|=U_MASK(u_charDirection(c));
    }
    if(firstMask&L_MASK) {
        // 5. In an LTR label, only characters with the BIDI properties L, EN,
        // ES, CS, ET, ON, BN and NSM are allowed.
        if((mask&~L_EN_ES_CS_ET_ON_BN_NSM_MASK)!=0) {
            info.isOkBiDi=false;
        }
    } else {
        // 2. In an RTL label, only characters with the BIDI properties R, AL,
        // AN, EN, ES, CS, ET, ON, BN and NSM are allowed.
        if((mask&~R_AL_AN_EN_ES_CS_ET_ON_BN_NSM_MASK)!=0) {
            info.isOkBiDi=false;
        }
        // 4. In an RTL label, if an EN is present, no AN may be present, and
        // vice versa.
        if((mask&EN_AN_MASK)==EN_AN_MASK) {
            info.isOkBiDi=false;
        }
    }
    // An RTL label is a label that contains at least one character of type
    // R, AL or AN. [...]
    // A "BIDI domain name" is a domain name that contains at least one RTL
    // label. [...]
    // The following rule, consisting of six conditions, applies to labels
    // in BIDI domain names.
    if((mask&R_AL_AN_MASK)!=0) {
        info.isBiDi=true;
    }
}

// Special code for the ASCII prefix of a BiDi domain name.
// The ASCII prefix is all-LTR.

// IDNA2008 BiDi rule, parts relevant to ASCII labels:
// 1. The first character must be a character with BIDI property L [...]
// 5. In an LTR label, only characters with the BIDI properties L, EN,
// ES, CS, ET, ON, BN and NSM are allowed.
// 6. In an LTR label, the end of the label must be a character with
// BIDI property L or EN [...]

// UTF-16 version, called for mapped ASCII prefix.
// Cannot contain uppercase A-Z.
// s[length-1] must be the trailing dot.
static UBool
isASCIIOkBiDi(const char16_t *s, int32_t length) {
    int32_t labelStart=0;
    for(int32_t i=0; i<length; ++i) {
        char16_t c=s[i];
        if(c==0x2e) {  // dot
            if(i>labelStart) {
                c=s[i-1];
                if(!(0x61<=c && c<=0x7a) && !(0x30<=c && c<=0x39)) {
                    // Last character in the label is not an L or EN.
                    return false;
                }
            }
            labelStart=i+1;
        } else if(i==labelStart) {
            if(!(0x61<=c && c<=0x7a)) {
                // First character in the label is not an L.
                return false;
            }
        } else {
            if(c<=0x20 && (c>=0x1c || (9<=c && c<=0xd))) {
                // Intermediate character in the label is a B, S or WS.
                return false;
            }
        }
    }
    return true;
}

// UTF-8 version, called for source ASCII prefix.
// Can contain uppercase A-Z.
// s[length-1] must be the trailing dot.
static UBool
isASCIIOkBiDi(const char *s, int32_t length) {
    int32_t labelStart=0;
    for(int32_t i=0; i<length; ++i) {
        char c=s[i];
        if(c==0x2e) {  // dot
            if(i>labelStart) {
                c=s[i-1];
                if(!(0x61<=c && c<=0x7a) && !(0x41<=c && c<=0x5a) && !(0x30<=c && c<=0x39)) {
                    // Last character in the label is not an L or EN.
                    return false;
                }
            }
            labelStart=i+1;
        } else if(i==labelStart) {
            if(!(0x61<=c && c<=0x7a) && !(0x41<=c && c<=0x5a)) {
                // First character in the label is not an L.
                return false;
            }
        } else {
            if(c<=0x20 && (c>=0x1c || (9<=c && c<=0xd))) {
                // Intermediate character in the label is a B, S or WS.
                return false;
            }
        }
    }
    return true;
}

UBool
UTS46::isLabelOkContextJ(const char16_t *label, int32_t labelLength) const {
    // [IDNA2008-Tables]
    // 200C..200D  ; CONTEXTJ    # ZERO WIDTH NON-JOINER..ZERO WIDTH JOINER
    for(int32_t i=0; i<labelLength; ++i) {
        if(label[i]==0x200c) {
            // Appendix A.1. ZERO WIDTH NON-JOINER
            // Rule Set:
            //  False;
            //  If Canonical_Combining_Class(Before(cp)) .eq.  Virama Then True;
            //  If RegExpMatch((Joining_Type:{L,D})(Joining_Type:T)*\u200C
            //     (Joining_Type:T)*(Joining_Type:{R,D})) Then True;
            if(i==0) {
                return false;
            }
            UChar32 c;
            int32_t j=i;
            U16_PREV_UNSAFE(label, j, c);
            if(uts46Norm2.getCombiningClass(c)==9) {
                continue;
            }
            // check precontext (Joining_Type:{L,D})(Joining_Type:T)*
            for(;;) {
                UJoiningType type=ubidi_getJoiningType(c);
                if(type==U_JT_TRANSPARENT) {
                    if(j==0) {
                        return false;
                    }
                    U16_PREV_UNSAFE(label, j, c);
                } else if(type==U_JT_LEFT_JOINING || type==U_JT_DUAL_JOINING) {
                    break;  // precontext fulfilled
                } else {
                    return false;
                }
            }
            // check postcontext (Joining_Type:T)*(Joining_Type:{R,D})
            for(j=i+1;;) {
                if(j==labelLength) {
                    return false;
                }
                U16_NEXT_UNSAFE(label, j, c);
                UJoiningType type=ubidi_getJoiningType(c);
                if(type==U_JT_TRANSPARENT) {
                    // just skip this character
                } else if(type==U_JT_RIGHT_JOINING || type==U_JT_DUAL_JOINING) {
                    break;  // postcontext fulfilled
                } else {
                    return false;
                }
            }
        } else if(label[i]==0x200d) {
            // Appendix A.2. ZERO WIDTH JOINER (U+200D)
            // Rule Set:
            //  False;
            //  If Canonical_Combining_Class(Before(cp)) .eq.  Virama Then True;
            if(i==0) {
                return false;
            }
            UChar32 c;
            int32_t j=i;
            U16_PREV_UNSAFE(label, j, c);
            if(uts46Norm2.getCombiningClass(c)!=9) {
                return false;
            }
        }
    }
    return true;
}

void
UTS46::checkLabelContextO(const char16_t *label, int32_t labelLength, IDNAInfo &info) const {
    int32_t labelEnd=labelLength-1;  // inclusive
    int32_t arabicDigits=0;  // -1 for 066x, +1 for 06Fx
    for(int32_t i=0; i<=labelEnd; ++i) {
        UChar32 c=label[i];
        if(c<0xb7) {
            // ASCII fastpath
        } else if(c<=0x6f9) {
            if(c==0xb7) {
                // Appendix A.3. MIDDLE DOT (U+00B7)
                // Rule Set:
                //  False;
                //  If Before(cp) .eq.  U+006C And
                //     After(cp) .eq.  U+006C Then True;
                if(!(0<i && label[i-1]==0x6c &&
                     i<labelEnd && label[i+1]==0x6c)) {
                    info.labelErrors|=UIDNA_ERROR_CONTEXTO_PUNCTUATION;
                }
            } else if(c==0x375) {
                // Appendix A.4. GREEK LOWER NUMERAL SIGN (KERAIA) (U+0375)
                // Rule Set:
                //  False;
                //  If Script(After(cp)) .eq.  Greek Then True;
                UScriptCode script=USCRIPT_INVALID_CODE;
                if(i<labelEnd) {
                    UErrorCode errorCode=U_ZERO_ERROR;
                    int32_t j=i+1;
                    U16_NEXT(label, j, labelLength, c);
                    script=uscript_getScript(c, &errorCode);
                }
                if(script!=USCRIPT_GREEK) {
                    info.labelErrors|=UIDNA_ERROR_CONTEXTO_PUNCTUATION;
                }
            } else if(c==0x5f3 || c==0x5f4) {
                // Appendix A.5. HEBREW PUNCTUATION GERESH (U+05F3)
                // Rule Set:
                //  False;
                //  If Script(Before(cp)) .eq.  Hebrew Then True;
                //
                // Appendix A.6. HEBREW PUNCTUATION GERSHAYIM (U+05F4)
                // Rule Set:
                //  False;
                //  If Script(Before(cp)) .eq.  Hebrew Then True;
                UScriptCode script=USCRIPT_INVALID_CODE;
                if(0<i) {
                    UErrorCode errorCode=U_ZERO_ERROR;
                    int32_t j=i;
                    U16_PREV(label, 0, j, c);
                    script=uscript_getScript(c, &errorCode);
                }
                if(script!=USCRIPT_HEBREW) {
                    info.labelErrors|=UIDNA_ERROR_CONTEXTO_PUNCTUATION;
                }
            } else if(0x660<=c /* && c<=0x6f9 */) {
                // Appendix A.8. ARABIC-INDIC DIGITS (0660..0669)
                // Rule Set:
                //  True;
                //  For All Characters:
                //    If cp .in. 06F0..06F9 Then False;
                //  End For;
                //
                // Appendix A.9. EXTENDED ARABIC-INDIC DIGITS (06F0..06F9)
                // Rule Set:
                //  True;
                //  For All Characters:
                //    If cp .in. 0660..0669 Then False;
                //  End For;
                if(c<=0x669) {
                    if(arabicDigits>0) {
                        info.labelErrors|=UIDNA_ERROR_CONTEXTO_DIGITS;
                    }
                    arabicDigits=-1;
                } else if(0x6f0<=c) {
                    if(arabicDigits<0) {
                        info.labelErrors|=UIDNA_ERROR_CONTEXTO_DIGITS;
                    }
                    arabicDigits=1;
                }
            }
        } else if(c==0x30fb) {
            // Appendix A.7. KATAKANA MIDDLE DOT (U+30FB)
            // Rule Set:
            //  False;
            //  For All Characters:
            //    If Script(cp) .in. {Hiragana, Katakana, Han} Then True;
            //  End For;
            UErrorCode errorCode=U_ZERO_ERROR;
            for(int j=0;;) {
                if(j>labelEnd) {
                    info.labelErrors|=UIDNA_ERROR_CONTEXTO_PUNCTUATION;
                    break;
                }
                U16_NEXT(label, j, labelLength, c);
                UScriptCode script=uscript_getScript(c, &errorCode);
                if(script==USCRIPT_HIRAGANA || script==USCRIPT_KATAKANA || script==USCRIPT_HAN) {
                    break;
                }
            }
        }
    }
}

U_NAMESPACE_END

// C API ------------------------------------------------------------------- ***

U_NAMESPACE_USE

U_CAPI UIDNA * U_EXPORT2
uidna_openUTS46(uint32_t options, UErrorCode *pErrorCode) {
    return reinterpret_cast<UIDNA *>(IDNA::createUTS46Instance(options, *pErrorCode));
}

U_CAPI void U_EXPORT2
uidna_close(UIDNA *idna) {
    delete reinterpret_cast<IDNA *>(idna);
}

static UBool
checkArgs(const void *label, int32_t length,
          void *dest, int32_t capacity,
          UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
    if(U_FAILURE(*pErrorCode)) {
        return false;
    }
    // sizeof(UIDNAInfo)=16 in the first API version.
    if(pInfo==nullptr || pInfo->size<16) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return false;
    }
    if( (label==nullptr ? length!=0 : length<-1) ||
        (dest==nullptr ? capacity!=0 : capacity<0) ||
        (dest==label && label!=nullptr)
    ) {
        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;
        return false;
    }
    // Set all *pInfo bytes to 0 except for the size field itself.
    uprv_memset(&pInfo->size+1, 0, pInfo->size-sizeof(pInfo->size));
    return true;
}

static void
idnaInfoToStruct(IDNAInfo &info, UIDNAInfo *pInfo) {
    pInfo->isTransitionalDifferent=info.isTransitionalDifferent();
    pInfo->errors=info.getErrors();
}

U_CAPI int32_t U_EXPORT2
uidna_labelToASCII(const UIDNA *idna,
                   const char16_t *label, int32_t length,
                   char16_t *dest, int32_t capacity,
                   UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
    if(!checkArgs(label, length, dest, capacity, pInfo, pErrorCode)) {
        return 0;
    }
    UnicodeString src(length < 0, label, length);
    UnicodeString destString(dest, 0, capacity);
    IDNAInfo info;
    reinterpret_cast<const IDNA *>(idna)->labelToASCII(src, destString, info, *pErrorCode);
    idnaInfoToStruct(info, pInfo);
    return destString.extract(dest, capacity, *pErrorCode);
}

U_CAPI int32_t U_EXPORT2
uidna_labelToUnicode(const UIDNA *idna,
                     const char16_t *label, int32_t length,
                     char16_t *dest, int32_t capacity,
                     UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
    if(!checkArgs(label, length, dest, capacity, pInfo, pErrorCode)) {
        return 0;
    }
    UnicodeString src(length < 0, label, length);
    UnicodeString destString(dest, 0, capacity);
    IDNAInfo info;
    reinterpret_cast<const IDNA *>(idna)->labelToUnicode(src, destString, info, *pErrorCode);
    idnaInfoToStruct(info, pInfo);
    return destString.extract(dest, capacity, *pErrorCode);
}

U_CAPI int32_t U_EXPORT2
uidna_nameToASCII(const UIDNA *idna,
                  const char16_t *name, int32_t length,
                  char16_t *dest, int32_t capacity,
                  UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
    if(!checkArgs(name, length, dest, capacity, pInfo, pErrorCode)) {
        return 0;
    }
    UnicodeString src(length < 0, name, length);
    UnicodeString destString(dest, 0, capacity);
    IDNAInfo info;
    reinterpret_cast<const IDNA *>(idna)->nameToASCII(src, destString, info, *pErrorCode);
    idnaInfoToStruct(info, pInfo);
    return destString.extract(dest, capacity, *pErrorCode);
}

U_CAPI int32_t U_EXPORT2
uidna_nameToUnicode(const UIDNA *idna,
                    const char16_t *name, int32_t length,
                    char16_t *dest, int32_t capacity,
                    UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
    if(!checkArgs(name, length, dest, capacity, pInfo, pErrorCode)) {
        return 0;
    }
    UnicodeString src(length < 0, name, length);
    UnicodeString destString(dest, 0, capacity);
    IDNAInfo info;
    reinterpret_cast<const IDNA *>(idna)->nameToUnicode(src, destString, info, *pErrorCode);
    idnaInfoToStruct(info, pInfo);
    return destString.extract(dest, capacity, *pErrorCode);
}

U_CAPI int32_t U_EXPORT2
uidna_labelToASCII_UTF8(const UIDNA *idna,
                        const char *label, int32_t length,
                        char *dest, int32_t capacity,
                        UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
    if(!checkArgs(label, length, dest, capacity, pInfo, pErrorCode)) {
        return 0;
    }
    StringPiece src(label, length<0 ? static_cast<int32_t>(uprv_strlen(label)) : length);
    return ByteSinkUtil::viaByteSinkToTerminatedChars(
        dest, capacity,
        [&](ByteSink& sink, UErrorCode& status) {
            IDNAInfo info;
            reinterpret_cast<const IDNA *>(idna)->labelToASCII_UTF8(src, sink, info, status);
            idnaInfoToStruct(info, pInfo);
        },
        *pErrorCode);
}

U_CAPI int32_t U_EXPORT2
uidna_labelToUnicodeUTF8(const UIDNA *idna,
                         const char *label, int32_t length,
                         char *dest, int32_t capacity,
                         UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
    if(!checkArgs(label, length, dest, capacity, pInfo, pErrorCode)) {
        return 0;
    }
    StringPiece src(label, length<0 ? static_cast<int32_t>(uprv_strlen(label)) : length);
    return ByteSinkUtil::viaByteSinkToTerminatedChars(
        dest, capacity,
        [&](ByteSink& sink, UErrorCode& status) {
            IDNAInfo info;
            reinterpret_cast<const IDNA *>(idna)->labelToUnicodeUTF8(src, sink, info, status);
            idnaInfoToStruct(info, pInfo);
        },
        *pErrorCode);
}

U_CAPI int32_t U_EXPORT2
uidna_nameToASCII_UTF8(const UIDNA *idna,
                       const char *name, int32_t length,
                       char *dest, int32_t capacity,
                       UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
    if(!checkArgs(name, length, dest, capacity, pInfo, pErrorCode)) {
        return 0;
    }
    StringPiece src(name, length<0 ? static_cast<int32_t>(uprv_strlen(name)) : length);
    return ByteSinkUtil::viaByteSinkToTerminatedChars(
        dest, capacity,
        [&](ByteSink& sink, UErrorCode& status) {
            IDNAInfo info;
            reinterpret_cast<const IDNA *>(idna)->nameToASCII_UTF8(src, sink, info, status);
            idnaInfoToStruct(info, pInfo);
        },
        *pErrorCode);
}

U_CAPI int32_t U_EXPORT2
uidna_nameToUnicodeUTF8(const UIDNA *idna,
                        const char *name, int32_t length,
                        char *dest, int32_t capacity,
                        UIDNAInfo *pInfo, UErrorCode *pErrorCode) {
    if(!checkArgs(name, length, dest, capacity, pInfo, pErrorCode)) {
        return 0;
    }
    StringPiece src(name, length<0 ? static_cast<int32_t>(uprv_strlen(name)) : length);
    return ByteSinkUtil::viaByteSinkToTerminatedChars(
        dest, capacity,
        [&](ByteSink& sink, UErrorCode& status) {
            IDNAInfo info;
            reinterpret_cast<const IDNA *>(idna)->nameToUnicodeUTF8(src, sink, info, status);
            idnaInfoToStruct(info, pInfo);
        },
        *pErrorCode);
}

#endif  // UCONFIG_NO_IDNA
                                                                                                                                                               node-23.7.0/deps/icu-small/source/common/utypeinfo.h                                                0000664 0000000 0000000 00000002315 14746647661 0022362 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 2012-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*/

#ifndef __UTYPEINFO_H__
#define __UTYPEINFO_H__

// Windows header <typeinfo> does not define 'exception' in 'std' namespace.
// Therefore, a project using ICU cannot be compiled with _HAS_EXCEPTIONS
// set to 0 on Windows with Visual Studio. To work around that, we have to
// include <exception> explicitly and add using statement below.
// Whenever 'typeid' is used, this header has to be included
// instead of <typeinfo>.
// Visual Studio 10 emits warning 4275 with this change. If you compile
// with exception disabled, you have to suppress warning 4275.
#if defined(_MSC_VER) && _HAS_EXCEPTIONS == 0
#include <exception>
using std::exception;
#endif
#if defined(__GLIBCXX__)
namespace std { class type_info; } // WORKAROUND: http://llvm.org/bugs/show_bug.cgi?id=13364
#endif
#include <typeinfo>  // for 'typeid' to work

#endif
                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/icu-small/source/common/utypes.cpp                                                 0000664 0000000 0000000 00000016730 14746647661 0022232 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
*
*   Copyright (C) 1997-2015, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
******************************************************************************
*
*  FILE NAME : utypes.c (previously putil.c)
*
*   Date        Name        Description
*   10/07/2004  grhoten     split from putil.c
******************************************************************************
*/

#include "unicode/utypes.h"

/* u_errorName() ------------------------------------------------------------ */

static const char * const
_uErrorInfoName[U_ERROR_WARNING_LIMIT-U_ERROR_WARNING_START]={
    "U_USING_FALLBACK_WARNING",
    "U_USING_DEFAULT_WARNING",
    "U_SAFECLONE_ALLOCATED_WARNING",
    "U_STATE_OLD_WARNING",
    "U_STRING_NOT_TERMINATED_WARNING",
    "U_SORT_KEY_TOO_SHORT_WARNING",
    "U_AMBIGUOUS_ALIAS_WARNING",
    "U_DIFFERENT_UCA_VERSION",
    "U_PLUGIN_CHANGED_LEVEL_WARNING",
};

static const char * const
_uTransErrorName[U_PARSE_ERROR_LIMIT - U_PARSE_ERROR_START]={
    "U_BAD_VARIABLE_DEFINITION",
    "U_MALFORMED_RULE",
    "U_MALFORMED_SET",
    "U_MALFORMED_SYMBOL_REFERENCE",
    "U_MALFORMED_UNICODE_ESCAPE",
    "U_MALFORMED_VARIABLE_DEFINITION",
    "U_MALFORMED_VARIABLE_REFERENCE",
    "U_MISMATCHED_SEGMENT_DELIMITERS",
    "U_MISPLACED_ANCHOR_START",
    "U_MISPLACED_CURSOR_OFFSET",
    "U_MISPLACED_QUANTIFIER",
    "U_MISSING_OPERATOR",
    "U_MISSING_SEGMENT_CLOSE",
    "U_MULTIPLE_ANTE_CONTEXTS",
    "U_MULTIPLE_CURSORS",
    "U_MULTIPLE_POST_CONTEXTS",
    "U_TRAILING_BACKSLASH",
    "U_UNDEFINED_SEGMENT_REFERENCE",
    "U_UNDEFINED_VARIABLE",
    "U_UNQUOTED_SPECIAL",
    "U_UNTERMINATED_QUOTE",
    "U_RULE_MASK_ERROR",
    "U_MISPLACED_COMPOUND_FILTER",
    "U_MULTIPLE_COMPOUND_FILTERS",
    "U_INVALID_RBT_SYNTAX",
    "U_INVALID_PROPERTY_PATTERN",
    "U_MALFORMED_PRAGMA",
    "U_UNCLOSED_SEGMENT",
    "U_ILLEGAL_CHAR_IN_SEGMENT",
    "U_VARIABLE_RANGE_EXHAUSTED",
    "U_VARIABLE_RANGE_OVERLAP",
    "U_ILLEGAL_CHARACTER",
    "U_INTERNAL_TRANSLITERATOR_ERROR",
    "U_INVALID_ID",
    "U_INVALID_FUNCTION"
};

static const char * const
_uErrorName[U_STANDARD_ERROR_LIMIT]={
    "U_ZERO_ERROR",

    "U_ILLEGAL_ARGUMENT_ERROR",
    "U_MISSING_RESOURCE_ERROR",
    "U_INVALID_FORMAT_ERROR",
    "U_FILE_ACCESS_ERROR",
    "U_INTERNAL_PROGRAM_ERROR",
    "U_MESSAGE_PARSE_ERROR",
    "U_MEMORY_ALLOCATION_ERROR",
    "U_INDEX_OUTOFBOUNDS_ERROR",
    "U_PARSE_ERROR",
    "U_INVALID_CHAR_FOUND",
    "U_TRUNCATED_CHAR_FOUND",
    "U_ILLEGAL_CHAR_FOUND",
    "U_INVALID_TABLE_FORMAT",
    "U_INVALID_TABLE_FILE",
    "U_BUFFER_OVERFLOW_ERROR",
    "U_UNSUPPORTED_ERROR",
    "U_RESOURCE_TYPE_MISMATCH",
    "U_ILLEGAL_ESCAPE_SEQUENCE",
    "U_UNSUPPORTED_ESCAPE_SEQUENCE",
    "U_NO_SPACE_AVAILABLE",
    "U_CE_NOT_FOUND_ERROR",
    "U_PRIMARY_TOO_LONG_ERROR",
    "U_STATE_TOO_OLD_ERROR",
    "U_TOO_MANY_ALIASES_ERROR",
    "U_ENUM_OUT_OF_SYNC_ERROR",
    "U_INVARIANT_CONVERSION_ERROR",
    "U_INVALID_STATE_ERROR",
    "U_COLLATOR_VERSION_MISMATCH",
    "U_USELESS_COLLATOR_ERROR",
    "U_NO_WRITE_PERMISSION",
    "U_INPUT_TOO_LONG_ERROR"
};
static const char * const
_uFmtErrorName[U_FMT_PARSE_ERROR_LIMIT - U_FMT_PARSE_ERROR_START] = {
    "U_UNEXPECTED_TOKEN",
    "U_MULTIPLE_DECIMAL_SEPARATORS",
    "U_MULTIPLE_EXPONENTIAL_SYMBOLS",
    "U_MALFORMED_EXPONENTIAL_PATTERN",
    "U_MULTIPLE_PERCENT_SYMBOLS",
    "U_MULTIPLE_PERMILL_SYMBOLS",
    "U_MULTIPLE_PAD_SPECIFIERS",
    "U_PATTERN_SYNTAX_ERROR",
    "U_ILLEGAL_PAD_POSITION",
    "U_UNMATCHED_BRACES",
    "U_UNSUPPORTED_PROPERTY",
    "U_UNSUPPORTED_ATTRIBUTE",
    "U_ARGUMENT_TYPE_MISMATCH",
    "U_DUPLICATE_KEYWORD",
    "U_UNDEFINED_KEYWORD",
    "U_DEFAULT_KEYWORD_MISSING",
    "U_DECIMAL_NUMBER_SYNTAX_ERROR",
    "U_FORMAT_INEXACT_ERROR",
    "U_NUMBER_ARG_OUTOFBOUNDS_ERROR",
    "U_NUMBER_SKELETON_SYNTAX_ERROR",
    "U_MF_UNRESOLVED_VARIABLE_ERROR",
    "U_MF_SYNTAX_ERROR",
    "U_MF_UNKNOWN_FUNCTION_ERROR",
    "U_MF_VARIANT_KEY_MISMATCH_ERROR",
    "U_MF_FORMATTING_ERROR",
    "U_MF_NONEXHAUSTIVE_PATTERN_ERROR",
    "U_MF_DUPLICATE_OPTION_NAME_ERROR",
    "U_MF_SELECTOR_ERROR",
    "U_MF_MISSING_SELECTOR_ANNOTATION_ERROR",
    "U_MF_DUPLICATE_DECLARATION_ERROR",
    "U_MF_OPERAND_MISMATCH_ERROR",
    "U_MF_DUPLICATE_VARIANT_ERROR"
};

static const char * const
_uBrkErrorName[U_BRK_ERROR_LIMIT - U_BRK_ERROR_START] = {
    "U_BRK_INTERNAL_ERROR",
    "U_BRK_HEX_DIGITS_EXPECTED",
    "U_BRK_SEMICOLON_EXPECTED",
    "U_BRK_RULE_SYNTAX",
    "U_BRK_UNCLOSED_SET",
    "U_BRK_ASSIGN_ERROR",
    "U_BRK_VARIABLE_REDFINITION",
    "U_BRK_MISMATCHED_PAREN",
    "U_BRK_NEW_LINE_IN_QUOTED_STRING",
    "U_BRK_UNDEFINED_VARIABLE",
    "U_BRK_INIT_ERROR",
    "U_BRK_RULE_EMPTY_SET",
    "U_BRK_UNRECOGNIZED_OPTION",
    "U_BRK_MALFORMED_RULE_TAG"
};

static const char * const
_uRegexErrorName[U_REGEX_ERROR_LIMIT - U_REGEX_ERROR_START] = {
    "U_REGEX_INTERNAL_ERROR",
    "U_REGEX_RULE_SYNTAX",
    "U_REGEX_INVALID_STATE",
    "U_REGEX_BAD_ESCAPE_SEQUENCE",
    "U_REGEX_PROPERTY_SYNTAX",
    "U_REGEX_UNIMPLEMENTED",
    "U_REGEX_MISMATCHED_PAREN",
    "U_REGEX_NUMBER_TOO_BIG",
    "U_REGEX_BAD_INTERVAL",
    "U_REGEX_MAX_LT_MIN",
    "U_REGEX_INVALID_BACK_REF",
    "U_REGEX_INVALID_FLAG",
    "U_REGEX_LOOK_BEHIND_LIMIT",
    "U_REGEX_SET_CONTAINS_STRING",
    "U_REGEX_OCTAL_TOO_BIG",
    "U_REGEX_MISSING_CLOSE_BRACKET",
    "U_REGEX_INVALID_RANGE",
    "U_REGEX_STACK_OVERFLOW",
    "U_REGEX_TIME_OUT",
    "U_REGEX_STOPPED_BY_CALLER",
    "U_REGEX_PATTERN_TOO_BIG",
    "U_REGEX_INVALID_CAPTURE_GROUP_NAME"
};

static const char * const
_uIDNAErrorName[U_IDNA_ERROR_LIMIT - U_IDNA_ERROR_START] = {
     "U_STRINGPREP_PROHIBITED_ERROR",
     "U_STRINGPREP_UNASSIGNED_ERROR",
     "U_STRINGPREP_CHECK_BIDI_ERROR",
     "U_IDNA_STD3_ASCII_RULES_ERROR",
     "U_IDNA_ACE_PREFIX_ERROR",
     "U_IDNA_VERIFICATION_ERROR",
     "U_IDNA_LABEL_TOO_LONG_ERROR",
     "U_IDNA_ZERO_LENGTH_LABEL_ERROR",
     "U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR"
};

static const char * const
_uPluginErrorName[U_PLUGIN_ERROR_LIMIT - U_PLUGIN_ERROR_START] = {
     "U_PLUGIN_TOO_HIGH",
     "U_PLUGIN_DIDNT_SET_LEVEL",
};

U_CAPI const char * U_EXPORT2
u_errorName(UErrorCode code) {
    if(U_ZERO_ERROR <= code && code < U_STANDARD_ERROR_LIMIT) {
        return _uErrorName[code];
    } else if(U_ERROR_WARNING_START <= code && code < U_ERROR_WARNING_LIMIT) {
        return _uErrorInfoName[code - U_ERROR_WARNING_START];
    } else if(U_PARSE_ERROR_START <= code && code < U_PARSE_ERROR_LIMIT){
        return _uTransErrorName[code - U_PARSE_ERROR_START];
    } else if(U_FMT_PARSE_ERROR_START <= code && code < U_FMT_PARSE_ERROR_LIMIT){
        return _uFmtErrorName[code - U_FMT_PARSE_ERROR_START];
    } else if (U_BRK_ERROR_START <= code  && code < U_BRK_ERROR_LIMIT){
        return _uBrkErrorName[code - U_BRK_ERROR_START];
    } else if (U_REGEX_ERROR_START <= code && code < U_REGEX_ERROR_LIMIT) {
        return _uRegexErrorName[code - U_REGEX_ERROR_START];
    } else if(U_IDNA_ERROR_START <= code && code < U_IDNA_ERROR_LIMIT) {
        return _uIDNAErrorName[code - U_IDNA_ERROR_START];
    } else if(U_PLUGIN_ERROR_START <= code && code < U_PLUGIN_ERROR_LIMIT) {
        return _uPluginErrorName[code - U_PLUGIN_ERROR_START];
    } else {
        return "[BOGUS UErrorCode]";
    }
}

/*
 * Hey, Emacs, please set the following:
 *
 * Local Variables:
 * indent-tabs-mode: nil
 * End:
 *
 */
                                        node-23.7.0/deps/icu-small/source/common/uvector.cpp                                                0000664 0000000 0000000 00000041451 14746647661 0022366 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
* Copyright (C) 1999-2013, International Business Machines Corporation and
* others. All Rights Reserved.
******************************************************************************
*   Date        Name        Description
*   10/22/99    alan        Creation.
**********************************************************************
*/

#include "uvector.h"
#include "cmemory.h"
#include "uarrsort.h"
#include "uelement.h"

U_NAMESPACE_BEGIN

constexpr int32_t DEFAULT_CAPACITY = 8;

/*
 * Constants for hinting whether a key is an integer
 * or a pointer.  If a hint bit is zero, then the associated
 * token is assumed to be an integer. This is needed for iSeries
 */
constexpr int8_t HINT_KEY_POINTER = 1;
constexpr int8_t HINT_KEY_INTEGER = 0;
 
UOBJECT_DEFINE_RTTI_IMPLEMENTATION(UVector)

UVector::UVector(UErrorCode &status) :
        UVector(nullptr, nullptr, DEFAULT_CAPACITY, status) {
}

UVector::UVector(int32_t initialCapacity, UErrorCode &status) :
        UVector(nullptr, nullptr, initialCapacity, status) {
}

UVector::UVector(UObjectDeleter *d, UElementsAreEqual *c, UErrorCode &status) :
        UVector(d, c, DEFAULT_CAPACITY, status) {
}

UVector::UVector(UObjectDeleter *d, UElementsAreEqual *c, int32_t initialCapacity, UErrorCode &status) :
    deleter(d),
    comparer(c)
{
    if (U_FAILURE(status)) {
        return;
    }
    // Fix bogus initialCapacity values; avoid malloc(0) and integer overflow
    if ((initialCapacity < 1) || (initialCapacity > static_cast<int32_t>(INT32_MAX / sizeof(UElement)))) {
        initialCapacity = DEFAULT_CAPACITY;
    }
    elements = static_cast<UElement*>(uprv_malloc(sizeof(UElement) * initialCapacity));
    if (elements == nullptr) {
        status = U_MEMORY_ALLOCATION_ERROR;
    } else {
        capacity = initialCapacity;
    }
}

UVector::~UVector() {
    removeAllElements();
    uprv_free(elements);
    elements = nullptr;
}

/**
 * Assign this object to another (make this a copy of 'other').
 * Use the 'assign' function to assign each element.
 */
void UVector::assign(const UVector& other, UElementAssigner *assign, UErrorCode &ec) {
    if (ensureCapacity(other.count, ec)) {
        setSize(other.count, ec);
        if (U_SUCCESS(ec)) {
            for (int32_t i=0; i<other.count; ++i) {
                if (elements[i].pointer != nullptr && deleter != nullptr) {
                    (*deleter)(elements[i].pointer);
                }
                (*assign)(&elements[i], &other.elements[i]);
            }
        }
    }
}

// This only does something sensible if this object has a non-null comparer
bool UVector::operator==(const UVector& other) const {
    U_ASSERT(comparer != nullptr);
    if (count != other.count) return false;
    if (comparer != nullptr) {
        // Compare using this object's comparer
        for (int32_t i=0; i<count; ++i) {
            if (!(*comparer)(elements[i], other.elements[i])) {
                return false;
            }
        }
    }
    return true;
}

void UVector::addElement(void* obj, UErrorCode &status) {
    U_ASSERT(deleter == nullptr);
    if (ensureCapacity(count + 1, status)) {
        elements[count++].pointer = obj;
    }
}

void UVector::adoptElement(void* obj, UErrorCode &status) {
    U_ASSERT(deleter != nullptr);
    if (ensureCapacity(count + 1, status)) {
        elements[count++].pointer = obj;
    } else {
        (*deleter)(obj);
    }
}
void UVector::addElement(int32_t elem, UErrorCode &status) {
    U_ASSERT(deleter == nullptr);  // Usage error. Mixing up ints and pointers.
    if (ensureCapacity(count + 1, status)) {
        elements[count].pointer = nullptr;     // Pointers may be bigger than ints.
        elements[count].integer = elem;
        count++;
    }
}

void UVector::setElementAt(void* obj, int32_t index) {
    if (0 <= index && index < count) {
        if (elements[index].pointer != nullptr && deleter != nullptr) {
            (*deleter)(elements[index].pointer);
        }
        elements[index].pointer = obj;
    } else {
        /* index out of range */
        if (deleter != nullptr) {
            (*deleter)(obj);
        }
    }
}

void UVector::setElementAt(int32_t elem, int32_t index) {
    U_ASSERT(deleter == nullptr);  // Usage error. Mixing up ints and pointers.
    if (0 <= index && index < count) {
        elements[index].pointer = nullptr;
        elements[index].integer = elem;
    }
    /* else index out of range */
}

void UVector::insertElementAt(void* obj, int32_t index, UErrorCode &status) {
    if (ensureCapacity(count + 1, status)) {
        if (0 <= index && index <= count) {
            for (int32_t i=count; i>index; --i) {
                elements[i] = elements[i-1];
            }
            elements[index].pointer = obj;
            ++count;
        } else {
            /* index out of range */
            status = U_ILLEGAL_ARGUMENT_ERROR;
        }
    }
    if (U_FAILURE(status) && deleter != nullptr) {
        (*deleter)(obj);
    }
}

void UVector::insertElementAt(int32_t elem, int32_t index, UErrorCode &status) {
    U_ASSERT(deleter == nullptr);  // Usage error. Mixing up ints and pointers.
    // must have 0 <= index <= count
    if (ensureCapacity(count + 1, status)) {
        if (0 <= index && index <= count) {
            for (int32_t i=count; i>index; --i) {
                elements[i] = elements[i-1];
            }
            elements[index].pointer = nullptr;
            elements[index].integer = elem;
            ++count;
        } else {
            /* index out of range */
            status = U_ILLEGAL_ARGUMENT_ERROR;
        }
    }
}

void* UVector::elementAt(int32_t index) const {
    return (0 <= index && index < count) ? elements[index].pointer : nullptr;
}

int32_t UVector::elementAti(int32_t index) const {
    return (0 <= index && index < count) ? elements[index].integer : 0;
}

UBool UVector::containsAll(const UVector& other) const {
    for (int32_t i=0; i<other.size(); ++i) {
        if (indexOf(other.elements[i]) < 0) {
            return false;
        }
    }
    return true;
}

UBool UVector::containsNone(const UVector& other) const {
    for (int32_t i=0; i<other.size(); ++i) {
        if (indexOf(other.elements[i]) >= 0) {
            return false;
        }
    }
    return true;
}

UBool UVector::removeAll(const UVector& other) {
    UBool changed = false;
    for (int32_t i=0; i<other.size(); ++i) {
        int32_t j = indexOf(other.elements[i]);
        if (j >= 0) {
            removeElementAt(j);
            changed = true;
        }
    }
    return changed;
}

UBool UVector::retainAll(const UVector& other) {
    UBool changed = false;
    for (int32_t j=size()-1; j>=0; --j) {
        int32_t i = other.indexOf(elements[j]);
        if (i < 0) {
            removeElementAt(j);
            changed = true;
        }
    }
    return changed;
}

void UVector::removeElementAt(int32_t index) {
    void* e = orphanElementAt(index);
    if (e != nullptr && deleter != nullptr) {
        (*deleter)(e);
    }
}

UBool UVector::removeElement(void* obj) {
    int32_t i = indexOf(obj);
    if (i >= 0) {
        removeElementAt(i);
        return true;
    }
    return false;
}

void UVector::removeAllElements() {
    if (deleter != nullptr) {
        for (int32_t i=0; i<count; ++i) {
            if (elements[i].pointer != nullptr) {
                (*deleter)(elements[i].pointer);
            }
        }
    }
    count = 0;
}

UBool   UVector::equals(const UVector &other) const {
    int      i;

    if (this->count != other.count) {
        return false;
    }
    if (comparer == nullptr) {
        for (i=0; i<count; i++) {
            if (elements[i].pointer != other.elements[i].pointer) {
                return false;
            }
        }
    } else {
        UElement key;
        for (i=0; i<count; i++) {
            key.pointer = &other.elements[i];
            if (!(*comparer)(key, elements[i])) {
                return false;
            }
        }
    }
    return true;
}



int32_t UVector::indexOf(void* obj, int32_t startIndex) const {
    UElement key;
    key.pointer = obj;
    return indexOf(key, startIndex, HINT_KEY_POINTER);
}

int32_t UVector::indexOf(int32_t obj, int32_t startIndex) const {
    UElement key;
    key.integer = obj;
    return indexOf(key, startIndex, HINT_KEY_INTEGER);
}

int32_t UVector::indexOf(UElement key, int32_t startIndex, int8_t hint) const {
    if (comparer != nullptr) {
        for (int32_t i=startIndex; i<count; ++i) {
            if ((*comparer)(key, elements[i])) {
                return i;
            }
        }
    } else {
        for (int32_t i=startIndex; i<count; ++i) {
            /* Pointers are not always the same size as ints so to perform
             * a valid comparison we need to know whether we are being
             * provided an int or a pointer. */
            if (hint & HINT_KEY_POINTER) {
                if (key.pointer == elements[i].pointer) {
                    return i;
                }
            } else {
                if (key.integer == elements[i].integer) {
                    return i;
                }
            }
        }
    }
    return -1;
}

UBool UVector::ensureCapacity(int32_t minimumCapacity, UErrorCode &status) {
    if (U_FAILURE(status)) {
        return false;
    }
    if (minimumCapacity < 0) {
        status = U_ILLEGAL_ARGUMENT_ERROR;
        return false;
    }
    if (capacity < minimumCapacity) {
        if (capacity > (INT32_MAX - 1) / 2) {        	// integer overflow check
            status = U_ILLEGAL_ARGUMENT_ERROR;
            return false;
        }
        int32_t newCap = capacity * 2;
        if (newCap < minimumCapacity) {
            newCap = minimumCapacity;
        }
        if (newCap > static_cast<int32_t>(INT32_MAX / sizeof(UElement))) { // integer overflow check
            // We keep the original memory contents on bad minimumCapacity.
            status = U_ILLEGAL_ARGUMENT_ERROR;
            return false;
        }
        UElement* newElems = static_cast<UElement*>(uprv_realloc(elements, sizeof(UElement) * newCap));
        if (newElems == nullptr) {
            // We keep the original contents on the memory failure on realloc or bad minimumCapacity.
            status = U_MEMORY_ALLOCATION_ERROR;
            return false;
        }
        elements = newElems;
        capacity = newCap;
    }
    return true;
}

/**
 * Change the size of this vector as follows: If newSize is smaller,
 * then truncate the array, possibly deleting held elements for i >=
 * newSize.  If newSize is larger, grow the array, filling in new
 * slots with nullptr.
 */
void UVector::setSize(int32_t newSize, UErrorCode &status) {
    if (!ensureCapacity(newSize, status)) {
        return;
    }
    if (newSize > count) {
        UElement empty;
        empty.pointer = nullptr;
        empty.integer = 0;
        for (int32_t i=count; i<newSize; ++i) {
            elements[i] = empty;
        }
    } else {
        /* Most efficient to count down */
        for (int32_t i=count-1; i>=newSize; --i) {
            removeElementAt(i);
        }
    }
    count = newSize;
}

/**
 * Fill in the given array with all elements of this vector.
 */
void** UVector::toArray(void** result) const {
    void** a = result;
    for (int i=0; i<count; ++i) {
        *a++ = elements[i].pointer;
    }
    return result;
}

UObjectDeleter *UVector::setDeleter(UObjectDeleter *d) {
    UObjectDeleter *old = deleter;
    deleter = d;
    return old;
}

UElementsAreEqual *UVector::setComparer(UElementsAreEqual *d) {
    UElementsAreEqual *old = comparer;
    comparer = d;
    return old;
}

/**
 * Removes the element at the given index from this vector and
 * transfer ownership of it to the caller.  After this call, the
 * caller owns the result and must delete it and the vector entry
 * at 'index' is removed, shifting all subsequent entries back by
 * one index and shortening the size of the vector by one.  If the
 * index is out of range or if there is no item at the given index
 * then 0 is returned and the vector is unchanged.
 */
void* UVector::orphanElementAt(int32_t index) {
    void* e = nullptr;
    if (0 <= index && index < count) {
        e = elements[index].pointer;
        for (int32_t i=index; i<count-1; ++i) {
            elements[i] = elements[i+1];
        }
        --count;
    }
    /* else index out of range */
    return e;
}

/**
 * Insert the given object into this vector at its sorted position
 * as defined by 'compare'.  The current elements are assumed to
 * be sorted already.
 */
void UVector::sortedInsert(void* obj, UElementComparator *compare, UErrorCode& ec) {
    UElement e;
    e.pointer = obj;
    sortedInsert(e, compare, ec);
}

/**
 * Insert the given integer into this vector at its sorted position
 * as defined by 'compare'.  The current elements are assumed to
 * be sorted already.
 */
void UVector::sortedInsert(int32_t obj, UElementComparator *compare, UErrorCode& ec) {
    U_ASSERT(deleter == nullptr);
    UElement e {};
    e.integer = obj;
    sortedInsert(e, compare, ec);
}

// ASSUME elements[] IS CURRENTLY SORTED
void UVector::sortedInsert(UElement e, UElementComparator *compare, UErrorCode& ec) {
    // Perform a binary search for the location to insert tok at.  Tok
    // will be inserted between two elements a and b such that a <=
    // tok && tok < b, where there is a 'virtual' elements[-1] always
    // less than tok and a 'virtual' elements[count] always greater
    // than tok.
    if (!ensureCapacity(count + 1, ec)) {
        if (deleter != nullptr) {
            (*deleter)(e.pointer);
        }
        return;
    }
    int32_t min = 0, max = count;
    while (min != max) {
        int32_t probe = (min + max) / 2;
        int32_t c = (*compare)(elements[probe], e);
        if (c > 0) {
            max = probe;
        } else {
            // assert(c <= 0);
            min = probe + 1;
        }
    }
    for (int32_t i=count; i>min; --i) {
        elements[i] = elements[i-1];
    }
    elements[min] = e;
    ++count;
}

/**
  *  Array sort comparator function.
  *  Used from UVector::sort()
  *  Conforms to function signature required for uprv_sortArray().
  *  This function is essentially just a wrapper, to make a
  *  UVector style comparator function usable with uprv_sortArray().
  *
  *  The context pointer to this function is a pointer back
  *  (with some extra indirection) to the user supplied comparator.
  *  
  */
static int32_t U_CALLCONV
sortComparator(const void *context, const void *left, const void *right) {
    UElementComparator *compare = *static_cast<UElementComparator * const *>(context);
    UElement e1 = *static_cast<const UElement *>(left);
    UElement e2 = *static_cast<const UElement *>(right);
    int32_t result = (*compare)(e1, e2);
    return result;
}


/**
  *  Array sort comparison function for use from UVector::sorti()
  *  Compares int32_t vector elements.
  */
static int32_t U_CALLCONV
sortiComparator(const void * /*context */, const void *left, const void *right) {
    const UElement *e1 = static_cast<const UElement *>(left);
    const UElement *e2 = static_cast<const UElement *>(right);
    int32_t result = e1->integer < e2->integer? -1 :
                     e1->integer == e2->integer? 0 : 1;
    return result;
}

/**
  * Sort the vector, assuming it contains ints.
  *     (A more general sort would take a comparison function, but it's
  *     not clear whether UVector's UElementComparator or
  *     UComparator from uprv_sortAray would be more appropriate.)
  */
void UVector::sorti(UErrorCode &ec) {
    if (U_SUCCESS(ec)) {
        uprv_sortArray(elements, count, sizeof(UElement),
                       sortiComparator, nullptr,  false, &ec);
    }
}


/**
 *  Sort with a user supplied comparator.
 *
 *    The comparator function handling is confusing because the function type
 *    for UVector  (as defined for sortedInsert()) is different from the signature
 *    required by uprv_sortArray().  This is handled by passing the
 *    the UVector sort function pointer via the context pointer to a
 *    sortArray() comparator function, which can then call back to
 *    the original user function.
 *
 *    An additional twist is that it's not safe to pass a pointer-to-function
 *    as  a (void *) data pointer, so instead we pass a (data) pointer to a
 *    pointer-to-function variable.
 */
void UVector::sort(UElementComparator *compare, UErrorCode &ec) {
    if (U_SUCCESS(ec)) {
        uprv_sortArray(elements, count, sizeof(UElement),
                       sortComparator, &compare, false, &ec);
    }
}


/**
 *  Stable sort with a user supplied comparator of type UComparator.
 */
void UVector::sortWithUComparator(UComparator *compare, const void *context, UErrorCode &ec) {
    if (U_SUCCESS(ec)) {
        uprv_sortArray(elements, count, sizeof(UElement),
                       compare, context, true, &ec);
    }
}

U_NAMESPACE_END

                                                                                                                                                                                                                       node-23.7.0/deps/icu-small/source/common/uvector.h                                                  0000664 0000000 0000000 00000031232 14746647661 0022027 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
**********************************************************************
*   Copyright (C) 1999-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
**********************************************************************
*   Date        Name        Description
*   10/22/99    alan        Creation.  This is an internal header.
*                           It should not be exported.
**********************************************************************
*/

#ifndef UVECTOR_H
#define UVECTOR_H

#include "unicode/utypes.h"
#include "unicode/uobject.h"
#include "cmemory.h"
#include "uarrsort.h"
#include "uelement.h"

U_NAMESPACE_BEGIN

/**
 * Ultralightweight C++ implementation of a `void*` vector
 * that is (mostly) compatible with java.util.Vector.
 *
 * This is a very simple implementation, written to satisfy an
 * immediate porting need.  As such, it is not completely fleshed out,
 * and it aims for simplicity and conformity.  Nonetheless, it serves
 * its purpose (porting code from java that uses java.util.Vector)
 * well, and it could be easily made into a more robust vector class.
 *
 * *Design notes*
 *
 * There is index bounds checking, but little is done about it.  If
 * indices are out of bounds, either nothing happens, or zero is
 * returned.  We *do* avoid indexing off into the weeds.
 *
 * Since we don't have garbage collection, UVector was given the
 * option to *own* its contents.  To employ this, set a deleter
 * function.  The deleter is called on a `void *` pointer when that
 * pointer is released by the vector, either when the vector itself is
 * destructed, or when a call to `setElementAt()` overwrites an element,
 * or when a call to remove()` or one of its variants explicitly
 * removes an element.  If no deleter is set, or the deleter is set to
 * zero, then it is assumed that the caller will delete elements as
 * needed.
 *
 * *Error Handling* Functions that can fail, from out of memory conditions
 * for example, include a UErrorCode parameter. Any function called
 * with an error code already indicating a failure will not modify the
 * vector in any way.
 *
 * For vectors that have a deleter function, any failure in inserting
 * an element into the vector will instead delete the element that
 * could not be adopted. This simplifies object ownership
 * management around calls to `addElement()` and `insertElementAt()`;
 * error or no, the function always takes ownership of an incoming object
 * from the caller.
 *
 * In order to implement methods such as `contains()` and `indexOf()`,
 * UVector needs a way to compare objects for equality.  To do so, it
 * uses a comparison function, or "comparer."  If the comparer is not
 * set, or is set to zero, then all such methods will act as if the
 * vector contains no element.  That is, indexOf() will always return
 * -1, contains() will always return false, etc.
 *
 * <p><b>To do</b>
 *
 * <p>Improve the handling of index out of bounds errors.
 *
 * @author Alan Liu
 */
class U_COMMON_API UVector : public UObject {
    // NOTE: UVector uses the UElement (union of void* and int32_t) as
    // its basic storage type.  It uses UElementsAreEqual as its
    // comparison function.  It uses UObjectDeleter as its deleter
    // function.  This allows sharing of support functions with UHashtable.

private:
    int32_t count = 0;

    int32_t capacity = 0;

    UElement* elements = nullptr;

    UObjectDeleter *deleter = nullptr;

    UElementsAreEqual *comparer = nullptr;

public:
    UVector(UErrorCode &status);

    UVector(int32_t initialCapacity, UErrorCode &status);

    UVector(UObjectDeleter *d, UElementsAreEqual *c, UErrorCode &status);

    UVector(UObjectDeleter *d, UElementsAreEqual *c, int32_t initialCapacity, UErrorCode &status);

    virtual ~UVector();

    /**
     * Assign this object to another (make this a copy of 'other').
     * Use the 'assign' function to assign each element.
     */
    void assign(const UVector& other, UElementAssigner *assign, UErrorCode &ec);

    /**
     * Compare this vector with another.  They will be considered
     * equal if they are of the same size and all elements are equal,
     * as compared using this object's comparer.
     */
    bool operator==(const UVector& other) const;

    /**
     * Equivalent to !operator==()
     */
    inline bool operator!=(const UVector& other) const {return !operator==(other);}

    //------------------------------------------------------------
    // java.util.Vector API
    //------------------------------------------------------------

    /**
     * Add an element at the end of the vector.
     * For use only with vectors that do not adopt their elements, which is to say,
     * have not set an element deleter function. See `adoptElement()`.
     */
    void addElement(void *obj, UErrorCode &status);

    /**
     * Add an element at the end of the vector.
     * For use only with vectors that adopt their elements, which is to say,
     * have set an element deleter function. See `addElement()`.
     *
     * If the element cannot be successfully added, it will be deleted. This is
     * normal ICU _adopt_ behavior - one way or another ownership of the incoming
     * object is transferred from the caller.
     *
     * `addElement()` and `adoptElement()` are separate functions to make it easier
     * to see what the function is doing at call sites. Having a single combined function,
     * as in earlier versions of UVector, had proved to be error-prone.
     */
    void adoptElement(void *obj, UErrorCode &status);

    void addElement(int32_t elem, UErrorCode &status);

    void setElementAt(void* obj, int32_t index);

    void setElementAt(int32_t elem, int32_t index);

    void insertElementAt(void* obj, int32_t index, UErrorCode &status);

    void insertElementAt(int32_t elem, int32_t index, UErrorCode &status);
    
    void* elementAt(int32_t index) const;

    int32_t elementAti(int32_t index) const;

    UBool equals(const UVector &other) const;

    inline void* firstElement() const {return elementAt(0);}

    inline void* lastElement() const {return elementAt(count-1);}

    inline int32_t lastElementi() const {return elementAti(count-1);}

    int32_t indexOf(void* obj, int32_t startIndex = 0) const;

    int32_t indexOf(int32_t obj, int32_t startIndex = 0) const;

    inline UBool contains(void* obj) const {return indexOf(obj) >= 0;}

    inline UBool contains(int32_t obj) const {return indexOf(obj) >= 0;}

    UBool containsAll(const UVector& other) const;

    UBool removeAll(const UVector& other);

    UBool retainAll(const UVector& other);

    void removeElementAt(int32_t index);

    UBool removeElement(void* obj);

    void removeAllElements();

    inline int32_t size() const {return count;}

    inline UBool isEmpty() const {return count == 0;}

    UBool ensureCapacity(int32_t minimumCapacity, UErrorCode &status);

    /**
     * Change the size of this vector as follows: If newSize is
     * smaller, then truncate the array, possibly deleting held
     * elements for i >= newSize.  If newSize is larger, grow the
     * array, filling in new slots with nullptr.
     */
    void setSize(int32_t newSize, UErrorCode &status);

    /**
     * Fill in the given array with all elements of this vector.
     */
    void** toArray(void** result) const;

    //------------------------------------------------------------
    // New API
    //------------------------------------------------------------

    UObjectDeleter *setDeleter(UObjectDeleter *d);
    bool hasDeleter() {return deleter != nullptr;}

    UElementsAreEqual *setComparer(UElementsAreEqual *c);

    inline void* operator[](int32_t index) const {return elementAt(index);}

    /**
     * Removes the element at the given index from this vector and
     * transfer ownership of it to the caller.  After this call, the
     * caller owns the result and must delete it and the vector entry
     * at 'index' is removed, shifting all subsequent entries back by
     * one index and shortening the size of the vector by one.  If the
     * index is out of range or if there is no item at the given index
     * then 0 is returned and the vector is unchanged.
     */
    void* orphanElementAt(int32_t index);

    /**
     * Returns true if this vector contains none of the elements
     * of the given vector.
     * @param other vector to be checked for containment
     * @return true if the test condition is met
     */
    UBool containsNone(const UVector& other) const;

    /**
     * Insert the given object into this vector at its sorted position
     * as defined by 'compare'.  The current elements are assumed to
     * be sorted already.
     */
    void sortedInsert(void* obj, UElementComparator *compare, UErrorCode& ec);

    /**
     * Insert the given integer into this vector at its sorted position
     * as defined by 'compare'.  The current elements are assumed to
     * be sorted already.
     */
    void sortedInsert(int32_t obj, UElementComparator *compare, UErrorCode& ec);

    /**
     * Sort the contents of the vector, assuming that the contents of the
     * vector are of type int32_t.
     */
    void sorti(UErrorCode &ec);

    /**
      * Sort the contents of this vector, using a caller-supplied function
      * to do the comparisons.  (It's confusing that
      *  UVector's UElementComparator function is different from the
      *  UComparator function type defined in uarrsort.h)
      */
    void sort(UElementComparator *compare, UErrorCode &ec);

    /**
     * Stable sort the contents of this vector using a caller-supplied function
     * of type UComparator to do the comparison.  Provides more flexibility
     * than UVector::sort() because an additional user parameter can be passed to
     * the comparison function.
     */
    void sortWithUComparator(UComparator *compare, const void *context, UErrorCode &ec);

    /**
     * ICU "poor man's RTTI", returns a UClassID for this class.
     */
    static UClassID U_EXPORT2 getStaticClassID();

    /**
     * ICU "poor man's RTTI", returns a UClassID for the actual class.
     */
    virtual UClassID getDynamicClassID() const override;

private:
    int32_t indexOf(UElement key, int32_t startIndex = 0, int8_t hint = 0) const;

    void sortedInsert(UElement e, UElementComparator *compare, UErrorCode& ec);

public:
    // Disallow
    UVector(const UVector&) = delete;

    // Disallow
    UVector& operator=(const UVector&) = delete;

};


/**
 * Ultralightweight C++ implementation of a `void*` stack
 * that is (mostly) compatible with java.util.Stack.  As in java, this
 * is merely a paper thin layer around UVector.  See the UVector
 * documentation for further information.
 *
 * *Design notes*
 *
 * The element at index `n-1` is (of course) the top of the
 * stack.
 *
 * The poorly named `empty()` method doesn't empty the
 * stack; it determines if the stack is empty.
 *
 * @author Alan Liu
 */
class U_COMMON_API UStack : public UVector {
public:
    UStack(UErrorCode &status);

    UStack(int32_t initialCapacity, UErrorCode &status);

    UStack(UObjectDeleter *d, UElementsAreEqual *c, UErrorCode &status);

    UStack(UObjectDeleter *d, UElementsAreEqual *c, int32_t initialCapacity, UErrorCode &status);

    virtual ~UStack();

    // It's okay not to have a virtual destructor (in UVector)
    // because UStack has no special cleanup to do.

    inline UBool empty() const {return isEmpty();}

    inline void* peek() const {return lastElement();}

    inline int32_t peeki() const {return lastElementi();}
    
    /**
     * Pop and return an element from the stack.
     * For stacks with a deleter function, the caller takes ownership
     * of the popped element.
     */
    void* pop();
    
    int32_t popi();
    
    inline void* push(void* obj, UErrorCode &status) {
        if (hasDeleter()) {
            adoptElement(obj, status);
            return (U_SUCCESS(status)) ? obj : nullptr;
        } else {
            addElement(obj, status);
            return obj;
        }
    }

    inline int32_t push(int32_t i, UErrorCode &status) {
        addElement(i, status);
        return i;
    }

    /*
    If the object o occurs as an item in this stack,
    this method returns the 1-based distance from the top of the stack.
    */
    int32_t search(void* obj) const;

    /**
     * ICU "poor man's RTTI", returns a UClassID for this class.
     */
    static UClassID U_EXPORT2 getStaticClassID();

    /**
     * ICU "poor man's RTTI", returns a UClassID for the actual class.
     */
    virtual UClassID getDynamicClassID() const override;

    // Disallow
    UStack(const UStack&) = delete;

    // Disallow
    UStack& operator=(const UStack&) = delete;
};

U_NAMESPACE_END

#endif
                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/icu-small/source/common/uvectr32.cpp                                               0000664 0000000 0000000 00000021274 14746647661 0022355 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
* Copyright (C) 1999-2015, International Business Machines Corporation and
* others. All Rights Reserved.
******************************************************************************
*   Date        Name        Description
*   10/22/99    alan        Creation.
**********************************************************************
*/

#include "uvectr32.h"
#include "cmemory.h"
#include "putilimp.h"

U_NAMESPACE_BEGIN

#define DEFAULT_CAPACITY 8

/*
 * Constants for hinting whether a key is an integer
 * or a pointer.  If a hint bit is zero, then the associated
 * token is assumed to be an integer. This is needed for iSeries
 */
 
UOBJECT_DEFINE_RTTI_IMPLEMENTATION(UVector32)

UVector32::UVector32(UErrorCode &status) :
    count(0),
    capacity(0),
    maxCapacity(0),
    elements(nullptr)
{
    _init(DEFAULT_CAPACITY, status);
}

UVector32::UVector32(int32_t initialCapacity, UErrorCode &status) :
    count(0),
    capacity(0),
    maxCapacity(0),
    elements(nullptr)
{
    _init(initialCapacity, status);
}



void UVector32::_init(int32_t initialCapacity, UErrorCode &status) {
    // Fix bogus initialCapacity values; avoid malloc(0)
    if (initialCapacity < 1) {
        initialCapacity = DEFAULT_CAPACITY;
    }
    if (maxCapacity>0 && maxCapacity<initialCapacity) {
        initialCapacity = maxCapacity;
    }
    if (initialCapacity > static_cast<int32_t>(INT32_MAX / sizeof(int32_t))) {
        initialCapacity = uprv_min(DEFAULT_CAPACITY, maxCapacity);
    }
    elements = static_cast<int32_t*>(uprv_malloc(sizeof(int32_t) * initialCapacity));
    if (elements == nullptr) {
        status = U_MEMORY_ALLOCATION_ERROR;
    } else {
        capacity = initialCapacity;
    }
}

UVector32::~UVector32() {
    uprv_free(elements);
    elements = nullptr;
}

/**
 * Assign this object to another (make this a copy of 'other').
 */
void UVector32::assign(const UVector32& other, UErrorCode &ec) {
    if (ensureCapacity(other.count, ec)) {
        setSize(other.count);
        for (int32_t i=0; i<other.count; ++i) {
            elements[i] = other.elements[i];
        }
    }
}


bool UVector32::operator==(const UVector32& other) const {
    int32_t i;
    if (count != other.count) return false;
    for (i=0; i<count; ++i) {
        if (elements[i] != other.elements[i]) {
            return false;
        }
    }
    return true;
}


void UVector32::setElementAt(int32_t elem, int32_t index) {
    if (0 <= index && index < count) {
        elements[index] = elem;
    }
    /* else index out of range */
}

void UVector32::insertElementAt(int32_t elem, int32_t index, UErrorCode &status) {
    // must have 0 <= index <= count
    if (0 <= index && index <= count && ensureCapacity(count + 1, status)) {
        for (int32_t i=count; i>index; --i) {
            elements[i] = elements[i-1];
        }
        elements[index] = elem;
        ++count;
    }
    /* else index out of range */
}

UBool UVector32::containsAll(const UVector32& other) const {
    for (int32_t i=0; i<other.size(); ++i) {
        if (indexOf(other.elements[i]) < 0) {
            return false;
        }
    }
    return true;
}

UBool UVector32::containsNone(const UVector32& other) const {
    for (int32_t i=0; i<other.size(); ++i) {
        if (indexOf(other.elements[i]) >= 0) {
            return false;
        }
    }
    return true;
}

UBool UVector32::removeAll(const UVector32& other) {
    UBool changed = false;
    for (int32_t i=0; i<other.size(); ++i) {
        int32_t j = indexOf(other.elements[i]);
        if (j >= 0) {
            removeElementAt(j);
            changed = true;
        }
    }
    return changed;
}

UBool UVector32::retainAll(const UVector32& other) {
    UBool changed = false;
    for (int32_t j=size()-1; j>=0; --j) {
        int32_t i = other.indexOf(elements[j]);
        if (i < 0) {
            removeElementAt(j);
            changed = true;
        }
    }
    return changed;
}

void UVector32::removeElementAt(int32_t index) {
    if (index >= 0) {
        for (int32_t i=index; i<count-1; ++i) {
            elements[i] = elements[i+1];
        }
        --count;
    }
}

void UVector32::removeAllElements() {
    count = 0;
}

UBool   UVector32::equals(const UVector32 &other) const {
    int      i;

    if (this->count != other.count) {
        return false;
    }
    for (i=0; i<count; i++) {
        if (elements[i] != other.elements[i]) {
            return false;
        }
    }
    return true;
}




int32_t UVector32::indexOf(int32_t key, int32_t startIndex) const {
    int32_t i;
    for (i=startIndex; i<count; ++i) {
        if (key == elements[i]) {
            return i;
        }
    }
    return -1;
}


UBool UVector32::expandCapacity(int32_t minimumCapacity, UErrorCode &status) {
    if (U_FAILURE(status)) {
        return false;
    }
    if (minimumCapacity < 0) {
        status = U_ILLEGAL_ARGUMENT_ERROR;
        return false;
    }
    if (capacity >= minimumCapacity) {
        return true;
    }
    if (maxCapacity>0 && minimumCapacity>maxCapacity) {
        status = U_BUFFER_OVERFLOW_ERROR;
        return false;
    }
    if (capacity > (INT32_MAX - 1) / 2) {  // integer overflow check
        status = U_ILLEGAL_ARGUMENT_ERROR;
        return false;
    }
    int32_t newCap = capacity * 2;
    if (newCap < minimumCapacity) {
        newCap = minimumCapacity;
    }
    if (maxCapacity > 0 && newCap > maxCapacity) {
        newCap = maxCapacity;
    }
    if (newCap > static_cast<int32_t>(INT32_MAX / sizeof(int32_t))) { // integer overflow check
        // We keep the original memory contents on bad minimumCapacity/maxCapacity.
        status = U_ILLEGAL_ARGUMENT_ERROR;
        return false;
    }
    int32_t* newElems = static_cast<int32_t*>(uprv_realloc(elements, sizeof(int32_t) * newCap));
    if (newElems == nullptr) {
        // We keep the original contents on the memory failure on realloc.
        status = U_MEMORY_ALLOCATION_ERROR;
        return false;
    }
    elements = newElems;
    capacity = newCap;
    return true;
}

void UVector32::setMaxCapacity(int32_t limit) {
    U_ASSERT(limit >= 0);
    if (limit < 0) {
        limit = 0;
    }
    if (limit > static_cast<int32_t>(INT32_MAX / sizeof(int32_t))) { // integer overflow check for realloc
        //  Something is very wrong, don't realloc, leave capacity and maxCapacity unchanged
        return;
    }
    maxCapacity = limit;
    if (capacity <= maxCapacity || maxCapacity == 0) {
        // Current capacity is within the new limit.
        return;
    }
    
    // New maximum capacity is smaller than the current size.
    // Realloc the storage to the new, smaller size.
    int32_t* newElems = static_cast<int32_t*>(uprv_realloc(elements, sizeof(int32_t) * maxCapacity));
    if (newElems == nullptr) {
        // Realloc to smaller failed.
        //   Just keep what we had.  No need to call it a failure.
        return;
    }
    elements = newElems;
    capacity = maxCapacity;
    if (count > capacity) {
        count = capacity;
    }
}

/**
 * Change the size of this vector as follows: If newSize is smaller,
 * then truncate the array, possibly deleting held elements for i >=
 * newSize.  If newSize is larger, grow the array, filling in new
 * slots with nullptr.
 */
void UVector32::setSize(int32_t newSize) {
    int32_t i;
    if (newSize < 0) {
        return;
    }
    if (newSize > count) {
        UErrorCode ec = U_ZERO_ERROR;
        if (!ensureCapacity(newSize, ec)) {
            return;
        }
        for (i=count; i<newSize; ++i) {
            elements[i] = 0;
        }
    } 
    count = newSize;
}




/**
 * Insert the given integer into this vector at its sorted position
 * as defined by 'compare'.  The current elements are assumed to
 * be sorted already.
 */
void UVector32::sortedInsert(int32_t tok, UErrorCode& ec) {
    // Perform a binary search for the location to insert tok at.  Tok
    // will be inserted between two elements a and b such that a <=
    // tok && tok < b, where there is a 'virtual' elements[-1] always
    // less than tok and a 'virtual' elements[count] always greater
    // than tok.
    int32_t min = 0, max = count;
    while (min != max) {
        int32_t probe = (min + max) / 2;
        //int8_t c = (*compare)(elements[probe], tok);
        //if (c > 0) {
        if (elements[probe] > tok) {
            max = probe;
        } else {
            // assert(c <= 0);
            min = probe + 1;
        }
    }
    if (ensureCapacity(count + 1, ec)) {
        for (int32_t i=count; i>min; --i) {
            elements[i] = elements[i-1];
        }
        elements[min] = tok;
        ++count;
    }
}





U_NAMESPACE_END

                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/icu-small/source/common/uvectr32.h                                                 0000664 0000000 0000000 00000020611 14746647661 0022014 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
**********************************************************************
*   Copyright (C) 1999-2011, International Business Machines
*   Corporation and others.  All Rights Reserved.
**********************************************************************
*/

//
//  UVector32 is a class implementing a vector of 32 bit integers.
//            It is similar to UVector, but holds int32_t values rather than pointers.
//            Most of the code is unchanged from UVector.
//

#ifndef UVECTOR32_H
#define UVECTOR32_H

#include "unicode/utypes.h"
#include "unicode/uobject.h"
#include "uhash.h"
#include "uassert.h"

U_NAMESPACE_BEGIN



/**
 * <p>Ultralightweight C++ implementation of a <tt>void*</tt> vector
 * that is (mostly) compatible with java.util.Vector.
 *
 * <p>This is a very simple implementation, written to satisfy an
 * immediate porting need.  As such, it is not completely fleshed out,
 * and it aims for simplicity and conformity.  Nonetheless, it serves
 * its purpose (porting code from java that uses java.util.Vector)
 * well, and it could be easily made into a more robust vector class.
 *
 * <p><b>Design notes</b>
 *
 * <p>There is index bounds checking, but little is done about it.  If
 * indices are out of bounds, either nothing happens, or zero is
 * returned.  We <em>do</em> avoid indexing off into the weeds.
 *
 * <p>There is detection of out of memory, but the handling is very
 * coarse-grained -- similar to UnicodeString's protocol, but even
 * coarser.  The class contains <em>one static flag</em> that is set
 * when any call to <tt>new</tt> returns zero.  This allows the caller
 * to use several vectors and make just one check at the end to see if
 * a memory failure occurred.  This is more efficient than making a
 * check after each call on each vector when doing many operations on
 * multiple vectors.  The single static flag works best when memory
 * failures are infrequent, and when recovery options are limited or
 * nonexistent.
 *
 * <p><b>To do</b>
 *
 * <p>Improve the handling of index out of bounds errors.
 *
 * @author Alan Liu
 */
class U_COMMON_API UVector32 : public UObject {
private:
    int32_t   count;

    int32_t   capacity;
    
    int32_t   maxCapacity;   // Limit beyond which capacity is not permitted to grow.

    int32_t*  elements;

public:
    UVector32(UErrorCode &status);

    UVector32(int32_t initialCapacity, UErrorCode &status);

    virtual ~UVector32();

    /**
     * Assign this object to another (make this a copy of 'other').
     * Use the 'assign' function to assign each element.
     */
    void assign(const UVector32& other, UErrorCode &ec);

    /**
     * Compare this vector with another.  They will be considered
     * equal if they are of the same size and all elements are equal,
     * as compared using this object's comparer.
     */
    bool operator==(const UVector32& other) const;

    /**
     * Equivalent to !operator==()
     */
    inline bool operator!=(const UVector32& other) const;

    //------------------------------------------------------------
    // java.util.Vector API
    //------------------------------------------------------------

    inline void addElement(int32_t elem, UErrorCode &status);

    void setElementAt(int32_t elem, int32_t index);

    void insertElementAt(int32_t elem, int32_t index, UErrorCode &status);
    
    inline int32_t elementAti(int32_t index) const;

    UBool equals(const UVector32 &other) const;

    inline int32_t lastElementi() const;

    int32_t indexOf(int32_t elem, int32_t startIndex = 0) const;

    inline UBool contains(int32_t elem) const;

    UBool containsAll(const UVector32& other) const;

    UBool removeAll(const UVector32& other);

    UBool retainAll(const UVector32& other);

    void removeElementAt(int32_t index);

    void removeAllElements();

    inline int32_t size() const;

    inline UBool isEmpty() const;

    // Inline.  Use this one for speedy size check.
    inline UBool ensureCapacity(int32_t minimumCapacity, UErrorCode &status);

    // Out-of-line, handles actual growth.  Called by ensureCapacity() when necessary.
    UBool expandCapacity(int32_t minimumCapacity, UErrorCode &status);

    /**
     * Change the size of this vector as follows: If newSize is
     * smaller, then truncate the array, possibly deleting held
     * elements for i >= newSize.  If newSize is larger, grow the
     * array, filling in new slows with zero.
     */
    void setSize(int32_t newSize);

    //------------------------------------------------------------
    // New API
    //------------------------------------------------------------

    /**
     * Returns true if this vector contains none of the elements
     * of the given vector.
     * @param other vector to be checked for containment
     * @return true if the test condition is met
     */
    UBool containsNone(const UVector32& other) const;


    /**
     * Insert the given integer into this vector at its sorted position.
     * The current elements are assumed to be sorted already.
     */
    void sortedInsert(int32_t elem, UErrorCode& ec);

    /**
     * Returns a pointer to the internal array holding the vector.
     */
    inline int32_t *getBuffer() const;

    /**
     * Set the maximum allowed buffer capacity for this vector/stack.
     * Default with no limit set is unlimited, go until malloc() fails.
     * A Limit of zero means unlimited capacity.
     * Units are vector elements (32 bits each), not bytes.
     */
    void setMaxCapacity(int32_t limit);

    /**
     * ICU "poor man's RTTI", returns a UClassID for this class.
     */
    static UClassID U_EXPORT2 getStaticClassID();

    /**
     * ICU "poor man's RTTI", returns a UClassID for the actual class.
     */
    virtual UClassID getDynamicClassID() const override;

private:
    void _init(int32_t initialCapacity, UErrorCode &status);

    // Disallow
    UVector32(const UVector32&) = delete;

    // Disallow
    UVector32& operator=(const UVector32&) = delete;


    //  API Functions for Stack operations.
    //  In the original UVector, these were in a separate derived class, UStack.
    //  Here in UVector32, they are all together.
public:
    inline UBool empty() const;   // TODO:  redundant, same as empty().  Remove it?

    inline int32_t peeki() const;
    
    inline int32_t popi();
    
    inline int32_t push(int32_t i, UErrorCode &status);

    inline int32_t *reserveBlock(int32_t size, UErrorCode &status);
    inline int32_t *popFrame(int32_t size);
};


// UVector32 inlines

inline UBool UVector32::ensureCapacity(int32_t minimumCapacity, UErrorCode &status) {
    if ((minimumCapacity >= 0) && (capacity >= minimumCapacity)) {
        return true;
    } else {
        return expandCapacity(minimumCapacity, status);
    }
}

inline int32_t UVector32::elementAti(int32_t index) const {
    return (index >= 0 && count > 0 && count - index > 0) ? elements[index] : 0;
}


inline void UVector32::addElement(int32_t elem, UErrorCode &status) {
    if (ensureCapacity(count + 1, status)) {
        elements[count] = elem;
        count++;
    }
}

inline int32_t *UVector32::reserveBlock(int32_t size, UErrorCode &status) {
    if (ensureCapacity(count+size, status) == false) {
        return nullptr;
    }
    int32_t  *rp = elements+count;
    count += size;
    return rp;
}

inline int32_t *UVector32::popFrame(int32_t size) {
    U_ASSERT(count >= size);
    count -= size;
    if (count < 0) {
        count = 0;
    }
    return elements+count-size;
}



inline int32_t UVector32::size() const {
    return count;
}

inline UBool UVector32::isEmpty() const {
    return count == 0;
}

inline UBool UVector32::contains(int32_t obj) const {
    return indexOf(obj) >= 0;
}

inline int32_t UVector32::lastElementi() const {
    return elementAti(count-1);
}

inline bool UVector32::operator!=(const UVector32& other) const {
    return !operator==(other);
}

inline int32_t *UVector32::getBuffer() const {
    return elements;
}


// UStack inlines

inline UBool UVector32::empty() const {
    return isEmpty();
}

inline int32_t UVector32::peeki() const {
    return lastElementi();
}

inline int32_t UVector32::push(int32_t i, UErrorCode &status) {
    addElement(i, status);
    return i;
}

inline int32_t UVector32::popi() {
    int32_t result = 0;
    if (count > 0) {
        count--;
        result = elements[count];
    }
    return result;
}

U_NAMESPACE_END

#endif
                                                                                                                       node-23.7.0/deps/icu-small/source/common/uvectr64.cpp                                               0000664 0000000 0000000 00000013536 14746647661 0022364 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
******************************************************************************
* Copyright (C) 1999-2015, International Business Machines Corporation and
* others. All Rights Reserved.
******************************************************************************
*/

#include "uvectr64.h"
#include "cmemory.h"
#include "putilimp.h"

U_NAMESPACE_BEGIN

#define DEFAULT_CAPACITY 8

/*
 * Constants for hinting whether a key is an integer
 * or a pointer.  If a hint bit is zero, then the associated
 * token is assumed to be an integer. This is needed for iSeries
 */
 
UOBJECT_DEFINE_RTTI_IMPLEMENTATION(UVector64)

UVector64::UVector64(UErrorCode &status) :
    count(0),
    capacity(0),
    maxCapacity(0),
    elements(nullptr)
{
    _init(DEFAULT_CAPACITY, status);
}

UVector64::UVector64(int32_t initialCapacity, UErrorCode &status) :
    count(0),
    capacity(0),
    maxCapacity(0),
    elements(nullptr)
{
    _init(initialCapacity, status);
}



void UVector64::_init(int32_t initialCapacity, UErrorCode &status) {
    // Fix bogus initialCapacity values; avoid malloc(0)
    if (initialCapacity < 1) {
        initialCapacity = DEFAULT_CAPACITY;
    }
    if (maxCapacity>0 && maxCapacity<initialCapacity) {
        initialCapacity = maxCapacity;
    }
    if (initialCapacity > static_cast<int32_t>(INT32_MAX / sizeof(int64_t))) {
        initialCapacity = uprv_min(DEFAULT_CAPACITY, maxCapacity);
    }
    elements = static_cast<int64_t*>(uprv_malloc(sizeof(int64_t) * initialCapacity));
    if (elements == nullptr) {
        status = U_MEMORY_ALLOCATION_ERROR;
    } else {
        capacity = initialCapacity;
    }
}

UVector64::~UVector64() {
    uprv_free(elements);
    elements = nullptr;
}

/**
 * Assign this object to another (make this a copy of 'other').
 */
void UVector64::assign(const UVector64& other, UErrorCode &ec) {
    if (ensureCapacity(other.count, ec)) {
        setSize(other.count);
        for (int32_t i=0; i<other.count; ++i) {
            elements[i] = other.elements[i];
        }
    }
}


bool UVector64::operator==(const UVector64& other) {
    int32_t i;
    if (count != other.count) return false;
    for (i=0; i<count; ++i) {
        if (elements[i] != other.elements[i]) {
            return false;
        }
    }
    return true;
}


void UVector64::setElementAt(int64_t elem, int32_t index) {
    if (0 <= index && index < count) {
        elements[index] = elem;
    }
    /* else index out of range */
}

void UVector64::insertElementAt(int64_t elem, int32_t index, UErrorCode &status) {
    // must have 0 <= index <= count
    if (0 <= index && index <= count && ensureCapacity(count + 1, status)) {
        for (int32_t i=count; i>index; --i) {
            elements[i] = elements[i-1];
        }
        elements[index] = elem;
        ++count;
    }
    /* else index out of range */
}

void UVector64::removeAllElements() {
    count = 0;
}

UBool UVector64::expandCapacity(int32_t minimumCapacity, UErrorCode &status) {
    if (U_FAILURE(status)) {
        return false;
    }
    if (minimumCapacity < 0) {
        status = U_ILLEGAL_ARGUMENT_ERROR;
        return false;
    }
    if (capacity >= minimumCapacity) {
        return true;
    }
    if (maxCapacity>0 && minimumCapacity>maxCapacity) {
        status = U_BUFFER_OVERFLOW_ERROR;
        return false;
    }
    if (capacity > (INT32_MAX - 1) / 2) {  // integer overflow check
        status = U_ILLEGAL_ARGUMENT_ERROR;
        return false;
    }
    int32_t newCap = capacity * 2;
    if (newCap < minimumCapacity) {
        newCap = minimumCapacity;
    }
    if (maxCapacity > 0 && newCap > maxCapacity) {
        newCap = maxCapacity;
    }
    if (newCap > static_cast<int32_t>(INT32_MAX / sizeof(int64_t))) { // integer overflow check
        // We keep the original memory contents on bad minimumCapacity/maxCapacity.
        status = U_ILLEGAL_ARGUMENT_ERROR;
        return false;
    }
    int64_t* newElems = static_cast<int64_t*>(uprv_realloc(elements, sizeof(int64_t) * newCap));
    if (newElems == nullptr) {
        // We keep the original contents on the memory failure on realloc.
        status = U_MEMORY_ALLOCATION_ERROR;
        return false;
    }
    elements = newElems;
    capacity = newCap;
    return true;
}

void UVector64::setMaxCapacity(int32_t limit) {
    U_ASSERT(limit >= 0);
    if (limit < 0) {
        limit = 0;
    }
    if (limit > static_cast<int32_t>(INT32_MAX / sizeof(int64_t))) { // integer overflow check for realloc
        //  Something is very wrong, don't realloc, leave capacity and maxCapacity unchanged
        return;
    }
    maxCapacity = limit;
    if (capacity <= maxCapacity || maxCapacity == 0) {
        // Current capacity is within the new limit.
        return;
    }
    
    // New maximum capacity is smaller than the current size.
    // Realloc the storage to the new, smaller size.
    int64_t* newElems = static_cast<int64_t*>(uprv_realloc(elements, sizeof(int64_t) * maxCapacity));
    if (newElems == nullptr) {
        // Realloc to smaller failed.
        //   Just keep what we had.  No need to call it a failure.
        return;
    }
    elements = newElems;
    capacity = maxCapacity;
    if (count > capacity) {
        count = capacity;
    }
}

/**
 * Change the size of this vector as follows: If newSize is smaller,
 * then truncate the array, possibly deleting held elements for i >=
 * newSize.  If newSize is larger, grow the array, filling in new
 * slots with nullptr.
 */
void UVector64::setSize(int32_t newSize) {
    int32_t i;
    if (newSize < 0) {
        return;
    }
    if (newSize > count) {
        UErrorCode ec = U_ZERO_ERROR;
        if (!ensureCapacity(newSize, ec)) {
            return;
        }
        for (i=count; i<newSize; ++i) {
            elements[i] = 0;
        }
    } 
    count = newSize;
}

U_NAMESPACE_END

                                                                                                                                                                  node-23.7.0/deps/icu-small/source/common/uvectr64.h                                                 0000664 0000000 0000000 00000017336 14746647661 0022033 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
**********************************************************************
*   Copyright (C) 1999-2014, International Business Machines
*   Corporation and others.  All Rights Reserved.
**********************************************************************
*/

//
//  UVector64 is a class implementing a vector of 64 bit integers.
//            It is similar to UVector32, but holds int64_t values rather than int32_t.
//            Most of the code is unchanged from UVector.
//

#ifndef UVECTOR64_H
#define UVECTOR64_H

#include "unicode/utypes.h"
#include "unicode/uobject.h"
#include "uhash.h"
#include "uassert.h"

U_NAMESPACE_BEGIN



/**
 * <p>Ultralightweight C++ implementation of an <tt>int64_t</tt> vector
 * that has a subset of methods from UVector32
 *
 * <p>This is a very simple implementation, written to satisfy an
 * immediate porting need.  As such, it is not completely fleshed out,
 * and it aims for simplicity and conformity.  Nonetheless, it serves
 * its purpose (porting code from java that uses java.util.Vector)
 * well, and it could be easily made into a more robust vector class.
 *
 * <p><b>Design notes</b>
 *
 * <p>There is index bounds checking, but little is done about it.  If
 * indices are out of bounds, either nothing happens, or zero is
 * returned.  We <em>do</em> avoid indexing off into the weeds.
 *
 * <p>There is detection of out of memory, but the handling is very
 * coarse-grained -- similar to UnicodeString's protocol, but even
 * coarser.  The class contains <em>one static flag</em> that is set
 * when any call to <tt>new</tt> returns zero.  This allows the caller
 * to use several vectors and make just one check at the end to see if
 * a memory failure occurred.  This is more efficient than making a
 * check after each call on each vector when doing many operations on
 * multiple vectors.  The single static flag works best when memory
 * failures are infrequent, and when recovery options are limited or
 * nonexistent.
 *
 * <p><b>To do</b>
 *
 * <p>Improve the handling of index out of bounds errors.
 *
 */
class U_COMMON_API UVector64 : public UObject {
private:
    int32_t   count;

    int32_t   capacity;
    
    int32_t   maxCapacity;   // Limit beyond which capacity is not permitted to grow.

    int64_t*  elements;

public:
    UVector64(UErrorCode &status);

    UVector64(int32_t initialCapacity, UErrorCode &status);

    virtual ~UVector64();

    /**
     * Assign this object to another (make this a copy of 'other').
     * Use the 'assign' function to assign each element.
     */
    void assign(const UVector64& other, UErrorCode &ec);

    /**
     * Compare this vector with another.  They will be considered
     * equal if they are of the same size and all elements are equal,
     * as compared using this object's comparer.
     */
    bool operator==(const UVector64& other);

    /**
     * Equivalent to !operator==()
     */
    inline bool operator!=(const UVector64& other);

    //------------------------------------------------------------
    // subset of java.util.Vector API
    //------------------------------------------------------------

    inline void addElement(int64_t elem, UErrorCode &status);

    void setElementAt(int64_t elem, int32_t index);

    void insertElementAt(int64_t elem, int32_t index, UErrorCode &status);
    
    inline int64_t elementAti(int32_t index) const;

    //UBool equals(const UVector64 &other) const;

    inline int64_t lastElementi() const;

    //int32_t indexOf(int64_t elem, int32_t startIndex = 0) const;

    //UBool contains(int64_t elem) const;

    //UBool containsAll(const UVector64& other) const;

    //UBool removeAll(const UVector64& other);

    //UBool retainAll(const UVector64& other);

    //void removeElementAt(int32_t index);

    void removeAllElements();

    inline int32_t size() const;

    inline UBool isEmpty() const { return count == 0; }

    // Inline.  Use this one for speedy size check.
    inline UBool ensureCapacity(int32_t minimumCapacity, UErrorCode &status);

    // Out-of-line, handles actual growth.  Called by ensureCapacity() when necessary.
    UBool expandCapacity(int32_t minimumCapacity, UErrorCode &status);

    /**
     * Change the size of this vector as follows: If newSize is
     * smaller, then truncate the array, possibly deleting held
     * elements for i >= newSize.  If newSize is larger, grow the
     * array, filling in new slows with zero.
     */
    void setSize(int32_t newSize);

    //------------------------------------------------------------
    // New API
    //------------------------------------------------------------

    //UBool containsNone(const UVector64& other) const;


    //void sortedInsert(int64_t elem, UErrorCode& ec);

    /**
     * Returns a pointer to the internal array holding the vector.
     */
    inline int64_t *getBuffer() const;

    /**
     * Set the maximum allowed buffer capacity for this vector/stack.
     * Default with no limit set is unlimited, go until malloc() fails.
     * A Limit of zero means unlimited capacity.
     * Units are vector elements (64 bits each), not bytes.
     */
    void setMaxCapacity(int32_t limit);

    /**
     * ICU "poor man's RTTI", returns a UClassID for this class.
     */
    static UClassID U_EXPORT2 getStaticClassID();

    /**
     * ICU "poor man's RTTI", returns a UClassID for the actual class.
     */
    virtual UClassID getDynamicClassID() const override;

private:
    void _init(int32_t initialCapacity, UErrorCode &status);

    // Disallow
    UVector64(const UVector64&) = delete;

    // Disallow
    UVector64& operator=(const UVector64&) = delete;


    //  API Functions for Stack operations.
    //  In the original UVector, these were in a separate derived class, UStack.
    //  Here in UVector64, they are all together.
public:
    //UBool empty() const;   // TODO:  redundant, same as empty().  Remove it?

    //int64_t peeki() const;
    
    inline int64_t popi();
    
    inline int64_t push(int64_t i, UErrorCode &status);

    inline int64_t *reserveBlock(int32_t size, UErrorCode &status);
    inline int64_t *popFrame(int32_t size);
};


// UVector64 inlines

inline UBool UVector64::ensureCapacity(int32_t minimumCapacity, UErrorCode &status) {
    if ((minimumCapacity >= 0) && (capacity >= minimumCapacity)) {
        return true;
    } else {
        return expandCapacity(minimumCapacity, status);
    }
}

inline int64_t UVector64::elementAti(int32_t index) const {
    return (0 <= index && index < count) ? elements[index] : 0;
}


inline void UVector64::addElement(int64_t elem, UErrorCode &status) {
    if (ensureCapacity(count + 1, status)) {
        elements[count] = elem;
        count++;
    }
}

inline int64_t *UVector64::reserveBlock(int32_t size, UErrorCode &status) {
    if (ensureCapacity(count+size, status) == false) {
        return nullptr;
    }
    int64_t  *rp = elements+count;
    count += size;
    return rp;
}

inline int64_t *UVector64::popFrame(int32_t size) {
    U_ASSERT(count >= size);
    count -= size;
    if (count < 0) {
        count = 0;
    }
    return elements+count-size;
}



inline int32_t UVector64::size() const {
    return count;
}

inline int64_t UVector64::lastElementi() const {
    return elementAti(count-1);
}

inline bool UVector64::operator!=(const UVector64& other) {
    return !operator==(other);
}

inline int64_t *UVector64::getBuffer() const {
    return elements;
}


// UStack inlines

inline int64_t UVector64::push(int64_t i, UErrorCode &status) {
    addElement(i, status);
    return i;
}

inline int64_t UVector64::popi() {
    int64_t result = 0;
    if (count > 0) {
        count--;
        result = elements[count];
    }
    return result;
}

U_NAMESPACE_END

#endif
                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/icu-small/source/common/wintz.cpp                                                  0000664 0000000 0000000 00000040042 14746647661 0022045 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
********************************************************************************
*   Copyright (C) 2005-2015, International Business Machines
*   Corporation and others.  All Rights Reserved.
********************************************************************************
*
* File WINTZ.CPP
*
********************************************************************************
*/

#include "unicode/utypes.h"

#if U_PLATFORM_USES_ONLY_WIN32_API

#include "wintz.h"
#include "charstr.h"
#include "cmemory.h"
#include "cstring.h"

#include "unicode/ures.h"
#include "unicode/unistr.h"
#include "uresimp.h"

#ifndef WIN32_LEAN_AND_MEAN
#   define WIN32_LEAN_AND_MEAN
#endif
#   define VC_EXTRALEAN
#   define NOUSER
#   define NOSERVICE
#   define NOIME
#   define NOMCX
#include <windows.h>

U_NAMESPACE_BEGIN

// Note these constants and the struct are only used when dealing with the fallback path for RDP sessions.

// This is the location of the time zones in the registry on Vista+ systems.
// See: https://docs.microsoft.com/windows/win32/api/timezoneapi/ns-timezoneapi-dynamic_time_zone_information
#define WINDOWS_TIMEZONES_REG_KEY_PATH L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"

// Max length for a registry key is 255. +1 for null.
// See: https://docs.microsoft.com/windows/win32/sysinfo/registry-element-size-limits
#define WINDOWS_MAX_REG_KEY_LENGTH 256

#if U_PLATFORM_HAS_WINUWP_API == 0

// This is the layout of the TZI binary value in the registry.
// See: https://docs.microsoft.com/windows/win32/api/timezoneapi/ns-timezoneapi-time_zone_information
typedef struct _REG_TZI_FORMAT {
    LONG Bias;
    LONG StandardBias;
    LONG DaylightBias;
    SYSTEMTIME StandardDate;
    SYSTEMTIME DaylightDate;
} REG_TZI_FORMAT;

#endif // U_PLATFORM_HAS_WINUWP_API

/**
* This is main Windows time zone detection function.
* 
* It returns the Windows time zone converted to an ICU time zone as a heap-allocated buffer, or nullptr upon failure.
*
* We use the Win32 API GetDynamicTimeZoneInformation (which is available since Vista) to get the current time zone info,
* as this API returns a non-localized time zone name which can be then mapped to an ICU time zone.
* 
* However, in some RDP/terminal services situations, this struct isn't always fully complete, and the TimeZoneKeyName
* field of the struct might be nullptr. This can happen with some 3rd party RDP clients, and also when using older versions
* of the RDP protocol, which don't send the newer TimeZoneKeyNamei information and only send the StandardName and DaylightName.
* 
* Since these 3rd party clients and older RDP clients only send the pre-Vista time zone information to the server, this means that we 
* need to fallback on using the pre-Vista methods to determine the time zone. This unfortunately requires examining the registry directly
* in order to try and determine the current time zone.
* 
* Note that this can however still fail in some cases though if the client and server are using different languages, as the StandardName
* that is sent by client is localized in the client's language. However, we must compare this to the names that are on the server, which
* are localized in registry using the server's language. Despite that, this is the best we can do.
* 
* Note: This fallback method won't work for the UWP version though, as we can't use the registry APIs in UWP.
* 
* Once we have the current Windows time zone, then we can then map it to an ICU time zone ID (~ Olsen ID).
*/
U_CAPI const char* U_EXPORT2
uprv_detectWindowsTimeZone()
{
    // We first try to obtain the time zone directly by using the TimeZoneKeyName field of the DYNAMIC_TIME_ZONE_INFORMATION struct.
    DYNAMIC_TIME_ZONE_INFORMATION dynamicTZI;
    uprv_memset(&dynamicTZI, 0, sizeof(dynamicTZI));
    SYSTEMTIME systemTimeAllZero;
    uprv_memset(&systemTimeAllZero, 0, sizeof(systemTimeAllZero));

    if (GetDynamicTimeZoneInformation(&dynamicTZI) == TIME_ZONE_ID_INVALID) {
        return nullptr;
    }

    // If the DST setting has been turned off in the Control Panel, then return "Etc/GMT<offset>".
    //
    // Note: This logic is based on how the Control Panel itself determines if DST is 'off' on Windows.
    // The code is somewhat convoluted; in a sort of pseudo-code it looks like this:
    // 
    //   IF (GetDynamicTimeZoneInformation != TIME_ZONE_ID_INVALID) && (DynamicDaylightTimeDisabled != 0) &&
    //      (StandardDate == DaylightDate) &&
    //      (
    //       (TimeZoneKeyName != Empty && StandardDate == 0) ||
    //       (TimeZoneKeyName == Empty && StandardDate != 0)
    //      )
    //   THEN
    //     DST setting is "Disabled".
    //
    if (dynamicTZI.DynamicDaylightTimeDisabled != 0 &&
        uprv_memcmp(&dynamicTZI.StandardDate, &dynamicTZI.DaylightDate, sizeof(dynamicTZI.StandardDate)) == 0 &&
        ((dynamicTZI.TimeZoneKeyName[0] != L'\0' && uprv_memcmp(&dynamicTZI.StandardDate, &systemTimeAllZero, sizeof(systemTimeAllZero)) == 0) ||
         (dynamicTZI.TimeZoneKeyName[0] == L'\0' && uprv_memcmp(&dynamicTZI.StandardDate, &systemTimeAllZero, sizeof(systemTimeAllZero)) != 0)))
    {
        LONG utcOffsetMins = dynamicTZI.Bias;
        if (utcOffsetMins == 0) {
            return uprv_strdup("Etc/UTC");
        }

        // No way to support when DST is turned off and the offset in minutes is not a multiple of 60.
        if (utcOffsetMins % 60 == 0) {
            char gmtOffsetTz[11] = {}; // "Etc/GMT+dd" is 11-char long with a terminal null.
            // Important note on the sign convention for zones:
            //
            // From https://en.wikipedia.org/wiki/Tz_database#Area
            //   "In order to conform with the POSIX style, those zone names beginning with "Etc/GMT" have their sign reversed
            //   from the standard ISO 8601 convention. In the "Etc" area, zones west of GMT have a positive sign and those
            //   east have a negative sign in their name (e.g "Etc/GMT-14" is 14 hours ahead of GMT)."
            //
            // Regarding the POSIX style, from https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
            //   "The offset specifies the time value you must add to the local time to get a Coordinated Universal Time value."
            //
            // However, the Bias value in DYNAMIC_TIME_ZONE_INFORMATION *already* follows the POSIX convention.
            // 
            // From https://docs.microsoft.com/en-us/windows/win32/api/timezoneapi/ns-timezoneapi-dynamic_time_zone_information
            //   "The bias is the difference, in minutes, between Coordinated Universal Time (UTC) and
            //   local time. All translations between UTC and local time are based on the following formula:
            //      UTC = local time + bias"
            //
            // For example, a time zone that is 3 hours ahead of UTC (UTC+03:00) would have a Bias value of -180, and the
            // corresponding time zone ID would be "Etc/GMT-3". (So there is no need to negate utcOffsetMins below.)
            int ret = snprintf(gmtOffsetTz, sizeof(gmtOffsetTz), "Etc/GMT%+ld", utcOffsetMins / 60);
            if (ret > 0 && ret < UPRV_LENGTHOF(gmtOffsetTz)) {
                return uprv_strdup(gmtOffsetTz);
            }
        }
    }

    // If DST is NOT disabled, but the TimeZoneKeyName field of the struct is nullptr, then we may be dealing with a
    // RDP/terminal services session where the 'Time Zone Redirection' feature is enabled. However, either the RDP
    // client sent the server incomplete info (some 3rd party RDP clients only send the StandardName and  DaylightName,
    // but do not send the important TimeZoneKeyName), or if the RDP server has not appropriately populated the struct correctly.
    //
    // In this case we unfortunately have no choice but to fallback to using the pre-Vista method of determining the
    // time zone, which requires examining the registry directly.
    //
    // Note that this can however still fail though if the client and server are using different languages, as the StandardName
    // that is sent by client is *localized* in the client's language. However, we must compare this to the names that are
    // on the server, which are *localized* in registry using the server's language.
    //
    // One other note is that this fallback method doesn't work for the UWP version, as we can't use the registry APIs.

    // windowsTimeZoneName will point at timezoneSubKeyName if we had to fallback to using the registry, and we found a match.
    WCHAR timezoneSubKeyName[WINDOWS_MAX_REG_KEY_LENGTH];
    WCHAR *windowsTimeZoneName = dynamicTZI.TimeZoneKeyName;

    if (dynamicTZI.TimeZoneKeyName[0] == 0) {

// We can't use the registry APIs in the UWP version.
#if U_PLATFORM_HAS_WINUWP_API == 1
        (void)timezoneSubKeyName; // suppress unused variable warnings.
        return nullptr;
#else
        // Open the path to the time zones in the Windows registry.
        LONG ret;
        HKEY hKeyAllTimeZones = nullptr;
        ret = RegOpenKeyExW(HKEY_LOCAL_MACHINE, WINDOWS_TIMEZONES_REG_KEY_PATH, 0, KEY_READ,
                            reinterpret_cast<PHKEY>(&hKeyAllTimeZones));
        
        if (ret != ERROR_SUCCESS) {
            // If we can't open the key, then we can't do much, so fail.
            return nullptr;
        }

        // Read the number of subkeys under the time zone registry path.
        DWORD numTimeZoneSubKeys;
        ret = RegQueryInfoKeyW(hKeyAllTimeZones, nullptr, nullptr, nullptr, &numTimeZoneSubKeys,
                               nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr);
        
        if (ret != ERROR_SUCCESS) {
            RegCloseKey(hKeyAllTimeZones);
            return nullptr;
        }

        // Examine each of the subkeys to try and find a match for the localized standard name ("Std").
        //
        // Note: The name of the time zone subkey itself is not localized, but the "Std" name is localized. This means
        // that we could fail to find a match if the RDP client and RDP server are using different languages, but unfortunately
        // there isn't much we can do about it.
        HKEY hKeyTimeZoneSubKey = nullptr;
        ULONG registryValueType;
        WCHAR registryStandardName[WINDOWS_MAX_REG_KEY_LENGTH];

        for (DWORD i = 0; i < numTimeZoneSubKeys; i++) {
            // Note: RegEnumKeyExW wants the size of the buffer in characters.
            DWORD size = UPRV_LENGTHOF(timezoneSubKeyName);
            ret = RegEnumKeyExW(hKeyAllTimeZones, i, timezoneSubKeyName, &size, nullptr, nullptr, nullptr, nullptr);

            if (ret != ERROR_SUCCESS) {
                RegCloseKey(hKeyAllTimeZones);
                return nullptr;
            }
            
            ret = RegOpenKeyExW(hKeyAllTimeZones, timezoneSubKeyName, 0, KEY_READ,
                                reinterpret_cast<PHKEY>(&hKeyTimeZoneSubKey));
            
            if (ret != ERROR_SUCCESS) {
                RegCloseKey(hKeyAllTimeZones);
                return nullptr;
            }

            // Note: RegQueryValueExW wants the size of the buffer in bytes.
            size = sizeof(registryStandardName);
            ret = RegQueryValueExW(hKeyTimeZoneSubKey, L"Std", nullptr, &registryValueType,
                                   reinterpret_cast<LPBYTE>(registryStandardName), &size);
            
            if (ret != ERROR_SUCCESS || registryValueType != REG_SZ) {
                RegCloseKey(hKeyTimeZoneSubKey);
                RegCloseKey(hKeyAllTimeZones);
                return nullptr;
            }

            // Note: wcscmp does an ordinal (byte) comparison.
            if (wcscmp(reinterpret_cast<WCHAR *>(registryStandardName), dynamicTZI.StandardName) == 0) {
                // Since we are comparing the *localized* time zone name, it's possible that some languages might use
                // the same string for more than one time zone. Thus we need to examine the TZI data in the registry to
                // compare the GMT offset (the bias), and the DST transition dates, to ensure it's the same time zone
                // as the currently reported one.
                REG_TZI_FORMAT registryTziValue;
                uprv_memset(&registryTziValue, 0, sizeof(registryTziValue));

                // Note: RegQueryValueExW wants the size of the buffer in bytes.
                DWORD timezoneTziValueSize = sizeof(registryTziValue);
                ret = RegQueryValueExW(hKeyTimeZoneSubKey, L"TZI", nullptr, &registryValueType,
                                     reinterpret_cast<LPBYTE>(&registryTziValue), &timezoneTziValueSize);

                if (ret == ERROR_SUCCESS) {
                    if ((dynamicTZI.Bias == registryTziValue.Bias) &&
                        (memcmp((const void *)&dynamicTZI.StandardDate, (const void *)&registryTziValue.StandardDate, sizeof(SYSTEMTIME)) == 0) &&
                        (memcmp((const void *)&dynamicTZI.DaylightDate, (const void *)&registryTziValue.DaylightDate, sizeof(SYSTEMTIME)) == 0))
                    {
                        // We found a matching time zone.
                        windowsTimeZoneName = timezoneSubKeyName;
                        break;
                    }
                }
            }
            RegCloseKey(hKeyTimeZoneSubKey);
            hKeyTimeZoneSubKey = nullptr;
        }

        if (hKeyTimeZoneSubKey != nullptr) {
            RegCloseKey(hKeyTimeZoneSubKey);
        }
        if (hKeyAllTimeZones != nullptr) {
            RegCloseKey(hKeyAllTimeZones);
        }
#endif // U_PLATFORM_HAS_WINUWP_API
    }

    CharString winTZ;
    UErrorCode status = U_ZERO_ERROR;
    winTZ.appendInvariantChars(UnicodeString(true, windowsTimeZoneName, -1), status);

    // Map Windows Timezone name (non-localized) to ICU timezone ID (~ Olson timezone id).
    StackUResourceBundle winTZBundle;
    ures_openDirectFillIn(winTZBundle.getAlias(), nullptr, "windowsZones", &status);
    ures_getByKey(winTZBundle.getAlias(), "mapTimezones", winTZBundle.getAlias(), &status);
    ures_getByKey(winTZBundle.getAlias(), winTZ.data(), winTZBundle.getAlias(), &status);

    if (U_FAILURE(status)) {
        return nullptr;
    }
    
    // Note: Since the ISO 3166 country/region codes are all invariant ASCII chars, we can
    // directly downcast from wchar_t to do the conversion.
    // We could call the A version of the GetGeoInfo API, but that would be slightly slower than calling the W API,
    // as the A version of the API will end up calling MultiByteToWideChar anyways internally.
    wchar_t regionCodeW[3] = {};
    char regionCode[3] = {}; // 2 letter ISO 3166 country/region code made entirely of invariant chars.
    int geoId = GetUserGeoID(GEOCLASS_NATION);
    int regionCodeLen = GetGeoInfoW(geoId, GEO_ISO2, regionCodeW, UPRV_LENGTHOF(regionCodeW), 0);

    const char16_t *icuTZ16 = nullptr;
    int32_t tzListLen = 0;

    if (regionCodeLen != 0) {
        for (int i = 0; i < UPRV_LENGTHOF(regionCodeW); i++) {
            regionCode[i] = static_cast<char>(regionCodeW[i]);
        }
        icuTZ16 = ures_getStringByKey(winTZBundle.getAlias(), regionCode, &tzListLen, &status);
    }
    if (regionCodeLen == 0 || U_FAILURE(status)) {
        // fallback to default "001" (world)
        status = U_ZERO_ERROR;
        icuTZ16 = ures_getStringByKey(winTZBundle.getAlias(), "001", &tzListLen, &status);
    }

    // Note: We want the first entry in the string returned by ures_getStringByKey.
    // However this string can be a space delimited list of timezones:
    //  Ex: "America/New_York America/Detroit America/Indiana/Petersburg ..."
    // We need to stop at the first space, so we pass tzLen (instead of tzListLen) to appendInvariantChars below.
    int32_t tzLen = 0;
    if (tzListLen > 0) {
        while (!(icuTZ16[tzLen] == u'\0' || icuTZ16[tzLen] == u' ')) {
            tzLen++;
        }
    }

    // Note: cloneData returns nullptr if the status is a failure, so this
    // will return nullptr if the above look-up fails.
    CharString icuTZStr;
    return icuTZStr.appendInvariantChars(icuTZ16, tzLen, status).cloneData(status);
}

U_NAMESPACE_END
#endif /* U_PLATFORM_USES_ONLY_WIN32_API  */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/icu-small/source/common/wintz.h                                                    0000664 0000000 0000000 00000001647 14746647661 0021522 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // © 2016 and later: Unicode, Inc. and others.
// License & terms of use: http://www.unicode.org/copyright.html
/*
********************************************************************************
*   Copyright (C) 2005-2011, International Business Machines
*   Corporation and others.  All Rights Reserved.
********************************************************************************
*
* File WINTZ.H
*
********************************************************************************
*/

#ifndef __WINTZ
#define __WINTZ

#include "unicode/utypes.h"

#if U_PLATFORM_USES_ONLY_WIN32_API

/**
 * \file 
 * \brief C API: Utilities for dealing w/ Windows time zones.
 */

U_CDECL_BEGIN
/* Forward declarations for Windows types... */
typedef struct _TIME_ZONE_INFORMATION TIME_ZONE_INFORMATION;
U_CDECL_END

U_CAPI const char* U_EXPORT2
uprv_detectWindowsTimeZone();

#endif /* U_PLATFORM_USES_ONLY_WIN32_API  */

#endif /* __WINTZ */
                                                                                         node-23.7.0/deps/icu-small/source/data/                                                             0000775 0000000 0000000 00000000000 14746647661 0017607 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/icu-small/source/data/in/                                                          0000775 0000000 0000000 00000000000 14746647661 0020215 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/icu-small/source/data/in/icudt76l.dat.bz2                                          0000664 0000000 0000000 00052245434 14746647661 0023067 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        BZh91AY&SYzX͞|7oaLRyDɣ}5Eke3jlPu},wu(Wo./w(
RPJBR( S׳kZ݋Ozsw)ǧlGi`wn2z_0)@JTgͅfZhfJxRAv@7]ewl[lЛ`+T|sʐbO377u$.zDku[Ϸ7hk(4}p_wr+3;`*{mv}<	з{ωo󷳰:` zQzWNΰtt{Ymgwen:eӭg[2_L,g}mG≧C47JG{yw}
}{۝RHkdM:fE
}w  >wp@ U =%w l@X{ 2 р"     1 d  nvjm{᱂;r3|CNJݴӧ)Zco"y0+;He}UZɠd d!*eD]hAE )Q w
Z2064٭_=	l$խT4A(8 W/v^ޜ@hn3܀@N; @wfխ,-+lST)Jx%04
]td0ɅPuZ(+XPj5`OVQ_>b cǯwf+[|stp!`@g"  m @W.=yکt=y]zQ 7N Dt uU͝P!=jcsw-k{zSp5M"\ }O}/3 \qts1W te"R ãSrGuy2fz	m].hP 7[{ A7]ņ2V  =(^+Mi޹H
hJ֞ Dcz = vbv썢^h nw3վ׷=  kg},4 @  mE+;3zH @ % k  y@(  WuB=篬H  "B  `   (@    $ tw` X=6 +v  `@   @ li @ tفU@    & :;xze<g{_l+C{[yCuB"ٸGeF^$!Vxntӵm 4xˇRgG \(d=qz{ǈQD%yofD(5=;˽ X      )cϰwy=aޟ}   h    o P+l@@t4,r˯JY^gOx:\<) A[;     3>2(R Ux: rGd޼=K5fx x{Y@dzy@mKӸG0iLFv           viBH=.:*5U Ulz%BZ J
(QI D(
 
$B	($@ 	q[[aM6- h;mM+z܅@e@ H$@.n$ۣ+<uHR  BpuA;<VOq1=@")p뺽[֑.JBMU] T{a 䭷ytdsb>yPOa[}S9'F񎁶  67Q KM
WCC^Ͻ/XO{s$=Ý/}[8wj)>R|O3T`۶{`z >z/}Mdl Fnj8mCj1wϻ8BCz
 )%w@  oxPZ1м<a'a}vxz8.t1hbح,}>w =_Fi ^t7z5G|[zNyΰ@T1;k4DP v}g@s&f}{h)9cW:zt\N|ws`]w{Up{SxM>N,ku}U%8G}ހ|8wܻ{b} `2i7"׹O\@8Il8⫝                               
                                  u                                 A7ӯ y@m {w33>;Pg6x {Q׺ ގysy @QlqӀvj+tD8 ؒYPjP`" Ϊ(R4tĎ
wi0
FoA@, o{  î@pku)Ckktk+L t:ahG
Pap7^	qn=cׁ>pq  ف  LC= y=|lX`}@͈4Rvr (Ugs==:;$fLc:ֽfsx({9>ND:]w0I6eyƻg3糽}9R,iBM=lk`8#A[fm݇ Wa=}{z.oc^SnL	ج3l}Ǽ1E U4T" 4SpOo'"}9PJ"K] DR% PlPHP{=RW @. ɠ @F3* ͮ!n  "h@       &&M                  &&!U<  !@       4   LM  M4L1Ljhz     2d      42h ѣ@ɦ     d0m SDB iLdhx&&h&ѣ$SMD` M4E?M'hbjGMjfF"@@      M4   iM14&	2hѣ!S& ɀS2M RB   	     @       	 14  4 & i' -XI ueS`xe_f NGk> yޜIgIћ_y׻̵YvGRCk*mOQ:^3kKvɁѭcZ ufr
=eZk	Š>0'-\܌$0fJ0EO0g=I*	2Bd=BTx%<`"b#vQX㲸s`9kROHZ94dA7LdGLS
Я?:)oQ}.\BX'9	`+ߏռu@F$/d[oυ)o!@2~QPM^xsB;zfE/{Gp>^f!gY8	 M0o=#y+XޏԷzK]fޢG>7a8Z4dw.Sв6OdWt)cNgo($fNFp_qWx۟HR3<b3R Ao	)Yƛ%~[zJKRA><#38nh5To!R(w#9zOާ>k	Z-$ą'm$"@/8(A c$cwBݮ}g<kBTA~gى(Sxő(:3jVomrBcLʧtU-U$!ӄO/4-3bi!6y^%$N?[g-FBкQB{r_(j{񅚈Ֆ"/!niMhvf&]oK*ȿ"Aq=ZN}u^:I9w`ZLeiQO*aHcm0|k\K<Ӹ+(RKr[LnhӢyn@Zu3}j-ьuW4!RvtϋIBŮ6gj)O6ܯ4'M\3ƑE97Anr=}i0dRb;ZE;^d9dNݩ2$hI[ٹY]
]ŌITe2'dr#g.MʛY~kOCȸЈb	AFLU":&`g
x
fxsP|'f,!Y#+Bݥx9;Ͽo=6&K9H@$m$\lrfXlIMAp'%xD@X:K3(hB7}I\pYYQZoa.fШHfjKIdY5
*Gپ~f8r*[<._ĶVTV_  #Xk9g:Z<[ܼ&awˏY/tz_>\=֧-#I.tw/5,nw˓`h&<RۗmkA84r'FW"(Q6pL~9pKTla"xBɷl*
-2wph<)CÅa#{[IQA2&eË+iЩ$I6HV=켮ni<)#Ȯ4{^#30N6cF8@ddfoO7v`;u[9|9G)v8)
d=czNrA좬iTo?g:ͦȈg<LL#)[t?{^YShn#878W"}v{XOu~^_ٽӲ=g
Uj	뻗BSU/  `C1)!H|s7e$?7¨OI {ٌC	ULfB|HTUn;9#wa`I"$1mj0	I$10*zhRL4Ju/_f`|5ϯoھTpK.)gӉ}voqe<Oug0'.*Ǜ*
sE@اY( dUyauX%,ZU(NGol~cdp40{=Yz
~M|eՇc~-
hmzV^ bɿ K<|`~2FvkyFuǻKb<2/M&t>\.3sw'Q1cu['\%hIu5v[˺9Mv3ci_}ǚe\H d	` U Tg(4=@I!}$
d;Sj@dDЄaQ X@ CE`ˋHbc`Z0"`Ö1t$ Y.lE:eww&/}"TSZ7mZSگ|a,d)6]":ՇB**V[Ol8W89-_NM	͈9$BJQT.ͻ{B(V#֐(q0lid#m3b3qp*3 LG`$X
($}%ǈ_S>cmӝ
wIbq8$`mwOSl'+;@Vis|;kyΛ<mqiw;~;=mϿY;af@ aT!HuAHX
AAR
~t:$`Ew	,TXJAd1T/Lm"(%2(	/!0Ir@PhT\`Q]j({XcQ#/$n!2yb$E#",1U0X.1B-X((bL1C!sU|X*c7v[$JJ@0@ŝuϽfS73q˭P\dG*`8IkȖ±b H}m5Y;ݱn`<{+YK*prt&2.*Vl\UlѮ;	q-Du_7KzhOu_U	1$rk3vzfw9̷/Lt?iny_~._d1Pi)Y"or `7,>W[ql:iqx,!)Xb=wo{gߺOih
aJzN=)黎MDRVV'`X,X筹-&'5[gI_^X2^0=.s;vH 2VP, LQQdFWV,s)'bApłZd)ܴzX41
%0@_ y`[Af(\aBJa(EF,R]jƥR
 ,-}Y0-}`\Q
jUE	L"E,,)TA)(,vI;ͯ_n\^g[;Bm `0)؍}:[	=&aV UK(giQἷhv_ֽVB:VE~:TB
}Ѐ[A \"1LI) Ia%H*ޔB)b)""AbQHH
;3pً9!20ˑ;OּSܩrUx}D4պ֊*ᕫe4bҖW'`{ge.UG;޵f=^
ၤW핂RUG> "+#닉tPKT,4"䑬dl:o*V
naw$bQZK!({W>y;{}?qg4MIn.*kvVzg(	~pGF\8;~?YRn:S2#O+4Ժ[k59{tm`=\L>MVybg3cjzmO.I:ѩ&>[,[¿-СB{>\qHҚ,5dx<O?7'ėV3m--wObSgO/l3V,@9j  
*#1Xc S@Z%6ŐP. `U2A ")>7-m(v@.Ŭ3Ή7JW_{[[O5~nu޷07tݬ:l36>,Eb p  PQ]%}׶t]_Iǘ=x_vp^WDk&^Mmx(D3֥V:Q<7=1|C6E3AWʹYVSQQcǫ}|I߽̭;ͩowy`}OrrHjrB[;q~)k|3TX)jy8('D
"7AM}<0mcRUk	xW5Z;j-~tqyhZזޟKo/Jן֨}|/,D鋕%2,	uŋWn;z~1k/_"($a3kƸ]>hνލUwiz/{:Wc}\q^6_?oxES}`5I6.G>N &g YӧN^P|]M=JbL$[Lx~D.g>[{ AOzbl{%3Np߽v&f5crDـkZ~xJ0Xث5(n.MX>	2g59jG(|=#,1J,8	"擌.%&R~SgY$KwHIsbm63wu!|;,a/5FxDWJ%	G 8)A0EƦCM&\=R+	H?Nj,yxv?>	\ 7ST{@RKcC$4\   vAkR*oM(:b^3~L_نk,*CV/KۋƖ2  h	:z"'sHnp$ۆo=blA@ɭJCHi'A^<ǰ8Ǫ /Np{㕳(.AykR9hjL>! GZsx4M 8,2Zo(ՋBsaFʃ \pc zdkmb-eqⴗ5u[[q`ˣgG?5E`@s/5;5IQ_ƄǻO2sHK5"T#h-YhjٌQ$)<Td<!Leo=LM@&t$Ee5zF ڶBid8: @  ЯA黗NȊj(0)\2	0b<Da&n3ןm/X&8벢R41`  N	oFp0݇Cb&pH"F6a(a{X!svoO663մ}ZH'E}wl[+ĝj;3&XP #`=
326o!<ؗZw_qt	^wMҖl@!!Ӈz>
RQ77c(9Y%d2څnqO<hD@7d䊅̈NgG,hʄZ}1i_z~ʽ%lҔ8e	)Fh 6BOC
᜜h&.Uʹo!PtBp!HB"djzwB#^ݶwa-v0GۊŚxdE,D-ӝcpݹK7T>Z} -	@D-FUƭ˼OGmDfA-.7{)/Q3gWB)
¸jD'I(8q$XRZdE_7}W'z?n?4`P'[{c؜.	66!gA: VDU/"b@q!k#&G](KF܇8 C Qlvl{WJ-ݯm,̚Ԕ"Ȥ/o45z hClD!!uʀ\_.%]Hd{}nw%3LRf8|yL%T"1P6B**.<+Ϧ>C'3tN=^?5mUb^IM qhN	sjk#Oć@^̄-U
P	+ux%uf%uX#_B^z@  -ph/UU QB5K1O&VTP:΃,:/DAPw=ˡ픅DPGCZ`6hν6w>ܞː6B=dwWnvCsl;ϯ|?s[S|wѕ%Ꙋ	C5uiR[,钟qLbxiRU}[[Sh_l91)9.u6](锺Q;oBZv,4(@OHcp`tpc~ÿ:$.Si8^+2
,Ta*ZxTbiE`aLa9Z\D@7<SM~qާ3%]ʹ 7VHco1$((hT֒vӫTmTCVn+[	_s0 B(Mq~gImYJBgű0y?|UFMYú7bgx/<.Deud0,ouU{p>zځt8z EΈj@	!hI^)U&,ap( u!B4Ij,ıӗgY}Ͼd'Ғʱ[ֆ>|QgU	us|/l^~knqk"`e	F6W/)im O8C HW~]iݯ;S9{<uaZqjBG@_4.$fB?C0('9򲛓Nsѣr:+ y}h9q<[
,O6'az_al1kdraˇ	˓X0cIxP<-3"RO	L)[a`Nz$kBʤqpO߲Tj<hx`0=al`6
qRw_#$BJ9.=<Z~ϩKU&(<;ث$Wќnoŷ}~>ytSCBiN3.T V]uů3t/g:Cg	x[庥QH|6``18dܙ39y![#Կ|v^eC](*LdTy˝uEtunzlv@|>p!]?ۛ<i 'vUN <oh}ݚρJ5v_-BJ@%B A$1Zh(p]+94KV	l֎䉏@-ʇ
Dz\5x2%Fej,e+DlcôgT;Lr;{.VHPHCbQdMǟ5wm-6ٚXJrSr ʕS{ݝ!pew;==o(HqZ㷏mT S-+9CYmIc[[<I.n}~ʌMWX 0") YX$9kqZg/'1SlHjxŖ@_	!B Ծn^#ZR!gh gR<2U ;Yeo<\@0<vl͙l[.8Ϊ')m31Og)bJ]S=CM&_1޻q(~f<izNH  8->^0B
aHO30t(J~vo*UrW{Ϗ}"y¸~ِ<o<MGix!Kʅl,@6@$=vqcOp@ tl$=B,$ ~۰$c4 )R
sc$V	TPT٣ezAmlYV0<!Tu&M74 x|ۈcBuR(ňK:[6Hb}<0# F@ayc,?A~%`, pȜ
0	;K"v5i%"ɇ;*9p*eAE3jz8Mt(
`|*?~~b;U90b^p&1 i3.zf7ĺE,BRTiZmAPC&ߖǹǭ·u:R;}?"64|Pc?v]-,4hI0.@4#G$Ⱥe@~
kv:dmƇTAD.{;4<`*8JK{;cf^(cnM3!fVKJQmiEטV`|&˹^Otee:z{/O=d4bIJTF  @q2{U/t-^/>S! $9y+2e>m-(m7 XNfYd,Asz_AP9r'/N{vm ?[ljGH(Qe]7[L *6ءxLH*1!bu1$ȖbZ$)Ra%K0!15 )rvNwWs^֘OgXc+v*DlPO`>΍tA|h?K/.n-̈m.տxd%$KQmuRfrͭE
b!!Tol2H`ghMnEsn^O?ĿѓFSf[.6;>?q83aϻxÖBڬ]mlsnjbӨȐRebMxgN|^qh!YjwE,Z7]W,Ky @ "vx`h9ǁwIe2/Qx<&\*0uԁPD2},.4V;::laUAlxV5BYW}&MpI0J 8]
90Lv-5P/5A.yqւIDj*95ɬwz}\MآΉdN{p00T0a%pu[	W"(Q^]6_GXc`XF܁AspPZ!ӭDTp2KK9))*)M4t$F誡e1i)<Fݪ~:z>]fDvZOU,r+]O"Zn~_\,Ά7a4U ;cPjAK("%iaJl`	2I
IPĉڣ6'0NOob
~qfMe<G'xn*MXV-B*I,m㷘.hjd-cN70oE"l>
*
 L<DDqL" {ѶsxT	giw+iQ̆=TH2+9}թݴo_qHH!XRU'"P4@cZ!ruGJMbhmS,$T$SZ5n$CrբM!lG&$UTPhRsz$E s&fbYDJIVNR&R&P<qxfXiȜ]+-1wŲ`,mf3"܌FQglc{4$kdf,S\KrBbI:56@U"OgS-o*)U8"ݝղ#<SpS!$@ApZZ"FN,Zm d+sb׸%*'WAd[lORYf<(a1JIȱ]K/bc;Ήb1Lm5-6'ݫg4|i ]pZ*+X5NY(\5$Sh6e9%y
ʠ!9g"JZK3JѕqZXH)QʀEX7KҶti3bJƵkZh8R.&ӊ94ˉ5$)CwҮzD)I3ΕAP<2kOi{|j57罒tn.zR}?Z8irYޯQs:ݠgCUvFBc'|3
UڶͧiZBWrNyl֠bfޗ7yxSF7(6)\ RU"XBLq8'؅0VVq	dϓ4PHp3!ΊpgR()ƏKR@d"]`>yBN`pDQUjQ*At>]V<ZIW9 \a#62&%P:86Rt.R)
Y{1!4i(g8M	h?FZ*2ٚC2U9Sgl93JQtswVӫ--W- +zbJֹŊ7
Y&6ŀH,FGgvɲД"D`1z֤!ItxTx)
 ]q$i	2FIa3 z;!/нϖ>c}2林OĤkZ	Tdϧ6mb=ܱu`hWЪ-֜ J`具<P&G@l!b_
=21*`X6bl!FH(~	9y {Yz7[u(A1e.0XԇFՒAs$)	b62#=f/h5^8>*tKBV8l9^BK_	2x1 w  AHd1AbF	I)X#*l.>&]QhfYJ@H2&#?!{<IŧD⤱ZcҡwEkL:=D&2 @ 0 4L5du[kc}~8V<x
i4`:v{ߘn/n][<YD6J %!o z4[y9_;uPmVSR$VNn\,ZP*{? Ȝ` sH<A9P1He3樹\Z.l~$(pl
jb&UץRnXDwgzf W(4Sy HO5Q`G$OP+" )L20a(3j;=}=o-WfgQSQ`oP[sb`Ii0%kcR5 DPHPOBl+/q.|"1zZܦȷ{>4Nċ M!,_]7d@`K,]AHQP*K ]踚shihk:{GԼ Fgpq:"U:xN@֢()JĴ;+\rymkEճ&d[Ð'2oͶywiooM^P	ɨoI00tQ`c%jCA}m]g[3o@*RBB(!U%*v%BQh@QAT    
!]OeWNuߴ.lX>C--qEA;~87܅߻rڝ݈՚=j?'J@ E >]t"Pe娦@,jɳ?	ny=3ۂ'<t8M[ l=u)aއz1^pA	_H=XM{ziFYFs0X_l=؝	<k[3kgoeN
{\crl ٶ hf]ي @}䈅㓄.xqB,ڃ$rZt@l_ˮ[#D s!fK NHv$b5AIP	0Ȕd	9t4y~[/yEL2 K̈qAAy	00a9& Iv]P[e|?|}%z4i2Ef39"W,@jG>hO1hnaqC_y}ٹ:৒V..Ջ+"ʑi[Oeu>'#*ş5$&e85Q%<#	2ϖC ̵r*mhLx\#Hq7{z=^g=~˞x807?g[1&3KQ-H0S=_~]8*Z
ܑsH٫%EJ[Am2aY`XXӕ.$mꎏQYqva8?3ZX1S`ŘV4kv0b@BD,@Lͭ8c^6ŦdƦKz>ItܚD|tGGoo5<"vs,
E8kZ&@V&En@l=#6nyH44 OˤkT/(%fe31VP7[fi|/Lix^N@18Z<.7цzm:#j(3*"R!,-su|@)Ha_]+7}B_Y\`KY/<Mvx.%p8E;j.-BڴWq_Cq', mK3{TYn]*Vet,$i)9"ao'6zwg$Ф.,S F. \
Ab'+Š"VbR0U
*94܂*xp Z	K$)SB
5@ Õ]PR/b[/1Ccr"ST		Ę`Q!U)LPr~S>R$Wy11*.iVU:;d3J*(,<%'.tnpm|Z.˱9[fDmIWZ`Rc+qķ4{w{Y!/P)lDq1߱mnza"/=d Z7vٷܩІPMv%	[>卛_]+mL&I$K*0[K2 %8 ̘-;W3ŝKLFmi=5{ӻlʌQc"tF,Db)PqۜUKvB='`)<UJ<clcNzݷe1A743FuhJNcUޓuR87KDH*URdJ!SL`Xj-^	R@Z8IƓӁEo1?\~}o3q]u6_~[Ϝ?"+Y9Y*LYspTQ
7hEHQNLA@!hO啮*T"?K~ڠAh\g[8%]J1_ol+6Խѵ=<\S`  %Yyhof~| RX_֞Vf8G{ILrQ`TI`ϗjY<acst/MdwIlt쫏,)/*|S!MJAE$ȇIE!@ĸJ`(JB5H@ZͣHZ&*zx:}ZXNd(jK
ڍ節R%mL޾VvGnXpPR$I$0]|IDFRI~1[l^C8PLWaX"J~&zOLzAd+9FrpaE ?|n7_EA^y>BTa"1 N"Hl<AW 49[ݶvcGNq9?
끭%-T%'|PQ6F0`# `bƗ\%V\%W[n30]4kVSv~,ϕ!pټ͜^,C*Xf]Ӣ?e `t@#E C]'R0('՗-."!V5_8֦NⲸDL_ྀk/Wge5G}
oQEQ+b
@zD0>{+ZFi*}L@7]icȱqhi6SpH1t}~?_;j*]!kn|(6p0^[E%s,&]x<&GKU7\w݉2xM	^ekMCDB`މ we,eRu}ф?}  @:Q##E~>LX.aD@UH (N9F76FA9i=	5?_JCG9?] ot2&ԟRyOJˠ~QG#g6=2pC\$꭛?C1c9pX!f궎n\k<YG)>z\ݬط:Hchx{16`
E9nI< dκfq:xu|ŶRwtrG^JG
R2=",v)^NSB2CKcj5BJŞRFmE3UuY~un m'bGJk.{f,Msc+\T`ÇN
C(Usk+#3"	طL\I4UhLm.I >&@Jmbm;NƬ	40	ܶGrRM0]|^u̡̟^ELw<1r=:0rS (INeAp['صJf5dF]ǝo`4xFWiyЉ8᱌CKhdϱ~wu!:A4RiDJI$$(&;26Yթ1h3ytRnPJ)j@\,Te$AeYd(3DYR3ԋaL\̑#چg0!DL)ZmlKM% iZV;lsDg.\n6vұtjJeMw̎cTIm x 싚:WHSB$}9wKn%X0iYOd`ŲTdSC#cZeB+ئVTdl4v῎z7\*I3u$wAo9I'XS+2I.#KW0AQspqe,ry+M4I#j.LpTVёdpR %YօŜ癗\1X\ހ:&o- %tȒA%3zSn^MB#%	!roH59deI1)fBvl@m7\^JO1wJ!Ù7y^d̠k"I	fA
5ɖ't
bih$ʜ$I4Θa2Uxw9<
xhU#T&J1Ywvc䥢%t*#@Y	Hh9NL)\u&v	yJT/ZTrTXԅ+Qѐ(rzxFRU523{)3&9b裸E(亊Wꮘõl0D7:ы[A/ݰ؁Jb2AѰWr!f= @}~H F#ϘHi&r.4$BdD^+g8?'Pu~}4>y-9:$@#6hoHyrqⲔGŮ(NwkZb戵X0A,ܙ>YGB06S=?1W;8[TbR#iط1;i>	 2 u.u|&=d&}cl	3Sˎ6C˜<2i+mNH)0";5\xn1"O9KG*?in~H&.>âmtneT-B " !K98|M6d(32՝B 2Dan7f㐘)'uYi	1Y}94KH_05e'?OLx+u@W:SJHeo}G#PA$H>~? ojsl2EBf
	c̖%6Y}Q
Y
lTsH.lrhNm8<mx[Qٶ7H<
,zܢ";)N% =p d]}:7=* շ&ڙeCZ1IDr#GSVnc_PM?dNftIX'+cP +c93D`oU4U~~_1agr52_vIx$utd
٠tpU84Δ@!Etzڳ_'0aZB1;x9Siڅ?@fT!b+&)ae51ZPYGo
'%[NXhwPxT8@yh0.y~asŬ/+*oP{>m9C!ȑ!HB@hw%\L`аr@D4ƦF^9v0"` >۷}oѪҌ\?eDm<=^`!IrX{B?o_/ifPUH7)+63|+"F	K)C3^!3AV/9+Q R	og+\resww37D.XD~ΘZW-t_vu؛u׃e$UVnvfa|9t]_ug{Pg34NE[A	 hPq	'0&l3Gbp~Wu_蟊؋$o`+BB8H@qɅk`tbu4BYZWZlKe~8<3'ZkGuK`mPƳ`Ɣ-(87$hz~^|=N=.[sX5nyyDzz9'fҘ|FK~J3Zd2r^Ǵ~@X00xƇ`f03innUo*;ӏf0гb* ;PQRIJY$
U@'/m=[.53|^2>0P4qEBbѣYmFc؞@A{Bۏŏ{i,Ry1_/ wᐜ1%TbJ`
@(^ڇ4i߆ַ{zu]<ŵT9!1v׼o]]x^KlT7RZS ;`	Px$eK
|tg:Ýrg aRTZ%HBknWomz]-7-ezoY[AKM\8Z,"C%@b0, a^S2f{4]K}T9ݎ]ɋЂJAL`LVZU7{W.g6"27|.%jHw0U>umzv@tm&AQ20aLQ(bJTB
FË)ML/K(!fcWs縓獪	7x,H%}hqe@0cuz6Kq/3@_X|Õ~Ä[+!,[(QK2AG$F,Csu_XW-Mڍl6VęC3t!aWhZ^b(,DQADTd20A	B+DPTTf 19vT?M\ adFI"
(
kP -"yCFxdc r%#,QLm$#nqTgK z})*RDI8Z'9H9p(ȷL$[`\ @Ie+67w_]Jғ\..Qi fq9Mdxɷdj̓b_Z4V1[i`Vf1 )BvH&*i 30닳5_	!Bۓf!<it^qߛ?qko[mDHnrz9a<=[esT,4nk`:rɕ(pAHGmN-,Hw)C1>oߧMӻt% ʤB"҉]IqF@/~.`Oy'v	y؆/S?ggUyUso\m]@!*9D"m!S3~ Z}A^XmFr,`'b׏+~ی);SՒ{;[,&8""H )17eNIk#JI=fo/A򂊢J`SKP}eBЙ02~#34vdfTXz-n[YO\;_*PМO#xxKp^\P8;r"H* z<N@1BhH%)It )zW6H)^|qcc}8ԯ()ܾ}P.aӧ'H(T)P	,{$ h\LH`K.	
EK2%%P*	|\P()L PI)2T( 1!#e4}ESgD#Div9}n?e6HLSl ZI2WLѓaVG0_`x,~'[K͠dؐX""#We>EXγvkoh턛KˆhaZCm!ȅ^R`?.5V^vb9}<bJ\뵽ҝ!"O	Bn*5 
qeKlJΤtvI(Glb=GBzz$D$#u*ט Ah8ek(sxͰf[&@)Y[6~#|96:޲ʚMliqSwBk5dcqq16prR pY%HA.K^<1ԙ|_n>4'~":Cq`InG3cXټՃo Q p@-g0dx;,
C2;ӍfD
b38d'1Y:Oq˖]s0 2 n)\}G62ڼa=6syvW.ySD+Db6 BDw 芊F&tob#&zXܡ	Qº 3`T }!e}!qEr؈tYdT*5*ϣB3^u'&޲sBgL&9*9IRidH󚼦yjZv>2Rxu&t|/SaBبTmʢ:kwTB qƪ9EˣI}h[C쒌Zw(׎3k)skDS5M1t9Pפ&G&!X9@)t@	I%w.-ef๷Dז{wܳ6K}EBlT-g{M*T~=gIJ{^Y>*SĴg9u/ϠqhQgșs{8?H
|nY^Ly%b*->)<i98JӁt8X TK:[62
PTKR%1Cq#J,#OezxnVt6'jnm"`[lźCEdHڞ2ҝG\ĦhdGE	HHBd\iY9` 8B;ޜCven*e}Y}WGj8<e`p^V.<JV
i+p1ƐxϭO5ɞ|wا;HʞCO$gI$GT x]p̢z)}Ш(r&tPXLGyA%!p)vl;Ũ]啸6˱UeVe(*L>۪dݼMFz20!s15DUcX͢4W}շxv=kPͧsD8JFnlS|BH4J}T2-XƆ6fVWeaσ[Ý+:7U(7^|'p2mdKǣGcAs*;Ƙj(
#縖\Вr`5Gc1_|zJXb踃Y1j=)9nی~AR&)'eU?$n=#%9`Ho72r
aD0݊0ds~smhDY#sYR-D"f	4Y\]N0(V=ق9mͪ\WnUAbpN	˞-"m/v|v>,L+KZxviJ*ҽ&56ݸƤ<fbB#J0j9e#e)[
bWd@duH`rdBgUN [#8UIrv͞g:'vjD2KΕ2i1s-h<;5UdS&ƺ+@dBD!:NEK@9i@;CSi4<!#4h$T%?I0A];qSj%	vyU*fD}iVl+PBdEL)LI]XBrs9$7DFe@^Mů.XOӼfVI[WgׅhVݶ& ̫,E'H[t#nu>M:mܚiLoG,6B%-%-%%WC|\o{%r`[]r;gwKc8l]x[).T	z9VÓ{ԟM\kK"NӎcGF$T=ٕgrعٹ-t-"$|*k:ȪWCI52J˪дϥ(ވYӕ\-+.4+Ft!yxsvEv_fΩR!^o|gA@PG/O{߸ϵ}MdZn$Y	o%7͖=&ڣ@ă|3g[-O{w{}ᓱe@QN-%o4	Hq[sf6 @'B;dYdE_'۷M7[=t'yȣzJֈ,u&η\P_,!In%}vf=]Vgy`=;*c$GTd@d͢tSV,NKC}.E,>˧ oJ  {Y3Ra\	ɐAd2`RvR԰{?18ucmfezn] ߼8UrozMf:oܳ3Ȍ'}ߺ_(Cgd]7ԈqYTg2i;ڑdE/9@pr^,N,!i V,$ [@ KMR]V0H'\'SL(8@h땱2dHB=0U6?;3D D45Z0
aܣN5 ^1ٝK Z/'me2v&.R+9KBJɋE#AD FF;za*Gy;wGB4/&e_:K#y{)b|M%{u\R#|z||<@D DA!K_g#~y0^d	jc:|AYEAIۉ.7DA3rUoTj}1Zlp$rB]|Ƭ\QԦuF&9^srJy(VYSAk"V@8ط`߅w?]i[uEkH :G!"oқHhd2w52'w~[mVDC\z;9ya"A KPAھ{y¬<v![ii)TRzG~3YK$AiCw|v32dS&}@Q\Y{UUDUUUTkW\SUds8Rki `?#AMVygimpNr9zsrQ3o`\(cPI"A	1/^]k";1F3?׺9567IX%%t?h٨{O=i A@.e6| sx2ew14Ǳ:&	3r EK}
ي}M́UFq=Gl=38{Ay}3=^91}ry {Tp~hGq7NU4IkOM	kp Lۨ)Xv<mO~_9n?Ef\֪jtzAHN.xڎy9ۇN0͔7A`o@[ݝ
lt I4pZ< pTR0	pLfLC`RL6pΣ<,~'c\>a@hacFP׈	ffwyOkG,ܟ]7I- g5YLU!w.+yS7ܽȡ=Lԇ7aQX3 4YCJ[RS4A[B-@5Pohp\Ӈ:b90;"dȌMCO;/Zv6r}[SvS,`!a" (nYC%J@ m]D[0D![Y/0?}Y]˼AtC+iU 2])a
+{@(4\"ҕg+%G+ B6"|iDSd6 1@@tpNA9k~pxz7Ꭺ=`c9*Iot1z=j`8F#}]xB?)׷2j~V"` /ᱰ Jza2bq`; h>-3_ ;GVnX*<cß^2pŒ+T'%T$" pJ@PxyC dzTRw R}Z7#>|R	xBLLbDH#> wb=k5*Ahq~m>7#0<gP6U%wW;t| LTJwy-Zé(oHV$-ɯY(DL(*s ` rbZ<Ș  M`"'є.(5R[sI/%6  x?`N0gMV
G+L,3Ny=|HȺfIyr  (ۯ#4>PU\+R"">B91JL.@/C8kc0n{ >AQ(ov7vvVNoRܯ*:\*k99+0`
l63!q 0Z? ,('S9:WyN4"/htZA~TqXz,poh>N@6K@(2!5albC8!!rS%0?궾V_F:wN

/L!Ȓr&5/ (+b	)rhQ9" kJa,vbd.@V ວpcWCBL05XFx.YVbbጉqk
"R<jhThdtH%6Ωy0D<&4 [3"m/dy-tΛrKǰⱭI.]ԯ#qhEDnE%ع8.4ϓe
ТcH[QѪA %{->*=@`&fGl$5ұw'sZGg `hNig]$7	 fDpT"U&furY$GBXϷwW0t"6ޢF;K3fQ&8iqNugZ.MЛLo>c .`.`=Y0#!3˺zNȅu!8nG_#8ymG?{ʇ{&eM&*ai1͵j8Q`ڴe ;& X͘睱4j˶Xbf$ͱ+&oڛe?`&î[3j1Zz:{^C³T	cQ?#{b.=[3䠺jR&Y[P445!9Egb:J rsrꬆWeWhvБ!$	>ID' [{כusM=%x==uDA%t RDP0"1H8@& <@C6`CK#f+pgj6Y<CbZ*6*KP6_}؆XzX]mQ.+-DB7ѯ$M1i- -37 Dz$Gx΍elE@;2n3ml 4sZf6Qa=HY|.'_X: t
n-!VZ9!ÛO7[?,G
0!mɧǜ5XUTDOks),Ne/yD" H/jLCMg" %XXcOF䌅#<mT7|68@5z<P@"!G8lba E+"jvMlY~8w}ŖCr_AėBXdpOF;O~ܢ*yvgQV֋
 R!5&$F"O`B*	
!zY</Koi÷C4 {(
:'AɹpZPwǝ%ӂ4w7]/}̊gG3WW'Wwuv'S!I=Asu ~deFpBr?aȫDim_"pt. P#.bw`j03D0-`1 H*q}1| D@F)z$ +3heg"&v4X	^$fn\n*Z@Y$rog\Lؤa'Ph;~˺#Rv#X0)UkK-eWj֍H2ĨSIfJiBKx[c& O|qaB"QQDJ)V6|&iV]<вf 	BF	ǫY)S).i唛R
iRҗն89|s3k2,_E`t@JT*#vf,p!4Ll8p 9޻?kNFU%F(^SBh Tȭd֡`D-50DBdO	'
+
4*L0%I*Ϣ
99޿Fs\x]ȅDbRr$F!*ⵘR[8;2r!}s&ܥCDS;o&dᡎꅡݳ޹gBWMSz0,I	/7u.`u5ٷ1y+<?q@TĊ(QEXep~d繎]|HlW9$M65Ymم
%JUJprW9 YG|Q8'%kx$fm % ` 9K]K4&$iBF7"~4Eܽ0/"$!#(|Uǖ:AN=,QXZX&<qD}< mM(<@}dҭ X~q,An&(&;@ r8񾲐@ [ i N;/b'|2UtN"\d%Ahp{W|Ix@ќPӗp¶rsx 51rvDu	#ٰOmurp8@$v] 29xv8ELb\61y:@ [NE=Hk@|%lSO:1-d:~U;;l3SD%ml!T*xfV̎~5(sCFm ߀9p|	ɽтX%fQ	ߚ˩Ь!Ǥ.]8#4mI$I$I$@DjdCōzU*~sQthz:ub\@@;"!P``nиk!  i J A D6UZc@4#,5<=1xW>KfMB<NN6&x_Zkv:#+Uj߃VA!vuE3USAYOFN`>ɸoa:V_ b& `cm>!~[iM&">%w}*@	qt KDD\c9ѡ0i9uq`*mW{nځY`&=tl/=:U4-L+1qZj=Q]zmMt 
;oF<G]}<qhe?9>ss۴`!rz$ KMĦ`_kU\qayWYVŜ:_xJo%'9U	L:@^@DL _+=a|70D6X)_k逇kf3zC!!Q;f9xL!Iiq6yA!D&^@"{ᥝѓ^$I[>J9;w]f{ˏ9?wݧHmWûwUٴdap#42229CZ*SAVg Hd.O[KXGKD'p9_C `|ll2VM@R.җh0>{>Tt<hoJ敎![O &8lA㌂ ejx Aq{2q}Vb)䶼L:-h1 -Hj'Gfݐ{<2r л0@]/sRwY>Ce؏Fy$[ipu5T3NTu*%Is\6(t5Ͷm>6J7٧(|FS)Y2ȩb"PZY32_ص^x5ƎI3\]iReaxDٖqEZcx8+cIo@b7A'i6	Ep@.HP( AnW x\ 9Aۖ=w39E35_(^O=nf#ktt8!j rͭ3"!n
zBuVش~s4]6"GWl`&a5{K.Z%zkI1f#b#1~Ww"A%BԻrDAߖ\5" s׽,=| #2Ay ET\
<P2CzV"Ó\<vXʗGD(pA\&-B[u}4	 lq.x5ߗ1y(o9ETc	}KEpu%u[6p1Myf P-V>`!<^E'^k_;湪ˁcF^eۘHDBM)HX D$$$F hD!r 0%_Ev4WWkk7/=׼yuXtXDXw9NQ_%ʗ7~jE!:?{|͎~\|o9~Egʍ+OB=W/mqj*!Ɂ0˵r#'|$ m-0qn3u\ir<mZw*	T`$SFh |Hp(3VѮhKWg/xHW;.CgX.Kc辧OdDXhЁHbA"y ;$ӪD,XV8)(&+鲚tY0UsB6ԨdhP
P1B `	$sLJbw⭕D%̾L,pXamPF@{XZ^\N >jmR
edM<<G(a(G@DXbEZ5ֵaddKfBa=mBDw#^m5SrniLj|ŨXDy/@.	}\ihby׆3yt`&R<z=3|Y񕎆07wg19yD},G>@<s1#DN,E X2j`T罽[.
j!CG4IW$jk%(U1&6b9	l 8 FhmD89_("nHqhi'"H@]&RW-{ZůbM h$@k2 {Ӂ԰ewkU6<{QCVj\L&w?3TPL29 >Ôš0ǨhĂA>@e,l=̆sN5#n,hdA]{n1lӀ`_$F" #ccՇAAq
Ř#@y\WuP ЀC H+8ߓEH@i%Oda3<J % 6t`x
#|1t^)>759OFp8fxwJ1^O u6-,2(
hG"7~ۢ,޾_3g~__;|:ZyfOk#d%&ߵCTâ9z;[, -P{c le; B«V;}dg,p}1(SYICqЄNу'm$e9lB6b.b 	L	yJ2 AbzZ2J(@y'qb0dTCW$@l5]@f/ձ*Q(2EUE
Ij!D$Z[}ՙfLLAV3l@d#Y*`(Yj2FAG'd!Q r_v;0tFv kJlji/uqqqR  d. owT. +Y$@AbLmƢlaI1$P-MF1bI$IO
REE-@VmTI$ xh0OYAp	 )	yzD
DVd↚&;aPH$&١=s!djaU73%
&#BV!}c	[H2)-"S@ X H'zGJX'sob 4-1qP9$+n{pI$)o Vwo8&&5iֆo&?SY205$y+fjYv2jFU
RprglF>`Ds#><zgmMDB/r)j41:O)[
JZ(@<ipZY:_gɫlrP0lvVkCյ}G6u @߻9^u@qVF5+RyB@441hD8w sP>HY-U?L2Q%6SB`  5l]"[*pғύzSuZʪlOU>w"݁)@fynݮzĨ]P%6ey$T`<6Zȡjn
Kd]H@@iNz@}i ;B k(ى$ DB77Lc|41a^Y+A44PsF	@b͛*0E'"qKm'7o3ŃM^\جsy5mLʸP:[%[
h{}sM(obL!] ffG?G)09q9k5232>)Ȟ^rꓻ=41B cb""tew=mm6Ne_jAa#Q~kBY(<:7%(SsrAnks[slv'$ӡhpnp,ۑSn;mP؂mSD}Tc}%vǷYPb
 ׊AמM^|FtIQ%
R]&	`rP.C20YP$Zi+*HxAA5zE1Vd&e<ؒ:Ԛ6sF7gt4߷<?O;` Om(c4nfFZ
|p~7+t*sجZ6璟EFjJBMB l0Imf\Bk	w\UJ;1xJ=9b6V!WarcmwsuiOŊv)DϺ$shGe (aD@G`ZEn[-ϣļ&$Rʪ bo<|Ё{A@LUjSVr`9=VKixMq\<fc,!,,%Y5ΨnKL1eY)<Z XeMn]ş2zH 3C0# T9ĜܔR4Ӯ`o|4$Ab@61E aTQm'/L@ǒ°:T1"'">FO^:Y\TT9DRK{[خ.UiuvP(
b*s4/,e-gY)w<&hE
 sLq̈"7+&Ea%%
ˎ*AE繴r|;0B3{Ǵ?;!YÊ 
&7b.	p lC@CSI%V5=(ܢc:VcHC62N*fe_"%e&$-§+ߺK@6X7V(mJ;3ǤzwxHR@¿ڶ@9mv8k˵CNdP	BJ݅rd(>R])j5w*&GEPQg$ڢ+ ̺Pc j-rSyAV	^%yFcqEPdY\ۣkߦV4W9OWm:4c(V1}{a L ""'5?WX<HoGc -y:l}\0%F)8Q z.CY<p^٫-]p,Wr$Ӫm->99`5|\v,v7_JW<g޴>@E` 'hR1)lp)[h"#p"0d`B6$mT-Xi'$cēd4q
"1#$C\g3'=쯔V"A/kÓq =ȕɟ{s: aѸLʏ90[)6\彣YB2vR:!q.z` ݟ7w,%.qSyͬ_N=@FZ1~Zm	{ F:<<6u^BR-p"$@`q IU ^-U٤zW[x=xg?tpeݢ4B	QhE/5C2Hi_K*=M=P6G/QrȨyb YSg =\ҾX|n@rf{q6Q.3e5m~kp{ٚiCa5 _ڽp 0D;T,}J@O<CeP,Նr%WK[KwW4|U҃$={B#{@<g ]Z }Yй`8"q[O3ڀ0,\Kʵ,h^#   	z! 'oC8):SweIi^rP{`_q|\`gECr|f=srKo;~&Â7!1%^'w!hy!ܓp,0-&I(ct7'h1b:4[@׏+;l5DI ዕA@U==w(pMqybbR\%.3Ϧ"KlE w`HX8ͻ!Zfz,8)[Ңǟ6GU_]%K	ߑ{|Kw>Y}3O=R <dw4NqNOmǶJ fB}nWyO`؆4,[)o9Z]mKG6V#c߃puEP</edĴHuctg]\̣qAbHBHggh$+_@sx
dJAgDV*ZDk6W\vXeh٦_XNJUXAF+և]s0ηcoȶ1A>E"##𳡦Q||POĹjڿ @I/u!cI-]2qm[@AӚdmiEb0Ab	ϰ=YWk|Ǜ*kCyG62*	lWZ 6
&|@`_1.ii1-	CDAM`E Ƣw{αHњ#Hv$)iaH!х2@jsfqrϕ'x8!.$@
$UUUUREU`UUUXUTX(EUUUaUUUUUUQX
0HUUUUEE^qP)VAWIJ"UATUF
`ȫ"U*0`)	%%QKL@AFw@$<X1TQW4J*Qsmx=iKQVx7ǁ#X/7X);,t}vSP@ M :cA0	PJJ$	bIKHeuX6c~[n/]=ШuHk>_]["^ߞ^fa6OnswIʨ٦Ԣ}\L{K<$$9K2;HIY	!	;d \$e6P6.J\*Ԙ$GGWilgSv"ݟn;2wx,yB5s&/eL+zF7q o<Ȃ;R$Q1呦VT>(ҫL
?$ʷlbn*ٖs/Gn'͌J
 -҂X]:2ەWW>r#3s>G*ΖRbBK:sjRMh6r[!/;nE8lgO}w\¤lQ˻B.R;R廿^taF5m/$2cX#BHis;aB~ѹ؉Fّ *j&#weVjկ(fg\)> QN>y>&mv1EcUEUV
D͢[1kk]V=]r9?c7WQwۇ'Lwˡf3v&Kd
xX֋) !Gg@ (eSKvT4X;=8ݞGZ滪Vª(ehI^{PGeE	lK"F>(AHYc5Y`kNmǄAnж%0"=Do|;i`=k[YMZ24کR?Z=ct	`F$/	[%eI_5*}48}.o. C5D-z	
''iȤ\S~hs}jzS@T+g{v!ԺWeq	˴*!)mأf	c$L<<'y8iVsxShAkhH݁륳8Sj18IP^"QNBX! :T#E`z"6-R7\TPx[5 4 
	"ܥH lk:zZ=;.Ҿ1%a\q	5l"Q>K$aGlF8CqMI׵}C~t>9!bygi4#gy}H40DӀ朅&Ӆ\6%[;H{
$#@(`Mݜb	9Fs@   B 7hعQFm}"l,=_Th"ϻ_+׶w0p@2GGs*׀pXT|/u4o1F3f& قmps߁sفi~"FhĒ&PdLIlQՍvxKu+qPW{C?Ӑ ~C%܏%r|/w9r✗ $:J晝Ӵw}<yIog]$rrYyHI0Lfv<A*Y;<X>EjH3t[ب)8{>t~?o}ߧ+S'|VXCpJ,Wph/6zwW1Ϳ4щk[|T:4a-C4rCWz&{6_#3{,S$0Ih0FrƦ]-d3j`JH\@[Pe/pJ,LVvT?zV&9RxXנ "#},Deuzky_)z
BԒjVcZBLv?.>K\)p\
2cҧ/z99_	i4 S 2润i;p8Sw9@&Xdtiuqӏ6.9' 8!$Guע2-WOb,Б]o;\81 PB<mJ|#ydX
9l.襻yڧ18\%\S#%~H&=FXi.nsj*TrH \H߲bߧ*x?Z ,~u&jz=-Tm2#>,2eϿp>Or-4D{o+lr.r'(lF<IFy^e{~ozJWI-JoW&]^#l܋]9/.Yp\gY(bSMppZӅk#i&z41sO:(D҉TRŷ;p"IfTsU&x*b F|%܁EF<UWI\]r!!lKko bl`υT)40R´ILP9gÏN+hЌD&q,6FMLPׇ_拐;y"0]D8cv_vKK>οykNؼԾ\.pX5A́DWJR!:ʴn9ua69$5lΗo]ގ[ÐCÝͨMv[xpmo%LNdj*Itk%]uٷCv73uFODp"{lbv͍z]pjmEZU$\DclzNHy"<s٥w_y27Mp
  zlń(@xW]lLዠ? 2lɓi}߳"KKiFͮ9Yf [ğ	lDEl~0ߦMV˲)NM1H fQ .'OFl5nu=אa;2 
8 TDF'!ס.E/g/fxX7g1`s%*gwE8zNvp|5S:t9(tUwT;@"_  7>6cm#9*v8phLnBųB̿?bL3y3T_U'ݬTİ.S<A r}Kr=#JQqbHסsf=k]L%$V1tQC y@-}NER`>>".iwC~a@+0Ȫm<;lK~vHƍ4)B49q?sZІ`=Xtǫ2VF-- +F2iv)DP@DҘxꗭ͟ψ5'4M 9` DXOj[COK1GT:%U`:y\um6KӅ֏Qsv=ceyrE\9[V-L~.Jo6`P uj7l-F(z\,$lKN2uogއo8@ ډ] EvÃ&bkOid0y\cܟC4vz044`6Ur^5Cy<:D ҀDjtW|mQ7Q# Z&@|%J$frо6ʩ|̱<$/`K!@62 {t^ޅv3ѳ/qr"gLNP$0x#-)()YӍ!i=3O508]yxxoB|#c6OOd%.Vx}W{/&Ft°2
CaG E1Ѱ.-9(QB*R(
Z#oE*1`+RVam״7\q~LWnьED֑0lMv e?=MF,bi)RyT`(r5@V("4""r.$@`.ˤ'L6fs=Cwtgطٹ,j9q('.fK.fL|3Ml`nĈoV%j:e3.K2$&B Ǻvrɡ+ QBKZtڷ*{)KQ0qD#^!1XYAMڻ_A}<y9>\^_k/o,_1RVaW)Ie{u ί꾅'4첰Ibmf%ϬF/	A)	8/PuCjAנ\≍%gzmUo"oRt/(RÁƉ'{.6ܬӇїݪ&pq9uvoTHnO~sa/EmT	$! ̪+b_:"C@֘y}SAm@#p-$.h1]*i%]"K\.wQv;]/q=YH-HBD%+$GfXop6<0\3e%^x_hb]xBd;WErvoɉϯtNE?oVWG{7c}ٽ%R\Ŏv4KP;Wv{_[eRTOC8?=|reJOmå㥪Վ/)P2Hڨ)SvWkD,}yۂ]f(VqYDOHBx&X+(7@ִaT S"#vPzSV@"eMe8޳~HD	$8lu#qK}hNC8q8[rJED-UlW?bb;g9N'oJNԕ1ECFVj0hEw*46؃|H*!zgڀ0쨩wln+e?$|3Ss{Mt[f^>6رw~5&" c MAM&GE.e hԏ6ԺEm-nyNo<((0:5 XȄEPd8oL'*8vl;gZB 7^htV;WQYxY^X^tu[_᛭<{F<j?&]Fh:5[K-TK)Ef,:#Xu~/v[4c;=ۂ"z""F$V
06]jxoIZn6iCZ˼3yϷa3(j?x6gC{}ѣn3	ZZ
;EZ=Umwa?߯?' ô	v({?gE<mͳ)hʩS؟&ؘ-/SO7;?[j]
D+#YDhF#*e)S($1ש_"B {<:kzK|NP4h>1"wzZD9'W~mk]ͷ^C'jQZ/0/oڷf,A;5_a-!*n-RȢ-0OXľ,SFTRyʨ-FvJ$``x#%ex$n,uM>&ha-}RU"j)6-,sٲ)I\9mdws3>3t+a՞ñ\I$!XV&7S:I)=׀=ɱpz,oLGlטtEsy4
B%3Wvj~jI`%`I4h3j钨X$AH4U~#7E-$#pz<
`V&T/V{L:}z4(E.Æ}Wga32|S\Χ**N`A*gwܚ$@DHH*3$,Au ~D";G;{;b6|$'q}:,%Fdd4\n㉱7C3juOY+M%K!*4ЀY#>7H}͌T#rmi/Zqh%#Khl1'͕AO nxחlTL-q_CY";e$+X:m-aZ^omx^@u(1Wn=f%Ga@D$  ,23j
*@@[cm]lY[vymUwBXOypߋfYsOu_	M-A;fm@mUhHs:hVT?6u0vp^2b7/F6fژgoC{sI_~\`/;gobo5=5ũEW!tyb|#vH.d"`"ET3aB7}ӆws箈0A@Is3ϫb0ShN<-zuH<B`T  9jԚ:o}ۛ:
VG%19:r}g'K(	"v{jEq!MR`b!9]_Knmsj.0O?H4z"";exi!U$qɚxUZM#hPVb}DrJS=_=@8\qJ̳-S@vs^i !wynFe*B'Z/s4H27֊#fZS-d]]c;O3g	:5@1_hLJ( `"y4Ϲ'DGFp~3J)xoLq.b{\%NoLUlϫ޳_u{Y6e6ep4/DU/*qCz*YRbUm_Wk;>oQx	,(CG!]3;aKχq_Ѡ`#>:Rz"*
Q*7U©XOo4֚n<붻sBc۳q9Dq$0Db۶׾?#RfGyIp^yPB.68ǏOt3V#0\H:"yfG51*U@r+X!I945-jZW	wа|N@T4@Fs4z k'ڢsN1v3o<oa"E׌P4ʩ0B<bQ +rQIu
7u1j=P7W>iYJ"vYKŷ&>㒢
!h~(
PIԅ`Y|=ʾlO.10;[6/'`ot_3RMSPp=rY c /kxCaVVDߧ5\!l3}C]1g̭924
kLuDF{k۬o}"t\89&vd>$a-QZם)0-ХU!췵0GC'kdiHB !Ya(-	VƓ%#k(r[>\-m,E2ۙ7ENrL)ڹUo2ZKܰEĠ>mI/qp^^wy r`dRT_t2Ae[#x_O
p
^@z	Ae8Åq}OQC@ZKh]:iK?Z@S*"h]4!nÂt
 CdE{!p!1AO_!V=8i/gA$(L=#x߅1ϣ(܈BȐ0XNÈ@ߥD;"r!eVhtl-o,W+^ٞ@d$i>5l\9C'ч%hAn!6@3;TҪ!tKR ^"P8qtw)mo0&,TU%NWXXٳ^ë2dVyNBwwk6[(X` ZD=X̉qL,f2)֎[pC#_>$)F5|Z(81szȁ<s˖gJ3al6qVq
6{Kp(*ChPF+V6cK-T"CxpHۜwh*̼<4䘁Ik.G=Y#\:sP@0o~noV6-8 Լ R.2os\k-{FغX B軯lfuwڳu~^:Srwwc⬪ĦTNL^")K+r ͢PYZ8k_嬨ekWoK"(QL7>k-TehմaU5J@Dۥ
(,F,Pb,א	M L n>Ҙt8Jg>(51\䕭ӔiڱeعI>j-]oήb$еLMsb0XC	cm9-øַEzS-.v&hqͰ.+ *n1ͧmgsHWEΎ!bg|hQ&Rpj4  B3H]:^1Q:/P]Abɱ%{j 5Z|p͆FƨN3@M6-|C]X@2m25@ZMH$5_1Bc1\᰹g Q/=H1Lx%YN.Vt &-N;a;3'xuOR.EU+*eHE8-C	 ! RHK50ltu[unq6 jmQWbL.5
ge& !^`%\Dd32dA&Aa!KIiB ʖeYR̆.\hI.M#r9׷|vϯ;|DJ[o]蛂Jj}b/_
oFN[rfe(D'&e
St+7ޏ}dgWe>c5(e:O|cd"	"Xph[0i3X)	^P'ҁ&WJM8J~'|sbNEչԕg%lsӼ۰SrTؐ r7l3(_~!N3@m;/⟬Cϕ~r$QRҪLB]>}ʍ2CIAKV&T6+pJ@!G$hh V.Xp[L~!l,^dy_*TiӦq4t033LGK
bCeUWoB]EE-<d=jG3tN~;2qguսٵ).JDT<؇ʛ6lu[Z8	5
OʐHA<H%咙]Nf)uj8H@FHS6m~@H^$0lqZwʄYNFR Ʌd?ȶ^t8]`ӌ`ͅzw͛gVF<W,uvgE83ZiO|myxB"<+ec	ض/ڭ{׿hʙy5Bd'v>PD/?Jݭ|=[bgHN?k5y-0P`+kDv.e'/1-v1!H8v썴V`0H)cѓ0\&9E(:hy_6xoyHw5Swg	RjWgHE߆[\[PYlG	 8	(li! '$QQENbX*5mc[saB:\i-Z+Y6?#<ReH~E	=8;F>bZNDqdI#i'll*c"=(y" /eE""F.mP{ʐ/wڸ,uQ,<-|ݞUMs/!VccV/ OEpF qĒ4s9_أѫi/b xMxGӯ&&n2正 L !yr>:$H`9yeVX s-zSufK/D{gٴ߰|HpW
Z'	VyNNkN6c5{!Aljj<-C.algrb;dDBHtMrkO<I0UI3V'z4*_Շ@2,2"y
g!Ge&~fW?d}>FhGZ2I۔zhV?<`nvj'AԮ%l_x_Q%%AkJBP]2w
Ppfɱ\{=[laI$E4IIoyxAH.^jfSHFhn7/?[z7fxdl\?W|
YbDCEɉ*6WlHf}6j2eeb٩b/c  /e >mH=CEbf-CZy|?n~O}} NV9~pW[rŷs}p6>b[;.X9 S5й'zSn(4D BLͯm9A^qSUǀ0JvD `@/]_elɀ )
@	rJ&AdKAlJGhbN>>qe f޽A3t/?m^u^CKX<~n;UkWvofXVﻇxyވlQr;^{c	FT*(:Mn)3W4s@0+oXU֬QG,*FW뢬H(ZxvS"RRy|KS<@ڏgX"93r|u?e	}{ْZ=h8hOp8( gFJB$RXCbvXs=QBrj$.a[yayR-֯mw,;+̮XL,P˲^ j{@onF,x`v'3*tJrFFѮrkF[=\铳`ѲXUsp=]+te*gL,{6c*pu} 	bwӂ!ȂP3jeJM1 |-Ԓ>fg]i?G?xDEUW=GcZT`X,Tő\@qL-c=>3AZtQ,R	J
*O!اX@(Me]6{B<$ %E_<ZxV*EZ̥8d3qQ6{}0[TEEX*Ryz(QZFDAEZ<*t,§syb~۾ze潙h*2ǁnz?Bj4%տ(x+W!w׆x-dk5a{n;_ћnljx%|oY+ 7+c$5MZKr饰1[;kIkIٺഠzq;z]+@gj F8F-@L@,-d95'[SmĳI{X;9JU".jFrNskQMzoA0NP$C΢'C80=odm:-m;F. V3Cq(:Xb
^e.M[ܚz3V%ňwi:dCm!h.=2>%;vuL}#gճ?lܥ O bv_QW9`(ݢ-܏<gnbB `,Ȁ!qkQ(%@%c%e%,=)BˬE8BBlz+8yKP%)Q^!]L:@kAd6F6m"˶87{ΡM撌WP5h	[MVr,&(Xp_=@G#!OS2'#;uCA \pR`P@3r"(6prbɛƀ4	YHС	w9WǫmF,-4cTeyY6;FXM+LiB7-oR|c8e ׀ jςHCxrG+ӻȽ6|35L\bx?)['S_CݱzfU>oWXYIZVhSL	|P%|%(F j?_KkdWgil0NآAZ 0dQ7E=W'rO=?x~-~v)vGo7m3G7&X:Jb[Ȁ7m!zϧ-U1URa;9Tf"+1R=gNeU={0ySxoo}>ل*۰o]ÍHF@g} 
n
_;L6UdF$@tie41dfཙO`,*>g_mr7k?)%|z!9h8׌56x-Fzf9w$e
;9ހ	Z>E82b؋?p#펽kY

>yqePn@BaIl(4B	œEHV9IQ*L?LQ;*nI
"@{0I|kKMnբO[⧬WDvo>X}Gjۗ-Y`")HQ}k+vn\S+(ᶟxLj)oX篽IV_~,XNn	d+	~ZnQbVxnS3>Kv[&x|rG T1]w9ԧ˅>nm>n/xg2d$watհdMVP[į=vaŜ
ĭ{z I9xC{;yV`'iE1N?13A$6
b1(v8zXlog/R̼RUr{vl:7Ol9WYܼ]^4w+x4Wgsm/LLR\gCvyy3+GO5uWs\h}W/D7;k'F3eqNo땼Wf?Jԡ2q Ӊjm-e-	ogC>d9:rƈj%n1a31C2о,Dǃǩ#R,YValns{I[[=DLѠkJK+u0+,:.O}7>Cx1?Up疁6)WrE>4*?[&kB-9cYWCJ3Ot2zگ%3::W#Scl#\aEߕav㰥}v2>KT׷oys(0'7genk9`to[xnVov-7Sd*)Jxα5Zo|bf̽=}~?wnGC6ͶfXYPu_>{YciҶ()ܞh1F('eXzJ_ZpTe/sٕYjkV,aGиS{5bS6nsgՙT3BquhZJmM~b^\m~}^|b:sٍCY֚Zg9-c#*u,/	*oׯ~z-cuVz+cpɯY_Gi_ߨ:PiN,Y,ew!2t?OVB&1qC#3Ek@T1bTGE%CK{QHlr`"8<|âE*$ %IWtvftY1^@b*(D0[p09'K{^fWMSBw+\Dyr9mg?-ml lqy}ag{ۍK:{kH/ɼ
Ot]W]y?Z*SLߔ_lV&V:z6N5d<,}"qWr 2'rUFE &"c#Td۳S^
H@ٗB~yA"
rhHDA1b6<o}it~~]%f#{'a"bhx9ܶ+E<54PnlPQDi{s|uxh?hsQΞveUi:vgAuzs=j`-ӡལQ3Ww 9k2!UvtYg;]ViZLO-sm] eP'b={kJCس}zzHACE>3gpHBi=pkޭygEhlFF'5j2}AЊkVG b]Tk~g(>UnaY/yo78yz.Rgsa9|<?}Άՠ7A35;gSA1^7qz_O)w~0=svܷ 'X.5m Ɉo&@'U@O,\hpd ̈>(PdnOZdoTnƧٜbb6mSDRuwy)z|M2v3A9#S9)w\86l2(2Lާ/{{,_)~^=)հXor0ݷ<T|v¼tnXG-_P,vG$KnP,IdG!0 Hf!{hamC4M-ƻ!Hתʶ܈=qN k=*˖w?oM#=`^t[pI	/
eWÔu?י/+0TwA*O8/_t #jHu;]!ey=f4',9)vX:-4+1rR[aw׈#(<|vQ!1PJHĹU :
~b
mgTcDQma_silmtn+dtKMwɌ.{rSxUߏf*.૨^Nۼs>-gfi.;}}esk{ڎϿ{_fۇ#1`0]<F;:O3X[dڽ{<N4	@@C*z {σqzF>kyO?`:I>z,Q6|
x^H-ֳ\N8u'r~/lNڈG-~~(6Va``;Y]|L`_V)uM0}]U>symrlB1oh>嶕H?%Wx:,׺ـ^OOz|6[LK;yg6y]9<3Sw{xDqg
<በ\\fPCڭ<mGwzz1mӑypJ6ur8|ndxlZ4m1]:nw1-r܏cmt~ڌOT:g+Ov3YnE7EֲcNv}.Zӕb2vZejXp͐
("`L!p-o=Ď8_ˤٟ[[,ݮ"eVx`G~lDX }s/x,[lm'w8<2Wǜ*o&BI/,B2%"v׉Oe?^fZK;ݿSDMGf=^
vYZϕw&29;`݇anvz^byʄn}PV_/jܽf굿eo^n+o2Nn{c~ct65lz	-6v36jWN_G2M1wB@gBy}s<l6Qv޼jKbL9"0EodyM2dm=ql6~o|}fik`]߳?W]g3#f23Sat\{v}\åhgַݺh"Ԡ1l:	nA(ZjpgH#D]3Y+2W&FP4]MÐ2zL.Ar4TEet:!U\X\@]	LGc16X* sg[7r87{zt9h/N}ՓVr8@7jeYD{>펫du*fvܫl28%r>ntjl@e,;_s%:dLWqug1rX7yfu8wd+~z̔}0y*l{om{NDTO_E$ZDGyXng8~|C@LoNO]E]{tJC^{ld皲4P@NGs2mO/3Ȳ  JI!GB4Iʟ"b͌*tx~$I?p4"=ϻ.[kj4ZB/5\3q`Vk7S4uv1ߓ|q=d.-7,[e\SܿηÇ*{';=_r,[s]oh7#~%8!a(SW"8&h@*n'*0hX!dˊ^G>Z^'^a~rzױڛT}o+wy'9},e嬩te{[L䲺ezVrJݷd|hXbrr8<c^ڑSv65x?Wc..ZğIOq?=#%olbGX퐒 odÉ<K35;#Cǿ|N`Bra|oSkC.~hV 4b "@ j&pwGz\"h83TxҶc4ܘ}E]}f}[uT1'ǦP?g	r2J$dz;r&>zWڝ6Ezj	"(;e5sRpb҂-/l}RuvfB۳p;VQ&Ld%MGVM,8p- cgfZw{Ѿ@ iz 4)~y>#JP*h2SD
 s43"aAfZՔƂ[_8o(iqC:Xi+,;]#vՔ덡zNqu?;o.'O"ilHjFZ"AC4kuD-
ȁiQ
ND|:c*!4/2ZP}]vLlĈ߻a8MiJGEǀ2a5& [2
O6uF:FT$@dXzVytjIpcO Lbeb,!@5p]'/J,so@ǀ#(<:68YQ=s/L'scҘCl<"hfGڐ<?̀At$fv/ RV$Ai].&T"zeJ#hX6NfA=řgBӛIHC"	Aw3b#uԒ!mgB+FݏT 23*Gc?Xௐ^S2K?j>c9+vsb
Og4X1I9<?b7HD$Ì\]4͇gz>9i
VbBO1"N_?kt76ۥ'{xWQF9ynU}=\o_\3fݏ26@fIB]E_"$nn	Ni
;v!>1E$`D*clSi&']hE_G26*ETߝbj`5uܬwS!P6V
 ?]YïVg`FxٝGV^ B= R ~Z$}vEF/-	1ձd2CW%8ZVPeo'ȺC_e@!yiQ[	'@^tͮz.G1C8קqQxܗ]2<vZco!5a6	Ͳұ_+x[F2?㛟kE1jgthpO+KeA,@2BTdV?qs[=#&[s*#ȏrs+#:1᫷20PQ
'7Sd|%b1z-A8oyT{zZ䱪M_-̟+dm4n/rΞzZFzc_$L:(x:A! ZGůBk1+Ģx(贒=
z%<?ȫ ew}>m/9Weo%kC%if6.ZjrY<Ms^&,xCq Oy dMF;]!\7=yE.(SGE1/X*i` q:/`\rGO<yiK=iFSs.c^j^/}cնr8eEȓˣ~nJL%Q@ɱ3<dٳP*4m*2q(3pB H˧NǶIj{Yc2TZB_hX~\9X1.ՃĠ?Vn%z(<5k<N~2,Ub',#NySUٵbY0BY]t7ynx?uBb]ҵz.Gs5T#$rQ`!+C2<h|,1U?=V}IX52\<J2:Z$aJ<S?<߅E>R<QI[{aL<)ız'cv2jPIX
ldd5n*I d+h#ԙ#"Jrrd"sT]x xJ`#sݞ@Ȃ'ɢ-v-t$K(ļHȢ$M߅ߎ侰|zq؝_+ze~;bb,I}z*LJRmɓN=	*vCfC[$  ζW@TɿKb1՛{(nV" 	ՙȠLʊRHȉnc'2,r&
͋,sQs\T3SPg?G	T;yz?2g.spd;yhguԚ&V.hDk%m[~K3_(u-^.R/a0W<=сOJd5Rz5Q+tp4YzNQ0Kl,eɮ|*3<.÷sK9&kCQ웛fטoB_f\^,ݶwY.Lr-.e=־쩝$ȘfQ'k߄j }WgGդ<\j{gn]<+JPPkY鶳KJ	@7׀K)Nw]B|-኉?PW#!葊໵)h#ƐVԣtWz2#n-8| eQk".?UΗtzƾnC,~.&iǖq^ٗ8%/Y֦"fGB	ej@CY?Qˇͺʽ/pw~?w^)!3"1O~a6xaGSO*8f࣓
jQ,<+QH[>;ɖ7ZUDxXs!**c9Qv@]`4BkH9d"J~]h$`&^%AA:eGuYw<]B/}i-^?vx`KDjb\YxlT+k*ast
Ayxt,xow.,8k '=
p#<1tkӪ*Z.a>i |PĬ;  Jm;w%.
LpCxra!E9G-m.|[x~_&`ۋ/]lhxꙅSlF${GI@I:.r 9 YxF×$K^C\ǉ=|73˷fƮbO^i8ϸF9J23vam(=A'c@ȊYUwhw{wxʏf6h|,Ϟ	ՙy&X+C6x$=R+6KJB
i25L$3:~yJgwiƗLciGG#w֝M3,+f6}#+ry;5!_kK8YX1dvD0ZWskR̍wڶ.NnE3ݲfhUі8P=_k fNZR@7cϩv5 ={<Vf!A@˶2 \LLNqkvCc8-qiCI׳X^{uT5N퍵s&cW[ڲ,SK?!|ŴK<7[/yrC2@duλ?IF1y/#(G||愐S2&Abf]BݙE2[cWhTVtǛr9<4޿yvrD^cU5ZS5]vżfXs˷{Wh|4[zǭ+h7׹ܽM*rsz|_s~ֹߟ=]ylkQ8(7`_fe6;*vAAvWY>ޓYiP4o|{&g!1RbEl&1!DnOaǝl%Vn55a7\e96?|!9ɔ+@DJBc+K\v-	Sk߉N@wSYoN-mSnؿ[Wxwn7tkYW]Q>Wry;ꦪτC=&k'"5fݚN=7C4Ww9aff2-eU6._:Πx	fbhl!v: m `#$"W`t*hJkAiTvMOo7ۃ}yTjU*p8,c+Vŭ<qY`K<TDg[Hu{ueI+4wGJ(yHp{x`Cj0	8?"@
  5 ce\߈yh@$Ђ~Hzٛ@C.f+W'y~JoL_شٰc-Rb_Zauv=e^>o1I;l5Z^kO%\.99:$]|#VGF-B|HbqlQL)X6Ig9+

¡M4[!*LkD|K){w()aZt3_/p'ĽxkX0Bbne}bͪO;HWv_Oؾ뗲s>ij.ɨ̈\<ί߅9G@ SA(2~c:{NU0ʟkL )lr(mڎ@/s<>$d9r6v#\=͖XA>}J1cyv%fhȠ)	H-#1||nzWO&q=Ѥ͠;NlpUCa"Fgt<7ɺI|Trv=t1׸Xn ϑ"R0O{qyG g*f_E_JŅ9%Z~jxk3K6.۰:ŢWUo9/QvWN11TϱGi,2Hl8jjE-viwk6guu$Qc֤7"fg:S?[E!mWk1Wtں#QUc$b2E<)c[.*5.,ǔ?||=vw/>9l4N+/5{sJ,Z܂U+:zQ̼ʐ%p<>&m*H8SJx<aE[*fnN2vr+t
'MԙgZ<vnZi٢:Epnݡ^>i F[6$H?I
݉w4+!&!M['r!2%9T;'PEsyg]O-qiͼg)I'@C_P3IOc\{(&G;Ax.weק55]O|Ċ&L]U-3'wx-pvp칹շ+k8 ӏiMPYٗxM.zfZbKnA@y<GМb,jc6\e]KEZn陘xwݙ,K՞4iy+t{Mt݈oUDGa|vҚp ~:"Ҽ_(39CMdcϯ4Z͊N6jR>p+55xQ0 ءf!1:(;,yzp/ÛFv
w{yiX9&Ѽ܎J*,GWHGkT	-U:R 08<7gr0-ۡu6 _yEr=ٟ]LxnX]T8^2d[ˢ. 9*]Т:W[y8j";) !^)Ҋ.-{qo&h8Ex2lt  $8ٗa]   5tM:xWwfZe}l oQ>+ҳP3㞮W1/O H  5hy֐xXE)s͒]	*	Su5%cZ,Hm65yZo:^Nf=i+7iꓑoj5@6۴׍^Ťj njZ5"P!i2Ҭ֩!8/},)k,0-[I5'W^zA_:tֳ񉢣?x95벪CS__R^WIydp9E}OpClrsq81SŖYCPa  ˍg ;?o<A,ODͿV"~/Z50qy38LDSfmޙvltHH9P7Bǭ$X47Aok5Ay,RzK2)3b`ll,)J#|!<2-;qjM[.}Hciw'jj0!CR%iLNJrW0D\K/2	p/S%ۗ*x,.};PrEglZ0pfj 0e\H0bd<Wvg!SioѕD13-߿fi\FD7pc6#h={{4$˴= l#^X`qd>`
5%iwX]'4¶1`Mv`=Z"qΪS40BK%bøВ_mi- gfA6s?FE[Se2`9{oAyaj\9u^!<Vrh01agcRV2 hXΪ6no6Ybjw.nQE6BS-ӍAD1l}W$!d[VN<aTmrI(nb|rtۋ 5!gՕA֦qp~pe*̙A17rMkd=-s j1L;kPL73]Ȥ5 $e.raQWV[#zóϚx	^M0~nΛO<vljfߖkY&YLCHs/Ams7A_בT0@iQi8aPWJT$g!~(F8c40V`+ L碐φN7[h6DV=Է/	klK fܲ^Fs6rgZdx	åKq''c]y<h9vS
\k0ܩ*#pldE3nͻqlm,u{)/-uU{)B.^932&k`JvgMUTStU]2I
 (y^gnf@-@0ϗzԇ0\e1fѰWg_lDb¼֘aͽIK,OY&8ϮuCURUbXJZ26lͮ(1 q+9ɥ^*qJA$2&rGJ[˭3Y䊊 N WJ4}
6}^yDDZ+Ϲ	͞x.\\^!,*-:OZ4b8|:ٮĎvS4ra4UuXvlk&e-3(MrKlW#^\Nd^V)>KLxJ1)D0  +Z.А<f>׃עYx1*+:*j_WRYf X{?FBCHӻkw4fdkY>{-SͫWuЄZ8󎔇K]WWkyB!>=V8H\.58%>>ubEz (8+Im#ZʼAR93!&R[uPܴMbVnW7\e`  Y@۞nܼVWWZ'vbY{JF
[&a/^A4 M  [۪8)4\.VA-`}G`@*|]ujR$cYw' %_"oYǝF?Ofu|VD( I   XVY0"Y͝V(]pUz@贷ǆD r[ylص9' @."#A>Mە`EAr0(*(VK:6xIӼo b4k0YLsHgIv+n[=dR!5EXZY:;Mg"
H?> 	3evu֚%">_CgYxk57I$_^5`0D5 :}JVqìiM'LdmgPӹT뤽;3{M&]y	99[5e-ܢg5uD
cjVjW}.Ʊ g5'DuFg;yb_kUգVURl0Kukf/s:fYa\A-(MEY˰ C+W1U^È,CT)J`"bPid.Y|sKo5RMsyK@[͓T uj]V#״ѫtrj;ge-6K(35HuB~M[}KĐZ,6`]& #zdl*&If__hV5MvGZƽ+Xl+;`lT-vg+Qg&}`oH.KVDL5/,|Z-p\-3K;WV@drX%svVM6 0aUHg\3rZ,mc=V-`aMg[E^YLUomx>Qnw<ogyg[b-vPw}!b@Tz^WgC]L?ZLdt޻X͹kWzn~1+`%OpZf[!.Eu;V3N6ua:;4'pׇ~sO9Z	A`<uo%tn,j|#[ǷT h%u
xє-Bv]Rvfϴ^Jx6h=`g;wMv-BAj&ú_VHf^1Uoav-.)ZkK]_{[n~o;=?gHywv5/8qû\momdM
mdv2]yo uݤs7n7X%
58 vu;hTswq^8r'nȣx^_n5:kCIo
ff=O[jz^?Sd_]wy`]0;]|wYw]t2pwtPh8K!X!w6Xek) ] lc4my	]µd]4AFSffF`W*mK놇bMX4PfZmy[5ks8DvC+Pbf@3^K6YcVGftquRmËq=6>h0xj[k٣}$-S:!3:}hTg*3K6WL` /OYscNMN~OжC߳j'c04;X"@attaV9ꥫuG35ˬސN,qjN@L^38Ep4i2L9TMC>Mas=9V݆dY,.$/'ϪitΣc73o	=>.gyQfS ֛Lh'M$Nbi;t[CEs׭N"6l}}F!,pJeqXB׸$Ф!6m@U~#.kշ'Uj..6hB[vPviPTaV d?#xΪq+gk-a
-ǰW}}昖\Z~Tba"Eh] ȸXEIP*4(tZL*fJeL;!.,gNE,]{ҧ3Ypy+j׾mn%#}+tY9}q>DE17Q1@P'hO(4O0wE%EAo)7XUEK\cy	حb	baHc nHjV`mDBu9&c,9_EjNW9WFǪ ^GN*-UC;~oK>Y0B)7\^[)ZV}V,X@7\#Z G+u@	ݏ֑reYxq{}.訔$CkIaL/2'$2 !f@48]6V
&^0p&R8I?)
M4_nָ		6Y	-q2O%|][Vp:m~dmY++Zc ?KgZLQ7ke&~_ٵb1AƠhgeK[o-1y&v+ )PO6gb.􎕀u@Z;TSJOi)`5,U
dJaVcg4(↏;1+ux5l[V{\[Ζ+A+<tjZl|gKlY	YMMgt|m3uYP[<t>k:6*~MW-Wb,5Eޓ$YSexF;
SL,\+4e/<[XWOOoOpB`u˓`3#!\$G+ͳ-<3&Iq$x]pL@pi;@,g]ކn$d>áR9YωvdVBXEv;7eŇW\y\޼Cduޭf\cw9x${ճG~Wu=~"HI}]}2-UeBH	+y诵agk ĕ`BA
"bJl1DQ(ceנX$-H@:.$k3zB;wFC4<.ßF~GPhQ [l+gaH0g$NƋp\d-黚]1sn'ĠCO`!X/ d$2=.}sO5~FONPiPc.85*DñfhuHsj0_:Vvrӳ{V&r)XlԁT͇=찋/aKӫ!&YԪ
 &(`r_>-.Wcs6SSdCyDq]&nmeAsg*5vӡ
ϒڟJGS'
ۯK<9P(IfA	!A		ZѤgl[tDBrڊJqGi(k:g9	u#rD3~]6C܂\o{YqaasY5VlecX7mbm*PEedQL*L.ZnMzt=8Q^^!*I</Ig'KtxD&;;ycHw;lW'2AD'>BKetwK]-OS!g7YC%fVʌ2͛-ܽLgTY:z7.ǭy|&`XS/rFiNbXK&z&XU yuH uFVB{4-Az~[iI쉺|C<wYۇWy0b3t뱳ӈhe^hB՗`sP!Ek}>OGu:7Zb-{'27wǄTj7N0<Lz'uoLAkAĂl!+(r3Bb:4V:иga>]eb$+M_ݤXdee\4buSt|g
)	qlT!s^(ydkڛipaC5y+쾍3YǯO-C>l_!`0 s#Dq%
4O_ljEwzg12ٹP.~7'uh|6j,'^	#,i0&81Բ5*qd񁛣G۳ͨ?U bgёn1{g&Y\f+'7'g_&?>'9Fq"X <hDz7g%;聤Aŀ (Ł)>.;y3mbjܢy{56,H nFR4.Sπ(`B`56k At1ޤ	dY^GgÄ;N f<?O񝾴ww?/vU6xf=lOlR[ŰWKT4m{k_l/k:{TIzHL (PS"5JJ@YJAaHL))H
`,
Hi1VrD77mqy]=nj-
̧G4좡0a/Z#'b1#SMy)# OIE\(DWoRt7y2٢n`4.yоcT;$3!zF-U{K6`sLWxJxo WUhD!XjFIFB9Qı@a҃IɒVbpboon5X5OVEc	cU襍qf&QJ-=T$nfYOS@Nr>U;MGw,Ö1UW F4DY ZNzl6s߱`pZdvS SX È޻pY'.}\0Ԏ*ujcߨ~"i/kMt\~>3.N:, ra_`
QVf St.ia	~}9M`pz[zO^ytZ̽.A!y Jt3Nӏ25Gc<ҳz舋N|LLT .8)
,s杞>/x܏m+͚܍::Զ=#`"%{fܜkIҮku1.zܳy]ζm (s08X`ɯ30yDѮfzqR)}d0mF7ۯ'ӿm9ڭn,	{T3q?NizϨ`kш4UY,ggyUYcz9[D1jmg{'vunaJ< )|@PZ-r1$HݳkQtKYYpsFNo63QWƬ-ERLUFԐI!Iv/y5XK(gCQP}K.jQJK68iT0[+sqEE_"k2l//FÓ_[8O:ʹyJ"߅k5y=MzoJfzRIZFim,󈦀QZ3"S8l`퐹࡮:l

3slYQufDfĺf.^|HAH̲ =dt.>0GMMK SӼ^(W5/@_~H>3/^5ADc7+zTmD6eļZA=r^BDH8a7C2
Ô]Hvyj^*(.+ftWU=|Q?{7y/EgDWom6XSi{ xqܕy<߹( "|uBn;RzQVlxk=WZʳEJ2(0Hy>{gW ǈ~?ΐ>vJ
>D}a`IŨU:Plzp[+UޙM\}SQΖ9=^siLr-]b<i:Nٻ2.{ηsS6ń^cN&8sOWZ긋Fg!*W,BNpCو 2MWq烏aab{^8cOxLlM
mqm}8|
oT@G6ZV'"	QJG[e!vƇOȈQ!E19|3K	$ۋFޤ.36uy
^wcxB؏Xq)~z dA8;!^7zu}v
E	Sq
Ѥo6I3kpæi.n8ԇCYxŎ>fm2=xXIDؒ,5&Q,ft5&:ZX&]} eAD {:;ndq[ D-	. ?Ӑem[~wl[3s3mEmc\_{sII"
KP7͌Jt%^  ${|88 2K23p&ܯ{X(L Rˉ% ak㊒]I
 D H1c,yR)#Қ&kd>~#6;M~70acٙn ߡW+	ZUtusif|֡rybݙ?StY/GƮ^/3`[.HsҊ{4UC^Wqq^0_sKUMCM~|k5Nzn@ړ~sȆ5[/.XfM=1NZ-(Aўs%9
MBm6le(RrOnq8.ο E(p hm,Y1$f^o}<yS}<$w|$Izz~IF9Cy}YuJ)Q4hO}}Fjtmx|ؓs U&rHe̲L,&c@Rq}Y\}[v,]ȷӵ_~@pݯ_q}Nm.(-V9{e44k#70B=tSctIr
w8N!2φ@iPƻffJQa=LSLTTMI߻~ܧuݫނ6y*t7[m+/)]T֖@N?`V a WJ I"~|f#df$2v_ga
P,ča;_^ˀQMKC%UdVlPMWWﲙuʔPL4x	'^"p2KU]kKdG<>]?[m{Fs&sx+eE$jV=I8-DrʐF.w$k/pRBl%/68
@L؂1}íڤX'ymtɚ`>*yT8qʜ-`<·l<qUu43$&34rBC0"+#vv.rxY}}$/, Vo)GC%y4\G~`p$` H4!;.g~?Cz>;}?k=l܉7)Hη12LG_5ʒu[B{QJc=wq@3}W#Zᴉ/BdAMzQE\ٺĘZya|V%ntɳ mU> ︌>ȧɊD"B 8z^` BsFb"R$=klkxrMm'bk*~9Ÿ́"Ls3Ց  RTD^nvB企 ƭ!-qX8%Á .ŃL   C67ViX>3i.OT^8< K M/? r!}֔SM ;<$!D_RuzEMGoy;!v?/Xz+*)vb?}3mh$A/|Z=X``n23U!LUX=LW<!ja6{*F-^?4^Fk\Wlm-yܣ&ʧnǈ>.AԒ6h~7&7ܕA󺛜'u.)^jst8I@P=:c0-drs߷ޕl.[pl pY Scp_%M^9>V<NvV?{	XFs-:/hwT{KժCO[pk4xu[_¶w߬b
Cf>mzHcvw.zp}AmCR6&ΐKg@W;TBEWINB}т54g)N~#o#V
e,G;d\&vI#*ںuwxIs!9 q_)k1Ǹ֤,7+nT z:kف!Q ~c5#3JS}T2|ٍ2UהKȑe:'퀡zk!(S  dWvHKu/}KV{qr]ฦ-eSdd鮫4Yڐm0cH])&+ԤWw.|z2Ͻs=&3HLxHu3%Z6ež#$G'mr#nx_YpC4AkeR@OY:ޥOHJ/*L/*K1s͈
 ^nq 2#ߑD=Tb≟pm*PEk-Jioͯ̈ZVSچQZȚ?PM[-y|T8Td6݋E檷)rD:;t,K"]>mvcmb91id<xbQ8	uH<񾱲Dv((QQLvu$@F4Pb$ \Z](mEvj8.=of0cë>@g~Pi I,UV#=QwiIV^/WbV)y\kwl[:?Y(KʢQ]~2NCo,{(<b
ƚ$fKuUz]hP֕Ŋ@')G@5
xy{yr\JDph#6 ^*;.{c;v\[Yx3Cao9gkn9WK}.|5BfefVj]զkvւt	[}۵5@|f@ŝE$4.8l2*T0E.b^Mߣh&aDMͬn;[	WFeUaCqg89p3~!ԛݼVEUT=Fi¿OT|1aH"5
7*I3~d[AчoPX[*	걦Gu*qe4&ZuTK  GF 
7kh2;c]Bf.BА]lh3)XgUEZS[Lļ 2L6'KXwb:aj
t,䵸.ѥkd	K1_WiA(/̺Ҧ{r^2ͪwU[V6^-Cjbo|F)bb:q kI"T#0p~l,(THBNne}&<| Oǧ	-;3o~#l~3R$!7u-
rZť-ߛiZk8ڿxWLO!XDw5lsa`'k9ʶ-q&"==*$Z߭T:`	>	)%)Iˍ.$[B)8<Gwc۹0V}O_92_gm V6yr7p}!@(D/T hNesNv{\V6?r`ITb,9YZ:g75	, ʟB5iHdRwu `fBI݈BXIߞq2%ǣqbaݶpAQZ(3hV^F8L+L!>D53ԍ柞zffpJp30p19#`pc͢D2fDb}Ow8UEA[$:TeC\)Y_D,3pY]VNBB_iuܔ{vn)pb5AnH1kib9iYqYNX
*n/6FeېE'+v0=JKJt8R:GLNQ.)5qv+ZOZT0ֵ蕯Z[#؏3B&໵1+zH+\ .rOA7B`Z @"g32η/gg=,ҜםsNNTm|ɜvN0ign?P;QZ048>by8WGC|u-Um4waG	ǲ} L+A`~cd#[GGD7Cn !|e0kvI7e>fy˦e+XM}
_AV7d* {Rģ(292Ɔ'ܻ"0>m!c&h{ֱl[Kx_޻z'ЋXZ*r="ߘp\&@B7Jp,SuL-P{pۮּd)CbKەk&:̗l2ckp/Yz2ՙ+f`?̩+,?ܿ/ a ͽQ]\2XІǠ% ձf9Q.niGťt{}c؁}giϢߢ}-cZ|
y&Ð汕`X'B旑@JL9MȻѤDƀ:9ɕ^)qUK.VzF8&$)Vm_
f <$֔.?E
NakܟJoΓӌUz1_::;G,T9x:6	dw<DCNuƫFGTIѝWdHsUfbJ,E}_4ÀSJc&i* L0"{sSRz.3gnc"Tr I@؁H܈+1hAwݟywiT;p{8dbOnaAJ|\\: 	bU/0㓾S^ ND&רh030eV )(@m,	IoqcSom`3!K3J33 +g/Uq>4K{fR\wܓD75c,l$77]fc<T@[B!Vbag8W}r	.٭/ D洂衦ji++&n 2v4tgE էqV 	ʭDiWGkW[Miew6a(6g(4?Ϡ>ȀAQw"?
0eh{,2GJFL`k WGx c;vy!ѻ#xcۃo{&xH<[@Jyo '%L8 `ܷ86kAG?cBO7<(.g1t̍͜|6tȟB7UNA_yJC[65Ĺ,d'@1!&zPN≭/S?y3=煟daiDEş45* 墆fH	Lt/QG?P Hncv%]!kY: :`;Z\>٫7jX;kO۶CnQdP"N/sٽ(MY.7\#y4qws@v ̝_`3Ju̪K%kBL8{s` w"W&NL7rRw\>KҦ{,m_*AL  L`doH8ţK[ p2R->Sq	C1yVܐa	>VFbP
@m>UTNpY\N9ơC
"p F`K	l&᥄NzZ
P|ڽTuQ.S$x*w{NG>=B9P[UcfgLrR[U-@ҭ5j)1F3.ӓM}	_ϒj~ns6
H2qp*_+FtTT{ZRsw	ai<ףWo~:iزݗbNײ[  N0V"$ZD=nbxQxaU[G
qh6+g}LgͱdE>2H&<r5	gXO;M/s[gU\wm	 9pl, dhrZ#e~Ϋ'l_p9dfSD.[<-JQ&ϲsx=]qHu=vGGS3ٞ&L ݱPj_3 #8#+]؀*pk/eyRp0ǡ*XX'$wSfseïyOxu]e
Rc;^ؤY8LVǝھB1>c{LjoP'C>7ǧVbBToȻ'B {=%s"֒c/GiP!iN6p^,S`@0C:Pf/?dBT< pIq8I$ ,CFym @vd6,
y `vB02 U1 T@M.w]G)aW	fDP[f8>## ཧq480  Jî·;#	sii1a<Œ ׍ Gy5V<R`Zy(fYZZS:ՎTׁn+f[fyg4p4;47.fOlr){qG{r:(n]qI)$ HPID$% $%D$JHRJJSMVR@UU+5yBMYyGï֟*C/z~ˣNyh`lD#99QٰP]K|i';m;i݉;#]Aj{#lTcpaOhnn_)5LYId}Nmuu{[j1EF)œ˖z"J2>+;λ5wyR[_VptU}q*r^]r[C릻lQ])%ۍ4+z~OhϿa:5ܥ\Z7墪!J{]0IR33ŕ5fej4jaVW"uLP^M'&[qV/s8y;gh֮ҹ2iX
Wt0δlwp.C!j\:ʢZH1(DQ9L`e҄d-kЭfs,/ÿ*z+&`xr\zێ,u}	#zn|; <8vBdQ u+%)I$оsan`݁Ӿ f"9 ,'LGm<Q+wn"}NY'}M4]c\v(qw[kM>5,t5F2_0/1,j8a}.
zHn+u&\sޛrl7TZD!v(@9·BdtՐUq@Eԯ4f&@
@6!5"M^B"#+}1
2`̷:	 [HTXakXh	bVm5/yK~:h\z{v&!uۇΦohAc.B=9~~	1C{y
B]pihrc8~xP	!TB突zQj -
ZVڴ _¶uqa{C9bD/ <& ggvϫÜhV̷+nJ6FPu\ӄW^.t_|I[ \[9K^_TTA#Ū27]\ǘc$:}|?~<}'</CC׺ʟ<|v= iծNPf=! f&US" 7NH%_(9ژCΉ1X3V3 sszy5Q.iқb]`6pWW|$<lvVzZZLH~-3mE.dӒJgY̻_:4Lay֩>Eb>g Q9$j, @-@"As:=W(f2d1닸.dˤe%yR㕩#

rݾju\8̼:BU媧>^*""'j''nV	Rqpڶa%ѿjdH?I3xcfų^S$|ksQ².JTS(ÔulY<fiu&wyc{kւ;a(re PD91hG'MeH9ulߐc5e>=P(3|}E6JL@AI]^wX' !wm\YXđo<lnc/\DL,36 N<9ݮ\sڤeJFYϗriPGԗ4&wFid6QL2M
\"׸u<jR'%׾5ܦ(tۜ1Ւۻ|}c*[qhpб1 n8Cuo4O!EIv-#Q,ť9bks/ReW1=;L&DXZ`.RѲHA!k^@'.rId,/<W5BAAA!j`lօBz&MWh2`9Ŗ$[3b%4LYho*(
v7C(.mJNJ$zbjyÐV5"LTC%%)$:Ys1F+h"-wyte7Fw:#2Qϛ#Af{&Z,[4[ԌS8r$=e6ZVDe%]#$P#ٲEs9rNW')^4]4-.ȔyLJi4r?}BLD֦V䅖AZ,̬ lfGQ
TF<M*+GҞ`LkqNUwVvߔVvRF&,$$|f*(W!+X&WLhd$%u$e9	̉6Wj0ؓ0Jf{n4o xYW+Je1>#aH9	@ s)HtUJl(=EVn-	Z7^TYЫI
 N)TR&8Έ+uRu#"d$ٮp2@DbtV9:Rdж)To+Sn6~tKi6s˚g##QY챍o{>>))WRZQM⳧2iݩӵXlC!QCXv.gPvX.V*-0^no:l9n,\=yOA]5(qk8CtC׋krŁH߭)J߮!7a:qǗ0C<DB81&Zߑ9b$kboH5mR	G,R-s
]$:Ăd*(5%IA$@76҂Aws̼Ö*LfqVd"dd#@ʹk2Аf
LhG`]/\D@|Uot,PYS"NCSJf49gd{lTF'w[rtIc\s,ZKGqs
U	&E%0l#ږȲK(·n1j	{*C9)ɹly2!ЯD$t΍v'MV))*w\%Z4RIr̮x(4B\Uv{<Fh\VBcCڦtw1jķ{0ƘU쑺fѣRsgJ`hrvo櫓:UYWFgbCX@nݮD̉{svީ,f}'qKFc7'aQC<ܲVml6NuȂ~NLP[لltv0eYӑY 﫬{LhQƓ(dNzk.}}XJV7[;Q\R9FiS0LA %9v@`}JmXd{S]FnSL>:{gX@%)7T$s.dTBJ
1sg<лWD?JƎCrMV/xי8dsVtâ-}K c~0	1_e7|D㸆[C#*){c8>Zwk-cS0+n(+;.v95C9 W~l\uԐЊ^^lޗQvFc|";	.'le@P^KB<p쭊A&	%li*a#8huNv<P9ʇ)ft  	 Z-PB`]DQ0`&jK	kb+!ִ~74鿳i]GT/Y+#MU4Xo¸T^/lb6c{pmzmk1q@>|p k5bdk۠Md9YRd4L!f؜ιcpo ģ`M}r
/gKA%:r
ߗ9Yot/7j
TsWWZ<7dKo!n0ŗmfnagͩ1:&H`q{q2$tY0!/YX.	4MyZ/- ЙXi,5p߿(nqfH}qe!*y8dzBNC"۽^^q
wP$%/t{o>xߕ3+@~6)/'v}?vFI0YjYXVV.7
<USvI_#l\] Lέ\ggKL.<UR(&+h5UV⩢Z
:t(Ye.^nUFH1	~!xTWW{,I\V&A M^00Ў)L=ɇ8P(  H6oȕ30]HaCe:?w˺3)=vƮ-r6n)	+x]yquh|5xFwzK<qY445*<a`iKn6Aƛi'?+$a! '8 
Wp8*
A2D2@`1h@ y+GGJ`j|Zc  !Y	&+<<L<P'';= Ӗy/&p, `u8ML0IC} YتC0X/(Bl*h@`$BHҠk69S.`ȰBB;efIPҤ KfɩKZY.*~b^kM/.mu!B$5Z6x(B2vh4`O`h*E# SInKK6*!׃wg06n}|iF4@hPĞRbva3MZՖބe #D9ʇ)uL?CwEg]_3ĵ>a.cQU׼v9Jչ%"%%e q}-Ag@AdHvc Aگm LÈjEQCȝI_r-MQm۽Sۇyl}~slV/ejg8gzpW&8Ch9ߪuTB+A^oNiE>-5bfI{<-
3ծ!DDH.\fl X(@I5I!Wa햬"K_^  §;6% 8;$XNFAAi-+URVUŹA^1%@ι]9qYB6ƻd4^+qWY>N_oČE]dZaXvyӇ}Ϣ?<ќLUjxy6'֬MӨsLiST(u qn(Tq%0 NEK`?>q?: b,-xűC5YoU挽ı&1=eϣpAT2t2{k`-k[@|cyeuM+_Cѯ
%3C%c뿑Ҙy?3%[You"9(~:tޞ~\4ÒMm\
ݺw-'EY"	@<LMl" 7<*e0\ax,2\douaXv&ެ~:#Raߦ0IN?/j|i?F|k.y.Ϫ<^+75:Dmj;Xg
^gz?͡r~pu( p,)*z>ЊK3}<ND#UPPٞ/QY-k^\y
2?"gtو@-EDJelBz>@{nJ7s/6vdj6A'0UP$ quՂ:;Hu^`Ŀ r.ʽaF[$[v`Ekv4Zbvv8,su7ph@毶/P  x#'df6ysL3[5mczϝ˹'2ZZYD1LU8q
fٻLZʷ2?%F
Bsx|JW3ӒUCi}~pIPV|uh|^+x_;b33QrԞ4M&Cn`Kkӏ:)nF]s;ksR+kXu>٤)F`v 7Z#@pBiAɁrd"]snDBWxF>BvAɀ)@x>>gF~Ӕ"]*UOB5
h_.~E|%Kcl%r,[X  K,*-{Xܠ,g}q9=*5'*os (PHoz'{$N> y0~UADH4?X`(b+g&a|X,jlz}h'Lk}|IXOӢZaTalQfKb.mkmP=m#|f^f0P4O\*;xr;a|6#PeoYX3w|!㻪|5А0E; 7pn&n-食y}AM	OZt2/2B:Ca'g5,kkXXzzrym3_]͵YI{qP11ZC;\:Z<!pBpqmmQuc_kQ면eo}!۶ ;T>J1Uo{Z:> DCe^-|\gq 8$+j}KާǣZύ]6j!*G9)*X$mQ{.fWb̳"b(	 /: =&_\ֻC!uzi򕇆OV_kRf!bץ2Z[-qmp-O)E@aMbS DRXŮR@$o*m2u?@?_|ڦ?뮸:omd;uOL>4[ZװiC/q̡;/.=
6BBc
@ 	Q|eXzn<RhyYh9R܌7o_fBޏwv<"F1C]3Rh[j\Y^i102kYm_E6us>^f?쾅^0$a
1o;<؂>h]3H~-mHbm5Y%`Llz9u7rr94>d);BL6@!\ ݕ
,(69{gn;\vJ-q ') k6a1a@,$g-	 lq]JF^q~ѳ}dRDL4:hE>s燐	\kk]wiRSڟYqGzrJC>`q^^yt	hIU}tܺkmXᵈMP	cihB	Mdi>ܟemc1yR[O^dW\u똱Nzkn9}/@6y	A(೻{_m&[IA hz&e-M>MMuuVl/3^K3)iOܭ?'qT;>P4|x	mX+Eؚ;dJ[[=uwjq}>M>XݲvXk?/##j>~T37+רhm9=CHStZM	xC.jV$}$ij/-l,0Eϭ#.6T+yp2[0:mنpjHc㙎l8Ad%A)sZd(Lib,d`}ƒ0cn&5qȱնr"o^	ao
U0'V,*7W-jW[βA2FF[gC@˕Ns=\gCs;oڐZigCd|f2WIWLV<g_xovdN
R]i3b+k.WH9^lnDl;'&s@1sYef5OPu6'*]xwAa@8>`d,T6;GJNo&Z%ܗMF7_V}]	Xd/K8F1JF 3GqCc&s7ψd(N N-b_JgwU:[l3@TV0RlMп.,6{H@7U)0tkC2c8ll/&)VvkGN܏h
נ~Z"՗iC'm[Wz7/N?ZXC]hwɩGY4>k3F1X+*޾AWOޓ}-10>`xβwhvN(eP	HOjS($=F+CUGE5+wx,	LESuEZqp|{}/0iuotJꔫA7y`6GFzX||d!h&oΏccA/OEDYفJJB ܇6n` PU:rڥHC`CX_Y#L̶QToм=+H#oU2$u~Pٌ}46LKSYh0sȟSaWQYjRm6Xz٫O/"(J?e"H<QҵI^0mTA^q߅h&4 {$'/QXϧ:;PMA&yXnh%G&RL9U%G(fW6<ɳHAd`xgg(- VJv{#tg*R_D;f[(GT(H̠Ho=c+}V z!mke|9>by5B8-\Ew?8Hlw}wrEALElΐ^yS명y"s&Qwy__ {|GKc0CoǷah9Loz ~#=(A [ \]:G6څ2zZ[X-
4ZMv2UtA(bHM:M}{q	Iy sqFS>֚í+؆A@+p>nB|@ےe/RmިAt68N$@re5Ġ[1ʘ	<Ci Ph7pS MM\6&J`_ 8f-`KuE=NܸX܃XD%4@
P	kS_4%\j`M7,$SNL1ВrVl9SYe2xdRJhpT䒮lPC;Wo[n9f͡?۲g}N]TRu y:ħft6Bߦg^Sg;.pyɔj{o4c*d,^O%jy}c0խbrw<۸gsԽ1)m7'f(RHIo2>e=zoAvg,BUDb,ҤΆQ@<z#vÐ<:ʾ冘= glO޹)]
!u<]6k Cm<\<ξH@b8H&0*
ACu ~|:A-?1
}N@JD3  pl¿sC+04Ńz|ߥⸯG+n6~$Umc<>1G`0ak`tU\[>P=fUis}M+Vm"6!x,
Yc&٧!r
ieonbUU}uH 
yy&<1`,#eAh[AajЄ<9qEM`,)FM)reh*#gPm_׍LXv\PةVzpwIpx,m#R$ԗH	'Oе$$ｿYesmt5iux0jb A\!f!	 !EV"8P&sW𙒤?04Ru':2|Q<3trbh`Rh0ᝄ[ X &UXEѸN$i@ׂK=d6 s.izcPH	K ,%ِ0$ҥC(FPn#*?9WO委ĩf}!4Q5V yhV!lQO`*Ⱥ"vaaJ
͒1 H<:9z\-嵢4gA!$
RgYsz	L I= 06'ńK)v9KQƓYc38%&ΠlL$XZ)(39DzS`g W4A[srhfnBմe Ħ pE [D0C0.[54Nl+f7P<B*d\!fK5$x`yVqdܪ疻J
Q<eG\G2T&5Q
f i;mџh$]u7NuXJ{.l{v`@zKp;Ga.X̖zSuaPAƸ. _.`3+8nϹFl0kLfC-kO(Ij!Mw  'bЬ:h:8594iC֚ev;ۂm33.6!vWJĖ6h ".Z{@mЯup	7t$yg6hA$Qٖhf4C F	D$L/i.kDZiG^hYGc	)Q@*9CP]?|,g7d-%ӊe)e\`ia[<ibUgn@y5 D@"JA卌Fdi4D7JVp1TP~`v~w2WuͪvjcRR@%YT b_fクV>ikoBjys{; 1=ǴX=jݴsӬVY8WBP!O/5Ae<ujG$ 1
:Օ* SmDly 3=2D"&@Ai"03%I'$	Pk!j)}1~\MָcOt`ܤx5&H66ew,fIV hIBtrCl'{0t\7fɑ|35!K2Ą{ȁD%_h{!~<-&D%2!s<,ƨ#Zp#MeXؐm/ k
I$JnWAbr36?腜(d CWi+|pu@}R$-B$j22=C	g T#X7끮\ܴ#y[ \!&= {B`a O-C 1  I"kc]ڢi"cYtzLn5,d"$!#&>b^nDp~);/6V/I7e$cS*1ol)Dr.޲hK8:-T:+}zYԏźթ)*k+RFNx]hXzs@o={cq>JGGl2zr/p(Dm]&C`Mݙʮqy&q};A&O p$ DĮ'gat!O㑏l5I=> {~ AVr_}quyoMd͗c'I\WʧS9,nqzMȭ m!Yf?FccVՍge~o/PRTfM^Ѫ&qptFtksCi:
<#2`v[<퀺`"@ Qg[ W[k!پûѓfCKtr{CS?I""1jX،i1ePڐ^C/M
G-!W7",w;&I-]X]3CrUs-KUbkJ],cХ*I>5zH}[fᗰ&af""@Ӎ+=-ի"1heqb-!jg377dx0Dp摤k,έB X-|28&cbΜt6A}1豁y*@۠sKX-7c~I+S	Ȗ%،NR; ;;/TpWPh7H)h̅Z#ØX@.8i&Wf<~',
: {j@Yz1FњHap3evNR ƸByp}D@h#f	Eu@GD؆A%sjE;5·i2*]TR|C: jvA:lG.vG<F?ӭݦ|>&pvwt:l؆Ka6
As^ph?9L)p~/S]EkZ4.KN7U:2Úݧ&s.IvxZ3sn4' eW1淲jZ[%>4PŴi\C
ΌĆ~{o9Bz㼄&$'B퐷wP&!7٘pK|`nM&4F	;[C4HY(tu~Ӿn=|IK֯ZIrB&&{qoϖK"6\4"*( ]A
{ѣ\Tp֩04jj$Nb. _c`a~No!/~t&5}s b@Zu3(KA/DC60~"_/lYf48Eh(5 ЀS\:Q||Ox{YWOT"ڗj!_9MgpeVD[m.Wym~^oBJBR$*)n!z,V8F;5w`bY Y4ԁk2k$+mo/nw$d-d!E(`P)ab	H PKЙM;35XfT9l]U 9VyaWyh^t\rNHGh</PN7hu亯ϼy{/M[GADo7i*F,(gafU	^tcު|G7|ú;os2%.ž^HߔDy,F\ϣo)2>e:R&Z/]0 U$FY5.32EUDUUDn(UUTDTEUEDQUUUUUdIlW#ƒb_@ CkBJ6֓	ɬZV\a2fjY\K;gW홂/tCkːմ$ǐd.#:"l!-#} r2I[Fd#V.RDA&	 @9>9ʘw拐 MiM˰;3GKroJVw^;ZlsĈ-̃8hG10lG1YGq+q~ߎ~Lb91H<P##%g֙ɣT^jAp$7Je ZiUٳ*VdpԦvnNA@negfGX'.MG%/uRu'{A9ZV
[!6gFmb${mQY_Y
!5q};(cz=,S1A{og&dK#0Ёmrԉ.Jox"(o<"#|	tr'ڼ/r;YA\Ut(]c׭H\YxI$9eanXɡmlu^^J(\
a"IhM:ҟ

 fEA+=όV+/sՙι+BL~e迿JȬ׌Vcf?WjYs+[YNcyĦ/lNɤ*@(`6)g"GW2>{XXiOC3/{>(Ӣٚ#yqOu|VIo%.i
j'	@$=ʏ=$<{w=Yyah-ãnK^$|@ڬ,04m!GmyV*!*a݉ {Mi,э>}!0bQ Cώfb63R5w  JIb02|ꐁB%p4l=5IU0"@kqk?/9ȰgpUTv~zBŇ#1R3]}ܽ7na bBY#atFf]n[29JbyBhU[&'68VG!XBoCS`zCm/v50bw)Vj{)_9c]nQ=k&z?bBž0Da.>"X0JG<ʑhGz;J%{v)0O<\}VajUn`KVguv/!%_!*2N~ӎZj1炝%( |z'>l^?m:o6gj
Apl_UѿK@f[G6ȏBp:Y{ʛN !-}?1ǂ涝vºP1'e,[6YdZ.F{?O&s0aOTyB4ר枅wKXy͋옔bPF,`KT@" RA4AYdM,tm p=줷]	>Շ6Źz0 4r8́CQHOZP.uykCvŉ#dz+vsmf
^сtI |&ێS	œ6~}0mwد)QR5ݒ,Vq"vOi5*01 EGO ~h/t[}b`=^d̀sFylp Eѯhfe^4X)O2ڑȗИR|gfTЫ̞I)K8/D#ߐ_`(xas9IZOМcQôA4:Fz2D(_8T<x*xp%9u);Xރ
=:,PvCQ/iFpGBj;#s5,X<a[ |8 su)3x2d_58(ww'^F}͍,HD5)[xo'gvHZ-JvO:!f>&FOmgQrorw ]ңOX'65Ahņx8M\z1EHJ ^-TNd~;L7XNlQ1{2us1&UP3K$h֚>=fP7@tW>3!x+Bࠃ@KW3mgO/<1$!	cwos9٭[6=1uCX5;zGԇѸ^?dzKsxVz~7\9G=-_X	@7ߦÁOuJ!B"w޵8`@2_N U+FڶK)=[HҢɘOv=o>{||L=( 	<@G02݈ @.Hr
xn
e9֚Fq44`r	ZXE6Tf di'#?Ul8}uU=fa,}o1$8JL=%Vqo`!_V][gЖEErIgmsN@^Ӵxxɳ7kū`M'BL}C~8zqmIh0>@n&ߋ݊m41@ yï,TxpO"N`~I%ϲP	3X,/rijVkn5'Oې|3*)A6s@hEp;oAuk
x|̙3G9-,l#}	Z6FzK@#ϛ:ve="h4~J^?!-o3$<kS*-Y|ݔ,19/zeT\8kOZ;.DyMrQZqBTlo&"?a;&=\E0yEO#д'n{buذx/Mb!vbۦf˸Ϋ9tV3yVCUxUh70^ӕ5W}L{1r*Yt׆VKqN}ʜnu{f_ eTe +OmǼKR
oqBBEY*1D"#<ѵ{rݨ?Xt.	"F>c˽PbB2?~[qnPfIF<F(ʋjARXJ
QQ0U"YŊPUDTUJDEXTTXRHQX6QPe%UUTQ"dEV1Qi) CA"TE(VRPdDpHHg>B<Aj瓄ؿ;#g8@0)V!1O5}rY-g Ì׮?[ֈĂoE(^pv.J~YyQ8]A7%u|)4g\1}mwDlf8]čtD̻#'cFƄO-s,kNsɐL!	"=?2фڮGYt}EaŜh,ԧՅ2;W[Օ~'6Gj{`?AY ^fb6ӳ}ޖ{v!tܹ6oհna&/ipx8s^j \ݚ]X2j	Q^f]$TZrBDײU__Oh.ghw>Zoػ7wbH6@@;J)LL>`Vr"kg 6ށ|8؟Њ P V"z],}.fsr^ f"P>\kg41'2?nQ`e+t3iXVC`ީ k]l%PyKq PL
l< pB:\NȌJƬ@*h:
 F4ǅWN#`P|!8ƑaZ!
⥮UeID y&6eFΔ-saL020.3S톶XY4CKV0i_ȖQ4Ή:9	7 >>	CPAZ",<BL
Uf42K;+R̚ Oq 
!ZZZ
Jۥ\xmp
kD$hӳ&52mNؗ"0heڜ`tmPXT40		Eh"@'t޽NdQXUic
o8u0&]f0ݺOrOJ:%LG6aqṛxr2XY9IidSuýƐ̤U۳,UN֡|feSڍI&nG#3.~rcGuԤ7q<0 D2B:Uɐ33'8̋ ^K|nJX *h +Pٸ-Yy	zCYNNv_lCN)~xS^HJأ93O5RbL  t 7̯2]Q\ Ql8T!4 E^f#U7DsIIA0$Àd7E9TyuqU^Q֛Ѯ X9fj7kH,Q8@sbtBI/l$G9 k{W%60s';<H%d`,4VMksMvMȎ@̨fա(Vp4!:@X=2^t?Z^C-sB-yQL7{IJ}ZRI5ӽ_]Xzd)JR)
rRI9ԒK"(("/ZDI;Ao;"pB+ yxXy˰9Ы{Z)hV-kWȘW
1hɼ3oG#( |Q 1dEl0A>	 G6+秽zk'CJt>0r<faRL?ځî~pdaDpvg>->s|2o7va3kcn`OM{?^IL
IiB 0eTP_?Dx[O'-Tᙪ3ʜλwl	cw}j붻'kE@l}i R2bMN`:Ƞ(8xKk? D@2|ZvV<@)']~uA9H_7d84<Km%S*?m1ڬ&_Ee5h1=e	nSO:rF}Z,6#.
_Xy54sL(/i损cIAtdT}<m+cWͯCOܪ<Ěw~1x
E^
L?<]I;ޥ
|Hm|MWmAbi_T'IJŕrġ[Wg;fk-JdFtP
NΜv@^QL@H@L$/FBŢǢlӂWa0Z<7<8g7z@NkdKhE74t?Yb&us_ecrxkx9=Ƞ6㊥=I'w5jOLF2{JԥGk]ʷ]r	`""fL3(@ƮVXYߔn@h\CzK[nhhx7W?lL|P1Ԇ3XtyX{;;]oPc'˸}G>Nظ (""+6C՞T|_K/h'ʚ"0Mz{i0u;$n~;UlXr!p>}rch|P"C_ПbbP/!&, aj7﷉sKlz׍cssS.]3|u?%SQ֔]ҲM'z~<|NL_5`#6.8$S"I4w<F;?g}D!L[4NG.=d\`QG.nmw4{~·.$=IyN|0h,:
ZABꆄLvATh!8ECL瞝c1|bQ209)f쪇%&lhmviVnҒ`qNG* OrR)-J?!GŃ=ֶ ز'$9{[;)\^S1^AolhsK {毡løS Aٛ^L/	z:ͷnުx힯;n~ܾx/*ݷ+>5mzs܇߷)::>CoyGhY~Ul-[ߎ=!oosUxw9^."2A< oWvba,Qg7w
PvX[#hN@;"4ۗј`Keχ7
''3:yTq)M>p$.<yH%F;*Z1/.JN 4yG/l438Xj8/aH
v{ӝ	W8BoBs,0@ϳe)@q[(b(giU @g0Lߨٝ@?]Ӛ`{g87#0ELndJb'UY4H5tcjH#!MU-3
xV"+ߒ̐WBיB5a<PFFGxE
AfhY36CT3IwHr!EV``
%uPJiw_ڃ@!WT}FP-:@@*l5QL B@ Q$G/H*LݾQ<r`,@ 9ybF7m1VjYs[UZ^Çcs5zn?CgSg]?b31l@xH:YmFWQc@}G1 ecqE^0Yw̫|%5D>]u\WEl ![;WA" f<!D@@e# \̦8?cL[%"mz۱DR~=I2(
bB~{Ik3Qau[.~Z1'qRQ`vEJdEsCUނU!m,3?_?R2w!A䯅'ɒt?1ga3J/X-/,g,w1?<tS 7]h1	=z <?fO@Iҿ4t;mTIx B 0}P=lP|$*,k6y376uG=;S'qxf$cxND?StG?&y j g_gmp(mB. $!ɉ88}@ kԦgwWMx`oo0;mH}3OJH5׆ycu)6!>Lg_ZIqM,Xp qai92q9uV5xW; ;ͦ;gouߦ<Z6A%4ƌV&l̓H^ ج̍&?Iݙ9e&$m[/3(*]Y,0, Jx50<0A
Ӄk\KEǃש;*|{]coِ$7{|ngzp޷wC9p(ۥddFʐAX]IZD
C]x$`7'||q^ۻuԴp[A־*@5IdllHb'6Y\X6_J^H֑`2'#\ rR	L`M0`pU	gRN )$9Y(2	h+GꋲuaILUCuy.]勳UJ)LcW8yJ |%(#i C4 GT 
*-:'QbW>B	mo?[ex;֌M_֏XrbU&[vD}wުrqk49.ً2]hT:OL2$
ڠ}~js:AѬ"(	@D
#Iq[R"9k/d?lDG`	J!6)_ET)7f~Ec=LX#hPD-`BڗאJvik7_|ַ"ڷB=AR3{a\d(eNhr WYj 0rKL"8ӊ3mSÒrȯffe^X8`xr" 9"T`@C̊V^8!	pk_1f>!^s?^]>yRNC~Lբuu60n\+瓄><g[fnvUUqEm*U^g[U;PKclcZ4~bROTN6ɇlH<>}:/.;I@"Gp&q~B%9#Ɍٚw$ 	IU#!Ƽ ݌tQa,xr#<OP|8D;Ǖt>q҃)j4\\^]CW&âbۡf!rnh@-nskZk;;PQW&{[>Tulp|, lR*@.IB0!DD\1ZJꦅcc|﷙v.31vnX>`+G5xWf_FVE%E֛LP`0$ʀ&akϿ?,*T4K Ne32f:b.qy)LJ3X!
&n-7~?k]Xws@D6&r5hZk>%<HkS&eI*LQQ2ʋifdrEUK-5xA 19Fty>]{[ʵ'?_&<,PYyBagj@ PvjkV zH%cV,eTi.V?c{=v&..$] u
<971EkoX?:x@ 
\9<	IP";KDl1BcwHR5ֳЅc~^k.UUZEF 	 +k0{
z{(ô%uPt[nh & eFBpuO_%${ζȧ|
ɷ(tfgov|a&&' . @3ϻO.]0rJ> dDS :ח[×0UtyMq*$I Q IQ 8ىP~lPP#fh=c=a
J% ?<푤9#+9+s]F"P"7#aTws2D[g+j HS3A ppKK?}qˉ1dU[km]\ @pu{@LA{JA s,Riq\g}m5N1ځ'"C:P:u"|Юt6[,/דA#IȈB7yl1qn$e@{DFIH`Pyer-D50ouўc8r7$TEDf+8t9Nahp:c.`*(l&
XH5;gQ۸_f8Ҩ@d1q0 |o{d^;nCa/:[,F}N^st
DyK7qe['"?O:c"X>YT
0 KAA8|
#:9 cx1 Ⱦ9騅3L  a| 3ph % PNAXupai `
1&3;` JÌG  wa#Fxw" $Z,-@I{GW!s!\-wڑI+\	gi#@#< !ħ34v8WuWhx`o^Uqs#$)I`NmfSAĠ,~t"~jck]W3g,r5Sͧ!29!PFf0gO D);D/RﳰޘX; f@B NNV/I~p_B7+?NJB ]kcyPi +0f w]Qn!_|w\@S0q@>SX	'G-qW2h&ioە"ϪyBi+^]cΕjv?i-_=קU[N<>]V.w:vr͂E9+7[Oi<Sq6xvcc~U/[>K7F\˪-gmntz=%`^߲}9dV2$]Ø7@A<;{&qC{4~ǂzAkhZ%nqϑyP$P3||]JD$U+A]{LC hd'1]ZksEt6he(dcfm$@a 젿j]a-ZgG<*kGl4a ]_QD&Vb`THN|\r)nη/y!@jE)X
;KyU /3PIЍ5!#K7.TsyP=w@9eD00Ơxue37v˒ͦ82¬ޠ
whʷ"y(Fol@fë`G[	FCv;T3KN-u={R8eu{UI'3[Fr:O{u`Np$J"Sfp"%*u+Hi~=Wcn)cFdm`KXpo
'/s\-ʻYA+~F5wGJ\>S'bڠrTDs(< 0DO;f~pH:Ps1D(Lm1û~UI0|}GBn+(ɾխr]vD /u*=FRpkW Bq樂s!JX_ٰPi`}ٶg9ȑ-b6U}(ESBGHDVrn߁>w؉^ٺM3i#jraQ0(	&Ŝ)1tQ˧W8\SpW_.Ox>}{<+  NAB&ؼ4(ca|@$MN:W@X D>D?g^m,gR6ƶxZ0@lh@vK=culjKǉ6m?rsZf
SCSN}ﻤ>zhr]'IcUNʨ]M^ø1̞!Z^-,9>dkŹp_Q*L%`@Jd]="QʪZ5Xld
h!|-oχ݅ʛ\24o}Yr'7A}=㣛U,cJPtzVv/aVQa+{ V42Lh9! R,,BTUĔ.TE,b,H\
b0QDV
ciRZ4C" "j&,UPPqVԈlEDJ#
BPVRJLHV	@QTU1
"
rRDePK*
*,HboneY9(RKR`Ȳ'sTkN0PX8QYPS)1)F	f*azRYi
E/S
ED+HUUPaYmPX",QiQSEYBbJQdlH(20JP@dU`AX *L(.4(¥M4QTE`Rē2*#0EU`LTPEeR6Qr4Ŋ0 
\tF $PX(Ebw1Ņ*v(*8!zA-EDPV,UHe"`0H%V ɱJR6ZPV,,(IzY[2R((9RLLͳﶮeiJHŴJǅb
#{nB`F9zt$
jqCauXhv3kD\M*s/<Z]ZѩF80=,sļ8X0	=I@}[!`/QM8ը떒p
T7ۍ%3cX.ONٖz4؍m}ޛsEK&2'>!]W,~9ݬf/f3d.1{O-gb0'Wģ=t_WتVɬҫAx->}}yoe֫G'Pس|->^:%ٽ?{Tm=d^ȡe?z	oZܝb:֖۪K_pj7QN̸FWq7Zq%xVgzP\]<:V?z4&}<m>$! ؉6FocR0uůhWR0 #QoliǮgΝҷe_,mbMBЄL!WM/ҥU P5Peu'-V{^z
6u?.JV:wfu %c.RO7^Rc#_QCH#]N8>Oq2Y؛FU*ɼn?);҄Ô)%Cb3욧3aoB6{c쫺tή+_}z Ke;F[{νt}v.z`ysW~oSq9OMln4|}݊uWFM$O1 "2a]!Te[46x^`
B~B8x{m߫(t[uɇpf~L[t;.S?2@_3iQ(yH#j')x^lnx\ĪÕ	KeD(NۊL FPY[XVqK9by#GȻR\
mRLBq܈z5ޅ'όH@<+؞09s,C̈;x61]:B0-0*Jo6y␔&6b쪱);"n rʟ^kt +U	ȯjK 3tFhIn±HķXzbunٹ7Zy{ Ni6mRgәl6<5}{,_9Ͽbce_Xޤ{jh{:'ܣw농9-eNMEd٫_ش]/!W:Tw-X$֗7d2CGZ[ѳws~)Ջd8:zkT-9_T7;|+豽_zb&1>ؿ}8MM5' q$piadDd39_sSgJueUe[d5+T'S[>CК@VyBHrL%u-J+#tyl 35c*(LAw;+H4@z ΞQG0"nb7;eNp^Ϳ,QAtáP.
GHėLފ|H@8{ y-c>uT(/*R&a(O*,ib5[Qłv	ձ.?0"KEf>Tٙ .dD6v41(+FM(Uf',XfMsqڝvMt|"[G	9[VΊ9Â(h)Ed~~^~8B-ctz@RA9>hNG6ޥXL ti.}[ϩGUqrlJ.eſmdHQ̶B: c"hZ\JN
%'a;8X$P 'tbI2WIBK^a;մ)x>MX?hzD߰=%dm͡AK|0;#u<	LXw2_!I@4aTN7R^r'JJp=	 t!VB" W6
b`*S@V@h)cP(RqIŭ6LBauQxxrQwZR$,'8W8|TϤ#r󭞷Hyynw_{IȽd33?Ny-BGTCOO1jG zkWtyNz>ꋄ|6/qgVGF,|]֩<9:ٟbޑ)ѭm[kE1G>wrX\c0>S=Za(9b>ߗVxp9q-~oV()}s~_/DdPԏM޶ṿ߁ uu]=x) q%J'/n27lgxU`՚Ϣt?{4{B{ 7~dNH*pؕ.Ylz<Q#f!`>5j^ T8FB8m6pO\-f:^\z0s ^M_14uR#<lwНw~<]<P|YH]8wк>?WQ9chNd:?X]=Hߗ߼yz흓,.C-wnUZ}vޛV/Ayi{u/iSr;~lht\GojQ*`B
-Nʫvc/gSKSeRwAȴ}61Go?wi\وx=(t'Lr~pXAu<v&-N9vF#%0t9(YڶWge-w:7-$$7tIi '׭[lzh|ggW]RYԥ.x,qZElW_i_>ΐ]c70`5	e[J0H3WCQt>E܈h3x: :Uz_lʍ}x u@v]`S %3P,ivU$YL<q|ZZX6j
H7T2@ O)tO16N7sif_=`@l}8w˘X{jRZ)y-	<IgZ_D=rLsny@_KY<}[H{OK\g$MZ`p,(l@x,>U@qqSG|?;w_>u!>erӵ)+Ym!kMjPQ]=eY,҄5)*EL&/0	#qhﵶ]vt9-3]bVG!`1:RVѓq˞9w2
$In/"MA32{m(ŐX?
&IzCb$w\jX=46Vص8DB1{~;970oj#o=a/ xv-uo5Yd 99I7lᗾ3]ݗ`<Ѷ#Yn"S;< {AAT2ǳC$;I>|LyvoWv*h	P:JYqD
E+{->7SJt5IFY.(<?.:ŏ8692:^+h>FPW:|'YNd7n%hj=`  mbE"Yߘ<A9l!M6w"{HdS!?a-SOIJzuƯ/7
O˗@K۬ Dhwc>=\
@|Սj*3g&SBhŭXjလS^1W{,EWv.Ē5ؗW+롞z?^6JOb=K[-e'М</7yfSEI: Z$B`n_2*~Mp54۵fv,<ٯT'MQ
fᾹ]m\w+oʍn? :vwa垳m郣z5|K<{i+-΍lL,@RS4H-dZل&t0#L5{ٚ=ݷ#Q_AKL~֫c4S:Mu+V-oD esmLx[lu
k$Wk0Eߣ]N6%`eX|W{Rt+4ˍiD+;dmmrk< 03M<f%HxC' mm=BNMO"7 9ܡGD:Zp7й/ZKxxy鵉&2ZTYkuF:a#aB;Ƈ]㰸oP g.;hoH#2OsxE@Do c1@Hw XOw}]g偍dlIpyaW~v/HNelU?6ف-:щEvz6$Ut ڳ]݈X;ַ&`GGdH3A//*.%olݶFJn]sTVբ5d㑠:9a]xPه$V KJ-<G;-<>>sԿeK\j?ٕ8Fl@AhIu#Ib/:RQPBd!D)%+G؜,$[*3"2B'K-YRDQQjfI$mpϧE44東saFȁf['f{Tx}<3"YUOE(Y~;yXnDb_NIk6dZ˙.bAwi
Qg2bՐ
>^:=?uY[:fyVm'F]}{]u*];SLv8	c>tկ< ?
hID Xa/WyߟIZ׎]n֞,}D'KgEt=$ixHYĄ 4B6\.=0U@鞭Ke:;amVFcdo3ƓG#J;ݿV7a!ۍ];Ub$:2Gdr3j5^
LHckH7Znָ,yqiaʔVMT:zB^oؼmt"Zk 'gfٙglrykevFaf&7a-s}Z˧Ӹ3AkkXbAiAyP?]q`=69@w\vmrU{:V6>Dp8=l+E_<TB<v$28a!`_]E1f2ʂĹmE=+crE;Zl@ʓmggՂVn;|;sZZwBHrh5.>sk_^7.xpφ1{W+[Gɡe#n{'C/lȩ^u  j5s,_T!9p`PhdoGi hHy`u kE (
66^YiXnV'ge:䠠h.}|U \ClcĲLb| 3l~Xc^7   {@"ptXށj#QgyJ<?rD/% l0:TĜ
T8N~U: 
7>aٶѺMk).V;ί ޿l[O&ұ0I[=_Ex??S!}yKA'aP2E-RadM,_[K~QrDTz^_ LC+Jc栰ުZM[OiU-HQeO,{/drW鮖R,OhZKSJATMUVKh䵺
[>2
*D}NtYxwMJQJv('QDPWkTVeqo3&(='`y[ءO{r]\,P&,jn~S63Nb	H%]lH֜ M'u!4/'W~y;<;Ҁo{% eU8 XcڋnEEOaɮ PDloIt:󡝛ۖ}| !y`pMmXmc5e-ĳ\(lX(6tQ;[i3x8$rq!:
L7GKUON%WęY)ZBfny34>.Gyn1b}h%Jqr8=u{)jrXacҝsBٽm	rzյלD*PدNX_.<'z:Q]bp|?{zWJ8Q1]!~߹UD7_vP^!%6Cƻo-Mb!Xyw~y܇8s]?d{?֛'~i%LJ-*ƤoA>ʾNl (fujelF2>uܶ⎏\ǣE>5\Wݱz_K+KĿWzGc.xy3;0]K & 6I1,"G٩P~߽ވy@AS!}@&1geJnl57t( 0l
m&i2[G'7oVFq_3Kχ`X[A휢 ?('/|2Sq֗0ζ=T>a0DvLD/{W7ZF@4 (4 `YpӼΫV$n0 !ߩa+џ}h~>yLL>vճ-o98c<V{W7x޺,+iw  
.׫evIZ=c#߯rNtޯ=rTJ_(k;yLϷfl\UMnzMr^kF7.ߕ㳷 Z#q,fj{-y	盳>^ohXDnj61`N~+rSPJKg%-Xп:ooY݇ۧ`>nIWݢskPv\j\]oUwJn(4S7̳"Z]2xoY<tO^VJxC}wO^_($9ei;?SÖ<.p`gg+*6J38q޷0ߗ:O}v/}ح[t/ePD^{s1TaͦFuUF\еCOpC_`PХy~mq&! oN@a9t@:Ȣ qǯrta_i)v~{QTE¯8Þ3p}:s¡IײgxcqExu[h!\,DF"&آ=]F`58| Nʅ&$:Edգ Ð FAlp 	 
) fbM`+QZt̟ѵZ왈'D|<I uG(|&;Lzϯ Mv
SG3H]'[W~mu{.+y/\GqƢ8b1 @BPϚ=[eSߗ{+Rp!F9>S7mŝbG3y̏E[ʶsoB6I+zNW[>厽En8վ헏alxl2l=ڦ5mGG|oq{^5ǩQl48'}\\]t7RKm7zWVz6ߞ\UKw=!j{iuZlTy>&8[CFt0j#K^6MV+b-R6FƗ:*>TVl[~jeUk;Gw7{]>7,C'oMv<*h|ůg,M~®?ck.j7w뷻wkDO~C3ԹzCd>y!K3=3}nOs\v?L>~^BJ}.Ҹ0kl\N0,I`i_[]o?wy_\{wxnVVݿl?BѷjŃ7_1Nx`2gwHe2"2:k"gZI#lyֽkMsQ.ixt>>*\<GK6>Wvh.|5\fk
hxgKOB^t,:гrQ4M깋=3NW&I6|t)y%.pgdϳ`BnXD@ذ^X	:;WVlW?Ӏ*3]Up1'%r|slYB+XWZWHl:OUc)D~R1P0z='JURZ+xR<
aH!M[ щLy;- oR6߳6dհEsUN՗Nq|pi5l@1	@)	 kPSaHgjSoU$%ڵ<qc^21Bbwh*`y:z$ű~6I}_?;CU7F+}̸J[kC!rWyDN(G;}vf9O((6P[h!v1lE财>֦Ga
>.sO>u+ŽV{GC{O.\Zh qAc$4]a'BAB8nTcJL--E2Ze_qHN2ZOvZzXi&5>6ԓi>EqbJ=]T@$m8lW4~K-_#[,.t*Pl;g[-Q6H\ilBr6z?^Ȗ7Ԛǻ{:!`_;
%*f3'u\=m]<ap	wճc戕%8!5Z;O&沽勅 R |SWmRZ(*B*j$j-q혗8@*גK28WU9OZ[TE{9!q?;(![xYI媷O g,cs6 @q2	RHv3 mu9I/gZnz7C1z&V_&~u<jAIz@<tu!AjͲױ #Qay\_x9/![85ft0Qͽ73aߚ(]x}Ut2%!Qh{3_h>AJڂ	Yf~wf;b:O)ܗO׏in 2k\_ye4J̿joniڥ݁_`܉~	J!c10N̢./:oI]9fvYL5yn3G0ZQnzT=&#:>;ez+S?Y{_iqw7pfS[|k5鉛,yxL	*zI=>GB[Vw/NmF^زijD:;DRl@LpCso1˖m̶g:4/x'ziešCdgτ{uYٚTNyKqEbge,:*,Wy.1:6vUд _D֑V|ZcqS#$R^ttyA$b$JHn^Qf\o.KJAٹ57<ԉmO(f
CIwxd7^uiny4:Г^=TU]U[Su)VsC9Eϕ	"S4eV[<W0ߪОiuYT1u.KSo2=uBŢXXd`eE4r!!2 
Ch\2w}1	THx_{wϏr~,W% s8]k3" ,9	4 Kx*^:99{i"P"&g޶U"h!!0m/#J}48-+bhTyp|z@bjSQJzJiA2a[Iw3$2yvD#qA9+ħ3(:8Bԉ:a{e5MtkqMwI[q
yDE3qN\\0:]DZ9^z$lЄd(6#:;ڷ6N70EDN@,b읃i0`!ͥ&JSgƃoVUMF-׮Cj*MV)der[+SZԒ]C~:n)UՖPֺQg"S '(ݐ3b81C_#+\1=~^%JQY]>r<@Taҹw4TMW3鸞ܭ=I"I>	&-p2s^^tȶneNc]Kº`RʉW//BLal_q8
`2.ed#ڥQ[l]nd2yzxÎTXSnA(r#2!MYI8?\&Sa#E|V&6XAu׎	km<]_䯏o&?K/V~ϻYKmS~oE
@ZQx<noem/NI&g߆6 mt fDI
UM6Mǟ;י˯y[n=N,f3OdO{!&9;C؜ѤZ3'{n;>1=P}"$$QDT:r-+eYL^t&^!x¯SӥbendSh
uЪGݐ͌^,uzL:LP>,w"ssr)?>fRDD=llĞKUIڔdPh8nL̖!$ܘ@'!"s`z{j``5QEaq9(9-x{*6Bo&IH+ 	P1(MI<*l&`$bVH88H§yEݣ5J&ahcde BENSLAb;KBM2$XpQyY+dVh&(dwy2fPª%	J(&EKqU3L4VmZ҂Pr,,RLRTZ#E&qqD376^,^su*@jKՕbvE<5U#$ت.M&䐼ºqIڜh+:<a+΍U!\,수D)stĒ(&XD 嚐)b^YMc%bp|$<B;=zGſU	,Dd+8QwOt=dO=R:-$`aMO#:lq̧98W.b(l<MࡳCʹēt9\C{fb^bSPPB i8s"Jиjd%٤S
\JXc't1 ,2+D'sQ`Z_>&K{e#~ΣsK{mr	-BSn7m`yckqi>c;t(RjЯK)N!Zw3#gKZ-dxice}}	[(RuU|VY!oφ:1ë0]
fj`C0hMڡ6q)+$Y!LƁ2	*CSD/BbYȂ$% E2P$0sh$:L!6Naf2%Ɣ~+@@R["3#drڤ1aABh)ƒs!Ihee1 SH\m̗"IL&){%֨d@l7Zzv!skfrL5.J$c2to0.`
ഈfls;;籤pȦfH܀dmATkS2;[mTC-5(ZfT5Rg_	IfCVbW}$NNo!{c؄Ej!вh1FD27^ɑ `.Y#\Y1FFd7#f
#,=&Ě^%\ePQ\	yXcvĮHrQ\xc2P+XW[z33M߼aR=7IΦiUU~vlIDCk$8!_v-NkVcTs	T`1N_meXN3[K*&-7gYr
<r7`&^LI3g|XsI
bwV7;2su&iÅgT7B	Rw' ؗȲ8fTLji"{$д{Hp>S=s+-q]̚GtWDwRCS3!GP7fV&fhQh唵M2p^KtkO,K%^bS)VNsԨjH\Ȓ5)+0k,Rٝa[axp;g9=&Z{̌QiY'FkvՑt,r&6Lp˟&r]M7h's)fX	ϑBgxN7wZL:Ȏ"gRc0͗el,SLz흮b6+p.C/Uջw*?~6jsox4lN I` xyQ3G
MDvm}:%eC!vm8aQc9{6^U.*.A
 ܫzգݷw=PDo&ULّr!)l!iDuwE	mEOA铘t@z V6@='
;}sLB)0OQz4^׏~d+q{݌zsCAOXιX;j	Yq.2>AJ*jM1rS! :i-a]Yg!x]s'c#!7,7h(5@Mrb]X!Hb<nU!}zڿ,Yq$eBRWfRZ8_xxw%-~fԩ\˺{U2D|ԀxC0J䖕EEO'khzQל</},7DYTda/EORR0模RT{ I5@`tX}ةC,&8iڗd>F;]g[P myjHUgaˉ~Bˈ@4@ " whUR%d  -h3 "i,;_4?ںƮMjB2ÖQ79K6@(*3""5Z3Q!'y6'( 	$ i<x#<Td?c]8㛙ʲƞF b??2u?¿v)..1	[ⳎQIWσ ЬZdV"rB3 4U	LklǙ`SJK_+NW]#>@;Uvfr,mUdVquJ
2x\I+Hχު-EM~hpfsEz9<t*ڷmi+]Qֆ#(Kl<^2d_"<gzq4^qYYLrGW݊)6^L.2[3F?8pZc=rN5nwն|~Sߦ	:|$Yyz[ڙ+jZZW[?.YXOP(
kJy\HNPѮ,чB$dNg+4p/<,GGg^{稯NTtO5^?'[*孢wmaQ̹]ЭX&Bj@r)AD
tX
0>7Ҟ8G;R|<rؤɟ#s~ƿ%vHM{yP4W0*aK 2^ƾXX}3&f?븕8`8퉣]{r8v>3l#7!_to1P.bZ$
bp덑62PYnh`MHbnO1qcj Ou0
 V*6!XBqLpxdQ;&,8T$T&T09[%kuwrŽSqnGxhB흵T_kqDHG <.$UΌ)weκ-[Y|/yԀQ4)L<Hmiwl8-Cmuċ9D(/KHvd->Ek8:4τd=鞻Z]RKRŦk4Q.ϯɱx'.|~<3crlzNB97EkToM!Wep%1ܞ
S+{/Yz5Y̅6]
*iPf"<o_hw)l0}5ajV* 6 KR1C^rJU;liz>~a\2϶[еZذ7[dG3UNwQ(N;oH<ɍp~!l`[rDgURw6x9kT/g)hC֝yd?ZXc.GpP<ocJzѿV6{N7֟5Dd;v{.}={??OE+mxo,3ћ_[2gc]yݖ»w^4=,\oa#tvzٷְ~=_kRi0
-NwD]]/Z瑫NܯlL%	jy:oV==ǘovroӕvx9ON6b.zpo1Yg
m1Mj1Vُ≐,LoS} g_޴ඦ9^l(ss<B|飦OVgr)}...VB~ޤckbCT%Uй`pԷFѬ靺g<Wc1K=$q98;T0uE|ENe'wO\nV1:ޓZ*ih 1|_GՏFuVCoʰl
I a	 r#e"޸(0!8
?DuqD.f؍/!  !  q:;铼>1c)0=M%N$bO\@sU<Ġ*%DԎI
s=X~Fc,2P^hۖL]Iz]XeΆFMvV:;GWrP(Q9&֛;im"ʈVcIH8;juZ~?qEd_K/xiۮVN?=".q|_#+Z}>QwZTAvU
b `ȲdI3LB,I73 2$r!fdC7>+ Sf@RLā)!)=h2B3qT-,3ث#zEY`V(~c6kaszpBMVr,L9Q۫KJ}­l;]5z*7M+UkxпE}1d(s85/p_@YK)jB0HȊ-x˰֥-2di\دC hUoc"VsƼoզ21Bt\70PE@D^D &1)$31ٹuσ[н[@0Li^1%#<{>reaoPih&l8_NOqOZZ9SW-j6 l)R)zDgrgRX6M,kx:uٳZW}nkGU{/gy;RzvL}knA" [r;'d_MJ@عc!RN\͕2/Z>Ĉa"Lgu\]B̅SȱZpG+]MuiuK4z3Q^aQ?R>TmI_;T:P'\d\ٖʙuy6UPB"1JJk+xg{Mm_vs-8TYzwH:Kk>F_U9	6r| H!%6߯e3+,r7j׭ $RZH,līTU&C ҰPbL?BV:L 	C4&!'W6[o^㮯/qCBմn%t_Q0ÍhP+كɦniݥuݥ.n\ϿGwtU<o0~/۾9vy궾϶DuT)@+I(S.e:1|2Q'{ Ox(yY!WiWJS>Jws'+7]
HM{pp>G+_3:|[3b@G'%^fnyydUD,'!EܽZæ<vKVZBw) bH6EX9wKp|hǕ_T!Q(qP1<={,l	xhNPEz6]bX,BE"8l2pϤw筮m+{44LkPMs*Ya"P-p-g5ŨIAVr1kȥ7秫E74	7]"ѣ!Y͙۹9RW]Ͼtyӆm&}GU|چmM
pUa$\`$g긅5ab~\},NFHH*XYW^1-Lֶb="MF*7#m/cg17\Dr"gR!dt@Ӆ>yr^us1!nn^]t*<)@B	+("1ˢkKLǸʿ-vBW␢b>k1EAJFnn";-L`N"Ir=[IІ|/oU-Ib 6x#AP&9[FR]9N/ cZ]JTDE5
@̰+WnKt]U~iS?_RǾ"V;.͑;XQ_XWWhK>'@c_3ۑݑa@Y&IģLޞcT
9Q^t`IIIЇdd`C!"p	 й16tPOR볍)u88(LŻbmaFQ+	Q)iBd6з(
J^^]2t[& rVS"RM	S).
N~e(Ԍsd~=_HӬ%"L"%-״w->~3|a)6"K-tkcS`6`ۭ!sAJS1 \sŬRԪe1mKzbAgPL3q':;U4=o(5;ELȲjْ	 ,K0)R( IRhD3F" YBd% %\e(-(0BI2Q@<RKkao/򻦿tPdqdX2d2ڮ󁼶'W%鷯F}TD M]Y%N!q8/(y|jQy^A:5ľ:R.0F`-f	b\N-=o>ֿg.Aڕ_kX<\#r+~@ ?1M[\ />E«yEaSs
9h1.$]"!7>rRֵssb"b3ӭ\2mA
T_UMht[˔ FQYM=iu"%]. ߡ]aۄ-WUitN\>7y%&(U{VcQ6J?GvrsÜ=~6O8w-ǣ\kjDӛGv;V:/nqC{eb̲d nW+=`I!\v~;]i"Aiqt0O)$2>4tUwp~>U:u.իMݔ|]\O?'lXB	u¼|atyn<w-( d+X0-vjhFҊ'O$o?z7Xn?\96\염b.s(e  Wh_~*3&^}#r%rucm+ثYj3$c/K3ߑat]Cq{>r8Vp0?5ϖ:jll/ɕn4`vZugVX9W/Td]@RH.4/$t#ja\Qѡx<el:Q.!؜l2IH[SՖR?u.ԘK&aa+1}Qg	˂1*61Ech㑇4;UHۃ>Dʾ+6]dc{_30B(?oɰO.t`@S#y ?$ԭmrƥSMygz1y.>Rw~V<w.Ȫ[Bzăo:t|>/Qz  tv%+UHPΊ^p69C~mmmSWX~d|l0 xdt=C*^1$SqyN0ct@(a$=X2Jt68)%UYא67-ppa믍s&j2"L!s_Vu~9UEUK|kEaRZ݃Zyp|GNg[ 
O3Oܱᣡh>3-6/aWZ^Ŀ<iCB',ՐgU%f4KۙL',,b|BIK|e˚2>f6濵謹׳},1t9>G#f":w<?1el4AVmgo${iyoG9|w{:xWΟ>gt;__,#n&cǐ.rsfeBfle*EyU$4ċy^|fvϼ;[d]__!YujPCIF;;MInY'o2d,J)ES+A~S0	TO)*>Ch$m>Z$~OY>BU껕ΏMVQOfkRĩr׾W?-vϭ' l@&P@$
"-UOy|	?ClkJ,8ט` !},9+-@$ʒf I>bRH	
d퐄6@lwoawsWy^q=p4>ˇzhêPES6A"W~-^PIKaS,I @ȽsaQc/9Y|23d;AoUPy1Srfx\Q!ԕaNGn>}mEs;.X<oL&ChfQ#/E='_1;adٰ'5x4_
k\c=7m~>3!!Þp񙵫<W:rJG%˖>vW5ThfqYx눂Q>GPD yʝ{؂_ݤv^Ah061Gu_wqP6=u|[?Ӥ'2;`mr-|)g-M:*&W;d71t8+@\*"b:e"B-Z0t'p[^v<*N`Vaᮛ33θfj@,{( ؓîߗзTf]1.{kU.*yDȚN1uPڻdFD
JB"QoyK|~铦_=XB
NV2̜WN	9/-!z ^9k3@2Cd!E;6w̪ ,'u)f5*M=V_1!|=tʾ/6S2ٗo-Ö
_fʅuʧ_t&vkIyH]cgxp)wC	c>Uߛ<ܽgJ;t5Ѻ$%52Q*Gk?qIGkV3n:;==A$۹%(_Bq\
eǇ{=1ޝ1h1HoRlfudNŮe:zaUE6۾b=ۋTLV1 G*NSĽw῏鿐铇CDټwuFIΡ2CI9DCaɰg XL1D,oa`ΰL	1PS	3ݤ3I,35f2qWts*TR\I(T@@I%'@G3d@!gK^h}N-S}?`1
,ڵ)aQFӺ#/MkLa3{WNPۭLp@?[Ű`nu#|4soWgJ l0Z)jikG9|wZ+ᇓ IUs׬A/fnQ,ǔn;\c1H]F=ǽV{Uy~"WXc3/}J&uon4	~r'ŵk\og_8ξ;si:)^0tx_'7ޔU`Pm<y.,=ܙۏ17o)G=޿Tw_,_HnM+gPns_1|E"	*oL820;rz8ҸeU`ǅL @׈ kH@(]H .V[w]޼vsg!n1f,bH\\?9CV]m;NC<Nbi}O;<\("	3<}˩TbȊQ5$
HFO)lQ?R<ow9o31U|.Mqy8*c1hezMO ٬hr
!}fd;_XrK4abރ&T3]mYɴ7]Tb-J"B> m@	ߺ;1̐@D]ՑDR:X25q5WŦc23Vcn6CT&$T<e6 B&j$0VzuFؓF1MQQQPc XjX
RAj,ݪn6VkgsԞ;[Gu3,hyvݼ 8=tDc8#uˌi^9 Ȟr89	 H'Q~t	#y> "bc.eѓ`;f=3{@"60J	jB[f0D?Hs!BxwDP/
iR6Y(0x)=Ї\<nza HK9[[6
uXZ40Cō1˸neGX׬N1:0:xp#!\YIq7cY\-w1Vty[ΛbalQu.wq9GKt|6-i¡2315	6*4SK'60Wn[<auk-B<v @ifJiҐL`Yeoc|2$Js+2QZކk&|.18/Ff%#z^6jDXgv,[oMu{g	Ir4Al!Oc*	/A¼>u$IMN;/M937<sFb0=F|W s9ȷ\RFڳDitVpV@ź~faM1/Qw=AD4	 ~T%lda|~ql#g 2*[0$A2zv>_q=D@d++rHk&İ
F{^Y#^HVςs{ԇ,,!B 4,BTtY=<M㼶*#1X
wTOAXU֜jx0;u>-3kM"D|GYO{S (/ xnTzO&myqT>zϒ?
X\Zޢ Uvk_YАGcf T`Rƣ>/,R1>[{RHV @ߛ!d w4֕2:: khj%Ha>71D'![!3}܈B
,+Ï -Nt\9o=Ј"yB#) L9(C>J$t齎s_L{OԞ.ೲlmW|w4=rP{AD]՞Hv2[/"@e*|U!y(k:󳶷g_uʵw%@@$o؂#]iId@;,ҍquNNYV42xf>.r:@FI )!#Ǝ&P+*Ē3ZN.1L 
'i}-3:Z |҆fq*
 n@`F0uAc`BvIx/zens
`S+2T@yr]`yn!)D㒾D4G["Я;ډ(]GZő)YD4(n<vK'%?<{ϼ >L[2*L-rJYe5chTQ[Dz}r*PYf@ΎQakJB6^zuwXau{6;3m'bZ1PIG:>&O<°ku
HsIve&#>_ܵVC^JV" Pli' _?_!|Y;y۩{#0|ٙj_epYg;|AZnOiq6ֆBYov+fxngɽ<Yk%~Drn,mV ƈ`)oz&&rir!H~ ̎D޷=ND&b	0QJP'֨G۱~yǞ8(/Ɓaގgx8v+)O[jdn/:wV_;!יHC_'s]+:}ӛSYOś=~p>UbLuL)	%Tm؟ߜ1*G-??V{#.j.wGL{#8h'lnYPϡ2볖@h+QL)=zZ
{靗~B]m"@,B3j[\fֵB`}mC 6,H)\ "B*{o~3w>-lHsş\l>οgG#QH	h&4CRW{{,fJ㮫$&C'և˯^v45[_Ԑ{/qCP:jV?7L'<:ڗi݅ƱpR??Mđ0~tkꒊd%	mM\ϥZ^:RΟݷ#4]}
U p 
mQ/kDb\-h~wwsqvƷϠ_+lӅ`1<caxKW7UB+)N-L%U$XOZ$IkRv?,BE%`ѯKL-,\]p.Z)7ndv{=o
Z˥Vp?cL8i)@BmwTGi_Ꮿm5ZpyDZ͑=A&<(T	ZT)u7kJHbJMUTX,2$b]bWa߷(bcimM
_gZQmun1(L»F?/EeN%=tq[rflfT[6W?}yu_rD,= DX^*okX3PV,W6HS]o8O|]jHd͍Сdk3PT`,TXTd2B^<?~,Yϥn/OpdOGR1h%LPDcY3Bxwt=%ZH"M4}b;Y*~1&:Rږ;\;BO#>S+mfn{L"i$)ȵ{c
aH#"!\>!s.[m֩S
TxTPDX.i&I[ʌm\کD7"(Y3nIRW_[?{JOCk}awY?kx~L-1	54,؍LQ:ϱ4q4&S9ǚYl3W4 w-6أYD@*bUikmxʱpk[*F("\tj؂VEP<[l>AlJD6عU}IXE-[ֻb5ƞ<#D)4d*˲l_	([o|dKmӑB8 ,ɬlѷ).AH`rBoq|\ ؋<$ z 3S10i0iXJ}ח3<t-JŪ*7e%=?0&==F;Fg:HSi>;Đ}R`:$c5}B 
` `@)J@.[e2޵E6츏	/<+^V޳M
gţ99
*FQlW4lsTX9(aG5i*"~v֫2홟m~:SBU;L)qY#=uNdp'"VE:ij@PމFڃ(;U~Y&%9;/ܧ*<P*fiҜy*1ϧ qJd(c-O٨~/rYm">rGZ}*٫)`u<(fXڿqs^؄IX$4>g?Qq!UgXl;=KrKm5㇩ٹ)ej;2"!C+ruk)@  Z;Qxg^+\Pƥӻd:i.b'9si{ݷ/̐aZ\;4~~ύMiO܍Qq<o]=|1_ϗq6|ǚ?Ii^ݯy`چǰ,ۭl. "B\O!#uCo9lCR'j߱b6;>jؕ? B4h\k] kO+}{;ۙ`>GuYO	5ߋ8Seu-.i-/k"&\R6m
&ᠵmy_Ύ\*b-n;o_//#WCi.v-֒}ڱ  (~es:1ŕNzj'z9UPȲGZ^	`V&;-jŕbs{<mf*'^Ό?}ffA#P3aXj55gOGbߞR2ŀ^A{'qn9w[*)_m:d>`W.5?_+1*Yi1{cUZ-c
~ňYlA_IOi.e2ƪ}xx?=eeň)+k~[-Ν4|FUvשG[a$_}p9>>9|b^f<v%V>UK!O~Bd:=ԺĞnx 2KiVA@
 ( $j])e[`3n$#5k˃W_k;'Ǟxj5ۙE"'=18^Q`yOI5<_KSCXaUX`%@xH{@}EP$bI\xb3}vx7OxT亞epF@sW7ckf-nTRdQ²U=^3qT igw˄tg_uqnHoR{M}ϻ^[ϖBG?FMۿilYKXD LajiZ6!	vOG]VK=mk&[!BOl6p_\V,EZ+%MJ3Fb8;vRŪL8Q5v=:`v!QUQEuP]eP\[gqjHр3vG١bc;9}: mb@@.B5aPv3[$@V<5{{:wjyMSr|}HOh8 G4G%(
z3bXFFPOa_D,@?C8,ЧJ8f$IY\ASՍu" rzgJY=#+뮨$A$xxÜ|H_%	xc_18ycqn׏4/!^z*@'s^Ezv)d+cmn]ȯj(ޘܐ;_:;CmbW{14%YBeC]x4f$pHA#ht~JMNAn]geuĨkJ$"Z-M@ zLNg
!B byd0/L8cxEXHKD842%ŪK> \~粷ah3fg')TʩlXԹXᏢ6v_o7ajn36(,O.O h	5R6cz+IXGoaF4}
fi#Y@U-(cmmG`ʍol}Ře4纔_}q<tv~*( Z: ,(ZYלp%´e+K#GPJ "SYöHOo]~c0~e'(O\c6HBD6NHĚԡj<*Ȱ<4xTp'U8ӑs}\8dxf6kgeVlN#WJ	m5ژÅW(ܒ"WߴufW(]q $ZK	M{0gn@:e$[؈Tx "h	XDg)V/	 &͢!M_O_0=]m;\bzX̐9x2ޗzz`[}ykuBn.]w㪹H{qGH̢^cSɈW>˻ݿqO7	⬡[#ETGD@;&~,X"A  s>7~'n?1 ?$gDIa9ixXq"JA
]MX~³iqaţUm2쯌SoLAUu!Zp 	$YZa قIs[ֈ92ACߒk֓\J4Ǝy!fȶRz(LI9 \芿^y${3 <ƈ+w~N&</_<zGc>Gw*YG7;uSjNIJ;\|Uk0nc,wEbq/Ez3bPV9xk?]V>@zC` G'NYa^0~3ͧ!|)#g?8nu|o0	W&u⌆7w7THmJ\$FZhq;R6	o%$,2>r~K22Og~Y][]ia^Xn ̧]nxO5+tl#wl	4q@"_(-M<	3bqOu9Eʔ9lL u˔
{p!t`;
 ;$J8a"{y^t٬2 7t3pB	92`CU0t̽tnn9CIfs4<p.A34Fi_0yVe2~qYULt1$S5#97ϒʲtgcbgw$"vxlcm/e8iIFg\\ҁ,,	|vs`ݫ7fS]A$eP@Ƅn.©Hѹ#EQqgUyJm8BSqbLauH&T&!Id~zY4lkd܈uTVi'-;/=e\˃cdzqs;h)2JsHiH\-i;F2{0Bz\H'BJ^I1wbޅ:uR}:L"ԙQ[[PS+zTߑ5[sa%CvxGDvw(t1řٞ<.x8dg'M\hp`Le`k
Y6뢣!)&qSyW5{Li8 ؽ	$LH|B*QUHh\(RfSXڝZJk
stDY#`䱊
{Y<*̖3]5y&ru%i9\IQrߌNVɦhېƫ($(ɸզMM^`7J<l9n0bs
 u]G:M~CFÌ.&QhAɫTXI%ߑf<^.|"|{F
in6L0W
yfuSu;dfeÏ<&2@pr'	E% gl	*P`|P.d:cymwHw'F5YFK"$i&۞BCHu柿tSs<9")a~-7ClWEL
b۱̛3<IO`ra&tiϾfMmjm[udo6.˦+RMw+:-b@狆-Z4ug݂zp29e<^N-Us~h,UB 
 N$'
5<w`,@bU]#9D@1!@h
|(%,n8pkNM=Qkb	l.QU	RqgtNrww|y}c{A`DD8)2CN+.m #Qv]r9e9	࠘?Wy6}roפq<t/X!_ B( bQf| ͟XyLe\Lٲ" &k*:<t=V=c@X_VK|XSfe(vŁX4#9SvvC«CrQsL\[2OJQB7^],mnp޾df-y+W鞦 tE<DayFN㛱ۛ73L;o*u<0B7U@l.+n~r{vVMezB-''^<!$ (MN!kZENڐF(c F3,zL*AP 0T'qaBi)q5+&DEgA?*i)uʁ	EB~pDp%ew<B@ٓ8y+4C+<5.ɮ29v\!Ua+aX:dAբ@pC	ݒ<u{[f-C d2v9K"7k@}o=4£q2g@V#TcVr 
-d\9LĨlQ	kZ/]YO%2j0tͣgQZMu,&850xʎMit&uaU7Tsʓ4eD:}GT0Ez18i'RsH"=p-u$ušIDeJ,G+jZQXFLP:_cJcX(bZ=C-A ZLGư",V[J"_y'@8Us8Nh o\AF=Ct鶛*]Q;k wiw:he]*D$Tw:91o1YnߒiLak}nU[A  yCme"@6IBo=4(_=I/:G_XbtL/^N-A<DVvhkS[ΣjZ}~nhyݱtU'<7ʇc_o&;zHDtjךurﾛLFciwVeg*j9{09zk~+ֱ߭T Loת?ާ/fx¹[XB؋S"pY":sf]c83tT@0LFKowlvٰc?Ͽ|]ۛ:o$yO\1/+'%ba6sx7k|>w.QnXٻu*jC_ݤWpJc1Σ:Q;tҿ6Jysɾ=ko)2	?M>Y+^|OF ? s93s;}LvҍCK%T8/ֵ]gOgx_qse_+$yXPo6=&۪TM¼U|E\9c櫑X@WkGTàYxQ_/f	>Am&o!jD3A^]N>QM#XmrrG^XIxvV<MR)r0{<y>m9@)K]a]EIm]Ά֗64YtNH-mF6n/&k}`~gϋ\I4(!РsA(IAF[!$"B 
@,Z&`n5AYZA&	N#D!A (QIjC1DMнr	
D2	d"ۻXX@`F)Ȳ
lmNPy[Lp?ϚW r"b)p7	䜚jj8iT!T;%RgCجn#*;bCM[dM႟gN aNP5O@:ͣKmqoT]\#uM`-`?S.E{+f[`۰@\3ndM	j(E
*	?F>زۖ2Dt*bp
Ȝɲ7eHx	@p?B所];Smjۍ|-y}a;^L<f(?PYYF$ʿPZŧS#N	Qks#"P\zLzN#gKpB80-<tr}'u_ۦe_ۇPqˏoj.R~%av`rf0,T;A7[#ӳJ/7eO]:Jؗ#NM(S8.rF)"j{|7HU5N7x	
Cx؀WsC1w}]
V .|azǨ|Jl/2
ZI";w,;֫7ur*#w;j-_~Hd]>=Z,qX.qKYk'X/[[-K.e[ZzqbY1`_9_4#_!ag-v{h)del}	;'oI1\[Z=.1WF0߃ds0a~I@BHB32BXnC  m( ( ,0Ȕ1EdcMa~CG0juU̳~~\=N| FtQʉo硣~M,LAL<o32Dkb݃<2P	  %	Z$<TmbR9|1<p!|L;	ϧ^W[l;qM::ڃzWw],g0{"9_ }_O<%bPe rɕ!HxQb4-Mg޲Ngo'X6X7!`Jc&L*b)tݱ 28`bg݉Z09pt 
0"[eO~xϩ~[ng7 'iX,\G185 H5wI9gCq8Q8,%;tS/A;^*UԸܾ8!ՐׂNv&Wq%+4xրEP~Jzٴ`(!AA̤F%ӗ2jklTQUDC`0r+:<[
#3|,:. r~w4K(<T0A6c5.wlIdߕW]&W{z;l08G4ccȯe,{r25o@і)໚ȤK)ߗk_͑=>-X.>lFb rHQ;A=<GK(2
x2
Rċ{oRTTM{uyA6znn~f|ߵ׳s48Xr`=vt
n8C>	n/q&Yp#1!2"BI$c~y"Җ/I	LKXǨ2POZ2~vyktp}M=NX[:ΖaA%y{oOD
8"V3&/Cw7j} 9u=`zT_؝@P*)<s rCDCz43;> bX44q1u6V@@icT|"gϵYvc]aH'HUL$1Kõ^<Z?l;E¯)~P@<IfrBoTQ^ myU񕹦lLMy)b֭ :>

cbҟ~/krd5_Q4hF󘑀 c<<?<8<~K:sn'yhؙ^W#{{܇7u$kѣr0W(eP+CEe%c3Ѱgo9Us{e,EX9Tջ#2{yMU"+T:1C;^]ktM< GG}vbe+2ln]0{c(EO~gVxKFTT٠=hsqԢNt'2ӱFds `${ņ~bZwdn2d Rmg]sbEDDQB0I$rr
`P*,blaBrV yyiVlkIy634AȓwG EyE'2<Y{rGMCU$1d"Otn{88.r߶rD`H˗&Y%A	wDIqХM/3t狳D򫝦d$c\ܶKq.Bx.aa(sؘo`KIBiNJANP;jV*X\m'K,b' l1$(IN,(>3JkbFTtqh̡3_C%u]7 {c`'ombs(p5*[YÅNyߞml25U2p9[^u観XҶ6YoO;N`˘Sȩ."}Slm6CZ⨛ r¶R#%C!$HB
s, hڕ6y#GI[ G(-WgF;dGsܔ{MKn;Q&O-7'N< Mnv 6a5ʤl{4vl9cVufaaz_1Isa]bsYb1d9kzyLGFηgy×[[H47t@hSX,)$*aQC-L(O,,S) dsl=۶t :uYI?P5#U)rUl~bBL~;7o9t#S@`?9i袯
FNu>}x(F@vf'c8:	Uh*J]uĿULy/
.e6ـ3:?=# >6-F8._3rgRZdhxQ߰.3XJ!3V@<'q"OG2\	{v}6B4^qf:B@K,kO O⚿/3qEWrpH!MOP9 ;bޛZ P[+zL4ʁ_YxIMOڄ QSrB`q> *QK%cz+,DօT ou?|s=spW=Zb2{ղppc5m>-Rz=$U[n'#zt)lf.ʕ:p   @@%ᜦ&zZgN [@\+
F4c'҅H@Z@dB$r)iG77l&៮1Pså*~s:b4}ϧR#wH@9t?ŵ>;7n9L ZW96nrJ9~b|~aIBV6|rҸSN͵Ѥ#z]jz4}Y#Qh)kYt>2uy_zvG8DT Ͼÿ4\:s:D㯋+W$kU\ʰ1ip(a/92Gwew0}zS,*Nu-c0?m60Ri_m'O0k&<镹!gJL#&P{b&ix	7?d#I]T:	"w*3@_&j.'kR{-yйz((3.V.S&IrnzvF_/=Rg
_Vxn*ډ.Rm&8gPQ ȋt".N-{`8Ǟ>-|P7N]+/(i:&#ph3u2Ay<OOOXQ-Gc@p9_
K~ڝÖ0uȡ	5#` 	VpʡzMWg&P)fJ룫*\zza>dJ(X[c1N+	5u
ܮgZo#!e
7xeeŴ.\R+Hx//`q84z}Yfƺ[PJU=k9.Vqfl5K,B8^z8_a"(wb
ƾ=[|C'X"kL1wܼ2tfM;]YdMfXv}׈ϿR?}#׉}c!xt|rbx9klh溲+rkJ2}Htl0j/@kê,=RG$1˽HC\/;uՃ_ϵ(}=L5-E3c~?｀>ǊP8rΉ}tc1
af5_%[#n5:ѹBaY-cf[SWs8UV&}
1o̙,ːp$`%wYմR|}Es\PFp x	|Lw9}MU/D0Qwn?'0x0I;Pld7ΎǯֺܸMUgCf0<C-6ݯ=^gwxa\Mn].Si6_N^@ejZ假Z47+t<H	R) Um}EN*] 	=AL'UYk8̘vzKYo5~C~q`{ch>n}/<Ic3ZD. cB_ ${oDl-dK
}\yjmnA^9;ܮ7?GcD=עϒw!;,xdrO13xusk?:ziie(Yr+2r.|pMslOas=Ko.C˼wlLHb2,` $yy.ї7obsla:S'o<f{=Z4S9 2Ǯ^cgvAV>0ÀfeD1x/[ ws73i㪑=?y5v3;^_U6TYk+'rLOr,n_)0>Ro_- $﫨iwUo 9XZGB6/
`ԥ ,3NrG=?3|/[MfGԈ9T"3sck`=Jxb8%:0mZ_VoUQFA4saYT}9,"oܓ>{zmrŜŉ}^Z7~#[ӿ	,c}sC ,tDvދgwz2OzyKL@wTYŮ!ۊxEdL
P,S
37%&2Xb!TTD4b>s
N?,,DE0!ӤDfJUe泏ŮJJ<ǕkCvӴ7HfF-U_Ëmp:"bIuzg[OOO1ra̘_8LN7Ώ ~wRI^|-U7c?@BE(KXENK("JUTŜdHB~-]d
fNIީ?"9Mh]3Fàt3f{θ˫n1 Eg -Ws%?P2+	
驎ogWz#:8FSmͱ_FJ5o:9f1c\#<yļ///A&]sw( @.QZ_C*}]yyaGI>ip|#Vftrơ/de.Z$H1Aj'd2MRQ2=NfᮁL"覞~T]QH+S7TJ *^t@?^.v>Q!0|~~哓޵ܮ6sٵ+hD:T1l\I['ٴ2xս**R)) Rh+m3܈fGGO6#m(Du<Gao*d}DR Q$ϩcfVc{0=7<`D~5Evceo뽥y"YB9$" ث!bjMUhq⺏ﭢhlF8q<csmMw k9:s{`uY )ڂ^y$<.S"  .p YZV%!D[y_ <F4,<NZ&={oZ&@+DXDqfBsnW	!f;w0m 4e)@UPQh?-]wG_;t8tTc
	lXV/`rƏEUa#J4]\PnX?vG+&d&!
" 󻴷|e1@=w5V/cGk\ww@I3ts+/{.Tao5W{}DN,vT'kȊu1xJwG鞜PQr1VDoMw}%LkYwWms.Zm[2P%ѫ%^"9Vꮎ]S-rֶb!3c`'betnӒu3zi#jd 3Oθ!P'ł6Q\y!]L0.f~|BΦnzUK	U/p|0?rE:;ڳm1QVQt$tUZUCa>UöE)\Mb')b9sd?j}iF6O1}28wb|-%XfBj`ecUXXv^myǇd6bBPa&;*l
[TMI&smh['޸Eo xjO}Cx58>&c$Aš.'>gÄHko8roiVA\"N	ٵuw^kG	{$X"	Rkg }n"_yƥJ>:S+n.0U{M_ֱW7%]ZJɘr\flLֻA^<VR4ffǜmU`
ۆוeYQ|]/֒ú|+I/WEL$5u[`eVV&~VS-B=>l>OXTڱxXFɫ5a76[1{O)/B<!C!}rxq.?bnWN\Jsn ,=YCq0_ֻ=AzZSbFOb^5qYSEzV/pEmҹ.I~kw^쏡g9s֫#~j7yXJT>G;hJ%!qq;` Jnze'?ʰ8NnssSIZg ٜq"P"cØyi6`6 ,6g|cz[QAZ3i62?D8zKuyɐ t*Xqyx"4F53sGZf<wߴ]a\th7^'ĒDR("D"F+|^CocA)&^F EC~.+H@ P\KQJv~fJ^tªW\6qmdy/}[_oUqzp3A̪)g|G|O|RC7S]Sm8 woF0qsՔۍ~z%z5Ё]>$Em]L UוxFkcw󆽤_x	oC"'TU3_wuDb2SۅT^v.3cu<bJaAJU=Q;:(_:SC!tL^/&/5LiT^[XQdv'fi׈.JyK,jޒ/be>b 3C+ĊY
nxJ zYחbĎNF#X"f7>ؙd3#n]8ӻ>I&`p3ǰ8tE'qibO}Rhde@vGja! GPuMs{]*n*: Ur]|unv[#R.J>$w&6~EӘ@WDl4:UeyWSwWͺ<uSx,QCAC;Lu w"!Zϝ+,5N9~i:eGH-&a;k2ĈK4:T`Zd|ÐDJWf6TLVR%:Փ #tF"?_s?5(6D;EuT*e|1)\r!fLPrUl0>:zTV[#fbGG2V2sIm H!w0_Ey?E
aEoMl;οKNh\b>mR}lV*~aZg/¼e!V5ce)29P&׬1M$dtsuy<2/L*lxKL0+(Bc !XEpml6xNsp=<w4vN 	{U*@te6dtA+6+]<]; GAjglQ%{#nLO&^~Ηv>q/4kwys$SE)wY%ҕ9*g}ǅ<L=g&6
g穲I a]ڶg8\,\nt,x`Ȓ}SA(v\ֳq!fqmB"4Tf^D""棛Q߇-^t7+n@e |]@  ˽u*o2WjEŽJr܉9c$	XpHԬqBm!C\I9uHk8quc~N;XDg ##@
ɫ&uޞQS1@T|tW/sMi_AR/u0Y+=<h+^bNlC~y}a`g	h $ ~`qp[FUxbN0*\W@M"wVtA*N9}eO/~'W^.7ߩ6V Qnk%wf'	"^Wg9zU]23) 0+DP[" P(.dϡ(AUrR"!O
)q=sm:wc"зG59A2^xZtO^[J.jٸLX0/1q{'q|.ˮg$u?צ+m;+΃ڶ2OLYo9.UrnkL\-Mq.hw6O8g t~<#B"""EPA y#4ɂ$hs ZhzEs)~틙_wu O^tZhG0N)tBrw{c.G"+k.ڦ9zo7/Q,|3mI7xjk0ٛxhw_pa&ᝋ	h/k`AƦa2s`|}CnC%cxQT 	7
ގVٞ +FDH R@.77 H ~<PxGW[_B?)
e'b_15}SԊ㜧R܈QRE8"kp.mKD|dNq=$R5ApQLA@@u D|-]"kYZ]6H<Ω7{_*^F/~0o;L榘h{d-uaG)A 3l *⯓TY1#9; sUXp[589``lUY3a FIvθn7E^o׎Ū[uق+<ST1('ژh!ZBCy6WuF\XV;O55|X:"ܨc&MRhWfWiY=teuŵjj.kfڔ_^u>Pp4!xe4khwUwJcZQ8γf袋$Vekly<-Jf^,,V*~Bڪ/I9ټkI'MzCy!&]w۶ zTflf` T<|C22
+8~fhՕw.TlBӝ4HX]Wȩۂl_^?t>VVw*Hc]Y.;[}cq]8<F,D0g6u^OwB!?w#mzPo_8;Vs~=yշ/s~[&gERٌn{+y:x\U+\.zIfU˹p`taro_sDAv_Q}|ac\,G/LXwf0QWWǣ/o}\A^P{to5fCHXvp|꺏(Cl9/VU:XUJҙufW5Q~Yf1^nm/X 5>ϴƓa<>Xq<@.}5GKHQN,='_~]mx=9" P	i|]{rC@%	#x?X{a!vrK̒ "N\}1WP.u
nޞ1~PH$wO^h;y%sý9|{w99QWXuˉ<7ؼ&b
*pԖXDQdZb P;liM*~Ͷҿ̰v-:݀( &6S꽯65fHZ.Bw>:J`rɛ(h;kSeLI箷ES\8CRIwL9</嬴1-Є@m~}[P>w{7:/a0C'_s;esIc_;heXh5CpfPXbt^>C\ƒ!L;}sKf 8WIU,ml=Uu;q[UuhV@cM~"JFd_Nr1$B5 &U1,xɾ	R9M`sn>4fbNr7}axiwfȐ.7]C2<|L)җ\V.4ssO>ϾMYUGFЄp]^-3eqs 0.^3؝]:ewK@#lՉsDᯊy\W 6 CǱ睄@C)쫴Wǫoph0H	'Kv]:1rE*7[_fشudn"PD*w8}'D .	ՈsG;r"vly(q`}5Я6lRJu79Y=ZG|`f
	qZeAƾ@NO9/}3l?}x4nQaz龷ʬGO1~20TO,G)vex-.܎to,uꖧz`5',5c/Oح^(l#U3~D<S\Pd3;"wHC8y焁S[BvNR5N$UxI&fIVJy^h8ҬP)QH[z)b^BuPD+P)c"t<_^uvޮ[&6W^O`.?mmNc<cakw|,)"<ĺ̉+o/{}7Gn㓬Zmu=4M?8H{IX,޸@d_%]U;Ihiviְ9*;"pA\`^2.YoTڻ%4cq]-/jaMބC@M)4&t'+Snγ"]}H$JBkQoHxD}I]~Iu3̎t+w}N?="ev=C4 @_aQH)J0nb*kF/~5t^H6;ڕhM;W]vjg87##:siuޯ.@ŭduӨuuvWmWpVLY_q9:/n\h.#%<IH @8мUoifkK{M냆vv_n9,GiO[=SPUV Pe	5))XŰ*%DY*oЀP@3O&o?kT"'r᢬?:f,Oq0eM*;
5WC4~isBÜY[YL>ly
98mZw q9z9pנFDCŻģ赤c2ڱB>
[q%m&mhYꄁs5yù$ZnUhTIYbୀҗ&i7%rm$XCFII.hLACy#%F2<ZJHGBR
thR)MLIr%)`(稛+_[o	Zd!E1>ey8B^8< }ɉ<y31͞9N%	Mힸ#u08?@^·UWq;$)(rˊ?=M2}(I=F/2=A
=f$ H9|P[w/*˕ћ,4,^rfkvpiy_U9|»|uN}TYlwڢOPϯ]ozkg]z`NiMa}~p}qix_ ϔ#$ JĤ$m'n&	1>Lm$3C꒴CDJZP!F.N@{Ie6nOfgiK||E6 )N[#A@ps]U/*8xGkAuQ.^eL0\$n|hxBKdǮ;`C0;O=|;"wWVzB]tѪ.j3φ``PIhE瓮_Cߧxw%ƲM .Z#XʢOJ?-F52X6AC+ҿy?ݫOSA$oɃZQq'JJ'W/6ۢȹvwzZ3a@]H?4j|k?*[6}Y/FD4b1jr
Ud͔(?ZjzOge&1A,}-&z~} TI;
G}ފ<Qhhi5ͻLkn
+Ǜ5̖gOzPw@9a&P?d慸n(Bp?hVs{t˳fό8Fq1v2QՊV'"'"2;dJ!
qP!GB/f(jߎ%}oitFsGST(\]zT q|VS9^F;mfd~\JTєKXy)Uÿb+D=5.|*r5ܺou^sƙRV#¯v5ǧ&'/:FGCOM&HnY+v#M{in6[n nWVW3쮐O8s8^D0H
0
X_8*|!Dⴎ;$ufb0HġX@qW!U0O{4kȭn*ЃS0"gF\pz1<	)yFHX	-Ljm/ۢ|a,<]x~oo40oS"x[.vCg,Ce_IWs#]~;9.`"oJxfڸ`[fGJyDƋ>&87	M6HăY(Yif:5Xn1i=edbaU\!|Z\e	n OyLSR!vV؉Js@~G\9G!YXr3<#-$W;O{Ȇׄa[bFE@n
XW98c{{8;Ed{\ͯGdKشΙ?:tE!Ue/IV}JaV#-9nik[QgrvBImyioN[+fϙ:+<_ݝ-Q|!Фi{?&c/m̅?ygOZA')!_WæFjUd]ս%s'*x͆ؔ2KƅzY&۝&yWq>{㫉FתX6Eq9l˗?	gmFk~_bݤCUo7
쇷rt ,?/L)9a!HPSZ@OH-Rh\??񣛏ݾ't٩y-kn&J3EDںwItļ6{,D?xkm/Ndz.X[:^7G6EW?ԣƺ*Ci7D	Pv,5'd!^2;PD e!!j^q!
@ +l YsW̜6s<tcF @Hqٷv
nx#YYFIVПS-ҵ:orڧH=x	(}p4x=QX4O<O[[ru6{o_sŶӟ4}&Xx(wzW#;,m}>+"SN!dj:Ghʍ!,4ϕ-C84`^zbe>
T}lÑc/(!].i=2&E2	?5Wg+٫8yCbwv
8Zy~ *FAԀ~	b'$SdQ*eQ+\ W?ygB |82x0
8hڣBB!D;[}sjB0!*ę-q2Q{_m$17-~½zYHfyAus %q5wFiw#jf)F0D}w.M[TI3&FLI$Q-̑o¥WJ<؏ynK01g ('؋FA5jrP>V0PGB4q x3?1m&
JH;93}R[d*rѤ?|#kOa69 @'癆%!#]~%	wPۏ)qp̌/.*JoQ0	W*Mc|W(d(KӲ@j H_J1/8)^0H.턐νO1o=,ע~e=fߕjǡfeo=zHUkIu{2?+jȞ[l5U{5CPG
#:$4yu .LfvσNۆ$ɂs+#pA3u{	r0/
YbBk)W#V܂rΔ>c%/gyc-P[K=<,[2lv;o9:hq}5[,c"FԇJ8ɥ$ \cQUc*py\G^NAуbƃWb5Aw7ǴD|PHZww, 6Q'(w4
?S&ɭ%WE@&tK$%4܀9טHSpͯ}3bbr)zjVܲu']]buWVDap'7Lƭ@П-VHdk=u/ME(NiBx^j21ΰR}H&u٢DMs&Xs=o|3EA/75ѯd.d&[};oq9ze2K䥸܃\c}1A;j)!ZC<! ɻܳuZ =IWndY6GɡRq:Κݏ4eXy%MBF4@
ޥ Eǜ`x3EHYQ[HFLæ櫾g;L#F>jPWU}rRϴבn2'RDw4O%tsp3hq0<W36!(Z6(\<|_6mp%{,)f6EX7L@-iԉ73LSzP!])aX%ؽ	|%˰UR'1j!e2^"lApWڜb*#8?w}y]o0u
֯ϲ$ͳSZ
DY}iʠf6zOc%މl7x(N =imֵ4e("HtJDBx?`9ʃR svXN&<QDb":(,~5ִϲW/}H;{
qbt^JЬӡI ^18m{*lJe^,j'1=	b=?\z<K*"taA3]zxϽ	ʳ?u D>#"^XMv<ҹ?2WW6{)[s;IwSqT9p^O^eڷm5o^4-pr	a Ɲ2"`cAN	QD0O#j[kHӃ>O3k%j;~6!ϫp7JT?v&`8Ɵ<wnۑ?	\[/t*9tX5uJ@(_hc7v<K	0;!}M99@-ynG0n<@.>BG\=k45"Em0	BoPZu\YrwUn1C/~? z(7]#ೋ&@?3osS{7Lo&A6rZ'u6_ֺxtW7>@u}IVtIbŨP)D*IdL U4xz`IxƕGg-v촢FRvXZk[ ۅ*){g4lÒ`$A#{J/b\(pZ(Vb^RcK|,gV^sIV(<Nb/ArXîHߟ[5yx_}&2C:[คĚJ0].U,75!UlcmB'J.'%x|Ys==]a\(v7}6|$y$k0G0 eq~d/>O.`Uԓ}.atZlN)_";rz9V0+ Fn]ʔߝjsP
pGnm79'Y?,d׆ Y=9 @ :4
tYm[ٻaJo;{iLZ:ND+g-FvV'-쵪|u-UUƋGgb{1Ct!1 _t:9cF"<ODRQՅ S}b,[mdzkq)SWO.}2`bnLsB72}8-۹kϻ>ܼ5icǺwsiv^Bi[#@sBX+A _0-n@b0I 1JQ/+^Ř;De͸,Eb́?]Өw~9]E1/6K~uȼ4@H<̶vOf1/=/)VsbW2SU$(;q沀6|;22UY7|J=z5޹jJMn4Yoo/Vqe,5/e(G!ztt&ɬSo$k|kʚQRg7E]9,׮t.-@,-@=B{n<C(ۡtY&\)^"uExTp:Bo4xC|.ǄOO8G-!ȿscdQ^NiG4Ӫ-}HGd$͉ԦwWb{vJ/)LsJdcU$A&6e̘$l<m@$!	;mx*8  'mKobZŠ2 lHHč\۸QK_]9%)@@JR	,1eJlFG9֢]jjbZ#[Y:NdSg}}Y_qjڥ]|ڕf؜>Dnp)S@DVm˜!P`j֞S!8b0'WVLP,ؙ[}V[ze].y7xNK3e׽74s@WoiԺf[\$մZ&ަu"%or)#x@ʠ32KZprKBT]71nz'X/T#p`l!ҙ&2I#5/ݡOOOR5D)H݃[nceW]V3JiZ=8xW䍢zK Ȃnw	5Yf(!
{v̼4^.K@之r>^eʂvLX!xt+:3$ύ~̞jyUV[U-`b*%FP(FPߗ,\S6$\ 7y/p`I =.LzwnKpf⎄ojg[vMhXFKK*nmQ (@qր2FXi8dVr𤐜)Rg|CMRT!Ut43`X.N`5L5!CmɼfV.\tJvеD^8l1kkmPH=}2X\]]97s`]⁂]e&q-e7vkY]s #ؿXZv6Q	4?\#wD٫e8
ûW\fa7׷]/FzX:|w ^OptKe#:#ڿg+9:@ !zVfdU*ĦZ`3{OAӸM3e|Wn0h \gqה~JLNgb}+[J˻)ؓa	*N+gVR%.%h1"XMaQu ނ2iNMN>(}ըȘWd&ڰ0]f fPYaJ6EXq*==>9'  1y@P?;
.d򼼀IAaͱjLfPVkcжwW3za	Y$q>O¼q/rO$dG0IfTb׀&x-/>pEB
 b5P``oyK¼|z	xV|P~.̳dZͧpW>lN8@`q-paoY^cW_3<{M(u0[)qPXo]W|AA[75Q0?;*42z{ coe:ql~Vdˢ7q9S-3Zcx%2(m~GY~،4CGP[ܵ8s-uoGDPE$8t?['>#uO|)^;tڣ}DP@h}ZsdͳW0IXUt3AS>(Y婖/:q&2sMsW(4mAЌGRژ͛lo҇f1KİGǙ,ur+K{T'Q4	u4>f;Y)+]?h?GjD@AZ#S0v$2ʬi7U4	ᵭXlkajW&b6dS/Q}{<240&TYGևi8ߤl(,]vsEی͐O0^pqZtk
HVK>]yLT<MTek䕓⯦!gHq	oZi_yru+[#`yg;B`5a٢)6=dJ zSBN}QDA&B>i*ly&0/Xs(/ ~*S"m:Wg@XV<t,Nݭg&,YE`W[v;+Gb7e%Gbǋv2j\".E1*	J'ŹR-6uAg4A$C8~w뻫}/tn׵YwYfFd?	w1ltfPv{Pe8I˿%ٵv.ZMv{ϪowXԻ?_'_>=M#@ѫsQC!rFrV]K[.[NFuP`HnTbiKͭXV,N8V9׍aS>2jG[UDޟO8ͻ֎,WLԃId([_BE:..&񳁪+AG6xYKƟ	1qjhIݚck>N4i6f,E8TB*ƐO*kXȄ>P/ )e\F(\]^P{cngIB,
"Kf`I4xNڣ(@0+]̋7N)Sz%Tf14V?M(-ףf}-fߌs?սʒ^C[!mn!`(Gl_G}r0FM3rY 9|URq:/#!Im3|k1=FZSa6oǖ7_kH4,`è}-<%b}_J:BInrNV=v#>0p?bOsMn~95cblt]w[Ox|OqD+gD3ｚ-O3K=20ؔfr>y;@zae%$l2>G}o(gw4GJ,n]شr%y2=|Avq)O޲bcdo1b,  =؜8=觋wv]|Ï{۱6?bT3;jƙ}l:1J֨55\ojwo<w G,FbA;ttif^eaWs/&<fXc6|`."r^YVp#O=zĎ¶z+׳./W:neaByws wZpn'ZcUD"#hDK*cDn+J.4I!xK3֝eu_//~8[BXm	YOKw[
,F*Zi	'YdSzcވhv^|1#1}ng( ܬcѾLOZ+#~XoLu_/6AnG]샙и(O37NF(2:=wlOwc а|μw8?dQEA)Da hM(.-AG3&GaNIdB0Dص_HmqW<)s#dH3NS!(&9 "]\2Ofq8*SP` I/cNKq-vPz̮fLKW67nc#l*+lJ6NֱYY^*rtov ^2""_86yR׾޶]	.2q^DO+@y@#k˴8_֚juÕ
T1A蹓a<%$㨠8!69>KƔFGol>ͷ?,s	X,>^ @D c>oo1-OwVǞʳ_nfhEϸV`MtX\0,U.I[xr($!-.'VOLZ)a,s^7jE׭A&=i|[(TI
`AGr`)oO9؜7M >e woѓiIۍ̬ěuBC( o?m05~'pGB`tZ,d|ͤ"?{)Ky1+x>k߇[?q7W^?>Ts]I#[T(Wu@ a&LàYE)1W꼎Gv_xM~qlsp󟷓!8}E'1!zՋ#Τde;nr)ky-Vtߝ2Ȱ
docs`ix1XE2I.եyV+JFS"kotB5I0Ua7;|7{TM$ÿ+FX@0q&7^<#!M =Xb!0_o\ħ,`(W^+ׅ	c_Xso70j/=YЅvꋜj᎐e~Xz*k5xw2fzؒ[vM;GN}@[:Yl"y4}ȭveRTN}Akv1t.T7SE9[YUgVNr!LHIf0QQ9NYOe^V')PM{fik].tn]o#.g 7Q;ʁݳ9ܪmJő8Io.I3=[uIK	EA HnowT椊Yʁ(̍*X_<,c6J25듃{-6T{\;fփbݷil:ngY^w7HJg1Nh<[m2Eؾ]<_1!CY$<TV\?~`]VVƮ
|܅g}]Z8}ڎS/>SrX!G0x{ZpvWr/T>lݯ=9wP:(样GVyux{'20zWsHLUeT V{Fܡ_{j*\C~6`biG"	&6o 1:Oh;3CP۷<HSS.󜮵LlS]@DwC-R!PX;{Qi,,ː pcU( 4+x߯+ڬ)C*|+{d
pJwNgöfLLi^GuF:Ye$7z__WAE&x u/C:c,ìݩQ+A&v-f兆e!c?xtݝ
b6f:OPTEq93j/-fg&jY+]uvf@^kDWt<0Gkq}#0bE\:v"c9,b]mYEG
c<Y&c+ 1b E5}VT4<R:GPg.,9c0ܜNv-zwkqCdi5zbӮh4\inGc8y>WZ-rrQ>ytfnX|gz賝޺wCn{;5){{,BChn-Ŋo->M'5z\z_(]8z^EgkƐn "(9ޖI0M{pcY[tkG;_K_.;{VS=+?u+v-AG%]l wwiݣ3:ϡ4VSW; 5 ˉ.4eD:DF& DҘx,ecAtФʻi첡
5Ъn	ki"D3d9iעXw3\.M]pqm0R$w d$4#$)BZ\KG8*~3ъf}㛗 t!N8+ːp<bCP#P4y" ) =0UVG&)N ;7|Vx=UҶןxv%9hRblf^{%sBC`OF^mҞ=*
BLR.Dp7w7K
#Aaj]d-ZWc0:͍ɓ|gX=OI5oXQX&RǶmaV]p(9 Ϟk^wO9ˮ0\ǭQ}tBP_]BL-c&^RIۋYbUR	<4pO{aӛ=$z`K|amiٱ=#vHHL@ˠ R~vHʜ]?ֳkΗz."L@DB3|63Vc{)^5Jׯւcӕ63Gjr[Awv@PaVDeL=v~e}>R})YCJ11qB s\ᬄ?2%,Dcг`&MiqxFzP*=܎F7_G., I&+̏>.ƺtRbJPM>qwb/zm<9p.\@u`@.},\o ;Hni@x;x 0W ]kj.vT-[=Ai[DYtx,%"X[BC'Rq@H$Y83# 72qpkP	 gqX|#.}|pɞ~l:Llir7N_a*Dgh|1&W V
;T5tjG!5a!wo3Y֥V
]/r	1	l^H?zQn\ n&>S {? D_䰛XVJA[ĞT[$Y{?ׯ;(87]#u<i5ܚjԻY+|i=xsW:<XEsc[Ѫ7ZXUV~65$^n.&],[v_Y'g+ƫ3[`Ik/,N08T\ yG"o
\y<;faK`9G,%~.T處DXq/ZRv;˰v6eb Ϝ3_ZΠW,H.ڽHAbQEe^V=7,P'7N?#_C7vepeYܶמd?)}0%=Z5lVz}P~7ed~}H%fEZc봙% 9B	O縉2L'?ܟYf1Bp622\#HsrSE&gGX4rs+U\4J>w}wԫ6ZN()Bσ26覥^R&Hl[mgl"P ,O]ca#n8{}ޞw=)[Wipzڰt>[~,9{KV\9{|x2[{߫NZ,:{.x nx'-oR`Y󏍟R2G|*n7ļNIE9ĲXX7vM:B3ٰF;6b?{~r<iZ2l²5#kUZK	_7淌/]UgԧS=rYoк#>kB |Ǒ4E׹+@>2F}ΗATCI]ɳ:+U̉e,|C<&G||bzDa*^V&U*^".   8k2/Xw}<F me*{3j&ɓ|߭Y8E4wHκ6FJ]xnvjiP}omO5|F}dt+*&ۇ~t%&ƠxLw~kmo]&z=a3yJ|@)p&v9! |eb '+Vr߅i0L|kfZ!@d7+̄[xfnOb輏pw%`1@DG0UQڬYDBJUCUHpqQi6뛢yD~6޶bՇ$&[M J7i3DA,ň`4!/ڼܘg$!Q䡑B#T5}ZYb`)eMBhF6PF	rv)36"0R$@;	AhUEbRhtR%acajYD!L	+0	$$ Icz.Sc
&lF	DX8CIDE3I5wSrf$CpR0@J&1DbEBlj8dK?fbP4c20aA$^4`²Bf2i $u.$"8VZiT#=ɊeaW5d#X-X䂇"<㙱{I ݆cE3K6*EBGFH]rm2^]oir'h^W^0U;f0vt{DSE`rG^HP:65qe)Y-nsXk<ŋwqSGOuϼ9E[|«ٴ'QF0o1#ัT=ߵ:3S+-54tvPw.4cdVlV
Zx܇a&bh#g^g{oC1AQ@x1W-~;3Zusm?z5z'j˸q`f5WK.2$APen^p+	dݝ'ўo`F!^ hc:Gȋ<BU[V]uӍ6ʙ8IOWK]v`˾O펒Q hAa}ŵ^
1^;(chā׬or @=\P, 9CV3;Fma- _*jYdLa&B),rKmww,?]IZ"5νs$i[ծ
>r`fTdl\^uೈbqmJ-p* qWտ3^sjG|`쫔c6Hw_Ӹ7NBqi^	ȶSDxPs6{o<odl*%۬g<9mPۂ:1Fzozj2J(4L_xmW|XwHRѧ)ۯןmk<õt ]a9XOV7	f*A9-2ZwLz2Yn~/qVAjq)އ説,܇xmSIΤV[ā;׾gy>cP	7?1[6ԕhi딖 (s90ƫWOX&3ӳ-(	^~<;<=(m-SNR@tPQiH3.i﫥r3+;FJLD.+
+˺),ekD@A2ikMfdz\߰uryI340:B)EiĒ`z4@GrT5h8s]!=nP9Ok9/axP:G|@F'a- 	5ӲQ.ħ&l؁_x#zppm2ssv^$uyv< VU|>_p^\x]ϾbGJT!߼0'}|BN[uO=hii#l/,uΩ@BRӏDwVΟx2%ilb
rQcX{˝Ec) BV38zOgIw"m_u3,AHQ,cu[u	!Ccl5y=5ŷV& K>P8l:@d
*
vb$Rc38$U`m4 ދvSY*%]4hjkW2(9G۷jϹ `z1:llY#t$ēvXI"UĎRKR  #E!.=yׯSs{|>YQ-"۰,XRpLnCk~)"-2fp5rZ#ufK5o?Iz'^_x@=A	ۧߑΠg+VJGW]46Zddաss]R++F+8.$F"A 3Љph0@%> z /sH⬙H+IYj<y݇;wWyIe!?^WG6.eUqV?]s.Aew1ɼfÙygpwxǔKQU꠻sʃ@Ӿ`xWx!;46$-z]C|\#~};2ԍMυ>/W_ݵ6~s\+5PU>¨IOwB$83reL\]J	x0hqnf*F{J<^\\,5淛6?!h1Cc+Hd>h1uAOE*=yw!p1CyzATT&{p,^`>F 8+AlMka-qsgQ!OJaj>:ݠ}S{icϭcl2CnbP{" <SQuy#Lۃا'm=ioɃRL,|S)o>l@zLzr}=Wkaiq~lє-@ַދt`\]\BRѕ~95edc7bt}$W|&)	2oc-<}oTxec'zu`1z^|}VK ~0%Wj{tulŶ	1֫k2ѻnc/6nvX}?zp:*h"W{Lt^BLpE`>H2tٙ9}+;@v(w:!|p~yk5I%6ez =ZG,|V7O{"Ӹ&Ype(Gfi4AW4PBb~Z׿#ҩ33}EY|9.+z\QH
wo{79x	m8ƃe8텋?gvW,*V1IW;w`eZ/fk-4b$ū
@`|OgMo59n?w"2=>gFElupB%լ1]T1>~ubɪ[t:kI9U(̰d+&c|gFF%M^=]RZeUti3]9_ybȚ%JWVݛd|KZ4?+ѹpl|`[OjQ_ieOX:IyF<jEOk1]̈́
G×W`١d+<ǟ^+']կ);_||9[-nAZjuw!0M!rp6ˍ6㩧S[{koEew-'9d%륺n[d up&p9M[&v1b+E"Q~Sz(rB&=զ4/xVҤw  _@o̖h3m @/n0'&X( OLTq˟bg0H!H 7\䃉*WvYkŉ!m/:8'8eNaOXBZ!Cǘm/	F^_]80NC(~5]:<t~7<Rp){7?Bf,o5!1]
dJږ{yr޻NQ_q{muam\x^*߰(zi_er?#mtEP,o-3,ێ+@Q ZK"ۻr`~cx[E٧`<VXVCt~;`l֤c: XL.PreJOGMvn*o
Gu<~+kӷܤv{{(@p+d,i^tیÓ6_;3;1YQ8h
#H)^I50sޙ5&<?nż@6bZ)Ջ@Iw~4:PV>7]_nx5~5h
Wh4g3[DyTۇw̙c1ԹT򵅮lkb"6vn~l]k[brFW97*껱)4PHPSf	Da] VYb#Zi xn+-\ܼ#XpnoTxDL=Q_odNDPU
𵣣_7#]Z􏇆:;>H-C$a4	i$A^KYi*̯6O䬎fXյWu՜m}1e=2{ı^j#%F$q2cΘuwר7v8,jo9/NM	<^Y%zn)v"ƚOMuEZBQ;<JGʜj_5~3h]"@XAթc	HLM `+kk jމUZAXNX]:-hr4n8A7y%xBf\Eᚐ;AI];ihM4qdkC^K!JAqMq'I[|(m?/ߞ!/ap~!i0?~Ǐ]">0°9堉iSc5{߫_ v"g) T*P'5=9*VW+k~z[2/);_"bJe,eHi`ٓzϪ(Qs 
1U(q W,,+aí6ɤ,eI=I}BrL*Ƀ U<Tɑ i O@ ,@]$Hz.HM&HhKHC2zf3XbM]Lh0.d)jHdI͠3dɑM{ Rq563l)ʁr4Yl00	-,<&11*+Q*ǅ,-lw(\ZTB  ,1i""`0`B.Z`3p$ IkA XZ*P*TB Bb"0b(PT  ~\c0#1Uf_X%,UV#d(H#r"cq@"@H!@E

 4(UH P6huW?kx",0bbX/%XdEEUcȤBֵ *Z"ɈҾ:`LDTB 0V1˰"#1R 0XV01"``fp*@$P P$bXCZ&CB!032*DB0X-AEfb%)H1"aI!dY ) *2*QW(\
B-8d`ԑoł݂E&cIf5cǏ	1LebBEjDDC  @w/5 ~lԂ<y瀀֧,eN9܃K0"q[v9RFg;^~3et::k|jEEqI0տBѪT}@mzAB>fIL gTBY4Iaw?A0&4%]}\ D*QY!C7,o Yt0J 氨A#
iZ"+(,1) b D̒H"TSCH_yhKA$,
d%_QzXm K=H00I2H,"ĕ}\nd!}W=ReBLCdn dY$)@BMFH.C!I^O;V!ˑT!tԤUP)R
Q@X(UX"AEDD,"!/aq{-0+H&;PPaTZÈw*G	B!HQP4]TJq'a=cyK{9y20D&N P 6aB@	7'ՠ.߿rG@`3 IะZdKb֒&l8
R)` LQ*Db,Db	
;k!a "E\g\_*0kUT`DD**2#B[C-WUb׌WOKzM4(
MF"$hس3jTIxWT7
$FXe̤"	H-HI% ߦp$p?fI~#>ՁBK(DZ$L"XP,S>Qzdh)
`Oa><|-J>yy$Hsb(v1_3r1%LP$j6_%~Oy_/A:&~ZH:?oF~΋Y_g[yѥX*M\+U32]KjTq0V[
YRRE١7@L&#&P&d@#66JBP>  ټҶXI%&Q@PZDb!mPV;vJʦ3ҭ"rB8Ȕ!}ߪNr4"4:lwڅ#9(H'$5|K$JB"NfC)$I$Hm$tÔACr#Eic0r[Ć03PGZ©)&&'""B@m!4C{ݦ(,IHN)H#\ː(J1VY?t@bR"&*4	hr2؁zĻ܇3-ydnzT.P'P3>D"p|͐4(fr":{0)-elH%`HBNfnŜz&ay̶@$ViJia0{ؔ9lH+K7ũV@&Cvhh h$Fz|+5n*H2$#f jb鈠(Ձғn$A~<f\e3{.ʤiml;"ņVEnMkMۍ2옪`*)+%\ܖ&g] o#V +A!!N }'Ҳ4EAd$xRTO-%e9a#$%&,%LTDġF|)FPUvSְuJ2MI#F,BA(#raYr,+y	%@D`VH2Hh/Ѫ5Vm6<0ҢXr	CKxޜbM$%+Y*B@ԄwJsPD%"KLκz	a8:UúcPOn#aՈdoE-b,t(`#DEN	$ &O";/a"I;[!.I-e̷@*Ld]t )Y&	-p$D}ʐhC{kDo[X
,ĕ:F($tQI\K%\SgbZJ7fX7`KaD0iҘ-m;	p ͐V臨"Q)A]IQo+$bu IKDiPRRHA$A{fE)4AdGit482>WrA9R,dTH$
qi"(RDƶ.9=`mܭ{juI9XKN2BE"*ɖJ$³g( e<CC#DCDع`Ķ*CHزIIu2gE
:R"wOvz@_⾱@yͻnFPdLy$A#Aq3)Du4IHmA@IAB3zxֳVCT̐vMj w7|yP3IfJ&4Aޑ !-$1HdʖoHA`nzLaY` !J(PÎDZԊD %KRPdVNCCyOD#&#ϻ!($:@W աC&84 5e J|R (Q",qc!66K4I HVF1j)>44,vߡr=R`\*H$
Q>΋/pw'KI$b!wh@!H&,.~t$Ihgc?v͑\JDÍb=|x6^2[!|y-,X s:~>Ct!	9p"<COAfP #VDVb+g=M&
'ٴnC,"IEk;)utYwX@0
S ܄KAA$r80<o;< !R6{gpGcT&"eF0=@I $E5riBfZ%$+.`0(Cf|vQ)]g>
u1f:1A&A#;%`"I:}vs`D)xP2(	3*$Bv"&e$˷)o)ڳX Bi0~,8TzWIYB%5&	k/_9gH=wA1Q}3{vt3QgBa]qz2ϘskcqDpkM9|
 SD$$	S!l6r)=PpO^X1scld0 1+rr6K҅"DI  0`Ѧ ,ZP#{	)
2dЂs'hVY9$Բ(Ԡ`HrlOfV(XY#eP`h	Ht!aok;3B$f	QIR!RzHvW@qty&:A0c2 z)(!Se3h  l%Pc"tlm<iC2Hm"r1[4H3Mkܩd(kH!B5dk`5f0H,0`kq00^A]/M	YR9PQRrVp4*IABw')B$$H@j^
	ҩF	 . ∦&SVhh6D%b@4pMuݐ  NE9^xF<ɪDs_FjQk_+F*jҬUVBuUc8A$"nI=-䁽C Y	,L<wg"3/lQGEUPCzɄd:dv!'$*D lۿ]썦1Tjݍ!ɄIh%0$HYn+(	&	BV.\ռebms+y͌3Ĵ.`SȭA\YtQyDS2JEI!/S	D"<ӶI"$vR v!gIHc=@#* ֙Ea3dIR,Vcqۮj?mC5( -X$
&h$C=W9dq0	9g9Ӊy@ 2qnBe|9٠pѬ|U"+=f_X,l!"OۺDA>rK#bK+3H%RHvVY"AA	e)buj҇3en) "#tTQ1%0E0FQJ`ksƎ}4rLBbXMh*/>2r!A)ij%]C!icG9kDm!(%%䑤2Sm圆I )וNu6Z=zSϿNi	eD5)uB|2<+R< d$EaΘ $U4j՘e"P#5Di2*D=idG"@tH\2+F,Qz}:S	1cy
;j:($҅28<ϊT<ś8٤E4ڄkXka]`("BDa)h@UIory=v ,HX/Kza}a p 3fٶ@٘-"F9Wk"0@}ǰXv'[!؀tm	:(BPa6?wW\2QNyiw(>3ˌOaH職	QɅY^_bڸSLII*	*9b҅H$wLsGLT_'1իC+Cx,հ_Yt	-e	MDչhm%P@a/7bx)CGkÈݒ_=Cд_K|@ , nrR[}wq
#¤#@8ÿhcc3ȷaVAaf֝pZYi;߃u9Jfq5i=]+̙2im]Dɛyl%o}S'
`sNEGUlbߵ&ǯS9\. EVsᎉסH[qi,Av[@0}CTmY^Mߘ./V$$7zљC#G216#ɻslI.?hC^@5X!8FC;K곯2Y>0jf/cxgbøkԯYk~>;ouٸg:!CG>m7̠Tb׾W2, @9LGG'7ڼf/mK1٣ımB4XM QˁYyց@u``NO t?[D\i4vU4uRQAbQGhs'EkR)7)mJW~[=؅Ͷ-BaPCTXxK+5ܝC㯱n;f$MUx] MϺqzB"Bk[8ӱ8#@ԗ>%:3XY![[EtoP,DzP0>N"s)1Q-bO1!,[Q!fӧ1ӷӸKgݘFsP2`"yh}Y?{J#t|bVl;X_3gfy}9ȁ}PxW"ceuq,*N9_5.쳼|YLg7Gm̨آѮsnFC.͑r+Yk^lŲfR{y=!Q'y`~ZIrQT/auIBH͕2cIDl!+
]"L7XD~il I8[[u,a@ݮ8;Hr09£=ܖF1E59699'MdJ(
=A}r-X=cB5M_EJ `|,&`K?} XLd/#y:EgiǂbvNy+_5jQ$9%ࠁ6HPK=t%8}ӽ.v`{[5O1o+Vu)we̲ݕcԭ]?Q3UNrmXSlCK:
znXv]Bm@Y{Og<ޱ_5E(!>W4lIR;I<mژU[	޻g2kA(BaN\VS4e/oXY$#I 1HE)dI0$6Hz.m(IRybpQ!GќjD8`vUB;y,	N~ {_vmVwޮq&<|2s9HYnX/B+#lU/M㜠	U}_;T~vj%/MTD[:sDe}Sg?Q$IlH$/ARI1knsr@H㌢l#4*crCL32"Qam1"Z4 עGi;+MH#ζ,/)Q 7ub%NT8p{
fCx~`?o_}|2ChJUDeծ%֫l$.79R N6ZDkAlnC`$Wh~siehM,sݒr!A"PPO8C(	":ǡ,?;A؂<>THȆv\v>Gῤ"xADfG#D!%rI#o΅!d l,?cʃ:@;76٦! `@f)z@Œ<#Q ֍s{]AMC
 KSAI#/tIY|˦w+ͺ%{5#rHP"ii)}Bl/?(K0DE3Vt~~ίw/>\fqm^sYSOֲb(B܋0&N)&WL7ۼ5;"nSuFZ"G@e°C)`r	&eIܿR}^ckWڟ9P;i`(X_JY>7谚H]d\B+ṉ5Lк@ B	)#d4}+GnɌY$rHQ} HN$l-XC$$xmTxX>
#D$;iH Aiscq1ԔGI.ͯr"o:jc4uZbEMEMW~[.ZfPJ(IYc<c~2bE%Z'GadH ADt*{6
w4GV#A/kpo>.]\HL<ٸB	]U11|F7(~VCu#W$ Kh|s]fy'CR@8-,tE^ᤢ?5,U&(4(2+QI3McBbֶ+cQM6w'hJ$a.^eh:p#tOXwGdJ"\IRߛI &ɌLA6RPKRY0vWd܆9+yf+$&V,a75}g\	G-$~CJv#LuTT-¯ IfЅ;xHXwcd52 r 2*]UDܨŢܡn;r0H`8 =?wDܖ:Th12(oq8A0RF쑕J#0,s+eU%4&$kAlS#rb=VIs"ZXZ`j=N8qwi_*Z-#įgz~φۈBvõxYk!9G2kdH2Is̒F`C;Wc۰=C-{k쵳<oWSM:/*}Nbu*Lue[baSD
-[iW9/J?l^@Yu 2DI^U&$p),Ta`QYULF	:Iu#d&C0NfU/,)@/Y366tidV5؅&Jv@rxH1Kz?,HGα]FZ&J?fw)/c;T/"iA;l=>Qi($B P,k\ܥC6ֲPDHԊ9rc˺gXY>'OZ~_{i%&ǇP&id1,R\b"bmu3uTsT`n±4r6(mcrpVfȋM,L 5h$<;5$4(/ηR	:sRLi,^DKRщP40 2&&ɐ|5D0+d+B LNN:Ң뭍cTS#Bu]/Y]'a'Xsznu$Eex{Oݳj@.g=o66(,B!&$Ht0H-+diCD6>mujabO~HԴwDGQW
g1H2$YUtO,	!FMȺBynA/m?9D_//]`/}x[q}($60_#	oA'	3<ox9{jJݩwtS)viK^|jx%-zG @wf){4aA@"430wdY6.ʒ \φӷX"0GyJ&Gׇ$gsO5!o`2
,dX	/҂1pGXNA uN,QaM+FA BG7,\5dADw v6lU̳{^ENԳ-9aHmIΈҏ#+sRd!϶h1(!(Q9'}7>U|܄#G)e%@YJ9WI)DG:BA)4'arTrD)%9gU  ЍiX_ŜD K񿀽|:_LH#Zs͍ D #	xF-29β?[e-cI{QtğzXn}΁~%W`](z__M`PdH/ansO% 4[˹-2D #ll?KI5ffv5E9ԘYVCkWKyYa]#B=R3yQ~Ws~]W[6O=AdD;7>o}6{i9l2/PY1Ҟ H 沕!MU6͋zuЁZ賔r"	sdQڂ ^{)b\͹"4݅/49/tF=ء:j$zZ/-9Ɉ"ɚ͹=1ޣ9'7GRdǊA$)巑cwe'-GBr4;	)zD@YAW <_Jjq~f\ko3m}g{<$@ыDW6lֽls-gl#E+fPSV`,WQC"P;D6
Y3IwqA.$#Ir(cI$NdͶyaAAetK\3Z+lu{̘Em"ŜqMdNx$od cZrC&ԢhF0v--/y;z٢s;
+	YD@2j8iY$<!zU$KkF=CYMRQ+?*G@)u#~ե"HwPg,R7cm!6\\ Q@M*y$6lhl<Pd	01(Qm)뚴7(h$g6Dro[)][XzXғ-+PA0s(1yQRMMA
8PvJ#x,笱QsME@saZ)#7X{ (N8jDhT\z+CT.֭sF)$I)oISdQ7#2,@Qp3"dƄ1pk0u$'R*dhQ1 yQ%֛oWSDhIfKfģ0H.S<4[1'BHvHF $I1-cp~|<c( [#&q(,/.
#Fسik28:T!sJcq-GV%JZlCШ$u,ΩC{QF YaŸk7;#ys,N&\,/LFgq,t!w-vdsXBNSbH Qj?Lȓ9v#c܉;$A>d?[C6UޖzQH!FX{#J(5HňA޺-5֎:,;_8u1UC$#"X=@Eut\PF0O2d+;T H@aOc?i	J@`]$l*P0HeKUjyV둦!R*um/_SSuؑn
ΟMCgw>ǘ|'Y`BN鯺ָ(QgNzif]I]D}
}{zmW_ht{wHn̼: A"gyri,S3+Ceރ:|3ڣD :oθՀ{Gw$gz;}I Dw|ڟ'?ٯ)cr0}wDhPh-Oa>)N'j
cfvr.a5f8BB݆(.3H)?pb9I>U-Ytr6#un3d59M;fxԽWs$xf'~pnT")"EvL"K `Yr(YC2W..H\ 3,˳Co$7.D
$A Ch<-ZM $b$͠3i.ٲAYȂ]qlf%H9pA9vd,t^k`lB$l(
9C9a/c7lǙi݄E'Ǥ	i&_͗E~oq֝xJa;GzY`}"wӻFeYzKF,HDՎD$Kƭf(o?,pdVmT_dGC]k`iw#gߛKik.'mZ9|zpь0D)J79eQG!9#{1QFJ6=}bBdDigsjPLAXqQ#b}c?_npܢml	ﮠ0_z4>urO}N~VIaa@]S)fǞ>U\]=¶ccF[w9ڝ[5(sa9Fcf8A>aV#{έ3aFF;F`*!6@$FEhR>^@CnJߩtֻQ0I$#שG*rKF0FI@$+/PqUJ:^R%qKHCT>	,eo"kTa}jZ3%GN$!F68T(@I(أ%i$	c4SzO?JyCmO\_E~JG~Ɵ6?k|$ܠG~YIS&0TeV|7[n%VVhs()}-	}/.lCvɛnWyz"@@gnB#!u2vfK7fHEvuyVxYä Q&G{3s[tmNow`45&7=[d"`$)Μ@ؖ"g
3XoLfF,eD@8`}+ 	O+YNH;F=ǇRz)4QD#rIQD	$23A>iY$(Tq++'cA!H5E`%a	<U0d$IPR0ȢhLDWiC XE@$-ъ ak**@C$L%"`fEDFfB!IBj$
>si?=MNA"xLNJo4حOa5}\\HG(ź{~NOKGaMI$nef_8ܫ6-Ś&jL$Ҁ={}7qs'$J!~تCqӏ[tzoF:{Z(hBLuUkڠգ gyr\ϧ÷m$;1D"{";.L*~u"	g22y-aUsr*'E{#ZGdT㑨(HfS"~$'y#iDs+Qj
3!d Ixr[+Շ^G4Qf AB(6DrUlW9'.
	9pu䑧yeYm34 ݝ thK$
I5,TVТK-RjuRT2LXpRn1VD؎C/ԾSs[c;1sUߕ\&Fn*XJg21ExD#jy0UJ-yCi]YW*E>SlUU]Ai;ߍU]SHiWqQtBa8P AHh3l#y{;uC:9ꃌG!{&vu(?;rHibAUݘ<{z'a^Ķ!Z"Sm iUgc6@sXw
6-Nd	=PpRSkdr8l<#vb<ￒDd9DB"7́$5+K)i̵[YI"2Xť{*ag';ʁ)ΫTQr4mRJ\qM@@@H8aWhoHVӰ\'znDQww2#U2'ph(ۧ4T6G;8PRޭb{Nr "H?㚄49QOc?1GWva]cDXm}pG`A:P&x|+<Y&GޅqFpYFGsZp'ֱAAe7[q2P?khK
ߑ^ݐ?k60gu%XbA#!lY4
C-jsA`P?'H!d8 <żY5UbVpk0=T,$H'9MAJȔM4.6RT[*J,_ZX,y =|%xʅTGPg<Ob
lI.B0_U2%	kd28tv7,F5L0 Dm{?ACf&pb#؛rB^ײzQ*FC+ehBM\Td"`)
CjlT=!oS#;wKZ-`s٠$Q#37!pӰ_t|vSC)(vFwNF
-٧r4#	R=ȳ<ȤN%ɅzB($Eɉ!4˧rrن]I0w A24.{)Exr+10e((*HGl;l#zQDc	#d%fd4W|v!.[b:Qg$`Za~j2&&yS#bH{\"
D$)2Mgdi͌x\/o6^Hy؞bրG(fFm* m2G+#zvpL`ntZY6Q̊({th9HoV@ l4&§:N)]S3#QnQVwNICZ.ߝP>on ruW\"ԃٖs$-\s?A=]v4N4h٘T~.wz0@h zg"ͲNX)w;Ccl,]u<ǜY>L+n6x$C蝇ysc\E$(Bgh0t!A.jrôBZ pȡ<:ܘۓ"-}?7ӕ51CTEqivɂG/GV9"LgjQ<3l p;Mʻ}^EGp[?]	y=CV$i*EBh+=isHXNa6I̊Auvd@j6+fƞ<_,yô5oLxvr˔(#?]V>RCIJ8\X,;cQ䳸.|^'W-1<we4[fa@@û*Dd)"I$;F0@ҹ݌ms E gH$cjPc Cc&f̤DӁ𹐐A$HX!q!(D(}w_2F~
·~z^m4(I<iQb%n6N{ 8RAg)30.6R ]ac/7t*ۢl1jSrAS͑ה
,Yg7-{g2-- ?JC3t-tm3,li<شJRF8/"6t&&-{Iܼ/BHY1Y$iGlk!FHXH$2y;ejjIB@Iqh!^eGeɵt{ė(=͹
rE!1W(T(pL2;jՕbW,($v#pKx,CdL7bD̄20r4"H
|%>|J'{9k!	-#y$=^Nh
CZ  o'2dOE3hIolL#WkPzF4*[>{Dl;g^Js<tW؇):gà(x{dY-cףƩTqCa˕=IG4.M;W8@ɜM 4^y:.j\\e*Zy+KFiV~7x1G#Yimo*	V،=XbiS\Vdmedo>3|<+a-ІDKC(M0P)ɐqH(`IoGwW{\X(ok;{jkM/
'(և`Me޳e؍r8iɒ;Ieus}vh~ʣ/?{:}t5V^]㢽$,C>8B*CB=T$`@Rl{3mVxS1'=+u?G}<;bW 2%	E4#ZYL6Zs܆:*b;ŊSsQ;Vr2ml̫ag,Fmeq?U@L<qq"-eNKSx"yiZq5΂F3%N{o-9)dSUHfP|c='/ys:r?
#yMQ{<'l=2õ2 :RʓOpUX OZ'`Y+˶Z|.gQs: 3l!c6Q	֢Y|y<fP4>]Ϙb)ʝ*5{_U88|S4ō4S>gm-9^Xm/{][Y+hW16܃ foCM6`Js;x, A0K7@yk&ox,ԜGgFʎqCu_6:g_6=ͧ0^Y|]_ma~Z}ILr~2]]8WI^>㫎jaWkbMyoXk~]՛5ѵzU\zC/N^g3VoBu\,\fiɒE3Yۊ_z*,FYa4q8-L)p^6M(so=0\jYp|BQpO%c,2rYUz9Xlz#P+&6RA])O:*b`1=/[;8\}9zq4{ʸ_j\&e ?8}<;4GTS[?6ZoK)'Lbt4F:ryɫaI2uVV+6= Lh}}Ѷ}cn*8?i+sk|]ZMXWWI3MTAs7^WGV^E6+rfYcQuͧ߾ao#{E.n;3	?	INjh!>>gW穸w,e  [6sC| B~)$^i~e  D:%3XG
?6xKߧKB#@~D? ~.	)!NkOCDשw 8p'5tz!$_W0,o`H-4<؟1ruDx[+$pa=8d86,SL-=je|v>Qyя(R,
q:9"h(;Cd@*lK-mg(/wn9ʋ=đW30nϴOW_*3G	V1F
AF0y2HV׻/9OLY{Ir`Weq/}EEA||PcE;|eq=M\[-Vw쒄Ucѳi_UnFXf+bʮҩ1輽CBǸu>U[?͘ӹA?cNI0G$,/mStQ)]JDA\[e!p0EfF-j ɿW{}ȵ{~YY>3V9M;,%2r_%flH; _j_S߶t	#"Y[\PBhy۴D!5BE"@@	uIa^O!쯸g秸fc%Sќz7wzk{BcJmxlTx|;n;,͝K]Ezs&Id˿n[wclMcOׇ 02W>.Q@XAYFDdY g"xcn{DYX0A_S_{Sxj=ۘm;W#+f<|&g<}cޏꭡcy>2߾hWpG'S#zCkFj:/,@U˟Hˍ>CB*WEÕ)H9j)g\-efeb;$#]vZk{u{O-ZZDh'S %-[
/t,`7@ 
Ku^ێ,#"?Y]m-![+Va7z`mߚ٨hesxw?%[Q\LBǻ/UzisULBkعWQmXU[nH
{F2!@pBp.)?*sn\=spnIϱ׷%z46\%bCrVobe	L+̒rT2搤OJ~XzDgA)?hםF8N͗m~xG E<Zjn_)W2xZdrn,qL<x\df<,oR,3gx*\@>5՚(X런`0r~MSvb\]*}s岿p/P~BO&}rW^s/ϚLTTS#2q#-y^V
A\&qwZw?'i. 
S6ɯ! 뫵g@iΫg"T$8ZM9uu݇a;[k Mdu0Z#3,aE9@͉ݼER<uH+"1cuV=Kg)s#Gq%j0z}8OvBۄ|
R0ivן8XB=Z	&A+
S-W]pAM	O?=p0d>93:Ϲ3blb}g Zlfg_3+ 3?8G>=Y^灬rW!Kq]#Y܎S]4%Vk3pX5wh`bQ;RtFApIVKnr/1'W;/xp^$+_8W1
,sݻh5$ __H+RInYG`MTf&D=  !O,op}U6۔Z}J;pWUd.?圁!E&U6ˮm|k8,,V|5jOY9Z|{;oA#C;AFz/IV5ojhHV5oN<c˚3^f)zbXx  wv/kxى޾~N/vwcFGc3OsL<"
H6ش{<o!&<u~W)TDv EWkϽ/! Ӏ%04hD!T!8#AtP*_4ZCHNuEoSp5=`uDrF?l$#dnR66ϖ"XITPQ? jUE%gDkNJ2K:F"wdU/r_<a]Ԧ& "49?v_9-ribֿ0^G}hgNyT;$vGjTRSV],()U5WﮱΛMow3@tm8f{2ugѿӁ7Gѓ_!Yȉ!~OLqyY!ҌwYب6O"	1	IubS"F<n'X"0oKԕU\b~A2+vLxsL
ʽ4pht\jc\L3=RuQ4K.hbPG@U[}SΨ<!KNsw=V:3V
Yy~=-?(^1w.Sɴ]:=g~hmu>>N'SϽ,8jުvʪӰv8M3XeﳙefJ%xa1?rBzڬ0N;GN[Dj375+YHݯ%#:<FjiYDo\Iҕ߇T [kyGH䄔5Q>{8=f{B2ȭ> ;nZh7@Yo  kk]V+zlLq tչR?pV|JU9A@|Rz|?3NLQUz)p2abY>bRD++~)a[9>Ka(9=,W* :kTca[yKafNm-y\^O)r,auDQ;_\?i%ET4~J;jzY]_0>[_82_w3ȧR}3'dPfN|!X%%(P^YYz,ʓ I
IzlM_E\y-./L׉UZZPDJHƒOkc(b6  >!=msޥyert3cxKW^u~oWncKKt^s	;Q|u뗩OC]Y?(տL_OkW/N;oaqw0 H^0  PB, X(#F(H"Dϩcy_in}SCpssz9yÈ  @^t[Hw|QvjA&r]h`Q㺟xsLhN0 Gg܏P5!FH4:$SjXAl,kB貫%[}TUjOeOaJw-a_2eu+bR?XgT_0/[T1r~:dm+oHa];+?	gW<1vg!Et qa\@9t=q^[06]~9=f[V<ߙXMR5wGc3F1(Ty;ZYQ5~ń=vmt_dĂrj_۹2od=
=s|r#A`;+`6Hc%nt	CSRr\#.L3<j  BF+#'<]J\FGeҫJw\-Ok"nBZܲ*FJ(los-v};rWJHu뵸^\NQZo;s/[Z`_+ãj=&yy_
9|e{Uh@
 A7~ RE$ (""=7m9NFͪR@E`(#?EZ̵@ ?MNOe^!TJ"N.;oiMSLJ@9<Atw?Bd`O/'׷rJg[UY#ɾ&xsG h%zb*%vӪ&hz|GA۵{;o %ʼrB[*bAt H:MВ d4>'.9Ҝ_e^&݇汦JJPmc41@." ]"(Xlszw3 `aK^7RVmehlP *>9i0"ۘW& 1%0!9Ȇ5)19qQy픤TU ,N=>k/0x-{_W+8Le:m
NBvCďU"
"um*"&&%ݭ^Q5ƿQ\,>vy{׍.<tb1~EoZ>ҝϡ2y@&1?Ϟ21Q=(`I$eF[z{E6Nl7Um=Wj?;Kyp J9z׏Q8o/ `yU^[s`>i!G}xГ75tC2ۧX  y iZxq:Him4TohV.W9HGJj1!q\+ˣ8)T|ȿsleHr2;5zOptR
+u;2}ٶ2]ZWY|Ϗ[Z,M++߮:2jB L@<HhB0PGo^
M2k:&D$ELN\u鋻7l	 ԯvxKQr;-­kIr[ynD`~f+>@	 [b"4M	엠j>EImV5jMăvNnN6pl9[Y_iTTz6V¾ԴV~uOCr{9};>RYҕECh~,LWO&kw
͙Z71LJf֞ݓ3{3
+}bKHZI&ED#NoOϙCrX 쨲<FEda0u`W_
>5Ǉ[ᴢVP,ze>Ƥd{3ڝW³؍Uo/	?;pj&t}\j;r;N?Xk퍄wN{ɏz>/LϰzL7.=W02VeZR\  ! 
Qku+$]b "FD# 
d"v&@O</ (k[0(3@ZrL-eُt1:&QyY6#_v<2K*Ci$?G/߇@_>3*3׺Nl-X>ec	I9N?7
*t?5ڒfHp0tZξ[w|1dZUI
F%Y3i
9SK3z(QnD0Y+IYSu[M4$rGKWYt)&Ųdg3àPAvkH2 %lXD.WТ')QGs;`ۨظ{X?c~2F=p`M_-PZ ))&w1yAM,ވ @;u~ 3LWA 7*F5AQʬ#c#	f,M$Gp '.#f񨵾ԵVQDtZS,0P!zng&OIxMʄH|p'3	7ވs9J	!"?ϱvF
J^ö hDv	jOb}]nH.ݎ͍Xa<#
TN>2Db+-X鄽(,EVQdg$+L	IH, ,'&H)D"?Sjɞ}{ ;zN%DLr0 C}.%*dTT)X
 PQAA@H"a7̾]\JKA]mƟ(U`?vjzy 
,P'HHCGIi}kJ7ψ6+ѼkrY~*;ޭ߯~ݮ;]5KA͌޵]sMcl^">Vs/Sny2"伍Sl
b*EA`Si;eIHdByL "Ub
_n_vU@?!0U17:.YXbqV.necOozZt]>0W7 tvjcPr|oVf>YA32a:[Ʀ0\@?mwl(I?8@+Xz	@pi>i=y[,^l{֞/W幾apDhr{[<M3OW..\1? /׾9eo2#MiVVbrig~mddNC+7V>N7	-&j5kZ>ƗCOےa(g>Ϣ<7C[aQUYdϰc=Ӵlt|57.Tb^ؔ.IIAЧXX͜A|dM7)hed)j	A0AID }D$dB "$0	1wPT Q-T"LQ[U(Ug+ci% U#AL76^oun?}m1Wm7]Ö\Nx0;d@ZaxJ|gxS٧7W]䒓U*.ɔ<-e]}\{\;yg{]Wҷ~w_>6޿]F=Q5r^f@MFKZ7V8[7?-@o{'jiyokW,"Y^^dCm
ThP-v(pćNIH܉hsXCi|}oܿC!-{\y;r\<0ZJI>6+pʗm:aA<9wz꺯3I	źi('s꼁1sn;v]pKQZ^h;1ėrY	sՅ&YR_UrBeS1*$E`,b,XA@bbȢ` *H*!bb1_SUny/?wcʗ^567uLlzrHa$HYvh}F6%U(?Ę4%Ux6_.Xxj2yW6ބˋPKa$V*6mtXLUc!}6>>5?3nc!{|ګKnY]~=SUO?D9_~QOc!zrkG^TxΊu}5:@qmgwt&qR;||gvBuH
TUdTb.#Wq]haAUC"]Y} u`U
"XHUlSWضzGXJΨLwV4	bU"
TEQD

,QbAEYH
H1Ab1ETH
H,EPd H{.p 0+e6DqK̃2ؖ\cVr Z 2]A1
(#A1YVDAbUEP
 XQdH," EH
EQi9rػyˁX*T~5/Q^",svUv~WHgŒ0UP2 0`+ͭM41?)8x]wmCUKqz2]u:_T{Aj =Z8нvLSq0dIi$|q87ؑ&#EbQܿ׭^Ey[m
ŊF[dFx˭C|R.VoH|C_5&+ePW%8HRD@ՍW=.x?4Abk,egfʳ<{IU *]N_qh߂աԃsgNglF<FHm32,|G#'wZ?!;P_ܮ[cc'z0sm(2:ki0띂kQ-p)&()-d8096+Tb=O{t̜Ǒ.緸ĻBN%%oa	fER۩.{8gWUeOJ!r<0Fy$DLe{8*.@X3kjoyк|_إ]Nzx/	X"&G G[
6EhIw6/\i`b3{xIRk;E[Qq|JȌq)(n1(d"VǹBpY8|ֽg&}QڻL!h5usu4ﻯl@w1))H-v4T}oԠ`l(
1-YQѴ.\ j2(RݷYPykyDa<A Nn&.g~È-ʈHЉF"Ā-S.KHȃRhfh]7+k3K0L?Xn7vZFg
zYv
a0>/)eA#z/ww|gIyz>w2&6fuWlv͒NWSC.zaNP+q	ݳݧLIxSߛ2rv8+߇"Ȗ5q=kf0R$9@?j`>_qIŪyG8ߧ3.[l3+ɓ>^MM$VEyy+lar,|Z#/i[RNOö`rқ~yC107ݨt;c͵\f{,sm8^X|O0/UdD%+'k^e1@2"Q:5uʽfV✸W=r(vu?NG-H8; U"Fx2Iq<7G"Eܤ3ت7F愨Njr2e'o䔦-ț1MRYmѰb1=&"#2ͯ/ΠĿt1ƸVhMmĤoJk^0
kE%z[ #OKSʦUuۓ{u@|pY0͉O<I"8A)Һuwe6[/;rgg.Sh&9r_2d+rfō)0ڜͿVs*RM}xuKG^e>?wYԕ[7MY+!M8#g/alKRdnrېf\TXيZ35`'pہSY(d7Տ+@u_n(y߷8a=<:hv,}\&y&ץ PٽY{8Gr(?B;
g'PK27gv3!r5~lEf[kq~.m&סitCi3]M]_s˶.*ZP@͔蛨STnd(kkIzjcy'+,hBdufܺ۠ݾz+4Jg*S}ݸ.oIK1URs#CTN@ALb5i2We2Xk Udf਩IkES 2׽AMO''\>0Ύ `9IaJ7Vo"EJ5G,T$#eY
"Og5J! X0m0N  ū᳝[iZeB\*IЯrq퀒E簜 "@ Ofh߂/Кf!HnP0H"G){)*%(q?dzyC6R2v"łMu9W8%*<Bp/\
BO)02KO@ZAq2>xAjϷ'ϒ34JPiY$RBqKy*ImW$Ԙb &^7dy;>|dt9Uv[CŮgP5\J5l1T/O"<1"+`PXh\{yt3Ry7ȐNI"ug_D3.yk*$sy$'D*7%paY6Z/ 䤒	&̲ӳA̓e$>G'&9`@.ZL%[ݙjͶǥR-@5f;kS-"-Jd2TљU4Pc
Vw,ytr2wPaq6#ȓ&YE:bI 
<'t-0Y`El EԻ}wgD ᒉҨtL$&yLF<̜I eb/oONƺ-[Τ3<J2fl2g09Y[$o,Y1&^:ԬFH3pgJ)7r-*T3.Xfڗ;B#6,]b42w*BJuxd neJh (kT3$26xav9hm;oi,{BQw`e4>#,MuDkfěձ8C4T0IFIǓv,[N0hx5f*oV)BU0z-R#y+Ō@	:<R&)D4֨s
*Q5Y
QKBrs89Nͤڂq@I'!&nА%xoRoJ^kZ.H"Izx}y_xjӠ+sG>{!Zku(ڦ&A?I5H˓ \@K%n	M&M*`ߡTX(Q"Ȣ`FTFHX,
AE,"ahbAbEXdMc1_u8-
OshFAt`m~qM&3 K|a 5~N*aT~W6;0T
:< rFVH-ypZ&!`2RfbގxT	g櫿<=țs|'7o=oPH}kͧz6pe6$+VEͰ߁q8ytCQ=Q%j'V@Ҡ=~崳7ޡR> ^[]C%'qOIn=\*ԯe?͸=[ͭbp\뻈kOU.-Q@ڰQU~[|'l+s<[h-D7mkkXu2(+AjO)T=cYhg6t>x:wu?ň^+"WD
-*3|l,-#f-ZV㴽ݵ3~WvVrXNju,xK붫_k!*sHI /lT5[uȔP5AՁFUg'̡_ͯ1t
Id9e42<e,3HHŨCh:ȝږ9a<
]-vT|C].Sܖo!$ݿ{ަ(g{f*(PߊJ쟭NG	òq-;gC~sDw>_O
qsٔ9J1+wcl(p5T =dٞJ{!Eߍ7.m蚤8&]݊,ЖkxY݊ijuKK	bvAteu
ECw`Pڑ	"Mag,10s@S1$1,dKuJدl8)A)l✪*g=4ơl=*L@&O,]>j%ry"B@ER_ޠ@h\GN׬}&*$HI	 0b޺}'e@p mnzq^ΧO@лuqu35#J	hFUf%GߡC;S]zy)|ɯUl6G i潮}n̰>l;Ċ}J}yx*6<i~сyqS[&vO)/K_m,* h~<Ӗy1w%Is:,6Yr""V8ZwG2Vv٦'&q5P *DGt34sqğs$\nk{iꝗ>&D@6=*w^RE#FW^4ݶD-HP@.sv4rgYhJ\T_~"x5+
0t$Z
I$J%
&Zq	DAr-B7Wv{YPh3>>z!k=LUÊ(zb)eO 57ߤ-zr/9}䦔n*K0zvJPDrvKEkͥj",\AQodd+?ǻB;g7O-g\zB[kVؘ^hBBDAY4ɛ\Wlr[,isab0Zki}#y|%xtv H$_C`vļ
doTDi ^\h6)X@ɠΥ.لh4UzPbIm^FOHUOgxJ?w?Gcu|m=zaAI-Np!ۗ*C0	hNޓDh!H
h'rP򜂊G(rg$(# gi4=фDk޶^S\<8>?ȪrL d /^'ܟ9曰-6<.fFZַHKG1&ǻYd:1J9J&uHR b
4eJ
R;46i3C H@3eLsf(o?oGygޫȱLMaT'ǰxuv<ɏ`=eb')g~%DNl`N's眕C&( &g4\Y=9{c؏$Hlj+' !M~e n?_؄j!h%$~+%΀CUtDA{f5N#xyz\Q$zG÷!vrtWaXyjv92\%sNzsYN6iDy9ӞXXY֯~}a~Ng{@Ud<3$AH} v(b$]W<Q&r< 5,x5=O̿4ZZ<{ͮ9Fcriq
g]^ N 	: A	[P
!9WY\~(N[ŭ`/[}X,k.7YLhYD,BBMbM"d;æHmp[Q
jj5̙]V4usJmu%?t,Yp궯%Ҩ*$}vCN䩼]s9J$E37$.\#mhȉӛ&3SNm_mUn|Jf5:^D%3:;KCX3m'8V|(M9#$e[7D1(9ű''ވhr29IG\%
{xͼf*$RY¢SUn`Ih1.7}p&,]#<d CC`}%ByEX"	%dȁѿI['~/u\ai@\dMNc%ݛ~Bp,뽜V[N4脭KsLKdrFU*F|98L&!YAd];.ԩxFyejMk<6=0U2{k.D$#E2@+BᔬH)k9pQ2:`c"5Yc~\d|2_LFsY^gJ߲ȷZ0Ryl.mG]ݳa,noI	+Sljr-HA#3cAn<Ada	q$F8NegyʐAУLoe-
HHv
Ԙ*:^Q7H0.Q$g7SWcK泰Up)nL*s	hoFq:
͊E/5$""M̚RdfIPx4Ң;FHM_9}лJP+[~DwYag8߄??`̸@ '%Ix4'JN맥PzfUcdy6#PZlS]v<wKth՟ U  $'8+(ºv~=p}ǻjq(-	5"*FxUq萼YHLq(gOW0@Qa{9Nka{vZʗ1 jg4~ۛ]ET#cyV7/ow=;/tO?Z[$Yᾯvs埗0	Mb>L3T/!ws8[3A|I%빹`dS
[Gg'SOwa;PX,_[,<|!L<JJh7A<6Os.,X	9j 4h[yCٸ?]|tUe_6$Pa@L ""J6H;"/gCIZفN(sakDxwfꉙRhz(:Bv`7F&e*`p}/ʭN-rsIWVj?k1H9g#da]G|7e2coUj'iOCC7&^BwC\	zo[{52nKtv9ZIÉDAaܚy@@F4#VP!w-SN&̩G` hr^6:Ł(?)AbrP1V*3UE*UExqx%UjPjiĴc8Ky`bb:tZSii2(o;hv#zY( nZMLW%jǤ$PHrGh1~<iL}`J&7en@1dǘKNpZ!wwF%
?Ex|
]`Ϯ fsΣ*`\nxzЉ+HL(cӲ9f2AA$ ۓr5MHpo5mb}%B[RZґ~I>\IzBz[AE:RN|f}6>9=%zx_P@ïI3CFa9kvh\~s#/<@9s
z0ǜKh̼*Wm	YjE%7d)۷TudA	}RG?%lq."iNGV~{o{D$1V' \V|pYd[|
@=F8"[RcVߜC C8QU.8'%L$"3d&Xhc,[,\ӷnW(f~!ͭ0G{(h	Q'GsMY/S {ɰKoPᔇ)|adOh_.w^_%kC]U

*"8+Y,(,KUiSO|{=7SS(C#f{	BL )BLYL͆)'P;-3kgP!@}/YY $B i":\-=442|lMm,}Wrx=C'G
&XϞ	  w˸l+tz1g0h MP1X<ݏ2"gzqn.2^XRPhȜaI|SeqB#z%hkZ<+vwL" \ BLH-m*t"QR	5ϰq	.F
eqbbWY1D_ 1DD'.;"bV=zw,u_.Zv՟gf08L%:B'.ݒpt!ܹw?" Uv=!}(=NJΌx ֘+ܐ*>pb*>MYĊ3TZwlmkƁjxjL+5PTC T ˵~,hkq԰
0fOLMYr @׌:GI>_WXZ*j<X)'	uL_kꋘ'r]ocqOv+IlM6<>o9kk|yHyoPVĭ%	}{^fc⼛x+ ?bnƖ!-ruleOretHƷBDV(aPzbw gL:b$PJp<CnEȜ?gHSo{q="?O?sfvm&rKX䰻]b$$xLĠ@,@PX tSbX(~J#Gr}g"at"W8Y2լeAT֧ bs'*zrZrrIC
IRs'"<|?JP>}h㸙~"ˢLti	<⡽_Չ}s^q!%$baK7U&>Go7)(&?3>,Xq3}WDH]kB
x&]Z$PsuO@P)S[@g] !yY&|/.(H7aL7	v6PňBJ'e[]t>&u֪>ڳCWs^6ɨ?0!kxič?%\{ÿ{=cȢJ`IQ5=Jx'W_G+iaUHѱRq`l у1ChlI&6)ls#7>>Ĳ*{	B]mt鎕<"yJ@b>bO5<2Vөp8'C\o1zx[k>cЗ`s:qIH`mMo&LIJDެ (CfQvrYГ22iOC&ze;-`LtKR36 Wܗb6e1Zdi-AC$$FŤD%%YdD
)ZR%ȁ,͈";Kpy
:8y|ڻ~Wr0j|^4ncFVtBeōzw!3<#Bn^{.f</13P~qfIe%7TRA6,jrej5YӃEˣ* !S'8!ʓf0G"=A+ƪe){˿"BL9M})o@T<M$S]|;F,!K
X$C "$DBݗ)'lk[~Ro_4c#%
 g@̃+Z~2|ޯ-ߨ{mj?(lTTq&p+^>Tk*ֺD&<ei&&7i|Y`י83|ND2לi13/ũӶwul4=}mr{˕NIduǃByĤmV^mwȄXشQ=h)
/OSp`Ľ
L/ Lg5Z"bR5GfJrW̵n\(h%o7#h?Ehqˍ=I&O]k^N9;c?$a*2z7VIe̹u..s2,D;vYe;0I};%+
#	eSJC^=V22 oBTRL)~m^u`Z\YȤ,Yvc=6fneSZ.a&^2DHzhl`s,rHq٥֙g0*qADqh甘Oi3X.Pfz4PHZ*jvpnn.;@/_&f́,840;<Lye	CڭC6ui"\̋)589g]R+4J{v0|SG[D
o49]Ӥ[vZq]ɖ ('V6>s'K.(ʁy(A;&c"utfiV]vŇ+OJ4q&yܮw|ii]"ъA4eXkg0K.qbvī-QbuwyO@%d܍­oH9'57{8c{>itx\4\=ȬUYհmBތCjdLic|SW^&]Sa/[3	6e!	r]~p{["/0*BmRG=mȺdV;´C-E^sװbѻgF}Tbm.S$'m(o@QQѺK.˗Uq<1C,2ȤHseS
+xӼ.BR<Q*2>wigǂ3|5^jqmջ6*yta,<]7b[զHM*N*DrTD[oD掤ʅ_ (	{By |QA$Dp=E,Dz˱ی0c7ap%pc9'9JRMj+n<,+$
3"ۇ=YE1I$R=*>)n;WIIk|SM^Xhɖ
-_amBکY\v .@2?M2C@VKWrJ0/X8.k#,Av12\qfDzXM"ʷn4eNm9f͢sc\"]I#wץ3ڝS)Ϫ܁f/QL*SnDYT*t\VKƴ.)\eףuЅܬ("#qsTV2}ԑbőW/M8%>USbv[HdIZ%⊅ bA(e>n˧2\p$P);e@¹&-I!)XG_(ߕtv;4mD4Č8] 8ŀVRB"$Bd('u,NtIsZcJV$=T0rdWCQ!m˞:Χ.ˆ4JL,sϡ`qYXrlr]rh`rA:,8˅-Yq9RzkPVEAHo$-g\I$R=
>)n;7	Ik|SQ^Xٷ6x8<OCw2y@KuR.[Ðeϊ"W0$FةK12?"<sNrSߺJW/pC9)xոkv.dreUuS4fEO5%Cǔ-9vmʄg#g</IdU&j!޻&n+2]>rtr|˃<E,IJ><Te>n˫2\p$P);e@¹&-t#oʺdϻ,B:"8Zo2)Ij62۫wyͶl5<rhX*xoQӒ,8$L%+'}c1TU28*TxމIS|L&%}FO/sZÂ`Uv@-[&<82_8Q&bl1rEJ*q7֘sӗ`]s?R&4H(䥸]%%1NB+M%.XU5N!-EYeeiHn
>f{:v$څڡ%-F!c[!ɕ~^tvl6*(Gd]""uə|,ϑ:Msc?$If3QY<zMMyabhHun,b<W1x\a~x~U$d6iPɆy^&cs3lۏsn܍ٱTɥ	`?DKtPXRƔHzlaQT !R# B۩n+T.?q	0<$4Ph 04Ǯ>xbQN(WV"Kwm K[LYSXp(
[AF69g-CZr|:"i^\	3OE-!/KARU9)-9, psos7ј7KcvybQ]|Z(]gy==w968hswwqHۡ~E*;y.x2Ǟ"<[s~DyK*U Ptw}h51T)cXYu`L=zNW=dbJ˹C.ev_Z|A	"mTi0$y¢guևzTqEy܌Mb-4YJzDŊqGa(?1 7ᙇu|GޞxФJ>Kbrmt ^>yn3N>!KLev}-͜-cKsY1$R,cTX"E

JdPDb!THȇd莜|{,ED$G&QeJܣH@QoEA6-]!LZ<A޳YhT]Kf[ZB+Q콇1+ɕaIwNw_#ui]#`4*#>=>oe<븾ZDYkvc7qYhf-8'ڱ;Tq]ǔ@hbwƱXPenZxYOP/z79ge[?]qyåX8sg=.-.`<];1 ,\,@/r2UO8uK.K7۴u:f(~DֈUC+=kpܐv}՘f6/Irb(DR,Xd*@PYE`.qRÑe!ba.Wٕt
0TUPF(Eavqb2*KO>`XM	K5;? Dˣ]k
yN\;{p}C^>xB܏T`s&n`	%ClJ7&bOźʌ^O8T~xbSLSpf;UiܜauK/#Wvrg~չۿkdZ [ɰu;SU+1U 䕋ݿ<ȟ}&PA ̮M$`hTͥ:/	=9<AVItRI}E!*plUBF*`H&+_!=17MڂZ.m|;)iVR]wf~[>}.A,ClV
>2-lnAО%εqbT%=w]A:p(<]$wLzbrVR\q6_[풥邂Fe//@/l,@7^@1tUS+zY?S=ŸS0HPadPD);E}	&lD\S|XɫG͋.KL0iYN%c52醶`󞰥uٟL;/XlF&44RMRХ'mcjw-y`"j]Ab}׉B+JRѓcf#gRź^C.]S#Uh 7Sw><󤤮9^*@iL"F0IBWp{%J`"9	<"/sy{+kʻFl N0DpOK^nBH6uf,bUYr,*teǙqM6]dۍJd.BG:Fd@WAsUIf[nI0R))]1%vɘXyKbpkMfBh;o&ɜۻĠT_<0Q^Gqxh@qǌ5f 3]鶽2rW05(8lywe5|dݤTH%)ݗ1"	gqi]|zZ̸
q"1]wmTYS@jy?=m]m_3`Xj4w?AptU]]Q=s׿f
i1,i0{x;{
7s,P &cq[aU`OIu+
|rt֡z@ˬa7(=-"(ZDEcxKpOqh,ť(F|&QSL΍+Lɷ.]R-e#~C}9>
R$!	dX4g}r<8V=vڦDпV1rAdɜcޛx$qtZ͂#&,x*P=UmQ?7}&d"\~9m$[ $Z]$k7jY4lgiPDl}0pX{~fJJWe7E% GSv,j' 1L=k;t@BK߮_3D{򘸂L^5;ă~ϺrIF,zKcvu/qmu4lGKMxoͨE-+aGT"^Y7WQ2>Jy耬6D^Su9$=҅g9=6J)D)H@W_-5YmA4V<0kNnO|9^|>ďbdDJhz8u|"8a6UӺEsz1ɕ^h,CM,pIm@UQ@)xjZ^rjd A#3RZ̵ؔsdv|ϲQQ7 X(@P/uح`Q$ 
 IC9vAKQY)!I$2Q.0r fA1r.Fv\*#JX1c,#Dk3
HYVZn窪*"XjP"+TXUbH#(A` ƒH&!fHz,AdEXEa",2_\+ju/qG;RtJp8>*(W»_;y}Om_}uAݞ'fnXbj*jJ::Ҳͤ|HTVx&ZdQDwi<@2,+(yn"ONW*7NiPmלxcb^ |_cW41E KBه//W?̍ ww|'www'd!	$6kZ   2       }kQww'p    ܝ          bff ! PDY       [̽LN'27ww|  F{Z߻J@,{֪ wq<o:ֵ'7 13    @2/g9l@%3"'37wrwwwwwp@                                                                    a              ;                        @                                                                                 Fdf             BD@swwww                  wwn `faÛ 0    iDwl9}]T/5?q8<xn0`       f`      yAJR'7wwwpO\'Vc9s ++AДȺ-JH,Uy[<1]ur*e9 1A؈ 00 htwwg/ÄT󞟷~'miF` j;7 1wwȄwl,"!Û   ` wwn `adNfn2'7wwn w{C:V'7 1  F  00 b 02sp0 ;sp3݀b         ``   00 ``   00           wwOojI iU1T M*b @ l;;N P  Hwwn&E)$D( Pf   
  ( R$N R 
        P  HwwpfF R "/?jkU ;@@;Z)$)8#323DI$+    Gwvw@     )   (r,<׋,bLEA ( P}>O0=    ( P       N;   R 
 Gwww (                 D8DD?iy~yjYdYe3vwB,vww 3+aݜݝLɍT (@ 
  (          P               Mٔ  @Bݝ( P           @;;P  @
fgvwG<   @@  #2UP     wgtw
      @f` @@     Pvww      
faݝ:wpU@@f P~WYJsi( P! NN $3@ @   P ! ; 
B ;dDDDN0    `         `     =     `   NN``  Y {r/W)4  00 `d   `   `M9  09շkZ1gpÛ TD f;swwp̝9sw~a~ [/#MWK=Ueѹf3U6W%q'|6)QCRq
$)8" 
\&dξvSAHC>X8PiqVO
O]лD)pϓO9xB`wĕ",hp Ҭu{BMt*eyReYIu,x*Wx}?tI^ސXoW>Wċ'XW1!(e-rT>RnF_>3!"iw"L^KcW4y#Pxzľ,D	ra]k pZ/Ʈ{t^~S[l=`xqo5TؕD򙺺3TP),V'QZJY0lI6s"P@lO7!Ԥ.v]\H0ƢT<ؤuͬF3@=Z߭)+F*0R!ƅIBTkv0 ꫀ)g{ *""-i?h\  g:'v		Wz-	! +)ʆ7"_1GgTwnF<6y:D!ᝫ}+ޏ#}lf<&(0S}p؁}'6'C?殇c­CU*'׮mJaᷱ+5?ht_.]wZXdjig=u}*Nq5iskvyoZ\kY5G{Os}Ɲ-mS9TӤ G~ʾw!,d`k]46g81_SsՁ%#AM(5-qk貜-\¹*ڷI\	DIa#jI>лc)SRěSE1ے`m%$"yf]ifր"V850[M'дma8kj~h6	:{9V	`(m%k +XG4<k85R59cMȆoS7֦ua\ﴹ3n7mi)(.ry#ff̮]h}w{n;}j8gS&$	!#ZbC%,'8Z[j<2shzV(@E"
QAd$ꕐ*3D@׶;`&9'Eh,&sC{nXuIӧ$mrEm]]NvRgɗ3Sg]Oz!t{v"ifP`U&{l'qܷSq~W)M3AR˭<cߝ3nvTo6v'#=?j@Wqk%X*0c9B@`@7!nLfmlA9&ˮ>[[w3i+cT:>Ou,E9+|]Rq(vL'9Vn6Y6bCl]'f.i4-9GTSuiGgRnӽGL<pȂrj[F-_{@xXhMW7E5wMӢx[%ygII󵠻mdnsOMKqf?7b:s`p8sMS7*q8:;9PS\)ivNgC݇(CnmӗzÉ's7.ovͧiMjo;V&bCn퐙!{dػ'`$pNn];nבI"
iq;8r$5q}
DYx(i盦AxYG`0AF~j:\%*RUa
٣b+Y&(@pr 	'@4߿' r4ikwa0rn1l\T`NdqZ&K:Ir6\j7f'F(LM~tny.ڌS5遺`cx<>5IdݺJsrT֪7Hf:Njkˮǣx|es춛3C5`9VMFIᆊC5 t8PLisf?;mta(mc#b<0mXM{q:kM
YF-d3bCr/u2ØyCaNٳskha7(é9noyJ;+\s3wX<7dCbǟC[1ai>䐅IjQmpN6\Y=^uO#ƍ5_Ӳq9kH\m'_:}~Cj]]mzZnuqnq!̮ezgU㷖*s\!:v(n&]H=)D'.&JN?1gF?durN1<K2V5yg>iA嫢u(Rhmk'[X
NkY@nXlsrrFcMS[Φ4Y5ԦݜESgN3k\v֧Pܷ60g':HM;c0C	<ًSN1l^:s)@$VݛugDÝzGndN<vu]p! !Pچi7p7n05&)eD2 k` %"}qjP6/Jαkvٵ뭃+0ΫYF$&25pZCgllc8rqnz~Yu6]O6&[V9hesFomh[I\[Rd嶢bf~馛Vp:#(99ּ.w0<RunMLZ\pz9m;cu93w	7Z%nٙdKDMz0'`XËuX#-pXFePj!XS}b;![}l-cQ6 HG-A(54 +w۩U˟S f$э}t4RmNF!q'_Dd} ӓye+G
TƚJ^JnWx
-_a|G{ 8ЈJBE@9CmGTA?8o]gPLZ\N|-&2{BUy*CRUs"bx_qFD&h;,k40 F 0[-Gjy6wq6'Aʹ]p)A4@@J ]3_I	a=x-lm3%ɈDjNlNȝ59ݮB[<SjtmeNs`D |^!I;XdS'BE$# E@;Gty=j=vzH49ݛ/]_l,M h  ZjAB*` $9h(r<M[m>t80sU<o4_Apdƥ>x@BX }j%ػC]F*/^ "G:k-p@
SR!yx&wTeLQ{zsɠpnc풷K<b4z'׽-5Z>7'6$zgl(UsdS¤ԋ/fN '2]2xN fd@t)g 6hTtd+ɪV3)H10u1?)	2s|Z؁˂+7Ub	s>Vh3%	WmX)M giң>RM ,,Ęݮ[@M6ͫvEB
#fMZ/޺~S95O L`y,d%Ho
8Ip|l؁Qx_bmG^~0@'GwWij5J-Y{EΑ0 3d=olCdN2lm/\}JCe`G,(@ /Yom]<krٞ怫-lQRw%.~iȊ"bpe%LȠJ8є	!vl)+v͌a[L)e^0FŨſBTx[MxrcY
JrcOg4Zsl3t,1ˍVʁMZn]AY%1;ЯfH6+N Lq9@=o,9X06fi2~f>!e:r7&<wB|(VD	h!c<[jJ R#-!f4@qLa>fAV*\^}q~cC᥊UUEtǱ>..k24/ohMrzY^{f2k[IU?&֭֗*Jf@!qHN]j6<>k=Qb-=dKljoǸq l"ؾB=5JZ~J-$r*(bF`fk[n'奩Prq\iƬF$ٻdN7ym}|V{|:>MnԢ +܆2@_>U굗XBosQ{K8Ӓh`:OV:@R	`gDĕIJ8pAWdfȉg?*!LO5@ c٫Mm8+bi`Ja@ PѕCҦ&zFboP<wȾZ?kp7vZw9eɚ]>&Cyqn2#d`> R_H=:!WNYTC7m3?.llݛ83uT9,gJ	-@BIU^wZ1,OEAWK㤌 -
t5'+kO]qIjbP0?1?R-}s|Dn^SaݧEHBVb"2EZ~٦5ˡo~}-9d gq2	vZ\|iT3EaC諀ØO#<o'gׁ^3O+Oi޳w/c: ?!|hn=:^Vwd?k"85ݘlF?Ccr{dPD٫T6XI %A	44fW?^:-HYGb{zRP5[Ԕ%OкX7r=+T""Y댁qSU"h+5kez	\F}ВokkѢqA 9"ÜC0
d/f l8sCV,u_xn`)wMDH~;eR|_E:7o!sfGTWsPpBGeщ4:;-n{`;%"*a_BCH\%s4(FH,!\_Wk~T<qoc]3c׮]Ea&@P
S*caQ6`nA)!'>h5h_%ihR!hV%u<G|Ls'	4mPnd2ÖY)4y_D+%1t)ےI@d֙{T^vu?.`)7;0%9+`ȦCwDēv̪YȖ86k3CE?kҬ<ߕ|tv{=ޮ>ۿ~mǞq@ ׁ	l	F!YNZ$iwr(6 ikmR'y=nkm̢dc!$S"5Z,}cv;߼*
6m??EbCbUgм/C!UFEghlZw䕢xF@_c8+GG$uw秗vVmYgN9RUxgU9hnd&ػY|m"{(^UIï9FXfI'*Y歳]$<4SEub.ؒ3hKU}8~.WA]fa!ɟxucP56P{CS.
 wp7Ȑu-@1&X_om]4,f&j2Bn6ܟҸ&]g2y(B^CfѡT9kCdŘWq9BZdvդBE ha%]0V+d8<l7~§j>^pؕif~qkMLbd-4}^f3ĿWǧNSTOREPTb5=kVx}E|F(_1^Eyu<OJNF*.bp:JrDQWW{.]mZS}V._D-Schnԩn]t=.d6xvo{}_{m.=!KL"Yկܮ(iii߹.)y~/:2r;0KxUm=4k"^JqHPMz  LD#h9
eiVܧ(EDlfRpcK@)@7k^&"iv% -+[]"]+~"s2*?o} )kgUj6$lD"(^ny^.}g'	qm 1S;Yܿw6Gu$t	c{ݨVfP#h\'7]?2=lË\eKȷaк ʸǹ"|tgwuGVNcZFF'._?:)v=|3Ըw7ວsx@*Ms3&Kyݾ^GBUu-H|d,Ub& =6nyTT{K^)㚊=sOQ^on<ŋusEh9c.)+0L?^C6bҐ0'[}!櫯&k9*)<XVۼY︽9mpnw[;o`~\0s#>O/B,zRzeKxӝde4IO494V B AQgXC	ISI*9ǐu*wX vx@"n-0XK{z?4^a|)(soA0c4r`Jr'5 ΃,b "NԹK?'UϪdTˑ
[ɮJ*ХK~Xվwȗq =() <@22V7g^s'\Q}$;[$H=gi{ZDjmM׷ 'F~ϑf=tsM1lnvk>%֧N9&A{YnʁJ\13t'd]$FIR}ݬVADSנqT1W4,_'WJgvc"ܐ"ZmNҝz$پ^a^w2RK{}Mk {RԳ%v^+s:|	I' Bsk>+EFlםpbI+"H,Ho.[_|9, ]"c"b:s`#8tL,v[Wp*џ㶲Vvăvo2ˋm<y,0mHkl~>t1)=vJaB(!tkrQ|)#o5HDb@B7EUvAC(~<A4<3^WPAa^Nyukc=y;%#)&p_XPBk{#HȗN-Y(1$ݨ{_KǛonZ
MW!W+O2wf
(2}߳y[f^OcZh	RϼƨrɺZ>ij(ɕe@vXh
Fsz븧K<
W2:X VV7q4xGHDLHoxĂD5;Y-3asٚc]n BBLΚU)	6ϐ=S`k kFa҉J16 <ԍ"ݳRn>B{)ԅJf9[W&tx6$%ĳ/m̋  KLkܫho=tx'$2٠`$(bڰ}cgʟA$dĊx!|Tc
D\Z[L؃tzɣ#یIΒ1icɯyU8<!8:!wqb.DfSɪ^sL)A 0@Q`$^휦Ԛnsy	,3ㄉ#JUgf΢'L,	\OadGDV)R@	=~+ e\kF7fd߀ÃĈPUp(L$	#Z3׌ c9⃶"fyO- !ed,.5<A:O{S
{cj~dU%N]=|L!}l>V捗Z>JS,/z@>!.B	JQ	aV~	ߌz%{>?,^I:CI;20~${k?i4oԛ$:fr*dg5UaѝZFZ'C9;Fjg/qrzvyFnr,uqn˼g֢pRpj,U58}w@vǾ7&!&З74BQ9Fn4-L#o]wCᨆ3gtuaΡ|?|8.&N铞OoXsnv<^x;%ZL	hh<²>%:vbV7_Pȡ:$S9է6[\YP!-,lx\͹sOӭcz^ӣ+9wgѥdg0Sdҩ<2&9s̺iTl*q4I$8umcߵMC`J{6$&BMcgJzM_	3ѩQ:6iMYԶʷ	}tw[ s0ſMB^*pzԚUSCN7cK!3f
w(UCjw;x4s7޺jXʅٴ[^[l5ɝ-hT8N֚	.y݃&$7Z3s+I*kD3+_SAemOBW$Ñʽ$vI=n84#D$Rv
`ٓ9236YmFM,vLhjmjf!$&k&D4z='n[é9TFs>*NզT0N59ʼu&i&jN:^s3m8ݝm\!jU4CbIzjRc.Sn6i$/﹎'܍hF*DP\85*ڨ\7WfQdar֔7:p%'F#&me.(<ي<QdhS%?},=ͱ8 
n0H@
JQyuͶ7{l}nV~xOJ#=)XV5GyMN  gA2 c,KK!"$ ኤ^rI@\rk?'ĕZ)ĲKɥIƟZ*ғt,{Yy{~
>ߡm˼Aa=I>?A̳t!«[#eAn"t{6&%+Bj9_W\tB6sw~]VlkY}9o\3#mRÃN"ݞV1mVUaG={3=~e
hs\X`oث1zhewj3syiB]`+Xx_GF@yMf9pZ(~+~q)L^1հD<Y3^qJS*_YxAZ_h{B 6aW_;z	a	Mt0Oݟ`M㸌+UQ=Hc 	Uy@,~wc.>@J#V5Q3B8"6U?v-eH}ϖ
~;ODCioO[녮KyJE)!v HLe*Zo47GhU~5E;yF睗gr.oRN;ؽDrr4cPHpݫy9O>'ҩӿL9)u5»7_%lOKX?WZ}{kXVUu>S߈P(7_'	w繇	a9U] 0zP]1ͷSbzM:Tfpy*c!B=x 	#bgu3)CY 18^lٳ#mi&*|Q۱sT.o=-̇,+rbHA[
L{'w_6t~ݠ:wpC4#yCg|[7r<,@v;X3=ȊAqwOo|X	bֵ%+(0~StR7_.nvv{	Ɋ{m.o!0`DC^iXP\eǽn6P$^>s{5;iW0Ô`0ѵXb( APګM4\s;4<fp޼OeO'*!"9#N	B\lBF amE9L> 5xj 5ܑP9O$toGwT~ڴuνXeSvMT_ǌmŷn;_aq'O6>3s65ǙĔ
.҅ʞ@kϫ#D뉐WIN~3MΑ^F!M\q=t(sw@ݻ0bFV tB@LǷ0%:4m'ZN##|zթR-o|ޭ0.OzjɊT, BH>@d?g/$l7fYnIx6}}n6ZqUytlk]b	o_t2]%.>|t/<}˩2b:9AA10LM 2ژKðurK4HRVdӦg)mK&TIF}&?R^ҎVķ|lheD3Ss%G*eTxY}sDoL0ǝv_:WIǅaK9m'9ޮcӖ4aJ-ȴH4UZԬ I 8A t	
ǭul	ܗqOXDfaBЭ
"vfET!Z!	;/>﷧i1[+-rͺWN xRϥ%"=\qɱ/n6tZnĲWKʖЮbۨu:kE[7FTEh>	+C;M5bɭyeS`ZҔorE,)k)Υ,gi\@9 6|PL3W|%2$5gzRb',WdbhzNoJYf[}t5qoml3"20+oF|F`$ HC\igSηI&+I%3 /v|M `;l"ˆ%-in|$[ȷS5Qub39i[մ,v-sv3c!hCmU|_)Hb͛mna=I'uaeW_mⳡ!g,;6YQ4dЇ|IЕVDhDa&ť*<!'=Ť\2'rjsN\:dt_$RTlgZ\G-㦧w$LDJ@=jsǊ !.i9sycGfU#MJFq,P"8hJPGJBIW2ؿ9*ӛ\k4pIjfҗ%Zf)q߉(7hPwZ*qg}>Blc+U~SKfL2bH<z6lQa$n(I) LI%+ppWvF/$Gd)r%Hi򜉺Dۡ,²dFE󧶑{fdLde04RŐV@#jS!RFr噂v:tCFbZd;S@ȗD!{({($BaynD!ӾwGg}rpf
#x(yP(8\3egeWcҪGWٽ5W%#)t-v{6>"O>Q@U(AQ҄A\y<n2Z%	rW3-rciӋ:+¾ybvBI.-=iJG^hq6ʹ_Wi~l9b'qXJ L=*g"q O?BISG|Ne_W[7g@H.q0HJ75zt<#\p;&?w#w.9<= 0~ٺQ	H^<U&VKb9 57 ыR{ ?JC3{Zm_4HL~ʧ{w%ep,uFkM.eEȔeeBJ@L$%A6S NBu^Θ2?Gx[S|ҙ8*MwiCߝ-KH,8H̊q%eğ&).)*EEwٍLGXQU9ŭ,L,dtWIE'f!(c,-́"(l,ēz"zj)i\f_c~ŕeT\ňB126#cVOqكH){̄Rm\ERERdi{kYoMNZ 朧Y`s%h(Q&XWH\de̋dm2xXA69e8DףȄ	h[|e\|	2򙶜dF`SjHTCwC8dWٚ԰{,*#W!! @ ~Ew#!,*"Iz:?d=`34-(]iAcu0
ޛaB NCngL1io?y-B[!z >OGyG%}]c"q%F,2`K3G-\y,k~Y^ )ޘ,
a!P wUtP^sE*.5
 2eQ	]J4ݹJW}l8 PMN3b'RQe]_BCg}tocOZ7w}9W&	TVim8%ۑv@HQ $
 ӨQ A^5dxUk*@(N,_zNr:ݮH^|]aeGF (-qopp
԰t`3ActJ+1hJw#nArqW6<Fug.e7;3/o%s3y,Ŵ_yGءyO_4{|zHȿ3=	zNᐱ6G_4hV^Ӱu㟛}х>^^]*ypKה#|;cB]Cn- m'ɿ.x]S7o#[Md,!5jr􊕳u,g<n\ ) AIʬpo	G:(̯V*=e趑6Dxbc.Uҵ*/h!ZXɳ>ALի~ğΠ
"(<qud/">١ҚFM,#;Bd1!POl'rܬ᫘f>3~}5!
GGEqx)<722
"]	1s&(c+05?Jz!&%3}j Ykյ',w#] _LwoKآ7U͓$D2Y1;)Ǘir	1odPU"K$r*J/]IC}cne)(n+M뗾\e(ğom_m~eJ8׎tI($-:iHP8ؿ.gy:6}ouA7a/T$5%:qFֆÔڎG׀N%7i7xqzߜ;ˀ2 R
B
t(Nsw8]*o|qw9XGg .ŉ΄J 6www/8ô4[
(qNzh|v
ㅧ&o,%6=H˳ˤ炀:pEz1Gy_[U"Zw 3*@	)Y@2WT=qvfK"1htŵˢڶgt,yDC.,"?e-ybLj!?ś$58%Z?ߵ5<G%lD2 ?^xNĶҠ4<)v``/η
"	ݑOd2ցbS̭$8}7tRymM>)p̓/s3I SӆAe@Ћƀӟl
pM`%ur@c+Ipԥ#B |gq:r`P= &?z;$;CqN3ELndiGc~=嵼o_
oþ[mAZuE݋zNmPiDȠD,e\)$I
J2OOƷ)c>)?O)œ;tw69Yp6뱯o"9/z~R(QC(XMGS!.5}GbX[+ROok?FN[K]$ꁵ/-ÿS"`$RZk]6]ʹ,U_{2I[)kllu,GK쵧R	Lа9غ#)"`зdL=M)
LLTvAdT]"Yؙ2ggÐ)(lKٳIO='sc"*8HU{aQSn
L77c`eƃ2v3T)"ujr(WQ*{ jkMU|4/o;ޭlHSI8Ƃ)XYF_Ĺ!gT@(QrR<bsk%"##n}ݡ|WKM%%%VCwHUF0 8ۢ'c),xp8A $0sB$e$$Wwfݯ/5)@H/E^CFŊeS"I[f_9 `Z-JB9SX,W\j/VGaYx}de(#F/툛abFlma{7	fZV@gmJu9V/@+r" uClڠ<v[CvF9  ө10}L&co)Ǟi]e׸ig]J}eWiidͤ_r?֨rLϷY^닕Ϊv&L]RK}&S:k;GgjV0s3[񚿕is;Myb6+ɴ=mT0D	Fʥh_k[4cսo_<Rg3m˺6[fq4<ħݠӶWFJCjʹW"-k@($ Xǧ̫֢.Pd?]`o{C`WeIDڟdU *PȖ~IM() 	zj\ySu+W`@nTѝyrgo]eE"(WgN?ْ_AE_v7yW[lar\x0oX>Aмv&16˹eWa:;cB 
`I 2FDaG7*<]Qb N.= !SG 3
(;\ķ[rjyNb/yvX4f{t#A? (xszar߁2yKb2\^!Aۓ =P&U˯z
F{'^#߲%nt
f( 3JdTl4uH1lxYT_+WƉs{R몋3avbkޛY_zjPVXMfZN	۵b&`H&``' !HܳPI 
0[nٜ *>' ȖPn)xS*%a9?fOLލ,d%';>2w`D~f\@hx8%d CۤX "
dE
AU"01PQ?GUW4> #.bFD"+"uUL\BuY1e2	!sy;/b⌙*[-oŞ/'`!Py1 3MOu7&BEfZ>!,,J{='%N1b13Ԫ}Nܞ`xV9da>Ym)kUvS2',Qha:srV4}1`$쳺brK^'|4~Sb&Ui}i-@'SҩC[{ENJtl(|F{?Ԟ1~tDRD	8`6fQ:')Is:6T	@bydR'4҅|<ئ1?ڪbE70/3?{]K8dA D1IRe)}=&bo:^R8!{Ĝ:0W\d/xYLGs̪tmlݏ#m[-OUr	ddκ_EOXkWGgh^m,SV 4}4ڮ9{axUaho/jDH44\kR2|M7{+9އ\fǎ*Q+Ukm{rEZ5jקp+RbJqQIEx)Nxq+KK6S<MY~4̡|Tl,\0_F$j&͡Efśz:k*nU]uJTMzQU׶7eo:Bgg|}:;e@/KfD9U?lwmweV&ReϏ&:Ze\Y9/jpku.ZGmхrO+?g~#W;.%nQfqcXe	B @#:;#"I	d 
, ,^\R*
w_Cmqaqv>v!mGW;6_Z 2A]>?/0O.<iųX{Xxl5FOӀ@ FǑ26ݫKqM(eeaD&b% @	3eiSsR(cT7#6;hރ;!:jpJ\~ci>)Rl|nf"ֶ(s.ZU?S
OFK1¹,cں΅qXdETG4潝6QۥgUM׬]2jjR_ǹYj@pO,,ZF{S/D8ۗlne;2[CZ,k^ޞ2"yɗrB'\w?74|.u.O,8oҩ^7')dB$n%XKg⣆nCdjp0"H4#rv	8%\~y"L"{7kB
TygVǆ`+.&HA{(`QԈNDKj(Ze	*ה| *AD^;v+]jaצ9!{fzսcW931Gͼ	V̵xkkj5JQPcAehBbNdӄ)?ag"S#AOHEތDp՚k3ǿ;ާi)lr@e?.~s2('d0h z>Xy}P73`TK	LP
*e1q<	G8(lVg /%2U$@SC>u.qH,xc^,SV7F@(Gz6aJ@1	~l>4[YIt7-.'Kԫb&2d|1rd%Q:}=2{y]`r;'EBLn=|_{KqRO]SrhԡHjfjIcr#[3UTW*:Hb-.YqlO5I
_Thy|)tM7nzJk捀v&& 4@XZwzob|^j+E3A"L8WƬ{[CJ>W~מ5A	bBpaՔlk̛43\}|{pzxAywyqupVo?CnQ0S"e%.xYC˒Jl+$8Bʞ8?	S(N8?KV\|nW?})-O䙀LSĻosAaj:Ŗi[RgNFAJbthE}NخB{At@o4˯G7FH=P^S"I}i{Sm+rC~?N}_ݳ{Ie窟7϶>|ݥ&TK{FB-rx1"k)ѱu Xd0)Sxwk:xfMv$e:.VȪ
0	"1:A%GXlڅ6l@%	;-i+{~iwtlRo_h'cv't\!mϽP]$$̗j4ڟ.%i5tx$qr"+mgvT#@m]]=.].&2dGdϡy)3ظN^ެv`b0y&Bs3ՈЂ,uJjI3Glw' 	ZI ]FvHQ9-p'HI!ؾt$@'t!!wqwZi#n:ٴy_Zx?]X=x_R	󔲔y'f0c#8vD$,k'alӱf0r#&֧D^e؏Hv){0.5Xs(֥6C1:2"0ΒBbA?(TDAu\}*
PX
AAV(1b"(ńU"
,1@QH(.Übt8דvވ0!pA4NRS!V:D !m<3a}M6_ݹ.:n3
7[]yeUu/qv_9NY`^5-`]c9;f>f-8>?w</ú¬uJ6-ư@ ]P̠Mg8'rA2UX0b)G_|4޽romW#S4NW.m}U#8#(DFOWUXa*^0D.y+,}|l7.>w&gR\7o5A꧄~UoH::xDй>Y#vhd<OֺP~R$'.=LM8 ywu#v9
	~XUX
#˼m<RyNOf0qoWk'Iv嗙J8HbTgyXSvm;CceB_;,oL8j~ev,^!"^EOX@
C0wqP?CE&' cjk C$]XN(lNwX)}xM9w*Ԣ1EB8X6>|9q4hrdM 7HC1P$0OhC}:9D$Q@ۋg+SnT_U1.1>͏G~djvL̰_3`NfD	BP<2IkBE{8'#)D#8p!z2
X`^i<8	eij۽VW5#%Z-S?/i|Y EᝉGuZԮhX+7}sk}Uno̪~2Ȥ]A()dBirse `|7B>21%oAr>~~B4lY19R)eOF^Ut͊*ƥ՝hUZh:Ee2m!$U$	H&@ͤٵQWjfWȚY"]&ID)Y1ͿR7F9ī42*yR"ah,/#zȿDۖ !Yf$YE}Zu;: @ =/b\N&{~MeᱬǹKr3&,'2u 3_O/ xYHrϒ`^Uw
J0ԋ:D@B57. 
%fMhA,e.><u6'L "+UIa%"L0ILAPHLwАI#$e@)dL!J%	PR)H%"@%
TdZSQb%A% Hl"KmJ-H"s5S$#2I$IA
HD("K-[pIaB(6(I%T@!AIe&LI)`AA8*HDJFP,2̰lİ2gdBHa?c}@WT1CVCu]. aa@D
CD"qU}Z:+\nZSrʖn^fs=bD<ܓMcj>߾ DDc9J?5WjyO0{n_VjgȒb*~BSdQY6iJ"_dVs	jg`5ͲCֻoͿf:zmw,*zzl'AA}z쿯|cL.^~T1QȠ-	l'Sd1k%3DFO n#h}'Ozmx:/)$mz[y6:.oң.z<(::|7ތt)BEyHPSB4S
*9F)q3!l"B'p"[A`ܞC }elc~6-rM7F*4$N1^E
fi{2B07EՍc-Z1h7'kGqs!r 2	^g4Zf`",Рjc/Ə֟9<X5r/j2
f- iAuУB	 FV
xN<W+.+P,WSq?L#YP;xH.wxv{^u m
pii),:Ý6@cA*FERC]U^XZaizdK,L)T_\#iAmB߻qY$wC3.l]
={&!%	dͺPkЫ54NrU{M>Y(^\4"5RBڣnK<)LphO@	xOWRLy^5}9yWc&n'yTVm8]Űw[f0H$F	
88ybR
?bf7I \ ԜyVǔsbI
8:d<.',JcsiLKl9VA	#/oy}_(VswPTpZA<Kdhei}.1|t::h7Im@atOG'`Nw$W\V.󻍤w[fҨ7齍S	(s>$RB4A
EbWH="*믨=-Qd75׽0Ӎ&&MM{O1ˡFaEΚ
@%+ًm]47371d^rX ʆ{4.5-hSA%@E}>o.j$8	8<׹YAB$Pd_U4>IX%F
*B9yŔyD :ⷬd2h}h/ū #^]*WYe,p#z< e$YBz;[ELLхb{y["|k!t{#|p B)IRd\`iǹC{t=Tz]_qZɳnm+jrM6 ыs)TMbh/s6rZd't:6:qޞu]:&8oQ)rNʕڇ|P@DvȀg.@}JkЋmgPE'^),PM 	;8dȡڣi7Ln @m&eBwٳ[Ywp˂RR8;&-=jԎԊj:y]eL ;d8hJAM$"M0,rcJk;נ8$d9HIyVUcOgc!vERˀ$Pl&3^7kcvXrK::yCW),"C7i<_%2@w9Hmk(߯Ŧ9k#lȖSLpF(Nb((f?&Jg51pDK]f][Z72A96$yWHe~l^m%U1t&'E2Gճ<D "@heb,	=QO#?||ґϹ>Ƭcȧbfyҧ7"m/#f-n*2p)0AL64!!ÃFmvoɱ:ocs{n@b!Q0)/TVQxi10p]#JyI
yMPIMJBJ$Y읬7HaܠNWc\2՘oeV% YȄI*XA7Ҥ;Dafâ͑0E6SJ@b aP)l4eڦIO;2>o?<G1HCޟ30l?KZ4!Gˤ~Tc%%척/9gUVn7?z|<zjAjDz?Í5GygqcW2ɥ{&aQя1[[q#qOPi~+xT=-R;O:^sh"E.-gǿ/ћ!iߒzfٚ?T|3]%_zeJOң޼Wտg\ݬ,hQF\T2cr3634귂\-͌ByQN>ak7!\O%Һ_2<2Ha?E.yIkڶqsԔ{|/y{~iW>gYI#+A`jsN	b˔
ZtpQd
{ra|1OPXaynP/`\KkS4P>͂27nqcMu1/եbRw(o_QjhԺ 3jy,8׳ǿ6/Л]DdE)#
X
>,9/u4AH7תtyĬxݜ/)%SN;kҒFFUxĻ0*7S
NíJ_(XU{?EOUc~/(sE]R4ifM0z3O>_1/#e[YTW#CցV|z 2I%l%}-V]O%
?yrcn$)ZzG~DU>ηbhzC0rS.Y"(dFNEG&?JɌ$JPқ*1DZNk
ЦF=4VO$zyY%(-=?d݇3Pى7W˕H7#e ԩƯI!KV#
- ^wVQ !s'd$Y}2Sd^/ft;(I$kO"Pᵓ3oQYYR2"`;#3nM4EFNJow'L컽{k3wgZ+~Y'%k_Dd~`97`U儮%#;%Jm	4j?,!3ДЛibQ\ddn6nJYa+Kڬй{^e֛GΗ9osna4
iFd*ϯ2s#ҁ+469hĴl)h~Bo`XvB+,[A`Zɱbm4/F5tADRHDXHbff&ʚ٢Χie7FȴmKQ8%̳Bl˺zr(QPcAѽժ49M16Kȣ fY
$MھVĘLJTڍNfk B$!F?ę1TTҌXh17`JYa"խae*ޭDb552t!RK2y2oM(^+_%P(uSm(eȔ"'$L4D+,{$B0MlXË[rB-SSɫys7ICw(kYZV)Uۊ
B)nԁ$a:HDS!nH&,,jXd+0eIIۆи!r:Hx7ý̦t$U+N/!ia0-!г2,	HM4mҔiD=Yoe;ND#.[@c*@:3kT9XRjThAfA4$@ "$
mDm4ֽCԌ	9rJ$^aVBHYY-obl3D`cdfXUyS+Vx,5$%Ͷ$<V0
ř1eyfssy8HDEwҳ+!6s&wR
ѱ,f&C6@[˼1i	IEQ4AyFB4Q+6A5szb?ȍe	2,Vzb!UcD1/R1+MUh!'HGZ39R'u0M"A(00;<W^3bCG,k<dR3pBpʛXŅ^c*"UQɋ@,M$d^PmUyUf"ͭgBa^4Ł"01kkU%MN(l1T	RbTZ1_p*
T`H*>cMp0th#!t{_]V8иH:1e Id/2bZ0&DruhK4ĕb,F*=.?ZMA$cٻg(V""Q܄:%I7u
H23V588uri	Z`4A3y1;|ΔOozecEf-cop-bP@攉

Z++;)H^obHXFyemFidh@ŒeWUy͒ĪKZ`E&AfQSBX0Hɿ5v
0IS8:T֎K7A*LENNjU|yi!F(5[!3LiK,EWi0rp±HA8NnĔҹ	F/Rd"LWPpQ,AlZq_#sKMX1h6HC-fDdQ;TB4v<^S32bJ,A ]ܲv4)
a#|,RDRD!D	M3rһP*63*Lc2>ćLcVe`VfmNŖ])7ÖD*2nsS7I1xe=-eX.eQ?~ĉ $f&J-"+̉!9]%LO '5TaHU+r92 YYXSw^R#OYSȔ!xbͦ-L$MF2L8bYS[:4b%"RJf\GЬl+홫X-H)#:A<&yٕc`,NLNH+$I%fH	QT(c4ùPlJ$&uzqRv>,bv/',X9Vfܜ$ZOaK7sy(Y^,P_Ūj:BXf	DJn,|ûhl Zfu"v[&Uy@nZf-.QՑ;(ѧeg4nI!6TDELdV0E%ٜ.(=YoRH)EYOŧްzx9d#O(ˁLE݄$}ϲn^KPl %-_mt@؟Z-X?q
čEB,9|0-وB9Ji1@``|Q?-
ڰIf#MvBՌ칌6?ʚc's}sF܌z^$K@-Z~1#IB<d+m) \qǻivכ>~ãZ)EQX~"kmbegujNފoY0if\C2|)Gm3xrڗiB+aMgWz:礵`EUvy;Wrǐdֱ6nkޫqxJ	bp_Jb{V2ٝ/^Y`ob]>puilꡕUXͧsSuZѷ|ǍSHS 0ڑPVS-T(L''PU]Bm#YZ OAԪ1#^XHxˡ
VJ;^u	!ᶅBSd@Pj  )ܷt"߳ni +.,"vx;Y{؈ˏV)$8$ hF^c8  T$9B1	[|O\;KnN{ث^kuyaP7n`8!SmJOo_@@4$b	Bs %0^ Ąl,0&K'uV!UAYŗvIuwx,={3d>JsOV;w_<9<[}\8~/'fc߷g+vr][(U%\.,6Ue(8"rT CQ4S]>9=A5`u6}/'fsю{U~eǊ`v+~׶.¡3K=~_ťfg*VT.=D (/Ht%| 16dޗ[G;=o!e2w+ }eHuVrw91"Nן߳~}oOAYFdHHϵRYzW ffla5 GKu?k}rZ]~\P_U:	:W/XI#va`8.,`@tl{Kt8!_ jG?(^AZ*ڴZiP2!$wC( Q4*ksT\
'»նiLP|:woVF9Q~KOѢh"=@lL.IflSG1OʜyEqJ%<s!!_MTjV:j8TR:ҏYT"%⧹u]ӣ\yT`X<Fwɘ,8%vI<b\Z1`Ia8ܳtPy
(!sEPX9 fmP[8-dbā  HI(r>"@-˦9<9b?AY3w
6czKP7x
И*<
ݺtX,wZ\ljb;iofA\>40{vm3^@"cJg1s^lb3Es,^ҁjf))$+vegc,USZY)k!XpzJ9D2K@o҃F᷆N)IHɴe "Z;dEvza9F`2}7p}흤bkk³>р	;n,QW;oAn돰A_
e^1#Qgg)`q	ha7Kz"Hč2	3ulxfo:Z፷QJ-\AzC'MslaP?d5>Uo9iX'kY,!!AweHHe%=HxPcn¶	q;	)7;mN9S0A'9`iJ\%s6#׵YZY,܋J!dE%&2n!|ض3@bK˓3SR͙$Gy)ZbE+h(Ly3Ӌ]Նɭh9#I7S,r,M5 Q|Y!;clh-=D.%V2Weef1rZ Q		_חH	ݟ%նlq6G9nK:0n<ZsڎcRrppYѻGR%Lo ⬭^e b
G]5y"$3` A mWll8E<oۋ6Nghb!ɝNΨYdkuH)Ō^Ņ
<G[|xf3k&r:9R	$c75mig72M{(lb(I%gS9goa07EܐPjv-"9A 92amYf.mr"NDbW%\FÑpP~兢g:z։t-܂'1"6LCлoOH϶o=nǾЕO0}ܛ}I-2픭nwmXkDxKD@Gx5}Mz֩mOdfNId%"(+CኩJErEa:;}VsH:HO#͖wzHvHŐx	h^S+*8q1Iֿ}{xxU;~vW ;mlfr8t46йAm+Vv#"a*sz'R1VROZ0HY/.2gӂf"3MmZUp֑A퉐P_r06܈Dk3At9ֈ^Aн܀1bCKd#dƑOu"$u1ޚ㡓/edrkmhFLY#Obiw¤EO[w#fH$e|<rѦTZgDr7<m3<Ծ6RQ|&p5Pw:NjSO9^ƆTNuY|$Xur|+?B=1X4VCըɖUBg.Cꄌ}*̊Rd>iGkn8ja)5|)Je7&Ud8G$m\mDe ܊φxk)O$7ZĕYoS,ZK3t#;Uu?#Kց¾YJ&Uw+AZr2dq@V>CّS҇EJ)!MK3j*y7<4F:7 J)\"XJNJx-%r}\NQ+1NQ$7F@dO5=U'vlBE,U60jԒdULR'IIK#Q:JHgY#=7ILeoJ6y4#jMg@P)ǓNJYM2̑r7Wy]l:]+]vċGD%$;E'<lҩtKn2Lr$Ifs+nخ2/&{P,3ɹ񊱦v3aVBI/cQ^Ejq
I}AFi&UZyͬets1[PPhR8~7}FfwD[ņ6l[J$
TMP
r?q(G]ٹVHS	eEyj
V z ,Mc%K
g}.B2Dd']$Rd)g2!V-v*Ga>JiqL*MVr܅c$bQv2Pe[e<NNVAʎ9)ɪwQYyG$
AEΈ"Pu5MieW(VW,ZRJ
U.$%aQ2喳9dRjv$y8](T>wŤfȥ@3EC$39	U|ŭb73+xkJStQ糣)[H$lc~
p 1:$E;UX2-o PndEq$xNX,^V>$v_[!>z
A 	P=Aˀt8":h`gE3j!c)P_h"8EB,c5	(`gƶF"#]!`Ijag-9RJ.n:R҆- wdX>JI&	!C:H$ƅBd)ʼg"Qsjئnan[;Z?hfOe4h$Y[jp=f:Ƹ̻][10qn4.|C%j5?*`뱍faJP|G*aT1חKa2|o/12>du׹tG61FwLÙgaS60chSaN*9TϠousPiy:m}uɼ瑣:PDLF&.¢4\ii"@TB2g!
q vg#CQ6uww`sL;֍zn]MP'u<]N¾*kI2}}#5dN#z=ar?I~w]]q:nWל΢y-~~O?-֢~Ѩmӳ|EN	; (|s.] ƷCZ!85o35"Y0m
Bm?eژ>0%Nu0^ui54&'nz+rsAc^oy(󦘅HQ'WhdmQ<=ouzj:-o[V-~,{IS/"ݟej,s (r?|J̜C64ecQai!-e	#дH$caM"
:\l%*3"_6QU}J')DA
OE<9K^Ү#Q4$S7t!+1eVʔQTgvXj	fF9Z5lk=*gb]?,l#(91sa*\
. NWFW!#q*= AI/C"T/ǎcg:F4
ĭ3{01BKEI8֌qu3햴ן(V',M2lP, 1VocFua2녯japQ(RB`JdKeQZ:5
/td3؊ ^ٸPHD
 uK(1D	WL]LRRwMssa	07V1jyem"xrEYʋ9_hR𤔣\{:`Qpvl>~#(e5'4	̲^$]ByT]iE%6&t(Qͨ"di?kx*вE8&$k dZ-Cdwe5"_;(hXǀaPGyTFqS|\X`C*ؙ|Z,9K	P@Q:O# 	,);;f݉3k.AKsUQxTqe3VaWZ15r/VRT6!4̎E6VK WGĪLIMRSytu!5r b	5`JO$bjȝ&q V2bVV%U3Jo.U*Tqfrg
g(JAGZCC!9)N@1Mu`LZ\i+:Tcg(OCsV)4L`IYMM_9^qpw&N	DZPI3XCX(#7
kih$"pZC'ixВי7(YsHgT213UD#YdDʦ1-!1k755!%j8r$k
ḅhJMg˱fw837sg1+)D";!Z[K^94TSU!Oe7K RGYef&HJ::: CkVXVX#2({ :*Ⱄxg%RD2Z2Kح2
hϝ
NG7V!&"Iԍ 57l("ӽLѠnJf=cbL]\͚T7ޓK4KLծ9_q$kITƁ:"Mɔ
[,	Y"ۉPCA-2b`B<%L(tt$: +mJTFu!Hȶ$9U&RPF{qf5YU+ް)Q,9²SΐQ438+&rHЉ$*kXC7"I(^	l̲ t,Nآ0lw\me~f^EK`0RiAE썔BTC8DaJU GAnԥRSm+doT4\-$TF̓X/?(TJ&){]d]Z$w+3bTi6y
˴[T܌Y4h#Z!N
!)x%jAp`,236aTꗔ9e"J:.ł{eUYz]3gBKS8΅_1 ֤buY_Kŭ+ E[,cW"ċ:eBMU\dqs7}wElؗ/oωpidCɩA/,\Jm1.D̬9{)0pԆoXo<e*|fjlyV9%Ԙ9W%-+TW0BY8(R
fy&BkdsWW2*КyZ^nDVkNՍӍ
(ߜYxi&43Q(a:Ռ{.Tdfs֥Xg{ɫb$/ Zg0( H	\䕡8:2آ3 a5w2EʄgD*L^G+''#d닕kZ#,͎FwC(2fXҝ|r$ߛdmRlrTDM;RA	mkV-2M"YAl&S3#ֺY%Js,JhxHARNWC+IAe&%3$Jyn^d6mbm/;;wRP@ΦTX)CgR`SSYk]ѻКJimy$, Jγ7,-N6!	$b6+m Q%mzF#rѶ2mjg&Qd/{]+CV*C"㥪bM<Uͳ|2_$sU3Rl@Xhes&+2b)(f$AAJm=eKNضdᇖV]U@^YX7W*,˻ʺQeTҴ`XUͭDڹL
fq9a
eqY^΄fp9A)FzIEBS݄$!Fj!RaQ*jVJa!َMHLHHBċGytĄnҋŕjax\BĈ
nD1(T3^v bdse[N8LK^/:PFE%MPQ͈'VoHٖaDQ
g&"0ͦԕk"Ե]bAXo9~L1mlSmjo.ގoe|!yȢ䌳Ϊ^W%Cg.dY*tvZI6,䳄iŪl*Z$dS!E`EI#ZSi&Q,<	ѬNɼYhejZPD4-=٦d^Ǒ-="AÛKa.=M]6
%a%(Ѽ_ gfV3΍\˥m!pySj.JyMJ滦5(ꉐ@gHyvpc-,٤
#ا-f*E$n醗BXd[$:HayլɵIdYT85IlV1vjIŦ#X8YMr4$J*VG΂뻂;aLQ5Vq$<2P2,tSbT&%d:Ӌc41u(:!4hrɍ!r`5UY|եjAY9!e7=bHؐdNN1VV܋)iSFhk:QT{kfQ'Ʀ%'6qJ Oj 3*-jn3znMUȓ2]%׷ңX'#VHޅ=E6AhH뜸ȼAjM[k %$+It5Y8HF BfS(.<F[es@Π(;uV -SB+ؤAvQy%H3&!"Fw,Jĕ@#$1BH#ٔH^.8,RWdhX7JK]]SdLZvݳri*DAFl,tegyprʋfԧTIg)%HQ!
$oGielԻiCm#Y2AU#	KيNqOl*ʰj˼n y3cmfZy[HZ(ɠ(b\#CA-g:uDFfn+L&YYLLdPt$mVU:1zHI7A:Ff-4Bn[k4JLNT(a
gI@n.AZya#am Zq{jfmH%$4`;kiXi҇t=m{ť/ G2[tUCb`BMݩ$Vu6H[+MQy,<ޏV#u#G)[)GLb<
%blQ )̠F
24P
ZY<)iê۹w%Z8*Z)64SX$ѐwDeتO;s6"\짭cD9mnĵpND0)^DC²;Hib+;"y*K(64BK\g4f	2ә=:Y#y5r!4d_΅жן<ջc͢dvGSf/'gLmOM
):Lv)v@F"[MU]4[&cDT)b&TL,;̌²&M?Kzzˌȵ`Lo"EH#7TE+XIy&3hM3X+I߿;XfBUn[ȔGla`ԋiw:FYe6o* AQ:NG,b7݇8%3P*UgB9LɼFuRɂ2ܤ=R[Rd_CwB:mO(yre@a<Th𠜹'jiyu⵵~C|Vt[FER4}C6zwiֵ`Oj (R	'6 %{+cQ6i=^f&8ZvPD!^+o$;H=	{AZ.a:$	,)tZ3'c#݄nKO>!Y`[fVQQz*-<'-mQ̢%[%Ca30h=T(jȳDt@ccR3.`CFǄJU!A3M'AXbӌ_i"Ƭ]PHʳcHRwTL2R"9̑B[D,M_D4Ӭ!qe"#f,QMR& `/IVh,#3L"Aē)$!L"`9Hٶ{(䠹$*Tb4«ՌRPɆALDgSLE8To*0KT;4*`AhP}S)VFQTf*м3# ն(F(DI*jOac;JN4fLD%Fj5AB*aĕ'c@v H)(4#)j\VcFTγEqIqζc H!0r3E(0HB	`@lBA"(-`LˀHTI,T]EZ73Ɨ @3A"\Y4A9!!.HH-ႛlHHTEPrJ% ȑ%Rs(%
$ъD&(Ȓjfl^	rJDڄU)$IH(&SXJ@%S.L	$H%K`dD" a4A31.	!T)J$QNfHrP͌$ "FBRڥ͘\م#WZAKsu0-d	 'AI,h,#$HaBibKL%QD@A&S,2Eٕ "hF9)%(]'H
2J H9)ARP (2	ih$Q(!R3	
4J-(3ZIADòYH$HDAAQh$JAnr'~"ȐqReQHJa),WZŭb*- 0@ s@)e-"I"Jiɖm,$@ i$n((L	m* ,:@!*AY	YI`! "`$ZB!ؙJ& KH-4dIIKa!$e Y@e0 &"e2ĐҒl ("D"PVaT24B-"Sp̰I5jd6A@H J%DEQ*e11&L9$"MQ)Id0A@ a	,D60BpM 
@l14 JH˂I$f޵f4Ml`"!
A[FhC $"[*1$J(A[dIuo|~*s (YCkg{_*dE]FE_b~WV.tN_-`I5

gTrPj^c0[86%.<bK_.<\@67"Cۯ<1=_ն#ʈsנ~17c xƺ9եK[qwKNl&gmv^.\]xlk|fn_\e4_ٶoQX|b+AGs75]Nƃ0UL?:)=EzP4wI}/A&WPl=%qo4IcQ{ec7L; O2vY`-n}ίVLҟ#Qѫ~*4[ٌp]"iz'm4J3_Ĺ@TST雅?  
*$Q#h:!! qx o>I;`+vHޅۅoCR\m6_L7 } >XJ"8#LEҎgՅ"S$ب_GE9 ̑$Wp$72JQ+6+o/}׵h_T0uYLl+(l,A֏[d^.;Rk* G^!e^dp."ŊҤq,UX-I)6c_%wpI*),"@DyBz/tơzZd2GX
Ŷݽja0-v~,G96?Z˻{ܳ#}2ծy:P [	$(Z uy;]T,1]s5.j|~M>?H dbE:^.HU$	"$O-5~[9\
,_z<\bki:`6#H!%%?j(Xj2ӭ:Qdi՛dʪՆo_9K+CC%k:PW<~Uga^'ԾUxU=,yM{(k鉂f$0vTq`<(4/"&+R_O1͜јfXv0^TNXЕ|N5:\=3IkXX>u22?s4UqTؓvU(}W3X2߷iϋ\h$UCXURcZAWેZ0?Bh(2j"RU[\S[^R"`8	q;Xf_~4u>۲ݔaB; 
 @$lɅgy,@ϓyM=^SR(9xpyw%X{:t9f5ajXX	;Cδ	mFAA$DsXHfn\~cd*"
.*RE|lVx ZBDDH$gV3jx6 wDNƮۥ4&,Y%/g;4<r}=?ny4:kn~UK|1'7P>=V8 mm)5Z({D2#95}vJAwlJJ?R	a&3fA)ZPMb(?-<9'jyz#"1j|"Ev]EfnQa|/(e|MHfD4Ң> )Z'ynqV w:Y6v)^a
6aw),;kmvf,ef59 Dҏ@-Oax<;2qmkf) bS@# '`I2ȶw`+"!&$W[sdEѲsѠF Q6`"4RZre !{,}ff&XNqL6M3EjDy0;^I1>V`JD=ciW1(&Y2(՞Wa=ű=w)x)pԡUOE-(\I6:npQU8.cpغ=]i-|ZRYFR HUT;lӭ	e."^V)	@_9:SfוA1§nl}}E ~q=-qB͇0rBDbx<TԙICd8@!dS՟((
bL=1Ļ)l
97'`w2=
Vf!""mJns	5hLolίP;?}H(@e*3(7v:H_VkeX_X` T⹼k}.Ψ.-16/BR~͜Rg&;1l>`VR!,~<J=U!Own"kp?^YiQ$S׷ڥ<ʥrt.J{{+kkPD}V*o]Z1IJU Rӥ}LjF/U0꽴;9ig?|Aa"jS52t_u5*s%}5pYU87Z%Bu|9!p;#xC͋,FztZ Qg#(=A1❲c(6D̧NK15@0=^a 74s6rbe"6vʟue@LA8Iđ36=hjfR(-
Gij^eEV۵Y5.7%@Vf]iɄ7҈o@*:<"SmmNSaNc<BxY8ɕae(!dm$wQ??+xԖΏdY/(xaZ? _2J;V}sNŝr,t_,]E
Q9^^A6|Aܡ!ZFpVŞOn0*\ѭ!?y4z<Ǽ֏w17VqkNUZ,iԮ%bm3^J@rL Ӽ,T%8`s+5e(< @Kmu
:u] _a*Ǉ?K/7]^uP;a Y	
sU-1ƅjVqzф_NhoUe!՚rm;V䰛{
#
ED" 2	"*^SOl^f] B<!\X/Ow%Փ%ԂFRŝ4Z~A,F؁-ZKF<]Pcw-';Eeh0eʢJiU-UMf.aAB~ge3/m@_v(WxwJp
$	EKA0юtjELd
(7~7_P6_1*.fqEH.;lp9X.-nVr=BۢRnrӝ;/PGqŝdϠaBPLBe<"̜#\dXqfk0v:]/s3ga>rZsUQY<̴ejGGOVb+5Zϵth1^e(ri{./I3y;Z^٬p,}sxQ*y;pwbNNne'~Y.:FEj/wt9s++R)tշ6\NNR3j6ٟsB7wu޶]Na7kYIں9K9su|:UrFthleZ|ƪZmԆhenQ(\Opoy 	SxЧIUKq|pvjh(s5v,(
ُ/?3co8/X50IMr5ߞ/=ռ/f=6KUlWʏ}ǁ7W+Z亂+/_<8I?jA/bsd‴+Iým!@{PSj,RC$ )o|qw;<%?7-sr>b1yȸ	:(	zgұ6fv _2?/d 2WuJ1Mv׀}YLifB 	BkE
e[q;(W o#{trj͡}(U0 C"%ƍ VoW!洎JI(=^xk<s"co:?X"PY-j] &ƙyf rAs1odDCA	X1\g-rq}D9eY֖{1H<H5"8F>CLV72|7lv11C)DP
^Utـq&q2{GvJ[`°R|LnBPEȂaʂ%	SZDk<cu2IA$PPT 6C*@BOP-ٍh$?tۅ4ߥ3p<7qh""oۑxЂEB^q}B/'LgXe*'HIXRf9ZV S9RҐce!aB(aL{>3Fޘ5wHQg,qN˙~>PFEXb)W!OAkisˊ2fe͖4V~h

Je#%\{}kNԬPya"dιڣU͓tM)"XIm3/4HQ97˖lZEcК&-Cn;VRep/lJ  l4:C!1s\N`@ͧ)
Q#,DA .(R,pJFQjjJeͨD+ X"!,B$!+anj$h
!狮oǗV\gžCPL!&@Z *\ث^&S; OfR+Q :_x%؝9@Ƴj$%ǨCU8;g)hu> o9m,$rm!bebC^AJA'qwͶfG3	^*_/X&I+6{:=C[}N6+JWHcneK~$EKeN2|` N֍O(:=--Pzs6iUm(SM֚[Uqͅ8CxޟdƴU^ݩw)Guꔫ/Ώ2oF/=wy+>ESQ	YpSK6TQxn
EnuTS۟*6Ƕ|cvGB<j0NLJ1@sI~헪ļ!$WM\Wr@GedB^8] 撀rVH(Vr7ђjtr3iUOT3+|(-/kԪI u/t,<\z۽׭$£)߹	쌲x,J>qժ%D.DPWNR~ԡ"X\wl6 @
` I
sv'90wmJvOZw_l'z;Ŝ:
S^tré&dnHp89
28Vxj$D؅@;5~pj~
|a@H1x)G[534Yoߏ@bqV3
g'9m땷nAH3M26^o(ފ%vd?c>h"l\PNYQ(qU1.;cF]ݴYg
e<0-om,Vɚ0Kה5O
y!f?뤏3Ywxm}/+۪&&H/è},g4Y+]>GY>p1Y(]=y_G8_}1[Kٺy6ۘ @,'y4F(
,@#$#↽٢*BP%B/}yžHAmjWy݃VR)dI2f,2ߥ (,"AWZ~3vn^1q?wzbWD	Q|9B:䷸S",HDAh={6k"~8tto"[pt6cbe՝$|{ZrbFbf
WQ_l`Um^[;F2k>p:U~hŪg% k{su\\Z4HT`([IwtP)c9Ld[mV)]9(aޣy%
,LvV*5}~^mW+C?'MTY^ lL[/!Tchef˷oGZk.:_F9­aj_]
<ݺQsm{Z\jovm;1n{,J+.lKkkRy{0e<Yq#UCd6CI"EFT`ö<FA ~-yw5vm]&+	3,\8:egIs4gQPfa66|ܽpIz.QRo)8Ct>~+zZ?6ʹ Fb(bԏYC]IێuOAwIsVxS	1$%ϔJpxb֖>SMߞ?dQWI]6It/IVv.X>;8C1̮aBYt!ӼhЪ,j58h3\q#kva+1HNRex6IcXZ̶uZS)&n⁖w(I}c=mb	^ѝIFP8iYX?j#i5쟊U7zH9W/Ooџ녆S_ qqVLծʟ{.<s[DVtTtҤ*bo4$cÙm,q>Ӱ{J!<@Dm뷳37sϢ_l߭Vױďzе 厗;-|ӢLN,#))ALĺ6;F_5np@nB6{s0B6{jl>9wH03]8ee@A%#a(K1q*G i$w>ӇS'``r
ygSU_{LK?/qa7\E,@k&d'B矛i/9!5ff޵$Ei{2hcxL$;ҤIdNIMT8T#2[?<=ǖˮ/Ao^o#Ql&A(l`(L5Vm>3Yl(2)!fQz@+B`(Hf2*z HyLII(UZ{Fvu,d-D"Xgҡ44Ŭ{P 	u8%*RST|?T!c=^{qIpMg xVD` dթcD\5W8ܜʯCCg &o$̎j7hy)T`8%')EiqH*=iBr	IV0,;jםVfK"MXs0b9--ϓn'i D$&( M"'l|30	 T#8Ne]xu6lYϳp& П=]s)Y>`%y_h@w(ĵM5)HSTn\A)z=>fplRoZ0J)hQ&ƦQtcg흓>7+B>D"a>jx+<0A #PWsd@@qN?odwx|W|'N먵*sYV
5l[Rr6sஷ]!➱
~5(:py$~n3zEjʧ eOݘۗ35Ƶm4}Rr=pD%+
Cw꩛²B	LUBljo~CvBaC-@k?|ouou^SИ]lxj(*Wd
-j	I{3Os0k!񜫂,W1:~ڳ[p<:gwԒk_5ߖ&U&bY޼ƴrX*׿6U&BcEYk>i%n*IF12"aG:`nSZmUJr;"T-02<Ϡ+.wǝcxigZwīxw f 6̤Yĩlb%
J9>ڞoSdB.Wu:_u|#BG	@=TGk:?q{ة kߟі(D$N*P"$vL
J>LC?2XQɽ	T7>))r^1bmd>~<ƨ6	+e6[UmǎYUFqLшEQEmqOo7Eg/iޙC߆xz^R-h\B|iCR`ĳ,ۊ_/0 ^~XՈQ%-MJTRy^ӡz9؞Ϲp?A#6 s1A`{eVMpdLO=/=i}nVjr xٳ[9?u{?|7 l':d+R_"bq*Wby@9azTUHV|+EnXyS.KN
8(En]IH_FzA~Jmebۡ@n;ʤdYrq㜏*T.ᘱnYBMg3'z_x;`?%Ond%;aeb﹠7jzӆ`RgIRChA8(QU{{eFǶ׮/o>}4}I1=j?khoy%%LdPdJc 1~RU48[NIV_lrj
@)i>se8G,MD׆ނ-;}(~@̣(;R>7Bi
>`ߖ^Q(F'F[~G6v4t?$-|q˕9wt\'Ǵ2 ^s, c8dH
Iχ;aj3
& ˾qA9$}Zz}bLƅ-X׼p}ݥ{*/Ns7{sN?JK㹫&Z.rABP,RQz)[-,z5X۷Έ$UiAb=xݻLN'}p/[$[P$Ve+f
Q̮b+_:]0VF˝e;OAǮwscqVHl~X"A WBy ,@@;M⎲(*ňKhlyjbQV;17qSKve)C 9 eeWvrl7q5ަfpgU,jn}˘@̔J0lZ$s#Atλ:$A@!/cnk5 mI'Euǵ?7Е@"~}Hsԥtǝ1SzI,nl.˱luܠ-.#[g8YW+L`R<ɦM-DEoɦ5
Fwآ'h7{݀A>j#OH6I{Lؔ>sT8M+APXTyAkCӢQNqxq|EfO$fexWsrteVR 6[ӭml^>Gmy^?kɳfQ*_GXŕt){v{:ªW|mAyr=ttd	qn_9| (];NFGEw4[(Q]}?k4/]ܐ<"@Ɗ\2Ճw}WP-u3psG.[U_׆cNTىʬaX^u'sxN]f=>Gu:yڬiS4Z;zu:S/m<7ߓ@ڳ[vyeV<lۻ+?Q!@FFF! "{_dgyWO	ɾJɉ'n[͖QͮZXrCmnɧ<i`Ct:L8ǽ_rϸǛ`ȹFţ܀A26C7tO&˲BU{䢏{<QHd i*3kw_ZJ(NuVEڀ4AUg[^"IQ*~旌cߐp HX" 0N#mHgTMN,Ep/	Ld\΋0@NVa[π!wI9[$9 |l9h%>R	yͰ˞zmrjrDl<9%`¿xln|jql9,U)3-뒲p&F4Ascr7ݙKB}wM,XTN-@:*Q\ Exbcwkݟ3Y?
Nb /`ؼ@L "851zʿȓe(2oئ'0NpFW5cS{fDI8,9I2_dvaZ4踲.LH\-3تm,6UF-إ֛:W)Hߠψa^ES
Ifzm$ƾսAXwjJn#u-!-% vz<C"/k~ k̫503|B Pj	&'{E DM2#N蚋򭑸%Hlڷgϔ|E8@tMGu)'>7!.1#aUŴ2&dGʷlw3$~[e|bޑ"=b$UXE9"tPG_
[n;F[LOMbmp.Gxݎ)3K]9N\W?.Lys3cFStSL"
"VЯj|vO>BS#}5Ct8y#2ef-@h}!q<cf[=-hEnU`Eͧu6	A-N	ЃSߎ^Eff-GNf3!n;
;,C@>3l+:庇rjy3"~=.~_rc>=Mh;wr/׊C%/[LvQMji}龫Wi(>/|և|p$ z)y-q.*?L=lLP/}gLQe*TѯR8&C)71$2QI`]HQi+8lgbHFhH2bprK'LNk1: 9bWRэb|HbRBKMs0*ˤ%o7)Kڽŏg{žh?*VK6by)~-Сt:@5%jM2o7~hY)UJc-$-<O'rdaJN0Y_'y:GKV\:_뫧Krc99:R0|ZI5dȐOcUfB(^a^$Y(A1=ICmk96ÜU*rlx<)͌A𠎉2u:Rs])KDԡ	s^a9s9Q1(SUQ2Rs|5))r^	bЗtu$7K4JANQtWrvyhGws%H($@ 7qL5l;Ny16筯[g4YG%XB,5,cHEs#P5?wcijkv)jNѯ@ Rs`5}zRѢ(ND(K
iu+gUQ"+3Ȥ@E f#[t_
\_<yq߅/DD1DPυ+iur!٫&'MKM+1B7dxf\Vᤔˆ纸LT]3֟ԦobVn-ȪWhݶ[яki+'Ysj)vDƷ,ӊQZ繌ablO$9<ʉmRTJ%%+z24z8fl&S}Df]>&ηz^٨P6I-&qMIИmu[YE&Ш-"W%(dRX$TBh49JZ*Av%EGytαv=R
K\
Yj	O%]mG\4SY8ͯN&%C86,5PAAm{ZΉIΉ812i8aiCr	U
'ՙJtB=-dW$ZJWjyYdi^iߪW]3[q|9`R\-J"fB]э)f#<ba<!cYn,w*XHj9g=)ФͪecusP4ͭ0
kvδ1X̎k5"u|ޑlͣZZ쿵XDl%Ic
؊9bs'ZmN_I) >BZRY>zY/,56Sn)	ϒ@ *5'Geb@M y`fIK])[Ki(zίZd\53ϟ{lȪyGBB<4ݤiZHP>w|MҪiV3ٶHxa8@]$+̷?ƽş}S↹m]9"?l^Zz-a{Og^]ާ:2Yda  $@d"HdFH2x}Ę2"AB eclgcO/?^b-t>ySQ)fE6!?U,E 'A1  DLTw<2}հ96~fܾId>Gg_CqŰzwvղMӨz6:8jpǍlOdԦ\g:~{o]o;YXl_=-Yxlnr֬*Ms<k3=̕)s{cҽ1.Zqw;m<
09DU_=iU,ÛsBTXPbwWȫlN_ /^+P;tN=N7P|.vcTjC牋Pz0{f3>|,WkVT4zFz\XW9*OrQ6_Ь7XYԯk[*k3Usj&cujﰧG6w黣0Q5hVּb"SdmO(Q¼h|vwе)C؀^r8vPTCx
bfQ@ J\a>#>z7Ce,Cd<[_w/#Y<vuPwYX=esUˏ2P=+@EA'D@})'1GdH_a d a""b(
U-JKXE=Db$Ux+~k-lY>~o5ݡ0& m6mӔΝhYcp<(IW݋GȌd:]!,࠽+q`}lB(d1֫%>硥8F/H{?~ۄZA \pCm8-<*(3Rc >_]ᑖӪ)K7FSs͔v|:G$uAs?~kS_ |ʹv^9qoVBD-HEit.Ĵ(hnHn85mgSTBpjy7o8.iV9(B/XlxzW>YvYՙ~״):=6I[,:8Ч*ϥs//ǛmOkVĀJRE٢M?g0]kjcs *ӷ=VɓͷPO٨$ \Cjl&eP5TaKɺ.uQ5iV.gMy6D\Q@rRcED&5}ڌ&dD%ێxA63/5Y&;<)R#E>	3!l H⽻ƽD)~=#Rq!B\acj)EG_?/_p6L|T}@@IŻz8v9L&A#)tno@gV-`k%~tH.{̘*O>	?
z'3֗H<^`bxDC^|y aK ) $oARxOIثs$DEQ$d$D"E00ێofr;'mѡ(Yb@5jwz/@ *jHh
!	OK/0է:c-F@~<ab
	'XbPE/ڞπگ.Na<!n  L8 Yeh^Χ=L ~gR       V/~CWe{oW?e:YZ<'Dٴ%Hjj, +^K9K"IOjaPrLނ=P+݈4K祼FPT!Wm/8=-M>3!M z rio<tf?gFZO	RZj?tUQm9~>/ 469(<ȏ<]
cq|@R\Q  HA	};^Job=̊cvw0*+	M sI[?P7~<O ϱ*JD)hWږ<yu=^&K`B1 Td(~1?fZ{ʦLKkǬ!80Mޤp>_B]mbn\`GP[w}iMs|S,n[[H8=| oZ~/x԰4Y8(|<_.|^WdEZׯ(D]<V2ymzdxʁ!}|8b3S2/豨zX[{>ߚ3P<^|-͉P}Ob5zB.$EA$I
T$f-h5sHC|,UzKJVcN1|z?qq.OQJ), %Q  A)\?c(g3gZ`N*6f#F(hڪГj`$Rw|_PMe\9?f>@  IXBsT(ŀ|k;4-d	5f3S/c翃{ϱ3;/}}-;_nhϯԴ2l/-48yKuSO/E#ݳ6ocl*3k&[Wb|(|,c>c!<W˨`"OdD(CzSPc	9v6Sd\
n)i3h{$>N=~#BsK#ddRBeo{AA dQc1B	AQ"#Xa!(m acaU߰f:4{͟Y4zk?ՉYun:vxq;6uFWZ*[(Kcw,! ڡrGqPsj!Y޴	>aɎssZ2҂t(S?%zkXALLuR)dHa9<2d*NsIŀ&xB\6
W?x)iW)A;L(v^E:oT'aBЪb;JUsgI瞺̌.Bb_hbe}?\"s0E?Yqw+}ġqȏq7ތ1maAGS~
ZWܙO[:2ho"tUfVOyY?zxb0q63*G6,ܠ~.~sԈ [	3l1#RRMZmɇw<C(J\>RҿOx.ΐR!RbK}M_=]z0.!"Ȱ+VAdꃈ+5MY8Y՗xu| ^h1z|:P_7U3_1z Owܚ݂;B>ӏwDbH!m8yK|O-J$A.T-6x2(AyT͂Zl;5p;mv?%z;-+PKBC>+R>vy#Q# ߋUB-lޮ=},I1u} ky+~)i(uQol{3SYb1%=GdH(I)B&R]eQ4D)'Fg?@Si$E
Gut#@:(I`9~TAr5
kZ7_{cyRMjKU(sݯv]Ԟvᾓ?</_QVm"uF=RMzSQ`U7mm,Da+NsN?GϩchKiU4]6?__nۚ)POƇL*1T9+Aa.O33٧Yp=ؠ@>B'ډ!uQ[=1O.?|zX^?NKZ~Nӊ ЁmT	 #B$d@!Wވ=4KAb]sr~!bn< 	qEK*'1 @@w1CAFPp7 ֮ީ4]/v{G_Ͽ"kwEe"Q{`/ϧ}KkiJDݽ{ZuW8UP9s2)	<I2}ze]>M~2m=mј($[qЬVVFkT)`}_
(4,X̬[Aqmwm7~:??uXNSEQ޴sBMV#VI]waq^8cF'_aKhuIH4cFA+&^*NXRe9H.%n@<voJ@  m%  ^-Ge:m~"ߍf&]U3])oE_7_r6&ѭYXR%_<]5ū~]~iu	Kʽlbx>=O1٧<_/et7~r"gZxRիVYY_X9\rAZ+,Xdv9ot8+>
gF,|)(*arUe" ;K"A0@ !S0I"Cg_1QBf<xokLd$9H200Kz/c}NGM0MZF~^V;bY l I"
B

H
XHY
B*1EAT#`EdD# "`) U,UI"$F*$IfU-걅L~v:i!u(MlC	娳Z4>~~~ ͻ{(7u_=H&+iVjٟ}kQO9K(?3-漴J,]){aOz9D3##<  3Hxa<MUX(J%&AX	t%[J^+8:U%vH|ث!U@ T88'EKt^V&]= Lc--_;@vDޏTt~Ӵ|Ըޡ^}m8c,uNG|d2'^2PW=Z[]wVѐbtZyJݥ1i
 ֧xf)H Fԭw3F;T|+
ֽ/zռos25]A^'O2u6 KhCـJ@6~` {!v#V8&(5b[NYeYj.?L!Pwۓ+-ax|KZjá7Z,
\PlE	-́tuh9qZŐI5acoG˺<\_tԾOml(T\7Ɗ(ءLP)ȞU,FIt}sw!""? sirb0 52swg`` r.i1cOá0-}c _,b=mTHI=[/=_R4):33+9کuWPP\*akHrKW?__s(-ziGdKgnw,희fU*3â4r&U>k?p[s3E6BMT<uSVNrQRG5XT̯T-̦<}Twxx;,wQKg<+]>t=/wOc:	&#ΓͶ}S|eBG(	 }~{9K7qPZ1ԔKa0R7z/ì[bQ/|9	k;9༚p`MB'BJ $)(ŐM 8*t-Ǯ*+\@yoc-+ܰz2pH  P~(LSVh;ȸkj߯|_ܬSezkk} a.s;|>,tx]9(κ>Ù8/N9o6uTv}0$!:J//΅AZjMρ\I71GחFf;! kc@҉co9c@*9`dTxN	5KϵT3-=iv|QSK?nN_](ڡAb]jy[` !UܨK=7!nP8E77)>;fk_Š-#ƌ gy ":q/P:v]y(xf͚N.mIu@=bP{>C'dEr慊%w8C	l!	 Aі+rՀrgRJ4Nֲnw??{*!]a  zK'Im;Gց#y8^ y{$ص$
su)Pq?/)/b>ռۚXz8R
PXAưX4v=r*y.[yP@Fe?9ӽCq1Gz2O5(Jj8&_?~T}V4jဆ=T,`.ouƛH^#%c]:[3dNcV[-qPUlTq.BC@08ЉlNP0A<Z/dxVOgĵM)EtUʅ{-d3\t9ՃSIm}au{eKz#iyB&͝.;X"ebƙml^"/^Mu&ƨF
emFWo/X-|U+=nwߐq5ڲ.F­TRSj7Xnho/U]ǙwlکQ]U~=ۻacJpvq(08''kG|>ϪI	o(c҂+`;$|n6dX}euY&ڃWmo<OGkHTCeE):[Н=ܻ4  "ŀYk6'nY@;mqlXj2,'|uo
=hKSjC F5iՏ?Lz޻~MALy:EL0FWÏU0]y;/u+~]I~Lh%!RY!Gt./z0h<horԧѨhlLǛ0R@w~_&pH;PlxGhpm:F;?pR)ͅc?xPvbf_܎0'Ud`!9.}gM=@Lp@eWIz{cʴgO=>tG˥=oPKp!^8C$9!c	((uLMs7ع'[ggϜ=HuH/*~_gEtN<12\h A[4:sql#Z[YRo D@["-hu7,+C+68<neqnąɥ>;6j3ωss ņj?%urpq)J<ZS$ }ڸ*ЯuS?D4U|Q}#_U퓖smQb7UDS7ԺWhbe]&TUP̫hDS}$\uj*k,JuW]q˷mm[*ګmW'FPH6t}ϋe?-nVٮ%JCMRGu_Zxqט9,5xMR!e2j5qC7#nQx8tF voaQ֭TZ n:;TBv|2pN=?[m 
!&g'#` zI9m/z㆛щ 5"?Ys\G- \$e<   0gaر6{xmJz!H)!C}>ͱ[Cvwp?`DBs?0جśht[F^;ꔧ<:Q8{%(WD= N
a%ëXlt3]xy,O	dUY|&37G)	KNόv~ec@G)JRcŢ{}ǒ>|QESS 84p~YeIw;{r::nrma:s:z}L,[T@@RK|@.1fJ,)CIAM{ngXoszqiT,ZU#1(BBMPew~x8/h^7Nj?2oqxkӬ{W:?0Cgwš<BrLX?W3rUR;zavg|nzگX(qj?7-Ҹmv\LKM]fjkR2cZZMVRR3tv}b1׺|n!JJH(yP)J!!#1A%sXqݠ(SD%2L[GqVY,B0K)	  Lڊv*Slyp쏄EKҷrC8Ld3
ױbzk_i3JBF;j)9&7S?>Ӏ!dqb{w GJG#A"y#}CQ^A(E!L$~jͫpbkVyt;ϡv8?ԛO,>z!)C&L)6"T qB a+
_I3p`IU~ݾvj$vf3`eyqR`>NJ߆>(i4 hDv 5=I.B`Km3^{&v5,uHr>iU_$)Rz%Zqǁˀ#fY>5-txՈ!}\x76H䮹p!Asݎ6L+)r~+>=gTOo,@(vN$8eG$'g~Z7id3 k(NSp"!a,&i@GNg3O6$_ɰwzܛ40R2Rt46ȻlTq.KSQQrof[]86,Gʉ>-=%?BRN^]Lj̙0DAP Zij!k}q8ƟizV .0+& ֻ'_
tFmpMhkl5Ϳ:{<G5neEBYpP	MMf҆ 2Ϝޚr&43%^ԁJb
̮I.xvن^68;YQ!!9 K!ߙ 52[XK׋H2	a*N6@]L
[( x$3-j.3\"^5@ZEGYS16s:	RzjP:g|ɪk9ϳs_C~^|von1|/OAYuV4dR99M̠\"	D<@
\٤
Jq^/%ۚ|6ׯAho]L+-tK8z
|dRIcϯ|AfyXLC0Ø&ZN
մ5|,cpe凨j>/pN# װA|G,Ǐ;E{ сcÑP# Ek
 Ŧ `4g.|G\PV;<v{N
U 8nOd#e4sbs	;Ոy-,`q1eG5h^]st"PЈ 6?C3a 0 *ؖAP2!|+KnSNDZPA\:.qjarƍm9VA
gI`Fn)FIeA2m*G`O:@#o!Ra@,ZҤϪɘQc;d P!B>HQ]	77e x$"}aS\h(U (t2^Ҽ7SN0ppWaa`@lT&р׿ញ(.39y/2ff!b[Ul
l/*¨3URa$i1+ܥO]+p^ϚǊzKvN&(
q:;g6Duy8;<~O#uHz;j2B"%J4¾^BUS|to;}
4E<elG RPo)EJ$iVCe63YnXY[9xUey:2jL|#E&o]<(bp·W#]c[B H(":bweMӿL2<c쳱/-䠸0ZtaT	U=41Jxt
9.S8od>;\Hw:CahC%ϭпPGmF40ALQpjߡOAgodxꅘ=Th5&N<0L传M>|=/(3<TP)1U$?uQec{7檙T֑Ij܃>SIσEFHÖA:%k*!%7>_٧]]_ÝyhBKJ#Ns~u0v	6M(7L?ӛh44@]{d뗸|險ڣ;r:X	#D'cq8]VU%I%A 69c5F'0aӡD@C"J5 @?.;ki3>g*:Z,r@6pUνX3hl5s:[aLaoyw9`Ό%rOd.jp|?iGǃ[P#_ԗ= 
󊆛ĊU%@.<V!`=N,CcZ
ocEۘn1Vwgv)
,{=p9Mߡq3+7^cE(|J Q`m쭽s+qFyLdyP+];,ׅWAd"O7]*`l:͜)Cĩ
sMP,"GxKQvfP)+yn=ǂȆ2c=atlw+ Â ȿ&WI J;MI>"v7d\byR7oQT24 $
CAB+s x7AQ$1/i-0a&O\TAtn&P(5كO4ڻ/@'e4!j.d9nPq:|7m31=q!ӕ݄Ԇ*PJ+RI;:vD8+D?YӐn!ZD`;az6K k*DP..͏8`+~CfG5[׿S	pM0 [F">0n{`R0TqNz%sAHH}w&݊ܟß^ ?LR[Hhmx)&Y×NF\{	ҁy5߮3UFmn4q6/MU쳿y6p_B\iuxSP(/N\Lwb=*ޗ 5U.5y?javrE{p!dtn̓J':@wYj
jo
j,EKb5  P !&JBf*颰[Ӯƙj!}JE#7<E  A\y@n%d쇟dN-~Ohޙ>[
0Rфp W0PFQ5ʃk?]BᵥqSm}1Ў
l0?o@O:+>bzf玆8>zhZ9*wzʟFxVnK+S+l,b3Q}wԐP_l^n!~TȇU߯7BnIg>2z?ODneWwwyr4
;}CRS	8ݏ#< B~:]}N?qhtX\ĤaG/Z|]|ز~{0Ev;}}ηd/}i%PO42׹Y-:MxƶӚ$I~xyn0žvw;hZb1g6*֊&X7%u/nO1Z_}I=܇> I}|1PC0fbNuI3ۂB'|gYwhF@ۆf`Q Yjx%rQ=>` kYUlN\x={u:0ST7fgm5o-DTv`tFCB}Ryd	:A,֤<A	c9aC?!xqɤ/铞abz)JUn`IgOEkKZlo߳?[qפ$sHhb͍:NֆsK1D#68C}N4GĥTLU<hK|{`_z
ƠؘwLkvfYC]W~ܫ?A+!0~PA}5ib0<Hw&WȖd#R2Mz4f /G9܊%[b8bA%UB~' e>JҫX %^t;AG|-ol49FkݔVo+BXFӮGŬwp\0eaըG0-9ぇlJ6pRA! MwC6QI`eR׷)hp'cAmYsFP7NFr$0
j.UaB;JvaOwP!+Tgv:ߚV <+?@;!3ѶӛntCK0*܁]k՗Uh!ǖRz|  J?oh Xo3{@gaC`.E,Y?kVQ@yW:Ӻ|m|W>޺m(䙾O78?'ay`T>O<u5y.لP^՗߬14xȰ$_V}ON`ag>-> A~4&D1a&EXxd
y;q2}mK.^‽SvyY&gkk<bqD[tϰԱ j^j G@k)@}-hщyF m3Mo\\x ~m%<'Gל@4S%0-{N}7/7F6C7m{79̚v6mK$i%',B`(G	)4CfR\Ƌv[Ym_bu~i	ãr9,ٔ6{kQԠ9Z?6.r͵`{:_Χ=5عQ@l1f*F$H6'Bq$HOa=U]i*0v]Iq:
.ut,
bڒYQbJmuhuT@DXI1%qG; t#y<//|y,*$R	ηZ!M2EFuBέKAc""Bh;뙫pҡH8&$(ww³k.Wᧀf)?#:;Zbj(huVnXk(˨?vAe^.Ӣhd*MU{OϹ<?իv)s6k3bigqE9|;`s\$[Z9ʓ訙"\\\$v򩪱:}L;ؤоtT !}cTsw\EtTG_fā{ρ`#Dvm3`eaY@&GӦ 涳 "!*I@fdh7Ζ,8Ĥ ; $b|r~KVSmrͷ2q5nC|kq'E')4 R 5vI@-"L 8co"`i_T6/|lH5c)ZZ@pȀh65%
 -UBqQ{M#:+ WOys_Ӫ3s@/we6@t06uk ?.o'! /؀ϜŹGT@˯4ě}cP&h&	6H@5dyCMg&$dhM{$!%̝KdHmXс0ȁr`2i6I6ղ{^6 IOÛPLh
 `lJwM>/\JrF7	NdSSD
v`^p& KU0
+'hs)	Ӽ(c;/B@"9J =Z.B5!n=9C]S}՛]Q!E1c{"őN,Z[9ܫcP  Trʷm^ːǻyw[籗tޢCd9ABv1ڎR&	5$*M:5	4djmeF8ShM阛HX=*CD2]AP9Y	 I:%s<РK'?( 8&m*!Y><Me_Jx7\tS͊RG7
bNUm:f
qiM4 ^7pVo]̬T-!;y;=ﱑBl\P'EFjCKEUf9y7\2j10
KZD1g3"e,~1VƸ#F _g&esF8[\?`_W?FDcumzBԢR ]7rd6lף #.bq;
~6dvږҁ?MF<,s{o:ԧۃo'aG8׽@Ybǫ/WO{{EgqVѪVOIAxǱHR-C_5`f58D$	<a ڏ-4/ [ޔF,hחF}3Ns "fa+ڒ7/|oLM&n}g5כֿEsF kC>ͯE"tfZlAJ1ǫ1У]u,ڲ3]P@^l<+7PnʫNE%Nzi]">4X#rďKziBbB	=7.Q/nU.Q	]+YH,Vlo;AٛEev!Ve:hRľd1'(Xl`]66`'3\__>{uKiN.hj7)qa܌j6,yț͋ҦnA̾Xq[Jd}ԙ|Te CwVf6/#vPr-ɍwdGͶI캼de|P
AELGvZaRq+qa+*j@f|f>-[	_Kppc<r~`m=\|͵8rj-k&fk':w}%A,VbI? *Ni`O+pm:uGR1#њPO$$R;r-Dp^1q\4AhhX3X`PCp`.~F#%	_jG&(-PzJEգs\W)\˸?qu Q|Gdm^8^IjmxpvkXpWA$ HQc9w{V"1hf[(7$DoA|3s5FJʝ˩(72M{$߯p C( AA~-?7̲f|{׭xIA
}5n\Iņ)vŔciKQ芋Ω00~Mhvr7W"Ȭ @"x:I
ipW,My<L	m*X o?יּ7"YBRbɋo#ۮ 9hw n.9SkIhi].*1B!D%x=p⌡7`<(_(aT},Py8yrb;`c;AE^v)sl:C/iQ+.~f[8^ƺ)^VyT,b`.;af?@pTW69a -[/ʸgx_7etH+#4д-!L7Nao?5}Vi4ksp)YZQIsBn-#Z7I
߁t "p7c3|G$zPlSw	Gh()$@>OF)BbOB\oO&.3?oc9S~ar_ |~=iH<GX^Ed"еCb }?q{EJ XޔzTR"|"  Y 0 uV'C5FۊB͎Uwt|/ێ2NkVں@ΑCI "mԵ%{[XO3)Ќ8v3phr9J7^Y.^>jz Q9O@<d+XDmɦs2CY"dD-b|䕲`$G #LNY_;.iuKTEL΋vHj_)՘<a]^@ 1b.jL69bIV{HFD8協[w`G\9kIM2>''˞ZSv=Tް^54Y&;6zU:se-zVOy̹w=U'rpzKĹ0=Ʒeu*ќi_ݼ{:2vh  RL4lv[EP|\톷RnjͽL*m2k-30_w-{>4lsE`cDVɖQ6[۵DTYe񾨰p qH칠$d@O\@V>vGٰw[FlHF)~lD*5be;<`> <o7\cu;2hs-oQpιcq]IZLP(9V=m	~BړdR@ma3<@;}9l
d_AX|Q¥/$(MRE7O9^"ߐwfi$FHǫT=(A(pSڎY
.Z
Gs^xH
Q V2U׬Ux#-Ee>!߼{?Y0r7D߀PX'j;G`t	 vtH_ AAw]2Xޑyb<k/ND25xGsm67\Bɴ;-"!2,`+Q_&-)37J@=FU? ڕK.<fs@n/$Y{=Ac:ܿbCCexHw搧:4#=nYva'F\4?5t4Vɗaq}3ɤ_~%֥#L͇N"*<Zu\"pŲu
Jq
iIߏv-6I7Gj6bhuL,\f|IOY	Aϴ
ġ1Gp1 ,RD>@	8@ D@|qqN^`ë2C6^(6J0>G̗b(ֶ35{$\!p.֣-gxȞ)
NT#yҞ  
 : 3G  4b,54lRpvյ"*JV92eYijo
#h0I7Ŀf|	vYPg)oﬨߕ9?(99i$Aft՚,ܶxsY2 X	&ܹܨ^-"eH,bȚl!Rf` a G/wdt.91! ݞbwn^v/ݷ4:g")`:UPmYŧS7uׇċ)|)nkwXE *|:+/`ut/&KЩZN"{҆|͜.۶(ao[hHdXCݮ;&[D?=
wfsa9
T2t]&^Y#:'_|~1|d?{8̐%bV``/c/{\=|`c}G@-&D2sٮB90X>UG DtQǷ=&b1}{]|J?+<S'kd'axH=cD؞n l'`lb7muyMѡI"k嵝V@Hs/pk4fi ]=5  MzG"UZq$P#]mAz,Z6cH׃
P<KclWC7:cOUz?9nނ\YSplźҏ<۠r_2_ٝT=<@"^k3TJI-Q9|8*GYFH M2zpky6_vS2퉧7ݱi1a+0Q g5^4`斷%̆B?:Ea<mڲLH㟳D6D<γM0ˡC{ZI'ԯ:yC78ɩǘ'[)F=(shv4rbJ@k6I+w_q#qgŤ%cBj"1D({6;خk="#+l$e
63Zh~Wf?QV pX0bv@a?^}o+JFLygQdWif||_j;X@p7(<3|U;*<rTcxFo\clw683gp\Mq\L`l}gF	#",L4"vד Kl:$ tE|`\c@ܤIQZڇ:
984^mP-N+1uP^鑋Ƌ\㰀lUG Z&QDUN9FrگLte!RYG A06Ko|{X&9@@]ј4̡]۪5HTE
ȧٴ k(!LZDjm:;JUO};_)Z*3KSWj6;СMzKݟiu)8@8n딩>{nhъy˶c{5\zX/	ou@ê!T>/#{)ɾIV3p/x]$\Lh1ŃkEjSd]JQī>% qLVBEގ
_-11!K)s;2s,|.PQItnOl?wNJatgޏUekQۼM>f|b#ih֐B$pZy,NA{^MiJ݄3#}N|:}09=4a	KNL
]Dj\$%{+?yz% MDd7nDJn~%b&XAzeI^RHsMi:eM6nLZR=bc  tM B{Iqddx=zwގ)3F:5CnƟ?q9p@t2߬5}U=-}}5,)b13omNgN?'fTO#u@5D\ ILvCt@Dot_	j#'}`i +
,XN9=~R}蜛r O.r{~S{_h4!	U[3F\a?( 	!InoPW^KW(!U[k1h빜<JZˍUϽn36k5nuf|o%)ګKn8}Ɏ<<W6v 1_~]~FՎaʹ&^2ws?|"M2m'Q7ptq:`O<\
_5 RX{zB3X9n*|𯽰וz+4\Hz=<J{%RkZ
A "rW!&a((JRw'mޏ۰(fed\0kO481׺P"xQ%#CZ\IU .]`UZU,g X}mO"uxNkkrWI@EF|mѤbD_Ȁġ0g;i50v;+qIVy<749}	~eJ)|0-n^p bh@ӻ#@MLR72jk/wI;mmڠ`$gzN2LYR ֿzU@T_wmTe.<|&I[{5Gu$')C!:ٌ0>cˁRZؖԛD76VކS]KUw2|Z$nmYኲK"GdVtBӆ'S*yv	'!y/ox1?::u[l4gyn~3Lihm3akCB斜p{巼S8-hu:%_4m#ӬpYHj)wgĔ	?ŀPtĤ#1[·%x^[?	"2&FEu_@H UG$m>l%
EEV;{LJe:rJLʻ[@>ScE<f"4aԎRD2ZgCH(S,}Z*b/(D36P{';r7,RPw~Pqh~Kw'q z-fd }<)7fqD$3䦕|W: jP-ATD"eZPbUy0Ϲ(ms\ w}|u?WaOb!Mw
a߻$f^snOܽFj6
A8X0)W ʙVМL C~9CADP5e5^}PG_mb䐞^1L`RHrtb_cI?J~^k#V[&VIf_c
ƩeRJ>[7
Z@(L"8lֻP=>
_sx7ob !󐤩/»;̈"ADDA"" yyiLXD
$uq<@IE>F'D?A\8b'7+h5@aL@"V@M+xbP}~sWx) }-wSUKn]ZhV,F"!E,-3`a{q@8Eb 3i_\>:Zϔ	EK&z~ˌ&
~7/gP}ȷwwC&\t_C<:Gk#TP+KȺJT>K.r@ 1L#_ 8Mq)H"+u
){Gy6@M OmOk/&Թ1r
do8{+(s!ŋB4+^< ]c#W;-UJqEӺa{k
f^ ŎCb3ڕ:RF%x	]2wJJ`Ӕ؟~Mu̮Lez`Fpchc?!{m_|7滝>7%#xd ,SWEصVoѻCKek:>[CsHPXk?ޫQ̘p+e^2CHsqt>Z,wC9\6+g
^wm.[*:#9d4?k? -CZMXi6&_<, D^jܓZLSߖ?0eTrS_=EiI>ykO^Q 6LcLx5Uoi4"+q`,6Ӝc*O/}IܣoPVrb!(4xAkB'))v1m\)y /)bͱc6Jqɶmx?'C|X{(}?)yZx1s*vRdJ0@"[ɰOH̰Ic]W˰S1/,%?FE<0CԐK0ť! +cB.kuYA#K)խCmwûyκM,?4\\/{EW?lqT[&qB2?!~w&=gPg+$o~hnᕗۙLIڠͽ`;jJкHW9B;!FXy`#Zv`M6t}ם+P6a1\z[uߕx}qѡ驣Ma,djĘXy[:αQO53GCBk}Rb^OWI~Y
S[Zd*y-G7ܾoRT: )E!JN"!u.>ȓ.ڄ޷voxn3)%xVPN5}f¥=hUP$BHJ|`#$ъ@ [kwTW^g]L7Y9j?$3   S]l.H_iϪoe2r1鞰@^~պ 4=C ! Q הV`6$&AVDHyg/*m]V]}j<D~3r_'Tfu:pYJ<*~[ZԺe`Guc,#l8¬<	}.Uoۍ0QEH^$ұ@΋x$'jdes3@17y.P(iy"EjNtg
FJ` 6,w{ljѶjE%YyZF|z@XK i@S(ͥ7{BjP22#NH PRf)JR*;;;pxӬ%3@1se%v4B":^~?󙀢6kX^b}]46Qq|XG7MeSM{17:S&bO؊h\&/:$Iк;<zRG+0]4206ab@S;JX }|XR2n=Dc1mov*}+b貺G!"U#9Ĭ$zn9xTۆe϶hEl.%˙C6_j`t=#466Jx5yU51Y= ^vE|ɜǃYvg)sJr᛾m[a8qc{9T&~x*w)%-wlo*<)CSZA*֞?TgGk$Mȍ w>"r̨Ի$2j4$*zbq[/Gé*QXVOٽɆ4tގ{O70
x<["ή8P@.J+/qN?v(
zڭ+07Hfk[?_FО>}佢%/Bp*s~k	o1j{҄
3(*:S@V^ό7d([MLӺGKCB=_0مR	cg-)KI^Q/Rk<bNG@r/ٹ*X1:^_HqHˣf7\5"4$oڥ6yܛg$R@YAfUeIgBP#Z_ڕi3%Yc9ĉ}|d+iKmI5I _~oru:BScBf1 `PO^Ǔ]l2;?h"( k<,߉iOG>Pޟ
"Jc= 9fywjPv+2LwI*qdTv<. ^ ~P<2񗁃Jq̣)W?{uF<`ʿ/( j2륰oﻋjwD$+ˢs)%`lܱDk? tPiB[a#`G,}6mRe0QMI4]=&5v#;w;Nox?#[-B!VrzXm3.EeVڀ@ս]!J¤u1QdY!(;7)z45߃|CW5notB3 }1F%(J^!bLŝ"s0%B\uxP'l{@<@?T.kn`9箳 BQV䬳ǰ+,kWRE#3#-J <@c
)F4<.N!.  9@FBUH%k9B5AUZZ
RZmD](^G>Hw)iiH7ܼftĀ^<H	3;g/2w
e"~N$ DZ^<1~ {O>+HfA!=~u=Q({<'\wN$A-,|~*>s_FZ}+)u׾*wSKU7* t~茔;ozC-SpRp8Imǀqqf⮩Ib@8ޙ	))|q+K9Uk/пBly#wEf:81iW&digE]ؼEHg9ӶݲaLC*#̙H5EL&K|BlMd#`5ِ׫w-5xƺ/Ge`$Hw٬?JrpQ>ƃkNsˣ=O~q30 7|}dq*'1@ivN)pN{#Jk^ր49PhӚN0łfM3=/<p.0yyO8t5od@}'X:`ÈX>`ZrO1 ky~sAY:`ei͕KT_)T@ ?%R!C
=}X+sq+u{0sE>B@dE!JÙH{c8߾4~ÍO_>"$g.kƘeeSm#TSJE	g:4k6yqXfu?v_~.^s<lVE	j@~Q" e黿v!s@0GS;m/uZE38r
?< @bCe+e1]fcׁ1[cp8Xrp8DђPPhe3p_!Y56Z]'ſGGn_&zwD?x FbJg}>EU(s~܏$_SHC@sS3eɷ+ll<۴xW%`s|тM2>|i.k潿}GwsTuU)KJRe):R(RB
 FCu~Z)Uhwʵp[3|==)ww'ŝ~Yz5B]:˗C7MsKpǬ*Se1EEa<T}k]k,RvfK0BE[@ߔx@aˤZN_xo~87"ytzPXvKJ&W+)yx˽(#Sz8zS-Lv W	޵uKeGv՜8ۗn{
{Վ
av;7;e$`Gηj<t.\q\^(s-DOHQsyD7f4^KNIqyG<^VQM4$+zVK
9a1w9nu%=pxڶ#
$?3d8ta/x=iyG44Rx+[K7SoM/l3Oax$g[lE|!lsW S_y\&=ŧ;fG dVhN2qFRe"<!w&D1?o^sU]P:^Y>3JY+_Mxh#tMn{90eiEx@.
x2/;GlpG-x&1I)РB,@l𫡅-3Al5>&Kfp3N8n!v%d5*Mxɢr^Ǻ'+5%#|lSNOʈWs	 }O Ag]G&oS)Nt@]@&8Be*	; ~@جhϻ.N;"bEsx8geGnGu?_y^(#XBgx<Ԗ;>Kju}`'Uy(&j$\hToSVۅ7^(&ռEq7fjN3JEk/8=Q7U_F[2}?i|{Y#z_@7Yk0_{樖8y$ /woZ<ٞ͌7v;۞ΐi24Qu9/)/0@v!2JėeU:+gg;IcПᖔIkAߞC'a%ZJO~-XICPHtSdZ\R,KQԼ:PG|F)&!a濳+^``P|A# Ea$MAgB*Yל@d.Dy	z%(Sp
Sڀv9^W4PǙع<=P2%@ixj;Sr]^vkKlX?9AƇ`e>uu<TyZ*>`3l@<07"=V`,gH$K?"5%	8|kJꫫ8ب{ $npm1&sN"lQ-hV}JXx1؟dJ=m?mX~HXqZ<._jyZX76 ?Q T
c4ǔ!l7'|%aשB 0^cos],Ukx-(DF^mg&\lؑ#: v%H'/_ƙCt#Z̄}q<nv~:]Yuo<hO']T]mv>U8OFj>0ĻfՃzߝC:,(vsfUR)zYX.5j;n7[5}Vίk*:P*PbFm!}A=]V76l7-ωp;dd>'or1Gx\h3<n}{]QKszimIʋ72uU??[Lfg63Z1br@qXE ~GK>-<u?ϭ+'&d+''ιծ5#{!Rϼ38#\^TJe~[a<|B1es֝A^0u%ʴ4@f:d3	<Ŕp-z,9o61>Sq.+@6OБA18$a$i9E1w6m=5suɟ8<mp#ߕͨmۜ(=hh7f^Iz0${Wmo}mrsO1_}Lrհh^2<L`tHX;*[Щl>ϔwzEڊ;STdMKh>Tg(#˹&))J2SݥJXQco)'8@,v=g@^:vNٮ8ε4#a!%'DF
}ҏsAOiuZޣ}6Xi'#WAx=m^+SQ&S@pY/'I^I5W4\[ݶ^%8Mބf~<_(Q|0ˆVW_XL~ݮk+sGa^B8CL|V憑)ۿIhFȆk}1%E:5{/`^ptۭU^̗cíC:Yp>C=>5]7Vuѽy\qV/ው6zg.|'bM
72e|\}Y, BMC3
wb8VPaT#ސHٚV-.pg8߳	N$7;L2KsZ0-"[FMؤBF
h׶r1UxO>RH!1L6J+A^"0|c5# ܩ98H9A,dX8w&oQvm)dI5Ll
{7\o<mB&B%݃W/vl
xee:5!`9HͥC~J<1Y?{56)?{nو|BVǒQaˈ
BL}CoD|i),/2n"&3^;CL)Sm9q
d[4Ҝ.YZATfě3	Lei#dFu(pF9ekPN8 RKߢ-wBZYVp3w^/u,]ꓐ&#r*1}"9{GXg0z%GSZ\W}㺒kC]AxPCZ}Ouڢ!̈́eֹI+B>QŽq,9L>>yU
ϝCC\HOyڊm28f ϧlw;٨YEވ#}GqMGTT"a?PˑőiH44v%,|$UR lR@h᫻:^i29kQߞt0bGZY:)k$lvW(%4[g$R_!f6(q֩p$$Y	&cDAMFùNmQ x _h1B,Muma0#_{E{wl> liZ,JgWh;U/ã4{7CsHH{ia+_M̶{!#xN
 BkK!~PQ'8$ bOH_'av9(J=K+2I;!#Ip*bXp.DL}Q=~\$MԻڜ[$0wfAr=Z죰R?N'ߣ)|dm!2CB}fޒ_.T`MF`69FAH٤ c,<s啹ȼݑs< %..B\}NFGb@7$b8=L1pv8 l.;,ӷC9L; qBy]8O2 SDBpHL0  ;K0IˆIi%F, -xzo!eE<FD]#i͒=|,@̗M%lmD	TdvL뮇
ѕIs.ҷv:![`skAC"ʬ[ӁZ ϛ*Y?=ɂW (СKd5Bvt`\gn-;o	Xכדڔ
)qew4RB7~ߛvo'/#9Ezn)z?ӡ5!	aAvc޵j<H_/ Lԫ8ГC	l%<!ZurPf!o/yE9;~5 !m:kS߽(TY[Mr!X(u_!vp#_ #jW L(4
Y$O{6-ő?BuDBn;/Wb0CUǋ:u-"}aӬlW^i`@ 14.Xx}Ɲ~VΧ_Yx6|坖M71JMyA/!l)
q5Do ^fZ6H6`PA96p8z"hB博[4hmlNXVK8;!9U	4`b  3n%gDv$ ,E$7x\: 	Xz`+6/:5 5BDaJ22<P.ʖ뙔Eaw/9ns.è^P'<ӗn~]WY3A]ִ*u-nUNYG6J!Wx}wj5l|3tzqC_FPW`c	ވǌ081qk)_5Wsm$^H1k/]AI΁N=
jV't>TZ`. /f"	]v	2;}xBxYQ#cu9ۡ(oĀ"ͣ(@y1<!!ܔd;k`r-BTBPAe,7})M}tmȫZtPM),۩xTl_@ =D0,Ci$n	TކʀFW(7HB9%+vj>S`Pg_Wp2GcCa )&
n^ +vJR s6(BEq] PVHB /jY$P_J@dZq'Z	.YnCt_KF4xuAe@- .i~^Ȑ"sCs${΃	L4',[Um6evz_5`\Eͻu12O+]θHܬA$u{혱 GSP [>0Hԑku`iXWF5V}:0*l<,nfH%P6]nm tHc]3Z_LN(*;;euȼIT
 u"KH[tAدq.J٤N9*SiLMK#.bM.43F M6=Y.t54iJRĒfLI mFJ!qBs&[	Y)5H(ɀa!dX\/7X(HE6ScJDM%m\jD39$t$n`G?@}K޼]CEɺH<[!8X pX[`'q;:x{yhmϖWrEsX{?O2@.S|GM%!׺ô1$?;Ь2捻(I$_{ '֜+7mBO-$~O)@j.q(k*$O_kLIZHa.`bǧhƕ9ϥZ<|wÏ{m^:`mFBq=J!`+st|^%x_R,S_<>j޿nPk,#;A I :? {D>ZtR猀r"ڰӴd+_ćhkLhӺ&d~i4
(Ӈ	BP VD-`^YDΤy$V9Åtd22R&/۳C%J az+뻽#ؓn4s48+(.smѹA眴?DCa]H7R&NmuRrV wO &|qf 1֊>ǿb:PkbhlkoQ_mC{4S?5Iˤe뾄ϟfxD]lr{me#;3Xg;Y JQPx c+PlpK%/gqb,+[T]{틌clݹp5:@߆b ^*4X%~hf,"!{O;C9F/8[9QsfqV9ߡӼuY:\ΗbǓIW<Z&n&U?̹.Pd^Y&KYv.	̍1Jn6>B:Lhce }FH[1;C67w]#09)0(e}U	4#AӐ+p<"E|u.Jv2 2Թ˓1<8`3r@$l!T(euP⭅] fbػlF5b5EA.*AQSEJ*U{oHZ}T/hץ"1ALuVt]KfhX|Owή}3n29PX%Dmx-$=oYή|qޛUmHk"-j.\\VZS_ߋbj ۛꥉr=q3z-Ny(Fo[Q"`"0F18F>Jή>ϳ>&KL+>IGGc훇ۏP{
 Aly]{n&OgX}LKk/3W2X<(ݹ=ʉ
#kgJ:`Bթ
Z!xW%OTL*OhOenMO- :W>${-ynhX3y6?Bt~V_&cpOӠ(mOCq_ani=i+J r2D-1[o%Nn>2.ѥ2&~y`VbIffc+\spsќ=V&*ժZtrp<09#8%ӐJri,Êa^=CuPMZRA-*6ֻMW[e'R^)"
ΡtŐJzɀ~{?-o0:{˽ih؆h龅Ӛ=A:$v(E(,ҁGbi@S?~itGF(wH' @[N3q9魅A&X7$ReOaIQ4" 3{PCYZ[kc6m|òwٹib66c{uQ2:#<b|!yNl3efZdu+×2Elmdtt.R$@U@T^Q.+26a\݂t=RjQ̲FjŖ{|gdՂuiZ3%n[Oj͓2߿~b|O;f=/ml >b_%4i5ZvWxYs	)2	3B u:%t@]5Ĵ)J1#_F;&o9̬\&mk~MtpTnjr3I>+3Nr\g)t]79/&[7
гt[
ۡsY߈(PA)֧([V	:0cJ٣l'77ŏe#_}nnLB}Zp137=zhÂ7W.;*7(Pn<ݤouů@	:ϱv- 
@)~X<D	͂`^AE)	=# A"sebESu-ɶktpظakI4o<M*Tt%uLp,Faeޱ"Ls-j:)c |OOcnqoM0[$;5ЋCQک͕Kd	ZsPp+Np-[Qp0/0BчMd#$^-6іfAZ$r܉o>qTzu+/g;|Y|<f_űsvO;	R848<z/3EHNXm\gXeM	1Dk%REhp'_<hlS?6kQ"\oe6~9W٘  6Q$8 և~?3jtʨU .ɝESl+\$	m~LWFB>`2	l8O6tʚe- Znc"C{I-%UfC|حy%vK]2`Xa|.A#MP=T! O1?uy_b6wY=kXiV6;K($~lE׸ucewV\t1jk׽`vl>5^^pJ@iOlP^r4 <{h7\VlfCNѮh; EU/dL}qˍbF'5nAnR8x7\ǔ+.9>c]"w8=e)yl0 OOw\ۻ|.*_aSKJ>oiݲ4QAvOM̊ԚY4Je
>1 Ib9ru%H LV6srGڢ#a,k$#ڙ=uUЭ[8JtCYzبZ?O[[^PJUU>~$$I"-ea I2ԩrm3uֹs[1ү,S}X(%ɠUWBd$nI$HTzsNfXhRd#r.Ce2Kf'mX%p(\G	$H6<mmnD^&(c#I/X[A$JJA(@dw};Yw$D	l	$muU.ŋSP.O=޳9CJ@-`=}vp#kD@; cvKbD)@y)@"0";|:'u"T[L[S*L{絉$UUUUTUEUUU$ 
߀J(%ImFcI$I$H`~NsM*V2}cBkRVGB -aJq:,<Zs4̌xZ[ZҭRUVk%2+]h9e֡Q2NX{j:ϲGFEsEHDUBqng2D H&	$&	I.B8$nW7v HUHGRUXgu{ݑI$M(EuC!@ .!@$ؖԺWLRI$$I4`sm9nAR	&ZIm"I$@dC<"_(#ivl-N"H%L&#tA⣦%$N,kYij	5נ¼FLSd;04D8"8Ia,ɬ	UeI2/ QX*ŮDXUk:cw(놐=^42-$ʙSzuJ7QvDODCTOhȎ瓓I$I*=ŉS|-",X.JEE6)HWA06ĉ&Ra($g^`r3aq3ɧ|hUUUUqk^0D:LՆ k,Ay@C qDUvKuɈ2"-IG~\{N<3<nDI&mmo>^`9[;_EEwǜ`Za$C>࢞c`=P1PLNc )a>`e9vg|Gmv B=)8\moC6q)\mu1;߷FoVɈudve5;vڡro3]-*RV[g-WuPrPS;VU>S5BG΋]Nւ	(-;.uJPKA.>(iނgh~Xr-}})K֦4ރYx(f7=eG.v8p)7ŝ1IP|bxu{!
ZD'NT..7oԯh e,:@F?I:YMgAJD9&i8xhAcx qDo@``00g1?Ky<#TyMOfuoP,):?{#/ofRWG,ش	Eq} C~x/Gq-Iaqx	Ní h(p'H<P~\	f6+=&s2]v xaVzqrgxhDD@]۟۹pt$3v##$W5ӥXd-u0 x*+Ʀ|gKs~4Fjzstڒ߉3ccEѳUһfc:=녾Bm k{׏7E9S٩ъ,.>4G*B|bʐ8
Kt(ZY(Hwtrb O9XiЖs;qRɡ<*gmڎU2+d.~8^j椫/c+czﬄ5"%%aqe1:
G&X`$a4Lr'fӄq",'hGNsD{w-m;dWDfWnվoTV npw2Pmo)(L[.uطnss\U9ۣ23 0pkef_8
D1bھ\[[<x[&f{-nowyVI7DF>sC}RDXȊck-0.7_81bȇ/c.c9P#oن'UhAJ?.EH.IKU@,WJ,i5ڽoI@!Z P4@8= j	`7_I@t ˆ(򑦀0oN?&;3G]/íCYm/wq-~Yqe+_VC' 	Ga$P `mZP[Ӝd+;gWǶe9<|1jM_VJM+EdAz6C/mg(LY?_ˋ/S=k?mvuC]2ܖ"dݑbc"	U]en.5B3n.$FȰ3
35 iux7;0Y&"Ԫ,-jHrl(rv<7.s_w}K?5-x[uCw7WnoeS~N;m
V.f$D9&PSF\߆gb7{^F:dU_8|z~[?"IA:*)JdZ%"<SQAloz'@Ǖn.V;
"y]HuBr$U"%HX|ŵWҩȰY*nubP:^FY
D׈G3Fh["j${#&Hڱ]faPJ6=}nfWް0f*Jq5Cu|,iq:ݾKHoNL"*!Ș-;~1>9Q*{e/bil	?phc4F3Jo2ﵦG QTq?f:p"g+.ՇP'ǎ{iW"" өos\oˤgᓌfQ89LG39M-SR{nJƴj2hoѻylef=1ѝ&E@Az,ѤS*HÎ{>?3 Ꮛ}<kp
x	1N}(qݿ\NqG oE@'ШAlnbg	rHR`OKGStcl&'<2Qvcm/<u1lw=,vm;{3N.5;3DYJW;;#~؂ʟK&dv[n=N9'=fgi,>MYV$=.E:Xf}yrn}~	p
\8N0[_[4R9u{ifunYaCPX677"W//ލIz-C#<QMQ]N@b1Q"IltdE0~KP1Z$X1" 6Lj`@fj1Z0VX5DD* hHR^X ,EUhTB1dEbAB+"" TAAa(d*1E#z:
e#G%C̴-dFURDcMOI4ȎkLU@R rT3/P{ͻ_u}oh(x*-FֳU*0V$b#V2g1$,QHBBT"Iy t~$-$	!) @	!HT$%I!M@@,Iq;-xii	3A?vH/IQcf7-Ƭ,vr܁U=*X^oZVq׎_~ /YxEDiUUQB"M*TPF-ymۨ":TƇ^kf~X_s/ ZpsM4QHg8uцD>_fkLҵQC%b
6?TW#fYUYzO͵sMi$4j)UV:-;2<<ζ<ic1\M0`i^D-4ҵ2ҙUI44M4M.ZSL6ziA<7Ƃ1-koO44nAe.۹P?! ($$+I-g;_0˕MgIkܔ}¦؎R^ƥH=;v/q{g/*ք=/"= us~BKdR<éj\dL	S$H)cb}.)D9bQM}s{M	A~]nnMfud{s uE
$I$ŭ,\H C	 N︻$&9UDUMXԒ^P/;**Qq@N/3<A$!yz~w$6 pMysXiw: eLe>hVy޾m(ؔdɟvڥ<b{HNT|TqD2ǫ8u%`˓UGj^11/w,Oק0g5r[K$+"7:2h{Ѓ6e$JGPjz-OI>@3FM&,#*nunwB7CYG sbfeh8=3(F!fQODRs1rNV܏!CILh&51XV3eK> K:굋M@X
%fLe2r\A0&#$IT4 2RGBڑ/b] [D.}#09wGhQ{.YT7j<ոYC wBN˽xN3뻜0*, YIC<BP@.ܮ		4cz&ki	iwso+UrLx; +ɢt08GcC5nV]VVуRwR}R]BYs-b/|i~;Uԓfn0ts;O3dh,iB՝mٲ5"IeD8Q`_#/OG9GȪ,f_:. /)x/סnjn{:Nҋ" XZ.sSI@Tre&Fu8|x\0nބ!n6Mgv^><=louIܓ\T	C ]bERwkƔϰeԏT.{nIB2 TxX_bt#	Qtnw?fk
&`=&R3/Yek0iznǍ(~~H5N  pJT`UP`8}>+|4OY%pKjam*pGIBM4	E,^MT$p<μ-'e LjoThwؼ|?B,VY[' D#v=ARݘxޙ1~IEYmw5w%ҕ9O./to^suߒgqEF"<xP;3;%_NQMUV[2~Zx;VI|yKG(6[).+nÙ{p2nqdZ8͠a{˛3<o}цp-q,_b
D	57.=[4>s@M 0XՄ Bq	!@"qЧ9"B& 
J'u%GfP<l\jc`y l̕\aq@3-Fϗ*7B,ҮuM'	h//lBm$s]zH5QQ3F)>F!i	@\MntcבEϐjD`Y:bFKFź3rr6MDYV.e7I54^jڧO׆ph_<tNK8++X.zZSi@Nm R]vNTGң-#~zi|هabkj w[Oڗsյ`?%!/1(RY\Ǥe-:xVrb۔s$7c<01fA"&ͼV&*~J؟@׳?8-	(H  sˇl2v6گP^߾-&la-um@{ϊ9+1v	hYĜq
T{e>k8O;uq((UTRϱh9j\geɽp/!8_:0pB:Q>KQ&cQn87ԉoL0tQo[|"laa8 w8"͜h1$=pܛ9~2J#QszJ"n(CZ1dXNFcjE
ҟ!~F6YG:,؎V?jh#\:sRX>[yJs͹_2>?tv@1eYRH(RҤРHASz~v}\4ㅙ˼~:;)I]7r~x]69K JS_-@h 54z&Z0p;W}S^޿#ƹQDse}Z`@}Yղeg}9-m iy_WYr"}9c+_d|}
BAkQw('Z,gs/c51&)XuL'nm
 0  w{[z~s<RltηhtY^<^IYkzEia| i$WW
^afu(@Xp-rj+4*8!"&sۘjh&	5=ϙ^O7	/*l5?,aߛJ)r7.
+JY|KoS<{qfhx>[OMm~35Ęa?n>}WM?'aI}I!֐alzϘBzo\{Rr>ZLw@ 04 !rZTXY.Z ^ꎘہ"O+;*E)p:FkYE,>2C̖]J~=??;<ᮀ_`Ɉ Nf)~L\EU׷?C?esM8d泘n?+-C%_>I^$<⾟ڛ?dz?9	&/T@.tcQ LBY c؀֐*8	rz1Nz>zp-ڵ zR^D
 żCݕi^'	>B~}SfV_^=^{$7~iװVlAt<!di;yyY
J'ޞ_<	s	-܏S:hm,E"=9# ~|~+ikcSWf;7{Wo_}/5aAd8EY(!
@	n1$%,	 b@$.a	,@L"'7hV{O6}/y;|甅<9 E2{ʧ V @ mSނo?azefF lT;U@!/BiBM=FU%a}dJIS)8dg蘄(DSFgp4ss	Dp/^{ 6"/d%zٽ͢<8ٷp,, k|xtBj@J	ڰќ{Gy@yQ{[0'	4*m 	sfsQZFmPf-îq!j΃6))fJe0m//|R=H a h]XDh)%aQQǔC=E54ȿ<(4R!mw]^]Zu
Qvb,PiYAޞ=Hdÿ~wyH7e[:Ē xVUX}C>R/~V#jg+%U-]f#ߐWZvH$o5yuy,jMxKQjm$l<ƱaūgɫOwzŽ{\̓&pP@ ød;
W˦avffzooDi1ۈLۧu{<	ſBn
esoXyȳ}dK6>n|7R=VT?f[S	} VP˦"	
ZoɧB?kҜ2*OcmD	8M^;GhU'cK*ڧ^f_gK(A%Ilq~@dUGء~-|f20<ݾ>Wl!ϑ2Xz7<(u8^>]F")f7hCzAe LU+B} /d3 C|.JD}2HCtVYL HVO3
㾧dvdh곭>Άlv	. ".tm ?Ugv@)
Mt~H-<
F3~BmY36QPc' x>	ۅmb1V2[%_V kHCs1  
 Ƕ)܆9e<ȹRY,GYi*uqjF̘fi- )7=jA ӡjHii?ق])8K/`%7:RߧYS>wql"sZ4Cx3FM<Akb?DO؃FQ]Jvbj%nXg&a \dkԽ6opB> [iRl7mh_Z@h3%.Ԋ56DOPCVg)FݭkZJ4ԥ-k*ҵfKX֕k5kZt,,; Ζ2!%QsWJW%;"q-F`CYI)"WUbs@sut9.3ez	: kO'HVc{.(f\^i9,4jAgيW&mF\=XRjt?u_F
(BJMdVn
8-3Ww񧔣(6.
p-e01Vϭ)H՛jlq+{idRwǇ'̈́ч@<Na7㻲&^Y=L{O>Inn@<@wXMq3<+CC:;]!d"Euy\6oUoJ̐ >tm9֎s=/|Wrt7)k_v~_zkuݯAu^BIա,p!3n-4j;Rt(a6ɽ붚\o'rfczgiwͯM'D'$t		Zq&0N>8sL*ӹ{]\|vK'h΂93&,xCTh5հ뷰4s_s$$&;]7Z5~a)J" @  n |usR4L&lQ<@(i:+>N)u-4n]7؄Piecj*љ.tF'7qDKhd٦\DfhQ	T_3v)-[z9$B	RgǣȬ@tFc8H^hgԴBL6BfҰOGo d+qU	Py߱E;Q&Cƍh{rO}Of{6h5?^.9`6-+ǙHN]הkrЕGNDxh[opgvY)?k';CwJva|c:py-B$К 'prV
laL
ij;#$}fV)Aiޝy~*"=Z	wFjEWj6䅨iГBBYPH0|ɜYY3XG]Ut~N
"}NLy|_1P" cBU q`,>TS^V/b-K)Q\O;%H̟V]nwGBek@sW7m VSVSؼ_L>5ُٸޘfke;(u]H	޴qjfθ4( q^y  ]6ؗ"?q߽;LQ؉=A_Vnދi~G釲&ٚnǬkEGdvIN/ţ$=VO5v \J z_C]K $v{oW9^+͚6]w.o#U\g˘Uʫ?*FPq96!w)c4.0+sQkI3dS,IZ5IOq<\0?H ϋ@@Ա{%W~:W8@ggD&K`Y-2z6$U $(o[7:-C	)N^̛}-~B CA5vpɗװ@+-hbLS _?=̿.l3I1= Ww=ۂ0aP%y
@$2d:1sɧ0f
G >2ǲєp@ihD*f8#Ht9,jrtǋ9¿4<t:)Lc	l6mDm^GGnϿG>_Nt׼־9L% P|N,UecUX7+3Ig(seA.FCz"?|PX0qA"LXgV{^~y UGQ>p lSRc)cDB:-e0Om~ӛyS2թvnґ~Tw̗`bt3x 	;2&\+"8Zktոrl9Cy/\@ؘd1SsHafzr|}	\7?E\#M;rb*?3n]nHev,G6c@TT:[ݼZqXn{1Vo/	9Ț]]BN*tmQzܗX208V_o4qdrq+AE85NO!+6I%y4HK(=F|ysMcEb\tYU{UݏŇU]Fy"GϠt+diOq6ӈ7y*~B?C	aBr9x"59/ǖbS#99OB?3DSgOg'|OඹbqDPʭiTY	B E&w`8/gDjNyInh@F-B:Z# a!ύ1޹QHӐC
_@ )uί(=:X
$SJNjgi{>/Our7/[u)Srȏ k(b Hstl[F::-+ޜ%>7I`NGXk3Mfjw)ٙSXYbfҲ#8:z>:OBX A(!E}94fOiH<BѯQhrW?>2@b60ZǬlU`T#!]$!	F5k@zN Hi0FR
X2A`j"2F	!,,YU'f=EiǳׁY٦itɟeXO-}'XƲ/zxT^H#FekS~eʕQn>FB!HzXDQ$%|}Cz\
:I%CVO{GE4.u/Gr9v7ϯ;ןw \˅p5˼#°TYdrHrΏ@}0h'\RҁGͽK+):\ z6H(-@'5-ۙ\ɲE0LPRhx-'ؑb@ifDߪc`Uz._}sw !;>%M;y*&GoXFlz?RIdRQ YF 	m8K6tAy4@g	a<f]Yb|rKrx\1ق{2+3ozSgTc9w⏍E\}iW)9֪εZֱ Z*YZֵ֋JTZֵ֫ZׅнȲ* cUnA= r=Wq9fsw,t/4}gxfc' sR|B.Z~_lD-7@mtA6@]Uil@K0 <#]9.`&jz.%qy俨iuYZ_4vxm:VGϱ !hjTTP/~zP 8H [u:OxUWuHR64^OrPu/D#3UEEotti䄀\V$o. 1RblA|DDDLR	Sw[]NޱLRxmHEz0{wNn+͟^P 7'<Y	X۠:QL*
IvSc<>  Ly\"i[>hIUW'I7V5XŒyV=y6_3R٫1ts-+C2yc).Fd4]77SRqqҲjהTѸ99}Gw9ldzzHvC
z%s-}>ohmCr?RsifϥC+hMVh+ڙq
&HTs9邔8{x#!;Dh}	WF޵SHcZeެgW6*RJlR=qSnH">Y	ጓ(NO8{h@4+ne^wl Ԇ,diΙǸ|'kFΈ/LdJ!DRzN=sk=@zwҞ\[3l恦:p=+<A,E]Ki4ն`mMWx!rf:MYs[bd7op*2 х'qvIjfpgz4r1	<x/1h"%1iiGĝzFf4E/C vF9PQ Nk+sm#CdZ/etʍd"eQB]YCuaPc	QU>gM}DޙFk")1R#r	m%M~k+H&H3]!p`e/pܥ%0xm2JNP0KKy|]'!zW-2yodz|Q-;,u+gt,Йl>d`	 )*4,`+Kxnh$cL߳|hM
%@d{ԽGޭlBRQX om"Abr^`'T!!QEBYP)R@AHRz^cx_#A<gإq6=`آ9S!6HjꨗdA9/Y.r9>9<@7e4Kt8|Z l	>hxFZ
0T	Nß]WmhM2-UQUR _{8$&-}Il)<Ci"c%];/2}v.2*+-Y*RCf+	/pGl	W4=-9ϢWxTC4Cj >?m*I s"gs>K&>YgW-3;M$D&x8!@!"!</sz?k{޷;j*bZ-0ևYCsHUlgxҩ-jg:kcUkd]IteR63GIuDrH0eQf&)=Z4W*ws?N?[(vXWQPǲ1]0FJV7X=	++ٜuvmrP	 :ZN@N討My旑˵(m3;3%/I8:fe9Mr(fEEU6|Jn>t}E~B	\u#i\Gp"""*f+޹ ţM gKe#x-2|惴6-P >b f3mP)=kus)d9J1~/nN:Tsr¦y=o(Q$՜qTgETf/\?{r'?
*ǻ_ң`Un~,xžn1ޖ+!gu?@Yhu?J#tf&cAݬxD*['8H9'c)_<waQ^J
Z;dUA\GyVcXϬI:
6I;a FV2x*;SY؅/6l*}>,w[?p?\{-raLYk$
Of-"T-qKsPܶ^٬"7ؒVnq8yhYt;{ x sYǲS@A:SVirغ2izCux[N+4\Pl۳ܲuԳ&u>L:n߽ڄB#MIM<Ke;u?_il:@&	M=N D+@ m$h;kVzu:ߗZ|L9+z];:>eoLs6>r|	I۰; w M$$: x/-ǀyea%*Os׍?:Y @DUc##6j L9RaI@ y9b.m+_8C"~4~o^IJv{rvlؓ<SnSOM1L!Ŵ|Z#,2ΔԮ_j/G/MvV͸C񕶘w6\3s[vy]q6RI
34VZIUeYJBJjY֡k:Xcv%;t7;pP;T- _!X\YZa+< qf|D397迕;G]Z~E؟m\Ĳq?OCcrsv8sƪ"*ɫBs|3s3}
G<eBH#O6XֲqCZCA<3rzr@CF ;;uZ+*<{ˤ]aV'.Ѿ5Y'i6{nm ==ZLiVD?gB]cW(Fp[6tmza-9xݡn1_}7}a|a' (

8 ]nn9%ܒto/&OdhXȈ8G"Y*s9wӅHڧ~P,GH餑=QPYFBp[hI;muCkUI&rSُ62
Q3ub_a6n3滃JkcN\	<!t,n3
RcTALɂ{kʿ`ˬ
hɫN@oeq^'1?[UZvSn"|YttdwnmEC=HW_tնȲ$$XEvW*BLKgIuJ!`2'o?]44X> g*l~| Q2ERriPr\5|R%r7qfSA/X_#QlXMpbpv@=&o`gn J+V/D77κ!1@	<1s;d4c:s/+xwMakn%*Chj.i)'H2@ +5<LD Vn: k&ROZPDuD˼Te[#5e&r8\E|(/7AӶwset}c|H4 J@Tbs!|*>-Q굀VּЃμJA[2~sk8?gƆѱr	d{8'
bNӾɰP#_!OfapcC*?wi4R)JRe/7m·[JoٝX9\Oӳt?g K8af&8)Kл+oz1Cj/#B/&~Jyh?mQi\	/aK'S>FAx/݊*'浝In6C?鸟^N	1u]'ں'}+/<}d]k'{/]#xq8H W͔ɠ'<MJ'}OB3I!E0]TO	qǛ\SږՌgJXw9;L5kv5Fr;Jke|6|BĂuEjlG2D"oqFozA6?4ܽ;^.Xħs{"f0hY.[pe}//|l~*\5
XV2!,R؃ʾxYCF|0m̈́54ߚssth0$<T~* 9p)GeHy&/whY⣍r&;Ʌ.މ7"#na1 I(EJ(a;n*Mcӫg)mrR4]q`Kvro*.ִ܌$wtjssBlauz8v;"KYLR0ť.:U/q-/N02:Pڔ;,jxO|je{f̙Kڻ^tAe=驔j*OxL,[%ŏTNqT9K`_H]NWݗ^_bw{9o ިy8`tITUHQr*K.:Њ,m,HhR,SrBRC {
K	)	 ,$ѵ/Uⴖ$lRfgK[ȧ{lmuAp% Ï5=^^˱-ϼAҟri e(j(ŀyGjwynj[c4,2NB@Bv;niT̈hK8Hq7Q!&yO"+= ,0l+Fbraʱ3߃R tj\-V3F[g~o{p
s,Xpm~.sVu>g''{FQZ]_>=?ww$%)JBO)#0HH  R%),)HKzQsvy'e~HTgv
/`G jyЋ
ӬKECH	
2x().ո|j~ـE]ĸj?{@T2  Qt.b<1#B1钏hR4:HnjC/J]J@xї !4R0㟅i̹v8ɲdKe綗~~}ѵ13h JSP 2=	h =jnI [KZ"I2yiEwN*)woT7j+Qf 1k!rZܓH@ҩE}M{Q#wۘ:ZjiV-Er&E{J%wMXe|{_=Khh7 2|yK6nI0L]xgHțK.tٜ}GO:!p%kfեZ#-jzeTXv)`恢6W=N-9QG"sF=QRd/5JE&X4\[r/McTj|4d,`d,|#N3GLql[y(s(ӷdivxV=&K#/p|Vuk^(Y2PF7aJ6{XAjqæMw(YKz܀ !/M xG$sUl"NtZ7tUCuҰİ_Hm,0u:C7r=Dڋ}gdkn*LD$VǘZ*	Ʌ3ΪyA#WtS6Wh)xE?1+KKo_0*S#.`NiɮlKh
9iResF:UIDsHc4 ey#M%v@Kl2K\ii_kr(zcֺhF?Lp	>$J+?Py:BSF(QcZ+:	*X:ĕ,GSc C6$->7}UF3%G:7sJK!J	}EݭHp ,qW-%r`C{CZ{ɀ4O1Ps쇆6_krǕd}ێ1bM0lYG)UȖ2(4	@xLD&m`[GT8^c|bw<&8MC@>t.IҡdI=]WhXwI&p`ȈiI H(	poE4 _Ḉb}?a^Vq鲻fM:G
ׁaѐ2 
hcT.iDϫbr
0u/!ڦ嶷"E-Ŵ`>Hz ,G{87s?c^4fSŦB5Z>U
Kr{[ʆy\rT:3]&Vfs6h-
&l#jô$]hM{H \&̪:op[:tJGވIBv!Nɇ]$|$e(-wHxN%O1ArU⁵\`éFö}NVv-Coa]Oa.֚l=?`;d%NqLBez]6iZBe^J*ȏ)NLV"OOZ6|oS)!>ʩըbJ{\7-Zs0 '=Qkdp\OqͥC[U:0I)]WD GɮT.jdu 8ERDI$)K9ZLZֳP"+ZIbr:	MVGZֵk:*ֵkZεBΟ}FEPH)ŋ!
HBEFE"bńEPERH!PQUAb,U
EXAE B 

,HER*"E 
Abbȱ@A`Y(PUEX*AH,EAbU (,H((*"    	˹V7E#KBB}
ۧꟌGvm50' mAw
¿<PjЯ	P-_*IS62]2S,:NNb5)X^8wu h@m^D?&n~w^-V-Cl3uO__>9*vR~=;b40vu[I0lƥwBFæluĐ V^%A߶q	RwyMq!ygݖhX-5(UvÄF`&r~P55.ßBlzI^f:UHL^v=V*s_y5PUŴokr)\+7e[F]߶h=nŭ˥},+QTY)h#M,9Hr' nt)56#ZyLCb<@(DD4?{sIx:S)Pl@JJb6)]>kQb˨u"M'Zxè:|43;O]G31}x~..s_>tA?]76Gc~c7!Gcza%+5\,+C[U,_	lp[qﲺ)`QZ9g3-CRR_ƜM{E3?N=^A[u~>:6|hece+g$s;h<e|آ:4∹Kо4dc@s"pңߦz~=:ʹ6`5w0ZgT$Z QZIHaU*2RK]~',|ɍ&3$'O%s=7N.!7jCMSPU	z,]Xǐ,aȩIŚāM*|2.zug6*̊s\Tyt. |rفDB˺y{\:m~13l8`	f80h#ILuK OrjMgS)wg5Żt罥"A/X'Bh]bj~ =tUdu<))	+
m
%Uq1VN@}fWSVHvv+r1q:f(Rxyzgep;,-2N<W0;	qS1C0LłϫD\O!uz8}%W XW)m¸zX`| ;<A
	R܅9e;T1Uiq->VQI}uZG燭BJ6{afJ۴A_rGAnwmsZ(UVuHp[Cg+g@sɏo2>G`E'b7dPC%inmLAQve#`C=`ڛEаQ~-< ^.KA*'6o)~B>Fm{)	,g#~s1	NT[+gt(BS/(ȇ(s(qG2@M@Sa;6 QB&Q_5p0^ޤ,l|>JD.'rW 
LD޸`EwV^(<_(gYdeD2Z x!P)礜IÎ3Q".0՝:fMH(cVMd 't~!TFId!!=(0B1JH!?Bb]}!6~3|酭˕=Y]>F!_}`r"UR/Cl?A*+QIsJ ֲԵ*I*W_So?[*v /?j&Eq ֜Y2`༶?0
Nپlڍ6;y`_#yξ |2cbfesxBhȑw}ώP'GΌ^bo@fq188ybَwFi_Ҭl`Lb@f*wY,"[|~j]&V%PRJ:JR(RasT%!~B'KD@)eYm_ȈFô
LǢ~LnQQ7M[kd 0T@Ġ|-x=]㹽ΜsH3h]Q3c[Zrk9L>L:{8톞UUmI:'e>#	~w<-_ak
T望ٱGf`gzIz=ssq
	h_jaUUVۂN_zd2zCn;r^4[!h9{=[m8k|ЩMx8:YT𵲑ӅC4ujiKr6	bŹ*K͚[9g^6&Ƙr.6ϣn?2w#rG7=>L:@([/+}gc⛔">{4DEv>w%lls+#4JQ.3(U:FӨBPUen/ݬ28'L.K&H 6zDPb[$H%͚lV`Ͽvλh$##Mє,0"I;-Ou{	=OxAVY\Tfޥ>:"6
?	\.qܢ-aO}FTtr=l[D/ǶSR<:QXLTEh.tCЎz3 EZ-Z- L$_#C1
.t`ryB)6pQK	uC(_)!-R+9DoY ZU?egɻBXGVޗY2nvt]l;%{DlRQ^oRc=b"#\Y:Imimk"{rPrV|;ρͪmDTYD&hTsDZ1m@ThB_O|FkKE2ޏCġ9dܳ(Kr:\_lTlWyxRs;xT`CB	")%Dwe >\7PHT=?P@$j+dhb/`xӞ(EIۣlV7#:v	l$kAIfd}˂aQ!.9eTDi1)NaD'f# r%	S4 y3RJ3kDS=[QzX#^/%qI#dKd2gŢpf KI(Q郖V@!ѵ7fc-vɪAl&_z\nf7w{ })bY>d$P`	EJ2	2NO]1$/.RaE2F@ U 	DK) E B  )$F @A@`x/?>#N4>'5\Zֻܭe 4xx6o=]􎁼,W7N@+sTF>b4~.^>!7^~gv2~miy}!s
awg?%UM:_rֺlzpRl3:Z4i@ xꄁieRhɓsCPƟ$w^yW+qe`zHOeM+ɢQ|;PО&ze0x^D$>UpMغsrm)K}.nEvE-_P?D4G"Xֳ&Ei4*dV62iYI'9N,*J#]5a_]uբu#]5ac]uժhX   ><+4JLZ2_Tߵ)Ʋ.kcr%5k.F?޵֔)
27Ph˳b{ЄA;:%$:^`qg<Q
/`Tc(|\xy n#"EiL٠n+vG4`Bĸ{:(4Y/,ti{f#Na;y'F0]JUUYHkY R
&j)$I$ 2E$2".a%#"$
"B"vD*FA#N!b0#	ݧ-j}]	ɚ9//*B筘 *cJ0uY  2fI	N)>s* 8bX_&]  O<^oF_C;a[Ma2ꛗJ˳ξ{^S͑+qu{%'_I;$ރ3fw#60>0ZY$i#Qx2Q<ս41/cݚiTjW o"  6'K#7;ۯxT<.*Ow<mWs:	gyW?hcĿR(caں5Ǧc_ <z|)9qW>$dhE_%\D7S3^ Ag?h$@TP<&5cV&!8;`-$-S_f>23 ,笑L_c@^Mt:+%g.:m8T.ZpTV)*Rd"0CuE9ƷdYZ'ܘ\BGv`	͏)tU=65#fJSPl`I.hpzeɂI5Z*4͏B\hЅ ^>3ʚfV[*nլ-Xlmʨz+o*(qKc,jl{djU*  ٘|ptDht6cؖyz A3Th> @(#Zђ* 1D-^:)*-/Q8.ɸbsƂ-	FiH6 ElbLd F	Dh$tTx(>:[7L}zD,f=HTwt\7&/[z[=95pֿdÀjI}Hxs}'+q$sI$:A$A   ^ұ1uY3;/Su$qgOVk"o7GK4Nr_wZfɸٲ3//|%4:
sf=xK=pM梻?Uئ
=a|K~;S?>lFIq	NEqiûoZH#ɴ1юii򴕙YV,KFq띮Jr)bY3:kv֭ey\,Nlc\p w͗<}ʃ)|X]OZxGv-KW_^7+7Ix#,[TB}^:u>:V`NӃxΌ+!D-~q!DV ̭d[@Z6gץ5l	mcGz6uhoPomw(}kg<<W:sjʆmuSfU]I92dmZUv > S.e
<)ZBFjibf@;z%OhldAN6S/rHِ7RAٮL_gr#˱oDx((v쭸E[vBPqY^q1Ne#'~sLitT8.#utDv
"+Ch4<2<n`ui{3v-&=v:\Uu'whWAd(NYpʫ9n3~s#y{*Vԋoрpr47x)^<-r&9,ώ(+|6pcEb!wG7k ;M?(1\i>hft)I@zC1;5vʒ9ߨQ.aq.*Z(DiM9mo?sO:[жGYRѱwr"x a84Y-m-4UC,Jhݬ+)|dTHNG<9CQ3yִ Hbɺh`mt/PhGS
NCt7wYPt><}! ?"?ed:7:ƬJu@LeQ8iLi]$(ԇXEp٢2B ETmT@ g'Hfwawum-n'̸^~XTY:ڏ}fP!З3ݢA=gXe,rd5?](Z%S"ys6@1F?x6JySr%ǡϹ-pq#mo?wKSm5.W
  CqȓSHžl"rF#x֌og㝫d6Tijq2dN<s|v}MZn;qQA|7kz,=}{4dv3>O$g}Cհާ|}blTz}UfǢzu!}nk0ϻӣE Z#;zg$bxgEha٬ApYGpwg4_CWͩVo1F⡻zn6r[AynKa[6yTyMWqȼaL􉞙AuhGWC<]V49, ܲeXeNdI6)ɼozvSЬl>ۻ]}Śfk)LtxHhf1 NLpEL%MJ%(R.|oSЕe/CrՈKD.?+Em[ܰ(7ߥ>y_ctelw%Oo`ǅrNJ_Wz@/־hpYUeX>Qyd#<NBy"5TW->R?~ki:Wsz5껬xkΉCL0{/_Kaw̳f>^\
L̷k*eQt<'}=~]s&}*a./wǛ[4E3I"ذ#^>+J
#ku /N5,QaNl~Y\ 6śfv<ߺjHE	V&T Ġpz+\W;g'ɣDh/?oӳ nm31h0$IUM&;97b>p8
xJyݶSĪs
pcsz?Au6ܰ=Z7^$SdWc'3!ݸS6Zpk4'%F|mSe,UĬHb1<S
:n)6i$*@e0v}>"2uGZom{'cbTdȕPLp,vu]z3TT!C^R2Z~+
-Ck۶V#KH%ђL`{meVywD	@Ar֟ u0	<~y/ӕ|='$>[o1Y&{|YN~uSH-&uLE">⎡2msz
GuFq>5c+8$+Η-mq|)5IyZhnS>𮓻,DXdV>p>!q<&F&%$A!!O+ǼIXʭ4r>;6ǴUt/>04B((DyH=jǝ0ۋq)?+ut.`'{j*ow9jjWܥM	ܬ_#GSP$.RG2f1',geFK+QJ{=W\uP?[PBdL/~F<e"q#?;⪛WCӌ}O뻍yK|k<i'K(Σ9n{<4;I*0"Rh]#a$=-#ln=Wkv,{^6bhreۏeSep.Vt:u-+æ|jۤڎbN:oPΖmAލ2csɺҩ6[{ǯ?%z#"e)dLș^<#ޞjnK5YNQ<.υK%wbY~H.'I#L*yoKɓt
XQw]2o~w+b7,/E[n"4zO A}kV7aSS4ѝ\J#U\mszgb|3LG&u?N7_a][y~r^a	#s>0/s'14\ ȉBnhA'L/[/C'`C_GˡU'&>~g_\2a
 xK{$bVAH9fħeDs#iBŶI@?9IӗviP	"*CEH/ʓ0e 4*{_l$i,{/b@#r `7A
2pTp_D6v9TD-BW?>6ñw\$of(.+3 c78 ˫Fv?njVyXI@M֬ߜ>o%%>%	^fN=4ibC(s*A3dq]k++.gKKz-\5W9Y$>/]?B'$1:|^hwu[lc/a3dѴݝwV~XGaa֔B맭iŅ*x+?}]RW:<_\yoxL-uQJC/Pc|,hdNQ(Be.u

in Md1#pzEflB+$I6*ӍnǄ3k}O40guwwWߠG+Xp([amnݢ}*({%s4G}WT\sq|__]2%N}~xיca8mc L^pڡvK!F#I]<*&
LI&OI298fu?TF,.\A&9L'حH,sͬ:a)xsծGZs$«~,	7l=|^$ʂ+cdx03HIBL/O2o! @}|2σuXJ,?$`݂I5 3i`h߉/mq?oĕG"lBzs˥\NU lntNH"-s)Xk#ITx[,qGhk/;H!|wmTf7{-1>fپtJ4' ƀ)^R5{MWvqό;&m~Щ)?"w5[!.RRVbX5FPb> -
H4`,$'bQ0"d$BXH,R@EAI	$*bD
Ou]w7?| 1vVr~gG# ˬ~_Z}"l y~_z`Po6L;@Wo0qq[G`IYC>lbm5%(1}iJw
?Aj85 z\r_Ь	h$K4NV\_!#	@!Tz@;6+C'H%ݕ((s9#KTI:a@>&ZiI!*XMZ@8>7ZcTc }EuX5LbtMI"&v5&YεPVbY6
$9֑VfiY%ky}	LiӧW.DLA A%D!"`bPXI (TD(@
|vg{6յv>NwWW݂Us!` W+мEʠXŽ!b{҇ee\T}gy݃m8|XBȿ="6)	#O}0-Q0}q>KЪC[!@,NŅuZuswQU#2AaI% /R]TM/ N,fKRHM޳y&vN8_ę$$MqBhoZpY%';mH}][i&Ca61ygcKXv+a80H[TͦmWc<~w㽻VgXp<>#i-g*d`f95ݵZk)OKɀ:6[ݼJ(˱4EvsG/kX%Vqa赍vT䔋sL,pu5`H.MX\6Fgf}SN78oƫ7>/1jK3^u8q8"A%7K-\D[f'5SXgƬ'[F7g{.8O+ﱺ'!֧Zq̷GVW̙#1xAh$Yf^,RORIySt)J$,qsP1w",8?/Μ;F@x߱1^XH 75U߆\ôRGO =$~=">7\(H#{
)&B\#H[%L,1@4Y5na#FȂ X&+߉
yl=t@= ʻ>hХ@d27syI<"zdoZ^"nAV'kv^K7<QoZ65:;ǣE@u7m=m6襘0upȈNO)$E4"H[ [vĕG:;~P-!/jFoS~7+oԸd,w 1JݱruYU-PAft͙f/e,zZCRs ThP6$t㐱wqbz Ә#mEl**!y̕%97ze#\6W.d><Vi>/\gl%$ C O6 \+$H(FR$AV'ZI$	"BxtY(Kx<]	RWw^%SS;WW2yxK]A '<8p9XfXwHU`ilk#u"'-Y_||V}g 0rOFّbٔa2G0|dbq1<_~XSn8|hhkVϴ5 f@yMLP-.Sx@K<zqF;PgwiX"!,{b{JeiְkJy/q{+c(Juk̺ g-yH` c 3G)i[FdЦ )s!vjSAاUC@4;nfz|̟./=\F^*?ZF;鷺5m!Xjq%%|N:-GťkSSg*΁mR](0l1;LeZc`J(U4KTNE\KEQv	,:J sWZLR vl"8K EZE >6b0In.*Hپ9tjiu`3c`2LYDQVH3>x].Y|9yd<pT!N45.ž}KĹJ*{/:-@}EA$DcU+NW )~ȷ>]73.vJ*"05$hqI~#vV#xmy4;5p^Ѥ=z}σ8copO@}hG=b]XkUPopMrN/& &S"K8>"ƊZ>YJrE<Iv huA{N?c#$4	An8MY-Wᖚe֯m^;ut!
3	^74NUԝ$ؗ_Qb#ńzQ1&00*NDB.Eli߭"ziy5)ļռKt́%SBDQT3
&}Rmkku ݔͮ5hyCZkR`r(->NhnSnxu|VZy8'w#ʗfR4""!l0o3yqs\ Ah"{y	[lG9$ >ʮ4ZWOem ԍ
#Brۇ8tBD`=,xϾᙝۊ%t+xw xi{{d0tHZ`$bFвH(O!Ud~Y""EI(, fA1$%(IAY3+iwT8?}'wn+з˅H6}$z` ?u`骅"h{-'Ɋ"DD ࢉ-uL73ޘ@'W"v@8e5_~<_킣_#LWɡ3KT?te4ooVk^d˞Ca8 It瀽'Q7nV ]t
YcYM"1)R/2_}B)JR(RJ35"q*J&fFJR%9NIJR)*PT""""|+uh7^dBZ%VoQ$ 6  @   <GGvk"0wR'^tڰx%Vc%_85h"LP޾k.˅>c$DjuePnufu)^'QPKt㨼CD#'O\uUEXfy1n@Йfe]ec&{!5Kb
Ŏ`Y"X,RABP*Oc׆u|@f7ub&pgWYF: 
6	 [".A3XwT1pb1{lkQ̵_궙$gJGZ#E/=ƚi1Hs{eB@\t>>
wnMO\.<U<*wCRt鸓yjk[~Vt:\7א^iN&hH猜ȐI-a
}f4zfkre(_JQ<wnr
ä5}s% 6|{SVI[hJO#{rM*^=Wij-n6>]g7LC$\y
AH1XS1EYVԥBSE搔?d!Phed,odvBr1$`p-C7#RPL! 4
pf3
KH.,h<BŖO0@p[9 u"~k!Z.W;A7(=d|QVg'[Is߼?=D"(0P(0CvT1!pQ,?S?'D`>MUuĒ"IXI0$:Gaj).O{}m{ی5:ߍ&*n1AI;MĀcA{f\uq2GcqAws!uNaBZB];B-6~U<ٻ\Ou,뷭|Ph@@l(VĪ6-n0K-NcMV75CalkCH;WU (
є	B:tōƊp3Mb3-㽦0Ǚn}?/R3QB$"hfimA %PAyR6	:uK,TQHCAz]?o>SdcvTLB>j+>B=:HBZ柳V[85g5I$C
ƍ49` Jg9	o9H4Is&rֵ`NvT?"Q?l'vq9Ds	O}C*af{6fp+_xiGt'fmUˆ@aߚߨ~iD&7_ۿL3D DG<A2=SE}>'W"jMFAŴ.h	D$M=`NH~DxU)BS6VEMsC/_ˇtȊ`mNGb}=N@ 7f{ 4 Ah~^$/$X nJ3lAol) /R@d <[眔!wy" M4M5p4kVl@q:XZف :N,>O5 BM[¸Ȳ(׸4q!*>IY;[:<pž{sz=_B)4 ȶ9	.-,ēغ$ =fΆ-*fddx~4
dKj񂔼Ϯҟ d S̲h֔.jǾZ?gmxG,I*c65kTYݟt,CK$;݀/v	Dq:HXFF]l[F]!
(bCTÛK.#»j[o?GԊ=o%E%XA\JDevP)%9J3,?Ack:"* ς,zOEX:7-jj3ɁOd5(.EIh2=9 =ca4/oG&îZtH2"j<McRȰGHlP+44ՠuriX@ҦS d{)9.,y[˻tN"f؝v<o1ɰKq)Z&^U|d%	n8Bͻ A2d0XCGxQ*ǼqƐM02"sKIW#T!~\"y4[2]C)OvZɌG0tݡ'lڭ4e1tЍGU9rzAOxi|>禷,fr@|hc'EBv'\
$xq0|7"錈d߫W[4<.t7oA^8 GƑ&?2Z)sN$ɾt}+p Q/#x1b`͏x"ҷ c]Pq kËaۓ~)nR`~{$ZSzH(OR.1Ab[p'6DL/R̿̆D?P\LUq歳bqq?C_Yz?㝩
ad?{_qwΠ bd ! HB Gn;fv!EXm]C6n}g[tvfn$A" !TQDA"!UHQOP,5EP@EBzQEA]q@T8eBcQ~Xĺ4tbTp+RG%u oUgjm1lzbgNSuIR}VyN_P47WKiX&y$Jb]rm8:ߞxA	=ۘ?'s0,Qn  A ҩ%k`qQ\+Obݐh >qg<G^$Zv8Ձ8nunL(Uq=*iX B̏%U}*7[v\|ʸ]ZPuďՇ_kٙ!#twwpNn>ZrZW1jh*7Ơ+s]PyBL\֋ 2vmC}%N7ƒ;p0B~M;S@=xi<ziͣ5*MhzpzxGLXn*Gnݸzvo4sڛrݏzUؗk@2flcb_(׹)I'=f,Ku^q~q |V ܔsgғ*[Y( 1h 2Ni 3A۟?X>JCxj%S&Mt_R JZiaS5+L0¥3^@3 Vgw/qND~Yz\ޢg`V_;5hl0<3Srfv|텻i*M0!ss!+"y%#1~aTSh|~זtܭQ]hN/\ZvUnŗϔ8WoPLR|{;C:>rkd6Tc]lhJϫݒ/}DAAdoÄ%١>2S~q#<oAÏt9m]$ u7eRmNB2K,ztAά8ԮrD'"̙XQwxs-ZaĳpS5yn}9^#5<82e
~u~@p(spM~9ڈ ɴc/%kB.L37NFYt2EԺzMN~mqt< ݝӍ]<:(@aH~н
 fNqJ^7I-^a;=L^􊎸]@s%@I}{_R)?u0/fc`ix;gSܯ->8ݲg8]U(m9EӺ+(K?G'O}}^1Z*DD&9y 3)%g@>{XaBpW!r-^c~!6ǧs(tyk[3&\7O\?P8#'.=SZt(NAY1ỞCI_G7Ϡ4/d>[1z$31bHIʲ ,'~e;Mq(/}'?vL|6*1g(VԦ+$@9 L _֧7p_Dѿ=XG4/iv;-G<N<[Pr; /n,E]*I0W ;h0%{-ø@ UR3_x/o?׋G]*iAgl.~?(ua>s9=a;_ߏ?~
J2d 9 (ٍ~ߊC1!	bJ@7k/eޔC
Ԃk%g ˙*߿Sd2+<XϘ"ǳ} aE0V+t;68)	RG  X :,<֝OμiFaL_kr]ձ󘹜T퍮/Σ#
/sTQnݜCmS;XWu}v	ׇ`-]k]^(}Ϝ?u}ٗr}޳A157iqlVcdfv!5naUU5s6<I&NvܡN86AH󮷌(Y_[ƪh[أ儓!6<~.S\x1|u}Y􏨿O~~JGR	"=sۇ.[""A> ߼$1"sLN&剼Z:d;:@Sr2цqRb@҄$`OBb#䒧ʈ:oΖ<C&GFI])x"sE%0үx'˙kl3(?>)e&mgÉC56:Ar[G
 6 XrD$3q$O3W*3t:^dG_[3/|*zE +z0f<^SIN!.7#)?Uu@2)_MW@k+1KՅe<K!YgB.*bX% XJ`9U>jA^/	|SJDn5/_-$'#@dnǏCw]s~fPDT<ZJ|*Nn"Ҡ72f8+f^o<OJ(㣿ݮKk8C<|+5xVv3jѡmh*,xVvyqi4#˴ksnwEz2T\IU۴m%DZ((: uB[GMk= mb2ذ A6F;Nt-)MK)`pלCłEs'G&C5]4̿-甄%H
	 	?Ύ݃a_k4SFy6X#Y'Z5i*`(8-&	 %f.(.0`J?Ia?i<YR=ᖻ~lO4U8>K-{N?ۋXЁ2?	ة0Q)&L	"G¡fKHu3.n3-NU#u[q.|2zhŜX+b>$L\aS9$q ed]We]_""D·Tj_ >am<<ិ
MY/kZg&ib
 0Tѧ<"j|Ө
D/!Ҵ6*nGQ/o~!ڥ%ӭy]C{~ΥOT1W$׌)0^S.cГdFS-=DH]a@:̢ -5ΐ@nVP! *_npWNr8yz̿"]k倩59D!augRٷ,Ler%WX8}]=j7dk7~&uʾEY9_]eD:M#X\r^BC!_I\

ތގ:(z	)y?l.cIGD1AL!Wמ/IL"
@-)2]×e6T$YjB7PϞ}r"HU<!]F -3D
Fi $v
#AKR-L=xo?NnD.y!vsTMgSN]چVmIdFăQX,XS $/ 7Rj\l  x(i~bdS=#P吸=_EaWw6.u:Ƨ9af{+O,
!Hze>	;	Է$,;6~u		McO'<|}f_~;`+5zdB^ЏkD. хxCzq7+<7i8Ɂ#0v  JB)!$N򀹅hdtKGj~?o5_]g6	I`\6!mڧz(+oqm[ >٭MyF0]w|VQ0;$CH2at7+*IK~*| k0PVᯰO}8mlB5w8s1WGu:]|SS9vHC1GhFk;vy}W/ψy^m7W
CMn7Yei?7c|<~Je<Sjsٺܞ;t S^ 8/i>HIQ⎍O~!Ό?3~ UP2f     '.Nj_Տc)̋<'~d_'Tl3Mh$S bW3qZz>yVד`fQ݌ZѪȷ1D|_~zkA)HsS9^Wk)VbbDga}Ƥ-ERq9Q@CngE4>5"ن٫Gjo6QUf\`f3r<X~MN|F
PX	m~e^v7O@W(^ғgYA-u$GnazI	xٗmzn;UbA쫐}dAaʓxo[w;ksoVIF~c~bA^dʔ6nPQ<v+{ v"u2R63n+4
c<x%+IWӞ,/=͏']c,WNY/){o޾<Sk`I{mk\ e<RBRM`V߭ҿ_D+F:ulə"s*ll&B&ʆi5;sO<gIKU:MS
|x@`źh3+V[nV2Yؘ!Yvd@C
<93q,c|M7v]iVz&osa7$KL %\"^Y[݆B6-*D-N	zk0.B3GҶkĈr \[Sb -Qѣ]&IRXfy9$9*(7_ssLBY<PŷS\*ܺxKΕ+ui#_+mKն:VKy}y_yyu<[.QԧIU\oƦȘ*~'l.{ho͞y6pV` `4F'uk{l[b5L[P<춈/zk;Am<lvq-"%r-M
;,^o-!k/9&C$a& ""&@#_m '`\hx2]|~Fݏ8I(<ŖFx.K]W9%=(>{ \fƒ?	ϾPJ?ץFoa4C%ȯ^]O"!nޟ_r+ jIsEْ>Ej=[ /tI'n֧~Ĵfo"i~qX$oo,ph pލ!<֠;9Vr+Ba ftHʺ9cԺqs)~?anly߳p:|%lGB6i>`*hH.FtyQA_^G0j*@xwpޙWܰ[yǽ;_3<asRCg,]]j`1h0ůO 'D[|E3&PW+ffC{Oꠚh{LuBlfvs/fMk|[	0h. ݿ*@Mf(BN;in& G\߮8%.dl8<,wfyG)N<%^;y|#LIDaI]:ǖVYu4^Eʌ?yaoV(a}=so4vb~+J{7!&f
9FbW[.i$=]GA Ҕiʫ囈`k61\UW#5_R%3Tԟ5L"3jKvF!OśK/.ZpJXolFQ.b0Õ8ݒ:*6\VI/3S$g hꚗUU#5
74y2`rbgS,$]FxgJ#}<e0ٖ󙶸^fsp!+	B]WLz3V:VgYjL6Ӫf{=I"g>MhAC&P1i'ՌOUl=MrsH67p#z#a]m͆S@hЊ݊`u܏}#SGZXD5eE	#b=#UrrQY= Kɥ7]DLM12hP[[M<a\00bp|T^gs(ۼǧQvy6W9u#?6QQܯڞ1!vt~H8$ HUi4$8s[4I4i-i?q [+n3&72[ Tz׊c	l.y$h}{Weh7iK	G7Yyz 1'RXF/&S`CK(ːd8.Y,p?ŗÍպUvC0'f&klުo'4$2A@E$$ "	I'Eנ+*4|	סJ$?/HExkY#,}jKؤb%QpR x8gk!{,qzܴ.?R"@ڰ)%1bg-h/"`A ~v*SvAi:(6:m:|]@?
Ŀ
in&MLZ}K;W]|_IS9A'-!9H.Qr.\'-EL :gb$Gp6нol|:C\i dEՐkݐ5k"-F(0N6/ܑg74uyaXR+׈lubyM~7^$&~@=T0_b45qxH4jDM9 ʀŝEN=ve?]oj^ۢ\aY&h֭q=C[
7D d>OT9x;iw"5sf6?/*~/2c2y	E5i?ޣGG9ſ^=wM>)N:LnG
{SN\ũh]o(r2)rD$	h(zi,Je*B9Krr$08ܛO7$6v|1Tujq$'+'KgBgI>@RlPT	akVl>E ƇD\Ɗ%B1z(P8$A~O:#Q
6sئ[J`oIupMGP]s#'[1L"P+Y͎,UpƄ$xKz.L%4*x]<92'T4Qx[0Jʪa֔sM?WU+@?΋`whMiZ %@	DNqpd\O:P/m:bxsF8 ۴t8ռàC <YFPl	GX2e5d~,+;{g_c/N;;i;SzN紫N\ڎ'Dr_Ks|ns#^2mz4ꍵxNbDV߆ZhYي'jXyH]f!'%d4ס2~Tݫ~EfM
 =&m@>h b2F("""1C7We͆X!
b0DTFHAD#1Oda(yyix@)zbQFajhR5skhVχX)_.j:_N\]j"8k,#nWc"XkP<WvWŋ?ăjXXr9()
!j@q0[!<2ilRAuoѪ7Jehy^Gt)HO;WmrnTԒVO$>ƻG'+|m,/er9;[I&υX'hhbVSoc@G^ON-GD7gv䒒O#>O{?u:y"e$ĶCƵK6y]>K㰬lv%C&jcj~nMS5:7	5]LlNo]LrMv_}K۱itSjǁgաÆ3m>CfR(J_G\لw1D>5ĨC#Dw>ZҐF]CUCdfsUc~O>"ħIT7ǤsɛL1MU+i;(S-j`Ү8ث=3:߲ҍذ];d,3 Z'mþej1YFfL E
kŁJ7?%
$#-RVؓadޔ%Ӳ0[fa.,QН3;*E<Q/AG%iC%e2@[Vko&ЀI \ Z\{1YaWh8+7V+(L6V1:qDhhХ6"=Kj9Ay/d<gn,S:	ĬTʒVlVGZKO@}*$y*S6es
,1:4ϭlGE5g}bT#!W^I_C~hP\9!{"D{(Q=D=t[)K/wNt~øEu8?&!x3&0Y;ĄBI"Ae2W R-kB@$-MUP,ETPHY
R
K1AnKBj6}bSATXS!%S[~K\2S	Rq齆=T+œ3ѾW&/}[6R}JLi<
y'}a\BUOҲ]! %J=׿W'GIJKÎ {#?CkR*&5}[ X%__Ϛ=ao1,;9.#.=	 ^R`d1gmHo;s-(C8hiݢ!줜DYP/ݢ[Ar-]C	"x<_q
0ܥˊ18º^Jk_+{p{.{TǬsme"kjZ7L.)XQvy]~Ԥ#v
A;g޶~KY>UըTSw-ff'}~j>Vp#mѯQ0 .EDie3S
S,\n^k~!:	JG1]tnҮvIܷ?!ۈ`JyfE[v8nv
$:z=h_"Uks #] VLZ'B	T`3$]V7Zw
~x.l!kz:=}
z}dXol3KVew	:q{{TXw(dr!0E%dJE@'BJ^o?CvshVa>ii|sN:%>EyÇ%HWV㙮ؑO(- ֭2sYg	HRm_?ePVh[ށcA}&0Ɯ1/Ҁq{|4X3mDJMUqJe-K_m޼YVS$Ya<l'Xi |}e]| fNAKJT-h84t87bXͤ1cpȵ"a<h3	|5-BH"[tCxq9lڃm&PrWp8j6$ŜGm2]]ӠdLrf;rĜ%y`e&k(QĊcP2D"d:MϚ~pw-@H%ɌSz\<8Z|A"[NrE.Ǯ(@;gr!R"('h
HtFObaSj̄)odNc3`Pt9W|vZJ#0+d^	
yH X-)9h^3(/s߳	Ek⋇S3{?wDWa4/GGQVi۽,#9;U@L|+{/ㅴ|HmJ DɘD6VPp}Ң3(HrڒiĠ烹2&գ,o;Ɵy1ǶB e!\Rtq*3nT`2`DiU׆[WrY:ñbuln'9A+Ф^p@U=?p֞wi};/Wg]DY ݖ;~ylYi '"G]ZZ+I3h2xzpnihT#^rݵo"͛w38C8M}W$ˍ,rڃ {Lłi|rcŀxol<@."X'lhNy5hzqBaHk+}5ЗKBmģ	\'N^-bb`"jaγ+Ҿ0}b,zc÷heٖҞ`b0oV'[Q p/]i-nrIG5JDUz$!JfZ+a&3]ZYrX_bǷ9=cObGm9;hyWȇ+E]QybkB{,k<AF]ۀ^޽VȳP:Ҫs˫nsUs|W,1o4X"%18Wp8
7V60.㟘(ZWE#[iO^<!-M3K>K<e=X0ȝz}Zm_\l_,'ӕ a`U'$֙g~մ$
}O1fmMϙ
>%`zI/Oсiǒ+QT	>e֍oXb2EMN`v S	><s%?͵IiIT_а	:`ʥkMZa~nO!xPLElP=YCBZr2ꟽ˲ehWo^<WdD-;Rh*4 h%XJ	ڴ
jML|;<"D}ҿ^<I
l3bGaq=n STKD{ [ОK6Ⱥvm]bd	p4NVZk	V3"OiLe +-

m9#v$3GMHV?H}G%<C<%ΪnMwP0"y<F#/bHOdTB@[(a/L8K0xskrpDJ"XRD[p>2/ɇ[noU>2E{lYM_çAUtTb^rbg%HȥxUY{/N7Euh0wKU]=\{ipsK|bqmCTeߑMO4`PbNݒ?DVTԿh/ǣDAi5{ ?X`0Wx]'`GNqOۇ}k5tﺁן̂9AVeg5}M>ІԳ'̶O ݱ\B281~{~=N-54?h[UHL^X?v|fb",ᴨx
}_Omg9TҕE2I%^L  :8g]>N|<]C!\+ d8@Cp Q}yV|DNDQDY`
B΃l6"(C
snh @'c7"ŏO]и2qtIK"?H3
{vmpØyl6AI׼vA>Ὦ.:YJ#1"֛ᄀ(|'ino~Ņ#AJߓ{7l*nGe7p^߅YOjh$U2ZǑ¯SbH}6+\~B|;%phKU>=8p>C*VBɬBtOYWd}6ae̊5b}Z}aۮRqOVUهe-ʩq0,MNXH)f}kΜ&b=$XK{54l:2)vj;jk(@&*!OGҌA@YqqH(ng@\jm^V 5XuJTHuݨb,b	Ifd1E

ǉ@irytcw򮾀OP4̹X1Ecyj.y$Grtp}%UpHz,t`::L@w2Q`f,k]CTh5Aql0dpxnuFs_a00?@3!4
`:FDEEҙBġdS}i\Tͪ4dzCɉv8MM}Jρb؜yy$B+˛m	o]͛f=<,gH{_%uym}
OYT|o5]b媞cOj_)T"^ST͠¡2oNj_n+2Mu]8
#hx2IB">9닮4oΡFyĮw@C[sۥb֐,҇KAK|){cf̱'=/im3L1Jj;9AgRV+k&#F[Q0qHA`AOe簑%H0\8'&h)3"(qj!8qoTuN3Ck?,3_1J7#WsH?ghDOgp܋y8,Z.g\erPm7?Znn3iڳx޼ڶo#3f`N}vOO0Hӡ͉:`q>-ni6v9Unk"_i+{{I!bwkDavz T.[| wW3R*^ѵ³k)HֆW?ٝ6#RO|r?"RnWi{7a6Ǜg>i9Cg9!m/laCVFr[D$~\Pz|wqVqvXP?OLgN9J=|n NU]=$ԭE|4qoI.p}*/7|"oym:Jԧ}z[TI!SSrþG#^mV^pĸ<QlkN;V+yxÌ]HyESzlkΓK%S%._TǤ&y~,	M КmIb=7 Q*!ݹ%DOEq;_)k[m38EW^ˍ2[R)?CV00H<5'a=X\rw|ˠIe+?F=#[/*{)=wVQ᤾lͩ&Ɩ}I}ɧ[Iؒ/}
T~gE_3I67t{?;%Asyf-!_&hiA\٩pz\#5zVwVrÝ<[?vf{2sMT:Lc!U5pcJ%v.qnw|9~K>RӿֳRم
sdsC+]y7<Jk/ȃYNj7j~l/loa~	=G^C!_IPZl-DC6!u"o풘rB%wz n_{:)CbnshnR_+ToOKY-!QNFfL}Ix2/ɸN['ݍ\m<\lǚ*Ԥ//!z
>r*fY{jL/ J ))QN`pb;15WŮ={bkHL|	¤Ij6ergtњ2Ge:MT4N=	2p뭝NսocSI.cq04pqj8VF$6ځQ9~)g(9IaHvؘn}-z4?'>ҁm1aIZZZ<q@ ˽퓸hM
̲jv0jɮZ5[~'..|&@i-3ȞNfmI3467[8"N:rixCT2vEpT{?'")I{B+9Fxy+2{#!yqAQ[oc͆
muK\`|%F]Q:Is`5ZEr[KGI
"r5bNˉ"l6KSzohϐ|ga5n7G*EDxF=a@O{Xv̨uSN2.
rEvHe?sf+_&9DW,L#FiIW5){zDldoUqw忛uzT+=wpx`YfXyUIi!m\KKͦGQ)wsUDx7ۙ1>JqZ@HzR[({_E_{TqJDA̽N";,*{iiG}vyilǴkv6]?_;/)/X,;N~[Myv4Iݰn5<=$|M-HﾻsOw*es9ޯz|M6B+[?~EmM	&O"ENvWCz[hj*rnT#VD]gЃRqiऋhֿ{&8n&`$Qt	φaɍuw`,>9yAp?#tr۲j}Svgz܎֏ـ&b~6g8w^c|wt1Xm;n?J?{ȗC[BQ3ڒ?
ۉBVo7%tTWjեKa*TӋ0s^(ַ){U`&wz^%2urޗH 8.D;yڽ&Mg"w[]wF$mo?MUZ(|e5ǹ(}H>QҮ}94l6#:ܞb-5-K8"6}@?ޞ.zE+*a"Mwej9U&ڧ7Ǽd|6ymhXgn0\wjhD>m.yR)%i{	W/gB@3~$-Nsexe͘QtO40/;6=V߼]C;.cH20!p?l9smSj>9-~0n5VJh@-?<=cScs	.5kWp0r4{6@fΖhōǍ^s،N.in!Șn\	Zz*trzyz44i}.uYԜkknFysfX_V`*%ȝꀄHH5{`p6I++-'.QO`r睽lkO+꼯4}VkeXWd^&Չ9DTN%Q,]LѾ8g}HSVuq|<7Y'Nr/ӟ(>#	0\K󖼵tGT/ݪ|HWnAr:`λVmojƀX~NF9"m-BR3v E@qɍsYc|_$.fO_HrK,.yI 24mq Q_I3} ]o&jIs~k!9HZzfF$y7|칙Ͻv[G'VƼ*[|b>#W&lj)[|ޖDnȱۊ䇼PVbnir-g˽
p0=	SPS8?;8W"FYOE){I0ۨiDbCyW>Aa fIwWc֡y>*j;ZYBKރ_c*)n&?H:fܳ3EKՖûphg-hʭeɟ/:嫈E[mU3Ayrs8,uguZ҅ݓtA+]а-W-Xpdr#6`2{Rc'nĪܽǘ|=/W? ur|'AݨV;B{5ҬGcn@\c9|;u$l/DrSPmwFeK~llũCF"<ufʃbI\J,^.rnDsPk5n7s0D;)V%p痭^]Ɲ8w{rW<"-+yz?٫&DB%FmVs@_
@B6D3`hFP?=kο(I}Y)\wsؑ.pu!7sעh
>#Qnԟ-jNx-Zmҙ)o%R\|/f^qEgZoƃAzXJlq5pU-!9fש)ϋL=ALkVzokbHCS³޸TKUQ{9}V xZ]Z?P5!%7?Sԇ_:ZHgiGf4vmHV^V=xBC/>L8<♤ʕZ#I&Los(1G%jp~8qf4ۨ&rŻ|-`XPn? ՄRa>/
˘<LM=-O6u]+>Z'w;p܏xx\?DqpIc^@"Wa=ĉ*@ew`z;6oVOJfܗI';h!T|OTGscpk.:IO<6uhK,~Ο?郆V<DzQLx;vVmJmbT݅j&avYLkܝE/@=þFW#Z7݁ף܇2F",Qѓi˹>7vLpz$Ǿ,35;86enb1T?C@0{Ә.?AXّ;!ycV]m`nS_m#2B|ԫ#؛v+RIsع!RÎe&D?f~z|VTy-%)}7|h=~m:.-9u#*/~~Y]Fýj.>^SFqrbA\ۿ4Iex:j.oT۴=~\'/z_;s_L8u	M:ԅT^Lo>Z9d	;cEv3p܁5Fdrf+M2i8*E59p&HQ/7=V!lB3csTɦ)LOpVwr$h	ٕ
.޵$:ɱ\VW
}75*6cj+q-A,7x904"{GLeXc3BG[E;6OʭĮԹtcb~8RcIM;].&HT>flݷ<WBd:z5ͫ?!2(9V6=Xf6U%^qUUIsub $0'9.qu͓m~VJ޾;2c	|S[dbTx|o?]voWp6rm0^NSwhN;RW9Qzy%bCHy/Hdv:fٮWuA]x
7G݅[ s"!"(P6+b[.DV˰z*q)^k,q@;Lͺ 3[;On+<x	yCod#7҈h*{?x"J,$4iT+f(K|+Dk"WF6+|:՛bڎJ?Ꙇ@Mj_	->t"?dϽ,}ѧAa=ޫS7]f!kӜOFo"GڥY<*r>M|gKtr<ZulZ˩-1m1;ƀKL߽
!ͭy'iL.掑rk3GI~%'z$NWЪ!6c%b0^i;;#itþI?c#<jѦmQ*xZy_vZ8\$b-F,ޏ֒JS8ZwujzkӼ:A/Y3q&,7|R+.UT$Adh{m#t64 $ܛ-gkNŤ-nD@Tg@1?]YrW,3矣űxoc"6GGymIqQ^GKC%߄x$jͻe$m59[<vtt=_SZHЈ/*A3w7#@z}0BmѺyxw2y*I{WAkJ9DOcGAL;uMΎA~EοcwMR"8OBjeW=&u(ymuzbur9AfɒO3ǎ,82Cvr'U]ػ`;k~[mZ۰}Mعs$HW2o~PP0@W{{2;>qy]\J7MצfڕV!oVRuy={ 9сK**C=ZViW}I/d[؞뽼lv$yjix&AL⣊~SJ(k&݁m3WZwyRqHv[;ڂAf]Y;_mA\GB웜5ä)"BDx?ʼC"Qg33jWȗҰL}w:9ע̥O.cuBvR[\eqex	~piB[z /OV3̂R,q=s=[EC^IБF:g6_^ʓ9c09V7-~^F$Vz16Qz֣Qj<=tFrYZKML$v6cbC7NKVXm!'yWw6,v.qBdqdaA!8L${G!|<j(hMZBev*[&M9etϧ,d8F+k\&RnPs^غ+ey0_FWN(V1{EYBt#ENI'D6;CFÿtN=LS̽aVO@NXN>,C5;*aF#.@7NZo;!u{1Yu栘\<E[Oa=Y3ΈNbgdDuT	nJCG1U#^~G%O"i#H͝S&Ms-,/_eҞ,WZA+|xev\-&+,-j|Ni6i䏺ښWQQ6cؚ~m= 4tok\]W8U}GLY!@֥O4N1[%
&+3TkMs~ݥg8jVwpb:ޙtY.T],:Z<q,#ݨ	o4FVh3԰D{^^zoPn?Nq7Fۛ%5j(gsQtND\di>WCĩ<Rw 2^F$*YH|ĳ2~;0*['5$2IzʾG=h|hVX;RVF۾d<ld475Xn:ѽ[g	T]LæD)^n@\t
(&Bߑ]fυ齨묻.v,g[:?;;r 8UvY,嫲\uhrF1 ~_Xwe\Y/YAH2s}M,IWBfLW&ۣ&Qt͍6K?&ej#Ϟ8Ys)1sˤ9G^N#3|^>wO'3բe9-Cn#Y9Jq2>^K=P#b0/i}ʝgruѾuvO	:hqcu{4MI=#5T%Bݛ&P{fkZ6ʟ+ 9;7$6QkA&(lݤ!WuR*2gz݈Gל8v楸L%,/=eڂ
5-84vp5c*xZlQ.zzǀ8#0tҟ>®,寕74>Z5(fR
lگ ZUjD%9.5\LrqXϚo)FUq5ٗ#̂yLbdkPk0kVE>Oͪ\۵)!D#+)9zĸsq[RgW''<zn/3wq_wWY*p^q9*'q[ji?CXdr[;l5ŀ&ݽE?|HEfn[_<&) '/g#lO&G	*Jg8QeMI驩`N|ti}%wkg2ύ^x&\B:֮|yqk2~x:GX-NsvGC7MLE+ϝLݹ*jt͇З+įh@O6)2ҦkToLiLmtn	!vJ	4` rU=ghEGx
sNZ^֘lN'gK&ʎM6\>ّZu^ku_Ύe+~Apa,k 'țٗQ&&blwJcq4_^lts9Qئ>BG<	f?ZUe	rĄ0s:=X-E*vBOFtD"ߠskZoүhD0Wgt$FV-/j"{Mf5?môfҦCӜࣼq%T)0RI^H@P)?#Z㉔;I8B_Z	3Z):bCZ;~AB54b=)}vTѼBWRrxYM7(^k_tn{13Pw>盍tÊ&&wXuԀЬ^/r>E[l>j&xP3hH/].͎qȎMN[v$dBi54mwB.fWhFH߂<X9h^_TLش2YkFޙg+<ǥ̯,G1~C'|cŶdz@):B
:c)|8$@fO[wHz1?65JNSpv531oah2(;Aƶ%P&+{/cQ>B|QbDIqRlr=D ^.inq&_5Q3yHa	¾\PDx}.8 rȨ͞gAޯ{rvg]Gn\j`g՛cWJҗoOQJs&݆R؅ޝ$J֦ӝ	w`)Fy2ec"okݣʵ@ܕ( CЧ
\s3AŁmg6~oL:.߲6~ҵu{{^V=aArLHFA2>Hs3Zu w w6]oqWgv8{R7{?­6iWڿ_
1Rhlx9i"Z@j"Q.8̽9%0Os&H;XilAqZ`Eշlz"4 Vp*n]6Hd OҤgzag"`x)K|Z?Y`O?7PB(4hYYe1E+6HAYrOg
2(U,.ĔtmLmb)yڷN/"!=]wVgwŸoG"Ն?˖ߕi<bk6w=9':Kq396xx+{mq$pzqZXB(Rjç(+[)}_(aBwW4^ŸT't;(s=kÏ5wJU8;u7%B=eO㞄)An/f$DF|&uo>GA6\JtrFSaږ1`Eyfxd(2ӄ<xkwn>%gX3ɋ)\1v/yĲc7#noIQ%UÝN 6a7%=ՙ`{/7=7v:uDPSx}Y.'ඌrE߅G5gs$4p)N ^<zDyfJgS'/;u'{fx!i"vBĪ#^{<P4Ίsy9)PzՕ>rfoDoߍFvC{/vmt9wcRƬܩu0]%˗{wX:}m:o^Ymۍ?zOsсo6^&p2N',7?#M^^AuP%hGЀsXdp~e;?]uE?*&Hԏ]~Ho.{#Ic+naB}۩&Zh8!5?iZzi!8˓Y5EnPΞl:)>`UƛUsWo'8ڑB(:AQ]׍DAٛX)ɪٯE9Vu
csp;v}Yjtމ|md,㰓C螡7q2	Ngs{fjA;ϣ:C4p<Ul5jƌ=BEh0;dI郗S-dzif-z<
	)2.Pҩ3r%Ѝ#jײv
yvn=ᅏI5T$LRka::J12Tx5ޟmSӄw7tC#+^  a^,:2I-]} 
EyK؟jy28QÃA]}Er=Y/;pef8ݍc!T!m
@7?ڎCԿףك[Wڔ5.IԈ5GPrߢ^ٻǔ4mR)~B^^W.#=wQ@_?|	amnͮWn
o}-gߋ|	hlsW o=heDR^gkCguPj޷E8"9-%ڙuyQLSqb΂+|}ZCݿOKyofZv4	@@}uH=ٽAÍ\NoC]2NC|.tgxYH2tNqTD<><*bjPG9[TXsz}4Yvcă7st٦9#kk?nfQY۫o_mWX6ˌ@T_f;wEu]?{hhBBro;9rҽ}^|ǇM|>ND[q'ʿ?.ђtNY,D>K4)㌵_v+9v[r)6O])::68>.#}dg.7q-iz}u-"|;! ǅbPe6N7&MLe^t ?"=jÆVr#(f|fA)~CŤ׬e▊|7g^|ȖT=@ҚȘ#B(j)wQ~/{7wi\|1\87|F>=ro&1߅Re8G*Oeރ9Y>>+`{~1ڏyKs4={iSB(%	O}Iھ~72YQMɗϜ18ҲJ=B͎,gm8Q{@m^VX*wfLO$KcE0ەQmnl簴d˭sxޤ7Esa%RLVP8RETV8u~8,Q*&~lݷV~giҸ{m9sv<0Oljҿo0{0Êoh۩Rx=z,l;y-*L6zUrE29}MlNǟR0\li򜻓5oz3KccsW7EEVVYۿҎ
Uc{kJ;v|>[ 6_QtjˮiVq@~t>|;;_ߪ6&w*9Q&ka#?]\x}3ol; 6j;[&\:@3R*+%rIڍ
xd8fuA܉Yܼ!msSf.^#m~Z혀t3?څї]8Y~mmYWHV=,2F.lso6~[6<CJfF7ooꟺiFa͠Y @ZQuf3%I,x=.~h96;}6 xr^ЭZkkq­%iz'ԋ*Lѭ"I9(M14>@1nܛZ;ls{Sr<Z8@ҼҤ~nGT}s?W[JTօBW^~Bzw빃okoc7{v뙪<2FrnT~ZMu(plpu/N]/!Ϫ~Κ-Z\2hҷe&"IkTe{uVD1NG\-N}rH8OR|-77o.-\{o/Z7=8t^$dđ:TzY\B0[[ҴmY)E^KmΡ\Q͙&QqŉԷ+`3KlRi=%n$ϸ?Ͱn݊e?[ǅ.s	+g('n34?aLOKVnt PD⟞"㽃*|L%0550̜@h .Vo(n6MuiƏ+קCK"[F,4D'^3cU]Qdלax|[Br	s(YZaг	2lĻ<#D	ЌtxfӚ8S6oYnn6{eFH+'ym.6kxd{SxR">|p]yx~
c4)}@udç3׃MOa5WS -ƭqs6Wg XטҀ^LeU4DoKI%O08V
R%Wddh9=G@UW=/6v_ZpMKw4L2j4i@sW;_J9Awi2=PDbM*ڳ~<⧵A;BOzф]C2ǦfU؊So.7JmY:K/.a:9		o:*<ͫq>v.}9Ϸd#cfy4lNJ_;#_~ؓxgQi!:~:atlP^&HB5;ѦV*>44aWQs 2ஙoulEt?1Y97rT =F)R2ѾygzR#C|7R9	a0Xfl-+ dB8ٚhֶ.]
UQ̤ZW=R>PYmdٖfy'kvnfDHHԼCȟ:qku-V3&Qh*3fd_ިsLdޝ2񷨙7tՍ|<z)DnNS:yL0
 *lcHonNQ-RKL4;qT]^#yI0g֡ ❾L$nB	w劮|Zr\
}J)Po=gyMoQNNe.lOJ4FKc_;TX>lL%F
jjsT#ݶ-rGS  :vqGV6]i9"@o޲di>GO>_Ur]N? tfy|6㪝B6Uƭ﫾,L7aaO'86SN*3ɡbE<]y;gsu.\Gt:$H$pyy}+)#2z䏀4Ui`x7TȖHW<Oe_{&doef~חIPd? xlBX.U#=W{;fLQryg՛;j#Z`xUU):btjw$D˩<]5Yӟ?w]םD3ݭ1MJ}ŵXPen"ƒKD,t[nB߳e&oU*A&__;u!`P+!gRklL}._s=mZS1<ce]7D4j)E+pHod_e/DNvS}C[lםޘ_
,iPtErsG;#}e~Ge	dZ;)CnK&:@gAЏ^$y" âyr=v
D+~H+:
`,~~rXuhL#'uuzsK >#YL88oPvSkwD߻ilߒL8ރCՇGR?HvKH[nM|FC$jis~6
ARq$]\9.jEú]Yj7>B5oozE98hmsۋG,y;sl׭U/㄁@ qxj9[r?EӀ-Y~:w5lfm9)HN^9QLA:18[	#!ObyQ5Pr3_7̭|B8	. l:_9oF%~idݳլ910<qFY n818V:ߟK5t!t2)ig=sL%`o7~Et@zv3A&`Eؑ+ɍ*$Ve^<M:2׊SVK=C^!9`Э,{pdAoUvF	ևGlEpcNP}ok+{NNz~xzK3p3iCKy4Jk:cC۱>ƨsd.ksqjo[q@Ӕ/:?3kh%@\U[@:$P}̻ܽR#S\G	gPҫX-YB/Wn~nY m!^NS}E;7k{(u+G-ߴJIڹӕ/l+	h;^t"gW/X_2;N[59~%8
]{
}x&76YQ5@x,6kХ9*=ޛNԫNZ4*GHMg}M
EǞϛ[Xgۇ>b'Ot3UEiv'\^!tv.HqSo:q]s5XZ";kiu	xg9NmJx{7F~^
SwRoTn`ۊ܍LŻ ]_.'go%\o?|Dbd]KMnN8gqo"/zկaQON-W'a{v8
yfm'YUzp6EzsuI;sVj<fBTKNL:8''ԴCCÔ4>(Hx?N,ʇ*.n!;d<Ub.5Z),P!Չ;v3;ă4uhqSl2]gK'
#<L׌X=O}zd0zRސ.O6(xIM͢y&_r	Bd? |)Ӱ!`kVZf/O5'֢^'5sc#Kq5"mݟxŮgUk`jPbL5*@d% l
l=6yĻOy`IOYz$t_[&oCpF\5>	KAivvuƟ#z>tmɾV`jVD[-\>O#B\xe_G/43uJQ7:bԵfǁ.krG˅y*0Lp{$~Eo7Wn
;=uU!э&~$cS<T&vo߳g4<@)ϊ-wtGOl\Ǐ#̫Ӊh+&LmطTOi֊?aJz5xzB|Z.;4UjZ<"[}N2b3or·m
|:Fׂ5dM+3_NƐwF&NI)~YS5\$h}-!v=)g~ZKC]XęwS\qKI`QM<dP=2GRRآo_5N6AsBjsbi]VQf;s{o˃a٭Qvqh{)`uO&BCto.B|6:dP >y!`g̼[Nw iޏ6o38Ukl5\5*tr;&dR-w?*.v'7覜wr.TO#$ԗ))
ugw\S{vY	oB1߲^g|d}W8HH69=F֨;Z}[rL{39hh=^P"^-_,ق}o>3)oxG,K{yP7n?U%j9+d*:ut!uPKqL$^=m7d4Uki^x:#a	j@gٛLSCQEIzM'ftfɚjl.ҟh]ѥ>M+'(Vc<ܩf*Rr'l{9xu'PW򛢴13BSlȈ`+e\r!x~s|E?N-鶓v>4<9\:3w "D^+\4̻:&9h6?SEIV'|JچKEl3w3D/y=n[Bﱦ^"_o|Iz-l%ϫOIJUFL3'D|0;F6$mzWB=}k9dn-![ȕs?7>@~w=uwl<r6vդ p0
Jv ΍-2CBq-@Σ~c@Qt	
}:(v=](&>)GKBJ/1 iJ6uٔ ݛs^g		ȏǻ+i>eY] iMh4qR>ʯ*bٷ_AZbBf(˝ʮ?Ӱ-*CAr0||iXE_fTزƚqũ9ڐf@_'3>O vuEҔ+}!zHi6hltå%&`<$#6#ק*rgd1])W}!zD+y)d6V  So[,|~)Z9=TfP(PuZIc"1<0o:VQ!u#-O~_HnE:|FtSZZKSyjyv_ӔEG&[w8⾻r4^FB Jqj+# MֶNu43$rP}lcl+󨶘m:"=0R̗dml|ٸŲY߯f_&pޜLњ¤ʷ?]MZVdIZx>\HnKpZcț=\,_?i<ƞ65Ud6CiaeL634_yyܕGKKFuxx2tFl~W|\tb/.ns6蹰c,~m%aO`vbi}{VwRA9̙֓->9kyvcr2Ñtp0{3T@2T@(|ތO9/c`pJJ8 K,BJs<(x5:NǼƨ&w6ctyTtqK`#C5\vtm^C
hG9ڢv|hGY(ZKg'E#Z0<͌5,/\UC/Cvblk;}rb&sz5Sqڋf@iI9Si0áj l[KJY:Pĵ!'l(\4|س{"_>}.n&F%z:W{WuPǛM>}Tގv-4t<?`:MuԁJHW_JYH+P^A1̌뛌Uї]dcx[4jzUFSmٔ$A,G>V=2jiCjXGኑ}]7vC8ԊGNq-TTotHny =tyK:Vݾgt//YW2˿x<qE`{/?/cCR1Ꜵxv8|64x웣9Үy2N[qTƍe.8s2s}(9׏:Nʾ?^1>ߧi:{ROױпvL#U֏t/'jZX(e(FYVZ9ifx4m&lr_g/cjOh_=A/Ȍ>Q{αW$jl^2<#r;GOo5JX֙C[Aj-׾lf3K"{t4o>
 agL,=ֺ޿Gٙ_x'*z+\f2Scu]۱^ol䊼̂D	϶m7MbID_,RRfQYZ?9zs+SnpWǾ,FEFSTR#gΣ+y)D	UThfOu1hNaı;}iYkrPOJbagҒxYh#BΈg˰ehptWv2+J<	{EZqʖ.,Rcae$!CMZ4#2;y>]c (v*юfQz>SķWA0
^>f-O}:*PůG>'YL+A:ğã%lViN?cE+;>x~4S0L!^u@F'Px	\eBrڵ^QD[:f
yȲ&;:Qs(	/<riJtgn򌩀<3aΙ)бh[^3T)0s7KWuXcӇ7M)f1xu٧N'ѼX:=+PR}YaN[îFwNX'{A$DJ|O畷ÍNZ:Kl'6~=9Qjfp!5<<pSf*94|tt4b$s}|0y&0x%Fs,7	%h'%gd:6BRˏ"$ ߕ׼q8sS'0:s/ݲۂaXa7Fr8saQΤkNqws$z'dlUԍIZyI͗dDizP7U}}Bzۻ,2i3󝴆V sI[00
$Gy.sO?*]-NdkAܧLG7{*NeSWobN!VoM}>B|kw):3A
799tɓgD56aO<	K(Bq
7\֍!q[u0s=H;g9g]{VۤlԷ9~2'gJ/Hq'oP4͜΢7G^s49陜fG'z<[ B6q]GugFU_6*6Z*v'|*H󽀧vPUyAU q5v4]N=%25ǱѢڞq{cU@L&7NܟD8@]3ሱEsd+٩Rg<$b6B:SA>TdtA?=m1M)2c懙%k/e#[N3$Hx[gzbu<&6ʳ	).*<k	fAmVҒ|3O"`LDpGS&'وM+n N">,FT9升mHSVY18*0=mgx+zcn]hlD:~Ο`n)0Wf+Y}~K9=@Wэƍ!&oW!0ϯ:QsZ8jnV.{L-_ŀstkLteb-޳DEcS4G^r`.XGϓiA8sР?HSjl94ՖS'C%J_՟%"JڛH0A[@jrJԇ߁T*EWu2;xM»JmH."֊ V+ GWS,"|M8Lf`;E͊{~F҉A~C`zV\hxSm.|F\>%AiEZV-݃tٕ֝r& O9U,0u!mt-n<IǜW/ntK/JRKߡץWq33}+6"??G:`r4'w$$k]5S@	+DOasrc5̞_KWʑMU<V)iKa 0x#~LAS4iYxm᧰_ƿ%aG?;ϫigfr 䡮}֚q]9ٗl2U'~;*uL[P;|6"\'ST{I}03|UamdԆriJ[ ^`BBJ5=^W03m3ohiJFc>.@=Ő:ggWAFC'WZ=X`tIY,ѷw;%̕abtCt*󈡬-BbdNoж86fpiu6ߍ'9Y/i7/Z~-,'o"Ӿ1t}GvJ_ZwɓDTo]:"u
no\&;fAWȀD!ڟ$G陪s̹>:P,wrsQ4V?L<\zIZnyCz5Y2 |+Z"S_os9LO1%aqUl1|(`+PoL`ՃXd(4NAVgrE,S}dNX-k|^# 6d\G_X~/pD?r#>S:L5K? K=}\Q2PXgS9{K0pPAP iKN;l.ldr;޿QiWN\շK/L=9ZLˤ.](9&.)%5QѺmW1),kS,E{ne?W	QМDZ4ZA$5k(:XuVg#
RvY)aD0*^8z<ܪoc`O>ik@GD8(	kJKx$ c؏=",E7*gcTvcZft8=<;7!kC٤RԜx5 doCPƨyv$L22hD?+B{/2#	-8:#jyc>x^v9,583I]-hFw+ܮVCVVKfl][76yaFV$^mt?tq )OKNVOwaWi|YsBoT..O0G2׊yi52rSgCa:ӤaFSTj;BE/xiڄȷ|pd+gǉ
nWsb[La =e,Z!Fr`#5_]t}A&z	1$RQi]}<TE(-Y0Oͮw埇}hG-pj5:ptjeYq؏ēz	L>}8*?7qV7FqYL\ggMͿ\?msjh	}9^ף r4/<I?7cbQj٭f׼ꫡt ҙؾg~6}+.HU2k[oZ^K45܈$2_"en<>hαrxN!P	qsn*t	nJ	ĉ"¯e5Uê&59srȞa'I9	\-~M7Gz~-~Tgl}bm1--pi! l혩y8u_D7ѐ]x`8`Q| {	srdڎ=iyb˳_i[ᐺVǣ,Qxڿi ?H91Ȫ#t<M6d1(1nqB5L?Nm?
a%hó1qŽ̯NHe:`O[xSMONye'woSa=+ŋ9q"_Gk5<DFi!jEO"o؍F=6n2*;LLiT^(vdX[	y<,"SO4^izޏ#x>[CcJ.C.xƟPfт@wOՕ4Wҫ깓`r2@2[/d9'LylJQ;A`4w`%1G
AabJSk<.6DV{6UɫNd󇶝a'EsDWLZ%T:a@UC?/du.\߲&Yh(.{\lg[
.'XxC0L"Gyv\3.	PGQrʭl؎b5KȚ4_kevj5yzJJI{AeR@p+ϳẴ"x?֔.1N
ƶ&z*CkM/(޶~B7RXJop|Y?&śOnkPcHZ,m3!*wS.7v]iO3OK}/?&_ݺsE߀\ڶɞ/dORQ}ׯΈD=X( 9u&xvGMpķr򸠖:@|Ƕ7NqN=> 4G}qg0AYƅ\tFZO@9\>p[l({ߞ6̋G>N!tdj{CR-g3w9>#{ 8sVPq1q:
?[ԏ":j TlvQ $o?mIh!\Dv7;0m2qwJpӞBq\:|MMW"zbw<ҌӀv{|Zܩu}8«o@b<*jۘxY7p+GwM|dW{KY5uR]KQae;\~.ʂ?4vaV?YW=ֺt0l9آe,AZ;L!GT7Er?a]ʹNѕ7I3jvÃs/6MEy!*9}qDn;U~kB fn]DW#mf.
u"nҦyt.Ɵ©	q-w8&< Cl3G~*2
g^yL9h~T_
P>itX+g.|)Vo7s s6o+y.Tc߄+/Q{
g"D fxXF ~}dvxaf,Vft;?ߨ47Lŉ[f֘=PK,DY\3fOXxɑb-ވN0hi%j=[bx'n/$mm(ף-^gvO_ۆEm-^gVxeCE-_B-"Ekvy4Ckɴ.0E7ey15\MIzdV (s @boJ0yzr}	U!:jjA	 Tmֱ;FCmE೿ުY`]9BaCёi,yzius@~0OEKQ_gaZkl`潉d@ŋ`Ҵ:ދ
sFҷT^>Z]{Gr"'̰j5\3YEl):L
MSFǁvO	ߍQ/C<α(4-t]Bm<'j4&QsV5vvpDzQp8|_f.0͸oҔ\37סUmu9V ?b8ǰtT;gLx`շO[iE7/kct߽<ݔ%zrmVzP->ȡCW"?F.r^l#[5z~D}I>2CVpĞ)aEzox7ok^9^\hmvl<Mu1.H~NG]]yppiu*\ikb?@ܙR_kJ9uEަg
hhє{]܏wAE*s汼&w0I̊']d^I8þ(93f:_<sHZyEϯgN[|&m&xޅ=Uspw9	g)*9u]$G4ùIlKFx&\2,7o=\wl,	tv/71Rm9hGUXs'Ά|ُsz*_իJofCQ'T賛1Mmc#tUVn
٩xfo{j EmhwRܹ%]_ \	gw45m[~>Z53:/]_-~7xؔM_SX[ 2DpA/8W_Hצw#<!FcR2WJ\	ۋ{pjo/6V.3<bNdCځqvv%Rqg;|}=F<V
CB3Yqj369s4\%S`y0j0v֍Eآ굇rBui܇Ͷ|:Q"Վܷ$\ޗ xӡfa:ބF]==&I{0D&r~vŸVXݰ3%#QFat栋WKʝo~PI4Ck *n/;+XN(Mz/O> jz|5kCMbW=m7ŧc^2Zk!QhUh^jW
/<͝;M-|\mD=M*4Ebl$RUCQcq
^ڸPء4y\8'i;ҋOs84@O4ݍ!O PFʸ)hǟϟ'ʏ9yrq3K3y())}Ct;qh"[h#ւ]Dy#X7RNIiTLԵin'q躝"A\'CuO6Cm̈́֏F2=}a8GC3]!u\oW~!Nt0}	=hʴ#>M	|NW=.X쒾/p97zs$L^_	';2˗$=a#)xeUUd+v}oSpҙ!y#ɫuV-
-bHkӓD<ebxxmxspL<:Cwq鼐aq|aY2ǂY^r9{ J}*)S4XQ1#;v^P[^czMqr<p!l(!yx##*+=4O6`לhcʳȷ
@
	r)'oyַܑΉF|E}TTKrE(֓+ϕ_p`ή70$Vl_ɪl8sdyck\*]-;b4YocBi39@nz3<:10w"qz#Ezpi<e6
hbܗrќ-Mݞ7w :ԒTWVXr$c[rs׻`e.XYz%dg
۲:Ӎ[y'SQVGDPbUke+G9sbV&&Ƶ=yh{vwqn]Ƚ]1\)㶵erJW&M&f Se-%-ѾꌨVI
[A;ٕ3uD,ζ2ie*-r3i^=5/j9!Vf_CVӸ_t
RZ]ωZ4}2,齹nҋ2QIy!5.Х.z6:,VXN6 (Cja8pl)ƗǎF+T
oW<%]?^/Gb4¯E$sǽ#6֗xxZjFkVw;O}Ҧ?\vAL5X<l`ˁ-߾*E2K-5lZ4¡d*gcS>TvO?g?G:f+ٜm85_r,=6rp亵ygۅ	g1,/RN'mҵґ.GO;I)A*ncY0W7f$# S)ղheˆai>Ez@(l[N<vU`w@>GšMBFz_ա*yhN)]%cWKlu.jte!x;E+ s<IG>t~6x݀ /yǶx@D^{-Y	-VJ5%X^[f=fC *5iZD3IMuYnw4w H4ϩ`fx}RY䚻,ãgi[1vXkVSzWA%>~5wᛑ ߉&,oɑJ627sߧ*l|6;/Ot;nvt.f9Tƹ[goA^pFdpLi9!i{ֱ7]hIzY^ڝ7lIMӻP%`7f,TE
xwE_0rB]5:2ƓZBSka[?b|Y9!)<u܇훧}Cս*׏R<It:E<hYtd"gr<XF BB|MN% 12vZM,YIIp "4<gr3p
TZwJq	v;JWRf˦5_3ԩl6hsuō۟rL5JH=Z8;%2S4ҘHYz]gk3mm	30ͱ$1'DVec]Mm%bcwMb&LXv
58jlȚק|>Lk3(of m]i߳|m=M5rwٝzDh3Y1Јay\kx榇u'@՗a_yvMԏȺ;tI>ieʱCQj.zO(֗ʿHu3 Ǭ|BJvOHIÎ`3h5Wqr	&vkmϊ)c*,CKE,eCT֔W4c>Gdn3ɯd6fEu`Q+1"w\gKֻnre@f9vӹ^c8<𳩧̈́tĹq;~:i.CeCȱOήTY+D3+<\NkEKHˆz]p[~Vv2b=sWxs7T$jiBC5̺Bh78]P;SN"E%D]&0dֱw^qŪN~y#¨[8|)Qr5
虢<愃}[E}py#R?B{YB)nq"rs#yLܿVqj{'QmTYF	%c`L;6럩C&vPƕs=E3g2ir/zv+^>]\-SYIH}j%g ҃՜RJs,6}[_iʨ;fٳ7vTM_L=6Q%6f>Izs1dO쳦ɉFiS6An=JL>ܫx>'սKLvcݼx)׊m_3&o|ɆSwIR7rhyAb{*Xg繐/o'[KJAGLɉ΋	|PՋ7ؾ;{ns<:|]8|]|\VEޝs$6^8f]mU^(cly..M9oPAdc.ӠCr(Zب4n]SCKXqȞ44u(MTs\uZB
!$$Fm977n'p|Yxq#8~;淌tB zA2d*(>=X+>ӓT葵JK,Ԝg-B8 xP3{>XAN\(kNho;5nLE"6߇:ٺ_N$VU+mkqM._[^x?QP wjG*{Ǆ=
8mspXbovsȉDTdt<&̹3gϊ.ϴ7ccHg~>Zv<s纶{5d-\;^݇)UtXd2
>= 2,w0cR-M)Om?j'^ sJlq>At%9HguXe蛿5txeu ,zu^YIse{hؙCG;J.q({c ݰ'aVo+ar^32|ğ7:ˑh5#}dnkM64p2nfq}-ث(^eݵXV#c|ȤjR$0|2<m5s=9$5hBVFj5[؇JvClJ`A-`?R@ԧ0勰$`
)w1\=;&N;͙oY|nO1mʵsK{ɀE*A]I{{ntM߉}̹=CF+Ǔf켚pd
9y\܅ye20oo֠HDE5mnǃkGPafAs}bW>.`>$c/'k|;Vct$5A_,DKkU|/0/{aף*Kos؞ӊi	ɠ߅OK*jd*\Ӝj6uVSRj{b.\ж (p>w\tl&r$CEޓ:m!i9)کt9vPeoa].~zԸ@\E(ދ}j6a[p {Z/ueeWwYxȂv=i\SkFyq9rnddO`3ϛKy.z{)\!3Ii5]Q	;bƽ?mG꿭瓾!7
r"r]TuS}NT X],Nt͗ybR+,{Kߋ?ʞ\e߬/'?ҋWק%z)=F-LDӌQ:GO~:'XC#8$LK}ެGϓ-cwكssDʰi;0bP2uq#Y~6Η3pvŢ+öܠݰ:zD,O6::Z\ãvCxn  FJ"aΜBH#hݓrHRQE$!Aǂ	nqD%XZhys
.M.	,5ntV&֫NDgU=|taZ
x3ٚi<fv|1z^7>ߒ܌۾ToSlaskckvz]f:!?w",e#VؙЯCucq5#̔M֊WN7ZL`^v߇Py-^һ3mI&ЉQKļ3몶%C{>#ѥu]zjdwY4_Mx>	eEQ=oq]:n''OIZ,NgE{n|%C˽ELN<;n%-#ݧxGz3[a\oI}}w-5kC'BL+ȭ|-<d<{}VgwgϹ5z.#7rg%25U2=~r͙shϏ+qqܲRvا2vϣκ4c~W rf5nӚ^"J3ΟKhb$v(ZfMK]gl=pz:߱Io96U}nkGKrG<}>>	к(|ѡza{LQ2Dr-o64GmKm^T
3'J2pQ/V!ǂ̟8y^WJۦhClQO:?'c/&]70	@Y@o,o?t^iK{g8MN/FW~4/(P)qt;UTi<mKɾ]^L䩜yO\ai'$߃8J:}΁
*p}Դ˧Uhex)meha֐k(<3Aw2\I*@hG}IKSm
:YNҾoonqL(8ȡo$6f%겂M}:b{tj\Y+ivn}]X3jדּ-mY	pKFU+:9B.	'$	͕"_'n_nf&{=&cAĴьd/N'ᱛ`(VPsW
sE1Qw`Wr%.Z
5FNCG7x>J˭BI=Oy<an[5YiFj]iyӥJ%L{#Cl[j**l2yEm>dWgQЈͬޅc61zA!Y lՇEV<I<f9gT$!
	{n(#gexiq֛Z9͸?2[B3LQhr>,\SJD;_w6ZG6byy@0cC	H)lgt6D7gےg6ؙڜRp"*рUSu+k|tV2/ܜ%CfDysiobbϛ-Νl$uNV}4gm!g])x&ni}fmh:䉲逸̵ ̺}4r7ya)b,P)YΟOP&-i?	*-=c0WJ{E߈:StIXrQ˔Io=ZtsEOsV
\tΈa![깎T6_P(n?virf{n^hĜ%Q=G	wss7ɃPopm㘒K/Zg.ϰRT
]!~&,{[e5(z+=:faCX(uPIл=77*f$0g`0kXvυ:e%T܀`u>zNtď>.jR+Q9=(+:z߬˛h^7!5iYS]^-?$",ץHgA¯؏ۺV:<Eh_BǂF\}Z nKMYHD븵p첞^ӬAk;ڌ.3}hI˷|flDJܮuec3N#] ࠣ>hFX0y|+NOyk7'j.w+J?~_5-^uLhޤ-y4 '5S+Š1.k$D*k\߈r'j	vϠ0m ƻlUB_ZvGj_.;1Tܟ$\lʃk%""T36;;fwY2!jvոt9el
b7"͞5L0FI%wu[{7԰"96PIȗh噕k6	heOۧPo%'7}cqiCm.z=* ҧ-7oRV̋aG84ieX/TWT̈́n񚢴sBF{7gUtmm}q
Z6w\uy
'95/Ѥ6!|@S{-a VnK]l5Kk/>}ԿS~Ѷh'!ߪes#^t:40r#u: MuV&6pvY7aHs4P^a0 ,އ:PfSpû#-uQwCSъr1'dʞ.Kے;gH-D䔽~kJ!kNzn) *O]4Km|nCp6Tz$޷;OHu
+X>YIuyjy'B,byu>Xw	˪#
st95A7NM"4$M(q+p|2beC"'Lׂ܃ -kw)˕g	NjϬ),l:EZ%kmʖXDKߜk3t7	mV_HI?lփ yd.u,7$'cW*uV*@Wl6~(+lJr-=yrKγ6Rԭw. QgFLKtԽE^RN|Ċ#96 y'mƍw-Ep@
rVcRN~}?&<yw+yq8 r-]0".-Au)߿`D%='	@&`Hf':m`Xf>:d{	WD20HtΌLvԤu៺9<%xukRۥm'BIfpxv?CKGxt!l9dQTZ#%##~U	N11C,"mKsŨT#+Y4hX3ڰA!N#n;qYq"5=Sxo[Dw#r]^yYڅ5/뾒tjb!}nJrɽV)_2*<tͻm:́Lu6W+D_.w lhHd3pvɑ;:zmH({27F^bb#Oxw>\ǁӷu6)rx}M{$nt<ܲޞ[h	u:ݺ0u!c`PIo.`:68^5(fCT4o:TY9i'@dxۊoHmg/Bq-cք@OtdfdT'%H9ÈfEDrOnK:I5**>m:EۇF,z[QANǷଅ,7/Uh@&KߟI-}*><ʎ9}7xsw?@Cq`d잩PAƴtn`}&ɚCKz(h0FQך_qcBLd{N]'>-8\Ah%pf@oL'`&k=}vWt\W;lQ#1x`wg'NoW	13zkKMèƈ;]"RwrnK\Y:\nBwI]½/7Ӹl3+]_h~Wz1}%,8;H_.BKXoPRu޿&~+c.z4='miϯ},jybܓ{wC~W5o>;&ºm}7^b~O`if	10tjjwwꍅvg,8*~ě*l6RAEIT[$%MCt/YX|vtI>l1oƷ~{:{d=D`CtQ^Rg!yn??:΁{e{(Q<W<z,x_+K!h:^GI,s;Pg4]{aa!@8}* ~( bB4@7Tb[xu][U;0ɋcy]׵s"ց6qPckKwk<ًzqBGyQ\A߰vxb!=KHy\g0EbUa҂%	/'C(@E<>%6<&1<),H(Ddv⃸"4zϕ08(·[Ve)lL텉rt+y`/0p8&~/99V6s,3$U @?	f!|	pF(c^WnX(ϑ-4T4i/qgՀIRPeҡRw]q%z,GUZl˱fjMX̥uA
F	CTb5h#׹+?h\X4WL;#{EGxzD0%$.;6sG 8ГԔ)f1>hD7Cԍ4v¬YcxeL5<ׂlBYYgNl>@eFI<'	%NM4dO+h`7I)/Ф wIZA\U:jY.ﭷ&K"vzS9McD8/
P:>nq}=G{g."`cLJ	2v0"MTz[Fyv2Cc	WL9V0V0mc,L2*?ByqU1߮eAuUJQ?)zXcnʹXItBWlC+ʧ1l竖7t_opM&)^nez9rŇw&+5|4nT=!ܱ]v'<'UȭhUMn(1{RENJ5a7BiҬ>z:QGד৶E(r(E_`aRI$=Lr	5M<V[cٝo[__e.v+x`UYFJo,/EZu}#[XZ'@}S[!C0wWy5`qq6Ґĥ4N /8ޖ!
ޑЅжaKR%	f	G&RFϏ.?}>.0kvXj1騨L"#JG6v-LKb:֑ 6>^2sxO_ rt^qK-x=I`wsFIؔ{5tygPG	.l7/B9vD8FSkϪZPvH,gHn}E
S~:w9Z_m2VRݘDHH47F/jþuuv;xg&XX,@-q_J
O*|D
đnq]/ӑ}%|xǫ<ǔO"УVf*yJ%U-7.?lнgS7ZdH-g}T@g%]9:;/@:wzvg޹?qpۢ]굌y3_^q=-~̰lO8	?1^nan8e@%sPDV<RKz@)ZG5C_9n_O{?i'\|ǥߢrxE%uK*7vL1EZ/Lgpz|WgxT롂ʪ'P=Y[a*|#SfBEt-ds?jzS9)uRDｦR#f"ځ;T[, xDm<31fdZ.]]ñW;rL'r<IEV(r[)p\pplZ'2sȗqY-Sѝt
v%rV|Nي,p(f9l'ڕpҜni'=EwV(wn~O$$E'E	V7L@pu5_`bA-JhȘ(%4STÁG.Xf\9xt$)_R^kj&%7"	$| wQן鼖-[8(POAC%ڶvYM/jӏ& 3[+zG31+FҚ xǞ/Ss.u2CAD990ßFn@c('t;MʐFT8y`d[/vQ0|O٤pgI)E00BO5K{cGc'ji?eLK7OXB?+Qvj[F>;r^KHP]Ώ
0<>_)3^s2}Hw')1ݿ_z!Ä_^M綆7+Y"j
6b|9uPQŲ.b]hD[:jvjNMೝVxswJj3~O1g|/.5˽PRy{xD6|nh2rQuYR #0
E^cz@dnS/3f
2@f \ӂ 8H^==
?#|A>߻{J4yGerr|FQBqV6P4&1Z]gbYä+"B/!:ЬA2rY1u8X"t3ZoWX Qi>j11w*I   ݍ!K֥G-OH</ͺk,	`t#̝k.]h=Zc<0^z*):]}ܣ-J~Mf
#g7'ҏ2hNȤB
0_F9r,t(JC,/5S/SwTbF~Ou/:tuwC!Of;2"6oh*fc}\WW(~0tyr}ET4rCS/!FE9g+9a	'ĈR33&%XK]@JU(+ዺdڇ]1e"Y͋9qXD{K>u_9#N<W >ĺ+Ķ?TҔ#51l=OÿJ!,:,Bv)Y]	S0
6њM	
bSLqQ-ix=Mձcnn<S!t7!(ߵ)9cv ue1:uʻ(oU5\%]oCDҰ
JB5EqzGjcqMh)PL aƇ<Fi-S縟4
HvQI|޴,ExYNdڄħlՖꐪXi!^/=ʆdHXbKk>LiO"gQLO C\OqnTp>ςB9ABXiB:6xo1밿k7%,ڦ2fs"KZ(~)3@G6(ZLH1}Yݑ
szBUm4gƘ}[b[XV3'@Z(BL ;+WW5}n>e󎝲hKJ;Wz	o@q 
tb6gMZ=a-_fVfn>dHYGDlǠ[@qn]}D. Ǻ6ƃN R$>ßdթZKs[UMtVÅ ggG<Z_@WBPr^u#gB#R\c %*:*#T8m#}b܊d .lmHI3+cXH7mc-Y@eWWcSdV(DTQlj@'19m )~[G:ιG=c}깎Q&;!Ǫw]l_(r?F~d#ޣI2$@%(_0E}~*jHmOyZOQE#qn,	5jH|*ņaġ#oRÛTNp[]\svqzx{R'WɏTd``d9& d8Z~0:{m.y*x#O֢1A+VtDz%8\1Rh)дT6 wgpq +Sr3ļ+:h4Cʠ.Kf3`O4ka' fe2|:[Ct%-tAvd5Y|kXZqPkCqGq&52zN%	JFdr
l=z,.`k.}@y/Z\b7@_tm$\Hж:j!YFfH-fˬ[z(4kP0
"C).&^c#2Rs;Ҁлu&S#B,9x!jl_U,mǨ`V:3y?>.0҂|`ˉ	t['3O.@E`5v0GH}3~,LF|+I.K+|Oب|,9,2/ngB03>FQQ|/CGb\?oLoNQs<FQ0q9_$O;٩0m }Q;fpvT|-ߢjv-,EоXlR2U9FHMM|k{.ﻵa޽Nv!Xᖻ]nDDO^TK:E*>!.
V
dN<th_x*&JTN?8KýVYIH- u"GiզьnvzH1O-OsnIgzr}DQj$-@;mhT	>*?<*ϻl^ͤܭ]>eR 3?V5M
و⣽]}1]lI@5-}d=^\ +B,TQN^7m=~W>y72ۘ3G;Ao
k\FO0L9:-OlinZA lHY@ <=(Pk׺a˶<NzOfpTvu*Fj\lkutE34\RO$fv||B~dbd&hM
LZH6GF'{ݚ>mI3do#1S[2TbIJhVYx?U}O>|؁sYIZeWG(ԛ
bYlAbv6y B2^0VGt>n* .-ձxݗ +"
p`ǼF"_Y	)r8^~uճxoI0S
Xo 2*ԶlMj
G.HМ)h';zh崠Gw	Fz)PIZ0g:TiZRVJ A0BȀ2,ZM#Gmvt9,7Mfޝ@Zt:a2i%V8ULS)Da*]-H72qފ}asRHpg	LJv9h᫑j5gTd8nkܞ'

>li<٫+1*R(g`/{eǏy7戞$O0lGm|^~R/|$23)zOS^3
?Uooّ.`Z&Ւ?߶(+۝@*å{,6GfYW@**qhul]O-uyץ(~fW?T/ie8p׿{!J2(l{I{[2gȠh[fhv3dBf	H'@-f<]LQ?`AF~_>hMcM]]Z/l/U=ˁ$|Beʺ.0M;2stX#l38 ]x!2F[,N"iӧh2=ը1u-y~9Ôlh?юUwWelqmNG	6·2),U5P"ѥ?U99Z*(ǎ<=Z5L%(QUDEQbyAMt;^9?O+#);e!:Y+<}1}uӇ~Y}݉qqFm3SqD8Ab !-%CK}.KBo˩JTpVXi>%gk^Z7L	gg-XXUll(m#_j)&kȺ?!˟aW0y'#|VQM?#X}w<]%
UD!N&[R~x8f7oJ'9v*Έ^\r.r, {_z"SRf]_O߅pW%AzǥIxBg+VxP:g&S3lk)	L 8Ͱϙ|	VxپU'o:m4 KLwSfMx
fMD; D.x		rGp#{e 9XœmF!k0<|$3IdUjqs)ff)Ɣˢ=4f!_)88Y{fl"NѐL,m`D\i${+DAkBlR7
+MW("@=ŷ"6&Q	',VdXqL7+dm'UwM#ɜw'!YIiVGVG&/ؙ9*HyFcn_kI$ޚUj</3bۖ!>Z{?y
 !w#3RIDIGQ[i䘽dZg~@MF
2[5&f
>-o|L8D=fHbPeʃ7xTV/WR_F)uNB{1V*֫VTU"]zJrTSL䢊>eTQE=a9j(MJ((u)al(=E8(=E7BD©}QHU!QoLȝuݑonOcdqw=g.ϩ7_ҟ.xr,v@2bu
{X1'H2P,4߾1iju&|[nN(JYg/Ng=;Uᬒ,
K3tH;E@A9)or?gB{'t=vNg,,m.IõRilA3?GyK_B Au/AcEvUc;Z;խcUWKOUg.ԧ_jv>_~  "7N!9	Jp"Gs-rspW) 1A!53j;婢7uso_>iMd.,}i<Y#Wv*E|k`<;iZ,وeER+mo].q?i%1\,XUoh및@Fs?M;Qof)٥+TR)VTpJ=T͈dM-l#6R	5̓`oQ6
RΡ9#ձ4`YHpfz٢v@,~5ڹLPU(QR|ba!5QAPρ{,(MfXsO#`2tXIAܒ&\maZlz)L>{D!geH2yϑ+)4,V-7Y]W4<ͪ,WQT[W~YYb3Jn&|ŪUƺocj9jl,M0J6m^J=&ΝhH㚜dl+ <T_e
vv	̈>XZ4c/H0"I\9ر3 KFpUFN;N))6nԸb qK_=1=	/[/0{k'Nʤng!{=DQViH4 6f4=w'FXr;[/qO~0"TU­að|Mkk2ZT[V&N,i@s @{ o%._K!n]KXCp3r2)}msKپ{
5	G>gk*Z(mx{K(օ|v:us+|ZTo^ qb\ŨI4߂M4 
a	Z) y  V7!#zy w`佲hng(<,5cemv ,z\Y!k0ImнS7WCgis6&T*K^p=w38 A7ę(o:G򪐄C}<2[u^eײ l"@m! ([d1Y&߬I0{el[Pݻ³Ƅ$7 	-=2%G29Lx>!G/Q6ۨTS$op>c;ىYsٵu4i IZ[#s6ngB;:J.*<"Zv|s̿q-G-`3hg0ŐJӧ ;Q@"cmLrFeAL} &~2Ʋ$}RӪ{>6I@^q:vvs4VU}FmV'Ų֪v~9d3?Uv?e7e/((}_
וՌÒ*?o.g02O{-Ƣ7O_yN@~uX;85Fِ{;
pOwgыU)KߖV7nxZR嗞k['H/-˧3s.wJD_UW^=ʊthʓnv4/*な5VE]3"ac,Jn@5FF!Z\˓P[v1YdA:rٴݫjUDpݰskOi"&ِv3'"B2  f:9S2z3yL[3Zq,-xݲJZ^ZiB+S5R$ >ꆖB
^{Te#"}4%πDZ1P{_ʄ46}RSAE"_
10 f-	YK^J.>32J
rpJw`Qʉ௲?Pl0x$Gb	@@CHM:A\h$0/3=!7(qL˅9|\bH*Խdc-6"8=ҧ@8zڀ3@Rv_@-$P,}z2?TA{;h,#)z)6,]& Ci\`,@Ҵ~+:B);q"ЁxHaWy2p·kwպ%#[j#-tx`
TgPXB`t TNvUĸa=Cڼ<.~cpۋF</+9.Ni`H]( %E	"(5trlޗon^K01dj5ݍސw_Kf:ksl?р|x/I<-xn02.:,q~竂Ǯר}0hD=qWE/XGEJsA!%Tp_uI
=BNx;NFl|?g4:ͽ}GJCKso1 ec-0Y4t" "?R?O6KoTSu_:>W+CU3Kom%bFx&Wh9]0p9k$ԝB~3%my1~HZn 1 D-eQqYO!(sb9 <"'Tx;$X,mfAQ1_ӟ:yaH)wOcmhZT{] n;o)ss.y\8A"@F#z8Awl?+$-f83;v{34OrJ@K[p|Q588ܵ.Ƌm_HL'ŨiܶjcL%KmX4z:!_P	n^$7GKI-))BR"_qx?V(L.9Le7+dLp[R)CeP%#ԅ?XQl^xP!jʧ,I|ubSr%Q3>;AC8P.D|a8t(Ra	Gd
6|s9L]6S/G~faHge߆CyuZ5MK:@qXcJ9}3BޞK@p"\U2'P=Fp"L@ǄB:@F:C˷?W`Tf>T4{Ӈ$SaH	gεG~1Oeil-x{$z3$AntbNqJ߬ !d1u=˷/5v!I10<WLpt9'Rk":Ve`1Ѳj>3s34AɈq	4Qg-93OjCt;}`r (.{S !lWj?axC/W{9B2i8>ǪqUqj~ "#(Of', ZS,9ܫnιHj_	:l] Ia礹S1ttۧלbWY?"Hw	پ[Tѹ|yQnH"TDļ3p(!v04)$y aj{nEjq"A0P>{0ߒ3]`o+7Bbg(mFFzs-9 5gt>V8oՊIם=w/p6Cydl2YoZ%V6:Y5:&` ɑsNѝZ
w>%sng)s!7nsY_;J<<2?zxYÙ@&ٟfRBq%W.֏VVV㚹'2h)ŮO- p{p5UV<]f;.caH-i|m%7XTVXSӞ{_4YY'Fdّ=*a|+sLvSSV9$=??az}MmH}_*r<T+ʛ4K`!)uPo>Ɣ(B.POϢ+2-=>R)XXz(!]Gt$	8SA%Þe9Vaq9xe+3Cc
&{ӎKyݛqUr!hh)"X3N#~ Ry
	`/k\,sw~(hg]#]_F?ahIefr Tb?OO}w0kK߳]8Gnm~ۥeyaAfR	.WҌ`;W&ƃgM&x{D 2<;ӱ)J_(j-$FU#5;,:b	@xK\wve3:3Fd1nV.26x!J_^^T0τrԸ|HȺf12)glKoy'EwIg^:rIsaՋi7ي:ǡEvAaN7NѰg^Kn멉9{È(kĤ(NPGfPm?ՑͿd5P՞CưH!Z:A:E(;$FqJƄSL%4+\T2dP+x-@&hqJmҧUEԞ &- ~w̥Jh]K<VL*`2M8okMn{bCsZcteٯ'r\~0E`Li-Gd5%IS:f- o8X=E;p%Kg^MĉFC*Ӂ5l2j\
Y@j/^#MhQi1c!a]4.Bj=p^S:"eW3f 1I,9Zc7ϵha?Aum	EA
St[娽쓐cOΜ՝qs+e&T W}NN`B=qEEA4c^0@B`G@/exo>Dd	KbUPދK|TK#Ykc4|NA\uͶCRb?Tߔ5Ŏ/bf~N.?E?nW̻lfgo!xX$Q`P|Q	@uq$!Vح0"(mxLGKw`Ht$ hDD(X6t/HP
`$Z=Mw.?uc[qW%^#ͼYWgװ{jYNu^߱dMT)r /"K|ņ*_]`Cv@(5]C?Fgr8_,GTY=[2#ߵw82/?gKhHXץwͮq)it<FZ\W!}r/=n+גQ΂{8Ab?2q:w&ɇɗu0+Y*"v!O<"j6ct
MW$=|vºI;+D>\[­KKSYc-g
`L<9TP&O+˨E8M51*܆DRxLAk2 4HWMw/#R"^RNT	Fq͛%=h~yZN뭂ܾ(z5.BHbÏI_˃Waf8Wd[IaakwNsGw)ݧܾɫWc?>_QSsnn>:!m[arkMSOpKkv,T1vzƛ,juPRT/zTnJT"(ʵYjUDDUT6+{{W?2K*+o\x"쎙}P8WY1zCtw(123gɺC9㠶Z_Q]Mi'윣6R;7SlYxGK='/7޽`,DIID%D 0(B	BIWo\R>Wu?M׽m31>)*R2R@i4wDX Cf`KAEHH+2T۳|SzfJ:C;ϝm#;R(EZN3&Ү[q^"pEHȷuWgF3b&nZńg(q?N=Kh2/7˓ު/Ep3JzOGmT߻%[߯ˇ:^ߤ&Tc.^.\8 )E[%LZ]+U)~VK=׆yKTSqrX_Kw]g&{U/JQٞ\6Y~]O}">İ|#3!O|놽ǘ^+LB!s}ܭ'~|" xT- P/@.^WsoUmܗc~5i棩{Az] vEfXU.\D`PtVyhn;43{b/Wt5fJ"!ƳaU!Lg
EnKV^ ;.sEZމrPv$B(i<URpL0,TZ fD*F ƺڈ^28lOb;b;]gnպP-ZKVzGFՏDgl&t9D	R]ِ@w4WPfneH-3@֡D0Newe淹{=Ӆl)
Rӓ&ULiWCw#xKs!Z*f!|;SRi@j2Q9Zh$&	jӾhx>{KNdҀHΎJarœ5>##:)׈$ ,Eҋ3FِI!'&2 ODO(r;:,G!$ՐbE?ǯ*<=QOmTӘ ~Lm,pZrh[qe>ᘅ
^lcnfE?@EG19y@@.^UIb=REETtkWbW]4?oأ,

}'#-9z^[mN(,bC.&p[y
PZ>7vzy쯶'|h@1J*#۸rm2w{/l=$|ޫ8Icasxw_;Ix[PwKáyξRډk5aҍ8)O*<K_IOiL7|o7lnog7\w0eEx@]ֻǡ8ySpP9]рjoIomo۹Z._@`Y;dX`09Jyҽb+]_;WlfګB3nOG^ˢJ0aV;O@γ?qAu'tw}k4P>Qm~w.}!":̣p^7W94s+K"lVXuяIK?lIO&6-Yå@SqnD	OCPVa2,a`4.EA|ZIj1$^/Uo_s;|2Z325PkǨqr1I _pl11	ን|Irl߽'Dcݱ<aU:w(o*GjՅbu|\v> שyFp`26%:_L4S-+ƺ85r4X HOD٬FLΌ?*ʿ_ug4OЬW\o1&dPMHU=i-,9ǎqUh\n5S?km]ɰR:bmrL\[EF4U}b]9lnw*ǾcWaAZA{Y{׾[(;$N(V;(	 G*TU_qQNU.nM9ؿX_
ԨRpeh*`>+GgG}C9oEfU AެIr%8J(ksU7fµqr:k`1=n9hĻxLz}_OcSf03:gysw!7?t~KY͎7ۻU-븫޹y~?ۆ|ȯP>6ɿN/-~<))gl/T f^OÌƕHk
V$b;5wt^UCmP0;hYWB)>i<i1# 4GZg;͂(xMǜsuTt4k}IU[˟w>g[q[Nʰ?0f{Wy*G]wzr!U]MG:l{"b?6 YZSoj`:dê?k8	E7uyڱ@n$<ix \L3NK@j.]AG_t_QH9T$.ä*bҨrV39n,SrMElKVzj\G9Ә]I%ͦW *=jSfs{1$t'9՜6dPaMb4׵/6#I5lD׳}a~_А7ChSC=JVJ[?0czJp,7ұmS?=w|XЃK,$jNыli6QHNBiaϊt"p$:5ʂZrTraQ(@IĮ]3a["<i#Y)k"T\q
6Zck@!Qł"(5Si*a]dv]albf2l8?K=J~޿KnNa\xw[Y_oڍgP, &4)%\xPg9`~O"R޼p(ͯO\߰rzsU9kŐ-As1U9:PD?LqAϐu<vqG$`p`eI?J@,K[0]4x *`@Ξg<p8Ә ੉ǚr@ӫad;ǗK-L(H=7ov̯nEZ[J3?9qIhr{z|RHvv_"LcQsP(shj)NuJ#N`_?
pPx,Ze
XNGD뤜b}DJWjB+v|U{p^\DWe7Y^kcbNU)-3BdqC=o7azQ|ʵDr[tlTFfZڒۭ\2 -d5JPj;^֍ց`|z`dZ3;\YR6sUXt=ܼosǝ2@E'g!}kiH!;r֬)Pxl6uU(c\~)SV%dyJ#lkgJy+ۗBp6JyzޟKQтKs{vg $mO5o 	/iGnH=܎q}Ɉ
?7+iԝ4l$rbJ.r!.{սSboB?W{;ִf;?mq5ÚI1NHV]6]e-ȵadG<E|n~g~gC*Bs>Y~hl1ea?S~oS\USl>jR@ sB?GӀlmZ<F"I>Xd 1j& 3?{fTY},yO^|Rnqn6U[ryn_f|>'q9I3>aw}?o*{Nm1tXμ^W3ٗ1j8jT"-r\'\xDeL}Oc_I+	S{1Ǳ
+3p.,
fiU{U(6%< G`(E.hsxXӟl]Y3yga.:1O=;^db7fIgҋENL[xĚ*یTJ~"jķ]ІX;9:fsYEW-Pʏa}k({#{wXRێeq*̥9k7-yӺ	 \kʜ6VEkO]sќ lH8y_dhШ!VxSgD'1#%vy}`ٺ/f݀KX
k}JCw6C=TΜI!Vd0ճ욁eX.Y%05pGn^Vi΄(Ay6_V#8y8;3AO!@ŴDsT!ǗTxgH2:נhP5mFI6ib
-axF"PsBr
HE5*RϏ4C#ҿZHDԕtܕEE5:xMFPK)[u4>	UGic"UJ
pAxK:">nB.|HFX~%1M|:>粿Cy`JjCm̍tvz0a1C肣^76C2[`o;
LSiuue(M#9SwVJ?D`6kܥYfPG!y.	GLmEqm=g\{̨By,0-?9ߩWzT8jړC&+,*}YPz̤R E΀ueq3&\x/ߪ3_ץ"ifavsT9N?U=zMּKa飔D/53_qXRÕ{SM!d\G/_}b(oƺOxWʠ.ydT[˙,ʿf4Zм/sTc˵#{JoVjZ]ð)[Yw쪨5po"7A,,{/4z翾n{m*5 -:X\NϢ O*?券y\鯘;_,ܜbd[khaGìu- F	D DF(",F
bH
E"HX*7snf4s@$|Dtթo'ϓxF=]v\zJ_%JW#%{&sYf9V9繅NvY>>kt#WfވeXGɹՙ mk9H;o[HɄ,~nPrt7<>oE50VcBr)]$6Q/جP-RsW yn5bX``WEiw+Zp,Wx~\B.uW&ݏ@,gR窮+̵LZ<oI=WCYlߺ-Ƌ3G0^n{p~ؼzgMhz_櫁y?ǃ<o9o;.+)};X/mNnv	t/.EvҼƇ&J|
p5<1VQp!klTdD8v<yhb]Nd:hЪ {+,2Mqb4Gou"~Oz5=SZu*(r_U6طPL1Nj9 ,[ym%>Ec;0fm,^glW?y?}!Bm"ZuB}^F.zʻS[ґ_M_nk~U v744%DJc%ndF`pfau QdNS#ɄBivwkbxK.gG_r]ViX|a"
Ga`i^G&P&E'R3Ff2|hN+9)~(m/fΤd(G,w7v=u]d
Pxn+ Q=pGk`,pI*V!T5%}`}fVKq6tvm4k'>ۂZ4ial4]g@)d^#9='Gvsǋۤ^m-~*#2
>RN&<NyR	N_Þ,m˷rܬQ_=5nZGҨdO\7{Rzs"B	mo8ØWG'?
:9d6~ќG!^ p!w	Y~OOy<$YUͅ=	<^D<
#s:{
%O#h5@nmެp@f_Ȱ36TL+?at;CL0Kmg3);_gjo9t{[A0$?U,/eS;eVM^ʇ4vU0Ve;Xܢjy2>)2@^*l$#GIS'rXZ٫2$4z;I~L-C;l##?\	kM_֒TFÛ_}4x
zX3Z;U- J0 0;rźۤZe:
ݴqmA0Sߢlzie0ad=8+gC~8V DpqiVH{<RܳpF'kMqb[UAtTAIkIYkf;	&9j5<C̶.sD/AGگU6RΊT5$?W}lM<h4p5k&UwQw]CO 
	PMkWp5}mk>{I/E]v׻8>Cqjwzigb@"GYeb6k85Wey8j=Ignk==?SG_	}]r{=}J^lz*s-9'jGTg|Ds	7NISη:b.#3EI$ZV%n䖲G7O_8o{~cڽZXYYTwvΪϫvӂ@X#^^\f|]R1ӏ{`jŧ8u׼:S1$_/bwuwc|?]}?t+yYurSyu#95PsS:_XӾa.}Ú_!c$ ~@٘b	DH$fcQ^T{x*b[̵c'>,׏8G0˄9y`Pw0F+nXK*V,Y,.MQ'Ȳs[em*}zL&OoMԧN	^-6f;^Z@j.q(c8_߫^>Fs:1Q-ю~7OUK-2(꒛l E?i\w֓ʉR6KF(fEr?cd6&{9$HThvy"A;nBd
C'Q|7i:qO!Cj	,`Q=ueIR5ժXvL~h{ߥF)⢹pgCQI9\rMμN?WتLʏM<0ifZ΅ $Ŀnlc&5d $OkQѤ-I1o8 U!H:/_4ގFH9mQWFǛ҇z+Qkj&{wOÿ*9FŒ#VCUݪC҆#((Ķ3է-ʞ[:2⣲av>qg94)Fi9i-WL1/'鰭i~;oL8Zgv\G6YϤz+8>QOؘ؞m#{RN=㿼{WRI;w:!	BJی%n}TW]\u6i/Kj5_[;;)}IO(cS(5O!?2*q'?@狶Z{һo=CΦ~"* :Τ6ڣp?vtRM׿Ȩ	`@"G7".3rI15ԖG/jDq/]G6$5߹`zO[X6c{S6D%L<)΄r7Vن s@ .fԲ؝QRZzXwh?ܖmS&,bk2 #×}}Cװo9! 	z8:3Z*f!:y<$u(f@=j9<qJ  @B5M8 (c/_D5g1N%Ph[j&[	Y,ݍ_vvo?roZA QH5/J3yA&GKz{^犼B7;\c2?VN_"C[ݳTB{Cn?ğA	`qWGC?ꛆp1q	IC&pn-w;4oPRzR.bc`*E}:NVy3N𪙢3`
4Jba2wئ\^.gN6ʃo[ea ЈXe2ְkș!#|OqshWxP?F>vs xwt9q| Sy%U7`VJWW~R%v	ZS{U@yPƄ#ˏnf
:B%CZB8f#ɘ3u_r{$)`Ne*Lg0YI 3	 Ҡ6SłpQ.itVl
k"}9='䣠ލRF.i[ܠ>@=0.:DMͲhT)%9\pu$gK"P	qty-(w*b*	P9hzvܾsO(çnpx]wb{P"9F(hϿ< $0"q>A~GĖb\TmŁÔ+?/es}H	BbDZyu˲;&"F"Df0QxQO.BO?G 0c&rA_m'`[<g`XrxZ'V [e숻{ھ\-}UW~_NCv.0VgŤ=~^O;kڥl{n{hC_R*ߣV;|ء"c{kclMJ\u|U-6JV>MU̔N!gcH|F|DLNK)鰖qdFl~#ԩlV#9_M_5P:o:~t'UR7KY5ɔ C39LɜT|0Xy؇^zs=q$UG5(>>Ɂq(OfmIg9/]%;Py``Âc\1ĕF*.?nϊ嗙"3r~nfKν]Э.Utr]{%/
`QxkeǚRϕg=^Cǲ9M# }ue*:ADwh$`ifYbNRGϲ'fD.FF[Wk=-6Q؃
AsQP3e0p\~*G=d@66Xkب5)T൲rqJ=#Fȃ2r^
p]ƞ~C"2b
v`>Ǧf\A(c.I!xsOa8м׸
/EF<9N[l
r3%Zk$8`!Uk.㶃ijs Nڭk)WS~(vR5WF/=zzە:Lk<ضV)r)S5`Do2<RA2N,.KoxbpXK2EM8bJz͍٭:<ʖf#1zk-5<d꡵WZ8H9[!+:{%;+IsA`}<ld+hLs-"%6XOX7l?1ws|M%2u+5 *Hm*H17 *9®̜uMzuN%F!#nCB|D
@F/{P%)rgO|h$#4DaY
#FF&8@)푦
wbTe{ZWdN't_NV[ȋZzE"8;o6-@QJym1SlB=ч#uLʚ6Ȝ~:r^MLSzsx;c73WkMаpyiZWz4w},0lx',mvu6-AaFiǺ>e#hts 'ç`AD08G3qؔ
([Am=3ɏmArÞ}FS[{7ȄJ׽ehyGA'1^-GZ/AVcX9Nv,Why5:vcOTzHC jyjZ%jPm7Fr":ck1Hxq]^`()lI3$ZB}o?NF`:6a.z\Uߑ#ŋ_&OQU~UA$]m %U[uA}eK֦&4$gV"?Q-
C3_{#d)3Ec/Ri'={
pѺ&/E3r9ZD.wge^ϐjjH7ÒUഁO^'an1v&v62ePx1dW¡ u[͎җѨ[>uE#q[ԵFԅUʔ$|ELcK> C󐡯m=*6>6ҋP;9m
M
v k̥hU+Q
0+BKL&WljD{{lWaοZĕLn8X'$"ss>sv*x..fN>jj'φXz}q}uf;lg[rGK_ڿts%pz}ƪr~p{\ᾃe-Uwڳ깼n7=r
ʜa=+QW]{=~~u=>Sҡ~ !.F!
b#m;$v~騠5@E+h%D vS#z7 3o$>'Px`sx-.)H|M_)`T.ԤzCau{UU_ɻCϱCQdzY-kNF$Lk%8x
܅)["R
t\`b	[Q")ˇ!;*Wmܕ[nKFIa>MlFEGyd7FؗӋ}$fу6:_mgF.ۮhptx2񛊭ƛ#ebwJTg_JiKTM$5f U`BB[O2ZUbhb&IV_Zf;~jrzLQްs7J&])'˟V]X YO7O(qt(Ki&$P G!ՊF 7ADҩ
^;d˹ 3A).-X̴@PHyF8y&jYTNh7CQ
QMbf4s?ˏ:ha?otoC		ΝN9ǾS}06j"VB@t7qExAQ蝀j@J^xQn:O__^Ln~xIZfr6/`9hd+ZB¡]]7I۸OPts*e;tJ><yd]=mbUFfr?е|=՚un:ݙM%Yy
59wHGn\$/:|;Г@'M]EGiշĺ$O./T܄GfT:G*eJ=lXw87 Ȃ0Ţr&R'Jv+m6q^j	d-(h0Kel&7Qݳ41$dp1V}bZ$ !>IUUS벺ź{XZY9dyT.u^#tk7wYBe^ȹXASmZ^TO5fQߟݎ`Hը5~a!9I<Ԭ@7WC;Ycr	$ "M	LU	ۏi﻽;_ߏ76C(\|4LNVuC!XWmL͓-T"mF[:˳A6zG,}8>ϣ7h%l_uՑB\s]ZڊjSn&b3b;@".ք*vE.|(w
C``s37zY~Y_6/Q縟=K\-W7枣u~˶V(TU{z녳5<Ao~\?uUm:~oמ|'lYw?c7{xnS5}UϤ}ڗkʛ\Hi(D	
K^q9ӃN;@$4:~w^z<ar8Md9n^So&Dh_}KS5OR#|m(7/T42#ASMT0YqOa**^Pт;:k#6Ysh__֗WQv,qBZ)vR<6,dSeyV\gI0W%jWf=>1溊k&NSk,N%VfYdf:&6pGj'@D-u"V업d8Cl*Nz;Z}5L(%`#znɬFvlBfx}T2Z!_yΪaD,EKmD
sYV#6:ʫ/`hތi:_ۉ%T`hҘ[/b\2RfF|	!
R1Sh:!Cp̷hee%D}csAf$1ooLs~ww,r2}4II6[Ҩ+k訂ou:43d՝[F< Gϲ(
x$wN1]tԌ:0zȨoCEy]htc!L*fّcUTC@1¸ҩkh4^|f"N85 d V{q_V!s>yepul|~rBguM7V[l`PV?93ck+C룎;
 Q!,~P7CMoxVuz[%Adlw.e'](< C9<BҸ]=
maP?U!vZG}: r=6}yP\p!ҟ*SuwIsUr^?6/=QawJF9K`&LA΂	D~(
Md#7/7{Sg$FJͯůO
AD޵w8 kq0@siܼesvZ-H	?X!5usWXIl{GWlwgU}T.={T<^#57_x5y^3󕭯.ݿiKapF-Ҳj/oU~ޗ[2yco1b>s6|,Z&CḢ34/Śn_{Jw|:/[rgV)\]6hlƫv)+&QFk<n(@koy߾ǞSqI.~a>ce|~Ye5uN'п[a|ne~lU,턨\`[a>}#oe.v/MwuzS[u>=kr;M6[r`{`5m:ȸExؓ_^aqAztYSBOCq侽/iތz:yw/zkT]C2daޜ"JUҚRu>DlR
R@+EoVg&`ٚ6uH,lh)yD,eyΏp$=F1Bf9z!!#0=	CCQB:L h@h`
.P>^Qߊ_UmUSeD.C.;&-H=H+sBꡰt)$N_ƊJz ٳIwȟR/'2p"$}X7?;jWyUj+5/Wn ah9Д%]v_{W֋~GqI]_7E E0r	lNuEIv?i:=96~"+*<</iy)߯l=v7=18Q`*Bߍ2b	H"օL7Z_Ezj$L"z1J{s+2;d]m?~`>?`
Jz#Z?DZ~o:eeSF"XCFrVݩ`h3.&7E?K0d-?Y	ΐu+
{?V*MY.p~*eOb"y1OZ֎r^[Bc>.e׺2oomx+Oӌ+Y)9h}g;m̂;[V]
(-}"P)
tPsjܤ۲6CoG5嗐ۺұ9ɻd^ٛsöYii >Z8/xC8GO٤xuwv<3V'2۫Ux}rl^bɦ^v^ɟ*aVgt<7k5}7%Ehu_&u+/ce'X\ -.s~}?˨#h[%\P\~c%\$`|+) 3F
0j%U3R=p)_YNOqN/:=9V>^]x!	^].=a0N_-b9'sѡ;b_jh.c-s߫=#okTZ:v1W(L>?	/mF7:*i}1rï2C,;BM~0*Tb-SUu"˂йT6jy׆E*K~#Hy
:i;X7GF!ĉyds~Ц7
mYɢ}!&C	ΨGți		7P>@e|BXiBXyYBr@^hvy+oV)O$RCtة<	!6l@bu-`?)D$=ؐyڔ̚daBFdꥋ?7߄,)AK)Y懋}}fU_ʸwR7-*5iNu$eNtOz;M!FPƧojCPP2P Ug./PU/خeLӬ.3/llJ<TD~i5l?[c c).WdؾK-*p>5PlD09GX #Jǣua+Ls/cTw?xҞ.{5ɝ_鵵GdEmMa	d c%X 	}-8?M˽z˘:w|߷?|7k힌ê)^Mu-ے2xݗ;mfh"N;Z"
ŉc"   !^ӏn˄ٴ-pfE`;v~Ƽ̱cw񇈄 .~I x!!
$ JB"OxF
cg͕}ܘEvq`tEj{9 )V.ɥ{0س3|fYks(qLF5{/wi41&M }Z D8JAm6af.QZ;2x~zc"hrw o«NKo
e"1='.U=7i
,1},EEDUxڦUV֥Dhuq{}+83śuV	eb^$)gn  *=;LTPD""x഍F)k
7)黌Yu	7VCȞcI"tSh{cyow}N=p#7e*G'֊~")
#Q(mNH`.[@nT",NUtIggW4+Y+Oac8LB6ќ=	t9~MŏU$Ar㤣Ukq]MݦKJܱ[{JJ9JphT+0ٽbmZx0~17Ǜ.ɲYUb.8ٱԼXlJ9k'h}KNe54\t.{EϏSa>(vu+nM] -8Yquoz/ɛ׿^*sdE-˵]](70@cSXy՚nzphjJ#!)">,Eb1xzfU+Ŵ؋R)Q::?e%X3*8ZqiVF 3c?@iOt 8u3<MpH8nۇG$0Hi!	gӈj@-.K!+-ZyNpC1l/chMG$Τ.seA~tf㼽ߌӆȷЏs*N:Z*ʮx& 
`aUL?(yd6 JsɅۦ|Q}'"	دBGAqYmza_JQ[.{bxPBYHTߕ-٘M6
{Y@eML밙&˶Hz_/ݢ9d=#OT/.$~KIdCCOr=ިڤ(<Bw@K4g]>?``l)oav:\|[O??%ʛMϲLW`nsXR:,9j о2T';人8Wl~G.Nv
kǦ}ee΍H2Oey hB|-X?3+e٬spHjGn+ZQ_w+:<h_Q75B׀I  eUes}vٳd`Y|g7gvq}_>MQ\<${B pd~N㷲(\S?y2)MC6mPx\_EZ>#3~9G@qIۑsQ*~Wg^G>4[+eP@g}:"d&{ܯ+Wv1]N7K\<DQxˬ8
zc䢮ǟ2[ʷHl]a*xDM:=[$v@ť<Yyx8by9)gBzIKْ7_k	Ƶ}n9Pᢘjg|mt=fžZś^|G 	9<D;i>N75&Ll=WΛĬ3t7[Zgk1c`UXWx
SnCmuRmk-UU^e@!W<7h
'Rp~qY#]%U~5D&k|k8+箟Cl qEtzWOPy~m[_nC9nWjQIӺo7G<t23|(Ty+dgIIG5-IɼZoBP$3Fž	fn=U ubI;ߠ~=pJ>5TGf'8Rc'f
/
{yʯDOަ!G?ΒPYc"NŽᮩP;qOYcᲮg>T;D*< a=% M7>5R,ū5ҷʍz1[vg{u/"{<2akH_ƫOЗl#$S597m{q2Q@G%cA;1Zױy=E7fɶY& F9;7C;I?ھ؈Oeď>+آE%=\MYa6av5>)HS0e1J&ggpU)qcI)+Dhl5CP榘p|xQdtsA1ٳtj?+8
+?r%0,f$A=L-#ELo[e6\H 5)X-m[lu
hVڊ@5J"P^_iyJ8"PT"I(ܮSӚdpZPWu.ر7*'',Zʢ<M`؈g4
Rxݽ)|%Pd(8	KAH-Y~޿q[-~zJXi.Vl;uNgUUp%ս`_&n%l:,gCVlH9m'H5-afaگhr}첛قo| 1xn.n~&\cӺhn>q@@3q%h=)'gh=?Zm2|mա--^:pV P_xe˫ֿ"Өgq?xc#<2y)aJ7zd'v]g1;Y-5' Wd_>ЯahaYuˆC.!]@CqAoK^%dĳz?D*ڟA$2{Mt0 /MsU]WEI bC33~kq?zbUyI[<dLȝ|/Kܞ٫ҟ8 WT?cu.vx~L(',-uqH<riܯGatvrOĭ=j5`ڼ`呕!8ݣ#0*O ¡t%U0hjft"B^-oAw~2>1إ?'h0|4ڏ"uvU/0sJJسFލ4gҩ@4;Ǎ{~VcnzUx}eF="T'|t
b14*"*YCbyȊF*"(|>s#3 fuw>RrpD._ODg
whM1
ĢRb
)5f?쵉UZ}Wwc([~/qU׆&s9*ǃ}q/?̇tOQ9wgONc?ǳ~OSY+=Zs7;P(cAlf+PɩT.5@`,B}TT1j'z:.ЊUL}uDJF.iߏ yWϏG#q0:Eo6˱zsn/fͲ4Bu~;i=GJ(~(')!y8z?
/mCę,K3_if_((vI-m_<X{	2Q6~!p)~92lO~-|G%2&V5AgG0}=*Êg4V@ !^Q2Tls1C=<GԀbI/JKxkfl6eRF,3C٤ڝJ)G0YֽAjZ,GgN2uUo'jщaf)YͳvȒxO}h&jvlRP;R[]5;>ԅXMe]АHS:ViDŽT _oH?9;*,q0g ^;Am,r^.BCtT`
D(>OT1_RDG?zy>__yu~o4}:d'pHatbALU?&eɴ'E֔D[\`T@u%}`~XP6:g:KhEۡ.{%ҡ 1NʕpBBf|{w%E7VpGG8ԭOkM2HlDgR٦"u-}X` 	/(H@!vmn[}IO~=ǚpqTz볖83vU|4Gy=e`^E9	A~Dv-j3N`VWo)c朰KcEkoĔ{\WKO>e`roh wrņ+JzrG(pEY	]+04X$ WkeVS~R+,:.ajL`\]z7e~'+Kإh-9=t/ހ?kզbH~ \
UP5U2gCnce _w%y8.]ˉ 9en3̞\[ŁH1#YWb?9?FهЏS{12+*c'8Pނm0C'kM}#B
X9&uħA>uv-X,iEJAh"X,>0`qe?3y+sxM3@p#
ղ}֙ZKD!݀s"$K݃Qj@C9wuc*"6˥NѼ+1Ç!>AuFBՊ='º)i;pڶQ0CbTtόg#-rײ*Ώ~^v6)̇WmX|W/[ƑývϚLV,TW:6;r1Q^>Kϑ%#.YZ`,>ٚ}2,܌=ܦ4V߲aY7	cjpu#\˼Wkbq\U~?>G)r6kVWY\YfUz]t\.|;=Cssߓr~<U'A_Cqa>}Vc7dDomdV'A̳p4ieĄs,!bHmD&:[X]Ö
o)9#"')`2]$V~8=g9xnqlU|se6V(II rPҝ<*C
(HJ ?܊n91(Xؤ[l	ȸ|0a&rIRȗCrgzm;nSE#!\'ĺZ8W4_	c1做م^2!Nطκ@_hDGloRNμԿ+6e;[Vx{74Ow;IpCzhGGut}gBߺ+3݁B)!&}wƫWGuK97, bxY\O)XD@dHq.@ Wa٭]r3h.I G~WSgD#_UP:zxj6LRi\C,8ey(xVD%}Ul=Ϣ	Hp^z 0շK12sh @W^^RZWlhe=}vLEЄWoCRH>R15]_V,nKX韯L&CG3~&?i'x\]-%zQ.
黰౻'yVA74Pj䑺X`a{}nW> 
	@ѱf/>٬Uk1JA+j8@UCw!H "`3O٫&C\ߟƸ=9#[; =vΩQN[}l>`3K6
Z](+ôEf.S<uqv!W\·$4EzMes#,kzLBJ (~+]{tJdWE_q:2oK%Aň8nVaB.h/t;|Mg^	7YDC6I@(1 |ysO}. 3˥upzs8]RK_[PrZz<M._sW^O;H|?*y	kTFanal"	#*D~֛azێJO9:~߳yv3%19,?޿C{Bx7[
kz>螵T'A}vJ}S~5CX?cӼuh#N^D>ϫ")釣=|t!9TCU>zjFi??֙&/@jMh&ɗ}	IiǑ?.,YzK	pb<ω$zaF`Zm4hz0x"`Bu#dVf	'>$9ӂ"k5Bxuǒk18UǸ,8FsF|S?K~cat$z<1`}fsZ!n=i,Mzqi.*slPE#<AzPӛ]slVA2PwZB1p'+m'2i`k5ܲIrhgwL՝{)4k1c!Sq[ñm9\fss		'Dܡ6d$t4#
y=TZ<h}ہ%V ew%J+Po\[m!.Lo(#X<sE(@k7!oD A,`G\fPKza
QXk0BфD@\ۋyPZaTmDS:q)cwz|?DY @,Q'*#*3cƤ;ʖg)JRe"ec+iᴎFur"9e
YSXt!+uB7!MClY>)o)dg`~l,>ŊG4mYZzX~eT3ܿk$+?RM@Wc\hR8"m*LGAD!?~`[}6S9_vrlAs'+3:Q"WE.#/~;^gx[{-Bb 3ȥ轋5h;xp+̿nl@ +c"-g8-kEtU~ĩMW;ǄQe7ki1usy޲_ǡ\#I?#YE;fĠ171oeSTR_ӹ{}^njfK
KWw,匶*o%*~ܕ>RPOoKY^%	l\v獓QiH8pѾx[N<
O](Ax3(Q-<3vOH]Gu2ݺ/yENjEMɳl
dk_ܭ6pf6J_/'j՝JPn;S^^۬uǙv>X8;ool_o</n]B >OQ+DϿ`8}lO|5|&V<LLڭ2+x*=k|˶
gzȘW1`ޅvk'z,qPO)Y챞\|ѱnnW^^}Y4|	q]Qhcu2r)3`Vk9yO~۱3eAc`99bz+oUOlͣ?^M BA8SKPl9j) JшMmyCh=/\.4bl%ϻՠ#`(&ZEAfFB8A"Q1A$;߄
?ӕ<UUZ#GX(Ѡ#T"BuJo6U~#p:m
V:DA^z1, A/6ET
`;P7?XU8pANYsOLC2njGo.?ԊQ8<5/oCo<5x5h?TM5{4fHΩ6R0nRmQp>XHfԉQRqMlLP 9`htoی"HyOfM7#OWCczGfΕp3V`[A0tRzRX=1«_qkʡNO>{AP5Z޹o\_uqt׋ V7q2JFv⤖^]7vF!]|i!kSR65ZU+o?ߎB~XIޝ=p>.t5ߥ,f$C	W-vrKi@p+|Z @D>.ʉ^t'ްD41MOov|'^^)vj@uW'SPnڢEg DL⯲\FMQ`Nic^jށch88įr祸pӕNۡ\
^՟^|@T)Aru]_¯.gOTK}B޳?aOy;}(ݝKgO0Y_o{	pA6Y}ў| "#El\ڳJZxo{z?|Z]{[5=aP].2}w"N~^_ٗayN]xO]z^_K\l\1b5Ei#@p$Ok9)J %ݫ?KoEgFfdd/j{t<=Z-mZ.M,=GɆVnwGr>[rWbVbD3:mMDu/Zs*40xOINRBiFf<Y2UYj'
VB+DClJd(K	7bI\(D Oeb(4
Ɠ>4gYsI&zf:y"(9>:g
38bWROĻdь nVò:\$fB|Q^H40LHD_ Ta&.GUTCShO`RW5D
Zi5ËL:7+0lys703~n~_,57hp'	CHu;>t w2MKuk%LΧG^7v8̗+A_d_zծA$)QB7Fu{'no&||Y2yx@Yw9g^fǅl0*"N
)}rqt1Kuv8s%P"͗Aj>5׭wkcb{*녭,T\<8G>}>i'|+{)TV$aB	H~5:2}YP "$)|[,Q0^wF3qHAL*Ta/냻FJޟScXe?ړ/H<~M{7vJtc_xJCք6ZK=ۯjvWrFM6]B&m[jWAr[$H>@{hlaPNYϫEhv/7<ǘM|^ժD}^m萯Tߒ~aqska<WF pi{5n&=mL6,Κ(d$C;AWZ?Cv:|+??kz9	p?{-czoaoh{!퟽jwOmCGC(t,?++{	GNIz:OO)~Sx0)Wa:X#2pqk+~<W?>k7։w~}$3;v^C=bSnޭ##6j*uZgg%-⮈l M`7HIzw'Mܣf(@oeF5-~onrj@rtZNKc~ũZx/ղx-tpT$N>>~gI6lS*9=vwvIl(vñY/d+;\Hlv2^ΥRZQ0w_ۺT_n5Hl\*o+5_;鰳po{"N!t
ذ-+/=*N*C&]%a5!cp,Y2Ny~`@Kf
ԏܱp]hr(%B)q֜Ozy^%!*E欲/1֖9βMa)ݖqوxQ|U7>1'uw0u]XmIriK9kxL;HVVz)B|0^.cSQ#Rmr<˛+XsޤZ *i4<SVckx`zKx!aɄ-<*ha at֢=ؔڡ։Qw ( a1ņMS/}RE:EgKS(EQ2LG6tA=ߍ9_7k[>-dE_YiOlXVOa?iۦ<9]e{~ǳps.2_S~p_t9>.71Oӽx7~JRy=b%YyQŮ"($ܠV9Ff~?6AN<.*<s ecjQCom)Yvץ>9(쬺	M(V"*Ic3	NeiKcL2^;	7ŕ566io/cn.콱e6Vg*,nZsPPRFFM$聬0񎘖?4h`Xp%.6^Lx@b`Q&=BFU4|bN~`đWz:!KtW|L@琢MZ.J7QHӼ	i  #LYC4~+u|4j}C[ _Z+t<ڀ>Nrc},5PP	QkmWG5ѼY txdP)t@~5|`Ũ3<@pӝ=;G}V?v_ԠFxng6</zi՜vv}fy]0LezHGބ[gW1*?/VYdlUQ!z U<`b "6zl>IӺoê38|r1l
|ɇR;~Ƒ 9,e	=8P`!ׁ@@>dq*ي]IXw~G<um[:pP#%t$D;S(R~ wm^4h_yuHG_)'J}]'r8Xg
3[  cV[yll%9e_o_}א`{N$m8uΕ>:o;;x~sʶ%Cl.X&!օ©uf<b(/wXri[ﬥkoVOӷUW^xP\|fGkt)'_hr+'o^짯_4}ˤK9S=*9ZT~6-}	`&l%fooZԂzCih1;U:ܹvEٹ٧PWũ&O,40uݸ>&E*xz~%kL
3Jla<^%ӍR{p\ۂXxKj'߱ƣR9kddkf|qKZZ-@Y(LЪ{Qf!<qm'ɿs*m2ņɨyna
k7AZ3Eci-RG CEl.#+%lʹ`Qw/MvHpfi%1W)FG2oSK`wxDߡzUWϙZȽ8Z'.Zj~jX"s&Zx)ھ{e;1o@
P !DO;A" 
}Q D3gN]}՟	TLKzmĿ5ISBz0e*B3dhNs7/.+Z<NHj
2~XxoJA7oZd&0vd2Q?>} s.ĭ'eO2hz+7
TlA_ęhXV4'Wa{^|}r*#:zs|>ہl`c֚ޏLk(Ԍ7gfezn$ǋx_g}w5~ת:aY@
dY"2*,W';~fv#o2d۵XzϳIZ(cՉ[`~6A໴+^Tʽ'T@zk1.]$>sΙd*ɇW7颶74$@B˔<ynyH_eQ_TGhRU':6RvN}wmzٮ_lo"w﮸~H
?jW:\
Q~,L^SWWbTGј/c WqF0N.2W+Z+YWw+iW-{S(O3@7YyG	d;xƶ4ݏt?<5s	Mu.7M>"Y]h]jO9C K
ShFG<o%zBZ㕧VС6?Qwݭ~:s~a|Q`\NeZ9:arη>,r)?" @JʬږIh	@u\cQ5TݑFgU@=	jkԐ&:}%QЂe^pSU@\@YDoҐLꀴ'WhU0@qb!A9=&I_o :ldQ|$E󗂘;(B5XA\(vm .f ދGB_o8@U@h\@󿜊ߘ,_vGC AQh9}KWվ}~go_υJ(?Az'Ϭg9R[·]vKE}$sf=+ΎVREf@H]ȊXHA3XA%J$µt6;߾wC4^˻G`AG`78×AO3'a쁌?A%$3$0,#sIL&1THRH$7{O?;>G+^olP^r?O;KW˯gPro%QU7w:~O&wBKbrZ2,?*;k
Eiw5N.fٻp-4+%PnXSsxZk~?ZEanss@ QAIәgMbLXg{Wc|V6*(.gRIwJyڔob޺>kw2oy_-	<._E,'!U60RZ_i|0dtt*;M{qZ39ib|d2W~)ٕ;=v_=@ЄU0c6~/&h 3YG?ś*-tx(x6BlezlTNJ|&8eA|2k{'mN4@FRPH%=)P_5E~yL&MFl.pe'2.[(@ႅL$AX:cٵnZ^^/Vm|W]E~R}^]stTR;v
P}Q7mAfu0&UG_6rޯ|}JfxbyaA~qA*5h+EQGglxﭏa("#\_˔2_B«W)a HXF>r"#""DPZ{{Ym{l)!BX!@(vK^B5:k`hV2&E]ڦhziZC[Q$y+'"!bB\fx>eپGƴTXgɪ8Դ_-f3#YK!G
=ߌc.JR|J?Qob?i)؋cG鲉<ˍNsy8#(V9NT<[zܴN?$Ϯ<;Ƃ%n]=YPz1apN>{:SOE{}P^9
5hn](2s'҅٩Dl'H:8vKr\1<.zcFeXS9EP١ΥssԊD6{I
ؐ#Cb;7oEn"g|"J+ˡa;+e4B/i="AP"r[R@1GpiPR>'MSu5鵲X9m,J6M}v=&CVwuR=$ Yi?wzM?I &g_p>W&vNyGѿh3]GGe*B?kBILm=F^6dYKu򃑟e6dVl;ȿ jD2c*΍ +"A׼:؟x0/E[ڈ
Hr(o #|<"ZH|,\{><, SY $腀|m6f4	jܤ0(p`0V'%I@	$XX.̚uq r7bT+dA4hhnN
8J"I_E(MOH$v&/7E.BT#!1͙# J%^ )K2cDqESa~ x.F*1>ni4&( 05HYXPo&F9m܌?TV:@~)$7jUB؆2FQa ja̢DqAz(EwA§ހ!VzL+
nϊP8LJAFdlО	w.@diFA̘<.cXwm	Mf9v  <"B.@
',4I Ifȡyl!}vjGFNngt$$x];cG6ͭ؜X
,]Ȗ_CjIU5жK`V"MXץ P}V*bK%|*OQ15U]ƴ(]4Dg`8nֶB@1,q<f	Hh	S<F`39"/-5āE;P5Lt"x VgS9C'QLWAˊŚAd/t, G%D.AbAZ >{T`-,:޽(@Z{<^<ےv=)*ؖ"k/ (( .εMJYO5<ŰHS¼rP|_E"Tq}Vz5QG7\nf$#D1ɧ[҃f4ӱ	,/UIfۦR[glNA7T9>B6.7/*]Wa*̈́PaEmcU m9l.߳}aJْa7kmgbl.+̧cG64@YYsLK-#GDO_OisdLcyLO=3|O5]~KKKK5Q޵<-~honf!<cxiٸ4t<Fdxn=&]Tuit/~s%ޙ~eb
N {A*J|K8|?O0D'jPDY	s]99Ж,?q"=ifHs[;c1'/ߏ	{a"T$| 6a#d@*(~|MjoY;<ML}8wzA$b "]P#BN6rge}uOF`%r+L<\`$}EP?#j$({ʁɥ8N6MSLa1seucƵFgerY-1qefnt;yJ+9ɣVf
-eU/>X^	[uU[-e!)ng.V AS!qײz3`Ynr65d2K)ZI>*>|ޠ3,0oQ+6۠@}.MS>23$.ك:W*fc'Ym%YшJ63\Z@ւ1X~Manй-s3Gj"Һ6.(BĎM[-Y1:Gr68J<#պqQnreTL҄5PJAYҸj^!\3!MDt`o>;Iݪ,A})M5Dt'h3~!P9jSm%<ZWD5eǳc1Ǩ
mml8 	]űֳcݨ{Na1]4iZ<H!_!InR6/>"6!è1EU$@%eNUNܒXm嵅x	l/\mxFq:k	D;e瘟ʬpX%~'1,Ը[,WeS-Jcu \zlH\3lEIj2nٱQ#&Yb&ղcpZ"=zw.dQ|?]R+KBdId?ITQG/jF	rK9_Y,B\R=Xi~e9Uv0f焠h/R&=:+pcYKfkٯfwS5},$qq v_YēkTGBl HBcgP\&	"4GA١&nA4"\v(sdՙg'[vն@hx&3>^e5Zh x90Y^T˒n7O!w4O
QVWCm$61Er@;o層;r;#k$˒˔s4H3]n4{MͪIXK=-nHq%zx\iRZysV˵pN\=sq9S"P\x\1`=|>1fUH+BfgdQNrn8K͕lg>0ct)l4=k-B;sқTOx?.2uRv~B껎_Rƥ(#J^b_ֲ_yG.fu;wZܯRSZW&ɏ_  	;Efu|O3bJd/F3wÞT!_><B! s+"gm1yl&gz밤'~vn	LY&}@ԴP33(hs:1glX#
d  "ͥMoXh&gYBK$bH  &!@BўIo)hSs5>.Eg}[Y3JuEgutpHE㸙b @$RDE0dE@ h\1R$l^'T,J2Jpn]e:ayn4@fݳgـ~$DW9 ~&)D92Q٭~/"F,Oyyg)wha'`#;a.3sU7&iJܻ*LȤ.NP{}ۊ[x?ؕ:Sớ_e]=nŚg}nɲ[|D6/Zm>b^|)t^#<.k\ZMvrWIzO[\n0+mcSv(SZ0mFb`9xm勉#fS*KZ2f!ڟobs-Y/zV9vY@?<^#S醤_z[z԰G.B nm§}~Q8xrv	H)/N$2"-w%f+mY}>Jꁄ8$G[mP`+v46_*B𩽺9F'N|LFa;TNMq'3˘"СBg	U0oKIεXd~&<#fr<k=j(_pF SC?>*W!ve(#y%^6;n۲9L7Sί+pO\cF˶fh$DOF4f"_7a-(cԿWCNlP{qf+։qR<~|hD]cY	mHlǮ5U3oMh;&:jL?/./3swkx0nnQbcܝ`#X0'W>C?_KhgF[@]9]WE:v.4tW̱gYNE+ݗX:¹tvJDA㹯SD@LjϸK
A;*.+#!&){ͰIYxHN
;ޠR<H%> MFY&$37Oin)1%
b٢9UM=DCәꅉ\7Ueס_;	>Nɇrx^RUD9a\gp%L*G(i=KpڅEiS65"G1i[|$51^pjvYݢe:PE_y'K6\1]Seg=E7@ھ*=.U %=@Â7}M%$0riL:{)ڕ,:"NKKᘐ!j_rjVv懮$OsA˯fk2͎u<:I96#˹r9?5Fو : .U?v]IΟU*6.]U9/;'*
7Ȕv'\\v+@36ṇ'֧׿LY6/y4-EDD`ژ%!&?yLw5M{z;yn$l}^=ڋ=)'7z)$xC=/5_l]~<}ǋڧb.rxr/^.vo/m qHҗՃoI)~f;HGSW5?pϭ1P#$OمIfIXAv(!^N˯^&$H[>aϹ5O@b7LM5g.åP4qdìUFKܱ{0p,6XbK6.7<Hܜ+
}LWCտ7	Gr꯽mՒb8czW|uNFDYP?d/gAc\J̖
Njd 3x@K0=W]Rl3&\ئ/ZIqĘ+Fyb:bu<Î¾lRc~D-нL\<YU:Lfkw9'3bg <g,W4NbL1^#`2027Hф j~.͏k)@ԌeWV]D )1,5TTO/ə6cWU/*mtv[|~_UVUZ!L*Sqf)u^q tdxusxrrα+Z&oRI-pEpJF۫=m$k
1]P$A0A8OewOZHD!"Dqzg2KG"x , 7]*f37i1Q{@!9W[Ke6*[9Mٚ)5p	`4wpuەPBqb׆-5|箏cq[	Rx5sj>{ Ilr'81Y߉0At^%ȹꉎ 1>>:"rտeC}.	,n{ʳC3!S,?ۢ)oaҚ26׵xCځ0[
+krvFN cɥb76G؍~hA1>QKIr+.rY]O,NÔ!D@Dr22#4N{(#66SCwCS=zR!=u5|I*1#Oؽ?u%\Ҟ.S|Ȣw-g)fE[/e"bӡ]U-qݣl'n%amSal,a;dIeLCmAҾ&PÎ=)1YU`Qgi{rC1%&NEg_zH0)@$#`_ǈdOhF9E`*(	ei$|;m9%D?q7gg~osZg(1Woz%+*N<6ZKv>ꥺ)󸨢.j)AR+ޢw[ζM8jOԚiSM9ρ%ު,2i(?i\WS/}ٵ(jhSTQE0llOZzt=^yC6^xd*HY8τu@` "Sm1jNxS6Fg?6A*UpƝ^Ǿ͛TvS	:E-.YdYj@U81 SF0BqY}ʧBͯkq7;MQDj%3yPvsU,fy49w}frq~6?DF=~Ca(Ǌr[ӵORCsk}	Q3|W1~s>+sd1]=ɸ],
ī:-a_f] : CvJTU׆zgmn!].+&8B͡AX bj$TZu3Q[yl#fɐ9+6CZ?;d_|tk3sg(BW,d
}V!VXӶ;D@  
H"H(DX!@sFתdte@LK!@|]DZiF͋zϜ)vEӂ8S=(K2M	-\[$5yӊQ?~{%X˂;ޑ7sA b*fM8*ꚮe*p{P#M`0~sR
`h`b#ؘx=PrQjcl!I_62@'8،8nL;!g:~GpVkg\slV]ҞJ@  B0A='5&TNiKQ]ܵXUԾJfjy3kdʲRKmD[ _H*HCDCI$XBLiL9 ލ49bot	!PMhZB<=1AƯ1_e$9aְNxF*ۨ9	<{T(ҌڞOuN̮#yX}]̿z߃=7evC*	(~(z^v]K.}~gxwsn~@0La~QqʡH;jo&k-8yE,M!g-0IB~ݲlkgJ4TAו́>WuR5>Eq!mTܤPPHgnTaV;W6Ł_4_vVH+|{M+6pa(#l}Gvؗ9Ή(mJ|DEZiy<"Y 'VL)
2|%+(;[y
Mi"۴^k^l5!28jװkC׃ܚ|ә=+;Z^|T:
JvYb$i]vߣc\ʆH;'	qO9\$٧'!rj<H(Sj&WgZ_7=XX)a}Jju0USqUDmDz~
0Gzb44JnǸ'*TFFShƒ.Bmg8_ܢ㬲]Lw;Y{ND3n)<VD[b7])UlR}sQ߭j(U=(-B/yV-gg-طE}㪵`T:kXG
"4ئz֥}UKKSBQ-?=G<eqpio1'ZfUG5ZΕu<
sV1lCgpy6˥wF9,ifVUyҦ-\8fLl!@G-N>G_/LUE:3Z|Tz:{f[ǇNk1Ib"vy8 jr˯uf=߽,QUw  K5YgE깃**rޘ.5YƘk[S33F`NkBpLhn! haD 	.0/U=KiCA4P@DX) ȉ(Db LWoϵolnEzu_|۞T9;Yڏe;m|{競=h3ٸ,~YNMwZRgZ@ICو=rG})Pm P}-K~xVAk+NRǚ*̲-]V')4yv7,fŻͶu5gV<´G8W\kh-i9hKg.h_l\f] $3]()$k<im.|+lԦmpgӠw}d46N7ѵ )Rvy5!1pbal@[˅@3a%=]F@h-b"[ 
,AP(#UVo M"`l؄o2`l<[=1xf/q=Rm$Fl=]bDcPfF|\@(. UavxR'DD4gt+bX§GkM.D+/mRu{Hc=y0*Bu5NРz HxH|30p>K1|LiƤ*\>E3¹iݯp_6=0%qz˲Bif5"7|}$ a{Da)#D#SBc2z҂[ZA!͌>">;rfjWfb,5ڻ.C`pd'ji/%[{tx1$QF(ы&^Z\<b#'7Sp*:h#dF*.4aPb4FbK̉EA	JD``QF
gd"
%]dM!	ع80-(PP,+(`iX(2TQ(T؇d"3,@h0pFF,Enq:LI;BWh0HEf6%]
. q&	]*3w\bZ*SB6|@X
"2hUB Gl1}jE&g=lbЄY҃MF8ɩC,9.)ٓC]FVCbhéQ`%gP(Ԩt#Q"iYܠA#9d q	qFDl7U=pjj٬~w;P)"5Z,Y79R.eQGX8	cc++lFdl=^Ezt02Ky3B;}{DhPs	a&{6.ֹ͟Su&O:;|8[8EC@?8ۃQni!Op݃x5AyoXoXEX?@
 "EM
OGO7ױ%kil+ף޷patK!ߙc返kp,r^@
Ni$E'3{hcFNm~/C*,J[֩'.11}=3Ȗ7;;:*GSЧ8:ǳ+rlR7دpX6,+ła͒MӜ-$H9Gns4L
P)@ߞv$5u6]2饆g8rUgzoĚG^<AQ/GW3n-<Me=t0{mف=o4?rĒ8=Kjq]uaL$ǫ*DmNcgY菉Ũ"PNFD0ȧ'qbHЪm84	"{_O(UCa[*4tmo:"<ixIZl.&*_gyror2j$?nf]~rWZ0Z6\-Wʷkӈ.GЈH"* Q:fTI"$U	HS=m89ҁ1bUPVYUKm{g<fMnي`O!Z^zs2HU}uUbIs!?eŧA5'l3MoT%Q޻}yk{?u7>N/ijWq}1E`|ؙݏ!'K{GEUj-8IP5ڼ%SthO:m'k}
2RB
^(E.9{G>.8\cO{*>/߿kxC{y@u+]Ov4M/Gkfl>:`.f6dKnU&O G<A
Pt
rRßDL	wO?cç鳆q7WFڭlT}7F(b';[?WI{>F{=\nP}c*ډ
$w-vv\ ы-IQOɉA;{̆`z'ӿqJi0ŧ{IoKq&{Z0-f7LƹjN
T~zXQb*M_'( ǣRY'cߦnz&aryu<73UN!?wr"Dβ7oR*	"uFlYf쿢]A:.Ta,LRp/VpgEI'cmSI'b`Q](4⫘ۺ!!ki~oj])??}wsOer2v]p(@C:a8|6>jEP$p.{{z~*`iG :8h?àcRN9M>Փ
⹡?5e`~~ckS >ت_zs'IB\f^xc#s(ߐ<SN̪sEHqN9:7F(F,Zř͚	Ծ6[oiry>sGr;2滼lbUr51&E<ݹzK7?#tv/e=bmZybZxCP:[x{VZ1`^HaL`;!bsQ#D^š~_dV@(w=#jw<^,~^ZNLseԮU+u^ 8zc@N90)RPN|_Mv<Ǹ>SԐ:j) bT"
 "ADb*""Hk֗ϙkf߱~v0o_$8S>5?ۻ	^A;բ'<s*w$y]=HʏT7B]]=>˓⮌(~ctZqe	hFe%H./Cimİj@ȓ?Dm!2fD䔾}D  GDò^[+ٲDS%O\}No9SYq|}S[T3UX媽+)NN혗;\3p/\]sA80ee78)K!ZTD	8@BK5"֍E^C
+eK;ˋ6#rVWjOa9>>qhF	aHڼ-{W.}V7<El4kAȪ/~ 6Ft=+QNd?a{Pb~x~w1x",Źj_qq{՝=,gOHJHJd
TQQaVD$q|{=3&9'HVjn{u1m:,j<UAGvL8S+85Y)\3s[DV2\p-(>Yo{|_o7/mm!;$2Ϣ
o   KO@R_tФq-T2Gݶ;1juśogb;{fs4VC4bB F
$%l`CO?1/JC߲B#$   0tqpNNuhϔ/?/ǛA3֎jFkglK۹/#tTRN  Sxgs|U䵋\[t'U_A@JDĠ& Hexʭ;kӳ-jEBhHRapUQQlVc@8c8*Zh_F_o@uc޴@S:W[	BV?ps}3H<6p|7+0;u~ʵ"Z/ }.j沔bC3]佞,2W䇬lh(x?dwrs=U'ȭ6Sm3HE+?wGd&))Fm`6 td-
Nl=,!62Ē	{Q$B*@c 
@/7=]yڽc'⼵{<GM;^:~yWߟ	oѰv9W&3aݲk0z>N^wm-㟽+Sd_%hdćfs:ճ5&~]}MOW#崭fդz9ROѠ<k'"{eS5^q5&6.c<#ߺZAcrOsi9c
'0ܺwCi;NwR6bJzbZ
G{..qX$x7~>@!괷'wgT߳aԆϦvO*3NuΣ5O\q-zZ_Z-[x+ɦ.G`E1X5w8jo{K-zr.2s/m`7(V
tﻞBu{M
7S}jJE¹GV͇90~L	2w~JTtjޗ9Q{h8,juzR
Ա,j慼f_ y*Іf6AidD!Y:ے 7088^H\"H	2/лO?QHhitI{P	ħ46"$h;o.}21$
uk6 Ŝz~{Rz)k/n!۲۾&{+^#%QP?TE`?\n?;ߛJ?Rʶ+5-)E(9H6Z7^ڵ-㮳"m**{Jlk{W­NI8\\˹K毣b:bINˋ- X$TQnVڗtؔ03𸝪څ딝c`sd15֋Mr{m8^Tqgx*0FMr%OLAm*5Ӝ`"xy(4 !;%Q9n=]Eo~hKC_qs^%̩u'3<$-@URR͊YbCA8	DӜ5+I:x hM~QntFڅx*%b7(pe
	YC1KO`u Pp"-%"ŨE+53~J܄OB].0nPCcEZ9n;urKt)DX$zWW{@s%sUlWT};m8 ^xaXdk+ \깇}I*2kPe
^{MOCxMqd:_mGMr7y1t)O>#_Q:fl _c*jRgy7c{J^k=/ѱkr/zQɋ3u6`'aT.jBC!3fW/㵶6mFHDDH@Tщj'\|$Xe"-|ρyin9n{vׯ}t_-E*~z{
լ]cG>:97%RsڃgqQ<N;q簹>eMQGvqu6UIJPJ7
:]iWPITuǵg̖j`*+2w-}`x{JDХ:
fݵ1Ｕ}JV&+/Bsm/;v;N(siq/v/E/ץSf2K):صBv^|^To$,{p- #?>Ҏ>V1V՝iu/kk+,òc"|Iw-Z㎺j_!}=bSܞcv6'J<;4=\VS6H2iWcȆ7__ib{,_kRuJ<.؀>RSρf-{Xnx6h֮w57?{`*tf`yV
lm 3ٖ)2B<-
ؽZs

wKBA"ɣk
UiM5fEC:h^N.[ǯPQ,!Oh[w+F=*~I?
Ug7OZ%mV#?ZO%xj4*֕y*}y˦=``+_DH0|A`:؀-DG]c,t-CB2wҖrma6(u:%"nhD"ļeD"p0(=1[%e(t	NTfܹ♮w+^ݣtw[$U:{1!ls"޶S}VUf=Š~-N>ϛ(S/Ne2M*>S/tlჄz-D%`:Nsƨ~\ΰ*Ĕ$Ke-"t|?}?/8I;.e$'Dy%MnSCgV_Hdן.GKoykӸk4ң^hf>iW1w睦}
96[)KpDn~er6M]'bTWq'	 e+n1ՠhonF' [sxS{~c}[0.S_ (=V-q?)9{[g&J%1l?o{tkB&]뽯?To6NҧU[w_vǌn}6/$Yx԰RLi[wQe6m6^ϴ,>\k]xfVX)+[M}{+=\h%gl.ئìihR 70/+R!ں
JE_T#-p^#QQQ]M
o:o!C4":JK9uO:Ƈr4gᢠ!S
۠iVPo}J<vyɷ~j>Jm*JA:KH?`:=TjRT[gՓC|twůTr6zeNY'PT|-C,>
+#/]/^+Ӹ""/vrf?oCla_Td+nN[ maH8 dyoC=B4J2+%NU4YJgtGصViE.Sػ+zk%Z}.x:(9EQ*Xr<V?wIc<X<x6U,HZeX{9d_dKG1<ܢWGC4c->źo=6&j $06Ppn{GyLX&M>b1&[367;1 ;lp=n&9vn)r|gBAq99Ӳ] cC;o:C3sGj*ӲSE]Rem"cA P 'ǘB,vq?DCzb0x}G~]?Im0< b!70o'|o/sl"ɀ?%xXUx>[|8kLrk>o%{2.coyb8:;t2->h^ԛOaCEr?h^2yw+Xc,m\-:VF;Rt8ב9Q>'@!c
v^n3u+qv1  
N:.?*zWQZ3\uwi2g2f=3mݵjܱ7wԮz_$ ČKP'gNiz<ZżZgpqXcc_aPZP95w,J+Q0dD??(Vkxz,'0+̸sՀ" AYpׂB}\^%3Ǣ.ܓ]foJjX5A!?V^c@6<d3X,8yMGI!,BFNi!rQ$piiZ娜K56		F+P;_%zOC6_]p`WӨ*Af9	k0jĻ~xVڱ/JoNT۷
:|8]<g^n4+=˵)YM	
sKfYZfg^,.eqǞ>2-3BD >O-^֫-Ѹ>NoUZaDrׯo{bZ_}".}:?Fm|}~kE@M_q},~ƨ]m$ĊȺONx<4w}Q 7F{u3⠜Vh)"k0jfn 0Η(b:3ȑA~0 (ߦ6MJT >|%ɴ]0:bՕnE9%ƳEU}poA@~8$Xrj(0,o(
Sxɻ/LOH^&&U_I_\`'V$byX<')5Z̓#-ŖAڷZ<9Qtb`!2w9H@B@q7`9x8َDcME?WY(X|0Ġu,n|"xJn=)@5|YH퀤`DUR("b'Tvwcb7Zj=9/㮫{+Kǁ}Oce)J*]SEy)޹w!N?RV;+TWrlwQ-?dk>[&Nhچ:~dmQدn,Y;BFtx[z5 WC
S#_rz8
DEAPHDA L|]O'As_%G%ퟅ6cG uf˫9ח8:N߭vIZU8gՉkmNR.] xL0]
P[,3:7P趎OѱOܥBR/W|=ɼfkn$Ipc6WSr)Uy8_cC続W2к988~>O0|U2B\+h|i/w-wJALC(g3(*F& u:@GCC@%f#
@^i ̉H',b[(]N~<@/Q8tf4;qqqiCH,ƌp-DnVvK}%@5SWYɃI-=-e*h{3r. .ʉKb41NB{jercu?sKMj<5 [@r14@'Xƃ,E V#D$ub%6mpr.<ʏnNQGM.+4wW) FN*Ngb
+j|9W%<YOs(9 ܉j(Hŏ_beR.<3l5UoZe"i>ϲZ~*v*LZYG+w|=7VcᘁY?4Ոh_(isBd|G(QGu$7z٪tMQͥ]Vų~
@lV;nmPrIB':v\뢜+Yfי;Sv\eiLB`mU%<|mt
A0dzFwrp_E
Qqۿ. gzpv$'"&+5z惐y#^}{Aa&^]U+ЪkKKj׫ZdQTT"2H:h|rֶU iH%)ќ+0kn+^uMB}_'sJ"vmOuZJ.^ŊjzQ`_5CrWv||9f=?	EV+{eO;V6Q"]Re'nc媣A6z>e>>M[x?{Aa"ϱkrMe_Z߬]PҜ[gNY9N@Z;Au rRn bJQݗc2^my2W¨XQxWə^<eMA i˨1qW+" !DEB1ױ"ͻMa\5'-`kUv,}^_QdcBZ;7(cQ(|[FsYcW.]K;9R9R4y$T_IpzW_-vUIKE?ӝ@SWޫAnL;SXV(Ըw-k5x;4`k+*>]eܸ{,SilM<m	黦iiSO`(i3$/I)<)M4ͧON.fڢMEN214N*F-8gWu@_|{yZJֽ+iUlUȰA}bB^զ\3A)P!x3uFEoFL]>WQQ"Q+Ӿ65oԹ⵪½8!ꮵc\3y\~/U]\yqQaG͡nn,LpYc?2T}K3oQ2}F#4&O-Abd\4VS?Fy_M(eg'߶I(@O
7YW@gm[10=eR1RC-_Zp8nMbQ?lj>3g+^^\eyft9rkW"_o3xd`D!?!	xCŵ_+PC0FFqgɒwh˵G(jfLsWײ'O'wb \X1aݒX7f6]1Kaкz|ˇZ#/Fbc{Zn
xOusPR aVLnKGՉ;#=t|Q^nEƈruVUqY~oIl[IrrRGjYmQ>!Ņ~Iy)eI6oOѣngvlScSNdh!ۀ4h.;^2d|2̝-s,Qlnm8	LUsw&"=KMz{0^y̵iO6xwdUbG]omkҷ(a(:Ȟ)Ph
)
`\orN[w~.EF!U:(4/eyZ|Z\qNG~\x]ђӔz]Y0j`oNjT@UC%g؆,e~h~gf#iY3d\˟mNHa؀Y~n.[kxswݾO5i4vgأ'onHLbP
xW7׈8B{v9$,w/,594-K%.bXEgVZʩ{܎ϥ^=hjv9ţt}]rd"yl
NbtI<]}F~-abKo7מ6"ãy=OrrHvUayCkW>'dILn9wRis0I29ZԆNG܏)ڪCV8u]JuTT]r|+cI"@zJA8BnK\Ozqs}7ʻWd/2z#SjulۘwTAh*o]Qsρ!B6	>;as>ԭ~=
W=~EX$ҁauЀR~ȤzU["P4.pڽV>X¤7tf+w:@]FF3,Xc<!UEj=<G;Ym6xK	s3d	fyZCN9dݧ?7AXsV?z̴+Zõo퍓G^yhl-q2Zb6JD;Nϵptzo} }x	}_9Q39LkܪVN#*Qz*\'zGixNl[-d>n A=rDJ^5M^P~mt߁Yqq@z' Mm<wǇU|NzF;t}Z0
暝gXon9"Jg&1{ֿVs@5A6f+R泤ӿS#NT]@@ @g8볶j
_ynnZ#x7T1O>ge}Ս`t:	|2m,}J_Sa:R쨪'BR(I=ŵ*>]/}k.]6p4\3S;O׷@;ݑ 3X]{~e{q;il<rDQr&4:iM^bV#Ւұ"xP
P\?J2RL9.;sjKА}	37?ٜǍ+nuzaǩżڨwZ^5J,#ٴ=/k$t|ja k4:&baiGn/C `@536nl;
ݝӐٲDCܐ:߮]OhmsiZ`ul@{4ss|sI֡-CMչfVqnjp5VC|+9̠αLX[L^aͱNT6ۓ򖿾%?e_{֙$R~
{z`:Lo/Fɖ3Z>U]M[2IޛKߧtqD^NޱjQ\*Ϸ[P+&gRe:11l+~ Akɚ_Rԭ1h{lhU8/֦ Oy BoKX֌yi-JL\Ć :Eq̥LOZŁ$p*3&(-cG,Z">&[d_\^څ[Srl͵

jb#Q@fzJ t; g.O5B) Z4# s#xgrL^iF[򑬱ka}Oii]+7|R]vGS-~4%dV\av^3}wow}r7,ވ\@@|w}o ʭ@%zy{D1ZJl 0WfxJ Q Sbowܱ'u/o'8L<~jS~]Pd!пᎭ5nxmS^Q8A8^+3˺v=,۳M4Iv/gG:fI:ΝW,C&q5\O컝g#^r4+sVUz&iJYd ]b1nI5f"|#9<ڶd 	I]z`䲎ȺU4:KD}2uRobr~g7}r0%"?׹)Vy_I_\BK	L3hYmfPQ_0LF{+|x,~7N+6{FZwj3mV(bǏ泺[ nxb"o.$JCؚHx M)#` cpoޢxN<#Cg=ݝ-97S9A	Z*pkA"O81aD;*̓XW7%rNk!:p;l3ϖ[ʨ@K?nF\ЋzS_>w|ty/&Uq& (@@'tkE! 'Y^\ gB&Ws8w2jdӭ-EktU2҆(%Pb8OS˜@\iCq)p+	2 d/EL8wX>FXL+ܰCfł,Kt9J"o՘(W!j]WG<kh&mܷjp@ƹQ7ޢwJ	x{#Z8V|m߈=TOwѵyQ3  HH@==nt"ЊګjWA<dz8 C0Boܽ]7'b!T=W-ႂX#	)D=80@yyJn#^"p'V;)@I`EDGO{DLgf.@m<`6f@̆5h/hr.x`!p8ngaʚ? tgu1y.r.t<]._'=io}{Bj~W{-Z]AV^tAOBr}ؗ70Fd}%^VYf ]! <T-o+A/zйn=cÆ?o${)5<j}O;ZHF+⻯g6%W#+
 tG	{|VzYz{~~s5wXֺ~ӋwU}TR"U#NiҴEQN:gRQ֮]X|,{v" e3
		Ts8fxHNs4f,~K_~=+X5_7a]lUUE7R頜 k0{6Vɋe,Vb[N冻+yc{=cPûX'xﯼRZM>	YRG5u:C`jw_f'[w}kv4H+YN	Pd%B BFi1-4J=mbt9Iyk@Z@O|3QÍ[ (wۂ6ZTH?aѼƚoO;'QE4IoVk o9vF(g#+_p䕺pU՝֕:}.00ɓ2qz=V]}F	&	|ӽm|a?~n!|yaJ䲎?zUYLQ
*'wpQw{:QqQ>/'S'v9S ņzgNl{"m(cInBYXCT fgwB'QM/1ʋu1C,ŋ[[-9p>1-պXa*lq*?2OE_O)ľc=_?%KW8H0@=cf>y+Ki4AjU}f0^qe
U^w@;yHI53*!bh(kԺX*onpFU#WVWq/*/	\Dъ;kNWUw}J<_Xe<<3ҹV
<(~FG2r9*S)boBn.aj\[L(I~~z)XȚ꫉jj}eXbSU.VU,Q2Z-u?&_\_k6#o麉j3.C[ al2x,09LG"4|+~dX=;ߐ%VZlsvl'sW\%{h5fV"%yO˂.7J򃾥TiN6^A47s0Dh$Ⱦ]gñ6A3f*M5٩[}!B!mg+|yvM'NSְ(8mtTa5N}CtWd"o7-
eD% %M\c>Gv 
/>c@DDRq,n>o<s)H#fpkN\9`(,$Zq
	L/Kr7Vc^x3Kqx?ǤzҢN.jJ^ͅޞէ[`6~ֽ{Q,B||07%GG	+I,!:`f&A	L:%(,EeQyLSUvkިl	z\]Ow-rz qo hbՄòXOfYMym6Sϐc:I 5?W3Nitn%H@q/kWwf3ndB?tv!CK0 ">	$=Ouרɺ=![t1
๋5y{Q>IbR*>~t3zLC+^`:HC|L2jfW:6y_oOb"7<ŎֱIׄ|GI]{ghnXkU.?E뽟=~~4U"+`Y!H:ҊQAA@zYuB*Ȣ"|BI^W7fs|Eڙ8iÁ3yj~mq&DɨvXL7eI;,|03<dpu#4BCmCg<lxv~]aWѥvaHKHfO-Ve)sNGQ;K^s˽K1Ek(qD+Gڗ-M5o`1?J<{(KA	#n~\ҬJlu:꽭7H"ငqG%wϕڐw~Iz	IOΐ!`ńAPGτ{^q7%zpH5Ļln8'hxRjWǄA3H# <hx}]ag|P6?+UCʅ*xEjћZn͡\c[M-Vz+sŬ9/߽w+7U̡eo~;+}j6F:|  C3
+Cy$g XQwJ+JGB
_λ6ȱ,eoEᱵ ޳ue{|G?_P:1XN0ACVD´?Ux__u]9m
z)
+#E|Z)EК-k}mO0_+E)%vMeҫx<mQK^9Õ{#ڞxKQo4kS~҄R*tsCY;Yܝ2v
ݲR+&k
kPCo>
}eWs`7\vqq{L``Þ3_+himrmExA{kˣ0h?ח2mryg2t]>wJp@  B16nȫq+swr|=gY*W/\	kMw/,R+zu\P&4[i|ϯQANs:WlvfBQ*BE}
;ɉ*)t6)XET#Ě|5f˪uܷ*lӪ5e0 ")$] HsA;!6$c`h K19tEepM p]5fʋMoMm,n)?&z_?W|O<_KHxT5REB,/e! H>O+/k^;r6$'Y^[(֧\fL76w4'_'2u;[RCaf;h~~Au
O<>@E =mg47$l@!& 	ғ_c&>zFN&߽j?$a.@ky]]O?TebQ#<> -({Է7+<s(DJޟ꾧7}#5TT)uL%{Z+f:ĖAF~n(hJOՌ'Ò8C x{Z(8~I-~y&kq0~^GYţjө;3ZV{\C}THi`$,RwL@<)M9VyYMnX&+-&5U_ظ3E8MT{CZLP,;Cű}6;RnFjۿF&LmR~G^odC 'NgA)'Z JP	_DY+CVEHSvq7]{^<ֶ-Ϳʘ̱ti2&Y^sW65laz.X-<ͫEU蒑Q?WQ2}9jN$~ڹKln
S}p[53.հ}O>)z(KzHI_q~b]ufizbY.[Wێ=WF{ߴ!5]3_c|OK=]vnӣ0z: JoۘhpF  B $~15UDG%PDDFsUȦ{Ez;aգuL5R/zzRLV`p;?i`*4YG͞fGrPZ?att<Aߏx].0ƇIO5kԇ>#DXQAKD5@%ѥ}|IG7_=⍊flZDqUܴe4TDWp{y7'ᾔUWX=׺&@( 2';ݒh*`6D*7+}t~0G{Tk{jtıx'
9UQ:]7'pȃu!D(g\D8"ͅ]_buR>e +uLe ѡﯾh[D. Kn?@l tL71q^Bo<R5нb =79>D<jWUxč*ߓ8UjotR1>7	*
vw܏0qj07 &}keЫCl6!6ғӠyJ'ο+ dKY-\8 N$TV*QT.*YO,b"E%n=SnBR	
OSVj+Z4KZt
;EfxMM}*vUpqu,mnyC!{\Jj|K^,2Wݳ9l=>/wt~\t-M4@ŋ]ҭs)ȰAg.C;jv-AbMR{D-A4(SY[ͷz"Lڛh3yҠ{b$RG;8_ꏯ#HC2ΰe
7'ؐ7'+|+7)pu..E2yz=n<l3c삵i`=MeݭZcga9|8Q~C"  QU$ѱXESWOh.Ltˊ;UVR+@8ݔh_ֿKk;e0X~mtin3kxk}E^kcj(&-sL-路-qB,R
	USJ|Sflѥ``ǟi5]sr\!nksZ:ihuB-f;@֔ABq)}Vܕ|3CRl旛(,9ᮓbAX] P<zi;=uylץzzJ(,YˣQ$iTYI$n=D#a;|LnQoȳpU(JF<ҔBvYЦJgĻQ sdpݘ&0 ݷCA:3s:A~9xg	2077xFI3Bu_̓٦?#;m99mFb *u.<>6u2&6	fUcRW_AI6nݹ-KmZőnsfRϙڣAsf8^M$4V~ɥUuL˙>!Lq
T+C$|s޾Y2~gơx/uӈ>"ftۮBŇOYܬ9uUN6iKG}Xb,=&DR S{Bf5WS;7z9vֶ]ީҵ3r5kmm^Xrs]b86e#p2} R+v-ױ9𿍥%(HYtO@-+>ULQAV߉}֑tʰ|uZ(mc_9T"hRWN)Q (ce'AT|ERوoEJWtTY`Df.-*0gϮ8@Tm|V:SW3>KQnκGuܥtNily+?Qe{
f-pOBZM˖!V Q	EQRH]7AbA .>xuVyԸ	[u58róF}],b1&,?u5ٯ\5^b 4}Y[>ɭ+L9FKYK?䉝oyq?T{c4ƺ(x< i;Q4W5R6xi}z-W5
xN.j3)UVښ۴rVkGPބߓc'1?w7S=?|5_
XCkphQbNR78B`)>'"~Ty|m	%21\*b%B2!k:Kp؀3Fū^CYANaص`	[NdڥD齘U9txLZ+)u';׹^eTӯB:E l2'}&@ "J *$Uo˪X f6'))ë꓎Z9Ua2b:=/*]ƾK4 .t 2(XN峸7ZЌ<&{N?}kWU%vizoIOQcѢY^hV	]
_P?ƀ:VnRg1YghՂYD)o#AOV_vS5qޤ3,z/5l]>6)\ĄUt_v$UC."@Y)ln*.Dk _?bnmFm<<9a/V]nKWuM:'7(ߊ,DO7u{)oCOiynL rT.kFpXDXx5Bv]~O縟ph(2~s縼\\ck5)>Neq(]ZkX]WEV]n-WبQShgtܟ]]mv,M=VPpܩT_&JȀUdFQ_P^ޓw~O}oĨ12{[^_<:D$	9o
<gl@X^լ* :N\n|o}xnc$hYEZ:]T4kQ.J6/*  L@^>CRl NFҷu^@aHf~WvɭZi3$ݬUlݛ0:n8 UUӢ[V\;-޷Jxv<W<Z\JDwF:*Rq<AK|33iDx\	D\7)!R,Ңl~ՊTMu /wa^P1շF]5F@}B! 0Ipp<GS[8ګ.SǾ6Mḙe8_;O_"SmxvE+Q=Yv%o.B-Ȟ;#:QEj^ζL%f6	;X7x/x''s{]B*4.uHW)_~t71r{_oW|u\l~ЬcEXz$BDEXeU;
^CcHJtP7oĹrQ8T('Ŧ0XG70
1jy?v#Q6[nL{oVG t,u~<d)-URb)FBIO$C?.$)7Fܸp%?-Ba5$YL5|G  J>ZgDU`пe} UccVEg짤qw¹rIM mŧIk%CiӪ_bpp]C%{zיa|â_dX _B#Dbã ҵJcUObx΃pp.5YQ{P*pZfRŔWlfWg2w/@ȏX&nn>E 0S@5zu( \Nv\[vzf߯S,K95F#	~Jؠ]5+5N!9/4`ejWt@#_oKK@;BSZsV3كlI+Z^SПt'C^«$C= S[cV(DzU)/K+Ř!yΧBdge-$dSJ
L9ASptW~3hN.4|+lq2g[~.*@L
aYuo?.>AŁrc"nqư3̚Yg~V,Hd0T!Fѡ}Kmr%f4;vbJ)l1P^#N(;12J_"
,uzxTC`-f({)i+*N]uH͈cȍ&nv8$ʜMD%׏fS!zW@ʫz;̈ֆ\^eIVjA=ʉҚ R)Ў̀]#!hJ)Or-2K3;Ǖ\3<CGeQ,k~d:7$.*%.5M!錱)]BAKC2--?r>*4(	<ЎXˠwAuMYm/,XK,	e]f4zȹ[QeԃJ]3֍.gzcu%Tbd\.Jn5=A
  X ^Nt#Z][=WɅHsF=\Z0["cLK,"$#n_"++:&u"?rז-mJtS+H&H9=RÇ;lXPEl^W$ QI^ys

Wj|ə:@T{'6Ka"CL4$#bNw7Ll"+
0hS^u;`gN 3wIdE7,7 w/e7-ĩ"ʓHu-/H5@xlvDH ;CKj:HeX"<0h LYn:Q2W{
Ș^}'Bg"gvM1+c\(Swg77fVR40[edp Oe(&
)\aÝ.];p܅zLd!bXg,.8<-.F6bUbg}ifDS^ut!dD)ءE3,6T^_~ٶEtlrwP.JE^OGhTHv Җr-2LK)}pID$rҧyf̖O<x9S:-"	꽻n70]Ӭ\\Kܞ'/7VrɖL+gX	[(4SBfu,M%r%nW9 _$3!~=j}#U{Q/%Yզ2;mo3j9l*nF)e
h֎R|	dkOwc}wuء=.NT,qS(mֹɈ*]0Ȗ#F36ykڵR(x	[{;xeIrrdr%ECzsGl5GL䏴cȹ9|[yJ[TL*+GcT[b(YZwQU%gآVn@T\ Qh	$t:@DgM:eQ ^Rq	%h)] <+B-b~S}^SO5yz2s?f94􌨌:Hh))2B!:I]6C;)\x1⵮p%ܐ%	iXS-Y#!QLҁT㷠 |D1!uAcƊ6XTpۅhd.9Xϡ%,Qwu\ܺ7&خK4iUيE2	NXdNdllrB_fQʗJ]e=4KKMTWPuB9qZ?W|Cj'nu1r]YQ)]F*+Ib|aY抲M6IGZH=#P)
1[i4;%:7qAr8*!Y[;R4af69}D4㵈 x/&|pCX",06zūqSHE1;n6δA#`l/lBB;%DK˩;?`f9U9nM+^<p3r)|4JhKzgcPtw<+cEgs{)X"m[-XxSJ+E~%4=R0~%UR71{F#2KP/UA5Me?c]ԝBIX̲tH;?Une+c!I EHȒN)ԅ^,(d"F`c`. 4QpM/ 0ڥ)-6)fuLAknS*#Ngl	+niK&8[p[8YNQpR+n񢲩"'$7=1F1	]XT(x$,dX5N֊HQdJʠbl@,eބ{v=m߸was$ʝjׂ		, -K%Ӥn[)Wfd-U(@ -MAbF ۖKDG&!
MrZ8&Z	ܳ.H"Fжd0k'(b(I]aHk6q~cESnH[C;)1_"JaBaYfܾ>aH
!A4%[t}yն!DE0@L΢.'+&uY,fe|]Np;JˡR$u2FgTVJ7
Ajf7,ZfyŽ1O(UzkvI_=;]} d&^Z}Nkuq㉊mz\BS\g[XIb>6gP>QNHiW.`m~qhMpn\n^{z&wdQȻE5 "\zkO%YxuN4'~`XgI^:ƒGke)ܦ#)V_@@
##钡=y='_26Zem?heAl2s#%F<t)=7֖RˢM}|ǩ5zybޒ|)Uhm물?EWl;bE+?!&0ܣ)	tQ`#FOU +,]$0/`!~ukpx_^Q~rW60Eb4sV#SAnPi%M,tn7ǳȭO'5-NFI,ܑ0g1_Dh,nj^
I/SzI*:kd 7DDBK(}'L]vbN$ϜAD
<Tg nc#bA#ĹoPC,\Y2Kwz_TG,[* ??ɿ(٢ܵZ`WʯJĸ[=#Η/VlKP /mtRL;N䴵bv"ȊcD6Oc=G<.lc0>X=:+4*7'$ miYUoOgFόyf$U&K.0R	۹ad#/ۃdvj$3d1ܭ!nC6ݗ<lX&Kԯf+ywxM.CK*p(Y{Bh	A
x@6ފvun|%F	$AH(&$-[SWM`zB& C5}sVe 8;+'ȒNgxb'Y?%UGe$a1Z *ɮ</Xƺi m`g-@l
hRDZ:-Ԣ6Ef\/]^<{}]S6NUk_Лcpz{m<Q-?k_o࿁4}.W	rOs4⌀,}ZtF=߱#	.3dXKQ4!TP5az>R[uC$:3Exsh6bՃ\a'AaD@&WcHa9!ē)`$#,&Ҏi`|EQސ*X~8E_-9Z@tꝜo[h<܆n:RR -rYY&PoJ47[)_ttze(XAHx c\;V-a[0mse.B{HdRD`;l#  ^KLu~=?ص6	!o/-MW{JNy'
o57X@ 5	GSQF\74Tڰ\Dfmf@O`"FߑL~E
xGg{3Z<hutKdÙr:%R`(зe(./_ +_9by*
ү b'p~ϥ>Mj(|TyotbPAD;dDo|<cVa`y%NPS?BQi3nAʴE
X2Gֲ<6(Sb՞B{u<w!8[Y%}yˇBqY "Ͷ#WV}Noʒc\/{??g]{a5	qv?FsuJ,&]XXj֎u [_LcWB0!ԫ7VLIg|kb^m=Ï=)9	OlDQOo_g&'BE8N +n}'z{5ۿ9ʸs}n:NnFJGa7pH礽;[En@lʦ J8>F8u׶LbDKVdet<]b--˘enh
py'p<?62%|BSBEFð"@Sq	 IELmJB<
R9[z]@ި8D,6"fWQ!,rXw?ȠLђU+kD_SZ[;Ǎ1-~Dp-6JU>;a͗Y04)Rpu:Cs1Ն
Gn6TX]uŭ_J38v1w=-]Kkssd^D1.o)J=#:5pM*IS(
"SSg:bͻ=׾z^;敢t1(mÈ-{=QbQωHK)^|*\ax	{dB5B@ ~z
,@ F$4o>l?``Wǳ4P^^Qg4[wgڴtZQTBMt	͹i3~GU\/˪5kxuzZ%ε)E~rk}_XT2QHvRG-'Tkzlhݕ_QO>ҩ՘5QL$1ţ*֙D3$L(B z+[. $.c̤Meo"L	KNV3k-Y,{eKZPrV1Ucݻ,7Cfdgt=13\|f?1E$
to*;&xz-.aU+I;ӓ5ȸc k(U_"hO]I&+EY(ߓ*]M@ݖZ^ګMki":ʥunӜm(OXJM&N}\Hgi8 ʪ~SnոUTU?J"rC%JQL]^hB/!=
PD{ƬqoTJrmyj4}dU޵w<-0+Ȼr	4+0H%[֏a/@ Ze`]@,WKuXExL++ȉW"]u݆XɽaWgPah2Yֿ}1d$Pu\P*mXDnWh4Klaːu]{+v>nDil<}QWoR_gphȰ_!<͞]g+SqR	o<iŽhimW#Ã:IgCu4zνW>:O~TqCa1evp𲃛UF+}OtA&*Z`QdYyg?E>juȈ}⫏UNjNI><?~9<$PBLeۂBJYqj#w0K%N{'dToo :KţrjխlfG:R\VŀluW/X-j즉I{Я
ȺqD!Dc"ǄvhtfOܫ;%Ȱ8wȺRSBUա?hNb^-U_E1YqZזXW#,ZEy_%V"#ex-aXz
<}DdS߾ ./]PFq׼#M*^n0`.3·taː!JBΤڭߧy_X<< (lT/^-}Ր!2	`H(Z{^nZ;֎z?_^W!/~z'@#~o|OT5`cߔ w4~IG M)&}~ 4nIlxZb_=eW*:*IRBE'D?LHR %*Pl`YIIP(3pq0[?Ix_NruO$w[Qt
W:٪[.}S״(wOao}&+ũKcLP_bTrľ~K~˞\oơ	*)k@ii-",oyI_ѻd8rHG[3tcs_Ft'-4N5.z&poԳU7JCBп"hLLLYT'_BN<qZ8\֧Ƹ'qFyT50@ú[6Q#pi|j`f a
Ȥ狿̯/[-g*2?H9 ).,y5AK|-BVu8Q-sGrw߷g9{ @fyUүtojPyQ`g~'o
V4qCi慺s]zm_y~֫	덩,"E)Җ(1<E١mkCӺ<žm*,)ykѸiWPw}GyXToX>[>5#yy>ooOo|Mz,/բBiSᥐ(Xg'8,*[?]5
`(OBBښcg+HnO.>@;V{$%Ad>F#  /*~<mY ;J]no#b|GLǣ0#Zc/ٱ,ڂ-:E&\BDj=4uRB{R(˕	#Md l8+ďO8fRCBHQ5+h>v|}ާY1<f^lQGҕin}\ѵվp&(nF뵵Bh,Q`R
ayq]#:0[N\<;+*exU沙noR~aEFyz?PBAfEEQI[6t{P,}]WMyYPV' JAQE@st=aǪ~lfK`L'OcQuYmQX DAM	 o^c9(ĥZdڤ}ԐH2JLCSSN׻dUj;w߅}v*jo"0<cV$y&yUWD޳yEKL»s0Н"@n4&7@P{occXU7<Z
e*>
soYF*>Tb_3T"gM.-o-=lp,Y__&eޓ+?_~aa2lڜ=eQS4}h_}s{|YsnbƫOWzN%+F>g1gJQDOsKl6bLN5H5Yywxۤw-1f2c1?"Z(K-Uo Q <\%$F.4ҙBtQF6gC
:PA߆'Qgͷ:ssw^i	#-Aɗ1;+ K6/ߞzsh ԪzK ;ZuqԬfӋf ZLr UdSaoVYzJ57ꚾ#-K٪kĥ3J>*"XtX{zVQUŶ5|oo8XcTPֲNaL&v[:`sC`L!O-lW6Igq3@qtv϶jF3cz+PR,G	qZA*(9Kp\(p:ΩuokyaĻo4JEZU<& 'oH^̀'v5"IiJk	o^lc8*0uV,|f/zf@ʯDom5):K 2b=%yV1M^PaJ<uV݂:KԢ~3oj=[ûl
>@ǳv#xTmB|O+>>yakB%^mRy:)XgXF*߾}fOG/*/	vKll9'&Dܰ>2g5^2PX?(ЈioUrQD<}cxLlaR~/="?Zvx--n?i[]w뙺#9;~X]QodPp]Oڻ5LS'UYgSE/joZWdjV6G+ߧܢRH?2[o_g@AՁDd}ov؎XXK=,^t=y4x_TyF
/ǀĔ
"Vn Et,o Y*"GZ|:Ӊ%FNv-&8^R{Np?Oj`hV^r<p89&4'CH֠!!uB7BU8#bLZCɉDq"N8Q4W3onoY&ȵlk
b9E7
GqQDƨ%h'u_᷼aq>Ǘp1bU!k
)ADe.Jkz¨LSu#XSQHW-bB$rƦfj,}%/f屼uB	W"Pi>y _n*efV활ͯFکM+° %GFk	O.(L)/';/-V?k_~ݿt8 YX3k&o*9nsWyu~y|fY%IC^s׷t|\02L{aH0rJ"BPj$ֈ↬qY>ʘx]U_ʶLA\3yD]GYX}Oǽ.pa!V~'|sDHBLx?gN] ^1!!atMH5S7˶"ly`X'Z}Y .{1Rjm0<
9-ѩd6"ҁp4D&T( ygw۟+	{^jStw;
F˹سA~YkQxjd_WPziE`/v-*9saYַUӷxnR,5Y7TJ|@,TM>{dv?ŊQ_T(ͥǩ:V,tzJҘ
QDΙMC}7]_7!컌[r$lbN_\bŌ|;rE^C6 og-e2%z.nl{+B6޲A{Xs=o: ~9H9F `*ʋglt7m!*,̿kBj_[\>,Wb[ضO+ȵj׆9VU	.}c]^KuCަ%؏Sc-99mUʲq~&A0:,u_NJ:kPF48-9nU\ӄ os]owZ2׵**u-(1+:y
B4`9g,ǚ`\FdV ;<řQ${j3VeYG_v;WᄇUiL9c/E%t7G$G5^ceYj$dW}^6_ Mv 1YFj!TB|k[oNlM7RﬕӢG31_TBXD  1KFDԠL᳏ը%],I=b+rNgE?KȰ'_i7`ж/>2nCE@@A=H?KoY	a}ϺE "Lz[zzbϺ8׋e8yAd s
B_۽_ `zLZ1v$zD% de3N}׈AyrzjsutT+%G؂vZejW^Cg{ª݊^}N??%jGyzm)nms^V<|J&҅U{6~sQ	κ{`E9TVJp'J]?۬[guMGiwJj2c_l6,m!"	9\y4O2{1\+ElC@A?|}eb/cO-W1 bZ;׫Ы3?VUJDLS{z̾{_|_l'*^.Vg1ww
 m;3"
]!1bz8W3H2GLjZsC;V_IAƬvvVxRԫ{fR令oQb}oDQKUwOkzV,>Owl6E~>|XЪA#h;q0S`_+5!`JG5,vBA{BC'
Ԝ.z{Ǭb;MopU]~($"uPF ^omy\
kLkz
}Yk]fnTJ}hz: QX֭ OzsN4`b-Xϳ;;ZO}ekE;ǅlmKb.\y
:` RegZvVs«=KB_YeG8pi>f$XDW1cy]ٟbiVVء[UD_NmZy5>xDYH@uXL#{1xw{GooknƬSE[<߾}z]N+d1Q]CK4x-İu߄#p*b||5*_Gzꈨl!Dm\ﬆ(mͰk4ɇU<B9;'8eR6ҧ.2b_{+j;wl5+`w|W{e4vR-]{Vve_E&˯~\(.%^`yc]@$ ;GY(P_.ZeW%ng}90,֛[l-6, ߣk.Ǭ?\xb	A6p` 
#*S쵇=?T5~#3o=^
\?Ͳڼ\lD`m	*g^J}s7,<y?l`xIu*oM_CotMon8oʦ?gkD6V/yΞ௡~>O[d  $qJ bfeZ+LjEfӸ7:Kͯ0~XXw,>r{έgU2w6ADC8%,0'v_@݅3ŖzV_ŀ$D:

axO.M|x}Sd/Wb!z{ױAU ;!.5*?idy#fegdKw 	n;DÃ|46ILkx¹!jl!"z|_al2kWϛjg> H[ 5nPSwQI 0(AYuJ;~\5<_TiD9vЅl9ρ~`#~ܲeyߪMĉ{٧tsA}oc0Nl'g㨟}x
A۰7;UpF>|b.B)<o]JOi1Q~?K*p͖y)]B#GMŮ'Qm}RH(b+T,|ҦF{OSWǶLѪh-;oXzT4i(		۴o!Evs5cO3ySy>'wSW巬VvwJXv5f"WJPU	:
cDD(-Pm-~΅Zg~E3:mIfs<҂vҾZlWJ$קqh_oKãiEM3y[0Uv=C	j^7zj:[-SϤ?};ew_c$uqPAEp*q0(Ցh}?!mدr^Zf,jT@m0P3#-;'.g3Ti|qSQd/orE~:ס3f1kgqWh8r׹F:׃YSjqjxA'(w΋^Efޙ̝qG_qQ:X܋=R^;˷/FDC%c}Ez0DtƮtKXTR:WDDT.ߊ;Z`tN]"KQ>_Rw]'U8\e7ḻzG3_PKr1@Di
 ;'{tO_q(QE*( gU/i|']2<L䷡IoŰ0Ǿyƕ65<2㰃]lDw f .i j5'Ӓ>l{ ̛JΫ绹׽<(>s_%\y+wv^9D 7!Q>÷ZD
"^Yxd(뎲kĬ m{=ߎDp؞j-ƈj~:#n]ϝf¾v4=:.l8H  $a ,;KBc=!gY<57b(Ȝf]ks}1a9<a)I?Ĥ KzM
2 0AH?-r]G-:=M@]H%M=]E3ȳ6b홨3l6y+ΠtkOIgӴ'I=c/Ia~Xi94SSE:e=9M&kݰu|L3b-1!`~uwTY辏δ*CUH̩6
3my
8mSU|k9h4MMb`2'N.-^ލ6OCquTmY=m439}v61=tWׅxn|И\RۏA(FՓi 1fa<0N3-lW%Agd=_拳j-վOZBgsRPp_7CatD!wuz629_rޅJ?<q=7'qSi>{2/gµ9SB
[P,;SlЈ܅ ȶ?j꽑2>S^Kzh:N_ʟ7	wtz4اs-Su.KDF(AѡU9svhpmmJUEMaG5LRb/~u3俲eȼllO-T\!O<?cd{X#Tإ72w;\%m!EO[mm{;o;>7=g1R(Y9s~'m?r^9}|{aR/j;էNi>&T:F*֯vLCoYyK]Iu
W6>/$Oe<<ZX}t.W}=ca.s
&wcUQpcB>ߒ@F&0Ā N1/ZBX[6|5d/$sV1ert<pe Hf_ߚ?;}곻+6=ww<6Bn?b\j6@@T|H#`X3 Ӵ X%6Qx'z!3§4;ߦD'_u|N\׮ҩVnOc-p>?OP:U3soolAYK8ih'I#8!Ĕ^rYXYP7IsI_#CЭK}.m`*k^},}x?A3?=Q8!+xFaTJbsز?gR٠psV B@=Dm|gUׁ}q@-_mL
iefUO=EM6Dϰw_a@:T( Ndaa`	cRQ+媽X:j|vz^LB6>cXؕץ=$!]*8ϗ ~[i/f]9.:C!}CzUSr=I4Ŕ$464"q˔柯|#ٕz{nUv>g vt=kzF?;VIڠ?zwFXYaAP9w3
/JE	Et Ni־>ގY@Fq2__ykj+'[|-)8olhdxR"Ùe|v\N=pO> Eڟ X'}(5ex[t#uaȒTbf,V~z	ȕNIu>|<JݧQrqvWnYǶؖl.]0!	0e
W^R&@f=Y?'ҵ|s
,$t?{9-T(ꦯFVcK'^*>I,Xb]ɔ)"AO/3^1=olVK´	k޷</գ~^ĵeE
w9Vnz%?ycl@L:hI&[ 01H#7y7KxִMRIbȺ(TOcG@ԠHt`$#ĕ7yL{|4kɓoҺ i6(۠Ƽ]f-8 .l5i*W]H3~PA|gB乆޵ٌ[a׳/h!6 +^w<M?6%rat.z紮^k$܄MrMԗk~cSy<˷w02ՌW˿5!ȁkvoaN8+gÉp.&`:.Q9އ10// rݪ̚} (yIV/VUVeo<O{ZgJwڥwѕ~Ѿ=J#" $YhqO Uyh"c(x +Ol@%\i˅ngez'>հGxV(6UGUZ;<__]d2ojޥgqKB^??e&JRI/IM%eXjRQ^ڈ 9{݊o_mnTU];w.,+}֘#/<)\3дbQ"V(b 9%qç?DY}8|~sQIݥ}&sߜZ~vWz?Oc,F(CGVʞeD|.N0)""X,S(fɰ3E
JsnШ#o!W`p3tQqn\UV2diW]s3DG2w5+ֈpz'p ֿuAj	nV91^WHd2`!)d xV3[{vCrLCߎ|M&k;^wkfb1z;(z}
ޏqD|$oףzq^OH6MQU:,?q[{v\dv_zMw\W}y̅owQg`	~x]&Y3:v7q|z[QTV.OZ\Dj'avQfCp#-_кA^I2ع3@UUy;zε~D%1D~jǮ9Jjm> `kο_y${^	҅៮TX@]}DyXq	Y:._	}MƚGeR	GDX<*a1 Q-,#So˜gz%"g>?ԓ(}҆h9Zx6\P$jXߞaֈuJ^$ܑ<$4$fv5dp[`Lքn/CDlc<\GxI@ǂwoqág8-GUJnmo:8);=&%[{lc,v}q " h]N>Գ( .BQ?&2xg9V3!H)l`C x.'CȢ!%Un,bsBǂWyN״z/GCKa#Com?;z-]|T|,@ԕڞٝ|SDTζoouLok1]O[taeTwtgD>(nvSmNXNp~oXr+=ctB@c^_zo@Dd?t5շU߱v!4ߋZZ/AIccZFn?ƯS߱^vKNSozz~uy7,W𫶜B5^VCt|^a8zyZN0l @x-YHw{'[109&qy%B5 \Fߦsr􉝛~Hy|IV0>p_3rmo? r'Īm7B nD6B!gc:JUW^ IS퓘#BoTO<x:Ϗkf '=Z%y]nf7Nv3uX36IJlȑҔN.J?WG1w0׸賬Yٞ3lUR#Z)C}ۤ9|JUɝ&n\ώ#.˂}fb"Ƙ| ;&W:ðUd	<K;nh~ap1XhEǸ'Y^h)ðRRFȔ(t1@`\3CͮxF%{;;"\s~{q[>s|p@yfU(ݿmAVfаBl;A4j+
TPtCëbh[	@<dm~$@<pflӯ>ArL(w|z|L?ȎWߋ'y'Jt;~w72'bps=0a!ve1 .o\9T?9)c]O<C>Zv5-[)M4!ޞ{>s^י鐳Y!,zr'u٪^}pN75H'j*pn`tWCgR|@w))pG(MߪUYg)~a=zIUWc%˿+ۀ+8*nNU끔s=`}1.up"u7F?Sycf:Su/9zgx\<?3ӼJOJ;CYU-r/TT|ZָzώzkA|/lR!}
@ʥjQG~y*Ԗ ǡtށ;r%`o!l+wm6_;DE</o9v:O^S??sOt)O۩~qUmMُ&E+q.3ѾIVJN)1U	q}櫥i̺f4{?
Օ:;?m]YuS%ץ9!_mkZk((lЮPU-EUJݵzRfW8p}>]8kvU!!k[խ.掃^D2BKlj4nNae{+^m}WO(NW̧v80@Ii{VUr
vQ|k=.ʪNEo1]_ּ	2?35/첷AW7<2<@BD$ s>*N	#JyT`^8|.!C_GM@T9wt#\v&39G K޿Eu;:&wJ_foԚ[?=NQ(r֓v iֆ7:sѢCvYYi7v[=>TX,:뗽w}:gӒј+Xgy]9GA>Nt
x}h?SHRQgKYmyű >Ho?#QF}3sUn2||7eJ>+'rWQ	_+s]1t'.5WLJf o>㵺&5VR+~+.:A<vkc b!0deA2%?֫,YM׾U5)OպoWE[|آ:}>X܃}D][-K1p7~M|;q""AэibqbP0`0ӵmӃ898Cz__q=L5{"_%'S=&yIyj9~)ytEްw*h_yu礄LW.O(D*pp߭Y%>z^C>_?tC:g\S՞ARaE BumSu\M\'z_Bա5''oxl^EE){B/`|Lw/d-H}v*Hp6F1KFc{Guɸmsi]=^_`6;Z|s55KkZ)(Wd;}HxLuĖ|uEk&>`ݩa\9,Q~gJSS}v~I>^YBJÍкjy9{)(LIŐE#$n5f?MvKnc:|Wd'
bg{u].{鐀빸,hF=k3rI(Dv<=tQ2``җX<Ҷ*ʐUOD:`kQHl&N2۶r?[tmmSwxhbVFu XbRul?-sA{5 o|}x51l1u@~IT9?Rj܏y/G݇cT&-^fƉPo Z{y0~b+; bH6)<-y*,١G3~,&R_bhs$L,+4
_M^н ?W4l}EvwNZo\)0 lqS31|8V@-R-x3YhYYi5.2'^_!3,:nOҎkE }ytT
"аϖN";姪\nޟ:]ya;H/_v=Lx|^H  _;-K1xt8qe%/풄 ?< A 8¿noU!VW=﫲&J W?$Lv79@HV	NczLOVP,wۨ `ZYnof}v-JL0/Fӊr|8vL\'Yi$t!5j]ކo1ho{jZӣ`f2ԝj,TV<^G]yOqYvן_[=M9t:YC_2Xݹbk
.aDZݽi)ʡMz]\SS[9g;Q]k-Y(jw߭ݻ[!V個q_[=I:r޵ݛ_"N/
UI\ tNTWk.  "@ ( 9OiJpc!rn?7c_G]Ӷz _%mgӋ%_nb?u!-@DDGpP5rF:H+CszhD/L'.R-kٯv0U?8BzD!lN'?ޫ~G[6d@U?%MN}3`Ym6*_q^ѰN1C$͇>G{EdD\ܳ/B
HuU&y(EqTxS'~lDAJa_2	i(P8ǣW~dl!iaẀu|.C_Tg={# Dץin?	e[q7{<.tk_UpuO6@5w^}:tKz/n`-0!%0-f?.Zrﾁn`MȦC8'#VYTvAOa6Гq%N߉"/	Z?eJMR0_&da7x~	8iO^vug9Yvf}dv&n0#'@^17ʯ<9. aU:<V-nEP| m}#¾sZĞBEst=+	yi!$GO2+X̈Sgltw%0	IoJ>ZiQraqӌ(*RG<nJWJ6uJgOhOhdw[uªoYn"+QHPT1}aÍùԹj.82u[,]Ed̻*_X^LFf<hrGFgyUb	P;=niOe^>'Vk|LQckw/?)Ǘוڹ>JMU4ği/V({s\fە	 kDg_>Fg+opݭMٯ8L[t=KT&i}̊Chz/6$昖r2W+ly|c~w#3	K(̉,XϮw.?,+
'b|0f\7FAeG+O`mcv|vSmQG=ztmٷ  띮5iK8^lgC7W%Vi&\s8Qؓol%4q>eBEOEs.o+4gKt?}$lo7;p,r<*;u]>!lp7\2P6ŸͶ?+:Gߋ~Sj	@A Ga%lS!6]q]gۨU{cՂ֦^no&IodB}E 7z#c}EyZ)˂Mpv16$Q} rNtkxo3ΛPs]?O0؎u٭a&ДfQ]hqmB/^>Ex诣)сe"iʚn'ŞҖE6kp>O佚~ 1<PK5 LhRQF1|W'eúannsMQ:lw{;=EU;Z `|hnx"O9u||L_B{l7lA/]3
!A9m:=>OvQOckෟb31;% \ew)|;]@R"{UXB|=N 9[/5=1:-\OKTy7o4މR}?3i*+cep,Vn>>t@ $(v4%/ltnvtz˯WmIޫ{󚌲/kOi'w9bpo+{ϝ8cmXFO^XToة?:!Åb;on6m~梋ͪ 2W޸Y!>H#6FXL>c~
jex+oJe!v}-Yֺpw2,- _~4jlp*=Ce |/s8^ ~N7uz_j!+=$v``7(y"?{=e=bU#\/D&K5W2C֩ō|x9BEUqkNU͖tWi݂UzI1=gdԥdrA~Y=	зtuK7F\}yxz!~/{jpS{K瘖U?`<c!J(q}W<8<}-|m!i՛j
hm1Lr8#$e^ =1ߥLT.7)!icw0r5*;;]/b{smWcb#Gϭ 5~LU#{媾IHZm.޷}[Ħ9+K߻jb¾Wi2S2sj\.ewh4;iDZ9ZnA/TV`;k6.2'؈KRɽЅ WE2K7ww[` E"I9>G/ZDq]%zD:H<.g0h灤0uHF~I'&pfoaqʯ|@`p+_??&xz4G\_mwBQO*F
ɳ_jMx-\]!m>ظy4,WoeM?3x9v_*>V_6-ͥeEq޷7=L>2x;?y;q+5K<4&EDv]oezXWͥ) ;8!d\ouK
-#JޣGCn}Aud{ZDgȅӹ'?LL֞Owk|}ڻ<E{A+',ux&$k;P]R|2P<MZs،,{|kr`wv72i@f~{;hTwLhy;ϻMMX;؟B{a\<e`/k{:Tj}徘L:='~e/w)~yH8K5y
_A]Zh/E<աELߦ9?e[v)^_rμWkUmt&7Q!j88nm_q93A|O>oN#dsNa9GD*nI95ۨJ7.Y@Wך/WzƾVn~$zp_dYYK[O8G S@ =J\,T7"`sU~]yé|)WVcnwEv:zl}ï7gۃIh`X$Heʀ^h*iof1uz1DCUlvhЦ?n]5qn^zZcVѫy:&Vh$x1gr(4MrTl(kt?#***bѧigAW%t2>W10pqycty<}CXW!8Bq}Ɲڹ{JTc!3\[H:?U[_W-r-W~omʁebv-o7\k_L7[#Chc    {`5ƿ25x$?V\Q퍿#3TմW}{ɂ{&0-WR_Wb$g.T-=%8PsUg^K.ںf">ӱxa}\D1XAn!7Z=('PjFNKx :r8uο0aa}*&Urdʘp8&-<1JWe8<A˫i߷ϥ1Bҝ6EV~^Wf-y/; WOCzge3Iۜ&zt!C.uf7e-PVIp(O	w^w:=sYf*J3aVݎ3mFI͖bY}cY[w;fVVZ[	 t-Mj]2wsw(䶍X57:ƴ^\*Kimc=mp×tf3{t+͵,Ց[ڥwk:JؕKvbf҂47,w&ɢm/ȼfVkO:nqmM`esnw=ۦf۳6fFZI[u͛MlEOvUgvݎFU&s]mEr{ƪ*ak쫰/MN-knYeZʹdٵmck0k۪VYgvֳlBmvR쵷;ͶF6T4jԢ>$uׇi 
PRJ xZIｰ-H|WɡsF[aրG}%_}ˑ D[w{=S'@ \*zϻ6	T|!s$
F&0   =4ց[mbjx pfR }w:wh:F = }}|  3J    XW r >|m  
= G|	><(>P     : x  >/}@;}G^>ﾡWoom[pІ^4}H0Y|8}Nj>_yROg*o|美zjq<²[_azQWi%>U}k1	/p|u#cR^zOzU*5SEQ4R[2#}7=RP>6ɪG<q҂|.9M{ԟ
J J<
]sD/.:  ŀtS9`:9 f1Р q@@ PP
Ql
<뭻m; v$ w
ϸ}z[f-݆e;gӭIhZ szVz=]bѡnh.@k%Ԩl5lT5}rTo          @
 nۃ T& f #@ 0(KgH W{x $9 9P      T           MH  h 4h@ T@ Iw<B  K@ {`H$N;cur (=
ֵSQ}N'^Ecs*>{o`jW%(́|:T٤eހ 2)i}i_hWhLϧ!Ma8zX+!.}EmlGG:PٕrեHW@ϙ>ڀ  5\dN]Aɯ^#}8WW<Ě L*ٶ^{Vhsq =f`ۖDۻ nun͛UTxu޾p}vsZ5wxAܭd޻Pҝktƨ6wj-⠯;>˞B*B@     *ȗ|>
 +}G݀أe{v&cGU֛n_ozEEwޯ]}o[{̭c<X^`ܽ.oo[ȯSdOiwgCYﭛ}⺩ wƾF{x=jv
uH|^O3p^\]x.{])	=xYyi-jK>vQ}:LGT>۾`g} wﻰ#a֛>{]tnλ>}>kwPTz*p_w=ˇT|o>}hx4ڨxsh o}||4i2V z%<[׻箭} 
 wzt;elkZ۵4PH  n {*j*׹r5xt  4 { &Êr:zn҃f>r==w#x˺x   ͅc<Ϩ׾u3}9 ݳCAH%;X(S: ϾjN|c@/Bw9O( y׾(x|mG:<=w Pޗ'ZT|kEt=>P@U  hlxA h ѡ|X o<P Ё |]ޜJP  GwݫuvԊ=\E
MW{/ {KkRsռ 9+rs7F|  \3R>Iqxn=;Wgǘ1.>h҇@ Mٛҍyq޼J _i>2             @ (         

@     T    @ P P P  

  @  +Mk@* (
QVT     
    h IE@- h@      (   h
($             h  v  H     (-4  B@   iBh      @
    `lU T   
  -@%  (  =>  T       !@    
 Q 
    E PP  @T)"4   4 
 (  @ A (   P P  
 &Р  (
   ( on}ލ@ L=3z4kuW^xG;;  o=^y&   e=uGn{  Q|̮>   |>s|
 
x]   ٷ[57<|)  e2zo{> 5=>#E;O)A ۀ{XR g"MI@ >: QΥO`2Z}9^|  =OFJQJ įh}^N#ח r {F2RX}:q|  Ph}AZπ=5@Y5  +{iֻ|  N>tc%dI|HU PD@xwTuwcU1I -J׀o/ 诰:7wLjA=@ޅkB;j;}*F>{>7P {X(yﾚDݽsxv'(} ==_C/}w3'Qs}#ޏ|㠝ֽ P^z<0t:_x@w }{{  	(   6@;{t=ty=ms ,9p a"'C Sf h   H (=   ^{`44    z   a   HP 
 @
    6  
'Z    4Huf4 fpt4  0w@a}zps> <@8   
$  9^  r%*=@9W)} k}-d^z o@g >  T            @     @  `	 b`A5  42    Dh@  I &556'TOie#R~)SMjz@S          `шC@ 0 0iƍ	{i
B)    @    h   ddFCAAƑ &&)S@ #@   142dz  L 4h@@  F0M0M2	"  M    d   2d&    	 &	24    	aPHxb9ŁE{>1#$W1]w&	߾T?Ei%-.|,bMu+&R҄tC6ZbXH❛݊:C>m/`ʠ>oO X(`-kWx.DDML#73=01y\}wNDl>Q858K p@" ^ZIeU8c-a/xt/?@ ]T$,N u, .oiu;e}4>i\)|=2{Y1-2:'ľi2H*:apx0GyGU	IiziYt_Oئt7qh|@M!P$룬QKsK:@5Eݕ3Ev}eh
?K*"߹iYcW)oYBӻu@WZ6hO'-7(dE1)j]3eV5ҫ
tD1uJŹf,F'06XS0EhA&aVBdk'%8f
sFJ%ۛn_}LԅjȊBk2H3 KTSr+M$NiAxsqfz3bs)Ϯjj:$4vt$ENG8Qlo%\vM3egN@U܆13:^m[Mip\gC[

L;pgЂVB2gED6U Z<hk3fϲ~ӖjacOU` G&]:Ѻ]G3o[=~i'p!(@Ex7*!w7e4!tQ೭2{>9׏_OT 꾉-fCYWWAȻ<@]Oޙ
9;]̍	DbydXn5*9Wj68L=wpFT%$iZ]C1{ecHe3N-4]SchUR+<4Q<LB'G${.cpYn-͘m2$8$'gӘ=ul,&2*W]S, 'ݧRjt̒"5r_r=]`q8UQ*l9ŞyAM*ob":Q#qw}/>ryLUӂص3O]6`(;5}Y}eLH1.`0C$"*՛w]!)左:u+q	zciEP$k4Wʼmd9y3޶h1̙)nc$`"smP

QF@ ;nԈ$¬QKZe,rB֘
|"
[GHO$UOǺcKU"TaO؟8Kϥ?=UPW	Bpyc|*}CucrV{_4#q-86	-IO7͎QuanYp{}5E"IN:ؕ6[sk]l, L 0DHr]YNy1.L(pqa~u6PtؘV4"
N-`QPaۦp0B>vw)"7̰U?q::\mv)76g\y+#a_ưDՂ1K2h-ݪY^uɪ!XZe)I^1-xU@)?HxrrZ"kZ8_v- MɭpzWZ,T坲c9%QyW1_-Rl2A6<_F#E "Tc:_H̖lZ7Etv]g:AD-F1FA|&8hgT9wQv[Q='MY 0SB­.YI}v~o#7	&dB	.F*)&Sٵ,~f\kVzaNm}y漨2` i	r]V$0Amu
E@|x@!g%j	/[9E)#6<ӺBB,RRx19	KUԩk'jWhVuҦEOg *w5sU%=+rF+w 82MMzו}dF1>``x.˵4S
:{,~}T$C	2!&sijNζMb)*%agi-Ew:t|3T;;h@# .twcdL˱g)/h,j`Gh<Ti4_͓YB@=\5_5/u=2$]Wcm"tLks0OtnI׹߼*Y)ˌ Ui-rp9;+$9&T~R56yTm6} zp8a1uLxT&=ޮ2?OC~ϹֲCgl8.GAC1m.)Z~Yd׋e%)tT`)uZ#Z%PftuDgrjy끫зkgkp홤Cg#<zSN[ycҿ|6%^R2}svTT:NpU9#jvUFdNsϻq9>ֶ'HE<ϖ6a:uݽbLhɋ6:b%TP3/4##-EUr>c6 "uCMv1)o´ٜ(_s7?Z+|Z)w!!9aڝyxɽ;lμrll>9M9-HSKWT/цmI`M4f2.y;212%k}]kӣfìbp4#0l ^*7hWMTHSӇ?IC_h3'sK]ipx$GΑ ;9@}@:e꡺M:cFd _οe:z^Gi#g;?lm.og?k<r4f)OS*l0d֓9`F䀀gX=vn~GSR2Yl_Z@=Y9Dh,<O3=(h^CkY.ZțKÂ-Qv&{v_SNNp~ 2@&E52BE)VC:%v"2S3HFZYT1,JuOmzJ9Mj^tJr?%C.r)!Dr̪Kе_fBWW.\ 't
BBҪ{/]'.
{;[?M\Mji_=aS`ڊK+Um; }%<bˋfxn72u ]T=df0f=ЛYځ#!ȅ;'@zT.z4#̔=(EY0  `Jϙu8WI~YsHMq$PY.PQ\Uw6-/U`z!:ɳd:zKHE'McdΡy5E%)r#ɃEU$ہB;2YU*"m꒜lZo*5P	LI#X|0JA3m87n7_v <*7˿y(IfoNen	DJQ&2?EAi&<]f/uaDٌ=p)Yq7KTx)CL~Iѡ+:\&8r:Y}M"OGݪ},tCzͼU&Л829cdNG5ovy(vP?+*ϢsL׵>H{bqHg~Q'!2Iw	En/2q<I I9 YL;cwjWn(<z`/Uj3^͵*cKE֟6P,!JmiZ"DxgCRO>mO |fAlI#OnL<MٔT4M*s<ݒZZL-0_{t ov'=N uGRAHcEeT\U`Ybĥb'udDH@ّ`sm5TXXuv'{é 5Ɓ8:  !-Ϟ#k2o֦eC~ZƊ_슖"P_Kg2Sn5TK|>++=֟;﵊G'7<}w
_nel6~HZЛnuzW"Wi)#GLT /+j.W$>s>7-h@2 = -ktK.L{Aggw3ģTݸ3@OPgJH˜Y{/7U7E `܈y2yJET͗Fab2&M=?=Ű)Lm/iNi=h="~""7GDAz)^"'ߊXMm6MƋbb vO #)uʾw_M'[ؾ|^]owTl4}ރUqV}^V!/%{mr5=R'YU`o TaG/Y+*? IB$iDA!)NI5YHnَ~_^U}m,N\8F
EXU,V.|lN7gJo_>Za3ǜ̮OԷ`PQBߚP+Z&@JBE)t8B@2v	sѫ:3q﾿Ă\pd޲x zN1 'e?mKsH"jrYPn-@7ʯ"ˬR'R<?3
E_ޯQv@G8#D#}1P	r&Ay!1ӧ8W~Ѓ(IVhI;MKBWF@F_o(ԃpeV-J̃^5C}ɉ%!΢9 oR @<g<t?-予]$'"]sQ/ZJm+`Jd;&s*)
3\G&yAG<ǖDJ!+Au佛ڍOy6Q_R @ӚSUK6,-iJ<\%+GYk!	|R`@XlZ	"|3i`:4/
/
+,<Q,U00vB '78ZT.3)u:T|ósVGovZ258Gd@N\Ȏ;4HcޜɬTdT7]~)ojG62P!S|=[}jv74gv~يSuJJ{Cv4I\RFxs4sgVdxC>hPև&gɳNߟhG0tD{$ɡ,qX]UDq]rGo[m6
+FIDl[a@̍>}%ܔnjBDEU(4DdOMe8!U$ct.	yneͻs'R91s#0Y  +VX8}CQ3Ǆ8QvTFgaeye/mΣ>.) N@t01\1F=wxpdSc%bABAR(@8Gb֠g~V8!Eܑ0'?Ǐ	T&.;
h Qgr*n'U
S> Ѵ|=jC.*w^>d6m[m]
5EAeı1& -D&E*ŒL <2=o+1D󩛉@?=ۊ=6ŒUÂ~
9SEsͨ=
O"W
f$l"{6h`9 O}Vpfߊ)yf:my@SLWV7`7M\;Q#8ْmEԠR@GtRBMcX3 wl󵔰<˞9~r2	&Q6:@&RV
*xĤ+M<nۭ+StEtV$F9z jH BBs#Dbg[kә׶ӁT
7Ra?j[LK*G=6}z;./KytfJȚpPs1|ɨ@;2,CpÅDC"aXkΗcۜL XۆӍ^)ܽ".<*9P"U}Wp:~0>IWd$AXIK:^[t	tQQG~</H6˓SFOUX]pWXWqqe"Q8"	á#m~N*J/q2u}d(A|'k2"3]䏯)6DoP]	L%EBpd+G?C}'iEVb(bHJ={ Di&,6pR<&OK)3(Nams$(d`=ͽs=Jw}[L(uŀY?pV6" ԋ<>ꆓa&ξz9uV`|\DEL()ϝ̈e+WUh"Gi	^3itG4{~'][|&qf۬tf)|X}R>W/,W-L+zay5D B#=e݄U@f6	$+ŭg~j_+cScxaTl"))$.ڌX$:)_[4~V`ިR!(N4DlYxϭ"IԿK4̓@mm{_/	*Y$%oE8"Px$*Xґ*vIS&Jc):噳@(xL[غ/l	SA{)8ݭI{
$ƴF54P;UFNV[\N9i]I?!#d*㫆@NPkD^H5X# k$v84H ,-e|Z43Vkd	!b6H3:e<Oea^႘A u~d+P!uloI}'R֣.Ջn,$(ZRW:-xEH)-o5
mG3Lf?UBՆ+SٕO6$GY0/)$`/4ffE MYtLf)Un$&0aPz |Z|elh."u$ʦywYoXbQ;LAD3!bʼcx2qSIANHXR EǖCugY;4}MFimZba(I .sL9lϫ~'ۓeج  tRaFiUr`3~KHN~
j5rԖMOjӶ>$NL#k,kM=𢎐szY*"P
񫐧>Eib.7gSltL/}nN^`~evZ#fe46G]䯁:؋F/	2ZS"3<B{tbaO#$bfOgI~I[h~A ÙLj`^oңbu>^oݟʽjQ@Yq/aĔ.TEgAnEWA'92#Xju@Tipvm+ĸv4=r1HPTDu@Ή2WT m7L޵Č9]l忴w;SK<3fLs!yi4 
(,	 Lb?jcYu;"dI 82;%Z05Fa*a B	Qo]`ARC`TQvI"9Zr)k]ve:qPڶ.~]o{d4 ?Zmg (B$Q";qXє_zRt-Z*A`mH)H>ȧdӽ<**CN {&JGrK-%|Q-gEv{͝5?ɍK3TAȅ'^mx-竰^dL5ӫYUn@j$:lNpܝaUkX4M~1̮H) .`\S\[dMG1q{T~ҧr&,9+\QRg$`_9quG(٠	ԋyk`}S{[eס1Lr* T&ҜB!%fHٳp·;bDuljx<bQߵ˥d}ArbMwJ~? ~niڏ͹tR{C9 exhͭľ+27ON^-g"}'%V!|AU软_Hȡǳ\UZBCݴCڣOK˫195¹D2 VbКqaۧ8K暌ίC]E%LE}%tߪj)Ow03Un1DM݋ϑX2sev7(w$*1*DždMSY;FxFbt/Vb.y&Ipw8h4Ƀ{,̘ ̚Ŧv)MJ^>ݫ0p3l߻=/ߍӁ[0I" 句-cT2vJݻꣴH{j u1/QnQ=.>!4f
aE'p0xoRVxE5TĄ!2+t֮[ED9sn9RHAۄBB#'UDknBeq*a9y-hpeЍxWoS]dFzRPJ,S0HB%1<CR0_pYY	-.9\qJ"r*{*!/y+
lulI>O`fuby
'9⢡sE9ÃY@Y'Bh
WKjh(5>ۆ1M7mD`'d#]mjF2TলۚL%
- lK<X^UY8_^KLٷ֕.Г'"
A"C%$i97&dB$VCXщy*{{k瞅TJJ>\=+Zk%)1(.!%]Սo^+a;O3:o'±O)r66y4tTD2hP@T<Q:oCc%|!B4NhɬѿN]D
{YкR~y8^O2ZIA|Ih	}&aC\§cV?eM^qڶ6A !=E <z.4Bvȶ0sxnˮ}r,p",O|L4!6UpVQBJ6/ N˹HUb	7@.&ⱊU;)]KtlWP7ï:Kcjn\{MK~g^w*C4pa9W#RQkÇLĿbZFR=J2,7FFM]FR:!\_=
GGLNq+
 VN#K&';3yY\+TOddj1^unaVCWx/&#-:z2()WetbXYjvԊ][< H_$щ56%)L!C!@V	G\8S_MjmX.7t"_m"QS݌9t.!n]sM]l\%:hUۜ0v<@p6jx'pws'3ݤbEg݅2}\wb^N>^A#@ipMFt%F+'T"[98%0^ghҘ+kJ*%JRXZ@&p,w(p 9R!C@))vH>7ȁ# "a`!.3Bۖ޵|Il'Sftʑk8UT8$( ".ܺ4yctC$dUw3x}Ui|)oOf#{ҶaA6J(&@`$8ia0U,tΠ!b\È3J`JzE)/yY_QE>2+:Ҵྥ/4^1\2Gvjܟ9{|sz`lMifzܮIJ=n>~Jl)W}8m..J*ߘ	M/+&xpa;,,7s*/F,$weAcC0-{k2cP&0D38x>^:^_KIezBk]Bc1ɣd<)*B${e`)h<LdM4-DtHQW\zYY3N)L;?HK%[UF"H+5+5OHk-L!(ka|>',VRI8jQb8Wt+cnB%rA_5<nrG&۔&,x!q(%	A'2TBW=<]15;j@a~,F9r]TB 6yIlXǀp:Tp%|C5E/8>eBƼȴPrQt.P*bT:6[;ӛmF=z%c Eb
Ѳ'1cM׺ o>뉐B6Xֲ a!e'T#-77]؟*6$GFa"D
oT
"%z,H.w7C6cU۠)]Tosx1(Fi5ueAB,HFtqCGP?V5 :0A5֍DT4ݷ'|9p|X=!Ec}t)h,&	!f~`\hmzxj!u	e)y?dM#MfmU!yYȀ	j̓qm`˪S4pK5e?Р0L!سG:	01DnA}aE纱Qx۬E@q7_<r%4]	Bz0TΑF!jN;7e#}pFbUdIhNƛ\$_cH}o4ZRm̉Vs"fdJݾ*[%b|O~ؒY,La: n_LD?[P~MxU݆8 <d[!jH~m7>j**E3I"ɣBHQ @F]v&H, Ѣ*RQh'+vAm$rt{qaņG?nAS'iKvv *ކ28<)ǡ`"ᑔXhdsj~[l1mDb3ҵKeԬ%HRTā1ïgZ4ywl/&LKf7Óe<ڲ>P[S+2"UHHh\j2~ŷ㢭i:]Wţv5LhLrN*{Bg9)dL븚[Eu`WY@UTk#l!$CWnF$L!y) "ZNwokhB.|sjE#	J iXy¨/30kTޅ}\c7Z4~veҶD"\XR'|Ab=U1dֺL H<ɡJ)]#[CU ihtNɵjktho*ָW5nʂەh
Ǡ*hDSoZyCⲺdy呌<> yoT|DUʲrM=(v]tuxڛy+2ea8x#Fhʪ"VW}d*܈C;UܧO;^+9Cq{ xA9	g1'[|Ϯ!N^_fNS1(u$P] jڱ1:?7[B$n
[lۇBU?,r=bqg5})@;еXXSS#@%?QWuIu^),DMQ@	AAa7ՇQQ[3Ce_/@mmn(Oˋ|vi8|P1I"E#66j5KXk Z6$ekrۃ3&$~#<=7Pvy+[tMGi:dTigGU$@\aͩz)
9]:d,<oFܼ&uZK(g!f%4\ٴ6&\sM5ͣhm$EC#-aMizTܽ8Dmuω$wC5~7As~nٸpodtETR )V k<RE*`'~ڨ)Z??kZvpPZ|&j#>+36Դ6?gg	Ksоa29ßi^w^/c XX=zFnI@J%*HGÖiQq{'kA.C0!xrRķ14?Yw/
tpiX4g	8Y*Zq/?,ҜI Sy@Vي^;Q1{5^YR<2Z^u~#{{6T?F)Xab
 >v&'%1s)F-JB,ͮ0Є<na.r7gl_Դ	0i*447*><~zxLQ.M{yH	%#5Y쏊7rg+4Jw_By7)?U$u* DEU/$T7EKJ8Y21)@9*n.tl9{PA9p8ӫ$\o9u 9}SJie%DnC+[Gk&fN9{BuBu S_!wf/y!6Hh[_Qƅz&Z̟P4.N*om	t*J"1BHB`A8UҀwu~S>_@7^swyb>1^,%ƙC<ҏKuQGtTI)a:==ns;1@"&սbQ
YG+w7%>$D+R5mejz'S}|}
H O+ߗ_^쿎}q	oY6?k>Qwӫz)e9SI1Hk|1?	D;* oW/vpdd&*4X& 	AZ`H_,5WGq v2~pwZ),/Y>zA©4-z6aO9D=m}O)YRp٦7@ӛ4WRlo)mF\׆|&YaQ;$@mRG7ƼSad^t6Zmo~ 9|Yb]A}آѰ%P ѷYGo/ض":["5Ǳe+L5+/dgDtv]h	P/Zcغhf#ͼ~&	X:($8m˞q@vhHP/ e.Lwqs @E`"N]IpEk{&c?>tPI"s2ы=Fc;R1Q(,T;/́ϸ98;2%R	P#ں"dQu?B	$#сFU8Mv0/9hCڌL롾0ёrÿPP WldBωjG;xuav$Y:v.E$fǜBF;H=gmEɩ)
ςbK]8+@be dxdŰc`!Nq+e89y5uԝF[H"zp/i#+~~[aފ14}(ú!lA}2xH;*1oVu[x/bmE6a {9ZdQ(}Ikxݙ:eftuz$a"H8(2$B0WI:
T@rFS4x69RnhL^
<b#daa{AC ~[y̵{Ն"@EOLD
Q7W@Fք)ϵΦ1캥Ib8zh[ a(j$ 2y8is8$e^dR!U=x xz|)gxPtz6C{kbd:jS>]Kcc\W]ݴf!7M	&RD8߈08XcIOM!sPߡ>>_СAJ&%r4=TP5GiNpfENpW%
iȽ$z	4u>EJF+.-HdcHa
Y*X_[:w[[t! B8exd>ү2[j>ZW^Dp?(R]cg%-~Bs_>h˝h"rݜ]4_3@xۈ2Řx؊嶅?eVj/F)_)rE}m_L8^& (1GK+`5ݯr4ܞm0E9'.Қ\OH$YM% 1(!I+IEP̓D.2E)jIKWWRC5J
P%5MF䕆 xS$'՞{žB#Cv$߇)QYaXu$] W;۠0@\h)tҘ$6撮B?P* pEy^@Ԝi~~gx:$>e[G]^l t+Mg7Xӂ׬+aQKA'^g>	AB67&L& /CdOgmA'm)7VsX{|#uIGG/JjrؠSbE{^&{M'F#2E'jiN*J溦eh;PUc5)x%fBH"
*a6uFv93#||6ɁJM\mty)?wts`k6^rl.7r3([sa5(ѦA,kT0Ў_I]45(R*uVcA(Zz!&ա4B[3_U<sU PSUyVo	BK󈪂L4ӿ{7p͇b]i0bo%I cqK9i\0xEov\exEBw%w}.7bZѠ$
Ȑ{[s6:sAheJ>p@xuMJRJ1t+__53bL1y}!X+|P	㴨<}i)ǂƬn{U/]]}8Q%	֑"FxRoo3]l @f1`!*>5w~>]#?ar®6;hӷw!VKVZmȪ)1}RQ]zovCt$Dꄐ<ҕ$%*Ou'BD]GbRʎ*iC'reu+KWEz
`V$Z?v:ʤ'd0pH;#h#*X\EŐIDsV5ɦ=1g|[g œA/ʃ?la,90$Q9Ԣ3"QfZfՔP}K%Gw~$"#y-衹:% - p9&!8',>𖒚vi&wz>sIaA\ō+Wh DB629
x,>Ifs 0MǕH~¤7].îFZal7M5WLՉd%1Ikjk	,cs#b뵵jí^L̐ba	aT&eYQ ,	#R*-a&]4jmaZ,smaj\"aCq1/y	 tǌh0a"e;v6+kWEd)ĥSIԈC;΄kb5725Tц*L(B uID, :Xl.'o\}l
68Esa6}gUz݇;YD=׽EMAOk8"< !ޮuP]=)rr"h\--+rHa4+ubDᰢ&!C)nF)@+=m.6kL	1+h㥉U6F`1o#sAwF˙$U͡ʧQQǨ@8?;^\)p"'s2m<N%$
(}}Q0'g98@CTfƥΎ+m
.4J)}(#f-X3DEfcbaXQ]Yڨ@ zV%kV;>޷W]c]Tl`'z=fTEM(T5N8,v}!l{͝fxe\ +*n0ȣ+o9
a>B$t (#5UH)U[pR	U}2{>O-KZMRi]mPDv$a1]X4!*rI:GjP;N_:VT>X\M"ٙF+-:+9>9/:&@9\ݖr$O<kpYz9E߷㛸LhT5D;nӉos JߥbbyiELsU =Vu.4Wzum<	Md'߁
Zf"iBGɼ6DX@BɖK$H,̀C9"Em.tJM󗵌@
bʢ).tơ7rX}ߪvs
x]9=T E	"|X	\]KV^ѫfjf#ۍL}i]n2YގS]g8WEx)r.*7%gZ-I{lXo$<ͰHN;\DxZRZ`6Ռ[}Kͽw]/MB@:yd`M;nDW@=p$```ql]Lw\<#=l`HBz$f`H#1tDVQuI&c]l߅̲(-Ҋ&~bH,+QGϠ3vyim]_eAk]ͮa!`: HaKVRB+A z+/
%N\	JGף[+4]9Iū/tuf>.m,.J!\A4ܻQ\B@Pa-q {'<7Y d޸zr%x<%]\.ӏ3-xLu%ڸi  ԓ@4^Yf2ERg08D@`@\Ely]@^q]u'NX/6li-j-KXDL̝mB;` 
sf6KWLut8O(
dm)t?lD]]|Mu}aƆ|x=P%y>WȍWίgcVqT$4Ƒ\l@*mTUQ& @$PfWYmzW.i!KBj9l%ѷq H!zF.;)hy0,Ǹb/++`:3Rֳw2L	JK{=hb!fbl󇤛қQvih'4~3_oKWS#jìSYP]]1iP( *T.Ճ,=88Mzg2js:!*Fw)&gBdP'Gm6\8,H8TxP@ٱ\NGۄVj7;$>]Wo¡Q"6}VXA37F$+[v5lsV+m^kkm3Kd`ֆJ:b)	ML).
Nt$U	R*]b*sa1ձi	,W.cGyS9_["_5lHn0.2`Ld8S[1i0B҈ӓ(/DWY)CD#c\=	K+hLµ	yPge;,ï-O*._Juԙʀ>T}άlȻEmd'DRgI2ȓB؆`T8D.ax(fnPӠV$
I\DTmm)1Al[F%Dpr`Z6顰O!Bh	4B  %I,=fQV>tZaZ$qyU{洹q=%:rt|CL>yw3Mͫ1V#
p6y f­q?5A$2Ϯ!J1iRienVw{}ߛM]l\A9LC5'k[L'H4Y}}BYz:]AF^B_ܷA
s;#&<Ar"w5sҮ.v2dQd  ACP9o,idԢ-ED*1FRA㹾d>t]>j}u@\Qqbcjj.꿿n_ψcfuDVŽMx_sQ)(F]'G| q׺|a(ڢ]_C듇LcՖlڈ4DIBae3Cf~6)La#BV>{t mkʁ0)|I@Ƽ&:pt3..٦0g%B fН}o̕ȫ96XHJA9ġ,%?yfrb'Pjv?[i=&(e`kM*.]I:n  aR`g=Ee.ӄ)|l8:^,u*;	h/ $GZqTemc>goG
K~WN29CS9 NDb[PR;i-J2j=	DOC-A2oveZ7jg#UɚPM.Y:X=(Y &>O?|*gߊiu("D
 =<9f}o²Mb"`=/-W:bغo~iayy'(N$4ROII:wHZdñ}e=ֱFPɴ|)(DZ,$@2 3lbTC*A!cGMH;kpS屒Zª?94wq,>%PVCP[BGHmvER-P`߻z9?>mKKDI^!QX5.ILSmSK;,.+[hCtS4LIASod8g޸m2Gѫi@7Wi\SVwYa"斻=rΔ_*mҵI3hcjԈBzSI5YoO^Q^%2t@Ra:QH,
nQ@Bh'	m<ՙn @-j-j,Zk@2͆HF0 K-kZ1m0]uHВiP5@ Ƒ5,fp
[LE*j.@SKLkPpx}/@8 PToޱh@
'wb5,}+#d#ҒKz:s{?U,WWlnxkatRٛk:#Q2,Q@vaBS~QmM3͈Gz)P3D ӧ[SqU-tr5kaz0kIJ|lLSGg;X_a|YEP*XA^s"HpSG?3$TI=
!C r3rfQ3OAa9{|SdsH1BRpmi+H(n)T$h6^`~a  #kCܘPU|ȃ&j;!fj`|YxmcwOBz~ɈUk8.~EA+q:9𕟼ܗsX0!PN  >:|==c^&҉ 7sCjcɹoCmYNd){^x}aqDhR]:N$Oi`Dފ&%L.0s ])6,a*aF*4tHBEZ X97p$QQ0%ib%Z@\$`H$:`_ >BL8$xjU1 SIWZ[EB	wRwi7algF}i58W:N8`ubfT]1`ow"qXNAO3218׍,(&*GU@yѹ{E`P2DM]>*;+Ąï[)0l	łu3|C`jBnTHBkS(Q|ȇJ+}n;#uZblHJl#kBZ= 	Ú]՛N},Bʖ4Q`6pTJxD
3$:m/MŬ]v=:ڇR4ʭP71,4Ek^de0? Y[vկf}MggE]Ed3
`B\B.͠(	tJ7RLWI@
s"	VaZ[e՟~5nϼOdIpPuXu
+! 8(n;<e5f\N?"\0;G5HI AK
DkUV#}(]$vs0 HyTt-ޖ>r@!=R<jL!C)u@ְ$Wmw=pp$FLLnwiǢ{e;kre"f[/nގkwuttJysܯ+-Ik-IeTj+x ))"n*TGi)LwU{f?!]N7}񷀱U"K X$3MIiۭeoj\12daTűh۱)pT'\"t^׉t@=%VHٖٻ9S:v:*%kY(H	ŷsx`\{~@C]O ՗y]\gF1E.n:M1Tq7'C01 >LH.rU HD)D(8h :A'ue<xUc֖o;JMs#BR"^G ~.oygˬH+BG,'0(1'eCU}MO7#b]VB	r'D9HR΢P|}Yп3ZDcESQSU{_#RTliaǨ ܄D'SBHAc(WIcl%nk*
SrԠT)<yB~Ac`,Ђ}LP.SQ@.|<4Y=l!][IZT@QBWCQ/kkx3X%2&X`GuN.4z@[0@+cvX[4B$rEڮRӵv8g*"s1-jŵa?m6A<_	ی  tckJ/r冩xTL8"#1""I^MR4?D5HC'wf+ŀp#F9M0]GxQ-"(BD8B#WK,$|%wra۹`X?W^fA2P4s c)0\c9$H̎ҊnsO}!Uq&Q`	8yd$(u  3Bh_9JgO;t`owYKkh4o,Y"ٍqysQa)uMO8oVq_; bm\2Gl0+c>.+޷@e=&`!L:rf#
myR^пǟ~' ]vs3ӵ[WqNo6Cp+ƣ9EshXD6JAP6K@Rqs1h&P=4oȿ{{s~%ًuLNAMRY	w4`8SiZJ>ߏ2ޘF:}~fVՊ-Z*  ht.f<o}]D_ub?%;`/GDq=$ Hk;wp=<HWɟܠǃOABpsvbK(@HHB&1">	َPx{X^$<fb䠊F)rz0 6F0;i`Ԥ!ZդMƷL{9_J׻9(ߦZSz7!xSiNp-VBQOGߩA1wu#1b9fAlsgT3ĩCtXst-o8ڼ1LeYBk[$;Zw}mur= #Mu b-t(K*3[[~mid;Z.!-+hǒgÓ`=LIbKgTg+SH.\A-{jSMJFS"D0'"	$ Y.LD%7lS5uE!y`
AT`'xkWe=>jc{> "4WMk!,毕ST"bQlw2!麤[tJEBp3wWj@M BG>:QYůi>fXf]&PrCW`\#\߼1:x< :}Gp=Gʸ8D؄ @Q
l.P3"KF!mar?M،PR bF !~V#tv;llƶ#!w~"7rAqҍg#{@߅1dLVQmEĲ^zeDBt3vBk,Ii@?=\,+4uBMn {㌧7 䧘@#at#FG9;aOƜ*jF"07M{lK1voIˉcR(JDK!g:FyЪ\ߘuG[n:ZNA*$]
 %\mix.,VAHZK!ڻQ;J3tFr(p}Vo#"@}boK23ՐۢγL!AO	LX-A61_gD sv3'p78&uG0&ev\Kqm~凇Wnχ2.G3#Rn828QB4w_1}:VPeUC	z=܈P`O/Ej|wC.ڌ_[l=x"%L[aɻR	`Y )n3u
X4j|W!B4'@?E < :ZΩ؅ғ~5GM{%\_E|)b/xwv_S_ǭ?ްo)Am+^"LV%vWd+1 5'ѹLhMfxY($mg<a$'J9ęuIt=eXPTS,ٺ{v|_kUu
;B)VOG7Yه߅W\@*OI;4eʨ:Qw]s=OYy^z '.G<MJuN$yFCL$7:|q֩)K\os""@5'qn%\`]6wR;L?&SΪKtm>S_ڞC1ofUXI6;p qDe̸4Y&4~Mv]r_ɢ	ٽzhڐ$`V/r0H{%>Ke?ͫ(2
8/jqGʓv'SBǽ+&)E:4snC\ /bj?WBfKQ>sF_:fڊ6x+ECơGWqTVV+"&g_y 2B$
ڣp6Zn.7sh_]7'Еv.Ɨ%ϴmdS/<\1aSJ UcZG3u\yZ+ƩlBߡvk<4iq{<!oҘ+@.=QՓ.+V/wpƕ.BEbTd(*ie8(Y4/^A|V%W?:WJӚDrn1p]T>r)ߞIԩ|7~,3!_l\9{LxV@֪NlIiSܬ(Mp,2#%1uH/8 \-4Sp|%7UƲRBG9%2?FWRk/Ǫk`]pfm;)$yYC7wexgjIDL>[UΩ6f~d;3"C:B?G:#6Lq}IRZl<H/u{*]j`@}6Xa`!q:C8ŚN?7xlli!z Љ ݾW:7qRO{;_ML	պ[Eeb}TXlqh>KzI~ùk:O#|RML+F=VxС]ZC+jxzeȩDL`gG[f|RM5f,]^=V74Z//:o	_6C)02BbЫLCn;u-9)T{f+9A$vy0U@Ω/YF=5dI.{v/=oo~k@6(ɀ@c)	:}3W)rT3	 qzzM`-Pwmp#0'KZ	?'}s⺂I;9D+p9L~ɁX"
e;uSbh2}=Gy?s`2p7,z-G^ $1'dBAVsٻ 5;Ny=RR)aIM*BUW_cě^k 6l޸p=BfCsn)wX  ?H0>lO+4OW~@!N9YK,|BĜȲv1rKO\,݅	2QC<./2OOur8N+D_=ZpX#|jkd'\h`]9fդP4ʏe{y}:ׅuN2}lBTlۆS ėF]jXMB[eW	%cxYC9,z7#6j2A|9BzB0Na%0N)YvqR/U\z*St㮝`}{4oKY0"L8yhz^uVC"$g׬<Jت|hiF	-'I#Y!|P%M͍@ 2K-G
Y8P2J`&!#e֪5sBV"r^	a	J@D0V*p(XL$&f K E@@	1לQai|mufny.hpeRBc;ذHJjl&o7i_S]ZibB4ض>Y'W>O]C)o&To	tVںhp$谅a/oQ`>11ͯv-hb s"@w)>EYFqUwgC>w&!䲌9mӹ\lQy[X)@SkJŃ$ =QIhXpӯ	|memgtGWExWŊGQ #ahs5jg\=bүr,ۛ0"2͇OL8geGnF`Qoj
תv]/^۷AagԤe[ԊTJ0N	X "aߖ>2ɞyE_mּ9GlIL@ s+`N^<%.m J>i,+:0_dj𱵞G	KEF	k]ܜ<5h_ 3v`@$B]Ez[aQRҍCL<DLH	q FkO3Sl3Q]wPQQwح T1fmwvzO:O/k躯WTƦgdAJs-F;y`t{+'4϶$J@-4X4ܹYZɕrMtUDaŇ nʿ|Upe1u3H*Z6zSB3haYq:;Xav#$i"D_|.xo}I"F|GOSE]JUuiARv9.{xEwLZNi_L#|GmxV,D:d"[:TݛJC/iKkt}3.7b1~.Km	h nd^ YZ0ަ> AIkj`m@{R&s6n4dG1)uP?ҧ3oY.#̍ 8KOC_ƙU @PekKa
0_>(xOIw iit9')AQL:اN1a	i ӏu
_vrTerIeD%+ wnuCI>q_+H3/9 APaq4~i@;o*?O1*lw-	J
8̿ide)~+LazES2P'z\z_4Z}ͅO;ʄQIbb9#fB&G2pwg-}5C!>mֻ^4\6Bwb	0|#)Qq$y h(J_ܛ9{x?O@~Lmf ʖ
8LL܆ |qf󏕲a$/4}ek7q]uL/(t\["clx*o뮂[P"g$ؒ@[DXkuK's =	lsj @WKΠ kxz{!Nf=/~L{oV h2>:(h#l11r(3:&ql]D](m	cH?Do	DXJվC32C k޾	[RlX\yHILoW)Ng',0Fe@or$9eu;}q@dU$RBKv¾ʲ_	-6ѨU  Ķ:ra ?H,¨MVfcn$9t,D+5-klWoUb2BPoG:ۏwx:=-eʤ^r@䎈ʺ*j86Yoo' ޮX(B$E @$Z7+WoS,
r  I ptwhuLmQ,tQu]x-}v=qe94e"{xs.MV3>b0Gqj'1*&懧JJ" W=UߣpQ|RV̄س9VMے@C;u0j!bS44'%<ˍt?M`*5Stxٲ<HV+kZ)b tē)bЊr^:1GifYZ rKlrol0PAP!>-a]kx	% bW=lI <
	|TFs_jWYcIQy6z%oi t3 I4jY_mXSPio-ß`5ҥEEiV0|-F{QH>'6	Y\PD a@.92 8ih7vߕ_7sqn#!))+ E$Sv0J?,(/[=STl˴bƋy PԆ[ؽSpM  LD>RĠόIBkW%hW^,gnu2dZ_oVk wH仢s z[1^-O`r#!MBg
a:<`v._GxnP"KeF𸻯$ڪxBo^P7d$`Ě9)!|8ifVQKw(㽎5ǂA $<IlA^Ř(8Ɵ\)PIkJvVxfC'[wǀ;lee(`0"!{L+0,ؗOn#kR $P2 toQnaə;nf*IëǢPB" mLm{5 WoB:#+>`QX#p.["2s2ff vvB($6M#D*ZYԳbXq@`0s.BeeqǭrdeDo_R@]#z>?|.c{T6i伤
I_Gpt5_Tk.3"e&&zm"V@OJRi3Y,[&6; U+	VM|rÏ|&i1!^naJLd6`a#PH;3hntUjs{~`KTz$dF*(i8RQoU@k4J|2e41<rV8%dA1-Oo bǾs祖!6*9PZ:j<b]j6͐Lf<NT,]4U,hd1@k4(yGv=^4\@=$&aUPBRzFL"ץʡcrN%ϭѢLe*'%$Y
௤sv*;(j[q+JU4yܱ倣~Tns}"qg/s|xBR04B	9E%+G@$mlLDim%ZIS1>؆<@B 1@"HD¸9Xx+ֲ),քޡ~T_^:0hD"sp%grL%7VI*01VspcDf1Mxa<%0eY#26l 4h*T&\*?C2%m$L2Y"`ljN7Iv92-Yiy'0_8.9=a53yR1Ǜ85H[ Mex\ԙwUJ|]2",Fwװttp?΍=N鴷b+)f~H,WtۗGH_dJ5_D3 9S[1c{ʅ07D"z2<RX ]׫58=5m
/}JnL2B|mgۦBzJ2&If9l<'hӈp8#f&}Yoʓ&jp#fwy6u#SK
O,o*Kqc$zRƖkPБҰnlhM̾	'L6ZeϞ)V[oLp8N;jl^<sJ" bLuMIUeOOY"{DNV~w2-s<
	8f8ښtFwNXZn+2JH!%R
VG̪$]H
akm kE5eTѮ/oJs8⪪;`}^$DotB`J=cԸ%&xYW?"KrV3ßZZP)fqOgM% 7^_k#d8r]~%iNC΅op!@W6GzmF/N9]L(@u5 ď6"Z%E<^UBƐ@so +--d3B̾Z.{,Ւ7Mg(UW8%T%Q 
H K`Q "&AhND{jgWs4#aK[a/~m?/zZ%=Bn,
Ri݉Lb*no!/-'ߞ.1xghÿmZvN[0m2I#Q!NݘoiMmZ<a99p:j*	\)D֍YϷ	{k{`<Dw~rfӕrX"%(z%"6=F]NQr% sø{Z4*%owXB[S!);4/ͪ-'R	1b%F--#tU#QPx!t/O82OgSi꾜qhkBfH	5 |~oj݈̭^x?S0i*eڍ>w#g3;(M^Jc5"DU  1~"$!7ܞ$AS/s7G+ښ#"\Z	e0dBʻ_agw	DRdH
ּcdP`SOeD
}?3E.
F6ퟁiIB;f3ēMpӚ9Kq1;Bj̏9yV~.ÃC~+~CD#<'&w.D=/])ߤҁU3lve<|ȏ4 L	jTTVO	?Yx
XgLstm͛w:ZgaLL(GuO4[=_3:)2ť-vuFp]xPsUIXAK6`
K6θ#@V Qq$Qiq$Z$i:	<B$`*Bmmy E97=f@puE/hn0B5y'(b^Gùo˴k܅9)jrt7P )*x
E,d-Ǝ/^44"o=  \Nn(4Qq#!#:eޟY]oї>]1C/6orW%?.TTbQZP#_5WNZd`@U0 L2oYa:_о4%%"{LSѵgbl,竡%M:5orSQ޹{7~kȭS|ⴔ MP8E30_f*VS c:խ"\)T!AqdhҐ!E.^
RAmȬh@{(^0,# g1$/6>*UHD@D序LيjC0k9j0%g6L}ZC%z%g$h0 o0ҪTQ=Q@tZfDj,TZ^	b&Ʃz/H+dEIe!(d0H#8 c\4QXo+6$lU{˔#)4U]@cD/5:ISfj_nm7Ё<ih֊)DT`é ysaE+IjWK!Ihh~'mvo=HAOet);[ِTtzWǩym4a]UGչtԊ,Ā$XT7e b؃鿤1m+C(P3.	z}#z.@#mTCq/[苙%zmfb XVt" J  h
I GR'"&sP5ypKDѿx^<7V9wA>}\I<3%cg(bOK|I-,$C C!u膏{

 1ƮTyP
Moj!kXIQrzTn'[3oe\ܬX(0,޻,QOYak ,wL	
#p⼜͌kԺ
=.>ꃪ~<'M53+j]:"$ $qʩeb<w|N_m(4ngBaz `0/kR
Q6ԭ鞧<\Oɽ~#ExyVSIWg;$iGGhdSW^V_\o&{XC
 0}>
K
r&[}l0y8 By]bndv~MZӯ-e<74[y62Ĥr`iDYXGq(r{<
1"d1o?%nJceLfAR E!GXI]iYrvYPY~WxFT7ku[һNJm/mi\+	X1 DL<GIxyairK1=da<8qH+?1P4ux1tMGkY&^ۻ\Lma \ 	/)Xq;KXdߚ\r'919E<s[$ͯifif7 r򔌞əHV<G UH_9K,6\U&)A-|YzOV|3vX[YԴN&FrPP$ll$c6n*#tKg}JyYk.EģPl&axaI5
7Xdml_p2 4Cw>zu6k[ȭT:uX o gL8k%=AWsBA`0^(}$Vg	ZX	jR}!U	Ad͔B2|b+['C.!#a#Fin6&A`Gy2ʹ2/{_4v5T"
 $ TP?_f޾#Yːn߭
\h έ!j|>p_8d@07yIho1.^_:/|TdQܩjڕ
&`NpFa3/yr ""ޖ
=]x|>/եˋ/6KBŌDD]f8wdL2P;vҋ "qMU/cGoMԠAY;5^y5vxlOiİM!uˁT@,]wv-P2nپm5]lVf5f!(AןRU3RCk-S)iJgd2PGRI)b0O"	y5(bP방/`sޭ^N'rJe4#I yma}}Cq)L;0u
9֞xWfεKx8Rc'WdW%5{MRq+27SCCzjzpQ 40
dҫl*[Up -oXDՃ0;If4"s)s0V-}dOW0R`lwo@D@bo!ʾoezI=}Ơ\&y6]=t!JݓT7Dng$@Yy|H}/uIu=^%|V9;qF*tYK
W*aX!rUQ9NSQaSAo\a3B_.*`dT ># Nz_QHQV4@*aJ2mOץR
ʃP$5iLP@D>5Be=rhU[dd$5AE=Wὴ=hJ6yz{
>wsgI"u6Z4zo~e*u2ld X+'*RާcN,:m}HWRZ29ըҭcajB˟<`jbSZL<Ԅ,Q250anQ<C:O7q/.n!%]
7ivᵒ8X6Ef|,j><*dDkWߖ+<l/h|y^kXDk5=i2,$	%r4RC	:]qW3/3ɎE%/C4=Ɖ`זkix͍"5Q]HEWU`P g/D=E^RM=֜/ٟVTTuz+ƴZa{$m>pBC 2l&eixhj!$  jXw+um9V4oj1,V,‘9*dAnx:4'5SXGT'Q#Za?w6Fy|,\&LAnIk3Ӈ(},CoRsHJ] 8$J'hvTQnh4oq"j:ǧKkN=EE"	uUh8D$+v$ײL'?u
:Q@z̮Q<DrĬWj6)*䌫8cډT@{:n]8?nGp,ymJwi[|.NV1B}a +M?J>k~ec,;Q8ç'Go0O7qxp'Y@΄*K?eTNH4dAМ>fΚ E5΋`B F-7*UMK(#THhUm6F-:北#,I1 HMZJT3}0}IYN%G ,(dRCgKp9wc`lIߑ+=Qf2מ_BmnD܍z/q@?0z%yϣό#.
5gS/!9u+2 'q ᭰ 'a,Ucbps)VIu-|VYzk?όx}cٹD@aB4,F:ʘ,PPu~QCؐ=.)ME&iJ %rTLDT1%לa7Y
`lHbn՝Lɍ,y,jӕ `M ck+}0F
Edr?
Ab	|גfj9Y"	nab,6ngpqE͞SonIVl'E)4!bq=ݳFoyD @	gfhkR]jVbςWqv頎\bex|sVno:o^wyX)3U;ZocgkWPS6iLE͚X1a49FzYTSi,gj^c>f׫f'g>Okd`ǐA4t¥MF*F<d0<#TH8L۹OR{D|l Fuy^ʢUk"#] e"fbeHRcUK]~ﮈL"}jJ}$ەy*8jN+}Xˆ'n7X?:9!5!yєI0Y|JEƗ?Fg+LW5x`"鯲~&9:tZ%&2#w-o1o;"j%9ŵN!?d*RE" 2(Y!Ԟ.34 [u,d8&A%92t(B;:]=ˣX<td3Bfs)ǠL) .і&>sܥy1ѿF (b!"J~̰	4N]2|JWT2<0n VeܦxKpSgGDFN
ߋ9E l+Jb[9Oܭ;MXg|qCVI$uNTir=OE
$o]!a,@?ؿ0(u}/.Ċ%mbp+>q5-aMMr	1+]<Vl)x0'tAN_CqT\!(ƪXTyV 3 G<:+(z$%?A_MG&ܑEgو"jH;&E!7KKJК)q)nPޟycꮠ6
pA+$qUY0Ks~.sP`+SI8S.$ƈg6XRz 3ŻoQ![oY$v. GQ	BN%QBw#gu9p޳7O~^oKEPH_ ё,u7v
Kmotȓq'LYMJཞ3TfQ  "Dg;Pȡ$&sEo"a̴"ks-!4!&V @Hxo?ǲZpwlxZ3C1|<Լ
aGx5!ddsÑ%Il3}YI8i2u1Bz)7Ys XBEYi!NY7Ҝ &Id X,w2\'=E2qWut.]L䙓 x7 8<+we[#Q%6T69$>e%d8oe,>D3:[/`=.0R*Dp6һEDּȐxx
z]MUz.c5v۪-񿞂9RaҎh%2*KSp>tbMш+30ݰpR881y<mz`G_NC'	@Y_a8}tk]Jqo7g)
j+VeA. 	\;4M/oYzIH*F)T@ᛀqwnoD9+/"\Voskf+!3#yS/0G%ŵ0J:|w׺gPЮA_3LDZmXF7g>)Z$FrwG`0t'L93b"+|-1Mqb%_E 5MP[&YqCK2H2:^2kTLf!g
PHEĸ:#uuIRB]1eȫxum4:uEÜI9{_-[daW`	$ڥ3E\!Jf"ۄ9]`A^K] |Mb\!M|6гYKQh%1 }+Q,[3&('Qw쿅aTpCzܹfi SaTF۬DyVAMRW*:IJA(-TDjd}eRA-mANcavƿgӭ4В$_ςР~[BnDQ/z_FI	 ioPT lbv
^>LjS@fgMLpZSec] ^˿ˍWK"i3ṷ,B%-WW*W|<gHTH.`i,$ "c·I"5L1H!EPCu+_l]S6w[I!d.K%ҋ{<:O[~JͽrĭTq2PfW*k[Qٌ`&?&R_vv"L˼O_(ȵOyҍψW :L;.0pi 1 :K wҹZί9{N'}q5s nS 8[vMG@M-$-|(Tun#uMWNUc%'.,a$^%}L?lNVc5 4'AOq΋CKLHu}U]ݿ%p!ND^aސivZ`$ZvZڏ(@hmsk=a`n6IaQ]E4ـ,EAq/ڤ)_׷w*JJ:I*ה	dF/iզY&UPKgN1VyŽgЋбt%eWB
F2uʱIRHgNDc~n[ʋ' 7[kD}!sdJ!0op*.}<s'̬5+bl(lr;e/Yڋ=}	EM5$(0Q뭠qmX?ŤcI4 +%=[q<$͂Xe`uW˫v^"s?3oμޓlR5URj@Ⱥ IH1dUH1KU1XԎ{xiyMU{H<jp
`ڼ5dX3b.DA">?ANhg6TcdM&:DHUqf5in0ҜUJΔYN*?[d|d57H]?gAs6:uz:11{n
g
&I*X= pƱAGO$y~=l+eB1`1_z-UZh|5>lb
o;B2#ﲕuI ܙ0v4PATH_TtP9ix2EP@tb [K6iGm%kx^C3꼖D.)Gk.3"'6}Fc V~b40شqr{dǭ}pِ{Z&85Jb@T0-=K:U^Xp8bWg{ʌ:8S W_C,MiP-sm?HUvA}W9{G=`1ÈTPsBE{.=ut֖w|}(!FY4H9=Q-wHv=CQ[/]X3!1hv/Rc?+MJމG[bHLvRN=6%T;N
-~|X|rM_?;;qF[3
D%Vn'=ߛև!pHd%v.ޡ:RQs!>DVʸ<pY·[ֻ^uUYJڜOK;î⚹ (""%Cϴ dbnZ:fz;ҔPXxnԇZ;ڿKBI0둆m0Ob4j6}W%)҇>'e*(ˁ~$s=5Sӛtϴo<v^ Ȁ@! N#^r A3g"VX0AUyF#ND?S]h"G2P+սpV}5C$n1NHN5;Kv.ؼ_Su3=\Mqz1iFHPCoS~Y>
0"Omܒ9S!χP?l#Fޤ:0&*[z<pΆmC@Q[YØ)yd.x} םJJjS+	3$!J r=֠ɍGw1"iX/,夊e˛FxscfvSEAb-q!$FW+fѣN7=LH^`߻|%4=z>_tCV~_eENõ#RF' K\zmÌ7"gR&	q2ܯ9:kUHePChN9p5u ūb:-1,vYő#QX sfbⶑ r!`hP?߮@ܦ~peEInJ!.
h@lY՜I/ByjGʃZQY?JE
_=msأ]HtLmG OOoxBF{UiKwo$Ǭ2%hʦjB¯`F'/;Ok镜ΨHBJcʠ1!&JFDvȵR?G$1Zo!{jo V:ɧDWgb_?JqҶ][G]lpTm7\F0d1AKJk_?j	ͦqNgtzDnA RDD"mbo:cXj^.N;Xj끢9%Q9jNgvڕNWz	h Q{|X9Ś#ϳW*Fte{pa!᷿-j:[tئZ⦯ȄX#¾{R(R^zJAtT<%h*a,mU*W$~ߛ@Qފo@"#.ШeIӋ2ښ̙6,9c:6'x˽Wk,).(Ƙ@%:"sBsÎ.RI𝏉3Oh+9쪍4XiLNOA^NOvӨA)Uv*u"u`.s.l]T}}8|_qcRP>!W{B B(!X-XM~WQeծ>`y|4|oӌ38W cdred+ ؔ$w+A'r̸ &6+p|Gv6~\%" =7)bU'?%n%Au|SR2Ig ?b<DFHs[ZY]Fl2**2_KqG}/%c-q( bΥΪBVCpz"pGz%[666xxE(Xز@B4!3u/U?fPuD׊fa̓e2%xIVcc(DdM=EK."p-a 55H#=&Ƌ(/?:ոR	@]4,챹)nI)\<g+RlM)(кUJc?0h<(Js$
$Xz.FԘ5+6fq\:j:h8O mܿo.4;_GS\)BQ`8uN77QMQroqf95UVtzLT
=7Yfm[P-rVyqkTY0Sa$ R"~
li͌V\Mz5(ɱOLHU۲l)_R~j_b<m@v	%MZ
G7Y.:(7Um^tY/=UZ(-[e&-<[ƀ창إQaws)j/y;<	?Si<A	иA%Jɩ>벨?Fw8GԤ%-cXqF%1ƀ68Ga3k9j/u=G!Mse4+dIKb $UOXV2{9s'AGfd<sb=<.I90m~իX|KZ֋*&&Tk^b9T~B}fB{9jwR;hk<
ńΐ'|}P
;.aI準*t ;ux%S~TabhCNfكo*ww5Ye
RIl`CsSL)L!+YQ'5	|7gHٯV^&Ŀ*8no:r/6)ZLk(6	.x|^^J4U
,PCUv"(uL:zPY0KhGMcF)[]tgg%@4Cx
X@fۚ'*%j)PbtV'rAypʝ7姽?-Ipyj	ggҳxx}I@
PHKƑ߹8n7!$ѶD;, #'
ny8׀
Cݑ\+(puje'!r!iX>O}JS\O֢3Y#N~l6uIb|f!h<(  ,Q/Ku\YquBf""MlȆhL%`}{fGUV-Fou{	՚ޓ3Ӌ[oçq^+5VZUc4LXFIm}E<xfa;"Sh^9m4J!Rw({;_Sd%- ~Oh^|}go-t\!w& 2j`GPct9:vi=x}j`<i>tc -9zCxZSDA$ZKk:^~.P<% <SNLgiw%Q˷ES .;Lη6cZMUf0e~Eۆ/b\9QrN+"Vi-7V&ԅI
IDݿSRJyz.YRź涻[^-esv[ lytoM$BU
Ix	^G#oe40
/Pʉg: 6-䌩&1Yt,Tg{\y2V.+p	ޑ+Ki~ǜd	$<P
.@ wkL;:1/k TFY$0,ZTU[t2~$Uz#:BٖkjWMfΌ'qL{!9)rpXf>^݈.ϑ8ǈ.s,^Rp':QO+ҟUz1"Dq# zg~SG>7XĪB&|Gަ ιHH9&Cŀ-iM#ϝoP|,)IoНLb_2񔢀^TWs2/5.4PΠ9zEZj	u:3thaɎ=r)>Q̜^khϐRJ(V*YA
oq;:8
p\~w܋-@KʃxI;#'PQ8	W({)DaF.t(Ģ) L"ׅXvZDhBB ~EmǡqvT]}	 S,lXvT*d[oy{Ϣ?U?P&E}~WAU|W}Xc[[#*D(#.gJZFöqJDp ! \XXO+m)mӫL1L.ziMS (LhDKM X%(G)jP*ypyFhrzNV\ !Dprҙ @	HG9?o&SXYj58ߕ%F2r吞@@!
fmJs*+TK&#Sy]*vhn6q25di~D4UxcKClz~\Bo-ԀI@(9Ul@-{F.)4d*H6Z\z4S~˖AHnYnnQ,.y@ZdH;	o&퉧ha/qЗȲVFd)2>jqFg^[ðAa0G@4\sh7"\'
PfEX%PI[!,Uϱ<[^K65셀g#v?OWHB
݋tƭ9?Y[//ϰ=K&mFpJ!*I!ʮ*THC!iBÈj\V17DFɏ{$Ht5}7%2 j s Sf=khz0"""U8S[FPJm^l!
Cqtx[xB4!vKw^~׬=TP?T2E:[܋uRɆb=DoPZ1isWKAkC1 Kgi6qTaߕX*oa`-N
8,!sNR,d@O7v^s>}ߒe+?C}}}Xa>|/x(ޒy`Ta]Xn)SG>TLKbQȹ1ۨszITXey<z:kQ=$Ӛ}!'z{Z!\ϭ@ѵtȼ:3uvѾ3Ĺma0q%nڗenqF.gth%ϥQHJi^rmӮ$ոfۉUw#b5QF7s[@lzZce [B-EƊ/<?Ϫ\E9p?ڿTB101(+"8$fE԰y%Dr:I땸>w0<ݴuM7h,vԿ+39ߙoYRTr
T٫ywmRa!<9}&*jo釕vc@6vkݲ:&L[tvA)"8w5@2V cQgks{>PD<e{:hEwʯ6"ax_'C%	&j`F%|TdӠz{'za	_Rp3ahmz#>7^KGƐIYٍHi4ufەB`^YC΂?l2FG$nrg(6юtVEzcIR[g`,,j/:~lo4c^Q6X%bR1S ;=wh*/'Ǉ3=3% 	j6M*)$ afƳx(4z}G`."ik˻J^?wYm'D{۲nMkkSeJ}	3Ll?.g)܈gnxV\/|y^MZ>aMTRTe6XJ"}/w$k%@\q
 ))BqS*3V;t1]|a^~veEP?jfi͕<HQKWg'ځP]@MZk];3.IWRE`Ő
2(ݟ-
uHk)x@B_F"C~ӱғQ1MA2+ 8CG+ģ.LfC3%C)y3ѿw0+\Ez^{ѤaU<w?fkHc+	5Kc4udw[#$)pԗCQ_+Gү^gt@
F+Pc[?PMjzŖB73s9` IMBU^@^ \>\?%ܸ;ή};7jAW`BHno0m_u>NIrj 'KRM^2UbI'h2ZNr:w)WoҪ^Zqc90B_98P7nZsѣoi)'\.XHFR$!IXwݳ6P\BT?hNyi'rBGJδajCbމenuLg^V@W
r12ei56dEd"8B@,SJ	B;ZxU5oq0WE1ۊ	IѼuЉt~>pe \TB<Y6YsiRP! >E{jX#P'jjFڕX	L2LSTᢣCփ,kUгv:meD !~xkD({	dAC0EoL@UO5|3Z^xnX&%И=jF
iT+uyEf {;Db)`#7Lv&iFqN=kgjLp3֛ޗ'53c#τȭþ>V?hXYI3L T@ڿ:؞` 4LӔ.ǣs\^(+vЌN(qAӡk:̤2l)ݗ3p*	!B(,0KTq 	 Ekqub<[pY=^ZoQ=w6}?^O+,~z`k5IIPJ-<S1Giǧ$1NsxMNFK.SYБGڊA0ތ$VG̃cs&T| x=&G<>Dl_D?O>ji`:Fҳ7]R1*|j+ʛEtJȵy"Z	-yS\PQɰ!j"3!(Ⓤc	EJE$)۫ttdd̂j\I *U"d0>TL2%Vf8Cҝ?,|]Q )7!`PkP1_[ԐjXÓu"AFx|F%j&tQ*6P`(aSG;Tlk-D,,H&cZnEv4vVF"vF؟?BT>-@ ej= p\߳H@&$<1+Z_6tߣc:&W++N\Kv(=>VQkK?Up X~3Pz{yTxeѺ{Ii 
sEUL:T*P1/&zf\B\G9I@jm	RJQCK=fNl|jߴei i$q7>UC>ONnl70$_ɞ(6xw	M8h߳	ZV8GX9}SWtj?> %tOy(^LrV0ulJ3SYﬄHP^ǩʎyρENl77Y)&^Rz[nqsBK đD 1"mGXPX\(uUVH	 ]ݻ1?f@Dt)<3/>3l&tZϷxZF0Sa4b}b=n=IwD~ic$eimorI;65+(}>^̚;h7m̾4ENVwytp!D٤H,˞i#wCVbzԮ-CAr+5u7Ya=
4:6N_'JlA)XF޾Dd_(K#6KVLnaN0)C# <SR+GS_q"98K!]X@K\6ۚY4r$%fN 0>~GK_q+{hOBOr-|UTYqIR!OLQE &W]WJjo\UijVDt5;&0Ph@=ElЈaףu밌s={Eg>w'ftXxՑ8;!#=Br"ѭFZǾ#['V{kAYvvPڦ\I^Qg)81#kSW5*^0*$P݆.I4;cI_qg6@`+4 1DWU]_Ec{p>K»MJ+yG0Ԅd
=>n,϶*9%-6 Q.4T#̠O9؂xoI_snxVzgcC|RZ-R].+ƉfH8Eqsb
9&vLHXbkuvFkDj	ӛǤubysP|D¿UݯRa[}B[ѓGG].'58+x5
W(sR61&[cvȫ
Ȭ^.騔ZR*N
&"2OӬ{g.M]@	D|Ri-t9جC3=U#0/c$A4\MuC(Swvs{?+`1A)1D)-
. EBfZ2X[p:<O^R45u/䠰{x5A͚L3U3=@ʬqN;n%U*LwrX9	NIHn"b"Q6	:
bh~43btE8>Y3	&Fkn,MA{9oVm/v-26րfs"l?m=׭|"F73͛9ri	bAi3,dl/" ``x	$KWNŚ?U1ߺ,E0j}:z
HMAъńXCZ02Jg)_ql!8RY ?h:q"WSKaPcsgq<
w	fokʀT2g7~ARx2nȉRΐަ#a,/@3㡦@'9f<+sݚ{Z#!y#58ҷ\gN2X a,.=mJg$23r'{ùvA8C!9F[,1]gN}D",8(`oPDOT1EO"ѓytoi&5cB{ =^Ğ0Jd6L{k?tѡ9HQBvp@;8N!0P};籓~*2piV%n*uZ6|Au_QK;7ПPIi~&͐CnouOCis e'Ԝ]&Q-ֳ}'ߥr,g1Ĺ'Ӗr/߾BF0`.9:ʆ(VO  ,uqL	>Fk	W̗qg>ao7KUt8]0[ca`F\-{O.	 	f@8WDOǝ .>ڪ1'~6}v6?ߛ3kH	u'Pȵ9iGb`0ɈoWJG2!i4n}OOwNٴ4"BVm2>0K@#krt\¿~Wh"4 &\`jL^	ȟuaɖix0/#A~A#a8j ן=~=^Gd ˖DnތHs(\:[d
`=V[zO.B,{4\/]bd**!69J۴a%TbCl4U:h}Y8 !8 .]kY.Y30Wu䡬4ߡ<5K˕$pd?EbbHw$B͝d1<lE.١:>7Ⱥ뮱ج	[ĵЍzt>O"hۏL!°-*K@YX$Κ%6u%pZ@k-,$v_s^ʚUF/W;]x/~9*xr'֞v/)kI˾cY(pOOGх
DQ%\'PH7ɫ B $Ddhn _)lDlo;M &9kbZ^{=e~9;N11%2r*ES@@co3Oz仌?v_v}%q6}mR(omn:Jj_-KI/ a
 UT%KӘԥH4AD_!ikZ"R3:R`D,ĵ2ӵALOF[7͏cwOfr )^ L`p49CEZZ' ?63͂"yb+10 ´.
:FSb݁?_'y}q5Mn^9:"C@H8oDrIdYX:f;#7p|z(JF==⯒.oq8#lnoFo݆YTegY//YfIMh	I@Y 1Ar^*jƥDB!d&zަԈEuo"5lmR%I
?H>e0iZ'[>n2W<&I0&
 A_Iz,Q,bs7QHhc_`%IkR\eQ:o9ݙ`W|3p,gbdMO!l%̑`qJr&<]y= P$
8[If"WE]D
21$o92! IubXP40^^sTkxy>
VM`eHh=v  mxT`f	i;b
BeYRe|~pe:=M#,$:Pґ`f	Qô)
،I!xVwCE<?5902Pf$xdcθĪFvQ;-OU[KƳ8+=k9!vA EHF	ejM4,` @Dp':P_2N+kr@E #GWVAUWQYt!k1LcX2 etfi^{-8kD5	|yH1KZք;Rpۍd"Ǭᷢ`ݧ1%VKy_=KsӇ)vss>*UZEĚ"!($Xo.
Aqge>x΄tU>B"0Lu_v74V Ы<RM̢33 XL*|Oye@BI4!#6W't4vBq_C0$]ٺ6X"Ji3Rܿϻ, GAk6{J1rvsŀ~o?πou$l1
J$a!|Ɯs&ZʜMw=y_Ӿ)p	}Oa^rL_\MHhN@i$[,X@A<H){\}*+`k볲q2īDvԝAPT%~N'!"PYokə̧aق@99e&$;Pn7:(|3RJfi	H{
2,;	V:d8Ͻa6uc%Ky v Y޲[ƿ-.BzVmHQVW3"y9f\OQ2/
MպEfO3Ћ2$^_u=865YPN䷱Q
$&X)>+)/.sSqUS^eU6oh˱s&a;{Pxx^Y, h	$ՋDF Y+ԹHSS	 H*(
 *Ɛ&m|vlyZg_)TfP	puql̓yc]EF'Ļjy+EJzܜDն5c`@s9K<njTN74H$B[+=Ts-Ji"~zLهDYwJ`cO?g}jTĉO(MCYk,IN#>CNwY?az}*UrFg9h`b!_y}j}ݝOvNLŜ٠DB1)WM"&hA4A#%WXp2qI7 ;v~l"ퟄWwsɘEe|x	4ag 4wV}+ҚcecT'\DmgՍTCzX3BXl/c[:- 883
*fNmPDO $tX8(gdCNΡ0Ioi
	u-/
hu@ E]A>pSOfMg}lbV	6FR9G9Zx]Vꂡ{Mǰw2e@i5]7Ț <S蜃^6,@XNb"ήJC2ʹ7rF+=WC tQJ<0&0
Ido8|D~	'F(i5ZUz0"H	  ˵ʴ11/|`O3<8@). s$d{ʿX*K$} felȅ}dQ"$Q]F_uFȋq_<TLZAtX<Qf&I6.X2!}Sa05# pUqPE,8Y"!ƃSGhG&4?纓v")z%B2FXp??~wXE#|̃0˔MzlqpavYY=;&i#WC7x%c$  hDʷ8Eo3w3APeO|z?t@}<̀Ϙ,efhRH)"[ub
Ea!;|fpBjnkzf/}Ղܝ$]:4H(p</G/V[,Qp_b{Hìwwl`ӅכoL=aΦ`8Ia.
GG"hF!ŬIk#2}+fMn[p5ػuѤ-Nu8D1BaOP SU:uDsڻ:2N^rcѩؚ?`Az#
($0Y@b&?ǠmJaOʛB&kRMEɓ8:uX%d	u`}fu+[6ۧ~WO!u	Vu'̽=C'ґ^?[W\ǥD$ D2 w,~*LhJ:ʜȧYH`|a5nŠ"`)B"av.2q-wZoחc|6XS1̅y%(h]a8( )jaew(T9[D !
A2gIȢ.UH%ۊ	5;.[
J[8VR~|it{ұz!nS3ezAa:Pl[m+xG^y7Ol}	'k?-'2Ni'ʁ§sJB47|]x-O5ڈ-RvZlZ=ů|ݪ&L]5G,
a:";b5>Aɖd*?2Ĵ0"J)F/.&VeпM~`̇tpuvap~l41q0;Ļ6}׻.Z	ȷ|yUjFV~nRj+16۲UvM|<ݨ5lL T9
*D?23@LV%/80ξ=Z0\GDc 3K2șgyh!Z^n8WR89$-Xl^L<.Ȑ	[H0 f0]ݓ٥TF6,*{F+c
7ƛbɋh͍sFvr-nzFmXͳ.^䷠Bm~nUݸdqZ6X2Q[آ9mo5+r4jQFFc˗Úldz0N
nIBv208Sbi{lnP9V"<&9N4,QjUC`G`ڣAFF}dTD@Y2CB9ɐ&qllYO-b#0JELl|kdHZߺ7VJA#N>]mZcE6(+*-VQJe*>]Uֱrd5kL?sA5Jh(J8;.C`52i]Z<.h7؉&EѭJV0P;;8jelؼ]]H!lkx{+%+~l8	ԵAmuvMZ$6~c%/I]J:j!3pCxIDZFOɮ-=xadwvH=)H
rn$&׍ѿÙt>aȒ0jƤ-#J4ң͘LMd5-nx'(P2C/! D1.m]nv@N+h4[q4R&DZwУl"ƃ-TJ5H76CQj-mkL*ɔd'C
JQkycsnK]G=f\f9o@GnݚkIQLNO~Xm0#ܞ%܎y<vSIԵnF=1й8ym+ZZM"Z&ͭ7J+nъ1SpZs%505K Zrj5B'WÕrnJjMsPZ\6.&P!QaژlH)ݖS}$>zuvkr0Zlp6Ɂ3ṷ~q(C;515ɟ.7HiKKit99A0 6uOӷn"ڎ1"qa^k< /(F9'e6էi0@6VCLTa`5h.qik|Ka+f7 C<99#¦ɺrƹk]Sλ$vk&g&%WrYv2E_[EZz#+2:ߥ	ShU$3=mw~x~HXoU5Sugg6J?sǵ\F[\?WkMjc=ct=k;Gl545ߥuV-W>Urc4T²Ƽiv'{32?ywڴ%eg<$<WO&6NP<K[!^"i˥U@݇UWLdĪ_ɰfmdyiGnCoXsiZO_ʺ>RQM6Mw5h^^fygi_!7(v\CV~4깋?e1;}C[&ߞkb!N(ifÝN;Z@ܥsI&jVMbOoU-sNq?ט6 +'5hA1Gjv;2 ?Dc^ZOV[M']Ǿ'$~d=d'ߔ/guW=|7ތ=ϴgƙLk8m'P
`y=/;sDg.*ͨH #97>)^Ccy>+G9}K7i ܳ㽩cH{UtIaA0yu.[x`{5S
{#ͳ\AÆ"|](c4IHlzT%pz%%C%	䴔*|bB/lg2ewuڕcA:_Jqj0YT"'Á)-# Uʽ佺	H+dI^fs6*5ϪBpa ):f&a/GdS~I8HEǫP>	b =7ӓMN	2t2%I;9_y9N)%qWX#Gu1#᭞qs-jĐsh =FQKB&!f0e&?WiбSZ.l&<,u>XS	C@vGqN-eLE{p,^QYp/+ڔ&eY)R$'xcGKdENrCIGR!!q{dM=Q
Zþf
p^yw#nMKE
ARB_2
ؽ^jlY_{JQmͮ<9Ld.3~\cSECM0^ˏHQ++dI"t,,4Vgx[1&ꌙ*ه_a¢ia6eGAHN<6긄}Qcf*A)C##ft,Լ؉X 4sgO\ėp"ł.`>+;|A\WL{GzP&jn%FƐLa.I^1v)(JAâzVx`vz>)2մL07>|`p~OlgEUHwwFO96-)Z~ZyMז~_^shnzYquy.bP"zQ__YO<~md?j	^% @ %?ޗ~`=}{v:9wt~w]?O7frZ|S:V˸WOY7Q<ssտ_jSXڈ4o/O UD=N@yO
ҏJ'Xϗ#d0дw=?M:<!_`ǻxRZηR՘nz~aiVTw(E[Pi:eD7ɉ׶ڲo "ERH@O/?sPazLL?oG;gW{y|އexgߡXIJ%?<}w/5/Xn"a+m6wfӻA~A.ߋ_~TQmX-O}k"#Yl6Rn4X@ޤ]S9p4b ¹Td{(Wd|aAɥx}{=Oz.(1խ{Q?a_nJZD2ǣt/ǋ}-t(aA_{|OwW/aOޏ}`>_i@v(֋;ɿ_;"$DZ%@|nW9?c"<PT]EZP}~3.|wsslaLn/y{
-iYk֦܄K/#%GcWme?'+?__oCs]Uw}}{"ڹWg=hT<e~9GoGy߇r>'9%4է|b&R=Ng3UQ]yT}ޟk/?r}VSG\~ʎʼ״4~Rw2o#qOYa	ޒWu_bg7V] _¬><8Sa #*C	4;BkPSy'"X=.z#&YY+jI3[y5y5$"2/N48>RL2->j
2hhX͎cc?4+	)ɎqN|ŘHD&SZlko(;v	)[qάM
;o;*	q+Y/.iF9.KR	)B/5$n9)	@i_:\T"m{Ǝ{gŵ@֠+ʫp>Rr,ƽmj7o7srS{&?(BXK1iD2͕ \E#>>05Hc뚼)=[ɘĊۢmD.bK87I|+V%1l9Xѡ(Jବbht[Q;զEoR""BAP~Ɲހz e~@ dpʎxg˵"@q{i})`q˷CDRָd7(08m
tRs>ty2L%
VAnVώgejgRWwZ:Xh( F5?R.b
ںv647)!R9Y⛀;{]nFrg_rHp\0"A86FE1i)]՞}'# ޱxk21d8<Jpt
b@8hE5Uy'Q^X kL$KjMgI7Ae$aSEڽhI%S@&D(>yg?'vQM;lO`'M/c@&!.6H8ܸ3	D)==C=50 ,R
[wд,Ȫh\7nZr1$`A$%'S-GY|wQ`얛ȁ'6hmu}\Z&^Dhq4Ĕ&Y7oA|]MUSSx*!zזfϻ |[uR?A0L Vo'@F%쪉s908̉w.FYzqP5sτR3q[=Ia]$a~Ƈ6C5Y`Je~D,캝`;,si2fGe②j6ҰSẗ=7U{P׋_>G8!f,WF0\j 3cdEB(-mC|!Ǭpmw ћE,n;2q28W8ُ$3$	\/b֨Tl:ckSFsq-μo,`48TC:H}2 -u?)5KO=u7[;T뺾E:
 $vsmLj^3\y0(#]4'	iAAu/p;9+))hU(Y YvJ4!K	TMtyUC3[ ]eǁĸp7<xݙ)_F,_fO0F띠 l@PRP, (An, X:GUE.t-뀅u51An~3u?Fߗ^lJ@ }8JJAh6@D5%@*X{k_DYd56`$=8V?Ug)rQǰ XМ K'=;x1[GzE]>:蕓~:"9Pl2C!`3>7Sǌ"_hYwyhk1x!ލg+^e	8ߍ|23P57=1qk,&3eq,0yWmF@\vA&c(GF9F|dM{xbېվ~	2cm+̸Æl|gqk-$w}{vySTg@:J2((igA#<(<'A3$d-6zB< ! 9
FskDv'§r-҈JRZV/|)PT|-YtSc 	h+69Z^!5rVi9gN8JN85u>reCtnҗ,}V5\YPW(9Y"EU#'x_:nӰI ыݫ>X_Mr9fr|U"@qc,Ί­F?wL 2atRÒ#Ė.WV7%^2=<0ٮaCrt_X0ZC͏Ot 8FT^ф,LS(YoӭhX4LdS@fIlTg	(AH:oC䞇Dۢ2dh C8ȐB
=PN:$98X<@	ġ"$E	Q8$sq{Kr2GL1wtr]c&teLAՓCgUXjfYG官Gu3gW_x_iv}!h	ѦCw=I+JCjo1ݭ^/t.6/cQ{d'{6!xv):]mƷ3ĺŭWX5:3J%hk5Nzio x45)z^3L=Zndԡ')q|iq}m?#@+H0_?kϫ;SO]ٱ1{WͭE_7͍ҟ~H=>8~JqB7]	@{9$j_P_u;8L /U'("Uj{*{0/OP4tKKX=@~@׻-Pi}VpJn|OIYwQ;<54,z
U^&![ ZZ%HbSI88u.]D҇.MFU~CZ7mc!ʟ>q#TMM_R5MG-% pMg)/]4=zDd*wli㩫T*PmVM1 m).0OH9.<0[DVrp'aYl+	o
7lbL7D~0ӥ(kL%߯۵ȴ@w ͠Z3nDܲ'eYӞ慙˭Xj)m<	nY8hI:\}p캫r*Ml[/6xoL	}T%n0C͎GVm;'U0.CZ/֎#F$t{)1h`)TGI~DP]QA@p8^lHŶm>s	
Pɻ9f*dAqY[\ưX^'_G܎CpmI6Y>p'eS֙Jjǫ	NС$yNtKZB61G/yp[qѲYJTqF6۝ׇt*%MpZӛJL[RCryʺ,┹ƃg`Uydr8:x{+.P|aFVS_O"ͅ 1$3KJ/N]3%"pXB>=eo@@1wԵn<6t9ZLڌ~_'X>Ĩ!T:$f-#rBZQUFD	rPo*?YEBq'?/z7|t).8sf*!+x߼H'ZbrGf\[$0l/K/	OIȱhɚq5~{c<W;EőCA	r0f=32آ] sX,;xΥpE:*?Zw>/~F!=S<*-WjYEZu:&}$$g.۶yQSVs,F]g3\w{1w.4ЬMM[;o,&x6̴OƑ&掳"VÙ{>M\ТֱzF*R޿:t/O@x7ejٍGnqR/(ދtOxoS\yb0?ĕHy~Ru3R٣~wCs8o}lr]O<PGDWtlm^S҉l2]Ͷh٬fDXES*ZQI$}4"@!fZI_+%2Zt|Y~3}]}>Ky=_Y
h4 q?zGw"D|?/2'+?i+EGQжS"Ek_.=vѾ~mӜWLSƓSw=~sazAz g s5@3&yiͷ xP{U?[	h3i#
[ޅ~16VaMrb_͌R/q	; ʪO*ӄ(R ep`{L2H;`M!9f
x5fհ?JZ)VJ7ۚ:WhKX7kn)ZuFTGp^ZӉ'#0cexڵ3HY֏#AW5FF	WNMHՍX鴸8ǰƹV_Rɋ&9z'~ҵN3\|py" 5:B(y0UxCuc'r͎}COq*E91*ؤHM^(1	3ʲcۚ-dJ.poˣ9khʨuס*L6^|w$(cyz

/޵rD!	f1-b3&J5u
\ ¤h^GU**VYR`shTB6̓F߳Y$+!<@JA܈pda8UcNd0 e?Yx,h*8(9`5f7Ȅܱl\#/Okg_ D (V0}d["&N{'qUϻjc=tT޽
q/	۷5LD䊨]EFJMɕjqRm}q!1?
bY~^go)EQi~\kq<+jvA>Uqͷֱϴ&	/Oؖ7
ƖKbWdc\ЫZI6$
ܛ15s"`/s	{5J~25hĕ'r٘2B!$W(PTm<W{8V4(uև椥JQEUޟmu@U^T֦|Kw\V+QyƠ=>,yW6kT[uW\.Jf/
rmj^FΗbK[;݇?w=FujۨBWpv~
"1|Om/U<'ls+~zn[qtxk}qw/}~/Tɕ&OڗaU9/, ?1<:qt=yV% o
'<HdlOQnv˒Jl~hQ}	3!S~\PbN@A m~jJu1eЬs7sϰ*e룼EFs&ټj34:hpb &pgl66}}p `Mvgn'Ƭv Y14&,_/gۓr/}g|MB§0a Gxq4?N$<q!CHݳyDH>ܱ6amF};]tonYyD(
l0
ɄR=;㭫qtsI~[|RAVQMw0B#Z$ $Aݽ?݉ یHCHI7O9׬rx(^fq߿];yCYqRNn-1sAlF\'j|;ak;K^bXrC;21@ +U!%]2ִ#Zux)/W;/'(rǇTaj\!bbaL 	7rN,*h21 u=سVcbbh*@VHp3Ov`"20}7҂̈(b1c $&ȃ*	hrIDF	| XQ"HO${D-qy0qvGi,AhDĈ!exsXC 8kY@6&h~u:CFy?ApݚLxin%:۝ІYE졀ֿm!=r AhHC8(?$cL;{xS@s㡞-6me	)bq
ďqk