itle .version {
    font-size: 0.8em;
    color: #666666;
}

footer#edit {
    border-top: solid 1px #e1e4e8;
    margin: 3em 0 4em 0;
    padding-top: 2em;
}
</style>
</head>
<body>
<div id="banner">
<div id="rainbar"></div>
<div id="logobar">
<svg class="logo" role="img" height="32" width="32" viewBox="0 0 700 700">
<polygon fill="#cb0000" points="0,700 700,700 700,0 0,0"></polygon>
<polygon fill="#ffffff" points="150,550 350,550 350,250 450,250 450,550 550,550 550,150 150,150"></polygon>
</svg>
<div class="title">
npm command-line interface
</div>
</div>
</div>

<section id="content">
<header class="title">
<h1 id="----dependency-selector-syntax--querying----1092">
    <span>Dependency Selector Syntax &amp; Querying</span>
    <span class="version">@10.9.2</span>
</h1>
<span class="description">Dependency Selector Syntax &amp; Querying</span>
</header>

<section id="table_of_contents">
<h2 id="table-of-contents">Table of contents</h2>
<div id="_table_of_contents"><ul><li><a href="#see-also">See Also</a></li></ul></div>
</section>

<div id="_content"><h3 id="description">Description</h3>
<p>The <a href="../commands/npm-query.html"><code>npm query</code></a> command exposes a new dependency selector syntax (informed by &amp; respecting many aspects of the <a href="https://dev.w3.org/csswg/selectors4/#relational">CSS Selectors 4 Spec</a>) which:</p>
<ul>
<li>Standardizes the shape of, &amp; querying of, dependency graphs with a robust object model, metadata &amp; selector syntax</li>
<li>Leverages existing, known language syntax &amp; operators from CSS to make disparate package information broadly accessible</li>
<li>Unlocks the ability to answer complex, multi-faceted questions about dependencies, their relationships &amp; associative metadata</li>
<li>Consolidates redundant logic of similar query commands in <code>npm</code> (ex. <code>npm fund</code>, <code>npm ls</code>, <code>npm outdated</code>, <code>npm audit</code> ...)</li>
</ul>
<h3 id="dependency-selector-syntax">Dependency Selector Syntax</h3>
<h4 id="overview">Overview:</h4>
<ul>
<li>there is no "type" or "tag" selectors (ex. <code>div, h1, a</code>) as a dependency/target is the only type of <code>Node</code> that can be queried</li>
<li>the term "dependencies" is in reference to any <code>Node</code> found in a <code>tree</code> returned by <code>Arborist</code></li>
</ul>
<h4 id="combinators">Combinators</h4>
<ul>
<li><code>&gt;</code> direct descendant/child</li>
<li><code> </code> any descendant/child</li>
<li><code>~</code> sibling</li>
</ul>
<h4 id="selectors">Selectors</h4>
<ul>
<li><code>*</code> universal selector</li>
<li><code>#&lt;name&gt;</code> dependency selector (equivalent to <code>[name="..."]</code>)</li>
<li><code>#&lt;name&gt;@&lt;version&gt;</code> (equivalent to <code>[name=&lt;name&gt;]:semver(&lt;version&gt;)</code>)</li>
<li><code>,</code> selector list delimiter</li>
<li><code>.</code> dependency type selector</li>
<li><code>:</code> pseudo selector</li>
</ul>
<h4 id="dependency-type-selectors">Dependency Type Selectors</h4>
<ul>
<li><code>.prod</code> dependency found in the <code>dependencies</code> section of <code>package.json</code>, or is a child of said dependency</li>
<li><code>.dev</code> dependency found in the <code>devDependencies</code> section of <code>package.json</code>, or is a child of said dependency</li>
<li><code>.optional</code> dependency found in the <code>optionalDependencies</code> section of <code>package.json</code>, or has <code>"optional": true</code> set in its entry in the <code>peerDependenciesMeta</code> section of <code>package.json</code>, or a child of said dependency</li>
<li><code>.peer</code> dependency found in the <code>peerDependencies</code> section of <code>package.json</code></li>
<li><code>.workspace</code> dependency found in the <a href="https://docs.npmjs.com/cli/v8/using-npm/workspaces"><code>workspaces</code></a> section of <code>package.json</code></li>
<li><code>.bundled</code> dependency found in the <code>bundleDependencies</code> section of <code>package.json</code>, or is a child of said dependency</li>
</ul>
<h4 id="pseudo-selectors">Pseudo Selectors</h4>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:not"><code>:not(&lt;selector&gt;)</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:has"><code>:has(&lt;selector&gt;)</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:is"><code>:is(&lt;selector list&gt;)</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:root"><code>:root</code></a> matches the root node/dependency</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:scope"><code>:scope</code></a> matches node/dependency it was queried against</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:empty"><code>:empty</code></a> when a dependency has no dependencies</li>
<li><a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json#private"><code>:private</code></a> when a dependency is private</li>
<li><code>:link</code> when a dependency is linked (for instance, workspaces or packages manually <a href="https://docs.npmjs.com/cli/v8/commands/npm-link"><code>linked</code></a></li>
<li><code>:deduped</code> when a dependency has been deduped (note that this does <em>not</em> always mean the dependency has been hoisted to the root of node_modules)</li>
<li><code>:overridden</code> when a dependency has been overridden</li>
<li><code>:extraneous</code> when a dependency exists but is not defined as a dependency of any node</li>
<li><code>:invalid</code> when a dependency version is out of its ancestors specified range</li>
<li><code>:missing</code> when a dependency is not found on disk</li>
<li><code>:semver(&lt;spec&gt;, [selector], [function])</code> match a valid <a href="https://github.com/npm/node-semver"><code>node-semver</code></a> version or range to a selector</li>
<li><code>:path(&lt;path&gt;)</code> <a href="https://www.npmjs.com/package/glob">glob</a> matching based on dependencies path relative to the project</li>
<li><code>:type(&lt;type&gt;)</code> <a href="https://github.com/npm/npm-package-arg#result-object">based on currently recognized types</a></li>
<li><code>:outdated(&lt;type&gt;)</code> when a dependency is outdated</li>
<li><code>:vuln(&lt;selector&gt;)</code> when a dependency has a known vulnerability</li>
</ul>
<h5 id="semverspec-selector-function"><code>:semver(&lt;spec&gt;, [selector], [function])</code></h5>
<p>The <code>:semver()</code> pseudo selector allows comparing fields from each node's <code>package.json</code> using <a href="https://github.com/npm/node-semver#readme">semver</a> methods. It accepts up to 3 parameters, all but the first of which are optional.</p>
<ul>
<li><code>spec</code> a semver version or range</li>
<li><code>selector</code> an attribute selector for each node (default <code>[version]</code>)</li>
<li><code>function</code> a semver method to apply, one of: <code>satisfies</code>, <code>intersects</code>, <code>subset</code>, <code>gt</code>, <code>gte</code>, <code>gtr</code>, <code>lt</code>, <code>lte</code>, <code>ltr</code>, <code>eq</code>, <code>neq</code> or the special function <code>infer</code> (default <code>infer</code>)</li>
</ul>
<p>When the special <code>infer</code> function is used the <code>spec</code> and the actual value from the node are compared. If both are versions, according to <code>semver.valid()</code>, <code>eq</code> is used. If both values are ranges, according to <code>!semver.valid()</code>, <code>intersects</code> is used. If the values are mixed types <code>satisfies</code> is used.</p>
<p>Some examples:</p>
<ul>
<li><code>:semver(^1.0.0)</code> returns every node that has a <code>version</code> satisfied by the provided range <code>^1.0.0</code></li>
<li><code>:semver(16.0.0, :attr(engines, [node]))</code> returns every node which has an <code>engines.node</code> property satisfying the version <code>16.0.0</code></li>
<li><code>:semver(1.0.0, [version], lt)</code> every node with a <code>version</code> less than <code>1.0.0</code></li>
</ul>
<h5 id="outdatedtype"><code>:outdated(&lt;type&gt;)</code></h5>
<p>The <code>:outdated</code> pseudo selector retrieves data from the registry and returns information about which of your dependencies are outdated. The type parameter may be one of the following:</p>
<ul>
<li><code>any</code> (default) a version exists that is greater than the current one</li>
<li><code>in-range</code> a version exists that is greater than the current one, and satisfies at least one if its parent's dependencies</li>
<li><code>out-of-range</code> a version exists that is greater than the current one, does not satisfy at least one of its parent's dependencies</li>
<li><code>major</code> a version exists that is a semver major greater than the current one</li>
<li><code>minor</code> a version exists that is a semver minor greater than the current one</li>
<li><code>patch</code> a version exists that is a semver patch greater than the current one</li>
</ul>
<p>In addition to the filtering performed by the pseudo selector, some extra data is added to the resulting objects. The following data can be found under the <code>queryContext</code> property of each node.</p>
<ul>
<li><code>versions</code> an array of every available version of the given node</li>
<li><code>outdated.inRange</code> an array of objects, each with a <code>from</code> and <code>versions</code>, where <code>from</code> is the on-disk location of the node that depends on the current node and <code>versions</code> is an array of all available versions that satisfies that dependency. This is only populated if <code>:outdated(in-range)</code> is used.</li>
<li><code>outdated.outOfRange</code> an array of objects, identical in shape to <code>inRange</code>, but where the <code>versions</code> array is every available version that does not satisfy the dependency. This is only populated if <code>:outdated(out-of-range)</code> is used.</li>
</ul>
<p>Some examples:</p>
<ul>
<li><code>:root &gt; :outdated(major)</code> returns every direct dependency that has a new semver major release</li>
<li><code>.prod:outdated(in-range)</code> returns production dependencies that have a new release that satisfies at least one of its parent's dependencies</li>
</ul>
<h5 id="vuln"><code>:vuln</code></h5>
<p>The <code>:vuln</code> pseudo selector retrieves data from the registry and returns information about which if your dependencies has a known vulnerability.  Only dependencies whose current version matches a vulnerability will be returned.  For example if you have <code>semver@7.6.0</code> in your tree, a vulnerability for <code>semver</code> which affects versions <code>&lt;=6.3.1</code> will not match.</p>
<p>You can also filter results by certain attributes in advisories.  Currently that includes <code>severity</code> and <code>cwe</code>.  Note that severity filtering is done per severity, it does not include severities "higher" or "lower" than the one specified.</p>
<p>In addition to the filtering performed by the pseudo selector, info about each relevant advisory will be added to the <code>queryContext</code> attribute of each node under the <code>advisories</code> attribute.</p>
<p>Some examples:</p>
<ul>
<li><code>:root &gt; .prod:vuln</code> returns direct production dependencies with any known vulnerability</li>
<li><code>:vuln([severity=high])</code> returns only dependencies with a vulnerability with a <code>high</code> severity.</li>
<li><code>:vuln([severity=high],[severity=moderate])</code> returns only dependencies with a vulnerability with a <code>high</code>  or <code>moderate</code> severity.</li>
<li><code>:vuln([cwe=1333])</code> returns only dependencies with a vulnerability that includes CWE-1333 (ReDoS)</li>
</ul>
<h4 id="attribute-selectors"><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors">Attribute Selectors</a></h4>
<p>The attribute selector evaluates the key/value pairs in <code>package.json</code> if they are <code>String</code>s.</p>
<ul>
<li><code>[]</code> attribute selector (ie. existence of attribute)</li>
<li><code>[attribute=value]</code> attribute value is equivalent...</li>
<li><code>[attribute~=value]</code> attribute value contains word...</li>
<li><code>[attribute*=value]</code> attribute value contains string...</li>
<li><code>[attribute|=value]</code> attribute value is equal to or starts with...</li>
<li><code>[attribute^=value]</code> attribute value starts with...</li>
<li><code>[attribute$=value]</code> attribute value ends with...</li>
</ul>
<h4 id="array--object-attribute-selectors"><code>Array</code> &amp; <code>Object</code> Attribute Selectors</h4>
<p>The generic <code>:attr()</code> pseudo selector standardizes a pattern which can be used for attribute selection of <code>Object</code>s, <code>Array</code>s or <code>Arrays</code> of <code>Object</code>s accessible via <code>Arborist</code>'s <code>Node.package</code> metadata. This allows for iterative attribute selection beyond top-level <code>String</code> evaluation. The last argument passed to <code>:attr()</code> must be an <code>attribute</code> selector or a nested <code>:attr()</code>. See examples below:</p>
<h4 id="objects"><code>Objects</code></h4>
<pre><code class="language-css">/* return dependencies that have a `scripts.test` containing `"tap"` */
*:attr(scripts, [test~=tap])
</code></pre>
<h4 id="nested-objects">Nested <code>Objects</code></h4>
<p>Nested objects are expressed as sequential arguments to <code>:attr()</code>.</p>
<pre><code class="language-css">/* return dependencies that have a testling config for opera browsers */
*:attr(testling, browsers, [~=opera])
</code></pre>
<h4 id="arrays"><code>Arrays</code></h4>
<p><code>Array</code>s specifically uses a special/reserved <code>.</code> character in place of a typical attribute name. <code>Arrays</code> also support exact <code>value</code> matching when a <code>String</code> is passed to the selector.</p>
<h5 id="example-of-an-array-attribute-selection">Example of an <code>Array</code> Attribute Selection:</h5>
<pre><code class="language-css">/* removes the distinction between properties &amp; arrays */
/* ie. we'd have to check the property &amp; iterate to match selection */
*:attr([keywords^=react])
*:attr(contributors, :attr([name~=Jordan]))
</code></pre>
<h5 id="example-of-an-array-matching-directly-to-a-value">Example of an <code>Array</code> matching directly to a value:</h5>
<pre><code class="language-css">/* return dependencies that have the exact keyword "react" */
/* this is equivalent to `*:keywords([value="react"])` */
*:attr([keywords=react])
</code></pre>
<h5 id="example-of-an-array-of-objects">Example of an <code>Array</code> of <code>Object</code>s:</h5>
<pre><code class="language-css">/* returns */
*:attr(contributors, [email=ruyadorno@github.com])
</code></pre>
<h3 id="groups">Groups</h3>
<p>Dependency groups are defined by the package relationships to their ancestors (ie. the dependency types that are defined in <code>package.json</code>). This approach is user-centric as the ecosystem has been taught to think about dependencies in these groups first-and-foremost. Dependencies are allowed to be included in multiple groups (ex. a <code>prod</code> dependency may also be a <code>dev</code> dependency (in that it's also required by another <code>dev</code> dependency) &amp; may also be <code>bundled</code> - a selector for that type of dependency would look like: <code>*.prod.dev.bundled</code>).</p>
<ul>
<li><code>.prod</code></li>
<li><code>.dev</code></li>
<li><code>.optional</code></li>
<li><code>.peer</code></li>
<li><code>.bundled</code></li>
<li><code>.workspace</code></li>
</ul>
<p>Please note that currently <code>workspace</code> deps are always <code>prod</code> dependencies.  Additionally the <code>.root</code> dependency is also considered a <code>prod</code> dependency.</p>
<h3 id="programmatic-usage">Programmatic Usage</h3>
<ul>
<li><code>Arborist</code>'s <code>Node</code> Class has a <code>.querySelectorAll()</code> method
<ul>
<li>this method will return a filtered, flattened dependency Arborist <code>Node</code> list based on a valid query selector</li>
</ul>
</li>
</ul>
<pre><code class="language-js">const Arborist = require('@npmcli/arborist')
const arb = new Arborist({})
</code></pre>
<pre><code class="language-js">// root-level
arb.loadActual().then(async (tree) =&gt; {
  // query all production dependencies
  const results = await tree.querySelectorAll('.prod')
  console.log(results)
})
</code></pre>
<pre><code class="language-js">// iterative
arb.loadActual().then(async (tree) =&gt; {
  // query for the deduped version of react
  const results = await tree.querySelectorAll('#react:not(:deduped)')
  // query the deduped react for git deps
  const deps = await results[0].querySelectorAll(':type(git)')
  console.log(deps)
})
</code></pre>
<h2 id="see-also">See Also</h2>
<ul>
<li><a href="../commands/npm-query.html">npm query</a></li>
<li><a href="https://npm.im/@npmcli/arborist">@npmcli/arborist</a></li>
</ul></div>

<footer id="edit">
<a href="https://github.com/npm/cli/edit/latest/docs/content/using-npm/dependency-selectors.md">
<svg role="img" viewBox="0 0 16 16" width="16" height="16" fill="currentcolor" style="vertical-align: text-bottom; margin-right: 0.3em;">
<path fill-rule="evenodd" d="M11.013 1.427a1.75 1.75 0 012.474 0l1.086 1.086a1.75 1.75 0 010 2.474l-8.61 8.61c-.21.21-.47.364-.756.445l-3.251.93a.75.75 0 01-.927-.928l.929-3.25a1.75 1.75 0 01.445-.758l8.61-8.61zm1.414 1.06a.25.25 0 00-.354 0L10.811 3.75l1.439 1.44 1.263-1.263a.25.25 0 000-.354l-1.086-1.086zM11.189 6.25L9.75 4.81l-6.286 6.287a.25.25 0 00-.064.108l-.558 1.953 1.953-.558a.249.249 0 00.108-.064l6.286-6.286z"></path>
</svg>
Edit this page on GitHub
</a>
</footer>
</section>



</body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/npm/docs/output/using-npm/developers.html                                          0000664 0000000 0000000 00000034520 14746647661 0023551 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        <!DOCTYPE html><html><head>
<meta charset="utf-8">
<title>developers</title>
<style>
body {
    background-color: #ffffff;
    color: #24292e;

    margin: 0;

    line-height: 1.5;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}
#rainbar {
    height: 10px;
    background-image: linear-gradient(139deg, #fb8817, #ff4b01, #c12127, #e02aff);
}

a {
    text-decoration: none;
    color: #0366d6;
}
a:hover {
    text-decoration: underline;
}

pre {
    margin: 1em 0px;
    padding: 1em;
    border: solid 1px #e1e4e8;
    border-radius: 6px;

    display: block;
    overflow: auto;

    white-space: pre;

    background-color: #f6f8fa;
    color: #393a34;
}
code {
    font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 85%;
    padding: 0.2em 0.4em;
    background-color: #f6f8fa;
    color: #393a34;
}
pre > code {
    padding: 0;
    background-color: inherit;
    color: inherit;
}
h1, h2, h3 {
    font-weight: 600;
}

#logobar {
    background-color: #333333;
    margin: 0 auto;
    padding: 1em 4em;
}
#logobar .logo {
    float: left;
}
#logobar .title {
    font-weight: 600;
    color: #dddddd;
    float: left;
    margin: 5px 0 0 1em;
}
#logobar:after {
    content: "";
    display: block;
    clear: both;
}

#content {
    margin: 0 auto;
    padding: 0 4em;
}

#table_of_contents > h2 {
    font-size: 1.17em;
}
#table_of_contents ul:first-child {
    border: solid 1px #e1e4e8;
    border-radius: 6px;
    padding: 1em;
    background-color: #f6f8fa;
    color: #393a34;
}
#table_of_contents ul {
    list-style-type: none;
    padding-left: 1.5em;
}
#table_of_contents li {
    font-size: 0.9em;
}
#table_of_contents li a {
    color: #000000;
}

header.title {
    border-bottom: solid 1px #e1e4e8;
}
header.title > h1 {
    margin-bottom: 0.25em;
}
header.title > .description {
    display: block;
    margin-bottom: 0.5em;
    line-height: 1;
}

header.title .version {
    font-size: 0.8em;
    color: #666666;
}

footer#edit {
    border-top: solid 1px #e1e4e8;
    margin: 3em 0 4em 0;
    padding-top: 2em;
}
</style>
</head>
<body>
<div id="banner">
<div id="rainbar"></div>
<div id="logobar">
<svg class="logo" role="img" height="32" width="32" viewBox="0 0 700 700">
<polygon fill="#cb0000" points="0,700 700,700 700,0 0,0"></polygon>
<polygon fill="#ffffff" points="150,550 350,550 350,250 450,250 450,550 550,550 550,150 150,150"></polygon>
</svg>
<div class="title">
npm command-line interface
</div>
</div>
</div>

<section id="content">
<header class="title">
<h1 id="----developers----1092">
    <span>developers</span>
    <span class="version">@10.9.2</span>
</h1>
<span class="description">Developer Guide</span>
</header>

<section id="table_of_contents">
<h2 id="table-of-contents">Table of contents</h2>
<div id="_table_of_contents"><ul><li><a href="#description">Description</a></li><li><a href="#about-these-documents">About These Documents</a></li><li><a href="#what-is-a-package">What is a Package</a></li><li><a href="#the-packagejson-file">The package.json File</a></li><li><a href="#keeping-files-out-of-your-package">Keeping files <em>out</em> of your Package</a></li><ul><li><a href="#testing-whether-your-npmignore-or-files-config-works">Testing whether your <code>.npmignore</code> or <code>files</code> config works</a></li></ul><li><a href="#link-packages">Link Packages</a></li><li><a href="#before-publishing-make-sure-your-package-installs-and-works">Before Publishing: Make Sure Your Package Installs and Works</a></li><li><a href="#create-a-user-account">Create a User Account</a></li><li><a href="#publish-your-package">Publish your Package</a></li><li><a href="#brag-about-it">Brag about it</a></li><li><a href="#see-also">See also</a></li></ul></div>
</section>

<div id="_content"><h3 id="description">Description</h3>
<p>So, you've decided to use npm to develop (and maybe publish/deploy)
your project.</p>
<p>Fantastic!</p>
<p>There are a few things that you need to do above the simple steps
that your users will do to install your program.</p>
<h3 id="about-these-documents">About These Documents</h3>
<p>These are man pages.  If you install npm, you should be able to
then do <code>man npm-thing</code> to get the documentation on a particular
topic, or <code>npm help thing</code> to see the same information.</p>
<h3 id="what-is-a-package">What is a Package</h3>
<p>A package is:</p>
<ul>
<li>a) a folder containing a program described by a package.json file</li>
<li>b) a gzipped tarball containing (a)</li>
<li>c) a url that resolves to (b)</li>
<li>d) a <code>&lt;name&gt;@&lt;version&gt;</code> that is published on the registry with (c)</li>
<li>e) a <code>&lt;name&gt;@&lt;tag&gt;</code> that points to (d)</li>
<li>f) a <code>&lt;name&gt;</code> that has a "latest" tag satisfying (e)</li>
<li>g) a <code>git</code> url that, when cloned, results in (a).</li>
</ul>
<p>Even if you never publish your package, you can still get a lot of
benefits of using npm if you just want to write a node program (a), and
perhaps if you also want to be able to easily install it elsewhere
after packing it up into a tarball (b).</p>
<p>Git urls can be of the form:</p>
<pre><code class="language-bash">git://github.com/user/project.git#commit-ish
git+ssh://user@hostname:project.git#commit-ish
git+http://user@hostname/project/blah.git#commit-ish
git+https://user@hostname/project/blah.git#commit-ish
</code></pre>
<p>The <code>commit-ish</code> can be any tag, sha, or branch which can be supplied as
an argument to <code>git checkout</code>.  The default is whatever the repository uses
as its default branch.</p>
<h3 id="the-packagejson-file">The package.json File</h3>
<p>You need to have a <code>package.json</code> file in the root of your project to do
much of anything with npm.  That is basically the whole interface.</p>
<p>See <a href="../configuring-npm/package-json.html"><code>package.json</code></a> for details about what
goes in that file.  At the very least, you need:</p>
<ul>
<li>
<p>name: This should be a string that identifies your project.  Please do
not use the name to specify that it runs on node, or is in JavaScript.
You can use the "engines" field to explicitly state the versions of node
(or whatever else) that your program requires, and it's pretty well
assumed that it's JavaScript.</p>
<p>It does not necessarily need to match your github repository name.</p>
<p>So, <code>node-foo</code> and <code>bar-js</code> are bad names.  <code>foo</code> or <code>bar</code> are better.</p>
</li>
<li>
<p>version: A semver-compatible version.</p>
</li>
<li>
<p>engines: Specify the versions of node (or whatever else) that your
program runs on.  The node API changes a lot, and there may be bugs or
new functionality that you depend on.  Be explicit.</p>
</li>
<li>
<p>author: Take some credit.</p>
</li>
<li>
<p>scripts: If you have a special compilation or installation script, then
you should put it in the <code>scripts</code> object.  You should definitely have at
least a basic smoke-test command as the "scripts.test" field.  See
<a href="../using-npm/scripts.html">scripts</a>.</p>
</li>
<li>
<p>main: If you have a single module that serves as the entry point to your
program (like what the "foo" package gives you at require("foo")), then
you need to specify that in the "main" field.</p>
</li>
<li>
<p>directories: This is an object mapping names to folders.  The best ones
to include are "lib" and "doc", but if you use "man" to specify a folder
full of man pages, they'll get installed just like these ones.</p>
</li>
</ul>
<p>You can use <code>npm init</code> in the root of your package in order to get you
started with a pretty basic package.json file.  See <a href="../commands/npm-init.html"><code>npm init</code></a> for more info.</p>
<h3 id="keeping-files-out-of-your-package">Keeping files <em>out</em> of your Package</h3>
<p>Use a <code>.npmignore</code> file to keep stuff out of your package.  If there's no
<code>.npmignore</code> file, but there <em>is</em> a <code>.gitignore</code> file, then npm will ignore
the stuff matched by the <code>.gitignore</code> file.  If you <em>want</em> to include
something that is excluded by your <code>.gitignore</code> file, you can create an
empty <code>.npmignore</code> file to override it. Like <code>git</code>, <code>npm</code> looks for
<code>.npmignore</code> and <code>.gitignore</code> files in all subdirectories of your package,
not only the root directory.</p>
<p><code>.npmignore</code> files follow the <a href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository#_ignoring">same pattern
rules</a>
as <code>.gitignore</code> files:</p>
<ul>
<li>Blank lines or lines starting with <code>#</code> are ignored.</li>
<li>Standard glob patterns work.</li>
<li>You can end patterns with a forward slash <code>/</code> to specify a directory.</li>
<li>You can negate a pattern by starting it with an exclamation point <code>!</code>.</li>
</ul>
<p>By default, the following paths and files are ignored, so there's no
need to add them to <code>.npmignore</code> explicitly:</p>
<ul>
<li><code>.*.swp</code></li>
<li><code>._*</code></li>
<li><code>.DS_Store</code></li>
<li><code>.git</code></li>
<li><code>.gitignore</code></li>
<li><code>.hg</code></li>
<li><code>.npmignore</code></li>
<li><code>.npmrc</code></li>
<li><code>.lock-wscript</code></li>
<li><code>.svn</code></li>
<li><code>.wafpickle-*</code></li>
<li><code>config.gypi</code></li>
<li><code>CVS</code></li>
<li><code>npm-debug.log</code></li>
</ul>
<p>Additionally, everything in <code>node_modules</code> is ignored, except for
bundled dependencies. npm automatically handles this for you, so don't
bother adding <code>node_modules</code> to <code>.npmignore</code>.</p>
<p>The following paths and files are never ignored, so adding them to
<code>.npmignore</code> is pointless:</p>
<ul>
<li><code>package.json</code></li>
<li><code>README</code> (and its variants)</li>
<li><code>CHANGELOG</code> (and its variants)</li>
<li><code>LICENSE</code> / <code>LICENCE</code></li>
</ul>
<p>If, given the structure of your project, you find <code>.npmignore</code> to be a
maintenance headache, you might instead try populating the <code>files</code>
property of <code>package.json</code>, which is an array of file or directory names
that should be included in your package. Sometimes manually picking
which items to allow is easier to manage than building a block list.</p>
<h4 id="testing-whether-your-npmignore-or-files-config-works">Testing whether your <code>.npmignore</code> or <code>files</code> config works</h4>
<p>If you want to double check that your package will include only the files
you intend it to when published, you can run the <code>npm pack</code> command locally
which will generate a tarball in the working directory, the same way it
does for publishing.</p>
<h3 id="link-packages">Link Packages</h3>
<p><code>npm link</code> is designed to install a development package and see the
changes in real time without having to keep re-installing it.  (You do
need to either re-link or <code>npm rebuild -g</code> to update compiled packages,
of course.)</p>
<p>More info at <a href="../commands/npm-link.html"><code>npm link</code></a>.</p>
<h3 id="before-publishing-make-sure-your-package-installs-and-works">Before Publishing: Make Sure Your Package Installs and Works</h3>
<p><strong>This is important.</strong></p>
<p>If you can not install it locally, you'll have
problems trying to publish it.  Or, worse yet, you'll be able to
publish it, but you'll be publishing a broken or pointless package.
So don't do that.</p>
<p>In the root of your package, do this:</p>
<pre><code class="language-bash">npm install . -g
</code></pre>
<p>That'll show you that it's working.  If you'd rather just create a symlink
package that points to your working directory, then do this:</p>
<pre><code class="language-bash">npm link
</code></pre>
<p>Use <code>npm ls -g</code> to see if it's there.</p>
<p>To test a local install, go into some other folder, and then do:</p>
<pre><code class="language-bash">cd ../some-other-folder
npm install ../my-package
</code></pre>
<p>to install it locally into the node_modules folder in that other place.</p>
<p>Then go into the node-repl, and try using require("my-thing") to
bring in your module's main module.</p>
<h3 id="create-a-user-account">Create a User Account</h3>
<p>Create a user with the adduser command.  It works like this:</p>
<pre><code class="language-bash">npm adduser
</code></pre>
<p>and then follow the prompts.</p>
<p>This is documented better in <a href="../commands/npm-adduser.html">npm adduser</a>.</p>
<h3 id="publish-your-package">Publish your Package</h3>
<p>This part's easy.  In the root of your folder, do this:</p>
<pre><code class="language-bash">npm publish
</code></pre>
<p>You can give publish a url to a tarball, or a filename of a tarball,
or a path to a folder.</p>
<p>Note that pretty much <strong>everything in that folder will be exposed</strong>
by default.  So, if you have secret stuff in there, use a
<code>.npmignore</code> file to list out the globs to ignore, or publish
from a fresh checkout.</p>
<h3 id="brag-about-it">Brag about it</h3>
<p>Send emails, write blogs, blab in IRC.</p>
<p>Tell the world how easy it is to install your program!</p>
<h3 id="see-also">See also</h3>
<ul>
<li><a href="../commands/npm.html">npm</a></li>
<li><a href="../commands/npm-init.html">npm init</a></li>
<li><a href="../configuring-npm/package-json.html">package.json</a></li>
<li><a href="../using-npm/scripts.html">npm scripts</a></li>
<li><a href="../commands/npm-publish.html">npm publish</a></li>
<li><a href="../commands/npm-adduser.html">npm adduser</a></li>
<li><a href="../using-npm/registry.html">npm registry</a></li>
</ul></div>

<footer id="edit">
<a href="https://github.com/npm/cli/edit/latest/docs/content/using-npm/developers.md">
<svg role="img" viewBox="0 0 16 16" width="16" height="16" fill="currentcolor" style="vertical-align: text-bottom; margin-right: 0.3em;">
<path fill-rule="evenodd" d="M11.013 1.427a1.75 1.75 0 012.474 0l1.086 1.086a1.75 1.75 0 010 2.474l-8.61 8.61c-.21.21-.47.364-.756.445l-3.251.93a.75.75 0 01-.927-.928l.929-3.25a1.75 1.75 0 01.445-.758l8.61-8.61zm1.414 1.06a.25.25 0 00-.354 0L10.811 3.75l1.439 1.44 1.263-1.263a.25.25 0 000-.354l-1.086-1.086zM11.189 6.25L9.75 4.81l-6.286 6.287a.25.25 0 00-.064.108l-.558 1.953 1.953-.558a.249.249 0 00.108-.064l6.286-6.286z"></path>
</svg>
Edit this page on GitHub
</a>
</footer>
</section>



</body></html>                                                                                                                                                                                node-23.7.0/deps/npm/docs/output/using-npm/logging.html                                             0000664 0000000 0000000 00000022372 14746647661 0023031 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        <!DOCTYPE html><html><head>
<meta charset="utf-8">
<title>Logging</title>
<style>
body {
    background-color: #ffffff;
    color: #24292e;

    margin: 0;

    line-height: 1.5;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}
#rainbar {
    height: 10px;
    background-image: linear-gradient(139deg, #fb8817, #ff4b01, #c12127, #e02aff);
}

a {
    text-decoration: none;
    color: #0366d6;
}
a:hover {
    text-decoration: underline;
}

pre {
    margin: 1em 0px;
    padding: 1em;
    border: solid 1px #e1e4e8;
    border-radius: 6px;

    display: block;
    overflow: auto;

    white-space: pre;

    background-color: #f6f8fa;
    color: #393a34;
}
code {
    font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 85%;
    padding: 0.2em 0.4em;
    background-color: #f6f8fa;
    color: #393a34;
}
pre > code {
    padding: 0;
    background-color: inherit;
    color: inherit;
}
h1, h2, h3 {
    font-weight: 600;
}

#logobar {
    background-color: #333333;
    margin: 0 auto;
    padding: 1em 4em;
}
#logobar .logo {
    float: left;
}
#logobar .title {
    font-weight: 600;
    color: #dddddd;
    float: left;
    margin: 5px 0 0 1em;
}
#logobar:after {
    content: "";
    display: block;
    clear: both;
}

#content {
    margin: 0 auto;
    padding: 0 4em;
}

#table_of_contents > h2 {
    font-size: 1.17em;
}
#table_of_contents ul:first-child {
    border: solid 1px #e1e4e8;
    border-radius: 6px;
    padding: 1em;
    background-color: #f6f8fa;
    color: #393a34;
}
#table_of_contents ul {
    list-style-type: none;
    padding-left: 1.5em;
}
#table_of_contents li {
    font-size: 0.9em;
}
#table_of_contents li a {
    color: #000000;
}

header.title {
    border-bottom: solid 1px #e1e4e8;
}
header.title > h1 {
    margin-bottom: 0.25em;
}
header.title > .description {
    display: block;
    margin-bottom: 0.5em;
    line-height: 1;
}

header.title .version {
    font-size: 0.8em;
    color: #666666;
}

footer#edit {
    border-top: solid 1px #e1e4e8;
    margin: 3em 0 4em 0;
    padding-top: 2em;
}
</style>
</head>
<body>
<div id="banner">
<div id="rainbar"></div>
<div id="logobar">
<svg class="logo" role="img" height="32" width="32" viewBox="0 0 700 700">
<polygon fill="#cb0000" points="0,700 700,700 700,0 0,0"></polygon>
<polygon fill="#ffffff" points="150,550 350,550 350,250 450,250 450,550 550,550 550,150 150,150"></polygon>
</svg>
<div class="title">
npm command-line interface
</div>
</div>
</div>

<section id="content">
<header class="title">
<h1 id="----logging----1092">
    <span>Logging</span>
    <span class="version">@10.9.2</span>
</h1>
<span class="description">Why, What &amp; How We Log</span>
</header>

<section id="table_of_contents">
<h2 id="table-of-contents">Table of contents</h2>
<div id="_table_of_contents"><ul><li><a href="#description">Description</a></li><li><a href="#setting-log-file-location">Setting Log File Location</a></li><li><a href="#setting-log-levels">Setting Log Levels</a></li><ul><li><a href="#loglevel"><code>loglevel</code></a></li><ul><li><a href="#aliases">Aliases</a></li></ul><li><a href="#foreground-scripts"><code>foreground-scripts</code></a></li></ul><li><a href="#timing-information">Timing Information</a></li><li><a href="#registry-response-headers">Registry Response Headers</a></li><ul><li><a href="#npm-notice"><code>npm-notice</code></a></li></ul><li><a href="#logs-and-sensitive-information">Logs and Sensitive Information</a></li><li><a href="#see-also">See also</a></li></ul></div>
</section>

<div id="_content"><h3 id="description">Description</h3>
<p>The <code>npm</code> CLI has various mechanisms for showing different levels of information back to end-users for certain commands, configurations &amp; environments.</p>
<h3 id="setting-log-file-location">Setting Log File Location</h3>
<p>All logs are written to a debug log, with the path to that file printed if the execution of a command fails.</p>
<p>The default location of the logs directory is a directory named <code>_logs</code> inside the npm cache. This can be changed with the <code>logs-dir</code> config option.</p>
<p>For example, if you wanted to write all your logs to the current working directory, you could run: <code>npm install --logs-dir=.</code>.  This is especially helpful in debugging a specific <code>npm</code> issue as you can run
a command multiple times with different config values and then diff all the log files.</p>
<p>Log files will be removed from the <code>logs-dir</code> when the number of log files exceeds <code>logs-max</code>, with the oldest logs being deleted first.</p>
<p>To turn off logs completely set <code>--logs-max=0</code>.</p>
<h3 id="setting-log-levels">Setting Log Levels</h3>
<h4 id="loglevel"><code>loglevel</code></h4>
<p><code>loglevel</code> is a global argument/config that can be set to determine the type of information to be displayed.</p>
<p>The default value of <code>loglevel</code> is <code>"notice"</code> but there are several levels/types of logs available, including:</p>
<ul>
<li><code>"silent"</code></li>
<li><code>"error"</code></li>
<li><code>"warn"</code></li>
<li><code>"notice"</code></li>
<li><code>"http"</code></li>
<li><code>"info"</code></li>
<li><code>"verbose"</code></li>
<li><code>"silly"</code></li>
</ul>
<p>All logs pertaining to a level proceeding the current setting will be shown.</p>
<h5 id="aliases">Aliases</h5>
<p>The log levels listed above have various corresponding aliases, including:</p>
<ul>
<li><code>-d</code>: <code>--loglevel info</code></li>
<li><code>--dd</code>: <code>--loglevel verbose</code></li>
<li><code>--verbose</code>: <code>--loglevel verbose</code></li>
<li><code>--ddd</code>: <code>--loglevel silly</code></li>
<li><code>-q</code>: <code>--loglevel warn</code></li>
<li><code>--quiet</code>: <code>--loglevel warn</code></li>
<li><code>-s</code>: <code>--loglevel silent</code></li>
<li><code>--silent</code>: <code>--loglevel silent</code></li>
</ul>
<h4 id="foreground-scripts"><code>foreground-scripts</code></h4>
<p>The <code>npm</code> CLI began hiding the output of lifecycle scripts for <code>npm install</code> as of <code>v7</code>. Notably, this means you will not see logs/output from packages that may be using "install scripts" to display information back to you or from your own project's scripts defined in <code>package.json</code>. If you'd like to change this behavior &amp; log this output you can set <code>foreground-scripts</code> to <code>true</code>.</p>
<h3 id="timing-information">Timing Information</h3>
<p>The <a href="../using-npm/config#timing.html"><code>--timing</code> config</a> can be set which does a few
things:</p>
<ol>
<li>Always shows the full path to the debug log regardless of command exit status</li>
<li>Write timing information to a process specific timing file in the cache or <code>logs-dir</code></li>
<li>Output timing information to the terminal</li>
</ol>
<p>This file contains a <code>timers</code> object where the keys are an identifier for the
portion of the process being timed and the value is the number of milliseconds it took to complete.</p>
<p>Sometimes it is helpful to get timing information without outputting anything to the terminal. For
example, the performance might be affected by writing to the terminal. In this case you can use
<code>--timing --silent</code> which will still write the timing file, but not output anything to the terminal
while running.</p>
<h3 id="registry-response-headers">Registry Response Headers</h3>
<h4 id="npm-notice"><code>npm-notice</code></h4>
<p>The <code>npm</code> CLI reads from &amp; logs any <code>npm-notice</code> headers that are returned from the configured registry. This mechanism can be used by third-party registries to provide useful information when network-dependent requests occur.</p>
<p>This header is not cached, and will not be logged if the request is served from the cache.</p>
<h3 id="logs-and-sensitive-information">Logs and Sensitive Information</h3>
<p>The <code>npm</code> CLI makes a best effort to redact the following from terminal output and log files:</p>
<ul>
<li>Passwords inside basic auth URLs</li>
<li>npm tokens</li>
</ul>
<p>However, this behavior should not be relied on to keep all possible sensitive information redacted. If you are concerned about secrets in your log file or terminal output, you can use <code>--loglevel=silent</code> and <code>--logs-max=0</code> to ensure no logs are written to your terminal or filesystem.</p>
<h3 id="see-also">See also</h3>
<ul>
<li><a href="../using-npm/config.html">config</a></li>
</ul></div>

<footer id="edit">
<a href="https://github.com/npm/cli/edit/latest/docs/content/using-npm/logging.md">
<svg role="img" viewBox="0 0 16 16" width="16" height="16" fill="currentcolor" style="vertical-align: text-bottom; margin-right: 0.3em;">
<path fill-rule="evenodd" d="M11.013 1.427a1.75 1.75 0 012.474 0l1.086 1.086a1.75 1.75 0 010 2.474l-8.61 8.61c-.21.21-.47.364-.756.445l-3.251.93a.75.75 0 01-.927-.928l.929-3.25a1.75 1.75 0 01.445-.758l8.61-8.61zm1.414 1.06a.25.25 0 00-.354 0L10.811 3.75l1.439 1.44 1.263-1.263a.25.25 0 000-.354l-1.086-1.086zM11.189 6.25L9.75 4.81l-6.286 6.287a.25.25 0 00-.064.108l-.558 1.953 1.953-.558a.249.249 0 00.108-.064l6.286-6.286z"></path>
</svg>
Edit this page on GitHub
</a>
</footer>
</section>



</body></html>                                                                                                                                                                                                                                                                      node-23.7.0/deps/npm/docs/output/using-npm/orgs.html                                                0000664 0000000 0000000 00000016107 14746647661 0022354 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        <!DOCTYPE html><html><head>
<meta charset="utf-8">
<title>orgs</title>
<style>
body {
    background-color: #ffffff;
    color: #24292e;

    margin: 0;

    line-height: 1.5;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}
#rainbar {
    height: 10px;
    background-image: linear-gradient(139deg, #fb8817, #ff4b01, #c12127, #e02aff);
}

a {
    text-decoration: none;
    color: #0366d6;
}
a:hover {
    text-decoration: underline;
}

pre {
    margin: 1em 0px;
    padding: 1em;
    border: solid 1px #e1e4e8;
    border-radius: 6px;

    display: block;
    overflow: auto;

    white-space: pre;

    background-color: #f6f8fa;
    color: #393a34;
}
code {
    font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 85%;
    padding: 0.2em 0.4em;
    background-color: #f6f8fa;
    color: #393a34;
}
pre > code {
    padding: 0;
    background-color: inherit;
    color: inherit;
}
h1, h2, h3 {
    font-weight: 600;
}

#logobar {
    background-color: #333333;
    margin: 0 auto;
    padding: 1em 4em;
}
#logobar .logo {
    float: left;
}
#logobar .title {
    font-weight: 600;
    color: #dddddd;
    float: left;
    margin: 5px 0 0 1em;
}
#logobar:after {
    content: "";
    display: block;
    clear: both;
}

#content {
    margin: 0 auto;
    padding: 0 4em;
}

#table_of_contents > h2 {
    font-size: 1.17em;
}
#table_of_contents ul:first-child {
    border: solid 1px #e1e4e8;
    border-radius: 6px;
    padding: 1em;
    background-color: #f6f8fa;
    color: #393a34;
}
#table_of_contents ul {
    list-style-type: none;
    padding-left: 1.5em;
}
#table_of_contents li {
    font-size: 0.9em;
}
#table_of_contents li a {
    color: #000000;
}

header.title {
    border-bottom: solid 1px #e1e4e8;
}
header.title > h1 {
    margin-bottom: 0.25em;
}
header.title > .description {
    display: block;
    margin-bottom: 0.5em;
    line-height: 1;
}

header.title .version {
    font-size: 0.8em;
    color: #666666;
}

footer#edit {
    border-top: solid 1px #e1e4e8;
    margin: 3em 0 4em 0;
    padding-top: 2em;
}
</style>
</head>
<body>
<div id="banner">
<div id="rainbar"></div>
<div id="logobar">
<svg class="logo" role="img" height="32" width="32" viewBox="0 0 700 700">
<polygon fill="#cb0000" points="0,700 700,700 700,0 0,0"></polygon>
<polygon fill="#ffffff" points="150,550 350,550 350,250 450,250 450,550 550,550 550,150 150,150"></polygon>
</svg>
<div class="title">
npm command-line interface
</div>
</div>
</div>

<section id="content">
<header class="title">
<h1 id="----orgs----1092">
    <span>orgs</span>
    <span class="version">@10.9.2</span>
</h1>
<span class="description">Working with Teams &amp; Orgs</span>
</header>

<section id="table_of_contents">
<h2 id="table-of-contents">Table of contents</h2>
<div id="_table_of_contents"><ul><li><a href="#description">Description</a></li><li><a href="#team-admins-create-teams">Team Admins create teams</a></li><li><a href="#publish-a-package-and-adjust-package-access">Publish a package and adjust package access</a></li><li><a href="#monitor-your-package-access">Monitor your package access</a></li><li><a href="#see-also">See also</a></li></ul></div>
</section>

<div id="_content"><h3 id="description">Description</h3>
<p>There are three levels of org users:</p>
<ol>
<li>Super admin, controls billing &amp; adding people to the org.</li>
<li>Team admin, manages team membership &amp; package access.</li>
<li>Developer, works on packages they are given access to.</li>
</ol>
<p>The super admin is the only person who can add users to the org because it impacts the monthly bill. The super admin will use the website to manage membership. Every org has a <code>developers</code> team that all users are automatically added to.</p>
<p>The team admin is the person who manages team creation, team membership, and package access for teams. The team admin grants package access to teams, not individuals.</p>
<p>The developer will be able to access packages based on the teams they are on. Access is either read-write or read-only.</p>
<p>There are two main commands:</p>
<ol>
<li><code>npm team</code> see <a href="../commands/npm-team.html">npm team</a> for more details</li>
<li><code>npm access</code> see <a href="../commands/npm-access.html">npm access</a> for more details</li>
</ol>
<h3 id="team-admins-create-teams">Team Admins create teams</h3>
<ul>
<li>Check who you’ve added to your org:</li>
</ul>
<pre><code class="language-bash">npm team ls &lt;org&gt;:developers
</code></pre>
<ul>
<li>
<p>Each org is automatically given a <code>developers</code> team, so you can see the whole list of team members in your org. This team automatically gets read-write access to all packages, but you can change that with the <code>access</code> command.</p>
</li>
<li>
<p>Create a new team:</p>
</li>
</ul>
<pre><code class="language-bash">npm team create &lt;org:team&gt;
</code></pre>
<ul>
<li>Add members to that team:</li>
</ul>
<pre><code class="language-bash">npm team add &lt;org:team&gt; &lt;user&gt;
</code></pre>
<h3 id="publish-a-package-and-adjust-package-access">Publish a package and adjust package access</h3>
<ul>
<li>In package directory, run</li>
</ul>
<pre><code class="language-bash">npm init --scope=&lt;org&gt;
</code></pre>
<p>to scope it for your org &amp; publish as usual</p>
<ul>
<li>Grant access:</li>
</ul>
<pre><code class="language-bash">npm access grant &lt;read-only|read-write&gt; &lt;org:team&gt; [&lt;package&gt;]
</code></pre>
<ul>
<li>Revoke access:</li>
</ul>
<pre><code class="language-bash">npm access revoke &lt;org:team&gt; [&lt;package&gt;]
</code></pre>
<h3 id="monitor-your-package-access">Monitor your package access</h3>
<ul>
<li>See what org packages a team member can access:</li>
</ul>
<pre><code class="language-bash">npm access ls-packages &lt;org&gt; &lt;user&gt;
</code></pre>
<ul>
<li>See packages available to a specific team:</li>
</ul>
<pre><code class="language-bash">npm access ls-packages &lt;org:team&gt;
</code></pre>
<ul>
<li>Check which teams are collaborating on a package:</li>
</ul>
<pre><code class="language-bash">npm access ls-collaborators &lt;pkg&gt;
</code></pre>
<h3 id="see-also">See also</h3>
<ul>
<li><a href="../commands/npm-team.html">npm team</a></li>
<li><a href="../commands/npm-access.html">npm access</a></li>
<li><a href="../using-npm/scope.html">npm scope</a></li>
</ul></div>

<footer id="edit">
<a href="https://github.com/npm/cli/edit/latest/docs/content/using-npm/orgs.md">
<svg role="img" viewBox="0 0 16 16" width="16" height="16" fill="currentcolor" style="vertical-align: text-bottom; margin-right: 0.3em;">
<path fill-rule="evenodd" d="M11.013 1.427a1.75 1.75 0 012.474 0l1.086 1.086a1.75 1.75 0 010 2.474l-8.61 8.61c-.21.21-.47.364-.756.445l-3.251.93a.75.75 0 01-.927-.928l.929-3.25a1.75 1.75 0 01.445-.758l8.61-8.61zm1.414 1.06a.25.25 0 00-.354 0L10.811 3.75l1.439 1.44 1.263-1.263a.25.25 0 000-.354l-1.086-1.086zM11.189 6.25L9.75 4.81l-6.286 6.287a.25.25 0 00-.064.108l-.558 1.953 1.953-.558a.249.249 0 00.108-.064l6.286-6.286z"></path>
</svg>
Edit this page on GitHub
</a>
</footer>
</section>



</body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/npm/docs/output/using-npm/package-spec.html                                        0000664 0000000 0000000 00000017551 14746647661 0023731 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        <!DOCTYPE html><html><head>
<meta charset="utf-8">
<title>package-spec</title>
<style>
body {
    background-color: #ffffff;
    color: #24292e;

    margin: 0;

    line-height: 1.5;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}
#rainbar {
    height: 10px;
    background-image: linear-gradient(139deg, #fb8817, #ff4b01, #c12127, #e02aff);
}

a {
    text-decoration: none;
    color: #0366d6;
}
a:hover {
    text-decoration: underline;
}

pre {
    margin: 1em 0px;
    padding: 1em;
    border: solid 1px #e1e4e8;
    border-radius: 6px;

    display: block;
    overflow: auto;

    white-space: pre;

    background-color: #f6f8fa;
    color: #393a34;
}
code {
    font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 85%;
    padding: 0.2em 0.4em;
    background-color: #f6f8fa;
    color: #393a34;
}
pre > code {
    padding: 0;
    background-color: inherit;
    color: inherit;
}
h1, h2, h3 {
    font-weight: 600;
}

#logobar {
    background-color: #333333;
    margin: 0 auto;
    padding: 1em 4em;
}
#logobar .logo {
    float: left;
}
#logobar .title {
    font-weight: 600;
    color: #dddddd;
    float: left;
    margin: 5px 0 0 1em;
}
#logobar:after {
    content: "";
    display: block;
    clear: both;
}

#content {
    margin: 0 auto;
    padding: 0 4em;
}

#table_of_contents > h2 {
    font-size: 1.17em;
}
#table_of_contents ul:first-child {
    border: solid 1px #e1e4e8;
    border-radius: 6px;
    padding: 1em;
    background-color: #f6f8fa;
    color: #393a34;
}
#table_of_contents ul {
    list-style-type: none;
    padding-left: 1.5em;
}
#table_of_contents li {
    font-size: 0.9em;
}
#table_of_contents li a {
    color: #000000;
}

header.title {
    border-bottom: solid 1px #e1e4e8;
}
header.title > h1 {
    margin-bottom: 0.25em;
}
header.title > .description {
    display: block;
    margin-bottom: 0.5em;
    line-height: 1;
}

header.title .version {
    font-size: 0.8em;
    color: #666666;
}

footer#edit {
    border-top: solid 1px #e1e4e8;
    margin: 3em 0 4em 0;
    padding-top: 2em;
}
</style>
</head>
<body>
<div id="banner">
<div id="rainbar"></div>
<div id="logobar">
<svg class="logo" role="img" height="32" width="32" viewBox="0 0 700 700">
<polygon fill="#cb0000" points="0,700 700,700 700,0 0,0"></polygon>
<polygon fill="#ffffff" points="150,550 350,550 350,250 450,250 450,550 550,550 550,150 150,150"></polygon>
</svg>
<div class="title">
npm command-line interface
</div>
</div>
</div>

<section id="content">
<header class="title">
<h1 id="----package-spec----1092">
    <span>package-spec</span>
    <span class="version">@10.9.2</span>
</h1>
<span class="description">Package name specifier</span>
</header>

<section id="table_of_contents">
<h2 id="table-of-contents">Table of contents</h2>
<div id="_table_of_contents"><ul><li><a href="#description">Description</a></li><li><a href="#package-name">Package name</a></li><li><a href="#aliases">Aliases</a></li><li><a href="#folders">Folders</a></li><li><a href="#tarballs">Tarballs</a></li><li><a href="#git-urls">git urls</a></li><li><a href="#see-also">See also</a></li></ul></div>
</section>

<div id="_content"><h3 id="description">Description</h3>
<p>Commands like <code>npm install</code> and the dependency sections in the
<code>package.json</code> use a package name specifier.  This can be many different
things that all refer to a "package".  Examples include a package name,
git url, tarball, or local directory.  These will generally be referred
to as <code>&lt;package-spec&gt;</code> in the help output for the npm commands that use
this package name specifier.</p>
<h3 id="package-name">Package name</h3>
<ul>
<li><code>[&lt;@scope&gt;/]&lt;pkg&gt;</code></li>
<li><code>[&lt;@scope&gt;/]&lt;pkg&gt;@&lt;tag&gt;</code></li>
<li><code>[&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version&gt;</code></li>
<li><code>[&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version range&gt;</code></li>
</ul>
<p>Refers to a package by name, with or without a scope, and optionally
tag, version, or version range.  This is typically used in combination
with the <a href="../using-npm/config#registry.html">registry</a> config to refer to a
package in a registry.</p>
<p>Examples:</p>
<ul>
<li><code>npm</code></li>
<li><code>@npmcli/arborist</code></li>
<li><code>@npmcli/arborist@latest</code></li>
<li><code>npm@6.13.1</code></li>
<li><code>npm@^4.0.0</code></li>
</ul>
<h3 id="aliases">Aliases</h3>
<ul>
<li><code>&lt;alias&gt;@npm:&lt;name&gt;</code></li>
</ul>
<p>Primarily used by commands like <code>npm install</code> and in the dependency
sections in the <code>package.json</code>, this refers to a package by an alias.
The <code>&lt;alias&gt;</code> is the name of the package as it is reified in the
<code>node_modules</code> folder, and the <code>&lt;name&gt;</code> refers to a package name as
found in the configured registry.</p>
<p>See <code>Package name</code> above for more info on referring to a package by
name, and <a href="../using-npm/config#registry.html">registry</a> for configuring which
registry is used when referring to a package by name.</p>
<p>Examples:</p>
<ul>
<li><code>semver:@npm:@npmcli/semver-with-patch</code></li>
<li><code>semver:@npm:semver@7.2.2</code></li>
<li><code>semver:@npm:semver@legacy</code></li>
</ul>
<h3 id="folders">Folders</h3>
<ul>
<li><code>&lt;folder&gt;</code></li>
</ul>
<p>This refers to a package on the local filesystem.  Specifically this is
a folder with a <code>package.json</code> file in it.  This <em>should</em> always be
prefixed with a <code>/</code> or <code>./</code> (or your OS equivalent) to reduce confusion.
npm currently will parse a string with more than one <code>/</code> in it as a
folder, but this is legacy behavior that may be removed in a future
version.</p>
<p>Examples:</p>
<ul>
<li><code>./my-package</code></li>
<li><code>/opt/npm/my-package</code></li>
</ul>
<h3 id="tarballs">Tarballs</h3>
<ul>
<li><code>&lt;tarball file&gt;</code></li>
<li><code>&lt;tarball url&gt;</code></li>
</ul>
<p>Examples:</p>
<ul>
<li><code>./my-package.tgz</code></li>
<li><code>https://registry.npmjs.org/semver/-/semver-1.0.0.tgz</code></li>
</ul>
<p>Refers to a package in a tarball format, either on the local filesystem
or remotely via url.  This is the format that packages exist in when
uploaded to a registry.</p>
<h3 id="git-urls">git urls</h3>
<ul>
<li><code>&lt;git:// url&gt;</code></li>
<li><code>&lt;github username&gt;/&lt;github project&gt;</code></li>
</ul>
<p>Refers to a package in a git repo.  This can be a full git url, git
shorthand, or a username/package on GitHub.  You can specify a
git tag, branch, or other git ref by appending <code>#ref</code>.</p>
<p>Examples:</p>
<ul>
<li><code>https://github.com/npm/cli.git</code></li>
<li><code>git@github.com:npm/cli.git</code></li>
<li><code>git+ssh://git@github.com/npm/cli#v6.0.0</code></li>
<li><code>github:npm/cli#HEAD</code></li>
<li><code>npm/cli#c12ea07</code></li>
</ul>
<h3 id="see-also">See also</h3>
<ul>
<li><a href="https://npm.im/npm-package-arg">npm-package-arg</a></li>
<li><a href="../using-npm/scope.html">scope</a></li>
<li><a href="../using-npm/config.html">config</a></li>
</ul></div>

<footer id="edit">
<a href="https://github.com/npm/cli/edit/latest/docs/content/using-npm/package-spec.md">
<svg role="img" viewBox="0 0 16 16" width="16" height="16" fill="currentcolor" style="vertical-align: text-bottom; margin-right: 0.3em;">
<path fill-rule="evenodd" d="M11.013 1.427a1.75 1.75 0 012.474 0l1.086 1.086a1.75 1.75 0 010 2.474l-8.61 8.61c-.21.21-.47.364-.756.445l-3.251.93a.75.75 0 01-.927-.928l.929-3.25a1.75 1.75 0 01.445-.758l8.61-8.61zm1.414 1.06a.25.25 0 00-.354 0L10.811 3.75l1.439 1.44 1.263-1.263a.25.25 0 000-.354l-1.086-1.086zM11.189 6.25L9.75 4.81l-6.286 6.287a.25.25 0 00-.064.108l-.558 1.953 1.953-.558a.249.249 0 00.108-.064l6.286-6.286z"></path>
</svg>
Edit this page on GitHub
</a>
</footer>
</section>



</body></html>                                                                                                                                                       node-23.7.0/deps/npm/docs/output/using-npm/registry.html                                            0000664 0000000 0000000 00000021050 14746647661 0023243 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        <!DOCTYPE html><html><head>
<meta charset="utf-8">
<title>registry</title>
<style>
body {
    background-color: #ffffff;
    color: #24292e;

    margin: 0;

    line-height: 1.5;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}
#rainbar {
    height: 10px;
    background-image: linear-gradient(139deg, #fb8817, #ff4b01, #c12127, #e02aff);
}

a {
    text-decoration: none;
    color: #0366d6;
}
a:hover {
    text-decoration: underline;
}

pre {
    margin: 1em 0px;
    padding: 1em;
    border: solid 1px #e1e4e8;
    border-radius: 6px;

    display: block;
    overflow: auto;

    white-space: pre;

    background-color: #f6f8fa;
    color: #393a34;
}
code {
    font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 85%;
    padding: 0.2em 0.4em;
    background-color: #f6f8fa;
    color: #393a34;
}
pre > code {
    padding: 0;
    background-color: inherit;
    color: inherit;
}
h1, h2, h3 {
    font-weight: 600;
}

#logobar {
    background-color: #333333;
    margin: 0 auto;
    padding: 1em 4em;
}
#logobar .logo {
    float: left;
}
#logobar .title {
    font-weight: 600;
    color: #dddddd;
    float: left;
    margin: 5px 0 0 1em;
}
#logobar:after {
    content: "";
    display: block;
    clear: both;
}

#content {
    margin: 0 auto;
    padding: 0 4em;
}

#table_of_contents > h2 {
    font-size: 1.17em;
}
#table_of_contents ul:first-child {
    border: solid 1px #e1e4e8;
    border-radius: 6px;
    padding: 1em;
    background-color: #f6f8fa;
    color: #393a34;
}
#table_of_contents ul {
    list-style-type: none;
    padding-left: 1.5em;
}
#table_of_contents li {
    font-size: 0.9em;
}
#table_of_contents li a {
    color: #000000;
}

header.title {
    border-bottom: solid 1px #e1e4e8;
}
header.title > h1 {
    margin-bottom: 0.25em;
}
header.title > .description {
    display: block;
    margin-bottom: 0.5em;
    line-height: 1;
}

header.title .version {
    font-size: 0.8em;
    color: #666666;
}

footer#edit {
    border-top: solid 1px #e1e4e8;
    margin: 3em 0 4em 0;
    padding-top: 2em;
}
</style>
</head>
<body>
<div id="banner">
<div id="rainbar"></div>
<div id="logobar">
<svg class="logo" role="img" height="32" width="32" viewBox="0 0 700 700">
<polygon fill="#cb0000" points="0,700 700,700 700,0 0,0"></polygon>
<polygon fill="#ffffff" points="150,550 350,550 350,250 450,250 450,550 550,550 550,150 150,150"></polygon>
</svg>
<div class="title">
npm command-line interface
</div>
</div>
</div>

<section id="content">
<header class="title">
<h1 id="----registry----1092">
    <span>registry</span>
    <span class="version">@10.9.2</span>
</h1>
<span class="description">The JavaScript Package Registry</span>
</header>

<section id="table_of_contents">
<h2 id="table-of-contents">Table of contents</h2>
<div id="_table_of_contents"><ul><li><a href="#description">Description</a></li><li><a href="#does-npm-send-any-information-about-me-back-to-the-registry">Does npm send any information about me back to the registry?</a></li><li><a href="#how-can-i-prevent-my-package-from-being-published-in-the-official-registry">How can I prevent my package from being published in the official registry?</a></li><li><a href="#where-can-i-find-my-and-others-published-packages">Where can I find my (and others') published packages?</a></li><li><a href="#see-also">See also</a></li></ul></div>
</section>

<div id="_content"><h3 id="description">Description</h3>
<p>To resolve packages by name and version, npm talks to a registry website
that implements the CommonJS Package Registry specification for reading
package info.</p>
<p>npm is configured to use the <strong>npm public registry</strong> at
<a href="https://registry.npmjs.org">https://registry.npmjs.org</a> by default. Use of the npm public registry is
subject to terms of use available at <a href="https://docs.npmjs.com/policies/terms">https://docs.npmjs.com/policies/terms</a>.</p>
<p>You can configure npm to use any compatible registry you like, and even run
your own registry. Use of someone else's registry may be governed by their
terms of use.</p>
<p>npm's package registry implementation supports several
write APIs as well, to allow for publishing packages and managing user
account information.</p>
<p>The npm public registry is powered by a CouchDB database,
of which there is a public mirror at <a href="https://skimdb.npmjs.com/registry">https://skimdb.npmjs.com/registry</a>.</p>
<p>The registry URL used is determined by the scope of the package (see
<a href="../using-npm/scope.html"><code>scope</code></a>. If no scope is specified, the default registry is
used, which is supplied by the <a href="../using-npm/config#registry.html"><code>registry</code> config</a>
parameter.  See <a href="../commands/npm-config.html"><code>npm config</code></a>,
<a href="../configuring-npm/npmrc.html"><code>npmrc</code></a>, and <a href="../using-npm/config.html"><code>config</code></a> for more on
managing npm's configuration.
Authentication configuration such as auth tokens and certificates are configured
specifically scoped to an individual registry. See
<a href="../configuring-npm/npmrc#auth-related-configuration.html">Auth Related Configuration</a></p>
<p>When the default registry is used in a package-lock or shrinkwrap it has the
special meaning of "the currently configured registry". If you create a lock
file while using the default registry you can switch to another registry and
npm will install packages from the new registry, but if you create a lock
file while using a custom registry packages will be installed from that
registry even after you change to another registry.</p>
<h3 id="does-npm-send-any-information-about-me-back-to-the-registry">Does npm send any information about me back to the registry?</h3>
<p>Yes.</p>
<p>When making requests of the registry npm adds two headers with information
about your environment:</p>
<ul>
<li><code>Npm-Scope</code> – If your project is scoped, this header will contain its
scope. In the future npm hopes to build registry features that use this
information to allow you to customize your experience for your
organization.</li>
<li><code>Npm-In-CI</code> – Set to "true" if npm believes this install is running in a
continuous integration environment, "false" otherwise. This is detected by
looking for the following environment variables: <code>CI</code>, <code>TDDIUM</code>,
<code>JENKINS_URL</code>, <code>bamboo.buildKey</code>. If you'd like to learn more you may find
the <a href="https://github.com/npm/npm-registry-client/pull/129">original PR</a>
interesting.
This is used to gather better metrics on how npm is used by humans, versus
build farms.</li>
</ul>
<p>The npm registry does not try to correlate the information in these headers
with any authenticated accounts that may be used in the same requests.</p>
<h3 id="how-can-i-prevent-my-package-from-being-published-in-the-official-registry">How can I prevent my package from being published in the official registry?</h3>
<p>Set <code>"private": true</code> in your <code>package.json</code> to prevent it from being
published at all, or
<code>"publishConfig":{"registry":"http://my-internal-registry.local"}</code>
to force it to be published only to your internal/private registry.</p>
<p>See <a href="../configuring-npm/package-json.html"><code>package.json</code></a> for more info on what goes in the package.json file.</p>
<h3 id="where-can-i-find-my-and-others-published-packages">Where can I find my (and others') published packages?</h3>
<p><a href="https://www.npmjs.com/">https://www.npmjs.com/</a></p>
<h3 id="see-also">See also</h3>
<ul>
<li><a href="../commands/npm-config.html">npm config</a></li>
<li><a href="../using-npm/config.html">config</a></li>
<li><a href="../configuring-npm/npmrc.html">npmrc</a></li>
<li><a href="../using-npm/developers.html">npm developers</a></li>
</ul></div>

<footer id="edit">
<a href="https://github.com/npm/cli/edit/latest/docs/content/using-npm/registry.md">
<svg role="img" viewBox="0 0 16 16" width="16" height="16" fill="currentcolor" style="vertical-align: text-bottom; margin-right: 0.3em;">
<path fill-rule="evenodd" d="M11.013 1.427a1.75 1.75 0 012.474 0l1.086 1.086a1.75 1.75 0 010 2.474l-8.61 8.61c-.21.21-.47.364-.756.445l-3.251.93a.75.75 0 01-.927-.928l.929-3.25a1.75 1.75 0 01.445-.758l8.61-8.61zm1.414 1.06a.25.25 0 00-.354 0L10.811 3.75l1.439 1.44 1.263-1.263a.25.25 0 000-.354l-1.086-1.086zM11.189 6.25L9.75 4.81l-6.286 6.287a.25.25 0 00-.064.108l-.558 1.953 1.953-.558a.249.249 0 00.108-.064l6.286-6.286z"></path>
</svg>
Edit this page on GitHub
</a>
</footer>
</section>



</body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/npm/docs/output/using-npm/removal.html                                             0000664 0000000 0000000 00000013264 14746647661 0023050 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        <!DOCTYPE html><html><head>
<meta charset="utf-8">
<title>removal</title>
<style>
body {
    background-color: #ffffff;
    color: #24292e;

    margin: 0;

    line-height: 1.5;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}
#rainbar {
    height: 10px;
    background-image: linear-gradient(139deg, #fb8817, #ff4b01, #c12127, #e02aff);
}

a {
    text-decoration: none;
    color: #0366d6;
}
a:hover {
    text-decoration: underline;
}

pre {
    margin: 1em 0px;
    padding: 1em;
    border: solid 1px #e1e4e8;
    border-radius: 6px;

    display: block;
    overflow: auto;

    white-space: pre;

    background-color: #f6f8fa;
    color: #393a34;
}
code {
    font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 85%;
    padding: 0.2em 0.4em;
    background-color: #f6f8fa;
    color: #393a34;
}
pre > code {
    padding: 0;
    background-color: inherit;
    color: inherit;
}
h1, h2, h3 {
    font-weight: 600;
}

#logobar {
    background-color: #333333;
    margin: 0 auto;
    padding: 1em 4em;
}
#logobar .logo {
    float: left;
}
#logobar .title {
    font-weight: 600;
    color: #dddddd;
    float: left;
    margin: 5px 0 0 1em;
}
#logobar:after {
    content: "";
    display: block;
    clear: both;
}

#content {
    margin: 0 auto;
    padding: 0 4em;
}

#table_of_contents > h2 {
    font-size: 1.17em;
}
#table_of_contents ul:first-child {
    border: solid 1px #e1e4e8;
    border-radius: 6px;
    padding: 1em;
    background-color: #f6f8fa;
    color: #393a34;
}
#table_of_contents ul {
    list-style-type: none;
    padding-left: 1.5em;
}
#table_of_contents li {
    font-size: 0.9em;
}
#table_of_contents li a {
    color: #000000;
}

header.title {
    border-bottom: solid 1px #e1e4e8;
}
header.title > h1 {
    margin-bottom: 0.25em;
}
header.title > .description {
    display: block;
    margin-bottom: 0.5em;
    line-height: 1;
}

header.title .version {
    font-size: 0.8em;
    color: #666666;
}

footer#edit {
    border-top: solid 1px #e1e4e8;
    margin: 3em 0 4em 0;
    padding-top: 2em;
}
</style>
</head>
<body>
<div id="banner">
<div id="rainbar"></div>
<div id="logobar">
<svg class="logo" role="img" height="32" width="32" viewBox="0 0 700 700">
<polygon fill="#cb0000" points="0,700 700,700 700,0 0,0"></polygon>
<polygon fill="#ffffff" points="150,550 350,550 350,250 450,250 450,550 550,550 550,150 150,150"></polygon>
</svg>
<div class="title">
npm command-line interface
</div>
</div>
</div>

<section id="content">
<header class="title">
<h1 id="----removal----1092">
    <span>removal</span>
    <span class="version">@10.9.2</span>
</h1>
<span class="description">Cleaning the Slate</span>
</header>

<section id="table_of_contents">
<h2 id="table-of-contents">Table of contents</h2>
<div id="_table_of_contents"><ul><li><a href="#synopsis">Synopsis</a></li><li><a href="#more-severe-uninstalling">More Severe Uninstalling</a></li><li><a href="#see-also">See also</a></li></ul></div>
</section>

<div id="_content"><h3 id="synopsis">Synopsis</h3>
<p>So sad to see you go.</p>
<pre><code class="language-bash">sudo npm uninstall npm -g
</code></pre>
<p>Or, if that fails, please proceed to more severe uninstalling methods.</p>
<h3 id="more-severe-uninstalling">More Severe Uninstalling</h3>
<p>Usually, the above instructions are sufficient.  That will remove
npm, but leave behind anything you've installed.</p>
<p>If that doesn't work, or if you require more drastic measures,
continue reading.</p>
<p>Note that this is only necessary for globally-installed packages.  Local
installs are completely contained within a project's <code>node_modules</code>
folder.  Delete that folder, and everything is gone unless a package's
install script is particularly ill-behaved.</p>
<p>This assumes that you installed node and npm in the default place.  If
you configured node with a different <code>--prefix</code>, or installed npm with a
different prefix setting, then adjust the paths accordingly, replacing
<code>/usr/local</code> with your install prefix.</p>
<p>To remove everything npm-related manually:</p>
<pre><code class="language-bash">rm -rf /usr/local/{lib/node{,/.npm,_modules},bin,share/man}/npm*
</code></pre>
<p>If you installed things <em>with</em> npm, then your best bet is to uninstall
them with npm first, and then install them again once you have a
proper install.  This can help find any symlinks that are lying
around:</p>
<pre><code class="language-bash">ls -laF /usr/local/{lib/node{,/.npm},bin,share/man} | grep npm
</code></pre>
<p>Prior to version 0.3, npm used shim files for executables and node
modules.  To track those down, you can do the following:</p>
<pre><code class="language-bash">find /usr/local/{lib/node,bin} -exec grep -l npm \{\} \; ;
</code></pre>
<h3 id="see-also">See also</h3>
<ul>
<li><a href="../commands/npm-uninstall.html">npm uninstall</a></li>
<li><a href="../commands/npm-prune.html">npm prune</a></li>
</ul></div>

<footer id="edit">
<a href="https://github.com/npm/cli/edit/latest/docs/content/using-npm/removal.md">
<svg role="img" viewBox="0 0 16 16" width="16" height="16" fill="currentcolor" style="vertical-align: text-bottom; margin-right: 0.3em;">
<path fill-rule="evenodd" d="M11.013 1.427a1.75 1.75 0 012.474 0l1.086 1.086a1.75 1.75 0 010 2.474l-8.61 8.61c-.21.21-.47.364-.756.445l-3.251.93a.75.75 0 01-.927-.928l.929-3.25a1.75 1.75 0 01.445-.758l8.61-8.61zm1.414 1.06a.25.25 0 00-.354 0L10.811 3.75l1.439 1.44 1.263-1.263a.25.25 0 000-.354l-1.086-1.086zM11.189 6.25L9.75 4.81l-6.286 6.287a.25.25 0 00-.064.108l-.558 1.953 1.953-.558a.249.249 0 00.108-.064l6.286-6.286z"></path>
</svg>
Edit this page on GitHub
</a>
</footer>
</section>



</body></html>                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/npm/docs/output/using-npm/scope.html                                               0000664 0000000 0000000 00000024656 14746647661 0022523 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        <!DOCTYPE html><html><head>
<meta charset="utf-8">
<title>scope</title>
<style>
body {
    background-color: #ffffff;
    color: #24292e;

    margin: 0;

    line-height: 1.5;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}
#rainbar {
    height: 10px;
    background-image: linear-gradient(139deg, #fb8817, #ff4b01, #c12127, #e02aff);
}

a {
    text-decoration: none;
    color: #0366d6;
}
a:hover {
    text-decoration: underline;
}

pre {
    margin: 1em 0px;
    padding: 1em;
    border: solid 1px #e1e4e8;
    border-radius: 6px;

    display: block;
    overflow: auto;

    white-space: pre;

    background-color: #f6f8fa;
    color: #393a34;
}
code {
    font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 85%;
    padding: 0.2em 0.4em;
    background-color: #f6f8fa;
    color: #393a34;
}
pre > code {
    padding: 0;
    background-color: inherit;
    color: inherit;
}
h1, h2, h3 {
    font-weight: 600;
}

#logobar {
    background-color: #333333;
    margin: 0 auto;
    padding: 1em 4em;
}
#logobar .logo {
    float: left;
}
#logobar .title {
    font-weight: 600;
    color: #dddddd;
    float: left;
    margin: 5px 0 0 1em;
}
#logobar:after {
    content: "";
    display: block;
    clear: both;
}

#content {
    margin: 0 auto;
    padding: 0 4em;
}

#table_of_contents > h2 {
    font-size: 1.17em;
}
#table_of_contents ul:first-child {
    border: solid 1px #e1e4e8;
    border-radius: 6px;
    padding: 1em;
    background-color: #f6f8fa;
    color: #393a34;
}
#table_of_contents ul {
    list-style-type: none;
    padding-left: 1.5em;
}
#table_of_contents li {
    font-size: 0.9em;
}
#table_of_contents li a {
    color: #000000;
}

header.title {
    border-bottom: solid 1px #e1e4e8;
}
header.title > h1 {
    margin-bottom: 0.25em;
}
header.title > .description {
    display: block;
    margin-bottom: 0.5em;
    line-height: 1;
}

header.title .version {
    font-size: 0.8em;
    color: #666666;
}

footer#edit {
    border-top: solid 1px #e1e4e8;
    margin: 3em 0 4em 0;
    padding-top: 2em;
}
</style>
</head>
<body>
<div id="banner">
<div id="rainbar"></div>
<div id="logobar">
<svg class="logo" role="img" height="32" width="32" viewBox="0 0 700 700">
<polygon fill="#cb0000" points="0,700 700,700 700,0 0,0"></polygon>
<polygon fill="#ffffff" points="150,550 350,550 350,250 450,250 450,550 550,550 550,150 150,150"></polygon>
</svg>
<div class="title">
npm command-line interface
</div>
</div>
</div>

<section id="content">
<header class="title">
<h1 id="----scope----1092">
    <span>scope</span>
    <span class="version">@10.9.2</span>
</h1>
<span class="description">Scoped packages</span>
</header>

<section id="table_of_contents">
<h2 id="table-of-contents">Table of contents</h2>
<div id="_table_of_contents"><ul><li><a href="#description">Description</a></li><li><a href="#installing-scoped-packages">Installing scoped packages</a></li><li><a href="#requiring-scoped-packages">Requiring scoped packages</a></li><li><a href="#publishing-scoped-packages">Publishing scoped packages</a></li><ul><li><a href="#publishing-public-scoped-packages-to-the-primary-npm-registry">Publishing public scoped packages to the primary npm registry</a></li><li><a href="#publishing-private-scoped-packages-to-the-npm-registry">Publishing private scoped packages to the npm registry</a></li></ul><li><a href="#associating-a-scope-with-a-registry">Associating a scope with a registry</a></li><li><a href="#see-also">See also</a></li></ul></div>
</section>

<div id="_content"><h3 id="description">Description</h3>
<p>All npm packages have a name. Some package names also have a scope. A scope
follows the usual rules for package names (URL-safe characters, no leading dots
or underscores). When used in package names, scopes are preceded by an <code>@</code> symbol
and followed by a slash, e.g.</p>
<pre><code class="language-bash">@somescope/somepackagename
</code></pre>
<p>Scopes are a way of grouping related packages together, and also affect a few
things about the way npm treats the package.</p>
<p>Each npm user/organization has their own scope, and only you can add packages
in your scope. This means you don't have to worry about someone taking your
package name ahead of you. Thus it is also a good way to signal official packages
for organizations.</p>
<p>Scoped packages can be published and installed as of <code>npm@2</code> and are supported
by the primary npm registry. Unscoped packages can depend on scoped packages and
vice versa. The npm client is backwards-compatible with unscoped registries,
so it can be used to work with scoped and unscoped registries at the same time.</p>
<h3 id="installing-scoped-packages">Installing scoped packages</h3>
<p>Scoped packages are installed to a sub-folder of the regular installation
folder, e.g. if your other packages are installed in <code>node_modules/packagename</code>,
scoped modules will be installed in <code>node_modules/@myorg/packagename</code>. The scope
folder (<code>@myorg</code>) is simply the name of the scope preceded by an <code>@</code> symbol, and can
contain any number of scoped packages.</p>
<p>A scoped package is installed by referencing it by name, preceded by an
<code>@</code> symbol, in <code>npm install</code>:</p>
<pre><code class="language-bash">npm install @myorg/mypackage
</code></pre>
<p>Or in <code>package.json</code>:</p>
<pre><code class="language-json">"dependencies": {
  "@myorg/mypackage": "^1.3.0"
}
</code></pre>
<p>Note that if the <code>@</code> symbol is omitted, in either case, npm will instead attempt to
install from GitHub; see <a href="../commands/npm-install.html"><code>npm install</code></a>.</p>
<h3 id="requiring-scoped-packages">Requiring scoped packages</h3>
<p>Because scoped packages are installed into a scope folder, you have to
include the name of the scope when requiring them in your code, e.g.</p>
<pre><code class="language-javascript">require('@myorg/mypackage')
</code></pre>
<p>There is nothing special about the way Node treats scope folders. This
simply requires the <code>mypackage</code> module in the folder named <code>@myorg</code>.</p>
<h3 id="publishing-scoped-packages">Publishing scoped packages</h3>
<p>Scoped packages can be published from the CLI as of <code>npm@2</code> and can be
published to any registry that supports them, including the primary npm
registry.</p>
<p>(As of 2015-04-19, and with npm 2.0 or better, the primary npm registry
<strong>does</strong> support scoped packages.)</p>
<p>If you wish, you may associate a scope with a registry; see below.</p>
<h4 id="publishing-public-scoped-packages-to-the-primary-npm-registry">Publishing public scoped packages to the primary npm registry</h4>
<p>Publishing to a scope, you have two options:</p>
<ul>
<li>Publishing to your user scope (example: <code>@username/module</code>)</li>
<li>Publishing to an organization scope (example: <code>@org/module</code>)</li>
</ul>
<p>If publishing a public module to an organization scope, you must
first either create an organization with the name of the scope
that you'd like to publish to or be added to an existing organization
with the appropriate permissions. For example, if you'd like to
publish to <code>@org</code>, you would  need to create the <code>org</code> organization
on npmjs.com prior to trying to publish.</p>
<p>Scoped packages are not public by default.  You will need to specify
<code>--access public</code> with the initial <code>npm publish</code> command.  This will publish
the package and set access to <code>public</code> as if you had run <code>npm access public</code>
after publishing.  You do not need to do this when publishing new versions of
an existing scoped package.</p>
<h4 id="publishing-private-scoped-packages-to-the-npm-registry">Publishing private scoped packages to the npm registry</h4>
<p>To publish a private scoped package to the npm registry, you must have
an <a href="https://docs.npmjs.com/private-modules/intro">npm Private Modules</a>
account.</p>
<p>You can then publish the module with <code>npm publish</code> or <code>npm publish --access restricted</code>, and it will be present in the npm registry, with
restricted access. You can then change the access permissions, if
desired, with <code>npm access</code> or on the npmjs.com website.</p>
<h3 id="associating-a-scope-with-a-registry">Associating a scope with a registry</h3>
<p>Scopes can be associated with a separate registry. This allows you to
seamlessly use a mix of packages from the primary npm registry and one or more
private registries, such as <a href="https://github.com/features/packages">GitHub Packages</a> or the open source <a href="https://verdaccio.org">Verdaccio</a>
project.</p>
<p>You can associate a scope with a registry at login, e.g.</p>
<pre><code class="language-bash">npm login --registry=http://reg.example.com --scope=@myco
</code></pre>
<p>Scopes have a many-to-one relationship with registries: one registry can
host multiple scopes, but a scope only ever points to one registry.</p>
<p>You can also associate a scope with a registry using <code>npm config</code>:</p>
<pre><code class="language-bash">npm config set @myco:registry=http://reg.example.com
</code></pre>
<p>Once a scope is associated with a registry, any <code>npm install</code> for a package
with that scope will request packages from that registry instead. Any
<code>npm publish</code> for a package name that contains the scope will be published to
that registry instead.</p>
<h3 id="see-also">See also</h3>
<ul>
<li><a href="../commands/npm-install.html">npm install</a></li>
<li><a href="../commands/npm-publish.html">npm publish</a></li>
<li><a href="../commands/npm-access.html">npm access</a></li>
<li><a href="../using-npm/registry.html">npm registry</a></li>
</ul></div>

<footer id="edit">
<a href="https://github.com/npm/cli/edit/latest/docs/content/using-npm/scope.md">
<svg role="img" viewBox="0 0 16 16" width="16" height="16" fill="currentcolor" style="vertical-align: text-bottom; margin-right: 0.3em;">
<path fill-rule="evenodd" d="M11.013 1.427a1.75 1.75 0 012.474 0l1.086 1.086a1.75 1.75 0 010 2.474l-8.61 8.61c-.21.21-.47.364-.756.445l-3.251.93a.75.75 0 01-.927-.928l.929-3.25a1.75 1.75 0 01.445-.758l8.61-8.61zm1.414 1.06a.25.25 0 00-.354 0L10.811 3.75l1.439 1.44 1.263-1.263a.25.25 0 000-.354l-1.086-1.086zM11.189 6.25L9.75 4.81l-6.286 6.287a.25.25 0 00-.064.108l-.558 1.953 1.953-.558a.249.249 0 00.108-.064l6.286-6.286z"></path>
</svg>
Edit this page on GitHub
</a>
</footer>
</section>



</body></html>                                                                                  node-23.7.0/deps/npm/docs/output/using-npm/scripts.html                                             0000664 0000000 0000000 00000054141 14746647661 0023071 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        <!DOCTYPE html><html><head>
<meta charset="utf-8">
<title>scripts</title>
<style>
body {
    background-color: #ffffff;
    color: #24292e;

    margin: 0;

    line-height: 1.5;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}
#rainbar {
    height: 10px;
    background-image: linear-gradient(139deg, #fb8817, #ff4b01, #c12127, #e02aff);
}

a {
    text-decoration: none;
    color: #0366d6;
}
a:hover {
    text-decoration: underline;
}

pre {
    margin: 1em 0px;
    padding: 1em;
    border: solid 1px #e1e4e8;
    border-radius: 6px;

    display: block;
    overflow: auto;

    white-space: pre;

    background-color: #f6f8fa;
    color: #393a34;
}
code {
    font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 85%;
    padding: 0.2em 0.4em;
    background-color: #f6f8fa;
    color: #393a34;
}
pre > code {
    padding: 0;
    background-color: inherit;
    color: inherit;
}
h1, h2, h3 {
    font-weight: 600;
}

#logobar {
    background-color: #333333;
    margin: 0 auto;
    padding: 1em 4em;
}
#logobar .logo {
    float: left;
}
#logobar .title {
    font-weight: 600;
    color: #dddddd;
    float: left;
    margin: 5px 0 0 1em;
}
#logobar:after {
    content: "";
    display: block;
    clear: both;
}

#content {
    margin: 0 auto;
    padding: 0 4em;
}

#table_of_contents > h2 {
    font-size: 1.17em;
}
#table_of_contents ul:first-child {
    border: solid 1px #e1e4e8;
    border-radius: 6px;
    padding: 1em;
    background-color: #f6f8fa;
    color: #393a34;
}
#table_of_contents ul {
    list-style-type: none;
    padding-left: 1.5em;
}
#table_of_contents li {
    font-size: 0.9em;
}
#table_of_contents li a {
    color: #000000;
}

header.title {
    border-bottom: solid 1px #e1e4e8;
}
header.title > h1 {
    margin-bottom: 0.25em;
}
header.title > .description {
    display: block;
    margin-bottom: 0.5em;
    line-height: 1;
}

header.title .version {
    font-size: 0.8em;
    color: #666666;
}

footer#edit {
    border-top: solid 1px #e1e4e8;
    margin: 3em 0 4em 0;
    padding-top: 2em;
}
</style>
</head>
<body>
<div id="banner">
<div id="rainbar"></div>
<div id="logobar">
<svg class="logo" role="img" height="32" width="32" viewBox="0 0 700 700">
<polygon fill="#cb0000" points="0,700 700,700 700,0 0,0"></polygon>
<polygon fill="#ffffff" points="150,550 350,550 350,250 450,250 450,550 550,550 550,150 150,150"></polygon>
</svg>
<div class="title">
npm command-line interface
</div>
</div>
</div>

<section id="content">
<header class="title">
<h1 id="----scripts----1092">
    <span>scripts</span>
    <span class="version">@10.9.2</span>
</h1>
<span class="description">How npm handles the "scripts" field</span>
</header>

<section id="table_of_contents">
<h2 id="table-of-contents">Table of contents</h2>
<div id="_table_of_contents"><ul><li><a href="#description">Description</a></li><li><a href="#pre--post-scripts">Pre &amp; Post Scripts</a></li><li><a href="#life-cycle-scripts">Life Cycle Scripts</a></li><ul><li><a href="#prepare-and-prepublish">Prepare and Prepublish</a></li><li><a href="#dependencies">Dependencies</a></li></ul><li><a href="#life-cycle-operation-order">Life Cycle Operation Order</a></li><ul><li><a href="#npm-cache-add"><a href="../commands/npm-cache.html"><code>npm cache add</code></a></a></li><li><a href="#npm-ci"><a href="../commands/npm-ci.html"><code>npm ci</code></a></a></li><li><a href="#npm-diff"><a href="../commands/npm-diff.html"><code>npm diff</code></a></a></li><li><a href="#npm-install"><a href="../commands/npm-install.html"><code>npm install</code></a></a></li><li><a href="#npm-pack"><a href="../commands/npm-pack.html"><code>npm pack</code></a></a></li><li><a href="#npm-publish"><a href="../commands/npm-publish.html"><code>npm publish</code></a></a></li><li><a href="#npm-rebuild"><a href="../commands/npm-rebuild.html"><code>npm rebuild</code></a></a></li><li><a href="#npm-restart"><a href="../commands/npm-restart.html"><code>npm restart</code></a></a></li><li><a href="#npm-run-user-defined"><a href="../commands/npm-run-script.html"><code>npm run &lt;user defined&gt;</code></a></a></li><li><a href="#npm-start"><a href="../commands/npm-start.html"><code>npm start</code></a></a></li><li><a href="#npm-stop"><a href="../commands/npm-stop.html"><code>npm stop</code></a></a></li><li><a href="#npm-test"><a href="../commands/npm-test.html"><code>npm test</code></a></a></li><li><a href="#npm-version"><a href="../commands/npm-version.html"><code>npm version</code></a></a></li><li><a href="#a-note-on-a-lack-of-npm-uninstall-scripts">A Note on a lack of <a href="../commands/npm-uninstall.html"><code>npm uninstall</code></a> scripts</a></li></ul><li><a href="#user">User</a></li><li><a href="#environment">Environment</a></li><ul><li><a href="#path">path</a></li><li><a href="#packagejson-vars">package.json vars</a></li><li><a href="#current-lifecycle-event">current lifecycle event</a></li></ul><li><a href="#examples">Examples</a></li><li><a href="#exiting">Exiting</a></li><li><a href="#best-practices">Best Practices</a></li><li><a href="#see-also">See Also</a></li></ul></div>
</section>

<div id="_content"><h3 id="description">Description</h3>
<p>The <code>"scripts"</code> property of your <code>package.json</code> file supports a number
of built-in scripts and their preset life cycle events as well as
arbitrary scripts. These all can be executed by running
<code>npm run-script &lt;stage&gt;</code> or <code>npm run &lt;stage&gt;</code> for short. <em>Pre</em> and <em>post</em>
commands with matching names will be run for those as well (e.g. <code>premyscript</code>,
<code>myscript</code>, <code>postmyscript</code>). Scripts from dependencies can be run with
<code>npm explore &lt;pkg&gt; -- npm run &lt;stage&gt;</code>.</p>
<h3 id="pre--post-scripts">Pre &amp; Post Scripts</h3>
<p>To create "pre" or "post" scripts for any scripts defined in the
<code>"scripts"</code> section of the <code>package.json</code>, simply create another script
<em>with a matching name</em> and add "pre" or "post" to the beginning of them.</p>
<pre><code class="language-json">{
  "scripts": {
    "precompress": "{{ executes BEFORE the `compress` script }}",
    "compress": "{{ run command to compress files }}",
    "postcompress": "{{ executes AFTER `compress` script }}"
  }
}
</code></pre>
<p>In this example <code>npm run compress</code> would execute these scripts as
described.</p>
<h3 id="life-cycle-scripts">Life Cycle Scripts</h3>
<p>There are some special life cycle scripts that happen only in certain
situations. These scripts happen in addition to the <code>pre&lt;event&gt;</code>, <code>post&lt;event&gt;</code>, and
<code>&lt;event&gt;</code> scripts.</p>
<ul>
<li><code>prepare</code>, <code>prepublish</code>, <code>prepublishOnly</code>, <code>prepack</code>, <code>postpack</code>, <code>dependencies</code></li>
</ul>
<p><strong>prepare</strong> (since <code>npm@4.0.0</code>)</p>
<ul>
<li>
<p>Runs BEFORE the package is packed, i.e. during <code>npm publish</code>
and <code>npm pack</code></p>
</li>
<li>
<p>Runs on local <code>npm install</code> without any arguments</p>
</li>
<li>
<p>Runs AFTER <code>prepublish</code>, but BEFORE <code>prepublishOnly</code></p>
</li>
<li>
<p>NOTE: If a package being installed through git contains a <code>prepare</code>
script, its <code>dependencies</code> and <code>devDependencies</code> will be installed, and
the prepare script will be run, before the package is packaged and
installed.</p>
</li>
<li>
<p>As of <code>npm@7</code> these scripts run in the background.
To see the output, run with: <code>--foreground-scripts</code>.</p>
</li>
</ul>
<p><strong>prepublish</strong> (DEPRECATED)</p>
<ul>
<li>Does not run during <code>npm publish</code>, but does run during <code>npm ci</code>
and <code>npm install</code>. See below for more info.</li>
</ul>
<p><strong>prepublishOnly</strong></p>
<ul>
<li>Runs BEFORE the package is prepared and packed, ONLY on <code>npm publish</code>.</li>
</ul>
<p><strong>prepack</strong></p>
<ul>
<li>Runs BEFORE a tarball is packed (on "<code>npm pack</code>", "<code>npm publish</code>", and when installing a git dependency).</li>
<li>NOTE: "<code>npm run pack</code>" is NOT the same as "<code>npm pack</code>". "<code>npm run pack</code>" is an arbitrary user defined script name, where as, "<code>npm pack</code>" is a CLI defined command.</li>
</ul>
<p><strong>postpack</strong></p>
<ul>
<li>Runs AFTER the tarball has been generated but before it is moved to its final destination (if at all, publish does not save the tarball locally)</li>
</ul>
<p><strong>dependencies</strong></p>
<ul>
<li>Runs AFTER any operations that modify the <code>node_modules</code> directory IF changes occurred.</li>
<li>Does NOT run in global mode</li>
</ul>
<h4 id="prepare-and-prepublish">Prepare and Prepublish</h4>
<p><strong>Deprecation Note: prepublish</strong></p>
<p>Since <code>npm@1.1.71</code>, the npm CLI has run the <code>prepublish</code> script for both <code>npm publish</code> and <code>npm install</code>, because it's a convenient way to prepare a package for use (some common use cases are described in the section below).  It has also turned out to be, in practice, <a href="https://github.com/npm/npm/issues/10074">very confusing</a>.  As of <code>npm@4.0.0</code>, a new event has been introduced, <code>prepare</code>, that preserves this existing behavior. A <em>new</em> event, <code>prepublishOnly</code> has been added as a transitional strategy to allow users to avoid the confusing behavior of existing npm versions and only run on <code>npm publish</code> (for instance, running the tests one last time to ensure they're in good shape).</p>
<p>See <a href="https://github.com/npm/npm/issues/10074">https://github.com/npm/npm/issues/10074</a> for a much lengthier justification, with further reading, for this change.</p>
<p><strong>Use Cases</strong></p>
<p>If you need to perform operations on your package before it is used, in a way that is not dependent on the operating system or architecture of the target system, use a <code>prepublish</code> script. This includes tasks such as:</p>
<ul>
<li>Compiling CoffeeScript source code into JavaScript.</li>
<li>Creating minified versions of JavaScript source code.</li>
<li>Fetching remote resources that your package will use.</li>
</ul>
<p>The advantage of doing these things at <code>prepublish</code> time is that they can be done once, in a single place, thus reducing complexity and variability. Additionally, this means that:</p>
<ul>
<li>You can depend on <code>coffee-script</code> as a <code>devDependency</code>, and thus
your users don't need to have it installed.</li>
<li>You don't need to include minifiers in your package, reducing
the size for your users.</li>
<li>You don't need to rely on your users having <code>curl</code> or <code>wget</code> or
other system tools on the target machines.</li>
</ul>
<h4 id="dependencies">Dependencies</h4>
<p>The <code>dependencies</code> script is run any time an <code>npm</code> command causes changes to the <code>node_modules</code> directory. It is run AFTER the changes have been applied and the <code>package.json</code> and <code>package-lock.json</code> files have been updated.</p>
<h3 id="life-cycle-operation-order">Life Cycle Operation Order</h3>
<h4 id="npm-cache-add"><a href="../commands/npm-cache.html"><code>npm cache add</code></a></h4>
<ul>
<li><code>prepare</code></li>
</ul>
<h4 id="npm-ci"><a href="../commands/npm-ci.html"><code>npm ci</code></a></h4>
<ul>
<li><code>preinstall</code></li>
<li><code>install</code></li>
<li><code>postinstall</code></li>
<li><code>prepublish</code></li>
<li><code>preprepare</code></li>
<li><code>prepare</code></li>
<li><code>postprepare</code></li>
</ul>
<p>These all run after the actual installation of modules into
<code>node_modules</code>, in order, with no internal actions happening in between</p>
<h4 id="npm-diff"><a href="../commands/npm-diff.html"><code>npm diff</code></a></h4>
<ul>
<li><code>prepare</code></li>
</ul>
<h4 id="npm-install"><a href="../commands/npm-install.html"><code>npm install</code></a></h4>
<p>These also run when you run <code>npm install -g &lt;pkg-name&gt;</code></p>
<ul>
<li><code>preinstall</code></li>
<li><code>install</code></li>
<li><code>postinstall</code></li>
<li><code>prepublish</code></li>
<li><code>preprepare</code></li>
<li><code>prepare</code></li>
<li><code>postprepare</code></li>
</ul>
<p>If there is a <code>binding.gyp</code> file in the root of your package and you
haven't defined your own <code>install</code> or <code>preinstall</code> scripts, npm will
default the <code>install</code> command to compile using node-gyp via <code>node-gyp rebuild</code></p>
<p>These are run from the scripts of <code>&lt;pkg-name&gt;</code></p>
<h4 id="npm-pack"><a href="../commands/npm-pack.html"><code>npm pack</code></a></h4>
<ul>
<li><code>prepack</code></li>
<li><code>prepare</code></li>
<li><code>postpack</code></li>
</ul>
<h4 id="npm-publish"><a href="../commands/npm-publish.html"><code>npm publish</code></a></h4>
<ul>
<li><code>prepublishOnly</code></li>
<li><code>prepack</code></li>
<li><code>prepare</code></li>
<li><code>postpack</code></li>
<li><code>publish</code></li>
<li><code>postpublish</code></li>
</ul>
<h4 id="npm-rebuild"><a href="../commands/npm-rebuild.html"><code>npm rebuild</code></a></h4>
<ul>
<li><code>preinstall</code></li>
<li><code>install</code></li>
<li><code>postinstall</code></li>
<li><code>prepare</code></li>
</ul>
<p><code>prepare</code> is only run if the current directory is a symlink (e.g. with
linked packages)</p>
<h4 id="npm-restart"><a href="../commands/npm-restart.html"><code>npm restart</code></a></h4>
<p>If there is a <code>restart</code> script defined, these events are run, otherwise
<code>stop</code> and <code>start</code> are both run if present, including their <code>pre</code> and
<code>post</code> iterations)</p>
<ul>
<li><code>prerestart</code></li>
<li><code>restart</code></li>
<li><code>postrestart</code></li>
</ul>
<h4 id="npm-run-user-defined"><a href="../commands/npm-run-script.html"><code>npm run &lt;user defined&gt;</code></a></h4>
<ul>
<li><code>pre&lt;user-defined&gt;</code></li>
<li><code>&lt;user-defined&gt;</code></li>
<li><code>post&lt;user-defined&gt;</code></li>
</ul>
<h4 id="npm-start"><a href="../commands/npm-start.html"><code>npm start</code></a></h4>
<ul>
<li><code>prestart</code></li>
<li><code>start</code></li>
<li><code>poststart</code></li>
</ul>
<p>If there is a <code>server.js</code> file in the root of your package, then npm
will default the <code>start</code> command to <code>node server.js</code>.  <code>prestart</code> and
<code>poststart</code> will still run in this case.</p>
<h4 id="npm-stop"><a href="../commands/npm-stop.html"><code>npm stop</code></a></h4>
<ul>
<li><code>prestop</code></li>
<li><code>stop</code></li>
<li><code>poststop</code></li>
</ul>
<h4 id="npm-test"><a href="../commands/npm-test.html"><code>npm test</code></a></h4>
<ul>
<li><code>pretest</code></li>
<li><code>test</code></li>
<li><code>posttest</code></li>
</ul>
<h4 id="npm-version"><a href="../commands/npm-version.html"><code>npm version</code></a></h4>
<ul>
<li><code>preversion</code></li>
<li><code>version</code></li>
<li><code>postversion</code></li>
</ul>
<h4 id="a-note-on-a-lack-of-npm-uninstall-scripts">A Note on a lack of <a href="../commands/npm-uninstall.html"><code>npm uninstall</code></a> scripts</h4>
<p>While npm v6 had <code>uninstall</code> lifecycle scripts, npm v7 does not. Removal of a package can happen for a wide variety of reasons, and there's no clear way to currently give the script enough context to be useful.</p>
<p>Reasons for a package removal include:</p>
<ul>
<li>a user directly uninstalled this package</li>
<li>a user uninstalled a dependant package and so this dependency is being uninstalled</li>
<li>a user uninstalled a dependant package but another package also depends on this version</li>
<li>this version has been merged as a duplicate with another version</li>
<li>etc.</li>
</ul>
<p>Due to the lack of necessary context, <code>uninstall</code> lifecycle scripts are not implemented and will not function.</p>
<h3 id="user">User</h3>
<p>When npm is run as root, scripts are always run with the effective uid
and gid of the working directory owner.</p>
<h3 id="environment">Environment</h3>
<p>Package scripts run in an environment where many pieces of information
are made available regarding the setup of npm and the current state of
the process.</p>
<h4 id="path">path</h4>
<p>If you depend on modules that define executable scripts, like test
suites, then those executables will be added to the <code>PATH</code> for
executing the scripts.  So, if your package.json has this:</p>
<pre><code class="language-json">{
  "name" : "foo",
  "dependencies" : {
    "bar" : "0.1.x"
  },
  "scripts": {
    "start" : "bar ./test"
  }
}
</code></pre>
<p>then you could run <code>npm start</code> to execute the <code>bar</code> script, which is
exported into the <code>node_modules/.bin</code> directory on <code>npm install</code>.</p>
<h4 id="packagejson-vars">package.json vars</h4>
<p>The package.json fields are tacked onto the <code>npm_package_</code> prefix. So,
for instance, if you had <code>{"name":"foo", "version":"1.2.5"}</code> in your
package.json file, then your package scripts would have the
<code>npm_package_name</code> environment variable set to "foo", and the
<code>npm_package_version</code> set to "1.2.5".  You can access these variables
in your code with <code>process.env.npm_package_name</code> and
<code>process.env.npm_package_version</code>, and so on for other fields.</p>
<p>See <a href="../configuring-npm/package-json.html"><code>package.json</code></a> for more on package configs.</p>
<h4 id="current-lifecycle-event">current lifecycle event</h4>
<p>Lastly, the <code>npm_lifecycle_event</code> environment variable is set to
whichever stage of the cycle is being executed. So, you could have a
single script used for different parts of the process which switches
based on what's currently happening.</p>
<p>Objects are flattened following this format, so if you had
<code>{"scripts":{"install":"foo.js"}}</code> in your package.json, then you'd
see this in the script:</p>
<pre><code class="language-bash">process.env.npm_package_scripts_install === "foo.js"
</code></pre>
<h3 id="examples">Examples</h3>
<p>For example, if your package.json contains this:</p>
<pre><code class="language-json">{
  "scripts" : {
    "install" : "scripts/install.js",
    "postinstall" : "scripts/install.js"
  }
}
</code></pre>
<p>then <code>scripts/install.js</code> will be called for the install and post-install
stages of the lifecycle.  Since <code>scripts/install.js</code> is running for two
different phases, it would be wise in this case to look at the
<code>npm_lifecycle_event</code> environment variable.</p>
<p>If you want to run a make command, you can do so.  This works just
fine:</p>
<pre><code class="language-json">{
  "scripts" : {
    "preinstall" : "./configure",
    "install" : "make &amp;&amp; make install",
    "test" : "make test"
  }
}
</code></pre>
<h3 id="exiting">Exiting</h3>
<p>Scripts are run by passing the line as a script argument to <code>sh</code>.</p>
<p>If the script exits with a code other than 0, then this will abort the
process.</p>
<p>Note that these script files don't have to be Node.js or even
JavaScript programs. They just have to be some kind of executable
file.</p>
<h3 id="best-practices">Best Practices</h3>
<ul>
<li>Don't exit with a non-zero error code unless you <em>really</em> mean it.
If the failure is minor or only will prevent some optional features, then
it's better to just print a warning and exit successfully.</li>
<li>Try not to use scripts to do what npm can do for you.  Read through
<a href="../configuring-npm/package-json.html"><code>package.json</code></a> to see all the things that you can specify and enable
by simply describing your package appropriately.  In general, this
will lead to a more robust and consistent state.</li>
<li>Inspect the env to determine where to put things.  For instance, if
the <code>npm_config_binroot</code> environment variable is set to <code>/home/user/bin</code>, then
don't try to install executables into <code>/usr/local/bin</code>.  The user
probably set it up that way for a reason.</li>
<li>Don't prefix your script commands with "sudo".  If root permissions
are required for some reason, then it'll fail with that error, and
the user will sudo the npm command in question.</li>
<li>Don't use <code>install</code>. Use a <code>.gyp</code> file for compilation, and <code>prepare</code>
for anything else. You should almost never have to explicitly set a
preinstall or install script. If you are doing this, please consider if
there is another option. The only valid use of <code>install</code> or <code>preinstall</code>
scripts is for compilation which must be done on the target architecture.</li>
<li>Scripts are run from the root of the package folder, regardless of what the
current working directory is when <code>npm</code> is invoked. If you want your
script to use different behavior based on what subdirectory you're in, you
can use the <code>INIT_CWD</code> environment variable, which holds the full path you
were in when you ran <code>npm run</code>.</li>
</ul>
<h3 id="see-also">See Also</h3>
<ul>
<li><a href="../commands/npm-run-script.html">npm run-script</a></li>
<li><a href="../configuring-npm/package-json.html">package.json</a></li>
<li><a href="../using-npm/developers.html">npm developers</a></li>
<li><a href="../commands/npm-install.html">npm install</a></li>
</ul></div>

<footer id="edit">
<a href="https://github.com/npm/cli/edit/latest/docs/content/using-npm/scripts.md">
<svg role="img" viewBox="0 0 16 16" width="16" height="16" fill="currentcolor" style="vertical-align: text-bottom; margin-right: 0.3em;">
<path fill-rule="evenodd" d="M11.013 1.427a1.75 1.75 0 012.474 0l1.086 1.086a1.75 1.75 0 010 2.474l-8.61 8.61c-.21.21-.47.364-.756.445l-3.251.93a.75.75 0 01-.927-.928l.929-3.25a1.75 1.75 0 01.445-.758l8.61-8.61zm1.414 1.06a.25.25 0 00-.354 0L10.811 3.75l1.439 1.44 1.263-1.263a.25.25 0 000-.354l-1.086-1.086zM11.189 6.25L9.75 4.81l-6.286 6.287a.25.25 0 00-.064.108l-.558 1.953 1.953-.558a.249.249 0 00.108-.064l6.286-6.286z"></path>
</svg>
Edit this page on GitHub
</a>
</footer>
</section>



</body></html>                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/npm/docs/output/using-npm/workspaces.html                                          0000664 0000000 0000000 00000027132 14746647661 0023563 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        <!DOCTYPE html><html><head>
<meta charset="utf-8">
<title>workspaces</title>
<style>
body {
    background-color: #ffffff;
    color: #24292e;

    margin: 0;

    line-height: 1.5;

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}
#rainbar {
    height: 10px;
    background-image: linear-gradient(139deg, #fb8817, #ff4b01, #c12127, #e02aff);
}

a {
    text-decoration: none;
    color: #0366d6;
}
a:hover {
    text-decoration: underline;
}

pre {
    margin: 1em 0px;
    padding: 1em;
    border: solid 1px #e1e4e8;
    border-radius: 6px;

    display: block;
    overflow: auto;

    white-space: pre;

    background-color: #f6f8fa;
    color: #393a34;
}
code {
    font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 85%;
    padding: 0.2em 0.4em;
    background-color: #f6f8fa;
    color: #393a34;
}
pre > code {
    padding: 0;
    background-color: inherit;
    color: inherit;
}
h1, h2, h3 {
    font-weight: 600;
}

#logobar {
    background-color: #333333;
    margin: 0 auto;
    padding: 1em 4em;
}
#logobar .logo {
    float: left;
}
#logobar .title {
    font-weight: 600;
    color: #dddddd;
    float: left;
    margin: 5px 0 0 1em;
}
#logobar:after {
    content: "";
    display: block;
    clear: both;
}

#content {
    margin: 0 auto;
    padding: 0 4em;
}

#table_of_contents > h2 {
    font-size: 1.17em;
}
#table_of_contents ul:first-child {
    border: solid 1px #e1e4e8;
    border-radius: 6px;
    padding: 1em;
    background-color: #f6f8fa;
    color: #393a34;
}
#table_of_contents ul {
    list-style-type: none;
    padding-left: 1.5em;
}
#table_of_contents li {
    font-size: 0.9em;
}
#table_of_contents li a {
    color: #000000;
}

header.title {
    border-bottom: solid 1px #e1e4e8;
}
header.title > h1 {
    margin-bottom: 0.25em;
}
header.title > .description {
    display: block;
    margin-bottom: 0.5em;
    line-height: 1;
}

header.title .version {
    font-size: 0.8em;
    color: #666666;
}

footer#edit {
    border-top: solid 1px #e1e4e8;
    margin: 3em 0 4em 0;
    padding-top: 2em;
}
</style>
</head>
<body>
<div id="banner">
<div id="rainbar"></div>
<div id="logobar">
<svg class="logo" role="img" height="32" width="32" viewBox="0 0 700 700">
<polygon fill="#cb0000" points="0,700 700,700 700,0 0,0"></polygon>
<polygon fill="#ffffff" points="150,550 350,550 350,250 450,250 450,550 550,550 550,150 150,150"></polygon>
</svg>
<div class="title">
npm command-line interface
</div>
</div>
</div>

<section id="content">
<header class="title">
<h1 id="----workspaces----1092">
    <span>workspaces</span>
    <span class="version">@10.9.2</span>
</h1>
<span class="description">Working with workspaces</span>
</header>

<section id="table_of_contents">
<h2 id="table-of-contents">Table of contents</h2>
<div id="_table_of_contents"><ul><li><a href="#description">Description</a></li><li><a href="#defining-workspaces">Defining workspaces</a></li><li><a href="#getting-started-with-workspaces">Getting started with workspaces</a></li><li><a href="#adding-dependencies-to-a-workspace">Adding dependencies to a workspace</a></li><li><a href="#using-workspaces">Using workspaces</a></li><li><a href="#running-commands-in-the-context-of-workspaces">Running commands in the context of workspaces</a></li><li><a href="#ignoring-missing-scripts">Ignoring missing scripts</a></li><li><a href="#see-also">See also</a></li></ul></div>
</section>

<div id="_content"><h3 id="description">Description</h3>
<p><strong>Workspaces</strong> is a generic term that refers to the set of features in the
npm cli that provides support for managing multiple packages from your local
file system from within a singular top-level, root package.</p>
<p>This set of features makes up for a much more streamlined workflow handling
linked packages from the local file system. It automates the linking process
as part of <code>npm install</code> and removes the need to manually use <code>npm link</code> in
order to add references to packages that should be symlinked into the current
<code>node_modules</code> folder.</p>
<p>We also refer to these packages being auto-symlinked during <code>npm install</code> as a
single <strong>workspace</strong>, meaning it's a nested package within the current local
file system that is explicitly defined in the <a href="../configuring-npm/package-json#workspaces.html"><code>package.json</code></a>
<code>workspaces</code> configuration.</p>
<h3 id="defining-workspaces">Defining workspaces</h3>
<p>Workspaces are usually defined via the <code>workspaces</code> property of the
<a href="../configuring-npm/package-json#workspaces.html"><code>package.json</code></a> file, e.g:</p>
<pre><code class="language-json">{
  "name": "my-workspaces-powered-project",
  "workspaces": [
    "packages/a"
  ]
}
</code></pre>
<p>Given the above <code>package.json</code> example living at a current working
directory <code>.</code> that contains a folder named <code>packages/a</code> that itself contains
a <code>package.json</code> inside it, defining a Node.js package, e.g:</p>
<pre><code>.
+-- package.json
`-- packages
   +-- a
   |   `-- package.json
</code></pre>
<p>The expected result once running <code>npm install</code> in this current working
directory <code>.</code> is that the folder <code>packages/a</code> will get symlinked to the
<code>node_modules</code> folder of the current working dir.</p>
<p>Below is a post <code>npm install</code> example, given that same previous example
structure of files and folders:</p>
<pre><code>.
+-- node_modules
|  `-- a -&gt; ../packages/a
+-- package-lock.json
+-- package.json
`-- packages
   +-- a
   |   `-- package.json
</code></pre>
<h3 id="getting-started-with-workspaces">Getting started with workspaces</h3>
<p>You may automate the required steps to define a new workspace using
<a href="../commands/npm-init.html">npm init</a>. For example in a project that already has a
<code>package.json</code> defined you can run:</p>
<pre><code>npm init -w ./packages/a
</code></pre>
<p>This command will create the missing folders and a new <code>package.json</code>
file (if needed) while also making sure to properly configure the
<code>"workspaces"</code> property of your root project <code>package.json</code>.</p>
<h3 id="adding-dependencies-to-a-workspace">Adding dependencies to a workspace</h3>
<p>It's possible to directly add/remove/update dependencies of your workspaces
using the <a href="../using-npm/config#workspace.html"><code>workspace</code> config</a>.</p>
<p>For example, assuming the following structure:</p>
<pre><code>.
+-- package.json
`-- packages
   +-- a
   |   `-- package.json
   `-- b
       `-- package.json
</code></pre>
<p>If you want to add a dependency named <code>abbrev</code> from the registry as a
dependency of your workspace <strong>a</strong>, you may use the workspace config to tell
the npm installer that package should be added as a dependency of the provided
workspace:</p>
<pre><code>npm install abbrev -w a
</code></pre>
<p>Note: other installing commands such as <code>uninstall</code>, <code>ci</code>, etc will also
respect the provided <code>workspace</code> configuration.</p>
<h3 id="using-workspaces">Using workspaces</h3>
<p>Given the <a href="https://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_all_together">specifics of how Node.js handles module resolution</a> it's possible to consume any defined workspace
by its declared <code>package.json</code> <code>name</code>. Continuing from the example defined
above, let's also create a Node.js script that will require the workspace <code>a</code>
example module, e.g:</p>
<pre><code>// ./packages/a/index.js
module.exports = 'a'

// ./lib/index.js
const moduleA = require('a')
console.log(moduleA) // -&gt; a
</code></pre>
<p>When running it with:</p>
<p><code>node lib/index.js</code></p>
<p>This demonstrates how the nature of <code>node_modules</code> resolution allows for
<strong>workspaces</strong> to enable a portable workflow for requiring each <strong>workspace</strong>
in such a way that is also easy to <a href="../commands/npm-publish.html">publish</a> these
nested workspaces to be consumed elsewhere.</p>
<h3 id="running-commands-in-the-context-of-workspaces">Running commands in the context of workspaces</h3>
<p>You can use the <code>workspace</code> configuration option to run commands in the context
of a configured workspace.
Additionally, if your current directory is in a workspace, the <code>workspace</code>
configuration is implicitly set, and <code>prefix</code> is set to the root workspace.</p>
<p>Following is a quick example on how to use the <code>npm run</code> command in the context
of nested workspaces. For a project containing multiple workspaces, e.g:</p>
<pre><code>.
+-- package.json
`-- packages
   +-- a
   |   `-- package.json
   `-- b
       `-- package.json
</code></pre>
<p>By running a command using the <code>workspace</code> option, it's possible to run the
given command in the context of that specific workspace. e.g:</p>
<pre><code>npm run test --workspace=a
</code></pre>
<p>You could also run the command within the workspace.</p>
<pre><code>cd packages/a &amp;&amp; npm run test
</code></pre>
<p>Either will run the <code>test</code> script defined within the
<code>./packages/a/package.json</code> file.</p>
<p>Please note that you can also specify this argument multiple times in the
command-line in order to target multiple workspaces, e.g:</p>
<pre><code>npm run test --workspace=a --workspace=b
</code></pre>
<p>Or run the command for each workspace within the 'packages' folder:</p>
<pre><code>npm run test --workspace=packages
</code></pre>
<p>It's also possible to use the <code>workspaces</code> (plural) configuration option to
enable the same behavior but running that command in the context of <strong>all</strong>
configured workspaces. e.g:</p>
<pre><code>npm run test --workspaces
</code></pre>
<p>Will run the <code>test</code> script in both <code>./packages/a</code> and <code>./packages/b</code>.</p>
<p>Commands will be run in each workspace in the order they appear in your <code>package.json</code></p>
<pre><code>{
  "workspaces": [ "packages/a", "packages/b" ]
}
</code></pre>
<p>Order of run is different with:</p>
<pre><code>{
  "workspaces": [ "packages/b", "packages/a" ]
}
</code></pre>
<h3 id="ignoring-missing-scripts">Ignoring missing scripts</h3>
<p>It is not required for all of the workspaces to implement scripts run with the <code>npm run</code> command.</p>
<p>By running the command with the <code>--if-present</code> flag, npm will ignore workspaces missing target script.</p>
<pre><code>npm run test --workspaces --if-present
</code></pre>
<h3 id="see-also">See also</h3>
<ul>
<li><a href="../commands/npm-install.html">npm install</a></li>
<li><a href="../commands/npm-publish.html">npm publish</a></li>
<li><a href="../commands/npm-run-script.html">npm run-script</a></li>
<li><a href="../using-npm/config.html">config</a></li>
</ul></div>

<footer id="edit">
<a href="https://github.com/npm/cli/edit/latest/docs/content/using-npm/workspaces.md">
<svg role="img" viewBox="0 0 16 16" width="16" height="16" fill="currentcolor" style="vertical-align: text-bottom; margin-right: 0.3em;">
<path fill-rule="evenodd" d="M11.013 1.427a1.75 1.75 0 012.474 0l1.086 1.086a1.75 1.75 0 010 2.474l-8.61 8.61c-.21.21-.47.364-.756.445l-3.251.93a.75.75 0 01-.927-.928l.929-3.25a1.75 1.75 0 01.445-.758l8.61-8.61zm1.414 1.06a.25.25 0 00-.354 0L10.811 3.75l1.439 1.44 1.263-1.263a.25.25 0 000-.354l-1.086-1.086zM11.189 6.25L9.75 4.81l-6.286 6.287a.25.25 0 00-.064.108l-.558 1.953 1.953-.558a.249.249 0 00.108-.064l6.286-6.286z"></path>
</svg>
Edit this page on GitHub
</a>
</footer>
</section>



</body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/npm/index.js                                                                       0000664 0000000 0000000 00000000221 14746647661 0015742 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        if (require.main === module) {
  require('./lib/cli.js')(process)
} else {
  throw new Error('The programmatic API was removed in npm v8.0.0')
}
                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/npm/lib/                                                                           0000775 0000000 0000000 00000000000 14746647661 0015050 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/npm/lib/arborist-cmd.js                                                            0000664 0000000 0000000 00000003160 14746647661 0017774 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { log } = require('proc-log')
const BaseCommand = require('./base-cmd.js')

// This is the base for all commands whose execWorkspaces just gets
// a list of workspace names and passes it on to new Arborist() to
// be able to run a filtered Arborist.reify() at some point.
class ArboristCmd extends BaseCommand {
  get isArboristCmd () {
    return true
  }

  static params = [
    'workspace',
    'workspaces',
    'include-workspace-root',
    'install-links',
  ]

  static workspaces = true
  static ignoreImplicitWorkspace = false
  static checkDevEngines = true

  constructor (npm) {
    super(npm)

    const { config } = this.npm

    // when location isn't set and global isn't true check for a package.json at
    // the localPrefix and set the location to project if found
    const locationProject = config.get('location') === 'project' || (
      config.isDefault('location')
      // this is different then `npm.global` which falls back to checking
      // location which we do not want to use here
      && !config.get('global')
      && npm.localPackage
    )

    // if audit is not set and we are in global mode and location is not project
    // and we assume its not a project related context, then we set audit=false
    if (config.isDefault('audit') && (this.npm.global || !locationProject)) {
      config.set('audit', false)
    } else if (this.npm.global && config.get('audit')) {
      log.warn('config', 'includes both --global and --audit, which is currently unsupported.')
    }
  }

  async execWorkspaces (args) {
    await this.setWorkspaces()
    return this.exec(args)
  }
}

module.exports = ArboristCmd
                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/npm/lib/base-cmd.js                                                                0000664 0000000 0000000 00000014174 14746647661 0017070 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { log } = require('proc-log')

class BaseCommand {
  // these defaults can be overridden by individual commands
  static workspaces = false
  static ignoreImplicitWorkspace = true
  static checkDevEngines = false

  // these should always be overridden by individual commands
  static name = null
  static description = null
  static params = null

  // this is a static so that we can read from it without instantiating a command
  // which would require loading the config
  static get describeUsage () {
    const { definitions } = require('@npmcli/config/lib/definitions')
    const { aliases: cmdAliases } = require('./utils/cmd-list')
    const seenExclusive = new Set()
    const wrapWidth = 80
    const { description, usage = [''], name, params } = this

    const fullUsage = [
      `${description}`,
      '',
      'Usage:',
      ...usage.map(u => `npm ${name} ${u}`.trim()),
    ]

    if (params) {
      let results = ''
      let line = ''
      for (const param of params) {
        /* istanbul ignore next */
        if (seenExclusive.has(param)) {
          continue
        }
        const { exclusive } = definitions[param]
        let paramUsage = `${definitions[param].usage}`
        if (exclusive) {
          const exclusiveParams = [paramUsage]
          seenExclusive.add(param)
          for (const e of exclusive) {
            seenExclusive.add(e)
            exclusiveParams.push(definitions[e].usage)
          }
          paramUsage = `${exclusiveParams.join('|')}`
        }
        paramUsage = `[${paramUsage}]`
        if (line.length + paramUsage.length > wrapWidth) {
          results = [results, line].filter(Boolean).join('\n')
          line = ''
        }
        line = [line, paramUsage].filter(Boolean).join(' ')
      }
      fullUsage.push('')
      fullUsage.push('Options:')
      fullUsage.push([results, line].filter(Boolean).join('\n'))
    }

    const aliases = Object.entries(cmdAliases).reduce((p, [k, v]) => {
      return p.concat(v === name ? k : [])
    }, [])

    if (aliases.length) {
      const plural = aliases.length === 1 ? '' : 'es'
      fullUsage.push('')
      fullUsage.push(`alias${plural}: ${aliases.join(', ')}`)
    }

    fullUsage.push('')
    fullUsage.push(`Run "npm help ${name}" for more info`)

    return fullUsage.join('\n')
  }

  constructor (npm) {
    this.npm = npm

    const { config } = this.npm

    if (!this.constructor.skipConfigValidation) {
      config.validate()
    }

    if (config.get('workspaces') === false && config.get('workspace').length) {
      throw new Error('Can not use --no-workspaces and --workspace at the same time')
    }
  }

  get name () {
    return this.constructor.name
  }

  get description () {
    return this.constructor.description
  }

  get params () {
    return this.constructor.params
  }

  get usage () {
    return this.constructor.describeUsage
  }

  usageError (prefix = '') {
    if (prefix) {
      prefix += '\n\n'
    }
    return Object.assign(new Error(`\n${prefix}${this.usage}`), {
      code: 'EUSAGE',
    })
  }

  // Compare the number of entries with what was expected
  checkExpected (entries) {
    if (!this.npm.config.isDefault('expect-results')) {
      const expected = this.npm.config.get('expect-results')
      if (!!entries !== !!expected) {
        log.warn(this.name, `Expected ${expected ? '' : 'no '}results, got ${entries}`)
        process.exitCode = 1
      }
    } else if (!this.npm.config.isDefault('expect-result-count')) {
      const expected = this.npm.config.get('expect-result-count')
      if (expected !== entries) {
        /* eslint-disable-next-line max-len */
        log.warn(this.name, `Expected ${expected} result${expected === 1 ? '' : 's'}, got ${entries}`)
        process.exitCode = 1
      }
    }
  }

  // Checks the devEngines entry in the package.json at this.localPrefix
  async checkDevEngines () {
    const force = this.npm.flatOptions.force

    const { devEngines } = await require('@npmcli/package-json')
      .normalize(this.npm.config.localPrefix)
      .then(p => p.content)
      .catch(() => ({}))

    if (typeof devEngines === 'undefined') {
      return
    }

    const { checkDevEngines, currentEnv } = require('npm-install-checks')
    const current = currentEnv.devEngines({
      nodeVersion: this.npm.nodeVersion,
      npmVersion: this.npm.version,
    })

    const failures = checkDevEngines(devEngines, current)
    const warnings = failures.filter(f => f.isWarn)
    const errors = failures.filter(f => f.isError)

    const genMsg = (failure, i = 0) => {
      return [...new Set([
        // eslint-disable-next-line
        i === 0 ? 'The developer of this package has specified the following through devEngines' : '',
        `${failure.message}`,
        `${failure.errors.map(e => e.message).join('\n')}`,
      ])].filter(v => v).join('\n')
    }

    [...warnings, ...(force ? errors : [])].forEach((failure, i) => {
      const message = genMsg(failure, i)
      log.warn('EBADDEVENGINES', message)
      log.warn('EBADDEVENGINES', {
        current: failure.current,
        required: failure.required,
      })
    })

    if (force) {
      return
    }

    if (errors.length) {
      const failure = errors[0]
      const message = genMsg(failure)
      throw Object.assign(new Error(message), {
        engine: failure.engine,
        code: 'EBADDEVENGINES',
        current: failure.current,
        required: failure.required,
      })
    }
  }

  async setWorkspaces () {
    const { relative } = require('node:path')

    const includeWorkspaceRoot = this.isArboristCmd
      ? false
      : this.npm.config.get('include-workspace-root')

    const prefixInsideCwd = relative(this.npm.localPrefix, process.cwd()).startsWith('..')
    const relativeFrom = prefixInsideCwd ? this.npm.localPrefix : process.cwd()

    const filters = this.npm.config.get('workspace')
    const getWorkspaces = require('./utils/get-workspaces.js')
    const ws = await getWorkspaces(filters, {
      path: this.npm.localPrefix,
      includeWorkspaceRoot,
      relativeFrom,
    })

    this.workspaces = ws
    this.workspaceNames = [...ws.keys()]
    this.workspacePaths = [...ws.values()]
  }
}

module.exports = BaseCommand
                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/npm/lib/cli.js                                                                     0000664 0000000 0000000 00000000627 14746647661 0016162 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        try {
  const { enableCompileCache } = require('node:module')
  /* istanbul ignore next */
  if (enableCompileCache) {
    enableCompileCache()
  }
} catch (e) { /* istanbul ignore next */ }

const validateEngines = require('./cli/validate-engines.js')
const cliEntry = require('node:path').resolve(__dirname, 'cli/entry.js')

module.exports = (process) => validateEngines(process, () => require(cliEntry))
                                                                                                         node-23.7.0/deps/npm/lib/cli/                                                                       0000775 0000000 0000000 00000000000 14746647661 0015617 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/npm/lib/cli/entry.js                                                               0000664 0000000 0000000 00000006177 14746647661 0017331 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* eslint-disable max-len */

// Separated out for easier unit testing
module.exports = async (process, validateEngines) => {
  // set it here so that regardless of what happens later, we don't
  // leak any private CLI configs to other programs
  process.title = 'npm'

  // if npm is called as "npmg" or "npm_g", then run in global mode.
  if (process.argv[1][process.argv[1].length - 1] === 'g') {
    process.argv.splice(1, 1, 'npm', '-g')
  }

  // Patch the global fs module here at the app level
  require('graceful-fs').gracefulify(require('node:fs'))

  const satisfies = require('semver/functions/satisfies')
  const ExitHandler = require('./exit-handler.js')
  const exitHandler = new ExitHandler({ process })
  const Npm = require('../npm.js')
  const npm = new Npm()
  exitHandler.setNpm(npm)

  // only log node and npm paths in argv initially since argv can contain sensitive info. a cleaned version will be logged later
  const { log, output } = require('proc-log')
  log.verbose('cli', process.argv.slice(0, 2).join(' '))
  log.info('using', 'npm@%s', npm.version)
  log.info('using', 'node@%s', process.version)

  // At this point we've required a few files and can be pretty sure we dont contain invalid syntax for this version of node. It's possible a lazy require would, but that's unlikely enough that it's not worth catching anymore and we attach the more important exit handlers.
  validateEngines.off()
  exitHandler.registerUncaughtHandlers()

  // It is now safe to log a warning if they are using a version of node that is not going to fail on syntax errors but is still unsupported and untested and might not work reliably. This is safe to use the logger now which we want since this will show up in the error log too.
  if (!satisfies(validateEngines.node, validateEngines.engines)) {
    log.warn('cli', validateEngines.unsupportedMessage)
  }

  // Now actually fire up npm and run the command.
  // This is how to use npm programmatically:
  try {
    const { exec, command, args } = await npm.load()

    if (!exec) {
      return exitHandler.exit()
    }

    if (!command) {
      output.standard(npm.usage)
      process.exitCode = 1
      return exitHandler.exit()
    }

    // Options are prefixed by a hyphen-minus (-, \u2d).
    // Other dash-type chars look similar but are invalid.
    const nonDashArgs = npm.argv.filter(a => /^[\u2010-\u2015\u2212\uFE58\uFE63\uFF0D]/.test(a))
    if (nonDashArgs.length) {
      log.error(
        'arg',
        'Argument starts with non-ascii dash, this is probably invalid:',
        require('@npmcli/redact').redactLog(nonDashArgs.join(', '))
      )
    }

    const execPromise = npm.exec(command, args)

    // this is async but we dont await it, since its ok if it doesnt
    // finish before the command finishes running. it uses command and argv
    // so it must be initiated here, after the command name is set
    const updateNotifier = require('./update-notifier.js')
    // eslint-disable-next-line promise/catch-or-return
    updateNotifier(npm).then((msg) => (npm.updateNotification = msg))

    await execPromise
    return exitHandler.exit()
  } catch (err) {
    return exitHandler.exit(err)
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/npm/lib/cli/exit-handler.js                                                        0000664 0000000 0000000 00000012226 14746647661 0020544 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { log, output, META } = require('proc-log')
const { errorMessage, getExitCodeFromError } = require('../utils/error-message.js')

class ExitHandler {
  #npm = null
  #process = null
  #exited = false
  #exitErrorMessage = false

  #noNpmError = false

  get #hasNpm () {
    return !!this.#npm
  }

  get #loaded () {
    return !!this.#npm?.loaded
  }

  get #showExitErrorMessage () {
    if (!this.#loaded) {
      return false
    }
    if (!this.#exited) {
      return true
    }
    return this.#exitErrorMessage
  }

  get #notLoadedOrExited () {
    return !this.#loaded && !this.#exited
  }

  setNpm (npm) {
    this.#npm = npm
  }

  constructor ({ process }) {
    this.#process = process
    this.#process.on('exit', this.#handleProcesExitAndReset)
  }

  registerUncaughtHandlers () {
    this.#process.on('uncaughtException', this.#handleExit)
    this.#process.on('unhandledRejection', this.#handleExit)
  }

  exit (err) {
    this.#handleExit(err)
  }

  #handleProcesExitAndReset = (code) => {
    this.#handleProcessExit(code)

    // Reset all the state. This is only relevant for tests since
    // in reality the process fully exits here.
    this.#process.off('exit', this.#handleProcesExitAndReset)
    this.#process.off('uncaughtException', this.#handleExit)
    this.#process.off('unhandledRejection', this.#handleExit)
    if (this.#loaded) {
      this.#npm.unload()
    }
    this.#npm = null
    this.#exited = false
    this.#exitErrorMessage = false
  }

  #handleProcessExit (code) {
    const numCode = Number(code) || 0
    // Always exit w/ a non-zero code if exit handler was not called
    const exitCode = this.#exited ? numCode : (numCode || 1)
    this.#process.exitCode = exitCode

    if (this.#notLoadedOrExited) {
      // Exit handler was not called and npm was not loaded so we have to log something
      this.#logConsoleError(new Error(`Process exited unexpectedly with code: ${exitCode}`))
      return
    }

    if (this.#logNoNpmError()) {
      return
    }

    const os = require('node:os')
    log.verbose('cwd', this.#process.cwd())
    log.verbose('os', `${os.type()} ${os.release()}`)
    log.verbose('node', this.#process.version)
    log.verbose('npm ', `v${this.#npm.version}`)

    // only show the notification if it finished
    if (typeof this.#npm.updateNotification === 'string') {
      log.notice('', this.#npm.updateNotification, { [META]: true, force: true })
    }

    if (!this.#exited) {
      log.error('', 'Exit handler never called!')
      log.error('', 'This is an error with npm itself. Please report this error at:')
      log.error('', '  <https://github.com/npm/cli/issues>')
      if (this.#npm.silent) {
        output.error('')
      }
    }

    log.verbose('exit', exitCode)

    if (exitCode) {
      log.verbose('code', exitCode)
    } else {
      log.info('ok')
    }

    if (this.#showExitErrorMessage) {
      log.error('', this.#npm.exitErrorMessage())
    }
  }

  #logConsoleError (err) {
    // Run our error message formatters on all errors even if we
    // have no npm or an unloaded npm. This will clean the error
    // and possible return a formatted message about EACCESS or something.
    const { summary, detail } = errorMessage(err, this.#npm)
    const formatted = [...new Set([...summary, ...detail].flat().filter(Boolean))].join('\n')
    // If we didn't get anything from the formatted message then just display the full stack
    // eslint-disable-next-line no-console
    console.error(formatted === err.message ? err.stack : formatted)
  }

  #logNoNpmError (err) {
    if (this.#hasNpm) {
      return false
    }
    // Make sure we only log this error once
    if (!this.#noNpmError) {
      this.#noNpmError = true
      this.#logConsoleError(
        new Error(`Exit prior to setting npm in exit handler`, err ? { cause: err } : {})
      )
    }
    return true
  }

  #handleExit = (err) => {
    this.#exited = true

    // No npm at all
    if (this.#logNoNpmError(err)) {
      return this.#process.exit(this.#process.exitCode || getExitCodeFromError(err) || 1)
    }

    // npm was never loaded but we still might have a config loading error or
    // something similar that we can run through the error message formatter
    // to give the user a clue as to what happened.s
    if (!this.#loaded) {
      this.#logConsoleError(new Error('Exit prior to config file resolving', { cause: err }))
      return this.#process.exit(this.#process.exitCode || getExitCodeFromError(err) || 1)
    }

    this.#exitErrorMessage = err?.suppressError === true ? false : !!err

    // Prefer the exit code of the error, then the current process exit code,
    // then set it to 1 if we still have an error. Otherwise we call process.exit
    // with undefined so that it can determine the final exit code
    const exitCode = err?.exitCode ?? this.#process.exitCode ?? (err ? 1 : undefined)

    // explicitly call process.exit now so we don't hang on things like the
    // update notifier, also flush stdout/err beforehand because process.exit doesn't
    // wait for that to happen.
    this.#process.stderr.write('', () => this.#process.stdout.write('', () => {
      this.#process.exit(exitCode)
    }))
  }
}

module.exports = ExitHandler
                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/npm/lib/cli/update-notifier.js                                                     0000664 0000000 0000000 00000007703 14746647661 0021263 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // print a banner telling the user to upgrade npm to latest
// but not in CI, and not if we're doing that already.
// Check daily for betas, and weekly otherwise.

const ciInfo = require('ci-info')
const gt = require('semver/functions/gt')
const gte = require('semver/functions/gte')
const parse = require('semver/functions/parse')
const { stat, writeFile } = require('node:fs/promises')
const { resolve } = require('node:path')

// update check frequency
const DAILY = 1000 * 60 * 60 * 24
const WEEKLY = DAILY * 7

// don't put it in the _cacache folder, just in npm's cache
const lastCheckedFile = npm =>
  resolve(npm.flatOptions.cache, '../_update-notifier-last-checked')

// Actual check for updates. This is a separate function so that we only load
// this if we are doing the actual update
const updateCheck = async (npm, spec, version, current) => {
  const pacote = require('pacote')

  const mani = await pacote.manifest(`npm@${spec}`, {
    // always prefer latest, even if doing --tag=whatever on the cmd
    defaultTag: 'latest',
    ...npm.flatOptions,
    cache: false,
  }).catch(() => null)

  // if pacote failed, give up
  if (!mani) {
    return null
  }

  const latest = mani.version

  // if the current version is *greater* than latest, we're on a 'next'
  // and should get the updates from that release train.
  // Note that this isn't another http request over the network, because
  // the packument will be cached by pacote from previous request.
  if (gt(version, latest) && spec === 'latest') {
    return updateNotifier(npm, `^${version}`)
  }

  // if we already have something >= the desired spec, then we're done
  if (gte(version, latest)) {
    return null
  }

  const chalk = npm.logChalk

  // ok!  notify the user about this update they should get.
  // The message is saved for printing at process exit so it will not get
  // lost in any other messages being printed as part of the command.
  const update = parse(mani.version)
  const type = update.major !== current.major ? 'major'
    : update.minor !== current.minor ? 'minor'
    : update.patch !== current.patch ? 'patch'
    : 'prerelease'
  const typec = type === 'major' ? 'red'
    : type === 'minor' ? 'yellow'
    : 'cyan'
  const cmd = `npm install -g npm@${latest}`
  const message = `\nNew ${chalk[typec](type)} version of npm available! ` +
    `${chalk[typec](current)} -> ${chalk.blue(latest)}\n` +
    `Changelog: ${chalk.blue(`https://github.com/npm/cli/releases/tag/v${latest}`)}\n` +
    `To update run: ${chalk.underline(cmd)}\n`

  return message
}

const updateNotifier = async (npm, spec = 'latest') => {
  // if we're on a prerelease train, then updates are coming fast
  // check for a new one daily.  otherwise, weekly.
  const { version } = npm
  const current = parse(version)

  // if we're on a beta train, always get the next beta
  if (current.prerelease.length) {
    spec = `^${version}`
  }

  // while on a beta train, get updates daily
  const duration = spec !== 'latest' ? DAILY : WEEKLY

  const t = new Date(Date.now() - duration)
  // if we don't have a file, then definitely check it.
  const st = await stat(lastCheckedFile(npm)).catch(() => ({ mtime: t - 1 }))

  // if we've already checked within the specified duration, don't check again
  if (!(t > st.mtime)) {
    return null
  }

  // intentional.  do not await this.  it's a best-effort update.  if this
  // fails, it's ok.  might be using /dev/null as the cache or something weird
  // like that.
  writeFile(lastCheckedFile(npm), '').catch(() => {})

  return updateCheck(npm, spec, version, current)
}

// only update the notification timeout if we actually finished checking
module.exports = npm => {
  if (
    // opted out
    !npm.config.get('update-notifier')
    // global npm update
    || (npm.flatOptions.global &&
      ['install', 'update'].includes(npm.command) &&
      npm.argv.some(arg => /^npm(@|$)/.test(arg)))
    // CI
    || ciInfo.isCI
  ) {
    return Promise.resolve(null)
  }

  return updateNotifier(npm)
}
                                                             node-23.7.0/deps/npm/lib/cli/validate-engines.js                                                    0000664 0000000 0000000 00000003734 14746647661 0021403 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // This is separate to indicate that it should contain code we expect to work in
// all versions of node >= 6.  This is a best effort to catch syntax errors to
// give users a good error message if they are using a node version that doesn't
// allow syntax we are using such as private properties, etc. This file is
// linted with ecmaVersion=6 so we don't use invalid syntax, which is set in the
// .eslintrc.local.json file

const { engines: { node: engines }, version } = require('../../package.json')
const npm = `v${version}`

module.exports = (process, getCli) => {
  const node = process.version

  /* eslint-disable-next-line max-len */
  const unsupportedMessage = `npm ${npm} does not support Node.js ${node}. This version of npm supports the following node versions: \`${engines}\`. You can find the latest version at https://nodejs.org/.`

  /* eslint-disable-next-line max-len */
  const brokenMessage = `ERROR: npm ${npm} is known not to run on Node.js ${node}.  This version of npm supports the following node versions: \`${engines}\`. You can find the latest version at https://nodejs.org/.`

  // coverage ignored because this is only hit in very unsupported node versions
  // and it's a best effort attempt to show something nice in those cases
  /* istanbul ignore next */
  const syntaxErrorHandler = (err) => {
    if (err instanceof SyntaxError) {
      // eslint-disable-next-line no-console
      console.error(`${brokenMessage}\n\nERROR:`)
      // eslint-disable-next-line no-console
      console.error(err)
      return process.exit(1)
    }
    throw err
  }

  process.on('uncaughtException', syntaxErrorHandler)
  process.on('unhandledRejection', syntaxErrorHandler)

  // require this only after setting up the error handlers
  const cli = getCli()
  return cli(process, {
    node,
    npm,
    engines,
    unsupportedMessage,
    off: () => {
      process.off('uncaughtException', syntaxErrorHandler)
      process.off('unhandledRejection', syntaxErrorHandler)
    },
  })
}
                                    node-23.7.0/deps/npm/lib/commands/                                                                  0000775 0000000 0000000 00000000000 14746647661 0016651 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/npm/lib/commands/access.js                                                         0000664 0000000 0000000 00000014055 14746647661 0020455 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const libnpmaccess = require('libnpmaccess')
const npa = require('npm-package-arg')
const { output } = require('proc-log')
const pkgJson = require('@npmcli/package-json')
const localeCompare = require('@isaacs/string-locale-compare')('en')
const { otplease } = require('../utils/auth.js')
const getIdentity = require('../utils/get-identity.js')
const BaseCommand = require('../base-cmd.js')

const commands = [
  'get',
  'grant',
  'list',
  'revoke',
  'set',
]

const setCommands = [
  'status=public',
  'status=private',
  'mfa=none',
  'mfa=publish',
  'mfa=automation',
  '2fa=none',
  '2fa=publish',
  '2fa=automation',
]

class Access extends BaseCommand {
  static description = 'Set access level on published packages'
  static name = 'access'
  static params = [
    'json',
    'otp',
    'registry',
  ]

  static usage = [
    'list packages [<user>|<scope>|<scope:team>] [<package>]',
    'list collaborators [<package> [<user>]]',
    'get status [<package>]',
    'set status=public|private [<package>]',
    'set mfa=none|publish|automation [<package>]',
    'grant <read-only|read-write> <scope:team> [<package>]',
    'revoke <scope:team> [<package>]',
  ]

  static async completion (opts) {
    const argv = opts.conf.argv.remain
    if (argv.length === 2) {
      return commands
    }

    if (argv.length === 3) {
      switch (argv[2]) {
        case 'grant':
          return ['read-only', 'read-write']
        case 'revoke':
          return []
        case 'list':
        case 'ls':
          return ['packages', 'collaborators']
        case 'get':
          return ['status']
        case 'set':
          return setCommands
        default:
          throw new Error(argv[2] + ' not recognized')
      }
    }
  }

  async exec ([cmd, subcmd, ...args]) {
    if (!cmd) {
      throw this.usageError()
    }
    if (!commands.includes(cmd)) {
      throw this.usageError(`${cmd} is not a valid access command`)
    }
    // All commands take at least one more parameter so we can do this check up front
    if (!subcmd) {
      throw this.usageError()
    }

    switch (cmd) {
      case 'grant':
        if (!['read-only', 'read-write'].includes(subcmd)) {
          throw this.usageError('grant must be either `read-only` or `read-write`')
        }
        if (!args[0]) {
          throw this.usageError('`<scope:team>` argument is required')
        }
        return this.#grant(subcmd, args[0], args[1])
      case 'revoke':
        return this.#revoke(subcmd, args[0])
      case 'list':
      case 'ls':
        if (subcmd === 'packages') {
          return this.#listPackages(args[0], args[1])
        }
        if (subcmd === 'collaborators') {
          return this.#listCollaborators(args[0], args[1])
        }
        throw this.usageError(`list ${subcmd} is not a valid access command`)
      case 'get':
        if (subcmd !== 'status') {
          throw this.usageError(`get ${subcmd} is not a valid access command`)
        }
        return this.#getStatus(args[0])
      case 'set':
        if (!setCommands.includes(subcmd)) {
          throw this.usageError(`set ${subcmd} is not a valid access command`)
        }
        return this.#set(subcmd, args[0])
    }
  }

  async #grant (permissions, scope, pkg) {
    await libnpmaccess.setPermissions(scope, pkg, permissions, this.npm.flatOptions)
  }

  async #revoke (scope, pkg) {
    await libnpmaccess.removePermissions(scope, pkg, this.npm.flatOptions)
  }

  async #listPackages (owner, pkg) {
    if (!owner) {
      owner = await getIdentity(this.npm, this.npm.flatOptions)
    }
    const pkgs = await libnpmaccess.getPackages(owner, this.npm.flatOptions)
    this.#output(pkgs, pkg)
  }

  async #listCollaborators (pkg, user) {
    const pkgName = await this.#getPackage(pkg, false)
    const collabs = await libnpmaccess.getCollaborators(pkgName, this.npm.flatOptions)
    this.#output(collabs, user)
  }

  async #getStatus (pkg) {
    const pkgName = await this.#getPackage(pkg, false)
    const visibility = await libnpmaccess.getVisibility(pkgName, this.npm.flatOptions)
    this.#output({ [pkgName]: visibility.public ? 'public' : 'private' })
  }

  async #set (subcmd, pkg) {
    const [subkey, subval] = subcmd.split('=')
    switch (subkey) {
      case 'mfa':
      case '2fa':
        return this.#setMfa(pkg, subval)
      case 'status':
        return this.#setStatus(pkg, subval)
    }
  }

  async #setMfa (pkg, level) {
    const pkgName = await this.#getPackage(pkg, false)
    await otplease(this.npm, this.npm.flatOptions, (opts) => {
      return libnpmaccess.setMfa(pkgName, level, opts)
    })
  }

  async #setStatus (pkg, status) {
    // only scoped packages can have their access changed
    const pkgName = await this.#getPackage(pkg, true)
    if (status === 'private') {
      status = 'restricted'
    }
    await otplease(this.npm, this.npm.flatOptions, (opts) => {
      return libnpmaccess.setAccess(pkgName, status, opts)
    })
    return this.#getStatus(pkgName)
  }

  async #getPackage (name, requireScope) {
    if (!name) {
      try {
        const { content } = await pkgJson.normalize(this.npm.prefix)
        name = content.name
      } catch (err) {
        if (err.code === 'ENOENT') {
          throw Object.assign(new Error('no package name given and no package.json found'), {
            code: 'ENOENT',
          })
        } else {
          throw err
        }
      }
    }

    const spec = npa(name)
    if (requireScope && !spec.scope) {
      throw this.usageError('This command is only available for scoped packages.')
    }
    return name
  }

  #output (items, limiter) {
    const outputs = {}
    const lookup = {
      __proto__: null,
      read: 'read-only',
      write: 'read-write',
    }
    for (const item in items) {
      const val = items[item]
      outputs[item] = lookup[val] || val
    }
    if (this.npm.config.get('json')) {
      output.buffer(outputs)
    } else {
      for (const item of Object.keys(outputs).sort(localeCompare)) {
        if (!limiter || limiter === item) {
          output.standard(`${item}: ${outputs[item]}`)
        }
      }
    }
  }
}

module.exports = Access
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/npm/lib/commands/adduser.js                                                        0000664 0000000 0000000 00000002451 14746647661 0020640 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { log, output } = require('proc-log')
const { redactLog: replaceInfo } = require('@npmcli/redact')
const auth = require('../utils/auth.js')
const BaseCommand = require('../base-cmd.js')

class AddUser extends BaseCommand {
  static description = 'Add a registry user account'
  static name = 'adduser'
  static params = [
    'registry',
    'scope',
    'auth-type',
  ]

  async exec () {
    const scope = this.npm.config.get('scope')
    let registry = this.npm.config.get('registry')

    if (scope) {
      const scopedRegistry = this.npm.config.get(`${scope}:registry`)
      const cliRegistry = this.npm.config.get('registry', 'cli')
      if (scopedRegistry && !cliRegistry) {
        registry = scopedRegistry
      }
    }

    const creds = this.npm.config.getCredentialsByURI(registry)

    log.notice('', `Log in on ${replaceInfo(registry)}`)

    const { message, newCreds } = await auth.adduser(this.npm, {
      ...this.npm.flatOptions,
      creds,
      registry,
    })

    this.npm.config.delete('_token', 'user') // prevent legacy pollution
    this.npm.config.setCredentialsByURI(registry, newCreds)

    if (scope) {
      this.npm.config.set(scope + ':registry', registry, 'user')
    }

    await this.npm.config.save('user')

    output.standard(message)
  }
}

module.exports = AddUser
                                                                                                                                                                                                                       node-23.7.0/deps/npm/lib/commands/audit.js                                                          0000664 0000000 0000000 00000006225 14746647661 0020322 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const npmAuditReport = require('npm-audit-report')
const ArboristWorkspaceCmd = require('../arborist-cmd.js')
const auditError = require('../utils/audit-error.js')
const { log, output } = require('proc-log')
const reifyFinish = require('../utils/reify-finish.js')
const VerifySignatures = require('../utils/verify-signatures.js')

class Audit extends ArboristWorkspaceCmd {
  static description = 'Run a security audit'
  static name = 'audit'
  static params = [
    'audit-level',
    'dry-run',
    'force',
    'json',
    'package-lock-only',
    'package-lock',
    'omit',
    'include',
    'foreground-scripts',
    'ignore-scripts',
    ...super.params,
  ]

  static usage = ['[fix|signatures]']

  static async completion (opts) {
    const argv = opts.conf.argv.remain

    if (argv.length === 2) {
      return ['fix', 'signatures']
    }

    switch (argv[2]) {
      case 'fix':
      case 'signatures':
        return []
      default:
        throw Object.assign(new Error(argv[2] + ' not recognized'), {
          code: 'EUSAGE',
        })
    }
  }

  async exec (args) {
    if (args[0] === 'signatures') {
      await this.auditSignatures()
    } else {
      await this.auditAdvisories(args)
    }
  }

  async auditAdvisories (args) {
    const fix = args[0] === 'fix'
    if (this.npm.config.get('package-lock') === false && fix) {
      throw this.usageError('fix can not be used without a package-lock')
    }
    const reporter = this.npm.config.get('json') ? 'json' : 'detail'
    const Arborist = require('@npmcli/arborist')
    const opts = {
      ...this.npm.flatOptions,
      audit: true,
      path: this.npm.prefix,
      reporter,
      workspaces: this.workspaceNames,
    }

    const arb = new Arborist(opts)
    await arb.audit({ fix })
    if (fix) {
      await reifyFinish(this.npm, arb)
    } else {
      // will throw if there's an error, because this is an audit command
      auditError(this.npm, arb.auditReport)
      const result = npmAuditReport(arb.auditReport, {
        ...opts,
        chalk: this.npm.chalk,
      })
      process.exitCode = process.exitCode || result.exitCode
      output.standard(result.report)
    }
  }

  async auditSignatures () {
    if (this.npm.global) {
      throw Object.assign(
        new Error('`npm audit signatures` does not support global packages'), {
          code: 'EAUDITGLOBAL',
        }
      )
    }

    log.verbose('audit', 'loading installed dependencies')
    const Arborist = require('@npmcli/arborist')
    const opts = {
      ...this.npm.flatOptions,
      path: this.npm.prefix,
      workspaces: this.workspaceNames,
    }

    const arb = new Arborist(opts)
    const tree = await arb.loadActual()
    let filterSet = new Set()
    if (opts.workspaces && opts.workspaces.length) {
      filterSet =
        arb.workspaceDependencySet(
          tree,
          opts.workspaces,
          this.npm.flatOptions.includeWorkspaceRoot
        )
    } else if (!this.npm.flatOptions.workspacesEnabled) {
      filterSet =
        arb.excludeWorkspacesDependencySet(tree)
    }

    const verify = new VerifySignatures(tree, filterSet, this.npm, { ...opts })
    await verify.run()
  }
}

module.exports = Audit
                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/npm/lib/commands/bugs.js                                                           0000664 0000000 0000000 00000001517 14746647661 0020153 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const PackageUrlCmd = require('../package-url-cmd.js')

class Bugs extends PackageUrlCmd {
  static description = 'Report bugs for a package in a web browser'
  static name = 'bugs'

  getUrl (spec, mani) {
    if (mani.bugs) {
      if (typeof mani.bugs === 'string') {
        return mani.bugs
      }

      if (typeof mani.bugs === 'object' && mani.bugs.url) {
        return mani.bugs.url
      }

      if (typeof mani.bugs === 'object' && mani.bugs.email) {
        return `mailto:${mani.bugs.email}`
      }
    }

    // try to get it from the repo, if possible
    const info = this.hostedFromMani(mani)
    const infoUrl = info?.bugs()
    if (infoUrl) {
      return infoUrl
    }

    // just send them to the website, hopefully that has some info!
    return `https://www.npmjs.com/package/${mani.name}`
  }
}

module.exports = Bugs
                                                                                                                                                                                 node-23.7.0/deps/npm/lib/commands/cache.js                                                          0000664 0000000 0000000 00000016174 14746647661 0020263 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const cacache = require('cacache')
const pacote = require('pacote')
const fs = require('node:fs/promises')
const { join } = require('node:path')
const semver = require('semver')
const BaseCommand = require('../base-cmd.js')
const npa = require('npm-package-arg')
const jsonParse = require('json-parse-even-better-errors')
const localeCompare = require('@isaacs/string-locale-compare')('en')
const { log, output } = require('proc-log')

const searchCachePackage = async (path, parsed, cacheKeys) => {
  /* eslint-disable-next-line max-len */
  const searchMFH = new RegExp(`^make-fetch-happen:request-cache:.*(?<!/[@a-zA-Z]+)/${parsed.name}/-/(${parsed.name}[^/]+.tgz)$`)
  const searchPack = new RegExp(`^make-fetch-happen:request-cache:.*/${parsed.escapedName}$`)
  const results = new Set()
  cacheKeys = new Set(cacheKeys)
  for (const key of cacheKeys) {
    // match on the public key registry url format
    if (searchMFH.test(key)) {
      // extract the version from the filename
      const filename = key.match(searchMFH)[1]
      const noExt = filename.slice(0, -4)
      const noScope = `${parsed.name.split('/').pop()}-`
      const ver = noExt.slice(noScope.length)
      if (semver.satisfies(ver, parsed.rawSpec)) {
        results.add(key)
      }
      continue
    }
    // is this key a packument?
    if (!searchPack.test(key)) {
      continue
    }

    results.add(key)
    let packument, details
    try {
      details = await cacache.get(path, key)
      packument = jsonParse(details.data)
    } catch (_) {
      // if we couldn't parse the packument, abort
      continue
    }
    if (!packument.versions || typeof packument.versions !== 'object') {
      continue
    }

    // assuming this is a packument
    for (const ver of Object.keys(packument.versions)) {
      if (semver.satisfies(ver, parsed.rawSpec)) {
        if (packument.versions[ver].dist &&
          typeof packument.versions[ver].dist === 'object' &&
          packument.versions[ver].dist.tarball !== undefined &&
          cacheKeys.has(`make-fetch-happen:request-cache:${packument.versions[ver].dist.tarball}`)
        ) {
          results.add(`make-fetch-happen:request-cache:${packument.versions[ver].dist.tarball}`)
        }
      }
    }
  }
  return results
}

class Cache extends BaseCommand {
  static description = 'Manipulates packages cache'
  static name = 'cache'
  static params = ['cache']
  static usage = [
    'add <package-spec>',
    'clean [<key>]',
    'ls [<name>@<version>]',
    'verify',
  ]

  static async completion (opts) {
    const argv = opts.conf.argv.remain
    if (argv.length === 2) {
      return ['add', 'clean', 'verify', 'ls']
    }

    // TODO - eventually...
    switch (argv[2]) {
      case 'verify':
      case 'clean':
      case 'add':
      case 'ls':
        return []
    }
  }

  async exec (args) {
    const cmd = args.shift()
    switch (cmd) {
      case 'rm': case 'clear': case 'clean':
        return await this.clean(args)
      case 'add':
        return await this.add(args)
      case 'verify': case 'check':
        return await this.verify()
      case 'ls':
        return await this.ls(args)
      default:
        throw this.usageError()
    }
  }

  // npm cache clean [pkg]*
  async clean (args) {
    const cachePath = join(this.npm.cache, '_cacache')
    if (args.length === 0) {
      if (!this.npm.config.get('force')) {
        throw new Error(`As of npm@5, the npm cache self-heals from corruption issues
  by treating integrity mismatches as cache misses.  As a result,
  data extracted from the cache is guaranteed to be valid.  If you
  want to make sure everything is consistent, use \`npm cache verify\`
  instead.  Deleting the cache can only make npm go slower, and is
  not likely to correct any problems you may be encountering!

  On the other hand, if you're debugging an issue with the installer,
  or race conditions that depend on the timing of writing to an empty
  cache, you can use \`npm install --cache /tmp/empty-cache\` to use a
  temporary cache instead of nuking the actual one.

  If you're sure you want to delete the entire cache, rerun this command
  with --force.`)
      }
      return fs.rm(cachePath, { recursive: true, force: true })
    }
    for (const key of args) {
      let entry
      try {
        entry = await cacache.get(cachePath, key)
      } catch (err) {
        log.warn('cache', `Not Found: ${key}`)
        break
      }
      output.standard(`Deleted: ${key}`)
      await cacache.rm.entry(cachePath, key)
      // XXX this could leave other entries without content!
      await cacache.rm.content(cachePath, entry.integrity)
    }
  }

  // npm cache add <tarball-url>...
  // npm cache add <pkg> <ver>...
  // npm cache add <tarball>...
  // npm cache add <folder>...
  async add (args) {
    log.silly('cache add', 'args', args)
    if (args.length === 0) {
      throw this.usageError('First argument to `add` is required')
    }

    await Promise.all(args.map(async spec => {
      log.silly('cache add', 'spec', spec)
      // we ask pacote for the thing, and then just throw the data
      // away so that it tee-pipes it into the cache like it does
      // for a normal request.
      await pacote.tarball.stream(spec, stream => {
        stream.resume()
        return stream.promise()
      }, { ...this.npm.flatOptions })

      await pacote.manifest(spec, {
        ...this.npm.flatOptions,
        fullMetadata: true,
      })
    }))
  }

  async verify () {
    const cache = join(this.npm.cache, '_cacache')
    const prefix = cache.indexOf(process.env.HOME) === 0
      ? `~${cache.slice(process.env.HOME.length)}`
      : cache
    const stats = await cacache.verify(cache)
    output.standard(`Cache verified and compressed (${prefix})`)
    output.standard(`Content verified: ${stats.verifiedContent} (${stats.keptSize} bytes)`)
    if (stats.badContentCount) {
      output.standard(`Corrupted content removed: ${stats.badContentCount}`)
    }
    if (stats.reclaimedCount) {
      /* eslint-disable-next-line max-len */
      output.standard(`Content garbage-collected: ${stats.reclaimedCount} (${stats.reclaimedSize} bytes)`)
    }
    if (stats.missingContent) {
      output.standard(`Missing content: ${stats.missingContent}`)
    }
    output.standard(`Index entries: ${stats.totalEntries}`)
    output.standard(`Finished in ${stats.runTime.total / 1000}s`)
  }

  // npm cache ls [--package <spec> ...]
  async ls (specs) {
    const cachePath = join(this.npm.cache, '_cacache')
    const cacheKeys = Object.keys(await cacache.ls(cachePath))
    if (specs.length > 0) {
      // get results for each package spec specified
      const results = new Set()
      for (const spec of specs) {
        const parsed = npa(spec)
        if (parsed.rawSpec !== '' && parsed.type === 'tag') {
          throw this.usageError('Cannot list cache keys for a tagged package.')
        }
        const keySet = await searchCachePackage(cachePath, parsed, cacheKeys)
        for (const key of keySet) {
          results.add(key)
        }
      }
      [...results].sort(localeCompare).forEach(key => output.standard(key))
      return
    }
    cacheKeys.sort(localeCompare).forEach(key => output.standard(key))
  }
}

module.exports = Cache
                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/npm/lib/commands/ci.js                                                             0000664 0000000 0000000 00000010345 14746647661 0017605 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const reifyFinish = require('../utils/reify-finish.js')
const runScript = require('@npmcli/run-script')
const fs = require('node:fs/promises')
const path = require('node:path')
const { log, time } = require('proc-log')
const validateLockfile = require('../utils/validate-lockfile.js')
const ArboristWorkspaceCmd = require('../arborist-cmd.js')
const getWorkspaces = require('../utils/get-workspaces.js')

class CI extends ArboristWorkspaceCmd {
  static description = 'Clean install a project'
  static name = 'ci'

  // These are in the order they will show up in when running "-h"
  static params = [
    'install-strategy',
    'legacy-bundling',
    'global-style',
    'omit',
    'include',
    'strict-peer-deps',
    'foreground-scripts',
    'ignore-scripts',
    'audit',
    'bin-links',
    'fund',
    'dry-run',
    ...super.params,
  ]

  async exec () {
    if (this.npm.global) {
      throw Object.assign(new Error('`npm ci` does not work for global packages'), {
        code: 'ECIGLOBAL',
      })
    }

    const where = this.npm.prefix
    const Arborist = require('@npmcli/arborist')
    const opts = {
      ...this.npm.flatOptions,
      packageLock: true, // npm ci should never skip lock files
      path: where,
      save: false, // npm ci should never modify the lockfile or package.json
      workspaces: this.workspaceNames,
    }

    const arb = new Arborist(opts)
    await arb.loadVirtual().catch(er => {
      log.verbose('loadVirtual', er.stack)
      const msg =
        'The `npm ci` command can only install with an existing package-lock.json or\n' +
        'npm-shrinkwrap.json with lockfileVersion >= 1. Run an install with npm@5 or\n' +
        'later to generate a package-lock.json file, then try again.'
      throw this.usageError(msg)
    })

    // retrieves inventory of packages from loaded virtual tree (lock file)
    const virtualInventory = new Map(arb.virtualTree.inventory)

    // build ideal tree step needs to come right after retrieving the virtual
    // inventory since it's going to erase the previous ref to virtualTree
    await arb.buildIdealTree()

    // verifies that the packages from the ideal tree will match
    // the same versions that are present in the virtual tree (lock file)
    // throws a validation error in case of mismatches
    const errors = validateLockfile(virtualInventory, arb.idealTree.inventory)
    if (errors.length) {
      throw this.usageError(
        '`npm ci` can only install packages when your package.json and ' +
        'package-lock.json or npm-shrinkwrap.json are in sync. Please ' +
        'update your lock file with `npm install` ' +
        'before continuing.\n\n' +
        errors.join('\n')
      )
    }

    const dryRun = this.npm.config.get('dry-run')
    if (!dryRun) {
      const workspacePaths = await getWorkspaces([], {
        path: this.npm.localPrefix,
        includeWorkspaceRoot: true,
      })

      // Only remove node_modules after we've successfully loaded the virtual
      // tree and validated the lockfile
      await time.start('npm-ci:rm', async () => {
        return await Promise.all([...workspacePaths.values()].map(async modulePath => {
          const fullPath = path.join(modulePath, 'node_modules')
          // get the list of entries so we can skip the glob for performance
          const entries = await fs.readdir(fullPath, null).catch(() => [])
          return Promise.all(entries.map(folder => {
            return fs.rm(path.join(fullPath, folder), { force: true, recursive: true })
          }))
        }))
      })
    }

    await arb.reify(opts)

    const ignoreScripts = this.npm.config.get('ignore-scripts')
    // run the same set of scripts that `npm install` runs.
    if (!ignoreScripts) {
      const scripts = [
        'preinstall',
        'install',
        'postinstall',
        'prepublish', // XXX should we remove this finally??
        'preprepare',
        'prepare',
        'postprepare',
      ]
      const scriptShell = this.npm.config.get('script-shell') || undefined
      for (const event of scripts) {
        await runScript({
          path: where,
          args: [],
          scriptShell,
          stdio: 'inherit',
          event,
        })
      }
    }
    await reifyFinish(this.npm, arb)
  }
}

module.exports = CI
                                                                                                                                                                                                                                                                                           node-23.7.0/deps/npm/lib/commands/completion.js                                                     0000664 0000000 0000000 00000021634 14746647661 0021366 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Each command has a completion function that takes an options object and a cb
// The callback gets called with an error and an array of possible completions.
// The options object is built up based on the environment variables set by
// zsh or bash when calling a function for completion, based on the cursor
// position and the command line thus far.  These are:
// COMP_CWORD: the index of the "word" in the command line being completed
// COMP_LINE: the full command line thusfar as a string
// COMP_POINT: the cursor index at the point of triggering completion
//
// We parse the command line with nopt, like npm does, and then create an
// options object containing:
// words: array of words in the command line
// w: the index of the word being completed (ie, COMP_CWORD)
// word: the word being completed
// line: the COMP_LINE
// lineLength
// point: the COMP_POINT, usually equal to line length, but not always, eg if
// the user has pressed the left-arrow to complete an earlier word
// partialLine: the line up to the point
// partialWord: the word being completed (which might be ''), up to the point
// conf: a nopt parse of the command line
//
// When the implementation completion method returns its list of strings,
// and arrays of strings, we filter that by any that start with the
// partialWord, since only those can possibly be valid matches.
//
// Matches are wrapped with ' to escape them, if necessary, and then printed
// one per line for the shell completion method to consume in IFS=$'\n' mode
// as an array.

const fs = require('node:fs/promises')
const nopt = require('nopt')
const { resolve } = require('node:path')
const { output } = require('proc-log')
const Npm = require('../npm.js')
const { definitions, shorthands } = require('@npmcli/config/lib/definitions')
const { commands, aliases, deref } = require('../utils/cmd-list.js')
const { isWindowsShell } = require('../utils/is-windows.js')
const BaseCommand = require('../base-cmd.js')

const fileExists = (file) => fs.stat(file).then(s => s.isFile()).catch(() => false)

const configNames = Object.keys(definitions)
const shorthandNames = Object.keys(shorthands)
const allConfs = configNames.concat(shorthandNames)

class Completion extends BaseCommand {
  static description = 'Tab Completion for npm'
  static name = 'completion'

  // completion for the completion command
  static async completion (opts) {
    if (opts.w > 2) {
      return
    }

    const [bashExists, zshExists] = await Promise.all([
      fileExists(resolve(process.env.HOME, '.bashrc')),
      fileExists(resolve(process.env.HOME, '.zshrc')),
    ])
    const out = []
    if (zshExists) {
      out.push(['>>', '~/.zshrc'])
    }

    if (bashExists) {
      out.push(['>>', '~/.bashrc'])
    }

    return out
  }

  async exec (args) {
    if (isWindowsShell) {
      const msg = 'npm completion supported only in MINGW / Git bash on Windows'
      throw Object.assign(new Error(msg), {
        code: 'ENOTSUP',
      })
    }

    const { COMP_CWORD, COMP_LINE, COMP_POINT, COMP_FISH } = process.env

    // if the COMP_* isn't in the env, then just dump the script.
    if (COMP_CWORD === undefined || COMP_LINE === undefined || COMP_POINT === undefined) {
      return dumpScript(resolve(this.npm.npmRoot, 'lib', 'utils', 'completion.sh'))
    }

    // ok we're actually looking at the envs and outputting the suggestions
    // get the partial line and partial word,
    // if the point isn't at the end.
    // ie, tabbing at: npm foo b|ar
    const w = +COMP_CWORD
    const words = args.map(unescape)
    const word = words[w]
    const line = COMP_LINE
    const point = +COMP_POINT
    const partialLine = line.slice(0, point)
    const partialWords = words.slice(0, w)

    // figure out where in that last word the point is.
    const partialWordRaw = args[w]
    let i = partialWordRaw.length
    while (partialWordRaw.slice(0, i) !== partialLine.slice(-1 * i) && i > 0) {
      i--
    }

    const partialWord = unescape(partialWordRaw.slice(0, i))
    partialWords.push(partialWord)

    const opts = {
      isFish: COMP_FISH === 'true',
      words,
      w,
      word,
      line,
      lineLength: line.length,
      point,
      partialLine,
      partialWords,
      partialWord,
      raw: args,
    }

    if (partialWords.slice(0, -1).indexOf('--') === -1) {
      if (word.charAt(0) === '-') {
        return this.wrap(opts, configCompl(opts))
      }

      if (words[w - 1] &&
        words[w - 1].charAt(0) === '-' &&
        !isFlag(words[w - 1])) {
        // awaiting a value for a non-bool config.
        // don't even try to do this for now
        return this.wrap(opts, configValueCompl(opts))
      }
    }

    // try to find the npm command.
    // it's the first thing after all the configs.
    // take a little shortcut and use npm's arg parsing logic.
    // don't have to worry about the last arg being implicitly
    // boolean'ed, since the last block will catch that.
    const types = Object.entries(definitions).reduce((acc, [key, def]) => {
      acc[key] = def.type
      return acc
    }, {})
    const parsed = opts.conf =
      nopt(types, shorthands, partialWords.slice(0, -1), 0)
    // check if there's a command already.
    const cmd = parsed.argv.remain[1]
    if (!cmd) {
      return this.wrap(opts, cmdCompl(opts, this.npm))
    }

    Object.keys(parsed).forEach(k => this.npm.config.set(k, parsed[k]))

    // at this point, if words[1] is some kind of npm command,
    // then complete on it.
    // otherwise, do nothing
    try {
      const { completion } = Npm.cmd(cmd)
      if (completion) {
        const comps = await completion(opts, this.npm)
        return this.wrap(opts, comps)
      }
    } catch {
      // it wasnt a valid command, so do nothing
    }
  }

  // The command should respond with an array.  Loop over that,
  // wrapping quotes around any that have spaces, and writing
  // them to stdout.
  // If any of the items are arrays, then join them with a space.
  // Ie, returning ['a', 'b c', ['d', 'e']] would allow it to expand
  // to: 'a', 'b c', or 'd' 'e'
  wrap (opts, compls) {
    // TODO this was dead code, leaving it in case we find some command we
    // forgot that requires this. if so *that command should fix its
    // completions*
    // compls = compls.map(w => !/\s+/.test(w) ? w : '\'' + w + '\'')

    if (opts.partialWord) {
      compls = compls.filter(c => c.startsWith(opts.partialWord))
    }

    if (compls.length > 0) {
      output.standard(compls.join('\n'))
    }
  }
}

const dumpScript = async (p) => {
  const d = (await fs.readFile(p, 'utf8')).replace(/^#!.*?\n/, '')
  await new Promise((res, rej) => {
    let done = false
    process.stdout.on('error', er => {
      if (done) {
        return
      }

      done = true

      // Darwin is a pain sometimes.
      //
      // This is necessary because the "source" or "." program in
      // bash on OS X closes its file argument before reading
      // from it, meaning that you get exactly 1 write, which will
      // work most of the time, and will always raise an EPIPE.
      //
      // Really, one should not be tossing away EPIPE errors, or any
      // errors, so casually.  But, without this, `. <(npm completion)`
      // can never ever work on OS X.
      // TODO Ignoring coverage, see 'non EPIPE errors cause failures' test.
      /* istanbul ignore next */
      if (er.errno === 'EPIPE') {
        res()
      } else {
        rej(er)
      }
    })

    process.stdout.write(d, () => {
      if (done) {
        return
      }

      done = true
      res()
    })
  })
}

const unescape = w => w.charAt(0) === '\'' ? w.replace(/^'|'$/g, '')
  : w.replace(/\\ /g, ' ')

// the current word has a dash.  Return the config names,
// with the same number of dashes as the current word has.
const configCompl = opts => {
  const word = opts.word
  const split = word.match(/^(-+)((?:no-)*)(.*)$/)
  const dashes = split[1]
  const no = split[2]
  const flags = configNames.filter(isFlag)
  return allConfs.map(c => dashes + c)
    .concat(flags.map(f => dashes + (no || 'no-') + f))
}

// expand with the valid values of various config values.
// not yet implemented.
const configValueCompl = () => []

// check if the thing is a flag or not.
const isFlag = word => {
  // shorthands never take args.
  const split = word.match(/^(-*)((?:no-)+)?(.*)$/)
  const no = split[2]
  const conf = split[3]
  const { type } = definitions[conf]
  return no ||
    type === Boolean ||
    (Array.isArray(type) && type.includes(Boolean)) ||
    shorthands[conf]
}

// complete against the npm commands
// if they all resolve to the same thing, just return the thing it already is
const cmdCompl = (opts) => {
  const allCommands = commands.concat(Object.keys(aliases))
  const matches = allCommands.filter(c => c.startsWith(opts.partialWord))
  if (!matches.length) {
    return matches
  }

  const derefs = new Set([...matches.map(c => deref(c))])
  if (derefs.size === 1) {
    return [...derefs]
  }

  return allCommands
}

module.exports = Completion
                                                                                                    node-23.7.0/deps/npm/lib/commands/config.js                                                         0000664 0000000 0000000 00000026264 14746647661 0020466 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { mkdir, readFile, writeFile } = require('node:fs/promises')
const { dirname, resolve } = require('node:path')
const { spawn } = require('node:child_process')
const { EOL } = require('node:os')
const localeCompare = require('@isaacs/string-locale-compare')('en')
const pkgJson = require('@npmcli/package-json')
const { defaults, definitions } = require('@npmcli/config/lib/definitions')
const { log, output } = require('proc-log')
const BaseCommand = require('../base-cmd.js')
const { redact } = require('@npmcli/redact')

// These are the configs that we can nerf-dart. Not all of them currently even
// *have* config definitions so we have to explicitly validate them here.
// This is used to validate during "npm config set"
const nerfDarts = [
  '_auth',
  '_authToken',
  '_password',
  'certfile',
  'email',
  'keyfile',
  'username',
]
// These are the config values to swap with "protected".  It does not catch
// every single sensitive thing a user may put in the npmrc file but it gets
// the common ones.  This is distinct from nerfDarts because that is used to
// validate valid configs during "npm config set", and folks may have old
// invalid entries lying around in a config file that we still want to protect
// when running "npm config list"
// This is a more general list of values to consider protected.  You can not
// "npm config get" them, and they will not display during "npm config list"
const protected = [
  'auth',
  'authToken',
  'certfile',
  'email',
  'keyfile',
  'password',
  'username',
]

// take an array of `[key, value, k2=v2, k3, v3, ...]` and turn into
// { key: value, k2: v2, k3: v3 }
const keyValues = args => {
  const kv = {}
  for (let i = 0; i < args.length; i++) {
    const arg = args[i].split('=')
    const key = arg.shift()
    const val = arg.length ? arg.join('=')
      : i < args.length - 1 ? args[++i]
      : ''
    kv[key.trim()] = val.trim()
  }
  return kv
}

const isProtected = (k) => {
  // _password
  if (k.startsWith('_')) {
    return true
  }
  if (protected.includes(k)) {
    return true
  }
  // //localhost:8080/:_password
  if (k.startsWith('//')) {
    if (k.includes(':_')) {
      return true
    }
    // //registry:_authToken or //registry:authToken
    for (const p of protected) {
      if (k.endsWith(`:${p}`) || k.endsWith(`:_${p}`)) {
        return true
      }
    }
  }
  return false
}

// Private fields are either protected or they can redacted info
const isPrivate = (k, v) => isProtected(k) || redact(v) !== v

const displayVar = (k, v) =>
  `${k} = ${isProtected(k, v) ? '(protected)' : JSON.stringify(redact(v))}`

class Config extends BaseCommand {
  static description = 'Manage the npm configuration files'
  static name = 'config'
  static usage = [
    'set <key>=<value> [<key>=<value> ...]',
    'get [<key> [<key> ...]]',
    'delete <key> [<key> ...]',
    'list [--json]',
    'edit',
    'fix',
  ]

  static params = [
    'json',
    'global',
    'editor',
    'location',
    'long',
  ]

  static ignoreImplicitWorkspace = false

  static skipConfigValidation = true

  static async completion (opts) {
    const argv = opts.conf.argv.remain
    if (argv[1] !== 'config') {
      argv.unshift('config')
    }

    if (argv.length === 2) {
      const cmds = ['get', 'set', 'delete', 'ls', 'rm', 'edit', 'fix']
      if (opts.partialWord !== 'l') {
        cmds.push('list')
      }

      return cmds
    }

    const action = argv[2]
    switch (action) {
      case 'set':
        // todo: complete with valid values, if possible.
        if (argv.length > 3) {
          return []
        }

        // fallthrough
        /* eslint no-fallthrough:0 */
      case 'get':
      case 'delete':
      case 'rm':
        return Object.keys(definitions)
      case 'edit':
      case 'list':
      case 'ls':
      case 'fix':
      default:
        return []
    }
  }

  async exec ([action, ...args]) {
    switch (action) {
      case 'set':
        await this.set(args)
        break
      case 'get':
        await this.get(args)
        break
      case 'delete':
      case 'rm':
      case 'del':
        await this.del(args)
        break
      case 'list':
      case 'ls':
        await (this.npm.flatOptions.json ? this.listJson() : this.list())
        break
      case 'edit':
        await this.edit()
        break
      case 'fix':
        await this.fix()
        break
      default:
        throw this.usageError()
    }
  }

  async set (args) {
    if (!args.length) {
      throw this.usageError()
    }

    const where = this.npm.flatOptions.location
    for (const [key, val] of Object.entries(keyValues(args))) {
      log.info('config', 'set %j %j', key, val)
      const baseKey = key.split(':').pop()
      if (!this.npm.config.definitions[baseKey] && !nerfDarts.includes(baseKey)) {
        throw new Error(`\`${baseKey}\` is not a valid npm option`)
      }
      const deprecated = this.npm.config.definitions[baseKey]?.deprecated
      if (deprecated) {
        throw new Error(
          `The \`${baseKey}\` option is deprecated, and can not be set in this way${deprecated}`
        )
      }

      if (val === '') {
        this.npm.config.delete(key, where)
      } else {
        this.npm.config.set(key, val, where)
      }

      if (!this.npm.config.validate(where)) {
        log.warn('config', 'omitting invalid config values')
      }
    }

    await this.npm.config.save(where)
  }

  async get (keys) {
    if (!keys.length) {
      return this.list()
    }

    const out = []
    for (const key of keys) {
      const val = this.npm.config.get(key)
      if (isPrivate(key, val)) {
        throw new Error(`The ${key} option is protected, and can not be retrieved in this way`)
      }

      const pref = keys.length > 1 ? `${key}=` : ''
      out.push(pref + val)
    }
    output.standard(out.join('\n'))
  }

  async del (keys) {
    if (!keys.length) {
      throw this.usageError()
    }

    const where = this.npm.flatOptions.location
    for (const key of keys) {
      this.npm.config.delete(key, where)
    }
    await this.npm.config.save(where)
  }

  async edit () {
    const ini = require('ini')
    const e = this.npm.flatOptions.editor
    const where = this.npm.flatOptions.location
    const file = this.npm.config.data.get(where).source

    // save first, just to make sure it's synced up
    // this also removes all the comments from the last time we edited it.
    await this.npm.config.save(where)

    const data = (
      await readFile(file, 'utf8').catch(() => '')
    ).replace(/\r\n/g, '\n')
    const entries = Object.entries(defaults)
    const defData = entries.reduce((str, [key, val]) => {
      const obj = { [key]: val }
      const i = ini.stringify(obj)
        .replace(/\r\n/g, '\n') // normalizes output from ini.stringify
        .replace(/\n$/m, '')
        .replace(/^/g, '; ')
        .replace(/\n/g, '\n; ')
        .split('\n')
      return str + '\n' + i
    }, '')

    const tmpData = `;;;;
; npm ${where}config file: ${file}
; this is a simple ini-formatted file
; lines that start with semi-colons are comments
; run \`npm help 7 config\` for documentation of the various options
;
; Configs like \`@scope:registry\` map a scope to a given registry url.
;
; Configs like \`//<hostname>/:_authToken\` are auth that is restricted
; to the registry host specified.

${data.split('\n').sort(localeCompare).join('\n').trim()}

;;;;
; all available options shown below with default values
;;;;

${defData}
`.split('\n').join(EOL)
    await mkdir(dirname(file), { recursive: true })
    await writeFile(file, tmpData, 'utf8')
    await new Promise((res, rej) => {
      const [bin, ...args] = e.split(/\s+/)
      const editor = spawn(bin, [...args, file], { stdio: 'inherit' })
      editor.on('exit', (code) => {
        if (code) {
          return rej(new Error(`editor process exited with code: ${code}`))
        }
        return res()
      })
    })
  }

  async fix () {
    let problems

    try {
      this.npm.config.validate()
      return // if validate doesn't throw we have nothing to do
    } catch (err) {
      // coverage skipped because we don't need to test rethrowing errors
      // istanbul ignore next
      if (err.code !== 'ERR_INVALID_AUTH') {
        throw err
      }

      problems = err.problems
    }

    if (!this.npm.config.isDefault('location')) {
      problems = problems.filter((problem) => {
        return problem.where === this.npm.config.get('location')
      })
    }

    this.npm.config.repair(problems)
    const locations = []

    output.standard('The following configuration problems have been repaired:\n')
    const summary = problems.map(({ action, from, to, key, where }) => {
      // coverage disabled for else branch because it is intentionally omitted
      // istanbul ignore else
      if (action === 'rename') {
        // we keep track of which configs were modified here so we know what to save later
        locations.push(where)
        return `~ \`${from}\` renamed to \`${to}\` in ${where} config`
      } else if (action === 'delete') {
        locations.push(where)
        return `- \`${key}\` deleted from ${where} config`
      }
    }).join('\n')
    output.standard(summary)

    return await Promise.all(locations.map((location) => this.npm.config.save(location)))
  }

  async list () {
    const msg = []
    // long does not have a flattener
    const long = this.npm.config.get('long')
    for (const [where, { data, source }] of this.npm.config.data.entries()) {
      if (where === 'default' && !long) {
        continue
      }

      const entries = Object.entries(data).sort(([a], [b]) => localeCompare(a, b))
      if (!entries.length) {
        continue
      }

      msg.push(`; "${where}" config from ${source}`, '')
      for (const [k, v] of entries) {
        const display = displayVar(k, v)
        const src = this.npm.config.find(k)
        msg.push(src === where ? display : `; ${display} ; overridden by ${src}`)
        msg.push()
      }
      msg.push('')
    }

    if (!long) {
      msg.push(
        `; node bin location = ${process.execPath}`,
        `; node version = ${process.version}`,
        `; npm local prefix = ${this.npm.localPrefix}`,
        `; npm version = ${this.npm.version}`,
        `; cwd = ${process.cwd()}`,
        `; HOME = ${process.env.HOME}`,
        '; Run `npm config ls -l` to show all defaults.'
      )
      msg.push('')
    }

    if (!this.npm.global) {
      const { content } = await pkgJson.normalize(this.npm.prefix).catch(() => ({ content: {} }))

      if (content.publishConfig) {
        const pkgPath = resolve(this.npm.prefix, 'package.json')
        msg.push(`; "publishConfig" from ${pkgPath}`)
        msg.push('; This set of config values will be used at publish-time.', '')
        const entries = Object.entries(content.publishConfig)
          .sort(([a], [b]) => localeCompare(a, b))
        for (const [k, value] of entries) {
          msg.push(displayVar(k, value))
        }
        msg.push('')
      }
    }

    output.standard(msg.join('\n').trim())
  }

  async listJson () {
    const publicConf = {}
    for (const key in this.npm.config.list[0]) {
      const value = this.npm.config.get(key)
      if (isPrivate(key, value)) {
        continue
      }

      publicConf[key] = value
    }
    output.buffer(publicConf)
  }
}

module.exports = Config
                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/npm/lib/commands/dedupe.js                                                         0000664 0000000 0000000 00000002643 14746647661 0020462 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const reifyFinish = require('../utils/reify-finish.js')
const ArboristWorkspaceCmd = require('../arborist-cmd.js')

// dedupe duplicated packages, or find them in the tree
class Dedupe extends ArboristWorkspaceCmd {
  static description = 'Reduce duplication in the package tree'
  static name = 'dedupe'
  static params = [
    'install-strategy',
    'legacy-bundling',
    'global-style',
    'strict-peer-deps',
    'package-lock',
    'omit',
    'include',
    'ignore-scripts',
    'audit',
    'bin-links',
    'fund',
    'dry-run',
    ...super.params,
  ]

  async exec () {
    if (this.npm.global) {
      const er = new Error('`npm dedupe` does not work in global mode.')
      er.code = 'EDEDUPEGLOBAL'
      throw er
    }

    const dryRun = this.npm.config.get('dry-run')
    const where = this.npm.prefix
    const Arborist = require('@npmcli/arborist')
    const opts = {
      ...this.npm.flatOptions,
      path: where,
      dryRun,
      // Saving during dedupe would only update if one of your direct
      // dependencies was also duplicated somewhere in your tree. It would be
      // confusing if running this were to also update your package.json.  In
      // order to reduce potential confusion we set this to false.
      save: false,
      workspaces: this.workspaceNames,
    }
    const arb = new Arborist(opts)
    await arb.dedupe(opts)
    await reifyFinish(this.npm, arb)
  }
}

module.exports = Dedupe
                                                                                             node-23.7.0/deps/npm/lib/commands/deprecate.js                                                      0000664 0000000 0000000 00000004206 14746647661 0021145 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const fetch = require('npm-registry-fetch')
const { otplease } = require('../utils/auth.js')
const npa = require('npm-package-arg')
const { log } = require('proc-log')
const semver = require('semver')
const getIdentity = require('../utils/get-identity.js')
const libaccess = require('libnpmaccess')
const BaseCommand = require('../base-cmd.js')

class Deprecate extends BaseCommand {
  static description = 'Deprecate a version of a package'
  static name = 'deprecate'
  static usage = ['<package-spec> <message>']
  static params = [
    'registry',
    'otp',
  ]

  static ignoreImplicitWorkspace = true

  static async completion (opts, npm) {
    if (opts.conf.argv.remain.length > 1) {
      return []
    }

    const username = await getIdentity(npm, npm.flatOptions)
    const packages = await libaccess.getPackages(username, npm.flatOptions)
    return Object.keys(packages)
      .filter((name) =>
        packages[name] === 'write' &&
        (opts.conf.argv.remain.length === 0 ||
          name.startsWith(opts.conf.argv.remain[0])))
  }

  async exec ([pkg, msg]) {
    // msg == null because '' is a valid value, it indicates undeprecate
    if (!pkg || msg == null) {
      throw this.usageError()
    }

    // fetch the data and make sure it exists.
    const p = npa(pkg)
    const spec = p.rawSpec === '*' ? '*' : p.fetchSpec

    if (semver.validRange(spec, true) === null) {
      throw new Error(`invalid version range: ${spec}`)
    }

    const uri = '/' + p.escapedName
    const packument = await fetch.json(uri, {
      ...this.npm.flatOptions,
      spec: p,
      query: { write: true },
    })

    const versions = Object.keys(packument.versions)
      .filter(v => semver.satisfies(v, spec, { includePrerelease: true }))

    if (versions.length) {
      for (const v of versions) {
        packument.versions[v].deprecated = msg
      }
      return otplease(this.npm, this.npm.flatOptions, opts => fetch(uri, {
        ...opts,
        spec: p,
        method: 'PUT',
        body: packument,
        ignoreBody: true,
      }))
    } else {
      log.warn('deprecate', 'No version found for', p.rawSpec)
    }
  }
}

module.exports = Deprecate
                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/npm/lib/commands/diff.js                                                           0000664 0000000 0000000 00000020222 14746647661 0020115 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { resolve } = require('node:path')
const semver = require('semver')
const libnpmdiff = require('libnpmdiff')
const npa = require('npm-package-arg')
const pacote = require('pacote')
const pickManifest = require('npm-pick-manifest')
const { log, output } = require('proc-log')
const pkgJson = require('@npmcli/package-json')
const BaseCommand = require('../base-cmd.js')

class Diff extends BaseCommand {
  static description = 'The registry diff command'
  static name = 'diff'
  static usage = [
    '[...<paths>]',
  ]

  static params = [
    'diff',
    'diff-name-only',
    'diff-unified',
    'diff-ignore-all-space',
    'diff-no-prefix',
    'diff-src-prefix',
    'diff-dst-prefix',
    'diff-text',
    'global',
    'tag',
    'workspace',
    'workspaces',
    'include-workspace-root',
  ]

  static workspaces = true
  static ignoreImplicitWorkspace = false

  async exec (args) {
    const specs = this.npm.config.get('diff').filter(d => d)
    if (specs.length > 2) {
      throw this.usageError(`Can't use more than two --diff arguments.`)
    }

    // execWorkspaces may have set this already
    if (!this.prefix) {
      this.prefix = this.npm.prefix
    }

    // this is the "top" directory, one up from node_modules
    // in global mode we have to walk one up from globalDir because our
    // node_modules is sometimes under ./lib, and in global mode we're only ever
    // walking through node_modules (because we will have been given a package
    // name already)
    if (this.npm.global) {
      this.top = resolve(this.npm.globalDir, '..')
    } else {
      this.top = this.prefix
    }

    const [a, b] = await this.retrieveSpecs(specs)
    log.info('diff', { src: a, dst: b })

    const res = await libnpmdiff([a, b], {
      ...this.npm.flatOptions,
      diffFiles: args,
      where: this.top,
    })
    return output.standard(res)
  }

  async execWorkspaces (args) {
    await this.setWorkspaces()
    for (const workspacePath of this.workspacePaths) {
      this.top = workspacePath
      this.prefix = workspacePath
      await this.exec(args)
    }
  }

  // get the package name from the packument at `path`
  // throws if no packument is present OR if it does not have `name` attribute
  async packageName () {
    let name
    try {
      const { content: pkg } = await pkgJson.normalize(this.prefix)
      name = pkg.name
    } catch (e) {
      log.verbose('diff', 'could not read project dir package.json')
    }

    if (!name) {
      throw this.usageError('Needs multiple arguments to compare or run from a project dir.')
    }

    return name
  }

  async retrieveSpecs ([a, b]) {
    if (a && b) {
      const specs = await this.convertVersionsToSpecs([a, b])
      return this.findVersionsByPackageName(specs)
    }

    // no arguments, defaults to comparing cwd
    // to its latest published registry version
    if (!a) {
      const pkgName = await this.packageName()
      return [
        `${pkgName}@${this.npm.config.get('tag')}`,
        `file:${this.prefix.replace(/#/g, '%23')}`,
      ]
    }

    // single argument, used to compare wanted versions of an
    // installed dependency or to compare the cwd to a published version
    let noPackageJson
    let pkgName
    try {
      const { content: pkg } = await pkgJson.normalize(this.prefix)
      pkgName = pkg.name
    } catch (e) {
      log.verbose('diff', 'could not read project dir package.json')
      noPackageJson = true
    }

    const missingPackageJson =
      this.usageError('Needs multiple arguments to compare or run from a project dir.')

    // using a valid semver range, that means it should just diff
    // the cwd against a published version to the registry using the
    // same project name and the provided semver range
    if (semver.validRange(a)) {
      if (!pkgName) {
        throw missingPackageJson
      }
      return [
        `${pkgName}@${a}`,
        `file:${this.prefix.replace(/#/g, '%23')}`,
      ]
    }

    // when using a single package name as arg and it's part of the current
    // install tree, then retrieve the current installed version and compare
    // it against the same value `npm outdated` would suggest you to update to
    const spec = npa(a)
    if (spec.registry) {
      let actualTree
      let node
      const Arborist = require('@npmcli/arborist')
      try {
        const opts = {
          ...this.npm.flatOptions,
          path: this.top,
        }
        const arb = new Arborist(opts)
        actualTree = await arb.loadActual(opts)
        node = actualTree &&
          actualTree.inventory.query('name', spec.name)
            .values().next().value
      } catch (e) {
        log.verbose('diff', 'failed to load actual install tree')
      }

      if (!node || !node.name || !node.package || !node.package.version) {
        if (noPackageJson) {
          throw missingPackageJson
        }
        return [
          `${spec.name}@${spec.fetchSpec}`,
          `file:${this.prefix.replace(/#/g, '%23')}`,
        ]
      }

      const tryRootNodeSpec = () =>
        (actualTree && actualTree.edgesOut.get(spec.name) || {}).spec

      const tryAnySpec = () => {
        for (const edge of node.edgesIn) {
          return edge.spec
        }
      }

      const aSpec = `file:${node.realpath.replace(/#/g, '%23')}`

      // finds what version of the package to compare against, if a exact
      // version or tag was passed than it should use that, otherwise
      // work from the top of the arborist tree to find the original semver
      // range declared in the package that depends on the package.
      let bSpec
      if (spec.rawSpec !== '*') {
        bSpec = spec.rawSpec
      } else {
        const bTargetVersion =
          tryRootNodeSpec()
          || tryAnySpec()

        // figure out what to compare against,
        // follows same logic to npm outdated "Wanted" results
        const packument = await pacote.packument(spec, {
          ...this.npm.flatOptions,
          preferOnline: true,
        })
        bSpec = pickManifest(
          packument,
          bTargetVersion,
          { ...this.npm.flatOptions }
        ).version
      }

      return [
        `${spec.name}@${aSpec}`,
        `${spec.name}@${bSpec}`,
      ]
    } else if (spec.type === 'directory') {
      return [
        `file:${spec.fetchSpec.replace(/#/g, '%23')}`,
        `file:${this.prefix.replace(/#/g, '%23')}`,
      ]
    } else {
      throw this.usageError(`Spec type ${spec.type} not supported.`)
    }
  }

  async convertVersionsToSpecs ([a, b]) {
    const semverA = semver.validRange(a)
    const semverB = semver.validRange(b)

    // both specs are semver versions, assume current project dir name
    if (semverA && semverB) {
      let pkgName
      try {
        const { content: pkg } = await pkgJson.normalize(this.prefix)
        pkgName = pkg.name
      } catch (e) {
        log.verbose('diff', 'could not read project dir package.json')
      }

      if (!pkgName) {
        throw this.usageError('Needs to be run from a project dir in order to diff two versions.')
      }

      return [`${pkgName}@${a}`, `${pkgName}@${b}`]
    }

    // otherwise uses the name from the other arg to
    // figure out the spec.name of what to compare
    if (!semverA && semverB) {
      return [a, `${npa(a).name}@${b}`]
    }

    if (semverA && !semverB) {
      return [`${npa(b).name}@${a}`, b]
    }

    // no valid semver ranges used
    return [a, b]
  }

  async findVersionsByPackageName (specs) {
    let actualTree
    const Arborist = require('@npmcli/arborist')
    try {
      const opts = {
        ...this.npm.flatOptions,
        path: this.top,
      }
      const arb = new Arborist(opts)
      actualTree = await arb.loadActual(opts)
    } catch (e) {
      log.verbose('diff', 'failed to load actual install tree')
    }

    return specs.map(i => {
      const spec = npa(i)
      if (spec.rawSpec !== '*') {
        return i
      }

      const node = actualTree
        && actualTree.inventory.query('name', spec.name)
          .values().next().value

      const res = !node || !node.package || !node.package.version
        ? spec.fetchSpec
        : `file:${node.realpath.replace(/#/g, '%23')}`

      return `${spec.name}@${res}`
    })
  }
}

module.exports = Diff
                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/npm/lib/commands/dist-tag.js                                                       0000664 0000000 0000000 00000013026 14746647661 0020725 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const npa = require('npm-package-arg')
const regFetch = require('npm-registry-fetch')
const semver = require('semver')
const { log, output } = require('proc-log')
const { otplease } = require('../utils/auth.js')
const pkgJson = require('@npmcli/package-json')
const BaseCommand = require('../base-cmd.js')

class DistTag extends BaseCommand {
  static description = 'Modify package distribution tags'
  static params = ['workspace', 'workspaces', 'include-workspace-root']
  static name = 'dist-tag'
  static usage = [
    'add <package-spec (with version)> [<tag>]',
    'rm <package-spec> <tag>',
    'ls [<package-spec>]',
  ]

  static workspaces = true
  static ignoreImplicitWorkspace = false

  static async completion (opts) {
    const argv = opts.conf.argv.remain
    if (argv.length === 2) {
      return ['add', 'rm', 'ls']
    }

    switch (argv[2]) {
      default:
        return []
    }
  }

  async exec ([cmdName, pkg, tag]) {
    const opts = {
      ...this.npm.flatOptions,
    }

    if (['add', 'a', 'set', 's'].includes(cmdName)) {
      return this.add(pkg, tag, opts)
    }

    if (['rm', 'r', 'del', 'd', 'remove'].includes(cmdName)) {
      return this.remove(pkg, tag, opts)
    }

    if (['ls', 'l', 'sl', 'list'].includes(cmdName)) {
      return this.list(pkg, opts)
    }

    if (!pkg) {
      // when only using the pkg name the default behavior
      // should be listing the existing tags
      return this.list(cmdName, opts)
    } else {
      throw this.usageError()
    }
  }

  async execWorkspaces ([cmdName, pkg, tag]) {
    // cmdName is some form of list
    // pkg is one of:
    // - unset
    // - .
    // - .@version
    if (['ls', 'l', 'sl', 'list'].includes(cmdName) && (!pkg || pkg === '.' || /^\.@/.test(pkg))) {
      return this.listWorkspaces()
    }

    // pkg is unset
    // cmdName is one of:
    // - unset
    // - .
    // - .@version
    if (!pkg && (!cmdName || cmdName === '.' || /^\.@/.test(cmdName))) {
      return this.listWorkspaces()
    }

    // anything else is just a regular dist-tag command
    // so we fallback to the non-workspaces implementation
    log.warn('dist-tag', 'Ignoring workspaces for specified package')
    return this.exec([cmdName, pkg, tag])
  }

  async add (spec, tag, opts) {
    spec = npa(spec || '')
    const version = spec.rawSpec
    const defaultTag = tag || this.npm.config.get('tag')

    log.verbose('dist-tag add', defaultTag, 'to', spec.name + '@' + version)

    // make sure new spec with tag is valid, this will throw if invalid
    npa(`${spec.name}@${defaultTag}`)

    if (!spec.name || !version || !defaultTag) {
      throw this.usageError('must provide a spec with a name and version, and a tag to add')
    }

    const t = defaultTag.trim()

    if (semver.validRange(t)) {
      throw new Error('Tag name must not be a valid SemVer range: ' + t)
    }

    const tags = await this.fetchTags(spec, opts)
    if (tags[t] === version) {
      log.warn('dist-tag add', t, 'is already set to version', version)
      return
    }
    tags[t] = version
    const url =
      `/-/package/${spec.escapedName}/dist-tags/${encodeURIComponent(t)}`
    const reqOpts = {
      ...opts,
      method: 'PUT',
      body: JSON.stringify(version),
      headers: {
        'content-type': 'application/json',
      },
      spec,
    }
    await otplease(this.npm, reqOpts, o => regFetch(url, o))
    output.standard(`+${t}: ${spec.name}@${version}`)
  }

  async remove (spec, tag, opts) {
    spec = npa(spec || '')
    log.verbose('dist-tag del', tag, 'from', spec.name)

    if (!spec.name) {
      throw this.usageError()
    }

    const tags = await this.fetchTags(spec, opts)
    if (!tags[tag]) {
      log.info('dist-tag del', tag, 'is not a dist-tag on', spec.name)
      throw new Error(tag + ' is not a dist-tag on ' + spec.name)
    }
    const version = tags[tag]
    delete tags[tag]
    const url =
      `/-/package/${spec.escapedName}/dist-tags/${encodeURIComponent(tag)}`
    const reqOpts = {
      ...opts,
      method: 'DELETE',
      spec,
    }
    await otplease(this.npm, reqOpts, o => regFetch(url, o))
    output.standard(`-${tag}: ${spec.name}@${version}`)
  }

  async list (spec, opts) {
    if (!spec) {
      if (this.npm.global) {
        throw this.usageError()
      }
      const { content: { name } } = await pkgJson.normalize(this.npm.prefix)
      if (!name) {
        throw this.usageError()
      }

      return this.list(name, opts)
    }
    spec = npa(spec)

    try {
      const tags = await this.fetchTags(spec, opts)
      const msg =
        Object.keys(tags).map(k => `${k}: ${tags[k]}`).sort().join('\n')
      output.standard(msg)
      return tags
    } catch (err) {
      log.error('dist-tag ls', "Couldn't get dist-tag data for", spec)
      throw err
    }
  }

  async listWorkspaces () {
    await this.setWorkspaces()

    for (const name of this.workspaceNames) {
      try {
        output.standard(`${name}:`)
        await this.list(npa(name), this.npm.flatOptions)
      } catch (err) {
        // set the exitCode directly, but ignore the error
        // since it will have already been logged by this.list()
        process.exitCode = 1
      }
    }
  }

  async fetchTags (spec, opts) {
    const data = await regFetch.json(
      `/-/package/${spec.escapedName}/dist-tags`,
      { ...opts, 'prefer-online': true, spec }
    )
    if (data && typeof data === 'object') {
      delete data._etag
    }
    if (!data || !Object.keys(data).length) {
      throw new Error('No dist-tags found for ' + spec.name)
    }

    return data
  }
}

module.exports = DistTag
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/npm/lib/commands/docs.js                                                           0000664 0000000 0000000 00000000701 14746647661 0020135 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const PackageUrlCmd = require('../package-url-cmd.js')

class Docs extends PackageUrlCmd {
  static description = 'Open documentation for a package in a web browser'
  static name = 'docs'

  getUrl (spec, mani) {
    if (mani.homepage) {
      return mani.homepage
    }

    const info = this.hostedFromMani(mani)
    if (info) {
      return info.docs()
    }

    return `https://www.npmjs.com/package/${mani.name}`
  }
}

module.exports = Docs
                                                               node-23.7.0/deps/npm/lib/commands/doctor.js                                                         0000664 0000000 0000000 00000024153 14746647661 0020506 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const cacache = require('cacache')
const { access, lstat, readdir, constants: { R_OK, W_OK, X_OK } } = require('node:fs/promises')
const fetch = require('make-fetch-happen')
const which = require('which')
const pacote = require('pacote')
const { resolve } = require('node:path')
const semver = require('semver')
const { log, output } = require('proc-log')
const ping = require('../utils/ping.js')
const { defaults } = require('@npmcli/config/lib/definitions')
const BaseCommand = require('../base-cmd.js')

const maskLabel = mask => {
  const label = []
  if (mask & R_OK) {
    label.push('readable')
  }

  if (mask & W_OK) {
    label.push('writable')
  }

  if (mask & X_OK) {
    label.push('executable')
  }

  return label.join(', ')
}

const subcommands = [
  {
    // Ping is left in as a legacy command but is listed as "connection" to
    // make more sense to more people
    groups: ['connection', 'ping', 'registry'],
    title: 'Connecting to the registry',
    cmd: 'checkPing',
  }, {
    groups: ['versions'],
    title: 'Checking npm version',
    cmd: 'getLatestNpmVersion',
  }, {
    groups: ['versions'],
    title: 'Checking node version',
    cmd: 'getLatestNodejsVersion',
  }, {
    groups: ['registry'],
    title: 'Checking configured npm registry',
    cmd: 'checkNpmRegistry',
  }, {
    groups: ['environment'],
    title: 'Checking for git executable in PATH',
    cmd: 'getGitPath',
  }, {
    groups: ['environment'],
    title: 'Checking for global bin folder in PATH',
    cmd: 'getBinPath',
  }, {
    groups: ['permissions', 'cache'],
    title: 'Checking permissions on cached files (this may take awhile)',
    cmd: 'checkCachePermission',
    windows: false,
  }, {
    groups: ['permissions'],
    title: 'Checking permissions on local node_modules (this may take awhile)',
    cmd: 'checkLocalModulesPermission',
    windows: false,
  }, {
    groups: ['permissions'],
    title: 'Checking permissions on global node_modules (this may take awhile)',
    cmd: 'checkGlobalModulesPermission',
    windows: false,
  }, {
    groups: ['permissions'],
    title: 'Checking permissions on local bin folder',
    cmd: 'checkLocalBinPermission',
    windows: false,
  }, {
    groups: ['permissions'],
    title: 'Checking permissions on global bin folder',
    cmd: 'checkGlobalBinPermission',
    windows: false,
  }, {
    groups: ['cache'],
    title: 'Verifying cache contents (this may take awhile)',
    cmd: 'verifyCachedFiles',
    windows: false,
  },
  // TODO:
  // group === 'dependencies'?
  //   - ensure arborist.loadActual() runs without errors and no invalid edges
  //   - ensure package-lock.json matches loadActual()
  //   - verify loadActual without hidden lock file matches hidden lockfile
  // group === '???'
  //   - verify all local packages have bins linked
  // What is the fix for these?
]

class Doctor extends BaseCommand {
  static description = 'Check the health of your npm environment'
  static name = 'doctor'
  static params = ['registry']
  static ignoreImplicitWorkspace = false
  static usage = [`[${subcommands.flatMap(s => s.groups)
    .filter((value, index, self) => self.indexOf(value) === index && value !== 'ping')
    .join('] [')}]`]

  static subcommands = subcommands

  async exec (args) {
    log.info('doctor', 'Running checkup')
    let allOk = true

    const actions = this.actions(args)

    const chalk = this.npm.chalk
    for (const { title, cmd } of actions) {
      this.output(title)
      // TODO when we have an in progress indicator that could go here
      let result
      try {
        result = await this[cmd]()
        this.output(`${chalk.green('Ok')}${result ? `\n${result}` : ''}\n`)
      } catch (err) {
        allOk = false
        this.output(`${chalk.red('Not ok')}\n${chalk.cyan(err)}\n`)
      }
    }

    if (!allOk) {
      if (this.npm.silent) {
        /* eslint-disable-next-line max-len */
        throw new Error('Some problems found. Check logs or disable silent mode for recommendations.')
      } else {
        throw new Error('Some problems found. See above for recommendations.')
      }
    }
  }

  async checkPing () {
    log.info('doctor', 'Pinging registry')
    try {
      await ping({ ...this.npm.flatOptions, retry: false })
      return ''
    } catch (er) {
      if (/^E\d{3}$/.test(er.code || '')) {
        throw er.code.slice(1) + ' ' + er.message
      } else {
        throw er.message
      }
    }
  }

  async getLatestNpmVersion () {
    log.info('doctor', 'Getting npm package information')
    const latest = (await pacote.manifest('npm@latest', this.npm.flatOptions)).version
    if (semver.gte(this.npm.version, latest)) {
      return `current: v${this.npm.version}, latest: v${latest}`
    } else {
      throw `Use npm v${latest}`
    }
  }

  async getLatestNodejsVersion () {
    // XXX get the latest in the current major as well
    const current = process.version
    const currentRange = `^${current}`
    const url = 'https://nodejs.org/dist/index.json'
    log.info('doctor', 'Getting Node.js release information')
    const res = await fetch(url, { method: 'GET', ...this.npm.flatOptions })
    const data = await res.json()
    let maxCurrent = '0.0.0'
    let maxLTS = '0.0.0'
    for (const { lts, version } of data) {
      if (lts && semver.gt(version, maxLTS)) {
        maxLTS = version
      }

      if (semver.satisfies(version, currentRange) && semver.gt(version, maxCurrent)) {
        maxCurrent = version
      }
    }
    const recommended = semver.gt(maxCurrent, maxLTS) ? maxCurrent : maxLTS
    if (semver.gte(process.version, recommended)) {
      return `current: ${current}, recommended: ${recommended}`
    } else {
      throw `Use node ${recommended} (current: ${current})`
    }
  }

  async getBinPath () {
    log.info('doctor', 'getBinPath', 'Finding npm global bin in your PATH')
    if (!process.env.PATH.includes(this.npm.globalBin)) {
      throw new Error(`Add ${this.npm.globalBin} to your $PATH`)
    }
    return this.npm.globalBin
  }

  async checkCachePermission () {
    return this.checkFilesPermission(this.npm.cache, true, R_OK)
  }

  async checkLocalModulesPermission () {
    return this.checkFilesPermission(this.npm.localDir, true, R_OK | W_OK, true)
  }

  async checkGlobalModulesPermission () {
    return this.checkFilesPermission(this.npm.globalDir, false, R_OK)
  }

  async checkLocalBinPermission () {
    return this.checkFilesPermission(this.npm.localBin, false, R_OK | W_OK | X_OK, true)
  }

  async checkGlobalBinPermission () {
    return this.checkFilesPermission(this.npm.globalBin, false, X_OK)
  }

  async checkFilesPermission (root, shouldOwn, mask, missingOk) {
    let ok = true

    try {
      const uid = process.getuid()
      const gid = process.getgid()
      const files = new Set([root])
      for (const f of files) {
        const st = await lstat(f).catch(er => {
          // if it can't be missing, or if it can and the error wasn't that it was missing
          if (!missingOk || er.code !== 'ENOENT') {
            ok = false
            log.warn('doctor', 'checkFilesPermission', 'error getting info for ' + f)
          }
        })

        if (!st) {
          continue
        }

        if (shouldOwn && (uid !== st.uid || gid !== st.gid)) {
          log.warn('doctor', 'checkFilesPermission', 'should be owner of ' + f)
          ok = false
        }

        if (!st.isDirectory() && !st.isFile()) {
          continue
        }

        try {
          await access(f, mask)
        } catch (er) {
          ok = false
          const msg = `Missing permissions on ${f} (expect: ${maskLabel(mask)})`
          log.error('doctor', 'checkFilesPermission', msg)
          continue
        }

        if (st.isDirectory()) {
          const entries = await readdir(f).catch(() => {
            ok = false
            log.warn('doctor', 'checkFilesPermission', 'error reading directory ' + f)
            return []
          })
          for (const entry of entries) {
            files.add(resolve(f, entry))
          }
        }
      }
    } finally {
      if (!ok) {
        throw (
          `Check the permissions of files in ${root}` +
          (shouldOwn ? ' (should be owned by current user)' : '')
        )
      } else {
        return ''
      }
    }
  }

  async getGitPath () {
    log.info('doctor', 'Finding git in your PATH')
    return await which('git').catch(er => {
      log.warn('doctor', 'getGitPath', er)
      throw new Error("Install git and ensure it's in your PATH.")
    })
  }

  async verifyCachedFiles () {
    log.info('doctor', 'verifyCachedFiles', 'Verifying the npm cache')

    const stats = await cacache.verify(this.npm.flatOptions.cache)
    const { badContentCount, reclaimedCount, missingContent, reclaimedSize } = stats
    if (badContentCount || reclaimedCount || missingContent) {
      if (badContentCount) {
        log.warn('doctor', 'verifyCachedFiles', `Corrupted content removed: ${badContentCount}`)
      }

      if (reclaimedCount) {
        log.warn(
          'doctor',
          'verifyCachedFiles',
          `Content garbage-collected: ${reclaimedCount} (${reclaimedSize} bytes)`
        )
      }

      if (missingContent) {
        log.warn('doctor', 'verifyCachedFiles', `Missing content: ${missingContent}`)
      }

      log.warn('doctor', 'verifyCachedFiles', 'Cache issues have been fixed')
    }
    log.info(
      'doctor',
      'verifyCachedFiles',
        `Verification complete. Stats: ${JSON.stringify(stats, null, 2)}`
    )
    return `verified ${stats.verifiedContent} tarballs`
  }

  async checkNpmRegistry () {
    if (this.npm.flatOptions.registry !== defaults.registry) {
      throw `Try \`npm config set registry=${defaults.registry}\``
    } else {
      return `using default registry (${defaults.registry})`
    }
  }

  output (...args) {
    // TODO display layer should do this
    if (!this.npm.silent) {
      output.standard(...args)
    }
  }

  actions (params) {
    return this.constructor.subcommands.filter(subcmd => {
      if (process.platform === 'win32' && subcmd.windows === false) {
        return false
      }
      if (params.length) {
        return params.some(param => subcmd.groups.includes(param))
      }
      return true
    })
  }
}

module.exports = Doctor
                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/npm/lib/commands/edit.js                                                           0000664 0000000 0000000 00000003414 14746647661 0020136 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { resolve } = require('node:path')
const { lstat } = require('node:fs/promises')
const cp = require('node:child_process')
const completion = require('../utils/installed-shallow.js')
const BaseCommand = require('../base-cmd.js')

const splitPackageNames = (path) => path.split('/')
// combine scoped parts
  .reduce((parts, part) => {
    if (parts.length === 0) {
      return [part]
    }

    const lastPart = parts[parts.length - 1]
    // check if previous part is the first part of a scoped package
    if (lastPart[0] === '@' && !lastPart.includes('/')) {
      parts[parts.length - 1] += '/' + part
    } else {
      parts.push(part)
    }

    return parts
  }, [])
  .join('/node_modules/')
  .replace(/(\/node_modules)+/, '/node_modules')

// npm edit <pkg>
// open the package folder in the $EDITOR
class Edit extends BaseCommand {
  static description = 'Edit an installed package'
  static name = 'edit'
  static usage = ['<pkg>[/<subpkg>...]']
  static params = ['editor']
  static ignoreImplicitWorkspace = false

  // TODO
  /* istanbul ignore next */
  static async completion (opts, npm) {
    return completion(npm, opts)
  }

  async exec (args) {
    if (args.length !== 1) {
      throw this.usageError()
    }

    const path = splitPackageNames(args[0])
    const dir = resolve(this.npm.dir, path)

    await lstat(dir)
    await new Promise((res, rej) => {
      const [bin, ...spawnArgs] = this.npm.config.get('editor').split(/\s+/)
      const editor = cp.spawn(bin, [...spawnArgs, dir], { stdio: 'inherit' })
      editor.on('exit', async (code) => {
        if (code) {
          return rej(new Error(`editor process exited with code: ${code}`))
        }
        await this.npm.exec('rebuild', [dir]).then(res).catch(rej)
      })
    })
  }
}

module.exports = Edit
                                                                                                                                                                                                                                                    node-23.7.0/deps/npm/lib/commands/exec.js                                                           0000664 0000000 0000000 00000006654 14746647661 0020146 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { resolve } = require('node:path')
const libexec = require('libnpmexec')
const BaseCommand = require('../base-cmd.js')

class Exec extends BaseCommand {
  static description = 'Run a command from a local or remote npm package'
  static params = [
    'package',
    'call',
    'workspace',
    'workspaces',
    'include-workspace-root',
  ]

  static name = 'exec'
  static usage = [
    '-- <pkg>[@<version>] [args...]',
    '--package=<pkg>[@<version>] -- <cmd> [args...]',
    '-c \'<cmd> [args...]\'',
    '--package=foo -c \'<cmd> [args...]\'',
  ]

  static workspaces = true
  static ignoreImplicitWorkspace = false
  static isShellout = true

  async exec (args) {
    return this.callExec(args)
  }

  async execWorkspaces (args) {
    await this.setWorkspaces()

    for (const [name, path] of this.workspaces) {
      const locationMsg =
        `in workspace ${this.npm.chalk.green(name)} at location:\n${this.npm.chalk.dim(path)}`
      await this.callExec(args, { name, locationMsg, runPath: path })
    }
  }

  async callExec (args, { name, locationMsg, runPath } = {}) {
    let localBin = this.npm.localBin
    let pkgPath = this.npm.localPrefix

    // This is where libnpmexec will actually run the scripts from
    if (!runPath) {
      runPath = process.cwd()
    } else {
      // We have to consider if the workspace has its own separate versions
      // libnpmexec will walk up to localDir after looking here
      localBin = resolve(this.npm.localDir, name, 'node_modules', '.bin')
      // We also need to look for `bin` entries in the workspace package.json
      // libnpmexec will NOT look in the project root for the bin entry
      pkgPath = runPath
    }

    const call = this.npm.config.get('call')
    let globalPath
    const {
      flatOptions,
      globalBin,
      globalDir,
      chalk,
    } = this.npm
    const scriptShell = this.npm.config.get('script-shell') || undefined
    const packages = this.npm.config.get('package')
    const yes = this.npm.config.get('yes')
    // --prefix sets both of these to the same thing, meaning the global prefix
    // is invalid (i.e. no lib/node_modules).  This is not a trivial thing to
    // untangle and fix so we work around it here.
    if (this.npm.localPrefix !== this.npm.globalPrefix) {
      globalPath = resolve(globalDir, '..')
    }

    if (call && args.length) {
      throw this.usageError()
    }

    return libexec({
      ...flatOptions,
      // we explicitly set packageLockOnly to false because if it's true
      // when we try to install a missing package, we won't actually install it
      packageLockOnly: false,
      // what the user asked to run args[0] is run by default
      args: [...args], // copy args so they dont get mutated
      // specify a custom command to be run instead of args[0]
      call,
      chalk,
      // where to look for bins globally, if a file matches call or args[0] it is called
      globalBin,
      // where to look for packages globally, if a package matches call or args[0] it is called
      globalPath,
      // where to look for bins locally, if a file matches call or args[0] it is called
      localBin,
      locationMsg,
      // packages that need to be installed
      packages,
      // path where node_modules is
      path: this.npm.localPrefix,
      // where to look for package.json#bin entries first
      pkgPath,
      // cwd to run from
      runPath,
      scriptShell,
      yes,
    })
  }
}

module.exports = Exec
                                                                                    node-23.7.0/deps/npm/lib/commands/explain.js                                                        0000664 0000000 0000000 00000007115 14746647661 0020653 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { explainNode } = require('../utils/explain-dep.js')
const npa = require('npm-package-arg')
const semver = require('semver')
const { relative, resolve } = require('node:path')
const validName = require('validate-npm-package-name')
const { output } = require('proc-log')
const ArboristWorkspaceCmd = require('../arborist-cmd.js')

class Explain extends ArboristWorkspaceCmd {
  static description = 'Explain installed packages'
  static name = 'explain'
  static usage = ['<package-spec>']
  static params = [
    'json',
    'workspace',
  ]

  static ignoreImplicitWorkspace = false

  // TODO
  /* istanbul ignore next */
  static async completion (opts, npm) {
    const completion = require('../utils/installed-deep.js')
    return completion(npm, opts)
  }

  async exec (args) {
    if (!args.length) {
      throw this.usageError()
    }

    const Arborist = require('@npmcli/arborist')
    const arb = new Arborist({ path: this.npm.prefix, ...this.npm.flatOptions })
    const tree = await arb.loadActual()

    if (this.npm.flatOptions.workspacesEnabled
      && this.workspaceNames
      && this.workspaceNames.length
    ) {
      this.filterSet = arb.workspaceDependencySet(tree, this.workspaceNames)
    } else if (!this.npm.flatOptions.workspacesEnabled) {
      this.filterSet =
        arb.excludeWorkspacesDependencySet(tree)
    }

    const nodes = new Set()
    for (const arg of args) {
      for (const node of this.getNodes(tree, arg)) {
        const filteredOut = this.filterSet
          && this.filterSet.size > 0
          && !this.filterSet.has(node)
        if (!filteredOut) {
          nodes.add(node)
        }
      }
    }
    if (nodes.size === 0) {
      throw new Error(`No dependencies found matching ${args.join(', ')}`)
    }

    const expls = []
    for (const node of nodes) {
      const { extraneous, dev, optional, devOptional, peer, inBundle, overridden } = node
      const expl = node.explain()
      if (extraneous) {
        expl.extraneous = true
      } else {
        expl.dev = dev
        expl.optional = optional
        expl.devOptional = devOptional
        expl.peer = peer
        expl.bundled = inBundle
        expl.overridden = overridden
      }
      expls.push(expl)
    }

    if (this.npm.flatOptions.json) {
      output.buffer(expls)
    } else {
      output.standard(expls.map(expl => {
        return explainNode(expl, Infinity, this.npm.chalk)
      }).join('\n\n'))
    }
  }

  getNodes (tree, arg) {
    // if it's just a name, return packages by that name
    const { validForOldPackages: valid } = validName(arg)
    if (valid) {
      return tree.inventory.query('packageName', arg)
    }

    // if it's a location, get that node
    const maybeLoc = arg.replace(/\\/g, '/').replace(/\/+$/, '')
    const nodeByLoc = tree.inventory.get(maybeLoc)
    if (nodeByLoc) {
      return [nodeByLoc]
    }

    // maybe a path to a node_modules folder
    const maybePath = relative(this.npm.prefix, resolve(maybeLoc))
      .replace(/\\/g, '/').replace(/\/+$/, '')
    const nodeByPath = tree.inventory.get(maybePath)
    if (nodeByPath) {
      return [nodeByPath]
    }

    // otherwise, try to select all matching nodes
    try {
      return this.getNodesByVersion(tree, arg)
    } catch (er) {
      return []
    }
  }

  getNodesByVersion (tree, arg) {
    const spec = npa(arg, this.npm.prefix)
    if (spec.type !== 'version' && spec.type !== 'range') {
      return []
    }

    return tree.inventory.filter(node => {
      return node.package.name === spec.name &&
        semver.satisfies(node.package.version, spec.rawSpec)
    })
  }
}

module.exports = Explain
                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/npm/lib/commands/explore.js                                                        0000664 0000000 0000000 00000004243 14746647661 0020670 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const pkgJson = require('@npmcli/package-json')
const runScript = require('@npmcli/run-script')
const { join, relative } = require('node:path')
const { log, output } = require('proc-log')
const completion = require('../utils/installed-shallow.js')
const BaseCommand = require('../base-cmd.js')

// npm explore <pkg>[@<version>]
// open a subshell to the package folder.
class Explore extends BaseCommand {
  static description = 'Browse an installed package'
  static name = 'explore'
  static usage = ['<pkg> [ -- <command>]']
  static params = ['shell']
  static ignoreImplicitWorkspace = false

  // TODO
  /* istanbul ignore next */
  static async completion (opts, npm) {
    return completion(npm, opts)
  }

  async exec (args) {
    if (args.length < 1 || !args[0]) {
      throw this.usageError()
    }

    const pkgname = args.shift()

    // detect and prevent any .. shenanigans
    const path = join(this.npm.dir, join('/', pkgname))
    if (relative(path, this.npm.dir) === '') {
      throw this.usageError()
    }

    // run as if running a script named '_explore', which we set to either
    // the set of arguments, or the shell config, and let @npmcli/run-script
    // handle all the escaping and PATH setup stuff.

    const { content: pkg } = await pkgJson.normalize(path).catch(er => {
      log.error('explore', `It doesn't look like ${pkgname} is installed.`)
      throw er
    })

    const { shell } = this.npm.flatOptions
    pkg.scripts = {
      ...(pkg.scripts || {}),
      _explore: args.join(' ').trim() || shell,
    }

    if (!args.length) {
      output.standard(`\nExploring ${path}\nType 'exit' or ^D when finished\n`)
    }

    return runScript({
      ...this.npm.flatOptions,
      pkg,
      path,
      event: '_explore',
      stdio: 'inherit',
    }).catch(er => {
      process.exitCode = typeof er.code === 'number' && er.code !== 0 ? er.code
        : 1
        // if it's not an exit error, or non-interactive, throw it
      const isProcExit = er.message === 'command failed' &&
          (typeof er.code === 'number' || /^SIG/.test(er.signal || ''))
      if (args.length || !isProcExit) {
        throw er
      }
    })
  }
}

module.exports = Explore
                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/npm/lib/commands/find-dupes.js                                                     0000664 0000000 0000000 00000001172 14746647661 0021246 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const ArboristWorkspaceCmd = require('../arborist-cmd.js')

// dedupe duplicated packages, or find them in the tree
class FindDupes extends ArboristWorkspaceCmd {
  static description = 'Find duplication in the package tree'
  static name = 'find-dupes'
  static params = [
    'install-strategy',
    'legacy-bundling',
    'global-style',
    'strict-peer-deps',
    'package-lock',
    'omit',
    'include',
    'ignore-scripts',
    'audit',
    'bin-links',
    'fund',
    ...super.params,
  ]

  async exec () {
    this.npm.config.set('dry-run', true)
    return this.npm.exec('dedupe', [])
  }
}

module.exports = FindDupes
                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/npm/lib/commands/fund.js                                                           0000664 0000000 0000000 00000014722 14746647661 0020151 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const archy = require('archy')
const pacote = require('pacote')
const semver = require('semver')
const { output } = require('proc-log')
const npa = require('npm-package-arg')
const { depth } = require('treeverse')
const { readTree: getFundingInfo, normalizeFunding, isValidFunding } = require('libnpmfund')
const { openUrl } = require('../utils/open-url.js')
const ArboristWorkspaceCmd = require('../arborist-cmd.js')

const getPrintableName = ({ name, version }) => {
  const printableVersion = version ? `@${version}` : ''
  return `${name}${printableVersion}`
}

const errCode = (msg, code) => Object.assign(new Error(msg), { code })

class Fund extends ArboristWorkspaceCmd {
  static description = 'Retrieve funding information'
  static name = 'fund'
  static params = ['json', 'browser', 'unicode', 'workspace', 'which']
  static usage = ['[<package-spec>]']

  // XXX: maybe worth making this generic for all commands?
  usageMessage (paramsObj = {}) {
    let msg = `\`npm ${this.constructor.name}`
    const params = Object.entries(paramsObj)
    if (params.length) {
      msg += ` ${this.constructor.usage}`
    }
    for (const [key, value] of params) {
      msg += ` --${key}=${value}`
    }
    return `${msg}\``
  }

  // TODO
  /* istanbul ignore next */
  static async completion (opts, npm) {
    const completion = require('../utils/installed-deep.js')
    return completion(npm, opts)
  }

  async exec (args) {
    const spec = args[0]

    let fundingSourceNumber = this.npm.config.get('which')
    if (fundingSourceNumber != null) {
      fundingSourceNumber = parseInt(fundingSourceNumber, 10)
      if (isNaN(fundingSourceNumber) || fundingSourceNumber < 1) {
        throw errCode(
          `${this.usageMessage({ which: 'fundingSourceNumber' })} must be given a positive integer`,
          'EFUNDNUMBER'
        )
      }
    }

    if (this.npm.global) {
      throw errCode(
        `${this.usageMessage()} does not support global packages`,
        'EFUNDGLOBAL'
      )
    }

    const where = this.npm.prefix
    const Arborist = require('@npmcli/arborist')
    const arb = new Arborist({ ...this.npm.flatOptions, path: where })
    const tree = await arb.loadActual()

    if (spec) {
      await this.openFundingUrl({
        path: where,
        tree,
        spec,
        fundingSourceNumber,
      })
      return
    }

    // TODO: add !workspacesEnabled option handling to libnpmfund
    const fundingInfo = getFundingInfo(tree, {
      ...this.flatOptions,
      Arborist,
      workspaces: this.workspaceNames,
    })

    if (this.npm.config.get('json')) {
      output.buffer(fundingInfo)
    } else {
      output.standard(this.printHuman(fundingInfo))
    }
  }

  printHuman (fundingInfo) {
    const unicode = this.npm.config.get('unicode')
    const seenUrls = new Map()

    const tree = obj => archy(obj, '', { unicode })

    const result = depth({
      tree: fundingInfo,

      // composes human readable package name
      // and creates a new archy item for readable output
      visit: ({ name, version, funding }) => {
        const [fundingSource] = [].concat(normalizeFunding(funding)).filter(isValidFunding)
        const { url } = fundingSource || {}
        const pkgRef = getPrintableName({ name, version })

        if (!url) {
          return { label: pkgRef }
        }
        let item
        if (seenUrls.has(url)) {
          item = seenUrls.get(url)
          item.label += `${this.npm.chalk.dim(',')} ${pkgRef}`
          return null
        }
        item = {
          label: tree({
            label: this.npm.chalk.blue(url),
            nodes: [pkgRef],
          }).trim(),
        }

        // stacks all packages together under the same item
        seenUrls.set(url, item)
        return item
      },

      // puts child nodes back into returned archy
      // output while also filtering out missing items
      leave: (item, children) => {
        if (item) {
          item.nodes = children.filter(Boolean)
        }

        return item
      },

      // turns tree-like object return by libnpmfund
      // into children to be properly read by treeverse
      getChildren: node =>
        Object.keys(node.dependencies || {}).map(key => ({
          name: key,
          ...node.dependencies[key],
        })),
    })

    const res = tree(result)
    return res
  }

  async openFundingUrl ({ path, tree, spec, fundingSourceNumber }) {
    const arg = npa(spec, path)

    const retrievePackageMetadata = () => {
      if (arg.type === 'directory') {
        if (tree.path === arg.fetchSpec) {
          // matches cwd, e.g: npm fund .
          return tree.package
        } else {
          // matches any file path within current arborist inventory
          for (const item of tree.inventory.values()) {
            if (item.path === arg.fetchSpec) {
              return item.package
            }
          }
        }
      } else {
        // tries to retrieve a package from arborist inventory
        // by matching resulted package name from the provided spec
        const [item] = [...tree.inventory.query('name', arg.name)]
          .filter(i => semver.valid(i.package.version))
          .sort((a, b) => semver.rcompare(a.package.version, b.package.version))

        if (item) {
          return item.package
        }
      }
    }

    const { funding } =
      retrievePackageMetadata() ||
      (await pacote.manifest(arg, this.npm.flatOptions).catch(() => ({})))

    const validSources = [].concat(normalizeFunding(funding)).filter(isValidFunding)

    if (!validSources.length) {
      throw errCode(`No valid funding method available for: ${spec}`, 'ENOFUND')
    }

    const fundSource = fundingSourceNumber
      ? validSources[fundingSourceNumber - 1]
      : validSources.length === 1 ? validSources[0]
      : null

    if (fundSource) {
      return openUrl(this.npm, ...this.urlMessage(fundSource))
    }

    const ambiguousUrlMsg = [
      ...validSources.map((s, i) => `${i + 1}: ${this.urlMessage(s).reverse().join(': ')}`),
      `Run ${this.usageMessage({ which: '1' })}` +
      ', for example, to open the first funding URL listed in that package',
    ]
    if (fundingSourceNumber) {
      ambiguousUrlMsg.unshift(`--which=${fundingSourceNumber} is not a valid index`)
    }
    output.standard(ambiguousUrlMsg.join('\n'))
  }

  urlMessage (source) {
    const { type, url } = source
    const typePrefix = type ? `${type} funding` : 'Funding'
    const message = `${typePrefix} available at the following URL`
    return [url, message]
  }
}

module.exports = Fund
                                              node-23.7.0/deps/npm/lib/commands/get.js                                                            0000664 0000000 0000000 00000001101 14746647661 0017757 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const Npm = require('../npm.js')
const BaseCommand = require('../base-cmd.js')

class Get extends BaseCommand {
  static description = 'Get a value from the npm configuration'
  static name = 'get'
  static usage = ['[<key> ...] (See `npm config`)']
  static params = ['long']
  static ignoreImplicitWorkspace = false

  // TODO
  /* istanbul ignore next */
  static async completion (opts) {
    const Config = Npm.cmd('config')
    return Config.completion(opts)
  }

  async exec (args) {
    return this.npm.exec('config', ['get'].concat(args))
  }
}

module.exports = Get
                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/npm/lib/commands/help-search.js                                                    0000664 0000000 0000000 00000013022 14746647661 0021400 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { readFile } = require('node:fs/promises')
const path = require('node:path')
const { glob } = require('glob')
const { output } = require('proc-log')
const BaseCommand = require('../base-cmd.js')

const globify = pattern => pattern.split('\\').join('/')

class HelpSearch extends BaseCommand {
  static description = 'Search npm help documentation'
  static name = 'help-search'
  static usage = ['<text>']
  static params = ['long']

  async exec (args) {
    if (!args.length) {
      throw this.usageError()
    }

    const docPath = path.resolve(this.npm.npmRoot, 'docs/content')
    let files = await glob(`${globify(docPath)}/*/*.md`)
    // preserve glob@8 behavior
    files = files.sort((a, b) => a.localeCompare(b, 'en'))
    const data = await this.readFiles(files)
    const results = await this.searchFiles(args, data)
    const formatted = this.formatResults(args, results)
    if (!formatted.trim()) {
      output.standard(`No matches in help for: ${args.join(' ')}\n`)
    } else {
      output.standard(formatted)
    }
  }

  async readFiles (files) {
    const res = {}
    await Promise.all(files.map(async file => {
      res[file] = (await readFile(file, 'utf8'))
        .replace(/^---\n(.*\n)*?---\n/, '').trim()
    }))
    return res
  }

  async searchFiles (args, data) {
    const results = []
    for (const [file, content] of Object.entries(data)) {
      const lowerCase = content.toLowerCase()
      // skip if no matches at all
      if (!args.some(a => lowerCase.includes(a.toLowerCase()))) {
        continue
      }

      const lines = content.split(/\n+/)

      // if a line has a search term, then skip it and the next line.
      // if the next line has a search term, then skip all 3
      // otherwise, set the line to null.  then remove the nulls.
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i]
        const nextLine = lines[i + 1]
        let match = false
        if (nextLine) {
          match = args.some(a =>
            nextLine.toLowerCase().includes(a.toLowerCase()))
          if (match) {
            // skip over the next line, and the line after it.
            i += 2
            continue
          }
        }

        match = args.some(a => line.toLowerCase().includes(a.toLowerCase()))

        if (match) {
          // skip over the next line
          i++
          continue
        }

        lines[i] = null
      }

      // now squish any string of nulls into a single null
      const pruned = lines.reduce((l, r) => {
        if (!(r === null && l[l.length - 1] === null)) {
          l.push(r)
        }

        return l
      }, [])

      if (pruned[pruned.length - 1] === null) {
        pruned.pop()
      }

      if (pruned[0] === null) {
        pruned.shift()
      }

      // now count how many args were found
      const found = {}
      let totalHits = 0
      for (const line of pruned) {
        for (const arg of args) {
          const hit = (line || '').toLowerCase()
            .split(arg.toLowerCase()).length - 1

          if (hit > 0) {
            found[arg] = (found[arg] || 0) + hit
            totalHits += hit
          }
        }
      }

      const cmd = 'npm help ' +
        path.basename(file, '.md').replace(/^npm-/, '')
      results.push({
        file,
        cmd,
        lines: pruned,
        found: Object.keys(found),
        hits: found,
        totalHits,
      })
    }

    // sort results by number of results found, then by number of hits
    // then by number of matching lines

    // coverage is ignored here because the contents of results are
    // nondeterministic due to either glob or readFiles or Object.entries
    return results.sort(/* istanbul ignore next */ (a, b) =>
      a.found.length > b.found.length ? -1
      : a.found.length < b.found.length ? 1
      : a.totalHits > b.totalHits ? -1
      : a.totalHits < b.totalHits ? 1
      : a.lines.length > b.lines.length ? -1
      : a.lines.length < b.lines.length ? 1
      : 0).slice(0, 10)
  }

  formatResults (args, results) {
    const cols = Math.min(process.stdout.columns || Infinity, 80) + 1

    const formattedOutput = results.map(res => {
      const out = [res.cmd]
      const r = Object.keys(res.hits)
        .map(k => `${k}:${res.hits[k]}`)
        .sort((a, b) => a > b ? 1 : -1)
        .join(' ')

      out.push(' '.repeat((Math.max(1, cols - out.join(' ').length - r.length - 1))))
      out.push(r)

      if (!this.npm.config.get('long')) {
        return out.join('')
      }

      out.unshift('\n\n')
      out.push('\n')
      out.push('-'.repeat(cols - 1) + '\n')
      res.lines.forEach((line, i) => {
        if (line === null || i > 3) {
          return
        }

        const hilitLine = []
        for (const arg of args) {
          const finder = line.toLowerCase().split(arg.toLowerCase())
          let p = 0
          for (const f of finder) {
            hilitLine.push(line.slice(p, p + f.length))
            const word = line.slice(p + f.length, p + f.length + arg.length)
            hilitLine.push(this.npm.chalk.blue(word))
            p += f.length + arg.length
          }
        }
        out.push(hilitLine.join('') + '\n')
      })

      return out.join('')
    }).join('\n')

    const finalOut = results.length && !this.npm.config.get('long')
      ? 'Top hits for ' + (args.map(JSON.stringify).join(' ')) + '\n' +
      '—'.repeat(cols - 1) + '\n' +
      formattedOutput + '\n' +
      '—'.repeat(cols - 1) + '\n' +
      '(run with -l or --long to see more context)'
      : formattedOutput

    return finalOut.trim()
  }
}

module.exports = HelpSearch
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/npm/lib/commands/help.js                                                           0000664 0000000 0000000 00000007250 14746647661 0020143 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const spawn = require('@npmcli/promise-spawn')
const path = require('node:path')
const { openUrl } = require('../utils/open-url.js')
const { glob } = require('glob')
const { output, input } = require('proc-log')
const localeCompare = require('@isaacs/string-locale-compare')('en')
const { deref } = require('../utils/cmd-list.js')
const BaseCommand = require('../base-cmd.js')

const globify = pattern => pattern.split('\\').join('/')

// Strips out the number from foo.7 or foo.7. or foo.7.tgz
// We don't currently compress our man pages but if we ever did this would
// seamlessly continue supporting it
const manNumberRegex = /\.(\d+)(\.[^/\\]*)?$/
// hardcoded names for mansections
// XXX: these are used in the docs workspace and should be exported
// from npm so section names can changed more easily
const manSectionNames = {
  1: 'commands',
  5: 'configuring-npm',
  7: 'using-npm',
}

class Help extends BaseCommand {
  static description = 'Get help on npm'
  static name = 'help'
  static usage = ['<term> [<terms..>]']
  static params = ['viewer']

  static async completion (opts, npm) {
    if (opts.conf.argv.remain.length > 2) {
      return []
    }
    const g = path.resolve(npm.npmRoot, 'man/man[0-9]/*.[0-9]')
    let files = await glob(globify(g))
    // preserve glob@8 behavior
    files = files.sort((a, b) => a.localeCompare(b, 'en'))

    return Object.keys(files.reduce(function (acc, file) {
      file = path.basename(file).replace(/\.[0-9]+$/, '')
      file = file.replace(/^npm-/, '')
      acc[file] = true
      return acc
    }, { help: true }))
  }

  async exec (args) {
    // By default we search all of our man subdirectories, but if the user has
    // asked for a specific one we limit the search to just there
    const manSearch = /^\d+$/.test(args[0]) ? `man${args.shift()}` : 'man*'

    if (!args.length) {
      return output.standard(this.npm.usage)
    }

    // npm help foo bar baz: search topics
    if (args.length > 1) {
      return this.helpSearch(args)
    }

    // `npm help package.json`
    const arg = (deref(args[0]) || args[0]).replace('.json', '-json')

    // find either section.n or npm-section.n
    const f = globify(path.resolve(this.npm.npmRoot, `man/${manSearch}/?(npm-)${arg}.[0-9]*`))

    const [man] = await glob(f).then(r => r.sort((a, b) => {
      // Because the glob is (subtly) different from manNumberRegex,
      // we can't rely on it passing.
      const aManNumberMatch = a.match(manNumberRegex)?.[1] || 999
      const bManNumberMatch = b.match(manNumberRegex)?.[1] || 999
      if (aManNumberMatch !== bManNumberMatch) {
        return aManNumberMatch - bManNumberMatch
      }
      return localeCompare(a, b)
    }))

    return man ? this.viewMan(man) : this.helpSearch(args)
  }

  helpSearch (args) {
    return this.npm.exec('help-search', args)
  }

  async viewMan (man) {
    const viewer = this.npm.config.get('viewer')

    if (viewer === 'browser') {
      return openUrl(this.npm, this.htmlMan(man), 'help available at the following URL', true)
    }

    let args = ['man', [man]]
    if (viewer === 'woman') {
      args = ['emacsclient', ['-e', `(woman-find-file '${man}')`]]
    }

    try {
      await input.start(() => spawn(...args, { stdio: 'inherit' }))
    } catch (err) {
      if (err.code) {
        throw new Error(`help process exited with code: ${err.code}`)
      } else {
        throw err
      }
    }
  }

  // Returns the path to the html version of the man page
  htmlMan (man) {
    const sect = manSectionNames[man.match(manNumberRegex)[1]]
    const f = path.basename(man).replace(manNumberRegex, '')
    return 'file:///' + path.resolve(this.npm.npmRoot, `docs/output/${sect}/${f}.html`)
  }
}

module.exports = Help
                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/npm/lib/commands/hook.js                                                           0000664 0000000 0000000 00000006575 14746647661 0020164 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const hookApi = require('libnpmhook')
const { otplease } = require('../utils/auth.js')
const relativeDate = require('tiny-relative-date')
const { output } = require('proc-log')
const BaseCommand = require('../base-cmd.js')

class Hook extends BaseCommand {
  static description = 'Manage registry hooks'
  static name = 'hook'
  static params = [
    'registry',
    'otp',
  ]

  static usage = [
    'add <pkg> <url> <secret> [--type=<type>]',
    'ls [pkg]',
    'rm <id>',
    'update <id> <url> <secret>',
  ]

  async exec (args) {
    return otplease(this.npm, { ...this.npm.flatOptions }, (opts) => {
      switch (args[0]) {
        case 'add':
          return this.add(args[1], args[2], args[3], opts)
        case 'ls':
          return this.ls(args[1], opts)
        case 'rm':
          return this.rm(args[1], opts)
        case 'update':
        case 'up':
          return this.update(args[1], args[2], args[3], opts)
        default:
          throw this.usageError()
      }
    })
  }

  async add (pkg, uri, secret, opts) {
    const hook = await hookApi.add(pkg, uri, secret, opts)
    if (opts.json) {
      output.buffer(hook)
    } else if (opts.parseable) {
      output.standard(Object.keys(hook).join('\t'))
      output.standard(Object.keys(hook).map(k => hook[k]).join('\t'))
    } else if (!this.npm.silent) {
      output.standard(`+ ${this.hookName(hook)} ${opts.unicode ? ' ➜ ' : ' -> '} ${hook.endpoint}`)
    }
  }

  async ls (pkg, opts) {
    const hooks = await hookApi.ls({ ...opts, package: pkg })

    if (opts.json) {
      output.buffer(hooks)
    } else if (opts.parseable) {
      output.standard(Object.keys(hooks[0]).join('\t'))
      hooks.forEach(hook => {
        output.standard(Object.keys(hook).map(k => hook[k]).join('\t'))
      })
    } else if (!hooks.length) {
      output.standard("You don't have any hooks configured yet.")
    } else if (!this.npm.silent) {
      output.standard(`You have ${hooks.length} hook${hooks.length !== 1 ? 's' : ''} configured.`)

      for (const hook of hooks) {
        output.standard(`Hook ${hook.id}: ${this.hookName(hook)}`)
        output.standard(`Endpoint: ${hook.endpoint}`)
        if (hook.last_delivery) {
          /* eslint-disable-next-line max-len */
          output.standard(`Triggered ${relativeDate(hook.last_delivery)}, response code was "${hook.response_code}"\n`)
        } else {
          output.standard('Never triggered\n')
        }
      }
    }
  }

  async rm (id, opts) {
    const hook = await hookApi.rm(id, opts)
    if (opts.json) {
      output.buffer(hook)
    } else if (opts.parseable) {
      output.standard(Object.keys(hook).join('\t'))
      output.standard(Object.keys(hook).map(k => hook[k]).join('\t'))
    } else if (!this.npm.silent) {
      output.standard(`- ${this.hookName(hook)} ${opts.unicode ? ' ✘ ' : ' X '} ${hook.endpoint}`)
    }
  }

  async update (id, uri, secret, opts) {
    const hook = await hookApi.update(id, uri, secret, opts)
    if (opts.json) {
      output.buffer(hook)
    } else if (opts.parseable) {
      output.standard(Object.keys(hook).join('\t'))
      output.standard(Object.keys(hook).map(k => hook[k]).join('\t'))
    } else if (!this.npm.silent) {
      output.standard(`+ ${this.hookName(hook)} ${opts.unicode ? ' ➜ ' : ' -> '} ${hook.endpoint}`)
    }
  }

  hookName (hook) {
    return `${hook.type === 'owner' ? '~' : ''}${hook.name}`
  }
}

module.exports = Hook
                                                                                                                                   node-23.7.0/deps/npm/lib/commands/init.js                                                           0000664 0000000 0000000 00000015552 14746647661 0020162 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { statSync } = require('node:fs')
const { relative, resolve } = require('node:path')
const { mkdir } = require('node:fs/promises')
const initJson = require('init-package-json')
const npa = require('npm-package-arg')
const libexec = require('libnpmexec')
const mapWorkspaces = require('@npmcli/map-workspaces')
const PackageJson = require('@npmcli/package-json')
const { log, output, input } = require('proc-log')
const updateWorkspaces = require('../utils/update-workspaces.js')
const BaseCommand = require('../base-cmd.js')

const posixPath = p => p.split('\\').join('/')

class Init extends BaseCommand {
  static description = 'Create a package.json file'
  static params = [
    'init-author-name',
    'init-author-url',
    'init-license',
    'init-module',
    'init-version',
    'yes',
    'force',
    'scope',
    'workspace',
    'workspaces',
    'workspaces-update',
    'include-workspace-root',
  ]

  static name = 'init'
  static usage = [
    '<package-spec> (same as `npx create-<package-spec>`)',
    '<@scope> (same as `npx <@scope>/create`)',
  ]

  static workspaces = true
  static ignoreImplicitWorkspace = false

  async exec (args) {
    // npm exec style
    if (args.length) {
      return await this.execCreate(args)
    }

    // no args, uses classic init-package-json boilerplate
    await this.template()
  }

  async execWorkspaces (args) {
    // if the root package is uninitiated, take care of it first
    if (this.npm.flatOptions.includeWorkspaceRoot) {
      await this.exec(args)
    }

    // reads package.json for the top-level folder first, by doing this we
    // ensure the command throw if no package.json is found before trying
    // to create a workspace package.json file or its folders
    const { content: pkg } = await PackageJson.normalize(this.npm.localPrefix).catch(err => {
      if (err.code === 'ENOENT') {
        log.warn('init', 'Missing package.json. Try with `--include-workspace-root`.')
      }
      throw err
    })

    // these are workspaces that are being created, so we cant use
    // this.setWorkspaces()
    const filters = this.npm.config.get('workspace')
    const wPath = filterArg => resolve(this.npm.localPrefix, filterArg)

    const workspacesPaths = []
    // npm-exec style, runs in the context of each workspace filter
    if (args.length) {
      for (const filterArg of filters) {
        const path = wPath(filterArg)
        await mkdir(path, { recursive: true })
        workspacesPaths.push(path)
        await this.execCreate(args, path)
        await this.setWorkspace(pkg, path)
      }
      return
    }

    // no args, uses classic init-package-json boilerplate
    for (const filterArg of filters) {
      const path = wPath(filterArg)
      await mkdir(path, { recursive: true })
      workspacesPaths.push(path)
      await this.template(path)
      await this.setWorkspace(pkg, path)
    }

    // reify packages once all workspaces have been initialized
    await this.update(workspacesPaths)
  }

  async execCreate (args, runPath = process.cwd()) {
    const [initerName, ...otherArgs] = args
    let packageName = initerName

    // Only a scope, possibly with a version
    if (/^@[^/]+$/.test(initerName)) {
      const [, scope, version] = initerName.split('@')
      packageName = `@${scope}/create`
      if (version) {
        packageName = `${packageName}@${version}`
      }
    } else {
      const req = npa(initerName)
      if (req.type === 'git' && req.hosted) {
        const { user, project } = req.hosted
        packageName = initerName.replace(`${user}/${project}`, `${user}/create-${project}`)
      } else if (req.registry) {
        packageName = `${req.name.replace(/^(@[^/]+\/)?/, '$1create-')}@${req.rawSpec}`
      } else {
        throw Object.assign(new Error(
          'Unrecognized initializer: ' + initerName +
          '\nFor more package binary executing power check out `npx`:' +
          '\nhttps://docs.npmjs.com/cli/commands/npx'
        ), { code: 'EUNSUPPORTED' })
      }
    }

    const newArgs = [packageName, ...otherArgs]
    const {
      flatOptions,
      localBin,
      globalBin,
      chalk,
    } = this.npm
    const scriptShell = this.npm.config.get('script-shell') || undefined
    const yes = this.npm.config.get('yes')

    await libexec({
      ...flatOptions,
      args: newArgs,
      localBin,
      globalBin,
      output,
      chalk,
      path: this.npm.localPrefix,
      runPath,
      scriptShell,
      yes,
    })
  }

  async template (path = process.cwd()) {
    const initFile = this.npm.config.get('init-module')
    if (!this.npm.config.get('yes') && !this.npm.config.get('force')) {
      output.standard([
        'This utility will walk you through creating a package.json file.',
        'It only covers the most common items, and tries to guess sensible defaults.',
        '',
        'See `npm help init` for definitive documentation on these fields',
        'and exactly what they do.',
        '',
        'Use `npm install <pkg>` afterwards to install a package and',
        'save it as a dependency in the package.json file.',
        '',
        'Press ^C at any time to quit.',
      ].join('\n'))
    }

    try {
      const data = await input.read(() => initJson(path, initFile, this.npm.config))
      log.silly('package data', data)
      return data
    } catch (er) {
      if (er.message === 'canceled') {
        log.warn('init', 'canceled')
      } else {
        throw er
      }
    }
  }

  async setWorkspace (pkg, workspacePath) {
    const workspaces = await mapWorkspaces({ cwd: this.npm.localPrefix, pkg })

    // skip setting workspace if current package.json glob already satisfies it
    for (const wPath of workspaces.values()) {
      if (wPath === workspacePath) {
        return
      }
    }

    // if a create-pkg didn't generate a package.json at the workspace
    // folder level, it might not be recognized as a workspace by
    // mapWorkspaces, so we're just going to avoid touching the
    // top-level package.json
    try {
      statSync(resolve(workspacePath, 'package.json'))
    } catch (err) {
      return
    }

    const pkgJson = await PackageJson.load(this.npm.localPrefix)

    pkgJson.update({
      workspaces: [
        ...(pkgJson.content.workspaces || []),
        posixPath(relative(this.npm.localPrefix, workspacePath)),
      ],
    })

    await pkgJson.save()
  }

  async update (workspacesPaths) {
    // translate workspaces paths into an array containing workspaces names
    const workspaces = []
    for (const path of workspacesPaths) {
      const { content: { name } } = await PackageJson.normalize(path).catch(() => ({ content: {} }))

      if (name) {
        workspaces.push(name)
      }
    }

    const {
      config,
      flatOptions,
      localPrefix,
    } = this.npm

    await updateWorkspaces({
      config,
      flatOptions,
      localPrefix,
      npm: this.npm,
      workspaces,
    })
  }
}

module.exports = Init
                                                                                                                                                      node-23.7.0/deps/npm/lib/commands/install-ci-test.js                                                0000664 0000000 0000000 00000000565 14746647661 0022231 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const CI = require('./ci.js')

// npm install-ci-test
// Runs `npm ci` and then runs `npm test`
class InstallCITest extends CI {
  static description = 'Install a project with a clean slate and run tests'
  static name = 'install-ci-test'

  async exec (args) {
    await this.npm.exec('ci', args)
    return this.npm.exec('test', [])
  }
}

module.exports = InstallCITest
                                                                                                                                           node-23.7.0/deps/npm/lib/commands/install-test.js                                                   0000664 0000000 0000000 00000000562 14746647661 0021635 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const Install = require('./install.js')

// npm install-test
// Runs `npm install` and then runs `npm test`
class InstallTest extends Install {
  static description = 'Install package(s) and run tests'
  static name = 'install-test'

  async exec (args) {
    await this.npm.exec('install', args)
    return this.npm.exec('test', [])
  }
}

module.exports = InstallTest
                                                                                                                                              node-23.7.0/deps/npm/lib/commands/install.js                                                        0000664 0000000 0000000 00000012235 14746647661 0020660 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { readdir } = require('node:fs/promises')
const { resolve, join } = require('node:path')
const { log } = require('proc-log')
const runScript = require('@npmcli/run-script')
const pacote = require('pacote')
const checks = require('npm-install-checks')
const reifyFinish = require('../utils/reify-finish.js')
const ArboristWorkspaceCmd = require('../arborist-cmd.js')

class Install extends ArboristWorkspaceCmd {
  static description = 'Install a package'
  static name = 'install'

  // These are in the order they will show up in when running "-h"
  // If adding to this list, consider adding also to ci.js
  static params = [
    'save',
    'save-exact',
    'global',
    'install-strategy',
    'legacy-bundling',
    'global-style',
    'omit',
    'include',
    'strict-peer-deps',
    'prefer-dedupe',
    'package-lock',
    'package-lock-only',
    'foreground-scripts',
    'ignore-scripts',
    'audit',
    'bin-links',
    'fund',
    'dry-run',
    'cpu',
    'os',
    'libc',
    ...super.params,
  ]

  static usage = ['[<package-spec> ...]']

  static async completion (opts) {
    const { partialWord } = opts
    // install can complete to a folder with a package.json, or any package.
    // if it has a slash, then it's gotta be a folder
    // if it starts with https?://, then just give up, because it's a url
    if (/^https?:\/\//.test(partialWord)) {
      // do not complete to URLs
      return []
    }

    if (/\//.test(partialWord)) {
      // Complete fully to folder if there is exactly one match and it
      // is a folder containing a package.json file.  If that is not the
      // case we return 0 matches, which will trigger the default bash
      // complete.
      const lastSlashIdx = partialWord.lastIndexOf('/')
      const partialName = partialWord.slice(lastSlashIdx + 1)
      const partialPath = partialWord.slice(0, lastSlashIdx) || '/'

      const isDirMatch = async sibling => {
        if (sibling.slice(0, partialName.length) !== partialName) {
          return false
        }

        try {
          const contents = await readdir(join(partialPath, sibling))
          const result = (contents.indexOf('package.json') !== -1)
          return result
        } catch (er) {
          return false
        }
      }

      try {
        const siblings = await readdir(partialPath)
        const matches = []
        for (const sibling of siblings) {
          if (await isDirMatch(sibling)) {
            matches.push(sibling)
          }
        }
        if (matches.length === 1) {
          return [join(partialPath, matches[0])]
        }
        // no matches
        return []
      } catch (er) {
        return [] // invalid dir: no matching
      }
    }
    // Note: there used to be registry completion here,
    // but it stopped making sense somewhere around
    // 50,000 packages on the registry
  }

  async exec (args) {
    // the /path/to/node_modules/..
    const globalTop = resolve(this.npm.globalDir, '..')
    const ignoreScripts = this.npm.config.get('ignore-scripts')
    const isGlobalInstall = this.npm.global
    const where = isGlobalInstall ? globalTop : this.npm.prefix
    const forced = this.npm.config.get('force')
    const scriptShell = this.npm.config.get('script-shell') || undefined

    // be very strict about engines when trying to update npm itself
    const npmInstall = args.find(arg => arg.startsWith('npm@') || arg === 'npm')
    if (isGlobalInstall && npmInstall) {
      const npmOptions = this.npm.flatOptions
      const npmManifest = await pacote.manifest(npmInstall, npmOptions)
      try {
        checks.checkEngine(npmManifest, npmManifest.version, process.version)
      } catch (e) {
        if (forced) {
          log.warn(
            'install',
            /* eslint-disable-next-line max-len */
            `Forcing global npm install with incompatible version ${npmManifest.version} into node ${process.version}`
          )
        } else {
          throw e
        }
      }
    }

    // don't try to install the prefix into itself
    args = args.filter(a => resolve(a) !== this.npm.prefix)

    // `npm i -g` => "install this package globally"
    if (where === globalTop && !args.length) {
      args = ['.']
    }

    // throw usage error if trying to install empty package
    // name to global space, e.g: `npm i -g ""`
    if (where === globalTop && !args.every(Boolean)) {
      throw this.usageError()
    }

    const Arborist = require('@npmcli/arborist')
    const opts = {
      ...this.npm.flatOptions,
      auditLevel: null,
      path: where,
      add: args,
      workspaces: this.workspaceNames,
    }
    const arb = new Arborist(opts)
    await arb.reify(opts)

    if (!args.length && !isGlobalInstall && !ignoreScripts) {
      const scripts = [
        'preinstall',
        'install',
        'postinstall',
        'prepublish', // XXX(npm9) should we remove this finally??
        'preprepare',
        'prepare',
        'postprepare',
      ]
      for (const event of scripts) {
        await runScript({
          path: where,
          args: [],
          scriptShell,
          stdio: 'inherit',
          event,
        })
      }
    }
    await reifyFinish(this.npm, arb)
  }
}

module.exports = Install
                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/npm/lib/commands/link.js                                                           0000664 0000000 0000000 00000012457 14746647661 0020155 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { readdir } = require('node:fs/promises')
const { resolve } = require('node:path')
const npa = require('npm-package-arg')
const pkgJson = require('@npmcli/package-json')
const semver = require('semver')
const reifyFinish = require('../utils/reify-finish.js')
const ArboristWorkspaceCmd = require('../arborist-cmd.js')

class Link extends ArboristWorkspaceCmd {
  static description = 'Symlink a package folder'
  static name = 'link'
  static usage = [
    '[<package-spec>]',
  ]

  static params = [
    'save',
    'save-exact',
    'global',
    'install-strategy',
    'legacy-bundling',
    'global-style',
    'strict-peer-deps',
    'package-lock',
    'omit',
    'include',
    'ignore-scripts',
    'audit',
    'bin-links',
    'fund',
    'dry-run',
    ...super.params,
  ]

  static async completion (opts, npm) {
    const dir = npm.globalDir
    const files = await readdir(dir)
    return files.filter(f => !/^[._-]/.test(f))
  }

  async exec (args) {
    if (this.npm.global) {
      throw Object.assign(
        new Error(
          'link should never be --global.\n' +
          'Please re-run this command with --local'
        ),
        { code: 'ELINKGLOBAL' }
      )
    }
    // install-links is implicitly false when running `npm link`
    this.npm.config.set('install-links', false)

    // link with no args: symlink the folder to the global location
    // link with package arg: symlink the global to the local
    args = args.filter(a => resolve(a) !== this.npm.prefix)
    return args.length
      ? this.linkInstall(args)
      : this.linkPkg()
  }

  async linkInstall (args) {
    // load current packages from the global space,
    // and then add symlinks installs locally
    const globalTop = resolve(this.npm.globalDir, '..')
    const Arborist = require('@npmcli/arborist')
    const globalOpts = {
      ...this.npm.flatOptions,
      Arborist,
      path: globalTop,
      global: true,
      prune: false,
    }
    const globalArb = new Arborist(globalOpts)

    // get only current top-level packages from the global space
    const globals = await globalArb.loadActual({
      filter: (node, kid) =>
        !node.isRoot || args.some(a => npa(a).name === kid),
    })

    // any extra arg that is missing from the current
    // global space should be reified there first
    const missing = this.missingArgsFromTree(globals, args)
    if (missing.length) {
      await globalArb.reify({
        ...globalOpts,
        add: missing,
      })
    }

    // get a list of module names that should be linked in the local prefix
    const names = []
    for (const a of args) {
      const arg = npa(a)
      if (arg.type === 'directory') {
        const { content } = await pkgJson.normalize(arg.fetchSpec)
        names.push(content.name)
      } else {
        names.push(arg.name)
      }
    }

    // npm link should not save=true by default unless you're
    // using any of --save-dev or other types
    const save =
      Boolean(
        (this.npm.config.find('save') !== 'default' &&
        this.npm.config.get('save')) ||
        this.npm.config.get('save-optional') ||
        this.npm.config.get('save-peer') ||
        this.npm.config.get('save-dev') ||
        this.npm.config.get('save-prod')
      )
    // create a new arborist instance for the local prefix and
    // reify all the pending names as symlinks there
    const localArb = new Arborist({
      ...this.npm.flatOptions,
      prune: false,
      path: this.npm.prefix,
      save,
    })
    await localArb.reify({
      ...this.npm.flatOptions,
      prune: false,
      path: this.npm.prefix,
      add: names.map(l => `file:${resolve(globalTop, 'node_modules', l).replace(/#/g, '%23')}`),
      save,
      workspaces: this.workspaceNames,
    })

    await reifyFinish(this.npm, localArb)
  }

  async linkPkg () {
    const wsp = this.workspacePaths
    const paths = wsp && wsp.length ? wsp : [this.npm.prefix]
    const add = paths.map(path => `file:${path.replace(/#/g, '%23')}`)
    const globalTop = resolve(this.npm.globalDir, '..')
    const Arborist = require('@npmcli/arborist')
    const arb = new Arborist({
      ...this.npm.flatOptions,
      Arborist,
      path: globalTop,
      global: true,
    })
    await arb.reify({
      add,
    })
    await reifyFinish(this.npm, arb)
  }

  // Returns a list of items that can't be fulfilled by
  // things found in the current arborist inventory
  missingArgsFromTree (tree, args) {
    if (tree.isLink) {
      return this.missingArgsFromTree(tree.target, args)
    }

    const foundNodes = []
    const missing = args.filter(a => {
      const arg = npa(a)
      const nodes = tree.children.values()
      const argFound = [...nodes].every(node => {
        // TODO: write tests for unmatching version specs, this is hard to test
        // atm but should be simple once we have a mocked registry again
        if (arg.name !== node.name /* istanbul ignore next */ || (
          arg.version &&
          /* istanbul ignore next */
          !semver.satisfies(node.version, arg.version)
        )) {
          foundNodes.push(node)
          return true
        }
      })
      return argFound
    })

    // remote nodes from the loaded tree in order
    // to avoid dropping them later when reifying
    for (const node of foundNodes) {
      node.parent = null
    }

    return missing
  }
}

module.exports = Link
                                                                                                                                                                                                                 node-23.7.0/deps/npm/lib/commands/ll.js                                                             0000664 0000000 0000000 00000000352 14746647661 0017616 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const LS = require('./ls.js')

class LL extends LS {
  static name = 'll'
  static usage = ['[[<@scope>/]<pkg> ...]']

  async exec (args) {
    this.npm.config.set('long', true)
    return super.exec(args)
  }
}

module.exports = LL
                                                                                                                                                                                                                                                                                      node-23.7.0/deps/npm/lib/commands/login.js                                                          0000664 0000000 0000000 00000002446 14746647661 0020325 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { log, output } = require('proc-log')
const { redactLog: replaceInfo } = require('@npmcli/redact')
const auth = require('../utils/auth.js')
const BaseCommand = require('../base-cmd.js')

class Login extends BaseCommand {
  static description = 'Login to a registry user account'
  static name = 'login'
  static params = [
    'registry',
    'scope',
    'auth-type',
  ]

  async exec () {
    const scope = this.npm.config.get('scope')
    let registry = this.npm.config.get('registry')

    if (scope) {
      const scopedRegistry = this.npm.config.get(`${scope}:registry`)
      const cliRegistry = this.npm.config.get('registry', 'cli')
      if (scopedRegistry && !cliRegistry) {
        registry = scopedRegistry
      }
    }

    const creds = this.npm.config.getCredentialsByURI(registry)

    log.notice('', `Log in on ${replaceInfo(registry)}`)

    const { message, newCreds } = await auth.login(this.npm, {
      ...this.npm.flatOptions,
      creds,
      registry,
    })

    this.npm.config.delete('_token', 'user') // prevent legacy pollution
    this.npm.config.setCredentialsByURI(registry, newCreds)

    if (scope) {
      this.npm.config.set(scope + ':registry', registry, 'user')
    }

    await this.npm.config.save('user')

    output.standard(message)
  }
}

module.exports = Login
                                                                                                                                                                                                                          node-23.7.0/deps/npm/lib/commands/logout.js                                                         0000664 0000000 0000000 00000002655 14746647661 0020530 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const npmFetch = require('npm-registry-fetch')
const { getAuth } = npmFetch
const { log } = require('proc-log')
const BaseCommand = require('../base-cmd.js')

class Logout extends BaseCommand {
  static description = 'Log out of the registry'
  static name = 'logout'
  static params = [
    'registry',
    'scope',
  ]

  async exec () {
    const registry = this.npm.config.get('registry')
    const scope = this.npm.config.get('scope')
    const regRef = scope ? `${scope}:registry` : 'registry'
    const reg = this.npm.config.get(regRef) || registry

    const auth = getAuth(reg, this.npm.flatOptions)

    const level = this.npm.config.find(`${auth.regKey}:${auth.authKey}`)

    // find the config level and only delete from there
    if (auth.token) {
      log.verbose('logout', `clearing token for ${reg}`)
      await npmFetch(`/-/user/token/${encodeURIComponent(auth.token)}`, {
        ...this.npm.flatOptions,
        registry: reg,
        method: 'DELETE',
        ignoreBody: true,
      })
    } else if (auth.isBasicAuth) {
      log.verbose('logout', `clearing user credentials for ${reg}`)
    } else {
      const msg = `not logged in to ${reg}, so can't log out!`
      throw Object.assign(new Error(msg), { code: 'ENEEDAUTH' })
    }

    if (scope) {
      this.npm.config.delete(regRef, level)
    }

    this.npm.config.clearCredentialsByURI(reg, level)

    await this.npm.config.save(level)
  }
}

module.exports = Logout
                                                                                   node-23.7.0/deps/npm/lib/commands/ls.js                                                             0000664 0000000 0000000 00000041476 14746647661 0017641 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { resolve, relative, sep } = require('node:path')
const archy = require('archy')
const { breadth } = require('treeverse')
const npa = require('npm-package-arg')
const { output } = require('proc-log')
const ArboristWorkspaceCmd = require('../arborist-cmd.js')
const localeCompare = require('@isaacs/string-locale-compare')('en')

const relativePrefix = `.${sep}`

const _depth = Symbol('depth')
const _dedupe = Symbol('dedupe')
const _filteredBy = Symbol('filteredBy')
const _include = Symbol('include')
const _invalid = Symbol('invalid')
const _name = Symbol('name')
const _missing = Symbol('missing')
const _parent = Symbol('parent')
const _problems = Symbol('problems')
const _required = Symbol('required')
const _type = Symbol('type')

class LS extends ArboristWorkspaceCmd {
  static description = 'List installed packages'
  static name = 'ls'
  static usage = ['<package-spec>']
  static params = [
    'all',
    'json',
    'long',
    'parseable',
    'global',
    'depth',
    'omit',
    'include',
    'link',
    'package-lock-only',
    'unicode',
    ...super.params,
  ]

  // TODO
  /* istanbul ignore next */
  static async completion (opts, npm) {
    const completion = require('../utils/installed-deep.js')
    return completion(npm, opts)
  }

  async exec (args) {
    const all = this.npm.config.get('all')
    const chalk = this.npm.chalk
    const depth = this.npm.config.get('depth')
    const global = this.npm.global
    const json = this.npm.config.get('json')
    const link = this.npm.config.get('link')
    const long = this.npm.config.get('long')
    const omit = this.npm.flatOptions.omit
    const parseable = this.npm.config.get('parseable')
    const unicode = this.npm.config.get('unicode')
    const packageLockOnly = this.npm.config.get('package-lock-only')
    const workspacesEnabled = this.npm.flatOptions.workspacesEnabled

    const path = global ? resolve(this.npm.globalDir, '..') : this.npm.prefix

    const Arborist = require('@npmcli/arborist')

    const arb = new Arborist({
      global,
      ...this.npm.flatOptions,
      legacyPeerDeps: false,
      path,
    })
    const tree = await this.initTree({ arb, args, packageLockOnly })

    // filters by workspaces nodes when using -w <workspace-name>
    // We only have to filter the first layer of edges, so we don't
    // explore anything that isn't part of the selected workspace set.
    let wsNodes
    if (this.workspaceNames && this.workspaceNames.length) {
      wsNodes = arb.workspaceNodes(tree, this.workspaceNames)
    }
    const filterBySelectedWorkspaces = edge => {
      if (!workspacesEnabled
        && edge.from.isProjectRoot
        && edge.to.isWorkspace
      ) {
        return false
      }

      if (!wsNodes || !wsNodes.length) {
        return true
      }

      if (this.npm.flatOptions.includeWorkspaceRoot
          && edge.to && !edge.to.isWorkspace) {
        return true
      }

      if (edge.from.isProjectRoot) {
        return (edge.to
          && edge.to.isWorkspace
          && wsNodes.includes(edge.to.target))
      }

      return true
    }

    const seenItems = new Set()
    const seenNodes = new Map()
    const problems = new Set()

    // defines special handling of printed depth when filtering with args
    const filterDefaultDepth = depth === null ? Infinity : depth
    const depthToPrint = (all || args.length)
      ? filterDefaultDepth
      : (depth || 0)

    // add root node of tree to list of seenNodes
    seenNodes.set(tree.path, tree)

    // tree traversal happens here, using treeverse.breadth
    const result = await breadth({
      tree,
      // recursive method, `node` is going to be the current elem (starting from
      // the `tree` obj) that was just visited in the `visit` method below
      // `nodeResult` is going to be the returned `item` from `visit`
      getChildren (node, nodeResult) {
        const seenPaths = new Set()
        const workspace = node.isWorkspace
        const currentDepth = workspace ? 0 : node[_depth]
        const shouldSkipChildren =
          !(node instanceof Arborist.Node) || (currentDepth > depthToPrint)
        return (shouldSkipChildren)
          ? []
          : [...(node.target).edgesOut.values()]
            .filter(filterBySelectedWorkspaces)
            .filter(currentDepth === 0 ? filterByEdgesTypes({
              link,
              omit,
            }) : () => true)
            .map(mapEdgesToNodes({ seenPaths }))
            .concat(appendExtraneousChildren({ node, seenPaths }))
            .sort(sortAlphabetically)
            .map(augmentNodesWithMetadata({
              args,
              currentDepth,
              nodeResult,
              seenNodes,
            }))
      },
      // visit each `node` of the `tree`, returning an `item` - these are
      // the elements that will be used to build the final output
      visit (node) {
        node[_problems] = getProblems(node, { global })

        const item = json
          ? getJsonOutputItem(node, { global, long })
          : parseable
            ? null
            : getHumanOutputItem(node, { args, chalk, global, long })

        // loop through list of node problems to add them to global list
        if (node[_include]) {
          for (const problem of node[_problems]) {
            problems.add(problem)
          }
        }

        seenItems.add(item)

        // return a promise so we don't blow the stack
        return Promise.resolve(item)
      },
    })

    // handle the special case of a broken package.json in the root folder
    const [rootError] = tree.errors.filter(e =>
      e.code === 'EJSONPARSE' && e.path === resolve(path, 'package.json'))

    if (json) {
      output.buffer(jsonOutput({ path, problems, result, rootError, seenItems }))
    } else {
      output.standard(parseable
        ? parseableOutput({ seenNodes, global, long })
        : humanOutput({ chalk, result, seenItems, unicode })
      )
    }

    // if filtering items, should exit with error code on no results
    if (result && !result[_include] && args.length) {
      process.exitCode = 1
    }

    if (rootError) {
      throw Object.assign(
        new Error('Failed to parse root package.json'),
        { code: 'EJSONPARSE' }
      )
    }

    const shouldThrow = problems.size &&
      ![...problems].every(problem => problem.startsWith('extraneous:'))

    if (shouldThrow) {
      throw Object.assign(
        new Error([...problems].join('\n')),
        { code: 'ELSPROBLEMS' }
      )
    }
  }

  async initTree ({ arb, args, packageLockOnly }) {
    const tree = await (
      packageLockOnly
        ? arb.loadVirtual()
        : arb.loadActual()
    )

    tree[_include] = args.length === 0
    tree[_depth] = 0

    return tree
  }
}

module.exports = LS

const isGitNode = (node) => {
  if (!node.resolved) {
    return
  }

  try {
    const { type } = npa(node.resolved)
    return type === 'git' || type === 'hosted'
  } catch (err) {
    return false
  }
}

const isOptional = (node) =>
  node[_type] === 'optional' || node[_type] === 'peerOptional'

const isExtraneous = (node, { global }) =>
  node.extraneous && !global

const getProblems = (node, { global }) => {
  const problems = new Set()

  if (node[_missing] && !isOptional(node)) {
    problems.add(`missing: ${node.pkgid}, required by ${node[_missing]}`)
  }

  if (node[_invalid]) {
    problems.add(`invalid: ${node.pkgid} ${node.path}`)
  }

  if (isExtraneous(node, { global })) {
    problems.add(`extraneous: ${node.pkgid} ${node.path}`)
  }

  return problems
}

// annotates _parent and _include metadata into the resulting
// item obj allowing for filtering out results during output
const augmentItemWithIncludeMetadata = (node, item) => {
  item[_parent] = node[_parent]
  item[_include] = node[_include]

  // append current item to its parent.nodes which is the
  // structure expected by archy in order to print tree
  if (node[_include]) {
    // includes all ancestors of included node
    let p = node[_parent]
    while (p) {
      p[_include] = true
      p = p[_parent]
    }
  }

  return item
}

const getHumanOutputItem = (node, { args, chalk, global, long }) => {
  const { pkgid, path } = node
  const workspacePkgId = chalk.blueBright(pkgid)
  let printable = node.isWorkspace ? workspacePkgId : pkgid

  // special formatting for top-level package name
  if (node.isRoot) {
    const hasNoPackageJson = !Object.keys(node.package).length
    if (hasNoPackageJson || global) {
      printable = path
    } else {
      printable += `${long ? '\n' : ' '}${path}`
    }
  }

  // TODO there is a LOT of overlap with lib/utils/explain-dep.js here

  const highlightDepName = args.length && node[_filteredBy]
  const missingColor = isOptional(node)
    ? chalk.yellow
    : chalk.red
  const missingMsg = `UNMET ${isOptional(node) ? 'OPTIONAL ' : ''}DEPENDENCY`
  const targetLocation = node.root
    ? relative(node.root.realpath, node.realpath)
    : node.targetLocation
  const invalid = node[_invalid]
    ? `invalid: ${node[_invalid]}`
    : ''
  const label =
    (
      node[_missing]
        ? missingColor(missingMsg) + ' '
        : ''
    ) +
    `${highlightDepName ? chalk.yellow(printable) : printable}` +
    (
      node[_dedupe]
        ? ' ' + chalk.dim('deduped')
        : ''
    ) +
    (
      invalid
        ? ' ' + chalk.red(invalid)
        : ''
    ) +
    (
      isExtraneous(node, { global })
        ? ' ' + chalk.red('extraneous')
        : ''
    ) +
    (
      node.overridden
        ? ' ' + chalk.dim('overridden')
        : ''
    ) +
    (isGitNode(node) ? ` (${node.resolved})` : '') +
    (node.isLink ? ` -> ${relativePrefix}${targetLocation}` : '') +
    (long ? `\n${node.package.description || ''}` : '')

  return augmentItemWithIncludeMetadata(node, { label, nodes: [] })
}

const getJsonOutputItem = (node, { global, long }) => {
  const item = {}

  if (node.version) {
    item.version = node.version
  }

  if (node.resolved) {
    item.resolved = node.resolved
  }

  // if the node is the project root, do not add the overridden flag. the project root can't be
  // overridden anyway, and if we add the flag it causes undesirable behavior when `npm ls --json`
  // is ran in an empty directory since we end up printing an object with only an overridden prop
  if (!node.isProjectRoot) {
    item.overridden = node.overridden
  }

  item[_name] = node.name

  // special formatting for top-level package name
  const hasPackageJson =
    node && node.package && Object.keys(node.package).length
  if (node.isRoot && hasPackageJson) {
    item.name = node.package.name || node.name
  }

  if (long && !node[_missing]) {
    item.name = item[_name]
    const { dependencies, ...packageInfo } = node.package
    Object.assign(item, packageInfo)
    item.extraneous = false
    item.path = node.path
    item._dependencies = {
      ...node.package.dependencies,
      ...node.package.optionalDependencies,
    }
    item.devDependencies = node.package.devDependencies || {}
    item.peerDependencies = node.package.peerDependencies || {}
  }

  // augment json output items with extra metadata
  if (isExtraneous(node, { global })) {
    item.extraneous = true
  }

  if (node[_invalid]) {
    item.invalid = node[_invalid]
  }

  if (node[_missing] && !isOptional(node)) {
    item.required = node[_required]
    item.missing = true
  }
  if (node[_include] && node[_problems] && node[_problems].size) {
    item.problems = [...node[_problems]]
  }

  return augmentItemWithIncludeMetadata(node, item)
}

const filterByEdgesTypes = ({ link, omit }) => (edge) => {
  for (const omitType of omit) {
    if (edge[omitType]) {
      return false
    }
  }
  return link ? edge.to && edge.to.isLink : true
}

const appendExtraneousChildren = ({ node, seenPaths }) =>
  // extraneous children are not represented
  // in edges out, so here we add them to the list:
  [...node.children.values()]
    .filter(i => !seenPaths.has(i.path) && i.extraneous)

const mapEdgesToNodes = ({ seenPaths }) => (edge) => {
  let node = edge.to

  // if the edge is linking to a missing node, we go ahead
  // and create a new obj that will represent the missing node
  if (edge.missing || (edge.optional && !node)) {
    const { name, spec } = edge
    const pkgid = `${name}@${spec}`
    node = { name, pkgid, [_missing]: edge.from.pkgid }
  }

  // keeps track of a set of seen paths to avoid the edge case in which a tree
  // item would appear twice given that it's a children of an extraneous item,
  // so it's marked extraneous but it will ALSO show up in edgesOuts of
  // its parent so it ends up as two diff nodes if we don't track it
  if (node.path) {
    seenPaths.add(node.path)
  }

  node[_required] = edge.spec || '*'
  node[_type] = edge.type

  if (edge.invalid) {
    const spec = JSON.stringify(node[_required])
    const from = edge.from.location || 'the root project'
    node[_invalid] = (node[_invalid] ? node[_invalid] + ', ' : '') +
      (`${spec} from ${from}`)
  }

  return node
}

const filterByPositionalArgs = (args, { node }) =>
  args.length > 0 ? args.some(
    (spec) => (node.satisfies && node.satisfies(spec))
  ) : true

const augmentNodesWithMetadata = ({
  args,
  currentDepth,
  nodeResult,
  seenNodes,
}) => (node) => {
  // if the original edge was a deduped dep, treeverse will fail to
  // revisit that node in tree traversal logic, so we make it so that
  // we have a diff obj for deduped nodes:
  if (seenNodes.has(node.path)) {
    const { realpath, root } = node
    const targetLocation = root ? relative(root.realpath, realpath)
      : node.targetLocation
    node = {
      name: node.name,
      version: node.version,
      pkgid: node.pkgid,
      package: node.package,
      path: node.path,
      isLink: node.isLink,
      realpath: node.realpath,
      targetLocation,
      [_type]: node[_type],
      [_invalid]: node[_invalid],
      [_missing]: node[_missing],
      // if it's missing, it's not deduped, it's just missing
      [_dedupe]: !node[_missing],
    }
  } else {
    // keeps track of already seen nodes in order to check for dedupes
    seenNodes.set(node.path, node)
  }

  // _parent is going to be a ref to a treeverse-visited node (returned from
  // getHumanOutputItem, getJsonOutputItem, etc) so that we have an easy
  // shortcut to place new nodes in their right place during tree traversal
  node[_parent] = nodeResult
  // _include is the property that allow us to filter based on position args
  // e.g: `npm ls foo`, `npm ls simple-output@2`
  // _filteredBy is used to apply extra color info to the item that
  // was used in args in order to filter
  node[_filteredBy] = node[_include] =
    filterByPositionalArgs(args, { node: seenNodes.get(node.path) })
  // _depth keeps track of how many levels deep tree traversal currently is
  // so that we can `npm ls --depth=1`
  node[_depth] = currentDepth + 1

  return node
}

const sortAlphabetically = ({ pkgid: a }, { pkgid: b }) => localeCompare(a, b)

const humanOutput = ({ chalk, result, seenItems, unicode }) => {
  // we need to traverse the entire tree in order to determine which items
  // should be included (since a nested transitive included dep will make it
  // so that all its ancestors should be displayed)
  // here is where we put items in their expected place for archy output
  for (const item of seenItems) {
    if (item[_include] && item[_parent]) {
      item[_parent].nodes.push(item)
    }
  }

  if (!result.nodes.length) {
    result.nodes = ['(empty)']
  }

  const archyOutput = archy(result, '', { unicode })
  return chalk.reset(archyOutput)
}

const jsonOutput = ({ path, problems, result, rootError, seenItems }) => {
  if (problems.size) {
    result.problems = [...problems]
  }

  if (rootError) {
    result.problems = [
      ...(result.problems || []),
      ...[`error in ${path}: Failed to parse root package.json`],
    ]
    result.invalid = true
  }

  // we need to traverse the entire tree in order to determine which items
  // should be included (since a nested transitive included dep will make it
  // so that all its ancestors should be displayed)
  // here is where we put items in their expected place for json output
  for (const item of seenItems) {
    // append current item to its parent item.dependencies obj in order
    // to provide a json object structure that represents the installed tree
    if (item[_include] && item[_parent]) {
      if (!item[_parent].dependencies) {
        item[_parent].dependencies = {}
      }

      item[_parent].dependencies[item[_name]] = item
    }
  }

  return result
}

const parseableOutput = ({ global, long, seenNodes }) => {
  let out = ''
  for (const node of seenNodes.values()) {
    if (node.path && node[_include]) {
      out += node.path
      if (long) {
        out += `:${node.pkgid}`
        out += node.path !== node.realpath ? `:${node.realpath}` : ''
        out += isExtraneous(node, { global }) ? ':EXTRANEOUS' : ''
        out += node[_invalid] ? ':INVALID' : ''
        out += node.overridden ? ':OVERRIDDEN' : ''
      }
      out += '\n'
    }
  }
  return out.trim()
}
                                                                                                                                                                                                  node-23.7.0/deps/npm/lib/commands/org.js                                                            0000664 0000000 0000000 00000010031 14746647661 0017771 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const liborg = require('libnpmorg')
const { otplease } = require('../utils/auth.js')
const BaseCommand = require('../base-cmd.js')
const { output } = require('proc-log')

class Org extends BaseCommand {
  static description = 'Manage orgs'
  static name = 'org'
  static usage = [
    'set orgname username [developer | admin | owner]',
    'rm orgname username',
    'ls orgname [<username>]',
  ]

  static params = ['registry', 'otp', 'json', 'parseable']

  static async completion (opts) {
    const argv = opts.conf.argv.remain
    if (argv.length === 2) {
      return ['set', 'rm', 'ls']
    }

    switch (argv[2]) {
      case 'ls':
      case 'add':
      case 'rm':
      case 'set':
        return []
      default:
        throw new Error(argv[2] + ' not recognized')
    }
  }

  async exec ([cmd, orgname, username, role]) {
    return otplease(this.npm, {
      ...this.npm.flatOptions,
    }, opts => {
      switch (cmd) {
        case 'add':
        case 'set':
          return this.set(orgname, username, role, opts)
        case 'rm':
          return this.rm(orgname, username, opts)
        case 'ls':
          return this.ls(orgname, username, opts)
        default:
          throw this.usageError()
      }
    })
  }

  async set (org, user, role, opts) {
    role = role || 'developer'
    if (!org) {
      throw new Error('First argument `orgname` is required.')
    }

    if (!user) {
      throw new Error('Second argument `username` is required.')
    }

    if (!['owner', 'admin', 'developer'].find(x => x === role)) {
      throw new Error(
        /* eslint-disable-next-line max-len */
        'Third argument `role` must be one of `owner`, `admin`, or `developer`, with `developer` being the default value if omitted.'
      )
    }

    const memDeets = await liborg.set(org, user, role, opts)
    if (opts.json) {
      output.standard(JSON.stringify(memDeets, null, 2))
    } else if (opts.parseable) {
      output.standard(['org', 'orgsize', 'user', 'role'].join('\t'))
      output.standard(
        [memDeets.org.name, memDeets.org.size, memDeets.user, memDeets.role].join('\t')
      )
    } else if (!this.npm.silent) {
      output.standard(
        `Added ${memDeets.user} as ${memDeets.role} to ${memDeets.org.name}. You now have ${
            memDeets.org.size
          } member${memDeets.org.size === 1 ? '' : 's'} in this org.`
      )
    }

    return memDeets
  }

  async rm (org, user, opts) {
    if (!org) {
      throw new Error('First argument `orgname` is required.')
    }

    if (!user) {
      throw new Error('Second argument `username` is required.')
    }

    await liborg.rm(org, user, opts)
    const roster = await liborg.ls(org, opts)
    user = user.replace(/^[~@]?/, '')
    org = org.replace(/^[~@]?/, '')
    const userCount = Object.keys(roster).length
    if (opts.json) {
      output.buffer({
        user,
        org,
        userCount,
        deleted: true,
      })
    } else if (opts.parseable) {
      output.standard(['user', 'org', 'userCount', 'deleted'].join('\t'))
      output.standard([user, org, userCount, true].join('\t'))
    } else if (!this.npm.silent) {
      output.standard(
        `Successfully removed ${user} from ${org}. You now have ${userCount} member${
          userCount === 1 ? '' : 's'
        } in this org.`
      )
    }
  }

  async ls (org, user, opts) {
    if (!org) {
      throw new Error('First argument `orgname` is required.')
    }

    let roster = await liborg.ls(org, opts)
    if (user) {
      const newRoster = {}
      if (roster[user]) {
        newRoster[user] = roster[user]
      }

      roster = newRoster
    }
    if (opts.json) {
      output.buffer(roster)
    } else if (opts.parseable) {
      output.standard(['user', 'role'].join('\t'))
      Object.keys(roster).forEach(u => {
        output.standard([u, roster[u]].join('\t'))
      })
    } else if (!this.npm.silent) {
      const chalk = this.npm.chalk
      for (const u of Object.keys(roster).sort()) {
        output.standard(`${u} - ${chalk.cyan(roster[u])}`)
      }
    }
  }
}

module.exports = Org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/npm/lib/commands/outdated.js                                                       0000664 0000000 0000000 00000017310 14746647661 0021022 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { resolve } = require('node:path')
const { stripVTControlCharacters } = require('node:util')
const pacote = require('pacote')
const table = require('text-table')
const npa = require('npm-package-arg')
const pickManifest = require('npm-pick-manifest')
const { output } = require('proc-log')
const localeCompare = require('@isaacs/string-locale-compare')('en')
const ArboristWorkspaceCmd = require('../arborist-cmd.js')

const safeNpa = (spec) => {
  try {
    return npa(spec)
  } catch {
    return null
  }
}

// This string is load bearing and is shared with Arborist
const MISSING = 'MISSING'

class Outdated extends ArboristWorkspaceCmd {
  static description = 'Check for outdated packages'
  static name = 'outdated'
  static usage = ['[<package-spec> ...]']
  static params = [
    'all',
    'json',
    'long',
    'parseable',
    'global',
    'workspace',
  ]

  #tree
  #list = []
  #edges = new Set()
  #filterSet

  async exec (args) {
    const Arborist = require('@npmcli/arborist')
    const arb = new Arborist({
      ...this.npm.flatOptions,
      path: this.npm.global ? resolve(this.npm.globalDir, '..') : this.npm.prefix,
    })
    this.#tree = await arb.loadActual()

    if (this.workspaceNames?.length) {
      this.#filterSet = arb.workspaceDependencySet(
        this.#tree,
        this.workspaceNames,
        this.npm.flatOptions.includeWorkspaceRoot
      )
    } else if (!this.npm.flatOptions.workspacesEnabled) {
      this.#filterSet = arb.excludeWorkspacesDependencySet(this.#tree)
    }

    if (args.length) {
      for (const arg of args) {
        // specific deps
        this.#getEdges(this.#tree.inventory.query('name', arg), 'edgesIn')
      }
    } else {
      if (this.npm.config.get('all')) {
        // all deps in tree
        this.#getEdges(this.#tree.inventory.values(), 'edgesOut')
      }
      // top-level deps
      this.#getEdges()
    }

    await Promise.all([...this.#edges].map((e) => this.#getOutdatedInfo(e)))

    // sorts list alphabetically by name and then dependent
    const outdated = this.#list
      .sort((a, b) => localeCompare(a.name, b.name) || localeCompare(a.dependent, b.dependent))

    if (outdated.length) {
      process.exitCode = 1
    }

    if (this.npm.config.get('json')) {
      output.buffer(this.#json(outdated))
      return
    }

    const res = this.npm.config.get('parseable')
      ? this.#parseable(outdated)
      : this.#pretty(outdated)

    if (res) {
      output.standard(res)
    }
  }

  #getEdges (nodes, type) {
    // when no nodes are provided then it should only read direct deps
    // from the root node and its workspaces direct dependencies
    if (!nodes) {
      this.#getEdgesOut(this.#tree)
      this.#getWorkspacesEdges()
      return
    }

    for (const node of nodes) {
      if (type === 'edgesOut') {
        this.#getEdgesOut(node)
      } else {
        this.#getEdgesIn(node)
      }
    }
  }

  #getEdgesIn (node) {
    for (const edge of node.edgesIn) {
      this.#trackEdge(edge)
    }
  }

  #getEdgesOut (node) {
    // TODO: normalize usage of edges and avoid looping through nodes here
    const edges = this.npm.global ? node.children.values() : node.edgesOut.values()
    for (const edge of edges) {
      this.#trackEdge(edge)
    }
  }

  #trackEdge (edge) {
    if (edge.from && this.#filterSet?.size > 0 && !this.#filterSet.has(edge.from.target)) {
      return
    }
    this.#edges.add(edge)
  }

  #getWorkspacesEdges () {
    if (this.npm.global) {
      return
    }

    for (const edge of this.#tree.edgesOut.values()) {
      if (edge?.to?.target?.isWorkspace) {
        this.#getEdgesOut(edge.to.target)
      }
    }
  }

  async #getPackument (spec) {
    return pacote.packument(spec, {
      ...this.npm.flatOptions,
      fullMetadata: this.npm.config.get('long'),
      preferOnline: true,
    })
  }

  async #getOutdatedInfo (edge) {
    const alias = safeNpa(edge.spec)?.subSpec
    const spec = npa(alias ? alias.name : edge.name)
    const node = edge.to || edge
    const { path, location, package: { version: current } = {} } = node

    const type = edge.optional ? 'optionalDependencies'
      : edge.peer ? 'peerDependencies'
      : edge.dev ? 'devDependencies'
      : 'dependencies'

    for (const omitType of this.npm.flatOptions.omit) {
      if (node[omitType]) {
        return
      }
    }

    // deps different from prod not currently
    // on disk are not included in the output
    if (edge.error === MISSING && type !== 'dependencies') {
      return
    }

    // if it's not a range, version, or tag, skip it
    if (!safeNpa(`${edge.name}@${edge.spec}`)?.registry) {
      return null
    }

    try {
      const packument = await this.#getPackument(spec)
      const expected = alias ? alias.fetchSpec : edge.spec
      const wanted = pickManifest(packument, expected, this.npm.flatOptions)
      const latest = pickManifest(packument, '*', this.npm.flatOptions)
      if (!current || current !== wanted.version || wanted.version !== latest.version) {
        this.#list.push({
          name: alias ? edge.spec.replace('npm', edge.name) : edge.name,
          path,
          type,
          current,
          location,
          wanted: wanted.version,
          latest: latest.version,
          workspaceDependent: edge.from?.isWorkspace ? edge.from.pkgid : null,
          dependent: edge.from?.name ?? 'global',
          homepage: packument.homepage,
        })
      }
    } catch (err) {
      // silently catch and ignore ETARGET, E403 &
      // E404 errors, deps are just skipped
      if (!['ETARGET', 'E404', 'E404'].includes(err.code)) {
        throw err
      }
    }
  }

  // formatting functions

  #pretty (list) {
    if (!list.length) {
      return
    }

    const long = this.npm.config.get('long')
    const { bold, yellow, red, cyan, blue } = this.npm.chalk

    return table([
      [
        'Package',
        'Current',
        'Wanted',
        'Latest',
        'Location',
        'Depended by',
        ...long ? ['Package Type', 'Homepage'] : [],
      ].map(h => bold.underline(h)),
      ...list.map((d) => [
        d.current === d.wanted ? yellow(d.name) : red(d.name),
        d.current ?? 'MISSING',
        cyan(d.wanted),
        blue(d.latest),
        d.location ?? '-',
        d.workspaceDependent ? blue(d.workspaceDependent) : d.dependent,
        ...long ? [d.type, blue(d.homepage ?? '')] : [],
      ]),
    ], {
      align: ['l', 'r', 'r', 'r', 'l'],
      stringLength: s => stripVTControlCharacters(s).length,
    })
  }

  // --parseable creates output like this:
  // <fullpath>:<name@wanted>:<name@installed>:<name@latest>:<dependedby>
  #parseable (list) {
    return list.map(d => [
      d.path,
      `${d.name}@${d.wanted}`,
      d.current ? `${d.name}@${d.current}` : 'MISSING',
      `${d.name}@${d.latest}`,
      d.dependent,
      ...this.npm.config.get('long') ? [d.type, d.homepage] : [],
    ].join(':')).join('\n')
  }

  #json (list) {
    // TODO(BREAKING_CHANGE): this should just return an array. It's a list and
    // turing it into an object with keys is lossy since multiple items in the
    // list could have the same key. For now we hack that by only changing
    // top level values into arrays if they have multiple outdated items
    return list.reduce((acc, d) => {
      const dep = {
        current: d.current,
        wanted: d.wanted,
        latest: d.latest,
        dependent: d.dependent,
        location: d.path,
        ...this.npm.config.get('long') ? { type: d.type, homepage: d.homepage } : {},
      }
      acc[d.name] = acc[d.name]
        // If this item alread has an outdated dep then we turn it into an array
        ? (Array.isArray(acc[d.name]) ? acc[d.name] : [acc[d.name]]).concat(dep)
        : dep
      return acc
    }, {})
  }
}

module.exports = Outdated
                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/npm/lib/commands/owner.js                                                          0000664 0000000 0000000 00000013544 14746647661 0020350 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const npa = require('npm-package-arg')
const npmFetch = require('npm-registry-fetch')
const pacote = require('pacote')
const { log, output } = require('proc-log')
const { otplease } = require('../utils/auth.js')
const pkgJson = require('@npmcli/package-json')
const BaseCommand = require('../base-cmd.js')
const { redact } = require('@npmcli/redact')

const readJson = async (path) => {
  try {
    const { content } = await pkgJson.normalize(path)
    return content
  } catch {
    return {}
  }
}

class Owner extends BaseCommand {
  static description = 'Manage package owners'
  static name = 'owner'
  static params = [
    'registry',
    'otp',
    'workspace',
    'workspaces',
  ]

  static usage = [
    'add <user> <package-spec>',
    'rm <user> <package-spec>',
    'ls <package-spec>',
  ]

  static workspaces = true
  static ignoreImplicitWorkspace = false

  static async completion (opts, npm) {
    const argv = opts.conf.argv.remain
    if (argv.length > 3) {
      return []
    }

    if (argv[1] !== 'owner') {
      argv.unshift('owner')
    }

    if (argv.length === 2) {
      return ['add', 'rm', 'ls']
    }

    // reaches registry in order to autocomplete rm
    if (argv[2] === 'rm') {
      if (npm.global) {
        return []
      }
      const { name } = await readJson(npm.prefix)
      if (!name) {
        return []
      }

      const spec = npa(name)
      const data = await pacote.packument(spec, {
        ...npm.flatOptions,
        fullMetadata: true,
      })
      if (data && data.maintainers && data.maintainers.length) {
        return data.maintainers.map(m => m.name)
      }
    }
    return []
  }

  async exec ([action, ...args]) {
    if (action === 'ls' || action === 'list') {
      await this.ls(args[0])
    } else if (action === 'add') {
      await this.changeOwners(args[0], args[1], 'add')
    } else if (action === 'rm' || action === 'remove') {
      await this.changeOwners(args[0], args[1], 'rm')
    } else {
      throw this.usageError()
    }
  }

  async execWorkspaces ([action, ...args]) {
    await this.setWorkspaces()
    // ls pkg or owner add/rm package
    if ((action === 'ls' && args.length > 0) || args.length > 1) {
      const implicitWorkspaces = this.npm.config.get('workspace', 'default')
      if (implicitWorkspaces.length === 0) {
        log.warn(`Ignoring specified workspace(s)`)
      }
      return this.exec([action, ...args])
    }

    for (const [name] of this.workspaces) {
      if (action === 'ls' || action === 'list') {
        await this.ls(name)
      } else if (action === 'add') {
        await this.changeOwners(args[0], name, 'add')
      } else if (action === 'rm' || action === 'remove') {
        await this.changeOwners(args[0], name, 'rm')
      } else {
        throw this.usageError()
      }
    }
  }

  async ls (pkg) {
    pkg = await this.getPkg(this.npm.prefix, pkg)
    const spec = npa(pkg)

    try {
      const packumentOpts = { ...this.npm.flatOptions, fullMetadata: true, preferOnline: true }
      const { maintainers } = await pacote.packument(spec, packumentOpts)
      if (!maintainers || !maintainers.length) {
        output.standard('no admin found')
      } else {
        output.standard(maintainers.map(m => `${m.name} <${m.email}>`).join('\n'))
      }
    } catch (err) {
      log.error('owner ls', "Couldn't get owner data", redact(pkg))
      throw err
    }
  }

  async getPkg (prefix, pkg) {
    if (!pkg) {
      if (this.npm.global) {
        throw this.usageError()
      }
      const { name } = await readJson(prefix)
      if (!name) {
        throw this.usageError()
      }

      return name
    }
    return pkg
  }

  async changeOwners (user, pkg, addOrRm) {
    if (!user) {
      throw this.usageError()
    }

    pkg = await this.getPkg(this.npm.prefix, pkg)
    log.verbose(`owner ${addOrRm}`, '%s to %s', user, pkg)

    const spec = npa(pkg)
    const uri = `/-/user/org.couchdb.user:${encodeURIComponent(user)}`
    let u

    try {
      u = await npmFetch.json(uri, this.npm.flatOptions)
    } catch (err) {
      log.error('owner mutate', `Error getting user data for ${user}`)
      throw err
    }

    // normalize user data
    u = { name: u.name, email: u.email }

    const data = await pacote.packument(spec, {
      ...this.npm.flatOptions,
      fullMetadata: true,
      preferOnline: true,
    })

    const owners = data.maintainers || []
    let maintainers
    if (addOrRm === 'add') {
      const existing = owners.find(o => o.name === u.name)
      if (existing) {
        log.info(
          'owner add',
          `Already a package owner: ${existing.name} <${existing.email}>`
        )
        return
      }
      maintainers = [
        ...owners,
        u,
      ]
    } else {
      maintainers = owners.filter(o => o.name !== u.name)

      if (maintainers.length === owners.length) {
        log.info('owner rm', 'Not a package owner: ' + u.name)
        return false
      }

      if (!maintainers.length) {
        throw Object.assign(
          new Error(
            'Cannot remove all owners of a package. Add someone else first.'
          ),
          { code: 'EOWNERRM' }
        )
      }
    }

    const dataPath = `/${spec.escapedName}/-rev/${encodeURIComponent(data._rev)}`
    try {
      const res = await otplease(this.npm, this.npm.flatOptions, opts => {
        return npmFetch.json(dataPath, {
          ...opts,
          method: 'PUT',
          body: {
            _id: data._id,
            _rev: data._rev,
            maintainers,
          },
          spec,
        })
      })
      if (addOrRm === 'add') {
        output.standard(`+ ${user} (${spec.name})`)
      } else {
        output.standard(`- ${user} (${spec.name})`)
      }
      return res
    } catch (err) {
      throw Object.assign(
        new Error('Failed to update package: ' + JSON.stringify(err.message)),
        { code: 'EOWNERMUTATE' }
      )
    }
  }
}

module.exports = Owner
                                                                                                                                                            node-23.7.0/deps/npm/lib/commands/pack.js                                                           0000664 0000000 0000000 00000005151 14746647661 0020127 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const pacote = require('pacote')
const libpack = require('libnpmpack')
const npa = require('npm-package-arg')
const { log, output } = require('proc-log')
const { getContents, logTar } = require('../utils/tar.js')
const BaseCommand = require('../base-cmd.js')

class Pack extends BaseCommand {
  static description = 'Create a tarball from a package'
  static name = 'pack'
  static params = [
    'dry-run',
    'json',
    'pack-destination',
    'workspace',
    'workspaces',
    'include-workspace-root',
  ]

  static usage = ['<package-spec>']
  static workspaces = true
  static ignoreImplicitWorkspace = false

  async exec (args) {
    if (args.length === 0) {
      args = ['.']
    }

    const unicode = this.npm.config.get('unicode')
    const json = this.npm.config.get('json')

    // Get the manifests and filenames first so we can bail early on manifest
    // errors before making any tarballs
    const manifests = []
    for (const arg of args) {
      const spec = npa(arg)
      const manifest = await pacote.manifest(spec, this.npm.flatOptions)
      if (!manifest._id) {
        throw new Error('Invalid package, must have name and version')
      }
      manifests.push({ arg, manifest })
    }

    // Load tarball names up for printing afterward to isolate from the
    // noise generated during packing
    const tarballs = []
    for (const { arg, manifest } of manifests) {
      const tarballData = await libpack(arg, {
        ...this.npm.flatOptions,
        foregroundScripts: this.npm.config.isDefault('foreground-scripts')
          ? true
          : this.npm.config.get('foreground-scripts'),
        prefix: this.npm.localPrefix,
        workspaces: this.workspacePaths,
      })
      tarballs.push(await getContents(manifest, tarballData))
    }

    for (const [index, tar] of Object.entries(tarballs)) {
      // XXX(BREAKING_CHANGE): publish outputs a json object with package
      // names as keys. Pack should do the same here instead of an array
      logTar(tar, { unicode, json, key: index })
      if (!json) {
        output.standard(tar.filename.replace(/^@/, '').replace(/\//, '-'))
      }
    }
  }

  async execWorkspaces (args) {
    // If they either ask for nothing, or explicitly include '.' in the args,
    // we effectively translate that into each workspace requested

    const useWorkspaces = args.length === 0 || args.includes('.')

    if (!useWorkspaces) {
      log.warn('Ignoring workspaces for specified package(s)')
      return this.exec(args)
    }

    await this.setWorkspaces()
    return this.exec([...this.workspacePaths, ...args.filter(a => a !== '.')])
  }
}

module.exports = Pack
                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/npm/lib/commands/ping.js                                                           0000664 0000000 0000000 00000001551 14746647661 0020146 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { redact } = require('@npmcli/redact')
const { log, output } = require('proc-log')
const pingUtil = require('../utils/ping.js')
const BaseCommand = require('../base-cmd.js')

class Ping extends BaseCommand {
  static description = 'Ping npm registry'
  static params = ['registry']
  static name = 'ping'

  async exec () {
    const cleanRegistry = redact(this.npm.config.get('registry'))
    log.notice('PING', cleanRegistry)
    const start = Date.now()
    const details = await pingUtil({ ...this.npm.flatOptions })
    const time = Date.now() - start
    log.notice('PONG', `${time}ms`)
    if (this.npm.config.get('json')) {
      output.buffer({
        registry: cleanRegistry,
        time,
        details,
      })
    } else if (Object.keys(details).length) {
      log.notice('PONG', JSON.stringify(details, null, 2))
    }
  }
}

module.exports = Ping
                                                                                                                                                       node-23.7.0/deps/npm/lib/commands/pkg.js                                                            0000664 0000000 0000000 00000007071 14746647661 0017775 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { output } = require('proc-log')
const PackageJson = require('@npmcli/package-json')
const BaseCommand = require('../base-cmd.js')
const Queryable = require('../utils/queryable.js')

class Pkg extends BaseCommand {
  static description = 'Manages your package.json'
  static name = 'pkg'
  static usage = [
    'set <key>=<value> [<key>=<value> ...]',
    'get [<key> [<key> ...]]',
    'delete <key> [<key> ...]',
    'set [<array>[<index>].<key>=<value> ...]',
    'set [<array>[].<key>=<value> ...]',
    'fix',
  ]

  static params = [
    'force',
    'json',
    'workspace',
    'workspaces',
  ]

  static workspaces = true
  static ignoreImplicitWorkspace = false

  async exec (args, { path = this.npm.localPrefix, workspace } = {}) {
    if (this.npm.global) {
      throw Object.assign(
        new Error(`There's no package.json file to manage on global mode`),
        { code: 'EPKGGLOBAL' }
      )
    }

    const [cmd, ..._args] = args
    switch (cmd) {
      case 'get':
        return this.get(_args, { path, workspace })
      case 'set':
        return this.set(_args, { path, workspace }).then(p => p.save())
      case 'delete':
        return this.delete(_args, { path, workspace }).then(p => p.save())
      case 'fix':
        return PackageJson.fix(path).then(p => p.save())
      default:
        throw this.usageError()
    }
  }

  async execWorkspaces (args) {
    await this.setWorkspaces()
    for (const [workspace, path] of this.workspaces.entries()) {
      await this.exec(args, { path, workspace })
    }
  }

  async get (args, { path, workspace }) {
    this.npm.config.set('json', true)
    const pkgJson = await PackageJson.load(path)

    let result = pkgJson.content

    if (args.length) {
      result = new Queryable(result).query(args)
      // in case there's only a single result from the query
      // just prints that one element to stdout
      // TODO(BREAKING_CHANGE): much like other places where we unwrap single
      // item arrays this should go away. it makes the behavior unknown for users
      // who don't already know the shape of the data.
      if (Object.keys(result).length === 1) {
        result = result[args]
      }
    }

    // The display layer is responsible for calling JSON.stringify on the result
    // TODO: https://github.com/npm/cli/issues/5508 a raw mode has been requested similar
    // to jq -r. If that was added then this method should no longer set `json:true` all the time
    output.buffer(workspace ? { [workspace]: result } : result)
  }

  async set (args, { path }) {
    const setError = () =>
      this.usageError('npm pkg set expects a key=value pair of args.')

    if (!args.length) {
      throw setError()
    }

    const force = this.npm.config.get('force')
    const json = this.npm.config.get('json')
    const pkgJson = await PackageJson.load(path)
    const q = new Queryable(pkgJson.content)
    for (const arg of args) {
      const [key, ...rest] = arg.split('=')
      const value = rest.join('=')
      if (!key || !value) {
        throw setError()
      }

      q.set(key, json ? JSON.parse(value) : value, { force })
    }

    return pkgJson.update(q.toJSON())
  }

  async delete (args, { path }) {
    const setError = () =>
      this.usageError('npm pkg delete expects key args.')

    if (!args.length) {
      throw setError()
    }

    const pkgJson = await PackageJson.load(path)
    const q = new Queryable(pkgJson.content)
    for (const key of args) {
      if (!key) {
        throw setError()
      }

      q.delete(key)
    }

    return pkgJson.update(q.toJSON())
  }
}

module.exports = Pkg
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/npm/lib/commands/prefix.js                                                         0000664 0000000 0000000 00000000517 14746647661 0020507 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { output } = require('proc-log')
const BaseCommand = require('../base-cmd.js')

class Prefix extends BaseCommand {
  static description = 'Display prefix'
  static name = 'prefix'
  static params = ['global']
  static usage = ['[-g]']

  async exec () {
    return output.standard(this.npm.prefix)
  }
}

module.exports = Prefix
                                                                                                                                                                                 node-23.7.0/deps/npm/lib/commands/profile.js                                                        0000664 0000000 0000000 00000025103 14746647661 0020650 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { inspect } = require('node:util')
const { URL } = require('node:url')
const { log, output } = require('proc-log')
const { get, set, createToken } = require('npm-profile')
const qrcodeTerminal = require('qrcode-terminal')
const { otplease } = require('../utils/auth.js')
const readUserInfo = require('../utils/read-user-info.js')
const BaseCommand = require('../base-cmd.js')

const qrcode = url =>
  new Promise((resolve) => qrcodeTerminal.generate(url, resolve))

const knownProfileKeys = [
  'name',
  'email',
  'two-factor auth',
  'fullname',
  'homepage',
  'freenode',
  'twitter',
  'github',
  'created',
  'updated',
]

const writableProfileKeys = [
  'email',
  'password',
  'fullname',
  'homepage',
  'freenode',
  'twitter',
  'github',
]

class Profile extends BaseCommand {
  static description = 'Change settings on your registry profile'
  static name = 'profile'
  static usage = [
    'enable-2fa [auth-only|auth-and-writes]',
    'disable-2fa',
    'get [<key>]',
    'set <key> <value>',
  ]

  static params = [
    'registry',
    'json',
    'parseable',
    'otp',
  ]

  static async completion (opts) {
    var argv = opts.conf.argv.remain

    if (!argv[2]) {
      return ['enable-2fa', 'disable-2fa', 'get', 'set']
    }

    switch (argv[2]) {
      case 'enable-2fa':
      case 'enable-tfa':
        return ['auth-and-writes', 'auth-only']

      case 'disable-2fa':
      case 'disable-tfa':
      case 'get':
      case 'set':
        return []
      default:
        throw new Error(argv[2] + ' not recognized')
    }
  }

  async exec (args) {
    if (args.length === 0) {
      throw this.usageError()
    }

    const [subcmd, ...opts] = args

    switch (subcmd) {
      case 'enable-2fa':
      case 'enable-tfa':
      case 'enable2fa':
      case 'enabletfa':
        return this.enable2fa(opts)
      case 'disable-2fa':
      case 'disable-tfa':
      case 'disable2fa':
      case 'disabletfa':
        return this.disable2fa()
      case 'get':
        return this.get(opts)
      case 'set':
        return this.set(opts)
      default:
        throw new Error('Unknown profile command: ' + subcmd)
    }
  }

  async get (args) {
    const tfa = 'two-factor auth'
    const info = await get({ ...this.npm.flatOptions })

    if (!info.cidr_whitelist) {
      delete info.cidr_whitelist
    }

    if (this.npm.config.get('json')) {
      output.buffer(info)
      return
    }

    // clean up and format key/values for output
    const cleaned = {}
    for (const key of knownProfileKeys) {
      cleaned[key] = info[key] || ''
    }

    const unknownProfileKeys = Object.keys(info).filter((k) => !(k in cleaned))
    for (const key of unknownProfileKeys) {
      cleaned[key] = info[key] || ''
    }

    delete cleaned.tfa
    delete cleaned.email_verified
    cleaned.email += info.email_verified ? ' (verified)' : '(unverified)'

    if (info.tfa && !info.tfa.pending) {
      cleaned[tfa] = info.tfa.mode
    } else {
      cleaned[tfa] = 'disabled'
    }

    if (args.length) {
      const values = args // comma or space separated
        .join(',')
        .split(/,/)
        .filter((arg) => arg.trim() !== '')
        .map((arg) => cleaned[arg])
        .join('\t')
      output.standard(values)
    } else {
      if (this.npm.config.get('parseable')) {
        for (const key of Object.keys(info)) {
          if (key === 'tfa') {
            output.standard(`${key}\t${cleaned[tfa]}`)
          } else {
            output.standard(`${key}\t${info[key]}`)
          }
        }
      } else {
        for (const [key, value] of Object.entries(cleaned)) {
          output.standard(`${key}: ${value}`)
        }
      }
    }
  }

  async set (args) {
    const conf = { ...this.npm.flatOptions }
    const prop = (args[0] || '').toLowerCase().trim()

    let value = args.length > 1 ? args.slice(1).join(' ') : null

    const readPasswords = async () => {
      const newpassword = await readUserInfo.password('New password: ')
      const confirmedpassword = await readUserInfo.password('       Again:     ')

      if (newpassword !== confirmedpassword) {
        log.warn('profile', 'Passwords do not match, please try again.')
        return readPasswords()
      }

      return newpassword
    }

    if (prop !== 'password' && value === null) {
      throw new Error('npm profile set <prop> <value>')
    }

    if (prop === 'password' && value !== null) {
      throw new Error(
        'npm profile set password\n' +
        'Do not include your current or new passwords on the command line.')
    }

    if (writableProfileKeys.indexOf(prop) === -1) {
      throw new Error(`"${prop}" is not a property we can set. ` +
        `Valid properties are: ` + writableProfileKeys.join(', '))
    }

    if (prop === 'password') {
      const current = await readUserInfo.password('Current password: ')
      const newpassword = await readPasswords()

      value = { old: current, new: newpassword }
    }

    // FIXME: Work around to not clear everything other than what we're setting
    const user = await get(conf)
    const newUser = {}

    for (const key of writableProfileKeys) {
      newUser[key] = user[key]
    }

    newUser[prop] = value

    const result = await otplease(this.npm, conf, c => set(newUser, c))

    if (this.npm.config.get('json')) {
      output.buffer({ [prop]: result[prop] })
    } else if (this.npm.config.get('parseable')) {
      output.standard(prop + '\t' + result[prop])
    } else if (result[prop] != null) {
      output.standard('Set', prop, 'to', result[prop])
    } else {
      output.standard('Set', prop)
    }
  }

  async enable2fa (args) {
    if (args.length > 1) {
      throw new Error('npm profile enable-2fa [auth-and-writes|auth-only]')
    }

    const mode = args[0] || 'auth-and-writes'
    if (mode !== 'auth-only' && mode !== 'auth-and-writes') {
      throw new Error(
        `Invalid two-factor authentication mode "${mode}".\n` +
        'Valid modes are:\n' +
        '  auth-only - Require two-factor authentication only when logging in\n' +
        '  auth-and-writes - Require two-factor authentication when logging in ' +
        'AND when publishing'
      )
    }

    if (this.npm.config.get('json') || this.npm.config.get('parseable')) {
      throw new Error(
        'Enabling two-factor authentication is an interactive operation and ' +
        (this.npm.config.get('json') ? 'JSON' : 'parseable') + ' output mode is not available'
      )
    }

    const info = {
      tfa: {
        mode: mode,
      },
    }

    // if they're using legacy auth currently then we have to
    // update them to a bearer token before continuing.
    const creds = this.npm.config.getCredentialsByURI(this.npm.config.get('registry'))
    const auth = {}

    if (creds.token) {
      auth.token = creds.token
    } else if (creds.username) {
      auth.basic = { username: creds.username, password: creds.password }
    } else if (creds.auth) {
      const basic = Buffer.from(creds.auth, 'base64').toString().split(':', 2)
      auth.basic = { username: basic[0], password: basic[1] }
    }

    if (!auth.basic && !auth.token) {
      throw new Error(
        'You need to be logged in to registry ' +
        `${this.npm.config.get('registry')} in order to enable 2fa`
      )
    }

    if (auth.basic) {
      log.info('profile', 'Updating authentication to bearer token')
      const result = await createToken(
        auth.basic.password, false, [], { ...this.npm.flatOptions }
      )

      if (!result.token) {
        throw new Error(
          `Your registry ${this.npm.config.get('registry')} does not seem to ` +
          'support bearer tokens. Bearer tokens are required for ' +
          'two-factor authentication'
        )
      }

      this.npm.config.setCredentialsByURI(
        this.npm.config.get('registry'),
        { token: result.token }
      )
      await this.npm.config.save('user')
    }

    log.notice('profile', 'Enabling two factor authentication for ' + mode)
    const password = await readUserInfo.password()
    info.tfa.password = password

    log.info('profile', 'Determine if tfa is pending')
    const userInfo = await get({ ...this.npm.flatOptions })

    const conf = { ...this.npm.flatOptions }
    if (userInfo && userInfo.tfa && userInfo.tfa.pending) {
      log.info('profile', 'Resetting two-factor authentication')
      await set({ tfa: { password, mode: 'disable' } }, conf)
    } else if (userInfo && userInfo.tfa) {
      if (!conf.otp) {
        conf.otp = await readUserInfo.otp(
          'Enter one-time password: '
        )
      }
    }

    log.info('profile', 'Setting two-factor authentication to ' + mode)
    const challenge = await set(info, conf)

    if (challenge.tfa === null) {
      output.standard('Two factor authentication mode changed to: ' + mode)
      return
    }

    const badResponse = typeof challenge.tfa !== 'string'
      || !/^otpauth:[/][/]/.test(challenge.tfa)
    if (badResponse) {
      throw new Error(
        'Unknown error enabling two-factor authentication. Expected otpauth URL' +
        ', got: ' + inspect(challenge.tfa)
      )
    }

    const otpauth = new URL(challenge.tfa)
    const secret = otpauth.searchParams.get('secret')
    const code = await qrcode(challenge.tfa)

    output.standard(
      'Scan into your authenticator app:\n' + code + '\n Or enter code:', secret
    )

    const interactiveOTP =
      await readUserInfo.otp('And an OTP code from your authenticator: ')

    log.info('profile', 'Finalizing two-factor authentication')

    const result = await set({ tfa: [interactiveOTP] }, conf)

    output.standard(
      '2FA successfully enabled. Below are your recovery codes, ' +
      'please print these out.'
    )
    output.standard(
      'You will need these to recover access to your account ' +
      'if you lose your authentication device.'
    )

    for (const tfaCode of result.tfa) {
      output.standard('\t' + tfaCode)
    }
  }

  async disable2fa () {
    const conf = { ...this.npm.flatOptions }
    const info = await get(conf)

    if (!info.tfa || info.tfa.pending) {
      output.standard('Two factor authentication not enabled.')
      return
    }

    const password = await readUserInfo.password()

    if (!conf.otp) {
      const msg = 'Enter one-time password: '
      conf.otp = await readUserInfo.otp(msg)
    }

    log.info('profile', 'disabling tfa')

    await set({ tfa: { password: password, mode: 'disable' } }, conf)

    if (this.npm.config.get('json')) {
      output.buffer({ tfa: false })
    } else if (this.npm.config.get('parseable')) {
      output.standard('tfa\tfalse')
    } else {
      output.standard('Two factor authentication disabled.')
    }
  }
}

module.exports = Profile
                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/npm/lib/commands/prune.js                                                          0000664 0000000 0000000 00000001437 14746647661 0020345 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const reifyFinish = require('../utils/reify-finish.js')
const ArboristWorkspaceCmd = require('../arborist-cmd.js')

// prune extraneous packages
class Prune extends ArboristWorkspaceCmd {
  static description = 'Remove extraneous packages'
  static name = 'prune'
  static params = [
    'omit',
    'include',
    'dry-run',
    'json',
    'foreground-scripts',
    'ignore-scripts',
    ...super.params,
  ]

  static usage = ['[[<@scope>/]<pkg>...]']

  async exec () {
    const where = this.npm.prefix
    const Arborist = require('@npmcli/arborist')
    const opts = {
      ...this.npm.flatOptions,
      path: where,
      workspaces: this.workspaceNames,
    }
    const arb = new Arborist(opts)
    await arb.prune(opts)
    await reifyFinish(this.npm, arb)
  }
}

module.exports = Prune
                                                                                                                                                                                                                                 node-23.7.0/deps/npm/lib/commands/publish.js                                                        0000664 0000000 0000000 00000016600 14746647661 0020660 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { log, output } = require('proc-log')
const semver = require('semver')
const pack = require('libnpmpack')
const libpub = require('libnpmpublish').publish
const runScript = require('@npmcli/run-script')
const pacote = require('pacote')
const npa = require('npm-package-arg')
const npmFetch = require('npm-registry-fetch')
const { redactLog: replaceInfo } = require('@npmcli/redact')
const { otplease } = require('../utils/auth.js')
const { getContents, logTar } = require('../utils/tar.js')
// for historical reasons, publishConfig in package.json can contain ANY config
// keys that npm supports in .npmrc files and elsewhere.  We *may* want to
// revisit this at some point, and have a minimal set that's a SemVer-major
// change that ought to get a RFC written on it.
const { flatten } = require('@npmcli/config/lib/definitions')
const pkgJson = require('@npmcli/package-json')
const BaseCommand = require('../base-cmd.js')

class Publish extends BaseCommand {
  static description = 'Publish a package'
  static name = 'publish'
  static params = [
    'tag',
    'access',
    'dry-run',
    'otp',
    'workspace',
    'workspaces',
    'include-workspace-root',
    'provenance',
  ]

  static usage = ['<package-spec>']
  static workspaces = true
  static ignoreImplicitWorkspace = false

  async exec (args) {
    if (args.length === 0) {
      args = ['.']
    }
    if (args.length !== 1) {
      throw this.usageError()
    }

    await this.#publish(args)
  }

  async execWorkspaces (args) {
    const useWorkspaces = args.length === 0 || args.includes('.')
    if (!useWorkspaces) {
      log.warn('Ignoring workspaces for specified package(s)')
      return this.exec(args)
    }
    await this.setWorkspaces()

    for (const [name, workspace] of this.workspaces.entries()) {
      try {
        await this.#publish([workspace], { workspace: name })
      } catch (err) {
        if (err.code !== 'EPRIVATE') {
          throw err
        }
        // eslint-disable-next-line max-len
        log.warn('publish', `Skipping workspace ${this.npm.chalk.cyan(name)}, marked as ${this.npm.chalk.bold('private')}`)
      }
    }
  }

  async #publish (args, { workspace } = {}) {
    log.verbose('publish', replaceInfo(args))

    const unicode = this.npm.config.get('unicode')
    const dryRun = this.npm.config.get('dry-run')
    const json = this.npm.config.get('json')
    const defaultTag = this.npm.config.get('tag')
    const ignoreScripts = this.npm.config.get('ignore-scripts')
    const { silent } = this.npm

    if (semver.validRange(defaultTag)) {
      throw new Error('Tag name must not be a valid SemVer range: ' + defaultTag.trim())
    }

    const opts = { ...this.npm.flatOptions, progress: false }

    // you can publish name@version, ./foo.tgz, etc.
    // even though the default is the 'file:.' cwd.
    const spec = npa(args[0])
    let manifest = await this.#getManifest(spec, opts)

    // only run scripts for directory type publishes
    if (spec.type === 'directory' && !ignoreScripts) {
      await runScript({
        event: 'prepublishOnly',
        path: spec.fetchSpec,
        stdio: 'inherit',
        pkg: manifest,
      })
    }

    // we pass dryRun: true to libnpmpack so it doesn't write the file to disk
    const tarballData = await pack(spec, {
      ...opts,
      foregroundScripts: this.npm.config.isDefault('foreground-scripts')
        ? true
        : this.npm.config.get('foreground-scripts'),
      dryRun: true,
      prefix: this.npm.localPrefix,
      workspaces: this.workspacePaths,
    })
    const pkgContents = await getContents(manifest, tarballData)
    const logPkg = () => logTar(pkgContents, { unicode, json, key: workspace })

    // The purpose of re-reading the manifest is in case it changed,
    // so that we send the latest and greatest thing to the registry
    // note that publishConfig might have changed as well!
    manifest = await this.#getManifest(spec, opts, true)

    // If we are not in JSON mode then we show the user the contents of the tarball
    // before it is published so they can see it while their otp is pending
    if (!json) {
      logPkg()
    }

    const resolved = npa.resolve(manifest.name, manifest.version)

    // make sure tag is valid, this will throw if invalid
    npa(`${manifest.name}@${defaultTag}`)

    const registry = npmFetch.pickRegistry(resolved, opts)
    const creds = this.npm.config.getCredentialsByURI(registry)
    const noCreds = !(creds.token || creds.username || creds.certfile && creds.keyfile)
    const outputRegistry = replaceInfo(registry)

    // if a workspace package is marked private then we skip it
    if (workspace && manifest.private) {
      throw Object.assign(
        new Error(`This package has been marked as private
  Remove the 'private' field from the package.json to publish it.`),
        { code: 'EPRIVATE' }
      )
    }

    if (noCreds) {
      const msg = `This command requires you to be logged in to ${outputRegistry}`
      if (dryRun) {
        log.warn('', `${msg} (dry-run)`)
      } else {
        throw Object.assign(new Error(msg), { code: 'ENEEDAUTH' })
      }
    }

    const access = opts.access === null ? 'default' : opts.access
    let msg = `Publishing to ${outputRegistry} with tag ${defaultTag} and ${access} access`
    if (dryRun) {
      msg = `${msg} (dry-run)`
    }

    log.notice('', msg)

    if (!dryRun) {
      await otplease(this.npm, opts, o => libpub(manifest, tarballData, o))
    }

    // In json mode we dont log until the publish has completed as this will
    // add it to the output only if completes successfully
    if (json) {
      logPkg()
    }

    if (spec.type === 'directory' && !ignoreScripts) {
      await runScript({
        event: 'publish',
        path: spec.fetchSpec,
        stdio: 'inherit',
        pkg: manifest,
      })

      await runScript({
        event: 'postpublish',
        path: spec.fetchSpec,
        stdio: 'inherit',
        pkg: manifest,
      })
    }

    if (!json && !silent) {
      output.standard(`+ ${pkgContents.id}`)
    }
  }

  // if it's a directory, read it from the file system
  // otherwise, get the full metadata from whatever it is
  // XXX can't pacote read the manifest from a directory?
  async #getManifest (spec, opts, logWarnings = false) {
    let manifest
    if (spec.type === 'directory') {
      const changes = []
      const pkg = await pkgJson.fix(spec.fetchSpec, { changes })
      if (changes.length && logWarnings) {
        /* eslint-disable-next-line max-len */
        log.warn('publish', 'npm auto-corrected some errors in your package.json when publishing.  Please run "npm pkg fix" to address these errors.')
        log.warn('publish', `errors corrected:\n${changes.join('\n')}`)
      }
      // Prepare is the special function for publishing, different than normalize
      const { content } = await pkg.prepare()
      manifest = content
    } else {
      manifest = await pacote.manifest(spec, {
        ...opts,
        fullmetadata: true,
        fullReadJson: true,
      })
    }
    if (manifest.publishConfig) {
      const cliFlags = this.npm.config.data.get('cli').raw
      // Filter out properties set in CLI flags to prioritize them over
      // corresponding `publishConfig` settings
      const filteredPublishConfig = Object.fromEntries(
        Object.entries(manifest.publishConfig).filter(([key]) => !(key in cliFlags)))
      flatten(filteredPublishConfig, opts)
    }
    return manifest
  }
}

module.exports = Publish
                                                                                                                                node-23.7.0/deps/npm/lib/commands/query.js                                                          0000664 0000000 0000000 00000007013 14746647661 0020355 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { resolve } = require('node:path')
const BaseCommand = require('../base-cmd.js')
const { log, output } = require('proc-log')

class QuerySelectorItem {
  constructor (node) {
    // all enumerable properties from the target
    Object.assign(this, node.target.package)

    // append extra info
    this.pkgid = node.target.pkgid
    this.location = node.target.location
    this.path = node.target.path
    this.realpath = node.target.realpath
    this.resolved = node.target.resolved
    this.from = []
    this.to = []
    this.dev = node.target.dev
    this.inBundle = node.target.inBundle
    this.deduped = this.from.length > 1
    this.overridden = node.overridden
    this.queryContext = node.queryContext
    for (const edge of node.target.edgesIn) {
      this.from.push(edge.from.location)
    }
    for (const [, edge] of node.target.edgesOut) {
      if (edge.to) {
        this.to.push(edge.to.location)
      }
    }
  }
}

class Query extends BaseCommand {
  #response = [] // response is the query response
  #seen = new Set() // paths we've seen so we can keep response deduped

  static description = 'Retrieve a filtered list of packages'
  static name = 'query'
  static usage = ['<selector>']

  static workspaces = true
  static ignoreImplicitWorkspace = false

  static params = [
    'global',
    'workspace',
    'workspaces',
    'include-workspace-root',
    'package-lock-only',
    'expect-results',
  ]

  constructor (...args) {
    super(...args)
    this.npm.config.set('json', true)
  }

  async exec (args) {
    const packageLock = this.npm.config.get('package-lock-only')
    const Arborist = require('@npmcli/arborist')
    const arb = new Arborist({
      ...this.npm.flatOptions,
      // one dir up from wherever node_modules lives
      path: resolve(this.npm.dir, '..'),
      forceActual: !packageLock,
    })
    let tree
    if (packageLock) {
      try {
        tree = await arb.loadVirtual()
      } catch (err) {
        log.verbose('loadVirtual', err.stack)
        throw this.usageError(
          'A package lock or shrinkwrap file is required in package-lock-only mode'
        )
      }
    } else {
      tree = await arb.loadActual()
    }
    await this.#queryTree(tree, args[0])
    this.#output()
  }

  async execWorkspaces (args) {
    await this.setWorkspaces()
    const Arborist = require('@npmcli/arborist')
    const arb = new Arborist({
      ...this.npm.flatOptions,
      path: this.npm.prefix,
    })
    // FIXME: Workspace support in query does not work as expected so this does not
    // do the same package-lock-only check as this.exec().
    // https://github.com/npm/cli/pull/6732#issuecomment-1708804921
    const tree = await arb.loadActual()
    for (const path of this.workspacePaths) {
      const wsTree = path === tree.root.path
        ? tree // --includes-workspace-root
        : await tree.querySelectorAll(`.workspace:path(${path})`).then(r => r[0].target)
      await this.#queryTree(wsTree, args[0])
    }
    this.#output()
  }

  #output () {
    this.checkExpected(this.#response.length)
    output.buffer(this.#response)
  }

  // builds a normalized inventory
  async #queryTree (tree, arg) {
    const items = await tree.querySelectorAll(arg, this.npm.flatOptions)
    for (const node of items) {
      const { location } = node.target
      if (!location || !this.#seen.has(location)) {
        const item = new QuerySelectorItem(node)
        this.#response.push(item)
        if (location) {
          this.#seen.add(item.location)
        }
      }
    }
  }
}

module.exports = Query
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/npm/lib/commands/rebuild.js                                                        0000664 0000000 0000000 00000004301 14746647661 0020633 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { resolve } = require('node:path')
const { output } = require('proc-log')
const npa = require('npm-package-arg')
const semver = require('semver')
const ArboristWorkspaceCmd = require('../arborist-cmd.js')

class Rebuild extends ArboristWorkspaceCmd {
  static description = 'Rebuild a package'
  static name = 'rebuild'
  static params = [
    'global',
    'bin-links',
    'foreground-scripts',
    'ignore-scripts',
    ...super.params,
  ]

  static usage = ['[<package-spec>] ...]']

  // TODO
  /* istanbul ignore next */
  static async completion (opts, npm) {
    const completion = require('../utils/installed-deep.js')
    return completion(npm, opts)
  }

  async exec (args) {
    const globalTop = resolve(this.npm.globalDir, '..')
    const where = this.npm.global ? globalTop : this.npm.prefix
    const Arborist = require('@npmcli/arborist')
    const arb = new Arborist({
      ...this.npm.flatOptions,
      path: where,
      // TODO when extending ReifyCmd
      // workspaces: this.workspaceNames,
    })

    if (args.length) {
      // get the set of nodes matching the name that we want rebuilt
      const tree = await arb.loadActual()
      const specs = args.map(arg => {
        const spec = npa(arg)
        if (spec.rawSpec === '*') {
          return spec
        }

        if (spec.type !== 'range' && spec.type !== 'version' && spec.type !== 'directory') {
          throw new Error('`npm rebuild` only supports SemVer version/range specifiers')
        }

        return spec
      })
      const nodes = tree.inventory.filter(node => this.isNode(specs, node))

      await arb.rebuild({ nodes })
    } else {
      await arb.rebuild()
    }

    output.standard('rebuilt dependencies successfully')
  }

  isNode (specs, node) {
    return specs.some(spec => {
      if (spec.type === 'directory') {
        return node.path === spec.fetchSpec
      }

      if (spec.name !== node.name) {
        return false
      }

      if (spec.rawSpec === '' || spec.rawSpec === '*') {
        return true
      }

      const { version } = node.package
      // TODO: add tests for a package with missing version
      return semver.satisfies(version, spec.fetchSpec)
    })
  }
}

module.exports = Rebuild
                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/npm/lib/commands/repo.js                                                           0000664 0000000 0000000 00000002376 14746647661 0020164 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { URL } = require('node:url')
const PackageUrlCmd = require('../package-url-cmd.js')

class Repo extends PackageUrlCmd {
  static description = 'Open package repository page in the browser'
  static name = 'repo'

  getUrl (spec, mani) {
    const r = mani.repository
    const rurl = !r ? null
      : typeof r === 'string' ? r
      : typeof r === 'object' && typeof r.url === 'string' ? r.url
      : null

    if (!rurl) {
      throw Object.assign(new Error('no repository'), {
        pkgid: spec,
      })
    }

    const info = this.hostedFromMani(mani)
    const url = info ?
      info.browse(mani.repository.directory) : unknownHostedUrl(rurl)

    if (!url) {
      throw Object.assign(new Error('no repository: could not get url'), {
        pkgid: spec,
      })
    }
    return url
  }
}

module.exports = Repo

const unknownHostedUrl = url => {
  try {
    const {
      protocol,
      hostname,
      pathname,
    } = new URL(url)

    /* istanbul ignore next - URL ctor should prevent this */
    if (!protocol || !hostname) {
      return null
    }

    const proto = /(git\+)http:$/.test(protocol) ? 'http:' : 'https:'
    const path = pathname.replace(/\.git$/, '')
    return `${proto}//${hostname}${path}`
  } catch (e) {
    return null
  }
}
                                                                                                                                                                                                                                                                  node-23.7.0/deps/npm/lib/commands/restart.js                                                        0000664 0000000 0000000 00000000466 14746647661 0020701 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const LifecycleCmd = require('../lifecycle-cmd.js')

// This ends up calling run-script(['restart', ...args])
class Restart extends LifecycleCmd {
  static description = 'Restart a package'
  static name = 'restart'
  static params = [
    'ignore-scripts',
    'script-shell',
  ]
}

module.exports = Restart
                                                                                                                                                                                                          node-23.7.0/deps/npm/lib/commands/root.js                                                           0000664 0000000 0000000 00000000447 14746647661 0020177 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { output } = require('proc-log')
const BaseCommand = require('../base-cmd.js')

class Root extends BaseCommand {
  static description = 'Display npm root'
  static name = 'root'
  static params = ['global']

  async exec () {
    output.standard(this.npm.dir)
  }
}

module.exports = Root
                                                                                                                                                                                                                         node-23.7.0/deps/npm/lib/commands/run-script.js                                                     0000664 0000000 0000000 00000014115 14746647661 0021317 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { output } = require('proc-log')
const pkgJson = require('@npmcli/package-json')
const BaseCommand = require('../base-cmd.js')
const { getError } = require('../utils/error-message.js')
const { outputError } = require('../utils/output-error.js')

class RunScript extends BaseCommand {
  static description = 'Run arbitrary package scripts'
  static params = [
    'workspace',
    'workspaces',
    'include-workspace-root',
    'if-present',
    'ignore-scripts',
    'foreground-scripts',
    'script-shell',
  ]

  static name = 'run-script'
  static usage = ['<command> [-- <args>]']
  static workspaces = true
  static ignoreImplicitWorkspace = false
  static isShellout = true
  static checkDevEngines = true

  static async completion (opts, npm) {
    const argv = opts.conf.argv.remain
    if (argv.length === 2) {
      const { content: { scripts = {} } } = await pkgJson.normalize(npm.localPrefix)
        .catch(() => ({ content: {} }))
      if (opts.isFish) {
        return Object.keys(scripts).map(s => `${s}\t${scripts[s].slice(0, 30)}`)
      }
      return Object.keys(scripts)
    }
  }

  async exec (args) {
    if (args.length) {
      await this.#run(args, { path: this.npm.localPrefix })
    } else {
      await this.#list(this.npm.localPrefix)
    }
  }

  async execWorkspaces (args) {
    await this.setWorkspaces()

    const ws = [...this.workspaces.entries()]
    for (const [workspace, path] of ws) {
      const last = path === ws.at(-1)[1]

      if (!args.length) {
        const newline = await this.#list(path, { workspace })
        if (newline && !last) {
          output.standard('')
        }
        continue
      }

      const pkg = await pkgJson.normalize(path).then(p => p.content)
      try {
        await this.#run(args, { path, pkg, workspace })
      } catch (e) {
        const err = getError(e, { npm: this.npm, command: null })
        outputError({
          ...err,
          error: [
            ['', `Lifecycle script \`${args[0]}\` failed with error:`],
            ...err.error,
            ['workspace', pkg._id || pkg.name],
            ['location', path],
          ],
        })
        process.exitCode = err.exitCode
        if (!last) {
          output.error('')
        }
      }
    }
  }

  async #run ([event, ...args], { path, pkg, workspace }) {
    const runScript = require('@npmcli/run-script')

    pkg ??= await pkgJson.normalize(path).then(p => p.content)

    const { scripts = {} } = pkg

    if (event === 'restart' && !scripts.restart) {
      scripts.restart = 'npm stop --if-present && npm start'
    } else if (event === 'env' && !scripts.env) {
      const { isWindowsShell } = require('../utils/is-windows.js')
      scripts.env = isWindowsShell ? 'SET' : 'env'
    }

    pkg.scripts = scripts

    if (
      !Object.prototype.hasOwnProperty.call(scripts, event) &&
      !(event === 'start' && (await runScript.isServerPackage(path)))
    ) {
      if (this.npm.config.get('if-present')) {
        return
      }

      const suggestions = require('../utils/did-you-mean.js')(pkg, event)
      const wsArg = workspace && path !== this.npm.localPrefix
        ? ` --workspace=${pkg._id || pkg.name}`
        : ''
      throw new Error([
        `Missing script: "${event}"${suggestions}\n`,
        'To see a list of scripts, run:',
        `  npm run${wsArg}`,
      ].join('\n'))
    }

    // positional args only added to the main event, not pre/post
    const events = [[event, args]]
    if (!this.npm.config.get('ignore-scripts')) {
      if (scripts[`pre${event}`]) {
        events.unshift([`pre${event}`, []])
      }

      if (scripts[`post${event}`]) {
        events.push([`post${event}`, []])
      }
    }

    for (const [ev, evArgs] of events) {
      await runScript({
        path,
        // this || undefined is because runScript will be unhappy with the
        // default null value
        scriptShell: this.npm.config.get('script-shell') || undefined,
        stdio: 'inherit',
        pkg,
        event: ev,
        args: evArgs,
      })
    }
  }

  async #list (path, { workspace } = {}) {
    const { scripts = {}, name, _id } = await pkgJson.normalize(path).then(p => p.content)
    const scriptEntries = Object.entries(scripts)

    if (this.npm.silent) {
      return
    }

    if (this.npm.config.get('json')) {
      output.buffer(workspace ? { [workspace]: scripts } : scripts)
      return
    }

    if (!scriptEntries.length) {
      return
    }

    if (this.npm.config.get('parseable')) {
      output.standard(scriptEntries
        .map((s) => (workspace ? [workspace, ...s] : s).join(':'))
        .join('\n')
        .trim())
      return
    }

    const cmdList = [
      'prepare', 'prepublishOnly',
      'prepack', 'postpack',
      'dependencies',
      'preinstall', 'install', 'postinstall',
      'prepublish', 'publish', 'postpublish',
      'prerestart', 'restart', 'postrestart',
      'prestart', 'start', 'poststart',
      'prestop', 'stop', 'poststop',
      'pretest', 'test', 'posttest',
      'preuninstall', 'uninstall', 'postuninstall',
      'preversion', 'version', 'postversion',
    ]
    const [cmds, runScripts] = scriptEntries.reduce((acc, s) => {
      acc[cmdList.includes(s[0]) ? 0 : 1].push(s)
      return acc
    }, [[], []])

    const { reset, bold, cyan, dim, blue } = this.npm.chalk
    const pkgId = `in ${cyan(_id || name)}`
    const title = (t) => reset(bold(t))

    if (cmds.length) {
      output.standard(`${title('Lifecycle scripts')} included ${pkgId}:`)
      for (const [k, v] of cmds) {
        output.standard(`  ${k}`)
        output.standard(`    ${dim(v)}`)
      }
    }

    if (runScripts.length) {
      const via = `via \`${blue('npm run-script')}\`:`
      if (!cmds.length) {
        output.standard(`${title('Scripts')} available ${pkgId} ${via}`)
      } else {
        output.standard(`available ${via}`)
      }
      for (const [k, v] of runScripts) {
        output.standard(`  ${k}`)
        output.standard(`    ${dim(v)}`)
      }
    }

    // Return true to indicate that something was output for this path
    // that should be separated from others
    return true
  }
}

module.exports = RunScript
                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/npm/lib/commands/sbom.js                                                           0000664 0000000 0000000 00000011010 14746647661 0020140 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const localeCompare = require('@isaacs/string-locale-compare')('en')
const BaseCommand = require('../base-cmd.js')
const { log, output } = require('proc-log')
const { cyclonedxOutput } = require('../utils/sbom-cyclonedx.js')
const { spdxOutput } = require('../utils/sbom-spdx.js')

const SBOM_FORMATS = ['cyclonedx', 'spdx']

class SBOM extends BaseCommand {
  #response = {} // response is the sbom response

  static description = 'Generate a Software Bill of Materials (SBOM)'
  static name = 'sbom'
  static workspaces = true

  static params = [
    'omit',
    'package-lock-only',
    'sbom-format',
    'sbom-type',
    'workspace',
    'workspaces',
  ]

  async exec () {
    const sbomFormat = this.npm.config.get('sbom-format')
    const packageLockOnly = this.npm.config.get('package-lock-only')

    if (!sbomFormat) {
      /* eslint-disable-next-line max-len */
      throw this.usageError(`Must specify --sbom-format flag with one of: ${SBOM_FORMATS.join(', ')}.`)
    }

    const opts = {
      ...this.npm.flatOptions,
      path: this.npm.prefix,
      forceActual: true,
    }
    const Arborist = require('@npmcli/arborist')
    const arb = new Arborist(opts)

    const tree = packageLockOnly ? await arb.loadVirtual(opts).catch(() => {
      /* eslint-disable-next-line max-len */
      throw this.usageError('A package lock or shrinkwrap file is required in package-lock-only mode')
    }) : await arb.loadActual(opts)

    // Collect the list of selected workspaces in the project
    const wsNodes = this.workspaceNames?.length
      ? arb.workspaceNodes(tree, this.workspaceNames)
      : null

    // Build the selector and query the tree for the list of nodes
    const selector = this.#buildSelector({ wsNodes })
    log.info('sbom', `Using dependency selector: ${selector}`)
    const items = await tree.querySelectorAll(selector)

    const errors = items.flatMap(node => detectErrors(node))
    if (errors.length) {
      throw Object.assign(new Error([...new Set(errors)].join('\n')), {
        code: 'ESBOMPROBLEMS',
      })
    }

    // Populate the response with the list of unique nodes (sorted by location)
    this.#buildResponse(items.sort((a, b) => localeCompare(a.location, b.location)))

    // TODO(BREAKING_CHANGE): all sbom output is in json mode but setting it before
    // any of the errors will cause those to be thrown in json mode.
    this.npm.config.set('json', true)
    output.buffer(this.#response)
  }

  async execWorkspaces (args) {
    await this.setWorkspaces()
    return this.exec(args)
  }

  // Build the selector from all of the specified filter options
  #buildSelector ({ wsNodes }) {
    let selector
    const omit = this.npm.flatOptions.omit
    const workspacesEnabled = this.npm.flatOptions.workspacesEnabled

    // If omit is specified, omit all nodes and their children which match the
    // specified selectors
    const omits = omit.reduce((acc, o) => `${acc}:not(.${o})`, '')

    if (!workspacesEnabled) {
      // If workspaces are disabled, omit all workspace nodes and their children
      selector = `:root > :not(.workspace)${omits},:root > :not(.workspace) *${omits},:extraneous`
    } else if (wsNodes && wsNodes.length > 0) {
      // If one or more workspaces are selected, select only those workspaces and their children
      selector = wsNodes.map(ws => `#${ws.name},#${ws.name} *${omits}`).join(',')
    } else {
      selector = `:root *${omits},:extraneous`
    }

    // Always include the root node
    return `:root,${selector}`
  }

  // builds a normalized inventory
  #buildResponse (items) {
    const sbomFormat = this.npm.config.get('sbom-format')
    const packageType = this.npm.config.get('sbom-type')
    const packageLockOnly = this.npm.config.get('package-lock-only')

    this.#response = sbomFormat === 'cyclonedx'
      ? cyclonedxOutput({ npm: this.npm, nodes: items, packageType, packageLockOnly })
      : spdxOutput({ npm: this.npm, nodes: items, packageType })
  }
}

const detectErrors = (node) => {
  const errors = []

  // Look for missing dependencies (that are NOT optional), or invalid dependencies
  for (const edge of node.edgesOut.values()) {
    if (edge.missing && !(edge.type === 'optional' || edge.type === 'peerOptional')) {
      errors.push(`missing: ${edge.name}@${edge.spec}, required by ${edge.from.pkgid}`)
    }

    if (edge.invalid) {
      /* istanbul ignore next */
      const spec = edge.spec || '*'
      const from = edge.from.pkgid
      errors.push(`invalid: ${edge.to.pkgid}, ${spec} required by ${from}`)
    }
  }

  return errors
}

module.exports = SBOM
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/npm/lib/commands/search.js                                                         0000664 0000000 0000000 00000003525 14746647661 0020461 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const Pipeline = require('minipass-pipeline')
const libSearch = require('libnpmsearch')
const { log, output } = require('proc-log')
const formatSearchStream = require('../utils/format-search-stream.js')
const BaseCommand = require('../base-cmd.js')

class Search extends BaseCommand {
  static description = 'Search for packages'
  static name = 'search'
  static params = [
    'json',
    'color',
    'parseable',
    'description',
    'searchlimit',
    'searchopts',
    'searchexclude',
    'registry',
    'prefer-online',
    'prefer-offline',
    'offline',
  ]

  static usage = ['<search term> [<search term> ...]']

  async exec (args) {
    const opts = {
      ...this.npm.flatOptions,
      ...this.npm.flatOptions.search,
      include: args.map(s => s.toLowerCase()).filter(Boolean),
      exclude: this.npm.flatOptions.search.exclude.split(/\s+/),
    }

    if (opts.include.length === 0) {
      throw new Error('search must be called with arguments')
    }

    // Used later to figure out whether we had any packages go out
    let anyOutput = false

    // Grab a configured output stream that will spit out packages in the desired format.
    const outputStream = formatSearchStream({
      args, // --searchinclude options are not highlighted
      ...opts,
      npm: this.npm,
    })

    log.silly('search', 'searching packages')
    const p = new Pipeline(
      libSearch.stream(opts.include, opts),
      outputStream
    )

    p.on('data', chunk => {
      if (!anyOutput) {
        anyOutput = true
      }
      output.standard(chunk.toString('utf8'))
    })

    await p.promise()
    if (!anyOutput && !this.npm.config.get('json') && !this.npm.config.get('parseable')) {
      output.standard('No matches found for ' + (args.map(JSON.stringify).join(' ')))
    }

    log.silly('search', 'search completed')
  }
}

module.exports = Search
                                                                                                                                                                           node-23.7.0/deps/npm/lib/commands/set.js                                                            0000664 0000000 0000000 00000001237 14746647661 0020005 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const Npm = require('../npm.js')
const BaseCommand = require('../base-cmd.js')

class Set extends BaseCommand {
  static description = 'Set a value in the npm configuration'
  static name = 'set'
  static usage = ['<key>=<value> [<key>=<value> ...] (See `npm config`)']
  static params = ['global', 'location']
  static ignoreImplicitWorkspace = false

  // TODO
  /* istanbul ignore next */
  static async completion (opts) {
    const Config = Npm.cmd('config')
    return Config.completion(opts)
  }

  async exec (args) {
    if (!args.length) {
      throw this.usageError()
    }
    return this.npm.exec('config', ['set'].concat(args))
  }
}

module.exports = Set
                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/npm/lib/commands/shrinkwrap.js                                                     0000664 0000000 0000000 00000005230 14746647661 0021377 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { resolve, basename } = require('node:path')
const { unlink } = require('node:fs/promises')
const { log } = require('proc-log')
const BaseCommand = require('../base-cmd.js')

class Shrinkwrap extends BaseCommand {
  static description = 'Lock down dependency versions for publication'
  static name = 'shrinkwrap'
  static ignoreImplicitWorkspace = false

  async exec () {
    // if has a npm-shrinkwrap.json, nothing to do
    // if has a package-lock.json, rename to npm-shrinkwrap.json
    // if has neither, load the actual tree and save that as npm-shrinkwrap.json
    //
    // loadVirtual, fall back to loadActual
    // rename shrinkwrap file type, and tree.meta.save()
    if (this.npm.global) {
      const er = new Error('`npm shrinkwrap` does not work for global packages')
      er.code = 'ESHRINKWRAPGLOBAL'
      throw er
    }

    const Arborist = require('@npmcli/arborist')
    const path = this.npm.prefix
    const sw = resolve(path, 'npm-shrinkwrap.json')
    const arb = new Arborist({ ...this.npm.flatOptions, path })
    const tree = await arb.loadVirtual().catch(() => arb.loadActual())
    const { meta } = tree
    const newFile = meta.hiddenLockfile || !meta.loadedFromDisk
    const oldFilename = meta.filename
    const notSW = !newFile && basename(oldFilename) !== 'npm-shrinkwrap.json'

    // The computed lockfile version of a hidden lockfile is always 3
    // even if the actual value of the property is a different.
    // When shrinkwrap is run with only a hidden lockfile we want to
    // set the shrinkwrap lockfile version as whatever was explicitly
    // requested with a fallback to the actual value from the hidden
    // lockfile.
    if (meta.hiddenLockfile) {
      meta.lockfileVersion = arb.options.lockfileVersion ||
        meta.originalLockfileVersion
    }
    meta.hiddenLockfile = false
    meta.filename = sw
    await meta.save()

    const updatedVersion = meta.originalLockfileVersion !== meta.lockfileVersion
      ? meta.lockfileVersion
      : null

    if (newFile) {
      let message = 'created a lockfile as npm-shrinkwrap.json'
      if (updatedVersion) {
        message += ` with version ${updatedVersion}`
      }
      log.notice('', message)
    } else if (notSW) {
      await unlink(oldFilename)
      let message = 'package-lock.json has been renamed to npm-shrinkwrap.json'
      if (updatedVersion) {
        message += ` and updated to version ${updatedVersion}`
      }
      log.notice('', message)
    } else if (updatedVersion) {
      log.notice('', `npm-shrinkwrap.json updated to version ${updatedVersion}`)
    } else {
      log.notice('', 'npm-shrinkwrap.json up to date')
    }
  }
}

module.exports = Shrinkwrap
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/npm/lib/commands/star.js                                                           0000664 0000000 0000000 00000003567 14746647661 0020173 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const fetch = require('npm-registry-fetch')
const npa = require('npm-package-arg')
const { log, output } = require('proc-log')
const getIdentity = require('../utils/get-identity')
const BaseCommand = require('../base-cmd.js')

class Star extends BaseCommand {
  static description = 'Mark your favorite packages'
  static name = 'star'
  static usage = ['[<package-spec>...]']
  static params = [
    'registry',
    'unicode',
    'otp',
  ]

  static ignoreImplicitWorkspace = false

  async exec (args) {
    if (!args.length) {
      throw this.usageError()
    }

    // if we're unstarring, then show an empty star image
    // otherwise, show the full star image
    const unicode = this.npm.config.get('unicode')
    const full = unicode ? '\u2605 ' : '(*)'
    const empty = unicode ? '\u2606 ' : '( )'
    const show = this.name === 'star' ? full : empty

    const pkgs = args.map(npa)
    const username = await getIdentity(this.npm, this.npm.flatOptions)

    for (const pkg of pkgs) {
      const fullData = await fetch.json(pkg.escapedName, {
        ...this.npm.flatOptions,
        spec: pkg,
        query: { write: true },
        preferOnline: true,
      })

      const body = {
        _id: fullData._id,
        _rev: fullData._rev,
        users: fullData.users || {},
      }

      if (this.name === 'star') {
        log.info('star', 'starring', body._id)
        body.users[username] = true
        log.verbose('star', 'starring', body)
      } else {
        delete body.users[username]
        log.info('unstar', 'unstarring', body._id)
        log.verbose('unstar', 'unstarring', body)
      }

      const data = await fetch.json(pkg.escapedName, {
        ...this.npm.flatOptions,
        spec: pkg,
        method: 'PUT',
        body,
      })

      output.standard(show + ' ' + pkg.name)
      log.verbose('star', data)
      return data
    }
  }
}

module.exports = Star
                                                                                                                                         node-23.7.0/deps/npm/lib/commands/stars.js                                                          0000664 0000000 0000000 00000002034 14746647661 0020342 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const fetch = require('npm-registry-fetch')
const { log, output } = require('proc-log')
const getIdentity = require('../utils/get-identity.js')
const BaseCommand = require('../base-cmd.js')

class Stars extends BaseCommand {
  static description = 'View packages marked as favorites'
  static name = 'stars'
  static usage = ['[<user>]']
  static params = ['registry']
  static ignoreImplicitWorkspace = false

  async exec ([user]) {
    try {
      if (!user) {
        user = await getIdentity(this.npm, this.npm.flatOptions)
      }

      const { rows } = await fetch.json('/-/_view/starredByUser', {
        ...this.npm.flatOptions,
        query: { key: `"${user}"` },
      })
      if (rows.length === 0) {
        log.warn('stars', 'user has not starred any packages')
      }

      for (const row of rows) {
        output.standard(row.value)
      }
    } catch (err) {
      if (err.code === 'ENEEDAUTH') {
        log.warn('stars', 'auth is required to look up your username')
      }
      throw err
    }
  }
}

module.exports = Stars
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/npm/lib/commands/start.js                                                          0000664 0000000 0000000 00000000454 14746647661 0020347 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const LifecycleCmd = require('../lifecycle-cmd.js')

// This ends up calling run-script(['start', ...args])
class Start extends LifecycleCmd {
  static description = 'Start a package'
  static name = 'start'
  static params = [
    'ignore-scripts',
    'script-shell',
  ]
}

module.exports = Start
                                                                                                                                                                                                                    node-23.7.0/deps/npm/lib/commands/stop.js                                                           0000664 0000000 0000000 00000000447 14746647661 0020201 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const LifecycleCmd = require('../lifecycle-cmd.js')

// This ends up calling run-script(['stop', ...args])
class Stop extends LifecycleCmd {
  static description = 'Stop a package'
  static name = 'stop'
  static params = [
    'ignore-scripts',
    'script-shell',
  ]
}

module.exports = Stop
                                                                                                                                                                                                                         node-23.7.0/deps/npm/lib/commands/team.js                                                           0000664 0000000 0000000 00000010555 14746647661 0020143 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const columns = require('cli-columns')
const libteam = require('libnpmteam')
const { output } = require('proc-log')
const { otplease } = require('../utils/auth.js')

const BaseCommand = require('../base-cmd.js')
class Team extends BaseCommand {
  static description = 'Manage organization teams and team memberships'
  static name = 'team'
  static usage = [
    'create <scope:team> [--otp <otpcode>]',
    'destroy <scope:team> [--otp <otpcode>]',
    'add <scope:team> <user> [--otp <otpcode>]',
    'rm <scope:team> <user> [--otp <otpcode>]',
    'ls <scope>|<scope:team>',
  ]

  static params = [
    'registry',
    'otp',
    'parseable',
    'json',
  ]

  static ignoreImplicitWorkspace = false

  static async completion (opts) {
    const { conf: { argv: { remain: argv } } } = opts
    const subcommands = ['create', 'destroy', 'add', 'rm', 'ls']

    if (argv.length === 2) {
      return subcommands
    }

    if (subcommands.includes(argv[2])) {
      return []
    }

    throw new Error(argv[2] + ' not recognized')
  }

  async exec ([cmd, entity = '', user = '']) {
    // Entities are in the format <scope>:<team>
    // XXX: "description" option to libnpmteam is used as a description of the
    // team, but in npm's options, this is a boolean meaning "show the
    // description in npm search output".  Hence its being set to null here.
    await otplease(this.npm, { ...this.npm.flatOptions }, opts => {
      entity = entity.replace(/^@/, '')
      switch (cmd) {
        case 'create': return this.create(entity, opts)
        case 'destroy': return this.destroy(entity, opts)
        case 'add': return this.add(entity, user, opts)
        case 'rm': return this.rm(entity, user, opts)
        case 'ls': {
          const match = entity.match(/[^:]+:.+/)
          if (match) {
            return this.listUsers(entity, opts)
          } else {
            return this.listTeams(entity, opts)
          }
        }
        default:
          throw this.usageError()
      }
    })
  }

  async create (entity, opts) {
    await libteam.create(entity, opts)
    if (opts.json) {
      output.buffer({
        created: true,
        team: entity,
      })
    } else if (opts.parseable) {
      output.standard(`${entity}\tcreated`)
    } else if (!this.npm.silent) {
      output.standard(`+@${entity}`)
    }
  }

  async destroy (entity, opts) {
    await libteam.destroy(entity, opts)
    if (opts.json) {
      output.buffer({
        deleted: true,
        team: entity,
      })
    } else if (opts.parseable) {
      output.standard(`${entity}\tdeleted`)
    } else if (!this.npm.silent) {
      output.standard(`-@${entity}`)
    }
  }

  async add (entity, user, opts) {
    await libteam.add(user, entity, opts)
    if (opts.json) {
      output.buffer({
        added: true,
        team: entity,
        user,
      })
    } else if (opts.parseable) {
      output.standard(`${user}\t${entity}\tadded`)
    } else if (!this.npm.silent) {
      output.standard(`${user} added to @${entity}`)
    }
  }

  async rm (entity, user, opts) {
    await libteam.rm(user, entity, opts)
    if (opts.json) {
      output.buffer({
        removed: true,
        team: entity,
        user,
      })
    } else if (opts.parseable) {
      output.standard(`${user}\t${entity}\tremoved`)
    } else if (!this.npm.silent) {
      output.standard(`${user} removed from @${entity}`)
    }
  }

  async listUsers (entity, opts) {
    const users = (await libteam.lsUsers(entity, opts)).sort()
    if (opts.json) {
      output.buffer(users)
    } else if (opts.parseable) {
      output.standard(users.join('\n'))
    } else if (!this.npm.silent) {
      const plural = users.length === 1 ? '' : 's'
      const more = users.length === 0 ? '' : ':\n'
      output.standard(`\n@${entity} has ${users.length} user${plural}${more}`)
      output.standard(columns(users, { padding: 1 }))
    }
  }

  async listTeams (entity, opts) {
    const teams = (await libteam.lsTeams(entity, opts)).sort()
    if (opts.json) {
      output.buffer(teams)
    } else if (opts.parseable) {
      output.standard(teams.join('\n'))
    } else if (!this.npm.silent) {
      const plural = teams.length === 1 ? '' : 's'
      const more = teams.length === 0 ? '' : ':\n'
      output.standard(`\n@${entity} has ${teams.length} team${plural}${more}`)
      output.standard(columns(teams.map(t => `@${t}`), { padding: 1 }))
    }
  }
}

module.exports = Team
                                                                                                                                                   node-23.7.0/deps/npm/lib/commands/test.js                                                           0000664 0000000 0000000 00000000447 14746647661 0020173 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const LifecycleCmd = require('../lifecycle-cmd.js')

// This ends up calling run-script(['test', ...args])
class Test extends LifecycleCmd {
  static description = 'Test a package'
  static name = 'test'
  static params = [
    'ignore-scripts',
    'script-shell',
  ]
}

module.exports = Test
                                                                                                                                                                                                                         node-23.7.0/deps/npm/lib/commands/token.js                                                          0000664 0000000 0000000 00000014020 14746647661 0020324 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { log, output } = require('proc-log')
const { listTokens, createToken, removeToken } = require('npm-profile')
const { otplease } = require('../utils/auth.js')
const readUserInfo = require('../utils/read-user-info.js')
const BaseCommand = require('../base-cmd.js')

class Token extends BaseCommand {
  static description = 'Manage your authentication tokens'
  static name = 'token'
  static usage = ['list', 'revoke <id|token>', 'create [--read-only] [--cidr=list]']
  static params = ['read-only', 'cidr', 'registry', 'otp']

  static async completion (opts) {
    const argv = opts.conf.argv.remain
    const subcommands = ['list', 'revoke', 'create']
    if (argv.length === 2) {
      return subcommands
    }

    if (subcommands.includes(argv[2])) {
      return []
    }

    throw new Error(argv[2] + ' not recognized')
  }

  async exec (args) {
    if (args.length === 0) {
      return this.list()
    }
    switch (args[0]) {
      case 'list':
      case 'ls':
        return this.list()
      case 'rm':
      case 'delete':
      case 'revoke':
      case 'remove':
        return this.rm(args.slice(1))
      case 'create':
        return this.create(args.slice(1))
      default:
        throw this.usageError(`${args[0]} is not a recognized subcommand.`)
    }
  }

  async list () {
    const json = this.npm.config.get('json')
    const parseable = this.npm.config.get('parseable')
    log.info('token', 'getting list')
    const tokens = await listTokens(this.npm.flatOptions)
    if (json) {
      output.buffer(tokens)
      return
    }
    if (parseable) {
      output.standard(['key', 'token', 'created', 'readonly', 'CIDR whitelist'].join('\t'))
      tokens.forEach(token => {
        output.standard(
          [
            token.key,
            token.token,
            token.created,
            token.readonly ? 'true' : 'false',
            token.cidr_whitelist ? token.cidr_whitelist.join(',') : '',
          ].join('\t')
        )
      })
      return
    }
    this.generateTokenIds(tokens, 6)
    const chalk = this.npm.chalk
    for (const token of tokens) {
      const level = token.readonly ? 'Read only token' : 'Publish token'
      const created = String(token.created).slice(0, 10)
      /* eslint-disable-next-line max-len */
      output.standard(`${chalk.blue(level)} ${token.token}… with id ${chalk.cyan(token.id)} created ${created}`)
      if (token.cidr_whitelist) {
        output.standard(`with IP whitelist: ${chalk.green(token.cidr_whitelist.join(','))}`)
      }
      output.standard()
    }
  }

  async rm (args) {
    if (args.length === 0) {
      throw this.usageError('`<tokenKey>` argument is required.')
    }

    const json = this.npm.config.get('json')
    const parseable = this.npm.config.get('parseable')
    const toRemove = []
    const opts = { ...this.npm.flatOptions }
    log.info('token', `removing ${toRemove.length} tokens`)
    const tokens = await listTokens(opts)
    args.forEach(id => {
      const matches = tokens.filter(token => token.key.indexOf(id) === 0)
      if (matches.length === 1) {
        toRemove.push(matches[0].key)
      } else if (matches.length > 1) {
        throw new Error(
          /* eslint-disable-next-line max-len */
          `Token ID "${id}" was ambiguous, a new token may have been created since you last ran \`npm token list\`.`
        )
      } else {
        const tokenMatches = tokens.some(t => id.indexOf(t.token) === 0)
        if (!tokenMatches) {
          throw new Error(`Unknown token id or value "${id}".`)
        }

        toRemove.push(id)
      }
    })
    await Promise.all(
      toRemove.map(key => {
        return otplease(this.npm, opts, c => removeToken(key, c))
      })
    )
    if (json) {
      output.buffer(toRemove)
    } else if (parseable) {
      output.standard(toRemove.join('\t'))
    } else {
      output.standard('Removed ' + toRemove.length + ' token' + (toRemove.length !== 1 ? 's' : ''))
    }
  }

  async create () {
    const json = this.npm.config.get('json')
    const parseable = this.npm.config.get('parseable')
    const cidr = this.npm.config.get('cidr')
    const readonly = this.npm.config.get('read-only')

    const validCIDR = await this.validateCIDRList(cidr)
    const password = await readUserInfo.password()
    log.info('token', 'creating')
    const result = await otplease(
      this.npm,
      { ...this.npm.flatOptions },
      c => createToken(password, readonly, validCIDR, c)
    )
    delete result.key
    delete result.updated
    if (json) {
      output.buffer(result)
    } else if (parseable) {
      Object.keys(result).forEach(k => output.standard(k + '\t' + result[k]))
    } else {
      const chalk = this.npm.chalk
      // Identical to list
      const level = result.readonly ? 'read only' : 'publish'
      output.standard(`Created ${chalk.blue(level)} token ${result.token}`)
      if (result.cidr_whitelist?.length) {
        output.standard(`with IP whitelist: ${chalk.green(result.cidr_whitelist.join(','))}`)
      }
    }
  }

  invalidCIDRError (msg) {
    return Object.assign(new Error(msg), { code: 'EINVALIDCIDR' })
  }

  generateTokenIds (tokens, minLength) {
    for (const token of tokens) {
      token.id = token.key
      for (let ii = minLength; ii < token.key.length; ++ii) {
        const match = tokens.some(
          ot => ot !== token && ot.key.slice(0, ii) === token.key.slice(0, ii)
        )
        if (!match) {
          token.id = token.key.slice(0, ii)
          break
        }
      }
    }
  }

  async validateCIDRList (cidrs) {
    const { v4: isCidrV4, v6: isCidrV6 } = await import('is-cidr')
    const maybeList = [].concat(cidrs).filter(Boolean)
    const list = maybeList.length === 1 ? maybeList[0].split(/,\s*/) : maybeList
    for (const cidr of list) {
      if (isCidrV6(cidr)) {
        throw this.invalidCIDRError(
          `CIDR whitelist can only contain IPv4 addresses${cidr} is IPv6`
        )
      }

      if (!isCidrV4(cidr)) {
        throw this.invalidCIDRError(`CIDR whitelist contains invalid CIDR entry: ${cidr}`)
      }
    }
    return list
  }
}

module.exports = Token
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/npm/lib/commands/uninstall.js                                                      0000664 0000000 0000000 00000003031 14746647661 0021215 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { resolve } = require('node:path')
const pkgJson = require('@npmcli/package-json')
const reifyFinish = require('../utils/reify-finish.js')
const completion = require('../utils/installed-shallow.js')
const ArboristWorkspaceCmd = require('../arborist-cmd.js')

class Uninstall extends ArboristWorkspaceCmd {
  static description = 'Remove a package'
  static name = 'uninstall'
  static params = ['save', 'global', ...super.params]
  static usage = ['[<@scope>/]<pkg>...']
  static ignoreImplicitWorkspace = false

  // TODO
  /* istanbul ignore next */
  static async completion (opts, npm) {
    return completion(npm, opts)
  }

  async exec (args) {
    if (!args.length) {
      if (!this.npm.global) {
        throw new Error('Must provide a package name to remove')
      } else {
        try {
          const { content: pkg } = await pkgJson.normalize(this.npm.localPrefix)
          args.push(pkg.name)
        } catch (er) {
          if (er.code !== 'ENOENT' && er.code !== 'ENOTDIR') {
            throw er
          } else {
            throw this.usageError()
          }
        }
      }
    }

    // the /path/to/node_modules/..
    const path = this.npm.global
      ? resolve(this.npm.globalDir, '..')
      : this.npm.localPrefix

    const Arborist = require('@npmcli/arborist')
    const opts = {
      ...this.npm.flatOptions,
      path,
      rm: args,
      workspaces: this.workspaceNames,
    }
    const arb = new Arborist(opts)
    await arb.reify(opts)
    await reifyFinish(this.npm, arb)
  }
}

module.exports = Uninstall
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/npm/lib/commands/unpublish.js                                                      0000664 0000000 0000000 00000012422 14746647661 0021221 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const libaccess = require('libnpmaccess')
const libunpub = require('libnpmpublish').unpublish
const npa = require('npm-package-arg')
const pacote = require('pacote')
const { output, log } = require('proc-log')
const pkgJson = require('@npmcli/package-json')
const { flatten } = require('@npmcli/config/lib/definitions')
const getIdentity = require('../utils/get-identity.js')
const { otplease } = require('../utils/auth.js')
const BaseCommand = require('../base-cmd.js')

const LAST_REMAINING_VERSION_ERROR = 'Refusing to delete the last version of the package. ' +
'It will block from republishing a new version for 24 hours.\n' +
'Run with --force to do this.'

class Unpublish extends BaseCommand {
  static description = 'Remove a package from the registry'
  static name = 'unpublish'
  static params = ['dry-run', 'force', 'workspace', 'workspaces']
  static usage = ['[<package-spec>]']
  static workspaces = true
  static ignoreImplicitWorkspace = false

  static async getKeysOfVersions (name, opts) {
    const packument = await pacote.packument(name, {
      ...opts,
      spec: name,
      query: { write: true },
    })
    return Object.keys(packument.versions)
  }

  static async completion (args, npm) {
    const { partialWord, conf } = args

    if (conf.argv.remain.length >= 3) {
      return []
    }

    const opts = { ...npm.flatOptions }
    const username = await getIdentity(npm, { ...opts }).catch(() => null)
    if (!username) {
      return []
    }

    const access = await libaccess.getPackages(username, opts)
    // do a bit of filtering at this point, so that we don't need
    // to fetch versions for more than one thing, but also don't
    // accidentally unpublish a whole project
    let pkgs = Object.keys(access)
    if (!partialWord || !pkgs.length) {
      return pkgs
    }

    const pp = npa(partialWord).name
    pkgs = pkgs.filter(p => !p.indexOf(pp))
    if (pkgs.length > 1) {
      return pkgs
    }

    const versions = await Unpublish.getKeysOfVersions(pkgs[0], opts)
    if (!versions.length) {
      return pkgs
    } else {
      return versions.map(v => `${pkgs[0]}@${v}`)
    }
  }

  async exec (args, { localPrefix } = {}) {
    if (args.length > 1) {
      throw this.usageError()
    }

    // workspace mode
    if (!localPrefix) {
      localPrefix = this.npm.localPrefix
    }

    const force = this.npm.config.get('force')
    const { silent } = this.npm
    const dryRun = this.npm.config.get('dry-run')

    let spec
    if (args.length) {
      spec = npa(args[0])
      if (spec.type !== 'version' && spec.rawSpec !== '*') {
        throw this.usageError(
          'Can only unpublish a single version, or the entire project.\n' +
          'Tags and ranges are not supported.'
        )
      }
    }

    log.silly('unpublish', 'args[0]', args[0])
    log.silly('unpublish', 'spec', spec)

    if (spec?.rawSpec === '*' && !force) {
      throw this.usageError(
        'Refusing to delete entire project.\n' +
        'Run with --force to do this.'
      )
    }

    const opts = { ...this.npm.flatOptions }

    let manifest
    try {
      const { content } = await pkgJson.prepare(localPrefix)
      manifest = content
    } catch (err) {
      if (err.code === 'ENOENT' || err.code === 'ENOTDIR') {
        if (!spec) {
          // We needed a local package.json to figure out what package to
          // unpublish
          throw this.usageError()
        }
      } else {
        // folks should know if ANY local package.json had a parsing error.
        // They may be relying on `publishConfig` to be loading and we don't
        // want to ignore errors in that case.
        throw err
      }
    }

    let pkgVersion // for cli output
    if (spec) {
      pkgVersion = spec.type === 'version' ? `@${spec.rawSpec}` : ''
    } else {
      spec = npa.resolve(manifest.name, manifest.version)
      log.verbose('unpublish', manifest)
      pkgVersion = manifest.version ? `@${manifest.version}` : ''
      if (!manifest.version && !force) {
        throw this.usageError(
          'Refusing to delete entire project.\n' +
          'Run with --force to do this.'
        )
      }
    }

    // If localPrefix has a package.json with a name that matches the package
    // being unpublished, load up the publishConfig
    if (manifest?.name === spec.name && manifest.publishConfig) {
      const cliFlags = this.npm.config.data.get('cli').raw
      // Filter out properties set in CLI flags to prioritize them over
      // corresponding `publishConfig` settings
      const filteredPublishConfig = Object.fromEntries(
        Object.entries(manifest.publishConfig).filter(([key]) => !(key in cliFlags)))
      flatten(filteredPublishConfig, opts)
    }

    const versions = await Unpublish.getKeysOfVersions(spec.name, opts)
    if (versions.length === 1 && spec.rawSpec === versions[0] && !force) {
      throw this.usageError(LAST_REMAINING_VERSION_ERROR)
    }
    if (versions.length === 1) {
      pkgVersion = ''
    }

    if (!dryRun) {
      await otplease(this.npm, opts, o => libunpub(spec, o))
    }
    if (!silent) {
      output.standard(`- ${spec.name}${pkgVersion}`)
    }
  }

  async execWorkspaces (args) {
    await this.setWorkspaces()

    for (const path of this.workspacePaths) {
      await this.exec(args, { localPrefix: path })
    }
  }
}

module.exports = Unpublish
                                                                                                                                                                                                                                              node-23.7.0/deps/npm/lib/commands/unstar.js                                                         0000664 0000000 0000000 00000000267 14746647661 0020530 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const Star = require('./star.js')

class Unstar extends Star {
  static description = 'Remove an item from your favorite packages'
  static name = 'unstar'
}

module.exports = Unstar
                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/npm/lib/commands/update.js                                                         0000664 0000000 0000000 00000003345 14746647661 0020476 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const path = require('node:path')
const { log } = require('proc-log')
const reifyFinish = require('../utils/reify-finish.js')
const ArboristWorkspaceCmd = require('../arborist-cmd.js')

class Update extends ArboristWorkspaceCmd {
  static description = 'Update packages'
  static name = 'update'

  static params = [
    'save',
    'global',
    'install-strategy',
    'legacy-bundling',
    'global-style',
    'omit',
    'include',
    'strict-peer-deps',
    'package-lock',
    'foreground-scripts',
    'ignore-scripts',
    'audit',
    'bin-links',
    'fund',
    'dry-run',
    ...super.params,
  ]

  static usage = ['[<pkg>...]']

  // TODO
  /* istanbul ignore next */
  static async completion (opts, npm) {
    const completion = require('../utils/installed-deep.js')
    return completion(npm, opts)
  }

  async exec (args) {
    const update = args.length === 0 ? true : args
    const global = path.resolve(this.npm.globalDir, '..')
    const where = this.npm.global ? global : this.npm.prefix

    // In the context of `npm update` the save
    // config value should default to `false`
    const save = this.npm.config.isDefault('save')
      ? false
      : this.npm.config.get('save')

    if (this.npm.config.get('depth')) {
      log.warn('update', 'The --depth option no longer has any effect. See RFC0019.\n' +
        'https://github.com/npm/rfcs/blob/latest/implemented/0019-remove-update-depth-option.md')
    }

    const Arborist = require('@npmcli/arborist')
    const opts = {
      ...this.npm.flatOptions,
      path: where,
      save,
      workspaces: this.workspaceNames,
    }
    const arb = new Arborist(opts)

    await arb.reify({ ...opts, update })
    await reifyFinish(this.npm, arb)
  }
}

module.exports = Update
                                                                                                                                                                                                                                                                                           node-23.7.0/deps/npm/lib/commands/version.js                                                        0000664 0000000 0000000 00000007054 14746647661 0020702 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { resolve } = require('node:path')
const { readFile } = require('node:fs/promises')
const { output } = require('proc-log')
const BaseCommand = require('../base-cmd.js')

class Version extends BaseCommand {
  static description = 'Bump a package version'
  static name = 'version'
  static params = [
    'allow-same-version',
    'commit-hooks',
    'git-tag-version',
    'json',
    'preid',
    'sign-git-tag',
    'workspace',
    'workspaces',
    'workspaces-update',
    'include-workspace-root',
  ]

  static workspaces = true
  static ignoreImplicitWorkspace = false

  /* eslint-disable-next-line max-len */
  static usage = ['[<newversion> | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git]']

  static async completion (opts) {
    const {
      conf: {
        argv: { remain },
      },
    } = opts
    if (remain.length > 2) {
      return []
    }

    return [
      'major',
      'minor',
      'patch',
      'premajor',
      'preminor',
      'prepatch',
      'prerelease',
      'from-git',
    ]
  }

  async exec (args) {
    switch (args.length) {
      case 0:
        return this.list()
      case 1:
        return this.change(args)
      default:
        throw this.usageError()
    }
  }

  async execWorkspaces (args) {
    switch (args.length) {
      case 0:
        return this.listWorkspaces()
      case 1:
        return this.changeWorkspaces(args)
      default:
        throw this.usageError()
    }
  }

  async change (args) {
    const libnpmversion = require('libnpmversion')
    const prefix = this.npm.config.get('tag-version-prefix')
    const version = await libnpmversion(args[0], {
      ...this.npm.flatOptions,
      path: this.npm.prefix,
    })
    return output.standard(`${prefix}${version}`)
  }

  async changeWorkspaces (args) {
    const updateWorkspaces = require('../utils/update-workspaces.js')
    const libnpmversion = require('libnpmversion')
    const prefix = this.npm.config.get('tag-version-prefix')
    const {
      config,
      flatOptions,
      localPrefix,
    } = this.npm
    await this.setWorkspaces()
    const updatedWorkspaces = []
    for (const [name, path] of this.workspaces) {
      output.standard(name)
      const version = await libnpmversion(args[0], {
        ...flatOptions,
        'git-tag-version': false,
        path,
      })
      updatedWorkspaces.push(name)
      output.standard(`${prefix}${version}`)
    }
    return updateWorkspaces({
      config,
      flatOptions,
      localPrefix,
      npm: this.npm,
      workspaces: updatedWorkspaces,
    })
  }

  async list (results = {}) {
    const pj = resolve(this.npm.prefix, 'package.json')

    const pkg = await readFile(pj, 'utf8')
      .then(data => JSON.parse(data))
      .catch(() => ({}))

    if (pkg.name && pkg.version) {
      results[pkg.name] = pkg.version
    }

    results.npm = this.npm.version
    for (const [key, version] of Object.entries(process.versions)) {
      results[key] = version
    }

    if (this.npm.config.get('json')) {
      output.buffer(results)
    } else {
      output.standard(results)
    }
  }

  async listWorkspaces () {
    const results = {}
    await this.setWorkspaces()
    for (const path of this.workspacePaths) {
      const pj = resolve(path, 'package.json')
      // setWorkspaces has already parsed package.json so we know it won't error
      const pkg = await readFile(pj, 'utf8').then(data => JSON.parse(data))

      if (pkg.name && pkg.version) {
        results[pkg.name] = pkg.version
      }
    }
    return this.list(results)
  }
}

module.exports = Version
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/npm/lib/commands/view.js                                                           0000664 0000000 0000000 00000031462 14746647661 0020167 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const columns = require('cli-columns')
const { readFile } = require('node:fs/promises')
const jsonParse = require('json-parse-even-better-errors')
const { log, output, META } = require('proc-log')
const npa = require('npm-package-arg')
const { resolve } = require('node:path')
const formatBytes = require('../utils/format-bytes.js')
const relativeDate = require('tiny-relative-date')
const semver = require('semver')
const { inspect } = require('node:util')
const { packument } = require('pacote')
const Queryable = require('../utils/queryable.js')
const BaseCommand = require('../base-cmd.js')
const { getError } = require('../utils/error-message.js')
const { jsonError, outputError } = require('../utils/output-error.js')

const readJson = file => readFile(file, 'utf8').then(jsonParse)

class View extends BaseCommand {
  static description = 'View registry info'
  static name = 'view'
  static params = [
    'json',
    'workspace',
    'workspaces',
    'include-workspace-root',
  ]

  static workspaces = true
  static ignoreImplicitWorkspace = false
  static usage = ['[<package-spec>] [<field>[.subfield]...]']

  static async completion (opts, npm) {
    if (opts.conf.argv.remain.length <= 2) {
      // There used to be registry completion here, but it stopped
      // making sense somewhere around 50,000 packages on the registry
      return
    }
    // have the package, get the fields
    const config = {
      ...npm.flatOptions,
      fullMetadata: true,
      preferOnline: true,
    }
    const spec = npa(opts.conf.argv.remain[2])
    const pckmnt = await packument(spec, config)
    const defaultTag = npm.config.get('tag')
    const dv = pckmnt.versions[pckmnt['dist-tags'][defaultTag]]
    pckmnt.versions = Object.keys(pckmnt.versions).sort(semver.compareLoose)

    return getCompletionFields(pckmnt).concat(getCompletionFields(dv))
  }

  async exec (args) {
    let { pkg, local, rest } = parseArgs(args)

    if (local) {
      if (this.npm.global) {
        throw new Error('Cannot use view command in global mode.')
      }
      const dir = this.npm.prefix
      const manifest = await readJson(resolve(dir, 'package.json'))
      if (!manifest.name) {
        throw new Error('Invalid package.json, no "name" field')
      }
      // put the version back if it existed
      pkg = `${manifest.name}${pkg.slice(1)}`
    }

    await this.#viewPackage(pkg, rest)
  }

  async execWorkspaces (args) {
    const { pkg, local, rest } = parseArgs(args)

    if (!local) {
      log.warn('Ignoring workspaces for specified package(s)')
      return this.exec([pkg, ...rest])
    }

    const json = this.npm.config.get('json')
    await this.setWorkspaces()

    for (const name of this.workspaceNames) {
      try {
        await this.#viewPackage(`${name}${pkg.slice(1)}`, rest, { workspace: true })
      } catch (e) {
        const err = getError(e, { npm: this.npm, command: this })
        if (err.code !== 'E404') {
          throw e
        }
        if (json) {
          output.buffer({ [META]: true, jsonError: { [name]: jsonError(err, this.npm) } })
        } else {
          outputError(err)
        }
        process.exitCode = err.exitCode
      }
    }
  }

  async #viewPackage (name, args, { workspace } = {}) {
    const wholePackument = !args.length
    const json = this.npm.config.get('json')

    // If we are viewing many packages and outputting individual fields then
    // output the name before doing any async activity
    if (!json && !wholePackument && workspace) {
      output.standard(`${name}:`)
    }

    const [pckmnt, data] = await this.#getData(name, args, wholePackument)

    if (!json && wholePackument) {
      // pretty view (entire packument)
      for (const v of data) {
        output.standard(this.#prettyView(pckmnt, Object.values(v)[0][Queryable.ALL]))
      }
      return
    }

    const res = this.#packageOutput(cleanData(data, wholePackument), pckmnt._id)
    if (res) {
      if (json) {
        output.buffer(workspace ? { [name]: res } : res)
      } else {
        output.standard(res)
      }
    }
  }

  async #getData (pkg, args) {
    const spec = npa(pkg)

    const pckmnt = await packument(spec, {
      ...this.npm.flatOptions,
      preferOnline: true,
      fullMetadata: true,
    })

    // get the data about this package
    let version = this.npm.config.get('tag')
    // rawSpec is the git url if this is from git
    if (spec.type !== 'git' && spec.type !== 'directory' && spec.rawSpec !== '*') {
      version = spec.rawSpec
    }

    if (pckmnt['dist-tags']?.[version]) {
      version = pckmnt['dist-tags'][version]
    }

    if (pckmnt.time?.unpublished) {
      const u = pckmnt.time.unpublished
      throw Object.assign(new Error(`Unpublished on ${u.time}`), {
        statusCode: 404,
        code: 'E404',
        pkgid: pckmnt._id,
      })
    }

    const versions = pckmnt.versions || {}
    pckmnt.versions = Object.keys(versions).filter(v => {
      if (semver.valid(v)) {
        return true
      }
      log.info('view', `Ignoring invalid version: ${v}`)
      return false
    }).sort(semver.compareLoose)

    // remove readme unless we asked for it
    if (args.indexOf('readme') === -1) {
      delete pckmnt.readme
    }

    const data = Object.entries(versions)
      .filter(([v]) => semver.satisfies(v, version, true))
      .flatMap(([, v]) => {
        // remove readme unless we asked for it
        if (args.indexOf('readme') !== -1) {
          delete v.readme
        }
        return showFields({
          data: pckmnt,
          version: v,
          fields: args,
          json: this.npm.config.get('json'),
        })
      })

    // No data has been pushed because no data is matching the specified version
    if (!data.length && version !== 'latest') {
      throw Object.assign(new Error(`No match found for version ${version}`), {
        statusCode: 404,
        code: 'E404',
        pkgid: `${pckmnt._id}@${version}`,
      })
    }

    return [pckmnt, data]
  }

  #packageOutput (data, name) {
    const json = this.npm.config.get('json')
    const versions = Object.keys(data)
    const includeVersions = versions.length > 1

    let includeFields
    const res = versions.flatMap((v) => {
      const fields = Object.entries(data[v])

      includeFields ||= (fields.length > 1)

      const msg = json ? {} : []

      for (let [f, d] of fields) {
        d = cleanup(d)

        if (json) {
          msg[f] = d
          continue
        }

        if (includeVersions || includeFields || typeof d !== 'string') {
          d = inspect(d, {
            showHidden: false,
            depth: 5,
            colors: this.npm.color,
            maxArrayLength: null,
          })
        }

        if (f && includeFields) {
          f += ' = '
        }

        msg.push(`${includeVersions ? `${name}@${v} ` : ''}${includeFields ? f : ''}${d}`)
      }

      return msg
    })

    if (json) {
      // TODO(BREAKING_CHANGE): all unwrapping should be removed. Users should know
      // based on their arguments if they can expect an array or an object. And this
      // unwrapping can break that assumption. Eg `npm view abbrev@^2` should always
      // return an array, but currently since there is only one version matching `^2`
      // this will return a single object instead.
      const first = Object.keys(res[0] || {})
      const jsonRes = first.length === 1 ? res.map(m => m[first[0]]) : res
      if (jsonRes.length === 0) {
        return
      }
      if (jsonRes.length === 1) {
        return jsonRes[0]
      }
      return jsonRes
    }

    return res.join('\n').trim()
  }

  #prettyView (packu, manifest) {
    // More modern, pretty printing of default view
    const unicode = this.npm.config.get('unicode')
    const chalk = this.npm.chalk
    const deps = Object.entries(manifest.dependencies || {}).map(([k, dep]) =>
      `${chalk.blue(k)}: ${dep}`
    )
    const site = manifest.homepage?.url || manifest.homepage
    const bins = Object.keys(manifest.bin || {})
    const licenseField = manifest.license || 'Proprietary'
    const license = typeof licenseField === 'string'
      ? licenseField
      : (licenseField.type || 'Proprietary')

    const res = []

    res.push('')
    res.push([
      chalk.underline.cyan(`${manifest.name}@${manifest.version}`),
      license.toLowerCase().trim() === 'proprietary'
        ? chalk.red(license)
        : chalk.green(license),
      `deps: ${deps.length ? chalk.cyan(deps.length) : chalk.cyan('none')}`,
      `versions: ${chalk.cyan(packu.versions.length + '')}`,
    ].join(' | '))

    manifest.description && res.push(manifest.description)
    if (site) {
      res.push(chalk.blue(site))
    }

    manifest.deprecated && res.push(
      `\n${chalk.redBright('DEPRECATED')}${unicode ? ' ⚠️ ' : '!!'} - ${manifest.deprecated}`
    )

    if (packu.keywords?.length) {
      res.push(`\nkeywords: ${
        packu.keywords.map(k => chalk.cyan(k)).join(', ')
      }`)
    }

    if (bins.length) {
      res.push(`\nbin: ${chalk.cyan(bins.join(', '))}`)
    }

    res.push('\ndist')
    res.push(`.tarball: ${chalk.blue(manifest.dist.tarball)}`)
    res.push(`.shasum: ${chalk.green(manifest.dist.shasum)}`)
    if (manifest.dist.integrity) {
      res.push(`.integrity: ${chalk.green(manifest.dist.integrity)}`)
    }
    if (manifest.dist.unpackedSize) {
      res.push(`.unpackedSize: ${chalk.blue(formatBytes(manifest.dist.unpackedSize, true))}`)
    }

    if (deps.length) {
      const maxDeps = 24
      res.push('\ndependencies:')
      res.push(columns(deps.slice(0, maxDeps), { padding: 1 }))
      if (deps.length > maxDeps) {
        res.push(chalk.dim(`(...and ${deps.length - maxDeps} more.)`))
      }
    }

    if (packu.maintainers?.length) {
      res.push('\nmaintainers:')
      packu.maintainers.forEach(u =>
        res.push(`- ${unparsePerson({
          name: chalk.blue(u.name),
          email: chalk.dim(u.email) })}`)
      )
    }

    res.push('\ndist-tags:')
    res.push(columns(Object.entries(packu['dist-tags']).map(([k, t]) =>
      `${chalk.blue(k)}: ${t}`
    )))

    const publisher = manifest._npmUser && unparsePerson({
      name: chalk.blue(manifest._npmUser.name),
      email: chalk.dim(manifest._npmUser.email),
    })
    if (publisher || packu.time) {
      let publishInfo = 'published'
      if (packu.time) {
        publishInfo += ` ${chalk.cyan(relativeDate(packu.time[manifest.version]))}`
      }
      if (publisher) {
        publishInfo += ` by ${publisher}`
      }
      res.push('')
      res.push(publishInfo)
    }

    return res.join('\n')
  }
}

module.exports = View

function parseArgs (args) {
  if (!args.length) {
    args = ['.']
  }

  const pkg = args.shift()

  return {
    pkg,
    local: /^\.@/.test(pkg) || pkg === '.',
    rest: args,
  }
}

function cleanData (obj, wholePackument) {
  // JSON formatted output (JSON or specific attributes from packument)
  const data = obj.reduce((acc, cur) => {
    if (cur) {
      Object.entries(cur).forEach(([k, v]) => {
        acc[k] ||= {}
        Object.keys(v).forEach((t) => {
          acc[k][t] = cur[k][t]
        })
      })
    }
    return acc
  }, {})

  if (wholePackument) {
    const cleaned = Object.entries(data).reduce((acc, [k, v]) => {
      acc[k] = v[Queryable.ALL]
      return acc
    }, {})
    log.silly('view', cleaned)
    return cleaned
  }

  return data
}

// return whatever was printed
function showFields ({ data, version, fields, json }) {
  const o = [data, version].reduce((acc, s) => {
    Object.entries(s).forEach(([k, v]) => {
      acc[k] = v
    })
    return acc
  }, {})

  const queryable = new Queryable(o)

  if (!fields.length) {
    return { [version.version]: queryable.query(Queryable.ALL) }
  }

  return fields.map((field) => {
    const s = queryable.query(field, { unwrapSingleItemArrays: !json })
    if (s) {
      return { [version.version]: s }
    }
  })
}

function cleanup (data) {
  if (Array.isArray(data)) {
    return data.map(cleanup)
  }

  if (!data || typeof data !== 'object') {
    return data
  }

  const keys = Object.keys(data)
  if (keys.length <= 3 && data.name && (
    (keys.length === 1) ||
    (keys.length === 3 && data.email && data.url) ||
    (keys.length === 2 && (data.email || data.url))
  )) {
    data = unparsePerson(data)
  }

  return data
}

const unparsePerson = (d) =>
  `${d.name}${d.email ? ` <${d.email}>` : ''}${d.url ? ` (${d.url})` : ''}`

function getCompletionFields (d, f = [], pref = []) {
  Object.entries(d).forEach(([k, v]) => {
    if (k.charAt(0) === '_' || k.indexOf('.') !== -1) {
      return
    }
    const p = pref.concat(k).join('.')
    f.push(p)
    if (Array.isArray(v)) {
      v.forEach((val, i) => {
        const pi = p + '[' + i + ']'
        if (val && typeof val === 'object') {
          getCompletionFields(val, f, [p])
        } else {
          f.push(pi)
        }
      })
      return
    }
    if (typeof v === 'object') {
      getCompletionFields(v, f, [p])
    }
  })
  return f
}
                                                                                                                                                                                                              node-23.7.0/deps/npm/lib/commands/whoami.js                                                         0000664 0000000 0000000 00000001017 14746647661 0020472 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { output } = require('proc-log')
const getIdentity = require('../utils/get-identity.js')
const BaseCommand = require('../base-cmd.js')

class Whoami extends BaseCommand {
  static description = 'Display npm username'
  static name = 'whoami'
  static params = ['registry']

  async exec () {
    const username = await getIdentity(this.npm, { ...this.npm.flatOptions })
    if (this.npm.config.get('json')) {
      output.buffer(username)
    } else {
      output.standard(username)
    }
  }
}

module.exports = Whoami
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/npm/lib/lifecycle-cmd.js                                                           0000664 0000000 0000000 00000001047 14746647661 0020110 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const BaseCommand = require('./base-cmd.js')

// The implementation of commands that are just "run a script"
// restart, start, stop, test
class LifecycleCmd extends BaseCommand {
  static usage = ['[-- <args>]']
  static isShellout = true
  static workspaces = true
  static ignoreImplicitWorkspace = false

  async exec (args) {
    return this.npm.exec('run-script', [this.constructor.name, ...args])
  }

  async execWorkspaces (args) {
    return this.npm.exec('run-script', [this.constructor.name, ...args])
  }
}

module.exports = LifecycleCmd
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/npm/lib/npm.js                                                                     0000664 0000000 0000000 00000033557 14746647661 0016215 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { resolve, dirname, join } = require('node:path')
const Config = require('@npmcli/config')
const which = require('which')
const fs = require('node:fs/promises')
const { definitions, flatten, shorthands } = require('@npmcli/config/lib/definitions')
const usage = require('./utils/npm-usage.js')
const LogFile = require('./utils/log-file.js')
const Timers = require('./utils/timers.js')
const Display = require('./utils/display.js')
const { log, time, output, META } = require('proc-log')
const { redactLog: replaceInfo } = require('@npmcli/redact')
const pkg = require('../package.json')
const { deref } = require('./utils/cmd-list.js')
const { jsonError, outputError } = require('./utils/output-error.js')

class Npm {
  static get version () {
    return pkg.version
  }

  static cmd (c) {
    const command = deref(c)
    if (!command) {
      throw Object.assign(new Error(`Unknown command ${c}`), {
        code: 'EUNKNOWNCOMMAND',
        command: c,
      })
    }
    return require(`./commands/${command}.js`)
  }

  unrefPromises = []
  updateNotification = null
  argv = []

  #command = null
  #runId = new Date().toISOString().replace(/[.:]/g, '_')
  #title = 'npm'
  #argvClean = []
  #npmRoot = null

  #display = null
  #logFile = new LogFile()
  #timers = new Timers()

  // all these options are only used by tests in order to make testing more
  // closely resemble real world usage. for now, npm has no programmatic API so
  // it is ok to add stuff here, but we should not rely on it more than
  // necessary. XXX: make these options not necessary by refactoring @npmcli/config
  //   - npmRoot: this is where npm looks for docs files and the builtin config
  //   - argv: this allows tests to extend argv in the same way the argv would
  //     be passed in via a CLI arg.
  //   - excludeNpmCwd: this is a hack to get @npmcli/config to stop walking up
  //     dirs to set a local prefix when it encounters the `npmRoot`. this
  //     allows tests created by tap inside this repo to not set the local
  //     prefix to `npmRoot` since that is the first dir it would encounter when
  //     doing implicit detection
  constructor ({
    stdout = process.stdout,
    stderr = process.stderr,
    npmRoot = dirname(__dirname),
    argv = [],
    excludeNpmCwd = false,
  } = {}) {
    this.#display = new Display({ stdout, stderr })
    this.#npmRoot = npmRoot
    this.config = new Config({
      npmPath: this.#npmRoot,
      definitions,
      flatten,
      shorthands,
      argv: [...process.argv, ...argv],
      excludeNpmCwd,
    })
  }

  async load () {
    let err
    try {
      return await time.start('npm:load', () => this.#load())
    } catch (e) {
      err = e
    }
    return this.#handleError(err)
  }

  async #load () {
    await time.start('npm:load:whichnode', async () => {
      // TODO should we throw here?
      const node = await which(process.argv[0]).catch(() => {})
      if (node && node.toUpperCase() !== process.execPath.toUpperCase()) {
        log.verbose('node symlink', node)
        process.execPath = node
        this.config.execPath = node
      }
    })

    await time.start('npm:load:configload', () => this.config.load())

    // npm --versions
    if (this.config.get('versions', 'cli')) {
      this.argv = ['version']
      this.config.set('usage', false, 'cli')
    } else {
      this.argv = [...this.config.parsedArgv.remain]
    }

    // Remove first argv since that is our command as typed
    // Note that this might not be the actual name of the command
    // due to aliases, etc. But we use the raw form of it later
    // in user output so it must be preserved as is.
    const commandArg = this.argv.shift()

    // This is the actual name of the command that will be run or
    // undefined if deref could not find a match
    const command = deref(commandArg)

    await this.#display.load({
      command,
      loglevel: this.config.get('loglevel'),
      stdoutColor: this.color,
      stderrColor: this.logColor,
      timing: this.config.get('timing'),
      unicode: this.config.get('unicode'),
      progress: this.flatOptions.progress,
      json: this.config.get('json'),
      heading: this.config.get('heading'),
    })
    process.env.COLOR = this.color ? '1' : '0'

    // npm -v
    // return from here early so we dont create any caches/logfiles/timers etc
    if (this.config.get('version', 'cli')) {
      output.standard(this.version)
      return { exec: false }
    }

    // mkdir this separately since the logs dir can be set to
    // a different location. if this fails, then we don't have
    // a cache dir, but we don't want to fail immediately since
    // the command might not need a cache dir (like `npm --version`)
    await time.start('npm:load:mkdirpcache', () =>
      fs.mkdir(this.cache, { recursive: true })
        .catch((e) => log.verbose('cache', `could not create cache: ${e}`)))

    // it's ok if this fails. user might have specified an invalid dir
    // which we will tell them about at the end
    if (this.config.get('logs-max') > 0) {
      await time.start('npm:load:mkdirplogs', () =>
        fs.mkdir(this.#logsDir, { recursive: true })
          .catch((e) => log.verbose('logfile', `could not create logs-dir: ${e}`)))
    }

    // note: this MUST be shorter than the actual argv length, because it
    // uses the same memory, so node will truncate it if it's too long.
    // We time this because setting process.title is slow sometimes but we
    // have to do it for security reasons. But still helpful to know how slow it is.
    time.start('npm:load:setTitle', () => {
      const { parsedArgv: { cooked, remain } } = this.config
      // Secrets are mostly in configs, so title is set using only the positional args
      // to keep those from being leaked.  We still do a best effort replaceInfo.
      this.#title = ['npm'].concat(replaceInfo(remain)).join(' ').trim()
      process.title = this.#title
      // The cooked argv is also logged separately for debugging purposes. It is
      // cleaned as a best effort by replacing known secrets like basic auth
      // password and strings that look like npm tokens. XXX: for this to be
      // safer the config should create a sanitized version of the argv as it
      // has the full context of what each option contains.
      this.#argvClean = replaceInfo(cooked)
      log.verbose('title', this.title)
      log.verbose('argv', this.#argvClean.map(JSON.stringify).join(' '))
    })

    // logFile.load returns a promise that resolves when old logs are done being cleaned.
    // We save this promise to an array so that we can await it in tests to ensure more
    // deterministic logging behavior. The process will also hang open if this were to
    // take a long time to resolve, but that is why process.exit is called explicitly
    // in the exit-handler.
    this.unrefPromises.push(this.#logFile.load({
      command,
      path: this.logPath,
      logsMax: this.config.get('logs-max'),
      timing: this.config.get('timing'),
    }))

    this.#timers.load({
      path: this.logPath,
      timing: this.config.get('timing'),
    })

    const configScope = this.config.get('scope')
    if (configScope && !/^@/.test(configScope)) {
      this.config.set('scope', `@${configScope}`, this.config.find('scope'))
    }

    if (this.config.get('force')) {
      log.warn('using --force', 'Recommended protections disabled.')
    }

    return { exec: true, command: commandArg, args: this.argv }
  }

  async exec (cmd, args = this.argv) {
    if (!this.#command) {
      let err
      try {
        await this.#exec(cmd, args)
      } catch (e) {
        err = e
      }
      return this.#handleError(err)
    } else {
      return this.#exec(cmd, args)
    }
  }

  // Call an npm command
  async #exec (cmd, args) {
    const Command = this.constructor.cmd(cmd)
    const command = new Command(this)

    // since 'test', 'start', 'stop', etc. commands re-enter this function
    // to call the run-script command, we need to only set it one time.
    if (!this.#command) {
      this.#command = command
      process.env.npm_command = this.command
    }

    if (this.config.get('usage')) {
      return output.standard(command.usage)
    }

    let execWorkspaces = false
    const hasWsConfig = this.config.get('workspaces') || this.config.get('workspace').length
    // if cwd is a workspace, the default is set to [that workspace]
    const implicitWs = this.config.get('workspace', 'default').length
    // (-ws || -w foo) && (cwd is not a workspace || command is not ignoring implicit workspaces)
    if (hasWsConfig && (!implicitWs || !Command.ignoreImplicitWorkspace)) {
      if (this.global) {
        throw new Error('Workspaces not supported for global packages')
      }
      if (!Command.workspaces) {
        throw Object.assign(new Error('This command does not support workspaces.'), {
          code: 'ENOWORKSPACES',
        })
      }
      execWorkspaces = true
    }

    if (command.checkDevEngines && !this.global) {
      await command.checkDevEngines()
    }

    return time.start(`command:${cmd}`, () =>
      execWorkspaces ? command.execWorkspaces(args) : command.exec(args))
  }

  // This gets called at the end of the exit handler and
  // during any tests to cleanup all of our listeners
  // Everything in here should be synchronous
  unload () {
    this.#timers.off()
    this.#display.off()
    this.#logFile.off()
  }

  finish (err) {
    // Finish all our timer work, this will write the file if requested, end timers, etc
    this.#timers.finish({
      id: this.#runId,
      command: this.#argvClean,
      logfiles: this.logFiles,
      version: this.version,
    })

    output.flush({
      [META]: true,
      // json can be set during a command so we send the
      // final value of it to the display layer here
      json: this.loaded && this.config.get('json'),
      jsonError: jsonError(err, this),
    })
  }

  exitErrorMessage () {
    if (this.logFiles.length) {
      return `A complete log of this run can be found in: ${this.logFiles}`
    }

    const logsMax = this.config.get('logs-max')
    if (logsMax <= 0) {
      // user specified no log file
      return `Log files were not written due to the config logs-max=${logsMax}`
    }

    // could be an error writing to the directory
    return `Log files were not written due to an error writing to the directory: ${this.#logsDir}` +
      '\nYou can rerun the command with `--loglevel=verbose` to see the logs in your terminal'
  }

  async #handleError (err) {
    if (err) {
      // Get the local package if it exists for a more helpful error message
      const localPkg = await require('@npmcli/package-json')
        .normalize(this.localPrefix)
        .then(p => p.content)
        .catch(() => null)
      Object.assign(err, this.#getError(err, { pkg: localPkg }))
    }

    this.finish(err)

    if (err) {
      throw err
    }
  }

  #getError (rawErr, opts) {
    const { files = [], ...error } = require('./utils/error-message.js').getError(rawErr, {
      npm: this,
      command: this.#command,
      ...opts,
    })

    const { writeFileSync } = require('node:fs')
    for (const [file, content] of files) {
      const filePath = `${this.logPath}${file}`
      const fileContent = `'Log files:\n${this.logFiles.join('\n')}\n\n${content.trim()}\n`
      try {
        writeFileSync(filePath, fileContent)
        error.detail.push(['', `\n\nFor a full report see:\n${filePath}`])
      } catch (fileErr) {
        log.warn('', `Could not write error message to ${file} due to ${fileErr}`)
      }
    }

    outputError(error)

    return error
  }

  get title () {
    return this.#title
  }

  get loaded () {
    return this.config.loaded
  }

  get version () {
    return this.constructor.version
  }

  get command () {
    return this.#command?.name
  }

  get flatOptions () {
    const { flat } = this.config
    flat.nodeVersion = process.version
    flat.npmVersion = pkg.version
    if (this.command) {
      flat.npmCommand = this.command
    }
    return flat
  }

  // color and logColor are a special derived values that takes into
  // consideration not only the config, but whether or not we are operating
  // in a tty with the associated output (stdout/stderr)
  get color () {
    return this.flatOptions.color
  }

  get logColor () {
    return this.flatOptions.logColor
  }

  get noColorChalk () {
    return this.#display.chalk.noColor
  }

  get chalk () {
    return this.#display.chalk.stdout
  }

  get logChalk () {
    return this.#display.chalk.stderr
  }

  get global () {
    return this.config.get('global') || this.config.get('location') === 'global'
  }

  get silent () {
    return this.flatOptions.silent
  }

  get lockfileVersion () {
    return 2
  }

  get started () {
    return this.#timers.started
  }

  get logFiles () {
    return this.#logFile.files
  }

  get #logsDir () {
    return this.config.get('logs-dir') || join(this.cache, '_logs')
  }

  get logPath () {
    return resolve(this.#logsDir, `${this.#runId}-`)
  }

  get npmRoot () {
    return this.#npmRoot
  }

  get cache () {
    return this.config.get('cache')
  }

  get globalPrefix () {
    return this.config.globalPrefix
  }

  get localPrefix () {
    return this.config.localPrefix
  }

  get localPackage () {
    return this.config.localPackage
  }

  get globalDir () {
    return process.platform !== 'win32'
      ? resolve(this.globalPrefix, 'lib', 'node_modules')
      : resolve(this.globalPrefix, 'node_modules')
  }

  get localDir () {
    return resolve(this.localPrefix, 'node_modules')
  }

  get dir () {
    return this.global ? this.globalDir : this.localDir
  }

  get globalBin () {
    const b = this.globalPrefix
    return process.platform !== 'win32' ? resolve(b, 'bin') : b
  }

  get localBin () {
    return resolve(this.dir, '.bin')
  }

  get bin () {
    return this.global ? this.globalBin : this.localBin
  }

  get prefix () {
    return this.global ? this.globalPrefix : this.localPrefix
  }

  get usage () {
    return usage(this)
  }
}

module.exports = Npm
                                                                                                                                                 node-23.7.0/deps/npm/lib/package-url-cmd.js                                                         0000664 0000000 0000000 00000003621 14746647661 0020344 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const pacote = require('pacote')
const { openUrl } = require('./utils/open-url.js')
const { log } = require('proc-log')
const BaseCommand = require('./base-cmd.js')

// Base command for opening urls from a package manifest (bugs, docs, repo)
class PackageUrlCommand extends BaseCommand {
  static params = [
    'browser',
    'registry',
    'workspace',
    'workspaces',
    'include-workspace-root',
  ]

  static workspaces = true
  static ignoreImplicitWorkspace = false
  static usage = ['[<pkgname> [<pkgname> ...]]']

  async exec (args) {
    if (!args || !args.length) {
      args = ['.']
    }

    for (const arg of args) {
      // XXX It is very odd that `where` is how pacote knows to look anywhere
      // other than the cwd.
      const opts = {
        ...this.npm.flatOptions,
        where: this.npm.localPrefix,
        fullMetadata: true,
      }
      const mani = await pacote.manifest(arg, opts)
      const url = this.getUrl(arg, mani)
      log.silly(this.name, 'url', url)
      await openUrl(this.npm, url, `${mani.name} ${this.name} available at the following URL`)
    }
  }

  async execWorkspaces (args) {
    if (args && args.length) {
      return this.exec(args)
    }
    await this.setWorkspaces()
    return this.exec(this.workspacePaths)
  }

  // given a manifest, try to get the hosted git info from it based on
  // repository (if a string) or repository.url (if an object) returns null
  // if it's not a valid repo, or not a known hosted repo
  hostedFromMani (mani) {
    const hostedGitInfo = require('hosted-git-info')
    const r = mani.repository
    const rurl = !r ? null
      : typeof r === 'string' ? r
      : typeof r === 'object' && typeof r.url === 'string' ? r.url
      : null

    // hgi returns undefined sometimes, but let's always return null here
    return (rurl && hostedGitInfo.fromUrl(rurl.replace(/^git\+/, ''))) || null
  }
}

module.exports = PackageUrlCommand
                                                                                                               node-23.7.0/deps/npm/lib/utils/                                                                     0000775 0000000 0000000 00000000000 14746647661 0016210 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/npm/lib/utils/audit-error.js                                                       0000664 0000000 0000000 00000002025 14746647661 0021002 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { log, output } = require('proc-log')
const { redactLog: replaceInfo } = require('@npmcli/redact')

// print an error or just nothing if the audit report has an error
// this is called by the audit command, and by the reify-output util
// prints a JSON version of the error if it's --json
// returns 'true' if there was an error, false otherwise

const auditError = (npm, report) => {
  if (!report || !report.error) {
    return false
  }

  if (npm.command !== 'audit') {
    return true
  }

  const { error } = report

  // ok, we care about it, then
  log.warn('audit', error.message)
  const { body: errBody } = error
  const body = Buffer.isBuffer(errBody) ? errBody.toString() : errBody
  if (npm.flatOptions.json) {
    output.buffer({
      message: error.message,
      method: error.method,
      uri: replaceInfo(error.uri),
      headers: error.headers,
      statusCode: error.statusCode,
      body,
    })
  } else {
    output.standard(body)
  }

  throw 'audit endpoint returned an error'
}

module.exports = auditError
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/npm/lib/utils/auth.js                                                              0000664 0000000 0000000 00000006333 14746647661 0017514 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { webAuthOpener, adduserWeb, loginWeb, loginCouch, adduserCouch } = require('npm-profile')
const { log } = require('proc-log')
const { createOpener } = require('../utils/open-url.js')
const read = require('../utils/read-user-info.js')

const otplease = async (npm, opts, fn) => {
  try {
    return await fn(opts)
  } catch (err) {
    if (!process.stdin.isTTY || !process.stdout.isTTY) {
      throw err
    }

    // web otp
    if (err.code === 'EOTP' && err.body?.authUrl && err.body?.doneUrl) {
      const { token: otp } = await webAuthOpener(
        createOpener(npm, 'Authenticate your account at'),
        err.body.authUrl,
        err.body.doneUrl,
        opts
      )
      return await fn({ ...opts, otp })
    }

    // classic otp
    if (err.code === 'EOTP' || (err.code === 'E401' && /one-time pass/.test(err.body))) {
      const otp = await read.otp('This operation requires a one-time password.\nEnter OTP:')
      return await fn({ ...opts, otp })
    }

    throw err
  }
}

const adduser = async (npm, { creds, ...opts }) => {
  const authType = npm.config.get('auth-type')
  let res
  if (authType === 'web') {
    try {
      res = await adduserWeb(createOpener(npm, 'Create your account at'), opts)
    } catch (err) {
      if (err.code === 'ENYI') {
        log.verbose('web add user not supported, trying couch')
      } else {
        throw err
      }
    }
  }

  // auth type !== web or ENYI error w/ web adduser
  if (!res) {
    const username = await read.username('Username:', creds.username)
    const password = await read.password('Password:', creds.password)
    const email = await read.email('Email: (this IS public) ', creds.email)
    // npm registry quirk: If you "add" an existing user with their current
    // password, it's effectively a login, and if that account has otp you'll
    // be prompted for it.
    res = await otplease(npm, opts, (reqOpts) => adduserCouch(username, email, password, reqOpts))
  }

  // We don't know the username if it was a web login, all we can reliably log is scope and registry
  const message = `Logged in${opts.scope ? ` to scope ${opts.scope}` : ''} on ${opts.registry}.`

  log.info('adduser', message)

  return {
    message,
    newCreds: { token: res.token },
  }
}

const login = async (npm, { creds, ...opts }) => {
  const authType = npm.config.get('auth-type')
  let res
  if (authType === 'web') {
    try {
      res = await loginWeb(createOpener(npm, 'Login at'), opts)
    } catch (err) {
      if (err.code === 'ENYI') {
        log.verbose('web login not supported, trying couch')
      } else {
        throw err
      }
    }
  }

  // auth type !== web or ENYI error w/ web login
  if (!res) {
    const username = await read.username('Username:', creds.username)
    const password = await read.password('Password:', creds.password)
    res = await otplease(npm, opts, (reqOpts) => loginCouch(username, password, reqOpts))
  }

  // We don't know the username if it was a web login, all we can reliably log is scope and registry
  const message = `Logged in${opts.scope ? ` to scope ${opts.scope}` : ''} on ${opts.registry}.`

  log.info('login', message)

  return {
    message,
    newCreds: { token: res.token },
  }
}

module.exports = {
  adduser,
  login,
  otplease,
}
                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/npm/lib/utils/cmd-list.js                                                          0000664 0000000 0000000 00000005617 14746647661 0020273 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const abbrev = require('abbrev')

// These correspond to filenames in lib/commands
// Please keep this list sorted alphabetically
const commands = [
  'access',
  'adduser',
  'audit',
  'bugs',
  'cache',
  'ci',
  'completion',
  'config',
  'dedupe',
  'deprecate',
  'diff',
  'dist-tag',
  'docs',
  'doctor',
  'edit',
  'exec',
  'explain',
  'explore',
  'find-dupes',
  'fund',
  'get',
  'help',
  'help-search',
  'hook',
  'init',
  'install',
  'install-ci-test',
  'install-test',
  'link',
  'll',
  'login',
  'logout',
  'ls',
  'org',
  'outdated',
  'owner',
  'pack',
  'ping',
  'pkg',
  'prefix',
  'profile',
  'prune',
  'publish',
  'query',
  'rebuild',
  'repo',
  'restart',
  'root',
  'run-script',
  'sbom',
  'search',
  'set',
  'shrinkwrap',
  'star',
  'stars',
  'start',
  'stop',
  'team',
  'test',
  'token',
  'uninstall',
  'unpublish',
  'unstar',
  'update',
  'version',
  'view',
  'whoami',
]

// These must resolve to an entry in commands
const aliases = {

  // aliases
  author: 'owner',
  home: 'docs',
  issues: 'bugs',
  info: 'view',
  show: 'view',
  find: 'search',
  add: 'install',
  unlink: 'uninstall',
  remove: 'uninstall',
  rm: 'uninstall',
  r: 'uninstall',

  // short names for common things
  un: 'uninstall',
  rb: 'rebuild',
  list: 'ls',
  ln: 'link',
  create: 'init',
  i: 'install',
  it: 'install-test',
  cit: 'install-ci-test',
  up: 'update',
  c: 'config',
  s: 'search',
  se: 'search',
  tst: 'test',
  t: 'test',
  ddp: 'dedupe',
  v: 'view',
  run: 'run-script',
  'clean-install': 'ci',
  'clean-install-test': 'install-ci-test',
  x: 'exec',
  why: 'explain',
  la: 'll',
  verison: 'version',
  ic: 'ci',

  // typos
  innit: 'init',
  // manually abbrev so that install-test doesn't make insta stop working
  in: 'install',
  ins: 'install',
  inst: 'install',
  insta: 'install',
  instal: 'install',
  isnt: 'install',
  isnta: 'install',
  isntal: 'install',
  isntall: 'install',
  'install-clean': 'ci',
  'isntall-clean': 'ci',
  hlep: 'help',
  'dist-tags': 'dist-tag',
  upgrade: 'update',
  udpate: 'update',
  rum: 'run-script',
  sit: 'install-ci-test',
  urn: 'run-script',
  ogr: 'org',
  'add-user': 'adduser',
}

const deref = (c) => {
  if (!c) {
    return
  }

  // Translate camelCase to snake-case (i.e. installTest to install-test)
  if (c.match(/[A-Z]/)) {
    c = c.replace(/([A-Z])/g, m => '-' + m.toLowerCase())
  }

  // if they asked for something exactly we are done
  if (commands.includes(c)) {
    return c
  }

  // if they asked for a direct alias
  if (aliases[c]) {
    return aliases[c]
  }

  const abbrevs = abbrev(commands.concat(Object.keys(aliases)))

  // first deref the abbrev, if there is one
  // then resolve any aliases
  // so `npm install-cl` will resolve to `install-clean` then to `ci`
  let a = abbrevs[c]
  while (aliases[a]) {
    a = aliases[a]
  }
  return a
}

module.exports = {
  aliases,
  commands,
  deref,
}
                                                                                                                 node-23.7.0/deps/npm/lib/utils/completion.fish                                                      0000664 0000000 0000000 00000003074 14746647661 0021240 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # npm completions for Fish shell
# This script is a work in progress and does not fall under the normal semver contract as the rest of npm.

# __fish_npm_needs_command taken from:
# https://stackoverflow.com/questions/16657803/creating-autocomplete-script-with-sub-commands
function __fish_npm_needs_command
    set -l cmd (commandline -opc)

    if test (count $cmd) -eq 1
        return 0
    end

    return 1
end

# Taken from https://github.com/fish-shell/fish-shell/blob/HEAD/share/completions/npm.fish
function __fish_complete_npm -d "Complete the commandline using npm's 'completion' tool"
    # tell npm we are fish shell
    set -lx COMP_FISH true
    if command -sq npm
        # npm completion is bash-centric, so we need to translate fish's "commandline" stuff to bash's $COMP_* stuff
        # COMP_LINE is an array with the words in the commandline
        set -lx COMP_LINE (commandline -opc)
        # COMP_CWORD is the index of the current word in COMP_LINE
        # bash starts arrays with 0, so subtract 1
        set -lx COMP_CWORD (math (count $COMP_LINE) - 1)
        # COMP_POINT is the index of point/cursor when the commandline is viewed as a string
        set -lx COMP_POINT (commandline -C)
        # If the cursor is after the last word, the empty token will disappear in the expansion
        # Readd it
        if test (commandline -ct) = ""
            set COMP_CWORD (math $COMP_CWORD + 1)
            set COMP_LINE $COMP_LINE ""
        end
        command npm completion -- $COMP_LINE 2>/dev/null
    end
end

# flush out what ships with fish
complete -e npm
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/npm/lib/utils/completion.sh                                                        0000775 0000000 0000000 00000003552 14746647661 0020725 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #!/bin/bash
###-begin-npm-completion-###
#
# npm command completion script
#
# Installation: npm completion >> ~/.bashrc  (or ~/.zshrc)
# Or, maybe: npm completion > /usr/local/etc/bash_completion.d/npm
#

if type complete &>/dev/null; then
  _npm_completion () {
    local words cword
    if type _get_comp_words_by_ref &>/dev/null; then
      _get_comp_words_by_ref -n = -n @ -n : -w words -i cword
    else
      cword="$COMP_CWORD"
      words=("${COMP_WORDS[@]}")
    fi

    local si="$IFS"
    if ! IFS=$'\n' COMPREPLY=($(COMP_CWORD="$cword" \
                           COMP_LINE="$COMP_LINE" \
                           COMP_POINT="$COMP_POINT" \
                           npm completion -- "${words[@]}" \
                           2>/dev/null)); then
      local ret=$?
      IFS="$si"
      return $ret
    fi
    IFS="$si"
    if type __ltrim_colon_completions &>/dev/null; then
      __ltrim_colon_completions "${words[cword]}"
    fi
  }
  complete -o default -F _npm_completion npm
elif type compdef &>/dev/null; then
  _npm_completion() {
    local si=$IFS
    compadd -- $(COMP_CWORD=$((CURRENT-1)) \
                 COMP_LINE=$BUFFER \
                 COMP_POINT=0 \
                 npm completion -- "${words[@]}" \
                 2>/dev/null)
    IFS=$si
  }
  compdef _npm_completion npm
elif type compctl &>/dev/null; then
  _npm_completion () {
    local cword line point words si
    read -Ac words
    read -cn cword
    let cword-=1
    read -l line
    read -ln point
    si="$IFS"
    if ! IFS=$'\n' reply=($(COMP_CWORD="$cword" \
                       COMP_LINE="$line" \
                       COMP_POINT="$point" \
                       npm completion -- "${words[@]}" \
                       2>/dev/null)); then

      local ret=$?
      IFS="$si"
      return $ret
    fi
    IFS="$si"
  }
  compctl -K _npm_completion npm
fi
###-end-npm-completion-###
                                                                                                                                                      node-23.7.0/deps/npm/lib/utils/did-you-mean.js                                                      0000664 0000000 0000000 00000002244 14746647661 0021040 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const Npm = require('../npm')
const { distance } = require('fastest-levenshtein')
const { commands } = require('./cmd-list.js')

const runScripts = ['stop', 'start', 'test', 'restart']

const isClose = (scmd, cmd) => distance(scmd, cmd) < scmd.length * 0.4

const didYouMean = (pkg, scmd) => {
  const { scripts = {}, bin = {} } = pkg || {}

  const best = [
    ...commands
      .filter(cmd => isClose(scmd, cmd) && scmd !== cmd)
      .map(str => [str, Npm.cmd(str).description]),
    ...Object.keys(scripts)
      // We would already be suggesting this in `npm x` so omit them here
      .filter(cmd => isClose(scmd, cmd) && !runScripts.includes(cmd))
      .map(str => [`run ${str}`, `run the "${str}" package script`]),
    ...Object.keys(bin)
      .filter(cmd => isClose(scmd, cmd))
      /* eslint-disable-next-line max-len */
      .map(str => [`exec ${str}`, `run the "${str}" command from either this or a remote npm package`]),
  ]

  if (best.length === 0) {
    return ''
  }

  return `\n\nDid you mean ${best.length === 1 ? 'this' : 'one of these'}?\n` +
    best.slice(0, 3).map(([msg, comment]) => `  npm ${msg} # ${comment}`).join('\n')
}

module.exports = didYouMean
                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/npm/lib/utils/display.js                                                           0000664 0000000 0000000 00000036605 14746647661 0020225 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { log, output, input, META } = require('proc-log')
const { explain } = require('./explain-eresolve.js')
const { formatWithOptions } = require('./format')

// This is the general approach to color:
// Eventually this will be exposed somewhere we can refer to these by name.
// Foreground colors only. Never set the background color.
/*
 * Black # (Don't use)
 * Red # Danger
 * Green # Success
 * Yellow # Warning
 * Blue # Accent
 * Magenta # Done
 * Cyan # Emphasis
 * White # (Don't use)
 */

// Translates log levels to chalk colors
const COLOR_PALETTE = ({ chalk: c }) => ({
  heading: c.bold,
  title: c.blueBright,
  timing: c.magentaBright,
  // loglevels
  error: c.red,
  warn: c.yellow,
  notice: c.cyanBright,
  http: c.green,
  info: c.cyan,
  verbose: c.blue,
  silly: c.blue.dim,
})

const LEVEL_OPTIONS = {
  silent: {
    index: 0,
  },
  error: {
    index: 1,
  },
  warn: {
    index: 2,
  },
  notice: {
    index: 3,
  },
  http: {
    index: 4,
  },
  info: {
    index: 5,
  },
  verbose: {
    index: 6,
  },
  silly: {
    index: 7,
  },
}

const LEVEL_METHODS = {
  ...LEVEL_OPTIONS,
  [log.KEYS.timing]: {
    show: ({ timing, index }) => !!timing && index !== 0,
  },
}

const setBlocking = (stream) => {
  // Copied from https://github.com/yargs/set-blocking
  // https://raw.githubusercontent.com/yargs/set-blocking/master/LICENSE.txt
  /* istanbul ignore next - we trust that this works */
  if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {
    stream._handle.setBlocking(true)
  }
  return stream
}

// These are important
// This is the key that is returned to the user for errors
const ERROR_KEY = 'error'
// This is the key producers use to indicate that there
// is a json error that should be merged into the finished output
const JSON_ERROR_KEY = 'jsonError'

const isPlainObject = (v) => v && typeof v === 'object' && !Array.isArray(v)

const getArrayOrObject = (items) => {
  if (items.length) {
    const foundNonObject = items.find(o => !isPlainObject(o))
    // Non-objects and arrays cant be merged, so just return the first item
    if (foundNonObject) {
      return foundNonObject
    }
    // We use objects with 0,1,2,etc keys to merge array
    if (items.every((o, i) => Object.hasOwn(o, i))) {
      return Object.assign([], ...items)
    }
  }
  // Otherwise its an object with all object items merged together
  return Object.assign({}, ...items.filter(o => isPlainObject(o)))
}

const getJsonBuffer = ({ [JSON_ERROR_KEY]: metaError }, buffer) => {
  const items = []
  // meta also contains the meta object passed to flush
  const errors = metaError ? [metaError] : []
  // index 1 is the meta, 2 is the logged argument
  for (const [, { [JSON_ERROR_KEY]: error }, obj] of buffer) {
    if (obj) {
      items.push(obj)
    }
    if (error) {
      errors.push(error)
    }
  }

  if (!items.length && !errors.length) {
    return null
  }

  const res = getArrayOrObject(items)

  // This skips any error checking since we can only set an error property
  // on an object that can be stringified
  // XXX(BREAKING_CHANGE): remove this in favor of always returning an object with result and error keys
  if (isPlainObject(res) && errors.length) {
    // This is not ideal. JSON output has always been keyed at the root with an `error`
    // key, so we cant change that without it being a breaking change. At the same time
    // some commands output arbitrary keys at the top level of the output, such as package
    // names. So the output could already have the same key. The choice here is to overwrite
    // it with our error since that is (probably?) more important.
    // XXX(BREAKING_CHANGE): all json output should be keyed under well known keys, eg `result` and `error`
    if (res[ERROR_KEY]) {
      log.warn('', `overwriting existing ${ERROR_KEY} on json output`)
    }
    res[ERROR_KEY] = getArrayOrObject(errors)
  }

  return res
}

const withMeta = (handler) => (level, ...args) => {
  let meta = {}
  const last = args.at(-1)
  if (last && typeof last === 'object' && Object.hasOwn(last, META)) {
    meta = args.pop()
  }
  return handler(level, meta, ...args)
}

class Display {
  #logState = {
    buffering: true,
    buffer: [],
  }

  #outputState = {
    buffering: true,
    buffer: [],
  }

  // colors
  #noColorChalk
  #stdoutChalk
  #stdoutColor
  #stderrChalk
  #stderrColor
  #logColors

  // progress
  #progress

  // options
  #command
  #levelIndex
  #timing
  #json
  #heading
  #silent

  // display streams
  #stdout
  #stderr

  constructor ({ stdout, stderr }) {
    this.#stdout = setBlocking(stdout)
    this.#stderr = setBlocking(stderr)

    // Handlers are set immediately so they can buffer all events
    process.on('log', this.#logHandler)
    process.on('output', this.#outputHandler)
    process.on('input', this.#inputHandler)
    this.#progress = new Progress({ stream: stderr })
  }

  off () {
    process.off('log', this.#logHandler)
    this.#logState.buffer.length = 0
    process.off('output', this.#outputHandler)
    this.#outputState.buffer.length = 0
    process.off('input', this.#inputHandler)
    this.#progress.off()
  }

  get chalk () {
    return {
      noColor: this.#noColorChalk,
      stdout: this.#stdoutChalk,
      stderr: this.#stderrChalk,
    }
  }

  async load ({
    command,
    heading,
    json,
    loglevel,
    progress,
    stderrColor,
    stdoutColor,
    timing,
    unicode,
  }) {
    // get createSupportsColor from chalk directly if this lands
    // https://github.com/chalk/chalk/pull/600
    const [{ Chalk }, { createSupportsColor }] = await Promise.all([
      import('chalk'),
      import('supports-color'),
    ])
    // we get the chalk level based on a null stream meaning chalk will only use
    // what it knows about the environment to get color support since we already
    // determined in our definitions that we want to show colors.
    const level = Math.max(createSupportsColor(null).level, 1)
    this.#noColorChalk = new Chalk({ level: 0 })
    this.#stdoutColor = stdoutColor
    this.#stdoutChalk = stdoutColor ? new Chalk({ level }) : this.#noColorChalk
    this.#stderrColor = stderrColor
    this.#stderrChalk = stderrColor ? new Chalk({ level }) : this.#noColorChalk
    this.#logColors = COLOR_PALETTE({ chalk: this.#stderrChalk })

    this.#command = command
    this.#levelIndex = LEVEL_OPTIONS[loglevel].index
    this.#timing = timing
    this.#json = json
    this.#heading = heading
    this.#silent = this.#levelIndex <= 0

    // Emit resume event on the logs which will flush output
    log.resume()
    output.flush()
    this.#progress.load({
      unicode,
      enabled: !!progress && !this.#silent,
    })
  }

  // STREAM WRITES

  // Write formatted and (non-)colorized output to streams
  #write (stream, options, ...args) {
    const colors = stream === this.#stdout ? this.#stdoutColor : this.#stderrColor
    const value = formatWithOptions({ colors, ...options }, ...args)
    this.#progress.write(() => stream.write(value))
  }

  // HANDLERS

  // Arrow function assigned to a private class field so it can be passed
  // directly as a listener and still reference "this"
  #logHandler = withMeta((level, meta, ...args) => {
    switch (level) {
      case log.KEYS.resume:
        this.#logState.buffering = false
        this.#logState.buffer.forEach((item) => this.#tryWriteLog(...item))
        this.#logState.buffer.length = 0
        break

      case log.KEYS.pause:
        this.#logState.buffering = true
        break

      default:
        if (this.#logState.buffering) {
          this.#logState.buffer.push([level, meta, ...args])
        } else {
          this.#tryWriteLog(level, meta, ...args)
        }
        break
    }
  })

  // Arrow function assigned to a private class field so it can be passed
  // directly as a listener and still reference "this"
  #outputHandler = withMeta((level, meta, ...args) => {
    this.#json = typeof meta.json === 'boolean' ? meta.json : this.#json
    switch (level) {
      case output.KEYS.flush: {
        this.#outputState.buffering = false
        if (this.#json) {
          const json = getJsonBuffer(meta, this.#outputState.buffer)
          if (json) {
            this.#writeOutput(output.KEYS.standard, meta, JSON.stringify(json, null, 2))
          }
        } else {
          this.#outputState.buffer.forEach((item) => this.#writeOutput(...item))
        }
        this.#outputState.buffer.length = 0
        break
      }

      case output.KEYS.buffer:
        this.#outputState.buffer.push([output.KEYS.standard, meta, ...args])
        break

      default:
        if (this.#outputState.buffering) {
          this.#outputState.buffer.push([level, meta, ...args])
        } else {
          // HACK: Check if the argument looks like a run-script banner. This can be
          // replaced with proc-log.META in @npmcli/run-script
          if (typeof args[0] === 'string' && args[0].startsWith('\n> ') && args[0].endsWith('\n')) {
            if (this.#silent || ['exec', 'explore'].includes(this.#command)) {
              // Silent mode and some specific commands always hide run script banners
              break
            } else if (this.#json) {
              // In json mode, change output to stderr since we dont want to break json
              // parsing on stdout if the user is piping to jq or something.
              // XXX: in a future (breaking?) change it might make sense for run-script to
              // always output these banners with proc-log.output.error if we think they
              // align closer with "logging" instead of "output"
              level = output.KEYS.error
            }
          }
          this.#writeOutput(level, meta, ...args)
        }
        break
    }
  })

  #inputHandler = withMeta((level, meta, ...args) => {
    switch (level) {
      case input.KEYS.start:
        log.pause()
        this.#outputState.buffering = true
        this.#progress.off()
        break

      case input.KEYS.end:
        log.resume()
        output.flush()
        this.#progress.resume()
        break

      case input.KEYS.read: {
        // The convention when calling input.read is to pass in a single fn that returns
        // the promise to await. resolve and reject are provided by proc-log
        const [res, rej, p] = args
        return input.start(() => p()
          .then(res)
          .catch(rej)
          // Any call to procLog.input.read will render a prompt to the user, so we always
          // add a single newline of output to stdout to move the cursor to the next line
          .finally(() => output.standard('')))
      }
    }
  })

  // OUTPUT

  #writeOutput (level, meta, ...args) {
    switch (level) {
      case output.KEYS.standard:
        this.#write(this.#stdout, {}, ...args)
        break

      case output.KEYS.error:
        this.#write(this.#stderr, {}, ...args)
        break
    }
  }

  // LOGS

  #tryWriteLog (level, meta, ...args) {
    try {
      // Also (and this is a really inexcusable kludge), we patch the
      // log.warn() method so that when we see a peerDep override
      // explanation from Arborist, we can replace the object with a
      // highly abbreviated explanation of what's being overridden.
      // TODO: this could probably be moved to arborist now that display is refactored
      const [heading, message, expl] = args
      if (level === log.KEYS.warn && heading === 'ERESOLVE' && expl && typeof expl === 'object') {
        this.#writeLog(level, meta, heading, message)
        this.#writeLog(level, meta, '', explain(expl, this.#stderrChalk, 2))
        return
      }
      this.#writeLog(level, meta, ...args)
    } catch (ex) {
      try {
        // if it crashed once, it might again!
        this.#writeLog(log.KEYS.verbose, meta, '', `attempt to log crashed`, ...args, ex)
      } catch (ex2) {
        // This happens if the object has an inspect method that crashes so just console.error
        // with the errors but don't do anything else that might error again.
        // eslint-disable-next-line no-console
        console.error(`attempt to log crashed`, ex, ex2)
      }
    }
  }

  #writeLog (level, meta, ...args) {
    const levelOpts = LEVEL_METHODS[level]
    const show = levelOpts.show ?? (({ index }) => levelOpts.index <= index)
    const force = meta.force && !this.#silent

    if (force || show({ index: this.#levelIndex, timing: this.#timing })) {
      // this mutates the array so we can pass args directly to format later
      const title = args.shift()
      const prefix = [
        this.#logColors.heading(this.#heading),
        this.#logColors[level](level),
        title ? this.#logColors.title(title) : null,
      ]
      this.#write(this.#stderr, { prefix }, ...args)
    }
  }
}

class Progress {
  // Taken from https://github.com/sindresorhus/cli-spinners
  // MIT License
  // Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)
  static dots = { duration: 80, frames: ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'] }
  static lines = { duration: 130, frames: ['-', '\\', '|', '/'] }

  #stream
  #spinner
  #enabled = false

  #frameIndex = 0
  #lastUpdate = 0
  #interval
  #timeout

  // We are rendering is enabled option is set and we are not waiting for the render timeout
  get #rendering () {
    return this.#enabled && !this.#timeout
  }

  // We are spinning if enabled option is set and the render interval has been set
  get #spinning () {
    return this.#enabled && this.#interval
  }

  constructor ({ stream }) {
    this.#stream = stream
  }

  load ({ enabled, unicode }) {
    this.#enabled = enabled
    this.#spinner = unicode ? Progress.dots : Progress.lines
    // Dont render the spinner for short durations
    this.#render(200)
  }

  off () {
    if (!this.#enabled) {
      return
    }
    clearTimeout(this.#timeout)
    this.#timeout = null
    clearInterval(this.#interval)
    this.#interval = null
    this.#frameIndex = 0
    this.#lastUpdate = 0
    this.#clearSpinner()
  }

  resume () {
    this.#render()
  }

  // If we are currenting rendering the spinner we clear it
  // before writing our line and then re-render the spinner after.
  // If not then all we need to do is write the line
  write (write) {
    if (this.#spinning) {
      this.#clearSpinner()
    }
    write()
    if (this.#spinning) {
      this.#render()
    }
  }

  #render (ms) {
    if (ms) {
      this.#timeout = setTimeout(() => {
        this.#timeout = null
        this.#renderSpinner()
      }, ms)
      // Make sure this timeout does not keep the process open
      this.#timeout.unref()
    } else {
      this.#renderSpinner()
    }
  }

  #renderSpinner () {
    if (!this.#rendering) {
      return
    }
    // We always attempt to render immediately but we only request to move to the next
    // frame if it has been longer than our spinner frame duration since our last update
    this.#renderFrame(Date.now() - this.#lastUpdate >= this.#spinner.duration)
    clearInterval(this.#interval)
    this.#interval = setInterval(() => this.#renderFrame(true), this.#spinner.duration)
  }

  #renderFrame (next) {
    if (next) {
      this.#lastUpdate = Date.now()
      this.#frameIndex++
      if (this.#frameIndex >= this.#spinner.frames.length) {
        this.#frameIndex = 0
      }
    }
    this.#clearSpinner()
    this.#stream.write(this.#spinner.frames[this.#frameIndex])
  }

  #clearSpinner () {
    // Move to the start of the line and clear the rest of the line
    this.#stream.cursorTo(0)
    this.#stream.clearLine(1)
  }
}

module.exports = Display
                                                                                                                           node-23.7.0/deps/npm/lib/utils/error-message.js                                                     0000664 0000000 0000000 00000035456 14746647661 0021336 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { format } = require('node:util')
const { resolve } = require('node:path')
const { redactLog: replaceInfo } = require('@npmcli/redact')
const { log } = require('proc-log')

const errorMessage = (er, npm) => {
  const summary = []
  const detail = []
  const files = []

  er.message &&= replaceInfo(er.message)
  er.stack &&= replaceInfo(er.stack)

  switch (er.code) {
    case 'ERESOLVE': {
      const { report } = require('./explain-eresolve.js')
      summary.push(['ERESOLVE', er.message])
      detail.push(['', ''])
      // XXX(display): error messages are logged so we use the logColor since that is based
      // on stderr. This should be handled solely by the display layer so it could also be
      // printed to stdout if necessary.
      const { explanation, file } = report(er, npm.logChalk, npm.noColorChalk)
      detail.push(['', explanation])
      files.push(['eresolve-report.txt', file])
      break
    }

    case 'ENOLOCK': {
      const cmd = npm.command || ''
      summary.push([cmd, 'This command requires an existing lockfile.'])
      detail.push([cmd, 'Try creating one first with: npm i --package-lock-only'])
      detail.push([cmd, `Original error: ${er.message}`])
      break
    }

    case 'ENOAUDIT':
      summary.push(['audit', er.message])
      break

    case 'ECONNREFUSED':
      summary.push(['', er])
      detail.push(['', [
        '',
        'If you are behind a proxy, please make sure that the',
        "'proxy' config is set properly.  See: 'npm help config'",
      ].join('\n')])
      break

    case 'EACCES':
    case 'EPERM': {
      const isCachePath =
        typeof er.path === 'string' && npm.loaded && er.path.startsWith(npm.config.get('cache'))
      const isCacheDest =
        typeof er.dest === 'string' && npm.loaded && er.dest.startsWith(npm.config.get('cache'))

      if (process.platform !== 'win32' && (isCachePath || isCacheDest)) {
        // user probably doesn't need this, but still add it to the debug log
        log.verbose(er.stack)
        summary.push(['', [
          '',
          'Your cache folder contains root-owned files, due to a bug in',
          'previous versions of npm which has since been addressed.',
          '',
          'To permanently fix this problem, please run:',
          `  sudo chown -R ${process.getuid()}:${process.getgid()} "${npm.config.get('cache')}"`,
        ].join('\n')])
      } else {
        summary.push(['', er])
        detail.push(['', [
          '',
          'The operation was rejected by your operating system.',
          ...process.platform === 'win32' ? [
            "It's possible that the file was already in use (by a text editor or antivirus),",
            'or that you lack permissions to access it.',
          ] : [
            'It is likely you do not have the permissions to access this file as the current user',
          ],
          '',
          'If you believe this might be a permissions issue, please double-check the',
          'permissions of the file and its containing directories, or try running',
          'the command again as root/Administrator.',
        ].join('\n')])
      }
      break
    }

    case 'ENOGIT':
      summary.push(['', er.message])
      detail.push(['', [
        '',
        'Failed using git.',
        'Please check if you have git installed and in your PATH.',
      ].join('\n')])
      break

    case 'EJSONPARSE':
      // Check whether we ran into a conflict in our own package.json
      if (er.path === resolve(npm.prefix, 'package.json')) {
        const { isDiff } = require('parse-conflict-json')
        const txt = require('node:fs').readFileSync(er.path, 'utf8').replace(/\r\n/g, '\n')
        if (isDiff(txt)) {
          detail.push(['', [
            'Merge conflict detected in your package.json.',
            '',
            'Please resolve the package.json conflict and retry.',
          ].join('\n')])
          break
        }
      }
      summary.push(['JSON.parse', er.message])
      detail.push(['JSON.parse', [
        'Failed to parse JSON data.',
        'Note: package.json must be actual JSON, not just JavaScript.',
      ].join('\n')])
      break

    case 'EOTP':
    case 'E401':
      // E401 is for places where we accidentally neglect OTP stuff
      if (er.code === 'EOTP' || /one-time pass/.test(er.message)) {
        summary.push(['', 'This operation requires a one-time password from your authenticator.'])
        detail.push(['', [
          'You can provide a one-time password by passing --otp=<code> to the command you ran.',
          'If you already provided a one-time password then it is likely that you either typoed',
          'it, or it timed out. Please try again.',
        ].join('\n')])
      } else {
        // npm ERR! code E401
        // npm ERR! Unable to authenticate, need: Basic
        const auth = !er.headers || !er.headers['www-authenticate']
          ? []
          : er.headers['www-authenticate'].map(au => au.split(/[,\s]+/))[0]

        if (auth.includes('Bearer')) {
          summary.push(['',
            'Unable to authenticate, your authentication token seems to be invalid.',
          ])
          detail.push(['', [
            'To correct this please try logging in again with:',
            '  npm login',
          ].join('\n')])
        } else if (auth.includes('Basic')) {
          summary.push(['', 'Incorrect or missing password.'])
          detail.push(['', [
            'If you were trying to login, change your password, create an',
            'authentication token or enable two-factor authentication then',
            'that means you likely typed your password in incorrectly.',
            'Please try again, or recover your password at:',
            '  https://www.npmjs.com/forgot',
            '',
            'If you were doing some other operation then your saved credentials are',
            'probably out of date. To correct this please try logging in again with:',
            '  npm login',
          ].join('\n')])
        } else {
          summary.push(['', er.message || er])
        }
      }
      break

    case 'E404':
      // There's no need to have 404 in the message as well.
      summary.push(['404', er.message.replace(/^404\s+/, '')])
      if (er.pkgid && er.pkgid !== '-') {
        const pkg = er.pkgid.replace(/(?!^)@.*$/, '')

        detail.push(['404', ''])
        detail.push(['404', '', `'${replaceInfo(er.pkgid)}' is not in this registry.`])

        const nameValidator = require('validate-npm-package-name')
        const valResult = nameValidator(pkg)

        if (!valResult.validForNewPackages) {
          detail.push(['404', 'This package name is not valid, because', ''])

          const errorsArray = [...(valResult.errors || []), ...(valResult.warnings || [])]
          errorsArray.forEach((item, idx) => detail.push(['404', ' ' + (idx + 1) + '. ' + item]))
        }

        detail.push(['404', ''])
        detail.push(['404', 'Note that you can also install from a'])
        detail.push(['404', 'tarball, folder, http url, or git url.'])
      }
      break

    case 'EPUBLISHCONFLICT':
      summary.push(['publish fail', 'Cannot publish over existing version.'])
      detail.push(['publish fail', "Update the 'version' field in package.json and try again."])
      detail.push(['publish fail', ''])
      detail.push(['publish fail', 'To automatically increment version numbers, see:'])
      detail.push(['publish fail', '  npm help version'])
      break

    case 'EISGIT':
      summary.push(['git', er.message])
      summary.push(['git', `  ${er.path}`])
      detail.push(['git', [
        'Refusing to remove it. Update manually,',
        'or move it out of the way first.',
      ].join('\n')])
      break

    case 'EBADDEVENGINES': {
      const { current, required } = er
      summary.push(['EBADDEVENGINES', er.message])
      detail.push(['EBADDEVENGINES', { current, required }])
      break
    }

    case 'EBADPLATFORM': {
      const actual = er.current
      const expected = { ...er.required }
      const checkedKeys = []
      for (const key in expected) {
        if (Array.isArray(expected[key]) && expected[key].length > 0) {
          expected[key] = expected[key].join(',')
          checkedKeys.push(key)
        } else if (expected[key] === undefined ||
            Array.isArray(expected[key]) && expected[key].length === 0) {
          delete expected[key]
          delete actual[key]
        } else {
          checkedKeys.push(key)
        }
      }

      const longestKey = Math.max(...checkedKeys.map((key) => key.length))
      const detailEntry = []
      for (const key of checkedKeys) {
        const padding = key.length === longestKey
          ? 1
          : 1 + (longestKey - key.length)

        // padding + 1 because 'actual' is longer than 'valid'
        detailEntry.push(`Valid ${key}:${' '.repeat(padding + 1)}${expected[key]}`)
        detailEntry.push(`Actual ${key}:${' '.repeat(padding)}${actual[key]}`)
      }

      summary.push(['notsup', format(
        'Unsupported platform for %s: wanted %j (current: %j)',
        er.pkgid,
        expected,
        actual
      )])
      detail.push(['notsup', detailEntry.join('\n')])
      break
    }

    case 'EEXIST':
      summary.push(['', er.message])
      summary.push(['', 'File exists: ' + (er.dest || er.path)])
      detail.push(['', 'Remove the existing file and try again, or run npm'])
      detail.push(['', 'with --force to overwrite files recklessly.'])
      break

    case 'ENEEDAUTH':
      summary.push(['need auth', er.message])
      detail.push(['need auth', 'You need to authorize this machine using `npm adduser`'])
      break

    case 'ECONNRESET':
    case 'ENOTFOUND':
    case 'ETIMEDOUT':
    case 'ERR_SOCKET_TIMEOUT':
    case 'EAI_FAIL':
      summary.push(['network', er.message])
      detail.push(['network', [
        'This is a problem related to network connectivity.',
        'In most cases you are behind a proxy or have bad network settings.',
        '',
        'If you are behind a proxy, please make sure that the',
        "'proxy' config is set properly.  See: 'npm help config'",
      ].join('\n')])
      break

    case 'ETARGET':
      summary.push(['notarget', er.message])
      detail.push(['notarget', [
        'In most cases you or one of your dependencies are requesting',
        "a package version that doesn't exist.",
      ].join('\n')])
      break

    case 'E403':
      summary.push(['403', er.message])
      detail.push(['403', [
        'In most cases, you or one of your dependencies are requesting',
        'a package version that is forbidden by your security policy, or',
        'on a server you do not have access to.',
      ].join('\n')])
      break

    case 'EBADENGINE':
      summary.push(['engine', er.message])
      summary.push(['engine', 'Not compatible with your version of node/npm: ' + er.pkgid])
      detail.push(['notsup', [
        'Not compatible with your version of node/npm: ' + er.pkgid,
        'Required: ' + JSON.stringify(er.required),
        'Actual:   ' +
        JSON.stringify({ npm: npm.version, node: process.version }),
      ].join('\n')])
      break

    case 'ENOSPC':
      summary.push(['nospc', er.message])
      detail.push(['nospc', [
        'There appears to be insufficient space on your system to finish.',
        'Clear up some disk space and try again.',
      ].join('\n')])
      break

    case 'EROFS':
      summary.push(['rofs', er.message])
      detail.push(['rofs', [
        'Often virtualized file systems, or other file systems',
        "that don't support symlinks, give this error.",
      ].join('\n')])
      break

    case 'ENOENT':
      summary.push(['enoent', er.message])
      detail.push(['enoent', [
        'This is related to npm not being able to find a file.',
        er.file ? `\nCheck if the file '${er.file}' is present.` : '',
      ].join('\n')])
      break

    case 'EMISSINGARG':
    case 'EUNKNOWNTYPE':
    case 'EINVALIDTYPE':
    case 'ETOOMANYARGS':
      summary.push(['typeerror', er.stack])
      detail.push(['typeerror', [
        'This is an error with npm itself. Please report this error at:',
        '  https://github.com/npm/cli/issues',
      ].join('\n')])
      break

    default:
      summary.push(['', er.message || er])
      if (er.cause) {
        detail.push(['cause', er.cause.message])
      }
      if (er.signal) {
        detail.push(['signal', er.signal])
      }
      if (er.cmd && Array.isArray(er.args)) {
        detail.push(['command', ...[er.cmd, ...er.args.map(replaceInfo)]])
      }
      if (er.stdout) {
        detail.push(['', er.stdout.trim()])
      }
      if (er.stderr) {
        detail.push(['', er.stderr.trim()])
      }
      break
  }

  return {
    summary,
    detail,
    files,
  }
}

const getExitCodeFromError = (err) => {
  if (typeof err?.errno === 'number') {
    return err.errno
  } else if (typeof err?.code === 'number') {
    return err.code
  }
}

const getError = (err, { npm, command, pkg }) => {
  // if we got a command that just shells out to something else, then it
  // will presumably print its own errors and exit with a proper status
  // code if there's a problem.  If we got an error with a code=0, then...
  // something else went wrong along the way, so maybe an npm problem?
  if (command?.constructor?.isShellout && typeof err.code === 'number' && err.code) {
    return {
      exitCode: err.code,
      suppressError: true,
    }
  }

  // XXX: we should stop throwing strings
  if (typeof err === 'string') {
    return {
      exitCode: 1,
      suppressError: true,
      summary: [['', err]],
    }
  }

  // XXX: we should stop throwing other non-errors
  if (!(err instanceof Error)) {
    return {
      exitCode: 1,
      suppressError: true,
      summary: [['weird error', err]],
    }
  }

  if (err.code === 'EUNKNOWNCOMMAND') {
    const suggestions = require('./did-you-mean.js')(pkg, err.command)
    return {
      exitCode: 1,
      suppressError: true,
      standard: [
        `Unknown command: "${err.command}"`,
        suggestions,
        'To see a list of supported npm commands, run:',
        '  npm help',
      ],
    }
  }

  // Anything after this is not suppressed and get more logged information

  // add a code to the error if it doesnt have one and mutate some properties
  // so they have redacted information
  err.code ??= err.message.match(/^(?:Error: )?(E[A-Z]+)/)?.[1]
  // this mutates the error and redacts stack/message
  const { summary, detail, files } = errorMessage(err, npm)

  return {
    err,
    code: err.code,
    exitCode: getExitCodeFromError(err) || 1,
    suppressError: false,
    summary,
    detail,
    files,
    verbose: ['type', 'stack', 'statusCode', 'pkgid']
      .filter(k => err[k])
      .map(k => [k, replaceInfo(err[k])]),
    error: ['code', 'syscall', 'file', 'path', 'dest', 'errno']
      .filter(k => err[k])
      .map(k => [k, err[k]]),
  }
}

module.exports = {
  getExitCodeFromError,
  errorMessage,
  getError,
}
                                                                                                                                                                                                                  node-23.7.0/deps/npm/lib/utils/explain-dep.js                                                       0000664 0000000 0000000 00000006037 14746647661 0020762 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { relative } = require('node:path')

const explainNode = (node, depth, chalk) =>
  printNode(node, chalk) +
  explainDependents(node, depth, chalk) +
  explainLinksIn(node, depth, chalk)

const colorType = (type, chalk) => {
  const style = type === 'extraneous' ? chalk.red
    : type === 'dev' ? chalk.blue
    : type === 'optional' ? chalk.magenta
    : type === 'peer' ? chalk.magentaBright
    : type === 'bundled' ? chalk.underline.cyan
    : type === 'workspace' ? chalk.blueBright
    : type === 'overridden' ? chalk.dim
    : /* istanbul ignore next */ s => s
  return style(type)
}

const printNode = (node, chalk) => {
  const extra = []

  for (const meta of ['extraneous', 'dev', 'optional', 'peer', 'bundled', 'overridden']) {
    if (node[meta]) {
      extra.push(` ${colorType(meta, chalk)}`)
    }
  }

  const pkgid = node.isWorkspace
    ? chalk.blueBright(`${node.name}@${node.version}`)
    : `${node.name}@${node.version}`

  return `${pkgid}${extra.join('')}` +
    (node.location ? chalk.dim(`\n${node.location}`) : '')
}

const explainLinksIn = ({ linksIn }, depth, chalk) => {
  if (!linksIn || !linksIn.length || depth <= 0) {
    return ''
  }

  const messages = linksIn.map(link => explainNode(link, depth - 1, chalk))
  const str = '\n' + messages.join('\n')
  return str.split('\n').join('\n  ')
}

const explainDependents = ({ dependents }, depth, chalk) => {
  if (!dependents || !dependents.length || depth <= 0) {
    return ''
  }

  const max = Math.ceil(depth / 2)
  const messages = dependents.slice(0, max)
    .map(edge => explainEdge(edge, depth, chalk))

  // show just the names of the first 5 deps that overflowed the list
  if (dependents.length > max) {
    let len = 0
    const maxLen = 50
    const showNames = []
    for (let i = max; i < dependents.length; i++) {
      const { from: { name: depName = 'the root project' } } = dependents[i]
      len += depName.length
      if (len >= maxLen && i < dependents.length - 1) {
        showNames.push('...')
        break
      }
      showNames.push(depName)
    }
    const show = `(${showNames.join(', ')})`
    messages.push(`${dependents.length - max} more ${show}`)
  }

  const str = '\n' + messages.join('\n')
  return str.split('\n').join('\n  ')
}

const explainEdge = ({ name, type, bundled, from, spec, rawSpec, overridden }, depth, chalk) => {
  let dep = type === 'workspace'
    ? chalk.bold(relative(from.location, spec.slice('file:'.length)))
    : `${name}@"${spec}"`
  if (overridden) {
    dep = `${colorType('overridden', chalk)} ${dep} (was "${rawSpec}")`
  }

  const fromMsg = ` from ${explainFrom(from, depth, chalk)}`

  return (type === 'prod' ? '' : `${colorType(type, chalk)} `) +
    (bundled ? `${colorType('bundled', chalk)} ` : '') +
    `${dep}${fromMsg}`
}

const explainFrom = (from, depth, chalk) => {
  if (!from.name && !from.version) {
    return 'the root project'
  }

  return printNode(from, chalk) +
    explainDependents(from, depth - 1, chalk) +
    explainLinksIn(from, depth - 1, chalk)
}

module.exports = { explainNode, printNode, explainEdge }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/npm/lib/utils/explain-eresolve.js                                                  0000664 0000000 0000000 00000005071 14746647661 0022033 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // this is called when an ERESOLVE error is caught in the exit-handler,
// or when there's a log.warn('eresolve', msg, explanation), to turn it
// into a human-intelligible explanation of what's wrong and how to fix.
const { explainEdge, explainNode, printNode } = require('./explain-dep.js')

// expl is an explanation object that comes from Arborist.  It looks like:
// Depth is how far we want to want to descend into the object making a report.
// The full report (ie, depth=Infinity) is always written to the cache folder
// at ${cache}/eresolve-report.txt along with full json.
const explain = (expl, chalk, depth) => {
  const { edge, dep, current, peerConflict, currentEdge } = expl

  const out = []
  const whileInstalling = dep && dep.whileInstalling ||
    current && current.whileInstalling ||
    edge && edge.from && edge.from.whileInstalling
  if (whileInstalling) {
    out.push('While resolving: ' + printNode(whileInstalling, chalk))
  }

  // it "should" be impossible for an ERESOLVE explanation to lack both
  // current and currentEdge, but better to have a less helpful error
  // than a crashing failure.
  if (current) {
    out.push('Found: ' + explainNode(current, depth, chalk))
  } else if (peerConflict && peerConflict.current) {
    out.push('Found: ' + explainNode(peerConflict.current, depth, chalk))
  } else if (currentEdge) {
    out.push('Found: ' + explainEdge(currentEdge, depth, chalk))
  } else /* istanbul ignore else - should always have one */ if (edge) {
    out.push('Found: ' + explainEdge(edge, depth, chalk))
  }

  out.push('\nCould not resolve dependency:\n' +
    explainEdge(edge, depth, chalk))

  if (peerConflict) {
    const heading = '\nConflicting peer dependency:'
    const pc = explainNode(peerConflict.peer, depth, chalk)
    out.push(heading + ' ' + pc)
  }

  return out.join('\n')
}

// generate a full verbose report and tell the user how to fix it
const report = (expl, chalk, noColorChalk) => {
  const flags = [
    expl.strictPeerDeps ? '--no-strict-peer-deps' : '',
    '--force',
    '--legacy-peer-deps',
  ].filter(Boolean)

  const or = (arr) => arr.length <= 2
    ? arr.join(' or ') :
    arr.map((v, i, l) => i + 1 === l.length ? `or ${v}` : v).join(', ')

  const fix = `Fix the upstream dependency conflict, or retry
this command with ${or(flags)}
to accept an incorrect (and potentially broken) dependency resolution.`

  return {
    explanation: `${explain(expl, chalk, 4)}\n\n${fix}`,
    file: `# npm resolution error report\n\n${explain(expl, noColorChalk, Infinity)}\n\n${fix}`,
  }
}

module.exports = {
  explain,
  report,
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/npm/lib/utils/format-bytes.js                                                      0000664 0000000 0000000 00000001165 14746647661 0021165 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Convert bytes to printable output, for file reporting in tarballs
// Only supports up to GB because that's way larger than anything the registry
// supports anyways.

const formatBytes = (bytes, space = true) => {
  let spacer = ''
  if (space) {
    spacer = ' '
  }

  if (bytes < 1000) {
    // B
    return `${bytes}${spacer}B`
  }

  if (bytes < 1000000) {
    // kB
    return `${(bytes / 1000).toFixed(1)}${spacer}kB`
  }

  if (bytes < 1000000000) {
    // MB
    return `${(bytes / 1000000).toFixed(1)}${spacer}MB`
  }

  // GB
  return `${(bytes / 1000000000).toFixed(1)}${spacer}GB`
}

module.exports = formatBytes
                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/npm/lib/utils/format-search-stream.js                                              0000664 0000000 0000000 00000011310 14746647661 0022566 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* eslint-disable max-len */
const { stripVTControlCharacters: strip } = require('node:util')
const { Minipass } = require('minipass')

// This module consumes package data in the following format:
//
// {
//   name: String,
//   description: String,
//   maintainers: [{ username: String, email: String }],
//   keywords: String | [String],
//   version: String,
//   date: Date // can be null,
// }
//
// The returned stream will format this package data
// into a byte stream of formatted, displayable output.

function filter (data, exclude) {
  const words = [data.name]
    .concat(data.maintainers.map(m => m.username))
    .concat(data.keywords || [])
    .map(f => f?.trim?.())
    .filter(Boolean)
    .join(' ')
    .toLowerCase()

  if (exclude.find(pattern => {
    // Treats both /foo and /foo/ as regex searches
    if (pattern.startsWith('/')) {
      if (pattern.endsWith('/')) {
        pattern = pattern.slice(0, -1)
      }
      return words.match(new RegExp(pattern.slice(1)))
    }
    return words.includes(pattern)
  })) {
    return false
  }

  return true
}

module.exports = (opts) => {
  return opts.json ? new JSONOutputStream(opts) : new TextOutputStream(opts)
}

class JSONOutputStream extends Minipass {
  #didFirst = false
  #exclude

  constructor (opts) {
    super()
    this.#exclude = opts.exclude
  }

  write (obj) {
    if (!filter(obj, this.#exclude)) {
      return
    }
    if (!this.#didFirst) {
      super.write('[\n')
      this.#didFirst = true
    } else {
      super.write('\n,\n')
    }

    return super.write(JSON.stringify(obj))
  }

  end () {
    super.write(this.#didFirst ? ']\n' : '\n[]\n')
    super.end()
  }
}

class TextOutputStream extends Minipass {
  #args
  #chalk
  #exclude
  #parseable

  constructor (opts) {
    super()
    this.#args = opts.args.map(s => s.toLowerCase()).filter(Boolean)
    this.#chalk = opts.npm.chalk
    this.#exclude = opts.exclude
    this.#parseable = opts.parseable
  }

  write (data) {
    if (!filter(data, this.#exclude)) {
      return
    }
    // Normalize
    const pkg = {
      authors: data.maintainers.map((m) => `${strip(m.username)}`).join(' '),
      publisher: strip(data.publisher?.username || ''),
      date: data.date ? data.date.toISOString().slice(0, 10) : 'prehistoric',
      description: strip(data.description ?? ''),
      keywords: [],
      name: strip(data.name),
      version: data.version,
    }
    if (Array.isArray(data.keywords)) {
      pkg.keywords = data.keywords.map(strip)
    } else if (typeof data.keywords === 'string') {
      pkg.keywords = strip(data.keywords.replace(/[,\s]+/, ' ')).split(' ')
    }

    let output
    if (this.#parseable) {
      output = [pkg.name, pkg.description, pkg.author, pkg.date, pkg.version, pkg.keywords]
        .filter(Boolean)
        .map(col => ('' + col).replace(/\t/g, ' ')).join('\t')
      return super.write(output)
    }

    const keywords = pkg.keywords.map(k => {
      if (this.#args.includes(k)) {
        return this.#chalk.cyan(k)
      } else {
        return k
      }
    }).join(' ')

    let description = []
    for (const arg of this.#args) {
      const finder = pkg.description.toLowerCase().split(arg.toLowerCase())
      let p = 0
      for (const f of finder) {
        description.push(pkg.description.slice(p, p + f.length))
        const word = pkg.description.slice(p + f.length, p + f.length + arg.length)
        description.push(this.#chalk.cyan(word))
        p += f.length + arg.length
      }
    }
    description = description.filter(Boolean)
    let name = pkg.name
    if (this.#args.includes(pkg.name)) {
      name = this.#chalk.cyan(pkg.name)
    } else {
      name = []
      for (const arg of this.#args) {
        const finder = pkg.name.toLowerCase().split(arg.toLowerCase())
        let p = 0
        for (const f of finder) {
          name.push(pkg.name.slice(p, p + f.length))
          const word = pkg.name.slice(p + f.length, p + f.length + arg.length)
          name.push(this.#chalk.cyan(word))
          p += f.length + arg.length
        }
      }
      name = this.#chalk.blue(name.join(''))
    }

    if (description.length) {
      output = `${name}\n${description.join('')}\n`
    } else {
      output = `${name}\n`
    }
    if (pkg.publisher) {
      output += `Version ${this.#chalk.blue(pkg.version)} published ${this.#chalk.blue(pkg.date)} by ${this.#chalk.blue(pkg.publisher)}\n`
    } else {
      output += `Version ${this.#chalk.blue(pkg.version)} published ${this.#chalk.blue(pkg.date)} by ${this.#chalk.yellow('???')}\n`
    }
    output += `Maintainers: ${pkg.authors}\n`
    if (keywords) {
      output += `Keywords: ${keywords}\n`
    }
    output += `${this.#chalk.blue(`https://npm.im/${pkg.name}`)}\n`
    return super.write(output)
  }
}
                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/npm/lib/utils/format.js                                                            0000664 0000000 0000000 00000003645 14746647661 0020046 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { formatWithOptions: baseFormatWithOptions } = require('node:util')

// These are most assuredly not a mistake
// https://eslint.org/docs/latest/rules/no-control-regex
// \x00 through \x1f, \x7f through \x9f, not including \x09 \x0a \x0b \x0d
/* eslint-disable-next-line no-control-regex */
const HAS_C01 = /[\x00-\x08\x0c\x0e-\x1f\x7f-\x9f]/

// Allows everything up to '[38;5;255m' in 8 bit notation
const ALLOWED_SGR = /^\[[0-9;]{0,8}m/

// '[38;5;255m'.length
const SGR_MAX_LEN = 10

// Strips all ANSI C0 and C1 control characters (except for SGR up to 8 bit)
function STRIP_C01 (str) {
  if (!HAS_C01.test(str)) {
    return str
  }
  let result = ''
  for (let i = 0; i < str.length; i++) {
    const char = str[i]
    const code = char.charCodeAt(0)
    if (!HAS_C01.test(char)) {
      // Most characters are in this set so continue early if we can
      result = `${result}${char}`
    } else if (code === 27 && ALLOWED_SGR.test(str.slice(i + 1, i + SGR_MAX_LEN + 1))) {
      // \x1b with allowed SGR
      result = `${result}\x1b`
    } else if (code <= 31) {
      // escape all other C0 control characters besides \x7f
      result = `${result}^${String.fromCharCode(code + 64)}`
    } else {
      // hasC01 ensures this is now a C1 control character or \x7f
      result = `${result}^${String.fromCharCode(code - 64)}`
    }
  }
  return result
}

const formatWithOptions = ({ prefix: prefixes = [], eol = '\n', ...options }, ...args) => {
  const prefix = prefixes.filter(p => p != null).join(' ')
  const formatted = STRIP_C01(baseFormatWithOptions(options, ...args))
  // Splitting could be changed to only `\n` once we are sure we only emit unix newlines.
  // The eol param to this function will put the correct newlines in place for the returned string.
  const lines = formatted.split(/\r?\n/)
  return lines.reduce((acc, l) => `${acc}${prefix}${prefix && l ? ' ' : ''}${l}${eol}`, '')
}

module.exports = { formatWithOptions }
                                                                                           node-23.7.0/deps/npm/lib/utils/get-identity.js                                                      0000664 0000000 0000000 00000001442 14746647661 0021155 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const npmFetch = require('npm-registry-fetch')

module.exports = async (npm, opts) => {
  const { registry } = opts

  // First, check if we have a user/pass-based auth
  const creds = npm.config.getCredentialsByURI(registry)
  if (creds.username) {
    return creds.username
  }

  // No username, but we have other credentials; fetch the username from registry
  if (creds.token || creds.certfile && creds.keyfile) {
    const registryData = await npmFetch.json('/-/whoami', { ...opts })
    if (typeof registryData?.username === 'string') {
      return registryData.username
    }
  }

  // At this point, even if they have a credentials object, it doesn't have a
  // valid token.
  throw Object.assign(
    new Error('This command requires you to be logged in.'),
    { code: 'ENEEDAUTH' }
  )
}
                                                                                                                                                                                                                              node-23.7.0/deps/npm/lib/utils/get-workspaces.js                                                    0000664 0000000 0000000 00000003324 14746647661 0021506 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { resolve, relative } = require('node:path')
const mapWorkspaces = require('@npmcli/map-workspaces')
const { minimatch } = require('minimatch')
const pkgJson = require('@npmcli/package-json')

// minimatch wants forward slashes only for glob patterns
const globify = pattern => pattern.split('\\').join('/')

// Returns an Map of paths to workspaces indexed by workspace name
// { foo => '/path/to/foo' }
const getWorkspaces = async (filters, { path, includeWorkspaceRoot, relativeFrom }) => {
  // TODO we need a better error to be bubbled up here if this call fails
  const { content: pkg } = await pkgJson.normalize(path)
  const workspaces = await mapWorkspaces({ cwd: path, pkg })
  let res = new Map()
  if (includeWorkspaceRoot) {
    res.set(pkg.name, path)
  }

  if (!filters.length) {
    res = new Map([...res, ...workspaces])
  }

  for (const filterArg of filters) {
    for (const [workspaceName, workspacePath] of workspaces.entries()) {
      let relativePath = relative(relativeFrom, workspacePath)
      if (filterArg.startsWith('./')) {
        relativePath = `./${relativePath}`
      }
      const relativeFilter = relative(path, filterArg)
      if (filterArg === workspaceName
        || resolve(relativeFrom, filterArg) === workspacePath
        || minimatch(relativePath, `${globify(relativeFilter)}/*`)
        || minimatch(relativePath, `${globify(filterArg)}/*`)
      ) {
        res.set(workspaceName, workspacePath)
      }
    }
  }

  if (!res.size) {
    let msg = '!'
    if (filters.length) {
      msg = `:\n ${filters.reduce(
        (acc, filterArg) => `${acc} --workspace=${filterArg}`, '')}`
    }

    throw new Error(`No workspaces found${msg}`)
  }

  return res
}

module.exports = getWorkspaces
                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/npm/lib/utils/installed-deep.js                                                    0000664 0000000 0000000 00000002151 14746647661 0021437 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { resolve } = require('node:path')
const localeCompare = require('@isaacs/string-locale-compare')('en')

const installedDeep = async (npm) => {
  const Arborist = require('@npmcli/arborist')
  const {
    depth,
    global,
    prefix,
    workspacesEnabled,
  } = npm.flatOptions

  const getValues = (tree) =>
    [...tree.inventory.values()]
      .filter(i => i.location !== '' && !i.isRoot)
      .map(i => {
        return i
      })
      .filter(i => (i.depth - 1) <= depth)
      .sort((a, b) => (a.depth - b.depth) || localeCompare(a.name, b.name))

  const res = new Set()
  const gArb = new Arborist({
    global: true,
    path: resolve(npm.globalDir, '..'),
    workspacesEnabled,
  })
  const gTree = await gArb.loadActual({ global: true })

  for (const node of getValues(gTree)) {
    res.add(global ? node.name : [node.name, '-g'])
  }

  if (!global) {
    const arb = new Arborist({ global: false, path: prefix, workspacesEnabled })
    const tree = await arb.loadActual()
    for (const node of getValues(tree)) {
      res.add(node.name)
    }
  }

  return [...res]
}

module.exports = installedDeep
                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/npm/lib/utils/installed-shallow.js                                                 0000664 0000000 0000000 00000001107 14746647661 0022173 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { readdirScoped } = require('@npmcli/fs')

const installedShallow = async (npm, opts) => {
  const names = async global => {
    const paths = await readdirScoped(global ? npm.globalDir : npm.localDir)
    return paths.map(p => p.replace(/\\/g, '/'))
  }
  const { conf: { argv: { remain } } } = opts
  if (remain.length > 3) {
    return null
  }

  const { global } = npm.flatOptions
  const locals = global ? [] : await names(false)
  const globals = (await names(true)).map(n => global ? n : `${n} -g`)
  return [...locals, ...globals]
}

module.exports = installedShallow
                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/npm/lib/utils/is-windows.js                                                        0000664 0000000 0000000 00000000261 14746647661 0020650 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const isWindowsShell = (process.platform === 'win32') &&
  !/^MINGW(32|64)$/.test(process.env.MSYSTEM) && process.env.TERM !== 'cygwin'

exports.isWindowsShell = isWindowsShell
                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/npm/lib/utils/log-file.js                                                          0000664 0000000 0000000 00000017443 14746647661 0020255 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const os = require('node:os')
const { join, dirname, basename } = require('node:path')
const fsMiniPass = require('fs-minipass')
const fs = require('node:fs/promises')
const { log } = require('proc-log')
const { formatWithOptions } = require('./format')

const padZero = (n, length) => n.toString().padStart(length.toString().length, '0')

class LogFiles {
  // Default to an array so we can buffer
  // initial writes before we know the cache location
  #logStream = []

  // We cap log files at a certain number of log events per file.
  // Note that each log event can write more than one line to the
  // file. Then we rotate log files once this number of events is reached
  #MAX_LOGS_PER_FILE = null

  // Now that we write logs continuously we need to have a backstop
  // here for infinite loops that still log. This is also partially handled
  // by the config.get('max-files') option, but this is a failsafe to
  // prevent runaway log file creation
  #MAX_FILES_PER_PROCESS = null

  #fileLogCount = 0
  #totalLogCount = 0
  #path = null
  #logsMax = null
  #files = []
  #timing = false

  constructor ({
    maxLogsPerFile = 50_000,
    maxFilesPerProcess = 5,
  } = {}) {
    this.#MAX_LOGS_PER_FILE = maxLogsPerFile
    this.#MAX_FILES_PER_PROCESS = maxFilesPerProcess
    this.on()
  }

  on () {
    process.on('log', this.#logHandler)
  }

  off () {
    process.off('log', this.#logHandler)
    this.#endStream()
  }

  load ({ command, path, logsMax = Infinity, timing } = {}) {
    if (['completion'].includes(command)) {
      return
    }

    // dir is user configurable and is required to exist so
    // this can error if the dir is missing or not configured correctly
    this.#path = path
    this.#logsMax = logsMax
    this.#timing = timing

    // Log stream has already ended
    if (!this.#logStream) {
      return
    }

    log.verbose('logfile', `logs-max:${logsMax} dir:${this.#path}`)

    // Write the contents of our array buffer to our new file stream and
    // set that as the new log logstream for future writes
    // if logs max is 0 then the user does not want a log file
    if (this.#logsMax > 0) {
      const initialFile = this.#openLogFile()
      if (initialFile) {
        for (const item of this.#logStream) {
          const formatted = this.#formatLogItem(...item)
          if (formatted !== null) {
            initialFile.write(formatted)
          }
        }
        this.#logStream = initialFile
      }
    }

    log.verbose('logfile', this.files[0] || 'no logfile created')

    // Kickoff cleaning process, even if we aren't writing a logfile.
    // This is async but it will always ignore the current logfile
    // Return the result so it can be awaited in tests
    return this.#cleanLogs()
  }

  get files () {
    return this.#files
  }

  get #isBuffered () {
    return Array.isArray(this.#logStream)
  }

  #endStream (output) {
    if (this.#logStream && !this.#isBuffered) {
      this.#logStream.end(output)
      this.#logStream = null
    }
  }

  #logHandler = (level, ...args) => {
    // Ignore pause and resume events since we
    // write everything to the log file
    if (level === 'pause' || level === 'resume') {
      return
    }

    // If the stream is ended then do nothing
    if (!this.#logStream) {
      return
    }

    if (this.#isBuffered) {
      // Cant do anything but buffer the output if we dont
      // have a file stream yet
      this.#logStream.push([level, ...args])
      return
    }

    const logOutput = this.#formatLogItem(level, ...args)
    if (logOutput === null) {
      return
    }

    // Open a new log file if we've written too many logs to this one
    if (this.#fileLogCount >= this.#MAX_LOGS_PER_FILE) {
      // Write last chunk to the file and close it
      this.#endStream(logOutput)
      if (this.#files.length >= this.#MAX_FILES_PER_PROCESS) {
        // but if its way too many then we just stop listening
        this.off()
      } else {
        // otherwise we are ready for a new file for the next event
        this.#logStream = this.#openLogFile()
      }
    } else {
      this.#logStream.write(logOutput)
    }
  }

  #formatLogItem (level, title, ...args) {
    // Only right timing logs to logfile if explicitly requests
    if (level === log.KEYS.timing && !this.#timing) {
      return null
    }

    this.#fileLogCount += 1
    const prefix = [this.#totalLogCount++, level, title || null]
    return formatWithOptions({ prefix, eol: os.EOL, colors: false }, ...args)
  }

  #getLogFilePath (count = '') {
    return `${this.#path}debug-${count}.log`
  }

  #openLogFile () {
    // Count in filename will be 0 indexed
    const count = this.#files.length

    try {
      // Pad with zeros so that our log files are always sorted properly
      // We never want to write files ending in `-9.log` and `-10.log` because
      // log file cleaning is done by deleting the oldest so in this example
      // `-10.log` would be deleted next
      const f = this.#getLogFilePath(padZero(count, this.#MAX_FILES_PER_PROCESS))
      // Some effort was made to make the async, but we need to write logs
      // during process.on('exit') which has to be synchronous. So in order
      // to never drop log messages, it is easiest to make it sync all the time
      // and this was measured to be about 1.5% slower for 40k lines of output
      const logStream = new fsMiniPass.WriteStreamSync(f, { flags: 'a' })
      if (count > 0) {
        // Reset file log count if we are opening
        // after our first file
        this.#fileLogCount = 0
      }
      this.#files.push(logStream.path)
      return logStream
    } catch (e) {
      // If the user has a readonly logdir then we don't want to
      // warn this on every command so it should be verbose
      log.verbose('logfile', `could not be created: ${e}`)
    }
  }

  async #cleanLogs () {
    // module to clean out the old log files
    // this is a best-effort attempt.  if a rm fails, we just
    // log a message about it and move on.  We do return a
    // Promise that succeeds when we've tried to delete everything,
    // just for the benefit of testing this function properly.

    try {
      const logPath = this.#getLogFilePath()
      const patternFileName = basename(logPath)
        // tell glob to only match digits
        .replace(/\d/g, 'd')
        // Handle the old (prior to 8.2.0) log file names which did not have a
        // counter suffix
        .replace('-.log', '')

      let files = await fs.readdir(
        dirname(logPath), {
          withFileTypes: true,
          encoding: 'utf-8',
        })
      files = files.sort((a, b) => basename(a.name).localeCompare(basename(b.name), 'en'))

      const logFiles = []

      for (const file of files) {
        if (!file.isFile()) {
          continue
        }

        const genericFileName = file.name.replace(/\d/g, 'd')
        const filePath = join(dirname(logPath), basename(file.name))

        // Always ignore the currently written files
        if (
          genericFileName.includes(patternFileName)
          && genericFileName.endsWith('.log')
          && !this.#files.includes(filePath)
        ) {
          logFiles.push(filePath)
        }
      }

      const toDelete = logFiles.length - this.#logsMax

      if (toDelete <= 0) {
        return
      }

      log.silly('logfile', `start cleaning logs, removing ${toDelete} files`)

      for (const file of logFiles.slice(0, toDelete)) {
        try {
          await fs.rm(file, { force: true })
        } catch (e) {
          log.silly('logfile', 'error removing log file', file, e)
        }
      }
    } catch (e) {
      // Disable cleanup failure warnings when log writing is disabled
      if (this.#logsMax > 0) {
        log.verbose('logfile', 'error cleaning log files', e)
      }
    } finally {
      log.silly('logfile', 'done cleaning log files')
    }
  }
}

module.exports = LogFiles
                                                                                                                                                                                                                             node-23.7.0/deps/npm/lib/utils/npm-usage.js                                                         0000664 0000000 0000000 00000004020 14746647661 0020436 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { commands } = require('./cmd-list')

const COL_MAX = 60
const COL_MIN = 24
const COL_GUTTER = 16
const INDENT = 4

const indent = (repeat = INDENT) => ' '.repeat(repeat)
const indentNewline = (repeat) => `\n${indent(repeat)}`

module.exports = (npm) => {
  const browser = npm.config.get('viewer') === 'browser' ? ' (in a browser)' : ''
  const allCommands = npm.config.get('long') ? cmdUsages(npm.constructor) : cmdNames()

  return `npm <command>

Usage:

npm install        install all the dependencies in your project
npm install <foo>  add the <foo> dependency to your project
npm test           run this project's tests
npm run <foo>      run the script named <foo>
npm <command> -h   quick help on <command>
npm -l             display usage info for all commands
npm help <term>    search for help on <term>${browser}
npm help npm       more involved overview${browser}

All commands:
${allCommands}

Specify configs in the ini-formatted file:
${indent() + npm.config.get('userconfig')}
or on the command line via: npm <command> --key=value

More configuration info: npm help config
Configuration fields: npm help 7 config

npm@${npm.version} ${npm.npmRoot}`
}

const cmdNames = () => {
  const out = ['']

  const line = !process.stdout.columns ? COL_MAX
    : Math.min(COL_MAX, Math.max(process.stdout.columns - COL_GUTTER, COL_MIN))

  let l = 0
  for (const c of commands) {
    if (out[l].length + c.length + 2 < line) {
      out[l] += ', ' + c
    } else {
      out[l++] += ','
      out[l] = c
    }
  }

  return indentNewline() + out.join(indentNewline()).slice(2)
}

const cmdUsages = (Npm) => {
  // return a string of <command>: <usage>
  let maxLen = 0
  const set = []
  for (const c of commands) {
    set.push([c, Npm.cmd(c).describeUsage.split('\n')])
    maxLen = Math.max(maxLen, c.length)
  }

  return set.map(([name, usageLines]) => {
    const gutter = indent(maxLen - name.length + 1)
    const usage = usageLines.join(indentNewline(INDENT + maxLen + 1))
    return indentNewline() + name + gutter + usage
  }).join('\n')
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/npm/lib/utils/open-url.js                                                          0000664 0000000 0000000 00000004556 14746647661 0020321 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { open } = require('@npmcli/promise-spawn')
const { output, input } = require('proc-log')
const { URL } = require('node:url')
const readline = require('node:readline/promises')
const { once } = require('node:events')

const assertValidUrl = (url) => {
  try {
    if (!/^https?:$/.test(new URL(url).protocol)) {
      throw new Error()
    }
  } catch {
    throw new Error('Invalid URL: ' + url)
  }
}

const outputMsg = (json, title, url) => {
  if (json) {
    output.buffer({ title, url })
  } else {
    output.standard(`${title}:\n${url}`)
  }
}

// attempt to open URL in web-browser, print address otherwise:
const openUrl = async (npm, url, title, isFile) => {
  url = encodeURI(url)
  const browser = npm.config.get('browser')
  const json = npm.config.get('json')

  if (browser === false) {
    outputMsg(json, title, url)
    return
  }

  // We pass this in as true from the help command so we know we don't have to
  // check the protocol
  if (!isFile) {
    assertValidUrl(url)
  }

  try {
    await input.start(() => open(url, {
      command: browser === true ? null : browser,
    }))
  } catch (err) {
    if (err.code !== 127) {
      throw err
    }
    outputMsg(json, title, url)
  }
}

// Prompt to open URL in browser if possible
const openUrlPrompt = async (npm, url, title, prompt, { signal }) => {
  const browser = npm.config.get('browser')
  const json = npm.config.get('json')

  assertValidUrl(url)
  outputMsg(json, title, url)

  if (browser === false || !process.stdin.isTTY || !process.stdout.isTTY) {
    return
  }

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  })

  try {
    await input.read(() => Promise.race([
      rl.question(prompt, { signal }),
      once(rl, 'error'),
      once(rl, 'SIGINT').then(() => {
        throw new Error('canceled')
      }),
    ]))
    rl.close()
    await openUrl(npm, url, 'Browser unavailable. Please open the URL manually')
  } catch (err) {
    rl.close()
    if (err.name !== 'AbortError') {
      throw err
    }
  }
}

// Rearrange arguments and return a function that takes the two arguments
// returned from the npm-profile methods that take an opener
const createOpener = (npm, title, prompt = 'Press ENTER to open in the browser...') =>
  (url, opts) => openUrlPrompt(npm, url, title, prompt, opts)

module.exports = {
  openUrl,
  openUrlPrompt,
  createOpener,
}
                                                                                                                                                  node-23.7.0/deps/npm/lib/utils/output-error.js                                                      0000664 0000000 0000000 00000001377 14746647661 0021245 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { log, output } = require('proc-log')

const outputError = ({ standard = [], verbose = [], error = [], summary = [], detail = [] }) => {
  for (const line of standard) {
    // Each output line is just a single string
    output.standard(line)
  }
  for (const line of verbose) {
    log.verbose(...line)
  }
  for (const line of [...error, ...summary, ...detail]) {
    log.error(...line)
  }
}

const jsonError = (error, npm) => {
  if (error && npm?.loaded && npm?.config.get('json')) {
    return {
      code: error.code,
      summary: (error.summary || []).map(l => l.slice(1).join(' ')).join('\n').trim(),
      detail: (error.detail || []).map(l => l.slice(1).join(' ')).join('\n').trim(),
    }
  }
}

module.exports = {
  outputError,
  jsonError,
}
                                                                                                                                                                                                                                                                 node-23.7.0/deps/npm/lib/utils/ping.js                                                              0000664 0000000 0000000 00000000406 14746647661 0017503 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // ping the npm registry
// used by the ping and doctor commands
const fetch = require('npm-registry-fetch')
module.exports = async (flatOptions) => {
  const res = await fetch('/-/ping', { ...flatOptions, cache: false })
  return res.json().catch(() => ({}))
}
                                                                                                                                                                                                                                                          node-23.7.0/deps/npm/lib/utils/queryable.js                                                         0000664 0000000 0000000 00000023071 14746647661 0020542 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const util = require('node:util')
const _delete = Symbol('delete')
const _append = Symbol('append')

const sqBracketsMatcher = str => str.match(/(.+)\[([^\]]+)\]\.?(.*)$/)

// replaces any occurrence of an empty-brackets (e.g: []) with a special
// Symbol(append) to represent it, this is going to be useful for the setter
// method that will push values to the end of the array when finding these
const replaceAppendSymbols = str => {
  const matchEmptyBracket = str.match(/^(.*)\[\]\.?(.*)$/)

  if (matchEmptyBracket) {
    const [, pre, post] = matchEmptyBracket
    return [...replaceAppendSymbols(pre), _append, post].filter(Boolean)
  }

  return [str]
}

const parseKeys = key => {
  const sqBracketItems = new Set()
  sqBracketItems.add(_append)
  const parseSqBrackets = str => {
    const index = sqBracketsMatcher(str)

    // once we find square brackets, we recursively parse all these
    if (index) {
      const preSqBracketPortion = index[1]

      // we want to have a `new String` wrapper here in order to differentiate
      // between multiple occurrences of the same string, e.g:
      // foo.bar[foo.bar] should split into { foo: { bar: { 'foo.bar': {} } }
      /* eslint-disable-next-line no-new-wrappers */
      const foundKey = new String(index[2])
      const postSqBracketPortion = index[3]

      // we keep track of items found during this step to make sure
      // we don't try to split-separate keys that were defined within
      // square brackets, since the key name itself might contain dots
      sqBracketItems.add(foundKey)

      // returns an array that contains either dot-separate items (that will
      // be split apart during the next step OR the fully parsed keys
      // read from square brackets, e.g:
      // foo.bar[1.0.0].a.b -> ['foo.bar', '1.0.0', 'a.b']
      return [
        ...parseSqBrackets(preSqBracketPortion),
        foundKey,
        ...(postSqBracketPortion ? parseSqBrackets(postSqBracketPortion) : []),
      ]
    }

    // at the end of parsing, any usage of the special empty-bracket syntax
    // (e.g: foo.array[]) has  not yet been parsed, here we'll take care
    // of parsing it and adding a special symbol to represent it in
    // the resulting list of keys
    return replaceAppendSymbols(str)
  }

  const res = []
  // starts by parsing items defined as square brackets, those might be
  // representing properties that have a dot in the name or just array
  // indexes, e.g: foo[1.0.0] or list[0]
  const sqBracketKeys = parseSqBrackets(key.trim())

  for (const k of sqBracketKeys) {
    // keys parsed from square brackets should just be added to list of
    // resulting keys as they might have dots as part of the key
    if (sqBracketItems.has(k)) {
      res.push(k)
    } else {
      // splits the dot-sep property names and add them to the list of keys
      /* eslint-disable-next-line no-new-wrappers */
      for (const splitKey of k.split('.')) {
        res.push(String(splitKey))
      }
    }
  }

  // returns an ordered list of strings in which each entry
  // represents a key in an object defined by the previous entry
  return res
}

const getter = ({ data, key }, { unwrapSingleItemArrays = true } = {}) => {
  // keys are a list in which each entry represents the name of
  // a property that should be walked through the object in order to
  // return the final found value
  const keys = parseKeys(key)
  let _data = data
  let label = ''

  for (const k of keys) {
    // empty-bracket-shortcut-syntax is not supported on getter
    if (k === _append) {
      throw Object.assign(new Error('Empty brackets are not valid syntax for retrieving values.'), {
        code: 'EINVALIDSYNTAX',
      })
    }

    // extra logic to take into account printing array, along with its
    // special syntax in which using a dot-sep property name after an
    // arry will expand it's results, e.g:
    // arr.name -> arr[0].name=value, arr[1].name=value, ...
    const maybeIndex = Number(k)
    if (Array.isArray(_data) && !Number.isInteger(maybeIndex)) {
      _data = _data.reduce((acc, i, index) => {
        acc[`${label}[${index}].${k}`] = i[k]
        return acc
      }, {})
      return _data
    } else {
      if (!Object.hasOwn(_data, k)) {
        return undefined
      }
      _data = _data[k]
    }

    label += k
  }

  // these are some legacy expectations from
  // the old API consumed by lib/view.js
  if (unwrapSingleItemArrays && Array.isArray(_data) && _data.length <= 1) {
    _data = _data[0]
  }

  return {
    [key]: _data,
  }
}

const setter = ({ data, key, value, force }) => {
  // setter goes to recursively transform the provided data obj,
  // setting properties from the list of parsed keys, e.g:
  // ['foo', 'bar', 'baz'] -> { foo: { bar: { baz:  {} } }
  const keys = parseKeys(key)
  const setKeys = (_data, _key) => {
    // handles array indexes, converting valid integers to numbers,
    // note that occurrences of Symbol(append) will throw,
    // so we just ignore these for now
    let maybeIndex = Number.NaN
    try {
      maybeIndex = Number(_key)
    } catch {
      // leave it NaN
    }
    if (!Number.isNaN(maybeIndex)) {
      _key = maybeIndex
    }

    // creates new array in case key is an index
    // and the array obj is not yet defined
    const keyIsAnArrayIndex = _key === maybeIndex || _key === _append
    const dataHasNoItems = !Object.keys(_data).length
    if (keyIsAnArrayIndex && dataHasNoItems && !Array.isArray(_data)) {
      _data = []
    }

    // converting from array to an object is also possible, in case the
    // user is using force mode, we should also convert existing arrays
    // to an empty object if the current _data is an array
    if (force && Array.isArray(_data) && !keyIsAnArrayIndex) {
      _data = { ..._data }
    }

    // the _append key is a special key that is used to represent
    // the empty-bracket notation, e.g: arr[] -> arr[arr.length]
    if (_key === _append) {
      if (!Array.isArray(_data)) {
        throw Object.assign(new Error(`Can't use append syntax in non-Array element`), {
          code: 'ENOAPPEND',
        })
      }
      _key = _data.length
    }

    // retrieves the next data object to recursively iterate on,
    // throws if trying to override a literal value or add props to an array
    const next = () => {
      const haveContents = !force && _data[_key] != null && value !== _delete
      const shouldNotOverrideLiteralValue = !(typeof _data[_key] === 'object')
      // if the next obj to recurse is an array and the next key to be
      // appended to the resulting obj is not an array index, then it
      // should throw since we can't append arbitrary props to arrays
      const shouldNotAddPropsToArrays =
        typeof keys[0] !== 'symbol' && Array.isArray(_data[_key]) && Number.isNaN(Number(keys[0]))

      const overrideError = haveContents && shouldNotOverrideLiteralValue
      if (overrideError) {
        throw Object.assign(
          new Error(`Property ${_key} already exists and is not an Array or Object.`),
          { code: 'EOVERRIDEVALUE' }
        )
      }

      const addPropsToArrayError = haveContents && shouldNotAddPropsToArrays
      if (addPropsToArrayError) {
        throw Object.assign(new Error(`Can't add property ${key} to an Array.`), {
          code: 'ENOADDPROP',
        })
      }

      return typeof _data[_key] === 'object' ? _data[_key] || {} : {}
    }

    // sets items from the parsed array of keys as objects, recurses to
    // setKeys in case there are still items to be handled, otherwise it
    // just sets the original value set by the user
    if (keys.length) {
      _data[_key] = setKeys(next(), keys.shift())
    } else {
      // handles special deletion cases for obj props / array items
      if (value === _delete) {
        if (Array.isArray(_data)) {
          _data.splice(_key, 1)
        } else {
          delete _data[_key]
        }
      } else {
        // finally, sets the value in its right place
        _data[_key] = value
      }
    }

    return _data
  }

  setKeys(data, keys.shift())
}

class Queryable {
  static ALL = ''

  #data = null

  constructor (obj) {
    if (!obj || typeof obj !== 'object') {
      throw Object.assign(new Error('Queryable needs an object to query properties from.'), {
        code: 'ENOQUERYABLEOBJ',
      })
    }

    this.#data = obj
  }

  query (queries, opts) {
    // this ugly interface here is meant to be a compatibility layer
    // with the legacy API lib/view.js is consuming, if at some point
    // we refactor that command then we can revisit making this nicer
    if (queries === Queryable.ALL) {
      return { [Queryable.ALL]: this.#data }
    }

    const q = query =>
      getter({
        data: this.#data,
        key: query,
      }, opts)

    if (Array.isArray(queries)) {
      let res = {}
      for (const query of queries) {
        res = { ...res, ...q(query) }
      }
      return res
    } else {
      return q(queries)
    }
  }

  // return the value for a single query if found, otherwise returns undefined
  get (query) {
    const obj = this.query(query)
    if (obj) {
      return obj[query]
    }
  }

  // creates objects along the way for the provided `query` parameter
  // and assigns `value` to the last property of the query chain
  set (query, value, { force } = {}) {
    setter({
      data: this.#data,
      key: query,
      value,
      force,
    })
  }

  // deletes the value of the property found at `query`
  delete (query) {
    setter({
      data: this.#data,
      key: query,
      value: _delete,
    })
  }

  toJSON () {
    return this.#data
  }

  [util.inspect.custom] () {
    return this.toJSON()
  }
}

module.exports = Queryable
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/npm/lib/utils/read-user-info.js                                                    0000664 0000000 0000000 00000003644 14746647661 0021375 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const { read: _read } = require('read')
const userValidate = require('npm-user-validate')
const { log, input } = require('proc-log')

const otpPrompt = `This command requires a one-time password (OTP) from your authenticator app.
Enter one below. You can also pass one on the command line by appending --otp=123456.
For more information, see:
https://docs.npmjs.com/getting-started/using-two-factor-authentication
Enter OTP: `
const passwordPrompt = 'npm password: '
const usernamePrompt = 'npm username: '
const emailPrompt = 'email (this IS public): '

const read = (...args) => input.read(() => _read(...args))

function readOTP (msg = otpPrompt, otp, isRetry) {
  if (isRetry && otp && /^[\d ]+$|^[A-Fa-f0-9]{64,64}$/.test(otp)) {
    return otp.replace(/\s+/g, '')
  }

  return read({ prompt: msg, default: otp || '' })
    .then((rOtp) => readOTP(msg, rOtp, true))
}

function readPassword (msg = passwordPrompt, password, isRetry) {
  if (isRetry && password) {
    return password
  }

  return read({ prompt: msg, silent: true, default: password || '' })
    .then((rPassword) => readPassword(msg, rPassword, true))
}

function readUsername (msg = usernamePrompt, username, isRetry) {
  if (isRetry && username) {
    const error = userValidate.username(username)
    if (error) {
      log.warn(error.message)
    } else {
      return Promise.resolve(username.trim())
    }
  }

  return read({ prompt: msg, default: username || '' })
    .then((rUsername) => readUsername(msg, rUsername, true))
}

function readEmail (msg = emailPrompt, email, isRetry) {
  if (isRetry && email) {
    const error = userValidate.email(email)
    if (error) {
      log.warn(error.message)
    } else {
      return email.trim()
    }
  }

  return read({ prompt: msg, default: email || '' })
    .then((username) => readEmail(msg, username, true))
}

module.exports = {
  otp: readOTP,
  password: readPassword,
  username: readUsername,
  email: readEmail,
}
                                                                                            node-23.7.0/deps/npm/lib/utils/reify-finish.js                                                      0000664 0000000 0000000 00000001566 14746647661 0021152 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const reifyOutput = require('./reify-output.js')
const ini = require('ini')
const { writeFile } = require('node:fs/promises')
const { resolve } = require('node:path')

const reifyFinish = async (npm, arb) => {
  await saveBuiltinConfig(npm, arb)
  reifyOutput(npm, arb)
}

const saveBuiltinConfig = async (npm, arb) => {
  const { options: { global }, actualTree } = arb
  if (!global) {
    return
  }

  // if we are using a builtin config, and just installed npm as
  // a top-level global package, we have to preserve that config.
  const npmNode = actualTree.inventory.get('node_modules/npm')
  if (!npmNode) {
    return
  }

  const builtinConf = npm.config.data.get('builtin')
  if (builtinConf.loadError) {
    return
  }

  const content = ini.stringify(builtinConf.raw).trim() + '\n'
  await writeFile(resolve(npmNode.path, 'npmrc'), content)
}

module.exports = reifyFinish
                                                                                                                                          node-23.7.0/deps/npm/lib/utils/reify-output.js                                                      0000664 0000000 0000000 00000013234 14746647661 0021225 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // pass in an arborist object, and it'll output the data about what
// was done, what was audited, etc.
//
// added ## packages, removed ## packages, and audited ## packages in 19.157s
//
// 1 package is looking for funding
//   run `npm fund` for details
//
// found 37 vulnerabilities (5 low, 7 moderate, 25 high)
//   run `npm audit fix` to fix them, or `npm audit` for details

const { log, output } = require('proc-log')
const { depth } = require('treeverse')
const ms = require('ms')
const npmAuditReport = require('npm-audit-report')
const { readTree: getFundingInfo } = require('libnpmfund')
const auditError = require('./audit-error.js')

// TODO: output JSON if flatOptions.json is true
const reifyOutput = (npm, arb) => {
  const { diff, actualTree } = arb

  // note: fails and crashes if we're running audit fix and there was an error
  // which is a good thing, because there's no point printing all this other
  // stuff in that case!
  const auditReport = auditError(npm, arb.auditReport) ? null : arb.auditReport

  // don't print any info in --silent mode, but we still need to
  // set the exitCode properly from the audit report, if we have one.
  if (npm.silent) {
    getAuditReport(npm, auditReport)
    return
  }

  const summary = {
    added: 0,
    removed: 0,
    changed: 0,
    audited: auditReport && !auditReport.error ? actualTree.inventory.size : 0,
    funding: 0,
  }

  if (diff) {
    const showDiff = npm.config.get('dry-run') || npm.config.get('long')
    const chalk = npm.chalk

    depth({
      tree: diff,
      visit: d => {
        switch (d.action) {
          case 'REMOVE':
            if (showDiff) {
              /* eslint-disable-next-line max-len */
              output.standard(`${chalk.blue('remove')} ${d.actual.name} ${d.actual.package.version}`)
            }
            summary.removed++
            break
          case 'ADD':
            if (showDiff) {
              output.standard(`${chalk.green('add')} ${d.ideal.name} ${d.ideal.package.version}`)
            }
            actualTree.inventory.has(d.ideal) && summary.added++
            break
          case 'CHANGE':
            if (showDiff) {
              /* eslint-disable-next-line max-len */
              output.standard(`${chalk.cyan('change')} ${d.actual.name} ${d.actual.package.version} => ${d.ideal.package.version}`)
            }
            summary.changed++
            break
          default:
            return
        }
        const node = d.actual || d.ideal
        log.silly(d.action, node.location)
      },
      getChildren: d => d.children,
    })
  }

  if (npm.flatOptions.fund) {
    const fundingInfo = getFundingInfo(actualTree, { countOnly: true })
    summary.funding = fundingInfo.length
  }

  if (npm.flatOptions.json) {
    if (auditReport) {
      // call this to set the exit code properly
      getAuditReport(npm, auditReport)
      summary.audit = npm.command === 'audit' ? auditReport
        : auditReport.toJSON().metadata
    }
    output.buffer(summary)
  } else {
    packagesChangedMessage(npm, summary)
    packagesFundingMessage(npm, summary)
    printAuditReport(npm, auditReport)
  }
}

// if we're running `npm audit fix`, then we print the full audit report
// at the end if there's still stuff, because it's silly for `npm audit`
// to tell you to run `npm audit` for details.  otherwise, use the summary
// report.  if we get here, we know it's not quiet or json.
// If the loglevel is silent, then we just run the report
// to get the exitCode set appropriately.
const printAuditReport = (npm, report) => {
  const res = getAuditReport(npm, report)
  if (!res || !res.report) {
    return
  }
  output.standard(`\n${res.report}`)
}

const getAuditReport = (npm, report) => {
  if (!report) {
    return
  }

  // when in silent mode, we print nothing.  the JSON output is
  // going to just JSON.stringify() the report object.
  const reporter = npm.silent ? 'quiet'
    : npm.flatOptions.json ? 'quiet'
    : npm.command !== 'audit' ? 'install'
    : 'detail'
  const defaultAuditLevel = npm.command !== 'audit' ? 'none' : 'low'
  const auditLevel = npm.flatOptions.auditLevel || defaultAuditLevel

  const res = npmAuditReport(report, {
    reporter,
    ...npm.flatOptions,
    auditLevel,
    chalk: npm.chalk,
  })
  if (npm.command === 'audit') {
    process.exitCode = process.exitCode || res.exitCode
  }
  return res
}

const packagesChangedMessage = (npm, { added, removed, changed, audited }) => {
  const msg = ['\n']
  if (added === 0 && removed === 0 && changed === 0) {
    msg.push('up to date')
    if (audited) {
      msg.push(', ')
    }
  } else {
    if (added) {
      msg.push(`added ${added} package${added === 1 ? '' : 's'}`)
    }

    if (removed) {
      if (added) {
        msg.push(', ')
      }

      if (added && !audited && !changed) {
        msg.push('and ')
      }

      msg.push(`removed ${removed} package${removed === 1 ? '' : 's'}`)
    }
    if (changed) {
      if (added || removed) {
        msg.push(', ')
      }

      if (!audited && (added || removed)) {
        msg.push('and ')
      }

      msg.push(`changed ${changed} package${changed === 1 ? '' : 's'}`)
    }
    if (audited) {
      msg.push(', and ')
    }
  }
  if (audited) {
    msg.push(`audited ${audited} package${audited === 1 ? '' : 's'}`)
  }

  msg.push(` in ${ms(Date.now() - npm.started)}`)
  output.standard(msg.join(''))
}

const packagesFundingMessage = (npm, { funding }) => {
  if (!funding) {
    return
  }

  output.standard('')
  const pkg = funding === 1 ? 'package' : 'packages'
  const is = funding === 1 ? 'is' : 'are'
  output.standard(`${funding} ${pkg} ${is} looking for funding`)
  output.standard('  run `npm fund` for details')
}

module.exports = reifyOutput
                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/npm/lib/utils/sbom-cyclonedx.js                                                    0000664 0000000 0000000 00000012323 14746647661 0021475 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const crypto = require('node:crypto')
const normalizeData = require('normalize-package-data')
const parseLicense = require('spdx-expression-parse')
const npa = require('npm-package-arg')
const ssri = require('ssri')

const CYCLONEDX_SCHEMA = 'http://cyclonedx.org/schema/bom-1.5.schema.json'
const CYCLONEDX_FORMAT = 'CycloneDX'
const CYCLONEDX_SCHEMA_VERSION = '1.5'

const PROP_PATH = 'cdx:npm:package:path'
const PROP_BUNDLED = 'cdx:npm:package:bundled'
const PROP_DEVELOPMENT = 'cdx:npm:package:development'
const PROP_EXTRANEOUS = 'cdx:npm:package:extraneous'
const PROP_PRIVATE = 'cdx:npm:package:private'

const REF_VCS = 'vcs'
const REF_WEBSITE = 'website'
const REF_ISSUE_TRACKER = 'issue-tracker'
const REF_DISTRIBUTION = 'distribution'

const ALGO_MAP = {
  sha1: 'SHA-1',
  sha256: 'SHA-256',
  sha384: 'SHA-384',
  sha512: 'SHA-512',
}

const cyclonedxOutput = ({ npm, nodes, packageType, packageLockOnly }) => {
  const rootNode = nodes.find(node => node.isRoot)
  const childNodes = nodes.filter(node => !node.isRoot && !node.isLink)
  const uuid = crypto.randomUUID()

  const deps = []
  const seen = new Set()
  for (let node of nodes) {
    if (node.isLink) {
      node = node.target
    }

    if (seen.has(node)) {
      continue
    }
    seen.add(node)
    deps.push(toCyclonedxDependency(node, nodes))
  }

  const bom = {
    $schema: CYCLONEDX_SCHEMA,
    bomFormat: CYCLONEDX_FORMAT,
    specVersion: CYCLONEDX_SCHEMA_VERSION,
    serialNumber: `urn:uuid:${uuid}`,
    version: 1,
    metadata: {
      timestamp: new Date().toISOString(),
      lifecycles: [
        { phase: packageLockOnly ? 'pre-build' : 'build' },
      ],
      tools: [
        {
          vendor: 'npm',
          name: 'cli',
          version: npm.version,
        },
      ],
      component: toCyclonedxItem(rootNode, { packageType }),
    },
    components: childNodes.map(toCyclonedxItem),
    dependencies: deps,
  }

  return bom
}

const toCyclonedxItem = (node, { packageType }) => {
  packageType = packageType || 'library'

  // Calculate purl from package spec
  let spec = npa(node.pkgid)
  spec = (spec.type === 'alias') ? spec.subSpec : spec
  const purl = npa.toPurl(spec) + (isGitNode(node) ? `?vcs_url=${node.resolved}` : '')

  if (node.package) {
    normalizeData(node.package)
  }

  let parsedLicense
  try {
    let license = node.package?.license
    if (license) {
      if (typeof license === 'object') {
        license = license.type
      }
    }

    parsedLicense = parseLicense(license)
  } catch (err) {
    parsedLicense = null
  }

  const component = {
    'bom-ref': toCyclonedxID(node),
    type: packageType,
    name: node.name,
    version: node.version,
    scope: (node.optional || node.devOptional) ? 'optional' : 'required',
    author: (typeof node.package?.author === 'object')
      ? node.package.author.name
      : (node.package?.author || undefined),
    description: node.package?.description || undefined,
    purl: purl,
    properties: [{
      name: PROP_PATH,
      value: node.location,
    }],
    externalReferences: [],
  }

  if (node.integrity) {
    const integrity = ssri.parse(node.integrity, { single: true })
    component.hashes = [{
      alg: ALGO_MAP[integrity.algorithm] || /* istanbul ignore next */ 'SHA-512',
      content: integrity.hexDigest(),
    }]
  }

  if (node.dev === true) {
    component.properties.push(prop(PROP_DEVELOPMENT))
  }

  if (node.package?.private === true) {
    component.properties.push(prop(PROP_PRIVATE))
  }

  if (node.extraneous === true) {
    component.properties.push(prop(PROP_EXTRANEOUS))
  }

  if (node.inBundle === true) {
    component.properties.push(prop(PROP_BUNDLED))
  }

  if (!node.isLink && node.resolved) {
    component.externalReferences.push(extRef(REF_DISTRIBUTION, node.resolved))
  }

  if (node.package?.repository?.url) {
    component.externalReferences.push(extRef(REF_VCS, node.package.repository.url))
  }

  if (node.package?.homepage) {
    component.externalReferences.push(extRef(REF_WEBSITE, node.package.homepage))
  }

  if (node.package?.bugs?.url) {
    component.externalReferences.push(extRef(REF_ISSUE_TRACKER, node.package.bugs.url))
  }

  // If license is a single SPDX license, use the license field
  if (parsedLicense?.license) {
    component.licenses = [{ license: { id: parsedLicense.license } }]
    // If license is a conjunction, use the expression field
  } else if (parsedLicense?.conjunction) {
    component.licenses = [{ expression: node.package.license }]
  }

  return component
}

const toCyclonedxDependency = (node, nodes) => {
  return {
    ref: toCyclonedxID(node),
    dependsOn: [...node.edgesOut.values()]
      // Filter out edges that are linking to nodes not in the list
      .filter(edge => nodes.find(n => n === edge.to))
      .map(edge => toCyclonedxID(edge.to))
      .filter(id => id),
  }
}

const toCyclonedxID = (node) => `${node.packageName}@${node.version}`

const prop = (name) => ({ name, value: 'true' })

const extRef = (type, url) => ({ type, url })

const isGitNode = (node) => {
  if (!node.resolved) {
    return
  }

  try {
    const { type } = npa(node.resolved)
    return type === 'git' || type === 'hosted'
  } catch (err) {
    /* istanbul ignore next */
    return false
  }
}

module.exports = { cyclonedxOutput }
                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/npm/lib/utils/sbom-spdx.js                                                         0000664 0000000 0000000 00000011130 14746647661 0020456 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        
const crypto = require('node:crypto')
const normalizeData = require('normalize-package-data')
const npa = require('npm-package-arg')
const ssri = require('ssri')

const SPDX_SCHEMA_VERSION = 'SPDX-2.3'
const SPDX_DATA_LICENSE = 'CC0-1.0'
const SPDX_IDENTIFER = 'SPDXRef-DOCUMENT'

const NO_ASSERTION = 'NOASSERTION'

const REL_DESCRIBES = 'DESCRIBES'
const REL_PREREQ = 'PREREQUISITE_FOR'
const REL_OPTIONAL = 'OPTIONAL_DEPENDENCY_OF'
const REL_DEV = 'DEV_DEPENDENCY_OF'
const REL_DEP = 'DEPENDENCY_OF'

const REF_CAT_PACKAGE_MANAGER = 'PACKAGE-MANAGER'
const REF_TYPE_PURL = 'purl'

const spdxOutput = ({ npm, nodes, packageType }) => {
  const rootNode = nodes.find(node => node.isRoot)
  const childNodes = nodes.filter(node => !node.isRoot && !node.isLink)
  const rootID = rootNode.pkgid
  const uuid = crypto.randomUUID()
  const ns = `http://spdx.org/spdxdocs/${npa(rootID).escapedName}-${rootNode.version}-${uuid}`

  const relationships = []
  const seen = new Set()
  for (let node of nodes) {
    if (node.isLink) {
      node = node.target
    }

    if (seen.has(node)) {
      continue
    }
    seen.add(node)

    const rels = [...node.edgesOut.values()]
      // Filter out edges that are linking to nodes not in the list
      .filter(edge => nodes.find(n => n === edge.to))
      .map(edge => toSpdxRelationship(node, edge))
      .filter(rel => rel)

    relationships.push(...rels)
  }

  const extraRelationships = nodes.filter(node => node.extraneous)
    .map(node => toSpdxRelationship(rootNode, { to: node, type: 'optional' }))

  relationships.push(...extraRelationships)

  const bom = {
    spdxVersion: SPDX_SCHEMA_VERSION,
    dataLicense: SPDX_DATA_LICENSE,
    SPDXID: SPDX_IDENTIFER,
    name: rootID,
    documentNamespace: ns,
    creationInfo: {
      created: new Date().toISOString(),
      creators: [
        `Tool: npm/cli-${npm.version}`,
      ],
    },
    documentDescribes: [toSpdxID(rootNode)],
    packages: [toSpdxItem(rootNode, { packageType }), ...childNodes.map(toSpdxItem)],
    relationships: [
      {
        spdxElementId: SPDX_IDENTIFER,
        relatedSpdxElement: toSpdxID(rootNode),
        relationshipType: REL_DESCRIBES,
      },
      ...relationships,
    ],
  }

  return bom
}

const toSpdxItem = (node, { packageType }) => {
  normalizeData(node.package)

  // Calculate purl from package spec
  let spec = npa(node.pkgid)
  spec = (spec.type === 'alias') ? spec.subSpec : spec
  const purl = npa.toPurl(spec) + (isGitNode(node) ? `?vcs_url=${node.resolved}` : '')

  /* For workspace nodes, use the location from their linkNode */
  let location = node.location
  if (node.isWorkspace && node.linksIn.size > 0) {
    location = node.linksIn.values().next().value.location
  }

  let license = node.package?.license
  if (license) {
    if (typeof license === 'object') {
      license = license.type
    }
  }

  const pkg = {
    name: node.packageName,
    SPDXID: toSpdxID(node),
    versionInfo: node.version,
    packageFileName: location,
    description: node.package?.description || undefined,
    primaryPackagePurpose: packageType ? packageType.toUpperCase() : undefined,
    downloadLocation: (node.isLink ? undefined : node.resolved) || NO_ASSERTION,
    filesAnalyzed: false,
    homepage: node.package?.homepage || NO_ASSERTION,
    licenseDeclared: license || NO_ASSERTION,
    externalRefs: [
      {
        referenceCategory: REF_CAT_PACKAGE_MANAGER,
        referenceType: REF_TYPE_PURL,
        referenceLocator: purl,
      },
    ],
  }

  if (node.integrity) {
    const integrity = ssri.parse(node.integrity, { single: true })
    pkg.checksums = [{
      algorithm: integrity.algorithm.toUpperCase(),
      checksumValue: integrity.hexDigest(),
    }]
  }
  return pkg
}

const toSpdxRelationship = (node, edge) => {
  let type
  switch (edge.type) {
    case 'peer':
      type = REL_PREREQ
      break
    case 'optional':
      type = REL_OPTIONAL
      break
    case 'dev':
      type = REL_DEV
      break
    default:
      type = REL_DEP
  }

  return {
    spdxElementId: toSpdxID(edge.to),
    relatedSpdxElement: toSpdxID(node),
    relationshipType: type,
  }
}

const toSpdxID = (node) => {
  let name = node.packageName

  // Strip leading @ for scoped packages
  name = name.replace(/^@/, '')

  // Replace slashes with dots
  name = name.replace(/\//g, '.')

  return `SPDXRef-Package-${name}-${node.version}`
}

const isGitNode = (node) => {
  if (!node.resolved) {
    return
  }

  try {
    const { type } = npa(node.resolved)
    return type === 'git' || type === 'hosted'
  } catch (err) {
    /* istanbul ignore next */
    return false
  }
}

module.exports = { spdxOutput }
                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/npm/lib/utils/tar.js                                                               0000664 0000000 0000000 00000006740 14746647661 0017343 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const tar = require('tar')
const ssri = require('ssri')
const { log, output } = require('proc-log')
const formatBytes = require('./format-bytes.js')
const localeCompare = require('@isaacs/string-locale-compare')('en', {
  sensitivity: 'case',
  numeric: true,
})

const logTar = (tarball, { unicode = false, json, key } = {}) => {
  if (json) {
    output.buffer(key == null ? tarball : { [key]: tarball })
    return
  }
  log.notice('')
  log.notice('', `${unicode ? '📦 ' : 'package:'} ${tarball.name}@${tarball.version}`)
  log.notice('Tarball Contents')
  if (tarball.files.length) {
    log.notice(
      '',
      tarball.files.map(f =>
        /^node_modules\//.test(f.path) ? null : `${formatBytes(f.size, false)} ${f.path}`
      ).filter(f => f).join('\n')
    )
  }
  if (tarball.bundled.length) {
    log.notice('Bundled Dependencies')
    tarball.bundled.forEach(name => log.notice('', name))
  }
  log.notice('Tarball Details')
  log.notice('', `name: ${tarball.name}`)
  log.notice('', `version: ${tarball.version}`)
  if (tarball.filename) {
    log.notice('', `filename: ${tarball.filename}`)
  }
  log.notice('', `package size: ${formatBytes(tarball.size)}`)
  log.notice('', `unpacked size: ${formatBytes(tarball.unpackedSize)}`)
  log.notice('', `shasum: ${tarball.shasum}`)
  /* eslint-disable-next-line max-len */
  log.notice('', `integrity: ${tarball.integrity.toString().slice(0, 20)}[...]${tarball.integrity.toString().slice(80)}`)
  if (tarball.bundled.length) {
    log.notice('', `bundled deps: ${tarball.bundled.length}`)
    log.notice('', `bundled files: ${tarball.entryCount - tarball.files.length}`)
    log.notice('', `own files: ${tarball.files.length}`)
  }
  log.notice('', `total files: ${tarball.entryCount}`)
  log.notice('', '')
}

const getContents = async (manifest, tarball) => {
  const files = []
  const bundled = new Set()
  let totalEntries = 0
  let totalEntrySize = 0

  // reads contents of tarball
  const stream = tar.t({
    onentry (entry) {
      totalEntries++
      totalEntrySize += entry.size
      const p = entry.path
      if (p.startsWith('package/node_modules/') && p !== 'package/node_modules/') {
        const name = p.match(/^package\/node_modules\/((?:@[^/]+\/)?[^/]+)/)[1]
        bundled.add(name)
      }
      files.push({
        path: entry.path.replace(/^package\//, ''),
        size: entry.size,
        mode: entry.mode,
      })
    },
  })
  stream.end(tarball)

  const integrity = ssri.fromData(tarball, {
    algorithms: ['sha1', 'sha512'],
  })

  const comparator = ({ path: a }, { path: b }) => localeCompare(a, b)

  const isUpper = str => {
    const ch = str.charAt(0)
    return ch === ch.toUpperCase()
  }

  const uppers = files.filter(file => isUpper(file.path))
  const others = files.filter(file => !isUpper(file.path))

  uppers.sort(comparator)
  others.sort(comparator)

  const shasum = integrity.sha1[0].hexDigest()
  return {
    id: manifest._id || `${manifest.name}@${manifest.version}`,
    name: manifest.name,
    version: manifest.version,
    size: tarball.length,
    unpackedSize: totalEntrySize,
    shasum,
    integrity: ssri.parse(integrity.sha512[0]),
    // @scope/packagename.tgz => scope-packagename.tgz
    // we can safely use these global replace rules due to npm package naming rules
    filename: `${manifest.name.replace('@', '').replace('/', '-')}-${manifest.version}.tgz`,
    files: uppers.concat(others),
    entryCount: totalEntries,
    bundled: Array.from(bundled),
  }
}

module.exports = { logTar, getContents }
                                node-23.7.0/deps/npm/lib/utils/timers.js                                                            0000664 0000000 0000000 00000004110 14746647661 0020045 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const EE = require('node:events')
const fs = require('node:fs')
const { log, time } = require('proc-log')

const INITIAL_TIMER = 'npm'

class Timers extends EE {
  #file
  #timing

  #unfinished = new Map()
  #finished = {}

  constructor () {
    super()
    this.on()
    time.start(INITIAL_TIMER)
    this.started = this.#unfinished.get(INITIAL_TIMER)
  }

  on () {
    process.on('time', this.#timeHandler)
  }

  off () {
    process.off('time', this.#timeHandler)
  }

  load ({ path, timing } = {}) {
    this.#timing = timing
    this.#file = `${path}timing.json`
  }

  finish (metadata) {
    time.end(INITIAL_TIMER)

    for (const [name, timer] of this.#unfinished) {
      log.silly('unfinished npm timer', name, timer)
    }

    if (!this.#timing) {
      // Not in timing mode, nothing else to do here
      return
    }

    try {
      this.#writeFile(metadata)
      log.info('timing', `Timing info written to: ${this.#file}`)
    } catch (e) {
      log.warn('timing', `could not write timing file: ${e}`)
    }
  }

  #writeFile (metadata) {
    const globalStart = this.started
    const globalEnd = this.#finished[INITIAL_TIMER]
    const content = {
      metadata,
      timers: this.#finished,
      // add any unfinished timers with their relative start/end
      unfinishedTimers: [...this.#unfinished.entries()].reduce((acc, [name, start]) => {
        acc[name] = [start - globalStart, globalEnd - globalStart]
        return acc
      }, {}),
    }
    fs.writeFileSync(this.#file, JSON.stringify(content) + '\n')
  }

  #timeHandler = (level, name) => {
    const now = Date.now()
    switch (level) {
      case time.KEYS.start:
        this.#unfinished.set(name, now)
        break
      case time.KEYS.end: {
        if (this.#unfinished.has(name)) {
          const ms = now - this.#unfinished.get(name)
          this.#finished[name] = ms
          this.#unfinished.delete(name)
          log.timing(name, `Completed in ${ms}ms`)
        } else {
          log.silly('timing', `Tried to end timer that doesn't exist: ${name}`)
        }
      }
    }
  }
}

module.exports = Timers
                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/npm/lib/utils/update-workspaces.js                                                 0000664 0000000 0000000 00000001765 14746647661 0022220 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict'

const reifyFinish = require('../utils/reify-finish.js')

async function updateWorkspaces ({
  config,
  flatOptions,
  localPrefix,
  npm,
  workspaces,
}) {
  if (!flatOptions.workspacesUpdate || !workspaces.length) {
    return
  }

  // default behavior is to not save by default in order to avoid
  // race condition problems when publishing multiple workspaces
  // that have dependencies on one another, it might still be useful
  // in some cases, which then need to set --save
  const save = config.isDefault('save')
    ? false
    : config.get('save')

  // runs a minimalistic reify update, targeting only the workspaces
  // that had version updates and skipping fund/audit/save
  const opts = {
    ...flatOptions,
    audit: false,
    fund: false,
    path: localPrefix,
    save,
  }
  const Arborist = require('@npmcli/arborist')
  const arb = new Arborist(opts)

  await arb.reify({ ...opts, update: workspaces })
  await reifyFinish(npm, arb)
}

module.exports = updateWorkspaces
           node-23.7.0/deps/npm/lib/utils/validate-lockfile.js                                                 0000664 0000000 0000000 00000001777 14746647661 0022141 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // compares the inventory of package items in the tree
// that is about to be installed (idealTree) with the inventory
// of items stored in the package-lock file (virtualTree)
//
// Returns empty array if no errors found or an array populated
// with an entry for each validation error found.
function validateLockfile (virtualTree, idealTree) {
  const errors = []

  // loops through the inventory of packages resulted by ideal tree,
  // for each package compares the versions with the version stored in the
  // package-lock and adds an error to the list in case of mismatches
  for (const [key, entry] of idealTree.entries()) {
    const lock = virtualTree.get(key)

    if (!lock) {
      errors.push(`Missing: ${entry.name}@${entry.version} from lock file`)
      continue
    }

    if (entry.version !== lock.version) {
      errors.push(`Invalid: lock file's ${lock.name}@${lock.version} does ` +
      `not satisfy ${entry.name}@${entry.version}`)
    }
  }
  return errors
}

module.exports = validateLockfile
 node-23.7.0/deps/npm/lib/utils/verify-signatures.js                                                 0000664 0000000 0000000 00000027654 14746647661 0022252 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        const fetch = require('npm-registry-fetch')
const localeCompare = require('@isaacs/string-locale-compare')('en')
const npa = require('npm-package-arg')
const pacote = require('pacote')
const pMap = require('p-map')
const tufClient = require('@sigstore/tuf')
const { log, output } = require('proc-log')

const sortAlphabetically = (a, b) => localeCompare(a.name, b.name)

class VerifySignatures {
  constructor (tree, filterSet, npm, opts) {
    this.tree = tree
    this.filterSet = filterSet
    this.npm = npm
    this.opts = opts
    this.keys = new Map()
    this.invalid = []
    this.missing = []
    this.checkedPackages = new Set()
    this.auditedWithKeysCount = 0
    this.verifiedSignatureCount = 0
    this.verifiedAttestationCount = 0
    this.exitCode = 0
  }

  async run () {
    const start = process.hrtime.bigint()

    // Find all deps in tree
    const { edges, registries } = this.getEdgesOut(this.tree.inventory.values(), this.filterSet)
    if (edges.size === 0) {
      throw new Error('found no installed dependencies to audit')
    }

    const tuf = await tufClient.initTUF({
      cachePath: this.opts.tufCache,
      retry: this.opts.retry,
      timeout: this.opts.timeout,
    })
    await Promise.all([...registries].map(registry => this.setKeys({ registry, tuf })))

    log.verbose('verifying registry signatures')
    await pMap(edges, (e) => this.getVerifiedInfo(e), { concurrency: 20, stopOnError: true })

    // Didn't find any dependencies that could be verified, e.g. only local
    // deps, missing version, not on a registry etc.
    if (!this.auditedWithKeysCount) {
      throw new Error('found no dependencies to audit that were installed from ' +
                      'a supported registry')
    }

    const invalid = this.invalid.sort(sortAlphabetically)
    const missing = this.missing.sort(sortAlphabetically)

    const hasNoInvalidOrMissing = invalid.length === 0 && missing.length === 0

    if (!hasNoInvalidOrMissing) {
      process.exitCode = 1
    }

    if (this.npm.config.get('json')) {
      output.buffer({ invalid, missing })
      return
    }
    const end = process.hrtime.bigint()
    const elapsed = end - start

    const auditedPlural = this.auditedWithKeysCount > 1 ? 's' : ''
    const timing = `audited ${this.auditedWithKeysCount} package${auditedPlural} in ` +
      `${Math.floor(Number(elapsed) / 1e9)}s`
    output.standard(timing)
    output.standard('')

    const verifiedBold = this.npm.chalk.bold('verified')
    if (this.verifiedSignatureCount) {
      if (this.verifiedSignatureCount === 1) {
        /* eslint-disable-next-line max-len */
        output.standard(`${this.verifiedSignatureCount} package has a ${verifiedBold} registry signature`)
      } else {
        /* eslint-disable-next-line max-len */
        output.standard(`${this.verifiedSignatureCount} packages have ${verifiedBold} registry signatures`)
      }
      output.standard('')
    }

    if (this.verifiedAttestationCount) {
      if (this.verifiedAttestationCount === 1) {
        /* eslint-disable-next-line max-len */
        output.standard(`${this.verifiedAttestationCount} package has a ${verifiedBold} attestation`)
      } else {
        /* eslint-disable-next-line max-len */
        output.standard(`${this.verifiedAttestationCount} packages have ${verifiedBold} attestations`)
      }
      output.standard('')
    }

    if (missing.length) {
      const missingClr = this.npm.chalk.redBright('missing')
      if (missing.length === 1) {
        /* eslint-disable-next-line max-len */
        output.standard(`1 package has a ${missingClr} registry signature but the registry is providing signing keys:`)
      } else {
        /* eslint-disable-next-line max-len */
        output.standard(`${missing.length} packages have ${missingClr} registry signatures but the registry is providing signing keys:`)
      }
      output.standard('')
      missing.map(m =>
        output.standard(`${this.npm.chalk.red(`${m.name}@${m.version}`)} (${m.registry})`)
      )
    }

    if (invalid.length) {
      if (missing.length) {
        output.standard('')
      }
      const invalidClr = this.npm.chalk.redBright('invalid')
      // We can have either invalid signatures or invalid provenance
      const invalidSignatures = this.invalid.filter(i => i.code === 'EINTEGRITYSIGNATURE')
      if (invalidSignatures.length) {
        if (invalidSignatures.length === 1) {
          output.standard(`1 package has an ${invalidClr} registry signature:`)
        } else {
          /* eslint-disable-next-line max-len */
          output.standard(`${invalidSignatures.length} packages have ${invalidClr} registry signatures:`)
        }
        output.standard('')
        invalidSignatures.map(i =>
          output.standard(`${this.npm.chalk.red(`${i.name}@${i.version}`)} (${i.registry})`)
        )
        output.standard('')
      }

      const invalidAttestations = this.invalid.filter(i => i.code === 'EATTESTATIONVERIFY')
      if (invalidAttestations.length) {
        if (invalidAttestations.length === 1) {
          output.standard(`1 package has an ${invalidClr} attestation:`)
        } else {
          /* eslint-disable-next-line max-len */
          output.standard(`${invalidAttestations.length} packages have ${invalidClr} attestations:`)
        }
        output.standard('')
        invalidAttestations.map(i =>
          output.standard(`${this.npm.chalk.red(`${i.name}@${i.version}`)} (${i.registry})`)
        )
        output.standard('')
      }

      if (invalid.length === 1) {
        /* eslint-disable-next-line max-len */
        output.standard(`Someone might have tampered with this package since it was published on the registry!`)
      } else {
        /* eslint-disable-next-line max-len */
        output.standard(`Someone might have tampered with these packages since they were published on the registry!`)
      }
      output.standard('')
    }
  }

  getEdgesOut (nodes, filterSet) {
    const edges = new Set()
    const registries = new Set()
    for (const node of nodes) {
      for (const edge of node.edgesOut.values()) {
        const filteredOut =
          edge.from
            && filterSet
            && filterSet.size > 0
            && !filterSet.has(edge.from.target)

        if (!filteredOut) {
          const spec = this.getEdgeSpec(edge)
          if (spec) {
            // Prefetch and cache public keys from used registries
            registries.add(this.getSpecRegistry(spec))
          }
          edges.add(edge)
        }
      }
    }
    return { edges, registries }
  }

  async setKeys ({ registry, tuf }) {
    const { host, pathname } = new URL(registry)
    // Strip any trailing slashes from pathname
    const regKey = `${host}${pathname.replace(/\/$/, '')}/keys.json`
    let keys = await tuf.getTarget(regKey)
      .then((target) => JSON.parse(target))
      .then(({ keys: ks }) => ks.map((key) => ({
        ...key,
        keyid: key.keyId,
        pemkey: `-----BEGIN PUBLIC KEY-----\n${key.publicKey.rawBytes}\n-----END PUBLIC KEY-----`,
        expires: key.publicKey.validFor.end || null,
      }))).catch(err => {
        if (err.code === 'TUF_FIND_TARGET_ERROR') {
          return null
        } else {
          throw err
        }
      })

    // If keys not found in Sigstore TUF repo, fallback to registry keys API
    if (!keys) {
      keys = await fetch.json('/-/npm/v1/keys', {
        ...this.npm.flatOptions,
        registry,
      }).then(({ keys: ks }) => ks.map((key) => ({
        ...key,
        pemkey: `-----BEGIN PUBLIC KEY-----\n${key.key}\n-----END PUBLIC KEY-----`,
      }))).catch(err => {
        if (err.code === 'E404' || err.code === 'E400') {
          return null
        } else {
          throw err
        }
      })
    }

    if (keys) {
      this.keys.set(registry, keys)
    }
  }

  getEdgeType (edge) {
    return edge.optional ? 'optionalDependencies'
      : edge.peer ? 'peerDependencies'
      : edge.dev ? 'devDependencies'
      : 'dependencies'
  }

  getEdgeSpec (edge) {
    let name = edge.name
    try {
      name = npa(edge.spec).subSpec.name
    } catch {
      // leave it as edge.name
    }
    try {
      return npa(`${name}@${edge.spec}`)
    } catch {
      // Skip packages with invalid spec
    }
  }

  buildRegistryConfig (registry) {
    const keys = this.keys.get(registry) || []
    const parsedRegistry = new URL(registry)
    const regKey = `//${parsedRegistry.host}${parsedRegistry.pathname}`
    return {
      [`${regKey}:_keys`]: keys,
    }
  }

  getSpecRegistry (spec) {
    return fetch.pickRegistry(spec, this.npm.flatOptions)
  }

  getValidPackageInfo (edge) {
    const type = this.getEdgeType(edge)
    // Skip potentially optional packages that are not on disk, as these could
    // be omitted during install
    if (edge.error === 'MISSING' && type !== 'dependencies') {
      return
    }

    const spec = this.getEdgeSpec(edge)
    // Skip invalid version requirements
    if (!spec) {
      return
    }
    const node = edge.to || edge
    const { version } = node.package || {}

    if (node.isWorkspace || // Skip local workspaces packages
        !version || // Skip packages that don't have a installed version, e.g. optonal dependencies
        !spec.registry) { // Skip if not from registry, e.g. git package
      return
    }

    for (const omitType of this.npm.config.get('omit')) {
      if (node[omitType]) {
        return
      }
    }

    return {
      name: spec.name,
      version,
      type,
      location: node.location,
      registry: this.getSpecRegistry(spec),
    }
  }

  async verifySignatures (name, version, registry) {
    const {
      _integrity: integrity,
      _signatures,
      _attestations,
      _resolved: resolved,
    } = await pacote.manifest(`${name}@${version}`, {
      verifySignatures: true,
      verifyAttestations: true,
      ...this.buildRegistryConfig(registry),
      ...this.npm.flatOptions,
    })
    const signatures = _signatures || []
    const result = {
      integrity,
      signatures,
      attestations: _attestations,
      resolved,
    }
    return result
  }

  async getVerifiedInfo (edge) {
    const info = this.getValidPackageInfo(edge)
    if (!info) {
      return
    }
    const { name, version, location, registry, type } = info
    if (this.checkedPackages.has(location)) {
      // we already did or are doing this one
      return
    }
    this.checkedPackages.add(location)

    // We only "audit" or verify the signature, or the presence of it, on
    // packages whose registry returns signing keys
    const keys = this.keys.get(registry) || []
    if (keys.length) {
      this.auditedWithKeysCount += 1
    }

    try {
      const { integrity, signatures, attestations, resolved } = await this.verifySignatures(
        name, version, registry
      )

      // Currently we only care about missing signatures on registries that provide a public key
      // We could make this configurable in the future with a strict/paranoid mode
      if (signatures.length) {
        this.verifiedSignatureCount += 1
      } else if (keys.length) {
        this.missing.push({
          integrity,
          location,
          name,
          registry,
          resolved,
          version,
        })
      }

      // Track verified attestations separately to registry signatures, as all
      // packages on registries with signing keys are expected to have registry
      // signatures, but not all packages have provenance and publish attestations.
      if (attestations) {
        this.verifiedAttestationCount += 1
      }
    } catch (e) {
      if (e.code === 'EINTEGRITYSIGNATURE' || e.code === 'EATTESTATIONVERIFY') {
        this.invalid.push({
          code: e.code,
          message: e.message,
          integrity: e.integrity,
          keyid: e.keyid,
          location,
          name,
          registry,
          resolved: e.resolved,
          signature: e.signature,
          predicateType: e.predicateType,
          type,
          version,
        })
      } else {
        throw e
      }
    }
  }
}

module.exports = VerifySignatures
                                                                                    node-23.7.0/deps/npm/man/                                                                           0000775 0000000 0000000 00000000000 14746647661 0015055 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/npm/man/man1/                                                                      0000775 0000000 0000000 00000000000 14746647661 0015711 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/npm/man/man1/npm-access.1                                                          0000664 0000000 0000000 00000007742 14746647661 0020036 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-ACCESS" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-access\fR - Set access level on published packages
.SS "Synopsis"
.P
.RS 2
.nf
npm access list packages \[lB]<user>|<scope>|<scope:team>\[rB] \[lB]<package>\[rB]
npm access list collaborators \[lB]<package> \[lB]<user>\[rB]\[rB]
npm access get status \[lB]<package>\[rB]
npm access set status=public|private \[lB]<package>\[rB]
npm access set mfa=none|publish|automation \[lB]<package>\[rB]
npm access grant <read-only|read-write> <scope:team> \[lB]<package>\[rB]
npm access revoke <scope:team> \[lB]<package>\[rB]
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Used to set access controls on private packages.
.P
For all of the subcommands, \fBnpm access\fR will perform actions on the packages in the current working directory if no package name is passed to the subcommand.
.RS 0
.IP \(bu 4
public / restricted (deprecated): Set a package to be either publicly accessible or restricted.
.IP \(bu 4
grant / revoke (deprecated): Add or remove the ability of users and teams to have read-only or read-write access to a package.
.IP \(bu 4
2fa-required / 2fa-not-required (deprecated): Configure whether a package requires that anyone publishing it have two-factor authentication enabled on their account.
.IP \(bu 4
ls-packages (deprecated): Show all of the packages a user or a team is able to access, along with the access level, except for read-only public packages (it won't print the whole registry listing)
.IP \(bu 4
ls-collaborators (deprecated): Show all of the access privileges for a package. Will only show permissions for packages to which you have at least read access. If \fB<user>\fR is passed in, the list is filtered only to teams \fIthat\fR user happens to belong to.
.IP \(bu 4
edit (not implemented)
.RE 0

.SS "Details"
.P
\fBnpm access\fR always operates directly on the current registry, configurable from the command line using \fB--registry=<registry url>\fR.
.P
Unscoped packages are \fIalways public\fR.
.P
Scoped packages \fIdefault to restricted\fR, but you can either publish them as public using \fBnpm publish --access=public\fR, or set their access as public using \fBnpm access public\fR after the initial publish.
.P
You must have privileges to set the access of a package:
.RS 0
.IP \(bu 4
You are an owner of an unscoped or scoped package.
.IP \(bu 4
You are a member of the team that owns a scope.
.IP \(bu 4
You have been given read-write privileges for a package, either as a member of a team or directly as an owner.
.RE 0

.P
If you have two-factor authentication enabled then you'll be prompted to provide a second factor, or may use the \fB--otp=...\fR option to specify it on the command line.
.P
If your account is not paid, then attempts to publish scoped packages will fail with an HTTP 402 status code (logically enough), unless you use \fB--access=public\fR.
.P
Management of teams and team memberships is done with the \fBnpm team\fR command.
.SS "Configuration"
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBotp\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with \fBnpm access\fR.
.P
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "See Also"
.RS 0
.IP \(bu 4
\fB\fBlibnpmaccess\fR\fR \fI\(lahttps://npm.im/libnpmaccess\(ra\fR
.IP \(bu 4
npm help team
.IP \(bu 4
npm help publish
.IP \(bu 4
npm help config
.IP \(bu 4
npm help registry
.RE 0
                              node-23.7.0/deps/npm/man/man1/npm-adduser.1                                                         0000664 0000000 0000000 00000003714 14746647661 0020217 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-ADDUSER" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-adduser\fR - Add a registry user account
.SS "Synopsis"
.P
.RS 2
.nf
npm adduser

alias: add-user
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Create a new user in the specified registry, and save the credentials to the \fB.npmrc\fR file. If no registry is specified, the default registry will be used (see npm help registry).
.P
When using \fBlegacy\fR for your \fBauth-type\fR, the username, password, and email are read in from prompts.
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBscope\fR"
.RS 0
.IP \(bu 4
Default: the scope of the current project, if any, or ""
.IP \(bu 4
Type: String
.RE 0

.P
Associate an operation with a scope for a scoped registry.
.P
Useful when logging in to or out of a private registry:
.P
.RS 2
.nf
# log in, linking the scope to the custom registry
npm login --scope=@mycorp --registry=https://registry.mycorp.com

# log out, removing the link and the auth token
npm logout --scope=@mycorp
.fi
.RE
.P
This will cause \fB@mycorp\fR to be mapped to the registry for future installation of packages specified according to the pattern \fB@mycorp/package\fR.
.P
This will also cause \fBnpm init\fR to create a scoped package.
.P
.RS 2
.nf
# accept all defaults, and create a package named "@foo/whatever",
# instead of just named "whatever"
npm init --scope=@foo --yes
.fi
.RE
.SS "\fBauth-type\fR"
.RS 0
.IP \(bu 4
Default: "web"
.IP \(bu 4
Type: "legacy" or "web"
.RE 0

.P
What authentication strategy to use with \fBlogin\fR. Note that if an \fBotp\fR config is given, this value will always be set to \fBlegacy\fR.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help owner
.IP \(bu 4
npm help whoami
.IP \(bu 4
npm help token
.IP \(bu 4
npm help profile
.RE 0
                                                    node-23.7.0/deps/npm/man/man1/npm-audit.1                                                           0000664 0000000 0000000 00000041751 14746647661 0017701 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-AUDIT" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-audit\fR - Run a security audit
.SS "Synopsis"
.P
.RS 2
.nf
npm audit \[lB]fix|signatures\[rB]
.fi
.RE
.SS "Description"
.P
The audit command submits a description of the dependencies configured in your project to your default registry and asks for a report of known vulnerabilities. If any vulnerabilities are found, then the impact and appropriate remediation will be calculated. If the \fBfix\fR argument is provided, then remediations will be applied to the package tree.
.P
The command will exit with a 0 exit code if no vulnerabilities were found.
.P
Note that some vulnerabilities cannot be fixed automatically and will require manual intervention or review. Also note that since \fBnpm audit
fix\fR runs a full-fledged \fBnpm install\fR under the hood, all configs that apply to the installer will also apply to \fBnpm install\fR -- so things like \fBnpm audit fix --package-lock-only\fR will work as expected.
.P
By default, the audit command will exit with a non-zero code if any vulnerability is found. It may be useful in CI environments to include the \fB--audit-level\fR parameter to specify the minimum vulnerability level that will cause the command to fail. This option does not filter the report output, it simply changes the command's failure threshold.
.SS "Package lock"
.P
By default npm requires a package-lock or shrinkwrap in order to run the audit. You can bypass the package lock with \fB--no-package-lock\fR but be aware the results may be different with every run, since npm will re-build the dependency tree each time.
.SS "Audit Signatures"
.P
To ensure the integrity of packages you download from the public npm registry, or any registry that supports signatures, you can verify the registry signatures of downloaded packages using the npm CLI.
.P
Registry signatures can be verified using the following \fBaudit\fR command:
.P
.RS 2
.nf
$ npm audit signatures
.fi
.RE
.P
The \fBaudit signatures\fR command will also verify the provenance attestations of downloaded packages. Because provenance attestations are such a new feature, security features may be added to (or changed in) the attestation format over time. To ensure that you're always able to verify attestation signatures check that you're running the latest version of the npm CLI. Please note this often means updating npm beyond the version that ships with Node.js.
.P
The npm CLI supports registry signatures and signing keys provided by any registry if the following conventions are followed:
.RS 0
.IP 1. 4
Signatures are provided in the package's \fBpackument\fR in each published version within the \fBdist\fR object:
.RE 0

.P
.RS 2
.nf
"dist":{
  "..omitted..": "..omitted..",
  "signatures": \[lB]{
    "keyid": "SHA256:{{SHA256_PUBLIC_KEY}}",
    "sig": "a312b9c3cb4a1b693e8ebac5ee1ca9cc01f2661c14391917dcb111517f72370809..."
  }\[rB]
}
.fi
.RE
.P
See this \fBexample\fR \fI\(lahttps://registry.npmjs.org/light-cycle/1.4.3\(ra\fR of a signed package from the public npm registry.
.P
The \fBsig\fR is generated using the following template: \fB${package.name}@${package.version}:${package.dist.integrity}\fR and the \fBkeyid\fR has to match one of the public signing keys below.
.RS 0
.IP 2. 4
Public signing keys are provided at \fBregistry-host.tld/-/npm/v1/keys\fR in the following format:
.RE 0

.P
.RS 2
.nf
{
  "keys": \[lB]{
    "expires": null,
    "keyid": "SHA256:{{SHA256_PUBLIC_KEY}}",
    "keytype": "ecdsa-sha2-nistp256",
    "scheme": "ecdsa-sha2-nistp256",
    "key": "{{B64_PUBLIC_KEY}}"
  }\[rB]
}
.fi
.RE
.P
Keys response:
.RS 0
.IP \(bu 4
\fBexpires\fR: null or a simplified extended \fBISO 8601 format\fR \fI\(lahttps://en.wikipedia.org/wiki/ISO_8601\(ra\fR: \fBYYYY-MM-DDTHH:mm:ss.sssZ\fR
.IP \(bu 4
\fBkeydid\fR: sha256 fingerprint of the public key
.IP \(bu 4
\fBkeytype\fR: only \fBecdsa-sha2-nistp256\fR is currently supported by the npm CLI
.IP \(bu 4
\fBscheme\fR: only \fBecdsa-sha2-nistp256\fR is currently supported by the npm CLI
.IP \(bu 4
\fBkey\fR: base64 encoded public key
.RE 0

.P
See this \fBexample key's response from the public npm registry\fR \fI\(lahttps://registry.npmjs.org/-/npm/v1/keys\(ra\fR.
.SS "Audit Endpoints"
.P
There are two audit endpoints that npm may use to fetch vulnerability information: the \fBBulk Advisory\fR endpoint and the \fBQuick Audit\fR endpoint.
.SS "Bulk Advisory Endpoint"
.P
As of version 7, npm uses the much faster \fBBulk Advisory\fR endpoint to optimize the speed of calculating audit results.
.P
npm will generate a JSON payload with the name and list of versions of each package in the tree, and POST it to the default configured registry at the path \fB/-/npm/v1/security/advisories/bulk\fR.
.P
Any packages in the tree that do not have a \fBversion\fR field in their package.json file will be ignored. If any \fB--omit\fR options are specified (either via the \fB\fB--omit\fR config\fR \fI\(la/using-npm/config#omit\(ra\fR, or one of the shorthands such as \fB--production\fR, \fB--only=dev\fR, and so on), then packages will be omitted from the submitted payload as appropriate.
.P
If the registry responds with an error, or with an invalid response, then npm will attempt to load advisory data from the \fBQuick Audit\fR endpoint.
.P
The expected result will contain a set of advisory objects for each dependency that matches the advisory range. Each advisory object contains a \fBname\fR, \fBurl\fR, \fBid\fR, \fBseverity\fR, \fBvulnerable_versions\fR, and \fBtitle\fR.
.P
npm then uses these advisory objects to calculate vulnerabilities and meta-vulnerabilities of the dependencies within the tree.
.SS "Quick Audit Endpoint"
.P
If the \fBBulk Advisory\fR endpoint returns an error, or invalid data, npm will attempt to load advisory data from the \fBQuick Audit\fR endpoint, which is considerably slower in most cases.
.P
The full package tree as found in \fBpackage-lock.json\fR is submitted, along with the following pieces of additional metadata:
.RS 0
.IP \(bu 4
\fBnpm_version\fR
.IP \(bu 4
\fBnode_version\fR
.IP \(bu 4
\fBplatform\fR
.IP \(bu 4
\fBarch\fR
.IP \(bu 4
\fBnode_env\fR
.RE 0

.P
All packages in the tree are submitted to the Quick Audit endpoint. Omitted dependency types are skipped when generating the report.
.SS "Scrubbing"
.P
Out of an abundance of caution, npm versions 5 and 6 would "scrub" any packages from the submitted report if their name contained a \fB/\fR character, so as to avoid leaking the names of potentially private packages or git URLs.
.P
However, in practice, this resulted in audits often failing to properly detect meta-vulnerabilities, because the tree would appear to be invalid due to missing dependencies, and prevented the detection of vulnerabilities in package trees that used git dependencies or private modules.
.P
This scrubbing has been removed from npm as of version 7.
.SS "Calculating Meta-Vulnerabilities and Remediations"
.P
npm uses the \fB\fB@npmcli/metavuln-calculator\fR\fR \fI\(lahttp://npm.im/@npmcli/metavuln-calculator\(ra\fR module to turn a set of security advisories into a set of "vulnerability" objects. A "meta-vulnerability" is a dependency that is vulnerable by virtue of dependence on vulnerable versions of a vulnerable package.
.P
For example, if the package \fBfoo\fR is vulnerable in the range \fB>=1.0.2
<2.0.0\fR, and the package \fBbar\fR depends on \fBfoo@^1.1.0\fR, then that version of \fBbar\fR can only be installed by installing a vulnerable version of \fBfoo\fR. In this case, \fBbar\fR is a "metavulnerability".
.P
Once metavulnerabilities for a given package are calculated, they are cached in the \fB~/.npm\fR folder and only re-evaluated if the advisory range changes, or a new version of the package is published (in which case, the new version is checked for metavulnerable status as well).
.P
If the chain of metavulnerabilities extends all the way to the root project, and it cannot be updated without changing its dependency ranges, then \fBnpm audit fix\fR will require the \fB--force\fR option to apply the remediation. If remediations do not require changes to the dependency ranges, then all vulnerable packages will be updated to a version that does not have an advisory or metavulnerability posted against it.
.SS "Exit Code"
.P
The \fBnpm audit\fR command will exit with a 0 exit code if no vulnerabilities were found. The \fBnpm audit fix\fR command will exit with 0 exit code if no vulnerabilities are found \fIor\fR if the remediation is able to successfully fix all vulnerabilities.
.P
If vulnerabilities were found the exit code will depend on the \fB\fBaudit-level\fR config\fR \fI\(la/using-npm/config#audit-level\(ra\fR.
.SS "Examples"
.P
Scan your project for vulnerabilities and automatically install any compatible updates to vulnerable dependencies:
.P
.RS 2
.nf
$ npm audit fix
.fi
.RE
.P
Run \fBaudit fix\fR without modifying \fBnode_modules\fR, but still updating the pkglock:
.P
.RS 2
.nf
$ npm audit fix --package-lock-only
.fi
.RE
.P
Skip updating \fBdevDependencies\fR:
.P
.RS 2
.nf
$ npm audit fix --only=prod
.fi
.RE
.P
Have \fBaudit fix\fR install SemVer-major updates to toplevel dependencies, not just SemVer-compatible ones:
.P
.RS 2
.nf
$ npm audit fix --force
.fi
.RE
.P
Do a dry run to get an idea of what \fBaudit fix\fR will do, and \fIalso\fR output install information in JSON format:
.P
.RS 2
.nf
$ npm audit fix --dry-run --json
.fi
.RE
.P
Scan your project for vulnerabilities and just show the details, without fixing anything:
.P
.RS 2
.nf
$ npm audit
.fi
.RE
.P
Get the detailed audit report in JSON format:
.P
.RS 2
.nf
$ npm audit --json
.fi
.RE
.P
Fail an audit only if the results include a vulnerability with a level of moderate or higher:
.P
.RS 2
.nf
$ npm audit --audit-level=moderate
.fi
.RE
.SS "Configuration"
.SS "\fBaudit-level\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null, "info", "low", "moderate", "high", "critical", or "none"
.RE 0

.P
The minimum level of vulnerability for \fBnpm audit\fR to exit with a non-zero exit code.
.SS "\fBdry-run\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, \fBinstall\fR, \fBupdate\fR, \fBdedupe\fR, \fBuninstall\fR, as well as \fBpack\fR and \fBpublish\fR.
.P
Note: This is NOT honored by other network related commands, eg \fBdist-tags\fR, \fBowner\fR, etc.
.SS "\fBforce\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Removes various protections against unfortunate side effects, common mistakes, unnecessary performance degradation, and malicious input.
.RS 0
.IP \(bu 4
Allow clobbering non-npm files in global installs.
.IP \(bu 4
Allow the \fBnpm version\fR command to work on an unclean git repository.
.IP \(bu 4
Allow deleting the cache folder with \fBnpm cache clean\fR.
.IP \(bu 4
Allow installing packages that have an \fBengines\fR declaration requiring a different version of npm.
.IP \(bu 4
Allow installing packages that have an \fBengines\fR declaration requiring a different version of \fBnode\fR, even if \fB--engine-strict\fR is enabled.
.IP \(bu 4
Allow \fBnpm audit fix\fR to install modules outside your stated dependency range (including SemVer-major changes).
.IP \(bu 4
Allow unpublishing all versions of a published package.
.IP \(bu 4
Allow conflicting peerDependencies to be installed in the root project.
.IP \(bu 4
Implicitly set \fB--yes\fR during \fBnpm init\fR.
.IP \(bu 4
Allow clobbering existing values in \fBnpm pkg\fR
.IP \(bu 4
Allow unpublishing of entire packages (not just a single version).
.RE 0

.P
If you don't have a clear idea of what you want to do, it is strongly recommended that you do not use this option!
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBpackage-lock-only\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to true, the current operation will only use the \fBpackage-lock.json\fR, ignoring \fBnode_modules\fR.
.P
For \fBupdate\fR this means only the \fBpackage-lock.json\fR will be updated, instead of checking \fBnode_modules\fR and downloading dependencies.
.P
For \fBlist\fR this means the output will be based on the tree described by the \fBpackage-lock.json\fR, rather than the contents of \fBnode_modules\fR.
.SS "\fBpackage-lock\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to false, then ignore \fBpackage-lock.json\fR files when installing. This will also prevent \fIwriting\fR \fBpackage-lock.json\fR if \fBsave\fR is true.
.SS "\fBomit\fR"
.RS 0
.IP \(bu 4
Default: 'dev' if the \fBNODE_ENV\fR environment variable is set to 'production', otherwise empty.
.IP \(bu 4
Type: "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Dependency types to omit from the installation tree on disk.
.P
Note that these dependencies \fIare\fR still resolved and added to the \fBpackage-lock.json\fR or \fBnpm-shrinkwrap.json\fR file. They are just not physically installed on disk.
.P
If a package type appears in both the \fB--include\fR and \fB--omit\fR lists, then it will be included.
.P
If the resulting omit list includes \fB'dev'\fR, then the \fBNODE_ENV\fR environment variable will be set to \fB'production'\fR for all lifecycle scripts.
.SS "\fBinclude\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: "prod", "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Option that allows for defining which types of dependencies to install.
.P
This is the inverse of \fB--omit=<type>\fR.
.P
Dependency types specified in \fB--include\fR will not be omitted, regardless of the order in which omit/include are specified on the command-line.
.SS "\fBforeground-scripts\fR"
.RS 0
.IP \(bu 4
Default: \fBfalse\fR unless when using \fBnpm pack\fR or \fBnpm publish\fR where it defaults to \fBtrue\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Run all build scripts (ie, \fBpreinstall\fR, \fBinstall\fR, and \fBpostinstall\fR) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
.P
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBinstall-links\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help install
.IP \(bu 4
npm help config
.RE 0
                       node-23.7.0/deps/npm/man/man1/npm-bugs.1                                                            0000664 0000000 0000000 00000006467 14746647661 0017540 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-BUGS" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-bugs\fR - Report bugs for a package in a web browser
.SS "Synopsis"
.P
.RS 2
.nf
npm bugs \[lB]<pkgname> \[lB]<pkgname> ...\[rB]\[rB]

alias: issues
.fi
.RE
.SS "Description"
.P
This command tries to guess at the likely location of a package's bug tracker URL or the \fBmailto\fR URL of the support email, and then tries to open it using the \fB\fB--browser\fR config\fR \fI\(la/using-npm/config#browser\(ra\fR param. If no package name is provided, it will search for a \fBpackage.json\fR in the current folder and use the \fBname\fR property.
.SS "Configuration"
.SS "\fBbrowser\fR"
.RS 0
.IP \(bu 4
Default: OS X: \fB"open"\fR, Windows: \fB"start"\fR, Others: \fB"xdg-open"\fR
.IP \(bu 4
Type: null, Boolean, or String
.RE 0

.P
The browser that is called by npm commands to open websites.
.P
Set to \fBfalse\fR to suppress browser behavior and instead print urls to terminal.
.P
Set to \fBtrue\fR to use default system URL opener.
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help docs
.IP \(bu 4
npm help view
.IP \(bu 4
npm help publish
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
\fBpackage.json\fR \fI\(la/configuring-npm/package-json\(ra\fR
.RE 0
                                                                                                                                                                                                         node-23.7.0/deps/npm/man/man1/npm-cache.1                                                           0000664 0000000 0000000 00000006100 14746647661 0017623 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-CACHE" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-cache\fR - Manipulates packages cache
.SS "Synopsis"
.P
.RS 2
.nf
npm cache add <package-spec>
npm cache clean \[lB]<key>\[rB]
npm cache ls \[lB]<name>@<version>\[rB]
npm cache verify
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Used to add, list, or clean the npm cache folder.
.RS 0
.IP \(bu 4
add: Add the specified packages to the local cache. This command is primarily intended to be used internally by npm, but it can provide a way to add data to the local installation cache explicitly.
.IP \(bu 4
clean: Delete all data out of the cache folder. Note that this is typically unnecessary, as npm's cache is self-healing and resistant to data corruption issues.
.IP \(bu 4
verify: Verify the contents of the cache folder, garbage collecting any unneeded data, and verifying the integrity of the cache index and all cached data.
.RE 0

.SS "Details"
.P
npm stores cache data in an opaque directory within the configured \fBcache\fR, named \fB_cacache\fR. This directory is a \fB\fBcacache\fR\fR \fI\(lahttp://npm.im/cacache\(ra\fR-based content-addressable cache that stores all http request data as well as other package-related data. This directory is primarily accessed through \fBpacote\fR, the library responsible for all package fetching as of npm@5.
.P
All data that passes through the cache is fully verified for integrity on both insertion and extraction. Cache corruption will either trigger an error, or signal to \fBpacote\fR that the data must be refetched, which it will do automatically. For this reason, it should never be necessary to clear the cache for any reason other than reclaiming disk space, thus why \fBclean\fR now requires \fB--force\fR to run.
.P
There is currently no method exposed through npm to inspect or directly manage the contents of this cache. In order to access it, \fBcacache\fR must be used directly.
.P
npm will not remove data by itself: the cache will grow as new packages are installed.
.SS "A note about the cache's design"
.P
The npm cache is strictly a cache: it should not be relied upon as a persistent and reliable data store for package data. npm makes no guarantee that a previously-cached piece of data will be available later, and will automatically delete corrupted contents. The primary guarantee that the cache makes is that, if it does return data, that data will be exactly the data that was inserted.
.P
To run an offline verification of existing cache contents, use \fBnpm cache
verify\fR.
.SS "Configuration"
.SS "\fBcache\fR"
.RS 0
.IP \(bu 4
Default: Windows: \fB%LocalAppData%\[rs]npm-cache\fR, Posix: \fB~/.npm\fR
.IP \(bu 4
Type: Path
.RE 0

.P
The location of npm's cache directory.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help install
.IP \(bu 4
npm help publish
.IP \(bu 4
npm help pack
.IP \(bu 4
https://npm.im/cacache
.IP \(bu 4
https://npm.im/pacote
.IP \(bu 4
https://npm.im/@npmcli/arborist
.IP \(bu 4
https://npm.im/make-fetch-happen
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/npm/man/man1/npm-ci.1                                                              0000664 0000000 0000000 00000023711 14746647661 0017162 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-CI" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-ci\fR - Clean install a project
.SS "Synopsis"
.P
.RS 2
.nf
npm ci

aliases: clean-install, ic, install-clean, isntall-clean
.fi
.RE
.SS "Description"
.P
This command is similar to npm help install, except it's meant to be used in automated environments such as test platforms, continuous integration, and deployment -- or any situation where you want to make sure you're doing a clean install of your dependencies.
.P
The main differences between using \fBnpm install\fR and \fBnpm ci\fR are:
.RS 0
.IP \(bu 4
The project \fBmust\fR have an existing \fBpackage-lock.json\fR or \fBnpm-shrinkwrap.json\fR.
.IP \(bu 4
If dependencies in the package lock do not match those in \fBpackage.json\fR, \fBnpm ci\fR will exit with an error, instead of updating the package lock.
.IP \(bu 4
\fBnpm ci\fR can only install entire projects at a time: individual dependencies cannot be added with this command.
.IP \(bu 4
If a \fBnode_modules\fR is already present, it will be automatically removed before \fBnpm ci\fR begins its install.
.IP \(bu 4
It will never write to \fBpackage.json\fR or any of the package-locks: installs are essentially frozen.
.RE 0

.P
NOTE: If you create your \fBpackage-lock.json\fR file by running \fBnpm install\fR with flags that can affect the shape of your dependency tree, such as \fB--legacy-peer-deps\fR or \fB--install-links\fR, you \fImust\fR provide the same flags to \fBnpm ci\fR or you are likely to encounter errors. An easy way to do this is to run, for example, \fBnpm config set legacy-peer-deps=true --location=project\fR and commit the \fB.npmrc\fR file to your repo.
.SS "Example"
.P
Make sure you have a package-lock and an up-to-date install:
.P
.RS 2
.nf
$ cd ./my/npm/project
$ npm install
added 154 packages in 10s
$ ls | grep package-lock
.fi
.RE
.P
Run \fBnpm ci\fR in that project
.P
.RS 2
.nf
$ npm ci
added 154 packages in 5s
.fi
.RE
.P
Configure Travis CI to build using \fBnpm ci\fR instead of \fBnpm install\fR:
.P
.RS 2
.nf
# .travis.yml
install:
- npm ci
# keep the npm cache around to speed up installs
cache:
  directories:
  - "$HOME/.npm"
.fi
.RE
.SS "Configuration"
.SS "\fBinstall-strategy\fR"
.RS 0
.IP \(bu 4
Default: "hoisted"
.IP \(bu 4
Type: "hoisted", "nested", "shallow", or "linked"
.RE 0

.P
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
.SS "\fBlegacy-bundling\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=nested\fR
.RE 0

.P
Instead of hoisting package installs in \fBnode_modules\fR, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets \fB--install-strategy=nested\fR.
.SS "\fBglobal-style\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=shallow\fR
.RE 0

.P
Only install direct dependencies in the top level \fBnode_modules\fR, but hoist on deeper dependencies. Sets \fB--install-strategy=shallow\fR.
.SS "\fBomit\fR"
.RS 0
.IP \(bu 4
Default: 'dev' if the \fBNODE_ENV\fR environment variable is set to 'production', otherwise empty.
.IP \(bu 4
Type: "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Dependency types to omit from the installation tree on disk.
.P
Note that these dependencies \fIare\fR still resolved and added to the \fBpackage-lock.json\fR or \fBnpm-shrinkwrap.json\fR file. They are just not physically installed on disk.
.P
If a package type appears in both the \fB--include\fR and \fB--omit\fR lists, then it will be included.
.P
If the resulting omit list includes \fB'dev'\fR, then the \fBNODE_ENV\fR environment variable will be set to \fB'production'\fR for all lifecycle scripts.
.SS "\fBinclude\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: "prod", "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Option that allows for defining which types of dependencies to install.
.P
This is the inverse of \fB--omit=<type>\fR.
.P
Dependency types specified in \fB--include\fR will not be omitted, regardless of the order in which omit/include are specified on the command-line.
.SS "\fBstrict-peer-deps\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to \fBtrue\fR, and \fB--legacy-peer-deps\fR is not set, then \fIany\fR conflicting \fBpeerDependencies\fR will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
.P
By default, conflicting \fBpeerDependencies\fR deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's \fBpeerDependencies\fR object.
.P
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If \fB--strict-peer-deps\fR is set, then this warning is treated as a failure.
.SS "\fBforeground-scripts\fR"
.RS 0
.IP \(bu 4
Default: \fBfalse\fR unless when using \fBnpm pack\fR or \fBnpm publish\fR where it defaults to \fBtrue\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Run all build scripts (ie, \fBpreinstall\fR, \fBinstall\fR, and \fBpostinstall\fR) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
.P
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBaudit\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm help audit for details on what is submitted.
.SS "\fBbin-links\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
Tells npm to create symlinks (or \fB.cmd\fR shims on Windows) for package executables.
.P
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
.SS "\fBfund\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" displays the message at the end of each \fBnpm install\fR acknowledging the number of dependencies looking for funding. See npm help fund for details.
.SS "\fBdry-run\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, \fBinstall\fR, \fBupdate\fR, \fBdedupe\fR, \fBuninstall\fR, as well as \fBpack\fR and \fBpublish\fR.
.P
Note: This is NOT honored by other network related commands, eg \fBdist-tags\fR, \fBowner\fR, etc.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBinstall-links\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help install
.IP \(bu 4
\fBpackage-lock.json\fR \fI\(la/configuring-npm/package-lock-json\(ra\fR
.RE 0
                                                       node-23.7.0/deps/npm/man/man1/npm-completion.1                                                      0000664 0000000 0000000 00000001751 14746647661 0020740 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-COMPLETION" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-completion\fR - Tab Completion for npm
.SS "Synopsis"
.P
.RS 2
.nf
npm completion
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Enables tab-completion in all npm commands.
.P
The synopsis above loads the completions into your current shell. Adding it to your ~/.bashrc or ~/.zshrc will make the completions available everywhere:
.P
.RS 2
.nf
npm completion >> ~/.bashrc
npm completion >> ~/.zshrc
.fi
.RE
.P
You may of course also pipe the output of \fBnpm completion\fR to a file such as \fB/usr/local/etc/bash_completion.d/npm\fR or \fB/etc/bash_completion.d/npm\fR if you have a system that will read that file for you.
.P
When \fBCOMP_CWORD\fR, \fBCOMP_LINE\fR, and \fBCOMP_POINT\fR are defined in the environment, \fBnpm completion\fR acts in "plumbing mode", and outputs completions based on the arguments.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help developers
.IP \(bu 4
npm help npm
.RE 0
                       node-23.7.0/deps/npm/man/man1/npm-config.1                                                          0000664 0000000 0000000 00000011040 14746647661 0020024 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-CONFIG" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-config\fR - Manage the npm configuration files
.SS "Synopsis"
.P
.RS 2
.nf
npm config set <key>=<value> \[lB]<key>=<value> ...\[rB]
npm config get \[lB]<key> \[lB]<key> ...\[rB]\[rB]
npm config delete <key> \[lB]<key> ...\[rB]
npm config list \[lB]--json\[rB]
npm config edit
npm config fix

alias: c
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
npm gets its config settings from the command line, environment variables, \fBnpmrc\fR files, and in some cases, the \fBpackage.json\fR file.
.P
See npm help npmrc for more information about the npmrc files.
.P
See npm help config for a more thorough explanation of the mechanisms involved, and a full list of config options available.
.P
The \fBnpm config\fR command can be used to update and edit the contents of the user and global npmrc files.
.SS "Sub-commands"
.P
Config supports the following sub-commands:
.SS "set"
.P
.RS 2
.nf
npm config set key=value \[lB]key=value...\[rB]
npm set key=value \[lB]key=value...\[rB]
.fi
.RE
.P
Sets each of the config keys to the value provided. Modifies the user configuration file unless \fB\fBlocation\fR\fR \fI\(la/commands/npm-config#location\(ra\fR is passed.
.P
If value is omitted, the key will be removed from your config file entirely.
.P
Note: for backwards compatibility, \fBnpm config set key value\fR is supported as an alias for \fBnpm config set key=value\fR.
.SS "get"
.P
.RS 2
.nf
npm config get \[lB]key ...\[rB]
npm get \[lB]key ...\[rB]
.fi
.RE
.P
Echo the config value(s) to stdout.
.P
If multiple keys are provided, then the values will be prefixed with the key names.
.P
If no keys are provided, then this command behaves the same as \fBnpm config
list\fR.
.SS "list"
.P
.RS 2
.nf
npm config list
.fi
.RE
.P
Show all the config settings. Use \fB-l\fR to also show defaults. Use \fB--json\fR to show the settings in json format.
.SS "delete"
.P
.RS 2
.nf
npm config delete key \[lB]key ...\[rB]
.fi
.RE
.P
Deletes the specified keys from all configuration files.
.SS "edit"
.P
.RS 2
.nf
npm config edit
.fi
.RE
.P
Opens the config file in an editor. Use the \fB--global\fR flag to edit the global config.
.SS "fix"
.P
.RS 2
.nf
npm config fix
.fi
.RE
.P
Attempts to repair invalid configuration items. Usually this means attaching authentication config (i.e. \fB_auth\fR, \fB_authToken\fR) to the configured \fBregistry\fR.
.SS "Configuration"
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBglobal\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Operates in "global" mode, so that packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "\fBeditor\fR"
.RS 0
.IP \(bu 4
Default: The EDITOR or VISUAL environment variables, or '%SYSTEMROOT%\[rs]notepad.exe' on Windows, or 'vi' on Unix systems
.IP \(bu 4
Type: String
.RE 0

.P
The command to run for \fBnpm edit\fR and \fBnpm config edit\fR.
.SS "\fBlocation\fR"
.RS 0
.IP \(bu 4
Default: "user" unless \fB--global\fR is passed, which will also set this value to "global"
.IP \(bu 4
Type: "global", "user", or "project"
.RE 0

.P
When passed to \fBnpm config\fR this refers to which config file to use.
.P
When set to "global" mode, packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "\fBlong\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Show extended information in \fBls\fR, \fBsearch\fR, and \fBhelp-search\fR.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help config
.IP \(bu 4
\fBpackage.json\fR \fI\(la/configuring-npm/package-json\(ra\fR
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help npm
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/npm/man/man1/npm-dedupe.1                                                          0000664 0000000 0000000 00000023212 14746647661 0020031 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-DEDUPE" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-dedupe\fR - Reduce duplication in the package tree
.SS "Synopsis"
.P
.RS 2
.nf
npm dedupe

alias: ddp
.fi
.RE
.SS "Description"
.P
Searches the local package tree and attempts to simplify the overall structure by moving dependencies further up the tree, where they can be more effectively shared by multiple dependent packages.
.P
For example, consider this dependency graph:
.P
.RS 2
.nf
a
+-- b <-- depends on c@1.0.x
|   `-- c@1.0.3
`-- d <-- depends on c@~1.0.9
    `-- c@1.0.10
.fi
.RE
.P
In this case, \fBnpm dedupe\fR will transform the tree to:
.P
.RS 2
.nf
a
+-- b
+-- d
`-- c@1.0.10
.fi
.RE
.P
Because of the hierarchical nature of node's module lookup, b and d will both get their dependency met by the single c package at the root level of the tree.
.P
In some cases, you may have a dependency graph like this:
.P
.RS 2
.nf
a
+-- b <-- depends on c@1.0.x
+-- c@1.0.3
`-- d <-- depends on c@1.x
    `-- c@1.9.9
.fi
.RE
.P
During the installation process, the \fBc@1.0.3\fR dependency for \fBb\fR was placed in the root of the tree. Though \fBd\fR's dependency on \fBc@1.x\fR could have been satisfied by \fBc@1.0.3\fR, the newer \fBc@1.9.0\fR dependency was used, because npm favors updates by default, even when doing so causes duplication.
.P
Running \fBnpm dedupe\fR will cause npm to note the duplication and re-evaluate, deleting the nested \fBc\fR module, because the one in the root is sufficient.
.P
To prefer deduplication over novelty during the installation process, run \fBnpm install --prefer-dedupe\fR or \fBnpm config set prefer-dedupe true\fR.
.P
Arguments are ignored. Dedupe always acts on the entire tree.
.P
Note that this operation transforms the dependency tree, but will never result in new modules being installed.
.P
Using \fBnpm find-dupes\fR will run the command in \fB--dry-run\fR mode.
.P
Note: \fBnpm dedupe\fR will never update the semver values of direct dependencies in your project \fBpackage.json\fR, if you want to update values in \fBpackage.json\fR you can run: \fBnpm update --save\fR instead.
.SS "Configuration"
.SS "\fBinstall-strategy\fR"
.RS 0
.IP \(bu 4
Default: "hoisted"
.IP \(bu 4
Type: "hoisted", "nested", "shallow", or "linked"
.RE 0

.P
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
.SS "\fBlegacy-bundling\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=nested\fR
.RE 0

.P
Instead of hoisting package installs in \fBnode_modules\fR, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets \fB--install-strategy=nested\fR.
.SS "\fBglobal-style\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=shallow\fR
.RE 0

.P
Only install direct dependencies in the top level \fBnode_modules\fR, but hoist on deeper dependencies. Sets \fB--install-strategy=shallow\fR.
.SS "\fBstrict-peer-deps\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to \fBtrue\fR, and \fB--legacy-peer-deps\fR is not set, then \fIany\fR conflicting \fBpeerDependencies\fR will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
.P
By default, conflicting \fBpeerDependencies\fR deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's \fBpeerDependencies\fR object.
.P
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If \fB--strict-peer-deps\fR is set, then this warning is treated as a failure.
.SS "\fBpackage-lock\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to false, then ignore \fBpackage-lock.json\fR files when installing. This will also prevent \fIwriting\fR \fBpackage-lock.json\fR if \fBsave\fR is true.
.SS "\fBomit\fR"
.RS 0
.IP \(bu 4
Default: 'dev' if the \fBNODE_ENV\fR environment variable is set to 'production', otherwise empty.
.IP \(bu 4
Type: "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Dependency types to omit from the installation tree on disk.
.P
Note that these dependencies \fIare\fR still resolved and added to the \fBpackage-lock.json\fR or \fBnpm-shrinkwrap.json\fR file. They are just not physically installed on disk.
.P
If a package type appears in both the \fB--include\fR and \fB--omit\fR lists, then it will be included.
.P
If the resulting omit list includes \fB'dev'\fR, then the \fBNODE_ENV\fR environment variable will be set to \fB'production'\fR for all lifecycle scripts.
.SS "\fBinclude\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: "prod", "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Option that allows for defining which types of dependencies to install.
.P
This is the inverse of \fB--omit=<type>\fR.
.P
Dependency types specified in \fB--include\fR will not be omitted, regardless of the order in which omit/include are specified on the command-line.
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBaudit\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm help audit for details on what is submitted.
.SS "\fBbin-links\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
Tells npm to create symlinks (or \fB.cmd\fR shims on Windows) for package executables.
.P
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
.SS "\fBfund\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" displays the message at the end of each \fBnpm install\fR acknowledging the number of dependencies looking for funding. See npm help fund for details.
.SS "\fBdry-run\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, \fBinstall\fR, \fBupdate\fR, \fBdedupe\fR, \fBuninstall\fR, as well as \fBpack\fR and \fBpublish\fR.
.P
Note: This is NOT honored by other network related commands, eg \fBdist-tags\fR, \fBowner\fR, etc.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBinstall-links\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help find-dupes
.IP \(bu 4
npm help ls
.IP \(bu 4
npm help update
.IP \(bu 4
npm help install
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/npm/man/man1/npm-deprecate.1                                                       0000664 0000000 0000000 00000003550 14746647661 0020522 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-DEPRECATE" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-deprecate\fR - Deprecate a version of a package
.SS "Synopsis"
.P
.RS 2
.nf
npm deprecate <package-spec> <message>
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
This command will update the npm registry entry for a package, providing a deprecation warning to all who attempt to install it.
.P
It works on \fBversion ranges\fR \fI\(lahttps://semver.npmjs.com/\(ra\fR as well as specific versions, so you can do something like this:
.P
.RS 2
.nf
npm deprecate my-thing@"< 0.2.3" "critical bug fixed in v0.2.3"
.fi
.RE
.P
SemVer ranges passed to this command are interpreted such that they \fIdo\fR include prerelease versions. For example:
.P
.RS 2
.nf
npm deprecate my-thing@1.x "1.x is no longer supported"
.fi
.RE
.P
In this case, a version \fBmy-thing@1.0.0-beta.0\fR will also be deprecated.
.P
You must be the package owner to deprecate something. See the \fBowner\fR and \fBadduser\fR help topics.
.P
To un-deprecate a package, specify an empty string (\fB""\fR) for the \fBmessage\fR argument. Note that you must use double quotes with no space between them to format an empty string.
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBotp\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with \fBnpm access\fR.
.P
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help publish
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help owner
.IP \(bu 4
npm help adduser
.RE 0
                                                                                                                                                        node-23.7.0/deps/npm/man/man1/npm-diff.1                                                            0000664 0000000 0000000 00000023057 14746647661 0017502 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-DIFF" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-diff\fR - The registry diff command
.SS "Synopsis"
.P
.RS 2
.nf
npm diff \[lB]...<paths>\[rB]
.fi
.RE
.SS "Description"
.P
Similar to its \fBgit diff\fR counterpart, this command will print diff patches of files for packages published to the npm registry.
.RS 0
.IP \(bu 4
\fBnpm diff --diff=<spec-a> --diff=<spec-b>\fR
.P
Compares two package versions using their registry specifiers, e.g: \fBnpm diff --diff=pkg@1.0.0 --diff=pkg@^2.0.0\fR. It's also possible to compare across forks of any package, e.g: \fBnpm diff --diff=pkg@1.0.0 --diff=pkg-fork@1.0.0\fR.
.P
Any valid spec can be used, so that it's also possible to compare directories or git repositories, e.g: \fBnpm diff --diff=pkg@latest --diff=./packages/pkg\fR
.P
Here's an example comparing two different versions of a package named \fBabbrev\fR from the registry:
.P
.RS 2
.nf
npm diff --diff=abbrev@1.1.0 --diff=abbrev@1.1.1
.fi
.RE
.P
On success, output looks like:
.P
.RS 2
.nf
diff --git a/package.json b/package.json
index v1.1.0..v1.1.1 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "abbrev",
-  "version": "1.1.0",
+  "version": "1.1.1",
   "description": "Like ruby's abbrev module, but in js",
   "author": "Isaac Z. Schlueter <i@izs.me>",
   "main": "abbrev.js",
.fi
.RE
.P
Given the flexible nature of npm specs, you can also target local directories or git repos just like when using \fBnpm install\fR:
.P
.RS 2
.nf
npm diff --diff=https://github.com/npm/libnpmdiff --diff=./local-path
.fi
.RE
.P
In the example above we can compare the contents from the package installed from the git repo at \fBgithub.com/npm/libnpmdiff\fR with the contents of the \fB./local-path\fR that contains a valid package, such as a modified copy of the original.
.IP \(bu 4
\fBnpm diff\fR (in a package directory, no arguments):
.P
If the package is published to the registry, \fBnpm diff\fR will fetch the tarball version tagged as \fBlatest\fR (this value can be configured using the \fBtag\fR option) and proceed to compare the contents of files present in that tarball, with the current files in your local file system.
.P
This workflow provides a handy way for package authors to see what package-tracked files have been changed in comparison with the latest published version of that package.
.IP \(bu 4
\fBnpm diff --diff=<pkg-name>\fR (in a package directory):
.P
When using a single package name (with no version or tag specifier) as an argument, \fBnpm diff\fR will work in a similar way to \fB\fBnpm-outdated\fR\fR \fI\(lanpm-outdated\(ra\fR and reach for the registry to figure out what current published version of the package named \fB<pkg-name>\fR will satisfy its dependent declared semver-range. Once that specific version is known \fBnpm diff\fR will print diff patches comparing the current version of \fB<pkg-name>\fR found in the local file system with that specific version returned by the registry.
.P
Given a package named \fBabbrev\fR that is currently installed:
.P
.RS 2
.nf
npm diff --diff=abbrev
.fi
.RE
.P
That will request from the registry its most up to date version and will print a diff output comparing the currently installed version to this newer one if the version numbers are not the same.
.IP \(bu 4
\fBnpm diff --diff=<spec-a>\fR (in a package directory):
.P
Similar to using only a single package name, it's also possible to declare a full registry specifier version if you wish to compare the local version of an installed package with the specific version/tag/semver-range provided in \fB<spec-a>\fR.
.P
An example: assuming \fBpkg@1.0.0\fR is installed in the current \fBnode_modules\fR folder, running:
.P
.RS 2
.nf
npm diff --diff=pkg@2.0.0
.fi
.RE
.P
It will effectively be an alias to \fBnpm diff --diff=pkg@1.0.0 --diff=pkg@2.0.0\fR.
.IP \(bu 4
\fBnpm diff --diff=<semver-a> \[lB]--diff=<semver-b>\[rB]\fR (in a package directory):
.P
Using \fBnpm diff\fR along with semver-valid version numbers is a shorthand to compare different versions of the current package.
.P
It needs to be run from a package directory, such that for a package named \fBpkg\fR running \fBnpm diff --diff=1.0.0 --diff=1.0.1\fR is the same as running \fBnpm diff --diff=pkg@1.0.0 --diff=pkg@1.0.1\fR.
.P
If only a single argument \fB<version-a>\fR is provided, then the current local file system is going to be compared against that version.
.P
Here's an example comparing two specific versions (published to the configured registry) of the current project directory:
.P
.RS 2
.nf
npm diff --diff=1.0.0 --diff=1.1.0
.fi
.RE
.RE 0

.P
Note that tag names are not valid \fB--diff\fR argument values, if you wish to compare to a published tag, you must use the \fBpkg@tagname\fR syntax.
.SS "Filtering files"
.P
It's possible to also specify positional arguments using file names or globs pattern matching in order to limit the result of diff patches to only a subset of files for a given package, e.g:
.P
.RS 2
.nf
npm diff --diff=pkg@2 ./lib/ CHANGELOG.md
.fi
.RE
.P
In the example above the diff output is only going to print contents of files located within the folder \fB./lib/\fR and changed lines of code within the \fBCHANGELOG.md\fR file.
.SS "Configuration"
.SS "\fBdiff\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Define arguments to compare in \fBnpm diff\fR.
.SS "\fBdiff-name-only\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Prints only filenames when using \fBnpm diff\fR.
.SS "\fBdiff-unified\fR"
.RS 0
.IP \(bu 4
Default: 3
.IP \(bu 4
Type: Number
.RE 0

.P
The number of lines of context to print in \fBnpm diff\fR.
.SS "\fBdiff-ignore-all-space\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Ignore whitespace when comparing lines in \fBnpm diff\fR.
.SS "\fBdiff-no-prefix\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Do not show any source or destination prefix in \fBnpm diff\fR output.
.P
Note: this causes \fBnpm diff\fR to ignore the \fB--diff-src-prefix\fR and \fB--diff-dst-prefix\fR configs.
.SS "\fBdiff-src-prefix\fR"
.RS 0
.IP \(bu 4
Default: "a/"
.IP \(bu 4
Type: String
.RE 0

.P
Source prefix to be used in \fBnpm diff\fR output.
.SS "\fBdiff-dst-prefix\fR"
.RS 0
.IP \(bu 4
Default: "b/"
.IP \(bu 4
Type: String
.RE 0

.P
Destination prefix to be used in \fBnpm diff\fR output.
.SS "\fBdiff-text\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Treat all files as text in \fBnpm diff\fR.
.SS "\fBglobal\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Operates in "global" mode, so that packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "\fBtag\fR"
.RS 0
.IP \(bu 4
Default: "latest"
.IP \(bu 4
Type: String
.RE 0

.P
If you ask npm to install a package and don't tell it a specific version, then it will install the specified tag.
.P
It is the tag added to the package@version specified in the \fBnpm dist-tag
add\fR command, if no explicit tag is given.
.P
When used by the \fBnpm diff\fR command, this is the tag used to fetch the tarball that will be compared with the local files by default.
.P
If used in the \fBnpm publish\fR command, this is the tag that will be added to the package submitted to the registry.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SH "SEE ALSO"
.RS 0
.IP \(bu 4
npm help outdated
.IP \(bu 4
npm help install
.IP \(bu 4
npm help config
.IP \(bu 4
npm help registry
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/npm/man/man1/npm-dist-tag.1                                                        0000664 0000000 0000000 00000013010 14746647661 0020272 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-DIST-TAG" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-dist-tag\fR - Modify package distribution tags
.SS "Synopsis"
.P
.RS 2
.nf
npm dist-tag add <package-spec (with version)> \[lB]<tag>\[rB]
npm dist-tag rm <package-spec> <tag>
npm dist-tag ls \[lB]<package-spec>\[rB]

alias: dist-tags
.fi
.RE
.SS "Description"
.P
Add, remove, and enumerate distribution tags on a package:
.RS 0
.IP \(bu 4
add: Tags the specified version of the package with the specified tag, or the \fB\fB--tag\fR config\fR \fI\(la/using-npm/config#tag\(ra\fR if not specified. If you have two-factor authentication on auth-and-writes then you\[cq]ll need to include a one-time password on the command line with \fB--otp <one-time password>\fR, or go through a second factor flow based on your \fBauthtype\fR.
.IP \(bu 4
rm: Clear a tag that is no longer in use from the package. If you have two-factor authentication on auth-and-writes then you\[cq]ll need to include a one-time password on the command line with \fB--otp <one-time password>\fR, or go through a second factor flow based on your \fBauthtype\fR
.IP \(bu 4
ls: Show all of the dist-tags for a package, defaulting to the package in the current prefix. This is the default action if none is specified.
.RE 0

.P
A tag can be used when installing packages as a reference to a version instead of using a specific version number:
.P
.RS 2
.nf
npm install <name>@<tag>
.fi
.RE
.P
When installing dependencies, a preferred tagged version may be specified:
.P
.RS 2
.nf
npm install --tag <tag>
.fi
.RE
.P
(This also applies to any other commands that resolve and install dependencies, such as \fBnpm dedupe\fR, \fBnpm update\fR, and \fBnpm audit fix\fR.)
.P
Publishing a package sets the \fBlatest\fR tag to the published version unless the \fB--tag\fR option is used. For example, \fBnpm publish --tag=beta\fR.
.P
By default, \fBnpm install <pkg>\fR (without any \fB@<version>\fR or \fB@<tag>\fR specifier) installs the \fBlatest\fR tag.
.SS "Purpose"
.P
Tags can be used to provide an alias instead of version numbers.
.P
For example, a project might choose to have multiple streams of development and use a different tag for each stream, e.g., \fBstable\fR, \fBbeta\fR, \fBdev\fR, \fBcanary\fR.
.P
By default, the \fBlatest\fR tag is used by npm to identify the current version of a package, and \fBnpm install <pkg>\fR (without any \fB@<version>\fR or \fB@<tag>\fR specifier) installs the \fBlatest\fR tag. Typically, projects only use the \fBlatest\fR tag for stable release versions, and use other tags for unstable versions such as prereleases.
.P
The \fBnext\fR tag is used by some projects to identify the upcoming version.
.P
Other than \fBlatest\fR, no tag has any special significance to npm itself.
.SS "Caveats"
.P
This command used to be known as \fBnpm tag\fR, which only created new tags, and so had a different syntax.
.P
Tags must share a namespace with version numbers, because they are specified in the same slot: \fBnpm install <pkg>@<version>\fR vs \fBnpm install <pkg>@<tag>\fR.
.P
Tags that can be interpreted as valid semver ranges will be rejected. For example, \fBv1.4\fR cannot be used as a tag, because it is interpreted by semver as \fB>=1.4.0 <1.5.0\fR. See \fI\(lahttps://github.com/npm/npm/issues/6082\(ra\fR.
.P
The simplest way to avoid semver problems with tags is to use tags that do not begin with a number or the letter \fBv\fR.
.SS "Configuration"
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help publish
.IP \(bu 4
npm help install
.IP \(bu 4
npm help dedupe
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/npm/man/man1/npm-docs.1                                                            0000664 0000000 0000000 00000006445 14746647661 0017524 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-DOCS" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-docs\fR - Open documentation for a package in a web browser
.SS "Synopsis"
.P
.RS 2
.nf
npm docs \[lB]<pkgname> \[lB]<pkgname> ...\[rB]\[rB]

alias: home
.fi
.RE
.SS "Description"
.P
This command tries to guess at the likely location of a package's documentation URL, and then tries to open it using the \fB\fB--browser\fR config\fR \fI\(la/using-npm/config#browser\(ra\fR param. You can pass multiple package names at once. If no package name is provided, it will search for a \fBpackage.json\fR in the current folder and use the \fBname\fR property.
.SS "Configuration"
.SS "\fBbrowser\fR"
.RS 0
.IP \(bu 4
Default: OS X: \fB"open"\fR, Windows: \fB"start"\fR, Others: \fB"xdg-open"\fR
.IP \(bu 4
Type: null, Boolean, or String
.RE 0

.P
The browser that is called by npm commands to open websites.
.P
Set to \fBfalse\fR to suppress browser behavior and instead print urls to terminal.
.P
Set to \fBtrue\fR to use default system URL opener.
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help view
.IP \(bu 4
npm help publish
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
\fBpackage.json\fR \fI\(la/configuring-npm/package-json\(ra\fR
.RE 0
                                                                                                                                                                                                                           node-23.7.0/deps/npm/man/man1/npm-doctor.1                                                          0000664 0000000 0000000 00000012400 14746647661 0020052 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-DOCTOR" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-doctor\fR - Check the health of your npm environment
.SS "Synopsis"
.P
.RS 2
.nf
npm doctor \[lB]connection\[rB] \[lB]registry\[rB] \[lB]versions\[rB] \[lB]environment\[rB] \[lB]permissions\[rB] \[lB]cache\[rB]
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
\fBnpm doctor\fR runs a set of checks to ensure that your npm installation has what it needs to manage your JavaScript packages. npm is mostly a standalone tool, but it does have some basic requirements that must be met:
.RS 0
.IP \(bu 4
Node.js and git must be executable by npm.
.IP \(bu 4
The primary npm registry, \fBregistry.npmjs.com\fR, or another service that uses the registry API, is available.
.IP \(bu 4
The directories that npm uses, \fBnode_modules\fR (both locally and globally), exist and can be written by the current user.
.IP \(bu 4
The npm cache exists, and the package tarballs within it aren't corrupt.
.RE 0

.P
Without all of these working properly, npm may not work properly. Many issues are often attributable to things that are outside npm's code base, so \fBnpm doctor\fR confirms that the npm installation is in a good state.
.P
Also, in addition to this, there are also very many issue reports due to using old versions of npm. Since npm is constantly improving, running \fBnpm@latest\fR is better than an old version.
.P
\fBnpm doctor\fR verifies the following items in your environment, and if there are any recommended changes, it will display them. By default npm runs all of these checks. You can limit what checks are ran by specifying them as extra arguments.
.SS "\fBConnecting to the registry\fR"
.P
By default, npm installs from the primary npm registry, \fBregistry.npmjs.org\fR. \fBnpm doctor\fR hits a special connection testing endpoint within the registry. This can also be checked with \fBnpm ping\fR. If this check fails, you may be using a proxy that needs to be configured, or may need to talk to your IT staff to get access over HTTPS to \fBregistry.npmjs.org\fR.
.P
This check is done against whichever registry you've configured (you can see what that is by running \fBnpm config get registry\fR), and if you're using a private registry that doesn't support the \fB/whoami\fR endpoint supported by the primary registry, this check may fail.
.SS "\fBChecking npm version\fR"
.P
While Node.js may come bundled with a particular version of npm, it's the policy of the CLI team that we recommend all users run \fBnpm@latest\fR if they can. As the CLI is maintained by a small team of contributors, there are only resources for a single line of development, so npm's own long-term support releases typically only receive critical security and regression fixes. The team believes that the latest tested version of npm is almost always likely to be the most functional and defect-free version of npm.
.SS "\fBChecking node version\fR"
.P
For most users, in most circumstances, the best version of Node will be the latest long-term support (LTS) release. Those of you who want access to new ECMAscript features or bleeding-edge changes to Node's standard library may be running a newer version, and some may be required to run an older version of Node because of enterprise change control policies. That's OK! But in general, the npm team recommends that most users run Node.js LTS.
.SS "\fBChecking configured npm registry\fR"
.P
You may be installing from private package registries for your project or company. That's great! Others may be following tutorials or StackOverflow questions in an effort to troubleshoot problems you may be having. Sometimes, this may entail changing the registry you're pointing at. This part of \fBnpm doctor\fR just lets you, and maybe whoever's helping you with support, know that you're not using the default registry.
.SS "\fBChecking for git executable in PATH\fR"
.P
While it's documented in the README, it may not be obvious that npm needs Git installed to do many of the things that it does. Also, in some cases \[en] especially on Windows \[en] you may have Git set up in such a way that it's not accessible via your \fBPATH\fR so that npm can find it. This check ensures that Git is available.
.SS "Permissions checks"
.RS 0
.IP \(bu 4
Your cache must be readable and writable by the user running npm.
.IP \(bu 4
Global package binaries must be writable by the user running npm.
.IP \(bu 4
Your local \fBnode_modules\fR path, if you're running \fBnpm doctor\fR with a project directory, must be readable and writable by the user running npm.
.RE 0

.SS "Validate the checksums of cached packages"
.P
When an npm package is published, the publishing process generates a checksum that npm uses at install time to verify that the package didn't get corrupted in transit. \fBnpm doctor\fR uses these checksums to validate the package tarballs in your local cache (you can see where that cache is located with \fBnpm config get cache\fR). In the event that there are corrupt packages in your cache, you should probably run \fBnpm cache clean -f\fR and reset the cache.
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help bugs
.IP \(bu 4
npm help help
.IP \(bu 4
npm help ping
.RE 0
                                                                                                                                                                                                                                                                node-23.7.0/deps/npm/man/man1/npm-edit.1                                                            0000664 0000000 0000000 00000002240 14746647661 0017506 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-EDIT" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-edit\fR - Edit an installed package
.SS "Synopsis"
.P
.RS 2
.nf
npm edit <pkg>\[lB]/<subpkg>...\[rB]
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Selects a dependency in the current project and opens the package folder in the default editor (or whatever you've configured as the npm \fBeditor\fR config -- see \fB\fBnpm-config\fR\fR \fI\(lanpm-config\(ra\fR.)
.P
After it has been edited, the package is rebuilt so as to pick up any changes in compiled packages.
.P
For instance, you can do \fBnpm install connect\fR to install connect into your package, and then \fBnpm edit connect\fR to make a few changes to your locally installed copy.
.SS "Configuration"
.SS "\fBeditor\fR"
.RS 0
.IP \(bu 4
Default: The EDITOR or VISUAL environment variables, or '%SYSTEMROOT%\[rs]notepad.exe' on Windows, or 'vi' on Unix systems
.IP \(bu 4
Type: String
.RE 0

.P
The command to run for \fBnpm edit\fR and \fBnpm config edit\fR.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help explore
.IP \(bu 4
npm help install
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.RE 0
                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/npm/man/man1/npm-exec.1                                                            0000664 0000000 0000000 00000030317 14746647661 0017513 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-EXEC" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-exec\fR - Run a command from a local or remote npm package
.SS "Synopsis"
.P
.RS 2
.nf
npm exec -- <pkg>\[lB]@<version>\[rB] \[lB]args...\[rB]
npm exec --package=<pkg>\[lB]@<version>\[rB] -- <cmd> \[lB]args...\[rB]
npm exec -c '<cmd> \[lB]args...\[rB]'
npm exec --package=foo -c '<cmd> \[lB]args...\[rB]'

alias: x
.fi
.RE
.SS "Description"
.P
This command allows you to run an arbitrary command from an npm package (either one installed locally, or fetched remotely), in a similar context as running it via \fBnpm run\fR.
.P
Run without positional arguments or \fB--call\fR, this allows you to interactively run commands in the same sort of shell environment that \fBpackage.json\fR scripts are run. Interactive mode is not supported in CI environments when standard input is a TTY, to prevent hangs.
.P
Whatever packages are specified by the \fB--package\fR option will be provided in the \fBPATH\fR of the executed command, along with any locally installed package executables. The \fB--package\fR option may be specified multiple times, to execute the supplied command in an environment where all specified packages are available.
.P
If any requested packages are not present in the local project dependencies, then a prompt is printed, which can be suppressed by providing either \fB--yes\fR or \fB--no\fR. When standard input is not a TTY or a CI environment is detected, \fB--yes\fR is assumed. The requested packages are installed to a folder in the npm cache, which is added to the \fBPATH\fR environment variable in the executed process.
.P
Package names provided without a specifier will be matched with whatever version exists in the local project. Package names with a specifier will only be considered a match if they have the exact same name and version as the local dependency.
.P
If no \fB-c\fR or \fB--call\fR option is provided, then the positional arguments are used to generate the command string. If no \fB--package\fR options are provided, then npm will attempt to determine the executable name from the package specifier provided as the first positional argument according to the following heuristic:
.RS 0
.IP \(bu 4
If the package has a single entry in its \fBbin\fR field in \fBpackage.json\fR, or if all entries are aliases of the same command, then that command will be used.
.IP \(bu 4
If the package has multiple \fBbin\fR entries, and one of them matches the unscoped portion of the \fBname\fR field, then that command will be used.
.IP \(bu 4
If this does not result in exactly one option (either because there are no bin entries, or none of them match the \fBname\fR of the package), then \fBnpm exec\fR exits with an error.
.RE 0

.P
To run a binary \fIother than\fR the named binary, specify one or more \fB--package\fR options, which will prevent npm from inferring the package from the first command argument.
.SS "\fBnpx\fR vs \fBnpm exec\fR"
.P
When run via the \fBnpx\fR binary, all flags and options \fImust\fR be set prior to any positional arguments. When run via \fBnpm exec\fR, a double-hyphen \fB--\fR flag can be used to suppress npm's parsing of switches and options that should be sent to the executed command.
.P
For example:
.P
.RS 2
.nf
$ npx foo@latest bar --package=@npmcli/foo
.fi
.RE
.P
In this case, npm will resolve the \fBfoo\fR package name, and run the following command:
.P
.RS 2
.nf
$ foo bar --package=@npmcli/foo
.fi
.RE
.P
Since the \fB--package\fR option comes \fIafter\fR the positional arguments, it is treated as an argument to the executed command.
.P
In contrast, due to npm's argument parsing logic, running this command is different:
.P
.RS 2
.nf
$ npm exec foo@latest bar --package=@npmcli/foo
.fi
.RE
.P
In this case, npm will parse the \fB--package\fR option first, resolving the \fB@npmcli/foo\fR package. Then, it will execute the following command in that context:
.P
.RS 2
.nf
$ foo@latest bar
.fi
.RE
.P
The double-hyphen character is recommended to explicitly tell npm to stop parsing command line options and switches. The following command would thus be equivalent to the \fBnpx\fR command above:
.P
.RS 2
.nf
$ npm exec -- foo@latest bar --package=@npmcli/foo
.fi
.RE
.SS "Configuration"
.SS "\fBpackage\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
The package or packages to install for npm help exec
.SS "\fBcall\fR"
.RS 0
.IP \(bu 4
Default: ""
.IP \(bu 4
Type: String
.RE 0

.P
Optional companion option for \fBnpm exec\fR, \fBnpx\fR that allows for specifying a custom command to be run along with the installed packages.
.P
.RS 2
.nf
npm exec --package yo --package generator-node --call "yo node"
.fi
.RE
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "Examples"
.P
Run the version of \fBtap\fR in the local dependencies, with the provided arguments:
.P
.RS 2
.nf
$ npm exec -- tap --bail test/foo.js
$ npx tap --bail test/foo.js
.fi
.RE
.P
Run a command \fIother than\fR the command whose name matches the package name by specifying a \fB--package\fR option:
.P
.RS 2
.nf
$ npm exec --package=foo -- bar --bar-argument
# ~ or ~
$ npx --package=foo bar --bar-argument
.fi
.RE
.P
Run an arbitrary shell script, in the context of the current project:
.P
.RS 2
.nf
$ npm x -c 'eslint && say "hooray, lint passed"'
$ npx -c 'eslint && say "hooray, lint passed"'
.fi
.RE
.SS "Workspaces support"
.P
You may use the \fB\fBworkspace\fR\fR \fI\(la/using-npm/config#workspace\(ra\fR or \fB\fBworkspaces\fR\fR \fI\(la/using-npm/config#workspaces\(ra\fR configs in order to run an arbitrary command from an npm package (either one installed locally, or fetched remotely) in the context of the specified workspaces. If no positional argument or \fB--call\fR option is provided, it will open an interactive subshell in the context of each of these configured workspaces one at a time.
.P
Given a project with configured workspaces, e.g:
.P
.RS 2
.nf
.
+-- package.json
`-- packages
   +-- a
   |   `-- package.json
   +-- b
   |   `-- package.json
   `-- c
       `-- package.json
.fi
.RE
.P
Assuming the workspace configuration is properly set up at the root level \fBpackage.json\fR file. e.g:
.P
.RS 2
.nf
{
    "workspaces": \[lB] "./packages/*" \[rB]
}
.fi
.RE
.P
You can execute an arbitrary command from a package in the context of each of the configured workspaces when using the \fB\fBworkspaces\fR config options\fR \fI\(la/using-npm/config#workspace\(ra\fR, in this example we're using \fBeslint\fR to lint any js file found within each workspace folder:
.P
.RS 2
.nf
npm exec --ws -- eslint ./*.js
.fi
.RE
.SS "Filtering workspaces"
.P
It's also possible to execute a command in a single workspace using the \fBworkspace\fR config along with a name or directory path:
.P
.RS 2
.nf
npm exec --workspace=a -- eslint ./*.js
.fi
.RE
.P
The \fBworkspace\fR config can also be specified multiple times in order to run a specific script in the context of multiple workspaces. When defining values for the \fBworkspace\fR config in the command line, it also possible to use \fB-w\fR as a shorthand, e.g:
.P
.RS 2
.nf
npm exec -w a -w b -- eslint ./*.js
.fi
.RE
.P
This last command will run the \fBeslint\fR command in both \fB./packages/a\fR and \fB./packages/b\fR folders.
.SS "Compatibility with Older npx Versions"
.P
The \fBnpx\fR binary was rewritten in npm v7.0.0, and the standalone \fBnpx\fR package deprecated at that time. \fBnpx\fR uses the \fBnpm exec\fR command instead of a separate argument parser and install process, with some affordances to maintain backwards compatibility with the arguments it accepted in previous versions.
.P
This resulted in some shifts in its functionality:
.RS 0
.IP \(bu 4
Any \fBnpm\fR config value may be provided.
.IP \(bu 4
To prevent security and user-experience problems from mistyping package names, \fBnpx\fR prompts before installing anything. Suppress this prompt with the \fB-y\fR or \fB--yes\fR option.
.IP \(bu 4
The \fB--no-install\fR option is deprecated, and will be converted to \fB--no\fR.
.IP \(bu 4
Shell fallback functionality is removed, as it is not advisable.
.IP \(bu 4
The \fB-p\fR argument is a shorthand for \fB--parseable\fR in npm, but shorthand for \fB--package\fR in npx. This is maintained, but only for the \fBnpx\fR executable.
.IP \(bu 4
The \fB--ignore-existing\fR option is removed. Locally installed bins are always present in the executed process \fBPATH\fR.
.IP \(bu 4
The \fB--npm\fR option is removed. \fBnpx\fR will always use the \fBnpm\fR it ships with.
.IP \(bu 4
The \fB--node-arg\fR and \fB-n\fR options are removed.
.IP \(bu 4
The \fB--always-spawn\fR option is redundant, and thus removed.
.IP \(bu 4
The \fB--shell\fR option is replaced with \fB--script-shell\fR, but maintained in the \fBnpx\fR executable for backwards compatibility.
.RE 0

.SS "A note on caching"
.P
The npm cli utilizes its internal package cache when using the package name specified. You can use the following to change how and when the cli uses this cache. See npm help cache for more on how the cache works.
.SS "prefer-online"
.P
Forces staleness checks for packages, making the cli look for updates immediately even if the package is already in the cache.
.SS "prefer-offline"
.P
Bypasses staleness checks for packages. Missing data will still be requested from the server. To force full offline mode, use \fBoffline\fR.
.SS "offline"
.P
Forces full offline mode. Any packages not locally cached will result in an error.
.SS "workspace"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result to selecting all of the nested workspaces)
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "workspaces"
.RS 0
.IP \(bu 4
Alias: \fB--ws\fR
.IP \(bu 4
Type: Boolean
.IP \(bu 4
Default: \fBfalse\fR
.RE 0

.P
Run scripts in the context of all configured workspaces for the current project.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help run-script
.IP \(bu 4
npm help scripts
.IP \(bu 4
npm help test
.IP \(bu 4
npm help start
.IP \(bu 4
npm help restart
.IP \(bu 4
npm help stop
.IP \(bu 4
npm help config
.IP \(bu 4
npm help workspaces
.IP \(bu 4
npm help npx
.RE 0
                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/npm/man/man1/npm-explain.1                                                         0000664 0000000 0000000 00000005575 14746647661 0020237 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-EXPLAIN" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-explain\fR - Explain installed packages
.SS "Synopsis"
.P
.RS 2
.nf
npm explain <package-spec>

alias: why
.fi
.RE
.SS "Description"
.P
This command will print the chain of dependencies causing a given package to be installed in the current project.
.P
If one or more package specs are provided, then only packages matching one of the specifiers will have their relationships explained.
.P
The package spec can also refer to a folder within \fB./node_modules\fR
.P
For example, running \fBnpm explain glob\fR within npm's source tree will show:
.P
.RS 2
.nf
glob@7.1.6
node_modules/glob
  glob@"^7.1.4" from the root project

glob@7.1.1 dev
node_modules/tacks/node_modules/glob
  glob@"^7.0.5" from rimraf@2.6.2
  node_modules/tacks/node_modules/rimraf
    rimraf@"^2.6.2" from tacks@1.3.0
    node_modules/tacks
      dev tacks@"^1.3.0" from the root project
.fi
.RE
.P
To explain just the package residing at a specific folder, pass that as the argument to the command. This can be useful when trying to figure out exactly why a given dependency is being duplicated to satisfy conflicting version requirements within the project.
.P
.RS 2
.nf
$ npm explain node_modules/nyc/node_modules/find-up
find-up@3.0.0 dev
node_modules/nyc/node_modules/find-up
  find-up@"^3.0.0" from nyc@14.1.1
  node_modules/nyc
    nyc@"^14.1.1" from tap@14.10.8
    node_modules/tap
      dev tap@"^14.10.8" from the root project
.fi
.RE
.SS "Configuration"
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help ls
.IP \(bu 4
npm help install
.IP \(bu 4
npm help link
.IP \(bu 4
npm help prune
.IP \(bu 4
npm help outdated
.IP \(bu 4
npm help update
.RE 0
                                                                                                                                   node-23.7.0/deps/npm/man/man1/npm-explore.1                                                         0000664 0000000 0000000 00000002105 14746647661 0020237 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-EXPLORE" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-explore\fR - Browse an installed package
.SS "Synopsis"
.P
.RS 2
.nf
npm explore <pkg> \[lB] -- <command>\[rB]
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Spawn a subshell in the directory of the installed package specified.
.P
If a command is specified, then it is run in the subshell, which then immediately terminates.
.P
This is particularly handy in the case of git submodules in the \fBnode_modules\fR folder:
.P
.RS 2
.nf
npm explore some-dependency -- git pull origin master
.fi
.RE
.P
Note that the package is \fInot\fR automatically rebuilt afterwards, so be sure to use \fBnpm rebuild <pkg>\fR if you make any changes.
.SS "Configuration"
.SS "\fBshell\fR"
.RS 0
.IP \(bu 4
Default: SHELL environment variable, or "bash" on Posix, or "cmd.exe" on Windows
.IP \(bu 4
Type: String
.RE 0

.P
The shell to run for the \fBnpm explore\fR command.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help edit
.IP \(bu 4
npm help rebuild
.IP \(bu 4
npm help install
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/npm/man/man1/npm-find-dupes.1                                                      0000664 0000000 0000000 00000016652 14746647661 0020633 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-FIND-DUPES" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-find-dupes\fR - Find duplication in the package tree
.SS "Synopsis"
.P
.RS 2
.nf
npm find-dupes
.fi
.RE
.SS "Description"
.P
Runs \fBnpm dedupe\fR in \fB--dry-run\fR mode, making npm only output the duplications, without actually changing the package tree.
.SS "Configuration"
.SS "\fBinstall-strategy\fR"
.RS 0
.IP \(bu 4
Default: "hoisted"
.IP \(bu 4
Type: "hoisted", "nested", "shallow", or "linked"
.RE 0

.P
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
.SS "\fBlegacy-bundling\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=nested\fR
.RE 0

.P
Instead of hoisting package installs in \fBnode_modules\fR, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets \fB--install-strategy=nested\fR.
.SS "\fBglobal-style\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=shallow\fR
.RE 0

.P
Only install direct dependencies in the top level \fBnode_modules\fR, but hoist on deeper dependencies. Sets \fB--install-strategy=shallow\fR.
.SS "\fBstrict-peer-deps\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to \fBtrue\fR, and \fB--legacy-peer-deps\fR is not set, then \fIany\fR conflicting \fBpeerDependencies\fR will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
.P
By default, conflicting \fBpeerDependencies\fR deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's \fBpeerDependencies\fR object.
.P
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If \fB--strict-peer-deps\fR is set, then this warning is treated as a failure.
.SS "\fBpackage-lock\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to false, then ignore \fBpackage-lock.json\fR files when installing. This will also prevent \fIwriting\fR \fBpackage-lock.json\fR if \fBsave\fR is true.
.SS "\fBomit\fR"
.RS 0
.IP \(bu 4
Default: 'dev' if the \fBNODE_ENV\fR environment variable is set to 'production', otherwise empty.
.IP \(bu 4
Type: "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Dependency types to omit from the installation tree on disk.
.P
Note that these dependencies \fIare\fR still resolved and added to the \fBpackage-lock.json\fR or \fBnpm-shrinkwrap.json\fR file. They are just not physically installed on disk.
.P
If a package type appears in both the \fB--include\fR and \fB--omit\fR lists, then it will be included.
.P
If the resulting omit list includes \fB'dev'\fR, then the \fBNODE_ENV\fR environment variable will be set to \fB'production'\fR for all lifecycle scripts.
.SS "\fBinclude\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: "prod", "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Option that allows for defining which types of dependencies to install.
.P
This is the inverse of \fB--omit=<type>\fR.
.P
Dependency types specified in \fB--include\fR will not be omitted, regardless of the order in which omit/include are specified on the command-line.
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBaudit\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm help audit for details on what is submitted.
.SS "\fBbin-links\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
Tells npm to create symlinks (or \fB.cmd\fR shims on Windows) for package executables.
.P
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
.SS "\fBfund\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" displays the message at the end of each \fBnpm install\fR acknowledging the number of dependencies looking for funding. See npm help fund for details.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBinstall-links\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help dedupe
.IP \(bu 4
npm help ls
.IP \(bu 4
npm help update
.IP \(bu 4
npm help install
.RE 0
                                                                                      node-23.7.0/deps/npm/man/man1/npm-fund.1                                                            0000664 0000000 0000000 00000007732 14746647661 0017530 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-FUND" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-fund\fR - Retrieve funding information
.SS "Synopsis"
.P
.RS 2
.nf
npm fund \[lB]<package-spec>\[rB]
.fi
.RE
.SS "Description"
.P
This command retrieves information on how to fund the dependencies of a given project. If no package name is provided, it will list all dependencies that are looking for funding in a tree structure, listing the type of funding and the url to visit. If a package name is provided then it tries to open its funding url using the \fB\fB--browser\fR config\fR \fI\(la/using-npm/config#browser\(ra\fR param; if there are multiple funding sources for the package, the user will be instructed to pass the \fB--which\fR option to disambiguate.
.P
The list will avoid duplicated entries and will stack all packages that share the same url as a single entry. Thus, the list does not have the same shape of the output from \fBnpm ls\fR.
.SS "Example"
.SS "Workspaces support"
.P
It's possible to filter the results to only include a single workspace and its dependencies using the \fB\fBworkspace\fR config\fR \fI\(la/using-npm/config#workspace\(ra\fR option.
.SS "Example:"
.P
Here's an example running \fBnpm fund\fR in a project with a configured workspace \fBa\fR:
.P
.RS 2
.nf
$ npm fund
test-workspaces-fund@1.0.0
+-- https://example.com/a
| | `-- a@1.0.0
| `-- https://example.com/maintainer
|     `-- foo@1.0.0
+-- https://example.com/npmcli-funding
|   `-- @npmcli/test-funding
`-- https://example.com/org
    `-- bar@2.0.0
.fi
.RE
.P
And here is an example of the expected result when filtering only by a specific workspace \fBa\fR in the same project:
.P
.RS 2
.nf
$ npm fund -w a
test-workspaces-fund@1.0.0
`-- https://example.com/a
  | `-- a@1.0.0
  `-- https://example.com/maintainer
      `-- foo@2.0.0
.fi
.RE
.SS "Configuration"
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBbrowser\fR"
.RS 0
.IP \(bu 4
Default: OS X: \fB"open"\fR, Windows: \fB"start"\fR, Others: \fB"xdg-open"\fR
.IP \(bu 4
Type: null, Boolean, or String
.RE 0

.P
The browser that is called by npm commands to open websites.
.P
Set to \fBfalse\fR to suppress browser behavior and instead print urls to terminal.
.P
Set to \fBtrue\fR to use default system URL opener.
.SS "\fBunicode\fR"
.RS 0
.IP \(bu 4
Default: false on windows, true on mac/unix systems with a unicode locale, as defined by the \fBLC_ALL\fR, \fBLC_CTYPE\fR, or \fBLANG\fR environment variables.
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set to true, npm uses unicode characters in the tree output. When false, it uses ascii characters instead of unicode glyphs.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBwhich\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Number
.RE 0

.P
If there are multiple funding sources, which 1-indexed source URL to open.
.SH "SEE ALSO"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help install
.IP \(bu 4
npm help docs
.IP \(bu 4
npm help ls
.IP \(bu 4
npm help config
.IP \(bu 4
npm help workspaces
.RE 0
                                      node-23.7.0/deps/npm/man/man1/npm-help-search.1                                                     0000664 0000000 0000000 00000001547 14746647661 0020765 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-HELP-SEARCH" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-help-search\fR - Search npm help documentation
.SS "Synopsis"
.P
.RS 2
.nf
npm help-search <text>
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
This command will search the npm markdown documentation files for the terms provided, and then list the results, sorted by relevance.
.P
If only one result is found, then it will show that help topic.
.P
If the argument to \fBnpm help\fR is not a known help topic, then it will call \fBhelp-search\fR. It is rarely if ever necessary to call this command directly.
.SS "Configuration"
.SS "\fBlong\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Show extended information in \fBls\fR, \fBsearch\fR, and \fBhelp-search\fR.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help npm
.IP \(bu 4
npm help help
.RE 0
                                                                                                                                                         node-23.7.0/deps/npm/man/man1/npm-help.1                                                            0000664 0000000 0000000 00000002117 14746647661 0017514 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-HELP" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-help\fR - Get help on npm
.SS "Synopsis"
.P
.RS 2
.nf
npm help <term> \[lB]<terms..>\[rB]

alias: hlep
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
If supplied a topic, then show the appropriate documentation page.
.P
If the topic does not exist, or if multiple terms are provided, then npm will run the \fBhelp-search\fR command to find a match. Note that, if \fBhelp-search\fR finds a single subject, then it will run \fBhelp\fR on that topic, so unique matches are equivalent to specifying a topic name.
.SS "Configuration"
.SS "\fBviewer\fR"
.RS 0
.IP \(bu 4
Default: "man" on Posix, "browser" on Windows
.IP \(bu 4
Type: String
.RE 0

.P
The program to use to view help content.
.P
Set to \fB"browser"\fR to view html help content in the default web browser.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help npm
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
\fBpackage.json\fR \fI\(la/configuring-npm/package-json\(ra\fR
.IP \(bu 4
npm help help-search
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/npm/man/man1/npm-hook.1                                                            0000664 0000000 0000000 00000005230 14746647661 0017523 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-HOOK" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-hook\fR - Manage registry hooks
.SS "Synopsis"
.P
.RS 2
.nf
npm hook add <pkg> <url> <secret> \[lB]--type=<type>\[rB]
npm hook ls \[lB]pkg\[rB]
npm hook rm <id>
npm hook update <id> <url> <secret>
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Allows you to manage \fBnpm hooks\fR \fI\(lahttps://blog.npmjs.org/post/145260155635/introducing-hooks-get-notifications-of-npm\(ra\fR, including adding, removing, listing, and updating.
.P
Hooks allow you to configure URL endpoints that will be notified whenever a change happens to any of the supported entity types. Three different types of entities can be watched by hooks: packages, owners, and scopes.
.P
To create a package hook, simply reference the package name.
.P
To create an owner hook, prefix the owner name with \fB~\fR (as in, \fB~youruser\fR).
.P
To create a scope hook, prefix the scope name with \fB@\fR (as in, \fB@yourscope\fR).
.P
The hook \fBid\fR used by \fBupdate\fR and \fBrm\fR are the IDs listed in \fBnpm hook ls\fR for that particular hook.
.P
The shared secret will be sent along to the URL endpoint so you can verify the request came from your own configured hook.
.SS "Example"
.P
Add a hook to watch a package for changes:
.P
.RS 2
.nf
$ npm hook add lodash https://example.com/ my-shared-secret
.fi
.RE
.P
Add a hook to watch packages belonging to the user \fBsubstack\fR:
.P
.RS 2
.nf
$ npm hook add ~substack https://example.com/ my-shared-secret
.fi
.RE
.P
Add a hook to watch packages in the scope \fB@npm\fR
.P
.RS 2
.nf
$ npm hook add @npm https://example.com/ my-shared-secret
.fi
.RE
.P
List all your active hooks:
.P
.RS 2
.nf
$ npm hook ls
.fi
.RE
.P
List your active hooks for the \fBlodash\fR package:
.P
.RS 2
.nf
$ npm hook ls lodash
.fi
.RE
.P
Update an existing hook's url:
.P
.RS 2
.nf
$ npm hook update id-deadbeef https://my-new-website.here/
.fi
.RE
.P
Remove a hook:
.P
.RS 2
.nf
$ npm hook rm id-deadbeef
.fi
.RE
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBotp\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with \fBnpm access\fR.
.P
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
.SS "See Also"
.RS 0
.IP \(bu 4
\fB"Introducing Hooks" blog post\fR \fI\(lahttps://blog.npmjs.org/post/145260155635/introducing-hooks-get-notifications-of-npm\(ra\fR
.RE 0
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/npm/man/man1/npm-init.1                                                            0000664 0000000 0000000 00000025552 14746647661 0017537 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-INIT" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-init\fR - Create a package.json file
.SS "Synopsis"
.P
.RS 2
.nf
npm init <package-spec> (same as `npx create-<package-spec>`)
npm init <@scope> (same as `npx <@scope>/create`)

aliases: create, innit
.fi
.RE
.SS "Description"
.P
\fBnpm init <initializer>\fR can be used to set up a new or existing npm package.
.P
\fBinitializer\fR in this case is an npm package named \fBcreate-<initializer>\fR, which will be installed by npm help npm-exec, and then have its main bin executed -- presumably creating or updating \fBpackage.json\fR and running any other initialization-related operations.
.P
The init command is transformed to a corresponding \fBnpm exec\fR operation as follows:
.RS 0
.IP \(bu 4
\fBnpm init foo\fR -> \fBnpm exec create-foo\fR
.IP \(bu 4
\fBnpm init @usr/foo\fR -> \fBnpm exec @usr/create-foo\fR
.IP \(bu 4
\fBnpm init @usr\fR -> \fBnpm exec @usr/create\fR
.IP \(bu 4
\fBnpm init @usr@2.0.0\fR -> \fBnpm exec @usr/create@2.0.0\fR
.IP \(bu 4
\fBnpm init @usr/foo@2.0.0\fR -> \fBnpm exec @usr/create-foo@2.0.0\fR
.RE 0

.P
If the initializer is omitted (by just calling \fBnpm init\fR), init will fall back to legacy init behavior. It will ask you a bunch of questions, and then write a package.json for you. It will attempt to make reasonable guesses based on existing fields, dependencies, and options selected. It is strictly additive, so it will keep any fields and values that were already set. You can also use \fB-y\fR/\fB--yes\fR to skip the questionnaire altogether. If you pass \fB--scope\fR, it will create a scoped package.
.P
\fINote:\fR if a user already has the \fBcreate-<initializer>\fR package globally installed, that will be what \fBnpm init\fR uses. If you want npm to use the latest version, or another specific version you must specify it:
.RS 0
.IP \(bu 4
\fBnpm init foo@latest\fR # fetches and runs the latest \fBcreate-foo\fR from the registry
.IP \(bu 4
\fBnpm init foo@1.2.3\fR # runs \fBcreate-foo@1.2.3\fR specifically
.RE 0

.SS "Forwarding additional options"
.P
Any additional options will be passed directly to the command, so \fBnpm init
foo -- --hello\fR will map to \fBnpm exec -- create-foo --hello\fR.
.P
To better illustrate how options are forwarded, here's a more evolved example showing options passed to both the \fBnpm cli\fR and a create package, both following commands are equivalent:
.RS 0
.IP \(bu 4
\fBnpm init foo -y --registry=<url> -- --hello -a\fR
.IP \(bu 4
\fBnpm exec -y --registry=<url> -- create-foo --hello -a\fR
.RE 0

.SS "Examples"
.P
Create a new React-based project using \fB\fBcreate-react-app\fR\fR \fI\(lahttps://npm.im/create-react-app\(ra\fR:
.P
.RS 2
.nf
$ npm init react-app ./my-react-app
.fi
.RE
.P
Create a new \fBesm\fR-compatible package using \fB\fBcreate-esm\fR\fR \fI\(lahttps://npm.im/create-esm\(ra\fR:
.P
.RS 2
.nf
$ mkdir my-esm-lib && cd my-esm-lib
$ npm init esm --yes
.fi
.RE
.P
Generate a plain old package.json using legacy init:
.P
.RS 2
.nf
$ mkdir my-npm-pkg && cd my-npm-pkg
$ git init
$ npm init
.fi
.RE
.P
Generate it without having it ask any questions:
.P
.RS 2
.nf
$ npm init -y
.fi
.RE
.SS "Workspaces support"
.P
It's possible to create a new workspace within your project by using the \fBworkspace\fR config option. When using \fBnpm init -w <dir>\fR the cli will create the folders and boilerplate expected while also adding a reference to your project \fBpackage.json\fR \fB"workspaces": \[lB]\[rB]\fR property in order to make sure that new generated \fBworkspace\fR is properly set up as such.
.P
Given a project with no workspaces, e.g:
.P
.RS 2
.nf
.
+-- package.json
.fi
.RE
.P
You may generate a new workspace using the legacy init:
.P
.RS 2
.nf
$ npm init -w packages/a
.fi
.RE
.P
That will generate a new folder and \fBpackage.json\fR file, while also updating your top-level \fBpackage.json\fR to add the reference to this new workspace:
.P
.RS 2
.nf
.
+-- package.json
`-- packages
   `-- a
       `-- package.json
.fi
.RE
.P
The workspaces init also supports the \fBnpm init <initializer> -w <dir>\fR syntax, following the same set of rules explained earlier in the initial \fBDescription\fR section of this page. Similar to the previous example of creating a new React-based project using \fB\fBcreate-react-app\fR\fR \fI\(lahttps://npm.im/create-react-app\(ra\fR, the following syntax will make sure to create the new react app as a nested \fBworkspace\fR within your project and configure your \fBpackage.json\fR to recognize it as such:
.P
.RS 2
.nf
npm init -w packages/my-react-app react-app .
.fi
.RE
.P
This will make sure to generate your react app as expected, one important consideration to have in mind is that \fBnpm exec\fR is going to be run in the context of the newly created folder for that workspace, and that's the reason why in this example the initializer uses the initializer name followed with a dot to represent the current directory in that context, e.g: \fBreact-app .\fR:
.P
.RS 2
.nf
.
+-- package.json
`-- packages
   +-- a
   |   `-- package.json
   `-- my-react-app
       +-- README
       +-- package.json
       `-- ...
.fi
.RE
.SS "Configuration"
.SS "\fBinit-author-name\fR"
.RS 0
.IP \(bu 4
Default: ""
.IP \(bu 4
Type: String
.RE 0

.P
The value \fBnpm init\fR should use by default for the package author's name.
.SS "\fBinit-author-url\fR"
.RS 0
.IP \(bu 4
Default: ""
.IP \(bu 4
Type: "" or URL
.RE 0

.P
The value \fBnpm init\fR should use by default for the package author's homepage.
.SS "\fBinit-license\fR"
.RS 0
.IP \(bu 4
Default: "ISC"
.IP \(bu 4
Type: String
.RE 0

.P
The value \fBnpm init\fR should use by default for the package license.
.SS "\fBinit-module\fR"
.RS 0
.IP \(bu 4
Default: "~/.npm-init.js"
.IP \(bu 4
Type: Path
.RE 0

.P
A module that will be loaded by the \fBnpm init\fR command. See the documentation for the \fBinit-package-json\fR \fI\(lahttps://github.com/npm/init-package-json\(ra\fR module for more information, or npm help init.
.SS "\fBinit-version\fR"
.RS 0
.IP \(bu 4
Default: "1.0.0"
.IP \(bu 4
Type: SemVer string
.RE 0

.P
The value that \fBnpm init\fR should use by default for the package version number, if not already set in package.json.
.SS "\fByes\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Automatically answer "yes" to any prompts that npm might print on the command line.
.SS "\fBforce\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Removes various protections against unfortunate side effects, common mistakes, unnecessary performance degradation, and malicious input.
.RS 0
.IP \(bu 4
Allow clobbering non-npm files in global installs.
.IP \(bu 4
Allow the \fBnpm version\fR command to work on an unclean git repository.
.IP \(bu 4
Allow deleting the cache folder with \fBnpm cache clean\fR.
.IP \(bu 4
Allow installing packages that have an \fBengines\fR declaration requiring a different version of npm.
.IP \(bu 4
Allow installing packages that have an \fBengines\fR declaration requiring a different version of \fBnode\fR, even if \fB--engine-strict\fR is enabled.
.IP \(bu 4
Allow \fBnpm audit fix\fR to install modules outside your stated dependency range (including SemVer-major changes).
.IP \(bu 4
Allow unpublishing all versions of a published package.
.IP \(bu 4
Allow conflicting peerDependencies to be installed in the root project.
.IP \(bu 4
Implicitly set \fB--yes\fR during \fBnpm init\fR.
.IP \(bu 4
Allow clobbering existing values in \fBnpm pkg\fR
.IP \(bu 4
Allow unpublishing of entire packages (not just a single version).
.RE 0

.P
If you don't have a clear idea of what you want to do, it is strongly recommended that you do not use this option!
.SS "\fBscope\fR"
.RS 0
.IP \(bu 4
Default: the scope of the current project, if any, or ""
.IP \(bu 4
Type: String
.RE 0

.P
Associate an operation with a scope for a scoped registry.
.P
Useful when logging in to or out of a private registry:
.P
.RS 2
.nf
# log in, linking the scope to the custom registry
npm login --scope=@mycorp --registry=https://registry.mycorp.com

# log out, removing the link and the auth token
npm logout --scope=@mycorp
.fi
.RE
.P
This will cause \fB@mycorp\fR to be mapped to the registry for future installation of packages specified according to the pattern \fB@mycorp/package\fR.
.P
This will also cause \fBnpm init\fR to create a scoped package.
.P
.RS 2
.nf
# accept all defaults, and create a package named "@foo/whatever",
# instead of just named "whatever"
npm init --scope=@foo --yes
.fi
.RE
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces-update\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to true, the npm cli will run an update after operations that may possibly change the workspaces installed to the \fBnode_modules\fR folder.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
\fBinit-package-json module\fR \fI\(lahttp://npm.im/init-package-json\(ra\fR
.IP \(bu 4
\fBpackage.json\fR \fI\(la/configuring-npm/package-json\(ra\fR
.IP \(bu 4
npm help version
.IP \(bu 4
npm help scope
.IP \(bu 4
npm help exec
.IP \(bu 4
npm help workspaces
.RE 0
                                                                                                                                                      node-23.7.0/deps/npm/man/man1/npm-install-ci-test.1                                                 0000664 0000000 0000000 00000020204 14746647661 0021575 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-INSTALL-CI-TEST" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-install-ci-test\fR - Install a project with a clean slate and run tests
.SS "Synopsis"
.P
.RS 2
.nf
npm install-ci-test

aliases: cit, clean-install-test, sit
.fi
.RE
.SS "Description"
.P
This command runs \fBnpm ci\fR followed immediately by \fBnpm test\fR.
.SS "Configuration"
.SS "\fBinstall-strategy\fR"
.RS 0
.IP \(bu 4
Default: "hoisted"
.IP \(bu 4
Type: "hoisted", "nested", "shallow", or "linked"
.RE 0

.P
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
.SS "\fBlegacy-bundling\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=nested\fR
.RE 0

.P
Instead of hoisting package installs in \fBnode_modules\fR, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets \fB--install-strategy=nested\fR.
.SS "\fBglobal-style\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=shallow\fR
.RE 0

.P
Only install direct dependencies in the top level \fBnode_modules\fR, but hoist on deeper dependencies. Sets \fB--install-strategy=shallow\fR.
.SS "\fBomit\fR"
.RS 0
.IP \(bu 4
Default: 'dev' if the \fBNODE_ENV\fR environment variable is set to 'production', otherwise empty.
.IP \(bu 4
Type: "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Dependency types to omit from the installation tree on disk.
.P
Note that these dependencies \fIare\fR still resolved and added to the \fBpackage-lock.json\fR or \fBnpm-shrinkwrap.json\fR file. They are just not physically installed on disk.
.P
If a package type appears in both the \fB--include\fR and \fB--omit\fR lists, then it will be included.
.P
If the resulting omit list includes \fB'dev'\fR, then the \fBNODE_ENV\fR environment variable will be set to \fB'production'\fR for all lifecycle scripts.
.SS "\fBinclude\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: "prod", "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Option that allows for defining which types of dependencies to install.
.P
This is the inverse of \fB--omit=<type>\fR.
.P
Dependency types specified in \fB--include\fR will not be omitted, regardless of the order in which omit/include are specified on the command-line.
.SS "\fBstrict-peer-deps\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to \fBtrue\fR, and \fB--legacy-peer-deps\fR is not set, then \fIany\fR conflicting \fBpeerDependencies\fR will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
.P
By default, conflicting \fBpeerDependencies\fR deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's \fBpeerDependencies\fR object.
.P
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If \fB--strict-peer-deps\fR is set, then this warning is treated as a failure.
.SS "\fBforeground-scripts\fR"
.RS 0
.IP \(bu 4
Default: \fBfalse\fR unless when using \fBnpm pack\fR or \fBnpm publish\fR where it defaults to \fBtrue\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Run all build scripts (ie, \fBpreinstall\fR, \fBinstall\fR, and \fBpostinstall\fR) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
.P
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBaudit\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm help audit for details on what is submitted.
.SS "\fBbin-links\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
Tells npm to create symlinks (or \fB.cmd\fR shims on Windows) for package executables.
.P
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
.SS "\fBfund\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" displays the message at the end of each \fBnpm install\fR acknowledging the number of dependencies looking for funding. See npm help fund for details.
.SS "\fBdry-run\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, \fBinstall\fR, \fBupdate\fR, \fBdedupe\fR, \fBuninstall\fR, as well as \fBpack\fR and \fBpublish\fR.
.P
Note: This is NOT honored by other network related commands, eg \fBdist-tags\fR, \fBowner\fR, etc.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBinstall-links\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help install-test
.IP \(bu 4
npm help ci
.IP \(bu 4
npm help test
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/npm/man/man1/npm-install-test.1                                                    0000664 0000000 0000000 00000025621 14746647661 0021214 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-INSTALL-TEST" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-install-test\fR - Install package(s) and run tests
.SS "Synopsis"
.P
.RS 2
.nf
npm install-test \[lB]<package-spec> ...\[rB]

alias: it
.fi
.RE
.SS "Description"
.P
This command runs an \fBnpm install\fR followed immediately by an \fBnpm test\fR. It takes exactly the same arguments as \fBnpm install\fR.
.SS "Configuration"
.SS "\fBsave\fR"
.RS 0
.IP \(bu 4
Default: \fBtrue\fR unless when using \fBnpm update\fR where it defaults to \fBfalse\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Save installed packages to a \fBpackage.json\fR file as dependencies.
.P
When used with the \fBnpm rm\fR command, removes the dependency from \fBpackage.json\fR.
.P
Will also prevent writing to \fBpackage-lock.json\fR if set to \fBfalse\fR.
.SS "\fBsave-exact\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Dependencies saved to package.json will be configured with an exact version rather than using npm's default semver range operator.
.SS "\fBglobal\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Operates in "global" mode, so that packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "\fBinstall-strategy\fR"
.RS 0
.IP \(bu 4
Default: "hoisted"
.IP \(bu 4
Type: "hoisted", "nested", "shallow", or "linked"
.RE 0

.P
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
.SS "\fBlegacy-bundling\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=nested\fR
.RE 0

.P
Instead of hoisting package installs in \fBnode_modules\fR, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets \fB--install-strategy=nested\fR.
.SS "\fBglobal-style\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=shallow\fR
.RE 0

.P
Only install direct dependencies in the top level \fBnode_modules\fR, but hoist on deeper dependencies. Sets \fB--install-strategy=shallow\fR.
.SS "\fBomit\fR"
.RS 0
.IP \(bu 4
Default: 'dev' if the \fBNODE_ENV\fR environment variable is set to 'production', otherwise empty.
.IP \(bu 4
Type: "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Dependency types to omit from the installation tree on disk.
.P
Note that these dependencies \fIare\fR still resolved and added to the \fBpackage-lock.json\fR or \fBnpm-shrinkwrap.json\fR file. They are just not physically installed on disk.
.P
If a package type appears in both the \fB--include\fR and \fB--omit\fR lists, then it will be included.
.P
If the resulting omit list includes \fB'dev'\fR, then the \fBNODE_ENV\fR environment variable will be set to \fB'production'\fR for all lifecycle scripts.
.SS "\fBinclude\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: "prod", "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Option that allows for defining which types of dependencies to install.
.P
This is the inverse of \fB--omit=<type>\fR.
.P
Dependency types specified in \fB--include\fR will not be omitted, regardless of the order in which omit/include are specified on the command-line.
.SS "\fBstrict-peer-deps\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to \fBtrue\fR, and \fB--legacy-peer-deps\fR is not set, then \fIany\fR conflicting \fBpeerDependencies\fR will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
.P
By default, conflicting \fBpeerDependencies\fR deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's \fBpeerDependencies\fR object.
.P
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If \fB--strict-peer-deps\fR is set, then this warning is treated as a failure.
.SS "\fBprefer-dedupe\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Prefer to deduplicate packages if possible, rather than choosing a newer version of a dependency.
.SS "\fBpackage-lock\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to false, then ignore \fBpackage-lock.json\fR files when installing. This will also prevent \fIwriting\fR \fBpackage-lock.json\fR if \fBsave\fR is true.
.SS "\fBpackage-lock-only\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to true, the current operation will only use the \fBpackage-lock.json\fR, ignoring \fBnode_modules\fR.
.P
For \fBupdate\fR this means only the \fBpackage-lock.json\fR will be updated, instead of checking \fBnode_modules\fR and downloading dependencies.
.P
For \fBlist\fR this means the output will be based on the tree described by the \fBpackage-lock.json\fR, rather than the contents of \fBnode_modules\fR.
.SS "\fBforeground-scripts\fR"
.RS 0
.IP \(bu 4
Default: \fBfalse\fR unless when using \fBnpm pack\fR or \fBnpm publish\fR where it defaults to \fBtrue\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Run all build scripts (ie, \fBpreinstall\fR, \fBinstall\fR, and \fBpostinstall\fR) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
.P
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBaudit\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm help audit for details on what is submitted.
.SS "\fBbin-links\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
Tells npm to create symlinks (or \fB.cmd\fR shims on Windows) for package executables.
.P
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
.SS "\fBfund\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" displays the message at the end of each \fBnpm install\fR acknowledging the number of dependencies looking for funding. See npm help fund for details.
.SS "\fBdry-run\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, \fBinstall\fR, \fBupdate\fR, \fBdedupe\fR, \fBuninstall\fR, as well as \fBpack\fR and \fBpublish\fR.
.P
Note: This is NOT honored by other network related commands, eg \fBdist-tags\fR, \fBowner\fR, etc.
.SS "\fBcpu\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
Override CPU architecture of native modules to install. Acceptable values are same as \fBcpu\fR field of package.json, which comes from \fBprocess.arch\fR.
.SS "\fBos\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
Override OS of native modules to install. Acceptable values are same as \fBos\fR field of package.json, which comes from \fBprocess.platform\fR.
.SS "\fBlibc\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
Override libc of native modules to install. Acceptable values are same as \fBlibc\fR field of package.json
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBinstall-links\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help install
.IP \(bu 4
npm help install-ci-test
.IP \(bu 4
npm help test
.RE 0
                                                                                                               node-23.7.0/deps/npm/man/man1/npm-install.1                                                         0000664 0000000 0000000 00000064227 14746647661 0020244 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-INSTALL" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-install\fR - Install a package
.SS "Synopsis"
.P
.RS 2
.nf
npm install \[lB]<package-spec> ...\[rB]

aliases: add, i, in, ins, inst, insta, instal, isnt, isnta, isntal, isntall
.fi
.RE
.SS "Description"
.P
This command installs a package and any packages that it depends on. If the package has a package-lock, or an npm shrinkwrap file, or a yarn lock file, the installation of dependencies will be driven by that, respecting the following order of precedence:
.RS 0
.IP \(bu 4
\fBnpm-shrinkwrap.json\fR
.IP \(bu 4
\fBpackage-lock.json\fR
.IP \(bu 4
\fByarn.lock\fR
.RE 0

.P
See \fBpackage-lock.json\fR \fI\(la/configuring-npm/package-lock-json\(ra\fR and npm help shrinkwrap.
.P
A \fBpackage\fR is:
.RS 0
.IP \(bu 4
a) a folder containing a program described by a \fB\fBpackage.json\fR\fR \fI\(la/configuring-npm/package-json\(ra\fR file
.IP \(bu 4
b) a gzipped tarball containing (a)
.IP \(bu 4
c) a url that resolves to (b)
.IP \(bu 4
d) a \fB<name>@<version>\fR that is published on the registry (see npm help registry) with (c)
.IP \(bu 4
e) a \fB<name>@<tag>\fR (see npm help dist-tag) that points to (d)
.IP \(bu 4
f) a \fB<name>\fR that has a "latest" tag satisfying (e)
.IP \(bu 4
g) a \fB<git remote url>\fR that resolves to (a)
.RE 0

.P
Even if you never publish your package, you can still get a lot of benefits of using npm if you just want to write a node program (a), and perhaps if you also want to be able to easily install it elsewhere after packing it up into a tarball (b).
.RS 0
.IP \(bu 4
\fBnpm install\fR (in a package directory, no arguments):
.P
Install the dependencies to the local \fBnode_modules\fR folder.
.P
In global mode (ie, with \fB-g\fR or \fB--global\fR appended to the command), it installs the current package context (ie, the current working directory) as a global package.
.P
By default, \fBnpm install\fR will install all modules listed as dependencies in \fB\fBpackage.json\fR\fR \fI\(la/configuring-npm/package-json\(ra\fR.
.P
With the \fB--production\fR flag (or when the \fBNODE_ENV\fR environment variable is set to \fBproduction\fR), npm will not install modules listed in \fBdevDependencies\fR. To install all modules listed in both \fBdependencies\fR and \fBdevDependencies\fR when \fBNODE_ENV\fR environment variable is set to \fBproduction\fR, you can use \fB--production=false\fR.
.RS 4
.P
NOTE: The \fB--production\fR flag has no particular meaning when adding a dependency to a project.
.RE 0

.IP \(bu 4
\fBnpm install <folder>\fR:
.P
If \fB<folder>\fR sits inside the root of your project, its dependencies will be installed and may be hoisted to the top-level \fBnode_modules\fR as they would for other types of dependencies. If \fB<folder>\fR sits outside the root of your project, \fInpm will not install the package dependencies\fR in the directory \fB<folder>\fR, but it will create a symlink to \fB<folder>\fR.
.RS 4
.P
NOTE: If you want to install the content of a directory like a package from the registry instead of creating a link, you would need to use the \fB--install-links\fR option.
.RE 0

.P
Example:
.P
.RS 2
.nf
npm install ../../other-package --install-links
npm install ./sub-package
.fi
.RE
.IP \(bu 4
\fBnpm install <tarball file>\fR:
.P
Install a package that is sitting on the filesystem. Note: if you just want to link a dev directory into your npm root, you can do this more easily by using npm help link.
.P
Tarball requirements:
.RS 4
.IP \(bu 4
The filename \fImust\fR use \fB.tar\fR, \fB.tar.gz\fR, or \fB.tgz\fR as the extension.
.IP \(bu 4
The package contents should reside in a subfolder inside the tarball (usually it is called \fBpackage/\fR). npm strips one directory layer when installing the package (an equivalent of \fBtar x
--strip-components=1\fR is run).
.IP \(bu 4
The package must contain a \fBpackage.json\fR file with \fBname\fR and \fBversion\fR properties.
.RE 0

.P
Example:
.P
.RS 2
.nf
npm install ./package.tgz
.fi
.RE
.IP \(bu 4
\fBnpm install <tarball url>\fR:
.P
Fetch the tarball url, and then install it. In order to distinguish between this and other options, the argument must start with "http://" or "https://"
.P
Example:
.P
.RS 2
.nf
npm install https://github.com/indexzero/forever/tarball/v0.5.6
.fi
.RE
.IP \(bu 4
\fBnpm install \[lB]<@scope>/\[rB]<name>\fR:
.P
Do a \fB<name>@<tag>\fR install, where \fB<tag>\fR is the "tag" config. (See \fB\fBconfig\fR\fR \fI\(la/using-npm/config#tag\(ra\fR. The config's default value is \fBlatest\fR.)
.P
In most cases, this will install the version of the modules tagged as \fBlatest\fR on the npm registry.
.P
Example:
.P
.RS 2
.nf
npm install sax
.fi
.RE
.P
\fBnpm install\fR saves any specified packages into \fBdependencies\fR by default. Additionally, you can control where and how they get saved with some additional flags:
.RS 4
.IP \(bu 4
\fB-P, --save-prod\fR: Package will appear in your \fBdependencies\fR. This is the default unless \fB-D\fR or \fB-O\fR are present.
.IP \(bu 4
\fB-D, --save-dev\fR: Package will appear in your \fBdevDependencies\fR.
.IP \(bu 4
\fB--save-peer\fR: Package will appear in your \fBpeerDependencies\fR.
.IP \(bu 4
\fB-O, --save-optional\fR: Package will appear in your \fBoptionalDependencies\fR.
.IP \(bu 4
\fB--no-save\fR: Prevents saving to \fBdependencies\fR.
.RE 0

.P
When using any of the above options to save dependencies to your package.json, there are two additional, optional flags:
.RS 4
.IP \(bu 4
\fB-E, --save-exact\fR: Saved dependencies will be configured with an exact version rather than using npm's default semver range operator.
.IP \(bu 4
\fB-B, --save-bundle\fR: Saved dependencies will also be added to your \fBbundleDependencies\fR list.
.RE 0

.P
Further, if you have an \fBnpm-shrinkwrap.json\fR or \fBpackage-lock.json\fR then it will be updated as well.
.P
\fB<scope>\fR is optional. The package will be downloaded from the registry associated with the specified scope. If no registry is associated with the given scope the default registry is assumed. See npm help scope.
.P
Note: if you do not include the @-symbol on your scope name, npm will interpret this as a GitHub repository instead, see below. Scopes names must also be followed by a slash.
.P
Examples:
.P
.RS 2
.nf
npm install sax
npm install githubname/reponame
npm install @myorg/privatepackage
npm install node-tap --save-dev
npm install dtrace-provider --save-optional
npm install readable-stream --save-exact
npm install ansi-regex --save-bundle
.fi
.RE
.IP \(bu 4
\fBnpm install <alias>@npm:<name>\fR:
.P
Install a package under a custom alias. Allows multiple versions of a same-name package side-by-side, more convenient import names for packages with otherwise long ones, and using git forks replacements or forked npm packages as replacements. Aliasing works only on your project and does not rename packages in transitive dependencies. Aliases should follow the naming conventions stated in \fB\fBvalidate-npm-package-name\fR\fR \fI\(lahttps://www.npmjs.com/package/validate-npm-package-name#naming-rules\(ra\fR.
.P
Examples:
.P
.RS 2
.nf
npm install my-react@npm:react
npm install jquery2@npm:jquery@2
npm install jquery3@npm:jquery@3
npm install npa@npm:npm-package-arg
.fi
.RE
.IP \(bu 4
\fBnpm install \[lB]<@scope>/\[rB]<name>@<tag>\fR:
.P
Install the version of the package that is referenced by the specified tag. If the tag does not exist in the registry data for that package, then this will fail.
.P
Example:
.P
.RS 2
.nf
npm install sax@latest
npm install @myorg/mypackage@latest
.fi
.RE
.IP \(bu 4
\fBnpm install \[lB]<@scope>/\[rB]<name>@<version>\fR:
.P
Install the specified version of the package. This will fail if the version has not been published to the registry.
.P
Example:
.P
.RS 2
.nf
npm install sax@0.1.1
npm install @myorg/privatepackage@1.5.0
.fi
.RE
.IP \(bu 4
\fBnpm install \[lB]<@scope>/\[rB]<name>@<version range>\fR:
.P
Install a version of the package matching the specified version range. This will follow the same rules for resolving dependencies described in \fB\fBpackage.json\fR\fR \fI\(la/configuring-npm/package-json\(ra\fR.
.P
Note that most version ranges must be put in quotes so that your shell will treat it as a single argument.
.P
Example:
.P
.RS 2
.nf
npm install sax@">=0.1.0 <0.2.0"
npm install @myorg/privatepackage@"16 - 17"
.fi
.RE
.IP \(bu 4
\fBnpm install <git remote url>\fR:
.P
Installs the package from the hosted git provider, cloning it with \fBgit\fR. For a full git remote url, only that URL will be attempted.
.P
.RS 2
.nf
<protocol>://\[lB]<user>\[lB]:<password>\[rB]@\[rB]<hostname>\[lB]:<port>\[rB]\[lB]:\[rB]\[lB]/\[rB]<path>\[lB]#<commit-ish> | #semver:<semver>\[rB]
.fi
.RE
.P
\fB<protocol>\fR is one of \fBgit\fR, \fBgit+ssh\fR, \fBgit+http\fR, \fBgit+https\fR, or \fBgit+file\fR.
.P
If \fB#<commit-ish>\fR is provided, it will be used to clone exactly that commit. If the commit-ish has the format \fB#semver:<semver>\fR, \fB<semver>\fR can be any valid semver range or exact version, and npm will look for any tags or refs matching that range in the remote repository, much as it would for a registry dependency. If neither \fB#<commit-ish>\fR or \fB#semver:<semver>\fR is specified, then the default branch of the repository is used.
.P
If the repository makes use of submodules, those submodules will be cloned as well.
.P
If the package being installed contains a \fBprepare\fR script, its \fBdependencies\fR and \fBdevDependencies\fR will be installed, and the prepare script will be run, before the package is packaged and installed.
.P
The following git environment variables are recognized by npm and will be added to the environment when running git:
.RS 4
.IP \(bu 4
\fBGIT_ASKPASS\fR
.IP \(bu 4
\fBGIT_EXEC_PATH\fR
.IP \(bu 4
\fBGIT_PROXY_COMMAND\fR
.IP \(bu 4
\fBGIT_SSH\fR
.IP \(bu 4
\fBGIT_SSH_COMMAND\fR
.IP \(bu 4
\fBGIT_SSL_CAINFO\fR
.IP \(bu 4
\fBGIT_SSL_NO_VERIFY\fR
.RE 0

.P
See the git man page for details.
.P
Examples:
.P
.RS 2
.nf
npm install git+ssh://git@github.com:npm/cli.git#v1.0.27
npm install git+ssh://git@github.com:npm/cli#pull/273
npm install git+ssh://git@github.com:npm/cli#semver:^5.0
npm install git+https://isaacs@github.com/npm/cli.git
npm install git://github.com/npm/cli.git#v1.0.27
GIT_SSH_COMMAND='ssh -i ~/.ssh/custom_ident' npm install git+ssh://git@github.com:npm/cli.git
.fi
.RE
.IP \(bu 4
\fBnpm install <githubname>/<githubrepo>\[lB]#<commit-ish>\[rB]\fR:
.IP \(bu 4
\fBnpm install github:<githubname>/<githubrepo>\[lB]#<commit-ish>\[rB]\fR:
.P
Install the package at \fBhttps://github.com/githubname/githubrepo\fR by attempting to clone it using \fBgit\fR.
.P
If \fB#<commit-ish>\fR is provided, it will be used to clone exactly that commit. If the commit-ish has the format \fB#semver:<semver>\fR, \fB<semver>\fR can be any valid semver range or exact version, and npm will look for any tags or refs matching that range in the remote repository, much as it would for a registry dependency. If neither \fB#<commit-ish>\fR or \fB#semver:<semver>\fR is specified, then the default branch is used.
.P
As with regular git dependencies, \fBdependencies\fR and \fBdevDependencies\fR will be installed if the package has a \fBprepare\fR script before the package is done installing.
.P
Examples:
.P
.RS 2
.nf
npm install mygithubuser/myproject
npm install github:mygithubuser/myproject
.fi
.RE
.IP \(bu 4
\fBnpm install gist:\[lB]<githubname>/\[rB]<gistID>\[lB]#<commit-ish>|#semver:<semver>\[rB]\fR:
.P
Install the package at \fBhttps://gist.github.com/gistID\fR by attempting to clone it using \fBgit\fR. The GitHub username associated with the gist is optional and will not be saved in \fBpackage.json\fR.
.P
As with regular git dependencies, \fBdependencies\fR and \fBdevDependencies\fR will be installed if the package has a \fBprepare\fR script before the package is done installing.
.P
Example:
.P
.RS 2
.nf
npm install gist:101a11beef
.fi
.RE
.IP \(bu 4
\fBnpm install bitbucket:<bitbucketname>/<bitbucketrepo>\[lB]#<commit-ish>\[rB]\fR:
.P
Install the package at \fBhttps://bitbucket.org/bitbucketname/bitbucketrepo\fR by attempting to clone it using \fBgit\fR.
.P
If \fB#<commit-ish>\fR is provided, it will be used to clone exactly that commit. If the commit-ish has the format \fB#semver:<semver>\fR, \fB<semver>\fR can be any valid semver range or exact version, and npm will look for any tags or refs matching that range in the remote repository, much as it would for a registry dependency. If neither \fB#<commit-ish>\fR or \fB#semver:<semver>\fR is specified, then \fBmaster\fR is used.
.P
As with regular git dependencies, \fBdependencies\fR and \fBdevDependencies\fR will be installed if the package has a \fBprepare\fR script before the package is done installing.
.P
Example:
.P
.RS 2
.nf
npm install bitbucket:mybitbucketuser/myproject
.fi
.RE
.IP \(bu 4
\fBnpm install gitlab:<gitlabname>/<gitlabrepo>\[lB]#<commit-ish>\[rB]\fR:
.P
Install the package at \fBhttps://gitlab.com/gitlabname/gitlabrepo\fR by attempting to clone it using \fBgit\fR.
.P
If \fB#<commit-ish>\fR is provided, it will be used to clone exactly that commit. If the commit-ish has the format \fB#semver:<semver>\fR, \fB<semver>\fR can be any valid semver range or exact version, and npm will look for any tags or refs matching that range in the remote repository, much as it would for a registry dependency. If neither \fB#<commit-ish>\fR or \fB#semver:<semver>\fR is specified, then \fBmaster\fR is used.
.P
As with regular git dependencies, \fBdependencies\fR and \fBdevDependencies\fR will be installed if the package has a \fBprepare\fR script before the package is done installing.
.P
Example:
.P
.RS 2
.nf
npm install gitlab:mygitlabuser/myproject
npm install gitlab:myusr/myproj#semver:^5.0
.fi
.RE
.RE 0

.P
You may combine multiple arguments and even multiple types of arguments. For example:
.P
.RS 2
.nf
npm install sax@">=0.1.0 <0.2.0" bench supervisor
.fi
.RE
.P
The \fB--tag\fR argument will apply to all of the specified install targets. If a tag with the given name exists, the tagged version is preferred over newer versions.
.P
The \fB--dry-run\fR argument will report in the usual way what the install would have done without actually installing anything.
.P
The \fB--package-lock-only\fR argument will only update the \fBpackage-lock.json\fR, instead of checking \fBnode_modules\fR and downloading dependencies.
.P
The \fB-f\fR or \fB--force\fR argument will force npm to fetch remote resources even if a local copy exists on disk.
.P
.RS 2
.nf
npm install sax --force
.fi
.RE
.SS "Configuration"
.P
See the npm help config help doc. Many of the configuration params have some effect on installation, since that's most of what npm does.
.P
These are some of the most common options related to installation.
.SS "\fBsave\fR"
.RS 0
.IP \(bu 4
Default: \fBtrue\fR unless when using \fBnpm update\fR where it defaults to \fBfalse\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Save installed packages to a \fBpackage.json\fR file as dependencies.
.P
When used with the \fBnpm rm\fR command, removes the dependency from \fBpackage.json\fR.
.P
Will also prevent writing to \fBpackage-lock.json\fR if set to \fBfalse\fR.
.SS "\fBsave-exact\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Dependencies saved to package.json will be configured with an exact version rather than using npm's default semver range operator.
.SS "\fBglobal\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Operates in "global" mode, so that packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "\fBinstall-strategy\fR"
.RS 0
.IP \(bu 4
Default: "hoisted"
.IP \(bu 4
Type: "hoisted", "nested", "shallow", or "linked"
.RE 0

.P
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
.SS "\fBlegacy-bundling\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=nested\fR
.RE 0

.P
Instead of hoisting package installs in \fBnode_modules\fR, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets \fB--install-strategy=nested\fR.
.SS "\fBglobal-style\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=shallow\fR
.RE 0

.P
Only install direct dependencies in the top level \fBnode_modules\fR, but hoist on deeper dependencies. Sets \fB--install-strategy=shallow\fR.
.SS "\fBomit\fR"
.RS 0
.IP \(bu 4
Default: 'dev' if the \fBNODE_ENV\fR environment variable is set to 'production', otherwise empty.
.IP \(bu 4
Type: "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Dependency types to omit from the installation tree on disk.
.P
Note that these dependencies \fIare\fR still resolved and added to the \fBpackage-lock.json\fR or \fBnpm-shrinkwrap.json\fR file. They are just not physically installed on disk.
.P
If a package type appears in both the \fB--include\fR and \fB--omit\fR lists, then it will be included.
.P
If the resulting omit list includes \fB'dev'\fR, then the \fBNODE_ENV\fR environment variable will be set to \fB'production'\fR for all lifecycle scripts.
.SS "\fBinclude\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: "prod", "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Option that allows for defining which types of dependencies to install.
.P
This is the inverse of \fB--omit=<type>\fR.
.P
Dependency types specified in \fB--include\fR will not be omitted, regardless of the order in which omit/include are specified on the command-line.
.SS "\fBstrict-peer-deps\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to \fBtrue\fR, and \fB--legacy-peer-deps\fR is not set, then \fIany\fR conflicting \fBpeerDependencies\fR will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
.P
By default, conflicting \fBpeerDependencies\fR deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's \fBpeerDependencies\fR object.
.P
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If \fB--strict-peer-deps\fR is set, then this warning is treated as a failure.
.SS "\fBprefer-dedupe\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Prefer to deduplicate packages if possible, rather than choosing a newer version of a dependency.
.SS "\fBpackage-lock\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to false, then ignore \fBpackage-lock.json\fR files when installing. This will also prevent \fIwriting\fR \fBpackage-lock.json\fR if \fBsave\fR is true.
.SS "\fBpackage-lock-only\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to true, the current operation will only use the \fBpackage-lock.json\fR, ignoring \fBnode_modules\fR.
.P
For \fBupdate\fR this means only the \fBpackage-lock.json\fR will be updated, instead of checking \fBnode_modules\fR and downloading dependencies.
.P
For \fBlist\fR this means the output will be based on the tree described by the \fBpackage-lock.json\fR, rather than the contents of \fBnode_modules\fR.
.SS "\fBforeground-scripts\fR"
.RS 0
.IP \(bu 4
Default: \fBfalse\fR unless when using \fBnpm pack\fR or \fBnpm publish\fR where it defaults to \fBtrue\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Run all build scripts (ie, \fBpreinstall\fR, \fBinstall\fR, and \fBpostinstall\fR) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
.P
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBaudit\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm help audit for details on what is submitted.
.SS "\fBbin-links\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
Tells npm to create symlinks (or \fB.cmd\fR shims on Windows) for package executables.
.P
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
.SS "\fBfund\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" displays the message at the end of each \fBnpm install\fR acknowledging the number of dependencies looking for funding. See npm help fund for details.
.SS "\fBdry-run\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, \fBinstall\fR, \fBupdate\fR, \fBdedupe\fR, \fBuninstall\fR, as well as \fBpack\fR and \fBpublish\fR.
.P
Note: This is NOT honored by other network related commands, eg \fBdist-tags\fR, \fBowner\fR, etc.
.SS "\fBcpu\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
Override CPU architecture of native modules to install. Acceptable values are same as \fBcpu\fR field of package.json, which comes from \fBprocess.arch\fR.
.SS "\fBos\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
Override OS of native modules to install. Acceptable values are same as \fBos\fR field of package.json, which comes from \fBprocess.platform\fR.
.SS "\fBlibc\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
Override libc of native modules to install. Acceptable values are same as \fBlibc\fR field of package.json
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBinstall-links\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
.SS "Algorithm"
.P
Given a \fBpackage{dep}\fR structure: \fBA{B,C}, B{C}, C{D}\fR, the npm install algorithm produces:
.P
.RS 2
.nf
A
+-- B
+-- C
+-- D
.fi
.RE
.P
That is, the dependency from B to C is satisfied by the fact that A already caused C to be installed at a higher level. D is still installed at the top level because nothing conflicts with it.
.P
For \fBA{B,C}, B{C,D@1}, C{D@2}\fR, this algorithm produces:
.P
.RS 2
.nf
A
+-- B
+-- C
   `-- D@2
+-- D@1
.fi
.RE
.P
Because B's D@1 will be installed in the top-level, C now has to install D@2 privately for itself. This algorithm is deterministic, but different trees may be produced if two dependencies are requested for installation in a different order.
.P
See npm help folders for a more detailed description of the specific folder structures that npm creates.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help update
.IP \(bu 4
npm help audit
.IP \(bu 4
npm help fund
.IP \(bu 4
npm help link
.IP \(bu 4
npm help rebuild
.IP \(bu 4
npm help scripts
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help dist-tag
.IP \(bu 4
npm help uninstall
.IP \(bu 4
npm help shrinkwrap
.IP \(bu 4
\fBpackage.json\fR \fI\(la/configuring-npm/package-json\(ra\fR
.IP \(bu 4
npm help workspaces
.RE 0
                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/npm/man/man1/npm-link.1                                                            0000664 0000000 0000000 00000031232 14746647661 0017521 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-LINK" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-link\fR - Symlink a package folder
.SS "Synopsis"
.P
.RS 2
.nf
npm link \[lB]<package-spec>\[rB]

alias: ln
.fi
.RE
.SS "Description"
.P
This is handy for installing your own stuff, so that you can work on it and test iteratively without having to continually rebuild.
.P
Package linking is a two-step process.
.P
First, \fBnpm link\fR in a package folder with no arguments will create a symlink in the global folder \fB{prefix}/lib/node_modules/<package>\fR that links to the package where the \fBnpm link\fR command was executed. It will also link any bins in the package to \fB{prefix}/bin/{name}\fR. Note that \fBnpm link\fR uses the global prefix (see \fBnpm prefix -g\fR for its value).
.P
Next, in some other location, \fBnpm link package-name\fR will create a symbolic link from globally-installed \fBpackage-name\fR to \fBnode_modules/\fR of the current folder.
.P
Note that \fBpackage-name\fR is taken from \fBpackage.json\fR, \fInot\fR from the directory name.
.P
The package name can be optionally prefixed with a scope. See npm help scope. The scope must be preceded by an @-symbol and followed by a slash.
.P
When creating tarballs for \fBnpm publish\fR, the linked packages are "snapshotted" to their current state by resolving the symbolic links, if they are included in \fBbundleDependencies\fR.
.P
For example:
.P
.RS 2
.nf
cd ~/projects/node-redis    # go into the package directory
npm link                    # creates global link
cd ~/projects/node-bloggy   # go into some other package directory.
npm link redis              # link-install the package
.fi
.RE
.P
Now, any changes to \fB~/projects/node-redis\fR will be reflected in \fB~/projects/node-bloggy/node_modules/node-redis/\fR. Note that the link should be to the package name, not the directory name for that package.
.P
You may also shortcut the two steps in one. For example, to do the above use-case in a shorter way:
.P
.RS 2
.nf
cd ~/projects/node-bloggy  # go into the dir of your main project
npm link ../node-redis     # link the dir of your dependency
.fi
.RE
.P
The second line is the equivalent of doing:
.P
.RS 2
.nf
(cd ../node-redis; npm link)
npm link redis
.fi
.RE
.P
That is, it first creates a global link, and then links the global installation target into your project's \fBnode_modules\fR folder.
.P
Note that in this case, you are referring to the directory name, \fBnode-redis\fR, rather than the package name \fBredis\fR.
.P
If your linked package is scoped (see npm help scope) your link command must include that scope, e.g.
.P
.RS 2
.nf
npm link @myorg/privatepackage
.fi
.RE
.SS "Caveat"
.P
Note that package dependencies linked in this way are \fInot\fR saved to \fBpackage.json\fR by default, on the assumption that the intention is to have a link stand in for a regular non-link dependency. Otherwise, for example, if you depend on \fBredis@^3.0.1\fR, and ran \fBnpm link redis\fR, it would replace the \fB^3.0.1\fR dependency with \fBfile:../path/to/node-redis\fR, which you probably don't want! Additionally, other users or developers on your project would run into issues if they do not have their folders set up exactly the same as yours.
.P
If you are adding a \fInew\fR dependency as a link, you should add it to the relevant metadata by running \fBnpm install <dep> --package-lock-only\fR.
.P
If you \fIwant\fR to save the \fBfile:\fR reference in your \fBpackage.json\fR and \fBpackage-lock.json\fR files, you can use \fBnpm link <dep> --save\fR to do so.
.SS "Workspace Usage"
.P
\fBnpm link <pkg> --workspace <name>\fR will link the relevant package as a dependency of the specified workspace(s). Note that It may actually be linked into the parent project's \fBnode_modules\fR folder, if there are no conflicting dependencies.
.P
\fBnpm link --workspace <name>\fR will create a global link to the specified workspace(s).
.SS "Configuration"
.SS "\fBsave\fR"
.RS 0
.IP \(bu 4
Default: \fBtrue\fR unless when using \fBnpm update\fR where it defaults to \fBfalse\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Save installed packages to a \fBpackage.json\fR file as dependencies.
.P
When used with the \fBnpm rm\fR command, removes the dependency from \fBpackage.json\fR.
.P
Will also prevent writing to \fBpackage-lock.json\fR if set to \fBfalse\fR.
.SS "\fBsave-exact\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Dependencies saved to package.json will be configured with an exact version rather than using npm's default semver range operator.
.SS "\fBglobal\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Operates in "global" mode, so that packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "\fBinstall-strategy\fR"
.RS 0
.IP \(bu 4
Default: "hoisted"
.IP \(bu 4
Type: "hoisted", "nested", "shallow", or "linked"
.RE 0

.P
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
.SS "\fBlegacy-bundling\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=nested\fR
.RE 0

.P
Instead of hoisting package installs in \fBnode_modules\fR, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets \fB--install-strategy=nested\fR.
.SS "\fBglobal-style\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=shallow\fR
.RE 0

.P
Only install direct dependencies in the top level \fBnode_modules\fR, but hoist on deeper dependencies. Sets \fB--install-strategy=shallow\fR.
.SS "\fBstrict-peer-deps\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to \fBtrue\fR, and \fB--legacy-peer-deps\fR is not set, then \fIany\fR conflicting \fBpeerDependencies\fR will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
.P
By default, conflicting \fBpeerDependencies\fR deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's \fBpeerDependencies\fR object.
.P
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If \fB--strict-peer-deps\fR is set, then this warning is treated as a failure.
.SS "\fBpackage-lock\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to false, then ignore \fBpackage-lock.json\fR files when installing. This will also prevent \fIwriting\fR \fBpackage-lock.json\fR if \fBsave\fR is true.
.SS "\fBomit\fR"
.RS 0
.IP \(bu 4
Default: 'dev' if the \fBNODE_ENV\fR environment variable is set to 'production', otherwise empty.
.IP \(bu 4
Type: "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Dependency types to omit from the installation tree on disk.
.P
Note that these dependencies \fIare\fR still resolved and added to the \fBpackage-lock.json\fR or \fBnpm-shrinkwrap.json\fR file. They are just not physically installed on disk.
.P
If a package type appears in both the \fB--include\fR and \fB--omit\fR lists, then it will be included.
.P
If the resulting omit list includes \fB'dev'\fR, then the \fBNODE_ENV\fR environment variable will be set to \fB'production'\fR for all lifecycle scripts.
.SS "\fBinclude\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: "prod", "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Option that allows for defining which types of dependencies to install.
.P
This is the inverse of \fB--omit=<type>\fR.
.P
Dependency types specified in \fB--include\fR will not be omitted, regardless of the order in which omit/include are specified on the command-line.
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBaudit\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm help audit for details on what is submitted.
.SS "\fBbin-links\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
Tells npm to create symlinks (or \fB.cmd\fR shims on Windows) for package executables.
.P
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
.SS "\fBfund\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" displays the message at the end of each \fBnpm install\fR acknowledging the number of dependencies looking for funding. See npm help fund for details.
.SS "\fBdry-run\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, \fBinstall\fR, \fBupdate\fR, \fBdedupe\fR, \fBuninstall\fR, as well as \fBpack\fR and \fBpublish\fR.
.P
Note: This is NOT honored by other network related commands, eg \fBdist-tags\fR, \fBowner\fR, etc.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBinstall-links\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help developers
.IP \(bu 4
\fBpackage.json\fR \fI\(la/configuring-npm/package-json\(ra\fR
.IP \(bu 4
npm help install
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.RE 0
                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/npm/man/man1/npm-login.1                                                           0000664 0000000 0000000 00000004455 14746647661 0017703 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-LOGIN" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-login\fR - Login to a registry user account
.SS "Synopsis"
.P
.RS 2
.nf
npm login
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Verify a user in the specified registry, and save the credentials to the \fB.npmrc\fR file. If no registry is specified, the default registry will be used (see npm help config).
.P
When using \fBlegacy\fR for your \fBauth-type\fR, the username and password, are read in from prompts.
.P
To reset your password, go to \fI\(lahttps://www.npmjs.com/forgot\(ra\fR
.P
To change your email address, go to \fI\(lahttps://www.npmjs.com/email-edit\(ra\fR
.P
You may use this command multiple times with the same user account to authorize on a new machine. When authenticating on a new machine, the username, password and email address must all match with your existing record.
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBscope\fR"
.RS 0
.IP \(bu 4
Default: the scope of the current project, if any, or ""
.IP \(bu 4
Type: String
.RE 0

.P
Associate an operation with a scope for a scoped registry.
.P
Useful when logging in to or out of a private registry:
.P
.RS 2
.nf
# log in, linking the scope to the custom registry
npm login --scope=@mycorp --registry=https://registry.mycorp.com

# log out, removing the link and the auth token
npm logout --scope=@mycorp
.fi
.RE
.P
This will cause \fB@mycorp\fR to be mapped to the registry for future installation of packages specified according to the pattern \fB@mycorp/package\fR.
.P
This will also cause \fBnpm init\fR to create a scoped package.
.P
.RS 2
.nf
# accept all defaults, and create a package named "@foo/whatever",
# instead of just named "whatever"
npm init --scope=@foo --yes
.fi
.RE
.SS "\fBauth-type\fR"
.RS 0
.IP \(bu 4
Default: "web"
.IP \(bu 4
Type: "legacy" or "web"
.RE 0

.P
What authentication strategy to use with \fBlogin\fR. Note that if an \fBotp\fR config is given, this value will always be set to \fBlegacy\fR.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help owner
.IP \(bu 4
npm help whoami
.IP \(bu 4
npm help token
.IP \(bu 4
npm help profile
.RE 0
                                                                                                                                                                                                                   node-23.7.0/deps/npm/man/man1/npm-logout.1                                                          0000664 0000000 0000000 00000003543 14746647661 0020101 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-LOGOUT" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-logout\fR - Log out of the registry
.SS "Synopsis"
.P
.RS 2
.nf
npm logout
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
When logged into a registry that supports token-based authentication, tell the server to end this token's session. This will invalidate the token everywhere you're using it, not just for the current environment.
.P
When logged into a legacy registry that uses username and password authentication, this will clear the credentials in your user configuration. In this case, it will \fIonly\fR affect the current environment.
.P
If \fB--scope\fR is provided, this will find the credentials for the registry connected to that scope, if set.
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBscope\fR"
.RS 0
.IP \(bu 4
Default: the scope of the current project, if any, or ""
.IP \(bu 4
Type: String
.RE 0

.P
Associate an operation with a scope for a scoped registry.
.P
Useful when logging in to or out of a private registry:
.P
.RS 2
.nf
# log in, linking the scope to the custom registry
npm login --scope=@mycorp --registry=https://registry.mycorp.com

# log out, removing the link and the auth token
npm logout --scope=@mycorp
.fi
.RE
.P
This will cause \fB@mycorp\fR to be mapped to the registry for future installation of packages specified according to the pattern \fB@mycorp/package\fR.
.P
This will also cause \fBnpm init\fR to create a scoped package.
.P
.RS 2
.nf
# accept all defaults, and create a package named "@foo/whatever",
# instead of just named "whatever"
npm init --scope=@foo --yes
.fi
.RE
.SS "See Also"
.RS 0
.IP \(bu 4
npm help adduser
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help config
.IP \(bu 4
npm help whoami
.RE 0
                                                                                                                                                             node-23.7.0/deps/npm/man/man1/npm-ls.1                                                              0000664 0000000 0000000 00000022317 14746647661 0017206 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-LS" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-ls\fR - List installed packages
.SS "Synopsis"
.P
.RS 2
.nf
npm ls <package-spec>

alias: list
.fi
.RE
.SS "Description"
.P
This command will print to stdout all the versions of packages that are installed, as well as their dependencies when \fB--all\fR is specified, in a tree structure.
.P
Note: to get a "bottoms up" view of why a given package is included in the tree at all, use npm help explain.
.P
Positional arguments are \fBname@version-range\fR identifiers, which will limit the results to only the paths to the packages named. Note that nested packages will \fIalso\fR show the paths to the specified packages. For example, running \fBnpm ls promzard\fR in npm's source tree will show:
.P
.RS 2
.nf
npm@10.9.2 /path/to/npm
└─┬ init-package-json@0.0.4
  └── promzard@0.1.5
.fi
.RE
.P
It will print out extraneous, missing, and invalid packages.
.P
If a project specifies git urls for dependencies these are shown in parentheses after the \fBname@version\fR to make it easier for users to recognize potential forks of a project.
.P
The tree shown is the logical dependency tree, based on package dependencies, not the physical layout of your \fBnode_modules\fR folder.
.P
When run as \fBll\fR or \fBla\fR, it shows extended information by default.
.SS "Note: Design Changes Pending"
.P
The \fBnpm ls\fR command's output and behavior made a \fIton\fR of sense when npm created a \fBnode_modules\fR folder that naively nested every dependency. In such a case, the logical dependency graph and physical tree of packages on disk would be roughly identical.
.P
With the advent of automatic install-time deduplication of dependencies in npm v3, the \fBls\fR output was modified to display the logical dependency graph as a tree structure, since this was more useful to most users. However, without using \fBnpm ls -l\fR, it became impossible to show \fIwhere\fR a package was actually installed much of the time!
.P
With the advent of automatic installation of \fBpeerDependencies\fR in npm v7, this gets even more curious, as \fBpeerDependencies\fR are logically "underneath" their dependents in the dependency graph, but are always physically at or above their location on disk.
.P
Also, in the years since npm got an \fBls\fR command (in version 0.0.2!), dependency graphs have gotten much larger as a general rule. Therefore, in order to avoid dumping an excessive amount of content to the terminal, \fBnpm
ls\fR now only shows the \fItop\fR level dependencies, unless \fB--all\fR is provided.
.P
A thorough re-examination of the use cases, intention, behavior, and output of this command, is currently underway. Expect significant changes to at least the default human-readable \fBnpm ls\fR output in npm v8.
.SS "Configuration"
.SS "\fBall\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When running \fBnpm outdated\fR and \fBnpm ls\fR, setting \fB--all\fR will show all outdated or installed packages, rather than only those directly depended upon by the current project.
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBlong\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Show extended information in \fBls\fR, \fBsearch\fR, and \fBhelp-search\fR.
.SS "\fBparseable\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Output parseable results from commands that write to standard output. For \fBnpm search\fR, this will be tab-separated table format.
.SS "\fBglobal\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Operates in "global" mode, so that packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "\fBdepth\fR"
.RS 0
.IP \(bu 4
Default: \fBInfinity\fR if \fB--all\fR is set, otherwise \fB1\fR
.IP \(bu 4
Type: null or Number
.RE 0

.P
The depth to go when recursing packages for \fBnpm ls\fR.
.P
If not set, \fBnpm ls\fR will show only the immediate dependencies of the root project. If \fB--all\fR is set, then npm will show all dependencies by default.
.SS "\fBomit\fR"
.RS 0
.IP \(bu 4
Default: 'dev' if the \fBNODE_ENV\fR environment variable is set to 'production', otherwise empty.
.IP \(bu 4
Type: "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Dependency types to omit from the installation tree on disk.
.P
Note that these dependencies \fIare\fR still resolved and added to the \fBpackage-lock.json\fR or \fBnpm-shrinkwrap.json\fR file. They are just not physically installed on disk.
.P
If a package type appears in both the \fB--include\fR and \fB--omit\fR lists, then it will be included.
.P
If the resulting omit list includes \fB'dev'\fR, then the \fBNODE_ENV\fR environment variable will be set to \fB'production'\fR for all lifecycle scripts.
.SS "\fBinclude\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: "prod", "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Option that allows for defining which types of dependencies to install.
.P
This is the inverse of \fB--omit=<type>\fR.
.P
Dependency types specified in \fB--include\fR will not be omitted, regardless of the order in which omit/include are specified on the command-line.
.SS "\fBlink\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Used with \fBnpm ls\fR, limiting output to only those packages that are linked.
.SS "\fBpackage-lock-only\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to true, the current operation will only use the \fBpackage-lock.json\fR, ignoring \fBnode_modules\fR.
.P
For \fBupdate\fR this means only the \fBpackage-lock.json\fR will be updated, instead of checking \fBnode_modules\fR and downloading dependencies.
.P
For \fBlist\fR this means the output will be based on the tree described by the \fBpackage-lock.json\fR, rather than the contents of \fBnode_modules\fR.
.SS "\fBunicode\fR"
.RS 0
.IP \(bu 4
Default: false on windows, true on mac/unix systems with a unicode locale, as defined by the \fBLC_ALL\fR, \fBLC_CTYPE\fR, or \fBLANG\fR environment variables.
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set to true, npm uses unicode characters in the tree output. When false, it uses ascii characters instead of unicode glyphs.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBinstall-links\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help explain
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help explain
.IP \(bu 4
npm help install
.IP \(bu 4
npm help link
.IP \(bu 4
npm help prune
.IP \(bu 4
npm help outdated
.IP \(bu 4
npm help update
.RE 0
                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/npm/man/man1/npm-org.1                                                             0000664 0000000 0000000 00000004412 14746647661 0017353 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-ORG" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-org\fR - Manage orgs
.SS "Synopsis"
.P
.RS 2
.nf
npm org set orgname username \[lB]developer | admin | owner\[rB]
npm org rm orgname username
npm org ls orgname \[lB]<username>\[rB]

alias: ogr
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Example"
.P
Add a new developer to an org:
.P
.RS 2
.nf
$ npm org set my-org @mx-smith
.fi
.RE
.P
Add a new admin to an org (or change a developer to an admin):
.P
.RS 2
.nf
$ npm org set my-org @mx-santos admin
.fi
.RE
.P
Remove a user from an org:
.P
.RS 2
.nf
$ npm org rm my-org mx-santos
.fi
.RE
.P
List all users in an org:
.P
.RS 2
.nf
$ npm org ls my-org
.fi
.RE
.P
List all users in JSON format:
.P
.RS 2
.nf
$ npm org ls my-org --json
.fi
.RE
.P
See what role a user has in an org:
.P
.RS 2
.nf
$ npm org ls my-org @mx-santos
.fi
.RE
.SS "Description"
.P
You can use the \fBnpm org\fR commands to manage and view users of an organization. It supports adding and removing users, changing their roles, listing them, and finding specific ones and their roles.
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBotp\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with \fBnpm access\fR.
.P
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBparseable\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Output parseable results from commands that write to standard output. For \fBnpm search\fR, this will be tab-separated table format.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "using orgs"
.IP \(bu 4
\fBDocumentation on npm Orgs\fR \fI\(lahttps://docs.npmjs.com/orgs/\(ra\fR
.RE 0
                                                                                                                                                                                                                                                      node-23.7.0/deps/npm/man/man1/npm-outdated.1                                                        0000664 0000000 0000000 00000014355 14746647661 0020404 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-OUTDATED" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-outdated\fR - Check for outdated packages
.SS "Synopsis"
.P
.RS 2
.nf
npm outdated \[lB]<package-spec> ...\[rB]
.fi
.RE
.SS "Description"
.P
This command will check the registry to see if any (or, specific) installed packages are currently outdated.
.P
By default, only the direct dependencies of the root project and direct dependencies of your configured \fIworkspaces\fR are shown. Use \fB--all\fR to find all outdated meta-dependencies as well.
.P
In the output:
.RS 0
.IP \(bu 4
\fBwanted\fR is the maximum version of the package that satisfies the semver range specified in \fBpackage.json\fR. If there's no available semver range (i.e. you're running \fBnpm outdated --global\fR, or the package isn't included in \fBpackage.json\fR), then \fBwanted\fR shows the currently-installed version.
.IP \(bu 4
\fBlatest\fR is the version of the package tagged as latest in the registry. Running \fBnpm publish\fR with no special configuration will publish the package with a dist-tag of \fBlatest\fR. This may or may not be the maximum version of the package, or the most-recently published version of the package, depending on how the package's developer manages the latest npm help dist-tag.
.IP \(bu 4
\fBlocation\fR is where in the physical tree the package is located.
.IP \(bu 4
\fBdepended by\fR shows which package depends on the displayed dependency
.IP \(bu 4
\fBpackage type\fR (when using \fB--long\fR / \fB-l\fR) tells you whether this package is a \fBdependency\fR or a dev/peer/optional dependency. Packages not included in \fBpackage.json\fR are always marked \fBdependencies\fR.
.IP \(bu 4
\fBhomepage\fR (when using \fB--long\fR / \fB-l\fR) is the \fBhomepage\fR value contained in the package's packument
.IP \(bu 4
Red means there's a newer version matching your semver requirements, so you should update now.
.IP \(bu 4
Yellow indicates that there's a newer version \fIabove\fR your semver requirements (usually new major, or new 0.x minor) so proceed with caution.
.RE 0

.SS "An example"
.P
.RS 2
.nf
$ npm outdated
Package      Current   Wanted   Latest  Location                  Depended by
glob          5.0.15   5.0.15    6.0.1  node_modules/glob         dependent-package-name
nothingness    0.0.3      git      git  node_modules/nothingness  dependent-package-name
npm            3.5.1    3.5.2    3.5.1  node_modules/npm          dependent-package-name
local-dev      0.0.3   linked   linked  local-dev                 dependent-package-name
once           1.3.2    1.3.3    1.3.3  node_modules/once         dependent-package-name
.fi
.RE
.P
With these \fBdependencies\fR:
.P
.RS 2
.nf
{
  "glob": "^5.0.15",
  "nothingness": "github:othiym23/nothingness#master",
  "npm": "^3.5.1",
  "once": "^1.3.1"
}
.fi
.RE
.P
A few things to note:
.RS 0
.IP \(bu 4
\fBglob\fR requires \fB^5\fR, which prevents npm from installing \fBglob@6\fR, which is outside the semver range.
.IP \(bu 4
Git dependencies will always be reinstalled, because of how they're specified. The installed committish might satisfy the dependency specifier (if it's something immutable, like a commit SHA), or it might not, so \fBnpm outdated\fR and \fBnpm update\fR have to fetch Git repos to check. This is why currently doing a reinstall of a Git dependency always forces a new clone and install.
.IP \(bu 4
\fBnpm@3.5.2\fR is marked as "wanted", but "latest" is \fBnpm@3.5.1\fR because npm uses dist-tags to manage its \fBlatest\fR and \fBnext\fR release channels. \fBnpm update\fR will install the \fInewest\fR version, but \fBnpm install npm\fR (with no semver range) will install whatever's tagged as \fBlatest\fR.
.IP \(bu 4
\fBonce\fR is just plain out of date. Reinstalling \fBnode_modules\fR from scratch or running \fBnpm update\fR will bring it up to spec.
.RE 0

.SS "Configuration"
.SS "\fBall\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When running \fBnpm outdated\fR and \fBnpm ls\fR, setting \fB--all\fR will show all outdated or installed packages, rather than only those directly depended upon by the current project.
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBlong\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Show extended information in \fBls\fR, \fBsearch\fR, and \fBhelp-search\fR.
.SS "\fBparseable\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Output parseable results from commands that write to standard output. For \fBnpm search\fR, this will be tab-separated table format.
.SS "\fBglobal\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Operates in "global" mode, so that packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help update
.IP \(bu 4
npm help dist-tag
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help workspaces
.RE 0
                                                                                                                                                                                                                                                                                   node-23.7.0/deps/npm/man/man1/npm-owner.1                                                           0000664 0000000 0000000 00000006447 14746647661 0017730 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-OWNER" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-owner\fR - Manage package owners
.SS "Synopsis"
.P
.RS 2
.nf
npm owner add <user> <package-spec>
npm owner rm <user> <package-spec>
npm owner ls <package-spec>

alias: author
.fi
.RE
.SS "Description"
.P
Manage ownership of published packages.
.RS 0
.IP \(bu 4
ls: List all the users who have access to modify a package and push new versions. Handy when you need to know who to bug for help.
.IP \(bu 4
add: Add a new user as a maintainer of a package. This user is enabled to modify metadata, publish new versions, and add other owners.
.IP \(bu 4
rm: Remove a user from the package owner list. This immediately revokes their privileges.
.RE 0

.P
Note that there is only one level of access. Either you can modify a package, or you can't. Future versions may contain more fine-grained access levels, but that is not implemented at this time.
.P
If you have two-factor authentication enabled with \fBauth-and-writes\fR (see npm help npm-profile) then you'll need to go through a second factor flow when changing ownership or include an otp on the command line with \fB--otp\fR.
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBotp\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with \fBnpm access\fR.
.P
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help profile
.IP \(bu 4
npm help publish
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help adduser
.RE 0
                                                                                                                                                                                                                         node-23.7.0/deps/npm/man/man1/npm-pack.1                                                            0000664 0000000 0000000 00000007450 14746647661 0017507 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-PACK" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-pack\fR - Create a tarball from a package
.SS "Synopsis"
.P
.RS 2
.nf
npm pack <package-spec>
.fi
.RE
.SS "Configuration"
.SS "\fBdry-run\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, \fBinstall\fR, \fBupdate\fR, \fBdedupe\fR, \fBuninstall\fR, as well as \fBpack\fR and \fBpublish\fR.
.P
Note: This is NOT honored by other network related commands, eg \fBdist-tags\fR, \fBowner\fR, etc.
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBpack-destination\fR"
.RS 0
.IP \(bu 4
Default: "."
.IP \(bu 4
Type: String
.RE 0

.P
Directory in which \fBnpm pack\fR will save tarballs.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "Description"
.P
For anything that's installable (that is, a package folder, tarball, tarball url, git url, name@tag, name@version, name, or scoped name), this command will fetch it to the cache, copy the tarball to the current working directory as \fB<name>-<version>.tgz\fR, and then write the filenames out to stdout.
.P
If the same package is specified multiple times, then the file will be overwritten the second time.
.P
If no arguments are supplied, then npm packs the current package folder.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
\fBnpm-packlist package\fR \fI\(lahttp://npm.im/npm-packlist\(ra\fR
.IP \(bu 4
npm help cache
.IP \(bu 4
npm help publish
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.RE 0
                                                                                                                                                                                                                        node-23.7.0/deps/npm/man/man1/npm-ping.1                                                            0000664 0000000 0000000 00000001525 14746647661 0017523 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-PING" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-ping\fR - Ping npm registry
.SS "Synopsis"
.P
.RS 2
.nf
npm ping
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Ping the configured or given npm registry and verify authentication. If it works it will output something like:
.P
.RS 2
.nf
npm notice PING https://registry.npmjs.org/
npm notice PONG 255ms
.fi
.RE
.P
otherwise you will get an error:
.P
.RS 2
.nf
npm notice PING http://foo.com/
npm ERR! code E404
npm ERR! 404 Not Found - GET http://www.foo.com/-/ping?write=true
.fi
.RE
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help doctor
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.RE 0
                                                                                                                                                                           node-23.7.0/deps/npm/man/man1/npm-pkg.1                                                             0000664 0000000 0000000 00000021004 14746647661 0017341 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-PKG" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-pkg\fR - Manages your package.json
.SS "Synopsis"
.P
.RS 2
.nf
npm pkg set <key>=<value> \[lB]<key>=<value> ...\[rB]
npm pkg get \[lB]<key> \[lB]<key> ...\[rB]\[rB]
npm pkg delete <key> \[lB]<key> ...\[rB]
npm pkg set \[lB]<array>\[lB]<index>\[rB].<key>=<value> ...\[rB]
npm pkg set \[lB]<array>\[lB]\[rB].<key>=<value> ...\[rB]
npm pkg fix
.fi
.RE
.SS "Description"
.P
A command that automates the management of \fBpackage.json\fR files. \fBnpm pkg\fR provide 3 different sub commands that allow you to modify or retrieve values for given object keys in your \fBpackage.json\fR.
.P
The syntax to retrieve and set fields is a dot separated representation of the nested object properties to be found within your \fBpackage.json\fR, it's the same notation used in npm help view to retrieve information from the registry manifest, below you can find more examples on how to use it.
.P
Returned values are always in \fBjson\fR format.
.RS 0
.IP \(bu 4
\fBnpm pkg get <field>\fR
.P
Retrieves a value \fBkey\fR, defined in your \fBpackage.json\fR file.
.P
For example, in order to retrieve the name of the current package, you can run:
.P
.RS 2
.nf
npm pkg get name
.fi
.RE
.P
It's also possible to retrieve multiple values at once:
.P
.RS 2
.nf
npm pkg get name version
.fi
.RE
.P
You can view child fields by separating them with a period. To retrieve the value of a test \fBscript\fR value, you would run the following command:
.P
.RS 2
.nf
npm pkg get scripts.test
.fi
.RE
.P
For fields that are arrays, requesting a non-numeric field will return all of the values from the objects in the list. For example, to get all the contributor emails for a package, you would run:
.P
.RS 2
.nf
npm pkg get contributors.email
.fi
.RE
.P
You may also use numeric indices in square braces to specifically select an item in an array field. To just get the email address of the first contributor in the list, you can run:
.P
.RS 2
.nf
npm pkg get contributors\[lB]0\[rB].email
.fi
.RE
.P
For complex fields you can also name a property in square brackets to specifically select a child field. This is especially helpful with the exports object:
.P
.RS 2
.nf
npm pkg get "exports\[lB].\[rB].require"
.fi
.RE
.IP \(bu 4
\fBnpm pkg set <field>=<value>\fR
.P
Sets a \fBvalue\fR in your \fBpackage.json\fR based on the \fBfield\fR value. When saving to your \fBpackage.json\fR file the same set of rules used during \fBnpm install\fR and other cli commands that touches the \fBpackage.json\fR file are used, making sure to respect the existing indentation and possibly applying some validation prior to saving values to the file.
.P
The same syntax used to retrieve values from your package can also be used to define new properties or overriding existing ones, below are some examples of how the dot separated syntax can be used to edit your \fBpackage.json\fR file.
.P
Defining a new bin named \fBmynewcommand\fR in your \fBpackage.json\fR that points to a file \fBcli.js\fR:
.P
.RS 2
.nf
npm pkg set bin.mynewcommand=cli.js
.fi
.RE
.P
Setting multiple fields at once is also possible:
.P
.RS 2
.nf
npm pkg set description='Awesome package' engines.node='>=10'
.fi
.RE
.P
It's also possible to add to array values, for example to add a new contributor entry:
.P
.RS 2
.nf
npm pkg set contributors\[lB]0\[rB].name='Foo' contributors\[lB]0\[rB].email='foo@bar.ca'
.fi
.RE
.P
You may also append items to the end of an array using the special empty bracket notation:
.P
.RS 2
.nf
npm pkg set contributors\[lB]\[rB].name='Foo' contributors\[lB]\[rB].name='Bar'
.fi
.RE
.P
It's also possible to parse values as json prior to saving them to your \fBpackage.json\fR file, for example in order to set a \fB"private": true\fR property:
.P
.RS 2
.nf
npm pkg set private=true --json
.fi
.RE
.P
It also enables saving values as numbers:
.P
.RS 2
.nf
npm pkg set tap.timeout=60 --json
.fi
.RE
.IP \(bu 4
\fBnpm pkg delete <key>\fR
.P
Deletes a \fBkey\fR from your \fBpackage.json\fR
.P
The same syntax used to set values from your package can also be used to remove existing ones. For example, in order to remove a script named build:
.P
.RS 2
.nf
npm pkg delete scripts.build
.fi
.RE
.IP \(bu 4
\fBnpm pkg fix\fR
.P
Auto corrects common errors in your \fBpackage.json\fR. npm already does this during \fBpublish\fR, which leads to subtle (mostly harmless) differences between the contents of your \fBpackage.json\fR file and the manifest that npm uses during installation.
.RE 0

.SS "Workspaces support"
.P
You can set/get/delete items across your configured workspaces by using the \fB\fBworkspace\fR\fR \fI\(la/using-npm/config#workspace\(ra\fR or \fB\fBworkspaces\fR\fR \fI\(la/using-npm/config#workspaces\(ra\fR config options.
.P
For example, setting a \fBfunding\fR value across all configured workspaces of a project:
.P
.RS 2
.nf
npm pkg set funding=https://example.com --ws
.fi
.RE
.P
When using \fBnpm pkg get\fR to retrieve info from your configured workspaces, the returned result will be in a json format in which top level keys are the names of each workspace, the values of these keys will be the result values returned from each of the configured workspaces, e.g:
.P
.RS 2
.nf
npm pkg get name version --ws
{
  "a": {
    "name": "a",
    "version": "1.0.0"
  },
  "b": {
    "name": "b",
    "version": "1.0.0"
  }
}
.fi
.RE
.SS "Configuration"
.SS "\fBforce\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Removes various protections against unfortunate side effects, common mistakes, unnecessary performance degradation, and malicious input.
.RS 0
.IP \(bu 4
Allow clobbering non-npm files in global installs.
.IP \(bu 4
Allow the \fBnpm version\fR command to work on an unclean git repository.
.IP \(bu 4
Allow deleting the cache folder with \fBnpm cache clean\fR.
.IP \(bu 4
Allow installing packages that have an \fBengines\fR declaration requiring a different version of npm.
.IP \(bu 4
Allow installing packages that have an \fBengines\fR declaration requiring a different version of \fBnode\fR, even if \fB--engine-strict\fR is enabled.
.IP \(bu 4
Allow \fBnpm audit fix\fR to install modules outside your stated dependency range (including SemVer-major changes).
.IP \(bu 4
Allow unpublishing all versions of a published package.
.IP \(bu 4
Allow conflicting peerDependencies to be installed in the root project.
.IP \(bu 4
Implicitly set \fB--yes\fR during \fBnpm init\fR.
.IP \(bu 4
Allow clobbering existing values in \fBnpm pkg\fR
.IP \(bu 4
Allow unpublishing of entire packages (not just a single version).
.RE 0

.P
If you don't have a clear idea of what you want to do, it is strongly recommended that you do not use this option!
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SH "SEE ALSO"
.RS 0
.IP \(bu 4
npm help install
.IP \(bu 4
npm help init
.IP \(bu 4
npm help config
.IP \(bu 4
npm help workspaces
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/npm/man/man1/npm-prefix.1                                                          0000664 0000000 0000000 00000002451 14746647661 0020062 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-PREFIX" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-prefix\fR - Display prefix
.SS "Synopsis"
.P
.RS 2
.nf
npm prefix \[lB]-g\[rB]
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Print the local prefix to standard output. This is the closest parent directory to contain a \fBpackage.json\fR file or \fBnode_modules\fR directory, unless \fB-g\fR is also specified.
.P
If \fB-g\fR is specified, this will be the value of the global prefix. See npm help config for more detail.
.SS "Example"
.P
.RS 2
.nf
npm prefix
/usr/local/projects/foo
.fi
.RE
.P
.RS 2
.nf
npm prefix -g
/usr/local
.fi
.RE
.SS "Configuration"
.SS "\fBglobal\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Operates in "global" mode, so that packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "See Also"
.RS 0
.IP \(bu 4
npm help root
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.RE 0
                                                                                                                                                                                                                       node-23.7.0/deps/npm/man/man1/npm-profile.1                                                         0000664 0000000 0000000 00000006541 14746647661 0020231 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-PROFILE" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-profile\fR - Change settings on your registry profile
.SS "Synopsis"
.P
.RS 2
.nf
npm profile enable-2fa \[lB]auth-only|auth-and-writes\[rB]
npm profile disable-2fa
npm profile get \[lB]<key>\[rB]
npm profile set <key> <value>
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Change your profile information on the registry. Note that this command depends on the registry implementation, so third-party registries may not support this interface.
.RS 0
.IP \(bu 4
\fBnpm profile get \[lB]<property>\[rB]\fR: Display all of the properties of your profile, or one or more specific properties. It looks like:
.RE 0

.P
.RS 2
.nf
name: example
email: e@example.com (verified)
two-factor auth: auth-and-writes
fullname: Example User
homepage:
freenode:
twitter:
github:
created: 2015-02-26T01:38:35.892Z
updated: 2017-10-02T21:29:45.922Z
.fi
.RE
.RS 0
.IP \(bu 4
\fBnpm profile set <property> <value>\fR: Set the value of a profile property. You can set the following properties this way: email, fullname, homepage, freenode, twitter, github
.IP \(bu 4
\fBnpm profile set password\fR: Change your password. This is interactive, you'll be prompted for your current password and a new password. You'll also be prompted for an OTP if you have two-factor authentication enabled.
.IP \(bu 4
\fBnpm profile enable-2fa \[lB]auth-and-writes|auth-only\[rB]\fR: Enables two-factor authentication. Defaults to \fBauth-and-writes\fR mode. Modes are:
.RS 4
.IP \(bu 4
\fBauth-only\fR: Require an OTP when logging in or making changes to your account's authentication. The OTP will be required on both the website and the command line.
.IP \(bu 4
\fBauth-and-writes\fR: Requires an OTP at all the times \fBauth-only\fR does, and also requires one when publishing a module, setting the \fBlatest\fR dist-tag, or changing access via \fBnpm access\fR and \fBnpm owner\fR.
.RE 0

.IP \(bu 4
\fBnpm profile disable-2fa\fR: Disables two-factor authentication.
.RE 0

.SS "Details"
.P
Some of these commands may not be available on non npmjs.com registries.
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBparseable\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Output parseable results from commands that write to standard output. For \fBnpm search\fR, this will be tab-separated table format.
.SS "\fBotp\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with \fBnpm access\fR.
.P
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help adduser
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help owner
.IP \(bu 4
npm help whoami
.IP \(bu 4
npm help token
.RE 0
                                                                                                                                                               node-23.7.0/deps/npm/man/man1/npm-prune.1                                                           0000664 0000000 0000000 00000014475 14746647661 0017727 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-PRUNE" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-prune\fR - Remove extraneous packages
.SS "Synopsis"
.P
.RS 2
.nf
npm prune \[lB]\[lB]<@scope>/\[rB]<pkg>...\[rB]
.fi
.RE
.SS "Description"
.P
This command removes "extraneous" packages. If a package name is provided, then only packages matching one of the supplied names are removed.
.P
Extraneous packages are those present in the \fBnode_modules\fR folder that are not listed as any package's dependency list.
.P
If the \fB--omit=dev\fR flag is specified or the \fBNODE_ENV\fR environment variable is set to \fBproduction\fR, this command will remove the packages specified in your \fBdevDependencies\fR.
.P
If the \fB--dry-run\fR flag is used then no changes will actually be made.
.P
If the \fB--json\fR flag is used, then the changes \fBnpm prune\fR made (or would have made with \fB--dry-run\fR) are printed as a JSON object.
.P
In normal operation, extraneous modules are pruned automatically, so you'll only need this command with the \fB--production\fR flag. However, in the real world, operation is not always "normal". When crashes or mistakes happen, this command can help clean up any resulting garbage.
.SS "Configuration"
.SS "\fBomit\fR"
.RS 0
.IP \(bu 4
Default: 'dev' if the \fBNODE_ENV\fR environment variable is set to 'production', otherwise empty.
.IP \(bu 4
Type: "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Dependency types to omit from the installation tree on disk.
.P
Note that these dependencies \fIare\fR still resolved and added to the \fBpackage-lock.json\fR or \fBnpm-shrinkwrap.json\fR file. They are just not physically installed on disk.
.P
If a package type appears in both the \fB--include\fR and \fB--omit\fR lists, then it will be included.
.P
If the resulting omit list includes \fB'dev'\fR, then the \fBNODE_ENV\fR environment variable will be set to \fB'production'\fR for all lifecycle scripts.
.SS "\fBinclude\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: "prod", "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Option that allows for defining which types of dependencies to install.
.P
This is the inverse of \fB--omit=<type>\fR.
.P
Dependency types specified in \fB--include\fR will not be omitted, regardless of the order in which omit/include are specified on the command-line.
.SS "\fBdry-run\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, \fBinstall\fR, \fBupdate\fR, \fBdedupe\fR, \fBuninstall\fR, as well as \fBpack\fR and \fBpublish\fR.
.P
Note: This is NOT honored by other network related commands, eg \fBdist-tags\fR, \fBowner\fR, etc.
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBforeground-scripts\fR"
.RS 0
.IP \(bu 4
Default: \fBfalse\fR unless when using \fBnpm pack\fR or \fBnpm publish\fR where it defaults to \fBtrue\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Run all build scripts (ie, \fBpreinstall\fR, \fBinstall\fR, and \fBpostinstall\fR) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
.P
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBinstall-links\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help uninstall
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help ls
.RE 0
                                                                                                                                                                                                   node-23.7.0/deps/npm/man/man1/npm-publish.1                                                         0000664 0000000 0000000 00000020171 14746647661 0020232 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-PUBLISH" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-publish\fR - Publish a package
.SS "Synopsis"
.P
.RS 2
.nf
npm publish <package-spec>
.fi
.RE
.SS "Description"
.P
Publishes a package to the registry so that it can be installed by name.
.P
By default npm will publish to the public registry. This can be overridden by specifying a different default registry or using a npm help scope in the name, combined with a scope-configured registry (see \fB\fBpackage.json\fR\fR \fI\(la/configuring-npm/package-json\(ra\fR).
.P
A \fBpackage\fR is interpreted the same way as other commands (like \fBnpm install\fR) and can be:
.RS 0
.IP \(bu 4
a) a folder containing a program described by a \fB\fBpackage.json\fR\fR \fI\(la/configuring-npm/package-json\(ra\fR file
.IP \(bu 4
b) a gzipped tarball containing (a)
.IP \(bu 4
c) a url that resolves to (b)
.IP \(bu 4
d) a \fB<name>@<version>\fR that is published on the registry (see npm help registry) with (c)
.IP \(bu 4
e) a \fB<name>@<tag>\fR (see npm help dist-tag) that points to (d)
.IP \(bu 4
f) a \fB<name>\fR that has a "latest" tag satisfying (e)
.IP \(bu 4
g) a \fB<git remote url>\fR that resolves to (a)
.RE 0

.P
The publish will fail if the package name and version combination already exists in the specified registry.
.P
Once a package is published with a given name and version, that specific name and version combination can never be used again, even if it is removed with npm help unpublish.
.P
As of \fBnpm@5\fR, both a sha1sum and an integrity field with a sha512sum of the tarball will be submitted to the registry during publication. Subsequent installs will use the strongest supported algorithm to verify downloads.
.P
Similar to \fB--dry-run\fR see npm help pack, which figures out the files to be included and packs them into a tarball to be uploaded to the registry.
.SS "Files included in package"
.P
To see what will be included in your package, run \fBnpm pack --dry-run\fR. All files are included by default, with the following exceptions:
.RS 0
.IP \(bu 4
Certain files that are relevant to package installation and distribution are always included. For example, \fBpackage.json\fR, \fBREADME.md\fR, \fBLICENSE\fR, and so on.
.IP \(bu 4
If there is a "files" list in \fB\fBpackage.json\fR\fR \fI\(la/configuring-npm/package-json\(ra\fR, then only the files specified will be included. (If directories are specified, then they will be walked recursively and their contents included, subject to the same ignore rules.)
.IP \(bu 4
If there is a \fB.gitignore\fR or \fB.npmignore\fR file, then ignored files in that and all child directories will be excluded from the package. If \fIboth\fR files exist, then the \fB.gitignore\fR is ignored, and only the \fB.npmignore\fR is used.
.P
\fB.npmignore\fR files follow the \fBsame pattern rules\fR \fI\(lahttps://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository#_ignoring\(ra\fR as \fB.gitignore\fR files
.IP \(bu 4
If the file matches certain patterns, then it will \fInever\fR be included, unless explicitly added to the \fB"files"\fR list in \fBpackage.json\fR, or un-ignored with a \fB!\fR rule in a \fB.npmignore\fR or \fB.gitignore\fR file.
.IP \(bu 4
Symbolic links are never included in npm packages.
.RE 0

.P
See npm help developers for full details on what's included in the published package, as well as details on how the package is built.
.SS "Configuration"
.SS "\fBtag\fR"
.RS 0
.IP \(bu 4
Default: "latest"
.IP \(bu 4
Type: String
.RE 0

.P
If you ask npm to install a package and don't tell it a specific version, then it will install the specified tag.
.P
It is the tag added to the package@version specified in the \fBnpm dist-tag
add\fR command, if no explicit tag is given.
.P
When used by the \fBnpm diff\fR command, this is the tag used to fetch the tarball that will be compared with the local files by default.
.P
If used in the \fBnpm publish\fR command, this is the tag that will be added to the package submitted to the registry.
.SS "\fBaccess\fR"
.RS 0
.IP \(bu 4
Default: 'public' for new packages, existing packages it will not change the current level
.IP \(bu 4
Type: null, "restricted", or "public"
.RE 0

.P
If you do not want your scoped package to be publicly viewable (and installable) set \fB--access=restricted\fR.
.P
Unscoped packages can not be set to \fBrestricted\fR.
.P
Note: This defaults to not changing the current access level for existing packages. Specifying a value of \fBrestricted\fR or \fBpublic\fR during publish will change the access for an existing package the same way that \fBnpm access set
status\fR would.
.SS "\fBdry-run\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, \fBinstall\fR, \fBupdate\fR, \fBdedupe\fR, \fBuninstall\fR, as well as \fBpack\fR and \fBpublish\fR.
.P
Note: This is NOT honored by other network related commands, eg \fBdist-tags\fR, \fBowner\fR, etc.
.SS "\fBotp\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with \fBnpm access\fR.
.P
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBprovenance\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When publishing from a supported cloud CI/CD system, the package will be publicly linked to where it was built and published from.
.P
This config can not be used with: \fBprovenance-file\fR
.SS "\fBprovenance-file\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: Path
.RE 0

.P
When publishing, the provenance bundle at the given path will be used.
.P
This config can not be used with: \fBprovenance\fR
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
\fBnpm-packlist package\fR \fI\(lahttp://npm.im/npm-packlist\(ra\fR
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help scope
.IP \(bu 4
npm help adduser
.IP \(bu 4
npm help owner
.IP \(bu 4
npm help deprecate
.IP \(bu 4
npm help dist-tag
.IP \(bu 4
npm help pack
.IP \(bu 4
npm help profile
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/npm/man/man1/npm-query.1                                                           0000664 0000000 0000000 00000017014 14746647661 0017733 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-QUERY" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-query\fR - Dependency selector query
.SS "Synopsis"
.P
.RS 2
.nf
npm query <selector>
.fi
.RE
.SS "Description"
.P
The \fBnpm query\fR command allows for usage of css selectors in order to retrieve an array of dependency objects.
.SS "Piping npm query to other commands"
.P
.RS 2
.nf
# find all dependencies with postinstall scripts & uninstall them
npm query ":attr(scripts, \[lB]postinstall\[rB])" | jq 'map(.name)|join("\[rs]n")' -r | xargs -I {} npm uninstall {}

# find all git dependencies & explain who requires them
npm query ":type(git)" | jq 'map(.name)' | xargs -I {} npm why {}
.fi
.RE
.SS "Extended Use Cases & Queries"
.P
.RS 2
.nf
// all deps
*

// all direct deps
:root > *

// direct production deps
:root > .prod

// direct development deps
:root > .dev

// any peer dep of a direct deps
:root > * > .peer

// any workspace dep
.workspace

// all workspaces that depend on another workspace
.workspace > .workspace

// all workspaces that have peer deps
.workspace:has(.peer)

// any dep named "lodash"
// equivalent to \[lB]name="lodash"\[rB]
#lodash

// any deps named "lodash" & within semver range ^"1.2.3"
#lodash@^1.2.3
// equivalent to...
\[lB]name="lodash"\[rB]:semver(^1.2.3)

// get the hoisted node for a given semver range
#lodash@^1.2.3:not(:deduped)

// querying deps with a specific version
#lodash@2.1.5
// equivalent to...
\[lB]name="lodash"\[rB]\[lB]version="2.1.5"\[rB]

// has any deps
:has(*)

// deps with no other deps (ie. "leaf" nodes)
:empty

// manually querying git dependencies
\[lB]repository^=github:\[rB],
\[lB]repository^=git:\[rB],
\[lB]repository^=https://github.com\[rB],
\[lB]repository^=http://github.com\[rB],
\[lB]repository^=https://github.com\[rB],
\[lB]repository^=+git:...\[rB]

// querying for all git dependencies
:type(git)

// get production dependencies that aren't also dev deps
.prod:not(.dev)

// get dependencies with specific licenses
\[lB]license=MIT\[rB], \[lB]license=ISC\[rB]

// find all packages that have @ruyadorno as a contributor
:attr(contributors, \[lB]email=ruyadorno@github.com\[rB])
.fi
.RE
.SS "Example Response Output"
.RS 0
.IP \(bu 4
an array of dependency objects is returned which can contain multiple copies of the same package which may or may not have been linked or deduped
.RE 0

.P
.RS 2
.nf
\[lB]
  {
    "name": "",
    "version": "",
    "description": "",
    "homepage": "",
    "bugs": {},
    "author": {},
    "license": {},
    "funding": {},
    "files": \[lB]\[rB],
    "main": "",
    "browser": "",
    "bin": {},
    "man": \[lB]\[rB],
    "directories": {},
    "repository": {},
    "scripts": {},
    "config": {},
    "dependencies": {},
    "devDependencies": {},
    "optionalDependencies": {},
    "bundledDependencies": {},
    "peerDependencies": {},
    "peerDependenciesMeta": {},
    "engines": {},
    "os": \[lB]\[rB],
    "cpu": \[lB]\[rB],
    "workspaces": {},
    "keywords": \[lB]\[rB],
    ...
  },
  ...
.fi
.RE
.SS "Expecting a certain number of results"
.P
One common use of \fBnpm query\fR is to make sure there is only one version of a certain dependency in your tree. This is especially common for ecosystems like that rely on \fBtypescript\fR where having state split across two different but identically-named packages causes bugs. You can use the \fB--expect-results\fR or \fB--expect-result-count\fR in your setup to ensure that npm will exit with an exit code if your tree doesn't look like you want it to.
.P
.RS 2
.nf
$ npm query '#react' --expect-result-count=1
.fi
.RE
.P
Perhaps you want to quickly check if there are any production dependencies that could be updated:
.P
.RS 2
.nf
$ npm query ':root>:outdated(in-range).prod' --no-expect-results
.fi
.RE
.SS "Package lock only mode"
.P
If package-lock-only is enabled, only the information in the package lock (or shrinkwrap) is loaded. This means that information from the package.json files of your dependencies will not be included in the result set (e.g. description, homepage, engines).
.SS "Configuration"
.SS "\fBglobal\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Operates in "global" mode, so that packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBpackage-lock-only\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to true, the current operation will only use the \fBpackage-lock.json\fR, ignoring \fBnode_modules\fR.
.P
For \fBupdate\fR this means only the \fBpackage-lock.json\fR will be updated, instead of checking \fBnode_modules\fR and downloading dependencies.
.P
For \fBlist\fR this means the output will be based on the tree described by the \fBpackage-lock.json\fR, rather than the contents of \fBnode_modules\fR.
.SS "\fBexpect-results\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Tells npm whether or not to expect results from the command. Can be either true (expect some results) or false (expect no results).
.P
This config can not be used with: \fBexpect-result-count\fR
.SS "\fBexpect-result-count\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Number
.RE 0

.P
Tells to expect a specific number of results from the command.
.P
This config can not be used with: \fBexpect-results\fR
.SH "SEE ALSO"
.RS 0
.IP \(bu 4
npm help "dependency selectors"
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/npm/man/man1/npm-rebuild.1                                                         0000664 0000000 0000000 00000013044 14746647661 0020213 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-REBUILD" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-rebuild\fR - Rebuild a package
.SS "Synopsis"
.P
.RS 2
.nf
npm rebuild \[lB]<package-spec>\[rB] ...\[rB]

alias: rb
.fi
.RE
.SS "Description"
.P
This command does the following:
.RS 0
.IP 1. 4
Execute lifecycle scripts (\fBpreinstall\fR, \fBinstall\fR, \fBpostinstall\fR, \fBprepare\fR)
.IP 2. 4
Links bins depending on whether bin links are enabled
.RE 0

.P
This command is particularly useful in scenarios including but not limited to:
.RS 0
.IP 1. 4
Installing a new version of \fBnode.js\fR, where you need to recompile all your C++ add-ons with the updated binary.
.IP 2. 4
Installing with \fB--ignore-scripts\fR and \fB--no-bin-links\fR, to explicitly choose which packages to build and/or link bins.
.RE 0

.P
If one or more package specs are provided, then only packages with a name and version matching one of the specifiers will be rebuilt.
.P
Usually, you should not need to run \fBnpm rebuild\fR as it is already done for you as part of npm install (unless you suppressed these steps with \fB--ignore-scripts\fR or \fB--no-bin-links\fR).
.P
If there is a \fBbinding.gyp\fR file in the root of your package, then npm will use a default install hook:
.P
.RS 2
.nf
"scripts": {
    "install": "node-gyp rebuild"
}
.fi
.RE
.P
This default behavior is suppressed if the \fBpackage.json\fR has its own \fBinstall\fR or \fBpreinstall\fR scripts. It is also suppressed if the package specifies \fB"gypfile": false\fR
.SS "Configuration"
.SS "\fBglobal\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Operates in "global" mode, so that packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "\fBbin-links\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
Tells npm to create symlinks (or \fB.cmd\fR shims on Windows) for package executables.
.P
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
.SS "\fBforeground-scripts\fR"
.RS 0
.IP \(bu 4
Default: \fBfalse\fR unless when using \fBnpm pack\fR or \fBnpm publish\fR where it defaults to \fBtrue\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Run all build scripts (ie, \fBpreinstall\fR, \fBinstall\fR, and \fBpostinstall\fR) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
.P
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBinstall-links\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help install
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/npm/man/man1/npm-repo.1                                                            0000664 0000000 0000000 00000006113 14746647661 0017531 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-REPO" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-repo\fR - Open package repository page in the browser
.SS "Synopsis"
.P
.RS 2
.nf
npm repo \[lB]<pkgname> \[lB]<pkgname> ...\[rB]\[rB]
.fi
.RE
.SS "Description"
.P
This command tries to guess at the likely location of a package's repository URL, and then tries to open it using the \fB\fB--browser\fR config\fR \fI\(la/using-npm/config#browser\(ra\fR param. If no package name is provided, it will search for a \fBpackage.json\fR in the current folder and use the \fBrepository\fR property.
.SS "Configuration"
.SS "\fBbrowser\fR"
.RS 0
.IP \(bu 4
Default: OS X: \fB"open"\fR, Windows: \fB"start"\fR, Others: \fB"xdg-open"\fR
.IP \(bu 4
Type: null, Boolean, or String
.RE 0

.P
The browser that is called by npm commands to open websites.
.P
Set to \fBfalse\fR to suppress browser behavior and instead print urls to terminal.
.P
Set to \fBtrue\fR to use default system URL opener.
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help docs
.IP \(bu 4
npm help config
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/npm/man/man1/npm-restart.1                                                         0000664 0000000 0000000 00000003261 14746647661 0020251 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-RESTART" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-restart\fR - Restart a package
.SS "Synopsis"
.P
.RS 2
.nf
npm restart \[lB]-- <args>\[rB]
.fi
.RE
.SS "Description"
.P
This restarts a project. It is equivalent to running \fBnpm run-script
restart\fR.
.P
If the current project has a \fB"restart"\fR script specified in \fBpackage.json\fR, then the following scripts will be run:
.RS 0
.IP 1. 4
prerestart
.IP 2. 4
restart
.IP 3. 4
postrestart
.RE 0

.P
If it does \fInot\fR have a \fB"restart"\fR script specified, but it does have \fBstop\fR and/or \fBstart\fR scripts, then the following scripts will be run:
.RS 0
.IP 1. 4
prerestart
.IP 2. 4
prestop
.IP 3. 4
stop
.IP 4. 4
poststop
.IP 5. 4
prestart
.IP 6. 4
start
.IP 7. 4
poststart
.IP 8. 4
postrestart
.RE 0

.SS "Configuration"
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBscript-shell\fR"
.RS 0
.IP \(bu 4
Default: '/bin/sh' on POSIX systems, 'cmd.exe' on Windows
.IP \(bu 4
Type: null or String
.RE 0

.P
The shell to use for scripts run with the \fBnpm exec\fR, \fBnpm run\fR and \fBnpm
init <package-spec>\fR commands.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help run-script
.IP \(bu 4
npm help scripts
.IP \(bu 4
npm help test
.IP \(bu 4
npm help start
.IP \(bu 4
npm help stop
.IP \(bu 4
npm help restart
.RE 0
                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/npm/man/man1/npm-root.1                                                            0000664 0000000 0000000 00000002256 14746647661 0017553 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-ROOT" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-root\fR - Display npm root
.SS "Synopsis"
.P
.RS 2
.nf
npm root
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Print the effective \fBnode_modules\fR folder to standard out.
.P
Useful for using npm in shell scripts that do things with the \fBnode_modules\fR folder. For example:
.P
.RS 2
.nf
#!/bin/bash
global_node_modules="$(npm root --global)"
echo "Global packages installed in: ${global_node_modules}"
.fi
.RE
.SS "Configuration"
.SS "\fBglobal\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Operates in "global" mode, so that packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "See Also"
.RS 0
.IP \(bu 4
npm help prefix
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.RE 0
                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/npm/man/man1/npm-run-script.1                                                      0000664 0000000 0000000 00000020275 14746647661 0020677 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-RUN-SCRIPT" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-run-script\fR - Run arbitrary package scripts
.SS "Synopsis"
.P
.RS 2
.nf
npm run-script <command> \[lB]-- <args>\[rB]

aliases: run, rum, urn
.fi
.RE
.SS "Description"
.P
This runs an arbitrary command from a package's \fB"scripts"\fR object. If no \fB"command"\fR is provided, it will list the available scripts.
.P
\fBrun\[lB]-script\[rB]\fR is used by the test, start, restart, and stop commands, but can be called directly, as well. When the scripts in the package are printed out, they're separated into lifecycle (test, start, restart) and directly-run scripts.
.P
Any positional arguments are passed to the specified script. Use \fB--\fR to pass \fB-\fR-prefixed flags and options which would otherwise be parsed by npm.
.P
For example:
.P
.RS 2
.nf
npm run test -- --grep="pattern"
.fi
.RE
.P
The arguments will only be passed to the script specified after \fBnpm run\fR and not to any \fBpre\fR or \fBpost\fR script.
.P
The \fBenv\fR script is a special built-in command that can be used to list environment variables that will be available to the script at runtime. If an "env" command is defined in your package, it will take precedence over the built-in.
.P
In addition to the shell's pre-existing \fBPATH\fR, \fBnpm run\fR adds \fBnode_modules/.bin\fR to the \fBPATH\fR provided to scripts. Any binaries provided by locally-installed dependencies can be used without the \fBnode_modules/.bin\fR prefix. For example, if there is a \fBdevDependency\fR on \fBtap\fR in your package, you should write:
.P
.RS 2
.nf
"scripts": {"test": "tap test/*.js"}
.fi
.RE
.P
instead of
.P
.RS 2
.nf
"scripts": {"test": "node_modules/.bin/tap test/*.js"}
.fi
.RE
.P
The actual shell your script is run within is platform dependent. By default, on Unix-like systems it is the \fB/bin/sh\fR command, on Windows it is \fBcmd.exe\fR. The actual shell referred to by \fB/bin/sh\fR also depends on the system. You can customize the shell with the \fB\fBscript-shell\fR config\fR \fI\(la/using-npm/config#script-shell\(ra\fR.
.P
Scripts are run from the root of the package folder, regardless of what the current working directory is when \fBnpm run\fR is called. If you want your script to use different behavior based on what subdirectory you're in, you can use the \fBINIT_CWD\fR environment variable, which holds the full path you were in when you ran \fBnpm run\fR.
.P
\fBnpm run\fR sets the \fBNODE\fR environment variable to the \fBnode\fR executable with which \fBnpm\fR is executed.
.P
If you try to run a script without having a \fBnode_modules\fR directory and it fails, you will be given a warning to run \fBnpm install\fR, just in case you've forgotten.
.SS "Workspaces support"
.P
You may use the \fB\fBworkspace\fR\fR \fI\(la/using-npm/config#workspace\(ra\fR or \fB\fBworkspaces\fR\fR \fI\(la/using-npm/config#workspaces\(ra\fR configs in order to run an arbitrary command from a package's \fB"scripts"\fR object in the context of the specified workspaces. If no \fB"command"\fR is provided, it will list the available scripts for each of these configured workspaces.
.P
Given a project with configured workspaces, e.g:
.P
.RS 2
.nf
.
+-- package.json
`-- packages
   +-- a
   |   `-- package.json
   +-- b
   |   `-- package.json
   `-- c
       `-- package.json
.fi
.RE
.P
Assuming the workspace configuration is properly set up at the root level \fBpackage.json\fR file. e.g:
.P
.RS 2
.nf
{
    "workspaces": \[lB] "./packages/*" \[rB]
}
.fi
.RE
.P
And that each of the configured workspaces has a configured \fBtest\fR script, we can run tests in all of them using the \fB\fBworkspaces\fR config\fR \fI\(la/using-npm/config#workspaces\(ra\fR:
.P
.RS 2
.nf
npm test --workspaces
.fi
.RE
.SS "Filtering workspaces"
.P
It's also possible to run a script in a single workspace using the \fBworkspace\fR config along with a name or directory path:
.P
.RS 2
.nf
npm test --workspace=a
.fi
.RE
.P
The \fBworkspace\fR config can also be specified multiple times in order to run a specific script in the context of multiple workspaces. When defining values for the \fBworkspace\fR config in the command line, it also possible to use \fB-w\fR as a shorthand, e.g:
.P
.RS 2
.nf
npm test -w a -w b
.fi
.RE
.P
This last command will run \fBtest\fR in both \fB./packages/a\fR and \fB./packages/b\fR packages.
.SS "Configuration"
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBif-present\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm will not exit with an error code when \fBrun-script\fR is invoked for a script that isn't defined in the \fBscripts\fR section of \fBpackage.json\fR. This option can be used when it's desirable to optionally run a script when it's present and fail if the script fails. This is useful, for example, when running scripts that may only apply for some builds in an otherwise generic CI setup.
.P
This value is not exported to the environment for child processes.
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBforeground-scripts\fR"
.RS 0
.IP \(bu 4
Default: \fBfalse\fR unless when using \fBnpm pack\fR or \fBnpm publish\fR where it defaults to \fBtrue\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Run all build scripts (ie, \fBpreinstall\fR, \fBinstall\fR, and \fBpostinstall\fR) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
.P
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
.SS "\fBscript-shell\fR"
.RS 0
.IP \(bu 4
Default: '/bin/sh' on POSIX systems, 'cmd.exe' on Windows
.IP \(bu 4
Type: null or String
.RE 0

.P
The shell to use for scripts run with the \fBnpm exec\fR, \fBnpm run\fR and \fBnpm
init <package-spec>\fR commands.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help scripts
.IP \(bu 4
npm help test
.IP \(bu 4
npm help start
.IP \(bu 4
npm help restart
.IP \(bu 4
npm help stop
.IP \(bu 4
npm help config
.IP \(bu 4
npm help workspaces
.RE 0
                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/npm/man/man1/npm-sbom.1                                                            0000664 0000000 0000000 00000021450 14746647661 0017525 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-SBOM" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-sbom\fR - Generate a Software Bill of Materials (SBOM)
.SS "Synopsis"
.P
.RS 2
.nf
npm sbom
.fi
.RE
.SS "Description"
.P
The \fBnpm sbom\fR command generates a Software Bill of Materials (SBOM) listing the dependencies for the current project. SBOMs can be generated in either \fBSPDX\fR \fI\(lahttps://spdx.dev/\(ra\fR or \fBCycloneDX\fR \fI\(lahttps://cyclonedx.org/\(ra\fR format.
.SS "Example CycloneDX SBOM"
.P
.RS 2
.nf
{
  "$schema": "http://cyclonedx.org/schema/bom-1.5.schema.json",
  "bomFormat": "CycloneDX",
  "specVersion": "1.5",
  "serialNumber": "urn:uuid:09f55116-97e1-49cf-b3b8-44d0207e7730",
  "version": 1,
  "metadata": {
    "timestamp": "2023-09-01T00:00:00.001Z",
    "lifecycles": \[lB]
      {
        "phase": "build"
      }
    \[rB],
    "tools": \[lB]
      {
        "vendor": "npm",
        "name": "cli",
        "version": "10.1.0"
      }
    \[rB],
    "component": {
      "bom-ref": "simple@1.0.0",
      "type": "library",
      "name": "simple",
      "version": "1.0.0",
      "scope": "required",
      "author": "John Doe",
      "description": "simple react app",
      "purl": "pkg:npm/simple@1.0.0",
      "properties": \[lB]
        {
          "name": "cdx:npm:package:path",
          "value": ""
        }
      \[rB],
      "externalReferences": \[lB]\[rB],
      "licenses": \[lB]
        {
          "license": {
            "id": "MIT"
          }
        }
      \[rB]
    }
  },
  "components": \[lB]
    {
      "bom-ref": "lodash@4.17.21",
      "type": "library",
      "name": "lodash",
      "version": "4.17.21",
      "scope": "required",
      "author": "John-David Dalton",
      "description": "Lodash modular utilities.",
      "purl": "pkg:npm/lodash@4.17.21",
      "properties": \[lB]
        {
          "name": "cdx:npm:package:path",
          "value": "node_modules/lodash"
        }
      \[rB],
      "externalReferences": \[lB]
        {
          "type": "distribution",
          "url": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz"
        },
        {
          "type": "vcs",
          "url": "git+https://github.com/lodash/lodash.git"
        },
        {
          "type": "website",
          "url": "https://lodash.com/"
        },
        {
          "type": "issue-tracker",
          "url": "https://github.com/lodash/lodash/issues"
        }
      \[rB],
      "hashes": \[lB]
        {
          "alg": "SHA-512",
          "content": "bf690311ee7b95e713ba568322e3533f2dd1cb880b189e99d4edef13592b81764daec43e2c54c61d5c558dc5cfb35ecb85b65519e74026ff17675b6f8f916f4a"
        }
      \[rB],
      "licenses": \[lB]
        {
          "license": {
            "id": "MIT"
          }
        }
      \[rB]
    }
  \[rB],
  "dependencies": \[lB]
    {
      "ref": "simple@1.0.0",
      "dependsOn": \[lB]
        "lodash@4.17.21"
      \[rB]
    },
    {
      "ref": "lodash@4.17.21",
      "dependsOn": \[lB]\[rB]
    }
  \[rB]
}
.fi
.RE
.SS "Example SPDX SBOM"
.P
.RS 2
.nf
{
  "spdxVersion": "SPDX-2.3",
  "dataLicense": "CC0-1.0",
  "SPDXID": "SPDXRef-DOCUMENT",
  "name": "simple@1.0.0",
  "documentNamespace": "http://spdx.org/spdxdocs/simple-1.0.0-bf81090e-8bbc-459d-bec9-abeb794e096a",
  "creationInfo": {
    "created": "2023-09-01T00:00:00.001Z",
    "creators": \[lB]
      "Tool: npm/cli-10.1.0"
    \[rB]
  },
  "documentDescribes": \[lB]
    "SPDXRef-Package-simple-1.0.0"
  \[rB],
  "packages": \[lB]
    {
      "name": "simple",
      "SPDXID": "SPDXRef-Package-simple-1.0.0",
      "versionInfo": "1.0.0",
      "packageFileName": "",
      "description": "simple react app",
      "primaryPackagePurpose": "LIBRARY",
      "downloadLocation": "NOASSERTION",
      "filesAnalyzed": false,
      "homepage": "NOASSERTION",
      "licenseDeclared": "MIT",
      "externalRefs": \[lB]
        {
          "referenceCategory": "PACKAGE-MANAGER",
          "referenceType": "purl",
          "referenceLocator": "pkg:npm/simple@1.0.0"
        }
      \[rB]
    },
    {
      "name": "lodash",
      "SPDXID": "SPDXRef-Package-lodash-4.17.21",
      "versionInfo": "4.17.21",
      "packageFileName": "node_modules/lodash",
      "description": "Lodash modular utilities.",
      "downloadLocation": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "filesAnalyzed": false,
      "homepage": "https://lodash.com/",
      "licenseDeclared": "MIT",
      "externalRefs": \[lB]
        {
          "referenceCategory": "PACKAGE-MANAGER",
          "referenceType": "purl",
          "referenceLocator": "pkg:npm/lodash@4.17.21"
        }
      \[rB],
      "checksums": \[lB]
        {
          "algorithm": "SHA512",
          "checksumValue": "bf690311ee7b95e713ba568322e3533f2dd1cb880b189e99d4edef13592b81764daec43e2c54c61d5c558dc5cfb35ecb85b65519e74026ff17675b6f8f916f4a"
        }
      \[rB]
    }
  \[rB],
  "relationships": \[lB]
    {
      "spdxElementId": "SPDXRef-DOCUMENT",
      "relatedSpdxElement": "SPDXRef-Package-simple-1.0.0",
      "relationshipType": "DESCRIBES"
    },
    {
      "spdxElementId": "SPDXRef-Package-simple-1.0.0",
      "relatedSpdxElement": "SPDXRef-Package-lodash-4.17.21",
      "relationshipType": "DEPENDS_ON"
    }
  \[rB]
}
.fi
.RE
.SS "Package lock only mode"
.P
If package-lock-only is enabled, only the information in the package lock (or shrinkwrap) is loaded. This means that information from the package.json files of your dependencies will not be included in the result set (e.g. description, homepage, engines).
.SS "Configuration"
.SS "\fBomit\fR"
.RS 0
.IP \(bu 4
Default: 'dev' if the \fBNODE_ENV\fR environment variable is set to 'production', otherwise empty.
.IP \(bu 4
Type: "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Dependency types to omit from the installation tree on disk.
.P
Note that these dependencies \fIare\fR still resolved and added to the \fBpackage-lock.json\fR or \fBnpm-shrinkwrap.json\fR file. They are just not physically installed on disk.
.P
If a package type appears in both the \fB--include\fR and \fB--omit\fR lists, then it will be included.
.P
If the resulting omit list includes \fB'dev'\fR, then the \fBNODE_ENV\fR environment variable will be set to \fB'production'\fR for all lifecycle scripts.
.SS "\fBpackage-lock-only\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to true, the current operation will only use the \fBpackage-lock.json\fR, ignoring \fBnode_modules\fR.
.P
For \fBupdate\fR this means only the \fBpackage-lock.json\fR will be updated, instead of checking \fBnode_modules\fR and downloading dependencies.
.P
For \fBlist\fR this means the output will be based on the tree described by the \fBpackage-lock.json\fR, rather than the contents of \fBnode_modules\fR.
.SS "\fBsbom-format\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: "cyclonedx" or "spdx"
.RE 0

.P
SBOM format to use when generating SBOMs.
.SS "\fBsbom-type\fR"
.RS 0
.IP \(bu 4
Default: "library"
.IP \(bu 4
Type: "library", "application", or "framework"
.RE 0

.P
The type of package described by the generated SBOM. For SPDX, this is the value for the \fBprimaryPackagePurpose\fR field. For CycloneDX, this is the value for the \fBtype\fR field.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SH "SEE ALSO"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help "dependency selectors"
.IP \(bu 4
\fBpackage.json\fR \fI\(la/configuring-npm/package-json\(ra\fR
.IP \(bu 4
npm help workspaces
.RE 0
                                                                                                                                                                                                                        node-23.7.0/deps/npm/man/man1/npm-search.1                                                          0000664 0000000 0000000 00000007564 14746647661 0020044 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-SEARCH" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-search\fR - Search for packages
.SS "Synopsis"
.P
.RS 2
.nf
npm search <search term> \[lB]<search term> ...\[rB]

aliases: find, s, se
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Search the registry for packages matching the search terms. \fBnpm search\fR performs a linear, incremental, lexically-ordered search through package metadata for all files in the registry. If your terminal has color support, it will further highlight the matches in the results. This can be disabled with the config item \fBcolor\fR
.P
Additionally, using the \fB--searchopts\fR and \fB--searchexclude\fR options paired with more search terms will include and exclude further patterns. The main difference between \fB--searchopts\fR and the standard search terms is that the former does not highlight results in the output and you can use them more fine-grained filtering. Additionally, you can add both of these to your config to change default search filtering behavior.
.P
Search also allows targeting of maintainers in search results, by prefixing their npm username with \fB=\fR.
.P
If a term starts with \fB/\fR, then it's interpreted as a regular expression and supports standard JavaScript RegExp syntax. In this case search will ignore a trailing \fB/\fR . (Note you must escape or quote many regular expression characters in most shells.)
.SS "Configuration"
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBcolor\fR"
.RS 0
.IP \(bu 4
Default: true unless the NO_COLOR environ is set to something other than '0'
.IP \(bu 4
Type: "always" or Boolean
.RE 0

.P
If false, never shows colors. If \fB"always"\fR then always shows colors. If true, then only prints color codes for tty file descriptors.
.SS "\fBparseable\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Output parseable results from commands that write to standard output. For \fBnpm search\fR, this will be tab-separated table format.
.SS "\fBdescription\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
Show the description in \fBnpm search\fR
.SS "\fBsearchlimit\fR"
.RS 0
.IP \(bu 4
Default: 20
.IP \(bu 4
Type: Number
.RE 0

.P
Number of items to limit search results to. Will not apply at all to legacy searches.
.SS "\fBsearchopts\fR"
.RS 0
.IP \(bu 4
Default: ""
.IP \(bu 4
Type: String
.RE 0

.P
Space-separated options that are always passed to search.
.SS "\fBsearchexclude\fR"
.RS 0
.IP \(bu 4
Default: ""
.IP \(bu 4
Type: String
.RE 0

.P
Space-separated options that limit the results from search.
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBprefer-online\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, staleness checks for cached data will be forced, making the CLI look for updates immediately even for fresh package data.
.SS "\fBprefer-offline\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, staleness checks for cached data will be bypassed, but missing data will be requested from the server. To force full offline mode, use \fB--offline\fR.
.SS "\fBoffline\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Force offline mode: no network requests will be done during install. To allow the CLI to fill in missing cache data, see \fB--prefer-offline\fR.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help view
.IP \(bu 4
npm help cache
.IP \(bu 4
https://npm.im/npm-registry-fetch
.RE 0
                                                                                                                                            node-23.7.0/deps/npm/man/man1/npm-shrinkwrap.1                                                      0000664 0000000 0000000 00000001760 14746647661 0020757 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-SHRINKWRAP" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-shrinkwrap\fR - Lock down dependency versions for publication
.SS "Synopsis"
.P
.RS 2
.nf
npm shrinkwrap
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
This command repurposes \fBpackage-lock.json\fR into a publishable \fBnpm-shrinkwrap.json\fR or simply creates a new one. The file created and updated by this command will then take precedence over any other existing or future \fBpackage-lock.json\fR files. For a detailed explanation of the design and purpose of package locks in npm, see npm help package-lock-json.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help install
.IP \(bu 4
npm help run-script
.IP \(bu 4
npm help scripts
.IP \(bu 4
\fBpackage.json\fR \fI\(la/configuring-npm/package-json\(ra\fR
.IP \(bu 4
\fBpackage-lock.json\fR \fI\(la/configuring-npm/package-lock-json\(ra\fR
.IP \(bu 4
\fBnpm-shrinkwrap.json\fR \fI\(la/configuring-npm/npm-shrinkwrap-json\(ra\fR
.IP \(bu 4
npm help ls
.RE 0
                node-23.7.0/deps/npm/man/man1/npm-star.1                                                            0000664 0000000 0000000 00000003423 14746647661 0017536 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-STAR" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-star\fR - Mark your favorite packages
.SS "Synopsis"
.P
.RS 2
.nf
npm star \[lB]<package-spec>...\[rB]
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
"Starring" a package means that you have some interest in it. It's a vaguely positive way to show that you care.
.P
It's a boolean thing. Starring repeatedly has no additional effect.
.SS "More"
.P
There's also these extra commands to help you manage your favorite packages:
.SS "Unstar"
.P
You can also "unstar" a package using npm help unstar
.P
"Unstarring" is the same thing, but in reverse.
.SS "Listing stars"
.P
You can see all your starred packages using npm help stars
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBunicode\fR"
.RS 0
.IP \(bu 4
Default: false on windows, true on mac/unix systems with a unicode locale, as defined by the \fBLC_ALL\fR, \fBLC_CTYPE\fR, or \fBLANG\fR environment variables.
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set to true, npm uses unicode characters in the tree output. When false, it uses ascii characters instead of unicode glyphs.
.SS "\fBotp\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with \fBnpm access\fR.
.P
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help unstar
.IP \(bu 4
npm help stars
.IP \(bu 4
npm help view
.IP \(bu 4
npm help whoami
.IP \(bu 4
npm help adduser
.RE 0
                                                                                                                                                                                                                                             node-23.7.0/deps/npm/man/man1/npm-stars.1                                                           0000664 0000000 0000000 00000001437 14746647661 0017724 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-STARS" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-stars\fR - View packages marked as favorites
.SS "Synopsis"
.P
.RS 2
.nf
npm stars \[lB]<user>\[rB]
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
If you have starred a lot of neat things and want to find them again quickly this command lets you do just that.
.P
You may also want to see your friend's favorite packages, in this case you will most certainly enjoy this command.
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help star
.IP \(bu 4
npm help unstar
.IP \(bu 4
npm help view
.IP \(bu 4
npm help whoami
.IP \(bu 4
npm help adduser
.RE 0
                                                                                                                                                                                                                                 node-23.7.0/deps/npm/man/man1/npm-start.1                                                           0000664 0000000 0000000 00000003457 14746647661 0017731 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-START" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-start\fR - Start a package
.SS "Synopsis"
.P
.RS 2
.nf
npm start \[lB]-- <args>\[rB]
.fi
.RE
.SS "Description"
.P
This runs a predefined command specified in the \fB"start"\fR property of a package's \fB"scripts"\fR object.
.P
If the \fB"scripts"\fR object does not define a \fB"start"\fR property, npm will run \fBnode server.js\fR.
.P
Note that this is different from the default node behavior of running the file specified in a package's \fB"main"\fR attribute when evoking with \fBnode .\fR
.P
As of \fB\fBnpm@2.0.0\fR\fR \fI\(lahttps://blog.npmjs.org/post/98131109725/npm-2-0-0\(ra\fR, you can use custom arguments when executing scripts. Refer to npm help run-script for more details.
.SS "Example"
.P
.RS 2
.nf
{
  "scripts": {
    "start": "node foo.js"
  }
}
.fi
.RE
.P
.RS 2
.nf
npm start

> npm@x.x.x start
> node foo.js

(foo.js output would be here)

.fi
.RE
.SS "Configuration"
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBscript-shell\fR"
.RS 0
.IP \(bu 4
Default: '/bin/sh' on POSIX systems, 'cmd.exe' on Windows
.IP \(bu 4
Type: null or String
.RE 0

.P
The shell to use for scripts run with the \fBnpm exec\fR, \fBnpm run\fR and \fBnpm
init <package-spec>\fR commands.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help run-script
.IP \(bu 4
npm help scripts
.IP \(bu 4
npm help test
.IP \(bu 4
npm help restart
.IP \(bu 4
npm help stop
.RE 0
                                                                                                                                                                                                                 node-23.7.0/deps/npm/man/man1/npm-stop.1                                                            0000664 0000000 0000000 00000002676 14746647661 0017563 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-STOP" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-stop\fR - Stop a package
.SS "Synopsis"
.P
.RS 2
.nf
npm stop \[lB]-- <args>\[rB]
.fi
.RE
.SS "Description"
.P
This runs a predefined command specified in the "stop" property of a package's "scripts" object.
.P
Unlike with npm help start, there is no default script that will run if the \fB"stop"\fR property is not defined.
.SS "Example"
.P
.RS 2
.nf
{
  "scripts": {
    "stop": "node bar.js"
  }
}
.fi
.RE
.P
.RS 2
.nf
npm stop

> npm@x.x.x stop
> node bar.js

(bar.js output would be here)

.fi
.RE
.SS "Configuration"
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBscript-shell\fR"
.RS 0
.IP \(bu 4
Default: '/bin/sh' on POSIX systems, 'cmd.exe' on Windows
.IP \(bu 4
Type: null or String
.RE 0

.P
The shell to use for scripts run with the \fBnpm exec\fR, \fBnpm run\fR and \fBnpm
init <package-spec>\fR commands.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help run-script
.IP \(bu 4
npm help scripts
.IP \(bu 4
npm help test
.IP \(bu 4
npm help start
.IP \(bu 4
npm help restart
.RE 0
                                                                  node-23.7.0/deps/npm/man/man1/npm-team.1                                                            0000664 0000000 0000000 00000010633 14746647661 0017514 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-TEAM" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-team\fR - Manage organization teams and team memberships
.SS "Synopsis"
.P
.RS 2
.nf
npm team create <scope:team> \[lB]--otp <otpcode>\[rB]
npm team destroy <scope:team> \[lB]--otp <otpcode>\[rB]
npm team add <scope:team> <user> \[lB]--otp <otpcode>\[rB]
npm team rm <scope:team> <user> \[lB]--otp <otpcode>\[rB]
npm team ls <scope>|<scope:team>
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Used to manage teams in organizations, and change team memberships. Does not handle permissions for packages.
.P
Teams must always be fully qualified with the organization/scope they belong to when operating on them, separated by a colon (\fB:\fR). That is, if you have a \fBnewteam\fR team in an \fBorg\fR organization, you must always refer to that team as \fB@org:newteam\fR in these commands.
.P
If you have two-factor authentication enabled in \fBauth-and-writes\fR mode, then you can provide a code from your authenticator with \fB\[lB]--otp <otpcode>\[rB]\fR. If you don't include this then you will be taken through a second factor flow based on your \fBauthtype\fR.
.RS 0
.IP \(bu 4
create / destroy: Create a new team, or destroy an existing one. Note: You cannot remove the \fBdevelopers\fR team, \fBlearn more.\fR \fI\(lahttps://docs.npmjs.com/about-developers-team\(ra\fR
.P
Here's how to create a new team \fBnewteam\fR under the \fBorg\fR org:
.P
.RS 2
.nf
npm team create @org:newteam
.fi
.RE
.P
You should see a confirming message such as: \fB+@org:newteam\fR once the new team has been created.
.IP \(bu 4
add: Add a user to an existing team.
.P
Adding a new user \fBusername\fR to a team named \fBnewteam\fR under the \fBorg\fR org:
.P
.RS 2
.nf
npm team add @org:newteam username
.fi
.RE
.P
On success, you should see a message: \fBusername added to @org:newteam\fR
.IP \(bu 4
rm: Using \fBnpm team rm\fR you can also remove users from a team they belong to.
.P
Here's an example removing user \fBusername\fR from \fBnewteam\fR team in \fBorg\fR organization:
.P
.RS 2
.nf
npm team rm @org:newteam username
.fi
.RE
.P
Once the user is removed a confirmation message is displayed: \fBusername removed from @org:newteam\fR
.IP \(bu 4
ls: If performed on an organization name, will return a list of existing teams under that organization. If performed on a team, it will instead return a list of all users belonging to that particular team.
.P
Here's an example of how to list all teams from an org named \fBorg\fR:
.P
.RS 2
.nf
npm team ls @org
.fi
.RE
.P
Example listing all members of a team named \fBnewteam\fR:
.P
.RS 2
.nf
npm team ls @org:newteam
.fi
.RE
.RE 0

.SS "Details"
.P
\fBnpm team\fR always operates directly on the current registry, configurable from the command line using \fB--registry=<registry url>\fR.
.P
You must be a \fIteam admin\fR to create teams and manage team membership, under the given organization. Listing teams and team memberships may be done by any member of the organization.
.P
Organization creation and management of team admins and \fIorganization\fR members is done through the website, not the npm CLI.
.P
To use teams to manage permissions on packages belonging to your organization, use the \fBnpm access\fR command to grant or revoke the appropriate permissions.
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBotp\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with \fBnpm access\fR.
.P
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
.SS "\fBparseable\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Output parseable results from commands that write to standard output. For \fBnpm search\fR, this will be tab-separated table format.
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help access
.IP \(bu 4
npm help config
.IP \(bu 4
npm help registry
.RE 0
                                                                                                     node-23.7.0/deps/npm/man/man1/npm-test.1                                                            0000664 0000000 0000000 00000002547 14746647661 0017552 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-TEST" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-test\fR - Test a package
.SS "Synopsis"
.P
.RS 2
.nf
npm test \[lB]-- <args>\[rB]

aliases: tst, t
.fi
.RE
.SS "Description"
.P
This runs a predefined command specified in the \fB"test"\fR property of a package's \fB"scripts"\fR object.
.SS "Example"
.P
.RS 2
.nf
{
  "scripts": {
    "test": "node test.js"
  }
}
.fi
.RE
.P
.RS 2
.nf
npm test
> npm@x.x.x test
> node test.js

(test.js output would be here)
.fi
.RE
.SS "Configuration"
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBscript-shell\fR"
.RS 0
.IP \(bu 4
Default: '/bin/sh' on POSIX systems, 'cmd.exe' on Windows
.IP \(bu 4
Type: null or String
.RE 0

.P
The shell to use for scripts run with the \fBnpm exec\fR, \fBnpm run\fR and \fBnpm
init <package-spec>\fR commands.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help run-script
.IP \(bu 4
npm help scripts
.IP \(bu 4
npm help start
.IP \(bu 4
npm help restart
.IP \(bu 4
npm help stop
.RE 0
                                                                                                                                                         node-23.7.0/deps/npm/man/man1/npm-token.1                                                           0000664 0000000 0000000 00000006166 14746647661 0017714 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-TOKEN" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-token\fR - Manage your authentication tokens
.SS "Synopsis"
.P
.RS 2
.nf
npm token list
npm token revoke <id|token>
npm token create \[lB]--read-only\[rB] \[lB]--cidr=list\[rB]
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
This lets you list, create and revoke authentication tokens.
.RS 0
.IP \(bu 4
\fBnpm token list\fR: Shows a table of all active authentication tokens. You can request this as JSON with \fB--json\fR or tab-separated values with \fB--parseable\fR.
.RE 0

.P
.RS 2
.nf
Read only token npm_1f… with id 7f3134 created 2017-10-21

Publish token npm_af…  with id c03241 created 2017-10-02
with IP Whitelist: 192.168.0.1/24

Publish token npm_… with id e0cf92 created 2017-10-02

.fi
.RE
.RS 0
.IP \(bu 4
\fBnpm token create \[lB]--read-only\[rB] \[lB]--cidr=<cidr-ranges>\[rB]\fR: Create a new authentication token. It can be \fB--read-only\fR, or accept a list of \fBCIDR\fR \fI\(lahttps://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\(ra\fR ranges with which to limit use of this token. This will prompt you for your password, and, if you have two-factor authentication enabled, an otp.
.P
Currently, the cli can not generate automation tokens. Please refer to the \fBdocs website\fR \fI\(lahttps://docs.npmjs.com/creating-and-viewing-access-tokens\(ra\fR for more information on generating automation tokens.
.RE 0

.P
.RS 2
.nf
Created publish token a73c9572-f1b9-8983-983d-ba3ac3cc913d
.fi
.RE
.RS 0
.IP \(bu 4
\fBnpm token revoke <token|id>\fR: Immediately removes an authentication token from the registry. You will no longer be able to use it. This can accept both complete tokens (such as those you get back from \fBnpm token create\fR, and those found in your \fB.npmrc\fR), and ids as seen in the parseable or json output of \fBnpm token list\fR. This will NOT accept the truncated token found in the normal \fBnpm token list\fR output.
.RE 0

.SS "Configuration"
.SS "\fBread-only\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
This is used to mark a token as unable to publish when configuring limited access tokens with the \fBnpm token create\fR command.
.SS "\fBcidr\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String (can be set multiple times)
.RE 0

.P
This is a list of CIDR address to be used when configuring limited access tokens with the \fBnpm token create\fR command.
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBotp\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with \fBnpm access\fR.
.P
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help adduser
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help owner
.IP \(bu 4
npm help whoami
.IP \(bu 4
npm help profile
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/npm/man/man1/npm-uninstall.1                                                       0000664 0000000 0000000 00000011576 14746647661 0020606 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-UNINSTALL" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-uninstall\fR - Remove a package
.SS "Synopsis"
.P
.RS 2
.nf
npm uninstall \[lB]<@scope>/\[rB]<pkg>...

aliases: unlink, remove, rm, r, un
.fi
.RE
.SS "Description"
.P
This uninstalls a package, completely removing everything npm installed on its behalf.
.P
It also removes the package from the \fBdependencies\fR, \fBdevDependencies\fR, \fBoptionalDependencies\fR, and \fBpeerDependencies\fR objects in your \fBpackage.json\fR.
.P
Further, if you have an \fBnpm-shrinkwrap.json\fR or \fBpackage-lock.json\fR, npm will update those files as well.
.P
\fB--no-save\fR will tell npm not to remove the package from your \fBpackage.json\fR, \fBnpm-shrinkwrap.json\fR, or \fBpackage-lock.json\fR files.
.P
\fB--save\fR or \fB-S\fR will tell npm to remove the package from your \fBpackage.json\fR, \fBnpm-shrinkwrap.json\fR, and \fBpackage-lock.json\fR files. This is the default, but you may need to use this if you have for instance \fBsave=false\fR in your \fBnpmrc\fR file
.P
In global mode (ie, with \fB-g\fR or \fB--global\fR appended to the command), it uninstalls the current package context as a global package. \fB--no-save\fR is ignored in this case.
.P
Scope is optional and follows the usual rules for npm help scope.
.SS "Examples"
.P
.RS 2
.nf
npm uninstall sax
.fi
.RE
.P
\fBsax\fR will no longer be in your \fBpackage.json\fR, \fBnpm-shrinkwrap.json\fR, or \fBpackage-lock.json\fR files.
.P
.RS 2
.nf
npm uninstall lodash --no-save
.fi
.RE
.P
\fBlodash\fR will not be removed from your \fBpackage.json\fR, \fBnpm-shrinkwrap.json\fR, or \fBpackage-lock.json\fR files.
.SS "Configuration"
.SS "\fBsave\fR"
.RS 0
.IP \(bu 4
Default: \fBtrue\fR unless when using \fBnpm update\fR where it defaults to \fBfalse\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Save installed packages to a \fBpackage.json\fR file as dependencies.
.P
When used with the \fBnpm rm\fR command, removes the dependency from \fBpackage.json\fR.
.P
Will also prevent writing to \fBpackage-lock.json\fR if set to \fBfalse\fR.
.SS "\fBglobal\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Operates in "global" mode, so that packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBinstall-links\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help prune
.IP \(bu 4
npm help install
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.RE 0
                                                                                                                                  node-23.7.0/deps/npm/man/man1/npm-unpublish.1                                                       0000664 0000000 0000000 00000011450 14746647661 0020575 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-UNPUBLISH" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-unpublish\fR - Remove a package from the registry
.SS "Synopsis"
.P
.RS 2
.nf
npm unpublish \[lB]<package-spec>\[rB]
.fi
.RE
.P
To learn more about how the npm registry treats unpublish, see our \fBunpublish policies\fR \fI\(lahttps://docs.npmjs.com/policies/unpublish\(ra\fR.
.SS "Warning"
.P
Consider using the npm help deprecate command instead, if your intent is to encourage users to upgrade, or if you no longer want to maintain a package.
.SS "Description"
.P
This removes a package version from the registry, deleting its entry and removing the tarball.
.P
The npm registry will return an error if you are not npm help "logged in".
.P
If you do not specify a package name at all, the name and version to be unpublished will be pulled from the project in the current directory.
.P
If you specify a package name but do not specify a version or if you remove all of a package's versions then the registry will remove the root package entry entirely.
.P
Even if you unpublish a package version, that specific name and version combination can never be reused. In order to publish the package again, you must use a new version number. If you unpublish the entire package, you may not publish any new versions of that package until 24 hours have passed.
.SS "Configuration"
.SS "\fBdry-run\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, \fBinstall\fR, \fBupdate\fR, \fBdedupe\fR, \fBuninstall\fR, as well as \fBpack\fR and \fBpublish\fR.
.P
Note: This is NOT honored by other network related commands, eg \fBdist-tags\fR, \fBowner\fR, etc.
.SS "\fBforce\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Removes various protections against unfortunate side effects, common mistakes, unnecessary performance degradation, and malicious input.
.RS 0
.IP \(bu 4
Allow clobbering non-npm files in global installs.
.IP \(bu 4
Allow the \fBnpm version\fR command to work on an unclean git repository.
.IP \(bu 4
Allow deleting the cache folder with \fBnpm cache clean\fR.
.IP \(bu 4
Allow installing packages that have an \fBengines\fR declaration requiring a different version of npm.
.IP \(bu 4
Allow installing packages that have an \fBengines\fR declaration requiring a different version of \fBnode\fR, even if \fB--engine-strict\fR is enabled.
.IP \(bu 4
Allow \fBnpm audit fix\fR to install modules outside your stated dependency range (including SemVer-major changes).
.IP \(bu 4
Allow unpublishing all versions of a published package.
.IP \(bu 4
Allow conflicting peerDependencies to be installed in the root project.
.IP \(bu 4
Implicitly set \fB--yes\fR during \fBnpm init\fR.
.IP \(bu 4
Allow clobbering existing values in \fBnpm pkg\fR
.IP \(bu 4
Allow unpublishing of entire packages (not just a single version).
.RE 0

.P
If you don't have a clear idea of what you want to do, it is strongly recommended that you do not use this option!
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help deprecate
.IP \(bu 4
npm help publish
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help adduser
.IP \(bu 4
npm help owner
.IP \(bu 4
npm help login
.RE 0
                                                                                                                                                                                                                        node-23.7.0/deps/npm/man/man1/npm-unstar.1                                                          0000664 0000000 0000000 00000003176 14746647661 0020106 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-UNSTAR" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-unstar\fR - Remove an item from your favorite packages
.SS "Synopsis"
.P
.RS 2
.nf
npm unstar \[lB]<package-spec>...\[rB]
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
"Unstarring" a package is the opposite of npm help star, it removes an item from your list of favorite packages.
.SS "More"
.P
There's also these extra commands to help you manage your favorite packages:
.SS "Star"
.P
You can "star" a package using npm help star
.SS "Listing stars"
.P
You can see all your starred packages using npm help stars
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "\fBunicode\fR"
.RS 0
.IP \(bu 4
Default: false on windows, true on mac/unix systems with a unicode locale, as defined by the \fBLC_ALL\fR, \fBLC_CTYPE\fR, or \fBLANG\fR environment variables.
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set to true, npm uses unicode characters in the tree output. When false, it uses ascii characters instead of unicode glyphs.
.SS "\fBotp\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or String
.RE 0

.P
This is a one-time password from a two-factor authenticator. It's needed when publishing or changing package permissions with \fBnpm access\fR.
.P
If not set, and a registry response fails with a challenge for a one-time password, npm will prompt on the command line for one.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help star
.IP \(bu 4
npm help stars
.IP \(bu 4
npm help view
.IP \(bu 4
npm help whoami
.IP \(bu 4
npm help adduser
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/npm/man/man1/npm-update.1                                                          0000664 0000000 0000000 00000031653 14746647661 0020055 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-UPDATE" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-update\fR - Update packages
.SS "Synopsis"
.P
.RS 2
.nf
npm update \[lB]<pkg>...\[rB]

aliases: up, upgrade, udpate
.fi
.RE
.SS "Description"
.P
This command will update all the packages listed to the latest version (specified by the \fB\fBtag\fR config\fR \fI\(la/using-npm/config#tag\(ra\fR), respecting the semver constraints of both your package and its dependencies (if they also require the same package).
.P
It will also install missing packages.
.P
If the \fB-g\fR flag is specified, this command will update globally installed packages.
.P
If no package name is specified, all packages in the specified location (global or local) will be updated.
.P
Note that by default \fBnpm update\fR will not update the semver values of direct dependencies in your project \fBpackage.json\fR. If you want to also update values in \fBpackage.json\fR you can run: \fBnpm update --save\fR (or add the \fBsave=true\fR option to a npm help "configuration file" to make that the default behavior).
.SS "Example"
.P
For the examples below, assume that the current package is \fBapp\fR and it depends on dependencies, \fBdep1\fR (\fBdep2\fR, .. etc.). The published versions of \fBdep1\fR are:
.P
.RS 2
.nf
{
  "dist-tags": { "latest": "1.2.2" },
  "versions": \[lB]
    "1.2.2",
    "1.2.1",
    "1.2.0",
    "1.1.2",
    "1.1.1",
    "1.0.0",
    "0.4.1",
    "0.4.0",
    "0.2.0"
  \[rB]
}
.fi
.RE
.SS "Caret Dependencies"
.P
If \fBapp\fR's \fBpackage.json\fR contains:
.P
.RS 2
.nf
"dependencies": {
  "dep1": "^1.1.1"
}
.fi
.RE
.P
Then \fBnpm update\fR will install \fBdep1@1.2.2\fR, because \fB1.2.2\fR is \fBlatest\fR and \fB1.2.2\fR satisfies \fB^1.1.1\fR.
.SS "Tilde Dependencies"
.P
However, if \fBapp\fR's \fBpackage.json\fR contains:
.P
.RS 2
.nf
"dependencies": {
  "dep1": "~1.1.1"
}
.fi
.RE
.P
In this case, running \fBnpm update\fR will install \fBdep1@1.1.2\fR. Even though the \fBlatest\fR tag points to \fB1.2.2\fR, this version does not satisfy \fB~1.1.1\fR, which is equivalent to \fB>=1.1.1 <1.2.0\fR. So the highest-sorting version that satisfies \fB~1.1.1\fR is used, which is \fB1.1.2\fR.
.SS "Caret Dependencies below 1.0.0"
.P
Suppose \fBapp\fR has a caret dependency on a version below \fB1.0.0\fR, for example:
.P
.RS 2
.nf
"dependencies": {
  "dep1": "^0.2.0"
}
.fi
.RE
.P
\fBnpm update\fR will install \fBdep1@0.2.0\fR.
.P
If the dependence were on \fB^0.4.0\fR:
.P
.RS 2
.nf
"dependencies": {
  "dep1": "^0.4.0"
}
.fi
.RE
.P
Then \fBnpm update\fR will install \fBdep1@0.4.1\fR, because that is the highest-sorting version that satisfies \fB^0.4.0\fR (\fB>= 0.4.0 <0.5.0\fR)
.SS "Subdependencies"
.P
Suppose your app now also has a dependency on \fBdep2\fR
.P
.RS 2
.nf
{
  "name": "my-app",
  "dependencies": {
      "dep1": "^1.0.0",
      "dep2": "1.0.0"
  }
}
.fi
.RE
.P
and \fBdep2\fR itself depends on this limited range of \fBdep1\fR
.P
.RS 2
.nf
{
"name": "dep2",
  "dependencies": {
    "dep1": "~1.1.1"
  }
}
.fi
.RE
.P
Then \fBnpm update\fR will install \fBdep1@1.1.2\fR because that is the highest version that \fBdep2\fR allows. npm will prioritize having a single version of \fBdep1\fR in your tree rather than two when that single version can satisfy the semver requirements of multiple dependencies in your tree. In this case if you really did need your package to use a newer version you would need to use \fBnpm install\fR.
.SS "Updating Globally-Installed Packages"
.P
\fBnpm update -g\fR will apply the \fBupdate\fR action to each globally installed package that is \fBoutdated\fR -- that is, has a version that is different from \fBwanted\fR.
.P
Note: Globally installed packages are treated as if they are installed with a caret semver range specified. So if you require to update to \fBlatest\fR you may need to run \fBnpm install -g \[lB]<pkg>...\[rB]\fR
.P
NOTE: If a package has been upgraded to a version newer than \fBlatest\fR, it will be \fIdowngraded\fR.
.SS "Configuration"
.SS "\fBsave\fR"
.RS 0
.IP \(bu 4
Default: \fBtrue\fR unless when using \fBnpm update\fR where it defaults to \fBfalse\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Save installed packages to a \fBpackage.json\fR file as dependencies.
.P
When used with the \fBnpm rm\fR command, removes the dependency from \fBpackage.json\fR.
.P
Will also prevent writing to \fBpackage-lock.json\fR if set to \fBfalse\fR.
.SS "\fBglobal\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Operates in "global" mode, so that packages are installed into the \fBprefix\fR folder instead of the current working directory. See npm help folders for more on the differences in behavior.
.RS 0
.IP \(bu 4
packages are installed into the \fB{prefix}/lib/node_modules\fR folder, instead of the current working directory.
.IP \(bu 4
bin files are linked to \fB{prefix}/bin\fR
.IP \(bu 4
man pages are linked to \fB{prefix}/share/man\fR
.RE 0

.SS "\fBinstall-strategy\fR"
.RS 0
.IP \(bu 4
Default: "hoisted"
.IP \(bu 4
Type: "hoisted", "nested", "shallow", or "linked"
.RE 0

.P
Sets the strategy for installing packages in node_modules. hoisted (default): Install non-duplicated in top-level, and duplicated as necessary within directory structure. nested: (formerly --legacy-bundling) install in place, no hoisting. shallow (formerly --global-style) only install direct deps at top-level. linked: (experimental) install in node_modules/.store, link in place, unhoisted.
.SS "\fBlegacy-bundling\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=nested\fR
.RE 0

.P
Instead of hoisting package installs in \fBnode_modules\fR, install packages in the same manner that they are depended on. This may cause very deep directory structures and duplicate package installs as there is no de-duplicating. Sets \fB--install-strategy=nested\fR.
.SS "\fBglobal-style\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.IP \(bu 4
DEPRECATED: This option has been deprecated in favor of \fB--install-strategy=shallow\fR
.RE 0

.P
Only install direct dependencies in the top level \fBnode_modules\fR, but hoist on deeper dependencies. Sets \fB--install-strategy=shallow\fR.
.SS "\fBomit\fR"
.RS 0
.IP \(bu 4
Default: 'dev' if the \fBNODE_ENV\fR environment variable is set to 'production', otherwise empty.
.IP \(bu 4
Type: "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Dependency types to omit from the installation tree on disk.
.P
Note that these dependencies \fIare\fR still resolved and added to the \fBpackage-lock.json\fR or \fBnpm-shrinkwrap.json\fR file. They are just not physically installed on disk.
.P
If a package type appears in both the \fB--include\fR and \fB--omit\fR lists, then it will be included.
.P
If the resulting omit list includes \fB'dev'\fR, then the \fBNODE_ENV\fR environment variable will be set to \fB'production'\fR for all lifecycle scripts.
.SS "\fBinclude\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: "prod", "dev", "optional", or "peer" (can be set multiple times)
.RE 0

.P
Option that allows for defining which types of dependencies to install.
.P
This is the inverse of \fB--omit=<type>\fR.
.P
Dependency types specified in \fB--include\fR will not be omitted, regardless of the order in which omit/include are specified on the command-line.
.SS "\fBstrict-peer-deps\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to \fBtrue\fR, and \fB--legacy-peer-deps\fR is not set, then \fIany\fR conflicting \fBpeerDependencies\fR will be treated as an install failure, even if npm could reasonably guess the appropriate resolution based on non-peer dependency relationships.
.P
By default, conflicting \fBpeerDependencies\fR deep in the dependency graph will be resolved using the nearest non-peer dependency specification, even if doing so will result in some packages receiving a peer dependency outside the range set in their package's \fBpeerDependencies\fR object.
.P
When such an override is performed, a warning is printed, explaining the conflict and the packages involved. If \fB--strict-peer-deps\fR is set, then this warning is treated as a failure.
.SS "\fBpackage-lock\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to false, then ignore \fBpackage-lock.json\fR files when installing. This will also prevent \fIwriting\fR \fBpackage-lock.json\fR if \fBsave\fR is true.
.SS "\fBforeground-scripts\fR"
.RS 0
.IP \(bu 4
Default: \fBfalse\fR unless when using \fBnpm pack\fR or \fBnpm publish\fR where it defaults to \fBtrue\fR
.IP \(bu 4
Type: Boolean
.RE 0

.P
Run all build scripts (ie, \fBpreinstall\fR, \fBinstall\fR, and \fBpostinstall\fR) scripts for installed packages in the foreground process, sharing standard input, output, and error with the main npm process.
.P
Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.
.SS "\fBignore-scripts\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If true, npm does not run scripts specified in package.json files.
.P
Note that commands explicitly intended to run a particular script, such as \fBnpm start\fR, \fBnpm stop\fR, \fBnpm restart\fR, \fBnpm test\fR, and \fBnpm run-script\fR will still run their intended script if \fBignore-scripts\fR is set, but they will \fInot\fR run any pre- or post-scripts.
.SS "\fBaudit\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" submit audit reports alongside the current npm command to the default registry and all registries configured for scopes. See the documentation for npm help audit for details on what is submitted.
.SS "\fBbin-links\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
Tells npm to create symlinks (or \fB.cmd\fR shims on Windows) for package executables.
.P
Set to false to have it not do this. This can be used to work around the fact that some file systems don't support symlinks, even on ostensibly Unix systems.
.SS "\fBfund\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
When "true" displays the message at the end of each \fBnpm install\fR acknowledging the number of dependencies looking for funding. See npm help fund for details.
.SS "\fBdry-run\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Indicates that you don't want npm to make any changes and that it should only report what it would have done. This can be passed into any of the commands that modify your local installation, eg, \fBinstall\fR, \fBupdate\fR, \fBdedupe\fR, \fBuninstall\fR, as well as \fBpack\fR and \fBpublish\fR.
.P
Note: This is NOT honored by other network related commands, eg \fBdist-tags\fR, \fBowner\fR, etc.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "\fBinstall-links\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
When set file: protocol dependencies will be packed and installed as regular dependencies instead of creating a symlink. This option has no effect on workspaces.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help install
.IP \(bu 4
npm help outdated
.IP \(bu 4
npm help shrinkwrap
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help folders
.IP \(bu 4
npm help ls
.RE 0
                                                                                     node-23.7.0/deps/npm/man/man1/npm-version.1                                                         0000664 0000000 0000000 00000017117 14746647661 0020257 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-VERSION" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-version\fR - Bump a package version
.SS "Synopsis"
.P
.RS 2
.nf
npm version \[lB]<newversion> | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git\[rB]

alias: verison
.fi
.RE
.SS "Configuration"
.SS "\fBallow-same-version\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Prevents throwing an error when \fBnpm version\fR is used to set the new version to the same value as the current version.
.SS "\fBcommit-hooks\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
Run git commit hooks when using the \fBnpm version\fR command.
.SS "\fBgit-tag-version\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
Tag the commit when using the \fBnpm version\fR command. Setting this to false results in no commit being made at all.
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBpreid\fR"
.RS 0
.IP \(bu 4
Default: ""
.IP \(bu 4
Type: String
.RE 0

.P
The "prerelease identifier" to use as a prefix for the "prerelease" part of a semver. Like the \fBrc\fR in \fB1.2.0-rc.8\fR.
.SS "\fBsign-git-tag\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to true, then the \fBnpm version\fR command will tag the version using \fB-s\fR to add a signature.
.P
Note that git requires you to have set up GPG keys in your git configs for this to work properly.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces-update\fR"
.RS 0
.IP \(bu 4
Default: true
.IP \(bu 4
Type: Boolean
.RE 0

.P
If set to true, the npm cli will run an update after operations that may possibly change the workspaces installed to the \fBnode_modules\fR folder.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "Description"
.P
Run this in a package directory to bump the version and write the new data back to \fBpackage.json\fR, \fBpackage-lock.json\fR, and, if present, \fBnpm-shrinkwrap.json\fR.
.P
The \fBnewversion\fR argument should be a valid semver string, a valid second argument to \fBsemver.inc\fR \fI\(lahttps://github.com/npm/node-semver#functions\(ra\fR (one of \fBpatch\fR, \fBminor\fR, \fBmajor\fR, \fBprepatch\fR, \fBpreminor\fR, \fBpremajor\fR, \fBprerelease\fR), or \fBfrom-git\fR. In the second case, the existing version will be incremented by 1 in the specified field. \fBfrom-git\fR will try to read the latest git tag, and use that as the new npm version.
.P
If run in a git repo, it will also create a version commit and tag. This behavior is controlled by \fBgit-tag-version\fR (see below), and can be disabled on the command line by running \fBnpm --no-git-tag-version version\fR. It will fail if the working directory is not clean, unless the \fB-f\fR or \fB--force\fR flag is set.
.P
If supplied with \fB-m\fR or \fB\fB--message\fR config\fR \fI\(la/using-npm/config#message\(ra\fR option, npm will use it as a commit message when creating a version commit. If the \fBmessage\fR config contains \fB%s\fR then that will be replaced with the resulting version number. For example:
.P
.RS 2
.nf
npm version patch -m "Upgrade to %s for reasons"
.fi
.RE
.P
If the \fB\fBsign-git-tag\fR config\fR \fI\(la/using-npm/config#sign-git-tag\(ra\fR is set, then the tag will be signed using the \fB-s\fR flag to git. Note that you must have a default GPG key set up in your git config for this to work properly. For example:
.P
.RS 2
.nf
$ npm config set sign-git-tag true
$ npm version patch

You need a passphrase to unlock the secret key for
user: "isaacs (http://blog.izs.me/) <i@izs.me>"
2048-bit RSA key, ID 6C481CF6, created 2010-08-31

Enter passphrase:
.fi
.RE
.P
If \fBpreversion\fR, \fBversion\fR, or \fBpostversion\fR are in the \fBscripts\fR property of the package.json, they will be executed as part of running \fBnpm
version\fR.
.P
The exact order of execution is as follows:
.RS 0
.IP 1. 4
Check to make sure the git working directory is clean before we get started. Your scripts may add files to the commit in future steps. This step is skipped if the \fB--force\fR flag is set.
.IP 2. 4
Run the \fBpreversion\fR script. These scripts have access to the old \fBversion\fR in package.json. A typical use would be running your full test suite before deploying. Any files you want added to the commit should be explicitly added using \fBgit add\fR.
.IP 3. 4
Bump \fBversion\fR in \fBpackage.json\fR as requested (\fBpatch\fR, \fBminor\fR, \fBmajor\fR, etc).
.IP 4. 4
Run the \fBversion\fR script. These scripts have access to the new \fBversion\fR in package.json (so they can incorporate it into file headers in generated files for example). Again, scripts should explicitly add generated files to the commit using \fBgit add\fR.
.IP 5. 4
Commit and tag.
.IP 6. 4
Run the \fBpostversion\fR script. Use it to clean up the file system or automatically push the commit and/or tag.
.RE 0

.P
Take the following example:
.P
.RS 2
.nf
{
  "scripts": {
    "preversion": "npm test",
    "version": "npm run build && git add -A dist",
    "postversion": "git push && git push --tags && rm -rf build/temp"
  }
}
.fi
.RE
.P
This runs all your tests and proceeds only if they pass. Then runs your \fBbuild\fR script, and adds everything in the \fBdist\fR directory to the commit. After the commit, it pushes the new commit and tag up to the server, and deletes the \fBbuild/temp\fR directory.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help init
.IP \(bu 4
npm help run-script
.IP \(bu 4
npm help scripts
.IP \(bu 4
\fBpackage.json\fR \fI\(la/configuring-npm/package-json\(ra\fR
.IP \(bu 4
npm help config
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/npm/man/man1/npm-view.1                                                            0000664 0000000 0000000 00000014006 14746647661 0017536 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-VIEW" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-view\fR - View registry info
.SS "Synopsis"
.P
.RS 2
.nf
npm view \[lB]<package-spec>\[rB] \[lB]<field>\[lB].subfield\[rB]...\[rB]

aliases: info, show, v
.fi
.RE
.SS "Description"
.P
This command shows data about a package and prints it to stdout.
.P
As an example, to view information about the \fBconnect\fR package from the registry, you would run:
.P
.RS 2
.nf
npm view connect
.fi
.RE
.P
The default version is \fB"latest"\fR if unspecified.
.P
Field names can be specified after the package descriptor. For example, to show the dependencies of the \fBronn\fR package at version \fB0.3.5\fR, you could do the following:
.P
.RS 2
.nf
npm view ronn@0.3.5 dependencies
.fi
.RE
.P
By default, \fBnpm view\fR shows data about the current project context (by looking for a \fBpackage.json\fR). To show field data for the current project use a file path (i.e. \fB.\fR):
.P
.RS 2
.nf
npm view . dependencies
.fi
.RE
.P
You can view child fields by separating them with a period. To view the git repository URL for the latest version of \fBnpm\fR, you would run the following command:
.P
.RS 2
.nf
npm view npm repository.url
.fi
.RE
.P
This makes it easy to view information about a dependency with a bit of shell scripting. For example, to view all the data about the version of \fBopts\fR that \fBronn\fR depends on, you could write the following:
.P
.RS 2
.nf
npm view opts@$(npm view ronn dependencies.opts)
.fi
.RE
.P
For fields that are arrays, requesting a non-numeric field will return all of the values from the objects in the list. For example, to get all the contributor email addresses for the \fBexpress\fR package, you would run:
.P
.RS 2
.nf
npm view express contributors.email
.fi
.RE
.P
You may also use numeric indices in square braces to specifically select an item in an array field. To just get the email address of the first contributor in the list, you can run:
.P
.RS 2
.nf
npm view express contributors\[lB]0\[rB].email
.fi
.RE
.P
If the field value you are querying for is a property of an object, you should run:
.P
.RS 2
.nf
npm view express time'\[lB]4.8.0\[rB]'
.fi
.RE
.P
Multiple fields may be specified, and will be printed one after another. For example, to get all the contributor names and email addresses, you can do this:
.P
.RS 2
.nf
npm view express contributors.name contributors.email
.fi
.RE
.P
"Person" fields are shown as a string if they would be shown as an object. So, for example, this will show the list of \fBnpm\fR contributors in the shortened string format. (See \fB\fBpackage.json\fR\fR \fI\(la/configuring-npm/package-json\(ra\fR for more on this.)
.P
.RS 2
.nf
npm view npm contributors
.fi
.RE
.P
If a version range is provided, then data will be printed for every matching version of the package. This will show which version of \fBjsdom\fR was required by each matching version of \fByui3\fR:
.P
.RS 2
.nf
npm view yui3@'>0.5.4' dependencies.jsdom
.fi
.RE
.P
To show the \fBconnect\fR package version history, you can do this:
.P
.RS 2
.nf
npm view connect versions
.fi
.RE
.SS "Configuration"
.SS "\fBjson\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Whether or not to output JSON data, rather than the normal output.
.RS 0
.IP \(bu 4
In \fBnpm pkg set\fR it enables parsing set values with JSON.parse() before saving them to your \fBpackage.json\fR.
.RE 0

.P
Not supported by all npm commands.
.SS "\fBworkspace\fR"
.RS 0
.IP \(bu 4
Default:
.IP \(bu 4
Type: String (can be set multiple times)
.RE 0

.P
Enable running a command in the context of the configured workspaces of the current project while filtering by running only the workspaces defined by this configuration option.
.P
Valid values for the \fBworkspace\fR config are either:
.RS 0
.IP \(bu 4
Workspace names
.IP \(bu 4
Path to a workspace directory
.IP \(bu 4
Path to a parent workspace directory (will result in selecting all workspaces within that folder)
.RE 0

.P
When set for the \fBnpm init\fR command, this may be set to the folder of a workspace which does not yet exist, to create the folder and set it up as a brand new workspace within the project.
.P
This value is not exported to the environment for child processes.
.SS "\fBworkspaces\fR"
.RS 0
.IP \(bu 4
Default: null
.IP \(bu 4
Type: null or Boolean
.RE 0

.P
Set to true to run the command in the context of \fBall\fR configured workspaces.
.P
Explicitly setting this to false will cause commands like \fBinstall\fR to ignore workspaces altogether. When not set explicitly:
.RS 0
.IP \(bu 4
Commands that operate on the \fBnode_modules\fR tree (install, update, etc.) will link workspaces into the \fBnode_modules\fR folder. - Commands that do other things (test, exec, publish, etc.) will operate on the root project, \fIunless\fR one or more workspaces are specified in the \fBworkspace\fR config.
.RE 0

.P
This value is not exported to the environment for child processes.
.SS "\fBinclude-workspace-root\fR"
.RS 0
.IP \(bu 4
Default: false
.IP \(bu 4
Type: Boolean
.RE 0

.P
Include the workspace root when workspaces are enabled for a command.
.P
When false, specifying individual workspaces via the \fBworkspace\fR config, or all workspaces via the \fBworkspaces\fR flag, will cause npm to operate only on the specified workspaces, and not on the root project.
.P
This value is not exported to the environment for child processes.
.SS "Output"
.P
If only a single string field for a single version is output, then it will not be colorized or quoted, to enable piping the output to another command. If the field is an object, it will be output as a JavaScript object literal.
.P
If the \fB--json\fR flag is given, the outputted fields will be JSON.
.P
If the version range matches multiple versions then each printed value will be prefixed with the version it applies to.
.P
If multiple fields are requested, then each of them is prefixed with the field name.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help "package spec"
.IP \(bu 4
npm help search
.IP \(bu 4
npm help registry
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help docs
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/npm/man/man1/npm-whoami.1                                                          0000664 0000000 0000000 00000001555 14746647661 0020055 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM-WHOAMI" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm-whoami\fR - Display npm username
.SS "Synopsis"
.P
.RS 2
.nf
npm whoami
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Description"
.P
Display the npm username of the currently logged-in user.
.P
If logged into a registry that provides token-based authentication, then connect to the \fB/-/whoami\fR registry endpoint to find the username associated with the token, and print to standard output.
.P
If logged into a registry that uses Basic Auth, then simply print the \fBusername\fR portion of the authentication string.
.SS "Configuration"
.SS "\fBregistry\fR"
.RS 0
.IP \(bu 4
Default: "https://registry.npmjs.org/"
.IP \(bu 4
Type: URL
.RE 0

.P
The base URL of the npm registry.
.SS "See Also"
.RS 0
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help adduser
.RE 0
                                                                                                                                                   node-23.7.0/deps/npm/man/man1/npm.1                                                                 0000664 0000000 0000000 00000013477 14746647661 0016601 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPM" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpm\fR - javascript package manager
.SS "Synopsis"
.P
.RS 2
.nf
npm
.fi
.RE
.P
Note: This command is unaware of workspaces.
.SS "Version"
.P
10.9.2
.SS "Description"
.P
npm is the package manager for the Node JavaScript platform. It puts modules in place so that node can find them, and manages dependency conflicts intelligently.
.P
It is extremely configurable to support a variety of use cases. Most commonly, you use it to publish, discover, install, and develop node programs.
.P
Run \fBnpm help\fR to get a list of available commands.
.SS "Important"
.P
npm comes preconfigured to use npm's public registry at https://registry.npmjs.org by default. Use of the npm public registry is subject to terms of use available at https://docs.npmjs.com/policies/terms.
.P
You can configure npm to use any compatible registry you like, and even run your own registry. Use of someone else's registry is governed by their terms of use.
.SS "Introduction"
.P
You probably got npm because you want to install stuff.
.P
The very first thing you will most likely want to run in any node program is \fBnpm install\fR to install its dependencies.
.P
You can also run \fBnpm install blerg\fR to install the latest version of "blerg". Check out npm help install for more info. It can do a lot of stuff.
.P
Use the \fBnpm search\fR command to show everything that's available in the public registry. Use \fBnpm ls\fR to show everything you've installed.
.SS "Dependencies"
.P
If a package lists a dependency using a git URL, npm will install that dependency using the \fB\fBgit\fR\fR \fI\(lahttps://github.com/git-guides/install-git\(ra\fR command and will generate an error if it is not installed.
.P
If one of the packages npm tries to install is a native node module and requires compiling of C++ Code, npm will use \fBnode-gyp\fR \fI\(lahttps://github.com/nodejs/node-gyp\(ra\fR for that task. For a Unix system, \fBnode-gyp\fR \fI\(lahttps://github.com/nodejs/node-gyp\(ra\fR needs Python, make and a buildchain like GCC. On Windows, Python and Microsoft Visual Studio C++ are needed. For more information visit \fBthe node-gyp repository\fR \fI\(lahttps://github.com/nodejs/node-gyp\(ra\fR and the \fBnode-gyp Wiki\fR \fI\(lahttps://github.com/nodejs/node-gyp/wiki\(ra\fR.
.SS "Directories"
.P
See npm help folders to learn about where npm puts stuff.
.P
In particular, npm has two modes of operation:
.RS 0
.IP \(bu 4
local mode: npm installs packages into the current project directory, which defaults to the current working directory. Packages install to \fB./node_modules\fR, and bins to \fB./node_modules/.bin\fR.
.IP \(bu 4
global mode: npm installs packages into the install prefix at \fB$npm_config_prefix/lib/node_modules\fR and bins to \fB$npm_config_prefix/bin\fR.
.RE 0

.P
Local mode is the default. Use \fB-g\fR or \fB--global\fR on any command to run in global mode instead.
.SS "Developer Usage"
.P
If you're using npm to develop and publish your code, check out the following help topics:
.RS 0
.IP \(bu 4
json: Make a package.json file. See \fB\fBpackage.json\fR\fR \fI\(la/configuring-npm/package-json\(ra\fR.
.IP \(bu 4
link: Links your current working code into Node's path, so that you don't have to reinstall every time you make a change. Use npm help link to do this.
.IP \(bu 4
install: It's a good idea to install things if you don't need the symbolic link. Especially, installing other peoples code from the registry is done via npm help install
.IP \(bu 4
adduser: Create an account or log in. When you do this, npm will store credentials in the user config file.
.IP \(bu 4
publish: Use the npm help publish command to upload your code to the registry.
.RE 0

.SS "Configuration"
.P
npm is extremely configurable. It reads its configuration options from 5 places.
.RS 0
.IP \(bu 4
Command line switches: Set a config with \fB--key val\fR. All keys take a value, even if they are booleans (the config parser doesn't know what the options are at the time of parsing). If you do not provide a value (\fB--key\fR) then the option is set to boolean \fBtrue\fR.
.IP \(bu 4
Environment Variables: Set any config by prefixing the name in an environment variable with \fBnpm_config_\fR. For example, \fBexport npm_config_key=val\fR.
.IP \(bu 4
User Configs: The file at \fB$HOME/.npmrc\fR is an ini-formatted list of configs. If present, it is parsed. If the \fBuserconfig\fR option is set in the cli or env, that file will be used instead.
.IP \(bu 4
Global Configs: The file found at \fB./etc/npmrc\fR (relative to the global prefix will be parsed if it is found. See npm help prefix for more info on the global prefix. If the \fBglobalconfig\fR option is set in the cli, env, or user config, then that file is parsed instead.
.IP \(bu 4
Defaults: npm's default configuration options are defined in \fBlib/utils/config/definitions.js\fR. These must not be changed.
.RE 0

.P
See npm help config for much much more information.
.SS "Contributions"
.P
Patches welcome!
.P
If you would like to help, but don't know what to work on, read the \fBcontributing guidelines\fR \fI\(lahttps://github.com/npm/cli/blob/latest/CONTRIBUTING.md\(ra\fR and check the issues list.
.SS "Bugs"
.P
When you find issues, please report them: \fI\(lahttps://github.com/npm/cli/issues\(ra\fR
.P
Please be sure to follow the template and bug reporting guidelines.
.SS "Feature Requests"
.P
Discuss new feature ideas on our discussion forum:
.RS 0
.IP \(bu 4
\fI\(lahttps://github.com/orgs/community/discussions/categories/npm\(ra\fR
.RE 0

.P
Or suggest formal RFC proposals:
.RS 0
.IP \(bu 4
\fI\(lahttps://github.com/npm/rfcs\(ra\fR
.RE 0

.SS "See Also"
.RS 0
.IP \(bu 4
npm help help
.IP \(bu 4
\fBpackage.json\fR \fI\(la/configuring-npm/package-json\(ra\fR
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help config
.IP \(bu 4
npm help install
.IP \(bu 4
npm help prefix
.IP \(bu 4
npm help publish
.RE 0
                                                                                                                                                                                                 node-23.7.0/deps/npm/man/man1/npx.1                                                                 0000664 0000000 0000000 00000014413 14746647661 0016603 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "NPX" "1" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBnpx\fR - Run a command from a local or remote npm package
.SS "Synopsis"
.P
.RS 2
.nf
npx -- <pkg>\[lB]@<version>\[rB] \[lB]args...\[rB]
npx --package=<pkg>\[lB]@<version>\[rB] -- <cmd> \[lB]args...\[rB]
npx -c '<cmd> \[lB]args...\[rB]'
npx --package=foo -c '<cmd> \[lB]args...\[rB]'
.fi
.RE
.SS "Description"
.P
This command allows you to run an arbitrary command from an npm package (either one installed locally, or fetched remotely), in a similar context as running it via \fBnpm run\fR.
.P
Whatever packages are specified by the \fB--package\fR option will be provided in the \fBPATH\fR of the executed command, along with any locally installed package executables. The \fB--package\fR option may be specified multiple times, to execute the supplied command in an environment where all specified packages are available.
.P
If any requested packages are not present in the local project dependencies, then they are installed to a folder in the npm cache, which is added to the \fBPATH\fR environment variable in the executed process. A prompt is printed (which can be suppressed by providing either \fB--yes\fR or \fB--no\fR).
.P
Package names provided without a specifier will be matched with whatever version exists in the local project. Package names with a specifier will only be considered a match if they have the exact same name and version as the local dependency.
.P
If no \fB-c\fR or \fB--call\fR option is provided, then the positional arguments are used to generate the command string. If no \fB--package\fR options are provided, then npm will attempt to determine the executable name from the package specifier provided as the first positional argument according to the following heuristic:
.RS 0
.IP \(bu 4
If the package has a single entry in its \fBbin\fR field in \fBpackage.json\fR, or if all entries are aliases of the same command, then that command will be used.
.IP \(bu 4
If the package has multiple \fBbin\fR entries, and one of them matches the unscoped portion of the \fBname\fR field, then that command will be used.
.IP \(bu 4
If this does not result in exactly one option (either because there are no bin entries, or none of them match the \fBname\fR of the package), then \fBnpm exec\fR exits with an error.
.RE 0

.P
To run a binary \fIother than\fR the named binary, specify one or more \fB--package\fR options, which will prevent npm from inferring the package from the first command argument.
.SS "\fBnpx\fR vs \fBnpm exec\fR"
.P
When run via the \fBnpx\fR binary, all flags and options \fImust\fR be set prior to any positional arguments. When run via \fBnpm exec\fR, a double-hyphen \fB--\fR flag can be used to suppress npm's parsing of switches and options that should be sent to the executed command.
.P
For example:
.P
.RS 2
.nf
$ npx foo@latest bar --package=@npmcli/foo
.fi
.RE
.P
In this case, npm will resolve the \fBfoo\fR package name, and run the following command:
.P
.RS 2
.nf
$ foo bar --package=@npmcli/foo
.fi
.RE
.P
Since the \fB--package\fR option comes \fIafter\fR the positional arguments, it is treated as an argument to the executed command.
.P
In contrast, due to npm's argument parsing logic, running this command is different:
.P
.RS 2
.nf
$ npm exec foo@latest bar --package=@npmcli/foo
.fi
.RE
.P
In this case, npm will parse the \fB--package\fR option first, resolving the \fB@npmcli/foo\fR package. Then, it will execute the following command in that context:
.P
.RS 2
.nf
$ foo@latest bar
.fi
.RE
.P
The double-hyphen character is recommended to explicitly tell npm to stop parsing command line options and switches. The following command would thus be equivalent to the \fBnpx\fR command above:
.P
.RS 2
.nf
$ npm exec -- foo@latest bar --package=@npmcli/foo
.fi
.RE
.SS "Examples"
.P
Run the version of \fBtap\fR in the local dependencies, with the provided arguments:
.P
.RS 2
.nf
$ npm exec -- tap --bail test/foo.js
$ npx tap --bail test/foo.js
.fi
.RE
.P
Run a command \fIother than\fR the command whose name matches the package name by specifying a \fB--package\fR option:
.P
.RS 2
.nf
$ npm exec --package=foo -- bar --bar-argument
# ~ or ~
$ npx --package=foo bar --bar-argument
.fi
.RE
.P
Run an arbitrary shell script, in the context of the current project:
.P
.RS 2
.nf
$ npm x -c 'eslint && say "hooray, lint passed"'
$ npx -c 'eslint && say "hooray, lint passed"'
.fi
.RE
.SS "Compatibility with Older npx Versions"
.P
The \fBnpx\fR binary was rewritten in npm v7.0.0, and the standalone \fBnpx\fR package deprecated at that time. \fBnpx\fR uses the \fBnpm exec\fR command instead of a separate argument parser and install process, with some affordances to maintain backwards compatibility with the arguments it accepted in previous versions.
.P
This resulted in some shifts in its functionality:
.RS 0
.IP \(bu 4
Any \fBnpm\fR config value may be provided.
.IP \(bu 4
To prevent security and user-experience problems from mistyping package names, \fBnpx\fR prompts before installing anything. Suppress this prompt with the \fB-y\fR or \fB--yes\fR option.
.IP \(bu 4
The \fB--no-install\fR option is deprecated, and will be converted to \fB--no\fR.
.IP \(bu 4
Shell fallback functionality is removed, as it is not advisable.
.IP \(bu 4
The \fB-p\fR argument is a shorthand for \fB--parseable\fR in npm, but shorthand for \fB--package\fR in npx. This is maintained, but only for the \fBnpx\fR executable.
.IP \(bu 4
The \fB--ignore-existing\fR option is removed. Locally installed bins are always present in the executed process \fBPATH\fR.
.IP \(bu 4
The \fB--npm\fR option is removed. \fBnpx\fR will always use the \fBnpm\fR it ships with.
.IP \(bu 4
The \fB--node-arg\fR and \fB-n\fR options have been removed. Use \fB\fBNODE_OPTIONS\fR\fR \fI\(lahttps://nodejs.org/api/cli.html#node_optionsoptions\(ra\fR instead: e.g., \fBNODE_OPTIONS="--trace-warnings --trace-exit" npx foo --random=true\fR
.IP \(bu 4
The \fB--always-spawn\fR option is redundant, and thus removed.
.IP \(bu 4
The \fB--shell\fR option is replaced with \fB--script-shell\fR, but maintained in the \fBnpx\fR executable for backwards compatibility.
.RE 0

.SS "See Also"
.RS 0
.IP \(bu 4
npm help run-script
.IP \(bu 4
npm help scripts
.IP \(bu 4
npm help test
.IP \(bu 4
npm help start
.IP \(bu 4
npm help restart
.IP \(bu 4
npm help stop
.IP \(bu 4
npm help config
.IP \(bu 4
npm help exec
.RE 0
                                                                                                                                                                                                                                                     node-23.7.0/deps/npm/man/man5/                                                                      0000775 0000000 0000000 00000000000 14746647661 0015715 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/npm/man/man5/folders.5                                                             0000664 0000000 0000000 00000021012 14746647661 0017435 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "FOLDERS" "5" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBfolders\fR - Folder Structures Used by npm
.SS "Description"
.P
npm puts various things on your computer. That's its job.
.P
This document will tell you what it puts where.
.SS "tl;dr"
.RS 0
.IP \(bu 4
Local install (default): puts stuff in \fB./node_modules\fR of the current package root.
.IP \(bu 4
Global install (with \fB-g\fR): puts stuff in /usr/local or wherever node is installed.
.IP \(bu 4
Install it \fBlocally\fR if you're going to \fBrequire()\fR it.
.IP \(bu 4
Install it \fBglobally\fR if you're going to run it on the command line.
.IP \(bu 4
If you need both, then install it in both places, or use \fBnpm link\fR.
.RE 0

.SS "prefix Configuration"
.P
The \fB\fBprefix\fR config\fR \fI\(la/using-npm/config#prefix\(ra\fR defaults to the location where node is installed. On most systems, this is \fB/usr/local\fR. On Windows, it's \fB%AppData%\[rs]npm\fR. On Unix systems, it's one level up, since node is typically installed at \fB{prefix}/bin/node\fR rather than \fB{prefix}/node.exe\fR.
.P
When the \fBglobal\fR flag is set, npm installs things into this prefix. When it is not set, it uses the root of the current package, or the current working directory if not in a package already.
.SS "Node Modules"
.P
Packages are dropped into the \fBnode_modules\fR folder under the \fBprefix\fR. When installing locally, this means that you can \fBrequire("packagename")\fR to load its main module, or \fBrequire("packagename/lib/path/to/sub/module")\fR to load other modules.
.P
Global installs on Unix systems go to \fB{prefix}/lib/node_modules\fR. Global installs on Windows go to \fB{prefix}/node_modules\fR (that is, no \fBlib\fR folder.)
.P
Scoped packages are installed the same way, except they are grouped together in a sub-folder of the relevant \fBnode_modules\fR folder with the name of that scope prefix by the @ symbol, e.g. \fBnpm install @myorg/package\fR would place the package in \fB{prefix}/node_modules/@myorg/package\fR. See npm help scope for more details.
.P
If you wish to \fBrequire()\fR a package, then install it locally.
.SS "Executables"
.P
When in global mode, executables are linked into \fB{prefix}/bin\fR on Unix, or directly into \fB{prefix}\fR on Windows. Ensure that path is in your terminal's \fBPATH\fR environment to run them.
.P
When in local mode, executables are linked into \fB./node_modules/.bin\fR so that they can be made available to scripts run through npm. (For example, so that a test runner will be in the path when you run \fBnpm test\fR.)
.SS "Man Pages"
.P
When in global mode, man pages are linked into \fB{prefix}/share/man\fR.
.P
When in local mode, man pages are not installed.
.P
Man pages are not installed on Windows systems.
.SS "Cache"
.P
See npm help cache. Cache files are stored in \fB~/.npm\fR on Posix, or \fB%LocalAppData%/npm-cache\fR on Windows.
.P
This is controlled by the \fB\fBcache\fR config\fR \fI\(la/using-npm/config#cache\(ra\fR param.
.SS "Temp Files"
.P
Temporary files are stored by default in the folder specified by the \fB\fBtmp\fR config\fR \fI\(la/using-npm/config#tmp\(ra\fR, which defaults to the TMPDIR, TMP, or TEMP environment variables, or \fB/tmp\fR on Unix and \fBc:\[rs]windows\[rs]temp\fR on Windows.
.P
Temp files are given a unique folder under this root for each run of the program, and are deleted upon successful exit.
.SS "More Information"
.P
When installing locally, npm first tries to find an appropriate \fBprefix\fR folder. This is so that \fBnpm install foo@1.2.3\fR will install to the sensible root of your package, even if you happen to have \fBcd\fRed into some other folder.
.P
Starting at the $PWD, npm will walk up the folder tree checking for a folder that contains either a \fBpackage.json\fR file, or a \fBnode_modules\fR folder. If such a thing is found, then that is treated as the effective "current directory" for the purpose of running npm commands. (This behavior is inspired by and similar to git's .git-folder seeking logic when running git commands in a working dir.)
.P
If no package root is found, then the current folder is used.
.P
When you run \fBnpm install foo@1.2.3\fR, then the package is loaded into the cache, and then unpacked into \fB./node_modules/foo\fR. Then, any of foo's dependencies are similarly unpacked into \fB./node_modules/foo/node_modules/...\fR.
.P
Any bin files are symlinked to \fB./node_modules/.bin/\fR, so that they may be found by npm scripts when necessary.
.SS "Global Installation"
.P
If the \fB\fBglobal\fR config\fR \fI\(la/using-npm/config#global\(ra\fR is set to true, then npm will install packages "globally".
.P
For global installation, packages are installed roughly the same way, but using the folders described above.
.SS "Cycles, Conflicts, and Folder Parsimony"
.P
Cycles are handled using the property of node's module system that it walks up the directories looking for \fBnode_modules\fR folders. So, at every stage, if a package is already installed in an ancestor \fBnode_modules\fR folder, then it is not installed at the current location.
.P
Consider the case above, where \fBfoo -> bar -> baz\fR. Imagine if, in addition to that, baz depended on bar, so you'd have: \fBfoo -> bar -> baz -> bar -> baz ...\fR. However, since the folder structure is: \fBfoo/node_modules/bar/node_modules/baz\fR, there's no need to put another copy of bar into \fB.../baz/node_modules\fR, since when baz calls \fBrequire("bar")\fR, it will get the copy that is installed in \fBfoo/node_modules/bar\fR.
.P
This shortcut is only used if the exact same version would be installed in multiple nested \fBnode_modules\fR folders. It is still possible to have \fBa/node_modules/b/node_modules/a\fR if the two "a" packages are different versions. However, without repeating the exact same package multiple times, an infinite regress will always be prevented.
.P
Another optimization can be made by installing dependencies at the highest level possible, below the localized "target" folder (hoisting). Since version 3, npm hoists dependencies by default.
.SS "Example"
.P
Consider this dependency graph:
.P
.RS 2
.nf
foo
+-- blerg@1.2.5
+-- bar@1.2.3
|   +-- blerg@1.x (latest=1.3.7)
|   +-- baz@2.x
|   |   `-- quux@3.x
|   |       `-- bar@1.2.3 (cycle)
|   `-- asdf@*
`-- baz@1.2.3
    `-- quux@3.x
        `-- bar
.fi
.RE
.P
In this case, we might expect a folder structure like this (with all dependencies hoisted to the highest level possible):
.P
.RS 2
.nf
foo
+-- node_modules
    +-- blerg (1.2.5) <---\[lB]A\[rB]
    +-- bar (1.2.3) <---\[lB]B\[rB]
    |   +-- node_modules
    |       +-- baz (2.0.2) <---\[lB]C\[rB]
    +-- asdf (2.3.4)
    +-- baz (1.2.3) <---\[lB]D\[rB]
    +-- quux (3.2.0) <---\[lB]E\[rB]
.fi
.RE
.P
Since foo depends directly on \fBbar@1.2.3\fR and \fBbaz@1.2.3\fR, those are installed in foo's \fBnode_modules\fR folder.
.P
Even though the latest copy of blerg is 1.3.7, foo has a specific dependency on version 1.2.5. So, that gets installed at \[lB]A\[rB]. Since the parent installation of blerg satisfies bar's dependency on \fBblerg@1.x\fR, it does not install another copy under \[lB]B\[rB].
.P
Bar \[lB]B\[rB] also has dependencies on baz and asdf. Because it depends on \fBbaz@2.x\fR, it cannot re-use the \fBbaz@1.2.3\fR installed in the parent \fBnode_modules\fR folder \[lB]D\[rB], and must install its own copy \[lB]C\[rB]. In order to minimize duplication, npm hoists dependencies to the top level by default, so asdf is installed under \[lB]A\[rB].
.P
Underneath bar, the \fBbaz -> quux -> bar\fR dependency creates a cycle. However, because bar is already in quux's ancestry \[lB]B\[rB], it does not unpack another copy of bar into that folder. Likewise, quux's \[lB]E\[rB] folder tree is empty, because its dependency on bar is satisfied by the parent folder copy installed at \[lB]B\[rB].
.P
For a graphical breakdown of what is installed where, use \fBnpm ls\fR.
.SS "Publishing"
.P
Upon publishing, npm will look in the \fBnode_modules\fR folder. If any of the items there are not in the \fBbundleDependencies\fR array, then they will not be included in the package tarball.
.P
This allows a package maintainer to install all of their dependencies (and dev dependencies) locally, but only re-publish those items that cannot be found elsewhere. See \fB\fBpackage.json\fR\fR \fI\(la/configuring-npm/package-json\(ra\fR for more information.
.SS "See also"
.RS 0
.IP \(bu 4
\fBpackage.json\fR \fI\(la/configuring-npm/package-json\(ra\fR
.IP \(bu 4
npm help install
.IP \(bu 4
npm help pack
.IP \(bu 4
npm help cache
.IP \(bu 4
npm help config
.IP \(bu 4
npm help npmrc
.IP \(bu 4
npm help config
.IP \(bu 4
npm help publish
.RE 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/npm/man/man5/install.5                                                             0000664 0000000 0000000 00000006050 14746647661 0017452 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .TH "INSTALL" "5" "December 2024" "NPM@10.9.2" ""
.SH "NAME"
\fBinstall\fR - Download and install node and npm
.SS "Description"
.P
To publish and install packages to and from the public npm registry, you must install Node.js and the npm command line interface using either a Node version manager or a Node installer. \fBWe strongly recommend using a Node version manager to install Node.js and npm.\fR We do not recommend using a Node installer, since the Node installation process installs npm in a directory with local permissions and can cause permissions errors when you run npm packages globally.
.SS "Overview"
.RS 0
.IP \(bu 4
\fBChecking your version of npm and Node.js\fR \fI(Checking your version of npm and Node.js)\fR
.IP \(bu 4
\fBUsing a Node version manager to install Node.js and npm\fR \fI(Using a Node version manager to install Node.js and npm)\fR
.IP \(bu 4
\fBUsing a Node installer to install Node.js and npm\fR \fI(Using a Node installer to install Node.js and npm)\fR
.RE 0

.SS "Checking your version of npm and Node.js"
.P
To see if you already have Node.js and npm installed and check the installed version, run the following commands:
.P
.RS 2
.nf
node -v
npm -v
.fi
.RE
.SS "Using a Node version manager to install Node.js and npm"
.P
Node version managers allow you to install and switch between multiple versions of Node.js and npm on your system so you can test your applications on multiple versions of npm to ensure they work for users on different versions. You can \fBsearch for them on GitHub\fR \fI\(lahttps://github.com/search?q=node+version+manager+archived%3Afalse&type=repositories&ref=advsearch\(ra\fR.
.SS "Using a Node installer to install Node.js and npm"
.P
If you are unable to use a Node version manager, you can use a Node installer to install both Node.js and npm on your system.
.RS 0
.IP \(bu 4
\fBNode.js installer\fR \fI\(lahttps://nodejs.org/en/download/\(ra\fR
.IP \(bu 4
\fBNodeSource installer\fR \fI\(lahttps://github.com/nodesource/distributions\(ra\fR. If you use Linux, we recommend that you use a NodeSource installer.
.RE 0

.SS "OS X or Windows Node installers"
.P
If you're using OS X or Windows, use one of the installers from the \fBNode.js download page\fR \fI\(lahttps://nodejs.org/en/download/\(ra\fR. Be sure to install the version labeled \fBLTS\fR. Other versions have not yet been tested with npm.
.SS "Linux or other operating systems Node installers"
.P
If you're using Linux or another operating system, use one of the following installers:
.RS 0
.IP \(bu 4
\fBNodeSource installer\fR \fI\(lahttps://github.com/nodesource/distributions\(ra\fR (recommended)
.IP \(bu 4
One of the installers on the \fBNode.js download page\fR \fI\(lahttps://nodejs.org/en/download/\(ra\fR
.RE 0

.P
Or see \fBthis page\fR \fI\(lahttps://nodejs.org/en/download/package-manager/\(ra\fR to install npm for Linux in the way many Linux developers prefer.
.SS "Less-common operating systems"
.P
For more information on installing Node.js on a variety of operating systems, see \fBthis page\fR \fI\(lahttps://nodejs.o