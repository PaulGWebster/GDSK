
MaxProtocol = TLSv1.1
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[27-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-27]
ExpectedProtocol = TLSv1.1
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[28-resumption]
ssl_conf = 28-resumption-ssl

[28-resumption-ssl]
server = 28-resumption-server
client = 28-resumption-client
resume-server = 28-resumption-resume-server
resume-client = 28-resumption-client

[28-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[28-resumption-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[28-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-28]
ExpectedProtocol = TLSv1.2
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[29-resumption]
ssl_conf = 29-resumption-ssl

[29-resumption-ssl]
server = 29-resumption-server
client = 29-resumption-client
resume-server = 29-resumption-resume-server
resume-client = 29-resumption-client

[29-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[29-resumption-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[29-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-29]
ExpectedProtocol = TLSv1.2
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[30-resumption]
ssl_conf = 30-resumption-ssl

[30-resumption-ssl]
server = 30-resumption-server
client = 30-resumption-client
resume-server = 30-resumption-resume-server
resume-client = 30-resumption-client

[30-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[30-resumption-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[30-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-30]
ExpectedProtocol = TLSv1.3
HandshakeMode = Resume
ResumptionExpected = Yes


# ===========================================================

[31-resumption]
ssl_conf = 31-resumption-ssl

[31-resumption-ssl]
server = 31-resumption-server
client = 31-resumption-client
resume-server = 31-resumption-resume-server
resume-client = 31-resumption-client

[31-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[31-resumption-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[31-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-31]
ExpectedProtocol = TLSv1.3
HandshakeMode = Resume
ResumptionExpected = Yes


# ===========================================================

[32-resumption]
ssl_conf = 32-resumption-ssl

[32-resumption-ssl]
server = 32-resumption-server
client = 32-resumption-client
resume-server = 32-resumption-server
resume-client = 32-resumption-resume-client

[32-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[32-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
MinProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[32-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-32]
ExpectedProtocol = TLSv1
HandshakeMode = Resume
ResumptionExpected = Yes


# ===========================================================

[33-resumption]
ssl_conf = 33-resumption-ssl

[33-resumption-ssl]
server = 33-resumption-server
client = 33-resumption-client
resume-server = 33-resumption-server
resume-client = 33-resumption-resume-client

[33-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[33-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
MinProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[33-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-33]
ExpectedProtocol = TLSv1
HandshakeMode = Resume
ResumptionExpected = Yes


# ===========================================================

[34-resumption]
ssl_conf = 34-resumption-ssl

[34-resumption-ssl]
server = 34-resumption-server
client = 34-resumption-client
resume-server = 34-resumption-server
resume-client = 34-resumption-resume-client

[34-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[34-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
MinProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[34-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-34]
ExpectedProtocol = TLSv1.1
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[35-resumption]
ssl_conf = 35-resumption-ssl

[35-resumption-ssl]
server = 35-resumption-server
client = 35-resumption-client
resume-server = 35-resumption-server
resume-client = 35-resumption-resume-client

[35-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[35-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
MinProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[35-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-35]
ExpectedProtocol = TLSv1.1
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[36-resumption]
ssl_conf = 36-resumption-ssl

[36-resumption-ssl]
server = 36-resumption-server
client = 36-resumption-client
resume-server = 36-resumption-server
resume-client = 36-resumption-resume-client

[36-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[36-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
MinProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[36-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-36]
ExpectedProtocol = TLSv1.2
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[37-resumption]
ssl_conf = 37-resumption-ssl

[37-resumption-ssl]
server = 37-resumption-server
client = 37-resumption-client
resume-server = 37-resumption-server
resume-client = 37-resumption-resume-client

[37-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[37-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
MinProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[37-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-37]
ExpectedProtocol = TLSv1.2
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[38-resumption]
ssl_conf = 38-resumption-ssl

[38-resumption-ssl]
server = 38-resumption-server
client = 38-resumption-client
resume-server = 38-resumption-server
resume-client = 38-resumption-resume-client

[38-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[38-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
MinProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[38-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-38]
ExpectedProtocol = TLSv1.3
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[39-resumption]
ssl_conf = 39-resumption-ssl

[39-resumption-ssl]
server = 39-resumption-server
client = 39-resumption-client
resume-server = 39-resumption-server
resume-client = 39-resumption-resume-client

[39-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[39-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
MinProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[39-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-39]
ExpectedProtocol = TLSv1.3
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[40-resumption]
ssl_conf = 40-resumption-ssl

[40-resumption-ssl]
server = 40-resumption-server
client = 40-resumption-client
resume-server = 40-resumption-server
resume-client = 40-resumption-resume-client

[40-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[40-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
MinProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[40-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-40]
ExpectedProtocol = TLSv1
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[41-resumption]
ssl_conf = 41-resumption-ssl

[41-resumption-ssl]
server = 41-resumption-server
client = 41-resumption-client
resume-server = 41-resumption-server
resume-client = 41-resumption-resume-client

[41-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[41-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
MinProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[41-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-41]
ExpectedProtocol = TLSv1
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[42-resumption]
ssl_conf = 42-resumption-ssl

[42-resumption-ssl]
server = 42-resumption-server
client = 42-resumption-client
resume-server = 42-resumption-server
resume-client = 42-resumption-resume-client

[42-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[42-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
MinProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[42-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-42]
ExpectedProtocol = TLSv1.1
HandshakeMode = Resume
ResumptionExpected = Yes


# ===========================================================

[43-resumption]
ssl_conf = 43-resumption-ssl

[43-resumption-ssl]
server = 43-resumption-server
client = 43-resumption-client
resume-server = 43-resumption-server
resume-client = 43-resumption-resume-client

[43-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[43-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
MinProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[43-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-43]
ExpectedProtocol = TLSv1.1
HandshakeMode = Resume
ResumptionExpected = Yes


# ===========================================================

[44-resumption]
ssl_conf = 44-resumption-ssl

[44-resumption-ssl]
server = 44-resumption-server
client = 44-resumption-client
resume-server = 44-resumption-server
resume-client = 44-resumption-resume-client

[44-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[44-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
MinProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[44-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-44]
ExpectedProtocol = TLSv1.2
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[45-resumption]
ssl_conf = 45-resumption-ssl

[45-resumption-ssl]
server = 45-resumption-server
client = 45-resumption-client
resume-server = 45-resumption-server
resume-client = 45-resumption-resume-client

[45-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[45-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
MinProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[45-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-45]
ExpectedProtocol = TLSv1.2
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[46-resumption]
ssl_conf = 46-resumption-ssl

[46-resumption-ssl]
server = 46-resumption-server
client = 46-resumption-client
resume-server = 46-resumption-server
resume-client = 46-resumption-resume-client

[46-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[46-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
MinProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[46-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-46]
ExpectedProtocol = TLSv1.3
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[47-resumption]
ssl_conf = 47-resumption-ssl

[47-resumption-ssl]
server = 47-resumption-server
client = 47-resumption-client
resume-server = 47-resumption-server
resume-client = 47-resumption-resume-client

[47-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[47-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
MinProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[47-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-47]
ExpectedProtocol = TLSv1.3
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[48-resumption]
ssl_conf = 48-resumption-ssl

[48-resumption-ssl]
server = 48-resumption-server
client = 48-resumption-client
resume-server = 48-resumption-server
resume-client = 48-resumption-resume-client

[48-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[48-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
MinProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[48-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-48]
ExpectedProtocol = TLSv1
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[49-resumption]
ssl_conf = 49-resumption-ssl

[49-resumption-ssl]
server = 49-resumption-server
client = 49-resumption-client
resume-server = 49-resumption-server
resume-client = 49-resumption-resume-client

[49-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[49-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
MinProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[49-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-49]
ExpectedProtocol = TLSv1
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[50-resumption]
ssl_conf = 50-resumption-ssl

[50-resumption-ssl]
server = 50-resumption-server
client = 50-resumption-client
resume-server = 50-resumption-server
resume-client = 50-resumption-resume-client

[50-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[50-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
MinProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[50-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-50]
ExpectedProtocol = TLSv1.1
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[51-resumption]
ssl_conf = 51-resumption-ssl

[51-resumption-ssl]
server = 51-resumption-server
client = 51-resumption-client
resume-server = 51-resumption-server
resume-client = 51-resumption-resume-client

[51-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[51-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
MinProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[51-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-51]
ExpectedProtocol = TLSv1.1
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[52-resumption]
ssl_conf = 52-resumption-ssl

[52-resumption-ssl]
server = 52-resumption-server
client = 52-resumption-client
resume-server = 52-resumption-server
resume-client = 52-resumption-resume-client

[52-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[52-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
MinProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[52-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-52]
ExpectedProtocol = TLSv1.2
HandshakeMode = Resume
ResumptionExpected = Yes


# ===========================================================

[53-resumption]
ssl_conf = 53-resumption-ssl

[53-resumption-ssl]
server = 53-resumption-server
client = 53-resumption-client
resume-server = 53-resumption-server
resume-client = 53-resumption-resume-client

[53-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[53-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
MinProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[53-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-53]
ExpectedProtocol = TLSv1.2
HandshakeMode = Resume
ResumptionExpected = Yes


# ===========================================================

[54-resumption]
ssl_conf = 54-resumption-ssl

[54-resumption-ssl]
server = 54-resumption-server
client = 54-resumption-client
resume-server = 54-resumption-server
resume-client = 54-resumption-resume-client

[54-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[54-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
MinProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[54-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-54]
ExpectedProtocol = TLSv1.3
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[55-resumption]
ssl_conf = 55-resumption-ssl

[55-resumption-ssl]
server = 55-resumption-server
client = 55-resumption-client
resume-server = 55-resumption-server
resume-client = 55-resumption-resume-client

[55-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[55-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
MinProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[55-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-55]
ExpectedProtocol = TLSv1.3
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[56-resumption]
ssl_conf = 56-resumption-ssl

[56-resumption-ssl]
server = 56-resumption-server
client = 56-resumption-client
resume-server = 56-resumption-server
resume-client = 56-resumption-resume-client

[56-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[56-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[56-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-56]
ExpectedProtocol = TLSv1
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[57-resumption]
ssl_conf = 57-resumption-ssl

[57-resumption-ssl]
server = 57-resumption-server
client = 57-resumption-client
resume-server = 57-resumption-server
resume-client = 57-resumption-resume-client

[57-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[57-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[57-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-57]
ExpectedProtocol = TLSv1
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[58-resumption]
ssl_conf = 58-resumption-ssl

[58-resumption-ssl]
server = 58-resumption-server
client = 58-resumption-client
resume-server = 58-resumption-server
resume-client = 58-resumption-resume-client

[58-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[58-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[58-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-58]
ExpectedProtocol = TLSv1.1
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[59-resumption]
ssl_conf = 59-resumption-ssl

[59-resumption-ssl]
server = 59-resumption-server
client = 59-resumption-client
resume-server = 59-resumption-server
resume-client = 59-resumption-resume-client

[59-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[59-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[59-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-59]
ExpectedProtocol = TLSv1.1
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[60-resumption]
ssl_conf = 60-resumption-ssl

[60-resumption-ssl]
server = 60-resumption-server
client = 60-resumption-client
resume-server = 60-resumption-server
resume-client = 60-resumption-resume-client

[60-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[60-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[60-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-60]
ExpectedProtocol = TLSv1.2
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[61-resumption]
ssl_conf = 61-resumption-ssl

[61-resumption-ssl]
server = 61-resumption-server
client = 61-resumption-client
resume-server = 61-resumption-server
resume-client = 61-resumption-resume-client

[61-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[61-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[61-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-61]
ExpectedProtocol = TLSv1.2
HandshakeMode = Resume
ResumptionExpected = No


# ===========================================================

[62-resumption]
ssl_conf = 62-resumption-ssl

[62-resumption-ssl]
server = 62-resumption-server
client = 62-resumption-client
resume-server = 62-resumption-server
resume-client = 62-resumption-resume-client

[62-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[62-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[62-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-62]
ExpectedProtocol = TLSv1.3
HandshakeMode = Resume
ResumptionExpected = Yes


# ===========================================================

[63-resumption]
ssl_conf = 63-resumption-ssl

[63-resumption-ssl]
server = 63-resumption-server
client = 63-resumption-client
resume-server = 63-resumption-server
resume-client = 63-resumption-resume-client

[63-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[63-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[63-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-63]
ExpectedProtocol = TLSv1.3
HandshakeMode = Resume
ResumptionExpected = Yes


# ===========================================================

[64-resumption-with-hrr]
ssl_conf = 64-resumption-with-hrr-ssl

[64-resumption-with-hrr-ssl]
server = 64-resumption-with-hrr-server
client = 64-resumption-with-hrr-client
resume-server = 64-resumption-with-hrr-server
resume-client = 64-resumption-with-hrr-resume-client

[64-resumption-with-hrr-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = P-256
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[64-resumption-with-hrr-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[64-resumption-with-hrr-resume-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-64]
ExpectedProtocol = TLSv1.3
HandshakeMode = Resume
Method = TLS
ResumptionExpected = Yes


                                         node-23.7.0/deps/openssl/openssl/test/ssl-tests/10-resumption.cnf.in                                0000664 0000000 0000000 00000001032 14746647661 0025312 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test version negotiation upon resumption.

use strict;
use warnings;

package ssltests;

use protocol_version;

our $fips_mode;

our @tests = generate_resumption_tests("TLS", $fips_mode);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/openssl/openssl/test/ssl-tests/11-dtls_resumption.cnf                              0000664 0000000 0000000 00000035142 14746647661 0025745 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 16

test-0 = 0-resumption
test-1 = 1-resumption
test-2 = 2-resumption
test-3 = 3-resumption
test-4 = 4-resumption
test-5 = 5-resumption
test-6 = 6-resumption
test-7 = 7-resumption
test-8 = 8-resumption
test-9 = 9-resumption
test-10 = 10-resumption
test-11 = 11-resumption
test-12 = 12-resumption
test-13 = 13-resumption
test-14 = 14-resumption
test-15 = 15-resumption
# ===========================================================

[0-resumption]
ssl_conf = 0-resumption-ssl

[0-resumption-ssl]
server = 0-resumption-server
client = 0-resumption-client
resume-server = 0-resumption-resume-server
resume-client = 0-resumption-client

[0-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
MinProtocol = DTLSv1
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-resumption-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedProtocol = DTLSv1
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = Yes


# ===========================================================

[1-resumption]
ssl_conf = 1-resumption-ssl

[1-resumption-ssl]
server = 1-resumption-server
client = 1-resumption-client
resume-server = 1-resumption-resume-server
resume-client = 1-resumption-client

[1-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
MinProtocol = DTLSv1
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-resumption-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedProtocol = DTLSv1
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = Yes


# ===========================================================

[2-resumption]
ssl_conf = 2-resumption-ssl

[2-resumption-ssl]
server = 2-resumption-server
client = 2-resumption-client
resume-server = 2-resumption-resume-server
resume-client = 2-resumption-client

[2-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
MinProtocol = DTLSv1
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-resumption-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ExpectedProtocol = DTLSv1.2
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = No


# ===========================================================

[3-resumption]
ssl_conf = 3-resumption-ssl

[3-resumption-ssl]
server = 3-resumption-server
client = 3-resumption-client
resume-server = 3-resumption-resume-server
resume-client = 3-resumption-client

[3-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
MinProtocol = DTLSv1
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-resumption-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
ExpectedProtocol = DTLSv1.2
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = No


# ===========================================================

[4-resumption]
ssl_conf = 4-resumption-ssl

[4-resumption-ssl]
server = 4-resumption-server
client = 4-resumption-client
resume-server = 4-resumption-resume-server
resume-client = 4-resumption-client

[4-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
MinProtocol = DTLSv1.2
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[4-resumption-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[4-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-4]
ExpectedProtocol = DTLSv1
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = No


# ===========================================================

[5-resumption]
ssl_conf = 5-resumption-ssl

[5-resumption-ssl]
server = 5-resumption-server
client = 5-resumption-client
resume-server = 5-resumption-resume-server
resume-client = 5-resumption-client

[5-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
MinProtocol = DTLSv1.2
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[5-resumption-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[5-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-5]
ExpectedProtocol = DTLSv1
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = No


# ===========================================================

[6-resumption]
ssl_conf = 6-resumption-ssl

[6-resumption-ssl]
server = 6-resumption-server
client = 6-resumption-client
resume-server = 6-resumption-resume-server
resume-client = 6-resumption-client

[6-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
MinProtocol = DTLSv1.2
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[6-resumption-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[6-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-6]
ExpectedProtocol = DTLSv1.2
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = Yes


# ===========================================================

[7-resumption]
ssl_conf = 7-resumption-ssl

[7-resumption-ssl]
server = 7-resumption-server
client = 7-resumption-client
resume-server = 7-resumption-resume-server
resume-client = 7-resumption-client

[7-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
MinProtocol = DTLSv1.2
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[7-resumption-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[7-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-7]
ExpectedProtocol = DTLSv1.2
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = Yes


# ===========================================================

[8-resumption]
ssl_conf = 8-resumption-ssl

[8-resumption-ssl]
server = 8-resumption-server
client = 8-resumption-client
resume-server = 8-resumption-server
resume-client = 8-resumption-resume-client

[8-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[8-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
MinProtocol = DTLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[8-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-8]
ExpectedProtocol = DTLSv1
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = Yes


# ===========================================================

[9-resumption]
ssl_conf = 9-resumption-ssl

[9-resumption-ssl]
server = 9-resumption-server
client = 9-resumption-client
resume-server = 9-resumption-server
resume-client = 9-resumption-resume-client

[9-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[9-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
MinProtocol = DTLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[9-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-9]
ExpectedProtocol = DTLSv1
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = Yes


# ===========================================================

[10-resumption]
ssl_conf = 10-resumption-ssl

[10-resumption-ssl]
server = 10-resumption-server
client = 10-resumption-client
resume-server = 10-resumption-server
resume-client = 10-resumption-resume-client

[10-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[10-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
MinProtocol = DTLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[10-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-10]
ExpectedProtocol = DTLSv1.2
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = No


# ===========================================================

[11-resumption]
ssl_conf = 11-resumption-ssl

[11-resumption-ssl]
server = 11-resumption-server
client = 11-resumption-client
resume-server = 11-resumption-server
resume-client = 11-resumption-resume-client

[11-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[11-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
MinProtocol = DTLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[11-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-11]
ExpectedProtocol = DTLSv1.2
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = No


# ===========================================================

[12-resumption]
ssl_conf = 12-resumption-ssl

[12-resumption-ssl]
server = 12-resumption-server
client = 12-resumption-client
resume-server = 12-resumption-server
resume-client = 12-resumption-resume-client

[12-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[12-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
MinProtocol = DTLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[12-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-12]
ExpectedProtocol = DTLSv1
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = No


# ===========================================================

[13-resumption]
ssl_conf = 13-resumption-ssl

[13-resumption-ssl]
server = 13-resumption-server
client = 13-resumption-client
resume-server = 13-resumption-server
resume-client = 13-resumption-resume-client

[13-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[13-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
MinProtocol = DTLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[13-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-13]
ExpectedProtocol = DTLSv1
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = No


# ===========================================================

[14-resumption]
ssl_conf = 14-resumption-ssl

[14-resumption-ssl]
server = 14-resumption-server
client = 14-resumption-client
resume-server = 14-resumption-server
resume-client = 14-resumption-resume-client

[14-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[14-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
MinProtocol = DTLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[14-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-14]
ExpectedProtocol = DTLSv1.2
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = Yes


# ===========================================================

[15-resumption]
ssl_conf = 15-resumption-ssl

[15-resumption-ssl]
server = 15-resumption-server
client = 15-resumption-client
resume-server = 15-resumption-server
resume-client = 15-resumption-resume-client

[15-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[15-resumption-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
MinProtocol = DTLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[15-resumption-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
MaxProtocol = DTLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-15]
ExpectedProtocol = DTLSv1.2
HandshakeMode = Resume
Method = DTLS
ResumptionExpected = Yes


                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/openssl/openssl/test/ssl-tests/11-dtls_resumption.cnf.in                           0000664 0000000 0000000 00000001033 14746647661 0026342 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test version negotiation upon resumption.

use strict;
use warnings;

package ssltests;

use protocol_version;

our $fips_mode;

our @tests = generate_resumption_tests("DTLS", $fips_mode);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/openssl/openssl/test/ssl-tests/12-ct.cnf                                           0000664 0000000 0000000 00000011757 14746647661 0023127 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 6

test-0 = 0-ct-permissive-without-scts
test-1 = 1-ct-permissive-with-scts
test-2 = 2-ct-strict-without-scts
test-3 = 3-ct-strict-with-scts
test-4 = 4-ct-permissive-resumption
test-5 = 5-ct-strict-resumption
# ===========================================================

[0-ct-permissive-without-scts]
ssl_conf = 0-ct-permissive-without-scts-ssl

[0-ct-permissive-without-scts-ssl]
server = 0-ct-permissive-without-scts-server
client = 0-ct-permissive-without-scts-client

[0-ct-permissive-without-scts-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-ct-permissive-without-scts-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = Success
client = 0-ct-permissive-without-scts-client-extra

[0-ct-permissive-without-scts-client-extra]
CTValidation = Permissive


# ===========================================================

[1-ct-permissive-with-scts]
ssl_conf = 1-ct-permissive-with-scts-ssl

[1-ct-permissive-with-scts-ssl]
server = 1-ct-permissive-with-scts-server
client = 1-ct-permissive-with-scts-client

[1-ct-permissive-with-scts-server]
Certificate = ${ENV::TEST_CERTS_DIR}/embeddedSCTs1.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/embeddedSCTs1-key.pem

[1-ct-permissive-with-scts-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/embeddedSCTs1_issuer.pem
VerifyMode = Peer

[test-1]
ExpectedResult = Success
client = 1-ct-permissive-with-scts-client-extra

[1-ct-permissive-with-scts-client-extra]
CTValidation = Permissive


# ===========================================================

[2-ct-strict-without-scts]
ssl_conf = 2-ct-strict-without-scts-ssl

[2-ct-strict-without-scts-ssl]
server = 2-ct-strict-without-scts-server
client = 2-ct-strict-without-scts-client

[2-ct-strict-without-scts-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-ct-strict-without-scts-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ExpectedClientAlert = HandshakeFailure
ExpectedResult = ClientFail
client = 2-ct-strict-without-scts-client-extra

[2-ct-strict-without-scts-client-extra]
CTValidation = Strict


# ===========================================================

[3-ct-strict-with-scts]
ssl_conf = 3-ct-strict-with-scts-ssl

[3-ct-strict-with-scts-ssl]
server = 3-ct-strict-with-scts-server
client = 3-ct-strict-with-scts-client

[3-ct-strict-with-scts-server]
Certificate = ${ENV::TEST_CERTS_DIR}/embeddedSCTs1.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/embeddedSCTs1-key.pem

[3-ct-strict-with-scts-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/embeddedSCTs1_issuer.pem
VerifyMode = Peer

[test-3]
ExpectedResult = Success
client = 3-ct-strict-with-scts-client-extra

[3-ct-strict-with-scts-client-extra]
CTValidation = Strict


# ===========================================================

[4-ct-permissive-resumption]
ssl_conf = 4-ct-permissive-resumption-ssl

[4-ct-permissive-resumption-ssl]
server = 4-ct-permissive-resumption-server
client = 4-ct-permissive-resumption-client
resume-server = 4-ct-permissive-resumption-server
resume-client = 4-ct-permissive-resumption-client

[4-ct-permissive-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/embeddedSCTs1.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/embeddedSCTs1-key.pem

[4-ct-permissive-resumption-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/embeddedSCTs1_issuer.pem
VerifyMode = Peer

[test-4]
ExpectedResult = Success
HandshakeMode = Resume
ResumptionExpected = Yes
client = 4-ct-permissive-resumption-client-extra
resume-client = 4-ct-permissive-resumption-client-extra

[4-ct-permissive-resumption-client-extra]
CTValidation = Permissive


# ===========================================================

[5-ct-strict-resumption]
ssl_conf = 5-ct-strict-resumption-ssl

[5-ct-strict-resumption-ssl]
server = 5-ct-strict-resumption-server
client = 5-ct-strict-resumption-client
resume-server = 5-ct-strict-resumption-server
resume-client = 5-ct-strict-resumption-resume-client

[5-ct-strict-resumption-server]
Certificate = ${ENV::TEST_CERTS_DIR}/embeddedSCTs1.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/embeddedSCTs1-key.pem

[5-ct-strict-resumption-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/embeddedSCTs1_issuer.pem
VerifyMode = Peer

[5-ct-strict-resumption-resume-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-5]
ExpectedResult = Success
HandshakeMode = Resume
ResumptionExpected = Yes
client = 5-ct-strict-resumption-client-extra
resume-client = 5-ct-strict-resumption-resume-client-extra

[5-ct-strict-resumption-client-extra]
CTValidation = Strict

[5-ct-strict-resumption-resume-client-extra]
CTValidation = Strict


                 node-23.7.0/deps/openssl/openssl/test/ssl-tests/12-ct.cnf.in                                        0000664 0000000 0000000 00000006333 14746647661 0023526 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2022 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test version negotiation

use strict;
use warnings;

package ssltests;


our @tests = (
    {
        name => "ct-permissive-without-scts",
        server => {
        },
        client => {
            extra => {
                "CTValidation" => "Permissive",
            },
        },
        test => {
            "ExpectedResult" => "Success",
        },
    },
    {
        name => "ct-permissive-with-scts",
        server => {
            "Certificate" => test_pem("embeddedSCTs1.pem"),
            "PrivateKey"  => test_pem("embeddedSCTs1-key.pem"),
        },
        client => {
            "VerifyCAFile" => test_pem("embeddedSCTs1_issuer.pem"),
            extra => {
                "CTValidation" => "Permissive",
            },
        },
        test => {
            "ExpectedResult" => "Success",
        },
    },
    {
        name => "ct-strict-without-scts",
        server => {
        },
        client => {
            extra => {
                "CTValidation" => "Strict",
            },
        },
        test => {
            "ExpectedResult" => "ClientFail",
            "ExpectedClientAlert" => "HandshakeFailure",
        },
    },
    {
        name => "ct-strict-with-scts",
        server => {
            "Certificate" => test_pem("embeddedSCTs1.pem"),
            "PrivateKey"  => test_pem("embeddedSCTs1-key.pem"),
        },
        client => {
            "VerifyCAFile" => test_pem("embeddedSCTs1_issuer.pem"),
            extra => {
                "CTValidation" => "Strict",
            },
        },
        test => {
            "ExpectedResult" => "Success",
        },
    },
    {
        name => "ct-permissive-resumption",
        server => {
            "Certificate" => test_pem("embeddedSCTs1.pem"),
            "PrivateKey"  => test_pem("embeddedSCTs1-key.pem"),
        },
        client => {
            "VerifyCAFile" => test_pem("embeddedSCTs1_issuer.pem"),
            extra => {
                "CTValidation" => "Permissive",
            },
        },
        test => {
            "HandshakeMode" => "Resume",
            "ResumptionExpected" => "Yes",
            "ExpectedResult" => "Success",
        },
    },
    {
        name => "ct-strict-resumption",
        server => {
            "Certificate" => test_pem("embeddedSCTs1.pem"),
            "PrivateKey"  => test_pem("embeddedSCTs1-key.pem"),
        },
        client => {
            "VerifyCAFile" => test_pem("embeddedSCTs1_issuer.pem"),
            extra => {
                "CTValidation" => "Strict",
            },
        },
        # SCTs are not present during resumption, so the resumption
        # should succeed.
        resume_client => {
            extra => {
                "CTValidation" => "Strict",
            },
        },
        test => {
            "HandshakeMode" => "Resume",
            "ResumptionExpected" => "Yes",
            "ExpectedResult" => "Success",
        },
    },
);
                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/openssl/openssl/test/ssl-tests/13-fragmentation.cnf                                0000664 0000000 0000000 00000043227 14746647661 0025355 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 22

test-0 = 0-one-fragment-minus-app-data
test-1 = 1-one-fragment-app-data
test-2 = 2-one-fragment-plus-app-data
test-3 = 3-small-app-data
test-4 = 4-small-app-data-large-fragment-size
test-5 = 5-medium-app-data
test-6 = 6-medium-plus-app-data
test-7 = 7-large-app-data
test-8 = 8-large-app-data-large-fragment-size
test-9 = 9-large-app-data-odd-fragment-size
test-10 = 10-large-app-data-aes-sha1-multibuffer
test-11 = 11-large-app-data-aes-sha2-multibuffer
test-12 = 12-large-app-data-aes-sha1-multibuffer-odd-fragment
test-13 = 13-large-app-data-aes-sha2-multibuffer-odd-fragment
test-14 = 14-small-app-data-aes-sha1-multibuffer
test-15 = 15-small-app-data-aes-sha2-multibuffer
test-16 = 16-Maximum Fragment Len extension set to 1024 w. FragmentSize disabled
test-17 = 17-Maximum Fragment Len extension equal FragmentSize to 2048
test-18 = 18-Maximum Fragment Len extension 512 lower than FragmentSize 1024
test-19 = 19-Maximum Fragment Len extension 1024 lower than FragmentSize 1024
test-20 = 20-Maximum Fragment Len extension 4096 greater than FragmentSize 2048
test-21 = 21-Maximum Fragment Len extension 2048 greater than FragmentSize 1024
# ===========================================================

[0-one-fragment-minus-app-data]
ssl_conf = 0-one-fragment-minus-app-data-ssl

[0-one-fragment-minus-app-data-ssl]
server = 0-one-fragment-minus-app-data-server
client = 0-one-fragment-minus-app-data-client

[0-one-fragment-minus-app-data-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-one-fragment-minus-app-data-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ApplicationData = 511


# ===========================================================

[1-one-fragment-app-data]
ssl_conf = 1-one-fragment-app-data-ssl

[1-one-fragment-app-data-ssl]
server = 1-one-fragment-app-data-server
client = 1-one-fragment-app-data-client

[1-one-fragment-app-data-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-one-fragment-app-data-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ApplicationData = 512


# ===========================================================

[2-one-fragment-plus-app-data]
ssl_conf = 2-one-fragment-plus-app-data-ssl

[2-one-fragment-plus-app-data-ssl]
server = 2-one-fragment-plus-app-data-server
client = 2-one-fragment-plus-app-data-client

[2-one-fragment-plus-app-data-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-one-fragment-plus-app-data-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ApplicationData = 513


# ===========================================================

[3-small-app-data]
ssl_conf = 3-small-app-data-ssl

[3-small-app-data-ssl]
server = 3-small-app-data-server
client = 3-small-app-data-client

[3-small-app-data-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-small-app-data-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
ApplicationData = 4097


# ===========================================================

[4-small-app-data-large-fragment-size]
ssl_conf = 4-small-app-data-large-fragment-size-ssl

[4-small-app-data-large-fragment-size-ssl]
server = 4-small-app-data-large-fragment-size-server
client = 4-small-app-data-large-fragment-size-client

[4-small-app-data-large-fragment-size-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[4-small-app-data-large-fragment-size-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-4]
ApplicationData = 4097
MaxFragmentSize = 16384


# ===========================================================

[5-medium-app-data]
ssl_conf = 5-medium-app-data-ssl

[5-medium-app-data-ssl]
server = 5-medium-app-data-server
client = 5-medium-app-data-client

[5-medium-app-data-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[5-medium-app-data-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-5]
ApplicationData = 32775


# ===========================================================

[6-medium-plus-app-data]
ssl_conf = 6-medium-plus-app-data-ssl

[6-medium-plus-app-data-ssl]
server = 6-medium-plus-app-data-server
client = 6-medium-plus-app-data-client

[6-medium-plus-app-data-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[6-medium-plus-app-data-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-6]
ApplicationData = 131069


# ===========================================================

[7-large-app-data]
ssl_conf = 7-large-app-data-ssl

[7-large-app-data-ssl]
server = 7-large-app-data-server
client = 7-large-app-data-client

[7-large-app-data-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[7-large-app-data-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-7]
ApplicationData = 1048576


# ===========================================================

[8-large-app-data-large-fragment-size]
ssl_conf = 8-large-app-data-large-fragment-size-ssl

[8-large-app-data-large-fragment-size-ssl]
server = 8-large-app-data-large-fragment-size-server
client = 8-large-app-data-large-fragment-size-client

[8-large-app-data-large-fragment-size-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[8-large-app-data-large-fragment-size-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-8]
ApplicationData = 1048576
MaxFragmentSize = 16384


# ===========================================================

[9-large-app-data-odd-fragment-size]
ssl_conf = 9-large-app-data-odd-fragment-size-ssl

[9-large-app-data-odd-fragment-size-ssl]
server = 9-large-app-data-odd-fragment-size-server
client = 9-large-app-data-odd-fragment-size-client

[9-large-app-data-odd-fragment-size-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[9-large-app-data-odd-fragment-size-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-9]
ApplicationData = 1048576
MaxFragmentSize = 5115


# ===========================================================

[10-large-app-data-aes-sha1-multibuffer]
ssl_conf = 10-large-app-data-aes-sha1-multibuffer-ssl

[10-large-app-data-aes-sha1-multibuffer-ssl]
server = 10-large-app-data-aes-sha1-multibuffer-server
client = 10-large-app-data-aes-sha1-multibuffer-client

[10-large-app-data-aes-sha1-multibuffer-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[10-large-app-data-aes-sha1-multibuffer-client]
CipherString = AES128-SHA
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-10]
ApplicationData = 1048576
MaxFragmentSize = 4096


# ===========================================================

[11-large-app-data-aes-sha2-multibuffer]
ssl_conf = 11-large-app-data-aes-sha2-multibuffer-ssl

[11-large-app-data-aes-sha2-multibuffer-ssl]
server = 11-large-app-data-aes-sha2-multibuffer-server
client = 11-large-app-data-aes-sha2-multibuffer-client

[11-large-app-data-aes-sha2-multibuffer-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[11-large-app-data-aes-sha2-multibuffer-client]
CipherString = AES128-SHA256
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-11]
ApplicationData = 1048576
MaxFragmentSize = 4096


# ===========================================================

[12-large-app-data-aes-sha1-multibuffer-odd-fragment]
ssl_conf = 12-large-app-data-aes-sha1-multibuffer-odd-fragment-ssl

[12-large-app-data-aes-sha1-multibuffer-odd-fragment-ssl]
server = 12-large-app-data-aes-sha1-multibuffer-odd-fragment-server
client = 12-large-app-data-aes-sha1-multibuffer-odd-fragment-client

[12-large-app-data-aes-sha1-multibuffer-odd-fragment-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[12-large-app-data-aes-sha1-multibuffer-odd-fragment-client]
CipherString = AES128-SHA
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-12]
ApplicationData = 1048579
MaxFragmentSize = 5115


# ===========================================================

[13-large-app-data-aes-sha2-multibuffer-odd-fragment]
ssl_conf = 13-large-app-data-aes-sha2-multibuffer-odd-fragment-ssl

[13-large-app-data-aes-sha2-multibuffer-odd-fragment-ssl]
server = 13-large-app-data-aes-sha2-multibuffer-odd-fragment-server
client = 13-large-app-data-aes-sha2-multibuffer-odd-fragment-client

[13-large-app-data-aes-sha2-multibuffer-odd-fragment-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[13-large-app-data-aes-sha2-multibuffer-odd-fragment-client]
CipherString = AES128-SHA256
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-13]
ApplicationData = 1048573
MaxFragmentSize = 5125


# ===========================================================

[14-small-app-data-aes-sha1-multibuffer]
ssl_conf = 14-small-app-data-aes-sha1-multibuffer-ssl

[14-small-app-data-aes-sha1-multibuffer-ssl]
server = 14-small-app-data-aes-sha1-multibuffer-server
client = 14-small-app-data-aes-sha1-multibuffer-client

[14-small-app-data-aes-sha1-multibuffer-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[14-small-app-data-aes-sha1-multibuffer-client]
CipherString = AES128-SHA
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-14]
ApplicationData = 4096
MaxFragmentSize = 4096


# ===========================================================

[15-small-app-data-aes-sha2-multibuffer]
ssl_conf = 15-small-app-data-aes-sha2-multibuffer-ssl

[15-small-app-data-aes-sha2-multibuffer-ssl]
server = 15-small-app-data-aes-sha2-multibuffer-server
client = 15-small-app-data-aes-sha2-multibuffer-client

[15-small-app-data-aes-sha2-multibuffer-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[15-small-app-data-aes-sha2-multibuffer-client]
CipherString = AES128-SHA256
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-15]
ApplicationData = 4096
MaxFragmentSize = 4096


# ===========================================================

[16-Maximum Fragment Len extension set to 1024 w. FragmentSize disabled]
ssl_conf = 16-Maximum Fragment Len extension set to 1024 w. FragmentSize disabled-ssl

[16-Maximum Fragment Len extension set to 1024 w. FragmentSize disabled-ssl]
server = 16-Maximum Fragment Len extension set to 1024 w. FragmentSize disabled-server
client = 16-Maximum Fragment Len extension set to 1024 w. FragmentSize disabled-client

[16-Maximum Fragment Len extension set to 1024 w. FragmentSize disabled-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[16-Maximum Fragment Len extension set to 1024 w. FragmentSize disabled-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-16]
ApplicationData = 3072
MaxFragmentSize = 16384
client = 16-Maximum Fragment Len extension set to 1024 w. FragmentSize disabled-client-extra

[16-Maximum Fragment Len extension set to 1024 w. FragmentSize disabled-client-extra]
MaxFragmentLenExt = 1024


# ===========================================================

[17-Maximum Fragment Len extension equal FragmentSize to 2048]
ssl_conf = 17-Maximum Fragment Len extension equal FragmentSize to 2048-ssl

[17-Maximum Fragment Len extension equal FragmentSize to 2048-ssl]
server = 17-Maximum Fragment Len extension equal FragmentSize to 2048-server
client = 17-Maximum Fragment Len extension equal FragmentSize to 2048-client

[17-Maximum Fragment Len extension equal FragmentSize to 2048-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[17-Maximum Fragment Len extension equal FragmentSize to 2048-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-17]
ApplicationData = 3072
MaxFragmentSize = 2048
client = 17-Maximum Fragment Len extension equal FragmentSize to 2048-client-extra

[17-Maximum Fragment Len extension equal FragmentSize to 2048-client-extra]
MaxFragmentLenExt = 2048


# ===========================================================

[18-Maximum Fragment Len extension 512 lower than FragmentSize 1024]
ssl_conf = 18-Maximum Fragment Len extension 512 lower than FragmentSize 1024-ssl

[18-Maximum Fragment Len extension 512 lower than FragmentSize 1024-ssl]
server = 18-Maximum Fragment Len extension 512 lower than FragmentSize 1024-server
client = 18-Maximum Fragment Len extension 512 lower than FragmentSize 1024-client

[18-Maximum Fragment Len extension 512 lower than FragmentSize 1024-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[18-Maximum Fragment Len extension 512 lower than FragmentSize 1024-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-18]
ApplicationData = 3072
MaxFragmentSize = 1024
client = 18-Maximum Fragment Len extension 512 lower than FragmentSize 1024-client-extra

[18-Maximum Fragment Len extension 512 lower than FragmentSize 1024-client-extra]
MaxFragmentLenExt = 512


# ===========================================================

[19-Maximum Fragment Len extension 1024 lower than FragmentSize 1024]
ssl_conf = 19-Maximum Fragment Len extension 1024 lower than FragmentSize 1024-ssl

[19-Maximum Fragment Len extension 1024 lower than FragmentSize 1024-ssl]
server = 19-Maximum Fragment Len extension 1024 lower than FragmentSize 1024-server
client = 19-Maximum Fragment Len extension 1024 lower than FragmentSize 1024-client

[19-Maximum Fragment Len extension 1024 lower than FragmentSize 1024-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[19-Maximum Fragment Len extension 1024 lower than FragmentSize 1024-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-19]
ApplicationData = 3072
MaxFragmentSize = 1024
client = 19-Maximum Fragment Len extension 1024 lower than FragmentSize 1024-client-extra

[19-Maximum Fragment Len extension 1024 lower than FragmentSize 1024-client-extra]
MaxFragmentLenExt = 2048


# ===========================================================

[20-Maximum Fragment Len extension 4096 greater than FragmentSize 2048]
ssl_conf = 20-Maximum Fragment Len extension 4096 greater than FragmentSize 2048-ssl

[20-Maximum Fragment Len extension 4096 greater than FragmentSize 2048-ssl]
server = 20-Maximum Fragment Len extension 4096 greater than FragmentSize 2048-server
client = 20-Maximum Fragment Len extension 4096 greater than FragmentSize 2048-client

[20-Maximum Fragment Len extension 4096 greater than FragmentSize 2048-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[20-Maximum Fragment Len extension 4096 greater than FragmentSize 2048-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-20]
ApplicationData = 8196
MaxFragmentSize = 2048
client = 20-Maximum Fragment Len extension 4096 greater than FragmentSize 2048-client-extra

[20-Maximum Fragment Len extension 4096 greater than FragmentSize 2048-client-extra]
MaxFragmentLenExt = 4096


# ===========================================================

[21-Maximum Fragment Len extension 2048 greater than FragmentSize 1024]
ssl_conf = 21-Maximum Fragment Len extension 2048 greater than FragmentSize 1024-ssl

[21-Maximum Fragment Len extension 2048 greater than FragmentSize 1024-ssl]
server = 21-Maximum Fragment Len extension 2048 greater than FragmentSize 1024-server
client = 21-Maximum Fragment Len extension 2048 greater than FragmentSize 1024-client

[21-Maximum Fragment Len extension 2048 greater than FragmentSize 1024-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[21-Maximum Fragment Len extension 2048 greater than FragmentSize 1024-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-21]
ApplicationData = 3072
MaxFragmentSize = 1024
client = 21-Maximum Fragment Len extension 2048 greater than FragmentSize 1024-client-extra

[21-Maximum Fragment Len extension 2048 greater than FragmentSize 1024-client-extra]
MaxFragmentLenExt = 2048


                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/openssl/openssl/test/ssl-tests/13-fragmentation.cnf.in                             0000664 0000000 0000000 00000015547 14746647661 0025766 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test packet fragmentation

use strict;
use warnings;

package ssltests;


our @tests = (
    # Default fragment size is 512.
    {
        name => "one-fragment-minus-app-data",
        server => { },
        client => { },
        test => {
            ApplicationData => 511,
        }
    },
    {
        name => "one-fragment-app-data",
        server => { },
        client => { },
        test => {
            ApplicationData => 512,
        }
    },
    {
        name => "one-fragment-plus-app-data",
        server => { },
        client => { },
        test => {
            ApplicationData => 513,
        }
    },
    {
        name => "small-app-data",
        server => { },
        client => { },
        test => {
            ApplicationData => 4 * 1024 + 1,
        }
    },
    {
        name => "small-app-data-large-fragment-size",
        server => { },
        client => { },
        test => {
            ApplicationData => 4 * 1024 + 1,
            MaxFragmentSize => 16384,
        }
    },
    {
        name => "medium-app-data",
        server => { },
        client => { },
        test => {
            ApplicationData => 32 * 1024 + 7,
        }
    },
    # Exceeds the 64kB write buffer size.
    {
        name => "medium-plus-app-data",
        server => { },
        client => { },
        test => {
            ApplicationData => 128 * 1024 - 3,
        }
    },
    {
        name => "large-app-data",
        server => { },
        client => { },
        test => {
            ApplicationData => 1024 * 1024,
        }
    },
    {
        name => "large-app-data-large-fragment-size",
        server => { },
        client => { },
        test => {
            ApplicationData => 1024 * 1024,
            MaxFragmentSize => 16384,
        }
    },
    {
        name => "large-app-data-odd-fragment-size",
        server => { },
        client => { },
        test => {
            ApplicationData => 1024 * 1024,
            MaxFragmentSize => 5 * 1024 - 5,
        }
    },
    # When the buffer / fragment size ratio is sufficiently large,
    # multi-buffer code kicks in on some platforms for AES-SHA.  The
    # exact minimum ratio depends on the platform, and is usually
    # around 4. Since the test buffer is 64kB, a 4kB fragment is
    # easily sufficient.
    #
    # (We run this test on all platforms though it's only true multibuffer
    #  on some of them.)
    {
        name => "large-app-data-aes-sha1-multibuffer",
        server => { },
        client => {
            CipherString => "AES128-SHA",
            MaxProtocol => "TLSv1.2"
        },
        test => {
            ApplicationData => 1024 * 1024,
            MaxFragmentSize => 4 * 1024,
        }
    },
    {
        name => "large-app-data-aes-sha2-multibuffer",
        server => { },
        client => {
            CipherString => "AES128-SHA256",
            MaxProtocol => "TLSv1.2"
        },
        test => {
            ApplicationData => 1024 * 1024,
            MaxFragmentSize => 4 * 1024,
        }
    },
        {
        name => "large-app-data-aes-sha1-multibuffer-odd-fragment",
        server => { },
        client => {
            CipherString => "AES128-SHA",
            MaxProtocol => "TLSv1.2"
        },
        test => {
            ApplicationData => 1024 * 1024 + 3,
            MaxFragmentSize => 5 * 1024 - 5,
        }
    },
    {
        name => "large-app-data-aes-sha2-multibuffer-odd-fragment",
        server => { },
        client => {
            CipherString => "AES128-SHA256",
            MaxProtocol => "TLSv1.2"
        },
        test => {
            ApplicationData => 1024 * 1024 - 3,
            MaxFragmentSize => 5 * 1024 + 5,
        }
    },
    # Test that multibuffer-capable code also handles small data correctly.
    # Here fragment size == app data size < buffer size,
    # so no multibuffering should happen.
    {
        name => "small-app-data-aes-sha1-multibuffer",
        server => { },
        client => {
            CipherString => "AES128-SHA",
            MaxProtocol => "TLSv1.2"
        },
        test => {
            ApplicationData => 4 * 1024,
            MaxFragmentSize => 4 * 1024,
        }
    },
    {
        name => "small-app-data-aes-sha2-multibuffer",
        server => { },
        client => {
            CipherString => "AES128-SHA256",
            MaxProtocol => "TLSv1.2"
        },
        test => {
            ApplicationData => 4 * 1024,
            MaxFragmentSize => 4 * 1024,
        }
    },
    ############################################
    # Default (Max) Fragment Size is 512.
    # Default Application data size is 256.
    {
        name => "Maximum Fragment Len extension set to 1024 w. FragmentSize disabled",
        server => { },
        client => {
            extra => {
                MaxFragmentLenExt => 1024,
            },
        },
        test => {
            ApplicationData => 3072,
            MaxFragmentSize => 16384,
        }
    },
    {
        name => "Maximum Fragment Len extension equal FragmentSize to 2048",
        server => { },
        client => {
            extra => {
                MaxFragmentLenExt => 2048,
            },
        },
        test => {
            ApplicationData => 3072,
            MaxFragmentSize => 2048,
        }
    },
    {
        name => "Maximum Fragment Len extension 512 lower than FragmentSize 1024",
        server => { },
        client => {
            extra => {
                MaxFragmentLenExt => 512,
            },
        },
        test => {
            ApplicationData => 3072,
            MaxFragmentSize => 1024,
        }
    },
    {
        name => "Maximum Fragment Len extension 1024 lower than FragmentSize 1024",
        server => { },
        client => {
            extra => {
                MaxFragmentLenExt => 2048,
            },
        },
        test => {
            ApplicationData => 3072,
            MaxFragmentSize => 1024,
        }
    },
    {
        name => "Maximum Fragment Len extension 4096 greater than FragmentSize 2048",
        server => { },
        client => {
            extra => {
                MaxFragmentLenExt => 4096,
            },
        },
        test => {
            ApplicationData => 8196,
            MaxFragmentSize => 2048,
        }
    },
    {
        name => "Maximum Fragment Len extension 2048 greater than FragmentSize 1024",
        server => { },
        client => {
            extra => {
                MaxFragmentLenExt => 2048,
            },
        },
        test => {
            ApplicationData => 3072,
            MaxFragmentSize => 1024,
        }
    },
);
                                                                                                                                                         node-23.7.0/deps/openssl/openssl/test/ssl-tests/14-curves.cnf                                       0000664 0000000 0000000 00000213505 14746647661 0024025 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 95

test-0 = 0-curve-prime256v1
test-1 = 1-curve-secp384r1
test-2 = 2-curve-secp521r1
test-3 = 3-curve-X25519
test-4 = 4-curve-X448
test-5 = 5-curve-ffdhe2048
test-6 = 6-curve-ffdhe3072
test-7 = 7-curve-ffdhe4096
test-8 = 8-curve-ffdhe6144
test-9 = 9-curve-ffdhe8192
test-10 = 10-curve-sect233k1
test-11 = 11-curve-sect233r1
test-12 = 12-curve-sect283k1
test-13 = 13-curve-sect283r1
test-14 = 14-curve-sect409k1
test-15 = 15-curve-sect409r1
test-16 = 16-curve-sect571k1
test-17 = 17-curve-sect571r1
test-18 = 18-curve-secp224r1
test-19 = 19-curve-sect163k1
test-20 = 20-curve-sect163r2
test-21 = 21-curve-prime192v1
test-22 = 22-curve-sect163r1
test-23 = 23-curve-sect193r1
test-24 = 24-curve-sect193r2
test-25 = 25-curve-sect239k1
test-26 = 26-curve-secp160k1
test-27 = 27-curve-secp160r1
test-28 = 28-curve-secp160r2
test-29 = 29-curve-secp192k1
test-30 = 30-curve-secp224k1
test-31 = 31-curve-secp256k1
test-32 = 32-curve-brainpoolP256r1
test-33 = 33-curve-brainpoolP384r1
test-34 = 34-curve-brainpoolP512r1
test-35 = 35-curve-sect233k1-tls12-in-tls13
test-36 = 36-curve-sect233r1-tls12-in-tls13
test-37 = 37-curve-sect283k1-tls12-in-tls13
test-38 = 38-curve-sect283r1-tls12-in-tls13
test-39 = 39-curve-sect409k1-tls12-in-tls13
test-40 = 40-curve-sect409r1-tls12-in-tls13
test-41 = 41-curve-sect571k1-tls12-in-tls13
test-42 = 42-curve-sect571r1-tls12-in-tls13
test-43 = 43-curve-secp224r1-tls12-in-tls13
test-44 = 44-curve-sect163k1-tls12-in-tls13
test-45 = 45-curve-sect163r2-tls12-in-tls13
test-46 = 46-curve-prime192v1-tls12-in-tls13
test-47 = 47-curve-sect163r1-tls12-in-tls13
test-48 = 48-curve-sect193r1-tls12-in-tls13
test-49 = 49-curve-sect193r2-tls12-in-tls13
test-50 = 50-curve-sect239k1-tls12-in-tls13
test-51 = 51-curve-secp160k1-tls12-in-tls13
test-52 = 52-curve-secp160r1-tls12-in-tls13
test-53 = 53-curve-secp160r2-tls12-in-tls13
test-54 = 54-curve-secp192k1-tls12-in-tls13
test-55 = 55-curve-secp224k1-tls12-in-tls13
test-56 = 56-curve-secp256k1-tls12-in-tls13
test-57 = 57-curve-brainpoolP256r1-tls12-in-tls13
test-58 = 58-curve-brainpoolP384r1-tls12-in-tls13
test-59 = 59-curve-brainpoolP512r1-tls12-in-tls13
test-60 = 60-curve-sect233k1-tls13
test-61 = 61-curve-sect233r1-tls13
test-62 = 62-curve-sect283k1-tls13
test-63 = 63-curve-sect283r1-tls13
test-64 = 64-curve-sect409k1-tls13
test-65 = 65-curve-sect409r1-tls13
test-66 = 66-curve-sect571k1-tls13
test-67 = 67-curve-sect571r1-tls13
test-68 = 68-curve-secp224r1-tls13
test-69 = 69-curve-sect163k1-tls13
test-70 = 70-curve-sect163r2-tls13
test-71 = 71-curve-prime192v1-tls13
test-72 = 72-curve-sect163r1-tls13
test-73 = 73-curve-sect193r1-tls13
test-74 = 74-curve-sect193r2-tls13
test-75 = 75-curve-sect239k1-tls13
test-76 = 76-curve-secp160k1-tls13
test-77 = 77-curve-secp160r1-tls13
test-78 = 78-curve-secp160r2-tls13
test-79 = 79-curve-secp192k1-tls13
test-80 = 80-curve-secp224k1-tls13
test-81 = 81-curve-secp256k1-tls13
test-82 = 82-curve-brainpoolP256r1-tls13
test-83 = 83-curve-brainpoolP384r1-tls13
test-84 = 84-curve-brainpoolP512r1-tls13
test-85 = 85-curve-ffdhe2048-tls13-in-tls12
test-86 = 86-curve-ffdhe2048-tls13-in-tls12-2
test-87 = 87-curve-ffdhe3072-tls13-in-tls12
test-88 = 88-curve-ffdhe3072-tls13-in-tls12-2
test-89 = 89-curve-ffdhe4096-tls13-in-tls12
test-90 = 90-curve-ffdhe4096-tls13-in-tls12-2
test-91 = 91-curve-ffdhe6144-tls13-in-tls12
test-92 = 92-curve-ffdhe6144-tls13-in-tls12-2
test-93 = 93-curve-ffdhe8192-tls13-in-tls12
test-94 = 94-curve-ffdhe8192-tls13-in-tls12-2
# ===========================================================

[0-curve-prime256v1]
ssl_conf = 0-curve-prime256v1-ssl

[0-curve-prime256v1-ssl]
server = 0-curve-prime256v1-server
client = 0-curve-prime256v1-client

[0-curve-prime256v1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = prime256v1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-curve-prime256v1-client]
CipherString = ECDHE
Curves = prime256v1
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = prime256v1


# ===========================================================

[1-curve-secp384r1]
ssl_conf = 1-curve-secp384r1-ssl

[1-curve-secp384r1-ssl]
server = 1-curve-secp384r1-server
client = 1-curve-secp384r1-client

[1-curve-secp384r1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp384r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-curve-secp384r1-client]
CipherString = ECDHE
Curves = secp384r1
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = secp384r1


# ===========================================================

[2-curve-secp521r1]
ssl_conf = 2-curve-secp521r1-ssl

[2-curve-secp521r1-ssl]
server = 2-curve-secp521r1-server
client = 2-curve-secp521r1-client

[2-curve-secp521r1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp521r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-curve-secp521r1-client]
CipherString = ECDHE
Curves = secp521r1
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = secp521r1


# ===========================================================

[3-curve-X25519]
ssl_conf = 3-curve-X25519-ssl

[3-curve-X25519-ssl]
server = 3-curve-X25519-server
client = 3-curve-X25519-client

[3-curve-X25519-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = X25519
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-curve-X25519-client]
CipherString = ECDHE
Curves = X25519
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = X25519


# ===========================================================

[4-curve-X448]
ssl_conf = 4-curve-X448-ssl

[4-curve-X448-ssl]
server = 4-curve-X448-server
client = 4-curve-X448-client

[4-curve-X448-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = X448
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[4-curve-X448-client]
CipherString = ECDHE
Curves = X448
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-4]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = X448


# ===========================================================

[5-curve-ffdhe2048]
ssl_conf = 5-curve-ffdhe2048-ssl

[5-curve-ffdhe2048-ssl]
server = 5-curve-ffdhe2048-server
client = 5-curve-ffdhe2048-client

[5-curve-ffdhe2048-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = ffdhe2048
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[5-curve-ffdhe2048-client]
CipherString = ECDHE
Curves = ffdhe2048
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-5]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = dhKeyAgreement


# ===========================================================

[6-curve-ffdhe3072]
ssl_conf = 6-curve-ffdhe3072-ssl

[6-curve-ffdhe3072-ssl]
server = 6-curve-ffdhe3072-server
client = 6-curve-ffdhe3072-client

[6-curve-ffdhe3072-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = ffdhe3072
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[6-curve-ffdhe3072-client]
CipherString = ECDHE
Curves = ffdhe3072
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-6]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = dhKeyAgreement


# ===========================================================

[7-curve-ffdhe4096]
ssl_conf = 7-curve-ffdhe4096-ssl

[7-curve-ffdhe4096-ssl]
server = 7-curve-ffdhe4096-server
client = 7-curve-ffdhe4096-client

[7-curve-ffdhe4096-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = ffdhe4096
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[7-curve-ffdhe4096-client]
CipherString = ECDHE
Curves = ffdhe4096
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-7]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = dhKeyAgreement


# ===========================================================

[8-curve-ffdhe6144]
ssl_conf = 8-curve-ffdhe6144-ssl

[8-curve-ffdhe6144-ssl]
server = 8-curve-ffdhe6144-server
client = 8-curve-ffdhe6144-client

[8-curve-ffdhe6144-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = ffdhe6144
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[8-curve-ffdhe6144-client]
CipherString = ECDHE
Curves = ffdhe6144
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-8]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = dhKeyAgreement


# ===========================================================

[9-curve-ffdhe8192]
ssl_conf = 9-curve-ffdhe8192-ssl

[9-curve-ffdhe8192-ssl]
server = 9-curve-ffdhe8192-server
client = 9-curve-ffdhe8192-client

[9-curve-ffdhe8192-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = ffdhe8192
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[9-curve-ffdhe8192-client]
CipherString = ECDHE
Curves = ffdhe8192
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-9]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = dhKeyAgreement


# ===========================================================

[10-curve-sect233k1]
ssl_conf = 10-curve-sect233k1-ssl

[10-curve-sect233k1-ssl]
server = 10-curve-sect233k1-server
client = 10-curve-sect233k1-client

[10-curve-sect233k1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect233k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[10-curve-sect233k1-client]
CipherString = ECDHE
Curves = sect233k1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-10]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect233k1


# ===========================================================

[11-curve-sect233r1]
ssl_conf = 11-curve-sect233r1-ssl

[11-curve-sect233r1-ssl]
server = 11-curve-sect233r1-server
client = 11-curve-sect233r1-client

[11-curve-sect233r1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect233r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[11-curve-sect233r1-client]
CipherString = ECDHE
Curves = sect233r1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-11]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect233r1


# ===========================================================

[12-curve-sect283k1]
ssl_conf = 12-curve-sect283k1-ssl

[12-curve-sect283k1-ssl]
server = 12-curve-sect283k1-server
client = 12-curve-sect283k1-client

[12-curve-sect283k1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect283k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[12-curve-sect283k1-client]
CipherString = ECDHE
Curves = sect283k1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-12]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect283k1


# ===========================================================

[13-curve-sect283r1]
ssl_conf = 13-curve-sect283r1-ssl

[13-curve-sect283r1-ssl]
server = 13-curve-sect283r1-server
client = 13-curve-sect283r1-client

[13-curve-sect283r1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect283r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[13-curve-sect283r1-client]
CipherString = ECDHE
Curves = sect283r1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-13]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect283r1


# ===========================================================

[14-curve-sect409k1]
ssl_conf = 14-curve-sect409k1-ssl

[14-curve-sect409k1-ssl]
server = 14-curve-sect409k1-server
client = 14-curve-sect409k1-client

[14-curve-sect409k1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect409k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[14-curve-sect409k1-client]
CipherString = ECDHE
Curves = sect409k1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-14]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect409k1


# ===========================================================

[15-curve-sect409r1]
ssl_conf = 15-curve-sect409r1-ssl

[15-curve-sect409r1-ssl]
server = 15-curve-sect409r1-server
client = 15-curve-sect409r1-client

[15-curve-sect409r1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect409r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[15-curve-sect409r1-client]
CipherString = ECDHE
Curves = sect409r1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-15]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect409r1


# ===========================================================

[16-curve-sect571k1]
ssl_conf = 16-curve-sect571k1-ssl

[16-curve-sect571k1-ssl]
server = 16-curve-sect571k1-server
client = 16-curve-sect571k1-client

[16-curve-sect571k1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect571k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[16-curve-sect571k1-client]
CipherString = ECDHE
Curves = sect571k1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-16]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect571k1


# ===========================================================

[17-curve-sect571r1]
ssl_conf = 17-curve-sect571r1-ssl

[17-curve-sect571r1-ssl]
server = 17-curve-sect571r1-server
client = 17-curve-sect571r1-client

[17-curve-sect571r1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect571r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[17-curve-sect571r1-client]
CipherString = ECDHE
Curves = sect571r1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-17]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect571r1


# ===========================================================

[18-curve-secp224r1]
ssl_conf = 18-curve-secp224r1-ssl

[18-curve-secp224r1-ssl]
server = 18-curve-secp224r1-server
client = 18-curve-secp224r1-client

[18-curve-secp224r1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp224r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[18-curve-secp224r1-client]
CipherString = ECDHE
Curves = secp224r1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-18]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = secp224r1


# ===========================================================

[19-curve-sect163k1]
ssl_conf = 19-curve-sect163k1-ssl

[19-curve-sect163k1-ssl]
server = 19-curve-sect163k1-server
client = 19-curve-sect163k1-client

[19-curve-sect163k1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect163k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[19-curve-sect163k1-client]
CipherString = ECDHE
Curves = sect163k1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-19]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect163k1


# ===========================================================

[20-curve-sect163r2]
ssl_conf = 20-curve-sect163r2-ssl

[20-curve-sect163r2-ssl]
server = 20-curve-sect163r2-server
client = 20-curve-sect163r2-client

[20-curve-sect163r2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect163r2
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[20-curve-sect163r2-client]
CipherString = ECDHE
Curves = sect163r2
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-20]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect163r2


# ===========================================================

[21-curve-prime192v1]
ssl_conf = 21-curve-prime192v1-ssl

[21-curve-prime192v1-ssl]
server = 21-curve-prime192v1-server
client = 21-curve-prime192v1-client

[21-curve-prime192v1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = prime192v1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[21-curve-prime192v1-client]
CipherString = ECDHE
Curves = prime192v1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-21]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = prime192v1


# ===========================================================

[22-curve-sect163r1]
ssl_conf = 22-curve-sect163r1-ssl

[22-curve-sect163r1-ssl]
server = 22-curve-sect163r1-server
client = 22-curve-sect163r1-client

[22-curve-sect163r1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect163r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[22-curve-sect163r1-client]
CipherString = ECDHE
Curves = sect163r1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-22]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect163r1


# ===========================================================

[23-curve-sect193r1]
ssl_conf = 23-curve-sect193r1-ssl

[23-curve-sect193r1-ssl]
server = 23-curve-sect193r1-server
client = 23-curve-sect193r1-client

[23-curve-sect193r1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect193r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[23-curve-sect193r1-client]
CipherString = ECDHE
Curves = sect193r1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-23]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect193r1


# ===========================================================

[24-curve-sect193r2]
ssl_conf = 24-curve-sect193r2-ssl

[24-curve-sect193r2-ssl]
server = 24-curve-sect193r2-server
client = 24-curve-sect193r2-client

[24-curve-sect193r2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect193r2
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[24-curve-sect193r2-client]
CipherString = ECDHE
Curves = sect193r2
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-24]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect193r2


# ===========================================================

[25-curve-sect239k1]
ssl_conf = 25-curve-sect239k1-ssl

[25-curve-sect239k1-ssl]
server = 25-curve-sect239k1-server
client = 25-curve-sect239k1-client

[25-curve-sect239k1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect239k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[25-curve-sect239k1-client]
CipherString = ECDHE
Curves = sect239k1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-25]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = sect239k1


# ===========================================================

[26-curve-secp160k1]
ssl_conf = 26-curve-secp160k1-ssl

[26-curve-secp160k1-ssl]
server = 26-curve-secp160k1-server
client = 26-curve-secp160k1-client

[26-curve-secp160k1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp160k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[26-curve-secp160k1-client]
CipherString = ECDHE
Curves = secp160k1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-26]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = secp160k1


# ===========================================================

[27-curve-secp160r1]
ssl_conf = 27-curve-secp160r1-ssl

[27-curve-secp160r1-ssl]
server = 27-curve-secp160r1-server
client = 27-curve-secp160r1-client

[27-curve-secp160r1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp160r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[27-curve-secp160r1-client]
CipherString = ECDHE
Curves = secp160r1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-27]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = secp160r1


# ===========================================================

[28-curve-secp160r2]
ssl_conf = 28-curve-secp160r2-ssl

[28-curve-secp160r2-ssl]
server = 28-curve-secp160r2-server
client = 28-curve-secp160r2-client

[28-curve-secp160r2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp160r2
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[28-curve-secp160r2-client]
CipherString = ECDHE
Curves = secp160r2
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-28]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = secp160r2


# ===========================================================

[29-curve-secp192k1]
ssl_conf = 29-curve-secp192k1-ssl

[29-curve-secp192k1-ssl]
server = 29-curve-secp192k1-server
client = 29-curve-secp192k1-client

[29-curve-secp192k1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp192k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[29-curve-secp192k1-client]
CipherString = ECDHE
Curves = secp192k1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-29]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = secp192k1


# ===========================================================

[30-curve-secp224k1]
ssl_conf = 30-curve-secp224k1-ssl

[30-curve-secp224k1-ssl]
server = 30-curve-secp224k1-server
client = 30-curve-secp224k1-client

[30-curve-secp224k1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp224k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[30-curve-secp224k1-client]
CipherString = ECDHE
Curves = secp224k1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-30]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = secp224k1


# ===========================================================

[31-curve-secp256k1]
ssl_conf = 31-curve-secp256k1-ssl

[31-curve-secp256k1-ssl]
server = 31-curve-secp256k1-server
client = 31-curve-secp256k1-client

[31-curve-secp256k1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp256k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[31-curve-secp256k1-client]
CipherString = ECDHE
Curves = secp256k1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-31]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = secp256k1


# ===========================================================

[32-curve-brainpoolP256r1]
ssl_conf = 32-curve-brainpoolP256r1-ssl

[32-curve-brainpoolP256r1-ssl]
server = 32-curve-brainpoolP256r1-server
client = 32-curve-brainpoolP256r1-client

[32-curve-brainpoolP256r1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = brainpoolP256r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[32-curve-brainpoolP256r1-client]
CipherString = ECDHE
Curves = brainpoolP256r1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-32]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = brainpoolP256r1


# ===========================================================

[33-curve-brainpoolP384r1]
ssl_conf = 33-curve-brainpoolP384r1-ssl

[33-curve-brainpoolP384r1-ssl]
server = 33-curve-brainpoolP384r1-server
client = 33-curve-brainpoolP384r1-client

[33-curve-brainpoolP384r1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = brainpoolP384r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[33-curve-brainpoolP384r1-client]
CipherString = ECDHE
Curves = brainpoolP384r1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-33]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = brainpoolP384r1


# ===========================================================

[34-curve-brainpoolP512r1]
ssl_conf = 34-curve-brainpoolP512r1-ssl

[34-curve-brainpoolP512r1-ssl]
server = 34-curve-brainpoolP512r1-server
client = 34-curve-brainpoolP512r1-client

[34-curve-brainpoolP512r1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = brainpoolP512r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[34-curve-brainpoolP512r1-client]
CipherString = ECDHE
Curves = brainpoolP512r1
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-34]
ExpectedProtocol = TLSv1.2
ExpectedResult = Success
ExpectedTmpKeyType = brainpoolP512r1


# ===========================================================

[35-curve-sect233k1-tls12-in-tls13]
ssl_conf = 35-curve-sect233k1-tls12-in-tls13-ssl

[35-curve-sect233k1-tls12-in-tls13-ssl]
server = 35-curve-sect233k1-tls12-in-tls13-server
client = 35-curve-sect233k1-tls12-in-tls13-client

[35-curve-sect233k1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect233k1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[35-curve-sect233k1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect233k1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-35]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[36-curve-sect233r1-tls12-in-tls13]
ssl_conf = 36-curve-sect233r1-tls12-in-tls13-ssl

[36-curve-sect233r1-tls12-in-tls13-ssl]
server = 36-curve-sect233r1-tls12-in-tls13-server
client = 36-curve-sect233r1-tls12-in-tls13-client

[36-curve-sect233r1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect233r1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[36-curve-sect233r1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect233r1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-36]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[37-curve-sect283k1-tls12-in-tls13]
ssl_conf = 37-curve-sect283k1-tls12-in-tls13-ssl

[37-curve-sect283k1-tls12-in-tls13-ssl]
server = 37-curve-sect283k1-tls12-in-tls13-server
client = 37-curve-sect283k1-tls12-in-tls13-client

[37-curve-sect283k1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect283k1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[37-curve-sect283k1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect283k1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-37]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[38-curve-sect283r1-tls12-in-tls13]
ssl_conf = 38-curve-sect283r1-tls12-in-tls13-ssl

[38-curve-sect283r1-tls12-in-tls13-ssl]
server = 38-curve-sect283r1-tls12-in-tls13-server
client = 38-curve-sect283r1-tls12-in-tls13-client

[38-curve-sect283r1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect283r1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[38-curve-sect283r1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect283r1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-38]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[39-curve-sect409k1-tls12-in-tls13]
ssl_conf = 39-curve-sect409k1-tls12-in-tls13-ssl

[39-curve-sect409k1-tls12-in-tls13-ssl]
server = 39-curve-sect409k1-tls12-in-tls13-server
client = 39-curve-sect409k1-tls12-in-tls13-client

[39-curve-sect409k1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect409k1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[39-curve-sect409k1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect409k1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-39]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[40-curve-sect409r1-tls12-in-tls13]
ssl_conf = 40-curve-sect409r1-tls12-in-tls13-ssl

[40-curve-sect409r1-tls12-in-tls13-ssl]
server = 40-curve-sect409r1-tls12-in-tls13-server
client = 40-curve-sect409r1-tls12-in-tls13-client

[40-curve-sect409r1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect409r1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[40-curve-sect409r1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect409r1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-40]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[41-curve-sect571k1-tls12-in-tls13]
ssl_conf = 41-curve-sect571k1-tls12-in-tls13-ssl

[41-curve-sect571k1-tls12-in-tls13-ssl]
server = 41-curve-sect571k1-tls12-in-tls13-server
client = 41-curve-sect571k1-tls12-in-tls13-client

[41-curve-sect571k1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect571k1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[41-curve-sect571k1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect571k1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-41]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[42-curve-sect571r1-tls12-in-tls13]
ssl_conf = 42-curve-sect571r1-tls12-in-tls13-ssl

[42-curve-sect571r1-tls12-in-tls13-ssl]
server = 42-curve-sect571r1-tls12-in-tls13-server
client = 42-curve-sect571r1-tls12-in-tls13-client

[42-curve-sect571r1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect571r1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[42-curve-sect571r1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect571r1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-42]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[43-curve-secp224r1-tls12-in-tls13]
ssl_conf = 43-curve-secp224r1-tls12-in-tls13-ssl

[43-curve-secp224r1-tls12-in-tls13-ssl]
server = 43-curve-secp224r1-tls12-in-tls13-server
client = 43-curve-secp224r1-tls12-in-tls13-client

[43-curve-secp224r1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = secp224r1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[43-curve-secp224r1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = secp224r1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-43]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[44-curve-sect163k1-tls12-in-tls13]
ssl_conf = 44-curve-sect163k1-tls12-in-tls13-ssl

[44-curve-sect163k1-tls12-in-tls13-ssl]
server = 44-curve-sect163k1-tls12-in-tls13-server
client = 44-curve-sect163k1-tls12-in-tls13-client

[44-curve-sect163k1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect163k1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[44-curve-sect163k1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect163k1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-44]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[45-curve-sect163r2-tls12-in-tls13]
ssl_conf = 45-curve-sect163r2-tls12-in-tls13-ssl

[45-curve-sect163r2-tls12-in-tls13-ssl]
server = 45-curve-sect163r2-tls12-in-tls13-server
client = 45-curve-sect163r2-tls12-in-tls13-client

[45-curve-sect163r2-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect163r2:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[45-curve-sect163r2-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect163r2:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-45]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[46-curve-prime192v1-tls12-in-tls13]
ssl_conf = 46-curve-prime192v1-tls12-in-tls13-ssl

[46-curve-prime192v1-tls12-in-tls13-ssl]
server = 46-curve-prime192v1-tls12-in-tls13-server
client = 46-curve-prime192v1-tls12-in-tls13-client

[46-curve-prime192v1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = prime192v1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[46-curve-prime192v1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = prime192v1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-46]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[47-curve-sect163r1-tls12-in-tls13]
ssl_conf = 47-curve-sect163r1-tls12-in-tls13-ssl

[47-curve-sect163r1-tls12-in-tls13-ssl]
server = 47-curve-sect163r1-tls12-in-tls13-server
client = 47-curve-sect163r1-tls12-in-tls13-client

[47-curve-sect163r1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect163r1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[47-curve-sect163r1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect163r1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-47]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[48-curve-sect193r1-tls12-in-tls13]
ssl_conf = 48-curve-sect193r1-tls12-in-tls13-ssl

[48-curve-sect193r1-tls12-in-tls13-ssl]
server = 48-curve-sect193r1-tls12-in-tls13-server
client = 48-curve-sect193r1-tls12-in-tls13-client

[48-curve-sect193r1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect193r1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[48-curve-sect193r1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect193r1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-48]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[49-curve-sect193r2-tls12-in-tls13]
ssl_conf = 49-curve-sect193r2-tls12-in-tls13-ssl

[49-curve-sect193r2-tls12-in-tls13-ssl]
server = 49-curve-sect193r2-tls12-in-tls13-server
client = 49-curve-sect193r2-tls12-in-tls13-client

[49-curve-sect193r2-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect193r2:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[49-curve-sect193r2-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect193r2:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-49]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[50-curve-sect239k1-tls12-in-tls13]
ssl_conf = 50-curve-sect239k1-tls12-in-tls13-ssl

[50-curve-sect239k1-tls12-in-tls13-ssl]
server = 50-curve-sect239k1-tls12-in-tls13-server
client = 50-curve-sect239k1-tls12-in-tls13-client

[50-curve-sect239k1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = sect239k1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[50-curve-sect239k1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = sect239k1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-50]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[51-curve-secp160k1-tls12-in-tls13]
ssl_conf = 51-curve-secp160k1-tls12-in-tls13-ssl

[51-curve-secp160k1-tls12-in-tls13-ssl]
server = 51-curve-secp160k1-tls12-in-tls13-server
client = 51-curve-secp160k1-tls12-in-tls13-client

[51-curve-secp160k1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = secp160k1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[51-curve-secp160k1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = secp160k1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-51]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[52-curve-secp160r1-tls12-in-tls13]
ssl_conf = 52-curve-secp160r1-tls12-in-tls13-ssl

[52-curve-secp160r1-tls12-in-tls13-ssl]
server = 52-curve-secp160r1-tls12-in-tls13-server
client = 52-curve-secp160r1-tls12-in-tls13-client

[52-curve-secp160r1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = secp160r1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[52-curve-secp160r1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = secp160r1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-52]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[53-curve-secp160r2-tls12-in-tls13]
ssl_conf = 53-curve-secp160r2-tls12-in-tls13-ssl

[53-curve-secp160r2-tls12-in-tls13-ssl]
server = 53-curve-secp160r2-tls12-in-tls13-server
client = 53-curve-secp160r2-tls12-in-tls13-client

[53-curve-secp160r2-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = secp160r2:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[53-curve-secp160r2-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = secp160r2:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-53]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[54-curve-secp192k1-tls12-in-tls13]
ssl_conf = 54-curve-secp192k1-tls12-in-tls13-ssl

[54-curve-secp192k1-tls12-in-tls13-ssl]
server = 54-curve-secp192k1-tls12-in-tls13-server
client = 54-curve-secp192k1-tls12-in-tls13-client

[54-curve-secp192k1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = secp192k1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[54-curve-secp192k1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = secp192k1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-54]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[55-curve-secp224k1-tls12-in-tls13]
ssl_conf = 55-curve-secp224k1-tls12-in-tls13-ssl

[55-curve-secp224k1-tls12-in-tls13-ssl]
server = 55-curve-secp224k1-tls12-in-tls13-server
client = 55-curve-secp224k1-tls12-in-tls13-client

[55-curve-secp224k1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = secp224k1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[55-curve-secp224k1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = secp224k1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-55]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[56-curve-secp256k1-tls12-in-tls13]
ssl_conf = 56-curve-secp256k1-tls12-in-tls13-ssl

[56-curve-secp256k1-tls12-in-tls13-ssl]
server = 56-curve-secp256k1-tls12-in-tls13-server
client = 56-curve-secp256k1-tls12-in-tls13-client

[56-curve-secp256k1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = secp256k1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[56-curve-secp256k1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = secp256k1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-56]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[57-curve-brainpoolP256r1-tls12-in-tls13]
ssl_conf = 57-curve-brainpoolP256r1-tls12-in-tls13-ssl

[57-curve-brainpoolP256r1-tls12-in-tls13-ssl]
server = 57-curve-brainpoolP256r1-tls12-in-tls13-server
client = 57-curve-brainpoolP256r1-tls12-in-tls13-client

[57-curve-brainpoolP256r1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = brainpoolP256r1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[57-curve-brainpoolP256r1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = brainpoolP256r1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-57]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[58-curve-brainpoolP384r1-tls12-in-tls13]
ssl_conf = 58-curve-brainpoolP384r1-tls12-in-tls13-ssl

[58-curve-brainpoolP384r1-tls12-in-tls13-ssl]
server = 58-curve-brainpoolP384r1-tls12-in-tls13-server
client = 58-curve-brainpoolP384r1-tls12-in-tls13-client

[58-curve-brainpoolP384r1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = brainpoolP384r1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[58-curve-brainpoolP384r1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = brainpoolP384r1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-58]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[59-curve-brainpoolP512r1-tls12-in-tls13]
ssl_conf = 59-curve-brainpoolP512r1-tls12-in-tls13-ssl

[59-curve-brainpoolP512r1-tls12-in-tls13-ssl]
server = 59-curve-brainpoolP512r1-tls12-in-tls13-server
client = 59-curve-brainpoolP512r1-tls12-in-tls13-client

[59-curve-brainpoolP512r1-tls12-in-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = brainpoolP512r1:P-256
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[59-curve-brainpoolP512r1-tls12-in-tls13-client]
CipherString = ECDHE@SECLEVEL=1
Curves = brainpoolP512r1:P-256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-59]
ExpectedProtocol = TLSv1.3
ExpectedResult = Success
ExpectedTmpKeyType = P-256


# ===========================================================

[60-curve-sect233k1-tls13]
ssl_conf = 60-curve-sect233k1-tls13-ssl

[60-curve-sect233k1-tls13-ssl]
server = 60-curve-sect233k1-tls13-server
client = 60-curve-sect233k1-tls13-client

[60-curve-sect233k1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect233k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[60-curve-sect233k1-tls13-client]
CipherString = ECDHE
Curves = sect233k1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-60]
ExpectedResult = ClientFail


# ===========================================================

[61-curve-sect233r1-tls13]
ssl_conf = 61-curve-sect233r1-tls13-ssl

[61-curve-sect233r1-tls13-ssl]
server = 61-curve-sect233r1-tls13-server
client = 61-curve-sect233r1-tls13-client

[61-curve-sect233r1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect233r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[61-curve-sect233r1-tls13-client]
CipherString = ECDHE
Curves = sect233r1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-61]
ExpectedResult = ClientFail


# ===========================================================

[62-curve-sect283k1-tls13]
ssl_conf = 62-curve-sect283k1-tls13-ssl

[62-curve-sect283k1-tls13-ssl]
server = 62-curve-sect283k1-tls13-server
client = 62-curve-sect283k1-tls13-client

[62-curve-sect283k1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect283k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[62-curve-sect283k1-tls13-client]
CipherString = ECDHE
Curves = sect283k1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-62]
ExpectedResult = ClientFail


# ===========================================================

[63-curve-sect283r1-tls13]
ssl_conf = 63-curve-sect283r1-tls13-ssl

[63-curve-sect283r1-tls13-ssl]
server = 63-curve-sect283r1-tls13-server
client = 63-curve-sect283r1-tls13-client

[63-curve-sect283r1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect283r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[63-curve-sect283r1-tls13-client]
CipherString = ECDHE
Curves = sect283r1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-63]
ExpectedResult = ClientFail


# ===========================================================

[64-curve-sect409k1-tls13]
ssl_conf = 64-curve-sect409k1-tls13-ssl

[64-curve-sect409k1-tls13-ssl]
server = 64-curve-sect409k1-tls13-server
client = 64-curve-sect409k1-tls13-client

[64-curve-sect409k1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect409k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[64-curve-sect409k1-tls13-client]
CipherString = ECDHE
Curves = sect409k1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-64]
ExpectedResult = ClientFail


# ===========================================================

[65-curve-sect409r1-tls13]
ssl_conf = 65-curve-sect409r1-tls13-ssl

[65-curve-sect409r1-tls13-ssl]
server = 65-curve-sect409r1-tls13-server
client = 65-curve-sect409r1-tls13-client

[65-curve-sect409r1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect409r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[65-curve-sect409r1-tls13-client]
CipherString = ECDHE
Curves = sect409r1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-65]
ExpectedResult = ClientFail


# ===========================================================

[66-curve-sect571k1-tls13]
ssl_conf = 66-curve-sect571k1-tls13-ssl

[66-curve-sect571k1-tls13-ssl]
server = 66-curve-sect571k1-tls13-server
client = 66-curve-sect571k1-tls13-client

[66-curve-sect571k1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect571k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[66-curve-sect571k1-tls13-client]
CipherString = ECDHE
Curves = sect571k1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-66]
ExpectedResult = ClientFail


# ===========================================================

[67-curve-sect571r1-tls13]
ssl_conf = 67-curve-sect571r1-tls13-ssl

[67-curve-sect571r1-tls13-ssl]
server = 67-curve-sect571r1-tls13-server
client = 67-curve-sect571r1-tls13-client

[67-curve-sect571r1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect571r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[67-curve-sect571r1-tls13-client]
CipherString = ECDHE
Curves = sect571r1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-67]
ExpectedResult = ClientFail


# ===========================================================

[68-curve-secp224r1-tls13]
ssl_conf = 68-curve-secp224r1-tls13-ssl

[68-curve-secp224r1-tls13-ssl]
server = 68-curve-secp224r1-tls13-server
client = 68-curve-secp224r1-tls13-client

[68-curve-secp224r1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp224r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[68-curve-secp224r1-tls13-client]
CipherString = ECDHE
Curves = secp224r1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-68]
ExpectedResult = ClientFail


# ===========================================================

[69-curve-sect163k1-tls13]
ssl_conf = 69-curve-sect163k1-tls13-ssl

[69-curve-sect163k1-tls13-ssl]
server = 69-curve-sect163k1-tls13-server
client = 69-curve-sect163k1-tls13-client

[69-curve-sect163k1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect163k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[69-curve-sect163k1-tls13-client]
CipherString = ECDHE
Curves = sect163k1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-69]
ExpectedResult = ClientFail


# ===========================================================

[70-curve-sect163r2-tls13]
ssl_conf = 70-curve-sect163r2-tls13-ssl

[70-curve-sect163r2-tls13-ssl]
server = 70-curve-sect163r2-tls13-server
client = 70-curve-sect163r2-tls13-client

[70-curve-sect163r2-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect163r2
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[70-curve-sect163r2-tls13-client]
CipherString = ECDHE
Curves = sect163r2
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-70]
ExpectedResult = ClientFail


# ===========================================================

[71-curve-prime192v1-tls13]
ssl_conf = 71-curve-prime192v1-tls13-ssl

[71-curve-prime192v1-tls13-ssl]
server = 71-curve-prime192v1-tls13-server
client = 71-curve-prime192v1-tls13-client

[71-curve-prime192v1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = prime192v1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[71-curve-prime192v1-tls13-client]
CipherString = ECDHE
Curves = prime192v1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-71]
ExpectedResult = ClientFail


# ===========================================================

[72-curve-sect163r1-tls13]
ssl_conf = 72-curve-sect163r1-tls13-ssl

[72-curve-sect163r1-tls13-ssl]
server = 72-curve-sect163r1-tls13-server
client = 72-curve-sect163r1-tls13-client

[72-curve-sect163r1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect163r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[72-curve-sect163r1-tls13-client]
CipherString = ECDHE
Curves = sect163r1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-72]
ExpectedResult = ClientFail


# ===========================================================

[73-curve-sect193r1-tls13]
ssl_conf = 73-curve-sect193r1-tls13-ssl

[73-curve-sect193r1-tls13-ssl]
server = 73-curve-sect193r1-tls13-server
client = 73-curve-sect193r1-tls13-client

[73-curve-sect193r1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect193r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[73-curve-sect193r1-tls13-client]
CipherString = ECDHE
Curves = sect193r1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-73]
ExpectedResult = ClientFail


# ===========================================================

[74-curve-sect193r2-tls13]
ssl_conf = 74-curve-sect193r2-tls13-ssl

[74-curve-sect193r2-tls13-ssl]
server = 74-curve-sect193r2-tls13-server
client = 74-curve-sect193r2-tls13-client

[74-curve-sect193r2-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect193r2
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[74-curve-sect193r2-tls13-client]
CipherString = ECDHE
Curves = sect193r2
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-74]
ExpectedResult = ClientFail


# ===========================================================

[75-curve-sect239k1-tls13]
ssl_conf = 75-curve-sect239k1-tls13-ssl

[75-curve-sect239k1-tls13-ssl]
server = 75-curve-sect239k1-tls13-server
client = 75-curve-sect239k1-tls13-client

[75-curve-sect239k1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = sect239k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[75-curve-sect239k1-tls13-client]
CipherString = ECDHE
Curves = sect239k1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-75]
ExpectedResult = ClientFail


# ===========================================================

[76-curve-secp160k1-tls13]
ssl_conf = 76-curve-secp160k1-tls13-ssl

[76-curve-secp160k1-tls13-ssl]
server = 76-curve-secp160k1-tls13-server
client = 76-curve-secp160k1-tls13-client

[76-curve-secp160k1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp160k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[76-curve-secp160k1-tls13-client]
CipherString = ECDHE
Curves = secp160k1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-76]
ExpectedResult = ClientFail


# ===========================================================

[77-curve-secp160r1-tls13]
ssl_conf = 77-curve-secp160r1-tls13-ssl

[77-curve-secp160r1-tls13-ssl]
server = 77-curve-secp160r1-tls13-server
client = 77-curve-secp160r1-tls13-client

[77-curve-secp160r1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp160r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[77-curve-secp160r1-tls13-client]
CipherString = ECDHE
Curves = secp160r1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-77]
ExpectedResult = ClientFail


# ===========================================================

[78-curve-secp160r2-tls13]
ssl_conf = 78-curve-secp160r2-tls13-ssl

[78-curve-secp160r2-tls13-ssl]
server = 78-curve-secp160r2-tls13-server
client = 78-curve-secp160r2-tls13-client

[78-curve-secp160r2-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp160r2
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[78-curve-secp160r2-tls13-client]
CipherString = ECDHE
Curves = secp160r2
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-78]
ExpectedResult = ClientFail


# ===========================================================

[79-curve-secp192k1-tls13]
ssl_conf = 79-curve-secp192k1-tls13-ssl

[79-curve-secp192k1-tls13-ssl]
server = 79-curve-secp192k1-tls13-server
client = 79-curve-secp192k1-tls13-client

[79-curve-secp192k1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp192k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[79-curve-secp192k1-tls13-client]
CipherString = ECDHE
Curves = secp192k1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-79]
ExpectedResult = ClientFail


# ===========================================================

[80-curve-secp224k1-tls13]
ssl_conf = 80-curve-secp224k1-tls13-ssl

[80-curve-secp224k1-tls13-ssl]
server = 80-curve-secp224k1-tls13-server
client = 80-curve-secp224k1-tls13-client

[80-curve-secp224k1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp224k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[80-curve-secp224k1-tls13-client]
CipherString = ECDHE
Curves = secp224k1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-80]
ExpectedResult = ClientFail


# ===========================================================

[81-curve-secp256k1-tls13]
ssl_conf = 81-curve-secp256k1-tls13-ssl

[81-curve-secp256k1-tls13-ssl]
server = 81-curve-secp256k1-tls13-server
client = 81-curve-secp256k1-tls13-client

[81-curve-secp256k1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = secp256k1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[81-curve-secp256k1-tls13-client]
CipherString = ECDHE
Curves = secp256k1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-81]
ExpectedResult = ClientFail


# ===========================================================

[82-curve-brainpoolP256r1-tls13]
ssl_conf = 82-curve-brainpoolP256r1-tls13-ssl

[82-curve-brainpoolP256r1-tls13-ssl]
server = 82-curve-brainpoolP256r1-tls13-server
client = 82-curve-brainpoolP256r1-tls13-client

[82-curve-brainpoolP256r1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = brainpoolP256r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[82-curve-brainpoolP256r1-tls13-client]
CipherString = ECDHE
Curves = brainpoolP256r1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-82]
ExpectedResult = ClientFail


# ===========================================================

[83-curve-brainpoolP384r1-tls13]
ssl_conf = 83-curve-brainpoolP384r1-tls13-ssl

[83-curve-brainpoolP384r1-tls13-ssl]
server = 83-curve-brainpoolP384r1-tls13-server
client = 83-curve-brainpoolP384r1-tls13-client

[83-curve-brainpoolP384r1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = brainpoolP384r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[83-curve-brainpoolP384r1-tls13-client]
CipherString = ECDHE
Curves = brainpoolP384r1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-83]
ExpectedResult = ClientFail


# ===========================================================

[84-curve-brainpoolP512r1-tls13]
ssl_conf = 84-curve-brainpoolP512r1-tls13-ssl

[84-curve-brainpoolP512r1-tls13-ssl]
server = 84-curve-brainpoolP512r1-tls13-server
client = 84-curve-brainpoolP512r1-tls13-client

[84-curve-brainpoolP512r1-tls13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Curves = brainpoolP512r1
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[84-curve-brainpoolP512r1-tls13-client]
CipherString = ECDHE
Curves = brainpoolP512r1
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-84]
ExpectedResult = ClientFail


# ===========================================================

[85-curve-ffdhe2048-tls13-in-tls12]
ssl_conf = 85-curve-ffdhe2048-tls13-in-tls12-ssl

[85-curve-ffdhe2048-tls13-in-tls12-ssl]
server = 85-curve-ffdhe2048-tls13-in-tls12-server
client = 85-curve-ffdhe2048-tls13-in-tls12-client

[85-curve-ffdhe2048-tls13-in-tls12-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe2048
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[85-curve-ffdhe2048-tls13-in-tls12-client]
CipherString = ECDHE@SECLEVEL=1
Curves = ffdhe2048
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-85]
ExpectedResult = ServerFail


# ===========================================================

[86-curve-ffdhe2048-tls13-in-tls12-2]
ssl_conf = 86-curve-ffdhe2048-tls13-in-tls12-2-ssl

[86-curve-ffdhe2048-tls13-in-tls12-2-ssl]
server = 86-curve-ffdhe2048-tls13-in-tls12-2-server
client = 86-curve-ffdhe2048-tls13-in-tls12-2-client

[86-curve-ffdhe2048-tls13-in-tls12-2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe2048
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[86-curve-ffdhe2048-tls13-in-tls12-2-client]
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe2048
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-86]
ExpectedResult = Success


# ===========================================================

[87-curve-ffdhe3072-tls13-in-tls12]
ssl_conf = 87-curve-ffdhe3072-tls13-in-tls12-ssl

[87-curve-ffdhe3072-tls13-in-tls12-ssl]
server = 87-curve-ffdhe3072-tls13-in-tls12-server
client = 87-curve-ffdhe3072-tls13-in-tls12-client

[87-curve-ffdhe3072-tls13-in-tls12-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe3072
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[87-curve-ffdhe3072-tls13-in-tls12-client]
CipherString = ECDHE@SECLEVEL=1
Curves = ffdhe3072
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-87]
ExpectedResult = ServerFail


# ===========================================================

[88-curve-ffdhe3072-tls13-in-tls12-2]
ssl_conf = 88-curve-ffdhe3072-tls13-in-tls12-2-ssl

[88-curve-ffdhe3072-tls13-in-tls12-2-ssl]
server = 88-curve-ffdhe3072-tls13-in-tls12-2-server
client = 88-curve-ffdhe3072-tls13-in-tls12-2-client

[88-curve-ffdhe3072-tls13-in-tls12-2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe3072
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[88-curve-ffdhe3072-tls13-in-tls12-2-client]
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe3072
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-88]
ExpectedResult = Success


# ===========================================================

[89-curve-ffdhe4096-tls13-in-tls12]
ssl_conf = 89-curve-ffdhe4096-tls13-in-tls12-ssl

[89-curve-ffdhe4096-tls13-in-tls12-ssl]
server = 89-curve-ffdhe4096-tls13-in-tls12-server
client = 89-curve-ffdhe4096-tls13-in-tls12-client

[89-curve-ffdhe4096-tls13-in-tls12-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe4096
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[89-curve-ffdhe4096-tls13-in-tls12-client]
CipherString = ECDHE@SECLEVEL=1
Curves = ffdhe4096
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-89]
ExpectedResult = ServerFail


# ===========================================================

[90-curve-ffdhe4096-tls13-in-tls12-2]
ssl_conf = 90-curve-ffdhe4096-tls13-in-tls12-2-ssl

[90-curve-ffdhe4096-tls13-in-tls12-2-ssl]
server = 90-curve-ffdhe4096-tls13-in-tls12-2-server
client = 90-curve-ffdhe4096-tls13-in-tls12-2-client

[90-curve-ffdhe4096-tls13-in-tls12-2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe4096
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[90-curve-ffdhe4096-tls13-in-tls12-2-client]
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe4096
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-90]
ExpectedResult = Success


# ===========================================================

[91-curve-ffdhe6144-tls13-in-tls12]
ssl_conf = 91-curve-ffdhe6144-tls13-in-tls12-ssl

[91-curve-ffdhe6144-tls13-in-tls12-ssl]
server = 91-curve-ffdhe6144-tls13-in-tls12-server
client = 91-curve-ffdhe6144-tls13-in-tls12-client

[91-curve-ffdhe6144-tls13-in-tls12-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe6144
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[91-curve-ffdhe6144-tls13-in-tls12-client]
CipherString = ECDHE@SECLEVEL=1
Curves = ffdhe6144
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-91]
ExpectedResult = ServerFail


# ===========================================================

[92-curve-ffdhe6144-tls13-in-tls12-2]
ssl_conf = 92-curve-ffdhe6144-tls13-in-tls12-2-ssl

[92-curve-ffdhe6144-tls13-in-tls12-2-ssl]
server = 92-curve-ffdhe6144-tls13-in-tls12-2-server
client = 92-curve-ffdhe6144-tls13-in-tls12-2-client

[92-curve-ffdhe6144-tls13-in-tls12-2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe6144
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[92-curve-ffdhe6144-tls13-in-tls12-2-client]
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe6144
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-92]
ExpectedResult = Success


# ===========================================================

[93-curve-ffdhe8192-tls13-in-tls12]
ssl_conf = 93-curve-ffdhe8192-tls13-in-tls12-ssl

[93-curve-ffdhe8192-tls13-in-tls12-ssl]
server = 93-curve-ffdhe8192-tls13-in-tls12-server
client = 93-curve-ffdhe8192-tls13-in-tls12-client

[93-curve-ffdhe8192-tls13-in-tls12-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe8192
MaxProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[93-curve-ffdhe8192-tls13-in-tls12-client]
CipherString = ECDHE@SECLEVEL=1
Curves = ffdhe8192
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-93]
ExpectedResult = ServerFail


# ===========================================================

[94-curve-ffdhe8192-tls13-in-tls12-2]
ssl_conf = 94-curve-ffdhe8192-tls13-in-tls12-2-ssl

[94-curve-ffdhe8192-tls13-in-tls12-2-ssl]
server = 94-curve-ffdhe8192-tls13-in-tls12-2-server
client = 94-curve-ffdhe8192-tls13-in-tls12-2-client

[94-curve-ffdhe8192-tls13-in-tls12-2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe8192
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[94-curve-ffdhe8192-tls13-in-tls12-2-client]
CipherString = DEFAULT@SECLEVEL=1
Curves = ffdhe8192
MaxProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-94]
ExpectedResult = Success


                                                                                                                                                                                           node-23.7.0/deps/openssl/openssl/test/ssl-tests/14-curves.cnf.in                                    0000664 0000000 0000000 00000012561 14746647661 0024431 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-

## SSL test configurations

package ssltests;

use strict;
use warnings;

use OpenSSL::Test;
use OpenSSL::Test::Utils qw(anydisabled);

our $fips_mode;

my @curves = ("prime256v1", "secp384r1", "secp521r1");

my @curves_no_fips = ("X25519", "X448");

push @curves, @curves_no_fips if !$fips_mode;

#Curves *only* suitable for use in TLSv1.3
my @curves_tls_1_3 = ("ffdhe2048", "ffdhe3072", "ffdhe4096", "ffdhe6144",
                      "ffdhe8192");

push @curves, @curves_tls_1_3;

my @curves_tls_1_2 = ("sect233k1", "sect233r1",
              "sect283k1", "sect283r1", "sect409k1", "sect409r1",
              "sect571k1", "sect571r1", "secp224r1");

my @curves_non_fips = ("sect163k1", "sect163r2", "prime192v1",
                       "sect163r1", "sect193r1", "sect193r2", "sect239k1",
                       "secp160k1", "secp160r1", "secp160r2", "secp192k1",
                       "secp224k1",  "secp256k1", "brainpoolP256r1",
                       "brainpoolP384r1", "brainpoolP512r1");

push @curves_tls_1_2, @curves_non_fips if !$fips_mode;

our @tests = ();

sub get_key_type {
    my $group = shift;
    my $keyType;

    if ($group =~ /ffdhe/) {
        $keyType = "dhKeyAgreement";
    } else {
        $keyType = $group;
    }

    return $keyType;
}

sub generate_tests() {
    foreach (0..$#curves) {
        my $curve = $curves[$_];
        push @tests, {
            name => "curve-${curve}",
            server => {
                "Curves" => $curve,
                "MaxProtocol" => "TLSv1.3"
            },
            client => {
                "CipherString" => "ECDHE",
                "MaxProtocol" => "TLSv1.3",
                "Curves" => $curve
            },
            test   => {
                "ExpectedTmpKeyType" => get_key_type($curve),
                "ExpectedProtocol" => "TLSv1.3",
                "ExpectedResult" => "Success"
            },
        };
    }
    foreach (0..$#curves_tls_1_2) {
        my $curve = $curves_tls_1_2[$_];
        push @tests, {
            name => "curve-${curve}",
            server => {
                "Curves" => $curve,
                "MaxProtocol" => "TLSv1.3"
            },
            client => {
                "CipherString" => "ECDHE",
                "MaxProtocol" => "TLSv1.2",
                "Curves" => $curve
            },
            test   => {
                "ExpectedTmpKeyType" => get_key_type($curve),
                "ExpectedProtocol" => "TLSv1.2",
                "ExpectedResult" => "Success"
            },
        };
    }
    foreach (0..$#curves_tls_1_2) {
        my $curve = $curves_tls_1_2[$_];
        push @tests, {
            name => "curve-${curve}-tls12-in-tls13",
            server => {
                "Curves" => "$curve:P-256",
                "CipherString" => 'DEFAULT@SECLEVEL=1',
                "MaxProtocol" => "TLSv1.3"
            },
            client => {
                "CipherString" => 'ECDHE@SECLEVEL=1',
                "MaxProtocol" => "TLSv1.3",
                "MinProtocol" => "TLSv1.3",
                "Curves" => "$curve:P-256"
            },
            test   => {
                #This curve is not allowed in a TLSv1.3 key_share. We should
                #succeed but fallback to P-256
                "ExpectedTmpKeyType" => "P-256",
                "ExpectedProtocol" => "TLSv1.3",
                "ExpectedResult" => "Success"
            },
        };
    }
    foreach (0..$#curves_tls_1_2) {
        my $curve = $curves_tls_1_2[$_];
        push @tests, {
            name => "curve-${curve}-tls13",
            server => {
                "Curves" => $curve,
                "MaxProtocol" => "TLSv1.3"
            },
            client => {
                "CipherString" => "ECDHE",
                "MinProtocol" => "TLSv1.3",
                "Curves" => $curve
            },
            test   => {
                "ExpectedResult" => "ClientFail"
            },
        };
    }
    foreach (0..$#curves_tls_1_3) {
        my $curve = $curves_tls_1_3[$_];
        push @tests, {
            name => "curve-${curve}-tls13-in-tls12",
            server => {
                "Curves" => $curve,
                "CipherString" => 'DEFAULT@SECLEVEL=1',
                "MaxProtocol" => "TLSv1.3"
            },
            client => {
                "CipherString" => 'ECDHE@SECLEVEL=1',
                "MaxProtocol" => "TLSv1.2",
                "Curves" => $curve
            },
            test   => {
                #These curves are only suitable for TLSv1.3 so we expect the
                #server to fail because it has no shared groups for TLSv1.2
                #ECDHE key exchange
                "ExpectedResult" => "ServerFail"
            },
        };
        push @tests, {
            name => "curve-${curve}-tls13-in-tls12-2",
            server => {
                "Curves" => $curve,
                "CipherString" => 'DEFAULT@SECLEVEL=1',
                "MaxProtocol" => "TLSv1.2"
            },
            client => {
                "CipherString" => 'DEFAULT@SECLEVEL=1',
                "MaxProtocol" => "TLSv1.3",
                "Curves" => $curve
            },
            test   => {
                #These curves are only suitable for TLSv1.3. We expect TLSv1.2
                #negotiation to succeed because we fall back to some other
                #ciphersuite
                "ExpectedResult" => "Success"
            },
        };
    }
}

generate_tests();
                                                                                                                                               node-23.7.0/deps/openssl/openssl/test/ssl-tests/15-certstatus.cnf                                   0000664 0000000 0000000 00000002525 14746647661 0024716 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 2

test-0 = 0-certstatus-good
test-1 = 1-certstatus-bad
# ===========================================================

[0-certstatus-good]
ssl_conf = 0-certstatus-good-ssl

[0-certstatus-good-ssl]
server = 0-certstatus-good-server
client = 0-certstatus-good-client

[0-certstatus-good-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-certstatus-good-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = Success
Method = TLS
server = 0-certstatus-good-server-extra

[0-certstatus-good-server-extra]
CertStatus = GoodResponse


# ===========================================================

[1-certstatus-bad]
ssl_conf = 1-certstatus-bad-ssl

[1-certstatus-bad-ssl]
server = 1-certstatus-bad-server
client = 1-certstatus-bad-client

[1-certstatus-bad-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-certstatus-bad-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedResult = ClientFail
Method = TLS
server = 1-certstatus-bad-server-extra

[1-certstatus-bad-server-extra]
CertStatus = BadResponse


                                                                                                                                                                           node-23.7.0/deps/openssl/openssl/test/ssl-tests/15-certstatus.cnf.in                                0000664 0000000 0000000 00000001772 14746647661 0025326 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test CertStatus messages

use strict;
use warnings;

package ssltests;


our @tests = (
    {
        name => "certstatus-good",
        server => {
            extra => {
                "CertStatus" => "GoodResponse",
            },
        },
        client => {},
        test => {
            "Method" => "TLS",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "certstatus-bad",
        server => {
            extra => {
                "CertStatus" => "BadResponse",
            },
        },
        client => {},
        test => {
            "Method" => "TLS",
            "ExpectedResult" => "ClientFail"
        }
    },
);
      node-23.7.0/deps/openssl/openssl/test/ssl-tests/16-dtls-certstatus.cnf                              0000664 0000000 0000000 00000002607 14746647661 0025664 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 2

test-0 = 0-certstatus-good
test-1 = 1-certstatus-bad
# ===========================================================

[0-certstatus-good]
ssl_conf = 0-certstatus-good-ssl

[0-certstatus-good-ssl]
server = 0-certstatus-good-server
client = 0-certstatus-good-client

[0-certstatus-good-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-certstatus-good-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = Success
Method = DTLS
server = 0-certstatus-good-server-extra

[0-certstatus-good-server-extra]
CertStatus = GoodResponse


# ===========================================================

[1-certstatus-bad]
ssl_conf = 1-certstatus-bad-ssl

[1-certstatus-bad-ssl]
server = 1-certstatus-bad-server
client = 1-certstatus-bad-client

[1-certstatus-bad-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-certstatus-bad-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedResult = ClientFail
Method = DTLS
server = 1-certstatus-bad-server-extra

[1-certstatus-bad-server-extra]
CertStatus = BadResponse


                                                                                                                         node-23.7.0/deps/openssl/openssl/test/ssl-tests/16-dtls-certstatus.cnf.in                           0000664 0000000 0000000 00000004516 14746647661 0026272 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2021 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test DTLS CertStatus messages

use strict;
use warnings;

package ssltests;
use OpenSSL::Test::Utils;

our $fips_mode;

our @tests = ();

our @tests_standard = (
    {
        name => "certstatus-good",
        server => {
            "CipherString" => "DEFAULT:\@SECLEVEL=0",
            extra => {
                "CertStatus" => "GoodResponse"
            },
        },
        client => {
            "CipherString" => "DEFAULT:\@SECLEVEL=0",
        },
        test => {
            "Method" => "DTLS",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "certstatus-bad",
        server => {
            "CipherString" => "DEFAULT:\@SECLEVEL=0",
            extra => {
                "CertStatus" => "BadResponse",
            },
        },
        client => {
            "CipherString" => "DEFAULT:\@SECLEVEL=0",
        },
        test => {
            "Method" => "DTLS",
            "ExpectedResult" => "ClientFail"
        }
    }
);

our @tests_sctp = (
    {
        name => "certstatus-good",
        server => {
            "CipherString" => "DEFAULT:\@SECLEVEL=0",
            extra => {
                "CertStatus" => "GoodResponse",
            },
        },
        client => {
            "CipherString" => "DEFAULT:\@SECLEVEL=0",
        },
        test => {
            "Method" => "DTLS",
            "UseSCTP" => "Yes",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "certstatus-bad",
        server => {
            "CipherString" => "DEFAULT:\@SECLEVEL=0",
            extra => {
                "CertStatus" => "BadResponse",
            },
        },
        client => {
            "CipherString" => "DEFAULT:\@SECLEVEL=0",
        },
        test => {
            "Method" => "DTLS",
            "UseSCTP" => "Yes",
            "ExpectedResult" => "ClientFail"
        }
    },
);

if  (!$fips_mode || !disabled("dtls1_2")) {
    push @tests, @tests_standard;
    push @tests, @tests_sctp unless disabled("sctp") || disabled("sock");
}
                                                                                                                                                                                  node-23.7.0/deps/openssl/openssl/test/ssl-tests/17-renegotiate.cnf                                  0000664 0000000 0000000 00000035621 14746647661 0025030 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 18

test-0 = 0-renegotiate-client-no-resume
test-1 = 1-renegotiate-client-resume
test-2 = 2-renegotiate-server-no-resume
test-3 = 3-renegotiate-server-resume
test-4 = 4-renegotiate-client-auth-require
test-5 = 5-renegotiate-client-auth-once
test-6 = 6-renegotiate-client-legacy-connect
test-7 = 7-renegotiate-aead-to-non-aead
test-8 = 8-renegotiate-non-aead-to-aead
test-9 = 9-renegotiate-non-aead-to-non-aead
test-10 = 10-renegotiate-aead-to-aead
test-11 = 11-no-renegotiation-server-by-client
test-12 = 12-no-renegotiation-server-by-server
test-13 = 13-no-renegotiation-client-by-server
test-14 = 14-no-renegotiation-client-by-client
test-15 = 15-no-extms-on-renegotiation
test-16 = 16-allow-client-renegotiation
test-17 = 17-no-client-renegotiation
# ===========================================================

[0-renegotiate-client-no-resume]
ssl_conf = 0-renegotiate-client-no-resume-ssl

[0-renegotiate-client-no-resume-ssl]
server = 0-renegotiate-client-no-resume-server
client = 0-renegotiate-client-no-resume-client

[0-renegotiate-client-no-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
Options = NoResumptionOnRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-renegotiate-client-no-resume-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = TLS
ResumptionExpected = No


# ===========================================================

[1-renegotiate-client-resume]
ssl_conf = 1-renegotiate-client-resume-ssl

[1-renegotiate-client-resume-ssl]
server = 1-renegotiate-client-resume-server
client = 1-renegotiate-client-resume-client

[1-renegotiate-client-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-renegotiate-client-resume-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = TLS
ResumptionExpected = Yes


# ===========================================================

[2-renegotiate-server-no-resume]
ssl_conf = 2-renegotiate-server-no-resume-ssl

[2-renegotiate-server-no-resume-ssl]
server = 2-renegotiate-server-no-resume-server
client = 2-renegotiate-server-no-resume-client

[2-renegotiate-server-no-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
Options = NoResumptionOnRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-renegotiate-server-no-resume-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ExpectedResult = Success
HandshakeMode = RenegotiateServer
Method = TLS
ResumptionExpected = No


# ===========================================================

[3-renegotiate-server-resume]
ssl_conf = 3-renegotiate-server-resume-ssl

[3-renegotiate-server-resume-ssl]
server = 3-renegotiate-server-resume-server
client = 3-renegotiate-server-resume-client

[3-renegotiate-server-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-renegotiate-server-resume-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
ExpectedResult = Success
HandshakeMode = RenegotiateServer
Method = TLS
ResumptionExpected = Yes


# ===========================================================

[4-renegotiate-client-auth-require]
ssl_conf = 4-renegotiate-client-auth-require-ssl

[4-renegotiate-client-auth-require-ssl]
server = 4-renegotiate-client-auth-require-server
client = 4-renegotiate-client-auth-require-client

[4-renegotiate-client-auth-require-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
Options = NoResumptionOnRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Require

[4-renegotiate-client-auth-require-client]
Certificate = ${ENV::TEST_CERTS_DIR}/ee-client-chain.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-key.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-4]
ExpectedResult = Success
HandshakeMode = RenegotiateServer
Method = TLS
ResumptionExpected = No


# ===========================================================

[5-renegotiate-client-auth-once]
ssl_conf = 5-renegotiate-client-auth-once-ssl

[5-renegotiate-client-auth-once-ssl]
server = 5-renegotiate-client-auth-once-server
client = 5-renegotiate-client-auth-once-client

[5-renegotiate-client-auth-once-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
Options = NoResumptionOnRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Once

[5-renegotiate-client-auth-once-client]
Certificate = ${ENV::TEST_CERTS_DIR}/ee-client-chain.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-key.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-5]
ExpectedResult = Success
HandshakeMode = RenegotiateServer
Method = TLS
ResumptionExpected = No


# ===========================================================

[6-renegotiate-client-legacy-connect]
ssl_conf = 6-renegotiate-client-legacy-connect-ssl

[6-renegotiate-client-legacy-connect-ssl]
server = 6-renegotiate-client-legacy-connect-server
client = 6-renegotiate-client-legacy-connect-client

[6-renegotiate-client-legacy-connect-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[6-renegotiate-client-legacy-connect-client]
CipherString = DEFAULT
Options = UnsafeLegacyServerConnect
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-6]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = TLS
ResumptionExpected = Yes


# ===========================================================

[7-renegotiate-aead-to-non-aead]
ssl_conf = 7-renegotiate-aead-to-non-aead-ssl

[7-renegotiate-aead-to-non-aead-ssl]
server = 7-renegotiate-aead-to-non-aead-server
client = 7-renegotiate-aead-to-non-aead-client

[7-renegotiate-aead-to-non-aead-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = NoResumptionOnRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[7-renegotiate-aead-to-non-aead-client]
CipherString = AES128-GCM-SHA256
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-7]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = TLS
ResumptionExpected = No
client = 7-renegotiate-aead-to-non-aead-client-extra

[7-renegotiate-aead-to-non-aead-client-extra]
RenegotiateCiphers = AES128-SHA


# ===========================================================

[8-renegotiate-non-aead-to-aead]
ssl_conf = 8-renegotiate-non-aead-to-aead-ssl

[8-renegotiate-non-aead-to-aead-ssl]
server = 8-renegotiate-non-aead-to-aead-server
client = 8-renegotiate-non-aead-to-aead-client

[8-renegotiate-non-aead-to-aead-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = NoResumptionOnRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[8-renegotiate-non-aead-to-aead-client]
CipherString = AES128-SHA
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-8]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = TLS
ResumptionExpected = No
client = 8-renegotiate-non-aead-to-aead-client-extra

[8-renegotiate-non-aead-to-aead-client-extra]
RenegotiateCiphers = AES128-GCM-SHA256


# ===========================================================

[9-renegotiate-non-aead-to-non-aead]
ssl_conf = 9-renegotiate-non-aead-to-non-aead-ssl

[9-renegotiate-non-aead-to-non-aead-ssl]
server = 9-renegotiate-non-aead-to-non-aead-server
client = 9-renegotiate-non-aead-to-non-aead-client

[9-renegotiate-non-aead-to-non-aead-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = NoResumptionOnRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[9-renegotiate-non-aead-to-non-aead-client]
CipherString = AES128-SHA
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-9]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = TLS
ResumptionExpected = No
client = 9-renegotiate-non-aead-to-non-aead-client-extra

[9-renegotiate-non-aead-to-non-aead-client-extra]
RenegotiateCiphers = AES256-SHA


# ===========================================================

[10-renegotiate-aead-to-aead]
ssl_conf = 10-renegotiate-aead-to-aead-ssl

[10-renegotiate-aead-to-aead-ssl]
server = 10-renegotiate-aead-to-aead-server
client = 10-renegotiate-aead-to-aead-client

[10-renegotiate-aead-to-aead-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = NoResumptionOnRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[10-renegotiate-aead-to-aead-client]
CipherString = AES128-GCM-SHA256
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-10]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = TLS
ResumptionExpected = No
client = 10-renegotiate-aead-to-aead-client-extra

[10-renegotiate-aead-to-aead-client-extra]
RenegotiateCiphers = AES256-GCM-SHA384


# ===========================================================

[11-no-renegotiation-server-by-client]
ssl_conf = 11-no-renegotiation-server-by-client-ssl

[11-no-renegotiation-server-by-client-ssl]
server = 11-no-renegotiation-server-by-client-server
client = 11-no-renegotiation-server-by-client-client

[11-no-renegotiation-server-by-client-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
Options = NoRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[11-no-renegotiation-server-by-client-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-11]
ExpectedResult = ClientFail
HandshakeMode = RenegotiateClient
Method = TLS
ResumptionExpected = No


# ===========================================================

[12-no-renegotiation-server-by-server]
ssl_conf = 12-no-renegotiation-server-by-server-ssl

[12-no-renegotiation-server-by-server-ssl]
server = 12-no-renegotiation-server-by-server-server
client = 12-no-renegotiation-server-by-server-client

[12-no-renegotiation-server-by-server-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
Options = NoRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[12-no-renegotiation-server-by-server-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-12]
ExpectedResult = ServerFail
HandshakeMode = RenegotiateServer
Method = TLS
ResumptionExpected = No


# ===========================================================

[13-no-renegotiation-client-by-server]
ssl_conf = 13-no-renegotiation-client-by-server-ssl

[13-no-renegotiation-client-by-server-ssl]
server = 13-no-renegotiation-client-by-server-server
client = 13-no-renegotiation-client-by-server-client

[13-no-renegotiation-client-by-server-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[13-no-renegotiation-client-by-server-client]
CipherString = DEFAULT
Options = NoRenegotiation
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-13]
ExpectedResult = ServerFail
HandshakeMode = RenegotiateServer
Method = TLS
ResumptionExpected = No


# ===========================================================

[14-no-renegotiation-client-by-client]
ssl_conf = 14-no-renegotiation-client-by-client-ssl

[14-no-renegotiation-client-by-client-ssl]
server = 14-no-renegotiation-client-by-client-server
client = 14-no-renegotiation-client-by-client-client

[14-no-renegotiation-client-by-client-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[14-no-renegotiation-client-by-client-client]
CipherString = DEFAULT
Options = NoRenegotiation
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-14]
ExpectedResult = ClientFail
HandshakeMode = RenegotiateClient
Method = TLS
ResumptionExpected = No


# ===========================================================

[15-no-extms-on-renegotiation]
ssl_conf = 15-no-extms-on-renegotiation-ssl

[15-no-extms-on-renegotiation-ssl]
server = 15-no-extms-on-renegotiation-server
client = 15-no-extms-on-renegotiation-client

[15-no-extms-on-renegotiation-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[15-no-extms-on-renegotiation-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-15]
ExpectedResult = ServerFail
HandshakeMode = RenegotiateClient
Method = TLS
ResumptionExpected = No
client = 15-no-extms-on-renegotiation-client-extra

[15-no-extms-on-renegotiation-client-extra]
RenegotiateNoExtms = Yes


# ===========================================================

[16-allow-client-renegotiation]
ssl_conf = 16-allow-client-renegotiation-ssl

[16-allow-client-renegotiation-ssl]
server = 16-allow-client-renegotiation-server
client = 16-allow-client-renegotiation-client

[16-allow-client-renegotiation-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[16-allow-client-renegotiation-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-16]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = TLS
ResumptionExpected = Yes


# ===========================================================

[17-no-client-renegotiation]
ssl_conf = 17-no-client-renegotiation-ssl

[17-no-client-renegotiation-ssl]
server = 17-no-client-renegotiation-server
client = 17-no-client-renegotiation-client

[17-no-client-renegotiation-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
Options = -ClientRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[17-no-client-renegotiation-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-17]
ExpectedResult = ClientFail
ExpectedServerAlert = NoRenegotiation
HandshakeMode = RenegotiateClient
Method = TLS
ResumptionExpected = No


                                                                                                               node-23.7.0/deps/openssl/openssl/test/ssl-tests/17-renegotiate.cnf.in                               0000664 0000000 0000000 00000021505 14746647661 0025431 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2022 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test Renegotiation

use strict;
use warnings;

package ssltests;
use OpenSSL::Test::Utils;

our @tests = (
    {
        name => "renegotiate-client-no-resume",
        server => {
            "Options" => "NoResumptionOnRenegotiation",
            "MaxProtocol" => "TLSv1.2"
        },
        client => {},
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateClient",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "renegotiate-client-resume",
        server => {
            "MaxProtocol" => "TLSv1.2"
        },
        client => {},
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateClient",
            "ResumptionExpected" => "Yes",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "renegotiate-server-no-resume",
        server => {
            "Options" => "NoResumptionOnRenegotiation",
            "MaxProtocol" => "TLSv1.2"
        },
        client => {},
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateServer",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "renegotiate-server-resume",
        server => {
            "MaxProtocol" => "TLSv1.2"
        },
        client => {},
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateServer",
            "ResumptionExpected" => "Yes",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "renegotiate-client-auth-require",
        server => {
            "Options" => "NoResumptionOnRenegotiation",
            "MaxProtocol" => "TLSv1.2",
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "Require",
        },
        client => {
            "Certificate" => test_pem("ee-client-chain.pem"),
            "PrivateKey"  => test_pem("ee-key.pem"),
        },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateServer",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "renegotiate-client-auth-once",
        server => {
            "Options" => "NoResumptionOnRenegotiation",
            "MaxProtocol" => "TLSv1.2",
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "Once",
        },
        client => {
            "Certificate" => test_pem("ee-client-chain.pem"),
            "PrivateKey"  => test_pem("ee-key.pem"),
        },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateServer",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
#       Just test that UnsafeLegacyServerConnect option
#       exists, it won't have any real effect here
        name => "renegotiate-client-legacy-connect",
        server => {
            "MaxProtocol" => "TLSv1.2"
        },
        client => {
            "Options" => "UnsafeLegacyServerConnect",
        },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateClient",
            "ResumptionExpected" => "Yes",
            "ExpectedResult" => "Success"
        }
    },
);
our @tests_tls1_2 = (
    {
        name => "renegotiate-aead-to-non-aead",
        server => {
            "Options" => "NoResumptionOnRenegotiation",
        },
        client => {
            "CipherString" => "AES128-GCM-SHA256",
            "MaxProtocol" => "TLSv1.2",
            extra => {
                "RenegotiateCiphers" => "AES128-SHA"
            }
        },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateClient",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "renegotiate-non-aead-to-aead",
        server => {
            "Options" => "NoResumptionOnRenegotiation",
        },
        client => {
            "CipherString" => "AES128-SHA",
            "MaxProtocol" => "TLSv1.2",
            extra => {
                "RenegotiateCiphers" => "AES128-GCM-SHA256"
            }
        },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateClient",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "renegotiate-non-aead-to-non-aead",
        server => {
            "Options" => "NoResumptionOnRenegotiation",
        },
        client => {
            "CipherString" => "AES128-SHA",
            "MaxProtocol" => "TLSv1.2",
            extra => {
                "RenegotiateCiphers" => "AES256-SHA"
            }
        },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateClient",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "renegotiate-aead-to-aead",
        server => {
            "Options" => "NoResumptionOnRenegotiation",
        },
        client => {
            "CipherString" => "AES128-GCM-SHA256",
            "MaxProtocol" => "TLSv1.2",
            extra => {
                "RenegotiateCiphers" => "AES256-GCM-SHA384"
            }
        },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateClient",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "no-renegotiation-server-by-client",
        server => {
            "Options" => "NoRenegotiation",
            "MaxProtocol" => "TLSv1.2"
        },
        client => { },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateClient",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "ClientFail"
        }
    },
    {
        name => "no-renegotiation-server-by-server",
        server => {
            "Options" => "NoRenegotiation",
            "MaxProtocol" => "TLSv1.2"
        },
        client => { },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateServer",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "ServerFail"
        }
    },
    {
        name => "no-renegotiation-client-by-server",
        server => {
            "MaxProtocol" => "TLSv1.2"
        },
        client => {
            "Options" => "NoRenegotiation",
        },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateServer",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "ServerFail"
        }
    },
    {
        name => "no-renegotiation-client-by-client",
        server => {
            "MaxProtocol" => "TLSv1.2"
        },
        client => {
            "Options" => "NoRenegotiation",
        },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateClient",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "ClientFail"
        }
    },
    {
        name => "no-extms-on-renegotiation",
        server => {
            "MaxProtocol" => "TLSv1.2"
        },
        client => {
            "MaxProtocol" => "TLSv1.2",
            extra => {
                "RenegotiateNoExtms" => "Yes"
            }
        },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateClient",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "ServerFail"
        }
    },
    {
        name => "allow-client-renegotiation",
        server => {
            "MaxProtocol" => "TLSv1.2",
        },
        client => {
            "MaxProtocol" => "TLSv1.2"
        },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateClient",
            "ResumptionExpected" => "Yes",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "no-client-renegotiation",
        server => {
            "MaxProtocol" => "TLSv1.2",
            "Options" => "-ClientRenegotiation"
        },
        client => {
            "MaxProtocol" => "TLSv1.2",
        },
        test => {
            "Method" => "TLS",
            "HandshakeMode" => "RenegotiateClient",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "ClientFail",
            "ExpectedServerAlert" => "NoRenegotiation"
        }
    }
);

push @tests, @tests_tls1_2 unless disabled("tls1_2");
                                                                                                                                                                                           node-23.7.0/deps/openssl/openssl/test/ssl-tests/18-dtls-renegotiate.cnf                             0000664 0000000 0000000 00000017304 14746647661 0025773 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 9

test-0 = 0-renegotiate-client-no-resume
test-1 = 1-renegotiate-client-resume
test-2 = 2-renegotiate-server-resume
test-3 = 3-renegotiate-client-auth-require
test-4 = 4-renegotiate-client-auth-once
test-5 = 5-renegotiate-aead-to-non-aead
test-6 = 6-renegotiate-non-aead-to-aead
test-7 = 7-renegotiate-non-aead-to-non-aead
test-8 = 8-renegotiate-aead-to-aead
# ===========================================================

[0-renegotiate-client-no-resume]
ssl_conf = 0-renegotiate-client-no-resume-ssl

[0-renegotiate-client-no-resume-ssl]
server = 0-renegotiate-client-no-resume-server
client = 0-renegotiate-client-no-resume-client

[0-renegotiate-client-no-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = NoResumptionOnRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-renegotiate-client-no-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = DTLS
ResumptionExpected = No
UseSCTP = No


# ===========================================================

[1-renegotiate-client-resume]
ssl_conf = 1-renegotiate-client-resume-ssl

[1-renegotiate-client-resume-ssl]
server = 1-renegotiate-client-resume-server
client = 1-renegotiate-client-resume-client

[1-renegotiate-client-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-renegotiate-client-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = DTLS
ResumptionExpected = Yes
UseSCTP = No


# ===========================================================

[2-renegotiate-server-resume]
ssl_conf = 2-renegotiate-server-resume-ssl

[2-renegotiate-server-resume-ssl]
server = 2-renegotiate-server-resume-server
client = 2-renegotiate-server-resume-client

[2-renegotiate-server-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-renegotiate-server-resume-client]
CipherString = DEFAULT:@SECLEVEL=0
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ExpectedResult = Success
HandshakeMode = RenegotiateServer
Method = DTLS
ResumptionExpected = No
UseSCTP = No


# ===========================================================

[3-renegotiate-client-auth-require]
ssl_conf = 3-renegotiate-client-auth-require-ssl

[3-renegotiate-client-auth-require-ssl]
server = 3-renegotiate-client-auth-require-server
client = 3-renegotiate-client-auth-require-client

[3-renegotiate-client-auth-require-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Require

[3-renegotiate-client-auth-require-client]
Certificate = ${ENV::TEST_CERTS_DIR}/ee-client-chain.pem
CipherString = DEFAULT:@SECLEVEL=0
PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-key.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
ExpectedResult = Success
HandshakeMode = RenegotiateServer
Method = DTLS
ResumptionExpected = No
UseSCTP = No


# ===========================================================

[4-renegotiate-client-auth-once]
ssl_conf = 4-renegotiate-client-auth-once-ssl

[4-renegotiate-client-auth-once-ssl]
server = 4-renegotiate-client-auth-once-server
client = 4-renegotiate-client-auth-once-client

[4-renegotiate-client-auth-once-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Once

[4-renegotiate-client-auth-once-client]
Certificate = ${ENV::TEST_CERTS_DIR}/ee-client-chain.pem
CipherString = DEFAULT:@SECLEVEL=0
PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-key.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-4]
ExpectedResult = Success
HandshakeMode = RenegotiateServer
Method = DTLS
ResumptionExpected = No
UseSCTP = No


# ===========================================================

[5-renegotiate-aead-to-non-aead]
ssl_conf = 5-renegotiate-aead-to-non-aead-ssl

[5-renegotiate-aead-to-non-aead-ssl]
server = 5-renegotiate-aead-to-non-aead-server
client = 5-renegotiate-aead-to-non-aead-client

[5-renegotiate-aead-to-non-aead-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = NoResumptionOnRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[5-renegotiate-aead-to-non-aead-client]
CipherString = AES128-GCM-SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-5]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = DTLS
ResumptionExpected = No
UseSCTP = No
client = 5-renegotiate-aead-to-non-aead-client-extra

[5-renegotiate-aead-to-non-aead-client-extra]
RenegotiateCiphers = AES128-SHA


# ===========================================================

[6-renegotiate-non-aead-to-aead]
ssl_conf = 6-renegotiate-non-aead-to-aead-ssl

[6-renegotiate-non-aead-to-aead-ssl]
server = 6-renegotiate-non-aead-to-aead-server
client = 6-renegotiate-non-aead-to-aead-client

[6-renegotiate-non-aead-to-aead-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = NoResumptionOnRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[6-renegotiate-non-aead-to-aead-client]
CipherString = AES128-SHA
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-6]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = DTLS
ResumptionExpected = No
UseSCTP = No
client = 6-renegotiate-non-aead-to-aead-client-extra

[6-renegotiate-non-aead-to-aead-client-extra]
RenegotiateCiphers = AES128-GCM-SHA256


# ===========================================================

[7-renegotiate-non-aead-to-non-aead]
ssl_conf = 7-renegotiate-non-aead-to-non-aead-ssl

[7-renegotiate-non-aead-to-non-aead-ssl]
server = 7-renegotiate-non-aead-to-non-aead-server
client = 7-renegotiate-non-aead-to-non-aead-client

[7-renegotiate-non-aead-to-non-aead-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = NoResumptionOnRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[7-renegotiate-non-aead-to-non-aead-client]
CipherString = AES128-SHA
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-7]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = DTLS
ResumptionExpected = No
UseSCTP = No
client = 7-renegotiate-non-aead-to-non-aead-client-extra

[7-renegotiate-non-aead-to-non-aead-client-extra]
RenegotiateCiphers = AES256-SHA


# ===========================================================

[8-renegotiate-aead-to-aead]
ssl_conf = 8-renegotiate-aead-to-aead-ssl

[8-renegotiate-aead-to-aead-ssl]
server = 8-renegotiate-aead-to-aead-server
client = 8-renegotiate-aead-to-aead-client

[8-renegotiate-aead-to-aead-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = NoResumptionOnRenegotiation
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[8-renegotiate-aead-to-aead-client]
CipherString = AES128-GCM-SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-8]
ExpectedResult = Success
HandshakeMode = RenegotiateClient
Method = DTLS
ResumptionExpected = No
UseSCTP = No
client = 8-renegotiate-aead-to-aead-client-extra

[8-renegotiate-aead-to-aead-client-extra]
RenegotiateCiphers = AES256-GCM-SHA384


                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/openssl/openssl/test/ssl-tests/18-dtls-renegotiate.cnf.in                          0000664 0000000 0000000 00000016024 14746647661 0026376 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2021 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test Renegotiation

use strict;
use warnings;

package ssltests;
use OpenSSL::Test::Utils;

our $fips_mode;

our @tests = ();

foreach my $sctp ("No", "Yes")
{
    next if disabled("sctp") && $sctp eq "Yes";
    next if disabled("dtls1_2") && $fips_mode;

    my $suffix = ($sctp eq "No") ? "" : "-sctp";
    our @tests_basic = (
        {
            name => "renegotiate-client-no-resume".$suffix,
            server => {
                "CipherString" => 'DEFAULT:@SECLEVEL=0',
                "Options" => "NoResumptionOnRenegotiation"
            },
            client => {
                "CipherString" => 'DEFAULT:@SECLEVEL=0'
            },
            test => {
                "Method" => "DTLS",
                "UseSCTP" => $sctp,
                "HandshakeMode" => "RenegotiateClient",
                "ResumptionExpected" => "No",
                "ExpectedResult" => "Success"
            }
        },
        {
            name => "renegotiate-client-resume".$suffix,
            server => {
                "CipherString" => 'DEFAULT:@SECLEVEL=0'
            },
            client => {
                "CipherString" => 'DEFAULT:@SECLEVEL=0'
            },
            test => {
                "Method" => "DTLS",
                "UseSCTP" => $sctp,
                "HandshakeMode" => "RenegotiateClient",
                "ResumptionExpected" => "Yes",
                "ExpectedResult" => "Success"
            }
        },
        # Note: Unlike the TLS tests, we will never do resumption with server
        # initiated reneg. This is because an OpenSSL DTLS client will always do a full
        # handshake (i.e. it doesn't supply a session id) when it receives a
        # HelloRequest. This is different to the OpenSSL TLS implementation where an
        # OpenSSL client will always try an abbreviated handshake (i.e. it will supply
        # the session id). This goes all the way to commit 48ae85b6f when abbreviated
        # handshake support was first added. Neither behaviour is wrong, but the
        # discrepancy is strange. TODO: Should we harmonise the TLS and DTLS behaviour,
        # and if so, what to?
        {
            name => "renegotiate-server-resume".$suffix,
            server => {
                "CipherString" => 'DEFAULT:@SECLEVEL=0'
            },
            client => {
                "CipherString" => 'DEFAULT:@SECLEVEL=0'
            },
            test => {
                "Method" => "DTLS",
                "UseSCTP" => $sctp,
                "HandshakeMode" => "RenegotiateServer",
                "ResumptionExpected" => "No",
                "ExpectedResult" => "Success"
            }
        },
        {
            name => "renegotiate-client-auth-require".$suffix,
            server => {
                "VerifyCAFile" => test_pem("root-cert.pem"),
                "VerifyMode" => "Require",
                "CipherString" => 'DEFAULT:@SECLEVEL=0'
            },
            client => {
                "Certificate" => test_pem("ee-client-chain.pem"),
                "PrivateKey"  => test_pem("ee-key.pem"),
                "CipherString" => 'DEFAULT:@SECLEVEL=0'
            },
            test => {
                "Method" => "DTLS",
                "UseSCTP" => $sctp,
                "HandshakeMode" => "RenegotiateServer",
                "ResumptionExpected" => "No",
                "ExpectedResult" => "Success"
            }
        },
        {
            name => "renegotiate-client-auth-once".$suffix,
            server => {
                "VerifyCAFile" => test_pem("root-cert.pem"),
                "VerifyMode" => "Once",
                "CipherString" => 'DEFAULT:@SECLEVEL=0'
            },
            client => {
                "Certificate" => test_pem("ee-client-chain.pem"),
                "PrivateKey"  => test_pem("ee-key.pem"),
                "CipherString" => 'DEFAULT:@SECLEVEL=0'
            },
            test => {
                "Method" => "DTLS",
                "UseSCTP" => $sctp,
                "HandshakeMode" => "RenegotiateServer",
                "ResumptionExpected" => "No",
                "ExpectedResult" => "Success"
            }
        }
    );
    push @tests, @tests_basic;

    next if disabled("dtls1_2");
    our @tests_dtls1_2 = (
        {
            name => "renegotiate-aead-to-non-aead".$suffix,
            server => {
                "Options" => "NoResumptionOnRenegotiation"
            },
            client => {
                "CipherString" => "AES128-GCM-SHA256",
                extra => {
                    "RenegotiateCiphers" => "AES128-SHA"
                }
            },
            test => {
                "Method" => "DTLS",
                "UseSCTP" => $sctp,
                "HandshakeMode" => "RenegotiateClient",
                "ResumptionExpected" => "No",
                "ExpectedResult" => "Success"
            }
        },
        {
            name => "renegotiate-non-aead-to-aead".$suffix,
            server => {
                "Options" => "NoResumptionOnRenegotiation"
            },
            client => {
                "CipherString" => "AES128-SHA",
                extra => {
                    "RenegotiateCiphers" => "AES128-GCM-SHA256"
                }
            },
            test => {
                "Method" => "DTLS",
                "UseSCTP" => $sctp,
                "HandshakeMode" => "RenegotiateClient",
                "ResumptionExpected" => "No",
                "ExpectedResult" => "Success"
            }
        },
        {
            name => "renegotiate-non-aead-to-non-aead".$suffix,
            server => {
                "Options" => "NoResumptionOnRenegotiation"
            },
            client => {
                "CipherString" => "AES128-SHA",
                extra => {
                    "RenegotiateCiphers" => "AES256-SHA"
                }
            },
            test => {
                "Method" => "DTLS",
                "UseSCTP" => $sctp,
                "HandshakeMode" => "RenegotiateClient",
                "ResumptionExpected" => "No",
                "ExpectedResult" => "Success"
            }
        },
        {
            name => "renegotiate-aead-to-aead".$suffix,
            server => {
                "Options" => "NoResumptionOnRenegotiation"
            },
            client => {
                "CipherString" => "AES128-GCM-SHA256",
                extra => {
                    "RenegotiateCiphers" => "AES256-GCM-SHA384"
                }
            },
            test => {
                "Method" => "DTLS",
                "UseSCTP" => $sctp,
                "HandshakeMode" => "RenegotiateClient",
                "ResumptionExpected" => "No",
                "ExpectedResult" => "Success"
            }
        },
    );
    push @tests, @tests_dtls1_2;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/openssl/openssl/test/ssl-tests/19-mac-then-encrypt.cnf                             0000664 0000000 0000000 00000016006 14746647661 0025676 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 9

test-0 = 0-disable-encrypt-then-mac-server-sha
test-1 = 1-disable-encrypt-then-mac-client-sha
test-2 = 2-disable-encrypt-then-mac-both-sha
test-3 = 3-disable-encrypt-then-mac-server-sha2
test-4 = 4-disable-encrypt-then-mac-client-sha2
test-5 = 5-disable-encrypt-then-mac-both-sha2
test-6 = 6-disable-encrypt-then-mac-server-sha-tls1
test-7 = 7-disable-encrypt-then-mac-client-sha-tls1
test-8 = 8-disable-encrypt-then-mac-both-sha-tls1
# ===========================================================

[0-disable-encrypt-then-mac-server-sha]
ssl_conf = 0-disable-encrypt-then-mac-server-sha-ssl

[0-disable-encrypt-then-mac-server-sha-ssl]
server = 0-disable-encrypt-then-mac-server-sha-server
client = 0-disable-encrypt-then-mac-server-sha-client

[0-disable-encrypt-then-mac-server-sha-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = -EncryptThenMac
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-disable-encrypt-then-mac-server-sha-client]
CipherString = AES128-SHA
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = Success


# ===========================================================

[1-disable-encrypt-then-mac-client-sha]
ssl_conf = 1-disable-encrypt-then-mac-client-sha-ssl

[1-disable-encrypt-then-mac-client-sha-ssl]
server = 1-disable-encrypt-then-mac-client-sha-server
client = 1-disable-encrypt-then-mac-client-sha-client

[1-disable-encrypt-then-mac-client-sha-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-disable-encrypt-then-mac-client-sha-client]
CipherString = AES128-SHA
MaxProtocol = TLSv1.2
Options = -EncryptThenMac
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedResult = Success


# ===========================================================

[2-disable-encrypt-then-mac-both-sha]
ssl_conf = 2-disable-encrypt-then-mac-both-sha-ssl

[2-disable-encrypt-then-mac-both-sha-ssl]
server = 2-disable-encrypt-then-mac-both-sha-server
client = 2-disable-encrypt-then-mac-both-sha-client

[2-disable-encrypt-then-mac-both-sha-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = -EncryptThenMac
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-disable-encrypt-then-mac-both-sha-client]
CipherString = AES128-SHA
MaxProtocol = TLSv1.2
Options = -EncryptThenMac
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ExpectedResult = Success


# ===========================================================

[3-disable-encrypt-then-mac-server-sha2]
ssl_conf = 3-disable-encrypt-then-mac-server-sha2-ssl

[3-disable-encrypt-then-mac-server-sha2-ssl]
server = 3-disable-encrypt-then-mac-server-sha2-server
client = 3-disable-encrypt-then-mac-server-sha2-client

[3-disable-encrypt-then-mac-server-sha2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = -EncryptThenMac
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-disable-encrypt-then-mac-server-sha2-client]
CipherString = AES128-SHA256
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
ExpectedResult = Success


# ===========================================================

[4-disable-encrypt-then-mac-client-sha2]
ssl_conf = 4-disable-encrypt-then-mac-client-sha2-ssl

[4-disable-encrypt-then-mac-client-sha2-ssl]
server = 4-disable-encrypt-then-mac-client-sha2-server
client = 4-disable-encrypt-then-mac-client-sha2-client

[4-disable-encrypt-then-mac-client-sha2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[4-disable-encrypt-then-mac-client-sha2-client]
CipherString = AES128-SHA256
MaxProtocol = TLSv1.2
Options = -EncryptThenMac
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-4]
ExpectedResult = Success


# ===========================================================

[5-disable-encrypt-then-mac-both-sha2]
ssl_conf = 5-disable-encrypt-then-mac-both-sha2-ssl

[5-disable-encrypt-then-mac-both-sha2-ssl]
server = 5-disable-encrypt-then-mac-both-sha2-server
client = 5-disable-encrypt-then-mac-both-sha2-client

[5-disable-encrypt-then-mac-both-sha2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = -EncryptThenMac
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[5-disable-encrypt-then-mac-both-sha2-client]
CipherString = AES128-SHA256
MaxProtocol = TLSv1.2
Options = -EncryptThenMac
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-5]
ExpectedResult = Success


# ===========================================================

[6-disable-encrypt-then-mac-server-sha-tls1]
ssl_conf = 6-disable-encrypt-then-mac-server-sha-tls1-ssl

[6-disable-encrypt-then-mac-server-sha-tls1-ssl]
server = 6-disable-encrypt-then-mac-server-sha-tls1-server
client = 6-disable-encrypt-then-mac-server-sha-tls1-client

[6-disable-encrypt-then-mac-server-sha-tls1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -EncryptThenMac
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[6-disable-encrypt-then-mac-server-sha-tls1-client]
CipherString = AES128-SHA@SECLEVEL=0
MaxProtocol = TLSv1
MinProtocol = TLSv1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-6]
ExpectedResult = Success


# ===========================================================

[7-disable-encrypt-then-mac-client-sha-tls1]
ssl_conf = 7-disable-encrypt-then-mac-client-sha-tls1-ssl

[7-disable-encrypt-then-mac-client-sha-tls1-ssl]
server = 7-disable-encrypt-then-mac-client-sha-tls1-server
client = 7-disable-encrypt-then-mac-client-sha-tls1-client

[7-disable-encrypt-then-mac-client-sha-tls1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[7-disable-encrypt-then-mac-client-sha-tls1-client]
CipherString = AES128-SHA@SECLEVEL=0
MaxProtocol = TLSv1
MinProtocol = TLSv1
Options = -EncryptThenMac
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-7]
ExpectedResult = Success


# ===========================================================

[8-disable-encrypt-then-mac-both-sha-tls1]
ssl_conf = 8-disable-encrypt-then-mac-both-sha-tls1-ssl

[8-disable-encrypt-then-mac-both-sha-tls1-ssl]
server = 8-disable-encrypt-then-mac-both-sha-tls1-server
client = 8-disable-encrypt-then-mac-both-sha-tls1-client

[8-disable-encrypt-then-mac-both-sha-tls1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
Options = -EncryptThenMac
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[8-disable-encrypt-then-mac-both-sha-tls1-client]
CipherString = AES128-SHA@SECLEVEL=0
MaxProtocol = TLSv1
MinProtocol = TLSv1
Options = -EncryptThenMac
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-8]
ExpectedResult = Success


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/openssl/openssl/test/ssl-tests/19-mac-then-encrypt.cnf.in                          0000664 0000000 0000000 00000007577 14746647661 0026320 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## SSL test configurations

package ssltests;

use OpenSSL::Test::Utils;

our $fips_mode;

our @tests = (
    {
        name => "disable-encrypt-then-mac-server-sha",
        server => {
          "Options" => "-EncryptThenMac",
        },
        client => {
          "CipherString" => "AES128-SHA",
          "MaxProtocol" => "TLSv1.2"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
    {
        name => "disable-encrypt-then-mac-client-sha",
        server => {
        },
        client => {
          "CipherString" => "AES128-SHA",
          "Options" => "-EncryptThenMac",
          "MaxProtocol" => "TLSv1.2"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
    {
        name => "disable-encrypt-then-mac-both-sha",
        server => {
          "Options" => "-EncryptThenMac",
        },
        client => {
          "CipherString" => "AES128-SHA",
          "Options" => "-EncryptThenMac",
          "MaxProtocol" => "TLSv1.2"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
);

my @tests_tls1_2 = (
    {
        name => "disable-encrypt-then-mac-server-sha2",
        server => {
          "Options" => "-EncryptThenMac",
        },
        client => {
          "CipherString" => "AES128-SHA256",
          "MaxProtocol" => "TLSv1.2"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
    {
        name => "disable-encrypt-then-mac-client-sha2",
        server => {
        },
        client => {
          "CipherString" => "AES128-SHA256",
          "Options" => "-EncryptThenMac",
          "MaxProtocol" => "TLSv1.2"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
    {
        name => "disable-encrypt-then-mac-both-sha2",
        server => {
          "Options" => "-EncryptThenMac",
        },
        client => {
          "CipherString" => "AES128-SHA256",
          "Options" => "-EncryptThenMac",
          "MaxProtocol" => "TLSv1.2"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
);

our @tests_tls1 = (
    {
        name => "disable-encrypt-then-mac-server-sha-tls1",
        server => {
          "CipherString" => 'DEFAULT:@SECLEVEL=0',
          "Options" => "-EncryptThenMac",
        },
        client => {
          "CipherString" => 'AES128-SHA@SECLEVEL=0',
          "MinProtocol" => "TLSv1",
          "MaxProtocol" => "TLSv1"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
    {
        name => "disable-encrypt-then-mac-client-sha-tls1",
        server => {
          "CipherString" => 'DEFAULT:@SECLEVEL=0',
        },
        client => {
          "CipherString" => 'AES128-SHA@SECLEVEL=0',
          "Options" => "-EncryptThenMac",
          "MinProtocol" => "TLSv1",
          "MaxProtocol" => "TLSv1"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
    {
        name => "disable-encrypt-then-mac-both-sha-tls1",
        server => {
          "CipherString" => 'DEFAULT:@SECLEVEL=0',
          "Options" => "-EncryptThenMac",
        },
        client => {
          "CipherString" => 'AES128-SHA@SECLEVEL=0',
          "Options" => "-EncryptThenMac",
          "MinProtocol" => "TLSv1",
          "MaxProtocol" => "TLSv1"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
);


push @tests, @tests_tls1_2 unless disabled("tls1_2");
push @tests, @tests_tls1 unless disabled("tls1") || $fips_mode;
                                                                                                                                 node-23.7.0/deps/openssl/openssl/test/ssl-tests/20-cert-select.cnf                                  0000664 0000000 0000000 00000201035 14746647661 0024720 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 57

test-0 = 0-ECDSA CipherString Selection
test-1 = 1-ECDSA CipherString Selection
test-2 = 2-ECDSA CipherString Selection
test-3 = 3-RSA CipherString Selection
test-4 = 4-P-256 CipherString and Signature Algorithm Selection
test-5 = 5-ECDSA CipherString Selection, no ECDSA certificate
test-6 = 6-ECDSA Signature Algorithm Selection
test-7 = 7-ECDSA Signature Algorithm Selection SHA384
test-8 = 8-ECDSA Signature Algorithm Selection compressed point
test-9 = 9-ECDSA Signature Algorithm Selection, no ECDSA certificate
test-10 = 10-RSA Signature Algorithm Selection
test-11 = 11-RSA-PSS Signature Algorithm Selection
test-12 = 12-RSA key exchange with all RSA certificate types
test-13 = 13-Suite B P-256 Hash Algorithm Selection
test-14 = 14-Suite B P-384 Hash Algorithm Selection
test-15 = 15-Ed25519 CipherString and Signature Algorithm Selection
test-16 = 16-Ed448 CipherString and Signature Algorithm Selection
test-17 = 17-TLS 1.2 Ed25519 Client Auth
test-18 = 18-TLS 1.2 Ed448 Client Auth
test-19 = 19-ECDSA Signature Algorithm Selection SHA1
test-20 = 20-ECDSA with brainpool
test-21 = 21-Ed25519 CipherString and Curves Selection
test-22 = 22-Ed448 CipherString and Curves Selection
test-23 = 23-RSA-PSS Certificate CipherString Selection
test-24 = 24-RSA-PSS Certificate Legacy Signature Algorithm Selection
test-25 = 25-RSA-PSS Certificate Unified Signature Algorithm Selection
test-26 = 26-Only RSA-PSS Certificate
test-27 = 27-Only RSA-PSS Certificate Valid Signature Algorithms
test-28 = 28-RSA-PSS Certificate, no PSS signature algorithms
test-29 = 29-Only RSA-PSS Restricted Certificate
test-30 = 30-RSA-PSS Restricted Certificate Valid Signature Algorithms
test-31 = 31-RSA-PSS Restricted Cert client prefers invalid Signature Algorithm
test-32 = 32-RSA-PSS Restricted Certificate Invalid Signature Algorithms
test-33 = 33-RSA key exchange with only RSA-PSS certificate
test-34 = 34-Only RSA-PSS Certificate, TLS v1.1
test-35 = 35-TLS 1.3 ECDSA Signature Algorithm Selection
test-36 = 36-TLS 1.3 ECDSA Signature Algorithm Selection compressed point
test-37 = 37-TLS 1.3 ECDSA Signature Algorithm Selection SHA1
test-38 = 38-TLS 1.3 ECDSA Signature Algorithm Selection with PSS
test-39 = 39-TLS 1.3 RSA Signature Algorithm Selection SHA384 with PSS
test-40 = 40-TLS 1.3 ECDSA Signature Algorithm Selection, no ECDSA certificate
test-41 = 41-TLS 1.3 RSA Signature Algorithm Selection, no PSS
test-42 = 42-TLS 1.3 RSA-PSS Signature Algorithm Selection
test-43 = 43-TLS 1.3 RSA Client Auth Signature Algorithm Selection
test-44 = 44-TLS 1.3 RSA Client Auth Signature Algorithm Selection non-empty CA Names
test-45 = 45-TLS 1.3 ECDSA Client Auth Signature Algorithm Selection
test-46 = 46-TLS 1.3 Ed25519 Signature Algorithm Selection
test-47 = 47-TLS 1.3 Ed448 Signature Algorithm Selection
test-48 = 48-TLS 1.3 Ed25519 CipherString and Groups Selection
test-49 = 49-TLS 1.3 Ed448 CipherString and Groups Selection
test-50 = 50-TLS 1.3 Ed25519 Client Auth
test-51 = 51-TLS 1.3 Ed448 Client Auth
test-52 = 52-TLS 1.3 ECDSA with brainpool but no suitable groups
test-53 = 53-TLS 1.3 ECDSA with brainpool
test-54 = 54-TLS 1.2 DSA Certificate Test
test-55 = 55-TLS 1.3 Client Auth No TLS 1.3 Signature Algorithms
test-56 = 56-TLS 1.3 DSA Certificate Test
# ===========================================================

[0-ECDSA CipherString Selection]
ssl_conf = 0-ECDSA CipherString Selection-ssl

[0-ECDSA CipherString Selection-ssl]
server = 0-ECDSA CipherString Selection-server
client = 0-ECDSA CipherString Selection-client

[0-ECDSA CipherString Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-ECDSA CipherString Selection-client]
CipherString = aECDSA
MaxProtocol = TLSv1.2
RequestCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = Success
ExpectedServerCANames = empty
ExpectedServerCertType = P-256
ExpectedServerSignType = EC


# ===========================================================

[1-ECDSA CipherString Selection]
ssl_conf = 1-ECDSA CipherString Selection-ssl

[1-ECDSA CipherString Selection-ssl]
server = 1-ECDSA CipherString Selection-server
client = 1-ECDSA CipherString Selection-client

[1-ECDSA CipherString Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Groups = P-384
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-ECDSA CipherString Selection-client]
CipherString = aECDSA
Groups = P-256:P-384
MaxProtocol = TLSv1.2
RequestCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedResult = Success
ExpectedServerCANames = empty
ExpectedServerCertType = P-256
ExpectedServerSignType = EC


# ===========================================================

[2-ECDSA CipherString Selection]
ssl_conf = 2-ECDSA CipherString Selection-ssl

[2-ECDSA CipherString Selection-ssl]
server = 2-ECDSA CipherString Selection-server
client = 2-ECDSA CipherString Selection-client

[2-ECDSA CipherString Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Groups = P-256:P-384
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-ECDSA CipherString Selection-client]
CipherString = aECDSA
Groups = P-384
MaxProtocol = TLSv1.2
RequestCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ExpectedResult = ServerFail


# ===========================================================

[3-RSA CipherString Selection]
ssl_conf = 3-RSA CipherString Selection-ssl

[3-RSA CipherString Selection-ssl]
server = 3-RSA CipherString Selection-server
client = 3-RSA CipherString Selection-client

[3-RSA CipherString Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-RSA CipherString Selection-client]
CipherString = aRSA
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
ExpectedResult = Success
ExpectedServerCertType = RSA
ExpectedServerSignType = RSA-PSS


# ===========================================================

[4-P-256 CipherString and Signature Algorithm Selection]
ssl_conf = 4-P-256 CipherString and Signature Algorithm Selection-ssl

[4-P-256 CipherString and Signature Algorithm Selection-ssl]
server = 4-P-256 CipherString and Signature Algorithm Selection-server
client = 4-P-256 CipherString and Signature Algorithm Selection-client

[4-P-256 CipherString and Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[4-P-256 CipherString and Signature Algorithm Selection-client]
CipherString = aECDSA
MaxProtocol = TLSv1.2
SignatureAlgorithms = ECDSA+SHA256:ed25519
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-4]
ExpectedResult = Success
ExpectedServerCertType = P-256
ExpectedServerSignHash = SHA256
ExpectedServerSignType = EC


# ===========================================================

[5-ECDSA CipherString Selection, no ECDSA certificate]
ssl_conf = 5-ECDSA CipherString Selection, no ECDSA certificate-ssl

[5-ECDSA CipherString Selection, no ECDSA certificate-ssl]
server = 5-ECDSA CipherString Selection, no ECDSA certificate-server
client = 5-ECDSA CipherString Selection, no ECDSA certificate-client

[5-ECDSA CipherString Selection, no ECDSA certificate-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[5-ECDSA CipherString Selection, no ECDSA certificate-client]
CipherString = aECDSA
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-5]
ExpectedResult = ServerFail


# ===========================================================

[6-ECDSA Signature Algorithm Selection]
ssl_conf = 6-ECDSA Signature Algorithm Selection-ssl

[6-ECDSA Signature Algorithm Selection-ssl]
server = 6-ECDSA Signature Algorithm Selection-server
client = 6-ECDSA Signature Algorithm Selection-client

[6-ECDSA Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[6-ECDSA Signature Algorithm Selection-client]
CipherString = DEFAULT
SignatureAlgorithms = ECDSA+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-6]
ExpectedResult = Success
ExpectedServerCertType = P-256
ExpectedServerSignHash = SHA256
ExpectedServerSignType = EC


# ===========================================================

[7-ECDSA Signature Algorithm Selection SHA384]
ssl_conf = 7-ECDSA Signature Algorithm Selection SHA384-ssl

[7-ECDSA Signature Algorithm Selection SHA384-ssl]
server = 7-ECDSA Signature Algorithm Selection SHA384-server
client = 7-ECDSA Signature Algorithm Selection SHA384-client

[7-ECDSA Signature Algorithm Selection SHA384-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[7-ECDSA Signature Algorithm Selection SHA384-client]
CipherString = DEFAULT
SignatureAlgorithms = ECDSA+SHA384
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-7]
ExpectedResult = Success
ExpectedServerCertType = P-256
ExpectedServerSignHash = SHA384
ExpectedServerSignType = EC


# ===========================================================

[8-ECDSA Signature Algorithm Selection compressed point]
ssl_conf = 8-ECDSA Signature Algorithm Selection compressed point-ssl

[8-ECDSA Signature Algorithm Selection compressed point-ssl]
server = 8-ECDSA Signature Algorithm Selection compressed point-server
client = 8-ECDSA Signature Algorithm Selection compressed point-client

[8-ECDSA Signature Algorithm Selection compressed point-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-cecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-cecdsa-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[8-ECDSA Signature Algorithm Selection compressed point-client]
CipherString = DEFAULT
SignatureAlgorithms = ECDSA+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-8]
ExpectedResult = Success
ExpectedServerCertType = P-256
ExpectedServerSignHash = SHA256
ExpectedServerSignType = EC


# ===========================================================

[9-ECDSA Signature Algorithm Selection, no ECDSA certificate]
ssl_conf = 9-ECDSA Signature Algorithm Selection, no ECDSA certificate-ssl

[9-ECDSA Signature Algorithm Selection, no ECDSA certificate-ssl]
server = 9-ECDSA Signature Algorithm Selection, no ECDSA certificate-server
client = 9-ECDSA Signature Algorithm Selection, no ECDSA certificate-client

[9-ECDSA Signature Algorithm Selection, no ECDSA certificate-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[9-ECDSA Signature Algorithm Selection, no ECDSA certificate-client]
CipherString = DEFAULT
SignatureAlgorithms = ECDSA+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-9]
ExpectedResult = ServerFail


# ===========================================================

[10-RSA Signature Algorithm Selection]
ssl_conf = 10-RSA Signature Algorithm Selection-ssl

[10-RSA Signature Algorithm Selection-ssl]
server = 10-RSA Signature Algorithm Selection-server
client = 10-RSA Signature Algorithm Selection-client

[10-RSA Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[10-RSA Signature Algorithm Selection-client]
CipherString = DEFAULT
SignatureAlgorithms = RSA+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-10]
ExpectedResult = Success
ExpectedServerCertType = RSA
ExpectedServerSignHash = SHA256
ExpectedServerSignType = RSA


# ===========================================================

[11-RSA-PSS Signature Algorithm Selection]
ssl_conf = 11-RSA-PSS Signature Algorithm Selection-ssl

[11-RSA-PSS Signature Algorithm Selection-ssl]
server = 11-RSA-PSS Signature Algorithm Selection-server
client = 11-RSA-PSS Signature Algorithm Selection-client

[11-RSA-PSS Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[11-RSA-PSS Signature Algorithm Selection-client]
CipherString = DEFAULT
SignatureAlgorithms = RSA-PSS+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-11]
ExpectedResult = Success
ExpectedServerCertType = RSA
ExpectedServerSignHash = SHA256
ExpectedServerSignType = RSA-PSS


# ===========================================================

[12-RSA key exchange with all RSA certificate types]
ssl_conf = 12-RSA key exchange with all RSA certificate types-ssl

[12-RSA key exchange with all RSA certificate types-ssl]
server = 12-RSA key exchange with all RSA certificate types-server
client = 12-RSA key exchange with all RSA certificate types-client

[12-RSA key exchange with all RSA certificate types-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PSS.Certificate = ${ENV::TEST_CERTS_DIR}/server-pss-cert.pem
PSS.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-pss-key.pem
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[12-RSA key exchange with all RSA certificate types-client]
CipherString = kRSA
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-12]
ExpectedResult = Success
ExpectedServerCertType = RSA


# ===========================================================

[13-Suite B P-256 Hash Algorithm Selection]
ssl_conf = 13-Suite B P-256 Hash Algorithm Selection-ssl

[13-Suite B P-256 Hash Algorithm Selection-ssl]
server = 13-Suite B P-256 Hash Algorithm Selection-server
client = 13-Suite B P-256 Hash Algorithm Selection-client

[13-Suite B P-256 Hash Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = SUITEB128
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/p256-server-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/p256-server-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[13-Suite B P-256 Hash Algorithm Selection-client]
CipherString = DEFAULT
SignatureAlgorithms = ECDSA+SHA384:ECDSA+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/p384-root.pem
VerifyMode = Peer

[test-13]
ExpectedResult = Success
ExpectedServerCertType = P-256
ExpectedServerSignHash = SHA256
ExpectedServerSignType = EC


# ===========================================================

[14-Suite B P-384 Hash Algorithm Selection]
ssl_conf = 14-Suite B P-384 Hash Algorithm Selection-ssl

[14-Suite B P-384 Hash Algorithm Selection-ssl]
server = 14-Suite B P-384 Hash Algorithm Selection-server
client = 14-Suite B P-384 Hash Algorithm Selection-client

[14-Suite B P-384 Hash Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = SUITEB128
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/p384-server-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/p384-server-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[14-Suite B P-384 Hash Algorithm Selection-client]
CipherString = DEFAULT
SignatureAlgorithms = ECDSA+SHA256:ECDSA+SHA384
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/p384-root.pem
VerifyMode = Peer

[test-14]
ExpectedResult = Success
ExpectedServerCertType = P-384
ExpectedServerSignHash = SHA384
ExpectedServerSignType = EC


# ===========================================================

[15-Ed25519 CipherString and Signature Algorithm Selection]
ssl_conf = 15-Ed25519 CipherString and Signature Algorithm Selection-ssl

[15-Ed25519 CipherString and Signature Algorithm Selection-ssl]
server = 15-Ed25519 CipherString and Signature Algorithm Selection-server
client = 15-Ed25519 CipherString and Signature Algorithm Selection-client

[15-Ed25519 CipherString and Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[15-Ed25519 CipherString and Signature Algorithm Selection-client]
CipherString = aECDSA
MaxProtocol = TLSv1.2
RequestCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
SignatureAlgorithms = ed25519:ECDSA+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-15]
ExpectedResult = Success
ExpectedServerCANames = empty
ExpectedServerCertType = Ed25519
ExpectedServerSignType = Ed25519


# ===========================================================

[16-Ed448 CipherString and Signature Algorithm Selection]
ssl_conf = 16-Ed448 CipherString and Signature Algorithm Selection-ssl

[16-Ed448 CipherString and Signature Algorithm Selection-ssl]
server = 16-Ed448 CipherString and Signature Algorithm Selection-server
client = 16-Ed448 CipherString and Signature Algorithm Selection-client

[16-Ed448 CipherString and Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[16-Ed448 CipherString and Signature Algorithm Selection-client]
CipherString = aECDSA
MaxProtocol = TLSv1.2
RequestCAFile = ${ENV::TEST_CERTS_DIR}/root-ed448-cert.pem
SignatureAlgorithms = ed448:ECDSA+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-ed448-cert.pem
VerifyMode = Peer

[test-16]
ExpectedResult = Success
ExpectedServerCANames = empty
ExpectedServerCertType = Ed448
ExpectedServerSignType = Ed448


# ===========================================================

[17-TLS 1.2 Ed25519 Client Auth]
ssl_conf = 17-TLS 1.2 Ed25519 Client Auth-ssl

[17-TLS 1.2 Ed25519 Client Auth-ssl]
server = 17-TLS 1.2 Ed25519 Client Auth-server
client = 17-TLS 1.2 Ed25519 Client Auth-client

[17-TLS 1.2 Ed25519 Client Auth-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Require

[17-TLS 1.2 Ed25519 Client Auth-client]
CipherString = DEFAULT
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/client-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/client-ed25519-key.pem
MaxProtocol = TLSv1.2
MinProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-17]
ExpectedClientCertType = Ed25519
ExpectedClientSignType = Ed25519
ExpectedResult = Success


# ===========================================================

[18-TLS 1.2 Ed448 Client Auth]
ssl_conf = 18-TLS 1.2 Ed448 Client Auth-ssl

[18-TLS 1.2 Ed448 Client Auth-ssl]
server = 18-TLS 1.2 Ed448 Client Auth-server
client = 18-TLS 1.2 Ed448 Client Auth-client

[18-TLS 1.2 Ed448 Client Auth-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Require

[18-TLS 1.2 Ed448 Client Auth-client]
CipherString = DEFAULT
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/client-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/client-ed448-key.pem
MaxProtocol = TLSv1.2
MinProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-18]
ExpectedClientCertType = Ed448
ExpectedClientSignType = Ed448
ExpectedResult = Success


# ===========================================================

[19-ECDSA Signature Algorithm Selection SHA1]
ssl_conf = 19-ECDSA Signature Algorithm Selection SHA1-ssl

[19-ECDSA Signature Algorithm Selection SHA1-ssl]
server = 19-ECDSA Signature Algorithm Selection SHA1-server
client = 19-ECDSA Signature Algorithm Selection SHA1-client

[19-ECDSA Signature Algorithm Selection SHA1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[19-ECDSA Signature Algorithm Selection SHA1-client]
CipherString = DEFAULT:@SECLEVEL=0
SignatureAlgorithms = ECDSA+SHA1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-19]
ExpectedResult = Success
ExpectedServerCertType = P-256
ExpectedServerSignHash = SHA1
ExpectedServerSignType = EC


# ===========================================================

[20-ECDSA with brainpool]
ssl_conf = 20-ECDSA with brainpool-ssl

[20-ECDSA with brainpool-ssl]
server = 20-ECDSA with brainpool-server
client = 20-ECDSA with brainpool-client

[20-ECDSA with brainpool-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-brainpoolP256r1-cert.pem
CipherString = DEFAULT
Groups = brainpoolP256r1
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-brainpoolP256r1-key.pem

[20-ECDSA with brainpool-client]
CipherString = aECDSA
Groups = brainpoolP256r1
MaxProtocol = TLSv1.2
RequestCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-20]
ExpectedResult = Success
ExpectedServerCANames = empty
ExpectedServerCertType = brainpoolP256r1
ExpectedServerSignType = EC


# ===========================================================

[21-Ed25519 CipherString and Curves Selection]
ssl_conf = 21-Ed25519 CipherString and Curves Selection-ssl

[21-Ed25519 CipherString and Curves Selection-ssl]
server = 21-Ed25519 CipherString and Curves Selection-server
client = 21-Ed25519 CipherString and Curves Selection-client

[21-Ed25519 CipherString and Curves Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[21-Ed25519 CipherString and Curves Selection-client]
CipherString = aECDSA
Curves = X25519
MaxProtocol = TLSv1.2
SignatureAlgorithms = ECDSA+SHA256:ed25519
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-21]
ExpectedResult = Success
ExpectedServerCertType = Ed25519
ExpectedServerSignType = Ed25519


# ===========================================================

[22-Ed448 CipherString and Curves Selection]
ssl_conf = 22-Ed448 CipherString and Curves Selection-ssl

[22-Ed448 CipherString and Curves Selection-ssl]
server = 22-Ed448 CipherString and Curves Selection-server
client = 22-Ed448 CipherString and Curves Selection-client

[22-Ed448 CipherString and Curves Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[22-Ed448 CipherString and Curves Selection-client]
CipherString = aECDSA
Curves = X448
MaxProtocol = TLSv1.2
SignatureAlgorithms = ECDSA+SHA256:ed448
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-ed448-cert.pem
VerifyMode = Peer

[test-22]
ExpectedResult = Success
ExpectedServerCertType = Ed448
ExpectedServerSignType = Ed448


# ===========================================================

[23-RSA-PSS Certificate CipherString Selection]
ssl_conf = 23-RSA-PSS Certificate CipherString Selection-ssl

[23-RSA-PSS Certificate CipherString Selection-ssl]
server = 23-RSA-PSS Certificate CipherString Selection-server
client = 23-RSA-PSS Certificate CipherString Selection-client

[23-RSA-PSS Certificate CipherString Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PSS.Certificate = ${ENV::TEST_CERTS_DIR}/server-pss-cert.pem
PSS.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-pss-key.pem
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[23-RSA-PSS Certificate CipherString Selection-client]
CipherString = aRSA
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-23]
ExpectedResult = Success
ExpectedServerCertType = RSA-PSS
ExpectedServerSignType = RSA-PSS


# ===========================================================

[24-RSA-PSS Certificate Legacy Signature Algorithm Selection]
ssl_conf = 24-RSA-PSS Certificate Legacy Signature Algorithm Selection-ssl

[24-RSA-PSS Certificate Legacy Signature Algorithm Selection-ssl]
server = 24-RSA-PSS Certificate Legacy Signature Algorithm Selection-server
client = 24-RSA-PSS Certificate Legacy Signature Algorithm Selection-client

[24-RSA-PSS Certificate Legacy Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PSS.Certificate = ${ENV::TEST_CERTS_DIR}/server-pss-cert.pem
PSS.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-pss-key.pem
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[24-RSA-PSS Certificate Legacy Signature Algorithm Selection-client]
CipherString = DEFAULT
SignatureAlgorithms = RSA-PSS+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-24]
ExpectedResult = Success
ExpectedServerCertType = RSA
ExpectedServerSignHash = SHA256
ExpectedServerSignType = RSA-PSS


# ===========================================================

[25-RSA-PSS Certificate Unified Signature Algorithm Selection]
ssl_conf = 25-RSA-PSS Certificate Unified Signature Algorithm Selection-ssl

[25-RSA-PSS Certificate Unified Signature Algorithm Selection-ssl]
server = 25-RSA-PSS Certificate Unified Signature Algorithm Selection-server
client = 25-RSA-PSS Certificate Unified Signature Algorithm Selection-client

[25-RSA-PSS Certificate Unified Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.2
PSS.Certificate = ${ENV::TEST_CERTS_DIR}/server-pss-cert.pem
PSS.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-pss-key.pem
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[25-RSA-PSS Certificate Unified Signature Algorithm Selection-client]
CipherString = DEFAULT
SignatureAlgorithms = rsa_pss_pss_sha256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-25]
ExpectedResult = Success
ExpectedServerCertType = RSA-PSS
ExpectedServerSignHash = SHA256
ExpectedServerSignType = RSA-PSS


# ===========================================================

[26-Only RSA-PSS Certificate]
ssl_conf = 26-Only RSA-PSS Certificate-ssl

[26-Only RSA-PSS Certificate-ssl]
server = 26-Only RSA-PSS Certificate-server
client = 26-Only RSA-PSS Certificate-client

[26-Only RSA-PSS Certificate-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-pss-cert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-pss-key.pem

[26-Only RSA-PSS Certificate-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-26]
ExpectedResult = Success
ExpectedServerCertType = RSA-PSS
ExpectedServerSignHash = SHA256
ExpectedServerSignType = RSA-PSS


# ===========================================================

[27-Only RSA-PSS Certificate Valid Signature Algorithms]
ssl_conf = 27-Only RSA-PSS Certificate Valid Signature Algorithms-ssl

[27-Only RSA-PSS Certificate Valid Signature Algorithms-ssl]
server = 27-Only RSA-PSS Certificate Valid Signature Algorithms-server
client = 27-Only RSA-PSS Certificate Valid Signature Algorithms-client

[27-Only RSA-PSS Certificate Valid Signature Algorithms-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-pss-cert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-pss-key.pem

[27-Only RSA-PSS Certificate Valid Signature Algorithms-client]
CipherString = DEFAULT
SignatureAlgorithms = rsa_pss_pss_sha512
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-27]
ExpectedResult = Success
ExpectedServerCertType = RSA-PSS
ExpectedServerSignHash = SHA512
ExpectedServerSignType = RSA-PSS


# ===========================================================

[28-RSA-PSS Certificate, no PSS signature algorithms]
ssl_conf = 28-RSA-PSS Certificate, no PSS signature algorithms-ssl

[28-RSA-PSS Certificate, no PSS signature algorithms-ssl]
server = 28-RSA-PSS Certificate, no PSS signature algorithms-server
client = 28-RSA-PSS Certificate, no PSS signature algorithms-client

[28-RSA-PSS Certificate, no PSS signature algorithms-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-pss-cert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-pss-key.pem

[28-RSA-PSS Certificate, no PSS signature algorithms-client]
CipherString = DEFAULT
SignatureAlgorithms = RSA+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-28]
ExpectedResult = ServerFail


# ===========================================================

[29-Only RSA-PSS Restricted Certificate]
ssl_conf = 29-Only RSA-PSS Restricted Certificate-ssl

[29-Only RSA-PSS Restricted Certificate-ssl]
server = 29-Only RSA-PSS Restricted Certificate-server
client = 29-Only RSA-PSS Restricted Certificate-client

[29-Only RSA-PSS Restricted Certificate-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-pss-restrict-cert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-pss-restrict-key.pem

[29-Only RSA-PSS Restricted Certificate-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-29]
ExpectedResult = Success
ExpectedServerCertType = RSA-PSS
ExpectedServerSignHash = SHA256
ExpectedServerSignType = RSA-PSS


# ===========================================================

[30-RSA-PSS Restricted Certificate Valid Signature Algorithms]
ssl_conf = 30-RSA-PSS Restricted Certificate Valid Signature Algorithms-ssl

[30-RSA-PSS Restricted Certificate Valid Signature Algorithms-ssl]
server = 30-RSA-PSS Restricted Certificate Valid Signature Algorithms-server
client = 30-RSA-PSS Restricted Certificate Valid Signature Algorithms-client

[30-RSA-PSS Restricted Certificate Valid Signature Algorithms-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-pss-restrict-cert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-pss-restrict-key.pem

[30-RSA-PSS Restricted Certificate Valid Signature Algorithms-client]
CipherString = DEFAULT
SignatureAlgorithms = rsa_pss_pss_sha256:rsa_pss_pss_sha512
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-30]
ExpectedResult = Success
ExpectedServerCertType = RSA-PSS
ExpectedServerSignHash = SHA256
ExpectedServerSignType = RSA-PSS


# ===========================================================

[31-RSA-PSS Restricted Cert client prefers invalid Signature Algorithm]
ssl_conf = 31-RSA-PSS Restricted Cert client prefers invalid Signature Algorithm-ssl

[31-RSA-PSS Restricted Cert client prefers invalid Signature Algorithm-ssl]
server = 31-RSA-PSS Restricted Cert client prefers invalid Signature Algorithm-server
client = 31-RSA-PSS Restricted Cert client prefers invalid Signature Algorithm-client

[31-RSA-PSS Restricted Cert client prefers invalid Signature Algorithm-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-pss-restrict-cert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-pss-restrict-key.pem

[31-RSA-PSS Restricted Cert client prefers invalid Signature Algorithm-client]
CipherString = DEFAULT
SignatureAlgorithms = rsa_pss_pss_sha512:rsa_pss_pss_sha256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-31]
ExpectedResult = Success
ExpectedServerCertType = RSA-PSS
ExpectedServerSignHash = SHA256
ExpectedServerSignType = RSA-PSS


# ===========================================================

[32-RSA-PSS Restricted Certificate Invalid Signature Algorithms]
ssl_conf = 32-RSA-PSS Restricted Certificate Invalid Signature Algorithms-ssl

[32-RSA-PSS Restricted Certificate Invalid Signature Algorithms-ssl]
server = 32-RSA-PSS Restricted Certificate Invalid Signature Algorithms-server
client = 32-RSA-PSS Restricted Certificate Invalid Signature Algorithms-client

[32-RSA-PSS Restricted Certificate Invalid Signature Algorithms-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-pss-restrict-cert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-pss-restrict-key.pem

[32-RSA-PSS Restricted Certificate Invalid Signature Algorithms-client]
CipherString = DEFAULT
SignatureAlgorithms = rsa_pss_pss_sha512
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-32]
ExpectedResult = ServerFail


# ===========================================================

[33-RSA key exchange with only RSA-PSS certificate]
ssl_conf = 33-RSA key exchange with only RSA-PSS certificate-ssl

[33-RSA key exchange with only RSA-PSS certificate-ssl]
server = 33-RSA key exchange with only RSA-PSS certificate-server
client = 33-RSA key exchange with only RSA-PSS certificate-client

[33-RSA key exchange with only RSA-PSS certificate-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-pss-cert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-pss-key.pem

[33-RSA key exchange with only RSA-PSS certificate-client]
CipherString = kRSA
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-33]
ExpectedResult = ServerFail


# ===========================================================

[34-Only RSA-PSS Certificate, TLS v1.1]
ssl_conf = 34-Only RSA-PSS Certificate, TLS v1.1-ssl

[34-Only RSA-PSS Certificate, TLS v1.1-ssl]
server = 34-Only RSA-PSS Certificate, TLS v1.1-server
client = 34-Only RSA-PSS Certificate, TLS v1.1-client

[34-Only RSA-PSS Certificate, TLS v1.1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-pss-cert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-pss-key.pem

[34-Only RSA-PSS Certificate, TLS v1.1-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-34]
ExpectedResult = ServerFail


# ===========================================================

[35-TLS 1.3 ECDSA Signature Algorithm Selection]
ssl_conf = 35-TLS 1.3 ECDSA Signature Algorithm Selection-ssl

[35-TLS 1.3 ECDSA Signature Algorithm Selection-ssl]
server = 35-TLS 1.3 ECDSA Signature Algorithm Selection-server
client = 35-TLS 1.3 ECDSA Signature Algorithm Selection-client

[35-TLS 1.3 ECDSA Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[35-TLS 1.3 ECDSA Signature Algorithm Selection-client]
CipherString = DEFAULT
SignatureAlgorithms = ECDSA+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-35]
ExpectedResult = Success
ExpectedServerCANames = empty
ExpectedServerCertType = P-256
ExpectedServerSignHash = SHA256
ExpectedServerSignType = EC


# ===========================================================

[36-TLS 1.3 ECDSA Signature Algorithm Selection compressed point]
ssl_conf = 36-TLS 1.3 ECDSA Signature Algorithm Selection compressed point-ssl

[36-TLS 1.3 ECDSA Signature Algorithm Selection compressed point-ssl]
server = 36-TLS 1.3 ECDSA Signature Algorithm Selection compressed point-server
client = 36-TLS 1.3 ECDSA Signature Algorithm Selection compressed point-client

[36-TLS 1.3 ECDSA Signature Algorithm Selection compressed point-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-cecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-cecdsa-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[36-TLS 1.3 ECDSA Signature Algorithm Selection compressed point-client]
CipherString = DEFAULT
SignatureAlgorithms = ECDSA+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-36]
ExpectedResult = Success
ExpectedServerCANames = empty
ExpectedServerCertType = P-256
ExpectedServerSignHash = SHA256
ExpectedServerSignType = EC


# ===========================================================

[37-TLS 1.3 ECDSA Signature Algorithm Selection SHA1]
ssl_conf = 37-TLS 1.3 ECDSA Signature Algorithm Selection SHA1-ssl

[37-TLS 1.3 ECDSA Signature Algorithm Selection SHA1-ssl]
server = 37-TLS 1.3 ECDSA Signature Algorithm Selection SHA1-server
client = 37-TLS 1.3 ECDSA Signature Algorithm Selection SHA1-client

[37-TLS 1.3 ECDSA Signature Algorithm Selection SHA1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=0
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[37-TLS 1.3 ECDSA Signature Algorithm Selection SHA1-client]
CipherString = DEFAULT:@SECLEVEL=0
SignatureAlgorithms = ECDSA+SHA1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-37]
ExpectedResult = ServerFail


# ===========================================================

[38-TLS 1.3 ECDSA Signature Algorithm Selection with PSS]
ssl_conf = 38-TLS 1.3 ECDSA Signature Algorithm Selection with PSS-ssl

[38-TLS 1.3 ECDSA Signature Algorithm Selection with PSS-ssl]
server = 38-TLS 1.3 ECDSA Signature Algorithm Selection with PSS-server
client = 38-TLS 1.3 ECDSA Signature Algorithm Selection with PSS-client

[38-TLS 1.3 ECDSA Signature Algorithm Selection with PSS-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[38-TLS 1.3 ECDSA Signature Algorithm Selection with PSS-client]
CipherString = DEFAULT
RequestCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
SignatureAlgorithms = ECDSA+SHA256:RSA-PSS+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-38]
ExpectedResult = Success
ExpectedServerCANames = ${ENV::TEST_CERTS_DIR}/root-cert.pem
ExpectedServerCertType = P-256
ExpectedServerSignHash = SHA256
ExpectedServerSignType = EC


# ===========================================================

[39-TLS 1.3 RSA Signature Algorithm Selection SHA384 with PSS]
ssl_conf = 39-TLS 1.3 RSA Signature Algorithm Selection SHA384 with PSS-ssl

[39-TLS 1.3 RSA Signature Algorithm Selection SHA384 with PSS-ssl]
server = 39-TLS 1.3 RSA Signature Algorithm Selection SHA384 with PSS-server
client = 39-TLS 1.3 RSA Signature Algorithm Selection SHA384 with PSS-client

[39-TLS 1.3 RSA Signature Algorithm Selection SHA384 with PSS-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[39-TLS 1.3 RSA Signature Algorithm Selection SHA384 with PSS-client]
CipherString = DEFAULT
SignatureAlgorithms = ECDSA+SHA384:RSA-PSS+SHA384
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-39]
ExpectedResult = Success
ExpectedServerCertType = RSA
ExpectedServerSignHash = SHA384
ExpectedServerSignType = RSA-PSS


# ===========================================================

[40-TLS 1.3 ECDSA Signature Algorithm Selection, no ECDSA certificate]
ssl_conf = 40-TLS 1.3 ECDSA Signature Algorithm Selection, no ECDSA certificate-ssl

[40-TLS 1.3 ECDSA Signature Algorithm Selection, no ECDSA certificate-ssl]
server = 40-TLS 1.3 ECDSA Signature Algorithm Selection, no ECDSA certificate-server
client = 40-TLS 1.3 ECDSA Signature Algorithm Selection, no ECDSA certificate-client

[40-TLS 1.3 ECDSA Signature Algorithm Selection, no ECDSA certificate-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[40-TLS 1.3 ECDSA Signature Algorithm Selection, no ECDSA certificate-client]
CipherString = DEFAULT
SignatureAlgorithms = ECDSA+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-40]
ExpectedResult = ServerFail


# ===========================================================

[41-TLS 1.3 RSA Signature Algorithm Selection, no PSS]
ssl_conf = 41-TLS 1.3 RSA Signature Algorithm Selection, no PSS-ssl

[41-TLS 1.3 RSA Signature Algorithm Selection, no PSS-ssl]
server = 41-TLS 1.3 RSA Signature Algorithm Selection, no PSS-server
client = 41-TLS 1.3 RSA Signature Algorithm Selection, no PSS-client

[41-TLS 1.3 RSA Signature Algorithm Selection, no PSS-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[41-TLS 1.3 RSA Signature Algorithm Selection, no PSS-client]
CipherString = DEFAULT
SignatureAlgorithms = RSA+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-41]
ExpectedResult = ServerFail


# ===========================================================

[42-TLS 1.3 RSA-PSS Signature Algorithm Selection]
ssl_conf = 42-TLS 1.3 RSA-PSS Signature Algorithm Selection-ssl

[42-TLS 1.3 RSA-PSS Signature Algorithm Selection-ssl]
server = 42-TLS 1.3 RSA-PSS Signature Algorithm Selection-server
client = 42-TLS 1.3 RSA-PSS Signature Algorithm Selection-client

[42-TLS 1.3 RSA-PSS Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[42-TLS 1.3 RSA-PSS Signature Algorithm Selection-client]
CipherString = DEFAULT
SignatureAlgorithms = RSA-PSS+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-42]
ExpectedResult = Success
ExpectedServerCertType = RSA
ExpectedServerSignHash = SHA256
ExpectedServerSignType = RSA-PSS


# ===========================================================

[43-TLS 1.3 RSA Client Auth Signature Algorithm Selection]
ssl_conf = 43-TLS 1.3 RSA Client Auth Signature Algorithm Selection-ssl

[43-TLS 1.3 RSA Client Auth Signature Algorithm Selection-ssl]
server = 43-TLS 1.3 RSA Client Auth Signature Algorithm Selection-server
client = 43-TLS 1.3 RSA Client Auth Signature Algorithm Selection-client

[43-TLS 1.3 RSA Client Auth Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ClientSignatureAlgorithms = PSS+SHA256
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Require

[43-TLS 1.3 RSA Client Auth Signature Algorithm Selection-client]
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/ee-ecdsa-client-chain.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-ecdsa-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
RSA.Certificate = ${ENV::TEST_CERTS_DIR}/ee-client-chain.pem
RSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-key.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-43]
ExpectedClientCANames = empty
ExpectedClientCertType = RSA
ExpectedClientSignHash = SHA256
ExpectedClientSignType = RSA-PSS
ExpectedResult = Success


# ===========================================================

[44-TLS 1.3 RSA Client Auth Signature Algorithm Selection non-empty CA Names]
ssl_conf = 44-TLS 1.3 RSA Client Auth Signature Algorithm Selection non-empty CA Names-ssl

[44-TLS 1.3 RSA Client Auth Signature Algorithm Selection non-empty CA Names-ssl]
server = 44-TLS 1.3 RSA Client Auth Signature Algorithm Selection non-empty CA Names-server
client = 44-TLS 1.3 RSA Client Auth Signature Algorithm Selection non-empty CA Names-client

[44-TLS 1.3 RSA Client Auth Signature Algorithm Selection non-empty CA Names-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ClientSignatureAlgorithms = PSS+SHA256
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
RequestCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Require

[44-TLS 1.3 RSA Client Auth Signature Algorithm Selection non-empty CA Names-client]
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/ee-ecdsa-client-chain.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-ecdsa-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
RSA.Certificate = ${ENV::TEST_CERTS_DIR}/ee-client-chain.pem
RSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-key.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-44]
ExpectedClientCANames = ${ENV::TEST_CERTS_DIR}/root-cert.pem
ExpectedClientCertType = RSA
ExpectedClientSignHash = SHA256
ExpectedClientSignType = RSA-PSS
ExpectedResult = Success


# ===========================================================

[45-TLS 1.3 ECDSA Client Auth Signature Algorithm Selection]
ssl_conf = 45-TLS 1.3 ECDSA Client Auth Signature Algorithm Selection-ssl

[45-TLS 1.3 ECDSA Client Auth Signature Algorithm Selection-ssl]
server = 45-TLS 1.3 ECDSA Client Auth Signature Algorithm Selection-server
client = 45-TLS 1.3 ECDSA Client Auth Signature Algorithm Selection-client

[45-TLS 1.3 ECDSA Client Auth Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ClientSignatureAlgorithms = ECDSA+SHA256
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Require

[45-TLS 1.3 ECDSA Client Auth Signature Algorithm Selection-client]
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/ee-ecdsa-client-chain.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-ecdsa-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
RSA.Certificate = ${ENV::TEST_CERTS_DIR}/ee-client-chain.pem
RSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-key.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-45]
ExpectedClientCertType = P-256
ExpectedClientSignHash = SHA256
ExpectedClientSignType = EC
ExpectedResult = Success


# ===========================================================

[46-TLS 1.3 Ed25519 Signature Algorithm Selection]
ssl_conf = 46-TLS 1.3 Ed25519 Signature Algorithm Selection-ssl

[46-TLS 1.3 Ed25519 Signature Algorithm Selection-ssl]
server = 46-TLS 1.3 Ed25519 Signature Algorithm Selection-server
client = 46-TLS 1.3 Ed25519 Signature Algorithm Selection-client

[46-TLS 1.3 Ed25519 Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[46-TLS 1.3 Ed25519 Signature Algorithm Selection-client]
CipherString = DEFAULT
SignatureAlgorithms = ed25519
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-46]
ExpectedResult = Success
ExpectedServerCertType = Ed25519
ExpectedServerSignType = Ed25519


# ===========================================================

[47-TLS 1.3 Ed448 Signature Algorithm Selection]
ssl_conf = 47-TLS 1.3 Ed448 Signature Algorithm Selection-ssl

[47-TLS 1.3 Ed448 Signature Algorithm Selection-ssl]
server = 47-TLS 1.3 Ed448 Signature Algorithm Selection-server
client = 47-TLS 1.3 Ed448 Signature Algorithm Selection-client

[47-TLS 1.3 Ed448 Signature Algorithm Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[47-TLS 1.3 Ed448 Signature Algorithm Selection-client]
CipherString = DEFAULT
SignatureAlgorithms = ed448
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-ed448-cert.pem
VerifyMode = Peer

[test-47]
ExpectedResult = Success
ExpectedServerCertType = Ed448
ExpectedServerSignType = Ed448


# ===========================================================

[48-TLS 1.3 Ed25519 CipherString and Groups Selection]
ssl_conf = 48-TLS 1.3 Ed25519 CipherString and Groups Selection-ssl

[48-TLS 1.3 Ed25519 CipherString and Groups Selection-ssl]
server = 48-TLS 1.3 Ed25519 CipherString and Groups Selection-server
client = 48-TLS 1.3 Ed25519 CipherString and Groups Selection-client

[48-TLS 1.3 Ed25519 CipherString and Groups Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[48-TLS 1.3 Ed25519 CipherString and Groups Selection-client]
CipherString = DEFAULT
Groups = X25519
SignatureAlgorithms = ECDSA+SHA256:ed25519
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-48]
ExpectedResult = Success
ExpectedServerCertType = P-256
ExpectedServerSignType = EC


# ===========================================================

[49-TLS 1.3 Ed448 CipherString and Groups Selection]
ssl_conf = 49-TLS 1.3 Ed448 CipherString and Groups Selection-ssl

[49-TLS 1.3 Ed448 CipherString and Groups Selection-ssl]
server = 49-TLS 1.3 Ed448 CipherString and Groups Selection-server
client = 49-TLS 1.3 Ed448 CipherString and Groups Selection-client

[49-TLS 1.3 Ed448 CipherString and Groups Selection-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ECDSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-cert.pem
ECDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-key.pem
Ed25519.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed25519-cert.pem
Ed25519.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed25519-key.pem
Ed448.Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
Ed448.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[49-TLS 1.3 Ed448 CipherString and Groups Selection-client]
CipherString = DEFAULT
Groups = X448
SignatureAlgorithms = ECDSA+SHA256:ed448
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-49]
ExpectedResult = Success
ExpectedServerCertType = P-256
ExpectedServerSignType = EC


# ===========================================================

[50-TLS 1.3 Ed25519 Client Auth]
ssl_conf = 50-TLS 1.3 Ed25519 Client Auth-ssl

[50-TLS 1.3 Ed25519 Client Auth-ssl]
server = 50-TLS 1.3 Ed25519 Client Auth-server
client = 50-TLS 1.3 Ed25519 Client Auth-client

[50-TLS 1.3 Ed25519 Client Auth-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Require

[50-TLS 1.3 Ed25519 Client Auth-client]
CipherString = DEFAULT
EdDSA.Certificate = ${ENV::TEST_CERTS_DIR}/client-ed25519-cert.pem
EdDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/client-ed25519-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-50]
ExpectedClientCertType = Ed25519
ExpectedClientSignType = Ed25519
ExpectedResult = Success


# ===========================================================

[51-TLS 1.3 Ed448 Client Auth]
ssl_conf = 51-TLS 1.3 Ed448 Client Auth-ssl

[51-TLS 1.3 Ed448 Client Auth-ssl]
server = 51-TLS 1.3 Ed448 Client Auth-server
client = 51-TLS 1.3 Ed448 Client Auth-client

[51-TLS 1.3 Ed448 Client Auth-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Require

[51-TLS 1.3 Ed448 Client Auth-client]
CipherString = DEFAULT
EdDSA.Certificate = ${ENV::TEST_CERTS_DIR}/client-ed448-cert.pem
EdDSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/client-ed448-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-51]
ExpectedClientCertType = Ed448
ExpectedClientSignType = Ed448
ExpectedResult = Success


# ===========================================================

[52-TLS 1.3 ECDSA with brainpool but no suitable groups]
ssl_conf = 52-TLS 1.3 ECDSA with brainpool but no suitable groups-ssl

[52-TLS 1.3 ECDSA with brainpool but no suitable groups-ssl]
server = 52-TLS 1.3 ECDSA with brainpool but no suitable groups-server
client = 52-TLS 1.3 ECDSA with brainpool but no suitable groups-client

[52-TLS 1.3 ECDSA with brainpool but no suitable groups-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-brainpoolP256r1-cert.pem
CipherString = DEFAULT
Groups = brainpoolP256r1
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-brainpoolP256r1-key.pem

[52-TLS 1.3 ECDSA with brainpool but no suitable groups-client]
CipherString = aECDSA
Groups = brainpoolP256r1
RequestCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-52]
ExpectedResult = ClientFail


# ===========================================================

[53-TLS 1.3 ECDSA with brainpool]
ssl_conf = 53-TLS 1.3 ECDSA with brainpool-ssl

[53-TLS 1.3 ECDSA with brainpool-ssl]
server = 53-TLS 1.3 ECDSA with brainpool-server
client = 53-TLS 1.3 ECDSA with brainpool-client

[53-TLS 1.3 ECDSA with brainpool-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-ecdsa-brainpoolP256r1-cert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ecdsa-brainpoolP256r1-key.pem

[53-TLS 1.3 ECDSA with brainpool-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
RequestCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-53]
ExpectedResult = ServerFail


# ===========================================================

[54-TLS 1.2 DSA Certificate Test]
ssl_conf = 54-TLS 1.2 DSA Certificate Test-ssl

[54-TLS 1.2 DSA Certificate Test-ssl]
server = 54-TLS 1.2 DSA Certificate Test-server
client = 54-TLS 1.2 DSA Certificate Test-client

[54-TLS 1.2 DSA Certificate Test-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = ALL
DHParameters = ${ENV::TEST_CERTS_DIR}/dhp2048.pem
DSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-dsa-cert.pem
DSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-dsa-key.pem
MaxProtocol = TLSv1.2
MinProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[54-TLS 1.2 DSA Certificate Test-client]
CipherString = ALL
SignatureAlgorithms = DSA+SHA256:DSA+SHA1
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-54]
ExpectedResult = Success


# ===========================================================

[55-TLS 1.3 Client Auth No TLS 1.3 Signature Algorithms]
ssl_conf = 55-TLS 1.3 Client Auth No TLS 1.3 Signature Algorithms-ssl

[55-TLS 1.3 Client Auth No TLS 1.3 Signature Algorithms-ssl]
server = 55-TLS 1.3 Client Auth No TLS 1.3 Signature Algorithms-server
client = 55-TLS 1.3 Client Auth No TLS 1.3 Signature Algorithms-client

[55-TLS 1.3 Client Auth No TLS 1.3 Signature Algorithms-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ClientSignatureAlgorithms = ECDSA+SHA1:DSA+SHA256:RSA+SHA256
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Request

[55-TLS 1.3 Client Auth No TLS 1.3 Signature Algorithms-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-55]
ExpectedResult = ServerFail


# ===========================================================

[56-TLS 1.3 DSA Certificate Test]
ssl_conf = 56-TLS 1.3 DSA Certificate Test-ssl

[56-TLS 1.3 DSA Certificate Test-ssl]
server = 56-TLS 1.3 DSA Certificate Test-server
client = 56-TLS 1.3 DSA Certificate Test-client

[56-TLS 1.3 DSA Certificate Test-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = ALL
DSA.Certificate = ${ENV::TEST_CERTS_DIR}/server-dsa-cert.pem
DSA.PrivateKey = ${ENV::TEST_CERTS_DIR}/server-dsa-key.pem
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[56-TLS 1.3 DSA Certificate Test-client]
CipherString = ALL
SignatureAlgorithms = DSA+SHA1:DSA+SHA256:ECDSA+SHA256
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-56]
ExpectedResult = ServerFail


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/openssl/openssl/test/ssl-tests/20-cert-select.cnf.in                               0000664 0000000 0000000 00000100632 14746647661 0025326 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-

## SSL test configurations


use strict;
use warnings;

package ssltests;
use OpenSSL::Test::Utils;

our $fips_mode;
our $no_deflt_libctx;

my $server = {
    "ECDSA.Certificate" => test_pem("server-ecdsa-cert.pem"),
    "ECDSA.PrivateKey" => test_pem("server-ecdsa-key.pem"),
    "Ed25519.Certificate" => test_pem("server-ed25519-cert.pem"),
    "Ed25519.PrivateKey" => test_pem("server-ed25519-key.pem"),
    "Ed448.Certificate" => test_pem("server-ed448-cert.pem"),
    "Ed448.PrivateKey" => test_pem("server-ed448-key.pem"),
    "MaxProtocol" => "TLSv1.2"
};

my $server_pss = {
    "PSS.Certificate" => test_pem("server-pss-cert.pem"),
    "PSS.PrivateKey" => test_pem("server-pss-key.pem"),
    "ECDSA.Certificate" => test_pem("server-ecdsa-cert.pem"),
    "ECDSA.PrivateKey" => test_pem("server-ecdsa-key.pem"),
    "Ed25519.Certificate" => test_pem("server-ed25519-cert.pem"),
    "Ed25519.PrivateKey" => test_pem("server-ed25519-key.pem"),
    "Ed448.Certificate" => test_pem("server-ed448-cert.pem"),
    "Ed448.PrivateKey" => test_pem("server-ed448-key.pem"),
    "MaxProtocol" => "TLSv1.2"
};

my $server_pss_only = {
    "Certificate" => test_pem("server-pss-cert.pem"),
    "PrivateKey" => test_pem("server-pss-key.pem"),
};

my $server_pss_restrict_only = {
    "Certificate" => test_pem("server-pss-restrict-cert.pem"),
    "PrivateKey" => test_pem("server-pss-restrict-key.pem"),
};

my $server_rsa_all;

if ($no_deflt_libctx) {
    $server_rsa_all = {
        "Certificate" => test_pem("servercert.pem"),
        "PrivateKey" => test_pem("serverkey.pem"),
    };
} else {
    $server_rsa_all = {
        "PSS.Certificate" => test_pem("server-pss-cert.pem"),
        "PSS.PrivateKey" => test_pem("server-pss-key.pem"),
        "Certificate" => test_pem("servercert.pem"),
        "PrivateKey" => test_pem("serverkey.pem"),
    };
}

our @tests = (
    {
        name => "ECDSA CipherString Selection",
        server => $server,
        client => {
            "CipherString" => "aECDSA",
            "MaxProtocol" => "TLSv1.2",
            "RequestCAFile" => test_pem("root-cert.pem"),
        },
        test   => {
            "ExpectedServerCertType" =>, "P-256",
            "ExpectedServerSignType" =>, "EC",
            # Note: certificate_authorities not sent for TLS < 1.3
            "ExpectedServerCANames" =>, "empty",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "ECDSA CipherString Selection",
        server => {
            "ECDSA.Certificate" => test_pem("server-ecdsa-cert.pem"),
            "ECDSA.PrivateKey" => test_pem("server-ecdsa-key.pem"),
            "MaxProtocol" => "TLSv1.2",
            #Deliberately set supported_groups to one not in the cert. This
            #should be tolerated
            "Groups" => "P-384"
        },
        client => {
            "CipherString" => "aECDSA",
            "MaxProtocol" => "TLSv1.2",
            "Groups" => "P-256:P-384",
            "RequestCAFile" => test_pem("root-cert.pem"),
        },
        test   => {
            "ExpectedServerCertType" =>, "P-256",
            "ExpectedServerSignType" =>, "EC",
            # Note: certificate_authorities not sent for TLS < 1.3
            "ExpectedServerCANames" =>, "empty",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "ECDSA CipherString Selection",
        server => {
            "ECDSA.Certificate" => test_pem("server-ecdsa-cert.pem"),
            "ECDSA.PrivateKey" => test_pem("server-ecdsa-key.pem"),
            "MaxProtocol" => "TLSv1.2",
            "Groups" => "P-256:P-384"
        },
        client => {
            "CipherString" => "aECDSA",
            "MaxProtocol" => "TLSv1.2",
            #Deliberately set groups to not include the certificate group. This
            #should fail
            "Groups" => "P-384",
            "RequestCAFile" => test_pem("root-cert.pem"),
        },
        test   => {
            "ExpectedResult" => "ServerFail"
        },
    },
    {
        name => "RSA CipherString Selection",
        server => $server,
        client => {
            "CipherString" => "aRSA",
            "MaxProtocol" => "TLSv1.2",
        },
        test   => {
            "ExpectedServerCertType" =>, "RSA",
            "ExpectedServerSignType" =>, "RSA-PSS",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "P-256 CipherString and Signature Algorithm Selection",
        server => $server,
        client => {
            "CipherString" => "aECDSA",
            "MaxProtocol" => "TLSv1.2",
            "SignatureAlgorithms" => "ECDSA+SHA256:ed25519",
        },
        test   => {
            "ExpectedServerCertType" => "P-256",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "EC",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "ECDSA CipherString Selection, no ECDSA certificate",
        server => {
            "MaxProtocol" => "TLSv1.2"
        },
        client => {
            "CipherString" => "aECDSA",
            "MaxProtocol" => "TLSv1.2"
        },
        test   => {
            "ExpectedResult" => "ServerFail"
        },
    },
    {
        name => "ECDSA Signature Algorithm Selection",
        server => $server,
        client => {
            "SignatureAlgorithms" => "ECDSA+SHA256",
        },
        test   => {
            "ExpectedServerCertType" => "P-256",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "EC",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "ECDSA Signature Algorithm Selection SHA384",
        server => $server,
        client => {
            "SignatureAlgorithms" => "ECDSA+SHA384",
        },
        test   => {
            "ExpectedServerCertType" => "P-256",
            "ExpectedServerSignHash" => "SHA384",
            "ExpectedServerSignType" => "EC",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "ECDSA Signature Algorithm Selection compressed point",
        server => {
            "ECDSA.Certificate" => test_pem("server-cecdsa-cert.pem"),
            "ECDSA.PrivateKey" => test_pem("server-cecdsa-key.pem"),
            "MaxProtocol" => "TLSv1.2"
        },
        client => {
            "SignatureAlgorithms" => "ECDSA+SHA256",
        },
        test   => {
            "ExpectedServerCertType" => "P-256",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "EC",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "ECDSA Signature Algorithm Selection, no ECDSA certificate",
        server => {
             "MaxProtocol" => "TLSv1.2"
        },
        client => {
            "SignatureAlgorithms" => "ECDSA+SHA256",
        },
        test   => {
            "ExpectedResult" => "ServerFail"
        },
    },
    {
        name => "RSA Signature Algorithm Selection",
        server => $server,
        client => {
            "SignatureAlgorithms" => "RSA+SHA256",
        },
        test   => {
            "ExpectedServerCertType" => "RSA",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "RSA",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "RSA-PSS Signature Algorithm Selection",
        server => $server,
        client => {
            "SignatureAlgorithms" => "RSA-PSS+SHA256",
        },
        test   => {
            "ExpectedServerCertType" => "RSA",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "RSA-PSS",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "RSA key exchange with all RSA certificate types",
        server => $server_rsa_all,
        client => {
            "CipherString" => "kRSA",
            "MaxProtocol" => "TLSv1.2",
        },
        test   => {
            "ExpectedServerCertType" =>, "RSA",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "Suite B P-256 Hash Algorithm Selection",
        server =>  {
            "ECDSA.Certificate" => test_pem("p256-server-cert.pem"),
            "ECDSA.PrivateKey" => test_pem("p256-server-key.pem"),
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "SUITEB128"
        },
        client => {
            "VerifyCAFile" => test_pem("p384-root.pem"),
            "SignatureAlgorithms" => "ECDSA+SHA384:ECDSA+SHA256"
        },
        test   => {
            "ExpectedServerCertType" => "P-256",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "EC",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "Suite B P-384 Hash Algorithm Selection",
        server =>  {
            "ECDSA.Certificate" => test_pem("p384-server-cert.pem"),
            "ECDSA.PrivateKey" => test_pem("p384-server-key.pem"),
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "SUITEB128"
        },
        client => {
            "VerifyCAFile" => test_pem("p384-root.pem"),
            "SignatureAlgorithms" => "ECDSA+SHA256:ECDSA+SHA384"
        },
        test   => {
            "ExpectedServerCertType" => "P-384",
            "ExpectedServerSignHash" => "SHA384",
            "ExpectedServerSignType" => "EC",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "Ed25519 CipherString and Signature Algorithm Selection",
        server => $server,
        client => {
            "CipherString" => "aECDSA",
            "MaxProtocol" => "TLSv1.2",
            "SignatureAlgorithms" => "ed25519:ECDSA+SHA256",
            "RequestCAFile" => test_pem("root-cert.pem"),
        },
        test   => {
            "ExpectedServerCertType" =>, "Ed25519",
            "ExpectedServerSignType" =>, "Ed25519",
            # Note: certificate_authorities not sent for TLS < 1.3
            "ExpectedServerCANames" =>, "empty",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "Ed448 CipherString and Signature Algorithm Selection",
        server => $server,
        client => {
            "CipherString" => "aECDSA",
            "MaxProtocol" => "TLSv1.2",
            "SignatureAlgorithms" => "ed448:ECDSA+SHA256",
            "RequestCAFile" => test_pem("root-ed448-cert.pem"),
            "VerifyCAFile" => test_pem("root-ed448-cert.pem"),
        },
        test   => {
            "ExpectedServerCertType" =>, "Ed448",
            "ExpectedServerSignType" =>, "Ed448",
            # Note: certificate_authorities not sent for TLS < 1.3
            "ExpectedServerCANames" =>, "empty",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.2 Ed25519 Client Auth",
        server => {
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "Require"
        },
        client => {
            "Ed25519.Certificate" => test_pem("client-ed25519-cert.pem"),
            "Ed25519.PrivateKey" => test_pem("client-ed25519-key.pem"),
            "MinProtocol" => "TLSv1.2",
            "MaxProtocol" => "TLSv1.2"
        },
        test   => {
            "ExpectedClientCertType" => "Ed25519",
            "ExpectedClientSignType" => "Ed25519",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.2 Ed448 Client Auth",
        server => {
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "Require"
        },
        client => {
            "Ed448.Certificate" => test_pem("client-ed448-cert.pem"),
            "Ed448.PrivateKey" => test_pem("client-ed448-key.pem"),
            "MinProtocol" => "TLSv1.2",
            "MaxProtocol" => "TLSv1.2"
        },
        test   => {
            "ExpectedClientCertType" => "Ed448",
            "ExpectedClientSignType" => "Ed448",
            "ExpectedResult" => "Success"
        },
    },
);

my @tests_non_fips = (
    {
        name => "ECDSA Signature Algorithm Selection SHA1",
        server => {
            "CipherString" => "DEFAULT:\@SECLEVEL=0",
            "ECDSA.Certificate" => test_pem("server-ecdsa-cert.pem"),
            "ECDSA.PrivateKey" => test_pem("server-ecdsa-key.pem"),
            "Ed25519.Certificate" => test_pem("server-ed25519-cert.pem"),
            "Ed25519.PrivateKey" => test_pem("server-ed25519-key.pem"),
            "Ed448.Certificate" => test_pem("server-ed448-cert.pem"),
            "Ed448.PrivateKey" => test_pem("server-ed448-key.pem"),
            "MaxProtocol" => "TLSv1.2"
        },
        client => {
            "CipherString" => "DEFAULT:\@SECLEVEL=0",
            "SignatureAlgorithms" => "ECDSA+SHA1",
        },
        test   => {
            "ExpectedServerCertType" => "P-256",
            "ExpectedServerSignHash" => "SHA1",
            "ExpectedServerSignType" => "EC",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "ECDSA with brainpool",
        server =>  {
            "Certificate" => test_pem("server-ecdsa-brainpoolP256r1-cert.pem"),
            "PrivateKey" => test_pem("server-ecdsa-brainpoolP256r1-key.pem"),
            "Groups" => "brainpoolP256r1",
        },
        client => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "aECDSA",
            "RequestCAFile" => test_pem("root-cert.pem"),
            "Groups" => "brainpoolP256r1",
        },
        test   => {
            "ExpectedServerCertType" =>, "brainpoolP256r1",
            "ExpectedServerSignType" =>, "EC",
            # Note: certificate_authorities not sent for TLS < 1.3
            "ExpectedServerCANames" =>, "empty",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "Ed25519 CipherString and Curves Selection",
        server => $server,
        client => {
            "CipherString" => "aECDSA",
            "MaxProtocol" => "TLSv1.2",
            "SignatureAlgorithms" => "ECDSA+SHA256:ed25519",
            # Excluding P-256 from the supported curves list means server
            # certificate should be Ed25519 and not P-256
            "Curves" => "X25519"
        },
        test   => {
            "ExpectedServerCertType" =>, "Ed25519",
            "ExpectedServerSignType" =>, "Ed25519",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "Ed448 CipherString and Curves Selection",
        server => $server,
        client => {
            "CipherString" => "aECDSA",
            "MaxProtocol" => "TLSv1.2",
            "SignatureAlgorithms" => "ECDSA+SHA256:ed448",
            "VerifyCAFile" => test_pem("root-ed448-cert.pem"),
            # Excluding P-256 from the supported curves list means server
            # certificate should be Ed25519 and not P-256
            "Curves" => "X448"
        },
        test   => {
            "ExpectedServerCertType" =>, "Ed448",
            "ExpectedServerSignType" =>, "Ed448",
            "ExpectedResult" => "Success"
        },
    },
);

my @tests_pss = (
    {
        name => "RSA-PSS Certificate CipherString Selection",
        server => $server_pss,
        client => {
            "CipherString" => "aRSA",
            "MaxProtocol" => "TLSv1.2",
        },
        test   => {
            "ExpectedServerCertType" =>, "RSA-PSS",
            "ExpectedServerSignType" =>, "RSA-PSS",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "RSA-PSS Certificate Legacy Signature Algorithm Selection",
        server => $server_pss,
        client => {
            "SignatureAlgorithms" => "RSA-PSS+SHA256",
        },
        test   => {
            "ExpectedServerCertType" => "RSA",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "RSA-PSS",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "RSA-PSS Certificate Unified Signature Algorithm Selection",
        server => $server_pss,
        client => {
            "SignatureAlgorithms" => "rsa_pss_pss_sha256",
        },
        test   => {
            "ExpectedServerCertType" => "RSA-PSS",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "RSA-PSS",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "Only RSA-PSS Certificate",
        server => $server_pss_only,
        client => {},
        test   => {
            "ExpectedServerCertType" => "RSA-PSS",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "RSA-PSS",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "Only RSA-PSS Certificate Valid Signature Algorithms",
        server => $server_pss_only,
        client => {
            "SignatureAlgorithms" => "rsa_pss_pss_sha512",
        },
        test   => {
            "ExpectedServerCertType" => "RSA-PSS",
            "ExpectedServerSignHash" => "SHA512",
            "ExpectedServerSignType" => "RSA-PSS",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "RSA-PSS Certificate, no PSS signature algorithms",
        server => $server_pss_only,
        client => {
            "SignatureAlgorithms" => "RSA+SHA256",
        },
        test   => {
            "ExpectedResult" => "ServerFail"
        },
    },
    {
        name => "Only RSA-PSS Restricted Certificate",
        server => $server_pss_restrict_only,
        client => {},
        test   => {
            "ExpectedServerCertType" => "RSA-PSS",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "RSA-PSS",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "RSA-PSS Restricted Certificate Valid Signature Algorithms",
        server => $server_pss_restrict_only,
        client => {
            "SignatureAlgorithms" => "rsa_pss_pss_sha256:rsa_pss_pss_sha512",
        },
        test   => {
            "ExpectedServerCertType" => "RSA-PSS",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "RSA-PSS",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "RSA-PSS Restricted Cert client prefers invalid Signature Algorithm",
        server => $server_pss_restrict_only,
        client => {
            "SignatureAlgorithms" => "rsa_pss_pss_sha512:rsa_pss_pss_sha256",
        },
        test   => {
            "ExpectedServerCertType" => "RSA-PSS",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "RSA-PSS",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "RSA-PSS Restricted Certificate Invalid Signature Algorithms",
        server => $server_pss_restrict_only,
        client => {
            "SignatureAlgorithms" => "rsa_pss_pss_sha512",
        },
        test   => {
            "ExpectedResult" => "ServerFail"
        },
    },
    {
        name => "RSA key exchange with only RSA-PSS certificate",
        server => $server_pss_only,
        client => {
            "CipherString" => "kRSA",
            "MaxProtocol" => "TLSv1.2",
        },
        test   => {
            "ExpectedResult" => "ServerFail"
        },
    },
);

my @tests_tls_1_1 = (
    {
        name => "Only RSA-PSS Certificate, TLS v1.1",
        server => $server_pss_only,
        client => {
            "MaxProtocol" => "TLSv1.1",
        },
        test   => {
            "ExpectedResult" => "ServerFail"
        },
    },
);

push @tests, @tests_non_fips unless $fips_mode;
push @tests, @tests_pss;
push @tests, @tests_tls_1_1 unless disabled("tls1_1") || $no_deflt_libctx;

my $server_tls_1_3;

if ($fips_mode) {
    $server_tls_1_3 = {
        "ECDSA.Certificate" => test_pem("server-ecdsa-cert.pem"),
        "ECDSA.PrivateKey" => test_pem("server-ecdsa-key.pem"),
        "MinProtocol" => "TLSv1.3",
        "MaxProtocol" => "TLSv1.3"
    };
} else {
    $server_tls_1_3 = {
        "ECDSA.Certificate" => test_pem("server-ecdsa-cert.pem"),
        "ECDSA.PrivateKey" => test_pem("server-ecdsa-key.pem"),
        "Ed25519.Certificate" => test_pem("server-ed25519-cert.pem"),
        "Ed25519.PrivateKey" => test_pem("server-ed25519-key.pem"),
        "Ed448.Certificate" => test_pem("server-ed448-cert.pem"),
        "Ed448.PrivateKey" => test_pem("server-ed448-key.pem"),
        "MinProtocol" => "TLSv1.3",
        "MaxProtocol" => "TLSv1.3"
    };
}

my $client_tls_1_3 = {
    "RSA.Certificate" => test_pem("ee-client-chain.pem"),
    "RSA.PrivateKey" => test_pem("ee-key.pem"),
    "ECDSA.Certificate" => test_pem("ee-ecdsa-client-chain.pem"),
    "ECDSA.PrivateKey" => test_pem("ee-ecdsa-key.pem"),
    "MinProtocol" => "TLSv1.3",
    "MaxProtocol" => "TLSv1.3"
};

my @tests_tls_1_3 = (
    {
        name => "TLS 1.3 ECDSA Signature Algorithm Selection",
        server => $server_tls_1_3,
        client => {
            "SignatureAlgorithms" => "ECDSA+SHA256",
        },
        test   => {
            "ExpectedServerCertType" => "P-256",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "EC",
            "ExpectedServerCANames" => "empty",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.3 ECDSA Signature Algorithm Selection compressed point",
        server => {
            "ECDSA.Certificate" => test_pem("server-cecdsa-cert.pem"),
            "ECDSA.PrivateKey" => test_pem("server-cecdsa-key.pem"),
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3"
        },
        client => {
            "SignatureAlgorithms" => "ECDSA+SHA256",
        },
        test   => {
            "ExpectedServerCertType" => "P-256",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "EC",
            "ExpectedServerCANames" => "empty",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.3 ECDSA Signature Algorithm Selection SHA1",
        server => {
            "CipherString" => "DEFAULT:\@SECLEVEL=0",
            "ECDSA.Certificate" => test_pem("server-ecdsa-cert.pem"),
            "ECDSA.PrivateKey" => test_pem("server-ecdsa-key.pem"),
            "Ed25519.Certificate" => test_pem("server-ed25519-cert.pem"),
            "Ed25519.PrivateKey" => test_pem("server-ed25519-key.pem"),
            "Ed448.Certificate" => test_pem("server-ed448-cert.pem"),
            "Ed448.PrivateKey" => test_pem("server-ed448-key.pem"),
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3"
        },
        client => {
            "CipherString" => "DEFAULT:\@SECLEVEL=0",
            "SignatureAlgorithms" => "ECDSA+SHA1",
        },
        test   => {
            "ExpectedResult" => "ServerFail"
        },
    },
    {
        name => "TLS 1.3 ECDSA Signature Algorithm Selection with PSS",
        server => $server_tls_1_3,
        client => {
            "SignatureAlgorithms" => "ECDSA+SHA256:RSA-PSS+SHA256",
            "RequestCAFile" => test_pem("root-cert.pem"),
        },
        test   => {
            "ExpectedServerCertType" => "P-256",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "EC",
            "ExpectedServerCANames" => test_pem("root-cert.pem"),
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.3 RSA Signature Algorithm Selection SHA384 with PSS",
        server => $server_tls_1_3,
        client => {
            "SignatureAlgorithms" => "ECDSA+SHA384:RSA-PSS+SHA384",
        },
        test   => {
            "ExpectedServerCertType" => "RSA",
            "ExpectedServerSignHash" => "SHA384",
            "ExpectedServerSignType" => "RSA-PSS",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.3 ECDSA Signature Algorithm Selection, no ECDSA certificate",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3"
        },
        client => {
            "SignatureAlgorithms" => "ECDSA+SHA256",
        },
        test   => {
            "ExpectedResult" => "ServerFail"
        },
    },
    {
        name => "TLS 1.3 RSA Signature Algorithm Selection, no PSS",
        server => $server_tls_1_3,
        client => {
            "SignatureAlgorithms" => "RSA+SHA256",
        },
        test   => {
            "ExpectedResult" => "ServerFail"
        },
    },
    {
        name => "TLS 1.3 RSA-PSS Signature Algorithm Selection",
        server => $server_tls_1_3,
        client => {
            "SignatureAlgorithms" => "RSA-PSS+SHA256",
        },
        test   => {
            "ExpectedServerCertType" => "RSA",
            "ExpectedServerSignHash" => "SHA256",
            "ExpectedServerSignType" => "RSA-PSS",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.3 RSA Client Auth Signature Algorithm Selection",
        server => {
            "ClientSignatureAlgorithms" => "PSS+SHA256",
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "Require"
        },
        client => $client_tls_1_3,
        test   => {
            "ExpectedClientCertType" => "RSA",
            "ExpectedClientSignHash" => "SHA256",
            "ExpectedClientSignType" => "RSA-PSS",
            "ExpectedClientCANames" => "empty",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.3 RSA Client Auth Signature Algorithm Selection non-empty CA Names",
        server => {
            "ClientSignatureAlgorithms" => "PSS+SHA256",
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "RequestCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "Require"
        },
        client => $client_tls_1_3,
        test   => {
            "ExpectedClientCertType" => "RSA",
            "ExpectedClientSignHash" => "SHA256",
            "ExpectedClientSignType" => "RSA-PSS",
            "ExpectedClientCANames" => test_pem("root-cert.pem"),
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.3 ECDSA Client Auth Signature Algorithm Selection",
        server => {
            "ClientSignatureAlgorithms" => "ECDSA+SHA256",
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "Require"
        },
        client => $client_tls_1_3,
        test   => {
            "ExpectedClientCertType" => "P-256",
            "ExpectedClientSignHash" => "SHA256",
            "ExpectedClientSignType" => "EC",
            "ExpectedResult" => "Success"
        },
    },
);

my @tests_tls_1_3_non_fips = (
    {
        name => "TLS 1.3 Ed25519 Signature Algorithm Selection",
        server => $server_tls_1_3,
        client => {
            "SignatureAlgorithms" => "ed25519",
        },
        test   => {
            "ExpectedServerCertType" => "Ed25519",
            "ExpectedServerSignType" => "Ed25519",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.3 Ed448 Signature Algorithm Selection",
        server => $server_tls_1_3,
        client => {
            "SignatureAlgorithms" => "ed448",
            "VerifyCAFile" => test_pem("root-ed448-cert.pem"),
        },
        test   => {
            "ExpectedServerCertType" => "Ed448",
            "ExpectedServerSignType" => "Ed448",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.3 Ed25519 CipherString and Groups Selection",
        server => $server_tls_1_3,
        client => {
            "SignatureAlgorithms" => "ECDSA+SHA256:ed25519",
            # Excluding P-256 from the supported groups list should
            # mean server still uses a P-256 certificate because supported
            # groups is not used in signature selection for TLS 1.3
            "Groups" => "X25519"
        },
        test   => {
            "ExpectedServerCertType" =>, "P-256",
            "ExpectedServerSignType" =>, "EC",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.3 Ed448 CipherString and Groups Selection",
        server => $server_tls_1_3,
        client => {
            "SignatureAlgorithms" => "ECDSA+SHA256:ed448",
            # Excluding P-256 from the supported groups list should
            # mean server still uses a P-256 certificate because supported
            # groups is not used in signature selection for TLS 1.3
            "Groups" => "X448"
        },
        test   => {
            "ExpectedServerCertType" =>, "P-256",
            "ExpectedServerSignType" =>, "EC",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.3 Ed25519 Client Auth",
        server => {
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "Require"
        },
        client => {
            "EdDSA.Certificate" => test_pem("client-ed25519-cert.pem"),
            "EdDSA.PrivateKey" => test_pem("client-ed25519-key.pem"),
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3"
        },
        test   => {
            "ExpectedClientCertType" => "Ed25519",
            "ExpectedClientSignType" => "Ed25519",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.3 Ed448 Client Auth",
        server => {
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "Require"
        },
        client => {
            "EdDSA.Certificate" => test_pem("client-ed448-cert.pem"),
            "EdDSA.PrivateKey" => test_pem("client-ed448-key.pem"),
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3"
        },
        test   => {
            "ExpectedClientCertType" => "Ed448",
            "ExpectedClientSignType" => "Ed448",
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "TLS 1.3 ECDSA with brainpool but no suitable groups",
        server =>  {
            "Certificate" => test_pem("server-ecdsa-brainpoolP256r1-cert.pem"),
            "PrivateKey" => test_pem("server-ecdsa-brainpoolP256r1-key.pem"),
            "Groups" => "brainpoolP256r1",
        },
        client => {
            "CipherString" => "aECDSA",
            "RequestCAFile" => test_pem("root-cert.pem"),
            "Groups" => "brainpoolP256r1",
        },
        test   => {
            #We only configured brainpoolP256r1 on the client side, but TLSv1.3
            #is enabled and this group is not allowed in TLSv1.3. Therefore this
            #should fail
            "ExpectedResult" => "ClientFail"
        },
    },
    {
        name => "TLS 1.3 ECDSA with brainpool",
        server =>  {
            "Certificate" => test_pem("server-ecdsa-brainpoolP256r1-cert.pem"),
            "PrivateKey" => test_pem("server-ecdsa-brainpoolP256r1-key.pem"),
        },
        client => {
            "RequestCAFile" => test_pem("root-cert.pem"),
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3"
        },
        test   => {
            "ExpectedResult" => "ServerFail"
        },
    },
);

push @tests, @tests_tls_1_3 unless disabled("tls1_3");
push @tests, @tests_tls_1_3_non_fips unless disabled("tls1_3") || $fips_mode;

my @tests_dsa_tls_1_2 = (
    {
        name => "TLS 1.2 DSA Certificate Test",
        server => {
            "DSA.Certificate" => test_pem("server-dsa-cert.pem"),
            "DSA.PrivateKey" => test_pem("server-dsa-key.pem"),
            "DHParameters" => test_pem("dhp2048.pem"),
            "MinProtocol" => "TLSv1.2",
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ALL",
        },
        client => {
            "SignatureAlgorithms" => "DSA+SHA256:DSA+SHA1",
            "CipherString" => "ALL",
        },
        test   => {
            "ExpectedResult" => "Success"
        },
    },
);

my @tests_dsa_tls_1_3 = (
    {
        name => "TLS 1.3 Client Auth No TLS 1.3 Signature Algorithms",
        server => {
            "ClientSignatureAlgorithms" => "ECDSA+SHA1:DSA+SHA256:RSA+SHA256",
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "Request"
        },
        client => {},
        test   => {
            "ExpectedResult" => "ServerFail"
        },
    },
    {
        name => "TLS 1.3 DSA Certificate Test",
        server => {
            "DSA.Certificate" => test_pem("server-dsa-cert.pem"),
            "DSA.PrivateKey" => test_pem("server-dsa-key.pem"),
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "CipherString" => "ALL",
        },
        client => {
            "SignatureAlgorithms" => "DSA+SHA1:DSA+SHA256:ECDSA+SHA256",
            "CipherString" => "ALL",
        },
        test   => {
            "ExpectedResult" => "ServerFail"
        },
    },
);

if (!disabled("dsa")) {
    push @tests, @tests_dsa_tls_1_2 unless disabled("dh");
    push @tests, @tests_dsa_tls_1_3 unless disabled("tls1_3");
}
                                                                                                      node-23.7.0/deps/openssl/openssl/test/ssl-tests/21-key-update.cnf                                   0000664 0000000 0000000 00000006321 14746647661 0024560 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 4

test-0 = 0-update-key-client-update-not-requested
test-1 = 1-update-key-server-update-not-requested
test-2 = 2-update-key-client-update-requested
test-3 = 3-update-key-server-update-requested
# ===========================================================

[0-update-key-client-update-not-requested]
ssl_conf = 0-update-key-client-update-not-requested-ssl

[0-update-key-client-update-not-requested-ssl]
server = 0-update-key-client-update-not-requested-server
client = 0-update-key-client-update-not-requested-client

[0-update-key-client-update-not-requested-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-update-key-client-update-not-requested-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = Success
HandshakeMode = KeyUpdateClient
KeyUpdateType = KeyUpdateNotRequested
ResumptionExpected = No


# ===========================================================

[1-update-key-server-update-not-requested]
ssl_conf = 1-update-key-server-update-not-requested-ssl

[1-update-key-server-update-not-requested-ssl]
server = 1-update-key-server-update-not-requested-server
client = 1-update-key-server-update-not-requested-client

[1-update-key-server-update-not-requested-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-update-key-server-update-not-requested-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedResult = Success
HandshakeMode = KeyUpdateServer
KeyUpdateType = KeyUpdateNotRequested
ResumptionExpected = No


# ===========================================================

[2-update-key-client-update-requested]
ssl_conf = 2-update-key-client-update-requested-ssl

[2-update-key-client-update-requested-ssl]
server = 2-update-key-client-update-requested-server
client = 2-update-key-client-update-requested-client

[2-update-key-client-update-requested-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-update-key-client-update-requested-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ExpectedResult = Success
HandshakeMode = KeyUpdateClient
KeyUpdateType = KeyUpdateRequested
ResumptionExpected = No


# ===========================================================

[3-update-key-server-update-requested]
ssl_conf = 3-update-key-server-update-requested-ssl

[3-update-key-server-update-requested-ssl]
server = 3-update-key-server-update-requested-server
client = 3-update-key-server-update-requested-client

[3-update-key-server-update-requested-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-update-key-server-update-requested-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
ExpectedResult = Success
HandshakeMode = KeyUpdateServer
KeyUpdateType = KeyUpdateRequested
ResumptionExpected = No


                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/openssl/openssl/test/ssl-tests/21-key-update.cnf.in                                0000664 0000000 0000000 00000003323 14746647661 0025164 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2017-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test KeyUpdate

use strict;
use warnings;

package ssltests;

our @tests = (
    {
        name => "update-key-client-update-not-requested",
        server => {},
        client => {},
        test => {
            "HandshakeMode" => "KeyUpdateClient",
            "KeyUpdateType" => "KeyUpdateNotRequested",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "update-key-server-update-not-requested",
        server => {},
        client => {},
        test => {
            "HandshakeMode" => "KeyUpdateServer",
            "KeyUpdateType" => "KeyUpdateNotRequested",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "update-key-client-update-requested",
        server => {},
        client => {},
        test => {
            "HandshakeMode" => "KeyUpdateClient",
            "KeyUpdateType" => "KeyUpdateRequested",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "update-key-server-update-requested",
        server => {},
        client => {},
        test => {
            "HandshakeMode" => "KeyUpdateServer",
            "KeyUpdateType" => "KeyUpdateRequested",
            "ResumptionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    }
);
                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/openssl/openssl/test/ssl-tests/22-compression.cnf                                  0000664 0000000 0000000 00000012410 14746647661 0025046 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 8

test-0 = 0-tlsv1_3-both-compress
test-1 = 1-tlsv1_3-client-compress
test-2 = 2-tlsv1_3-server-compress
test-3 = 3-tlsv1_3-neither-compress
test-4 = 4-tlsv1_2-both-compress
test-5 = 5-tlsv1_2-client-compress
test-6 = 6-tlsv1_2-server-compress
test-7 = 7-tlsv1_2-neither-compress
# ===========================================================

[0-tlsv1_3-both-compress]
ssl_conf = 0-tlsv1_3-both-compress-ssl

[0-tlsv1_3-both-compress-ssl]
server = 0-tlsv1_3-both-compress-server
client = 0-tlsv1_3-both-compress-client

[0-tlsv1_3-both-compress-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = Compression
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-tlsv1_3-both-compress-client]
CipherString = DEFAULT
Options = Compression
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
CompressionExpected = No
ExpectedResult = Success


# ===========================================================

[1-tlsv1_3-client-compress]
ssl_conf = 1-tlsv1_3-client-compress-ssl

[1-tlsv1_3-client-compress-ssl]
server = 1-tlsv1_3-client-compress-server
client = 1-tlsv1_3-client-compress-client

[1-tlsv1_3-client-compress-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-tlsv1_3-client-compress-client]
CipherString = DEFAULT
Options = Compression
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
CompressionExpected = No
ExpectedResult = Success


# ===========================================================

[2-tlsv1_3-server-compress]
ssl_conf = 2-tlsv1_3-server-compress-ssl

[2-tlsv1_3-server-compress-ssl]
server = 2-tlsv1_3-server-compress-server
client = 2-tlsv1_3-server-compress-client

[2-tlsv1_3-server-compress-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = Compression
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-tlsv1_3-server-compress-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
CompressionExpected = No
ExpectedResult = Success


# ===========================================================

[3-tlsv1_3-neither-compress]
ssl_conf = 3-tlsv1_3-neither-compress-ssl

[3-tlsv1_3-neither-compress-ssl]
server = 3-tlsv1_3-neither-compress-server
client = 3-tlsv1_3-neither-compress-client

[3-tlsv1_3-neither-compress-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-tlsv1_3-neither-compress-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
CompressionExpected = No
ExpectedResult = Success


# ===========================================================

[4-tlsv1_2-both-compress]
ssl_conf = 4-tlsv1_2-both-compress-ssl

[4-tlsv1_2-both-compress-ssl]
server = 4-tlsv1_2-both-compress-server
client = 4-tlsv1_2-both-compress-client

[4-tlsv1_2-both-compress-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = Compression
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[4-tlsv1_2-both-compress-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.2
Options = Compression
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-4]
CompressionExpected = Yes
ExpectedResult = Success


# ===========================================================

[5-tlsv1_2-client-compress]
ssl_conf = 5-tlsv1_2-client-compress-ssl

[5-tlsv1_2-client-compress-ssl]
server = 5-tlsv1_2-client-compress-server
client = 5-tlsv1_2-client-compress-client

[5-tlsv1_2-client-compress-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[5-tlsv1_2-client-compress-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.2
Options = Compression
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-5]
CompressionExpected = No
ExpectedResult = Success


# ===========================================================

[6-tlsv1_2-server-compress]
ssl_conf = 6-tlsv1_2-server-compress-ssl

[6-tlsv1_2-server-compress-ssl]
server = 6-tlsv1_2-server-compress-server
client = 6-tlsv1_2-server-compress-client

[6-tlsv1_2-server-compress-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = Compression
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[6-tlsv1_2-server-compress-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-6]
CompressionExpected = No
ExpectedResult = Success


# ===========================================================

[7-tlsv1_2-neither-compress]
ssl_conf = 7-tlsv1_2-neither-compress-ssl

[7-tlsv1_2-neither-compress-ssl]
server = 7-tlsv1_2-neither-compress-server
client = 7-tlsv1_2-neither-compress-client

[7-tlsv1_2-neither-compress-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[7-tlsv1_2-neither-compress-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-7]
CompressionExpected = No
ExpectedResult = Success


                                                                                                                                                                                                                                                        node-23.7.0/deps/openssl/openssl/test/ssl-tests/22-compression.cnf.in                               0000664 0000000 0000000 00000005704 14746647661 0025463 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test Compression

use strict;
use warnings;

package ssltests;
use OpenSSL::Test::Utils;

our @tests = ();

our @tests_tls1_3 = (
    {
        name => "tlsv1_3-both-compress",
        server => {
            "Options" => "Compression"
        },
        client => {
            "Options" => "Compression"
        },
        test => {
            "CompressionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "tlsv1_3-client-compress",
        server => {
        },
        client => {
            "Options" => "Compression"
        },
        test => {
            "CompressionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "tlsv1_3-server-compress",
        server => {
            "Options" => "Compression"
        },
        client => {
        },
        test => {
            "CompressionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "tlsv1_3-neither-compress",
        server => {
        },
        client => {
        },
        test => {
            "CompressionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
);
our @tests_tls1_2 = (
    {
        name => "tlsv1_2-both-compress",
        server => {
            "Options" => "Compression"
        },
        client => {
            "Options" => "Compression",
            "MaxProtocol" => "TLSv1.2"
        },
        test => {
            "CompressionExpected" => "Yes",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "tlsv1_2-client-compress",
        server => {
        },
        client => {
            "Options" => "Compression",
            "MaxProtocol" => "TLSv1.2"
        },
        test => {
            "CompressionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "tlsv1_2-server-compress",
        server => {
            "Options" => "Compression"
        },
        client => {
            "MaxProtocol" => "TLSv1.2"
        },
        test => {
            "CompressionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "tlsv1_2-neither-compress",
        server => {
        },
        client => {
            "MaxProtocol" => "TLSv1.2"
        },
        test => {
            "CompressionExpected" => "No",
            "ExpectedResult" => "Success"
        }
    },
);

push @tests, @tests_tls1_3 unless disabled("tls1_3");
push @tests, @tests_tls1_2 unless alldisabled(("tls1_2", "tls1_1", "tls1",
                                               "ssl3"));
                                                            node-23.7.0/deps/openssl/openssl/test/ssl-tests/23-srp.cnf                                          0000664 0000000 0000000 00000006111 14746647661 0023313 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 4

test-0 = 0-srp
test-1 = 1-srp-bad-password
test-2 = 2-srp-auth
test-3 = 3-srp-auth-bad-password
# ===========================================================

[0-srp]
ssl_conf = 0-srp-ssl

[0-srp-ssl]
server = 0-srp-server
client = 0-srp-client

[0-srp-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = SRP
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-srp-client]
CipherString = SRP
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = Success
server = 0-srp-server-extra
client = 0-srp-client-extra

[0-srp-server-extra]
SRPPassword = password
SRPUser = user

[0-srp-client-extra]
SRPPassword = password
SRPUser = user


# ===========================================================

[1-srp-bad-password]
ssl_conf = 1-srp-bad-password-ssl

[1-srp-bad-password-ssl]
server = 1-srp-bad-password-server
client = 1-srp-bad-password-client

[1-srp-bad-password-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = SRP
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-srp-bad-password-client]
CipherString = SRP
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedResult = ServerFail
server = 1-srp-bad-password-server-extra
client = 1-srp-bad-password-client-extra

[1-srp-bad-password-server-extra]
SRPPassword = password
SRPUser = user

[1-srp-bad-password-client-extra]
SRPPassword = passw0rd
SRPUser = user


# ===========================================================

[2-srp-auth]
ssl_conf = 2-srp-auth-ssl

[2-srp-auth-ssl]
server = 2-srp-auth-server
client = 2-srp-auth-client

[2-srp-auth-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = aSRP
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-srp-auth-client]
CipherString = aSRP
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ExpectedResult = Success
server = 2-srp-auth-server-extra
client = 2-srp-auth-client-extra

[2-srp-auth-server-extra]
SRPPassword = password
SRPUser = user

[2-srp-auth-client-extra]
SRPPassword = password
SRPUser = user


# ===========================================================

[3-srp-auth-bad-password]
ssl_conf = 3-srp-auth-bad-password-ssl

[3-srp-auth-bad-password-ssl]
server = 3-srp-auth-bad-password-server
client = 3-srp-auth-bad-password-client

[3-srp-auth-bad-password-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = aSRP
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-srp-auth-bad-password-client]
CipherString = aSRP
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
ExpectedResult = ServerFail
server = 3-srp-auth-bad-password-server-extra
client = 3-srp-auth-bad-password-client-extra

[3-srp-auth-bad-password-server-extra]
SRPPassword = password
SRPUser = user

[3-srp-auth-bad-password-client-extra]
SRPPassword = passw0rd
SRPUser = user


                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/openssl/openssl/test/ssl-tests/23-srp.cnf.in                                       0000664 0000000 0000000 00000005461 14746647661 0023727 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2017-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html

use strict;
use warnings;

package ssltests;

# SRP is only supported up to TLSv1.2

our @tests = (
    {
        name => "srp",
        server => {
            "CipherString" => "SRP",
            "MaxProtocol" => "TLSv1.2",
            extra => {
                "SRPUser" => "user",
                "SRPPassword" => "password",
            },
        },
        client => {
            "CipherString" => "SRP",
            "MaxProtocol" => "TLSv1.2",
            extra => {
                "SRPUser" => "user",
                "SRPPassword" => "password",
            },
        },
        test => {
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "srp-bad-password",
        server => {
            "CipherString" => "SRP",
            "MaxProtocol" => "TLSv1.2",
            extra => {
                "SRPUser" => "user",
                "SRPPassword" => "password",
            },
        },
        client => {
            "CipherString" => "SRP",
            "MaxProtocol" => "TLSv1.2",
            extra => {
                "SRPUser" => "user",
                "SRPPassword" => "passw0rd",
            },
        },
        test => {
            # Server fails first with bad client Finished.
            "ExpectedResult" => "ServerFail"
        },
    },
    {
        name => "srp-auth",
        server => {
            "CipherString" => "aSRP",
            "MaxProtocol" => "TLSv1.2",
            extra => {
                "SRPUser" => "user",
                "SRPPassword" => "password",
            },
        },
        client => {
            "CipherString" => "aSRP",
            "MaxProtocol" => "TLSv1.2",
            extra => {
                "SRPUser" => "user",
                "SRPPassword" => "password",
            },
        },
        test => {
            "ExpectedResult" => "Success"
        },
    },
    {
        name => "srp-auth-bad-password",
        server => {
            "CipherString" => "aSRP",
            "MaxProtocol" => "TLSv1.2",
            extra => {
                "SRPUser" => "user",
                "SRPPassword" => "password",
            },
        },
        client => {
            "CipherString" => "aSRP",
            "MaxProtocol" => "TLSv1.2",
            extra => {
                "SRPUser" => "user",
                "SRPPassword" => "passw0rd",
            },
        },
        test => {
            # Server fails first with bad client Finished.
            "ExpectedResult" => "ServerFail"
        },
    },
);
                                                                                                                                                                                                               node-23.7.0/deps/openssl/openssl/test/ssl-tests/24-padding.cnf                                      0000664 0000000 0000000 00000001227 14746647661 0024121 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 1

test-0 = 0-default
# ===========================================================

[0-default]
ssl_conf = 0-default-ssl

[0-default-ssl]
server = 0-default-server
client = 0-default-client

[0-default-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
RecordPadding = 64

[0-default-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
RecordPadding = 11
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = Success


                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/openssl/openssl/test/ssl-tests/24-padding.cnf.in                                   0000664 0000000 0000000 00000001405 14746647661 0024524 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2017-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## SSL test configurations

package ssltests;

our @tests = (
    {
        name => "default",
        server => { "RecordPadding" => 64,
	            "MaxProtocol" => "TLSv1.3",
                    "MinProtocol" => "TLSv1.3" },
        client => { "RecordPadding" => 11,
	            "MaxProtocol" => "TLSv1.3",
                    "MinProtocol" => "TLSv1.3" },
        test   => { "ExpectedResult" => "Success" },
    },
);
                                                                                                                                                                                                                                                           node-23.7.0/deps/openssl/openssl/test/ssl-tests/25-cipher.cnf                                       0000664 0000000 0000000 00000015625 14746647661 0023775 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 9

test-0 = 0-cipher-server-1
test-1 = 1-cipher-server-2
test-2 = 2-cipher-server-client-list
test-3 = 3-cipher-server-pref-1
test-4 = 4-cipher-server-pref-2
test-5 = 5-cipher-server-pref-client-list
test-6 = 6-cipher-server-pref-not-mobile
test-7 = 7-cipher-server-pref-mobile
test-8 = 8-cipher-server-pref-mobile2
# ===========================================================

[0-cipher-server-1]
ssl_conf = 0-cipher-server-1-ssl

[0-cipher-server-1-ssl]
server = 0-cipher-server-1-server
client = 0-cipher-server-1-client

[0-cipher-server-1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-cipher-server-1-client]
CipherString = ECDHE-RSA-AES256-SHA384
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedCipher = ECDHE-RSA-AES256-SHA384


# ===========================================================

[1-cipher-server-2]
ssl_conf = 1-cipher-server-2-ssl

[1-cipher-server-2-ssl]
server = 1-cipher-server-2-server
client = 1-cipher-server-2-client

[1-cipher-server-2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-cipher-server-2-client]
CipherString = ECDHE-RSA-AES128-SHA256
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedCipher = ECDHE-RSA-AES128-SHA256


# ===========================================================

[2-cipher-server-client-list]
ssl_conf = 2-cipher-server-client-list-ssl

[2-cipher-server-client-list-ssl]
server = 2-cipher-server-client-list-server
client = 2-cipher-server-client-list-client

[2-cipher-server-client-list-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-cipher-server-client-list-client]
CipherString = ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ExpectedCipher = ECDHE-RSA-AES128-SHA256


# ===========================================================

[3-cipher-server-pref-1]
ssl_conf = 3-cipher-server-pref-1-ssl

[3-cipher-server-pref-1-ssl]
server = 3-cipher-server-pref-1-server
client = 3-cipher-server-pref-1-client

[3-cipher-server-pref-1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256
MaxProtocol = TLSv1.2
Options = ServerPreference
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-cipher-server-pref-1-client]
CipherString = ECDHE-RSA-AES256-SHA384
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
ExpectedCipher = ECDHE-RSA-AES256-SHA384


# ===========================================================

[4-cipher-server-pref-2]
ssl_conf = 4-cipher-server-pref-2-ssl

[4-cipher-server-pref-2-ssl]
server = 4-cipher-server-pref-2-server
client = 4-cipher-server-pref-2-client

[4-cipher-server-pref-2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256
MaxProtocol = TLSv1.2
Options = ServerPreference
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[4-cipher-server-pref-2-client]
CipherString = ECDHE-RSA-AES128-SHA256
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-4]
ExpectedCipher = ECDHE-RSA-AES128-SHA256


# ===========================================================

[5-cipher-server-pref-client-list]
ssl_conf = 5-cipher-server-pref-client-list-ssl

[5-cipher-server-pref-client-list-ssl]
server = 5-cipher-server-pref-client-list-server
client = 5-cipher-server-pref-client-list-client

[5-cipher-server-pref-client-list-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256
MaxProtocol = TLSv1.2
Options = ServerPreference
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[5-cipher-server-pref-client-list-client]
CipherString = ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-5]
ExpectedCipher = ECDHE-RSA-AES256-SHA384


# ===========================================================

[6-cipher-server-pref-not-mobile]
ssl_conf = 6-cipher-server-pref-not-mobile-ssl

[6-cipher-server-pref-not-mobile-ssl]
server = 6-cipher-server-pref-not-mobile-server
client = 6-cipher-server-pref-not-mobile-client

[6-cipher-server-pref-not-mobile-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-CHACHA20-POLY1305
MaxProtocol = TLSv1.2
Options = ServerPreference
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[6-cipher-server-pref-not-mobile-client]
CipherString = ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-6]
ExpectedCipher = ECDHE-RSA-AES256-SHA384


# ===========================================================

[7-cipher-server-pref-mobile]
ssl_conf = 7-cipher-server-pref-mobile-ssl

[7-cipher-server-pref-mobile-ssl]
server = 7-cipher-server-pref-mobile-server
client = 7-cipher-server-pref-mobile-client

[7-cipher-server-pref-mobile-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-CHACHA20-POLY1305
MaxProtocol = TLSv1.2
Options = ServerPreference,PrioritizeChaCha
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[7-cipher-server-pref-mobile-client]
CipherString = ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-CHACHA20-POLY1305
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-7]
ExpectedCipher = ECDHE-RSA-AES256-SHA384


# ===========================================================

[8-cipher-server-pref-mobile2]
ssl_conf = 8-cipher-server-pref-mobile2-ssl

[8-cipher-server-pref-mobile2-ssl]
server = 8-cipher-server-pref-mobile2-server
client = 8-cipher-server-pref-mobile2-client

[8-cipher-server-pref-mobile2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-CHACHA20-POLY1305
MaxProtocol = TLSv1.2
Options = ServerPreference,PrioritizeChaCha
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[8-cipher-server-pref-mobile2-client]
CipherString = ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-8]
ExpectedCipher = ECDHE-RSA-CHACHA20-POLY1305


                                                                                                           node-23.7.0/deps/openssl/openssl/test/ssl-tests/25-cipher.cnf.in                                    0000664 0000000 0000000 00000011623 14746647661 0024374 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2017-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test version negotiation

use strict;
use warnings;

package ssltests;
use OpenSSL::Test::Utils;

our $fips_mode;

our @tests = (
    {
        name => "cipher-server-1",
        server => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256",
    },
        client => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES256-SHA384"
        },
        test => {
            "ExpectedCipher" => "ECDHE-RSA-AES256-SHA384",
        },
    },
    {
        name => "cipher-server-2",
        server => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256",
        },
        client => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES128-SHA256"
        },
        test => {
            "ExpectedCipher" => "ECDHE-RSA-AES128-SHA256",
        },
    },
    {
        name => "cipher-server-client-list",
        server => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256",
        },
        client => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384",
        },
        test => {
            "ExpectedCipher" => "ECDHE-RSA-AES128-SHA256",
        },
    },
    {
        name => "cipher-server-pref-1",
        server => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256",
            "Options" => "ServerPreference",
        },
        client => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES256-SHA384"
        },
        test => {
            "ExpectedCipher" => "ECDHE-RSA-AES256-SHA384",
        },
    },
    {
        name => "cipher-server-pref-2",
        server => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256",
            "Options" => "ServerPreference",
        },
        client => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES128-SHA256"
        },
        test => {
            "ExpectedCipher" => "ECDHE-RSA-AES128-SHA256",
        },
    },
    {
        name => "cipher-server-pref-client-list",
        server => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256",
            "Options" => "ServerPreference",
        },
        client => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384",
        },
        test => {
            "ExpectedCipher" => "ECDHE-RSA-AES256-SHA384",
        },
    },
    {
        name => "cipher-server-pref-not-mobile",
        server => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-CHACHA20-POLY1305",
            "Options" => "ServerPreference",
        },
        client => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384",
        },
        test => {
            "ExpectedCipher" => "ECDHE-RSA-AES256-SHA384",
        },
    },
    {
        name => "cipher-server-pref-mobile",
        server => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-CHACHA20-POLY1305",
            "Options" => "ServerPreference,PrioritizeChaCha",
        },
        client => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-CHACHA20-POLY1305",
        },
        test => {
            "ExpectedCipher" => "ECDHE-RSA-AES256-SHA384",
        },
    },
);

my @tests_poly1305 = (
    {
        name => "cipher-server-pref-mobile2",
        server => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-CHACHA20-POLY1305",
            "Options" => "ServerPreference,PrioritizeChaCha",
        },
        client => {
            "MaxProtocol" => "TLSv1.2",
            "CipherString" => "ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384",
        },
        test => {
            "ExpectedCipher" => "ECDHE-RSA-CHACHA20-POLY1305",
        },
    },
);

push @tests, @tests_poly1305
    unless disabled("poly1305") || disabled("chacha") || $fips_mode;
                                                                                                             node-23.7.0/deps/openssl/openssl/test/ssl-tests/26-tls13_client_auth.cnf                            0000664 0000000 0000000 00000036211 14746647661 0026043 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 14

test-0 = 0-server-auth-TLSv1.3
test-1 = 1-client-auth-TLSv1.3-request
test-2 = 2-client-auth-TLSv1.3-require-fail
test-3 = 3-client-auth-TLSv1.3-require
test-4 = 4-client-auth-TLSv1.3-require-non-empty-names
test-5 = 5-client-auth-TLSv1.3-noroot
test-6 = 6-client-auth-TLSv1.3-request-post-handshake
test-7 = 7-client-auth-TLSv1.3-require-fail-post-handshake
test-8 = 8-client-auth-TLSv1.3-require-post-handshake
test-9 = 9-client-auth-TLSv1.3-require-non-empty-names-post-handshake
test-10 = 10-client-auth-TLSv1.3-noroot-post-handshake
test-11 = 11-client-auth-TLSv1.3-request-force-client-post-handshake
test-12 = 12-client-auth-TLSv1.3-request-force-server-post-handshake
test-13 = 13-client-auth-TLSv1.3-request-force-both-post-handshake
# ===========================================================

[0-server-auth-TLSv1.3]
ssl_conf = 0-server-auth-TLSv1.3-ssl

[0-server-auth-TLSv1.3-ssl]
server = 0-server-auth-TLSv1.3-server
client = 0-server-auth-TLSv1.3-client

[0-server-auth-TLSv1.3-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-server-auth-TLSv1.3-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = Success


# ===========================================================

[1-client-auth-TLSv1.3-request]
ssl_conf = 1-client-auth-TLSv1.3-request-ssl

[1-client-auth-TLSv1.3-request-ssl]
server = 1-client-auth-TLSv1.3-request-server
client = 1-client-auth-TLSv1.3-request-client

[1-client-auth-TLSv1.3-request-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyMode = Request

[1-client-auth-TLSv1.3-request-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedResult = Success


# ===========================================================

[2-client-auth-TLSv1.3-require-fail]
ssl_conf = 2-client-auth-TLSv1.3-require-fail-ssl

[2-client-auth-TLSv1.3-require-fail-ssl]
server = 2-client-auth-TLSv1.3-require-fail-server
client = 2-client-auth-TLSv1.3-require-fail-client

[2-client-auth-TLSv1.3-require-fail-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Require

[2-client-auth-TLSv1.3-require-fail-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ExpectedResult = ServerFail
ExpectedServerAlert = CertificateRequired


# ===========================================================

[3-client-auth-TLSv1.3-require]
ssl_conf = 3-client-auth-TLSv1.3-require-ssl

[3-client-auth-TLSv1.3-require-ssl]
server = 3-client-auth-TLSv1.3-require-server
client = 3-client-auth-TLSv1.3-require-client

[3-client-auth-TLSv1.3-require-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ClientSignatureAlgorithms = PSS+SHA256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Request

[3-client-auth-TLSv1.3-require-client]
Certificate = ${ENV::TEST_CERTS_DIR}/ee-client-chain.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-key.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
ExpectedClientCANames = empty
ExpectedClientCertType = RSA
ExpectedClientSignHash = SHA256
ExpectedClientSignType = RSA-PSS
ExpectedResult = Success


# ===========================================================

[4-client-auth-TLSv1.3-require-non-empty-names]
ssl_conf = 4-client-auth-TLSv1.3-require-non-empty-names-ssl

[4-client-auth-TLSv1.3-require-non-empty-names-ssl]
server = 4-client-auth-TLSv1.3-require-non-empty-names-server
client = 4-client-auth-TLSv1.3-require-non-empty-names-client

[4-client-auth-TLSv1.3-require-non-empty-names-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ClientCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
ClientSignatureAlgorithms = PSS+SHA256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = Request

[4-client-auth-TLSv1.3-require-non-empty-names-client]
Certificate = ${ENV::TEST_CERTS_DIR}/ee-client-chain.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-key.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-4]
ExpectedClientCANames = ${ENV::TEST_CERTS_DIR}/root-cert.pem
ExpectedClientCertType = RSA
ExpectedClientSignHash = SHA256
ExpectedClientSignType = RSA-PSS
ExpectedResult = Success


# ===========================================================

[5-client-auth-TLSv1.3-noroot]
ssl_conf = 5-client-auth-TLSv1.3-noroot-ssl

[5-client-auth-TLSv1.3-noroot-ssl]
server = 5-client-auth-TLSv1.3-noroot-server
client = 5-client-auth-TLSv1.3-noroot-client

[5-client-auth-TLSv1.3-noroot-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyMode = Require

[5-client-auth-TLSv1.3-noroot-client]
Certificate = ${ENV::TEST_CERTS_DIR}/ee-client-chain.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-key.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-5]
ExpectedResult = ServerFail
ExpectedServerAlert = UnknownCA


# ===========================================================

[6-client-auth-TLSv1.3-request-post-handshake]
ssl_conf = 6-client-auth-TLSv1.3-request-post-handshake-ssl

[6-client-auth-TLSv1.3-request-post-handshake-ssl]
server = 6-client-auth-TLSv1.3-request-post-handshake-server
client = 6-client-auth-TLSv1.3-request-post-handshake-client

[6-client-auth-TLSv1.3-request-post-handshake-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyMode = RequestPostHandshake

[6-client-auth-TLSv1.3-request-post-handshake-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-6]
ExpectedResult = ServerFail
HandshakeMode = PostHandshakeAuth


# ===========================================================

[7-client-auth-TLSv1.3-require-fail-post-handshake]
ssl_conf = 7-client-auth-TLSv1.3-require-fail-post-handshake-ssl

[7-client-auth-TLSv1.3-require-fail-post-handshake-ssl]
server = 7-client-auth-TLSv1.3-require-fail-post-handshake-server
client = 7-client-auth-TLSv1.3-require-fail-post-handshake-client

[7-client-auth-TLSv1.3-require-fail-post-handshake-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = RequirePostHandshake

[7-client-auth-TLSv1.3-require-fail-post-handshake-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-7]
ExpectedResult = ServerFail
HandshakeMode = PostHandshakeAuth


# ===========================================================

[8-client-auth-TLSv1.3-require-post-handshake]
ssl_conf = 8-client-auth-TLSv1.3-require-post-handshake-ssl

[8-client-auth-TLSv1.3-require-post-handshake-ssl]
server = 8-client-auth-TLSv1.3-require-post-handshake-server
client = 8-client-auth-TLSv1.3-require-post-handshake-client

[8-client-auth-TLSv1.3-require-post-handshake-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ClientSignatureAlgorithms = PSS+SHA256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = RequestPostHandshake

[8-client-auth-TLSv1.3-require-post-handshake-client]
Certificate = ${ENV::TEST_CERTS_DIR}/ee-client-chain.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-key.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-8]
ExpectedClientCANames = empty
ExpectedClientCertType = RSA
ExpectedClientSignHash = SHA256
ExpectedClientSignType = RSA-PSS
ExpectedResult = Success
HandshakeMode = PostHandshakeAuth
client = 8-client-auth-TLSv1.3-require-post-handshake-client-extra

[8-client-auth-TLSv1.3-require-post-handshake-client-extra]
EnablePHA = Yes


# ===========================================================

[9-client-auth-TLSv1.3-require-non-empty-names-post-handshake]
ssl_conf = 9-client-auth-TLSv1.3-require-non-empty-names-post-handshake-ssl

[9-client-auth-TLSv1.3-require-non-empty-names-post-handshake-ssl]
server = 9-client-auth-TLSv1.3-require-non-empty-names-post-handshake-server
client = 9-client-auth-TLSv1.3-require-non-empty-names-post-handshake-client

[9-client-auth-TLSv1.3-require-non-empty-names-post-handshake-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
ClientCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
ClientSignatureAlgorithms = PSS+SHA256
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-cert.pem
VerifyMode = RequestPostHandshake

[9-client-auth-TLSv1.3-require-non-empty-names-post-handshake-client]
Certificate = ${ENV::TEST_CERTS_DIR}/ee-client-chain.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-key.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-9]
ExpectedClientCANames = ${ENV::TEST_CERTS_DIR}/root-cert.pem
ExpectedClientCertType = RSA
ExpectedClientSignHash = SHA256
ExpectedClientSignType = RSA-PSS
ExpectedResult = Success
HandshakeMode = PostHandshakeAuth
client = 9-client-auth-TLSv1.3-require-non-empty-names-post-handshake-client-extra

[9-client-auth-TLSv1.3-require-non-empty-names-post-handshake-client-extra]
EnablePHA = Yes


# ===========================================================

[10-client-auth-TLSv1.3-noroot-post-handshake]
ssl_conf = 10-client-auth-TLSv1.3-noroot-post-handshake-ssl

[10-client-auth-TLSv1.3-noroot-post-handshake-ssl]
server = 10-client-auth-TLSv1.3-noroot-post-handshake-server
client = 10-client-auth-TLSv1.3-noroot-post-handshake-client

[10-client-auth-TLSv1.3-noroot-post-handshake-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyMode = RequirePostHandshake

[10-client-auth-TLSv1.3-noroot-post-handshake-client]
Certificate = ${ENV::TEST_CERTS_DIR}/ee-client-chain.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/ee-key.pem
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-10]
ExpectedResult = ServerFail
ExpectedServerAlert = UnknownCA
HandshakeMode = PostHandshakeAuth
client = 10-client-auth-TLSv1.3-noroot-post-handshake-client-extra

[10-client-auth-TLSv1.3-noroot-post-handshake-client-extra]
EnablePHA = Yes


# ===========================================================

[11-client-auth-TLSv1.3-request-force-client-post-handshake]
ssl_conf = 11-client-auth-TLSv1.3-request-force-client-post-handshake-ssl

[11-client-auth-TLSv1.3-request-force-client-post-handshake-ssl]
server = 11-client-auth-TLSv1.3-request-force-client-post-handshake-server
client = 11-client-auth-TLSv1.3-request-force-client-post-handshake-client

[11-client-auth-TLSv1.3-request-force-client-post-handshake-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyMode = RequestPostHandshake

[11-client-auth-TLSv1.3-request-force-client-post-handshake-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-11]
ExpectedResult = Success
HandshakeMode = PostHandshakeAuth
client = 11-client-auth-TLSv1.3-request-force-client-post-handshake-client-extra

[11-client-auth-TLSv1.3-request-force-client-post-handshake-client-extra]
EnablePHA = Yes


# ===========================================================

[12-client-auth-TLSv1.3-request-force-server-post-handshake]
ssl_conf = 12-client-auth-TLSv1.3-request-force-server-post-handshake-ssl

[12-client-auth-TLSv1.3-request-force-server-post-handshake-ssl]
server = 12-client-auth-TLSv1.3-request-force-server-post-handshake-server
client = 12-client-auth-TLSv1.3-request-force-server-post-handshake-client

[12-client-auth-TLSv1.3-request-force-server-post-handshake-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyMode = RequestPostHandshake

[12-client-auth-TLSv1.3-request-force-server-post-handshake-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-12]
ExpectedResult = ClientFail
HandshakeMode = PostHandshakeAuth
server = 12-client-auth-TLSv1.3-request-force-server-post-handshake-server-extra

[12-client-auth-TLSv1.3-request-force-server-post-handshake-server-extra]
ForcePHA = Yes


# ===========================================================

[13-client-auth-TLSv1.3-request-force-both-post-handshake]
ssl_conf = 13-client-auth-TLSv1.3-request-force-both-post-handshake-ssl

[13-client-auth-TLSv1.3-request-force-both-post-handshake-ssl]
server = 13-client-auth-TLSv1.3-request-force-both-post-handshake-server
client = 13-client-auth-TLSv1.3-request-force-both-post-handshake-client

[13-client-auth-TLSv1.3-request-force-both-post-handshake-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
VerifyMode = RequestPostHandshake

[13-client-auth-TLSv1.3-request-force-both-post-handshake-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.3
MinProtocol = TLSv1.3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-13]
ExpectedResult = Success
HandshakeMode = PostHandshakeAuth
server = 13-client-auth-TLSv1.3-request-force-both-post-handshake-server-extra
client = 13-client-auth-TLSv1.3-request-force-both-post-handshake-client-extra

[13-client-auth-TLSv1.3-request-force-both-post-handshake-server-extra]
ForcePHA = Yes

[13-client-auth-TLSv1.3-request-force-both-post-handshake-client-extra]
EnablePHA = Yes


                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/openssl/openssl/test/ssl-tests/26-tls13_client_auth.cnf.in                         0000664 0000000 0000000 00000022665 14746647661 0026460 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2018-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test TLSv1.3 certificate authentication
## Similar to 04-client_auth.cnf.in output, but specific for
## TLSv1.3 and post-handshake authentication

use strict;
use warnings;

package ssltests;
use OpenSSL::Test::Utils;

our @tests = (
    {
        name => "server-auth-TLSv1.3",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
        },
        test => {
            "ExpectedResult" => "Success",
        },
    },
    {
        name => "client-auth-TLSv1.3-request",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "VerifyMode" => "Request",
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
        },
        test => {
            "ExpectedResult" => "Success",
        },
    },
    {
        name => "client-auth-TLSv1.3-require-fail",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "Require",
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
        },
        test => {
            "ExpectedResult" => "ServerFail",
            "ExpectedServerAlert" => "CertificateRequired",
        },
    },
    {
        name => "client-auth-TLSv1.3-require",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "ClientSignatureAlgorithms" => "PSS+SHA256",
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "Request",
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "Certificate" => test_pem("ee-client-chain.pem"),
            "PrivateKey" => test_pem("ee-key.pem"),
        },
        test => {
            "ExpectedResult" => "Success",
            "ExpectedClientCertType" => "RSA",
            "ExpectedClientSignType" => "RSA-PSS",
            "ExpectedClientSignHash" => "SHA256",
            "ExpectedClientCANames" => "empty"
        },
    },
    {
        name => "client-auth-TLSv1.3-require-non-empty-names",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "ClientSignatureAlgorithms" => "PSS+SHA256",
            "ClientCAFile" => test_pem("root-cert.pem"),
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "Request",
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "Certificate" => test_pem("ee-client-chain.pem"),
            "PrivateKey" => test_pem("ee-key.pem"),
        },
        test => {
            "ExpectedResult" => "Success",
            "ExpectedClientCertType" => "RSA",
            "ExpectedClientSignType" => "RSA-PSS",
            "ExpectedClientSignHash" => "SHA256",
            "ExpectedClientCANames" => test_pem("root-cert.pem"),
        },
    },
    {
        name => "client-auth-TLSv1.3-noroot",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "VerifyMode" => "Require",
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "Certificate" => test_pem("ee-client-chain.pem"),
            "PrivateKey" => test_pem("ee-key.pem"),
        },
        test => {
            "ExpectedResult" => "ServerFail",
            "ExpectedServerAlert" => "UnknownCA",
        },
    },
    {
        name => "client-auth-TLSv1.3-request-post-handshake",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "VerifyMode" => "RequestPostHandshake",
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
        },
        test => {
            "ExpectedResult" => "ServerFail",
            "HandshakeMode" => "PostHandshakeAuth",
        },
    },
    {
        name => "client-auth-TLSv1.3-require-fail-post-handshake",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "RequirePostHandshake",
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
        },
        test => {
            "ExpectedResult" => "ServerFail",
            "HandshakeMode" => "PostHandshakeAuth",
        },
    },
    {
        name => "client-auth-TLSv1.3-require-post-handshake",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "ClientSignatureAlgorithms" => "PSS+SHA256",
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "RequestPostHandshake",
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "Certificate" => test_pem("ee-client-chain.pem"),
            "PrivateKey" => test_pem("ee-key.pem"),
            extra => {
                "EnablePHA" => "Yes",
            },
        },
        test => {
            "ExpectedResult" => "Success",
            "HandshakeMode" => "PostHandshakeAuth",
            "ExpectedClientCertType" => "RSA",
            "ExpectedClientSignType" => "RSA-PSS",
            "ExpectedClientSignHash" => "SHA256",
            "ExpectedClientCANames" => "empty"
        },
    },
    {
        name => "client-auth-TLSv1.3-require-non-empty-names-post-handshake",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "ClientSignatureAlgorithms" => "PSS+SHA256",
            "ClientCAFile" => test_pem("root-cert.pem"),
            "VerifyCAFile" => test_pem("root-cert.pem"),
            "VerifyMode" => "RequestPostHandshake",
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "Certificate" => test_pem("ee-client-chain.pem"),
            "PrivateKey" => test_pem("ee-key.pem"),
            extra => {
                "EnablePHA" => "Yes",
            },
        },
        test => {
            "ExpectedResult" => "Success",
            "HandshakeMode" => "PostHandshakeAuth",
            "ExpectedClientCertType" => "RSA",
            "ExpectedClientSignType" => "RSA-PSS",
            "ExpectedClientSignHash" => "SHA256",
            "ExpectedClientCANames" => test_pem("root-cert.pem"),
        },
    },
    {
        name => "client-auth-TLSv1.3-noroot-post-handshake",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "VerifyMode" => "RequirePostHandshake",
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "Certificate" => test_pem("ee-client-chain.pem"),
            "PrivateKey" => test_pem("ee-key.pem"),
            extra => {
                "EnablePHA" => "Yes",
            },
        },
        test => {
            "ExpectedResult" => "ServerFail",
            "HandshakeMode" => "PostHandshakeAuth",
            "ExpectedServerAlert" => "UnknownCA",
        },
    },
    {
        name => "client-auth-TLSv1.3-request-force-client-post-handshake",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "VerifyMode" => "RequestPostHandshake",
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            extra => {
                "EnablePHA" => "Yes",
            },
        },
        test => {
            "ExpectedResult" => "Success",
            "HandshakeMode" => "PostHandshakeAuth",
        },
    },
    {
        name => "client-auth-TLSv1.3-request-force-server-post-handshake",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "VerifyMode" => "RequestPostHandshake",
            extra => {
                "ForcePHA" => "Yes",
            },
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
        },
        test => {
            "ExpectedResult" => "ClientFail",
            "HandshakeMode" => "PostHandshakeAuth",
        },
    },
    {
        name => "client-auth-TLSv1.3-request-force-both-post-handshake",
        server => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            "VerifyMode" => "RequestPostHandshake",
            extra => {
                "ForcePHA" => "Yes",
            },
        },
        client => {
            "MinProtocol" => "TLSv1.3",
            "MaxProtocol" => "TLSv1.3",
            extra => {
                "EnablePHA" => "Yes",
            },
        },
        test => {
            "ExpectedResult" => "Success",
            "HandshakeMode" => "PostHandshakeAuth",
        },
    },
);
                                                                           node-23.7.0/deps/openssl/openssl/test/ssl-tests/27-ticket-appdata.cnf                               0000664 0000000 0000000 00000007745 14746647661 0025424 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 4

test-0 = 0-session-ticket-app-data12
test-1 = 1-session-ticket-app-data12
test-2 = 2-session-ticket-app-data13
test-3 = 3-session-ticket-app-data13
# ===========================================================

[0-session-ticket-app-data12]
ssl_conf = 0-session-ticket-app-data12-ssl

[0-session-ticket-app-data12-ssl]
server = 0-session-ticket-app-data12-server
client = 0-session-ticket-app-data12-client
resume-server = 0-session-ticket-app-data12-server
resume-client = 0-session-ticket-app-data12-client

[0-session-ticket-app-data12-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-session-ticket-app-data12-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.2
Options = SessionTicket
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = Success
ExpectedSessionTicketAppData = HelloWorld
HandshakeMode = Resume
ResumptionExpected = Yes
SessionTicketExpected = Yes
server = 0-session-ticket-app-data12-server-extra
resume-server = 0-session-ticket-app-data12-server-extra

[0-session-ticket-app-data12-server-extra]
SessionTicketAppData = HelloWorld


# ===========================================================

[1-session-ticket-app-data12]
ssl_conf = 1-session-ticket-app-data12-ssl

[1-session-ticket-app-data12-ssl]
server = 1-session-ticket-app-data12-server
client = 1-session-ticket-app-data12-client
resume-server = 1-session-ticket-app-data12-server
resume-client = 1-session-ticket-app-data12-client

[1-session-ticket-app-data12-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-session-ticket-app-data12-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.2
Options = SessionTicket
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedResult = Success
ExpectedSessionTicketAppData = 
HandshakeMode = Resume
ResumptionExpected = Yes
SessionTicketExpected = Yes


# ===========================================================

[2-session-ticket-app-data13]
ssl_conf = 2-session-ticket-app-data13-ssl

[2-session-ticket-app-data13-ssl]
server = 2-session-ticket-app-data13-server
client = 2-session-ticket-app-data13-client
resume-server = 2-session-ticket-app-data13-server
resume-client = 2-session-ticket-app-data13-client

[2-session-ticket-app-data13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-session-ticket-app-data13-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.3
Options = SessionTicket
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ExpectedResult = Success
ExpectedSessionTicketAppData = HelloWorld
HandshakeMode = Resume
ResumptionExpected = Yes
SessionTicketExpected = Yes
server = 2-session-ticket-app-data13-server-extra
resume-server = 2-session-ticket-app-data13-server-extra

[2-session-ticket-app-data13-server-extra]
SessionTicketAppData = HelloWorld


# ===========================================================

[3-session-ticket-app-data13]
ssl_conf = 3-session-ticket-app-data13-ssl

[3-session-ticket-app-data13-ssl]
server = 3-session-ticket-app-data13-server
client = 3-session-ticket-app-data13-client
resume-server = 3-session-ticket-app-data13-server
resume-client = 3-session-ticket-app-data13-client

[3-session-ticket-app-data13-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = SessionTicket
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-session-ticket-app-data13-client]
CipherString = DEFAULT
MaxProtocol = TLSv1.3
Options = SessionTicket
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
ExpectedResult = Success
ExpectedSessionTicketAppData = 
HandshakeMode = Resume
ResumptionExpected = Yes
SessionTicketExpected = Yes


                           node-23.7.0/deps/openssl/openssl/test/ssl-tests/27-ticket-appdata.cnf.in                            0000664 0000000 0000000 00000004565 14746647661 0026026 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2018-2021 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test session ticket app data

use strict;
use warnings;

package ssltests;
use OpenSSL::Test::Utils;

our @tests12 = (
    {
	"name" => "session-ticket-app-data12",
	"client" => {
	    "MaxProtocol" => "TLSv1.2",
	    "Options" => "SessionTicket",
	},
	"server" => {
	    "Options" => "SessionTicket",
	    "extra" => {
		"SessionTicketAppData" => "HelloWorld",
	    },
	},
	"test" => {
	    "HandshakeMode" => "Resume",
	    "ExpectedResult" => "Success",
	    "SessionTicketExpected" => "Yes",
	    "ResumptionExpected" => "Yes",
	    "ExpectedSessionTicketAppData" => "HelloWorld",
	}
    },
    {
	"name" => "session-ticket-app-data12",
	"client" => {
	    "MaxProtocol" => "TLSv1.2",
	    "Options" => "SessionTicket",
	},
	"server" => {
	    "Options" => "SessionTicket",
	},
	"test" => {
	    "HandshakeMode" => "Resume",
	    "ExpectedResult" => "Success",
	    "SessionTicketExpected" => "Yes",
	    "ResumptionExpected" => "Yes",
	    "ExpectedSessionTicketAppData" => "",
	}
    }
);
our @tests13 = (
    {
	"name" => "session-ticket-app-data13",
	"client" => {
	    "MaxProtocol" => "TLSv1.3",
	    "Options" => "SessionTicket",
	},
	"server" => {
	    "Options" => "SessionTicket",
	    "extra" => {
		"SessionTicketAppData" => "HelloWorld",
	    },
	},
	"test" => {
	    "HandshakeMode" => "Resume",
	    "ExpectedResult" => "Success",
	    "SessionTicketExpected" => "Yes",
	    "ResumptionExpected" => "Yes",
	    "ExpectedSessionTicketAppData" => "HelloWorld",
	}
    },
    {
	"name" => "session-ticket-app-data13",
	"client" => {
	    "MaxProtocol" => "TLSv1.3",
	    "Options" => "SessionTicket",
	},
	"server" => {
	    "Options" => "SessionTicket",
	},
	"test" => {
	    "HandshakeMode" => "Resume",
	    "ExpectedResult" => "Success",
	    "SessionTicketExpected" => "Yes",
	    "ResumptionExpected" => "Yes",
	    "ExpectedSessionTicketAppData" => "",
	}
    }
);

our @tests = ();
push @tests, @tests12 unless disabled("tls1_2");
push @tests, @tests13 unless disabled("tls1_3")
                             || (disabled("ec") && disabled("dh"));
                                                                                                                                           node-23.7.0/deps/openssl/openssl/test/ssl-tests/28-seclevel.cnf                                     0000664 0000000 0000000 00000010441 14746647661 0024317 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 6

test-0 = 0-SECLEVEL 3 with default key
test-1 = 1-SECLEVEL 4 with ED448 key
test-2 = 2-SECLEVEL 5 server with ED448 key
test-3 = 3-SECLEVEL 5 client with ED448 key
test-4 = 4-SECLEVEL 3 with P-384 key, X25519 ECDHE
test-5 = 5-SECLEVEL 3 with ED448 key, TLSv1.2
# ===========================================================

[0-SECLEVEL 3 with default key]
ssl_conf = 0-SECLEVEL 3 with default key-ssl

[0-SECLEVEL 3 with default key-ssl]
server = 0-SECLEVEL 3 with default key-server
client = 0-SECLEVEL 3 with default key-client

[0-SECLEVEL 3 with default key-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT:@SECLEVEL=3
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-SECLEVEL 3 with default key-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = ServerFail


# ===========================================================

[1-SECLEVEL 4 with ED448 key]
ssl_conf = 1-SECLEVEL 4 with ED448 key-ssl

[1-SECLEVEL 4 with ED448 key-ssl]
server = 1-SECLEVEL 4 with ED448 key-server
client = 1-SECLEVEL 4 with ED448 key-client

[1-SECLEVEL 4 with ED448 key-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
CipherString = DEFAULT:@SECLEVEL=4
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem

[1-SECLEVEL 4 with ED448 key-client]
CipherString = DEFAULT:@SECLEVEL=4
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-ed448-cert.pem
VerifyMode = Peer

[test-1]
ExpectedResult = Success


# ===========================================================

[2-SECLEVEL 5 server with ED448 key]
ssl_conf = 2-SECLEVEL 5 server with ED448 key-ssl

[2-SECLEVEL 5 server with ED448 key-ssl]
server = 2-SECLEVEL 5 server with ED448 key-server
client = 2-SECLEVEL 5 server with ED448 key-client

[2-SECLEVEL 5 server with ED448 key-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
CipherString = DEFAULT:@SECLEVEL=5
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem

[2-SECLEVEL 5 server with ED448 key-client]
CipherString = DEFAULT:@SECLEVEL=4
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-ed448-cert.pem
VerifyMode = Peer

[test-2]
ExpectedResult = ServerFail


# ===========================================================

[3-SECLEVEL 5 client with ED448 key]
ssl_conf = 3-SECLEVEL 5 client with ED448 key-ssl

[3-SECLEVEL 5 client with ED448 key-ssl]
server = 3-SECLEVEL 5 client with ED448 key-server
client = 3-SECLEVEL 5 client with ED448 key-client

[3-SECLEVEL 5 client with ED448 key-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
CipherString = DEFAULT:@SECLEVEL=4
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem

[3-SECLEVEL 5 client with ED448 key-client]
CipherString = DEFAULT:@SECLEVEL=5
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-ed448-cert.pem
VerifyMode = Peer

[test-3]
ExpectedResult = ServerFail


# ===========================================================

[4-SECLEVEL 3 with P-384 key, X25519 ECDHE]
ssl_conf = 4-SECLEVEL 3 with P-384 key, X25519 ECDHE-ssl

[4-SECLEVEL 3 with P-384 key, X25519 ECDHE-ssl]
server = 4-SECLEVEL 3 with P-384 key, X25519 ECDHE-server
client = 4-SECLEVEL 3 with P-384 key, X25519 ECDHE-client

[4-SECLEVEL 3 with P-384 key, X25519 ECDHE-server]
Certificate = ${ENV::TEST_CERTS_DIR}/p384-server-cert.pem
CipherString = DEFAULT:@SECLEVEL=3
Groups = X25519
PrivateKey = ${ENV::TEST_CERTS_DIR}/p384-server-key.pem

[4-SECLEVEL 3 with P-384 key, X25519 ECDHE-client]
CipherString = ECDHE:@SECLEVEL=3
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/p384-root.pem
VerifyMode = Peer

[test-4]
ExpectedResult = Success


# ===========================================================

[5-SECLEVEL 3 with ED448 key, TLSv1.2]
ssl_conf = 5-SECLEVEL 3 with ED448 key, TLSv1.2-ssl

[5-SECLEVEL 3 with ED448 key, TLSv1.2-ssl]
server = 5-SECLEVEL 3 with ED448 key, TLSv1.2-server
client = 5-SECLEVEL 3 with ED448 key, TLSv1.2-client

[5-SECLEVEL 3 with ED448 key, TLSv1.2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/server-ed448-cert.pem
CipherString = DEFAULT:@SECLEVEL=3
MaxProtocol = TLSv1.2
PrivateKey = ${ENV::TEST_CERTS_DIR}/server-ed448-key.pem

[5-SECLEVEL 3 with ED448 key, TLSv1.2-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/root-ed448-cert.pem
VerifyMode = Peer

[test-5]
ExpectedResult = Success


                                                                                                                                                                                                                               node-23.7.0/deps/openssl/openssl/test/ssl-tests/28-seclevel.cnf.in                                  0000664 0000000 0000000 00000007133 14746647661 0024730 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2024 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## SSL test configurations

package ssltests;
use OpenSSL::Test::Utils;

our $fips_mode;

our @tests = (
    {
        name => "SECLEVEL 3 with default key",
        server => { "CipherString" => "DEFAULT:\@SECLEVEL=3" },
        client => { },
        test   => { "ExpectedResult" => "ServerFail" },
    },
);

our @tests_ec = (
    {
        name => "SECLEVEL 4 with ED448 key",
        server => { "CipherString" => "DEFAULT:\@SECLEVEL=4",
                    "Certificate" => test_pem("server-ed448-cert.pem"),
                    "PrivateKey" => test_pem("server-ed448-key.pem") },
        client => { "CipherString" => "DEFAULT:\@SECLEVEL=4",
                    "VerifyCAFile" => test_pem("root-ed448-cert.pem") },
        test   => { "ExpectedResult" => "Success" },
    },
    {
        # The Ed448 signature algorithm will not be enabled.
        # Because of the config order, the certificate is first loaded, and
        # then the security level is chaged. If you try this with s_server
        # the order will be reversed and it will instead fail to load the key.
        name => "SECLEVEL 5 server with ED448 key",
        server => { "CipherString" => "DEFAULT:\@SECLEVEL=5",
                    "Certificate" => test_pem("server-ed448-cert.pem"),
                    "PrivateKey" => test_pem("server-ed448-key.pem") },
        client => { "CipherString" => "DEFAULT:\@SECLEVEL=4",
                    "VerifyCAFile" => test_pem("root-ed448-cert.pem") },
        test   => { "ExpectedResult" => "ServerFail" },
    },
    {
        # The client will not sent the Ed448 signature algorithm, so the server
        # doesn't have a useable signature algorithm for the certificate.
        name => "SECLEVEL 5 client with ED448 key",
        server => { "CipherString" => "DEFAULT:\@SECLEVEL=4",
                    "Certificate" => test_pem("server-ed448-cert.pem"),
                    "PrivateKey" => test_pem("server-ed448-key.pem") },
        client => { "CipherString" => "DEFAULT:\@SECLEVEL=5",
                    "VerifyCAFile" => test_pem("root-ed448-cert.pem") },
        test   => { "ExpectedResult" => "ServerFail" },
    }
);

our @tests_ec_non_fips = (
    {
        name => "SECLEVEL 3 with P-384 key, X25519 ECDHE",
        server => { "CipherString" => "DEFAULT:\@SECLEVEL=3",
                    "Certificate" => test_pem("p384-server-cert.pem"),
                    "PrivateKey" => test_pem("p384-server-key.pem"),
                    "Groups" => "X25519" },
        client => { "CipherString" => "ECDHE:\@SECLEVEL=3",
                    "VerifyCAFile" => test_pem("p384-root.pem") },
        test   => { "ExpectedResult" => "Success" },
    },
);

our @tests_tls1_2 = (
    {
        name => "SECLEVEL 3 with ED448 key, TLSv1.2",
        server => { "CipherString" => "DEFAULT:\@SECLEVEL=3",
                    "Certificate" => test_pem("server-ed448-cert.pem"),
                    "PrivateKey" => test_pem("server-ed448-key.pem"),
                    "MaxProtocol" => "TLSv1.2" },
        client => { "VerifyCAFile" => test_pem("root-ed448-cert.pem") },
        test   => { "ExpectedResult" => "Success" },
    },
);

push @tests_ec, @tests_ec_non_fips unless $fips_mode;
push @tests, @tests_ec unless disabled("ec");
push @tests, @tests_tls1_2 unless disabled("tls1_2") || disabled("ec");
                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/openssl/openssl/test/ssl-tests/29-dtls-sctp-label-bug.cnf                          0000664 0000000 0000000 00000005171 14746647661 0026267 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 4

test-0 = 0-SCTPLabelBug-good1
test-1 = 1-SCTPLabelBug-good2
test-2 = 2-SCTPLabelBug-bad1
test-3 = 3-SCTPLabelBug-bad2
# ===========================================================

[0-SCTPLabelBug-good1]
ssl_conf = 0-SCTPLabelBug-good1-ssl

[0-SCTPLabelBug-good1-ssl]
server = 0-SCTPLabelBug-good1-server
client = 0-SCTPLabelBug-good1-client

[0-SCTPLabelBug-good1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-SCTPLabelBug-good1-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
EnableClientSCTPLabelBug = No
EnableServerSCTPLabelBug = No
ExpectedResult = Success
Method = DTLS
UseSCTP = Yes


# ===========================================================

[1-SCTPLabelBug-good2]
ssl_conf = 1-SCTPLabelBug-good2-ssl

[1-SCTPLabelBug-good2-ssl]
server = 1-SCTPLabelBug-good2-server
client = 1-SCTPLabelBug-good2-client

[1-SCTPLabelBug-good2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-SCTPLabelBug-good2-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
EnableClientSCTPLabelBug = Yes
EnableServerSCTPLabelBug = Yes
ExpectedResult = Success
Method = DTLS
UseSCTP = Yes


# ===========================================================

[2-SCTPLabelBug-bad1]
ssl_conf = 2-SCTPLabelBug-bad1-ssl

[2-SCTPLabelBug-bad1-ssl]
server = 2-SCTPLabelBug-bad1-server
client = 2-SCTPLabelBug-bad1-client

[2-SCTPLabelBug-bad1-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-SCTPLabelBug-bad1-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
EnableClientSCTPLabelBug = Yes
EnableServerSCTPLabelBug = No
ExpectedResult = ClientFail
Method = DTLS
UseSCTP = Yes


# ===========================================================

[3-SCTPLabelBug-bad2]
ssl_conf = 3-SCTPLabelBug-bad2-ssl

[3-SCTPLabelBug-bad2-ssl]
server = 3-SCTPLabelBug-bad2-server
client = 3-SCTPLabelBug-bad2-client

[3-SCTPLabelBug-bad2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-SCTPLabelBug-bad2-client]
CipherString = DEFAULT
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
EnableClientSCTPLabelBug = No
EnableServerSCTPLabelBug = Yes
ExpectedResult = ClientFail
Method = DTLS
UseSCTP = Yes


                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/openssl/openssl/test/ssl-tests/29-dtls-sctp-label-bug.cnf.in                       0000664 0000000 0000000 00000003407 14746647661 0026674 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2019-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test SSL_MODE_DTLS_SCTP_LABEL_LENGTH_BUG handling

use strict;
use warnings;

package ssltests;
use OpenSSL::Test::Utils;

our @tests = (
    {
        name => "SCTPLabelBug-good1",
        server => {},
        client => {},
        test => {
            "Method" => "DTLS",
            "UseSCTP" => "Yes",
            "EnableClientSCTPLabelBug" => "No",
            "EnableServerSCTPLabelBug" => "No",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "SCTPLabelBug-good2",
        server => {},
        client => {},
        test => {
            "Method" => "DTLS",
            "UseSCTP" => "Yes",
            "EnableClientSCTPLabelBug" => "Yes",
            "EnableServerSCTPLabelBug" => "Yes",
            "ExpectedResult" => "Success"
        }
    },
    {
        name => "SCTPLabelBug-bad1",
        server => {},
        client => {},
        test => {
            "Method" => "DTLS",
            "UseSCTP" => "Yes",
            "EnableClientSCTPLabelBug" => "Yes",
            "EnableServerSCTPLabelBug" => "No",
            "ExpectedResult" => "ClientFail"
        }
    },
    {
        name => "SCTPLabelBug-bad2",
        server => {},
        client => {},
        test => {
            "Method" => "DTLS",
            "UseSCTP" => "Yes",
            "EnableClientSCTPLabelBug" => "No",
            "EnableServerSCTPLabelBug" => "Yes",
            "ExpectedResult" => "ClientFail"
        }
    },
);
                                                                                                                                                                                                                                                         node-23.7.0/deps/openssl/openssl/test/ssl-tests/30-extended-master-secret.cnf                       0000664 0000000 0000000 00000014350 14746647661 0027065 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Generated with generate_ssl_tests.pl

num_tests = 7

test-0 = 0-disable-extended-master-secret-server-sha
test-1 = 1-disable-extended-master-secret-client-sha
test-2 = 2-disable-extended-master-secret-both-sha
test-3 = 3-disable-extended-master-secret-both-resume
test-4 = 4-disable-extended-master-secret-server-sha2
test-5 = 5-disable-extended-master-secret-client-sha2
test-6 = 6-disable-extended-master-secret-both-sha2
# ===========================================================

[0-disable-extended-master-secret-server-sha]
ssl_conf = 0-disable-extended-master-secret-server-sha-ssl

[0-disable-extended-master-secret-server-sha-ssl]
server = 0-disable-extended-master-secret-server-sha-server
client = 0-disable-extended-master-secret-server-sha-client

[0-disable-extended-master-secret-server-sha-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = -ExtendedMasterSecret
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[0-disable-extended-master-secret-server-sha-client]
CipherString = AES128-SHA
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-0]
ExpectedResult = Success


# ===========================================================

[1-disable-extended-master-secret-client-sha]
ssl_conf = 1-disable-extended-master-secret-client-sha-ssl

[1-disable-extended-master-secret-client-sha-ssl]
server = 1-disable-extended-master-secret-client-sha-server
client = 1-disable-extended-master-secret-client-sha-client

[1-disable-extended-master-secret-client-sha-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[1-disable-extended-master-secret-client-sha-client]
CipherString = AES128-SHA
MaxProtocol = TLSv1.2
Options = -ExtendedMasterSecret
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-1]
ExpectedResult = Success


# ===========================================================

[2-disable-extended-master-secret-both-sha]
ssl_conf = 2-disable-extended-master-secret-both-sha-ssl

[2-disable-extended-master-secret-both-sha-ssl]
server = 2-disable-extended-master-secret-both-sha-server
client = 2-disable-extended-master-secret-both-sha-client

[2-disable-extended-master-secret-both-sha-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = -ExtendedMasterSecret
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[2-disable-extended-master-secret-both-sha-client]
CipherString = AES128-SHA
MaxProtocol = TLSv1.2
Options = -ExtendedMasterSecret
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-2]
ExpectedResult = Success


# ===========================================================

[3-disable-extended-master-secret-both-resume]
ssl_conf = 3-disable-extended-master-secret-both-resume-ssl

[3-disable-extended-master-secret-both-resume-ssl]
server = 3-disable-extended-master-secret-both-resume-server
client = 3-disable-extended-master-secret-both-resume-client
resume-server = 3-disable-extended-master-secret-both-resume-resume-server
resume-client = 3-disable-extended-master-secret-both-resume-resume-client

[3-disable-extended-master-secret-both-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = -ExtendedMasterSecret
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-disable-extended-master-secret-both-resume-resume-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[3-disable-extended-master-secret-both-resume-client]
CipherString = AES128-SHA
MaxProtocol = TLSv1.2
Options = -ExtendedMasterSecret
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[3-disable-extended-master-secret-both-resume-resume-client]
CipherString = AES128-SHA
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-3]
ExpectedResult = Success
HandshakeMode = Resume


# ===========================================================

[4-disable-extended-master-secret-server-sha2]
ssl_conf = 4-disable-extended-master-secret-server-sha2-ssl

[4-disable-extended-master-secret-server-sha2-ssl]
server = 4-disable-extended-master-secret-server-sha2-server
client = 4-disable-extended-master-secret-server-sha2-client

[4-disable-extended-master-secret-server-sha2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = -ExtendedMasterSecret
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[4-disable-extended-master-secret-server-sha2-client]
CipherString = AES128-SHA256
MaxProtocol = TLSv1.2
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-4]
ExpectedResult = Success


# ===========================================================

[5-disable-extended-master-secret-client-sha2]
ssl_conf = 5-disable-extended-master-secret-client-sha2-ssl

[5-disable-extended-master-secret-client-sha2-ssl]
server = 5-disable-extended-master-secret-client-sha2-server
client = 5-disable-extended-master-secret-client-sha2-client

[5-disable-extended-master-secret-client-sha2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[5-disable-extended-master-secret-client-sha2-client]
CipherString = AES128-SHA256
MaxProtocol = TLSv1.2
Options = -ExtendedMasterSecret
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-5]
ExpectedResult = Success


# ===========================================================

[6-disable-extended-master-secret-both-sha2]
ssl_conf = 6-disable-extended-master-secret-both-sha2-ssl

[6-disable-extended-master-secret-both-sha2-ssl]
server = 6-disable-extended-master-secret-both-sha2-server
client = 6-disable-extended-master-secret-both-sha2-client

[6-disable-extended-master-secret-both-sha2-server]
Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
CipherString = DEFAULT
Options = -ExtendedMasterSecret
PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem

[6-disable-extended-master-secret-both-sha2-client]
CipherString = AES128-SHA256
MaxProtocol = TLSv1.2
Options = -ExtendedMasterSecret
VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
VerifyMode = Peer

[test-6]
ExpectedResult = Success


                                                                                                                                                                                                                                                                                        node-23.7.0/deps/openssl/openssl/test/ssl-tests/30-extended-master-secret.cnf.in                    0000664 0000000 0000000 00000006203 14746647661 0027470 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## SSL test configurations

package ssltests;

use OpenSSL::Test::Utils;

our @tests = ();

my @tests_tls1_2 = (
    {
        name => "disable-extended-master-secret-server-sha",
        server => {
          "Options" => "-ExtendedMasterSecret",
        },
        client => {
          "CipherString" => "AES128-SHA",
          "MaxProtocol" => "TLSv1.2"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
    {
        name => "disable-extended-master-secret-client-sha",
        server => {
        },
        client => {
          "CipherString" => "AES128-SHA",
          "Options" => "-ExtendedMasterSecret",
          "MaxProtocol" => "TLSv1.2"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
    {
        name => "disable-extended-master-secret-both-sha",
        server => {
          "Options" => "-ExtendedMasterSecret",
        },
        client => {
          "CipherString" => "AES128-SHA",
          "Options" => "-ExtendedMasterSecret",
          "MaxProtocol" => "TLSv1.2"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
    {
        name => "disable-extended-master-secret-both-resume",
        server => {
          "Options" => "-ExtendedMasterSecret",
        },
        resume_server => {
        },
        client => {
          "CipherString" => "AES128-SHA",
          "Options" => "-ExtendedMasterSecret",
          "MaxProtocol" => "TLSv1.2"
        },
        resume_client => {
          "CipherString" => "AES128-SHA",
          "MaxProtocol" => "TLSv1.2"
        },
        test   => {
	  "HandshakeMode" => "Resume",
          "ExpectedResult" => "Success",
        },
    },
    {
        name => "disable-extended-master-secret-server-sha2",
        server => {
          "Options" => "-ExtendedMasterSecret",
        },
        client => {
          "CipherString" => "AES128-SHA256",
          "MaxProtocol" => "TLSv1.2"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
    {
        name => "disable-extended-master-secret-client-sha2",
        server => {
        },
        client => {
          "CipherString" => "AES128-SHA256",
          "Options" => "-ExtendedMasterSecret",
          "MaxProtocol" => "TLSv1.2"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
    {
        name => "disable-extended-master-secret-both-sha2",
        server => {
          "Options" => "-ExtendedMasterSecret",
        },
        client => {
          "CipherString" => "AES128-SHA256",
          "Options" => "-ExtendedMasterSecret",
          "MaxProtocol" => "TLSv1.2"
        },
        test   => {
          "ExpectedResult" => "Success",
        },
    },
);

push @tests, @tests_tls1_2 unless disabled("tls1_2");
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/openssl/openssl/test/ssl-tests/protocol_version.pm                                 0000664 0000000 0000000 00000034405 14746647661 0025550 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2021 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html


## Test version negotiation

package ssltests;

use strict;
use warnings;

use List::Util qw/max min/;

use OpenSSL::Test;
use OpenSSL::Test::Utils qw/anydisabled alldisabled disabled/;
setup("no_test_here");

my @tls_protocols = ("SSLv3", "TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3");
my @tls_protocols_fips = ("TLSv1.2", "TLSv1.3");
# undef stands for "no limit".
my @min_tls_protocols = (undef, "SSLv3", "TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3");
my @min_tls_protocols_fips = (undef, "TLSv1.2", "TLSv1.3");
my @max_tls_protocols = ("SSLv3", "TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3", undef);
my @max_tls_protocols_fips = ("TLSv1.2", "TLSv1.3", undef);

my @is_tls_disabled = anydisabled("ssl3", "tls1", "tls1_1", "tls1_2", "tls1_3");
my @is_tls_disabled_fips = anydisabled("tls1_2", "tls1_3");

my $min_tls_enabled; my $max_tls_enabled;
my $min_tls_enabled_fips; my $max_tls_enabled_fips;

# Protocol configuration works in cascades, i.e.,
# $no_tls1_1 disables TLSv1.1 and below.
#
# $min_enabled and $max_enabled will be correct if there is at least one
# protocol enabled.

sub min_prot_enabled {
    my $protref = shift;
    my $disabledref = shift;
    my @protocols = @{$protref};
    my @is_disabled = @{$disabledref};
    my $min_enabled;

    foreach my $i (0..$#protocols) {
        if (!$is_disabled[$i]) {
            $min_enabled = $i;
            last;
        }
    }
    return $min_enabled;
}

sub max_prot_enabled {
    my $protref = shift;
    my $disabledref = shift;
    my @protocols = @{$protref};
    my @is_disabled = @{$disabledref};
    my $max_enabled;

    foreach my $i (0..$#protocols) {
        if (!$is_disabled[$i]
                && ($protocols[$i] ne "TLSv1.3"
                    || !disabled("ec")
                    || !disabled("dh"))) {
            $max_enabled = $i;
        }
    }
    return $max_enabled;
}

$min_tls_enabled = min_prot_enabled(\@tls_protocols, \@is_tls_disabled);
$max_tls_enabled = max_prot_enabled(\@tls_protocols, \@is_tls_disabled);
$min_tls_enabled_fips = min_prot_enabled(\@tls_protocols_fips, \@is_tls_disabled_fips);
$max_tls_enabled_fips = max_prot_enabled(\@tls_protocols_fips, \@is_tls_disabled_fips);


my @dtls_protocols = ("DTLSv1", "DTLSv1.2");
my @dtls_protocols_fips = ("DTLSv1.2");
# undef stands for "no limit".
my @min_dtls_protocols = (undef, "DTLSv1", "DTLSv1.2");
my @min_dtls_protocols_fips = (undef, "DTLSv1.2");
my @max_dtls_protocols = ("DTLSv1", "DTLSv1.2", undef);
my @max_dtls_protocols_fips = ("DTLSv1.2", undef);

my @is_dtls_disabled = anydisabled("dtls1", "dtls1_2");
my @is_dtls_disabled_fips = anydisabled("dtls1_2");

my $min_dtls_enabled; my $max_dtls_enabled;
my $min_dtls_enabled_fips; my $max_dtls_enabled_fips;

# $min_enabled and $max_enabled will be correct if there is at least one
# protocol enabled.
$min_dtls_enabled = min_prot_enabled(\@dtls_protocols, \@is_dtls_disabled);
$max_dtls_enabled = max_prot_enabled(\@dtls_protocols, \@is_dtls_disabled);
$min_dtls_enabled_fips = min_prot_enabled(\@dtls_protocols_fips, \@is_dtls_disabled_fips);
$max_dtls_enabled_fips = max_prot_enabled(\@dtls_protocols_fips, \@is_dtls_disabled_fips);

sub no_tests {
    my ($dtls, $fips) = @_;
    if ($dtls && $fips) {
        return disabled("dtls1_2");
    }
    return $dtls ? alldisabled("dtls1", "dtls1_2") :
      alldisabled("ssl3", "tls1", "tls1_1", "tls1_2", "tls1_3");
}

sub generate_version_tests {
    my $method = shift;
    my $fips = shift;

    my $dtls = $method eq "DTLS";
    # Don't write the redundant "Method = TLS" into the configuration.
    undef $method if !$dtls;

    my @protocols;
    my @min_protocols;
    my @max_protocols;
    my $min_enabled;
    my $max_enabled;
    if ($fips) {
        @protocols = $dtls ? @dtls_protocols_fips : @tls_protocols_fips;
        @min_protocols = $dtls ? @min_dtls_protocols_fips : @min_tls_protocols_fips;
        @max_protocols = $dtls ? @max_dtls_protocols_fips : @max_tls_protocols_fips;
        $min_enabled  = $dtls ? $min_dtls_enabled_fips : $min_tls_enabled_fips;
        $max_enabled  = $dtls ? $max_dtls_enabled_fips : $max_tls_enabled_fips;
    } else {
        @protocols = $dtls ? @dtls_protocols : @tls_protocols;
        @min_protocols = $dtls ? @min_dtls_protocols : @min_tls_protocols;
        @max_protocols = $dtls ? @max_dtls_protocols : @max_tls_protocols;
        $min_enabled  = $dtls ? $min_dtls_enabled : $min_tls_enabled;
        $max_enabled  = $dtls ? $max_dtls_enabled : $max_tls_enabled;
    }

    if (no_tests($dtls, $fips)) {
        return;
    }

    my @tests = ();

    for (my $sctp = 0; $sctp < ($dtls && !disabled("sctp") ? 2 : 1); $sctp++) {
        foreach my $c_min (0..$#min_protocols) {
            my $c_max_min = $c_min == 0 ? 0 : $c_min - 1;
            foreach my $c_max ($c_max_min..$#max_protocols) {
                foreach my $s_min (0..$#min_protocols) {
                    my $s_max_min = $s_min == 0 ? 0 : $s_min - 1;
                    foreach my $s_max ($s_max_min..$#max_protocols) {
                        my ($result, $protocol) =
                            expected_result($c_min, $c_max, $s_min, $s_max,
                                            $min_enabled, $max_enabled,
                                            \@protocols);
                        push @tests, {
                            "name" => "version-negotiation",
                            "client" => {
                                "CipherString" => "DEFAULT:\@SECLEVEL=0",
                                "MinProtocol" => $min_protocols[$c_min],
                                "MaxProtocol" => $max_protocols[$c_max],
                            },
                            "server" => {
                                "CipherString" => "DEFAULT:\@SECLEVEL=0",
                                "MinProtocol" => $min_protocols[$s_min],
                                "MaxProtocol" => $max_protocols[$s_max],
                            },
                            "test" => {
                                "ExpectedResult" => $result,
                                "ExpectedProtocol" => $protocol,
                                "Method" => $method,
                            }
                        };
                        $tests[-1]{"test"}{"UseSCTP"} = "Yes" if $sctp;
                    }
                }
            }
        }
    }
    return @tests
        if disabled("tls1_3")
           || disabled("tls1_2")
           || (disabled("ec") && disabled("dh"))
           || $dtls;

    #Add some version/ciphersuite sanity check tests
    push @tests, {
        "name" => "ciphersuite-sanity-check-client",
        "client" => {
            #Offering only <=TLSv1.2 ciphersuites with TLSv1.3 should fail
            "CipherString" => "AES128-SHA",
            "Ciphersuites" => "",
        },
        "server" => {
            "MaxProtocol" => "TLSv1.2"
        },
        "test" => {
            "ExpectedResult" => "ClientFail",
        }
    };
    push @tests, {
        "name" => "ciphersuite-sanity-check-server",
        "client" => {
            "CipherString" => "AES128-SHA",
            "MaxProtocol" => "TLSv1.2"
        },
        "server" => {
            #Allowing only <=TLSv1.2 ciphersuites with TLSv1.3 should fail
            "CipherString" => "AES128-SHA",
            "Ciphersuites" => "",
        },
        "test" => {
            "ExpectedResult" => "ServerFail",
        }
    };

    return @tests;
}

sub generate_resumption_tests {
    my $method = shift;
    my $fips = shift;

    my $dtls = $method eq "DTLS";
    # Don't write the redundant "Method = TLS" into the configuration.
    undef $method if !$dtls;

    my @protocols;
    my $min_enabled;
    my $max_enabled;

    if ($fips) {
        @protocols = $dtls ? @dtls_protocols_fips : @tls_protocols_fips;
        $min_enabled  = $dtls ? $min_dtls_enabled_fips : $min_tls_enabled_fips;
        $max_enabled = $dtls ? $max_dtls_enabled_fips : $max_tls_enabled_fips;
    } else {
        @protocols = $dtls ? @dtls_protocols : @tls_protocols;
        $min_enabled  = $dtls ? $min_dtls_enabled : $min_tls_enabled;
        $max_enabled = $dtls ? $max_dtls_enabled : $max_tls_enabled;
    }

    if (no_tests($dtls)) {
        return;
    }

    my @server_tests = ();
    my @client_tests = ();

    # Obtain the first session against a fixed-version server/client.
    foreach my $original_protocol($min_enabled..$max_enabled) {
        # Upgrade or downgrade the server/client max version support and test
        # that it upgrades, downgrades or resumes the session as well.
        foreach my $resume_protocol($min_enabled..$max_enabled) {
            my $resumption_expected;
            # We should only resume on exact version match.
            if ($original_protocol eq $resume_protocol) {
                $resumption_expected = "Yes";
            } else {
                $resumption_expected = "No";
            }

            for (my $sctp = 0; $sctp < ($dtls && !disabled("sctp") ? 2 : 1);
                 $sctp++) {
                foreach my $ticket ("SessionTicket", "-SessionTicket") {
                    # Client is flexible, server upgrades/downgrades.
                    push @server_tests, {
                        "name" => "resumption",
                        "client" => {
                            "CipherString" => "DEFAULT:\@SECLEVEL=0",
                        },
                        "server" => {
                            "CipherString" => "DEFAULT:\@SECLEVEL=0",
                            "MinProtocol" => $protocols[$original_protocol],
                            "MaxProtocol" => $protocols[$original_protocol],
                            "Options" => $ticket,
                        },
                        "resume_server" => {
                            "CipherString" => "DEFAULT:\@SECLEVEL=0",
                            "MaxProtocol" => $protocols[$resume_protocol],
                            "Options" => $ticket,
                        },
                        "test" => {
                            "ExpectedProtocol" => $protocols[$resume_protocol],
                            "Method" => $method,
                            "HandshakeMode" => "Resume",
                            "ResumptionExpected" => $resumption_expected,
                        }
                    };
                    $server_tests[-1]{"test"}{"UseSCTP"} = "Yes" if $sctp;
                    # Server is flexible, client upgrades/downgrades.
                    push @client_tests, {
                        "name" => "resumption",
                        "client" => {
                            "CipherString" => "DEFAULT:\@SECLEVEL=0",
                            "MinProtocol" => $protocols[$original_protocol],
                            "MaxProtocol" => $protocols[$original_protocol],
                        },
                        "server" => {
                            "CipherString" => "DEFAULT:\@SECLEVEL=0",
                            "Options" => $ticket,
                        },
                        "resume_client" => {
                            "CipherString" => "DEFAULT:\@SECLEVEL=0",
                            "MaxProtocol" => $protocols[$resume_protocol],
                        },
                        "test" => {
                            "ExpectedProtocol" => $protocols[$resume_protocol],
                            "Method" => $method,
                            "HandshakeMode" => "Resume",
                            "ResumptionExpected" => $resumption_expected,
                        }
                    };
                    $client_tests[-1]{"test"}{"UseSCTP"} = "Yes" if $sctp;
                }
            }
        }
    }

    if (!disabled("tls1_3") && (!disabled("ec") || !disabled("dh")) && !$dtls) {
        push @client_tests, {
            "name" => "resumption-with-hrr",
            "client" => {
            },
            "server" => {
                "Curves" => disabled("ec") ? "ffdhe3072" : "P-256"
            },
            "resume_client" => {
            },
            "test" => {
                "ExpectedProtocol" => "TLSv1.3",
                "Method" => "TLS",
                "HandshakeMode" => "Resume",
                "ResumptionExpected" => "Yes",
            }
        };
    }

    return (@server_tests, @client_tests);
}

sub expected_result {
    my ($c_min, $c_max, $s_min, $s_max, $min_enabled, $max_enabled,
        $protocols) = @_;
    my @prots = @$protocols;

    my $orig_c_max = $c_max;
    # Adjust for "undef" (no limit).
    $c_min = $c_min == 0 ? 0 : $c_min - 1;
    $c_max = $c_max == scalar @$protocols ? $c_max - 1 : $c_max;
    $s_min = $s_min == 0 ? 0 : $s_min - 1;
    $s_max = $s_max == scalar @$protocols ? $s_max - 1 : $s_max;

    # We now have at least one protocol enabled, so $min_enabled and
    # $max_enabled are well-defined.
    $c_min = max $c_min, $min_enabled;
    $s_min = max $s_min, $min_enabled;
    $c_max = min $c_max, $max_enabled;
    $s_max = min $s_max, $max_enabled;

    if ($c_min > $c_max
            || ($orig_c_max != scalar @$protocols
                && $prots[$orig_c_max] eq "TLSv1.3"
                && $c_max != $orig_c_max
                && !disabled("tls1_3"))) {
        # Client should fail to even send a hello.
        return ("ClientFail", undef);
    } elsif ($s_min > $s_max) {
        # Server has no protocols, should always fail.
        return ("ServerFail", undef);
    } elsif ($s_min > $c_max) {
        # Server doesn't support the client range.
        return ("ServerFail", undef);
    } elsif ($c_min > $s_max) {
        if ($prots[$c_max] eq "TLSv1.3") {
            # Client will have sent supported_versions, so server will know
            # that there are no overlapping versions.
            return ("ServerFail", undef);
        } else {
            # Server will try with a version that is lower than the lowest
            # supported client version.
            return ("ClientFail", undef);
        }
    } else {
        # Server and client ranges overlap.
        my $max_common = $s_max < $c_max ? $s_max : $c_max;
        return ("Success", $protocols->[$max_common]);
    }
}

1;
                                                                                                                                                                                                                                                           node-23.7.0/deps/openssl/openssl/test/ssl-tests/ssltests_base.pm                                    0000664 0000000 0000000 00000001543 14746647661 0025015 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # -*- mode: perl; -*-
# Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the Apache License 2.0 (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html

## SSL test configurations

package ssltests;

sub test_pem
{
    my ($file) = @_;
    my $dir_sep = $^O ne "VMS" ? "/" : "";
    return "\${ENV::TEST_CERTS_DIR}" . $dir_sep . $file,
}

our $fips_mode = 0;
our $no_deflt_libctx = 0;

our %base_server = (
    "Certificate" => test_pem("servercert.pem"),
    "PrivateKey"  => test_pem("serverkey.pem"),
    "CipherString" => "DEFAULT",
);

our %base_client = (
    "VerifyCAFile" => test_pem("rootcert.pem"),
    "VerifyMode" => "Peer",
    "CipherString" => "DEFAULT",
);
                                                                                                                                                             node-23.7.0/deps/openssl/openssl/test/ssl_cert_table_internal_test.c                                0000664 0000000 0000000 00000004224 14746647661 0025723 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright 2017-2021 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

/* Internal tests for the x509 and x509v3 modules */

#include <stdio.h>
#include <string.h>

#include <openssl/ssl.h>
#include "testutil.h"
#include "internal/nelem.h"
#include "../ssl/ssl_local.h"
#include "../ssl/ssl_cert_table.h"

#define test_cert_table(nid, amask, idx) \
    do_test_cert_table(nid, amask, idx, #idx)

static int do_test_cert_table(int nid, uint32_t amask, size_t idx,
                              const char *idxname)
{
    const SSL_CERT_LOOKUP *clu = &ssl_cert_info[idx];

    if (clu->nid == nid && clu->amask == amask)
        return 1;

    TEST_error("Invalid table entry for certificate type %s, index %zu",
               idxname, idx);
    if (clu->nid != nid)
        TEST_note("Expected %s, got %s\n", OBJ_nid2sn(nid),
                  OBJ_nid2sn(clu->nid));
    if (clu->amask != amask)
        TEST_note("Expected auth mask 0x%x, got 0x%x\n", amask, clu->amask);
    return 0;
}

/* Sanity check of ssl_cert_table */

static int test_ssl_cert_table(void)
{
    return TEST_size_t_eq(OSSL_NELEM(ssl_cert_info), SSL_PKEY_NUM)
           && test_cert_table(EVP_PKEY_RSA, SSL_aRSA, SSL_PKEY_RSA)
           && test_cert_table(EVP_PKEY_DSA, SSL_aDSS, SSL_PKEY_DSA_SIGN)
           && test_cert_table(EVP_PKEY_EC, SSL_aECDSA, SSL_PKEY_ECC)
           && test_cert_table(NID_id_GostR3410_2001, SSL_aGOST01,
                              SSL_PKEY_GOST01)
           && test_cert_table(NID_id_GostR3410_2012_256, SSL_aGOST12,
                              SSL_PKEY_GOST12_256)
           && test_cert_table(NID_id_GostR3410_2012_512, SSL_aGOST12,
                              SSL_PKEY_GOST12_512)
           && test_cert_table(EVP_PKEY_ED25519, SSL_aECDSA, SSL_PKEY_ED25519)
           && test_cert_table(EVP_PKEY_ED448, SSL_aECDSA, SSL_PKEY_ED448);
}

int setup_tests(void)
{
    ADD_TEST(test_ssl_cert_table);
    return 1;
}
                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/openssl/openssl/test/ssl_ctx_test.c                                                0000664 0000000 0000000 00000004425 14746647661 0022524 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright 2018-2020 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

#include "testutil.h"
#include <openssl/ssl.h>

typedef struct {
    int min_version;
    int max_version;
    int min_ok;
    int max_ok;
    int expected_min;
    int expected_max;
} version_test;

static const version_test version_testdata[] = {
    /* min           max             ok    expected min    expected max */
    {0,              0,              1, 1, 0,              0},
    {TLS1_VERSION,   TLS1_2_VERSION, 1, 1, TLS1_VERSION,   TLS1_2_VERSION},
    {TLS1_2_VERSION, TLS1_2_VERSION, 1, 1, TLS1_2_VERSION, TLS1_2_VERSION},
    {TLS1_2_VERSION, TLS1_1_VERSION, 1, 1, TLS1_2_VERSION, TLS1_1_VERSION},
    {7,              42,             0, 0, 0,              0},
};

static int test_set_min_max_version(int idx_tst)
{
    SSL_CTX *ctx = NULL;
    SSL *ssl = NULL;
    int testresult = 0;
    version_test t = version_testdata[idx_tst];

    ctx = SSL_CTX_new(TLS_server_method());
    if (ctx == NULL)
        goto end;

    ssl = SSL_new(ctx);
    if (ssl == NULL)
        goto end;

    if (!TEST_int_eq(SSL_CTX_set_min_proto_version(ctx, t.min_version), t.min_ok))
        goto end;
    if (!TEST_int_eq(SSL_CTX_set_max_proto_version(ctx, t.max_version), t.max_ok))
        goto end;
    if (!TEST_int_eq(SSL_CTX_get_min_proto_version(ctx), t.expected_min))
        goto end;
    if (!TEST_int_eq(SSL_CTX_get_max_proto_version(ctx), t.expected_max))
        goto end;

    if (!TEST_int_eq(SSL_set_min_proto_version(ssl, t.min_version), t.min_ok))
        goto end;
    if (!TEST_int_eq(SSL_set_max_proto_version(ssl, t.max_version), t.max_ok))
        goto end;
    if (!TEST_int_eq(SSL_get_min_proto_version(ssl), t.expected_min))
        goto end;
    if (!TEST_int_eq(SSL_get_max_proto_version(ssl), t.expected_max))
        goto end;

    testresult = 1;

  end:
    SSL_free(ssl);
    SSL_CTX_free(ctx);
    return testresult;
}

int setup_tests(void)
{
    ADD_ALL_TESTS(test_set_min_max_version, sizeof(version_testdata) / sizeof(version_test));
    return 1;
}
                                                                                                                                                                                                                                           node-23.7.0/deps/openssl/openssl/test/ssl_old_test.c                                                0000664 0000000 0000000 00000305515 14746647661 0022510 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright 1995-2023 The OpenSSL Project Authors. All Rights Reserved.
 * Copyright (c) 2002, Oracle and/or its affiliates. All rights reserved
 * Copyright 2005 Nokia. All rights reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

#include "e_os.h"

/* Or gethostname won't be declared properly on Linux and GNU platforms. */
#ifndef _BSD_SOURCE
# define _BSD_SOURCE 1
#endif
#ifndef _DEFAULT_SOURCE
# define _DEFAULT_SOURCE 1
#endif

#include <assert.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "internal/nelem.h"

#ifdef OPENSSL_SYS_VMS
/*
 * Or isascii won't be declared properly on VMS (at least with DECompHP C).
 */
# define _XOPEN_SOURCE 500
#endif

#include <ctype.h>

#include <openssl/bio.h>
#include <openssl/crypto.h>
#include <openssl/evp.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/rand.h>
#include <openssl/rsa.h>
#ifndef OPENSSL_NO_DSA
# include <openssl/dsa.h>
#endif
#include <openssl/bn.h>
#ifndef OPENSSL_NO_CT
# include <openssl/ct.h>
#endif
#include <openssl/provider.h>
#include "testutil.h"

/*
 * Or gethostname won't be declared properly
 * on Compaq platforms (at least with DEC C).
 * Do not try to put it earlier, or IPv6 includes
 * get screwed...
 */
#define _XOPEN_SOURCE_EXTENDED  1

#ifdef OPENSSL_SYS_WINDOWS
# include <winsock.h>
#else
# include <unistd.h>
#endif

#include "helpers/predefined_dhparams.h"

static SSL_CTX *s_ctx = NULL;
static SSL_CTX *s_ctx2 = NULL;

/*
 * There is really no standard for this, so let's assign something
 * only for this test
 */
#define COMP_ZLIB       1

static int verify_callback(int ok, X509_STORE_CTX *ctx);
static int app_verify_callback(X509_STORE_CTX *ctx, void *arg);
#define APP_CALLBACK_STRING "Test Callback Argument"
struct app_verify_arg {
    char *string;
    int app_verify;
};

static char *psk_key = NULL;    /* by default PSK is not used */
#ifndef OPENSSL_NO_PSK
static unsigned int psk_client_callback(SSL *ssl, const char *hint,
                                        char *identity,
                                        unsigned int max_identity_len,
                                        unsigned char *psk,
                                        unsigned int max_psk_len);
static unsigned int psk_server_callback(SSL *ssl, const char *identity,
                                        unsigned char *psk,
                                        unsigned int max_psk_len);
#endif

static BIO *bio_stdout = NULL;

#ifndef OPENSSL_NO_NEXTPROTONEG
/* Note that this code assumes that this is only a one element list: */
static const char NEXT_PROTO_STRING[] = "\x09testproto";
static int npn_client = 0;
static int npn_server = 0;
static int npn_server_reject = 0;

static int cb_client_npn(SSL *s, unsigned char **out, unsigned char *outlen,
                         const unsigned char *in, unsigned int inlen,
                         void *arg)
{
    /*
     * This callback only returns the protocol string, rather than a length
     * prefixed set. We assume that NEXT_PROTO_STRING is a one element list
     * and remove the first byte to chop off the length prefix.
     */
    *out = (unsigned char *)NEXT_PROTO_STRING + 1;
    *outlen = sizeof(NEXT_PROTO_STRING) - 2;
    return SSL_TLSEXT_ERR_OK;
}

static int cb_server_npn(SSL *s, const unsigned char **data,
                         unsigned int *len, void *arg)
{
    *data = (const unsigned char *)NEXT_PROTO_STRING;
    *len = sizeof(NEXT_PROTO_STRING) - 1;
    return SSL_TLSEXT_ERR_OK;
}

static int cb_server_rejects_npn(SSL *s, const unsigned char **data,
                                 unsigned int *len, void *arg)
{
    return SSL_TLSEXT_ERR_NOACK;
}

static int verify_npn(SSL *client, SSL *server)
{
    const unsigned char *client_s;
    unsigned client_len;
    const unsigned char *server_s;
    unsigned server_len;

    SSL_get0_next_proto_negotiated(client, &client_s, &client_len);
    SSL_get0_next_proto_negotiated(server, &server_s, &server_len);

    if (client_len) {
        BIO_printf(bio_stdout, "Client NPN: ");
        BIO_write(bio_stdout, client_s, client_len);
        BIO_printf(bio_stdout, "\n");
    }

    if (server_len) {
        BIO_printf(bio_stdout, "Server NPN: ");
        BIO_write(bio_stdout, server_s, server_len);
        BIO_printf(bio_stdout, "\n");
    }

    /*
     * If an NPN string was returned, it must be the protocol that we
     * expected to negotiate.
     */
    if (client_len && (client_len != sizeof(NEXT_PROTO_STRING) - 2 ||
                       memcmp(client_s, NEXT_PROTO_STRING + 1, client_len)))
        return -1;
    if (server_len && (server_len != sizeof(NEXT_PROTO_STRING) - 2 ||
                       memcmp(server_s, NEXT_PROTO_STRING + 1, server_len)))
        return -1;

    if (!npn_client && client_len)
        return -1;
    if (!npn_server && server_len)
        return -1;
    if (npn_server_reject && server_len)
        return -1;
    if (npn_client && npn_server && (!client_len || !server_len))
        return -1;

    return 0;
}
#endif

static const char *alpn_client;
static char *alpn_server;
static char *alpn_server2;
static const char *alpn_expected;
static unsigned char *alpn_selected;
static const char *server_min_proto;
static const char *server_max_proto;
static const char *client_min_proto;
static const char *client_max_proto;
static const char *should_negotiate;
static const char *sn_client;
static const char *sn_server1;
static const char *sn_server2;
static int sn_expect = 0;
static const char *server_sess_out;
static const char *server_sess_in;
static const char *client_sess_out;
static const char *client_sess_in;
static SSL_SESSION *server_sess;
static SSL_SESSION *client_sess;

static int servername_cb(SSL *s, int *ad, void *arg)
{
    const char *servername = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);
    if (sn_server2 == NULL) {
        BIO_printf(bio_stdout, "Servername 2 is NULL\n");
        return SSL_TLSEXT_ERR_NOACK;
    }

    if (servername) {
        if (s_ctx2 != NULL && sn_server2 != NULL &&
            !OPENSSL_strcasecmp(servername, sn_server2)) {
            BIO_printf(bio_stdout, "Switching server context.\n");
            SSL_set_SSL_CTX(s, s_ctx2);
        }
    }
    return SSL_TLSEXT_ERR_OK;
}
static int verify_servername(SSL *client, SSL *server)
{
    /* just need to see if sn_context is what we expect */
    SSL_CTX* ctx = SSL_get_SSL_CTX(server);
    if (sn_expect == 0)
        return 0;
    if (sn_expect == 1 && ctx == s_ctx)
        return 0;
    if (sn_expect == 2 && ctx == s_ctx2)
        return 0;
    BIO_printf(bio_stdout, "Servername: expected context %d\n", sn_expect);
    if (ctx == s_ctx2)
        BIO_printf(bio_stdout, "Servername: context is 2\n");
    else if (ctx == s_ctx)
        BIO_printf(bio_stdout, "Servername: context is 1\n");
    else
        BIO_printf(bio_stdout, "Servername: context is unknown\n");
    return -1;
}


/*-
 * next_protos_parse parses a comma separated list of strings into a string
 * in a format suitable for passing to SSL_CTX_set_next_protos_advertised.
 *   outlen: (output) set to the length of the resulting buffer on success.
 *   in: a NUL terminated string like "abc,def,ghi"
 *
 *   returns: a malloced buffer or NULL on failure.
 */
static unsigned char *next_protos_parse(size_t *outlen,
                                        const char *in)
{
    size_t len;
    unsigned char *out;
    size_t i, start = 0;

    len = strlen(in);
    if (len >= 65535)
        return NULL;

    out = OPENSSL_malloc(strlen(in) + 1);
    if (!out)
        return NULL;

    for (i = 0; i <= len; ++i) {
        if (i == len || in[i] == ',') {
            if (i - start > 255) {
                OPENSSL_free(out);
                return NULL;
            }
            out[start] = (unsigned char)(i - start);
            start = i + 1;
        } else
            out[i + 1] = in[i];
    }

    *outlen = len + 1;
    return out;
}

static int cb_server_alpn(SSL *s, const unsigned char **out,
                          unsigned char *outlen, const unsigned char *in,
                          unsigned int inlen, void *arg)
{
    unsigned char *protos;
    size_t protos_len;
    char* alpn_str = arg;

    protos = next_protos_parse(&protos_len, alpn_str);
    if (protos == NULL) {
        fprintf(stderr, "failed to parser ALPN server protocol string: %s\n",
                alpn_str);
        abort();
    }

    if (SSL_select_next_proto
        ((unsigned char **)out, outlen, protos, protos_len, in,
         inlen) != OPENSSL_NPN_NEGOTIATED) {
        OPENSSL_free(protos);
        return SSL_TLSEXT_ERR_NOACK;
    }

    /*
     * Make a copy of the selected protocol which will be freed in
     * verify_alpn.
     */
    alpn_selected = OPENSSL_malloc(*outlen);
    if (alpn_selected == NULL) {
        fprintf(stderr, "failed to allocate memory\n");
        OPENSSL_free(protos);
        abort();
    }
    memcpy(alpn_selected, *out, *outlen);
    *out = alpn_selected;

    OPENSSL_free(protos);
    return SSL_TLSEXT_ERR_OK;
}

static int verify_alpn(SSL *client, SSL *server)
{
    const unsigned char *client_proto, *server_proto;
    unsigned int client_proto_len = 0, server_proto_len = 0;
    SSL_get0_alpn_selected(client, &client_proto, &client_proto_len);
    SSL_get0_alpn_selected(server, &server_proto, &server_proto_len);

    OPENSSL_free(alpn_selected);
    alpn_selected = NULL;

    if (client_proto_len != server_proto_len) {
        BIO_printf(bio_stdout, "ALPN selected protocols differ!\n");
        goto err;
    }

    if (client_proto != NULL &&
        memcmp(client_proto, server_proto, client_proto_len) != 0) {
        BIO_printf(bio_stdout, "ALPN selected protocols differ!\n");
        goto err;
    }

    if (client_proto_len > 0 && alpn_expected == NULL) {
        BIO_printf(bio_stdout, "ALPN unexpectedly negotiated\n");
        goto err;
    }

    if (alpn_expected != NULL &&
        (client_proto_len != strlen(alpn_expected) ||
         memcmp(client_proto, alpn_expected, client_proto_len) != 0)) {
        BIO_printf(bio_stdout,
                   "ALPN selected protocols not equal to expected protocol: %s\n",
                   alpn_expected);
        goto err;
    }

    return 0;

 err:
    BIO_printf(bio_stdout, "ALPN results: client: '");
    BIO_write(bio_stdout, client_proto, client_proto_len);
    BIO_printf(bio_stdout, "', server: '");
    BIO_write(bio_stdout, server_proto, server_proto_len);
    BIO_printf(bio_stdout, "'\n");
    BIO_printf(bio_stdout, "ALPN configured: client: '%s', server: '",
                   alpn_client);
    if (SSL_get_SSL_CTX(server) == s_ctx2) {
        BIO_printf(bio_stdout, "%s'\n",
                   alpn_server2);
    } else {
        BIO_printf(bio_stdout, "%s'\n",
                   alpn_server);
    }
    return -1;
}

/*
 * WARNING : below extension types are *NOT* IETF assigned, and could
 * conflict if these types are reassigned and handled specially by OpenSSL
 * in the future
 */
#define TACK_EXT_TYPE 62208
#define CUSTOM_EXT_TYPE_0 1000
#define CUSTOM_EXT_TYPE_1 1001
#define CUSTOM_EXT_TYPE_2 1002
#define CUSTOM_EXT_TYPE_3 1003

static const char custom_ext_cli_string[] = "abc";
static const char custom_ext_srv_string[] = "defg";

/* These set from cmdline */
static char *serverinfo_file = NULL;
static int serverinfo_sct = 0;
static int serverinfo_tack = 0;

/* These set based on extension callbacks */
static int serverinfo_sct_seen = 0;
static int serverinfo_tack_seen = 0;
static int serverinfo_other_seen = 0;

/* This set from cmdline */
static int custom_ext = 0;

/* This set based on extension callbacks */
static int custom_ext_error = 0;

static int serverinfo_cli_parse_cb(SSL *s, unsigned int ext_type,
                                   const unsigned char *in, size_t inlen,
                                   int *al, void *arg)
{
    if (ext_type == TLSEXT_TYPE_signed_certificate_timestamp)
        serverinfo_sct_seen++;
    else if (ext_type == TACK_EXT_TYPE)
        serverinfo_tack_seen++;
    else
        serverinfo_other_seen++;
    return 1;
}

static int verify_serverinfo(void)
{
    if (serverinfo_sct != serverinfo_sct_seen)
        return -1;
    if (serverinfo_tack != serverinfo_tack_seen)
        return -1;
    if (serverinfo_other_seen)
        return -1;
    return 0;
}

/*-
 * Four test cases for custom extensions:
 * 0 - no ClientHello extension or ServerHello response
 * 1 - ClientHello with "abc", no response
 * 2 - ClientHello with "abc", empty response
 * 3 - ClientHello with "abc", "defg" response
 */

static int custom_ext_0_cli_add_cb(SSL *s, unsigned int ext_type,
                                   const unsigned char **out,
                                   size_t *outlen, int *al, void *arg)
{
    if (ext_type != CUSTOM_EXT_TYPE_0)
        custom_ext_error = 1;
    return 0;                   /* Don't send an extension */
}

static int custom_ext_0_cli_parse_cb(SSL *s, unsigned int ext_type,
                                     const unsigned char *in,
                                     size_t inlen, int *al, void *arg)
{
    return 1;
}

static int custom_ext_1_cli_add_cb(SSL *s, unsigned int ext_type,
                                   const unsigned char **out,
                                   size_t *outlen, int *al, void *arg)
{
    if (ext_type != CUSTOM_EXT_TYPE_1)
        custom_ext_error = 1;
    *out = (const unsigned char *)custom_ext_cli_string;
    *outlen = strlen(custom_ext_cli_string);
    return 1;                   /* Send "abc" */
}

static int custom_ext_1_cli_parse_cb(SSL *s, unsigned int ext_type,
                                     const unsigned char *in,
                                     size_t inlen, int *al, void *arg)
{
    return 1;
}

static int custom_ext_2_cli_add_cb(SSL *s, unsigned int ext_type,
                                   const unsigned char **out,
                                   size_t *outlen, int *al, void *arg)
{
    if (ext_type != CUSTOM_EXT_TYPE_2)
        custom_ext_error = 1;
    *out = (const unsigned char *)custom_ext_cli_string;
    *outlen = strlen(custom_ext_cli_string);
    return 1;                   /* Send "abc" */
}

static int custom_ext_2_cli_parse_cb(SSL *s, unsigned int ext_type,
                                     const unsigned char *in,
                                     size_t inlen, int *al, void *arg)
{
    if (ext_type != CUSTOM_EXT_TYPE_2)
        custom_ext_error = 1;
    if (inlen != 0)
        custom_ext_error = 1;   /* Should be empty response */
    return 1;
}

static int custom_ext_3_cli_add_cb(SSL *s, unsigned int ext_type,
                                   const unsigned char **out,
                                   size_t *outlen, int *al, void *arg)
{
    if (ext_type != CUSTOM_EXT_TYPE_3)
        custom_ext_error = 1;
    *out = (const unsigned char *)custom_ext_cli_string;
    *outlen = strlen(custom_ext_cli_string);
    return 1;                   /* Send "abc" */
}

static int custom_ext_3_cli_parse_cb(SSL *s, unsigned int ext_type,
                                     const unsigned char *in,
                                     size_t inlen, int *al, void *arg)
{
    if (ext_type != CUSTOM_EXT_TYPE_3)
        custom_ext_error = 1;
    if (inlen != strlen(custom_ext_srv_string))
        custom_ext_error = 1;
    if (memcmp(custom_ext_srv_string, in, inlen) != 0)
        custom_ext_error = 1;   /* Check for "defg" */
    return 1;
}

/*
 * custom_ext_0_cli_add_cb returns 0 - the server won't receive a callback
 * for this extension
 */
static int custom_ext_0_srv_parse_cb(SSL *s, unsigned int ext_type,
                                     const unsigned char *in,
                                     size_t inlen, int *al, void *arg)
{
    custom_ext_error = 1;
    return 1;
}

/* 'add' callbacks are only called if the 'parse' callback is called */
static int custom_ext_0_srv_add_cb(SSL *s, unsigned int ext_type,
                                   const unsigned char **out,
                                   size_t *outlen, int *al, void *arg)
{
    /* Error: should not have been called */
    custom_ext_error = 1;
    return 0;                   /* Don't send an extension */
}

static int custom_ext_1_srv_parse_cb(SSL *s, unsigned int ext_type,
                                     const unsigned char *in,
                                     size_t inlen, int *al, void *arg)
{
    if (ext_type != CUSTOM_EXT_TYPE_1)
        custom_ext_error = 1;
    /* Check for "abc" */
    if (inlen != strlen(custom_ext_cli_string))
        custom_ext_error = 1;
    if (memcmp(in, custom_ext_cli_string, inlen) != 0)
        custom_ext_error = 1;
    return 1;
}

static int custom_ext_1_srv_add_cb(SSL *s, unsigned int ext_type,
                                   const unsigned char **out,
                                   size_t *outlen, int *al, void *arg)
{
    return 0;                   /* Don't send an extension */
}

static int custom_ext_2_srv_parse_cb(SSL *s, unsigned int ext_type,
                                     const unsigned char *in,
                                     size_t inlen, int *al, void *arg)
{
    if (ext_type != CUSTOM_EXT_TYPE_2)
        custom_ext_error = 1;
    /* Check for "abc" */
    if (inlen != strlen(custom_ext_cli_string))
        custom_ext_error = 1;
    if (memcmp(in, custom_ext_cli_string, inlen) != 0)
        custom_ext_error = 1;
    return 1;
}

static int custom_ext_2_srv_add_cb(SSL *s, unsigned int ext_type,
                                   const unsigned char **out,
                                   size_t *outlen, int *al, void *arg)
{
    *out = NULL;
    *outlen = 0;
    return 1;                   /* Send empty extension */
}

static int custom_ext_3_srv_parse_cb(SSL *s, unsigned int ext_type,
                                     const unsigned char *in,
                                     size_t inlen, int *al, void *arg)
{
    if (ext_type != CUSTOM_EXT_TYPE_3)
        custom_ext_error = 1;
    /* Check for "abc" */
    if (inlen != strlen(custom_ext_cli_string))
        custom_ext_error = 1;
    if (memcmp(in, custom_ext_cli_string, inlen) != 0)
        custom_ext_error = 1;
    return 1;
}

static int custom_ext_3_srv_add_cb(SSL *s, unsigned int ext_type,
                                   const unsigned char **out,
                                   size_t *outlen, int *al, void *arg)
{
    *out = (const unsigned char *)custom_ext_srv_string;
    *outlen = strlen(custom_ext_srv_string);
    return 1;                   /* Send "defg" */
}

static char *cipher = NULL;
static char *ciphersuites = NULL;
static int verbose = 0;
static int debug = 0;

int doit_localhost(SSL *s_ssl, SSL *c_ssl, int family,
                   long bytes, clock_t *s_time, clock_t *c_time);
int doit_biopair(SSL *s_ssl, SSL *c_ssl, long bytes, clock_t *s_time,
                 clock_t *c_time);
int doit(SSL *s_ssl, SSL *c_ssl, long bytes);

static void sv_usage(void)
{
    fprintf(stderr, "usage: ssltest [args ...]\n");
    fprintf(stderr, "\n");
    fprintf(stderr, " -server_auth  - check server certificate\n");
    fprintf(stderr, " -client_auth  - do client authentication\n");
    fprintf(stderr, " -v            - more output\n");
    fprintf(stderr, " -d            - debug output\n");
    fprintf(stderr, " -reuse        - use session-id reuse\n");
    fprintf(stderr, " -num <val>    - number of connections to perform\n");
    fprintf(stderr,
            " -bytes <val>  - number of bytes to swap between client/server\n");
#ifndef OPENSSL_NO_DH
    fprintf(stderr,
            " -dhe512       - use 512 bit key for DHE (to test failure)\n");
    fprintf(stderr,
            " -dhe1024dsa   - use 1024 bit key (with 160-bit subprime) for DHE\n");
    fprintf(stderr,
            " -dhe2048      - use 2048 bit key (safe prime) for DHE (default, no-op)\n");
    fprintf(stderr,
            " -dhe4096      - use 4096 bit key (safe prime) for DHE\n");
#endif
    fprintf(stderr, " -no_dhe       - disable DHE\n");
#ifndef OPENSSL_NO_EC
    fprintf(stderr, " -no_ecdhe     - disable ECDHE\n");
#endif
#ifndef OPENSSL_NO_PSK
    fprintf(stderr, " -psk arg      - PSK in hex (without 0x)\n");
#endif
#ifndef OPENSSL_NO_SSL3
    fprintf(stderr, " -ssl3         - use SSLv3\n");
#endif
#ifndef OPENSSL_NO_TLS1
    fprintf(stderr, " -tls1         - use TLSv1\n");
#endif
#ifndef OPENSSL_NO_TLS1_1
    fprintf(stderr, " -tls1_1       - use TLSv1.1\n");
#endif
#ifndef OPENSSL_NO_TLS1_2
    fprintf(stderr, " -tls1_2       - use TLSv1.2\n");
#endif
#ifndef OPENSSL_NO_DTLS
    fprintf(stderr, " -dtls         - use DTLS\n");
#ifndef OPENSSL_NO_DTLS1
    fprintf(stderr, " -dtls1        - use DTLSv1\n");
#endif
#ifndef OPENSSL_NO_DTLS1_2
    fprintf(stderr, " -dtls12       - use DTLSv1.2\n");
#endif
#endif
    fprintf(stderr, " -CApath arg   - PEM format directory of CA's\n");
    fprintf(stderr, " -CAfile arg   - PEM format file of CA's\n");
    fprintf(stderr, " -s_cert arg   - Server certificate file\n");
    fprintf(stderr,
            " -s_key arg    - Server key file (default: same as -cert)\n");
    fprintf(stderr, " -c_cert arg   - Client certificate file\n");
    fprintf(stderr,
            " -c_key arg    - Client key file (default: same as -c_cert)\n");
    fprintf(stderr, " -cipher arg   - The TLSv1.2 and below cipher list\n");
    fprintf(stderr, " -ciphersuites arg   - The TLSv1.3 ciphersuites\n");
    fprintf(stderr, " -bio_pair     - Use BIO pairs\n");
    fprintf(stderr, " -ipv4         - Use IPv4 connection on localhost\n");
    fprintf(stderr, " -ipv6         - Use IPv6 connection on localhost\n");
    fprintf(stderr, " -f            - Test even cases that can't work\n");
    fprintf(stderr,
            " -time         - measure processor time used by client and server\n");
    fprintf(stderr, " -zlib         - use zlib compression\n");
#ifndef OPENSSL_NO_NEXTPROTONEG
    fprintf(stderr, " -npn_client - have client side offer NPN\n");
    fprintf(stderr, " -npn_server - have server side offer NPN\n");
    fprintf(stderr, " -npn_server_reject - have server reject NPN\n");
#endif
    fprintf(stderr, " -serverinfo_file file - have server use this file\n");
    fprintf(stderr, " -serverinfo_sct  - have client offer and expect SCT\n");
    fprintf(stderr,
            " -serverinfo_tack - have client offer and expect TACK\n");
    fprintf(stderr,
            " -custom_ext - try various custom extension callbacks\n");
    fprintf(stderr, " -alpn_client <string> - have client side offer ALPN\n");
    fprintf(stderr, " -alpn_server <string> - have server side offer ALPN\n");
    fprintf(stderr, " -alpn_server1 <string> - alias for -alpn_server\n");
    fprintf(stderr, " -alpn_server2 <string> - have server side context 2 offer ALPN\n");
    fprintf(stderr,
            " -alpn_expected <string> - the ALPN protocol that should be negotiated\n");
    fprintf(stderr, " -server_min_proto <string> - Minimum version the server should support\n");
    fprintf(stderr, " -server_max_proto <string> - Maximum version the server should support\n");
    fprintf(stderr, " -client_min_proto <string> - Minimum version the client should support\n");
    fprintf(stderr, " -client_max_proto <string> - Maximum version the client should support\n");
    fprintf(stderr, " -should_negotiate <string> - The version that should be negotiated, fail-client or fail-server\n");
#ifndef OPENSSL_NO_CT
    fprintf(stderr, " -noct         - no certificate transparency\n");
    fprintf(stderr, " -requestct    - request certificate transparency\n");
    fprintf(stderr, " -requirect    - require certificate transparency\n");
#endif
    fprintf(stderr, " -sn_client <string>  - have client request this servername\n");
    fprintf(stderr, " -sn_server1 <string> - have server context 1 respond to this servername\n");
    fprintf(stderr, " -sn_server2 <string> - have server context 2 respond to this servername\n");
    fprintf(stderr, " -sn_expect1          - expected server 1\n");
    fprintf(stderr, " -sn_expect2          - expected server 2\n");
    fprintf(stderr, " -server_sess_out <file>    - Save the server session to a file\n");
    fprintf(stderr, " -server_sess_in <file>     - Read the server session from a file\n");
    fprintf(stderr, " -client_sess_out <file>    - Save the client session to a file\n");
    fprintf(stderr, " -client_sess_in <file>     - Read the client session from a file\n");
    fprintf(stderr, " -should_reuse <number>     - The expected state of reusing the session\n");
    fprintf(stderr, " -no_ticket    - do not issue TLS session ticket\n");
    fprintf(stderr, " -client_ktls  - try to enable client KTLS\n");
    fprintf(stderr, " -server_ktls  - try to enable server KTLS\n");
    fprintf(stderr, " -provider <name>    - Load the given provider into the library context\n");
    fprintf(stderr, " -config <cnf>    - Load the given config file into the library context\n");
}

static void print_key_details(BIO *out, EVP_PKEY *key)
{
    int keyid = EVP_PKEY_get_id(key);

#ifndef OPENSSL_NO_EC
    if (keyid == EVP_PKEY_EC) {
        char group[80];
        size_t size;

        if (!EVP_PKEY_get_group_name(key, group, sizeof(group), &size))
            strcpy(group, "unknown group");
        BIO_printf(out, "%d bits EC (%s)", EVP_PKEY_get_bits(key), group);
    } else
#endif
    {
        const char *algname;
        switch (keyid) {
        case EVP_PKEY_RSA:
            algname = "RSA";
            break;
        case EVP_PKEY_DSA:
            algname = "DSA";
            break;
        case EVP_PKEY_DH:
            algname = "DH";
            break;
        default:
            algname = OBJ_nid2sn(keyid);
            break;
        }
        BIO_printf(out, "%d bits %s", EVP_PKEY_get_bits(key), algname);
    }
}

static void print_details(SSL *c_ssl, const char *prefix)
{
    const SSL_CIPHER *ciph;
    int mdnid;
    X509 *cert;
    EVP_PKEY *pkey;

    ciph = SSL_get_current_cipher(c_ssl);
    BIO_printf(bio_stdout, "%s%s, cipher %s %s",
               prefix,
               SSL_get_version(c_ssl),
               SSL_CIPHER_get_version(ciph), SSL_CIPHER_get_name(ciph));
    cert = SSL_get0_peer_certificate(c_ssl);
    if (cert != NULL) {
        EVP_PKEY* pubkey = X509_get0_pubkey(cert);

        if (pubkey != NULL) {
            BIO_puts(bio_stdout, ", ");
            print_key_details(bio_stdout, pubkey);
        }
    }
    if (SSL_get_peer_tmp_key(c_ssl, &pkey)) {
        BIO_puts(bio_stdout, ", temp key: ");
        print_key_details(bio_stdout, pkey);
        EVP_PKEY_free(pkey);
    }
    if (SSL_get_peer_signature_nid(c_ssl, &mdnid))
        BIO_printf(bio_stdout, ", digest=%s", OBJ_nid2sn(mdnid));
    BIO_printf(bio_stdout, "\n");
}

/*
 * protocol_from_string - converts a protocol version string to a number
 *
 * Returns -1 on failure or the version on success
 */
static int protocol_from_string(const char *value)
{
    struct protocol_versions {
        const char *name;
        int version;
    };
    static const struct protocol_versions versions[] = {
        {"ssl3", SSL3_VERSION},
        {"tls1", TLS1_VERSION},
        {"tls1.1", TLS1_1_VERSION},
        {"tls1.2", TLS1_2_VERSION},
        {"tls1.3", TLS1_3_VERSION},
        {"dtls1", DTLS1_VERSION},
        {"dtls1.2", DTLS1_2_VERSION}};
    size_t i;
    size_t n = OSSL_NELEM(versions);

    for (i = 0; i < n; i++)
        if (strcmp(versions[i].name, value) == 0)
            return versions[i].version;
    return -1;
}

static SSL_SESSION *read_session(const char *filename)
{
    SSL_SESSION *sess;
    BIO *f = BIO_new_file(filename, "r");

    if (f == NULL) {
        BIO_printf(bio_err, "Can't open session file %s\n", filename);
        ERR_print_errors(bio_err);
        return NULL;
    }
    sess = PEM_read_bio_SSL_SESSION(f, NULL, 0, NULL);
    if (sess == NULL) {
        BIO_printf(bio_err, "Can't parse session file %s\n", filename);
        ERR_print_errors(bio_err);
    }
    BIO_free(f);
    return sess;
}

static int write_session(const char *filename, SSL_SESSION *sess)
{
    BIO *f;

    if (sess == NULL) {
        BIO_printf(bio_err, "No session information\n");
        return 0;
    }

    f = BIO_new_file(filename, "w");
    if (f == NULL) {
        BIO_printf(bio_err, "Can't open session file %s\n", filename);
        ERR_print_errors(bio_err);
        return 0;
    }
    PEM_write_bio_SSL_SESSION(f, sess);
    BIO_free(f);
    return 1;
}

/*
 * set_protocol_version - Sets protocol version minimum or maximum
 *
 * Returns 0 on failure and 1 on success
 */
static int set_protocol_version(const char *version, SSL *ssl, int setting)
{
    if (version != NULL) {
        int ver = protocol_from_string(version);
        if (ver < 0) {
            BIO_printf(bio_err, "Error parsing: %s\n", version);
            return 0;
        }
        return SSL_ctrl(ssl, setting, ver, NULL);
    }
    return 1;
}

int main(int argc, char *argv[])
{
    const char *CApath = NULL, *CAfile = NULL;
    int badop = 0;
    enum { BIO_MEM, BIO_PAIR, BIO_IPV4, BIO_IPV6 } bio_type = BIO_MEM;
    int force = 0;
    int dtls1 = 0, dtls12 = 0, dtls = 0, tls1 = 0, tls1_1 = 0, tls1_2 = 0, ssl3 = 0;
    int ret = EXIT_FAILURE;
    int client_auth = 0;
    int server_auth = 0, i;
    struct app_verify_arg app_verify_arg =
        { APP_CALLBACK_STRING, 0 };
    SSL_CTX *c_ctx = NULL;
    const SSL_METHOD *meth = NULL;
    SSL *c_ssl = NULL;
    SSL *s_ssl = NULL;
    int number = 1, reuse = 0;
    int should_reuse = -1;
    int no_ticket = 0;
    int client_ktls = 0, server_ktls = 0;
    long bytes = 256L;
#ifndef OPENSSL_NO_DH
    EVP_PKEY *dhpkey;
    int dhe512 = 0, dhe1024dsa = 0, dhe4096 = 0;
    int no_dhe = 0;
#endif
    int no_psk = 0;
    int print_time = 0;
    clock_t s_time = 0, c_time = 0;
#ifndef OPENSSL_NO_COMP
    int n, comp = 0;
    COMP_METHOD *cm = NULL;
    STACK_OF(SSL_COMP) *ssl_comp_methods = NULL;
#endif
    int no_protocol;
    int min_version = 0, max_version = 0;
#ifndef OPENSSL_NO_CT
    /*
     * Disable CT validation by default, because it will interfere with
     * anything using custom extension handlers to deal with SCT extensions.
     */
    int ct_validation = 0;
#endif
    SSL_CONF_CTX *s_cctx = NULL, *c_cctx = NULL, *s_cctx2 = NULL;
    STACK_OF(OPENSSL_STRING) *conf_args = NULL;
    char *arg = NULL, *argn = NULL;
    const char *provider = NULL, *config = NULL;
    OSSL_PROVIDER *thisprov = NULL, *defctxnull = NULL;
    OSSL_LIB_CTX *libctx = NULL;

    verbose = 0;
    debug = 0;

    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);
    bio_stdout = BIO_new_fp(stdout, BIO_NOCLOSE | BIO_FP_TEXT);

    s_cctx = SSL_CONF_CTX_new();
    s_cctx2 = SSL_CONF_CTX_new();
    c_cctx = SSL_CONF_CTX_new();

    if (!s_cctx || !c_cctx || !s_cctx2) {
        ERR_print_errors(bio_err);
        goto end;
    }

    SSL_CONF_CTX_set_flags(s_cctx,
                           SSL_CONF_FLAG_CMDLINE | SSL_CONF_FLAG_SERVER |
                           SSL_CONF_FLAG_CERTIFICATE |
                           SSL_CONF_FLAG_REQUIRE_PRIVATE);
    SSL_CONF_CTX_set_flags(s_cctx2,
                           SSL_CONF_FLAG_CMDLINE | SSL_CONF_FLAG_SERVER |
                           SSL_CONF_FLAG_CERTIFICATE |
                           SSL_CONF_FLAG_REQUIRE_PRIVATE);
    if (!SSL_CONF_CTX_set1_prefix(s_cctx, "-s_")) {
        ERR_print_errors(bio_err);
        goto end;
    }
    if (!SSL_CONF_CTX_set1_prefix(s_cctx2, "-s_")) {
        ERR_print_errors(bio_err);
        goto end;
    }

    SSL_CONF_CTX_set_flags(c_cctx,
                           SSL_CONF_FLAG_CMDLINE | SSL_CONF_FLAG_CLIENT |
                           SSL_CONF_FLAG_CERTIFICATE |
                           SSL_CONF_FLAG_REQUIRE_PRIVATE);
    if (!SSL_CONF_CTX_set1_prefix(c_cctx, "-c_")) {
        ERR_print_errors(bio_err);
        goto end;
    }

    argc--;
    argv++;

    while (argc >= 1) {
        if (strcmp(*argv, "-F") == 0) {
            fprintf(stderr,
                    "not compiled with FIPS support, so exiting without running.\n");
            EXIT(0);
        } else if (strcmp(*argv, "-server_auth") == 0)
            server_auth = 1;
        else if (strcmp(*argv, "-client_auth") == 0)
            client_auth = 1;
        else if (strcmp(*argv, "-v") == 0)
            verbose = 1;
        else if (strcmp(*argv, "-d") == 0)
            debug = 1;
        else if (strcmp(*argv, "-reuse") == 0)
            reuse = 1;
        else if (strcmp(*argv, "-no_dhe") == 0)
#ifdef OPENSSL_NO_DH
            /* unused in this case */;
#else
            no_dhe = 1;
        else if (strcmp(*argv, "-dhe512") == 0)
            dhe512 = 1;
        else if (strcmp(*argv, "-dhe1024dsa") == 0)
            dhe1024dsa = 1;
        else if (strcmp(*argv, "-dhe4096") == 0)
            dhe4096 = 1;
#endif
        else if (strcmp(*argv, "-no_ecdhe") == 0)
            /* obsolete */;
        else if (strcmp(*argv, "-psk") == 0) {
            if (--argc < 1)
                goto bad;
            psk_key = *(++argv);
#ifndef OPENSSL_NO_PSK
            if (strspn(psk_key, "abcdefABCDEF1234567890") != strlen(psk_key)) {
                BIO_printf(bio_err, "Not a hex number '%s'\n", *argv);
                goto bad;
            }
#else
            no_psk = 1;
#endif
        }
        else if (strcmp(*argv, "-tls1_2") == 0) {
            tls1_2 = 1;
        } else if (strcmp(*argv, "-tls1_1") == 0) {
            tls1_1 = 1;
        } else if (strcmp(*argv, "-tls1") == 0) {
            tls1 = 1;
        } else if (strcmp(*argv, "-ssl3") == 0) {
            ssl3 = 1;
        } else if (strcmp(*argv, "-dtls1") == 0) {
            dtls1 = 1;
        } else if (strcmp(*argv, "-dtls12") == 0) {
            dtls12 = 1;
        } else if (strcmp(*argv, "-dtls") == 0) {
            dtls = 1;
        } else if (strncmp(*argv, "-num", 4) == 0) {
            if (--argc < 1)
                goto bad;
            number = atoi(*(++argv));
            if (number == 0)
                number = 1;
        } else if (strcmp(*argv, "-bytes") == 0) {
            if (--argc < 1)
                goto bad;
            bytes = atol(*(++argv));
            if (bytes == 0L)
                bytes = 1L;
            i = strlen(argv[0]);
            if (argv[0][i - 1] == 'k')
                bytes *= 1024L;
            if (argv[0][i - 1] == 'm')
                bytes *= 1024L * 1024L;
        } else if (strcmp(*argv, "-cipher") == 0) {
            if (--argc < 1)
                goto bad;
            cipher = *(++argv);
        } else if (strcmp(*argv, "-ciphersuites") == 0) {
            if (--argc < 1)
                goto bad;
            ciphersuites = *(++argv);
        } else if (strcmp(*argv, "-CApath") == 0) {
            if (--argc < 1)
                goto bad;
            CApath = *(++argv);
        } else if (strcmp(*argv, "-CAfile") == 0) {
            if (--argc < 1)
                goto bad;
            CAfile = *(++argv);
        } else if (strcmp(*argv, "-bio_pair") == 0) {
            bio_type = BIO_PAIR;
        }
#ifndef OPENSSL_NO_SOCK
        else if (strcmp(*argv, "-ipv4") == 0) {
            bio_type = BIO_IPV4;
        } else if (strcmp(*argv, "-ipv6") == 0) {
            bio_type = BIO_IPV6;
        }
#endif
        else if (strcmp(*argv, "-f") == 0) {
            force = 1;
        } else if (strcmp(*argv, "-time") == 0) {
            print_time = 1;
        }
#ifndef OPENSSL_NO_CT
        else if (strcmp(*argv, "-noct") == 0) {
            ct_validation = 0;
        }
        else if (strcmp(*argv, "-ct") == 0) {
            ct_validation = 1;
        }
#endif
#ifndef OPENSSL_NO_COMP
        else if (strcmp(*argv, "-zlib") == 0) {
            comp = COMP_ZLIB;
        }
#endif
        else if (strcmp(*argv, "-app_verify") == 0) {
            app_verify_arg.app_verify = 1;
        }
#ifndef OPENSSL_NO_NEXTPROTONEG
          else if (strcmp(*argv, "-npn_client") == 0) {
            npn_client = 1;
        } else if (strcmp(*argv, "-npn_server") == 0) {
            npn_server = 1;
        } else if (strcmp(*argv, "-npn_server_reject") == 0) {
            npn_server_reject = 1;
        }
#endif
        else if (strcmp(*argv, "-serverinfo_sct") == 0) {
            serverinfo_sct = 1;
        } else if (strcmp(*argv, "-serverinfo_tack") == 0) {
            serverinfo_tack = 1;
        } else if (strcmp(*argv, "-serverinfo_file") == 0) {
            if (--argc < 1)
                goto bad;
            serverinfo_file = *(++argv);
        } else if (strcmp(*argv, "-custom_ext") == 0) {
            custom_ext = 1;
        } else if (strcmp(*argv, "-alpn_client") == 0) {
            if (--argc < 1)
                goto bad;
            alpn_client = *(++argv);
        } else if (strcmp(*argv, "-alpn_server") == 0 ||
                   strcmp(*argv, "-alpn_server1") == 0) {
            if (--argc < 1)
                goto bad;
            alpn_server = *(++argv);
        } else if (strcmp(*argv, "-alpn_server2") == 0) {
            if (--argc < 1)
                goto bad;
            alpn_server2 = *(++argv);
        } else if (strcmp(*argv, "-alpn_expected") == 0) {
            if (--argc < 1)
                goto bad;
            alpn_expected = *(++argv);
        } else if (strcmp(*argv, "-server_min_proto") == 0) {
            if (--argc < 1)
                goto bad;
            server_min_proto = *(++argv);
        } else if (strcmp(*argv, "-server_max_proto") == 0) {
            if (--argc < 1)
                goto bad;
            server_max_proto = *(++argv);
        } else if (strcmp(*argv, "-client_min_proto") == 0) {
            if (--argc < 1)
                goto bad;
            client_min_proto = *(++argv);
        } else if (strcmp(*argv, "-client_max_proto") == 0) {
            if (--argc < 1)
                goto bad;
            client_max_proto = *(++argv);
        } else if (strcmp(*argv, "-should_negotiate") == 0) {
            if (--argc < 1)
                goto bad;
            should_negotiate = *(++argv);
        } else if (strcmp(*argv, "-sn_client") == 0) {
            if (--argc < 1)
                goto bad;
            sn_client = *(++argv);
        } else if (strcmp(*argv, "-sn_server1") == 0) {
            if (--argc < 1)
                goto bad;
            sn_server1 = *(++argv);
        } else if (strcmp(*argv, "-sn_server2") == 0) {
            if (--argc < 1)
                goto bad;
            sn_server2 = *(++argv);
        } else if (strcmp(*argv, "-sn_expect1") == 0) {
            sn_expect = 1;
        } else if (strcmp(*argv, "-sn_expect2") == 0) {
            sn_expect = 2;
        } else if (strcmp(*argv, "-server_sess_out") == 0) {
            if (--argc < 1)
                goto bad;
            server_sess_out = *(++argv);
        } else if (strcmp(*argv, "-server_sess_in") == 0) {
            if (--argc < 1)
                goto bad;
            server_sess_in = *(++argv);
        } else if (strcmp(*argv, "-client_sess_out") == 0) {
            if (--argc < 1)
                goto bad;
            client_sess_out = *(++argv);
        } else if (strcmp(*argv, "-client_sess_in") == 0) {
            if (--argc < 1)
                goto bad;
            client_sess_in = *(++argv);
        } else if (strcmp(*argv, "-should_reuse") == 0) {
            if (--argc < 1)
                goto bad;
            should_reuse = !!atoi(*(++argv));
        } else if (strcmp(*argv, "-no_ticket") == 0) {
            no_ticket = 1;
        } else if (strcmp(*argv, "-client_ktls") == 0) {
            client_ktls = 1;
        } else if (strcmp(*argv, "-server_ktls") == 0) {
            server_ktls = 1;
        } else if (strcmp(*argv, "-provider") == 0) {
            if (--argc < 1)
                goto bad;
            provider = *(++argv);
        } else if (strcmp(*argv, "-config") == 0) {
            if (--argc < 1)
                goto bad;
            config = *(++argv);
        } else {
            int rv;
            arg = argv[0];
            argn = argv[1];
            /* Try to process command using SSL_CONF */
            rv = SSL_CONF_cmd_argv(c_cctx, &argc, &argv);
            /* If not processed try server */
            if (rv == 0)
                rv = SSL_CONF_cmd_argv(s_cctx, &argc, &argv);
            /* Recognised: store it for later use */
            if (rv > 0) {
                if (rv == 1)
                    argn = NULL;
                if (!conf_args) {
                    conf_args = sk_OPENSSL_STRING_new_null();
                    if (!conf_args)
                        goto end;
                }
                if (!sk_OPENSSL_STRING_push(conf_args, arg))
                    goto end;
                if (!sk_OPENSSL_STRING_push(conf_args, argn))
                    goto end;
                continue;
            }
            if (rv == -3)
                BIO_printf(bio_err, "Missing argument for %s\n", arg);
            else if (rv < 0)
                BIO_printf(bio_err, "Error with command %s\n", arg);
            else if (rv == 0)
                BIO_printf(bio_err, "unknown option %s\n", arg);
            badop = 1;
            break;
        }
        argc--;
        argv++;
    }
    if (badop) {
 bad:
        sv_usage();
        goto end;
    }

    if (ssl3 + tls1 + tls1_1 + tls1_2 + dtls + dtls1 + dtls12 > 1) {
        fprintf(stderr, "At most one of -ssl3, -tls1, -tls1_1, -tls1_2, -dtls, -dtls1 or -dtls12 should "
                "be requested.\n");
        EXIT(1);
    }

#ifdef OPENSSL_NO_SSL3
    if (ssl3)
        no_protocol = 1;
    else
#endif
#ifdef OPENSSL_NO_TLS1
    if (tls1)
        no_protocol = 1;
    else
#endif
#ifdef OPENSSL_NO_TLS1_1
    if (tls1_1)
        no_protocol = 1;
    else
#endif
#ifdef OPENSSL_NO_TLS1_2
    if (tls1_2)
        no_protocol = 1;
    else
#endif
#if defined(OPENSSL_NO_DTLS) || defined(OPENSSL_NO_DTLS1)
    if (dtls1)
        no_protocol = 1;
    else
#endif
#if defined(OPENSSL_NO_DTLS) || defined(OPENSSL_NO_DTLS1_2)
    if (dtls12)
        no_protocol = 1;
    else
#endif
        no_protocol = 0;

    /*
     * Testing was requested for a compiled-out protocol (e.g. SSLv3).
     * Ideally, we would error out, but the generic test wrapper can't know
     * when to expect failure. So we do nothing and return success.
     */
    if (no_protocol) {
        fprintf(stderr, "Testing was requested for a disabled protocol. "
                "Skipping tests.\n");
        ret = EXIT_SUCCESS;
        goto end;
    }

    if (!ssl3 && !tls1 && !tls1_1 && !tls1_2 && !dtls && !dtls1 && !dtls12 && number > 1
            && !reuse && !force) {
        fprintf(stderr, "This case cannot work.  Use -f to perform "
                "the test anyway (and\n-d to see what happens), "
                "or add one of -ssl3, -tls1, -tls1_1, -tls1_2, -dtls, -dtls1, -dtls12, -reuse\n"
                "to avoid protocol mismatch.\n");
        EXIT(1);
    }

    if (print_time) {
        if (bio_type == BIO_MEM) {
            fprintf(stderr, "Using BIO pair (-bio_pair)\n");
            bio_type = BIO_PAIR;
        }
        if (number < 50 && !force)
            fprintf(stderr,
                    "Warning: For accurate timings, use more connections (e.g. -num 1000)\n");
    }

#ifndef OPENSSL_NO_COMP
    if (comp == COMP_ZLIB)
        cm = COMP_zlib();
    if (cm != NULL) {
        if (COMP_get_type(cm) != NID_undef) {
            if (SSL_COMP_add_compression_method(comp, cm) != 0) {
                fprintf(stderr, "Failed to add compression method\n");
                ERR_print_errors_fp(stderr);
            }
        } else {
            fprintf(stderr,
                    "Warning: %s compression not supported\n",
                    comp == COMP_ZLIB ? "zlib" : "unknown");
            ERR_print_errors_fp(stderr);
        }
    }
    ssl_comp_methods = SSL_COMP_get_compression_methods();
    n = sk_SSL_COMP_num(ssl_comp_methods);
    if (n) {
        int j;
        printf("Available compression methods:");
        for (j = 0; j < n; j++) {
            SSL_COMP *c = sk_SSL_COMP_value(ssl_comp_methods, j);
            printf("  %s:%d", SSL_COMP_get0_name(c), SSL_COMP_get_id(c));
        }
        printf("\n");
    }
#endif

#ifndef OPENSSL_NO_TLS
    meth = TLS_method();
    if (ssl3) {
        min_version = SSL3_VERSION;
        max_version = SSL3_VERSION;
    } else if (tls1) {
        min_version = TLS1_VERSION;
        max_version = TLS1_VERSION;
    } else if (tls1_1) {
        min_version = TLS1_1_VERSION;
        max_version = TLS1_1_VERSION;
    } else if (tls1_2) {
        min_version = TLS1_2_VERSION;
        max_version = TLS1_2_VERSION;
    } else {
        min_version = 0;
# if defined(OPENSSL_NO_EC) && defined(OPENSSL_NO_DH)
        /* We only have ec and dh based built-in groups for TLSv1.3 */
        max_version = TLS1_2_VERSION;
# else
        max_version = 0;
# endif
    }
#endif
#ifndef OPENSSL_NO_DTLS
    if (dtls || dtls1 || dtls12) {
        meth = DTLS_method();
        if (dtls1) {
            min_version = DTLS1_VERSION;
            max_version = DTLS1_VERSION;
        } else if (dtls12) {
            min_version = DTLS1_2_VERSION;
            max_version = DTLS1_2_VERSION;
        } else {
            min_version = 0;
            max_version = 0;
        }
    }
#endif

    if (provider != NULL
            && !test_get_libctx(&libctx, &defctxnull, config, &thisprov, provider))
        goto end;

    c_ctx = SSL_CTX_new_ex(libctx, NULL, meth);
    s_ctx = SSL_CTX_new_ex(libctx, NULL, meth);
    s_ctx2 = SSL_CTX_new_ex(libctx, NULL, meth); /* no SSL_CTX_dup! */
    if ((c_ctx == NULL) || (s_ctx == NULL) || (s_ctx2 == NULL)) {
        ERR_print_errors(bio_err);
        goto end;
    }
    /*
     * Since we will use low security ciphersuites and keys for testing set
     * security level to zero by default. Tests can override this by adding
     * "@SECLEVEL=n" to the cipher string.
     */
    SSL_CTX_set_security_level(c_ctx, 0);
    SSL_CTX_set_security_level(s_ctx, 0);
    SSL_CTX_set_security_level(s_ctx2, 0);

    if (no_ticket) {
        SSL_CTX_set_options(c_ctx, SSL_OP_NO_TICKET);
        SSL_CTX_set_options(s_ctx, SSL_OP_NO_TICKET);
    }

    if (SSL_CTX_set_min_proto_version(c_ctx, min_version) == 0)
        goto end;
    if (SSL_CTX_set_max_proto_version(c_ctx, max_version) == 0)
        goto end;
    if (SSL_CTX_set_min_proto_version(s_ctx, min_version) == 0)
        goto end;
    if (SSL_CTX_set_max_proto_version(s_ctx, max_version) == 0)
        goto end;

    if (cipher != NULL) {
        if (strcmp(cipher, "") == 0) {
            if (!SSL_CTX_set_cipher_list(c_ctx, cipher)) {
                if (ERR_GET_REASON(ERR_peek_error()) == SSL_R_NO_CIPHER_MATCH) {
                    ERR_clear_error();
                } else {
                    ERR_print_errors(bio_err);
                    goto end;
                }
            } else {
                /* Should have failed when clearing all TLSv1.2 ciphers. */
                fprintf(stderr, "CLEARING ALL TLSv1.2 CIPHERS SHOULD FAIL\n");
                goto end;
            }

            if (!SSL_CTX_set_cipher_list(s_ctx, cipher)) {
                if (ERR_GET_REASON(ERR_peek_error()) == SSL_R_NO_CIPHER_MATCH) {
                    ERR_clear_error();
                } else {
                    ERR_print_errors(bio_err);
                    goto end;
                }
            } else {
                /* Should have failed when clearing all TLSv1.2 ciphers. */
                fprintf(stderr, "CLEARING ALL TLSv1.2 CIPHERS SHOULD FAIL\n");
                goto end;
            }

            if (!SSL_CTX_set_cipher_list(s_ctx2, cipher)) {
                if (ERR_GET_REASON(ERR_peek_error()) == SSL_R_NO_CIPHER_MATCH) {
                    ERR_clear_error();
                } else {
                    ERR_print_errors(bio_err);
                    goto end;
                }
            } else {
                /* Should have failed when clearing all TLSv1.2 ciphers. */
                fprintf(stderr, "CLEARING ALL TLSv1.2 CIPHERS SHOULD FAIL\n");
                goto end;
            }
        } else {
            if (!SSL_CTX_set_cipher_list(c_ctx, cipher)
                    || !SSL_CTX_set_cipher_list(s_ctx, cipher)
                    || !SSL_CTX_set_cipher_list(s_ctx2, cipher)) {
                ERR_print_errors(bio_err);
                goto end;
            }
        }
    }
    if (ciphersuites != NULL) {
        if (!SSL_CTX_set_ciphersuites(c_ctx, ciphersuites)
            || !SSL_CTX_set_ciphersuites(s_ctx, ciphersuites)
            || !SSL_CTX_set_ciphersuites(s_ctx2, ciphersuites)) {
            ERR_print_errors(bio_err);
            goto end;
        }
    }

#ifndef OPENSSL_NO_CT
    if (ct_validation &&
        !SSL_CTX_enable_ct(c_ctx, SSL_CT_VALIDATION_STRICT)) {
        ERR_print_errors(bio_err);
        goto end;
    }
#endif

    /* Process SSL_CONF arguments */
    SSL_CONF_CTX_set_ssl_ctx(c_cctx, c_ctx);
    SSL_CONF_CTX_set_ssl_ctx(s_cctx, s_ctx);
    SSL_CONF_CTX_set_ssl_ctx(s_cctx2, s_ctx2);

    for (i = 0; i < sk_OPENSSL_STRING_num(conf_args); i += 2) {
        int rv;
        arg = sk_OPENSSL_STRING_value(conf_args, i);
        argn = sk_OPENSSL_STRING_value(conf_args, i + 1);
        rv = SSL_CONF_cmd(c_cctx, arg, argn);
        /* If not recognised use server context */
        if (rv == -2) {
            rv = SSL_CONF_cmd(s_cctx2, arg, argn);
            if (rv > 0)
                rv = SSL_CONF_cmd(s_cctx, arg, argn);
        }
        if (rv <= 0) {
            BIO_printf(bio_err, "Error processing %s %s\n",
                       arg, argn ? argn : "");
            ERR_print_errors(bio_err);
            goto end;
        }
    }

    if (!SSL_CONF_CTX_finish(s_cctx) || !SSL_CONF_CTX_finish(c_cctx) || !SSL_CONF_CTX_finish(s_cctx2)) {
        BIO_puts(bio_err, "Error finishing context\n");
        ERR_print_errors(bio_err);
        goto end;
    }
#ifndef OPENSSL_NO_DH
    if (!no_dhe) {
        if (dhe1024dsa)
            dhpkey = get_dh1024dsa(libctx);
        else if (dhe512)
            dhpkey = get_dh512(libctx);
        else if (dhe4096)
            dhpkey = get_dh4096(libctx);
        else
            dhpkey = get_dh2048(libctx);

        if (dhpkey == NULL || !EVP_PKEY_up_ref(dhpkey)) {
            EVP_PKEY_free(dhpkey);
            BIO_puts(bio_err, "Error getting DH parameters\n");
            ERR_print_errors(bio_err);
            goto end;
        }
        if (!SSL_CTX_set0_tmp_dh_pkey(s_ctx, dhpkey))
            EVP_PKEY_free(dhpkey);
        if (!SSL_CTX_set0_tmp_dh_pkey(s_ctx2, dhpkey))
            EVP_PKEY_free(dhpkey);
    }
#endif

    if (!(SSL_CTX_load_verify_file(s_ctx, CAfile)
          || SSL_CTX_load_verify_dir(s_ctx, CApath))
        || !SSL_CTX_set_default_verify_paths(s_ctx)
        || !(SSL_CTX_load_verify_file(s_ctx2, CAfile)
             || SSL_CTX_load_verify_dir(s_ctx2, CApath))
        || !SSL_CTX_set_default_verify_paths(s_ctx2)
        || !(SSL_CTX_load_verify_file(c_ctx, CAfile)
             || SSL_CTX_load_verify_dir(c_ctx, CApath))
        || !SSL_CTX_set_default_verify_paths(c_ctx)) {
        ERR_print_errors(bio_err);
    }

#ifndef OPENSSL_NO_CT
    if (!SSL_CTX_set_default_ctlog_list_file(s_ctx) ||
        !SSL_CTX_set_default_ctlog_list_file(s_ctx2) ||
        !SSL_CTX_set_default_ctlog_list_file(c_ctx)) {
        ERR_print_errors(bio_err);
    }
#endif

    if (client_auth) {
        printf("client authentication\n");
        SSL_CTX_set_verify(s_ctx,
                           SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
                           verify_callback);
        SSL_CTX_set_verify(s_ctx2,
                           SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
                           verify_callback);
        SSL_CTX_set_cert_verify_callback(s_ctx, app_verify_callback,
                                         &app_verify_arg);
        SSL_CTX_set_cert_verify_callback(s_ctx2, app_verify_callback,
                                         &app_verify_arg);
    }
    if (server_auth) {
        printf("server authentication\n");
        SSL_CTX_set_verify(c_ctx, SSL_VERIFY_PEER, verify_callback);
        SSL_CTX_set_cert_verify_callback(c_ctx, app_verify_callback,
                                         &app_verify_arg);
    }

    {
        int session_id_context = 0;
        if (!SSL_CTX_set_session_id_context(s_ctx, (void *)&session_id_context,
                                            sizeof(session_id_context)) ||
            !SSL_CTX_set_session_id_context(s_ctx2, (void *)&session_id_context,
                                            sizeof(session_id_context))) {
            ERR_print_errors(bio_err);
            goto end;
        }
    }

    /* Use PSK only if PSK key is given */
    if (psk_key != NULL) {
        /*
         * no_psk is used to avoid putting psk command to openssl tool
         */
        if (no_psk) {
            /*
             * if PSK is not compiled in and psk key is given, do nothing and
             * exit successfully
             */
            ret = EXIT_SUCCESS;
            goto end;
        }
#ifndef OPENSSL_NO_PSK
        SSL_CTX_set_psk_client_callback(c_ctx, psk_client_callback);
        SSL_CTX_set_psk_server_callback(s_ctx, psk_server_callback);
        SSL_CTX_set_psk_server_callback(s_ctx2, psk_server_callback);
        if (debug)
            BIO_printf(bio_err, "setting PSK identity hint to s_ctx\n");
        if (!SSL_CTX_use_psk_identity_hint(s_ctx, "ctx server identity_hint") ||
            !SSL_CTX_use_psk_identity_hint(s_ctx2, "ctx server identity_hint")) {
            BIO_printf(bio_err, "error setting PSK identity hint to s_ctx\n");
            ERR_print_errors(bio_err);
            goto end;
        }
#endif
    }

#ifndef OPENSSL_NO_NEXTPROTONEG
    if (npn_client) {
        SSL_CTX_set_next_proto_select_cb(c_ctx, cb_client_npn, NULL);
    }
    if (npn_server) {
        if (npn_server_reject) {
            BIO_printf(bio_err,
                       "Can't have both -npn_server and -npn_server_reject\n");
            goto end;
        }
        SSL_CTX_set_npn_advertised_cb(s_ctx, cb_server_npn, NULL);
        SSL_CTX_set_npn_advertised_cb(s_ctx2, cb_server_npn, NULL);
    }
    if (npn_server_reject) {
        SSL_CTX_set_npn_advertised_cb(s_ctx, cb_server_rejects_npn, NULL);
        SSL_CTX_set_npn_advertised_cb(s_ctx2, cb_server_rejects_npn, NULL);
    }
#endif

    if (serverinfo_sct) {
        if (!SSL_CTX_add_client_custom_ext(c_ctx,
                TLSEXT_TYPE_signed_certificate_timestamp,
                NULL, NULL, NULL,
                serverinfo_cli_parse_cb, NULL)) {
            BIO_printf(bio_err, "Error adding SCT extension\n");
            goto end;
        }
    }
    if (serverinfo_tack) {
        if (!SSL_CTX_add_client_custom_ext(c_ctx, TACK_EXT_TYPE,
                                      NULL, NULL, NULL,
                                      serverinfo_cli_parse_cb, NULL)) {
            BIO_printf(bio_err, "Error adding TACK extension\n");
            goto end;
        }
    }
    if (serverinfo_file)
        if (!SSL_CTX_use_serverinfo_file(s_ctx, serverinfo_file) ||
            !SSL_CTX_use_serverinfo_file(s_ctx2, serverinfo_file)) {
            BIO_printf(bio_err, "missing serverinfo file\n");
            goto end;
        }

    if (custom_ext) {
        if (!SSL_CTX_add_client_custom_ext(c_ctx, CUSTOM_EXT_TYPE_0,
                                      custom_ext_0_cli_add_cb,
                                      NULL, NULL,
                                      custom_ext_0_cli_parse_cb, NULL)
            || !SSL_CTX_add_client_custom_ext(c_ctx, CUSTOM_EXT_TYPE_1,
                                      custom_ext_1_cli_add_cb,
                                      NULL, NULL,
                                      custom_ext_1_cli_parse_cb, NULL)
            || !SSL_CTX_add_client_custom_ext(c_ctx, CUSTOM_EXT_TYPE_2,
                                      custom_ext_2_cli_add_cb,
                                      NULL, NULL,
                                      custom_ext_2_cli_parse_cb, NULL)
            || !SSL_CTX_add_client_custom_ext(c_ctx, CUSTOM_EXT_TYPE_3,
                                      custom_ext_3_cli_add_cb,
                                      NULL, NULL,
                                      custom_ext_3_cli_parse_cb, NULL)
            || !SSL_CTX_add_server_custom_ext(s_ctx, CUSTOM_EXT_TYPE_0,
                                      custom_ext_0_srv_add_cb,
                                      NULL, NULL,
                                      custom_ext_0_srv_parse_cb, NULL)
            || !SSL_CTX_add_server_custom_ext(s_ctx2, CUSTOM_EXT_TYPE_0,
                                      custom_ext_0_srv_add_cb,
                                      NULL, NULL,
                                      custom_ext_0_srv_parse_cb, NULL)
            || !SSL_CTX_add_server_custom_ext(s_ctx, CUSTOM_EXT_TYPE_1,
                                      custom_ext_1_srv_add_cb,
                                      NULL, NULL,
                                      custom_ext_1_srv_parse_cb, NULL)
            || !SSL_CTX_add_server_custom_ext(s_ctx2, CUSTOM_EXT_TYPE_1,
                                      custom_ext_1_srv_add_cb,
                                      NULL, NULL,
                                      custom_ext_1_srv_parse_cb, NULL)
            || !SSL_CTX_add_server_custom_ext(s_ctx, CUSTOM_EXT_TYPE_2,
                                      custom_ext_2_srv_add_cb,
                                      NULL, NULL,
                                      custom_ext_2_srv_parse_cb, NULL)
            || !SSL_CTX_add_server_custom_ext(s_ctx2, CUSTOM_EXT_TYPE_2,
                                      custom_ext_2_srv_add_cb,
                                      NULL, NULL,
                                      custom_ext_2_srv_parse_cb, NULL)
            || !SSL_CTX_add_server_custom_ext(s_ctx, CUSTOM_EXT_TYPE_3,
                                      custom_ext_3_srv_add_cb,
                                      NULL, NULL,
                                      custom_ext_3_srv_parse_cb, NULL)
            || !SSL_CTX_add_server_custom_ext(s_ctx2, CUSTOM_EXT_TYPE_3,
                                      custom_ext_3_srv_add_cb,
                                      NULL, NULL,
                                      custom_ext_3_srv_parse_cb, NULL)) {
            BIO_printf(bio_err, "Error setting custom extensions\n");
            goto end;
        }
    }

    if (alpn_server)
        SSL_CTX_set_alpn_select_cb(s_ctx, cb_server_alpn, alpn_server);
    if (alpn_server2)
        SSL_CTX_set_alpn_select_cb(s_ctx2, cb_server_alpn, alpn_server2);

    if (alpn_client) {
        size_t alpn_len;
        unsigned char *alpn = next_protos_parse(&alpn_len, alpn_client);

        if (alpn == NULL) {
            BIO_printf(bio_err, "Error parsing -alpn_client argument\n");
            goto end;
        }
        /* Returns 0 on success!! */
        if (SSL_CTX_set_alpn_protos(c_ctx, alpn, alpn_len)) {
            BIO_printf(bio_err, "Error setting ALPN\n");
            OPENSSL_free(alpn);
            goto end;
        }
        OPENSSL_free(alpn);
    }

    if (server_sess_in != NULL) {
        server_sess = read_session(server_sess_in);
        if (server_sess == NULL)
            goto end;
    }
    if (client_sess_in != NULL) {
        client_sess = read_session(client_sess_in);
        if (client_sess == NULL)
            goto end;
    }

    if (server_sess_out != NULL || server_sess_in != NULL) {
        char *keys;
        long size;

        /* Use a fixed key so that we can decrypt the ticket. */
        size = SSL_CTX_set_tlsext_ticket_keys(s_ctx, NULL, 0);
        keys = OPENSSL_zalloc(size);
        if (keys == NULL)
            goto end;
        SSL_CTX_set_tlsext_ticket_keys(s_ctx, keys, size);
        OPENSSL_free(keys);
    }

    if (sn_server1 != NULL || sn_server2 != NULL)
        SSL_CTX_set_tlsext_servername_callback(s_ctx, servername_cb);

    c_ssl = SSL_new(c_ctx);
    s_ssl = SSL_new(s_ctx);
    if (c_ssl == NULL || s_ssl == NULL)
        goto end;

    if (sn_client)
        SSL_set_tlsext_host_name(c_ssl, sn_client);
    if (client_ktls)
        SSL_set_options(c_ssl, SSL_OP_ENABLE_KTLS);
    if (server_ktls)
        SSL_set_options(s_ssl, SSL_OP_ENABLE_KTLS);

    if (!set_protocol_version(server_min_proto, s_ssl, SSL_CTRL_SET_MIN_PROTO_VERSION))
        goto end;
    if (!set_protocol_version(server_max_proto, s_ssl, SSL_CTRL_SET_MAX_PROTO_VERSION))
        goto end;
    if (!set_protocol_version(client_min_proto, c_ssl, SSL_CTRL_SET_MIN_PROTO_VERSION))
        goto end;
    if (!set_protocol_version(client_max_proto, c_ssl, SSL_CTRL_SET_MAX_PROTO_VERSION))
        goto end;

    if (server_sess) {
        if (SSL_CTX_add_session(s_ctx, server_sess) == 0) {
            BIO_printf(bio_err, "Can't add server session\n");
            ERR_print_errors(bio_err);
            goto end;
        }
    }

    BIO_printf(bio_stdout, "Doing handshakes=%d bytes=%ld\n", number, bytes);
    for (i = 0; i < number; i++) {
        if (!reuse) {
            if (!SSL_set_session(c_ssl, NULL)) {
                BIO_printf(bio_err, "Failed to set session\n");
                goto end;
            }
        }
        if (client_sess_in != NULL) {
            if (SSL_set_session(c_ssl, client_sess) == 0) {
                BIO_printf(bio_err, "Can't set client session\n");
                ERR_print_errors(bio_err);
                goto end;
            }
        }
        switch (bio_type) {
        case BIO_MEM:
            ret = doit(s_ssl, c_ssl, bytes);
            break;
        case BIO_PAIR:
            ret = doit_biopair(s_ssl, c_ssl, bytes, &s_time, &c_time);
            break;
#ifndef OPENSSL_NO_SOCK
        case BIO_IPV4:
            ret = doit_localhost(s_ssl, c_ssl, BIO_FAMILY_IPV4,
                                 bytes, &s_time, &c_time);
            break;
        case BIO_IPV6:
            ret = doit_localhost(s_ssl, c_ssl, BIO_FAMILY_IPV6,
                                 bytes, &s_time, &c_time);
            break;
#else
        case BIO_IPV4:
        case BIO_IPV6:
            ret = EXIT_FAILURE;
            goto end;
#endif
        }
        if (ret != EXIT_SUCCESS)
            break;
    }

    if (should_negotiate && ret == EXIT_SUCCESS &&
        strcmp(should_negotiate, "fail-server") != 0 &&
        strcmp(should_negotiate, "fail-client") != 0) {
        int version = protocol_from_string(should_negotiate);
        if (version < 0) {
            BIO_printf(bio_err, "Error parsing: %s\n", should_negotiate);
            ret = EXIT_FAILURE;
            goto end;
        }
        if (SSL_version(c_ssl) != version) {
            BIO_printf(bio_err, "Unexpected version negotiated. "
                "Expected: %s, got %s\n", should_negotiate, SSL_get_version(c_ssl));
            ret = EXIT_FAILURE;
            goto end;
        }
    }

    if (should_reuse != -1) {
        if (SSL_session_reused(s_ssl) != should_reuse ||
            SSL_session_reused(c_ssl) != should_reuse) {
            BIO_printf(bio_err, "Unexpected session reuse state. "
                "Expected: %d, server: %d, client: %d\n", should_reuse,
                SSL_session_reused(s_ssl), SSL_session_reused(c_ssl));
            ret = EXIT_FAILURE;
            goto end;
        }
    }

    if (server_sess_out != NULL) {
        if (write_session(server_sess_out, SSL_get_session(s_ssl)) == 0) {
            ret = EXIT_FAILURE;
            goto end;
        }
    }
    if (client_sess_out != NULL) {
        if (write_session(client_sess_out, SSL_get_session(c_ssl)) == 0) {
            ret = EXIT_FAILURE;
            goto end;
        }
    }

    if (!verbose) {
        print_details(c_ssl, "");
    }
    if (print_time) {
#ifdef CLOCKS_PER_SEC
        /*
         * "To determine the time in seconds, the value returned by the clock
         * function should be divided by the value of the macro
         * CLOCKS_PER_SEC." -- ISO/IEC 9899
         */
        BIO_printf(bio_stdout, "Approximate total server time: %6.2f s\n"
                   "Approximate total client time: %6.2f s\n",
                   (double)s_time / CLOCKS_PER_SEC,
                   (double)c_time / CLOCKS_PER_SEC);
#else
        BIO_printf(bio_stdout,
                   "Approximate total server time: %6.2f units\n"
                   "Approximate total client time: %6.2f units\n",
                   (double)s_time, (double)c_time);
#endif
    }

 end:
    SSL_free(s_ssl);
    SSL_free(c_ssl);
    SSL_CTX_free(s_ctx);
    SSL_CTX_free(s_ctx2);
    SSL_CTX_free(c_ctx);
    SSL_CONF_CTX_free(s_cctx);
    SSL_CONF_CTX_free(s_cctx2);
    SSL_CONF_CTX_free(c_cctx);
    sk_OPENSSL_STRING_free(conf_args);

    BIO_free(bio_stdout);

    SSL_SESSION_free(server_sess);
    SSL_SESSION_free(client_sess);

    OSSL_PROVIDER_unload(defctxnull);
    OSSL_PROVIDER_unload(thisprov);
    OSSL_LIB_CTX_free(libctx);

    BIO_free(bio_err);
    EXIT(ret);
}

#ifndef OPENSSL_NO_SOCK
int doit_localhost(SSL *s_ssl, SSL *c_ssl, int family, long count,
                   clock_t *s_time, clock_t *c_time)
{
    long cw_num = count, cr_num = count, sw_num = count, sr_num = count;
    BIO *s_ssl_bio = NULL, *c_ssl_bio = NULL;
    BIO *acpt = NULL, *server = NULL, *client = NULL;
    char addr_str[40];
    int ret = EXIT_FAILURE;
    int err_in_client = 0;
    int err_in_server = 0;

    acpt = BIO_new_accept(family == BIO_FAMILY_IPV4 ? "127.0.0.1:0"
                                                    : "[::1]:0");
    if (acpt == NULL)
        goto err;
    BIO_set_accept_ip_family(acpt, family);
    BIO_set_bind_mode(acpt, BIO_SOCK_NONBLOCK | BIO_SOCK_REUSEADDR);
    if (BIO_do_accept(acpt) <= 0)
        goto err;

    BIO_snprintf(addr_str, sizeof(addr_str), ":%s", BIO_get_accept_port(acpt));

    client = BIO_new_connect(addr_str);
    if (!client)
        goto err;
    BIO_set_conn_ip_family(client, family);

    if (BIO_set_nbio(client, 1) <= 0)
        goto err;
    if (BIO_set_nbio(acpt, 1) <= 0)
        goto err;

    {
        int st_connect = 0, st_accept = 0;

        while(!st_connect || !st_accept) {
            if (!st_connect) {
                if (BIO_do_connect(client) <= 0) {
                    if (!BIO_should_retry(client))
                        goto err;
                } else {
                    st_connect = 1;
                }
            }
            if (!st_accept) {
                if (BIO_do_accept(acpt) <= 0) {
                    if (!BIO_should_retry(acpt))
                        goto err;
                } else {
                    st_accept = 1;
                }
            }
        }
    }
    /* We're not interested in accepting further connects */
    server = BIO_pop(acpt);
    BIO_free_all(acpt);
    acpt = NULL;

    s_ssl_bio = BIO_new(BIO_f_ssl());
    if (!s_ssl_bio)
        goto err;

    c_ssl_bio = BIO_new(BIO_f_ssl());
    if (!c_ssl_bio)
        goto err;

    SSL_set_connect_state(c_ssl);
    SSL_set_bio(c_ssl, client, client);
    (void)BIO_set_ssl(c_ssl_bio, c_ssl, BIO_NOCLOSE);

    SSL_set_accept_state(s_ssl);
    SSL_set_bio(s_ssl, server, server);
    (void)BIO_set_ssl(s_ssl_bio, s_ssl, BIO_NOCLOSE);

    do {
        /*-
         * c_ssl_bio:          SSL filter BIO
         *
         * client:             I/O for SSL library
         *
         *
         * server:             I/O for SSL library
         *
         * s_ssl_bio:          SSL filter BIO
         */

        /*
         * We have non-blocking behaviour throughout this test program, but
         * can be sure that there is *some* progress in each iteration; so we
         * don't have to worry about ..._SHOULD_READ or ..._SHOULD_WRITE --
         * we just try everything in each iteration
         */

        {
            /* CLIENT */

            char cbuf[1024 * 8];
            int i, r;
            clock_t c_clock = clock();

            memset(cbuf, 0, sizeof(cbuf));

            if (debug)
                if (SSL_in_init(c_ssl))
                    printf("client waiting in SSL_connect - %s\n",
                           SSL_state_string_long(c_ssl));

            if (cw_num > 0) {
                /* Write to server. */

                if (cw_num > (long)sizeof(cbuf))
                    i = sizeof(cbuf);
                else
                    i = (int)cw_num;
                r = BIO_write(c_ssl_bio, cbuf, i);
                if (r < 0) {
                    if (!BIO_should_retry(c_ssl_bio)) {
                        fprintf(stderr, "ERROR in CLIENT (write)\n");
                        err_in_client = 1;
                        goto err;
                    }
                    /*
                     * BIO_should_retry(...) can just be ignored here. The
                     * library expects us to call BIO_write with the same
                     * arguments again, and that's what we will do in the
                     * next iteration.
                     */
                } else if (r == 0) {
                    fprintf(stderr, "SSL CLIENT STARTUP FAILED\n");
                    goto err;
                } else {
                    if (debug)
                        printf("client wrote %d\n", r);
                    cw_num -= r;
                }
            }

            if (cr_num > 0) {
                /* Read from server. */

                r = BIO_read(c_ssl_bio, cbuf, sizeof(cbuf));
                if (r < 0) {
                    if (!BIO_should_retry(c_ssl_bio)) {
                        fprintf(stderr, "ERROR in CLIENT (read)\n");
                        err_in_client = 1;
                        goto err;
                    }
                    /*
                     * Again, "BIO_should_retry" can be ignored.
                     */
                } else if (r == 0) {
                    fprintf(stderr, "SSL CLIENT STARTUP FAILED\n");
                    goto err;
                } else {
                    if (debug)
                        printf("client read %d\n", r);
                    cr_num -= r;
                }
            }

            /*
             * c_time and s_time increments will typically be very small
             * (depending on machine speed and clock tick intervals), but
             * sampling over a large number of connections should result in
             * fairly accurate figures.  We cannot guarantee a lot, however
             * -- if each connection lasts for exactly one clock tick, it
             * will be counted only for the client or only for the server or
             * even not at all.
             */
            *c_time += (clock() - c_clock);
        }

        {
            /* SERVER */

            char sbuf[1024 * 8];
            int i, r;
            clock_t s_clock = clock();

            memset(sbuf, 0, sizeof(sbuf));

            if (debug)
                if (SSL_in_init(s_ssl))
                    printf("server waiting in SSL_accept - %s\n",
                           SSL_state_string_long(s_ssl));

            if (sw_num > 0) {
                /* Write to client. */

                if (sw_num > (long)sizeof(sbuf))
                    i = sizeof(sbuf);
                else
                    i = (int)sw_num;
                r = BIO_write(s_ssl_bio, sbuf, i);
                if (r < 0) {
                    if (!BIO_should_retry(s_ssl_bio)) {
                        fprintf(stderr, "ERROR in SERVER (write)\n");
                        err_in_server = 1;
                        goto err;
                    }
                    /* Ignore "BIO_should_retry". */
                } else if (r == 0) {
                    fprintf(stderr, "SSL SERVER STARTUP FAILED\n");
                    goto err;
                } else {
                    if (debug)
                        printf("server wrote %d\n", r);
                    sw_num -= r;
                }
            }

            if (sr_num > 0) {
                /* Read from client. */

                r = BIO_read(s_ssl_bio, sbuf, sizeof(sbuf));
                if (r < 0) {
                    if (!BIO_should_retry(s_ssl_bio)) {
                        fprintf(stderr, "ERROR in SERVER (read)\n");
                        err_in_server = 1;
                        goto err;
                    }
                    /* blah, blah */
                } else if (r == 0) {
                    fprintf(stderr, "SSL SERVER STARTUP FAILED\n");
                    goto err;
                } else {
                    if (debug)
                        printf("server read %d\n", r);
                    sr_num -= r;
                }
            }

            *s_time += (clock() - s_clock);
        }
    }
    while (cw_num > 0 || cr_num > 0 || sw_num > 0 || sr_num > 0);

    if (verbose) {
        print_details(c_ssl, "DONE via TCP connect: ");

        if (BIO_get_ktls_send(SSL_get_wbio(s_ssl))
                && BIO_get_ktls_recv(SSL_get_rbio(s_ssl)))
            BIO_printf(bio_stdout, "Server using Kernel TLS in both directions\n");
        else if (BIO_get_ktls_send(SSL_get_wbio(s_ssl)))
            BIO_printf(bio_stdout, "Server using Kernel TLS for sending\n");
        else if (BIO_get_ktls_recv(SSL_get_rbio(s_ssl)))
            BIO_printf(bio_stdout, "Server using Kernel TLS for receiving\n");

        if (BIO_get_ktls_send(SSL_get_wbio(c_ssl))
                && BIO_get_ktls_recv(SSL_get_rbio(c_ssl)))
            BIO_printf(bio_stdout, "Client using Kernel TLS in both directions\n");
        else if (BIO_get_ktls_send(SSL_get_wbio(c_ssl)))
            BIO_printf(bio_stdout, "Client using Kernel TLS for sending\n");
        else if (BIO_get_ktls_recv(SSL_get_rbio(c_ssl)))
            BIO_printf(bio_stdout, "Client using Kernel TLS for receiving\n");
    }
# ifndef OPENSSL_NO_NEXTPROTONEG
    if (verify_npn(c_ssl, s_ssl) < 0)
        goto end;
# endif
    if (verify_serverinfo() < 0) {
        fprintf(stderr, "Server info verify error\n");
        goto err;
    }
    if (verify_alpn(c_ssl, s_ssl) < 0
            || verify_servername(c_ssl, s_ssl) < 0)
        goto err;

    if (custom_ext_error) {
        fprintf(stderr, "Custom extension error\n");
        goto err;
    }

# ifndef OPENSSL_NO_NEXTPROTONEG
 end:
# endif
    ret = EXIT_SUCCESS;

 err:
    ERR_print_errors(bio_err);

    BIO_free_all(acpt);
    BIO_free(server);
    BIO_free(client);
    BIO_free(s_ssl_bio);
    BIO_free(c_ssl_bio);

    if (should_negotiate != NULL && strcmp(should_negotiate, "fail-client") == 0)
        ret = (err_in_client != 0) ? EXIT_SUCCESS : EXIT_FAILURE;
    else if (should_negotiate != NULL && strcmp(should_negotiate, "fail-server") == 0)
        ret = (err_in_server != 0) ? EXIT_SUCCESS : EXIT_FAILURE;

    return ret;
}
#endif

int doit_biopair(SSL *s_ssl, SSL *c_ssl, long count,
                 clock_t *s_time, clock_t *c_time)
{
    long cw_num = count, cr_num = count, sw_num = count, sr_num = count;
    BIO *s_ssl_bio = NULL, *c_ssl_bio = NULL;
    BIO *server = NULL, *server_io = NULL, *client = NULL, *client_io = NULL;
    int ret = EXIT_FAILURE;
    int err_in_client = 0;
    int err_in_server = 0;

    size_t bufsiz = 256;        /* small buffer for testing */

    if (!BIO_new_bio_pair(&server, bufsiz, &server_io, bufsiz))
        goto err;
    if (!BIO_new_bio_pair(&client, bufsiz, &client_io, bufsiz))
        goto err;

    s_ssl_bio = BIO_new(BIO_f_ssl());
    if (!s_ssl_bio)
        goto err;

    c_ssl_bio = BIO_new(BIO_f_ssl());
    if (!c_ssl_bio)
        goto err;

    SSL_set_connect_state(c_ssl);
    SSL_set_bio(c_ssl, client, client);
    (void)BIO_set_ssl(c_ssl_bio, c_ssl, BIO_NOCLOSE);

    SSL_set_accept_state(s_ssl);
    SSL_set_bio(s_ssl, server, server);
    (void)BIO_set_ssl(s_ssl_bio, s_ssl, BIO_NOCLOSE);

    do {
        /*-
         * c_ssl_bio:          SSL filter BIO
         *
         * client:             pseudo-I/O for SSL library
         *
         * client_io:          client's SSL communication; usually to be
         *                     relayed over some I/O facility, but in this
         *                     test program, we're the server, too:
         *
         * server_io:          server's SSL communication
         *
         * server:             pseudo-I/O for SSL library
         *
         * s_ssl_bio:          SSL filter BIO
         *
         * The client and the server each employ a "BIO pair":
         * client + client_io, server + server_io.
         * BIO pairs are symmetric.  A BIO pair behaves similar
         * to a non-blocking socketpair (but both endpoints must
         * be handled by the same thread).
         * [Here we could connect client and server to the ends
         * of a single BIO pair, but then this code would be less
         * suitable as an example for BIO pairs in general.]
         *
         * Useful functions for querying the state of BIO pair endpoints:
         *
         * BIO_ctrl_pending(bio)              number of bytes we can read now
         * BIO_ctrl_get_read_request(bio)     number of bytes needed to fulfill
         *                                      other side's read attempt
         * BIO_ctrl_get_write_guarantee(bio)   number of bytes we can write now
         *
         * ..._read_request is never more than ..._write_guarantee;
         * it depends on the application which one you should use.
         */

        /*
         * We have non-blocking behaviour throughout this test program, but
         * can be sure that there is *some* progress in each iteration; so we
         * don't have to worry about ..._SHOULD_READ or ..._SHOULD_WRITE --
         * we just try everything in each iteration
         */

        {
            /* CLIENT */

            char cbuf[1024 * 8];
            int i, r;
            clock_t c_clock = clock();

            memset(cbuf, 0, sizeof(cbuf));

            if (debug)
                if (SSL_in_init(c_ssl))
                    printf("client waiting in SSL_connect - %s\n",
                           SSL_state_string_long(c_ssl));

            if (cw_num > 0) {
                /* Write to server. */

                if (cw_num > (long)sizeof(cbuf))
                    i = sizeof(cbuf);
                else
                    i = (int)cw_num;
                r = BIO_write(c_ssl_bio, cbuf, i);
                if (r < 0) {
                    if (!BIO_should_retry(c_ssl_bio)) {
                        fprintf(stderr, "ERROR in CLIENT\n");
                        err_in_client = 1;
                        goto err;
                    }
                    /*
                     * BIO_should_retry(...) can just be ignored here. The
                     * library expects us to call BIO_write with the same
                     * arguments again, and that's what we will do in the
                     * next iteration.
                     */
                } else if (r == 0) {
                    fprintf(stderr, "SSL CLIENT STARTUP FAILED\n");
                    goto err;
                } else {
                    if (debug)
                        printf("client wrote %d\n", r);
                    cw_num -= r;
                }
            }

            if (cr_num > 0) {
                /* Read from server. */

                r = BIO_read(c_ssl_bio, cbuf, sizeof(cbuf));
                if (r < 0) {
                    if (!BIO_should_retry(c_ssl_bio)) {
                        fprintf(stderr, "ERROR in CLIENT\n");
                        err_in_client = 1;
                        goto err;
                    }
                    /*
                     * Again, "BIO_should_retry" can be ignored.
                     */
                } else if (r == 0) {
                    fprintf(stderr, "SSL CLIENT STARTUP FAILED\n");
                    goto err;
                } else {
                    if (debug)
                        printf("client read %d\n", r);
                    cr_num -= r;
                }
            }

            /*
             * c_time and s_time increments will typically be very small
             * (depending on machine speed and clock tick intervals), but
             * sampling over a large number of connections should result in
             * fairly accurate figures.  We cannot guarantee a lot, however
             * -- if each connection lasts for exactly one clock tick, it
             * will be counted only for the client or only for the server or
             * even not at all.
             */
            *c_time += (clock() - c_clock);
        }

        {
            /* SERVER */

            char sbuf[1024 * 8];
            int i, r;
            clock_t s_clock = clock();

            memset(sbuf, 0, sizeof(sbuf));

            if (debug)
                if (SSL_in_init(s_ssl))
                    printf("server waiting in SSL_accept - %s\n",
                           SSL_state_string_long(s_ssl));

            if (sw_num > 0) {
                /* Write to client. */

                if (sw_num > (long)sizeof(sbuf))
                    i = sizeof(sbuf);
                else
                    i = (int)sw_num;
                r = BIO_write(s_ssl_bio, sbuf, i);
                if (r < 0) {
                    if (!BIO_should_retry(s_ssl_bio)) {
                        fprintf(stderr, "ERROR in SERVER\n");
                        err_in_server = 1;
                        goto err;
                    }
                    /* Ignore "BIO_should_retry". */
                } else if (r == 0) {
                    fprintf(stderr, "SSL SERVER STARTUP FAILED\n");
                    goto err;
                } else {
                    if (debug)
                        printf("server wrote %d\n", r);
                    sw_num -= r;
                }
            }

            if (sr_num > 0) {
                /* Read from client. */

                r = BIO_read(s_ssl_bio, sbuf, sizeof(sbuf));
                if (r < 0) {
                    if (!BIO_should_retry(s_ssl_bio)) {
                        fprintf(stderr, "ERROR in SERVER\n");
                        err_in_server = 1;
                        goto err;
                    }
                    /* blah, blah */
                } else if (r == 0) {
                    fprintf(stderr, "SSL SERVER STARTUP FAILED\n");
                    goto err;
                } else {
                    if (debug)
                        printf("server read %d\n", r);
                    sr_num -= r;
                }
            }

            *s_time += (clock() - s_clock);
        }

        {
            /* "I/O" BETWEEN CLIENT AND SERVER. */

            size_t r1, r2;
            BIO *io1 = server_io, *io2 = client_io;
            /*
             * we use the non-copying interface for io1 and the standard
             * BIO_write/BIO_read interface for io2
             */

            static int prev_progress = 1;
            int progress = 0;

            /* io1 to io2 */
            do {
                size_t num;
                int r;

                r1 = BIO_ctrl_pending(io1);
                r2 = BIO_ctrl_get_write_guarantee(io2);

                num = r1;
                if (r2 < num)
                    num = r2;
                if (num) {
                    char *dataptr;

                    if (INT_MAX < num) /* yeah, right */
                        num = INT_MAX;

                    r = BIO_nread(io1, &dataptr, (int)num);
                    assert(r > 0);
                    assert(r <= (int)num);
                    /*
                     * possibly r < num (non-contiguous data)
                     */
                    num = r;
                    r = BIO_write(io2, dataptr, (int)num);
                    if (r != (int)num) { /* can't happen */
                        fprintf(stderr, "ERROR: BIO_write could not write "
                                "BIO_ctrl_get_write_guarantee() bytes");
                        goto err;
                    }
                    progress = 1;

                    if (debug)
                        printf((io1 == client_io) ?
                               "C->S relaying: %d bytes\n" :
                               "S->C relaying: %d bytes\n", (int)num);
                }
            }
            while (r1 && r2);

            /* io2 to io1 */
            {
                size_t num;
                int r;

                r1 = BIO_ctrl_pending(io2);
                r2 = BIO_ctrl_get_read_request(io1);
                /*
                 * here we could use ..._get_write_guarantee instead of
                 * ..._get_read_request, but by using the latter we test
                 * restartability of the SSL implementation more thoroughly
                 */
                num = r1;
                if (r2 < num)
                    num = r2;
                if (num) {
                    char *dataptr;

                    if (INT_MAX < num)
                        num = INT_MAX;

                    if (num > 1)
                        --num;  /* test restartability even more thoroughly */

                    r = BIO_nwrite0(io1, &dataptr);
                    assert(r > 0);
                    if (r < (int)num)
                        num = r;
                    r = BIO_read(io2, dataptr, (int)num);
                    if (r != (int)num) { /* can't happen */
                        fprintf(stderr, "ERROR: BIO_read could not read "
                                "BIO_ctrl_pending() bytes");
                        goto err;
                    }
                    progress = 1;
                    r = BIO_nwrite(io1, &dataptr, (int)num);
                    if (r != (int)num) { /* can't happen */
                        fprintf(stderr, "ERROR: BIO_nwrite() did not accept "
                                "BIO_nwrite0() bytes");
                        goto err;
                    }

                    if (debug)
                        printf((io2 == client_io) ?
                               "C->S relaying: %d bytes\n" :
                               "S->C relaying: %d bytes\n", (int)num);
                }
            }                   /* no loop, BIO_ctrl_get_read_request now
                                 * returns 0 anyway */

            if (!progress && !prev_progress)
                if (cw_num > 0 || cr_num > 0 || sw_num > 0 || sr_num > 0) {
                    fprintf(stderr, "ERROR: got stuck\n");
                    fprintf(stderr, " ERROR.\n");
                    goto err;
                }
            prev_progress = progress;
        }
    }
    while (cw_num > 0 || cr_num > 0 || sw_num > 0 || sr_num > 0);

    if (verbose)
        print_details(c_ssl, "DONE via BIO pair: ");
#ifndef OPENSSL_NO_NEXTPROTONEG
    if (verify_npn(c_ssl, s_ssl) < 0)
        goto end;
#endif
    if (verify_serverinfo() < 0) {
        fprintf(stderr, "Server info verify error\n");
        goto err;
    }
    if (verify_alpn(c_ssl, s_ssl) < 0
            || verify_servername(c_ssl, s_ssl) < 0)
        goto err;

    if (custom_ext_error) {
        fprintf(stderr, "Custom extension error\n");
        goto err;
    }

#ifndef OPENSSL_NO_NEXTPROTONEG
 end:
#endif
    ret = EXIT_SUCCESS;

 err:
    ERR_print_errors(bio_err);

    BIO_free(server);
    BIO_free(server_io);
    BIO_free(client);
    BIO_free(client_io);
    BIO_free(s_ssl_bio);
    BIO_free(c_ssl_bio);

    if (should_negotiate != NULL && strcmp(should_negotiate, "fail-client") == 0)
        ret = (err_in_client != 0) ? EXIT_SUCCESS : EXIT_FAILURE;
    else if (should_negotiate != NULL && strcmp(should_negotiate, "fail-server") == 0)
        ret = (err_in_server != 0) ? EXIT_SUCCESS : EXIT_FAILURE;

    return ret;
}

#define W_READ  1
#define W_WRITE 2
#define C_DONE  1
#define S_DONE  2

int doit(SSL *s_ssl, SSL *c_ssl, long count)
{
    char *cbuf = NULL, *sbuf = NULL;
    long bufsiz;
    long cw_num = count, cr_num = count;
    long sw_num = count, sr_num = count;
    int ret = EXIT_FAILURE;
    BIO *c_to_s = NULL;
    BIO *s_to_c = NULL;
    BIO *c_bio = NULL;
    BIO *s_bio = NULL;
    int c_r, c_w, s_r, s_w;
    int i, j;
    int done = 0;
    int c_write, s_write;
    int do_server = 0, do_client = 0;
    int max_frag = 5 * 1024;
    int err_in_client = 0;
    int err_in_server = 0;

    bufsiz = count > 40 * 1024 ? 40 * 1024 : count;

    if ((cbuf = OPENSSL_zalloc(bufsiz)) == NULL)
        goto err;
    if ((sbuf = OPENSSL_zalloc(bufsiz)) == NULL)
        goto err;

    c_to_s = BIO_new(BIO_s_mem());
    s_to_c = BIO_new(BIO_s_mem());
    if ((s_to_c == NULL) || (c_to_s == NULL)) {
        ERR_print_errors(bio_err);
        goto err;
    }

    c_bio = BIO_new(BIO_f_ssl());
    s_bio = BIO_new(BIO_f_ssl());
    if ((c_bio == NULL) || (s_bio == NULL)) {
        ERR_print_errors(bio_err);
        goto err;
    }

    SSL_set_connect_state(c_ssl);
    SSL_set_bio(c_ssl, s_to_c, c_to_s);
    SSL_set_max_send_fragment(c_ssl, max_frag);
    BIO_set_ssl(c_bio, c_ssl, BIO_NOCLOSE);

    /*
     * We've just given our ref to these BIOs to c_ssl. We need another one to
     * give to s_ssl
     */
    if (!BIO_up_ref(c_to_s)) {
        /* c_to_s and s_to_c will get freed when we free c_ssl */
        c_to_s = NULL;
        s_to_c = NULL;
        goto err;
    }
    if (!BIO_up_ref(s_to_c)) {
        /* s_to_c will get freed when we free c_ssl */
        s_to_c = NULL;
        goto err;
    }

    SSL_set_accept_state(s_ssl);
    SSL_set_bio(s_ssl, c_to_s, s_to_c);

    /* We've used up all our refs to these now */
    c_to_s = NULL;
    s_to_c = NULL;

    SSL_set_max_send_fragment(s_ssl, max_frag);
    BIO_set_ssl(s_bio, s_ssl, BIO_NOCLOSE);

    c_r = 0;
    s_r = 1;
    c_w = 1;
    s_w = 0;
    c_write = 1, s_write = 0;

    /* We can always do writes */
    for (;;) {
        do_server = 0;
        do_client = 0;

        i = (int)BIO_pending(s_bio);
        if ((i && s_r) || s_w)
            do_server = 1;

        i = (int)BIO_pending(c_bio);
        if ((i && c_r) || c_w)
            do_client = 1;

        if (do_server && debug) {
            if (SSL_in_init(s_ssl))
                printf("server waiting in SSL_accept - %s\n",
                       SSL_state_string_long(s_ssl));
        }

        if (do_client && debug) {
            if (SSL_in_init(c_ssl))
                printf("client waiting in SSL_connect - %s\n",
                       SSL_state_string_long(c_ssl));
        }

        if (!do_client && !do_server) {
            fprintf(stdout, "ERROR IN STARTUP\n");
            ERR_print_errors(bio_err);
            goto err;
        }
        if (do_client && !(done & C_DONE)) {
            if (c_write) {
                j = (cw_num > bufsiz) ? (int)bufsiz : (int)cw_num;
                i = BIO_write(c_bio, cbuf, j);
                if (i < 0) {
                    c_r = 0;
                    c_w = 0;
                    if (BIO_should_retry(c_bio)) {
                        if (BIO_should_read(c_bio))
                            c_r = 1;
                        if (BIO_should_write(c_bio))
                            c_w = 1;
                    } else {
                        fprintf(stderr, "ERROR in CLIENT\n");
                        err_in_client = 1;
                        ERR_print_errors(bio_err);
                        goto err;
                    }
                } else if (i == 0) {
                    fprintf(stderr, "SSL CLIENT STARTUP FAILED\n");
                    goto err;
                } else {
                    if (debug)
                        printf("client wrote %d\n", i);
                    /* ok */
                    s_r = 1;
                    c_write = 0;
                    cw_num -= i;
                    if (max_frag > 1029)
                        SSL_set_max_send_fragment(c_ssl, max_frag -= 5);
                }
            } else {
                i = BIO_read(c_bio, cbuf, bufsiz);
                if (i < 0) {
                    c_r = 0;
                    c_w = 0;
                    if (BIO_should_retry(c_bio)) {
                        if (BIO_should_read(c_bio))
                            c_r = 1;
                        if (BIO_should_write(c_bio))
                            c_w = 1;
                    } else {
                        fprintf(stderr, "ERROR in CLIENT\n");
                        err_in_client = 1;
                        ERR_print_errors(bio_err);
                        goto err;
                    }
                } else if (i == 0) {
                    fprintf(stderr, "SSL CLIENT STARTUP FAILED\n");
                    goto err;
                } else {
                    if (debug)
                        printf("client read %d\n", i);
                    cr_num -= i;
                    if (sw_num > 0) {
                        s_write = 1;
                        s_w = 1;
                    }
                    if (cr_num <= 0) {
                        s_write = 1;
                        s_w = 1;
                        done = S_DONE | C_DONE;
                    }
                }
            }
        }

        if (do_server && !(done & S_DONE)) {
            if (!s_write) {
                i = BIO_read(s_bio, sbuf, bufsiz);
                if (i < 0) {
                    s_r = 0;
                    s_w = 0;
                    if (BIO_should_retry(s_bio)) {
                        if (BIO_should_read(s_bio))
                            s_r = 1;
                        if (BIO_should_write(s_bio))
                            s_w = 1;
                    } else {
                        fprintf(stderr, "ERROR in SERVER\n");
                        err_in_server = 1;
                        ERR_print_errors(bio_err);
                        goto err;
                    }
                } else if (i == 0) {
                    ERR_print_errors(bio_err);
                    fprintf(stderr,
                            "SSL SERVER STARTUP FAILED in SSL_read\n");
                    goto err;
                } else {
                    if (debug)
                        printf("server read %d\n", i);
                    sr_num -= i;
                    if (cw_num > 0) {
                        c_write = 1;
                        c_w = 1;
                    }
                    if (sr_num <= 0) {
                        s_write = 1;
                        s_w = 1;
                        c_write = 0;
                    }
                }
            } else {
                j = (sw_num > bufsiz) ? (int)bufsiz : (int)sw_num;
                i = BIO_write(s_bio, sbuf, j);
                if (i < 0) {
                    s_r = 0;
                    s_w = 0;
                    if (BIO_should_retry(s_bio)) {
                        if (BIO_should_read(s_bio))
                            s_r = 1;
                        if (BIO_should_write(s_bio))
                            s_w = 1;
                    } else {
                        fprintf(stderr, "ERROR in SERVER\n");
                        err_in_server = 1;
                        ERR_print_errors(bio_err);
                        goto err;
                    }
                } else if (i == 0) {
                    ERR_print_errors(bio_err);
                    fprintf(stderr,
                            "SSL SERVER STARTUP FAILED in SSL_write\n");
                    goto err;
                } else {
                    if (debug)
                        printf("server wrote %d\n", i);
                    sw_num -= i;
                    s_write = 0;
                    c_r = 1;
                    if (sw_num <= 0)
                        done |= S_DONE;
                    if (max_frag > 1029)
                        SSL_set_max_send_fragment(s_ssl, max_frag -= 5);
                }
            }
        }

        if ((done & S_DONE) && (done & C_DONE))
            break;
    }

    if (verbose)
        print_details(c_ssl, "DONE: ");
#ifndef OPENSSL_NO_NEXTPROTONEG
    if (verify_npn(c_ssl, s_ssl) < 0)
        goto err;
#endif
    if (verify_serverinfo() < 0) {
        fprintf(stderr, "Server info verify error\n");
        goto err;
    }
    if (custom_ext_error) {
        fprintf(stderr, "Custom extension error\n");
        goto err;
    }
    ret = EXIT_SUCCESS;
 err:
    BIO_free(c_to_s);
    BIO_free(s_to_c);
    BIO_free_all(c_bio);
    BIO_free_all(s_bio);
    OPENSSL_free(cbuf);
    OPENSSL_free(sbuf);

    if (should_negotiate != NULL && strcmp(should_negotiate, "fail-client") == 0)
        ret = (err_in_client != 0) ? EXIT_SUCCESS : EXIT_FAILURE;
    else if (should_negotiate != NULL && strcmp(should_negotiate, "fail-server") == 0)
        ret = (err_in_server != 0) ? EXIT_SUCCESS : EXIT_FAILURE;

    return ret;
}

static int verify_callback(int ok, X509_STORE_CTX *ctx)
{
    char *s, buf[256];

    s = X509_NAME_oneline(X509_get_subject_name(X509_STORE_CTX_get_current_cert(ctx)),
                          buf, sizeof(buf));
    if (s != NULL) {
        if (ok)
            printf("depth=%d %s\n", X509_STORE_CTX_get_error_depth(ctx), buf);
        else {
            fprintf(stderr, "depth=%d error=%d %s\n",
                    X509_STORE_CTX_get_error_depth(ctx),
                    X509_STORE_CTX_get_error(ctx), buf);
        }
    }

    if (ok == 0) {
        int i = X509_STORE_CTX_get_error(ctx);

        switch (i) {
        default:
            fprintf(stderr, "Error string: %s\n",
                    X509_verify_cert_error_string(i));
            break;
        case X509_V_ERR_CERT_NOT_YET_VALID:
        case X509_V_ERR_CERT_HAS_EXPIRED:
        case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
            ok = 1;
            break;
        }
    }

    return ok;
}

static int app_verify_callback(X509_STORE_CTX *ctx, void *arg)
{
    int ok = 1;
    struct app_verify_arg *cb_arg = arg;

    if (cb_arg->app_verify) {
        char *s = NULL, buf[256];
        X509 *c = X509_STORE_CTX_get0_cert(ctx);

        printf("In app_verify_callback, allowing cert. ");
        printf("Arg is: %s\n", cb_arg->string);
        printf("Finished printing do we have a context? 0x%p a cert? 0x%p\n",
                (void *)ctx, (void *)c);
        if (c)
            s = X509_NAME_oneline(X509_get_subject_name(c), buf, 256);
        if (s != NULL) {
            printf("cert depth=%d %s\n",
                    X509_STORE_CTX_get_error_depth(ctx), buf);
        }
        return 1;
    }

    ok = X509_verify_cert(ctx);

    return ok;
}

#ifndef OPENSSL_NO_PSK
/* convert the PSK key (psk_key) in ascii to binary (psk) */
static int psk_key2bn(const char *pskkey, unsigned char *psk,
                      unsigned int max_psk_len)
{
    int ret;
    BIGNUM *bn = NULL;

    ret = BN_hex2bn(&bn, pskkey);
    if (!ret) {
        BIO_printf(bio_err, "Could not convert PSK key '%s' to BIGNUM\n",
                   pskkey);
        BN_free(bn);
        return 0;
    }
    if (BN_num_bytes(bn) > (int)max_psk_len) {
        BIO_printf(bio_err,
                   "psk buffer of callback is too small (%d) for key (%d)\n",
                   max_psk_len, BN_num_bytes(bn));
        BN_free(bn);
        return 0;
    }
    ret = BN_bn2bin(bn, psk);
    BN_free(bn);
    return ret;
}

static unsigned int psk_client_callback(SSL *ssl, const char *hint,
                                        char *identity,
                                        unsigned int max_identity_len,
                                        unsigned char *psk,
                                        unsigned int max_psk_len)
{
    int ret;
    unsigned int psk_len = 0;

    ret = BIO_snprintf(identity, max_identity_len, "Client_identity");
    if (ret < 0)
        goto out_err;
    if (debug)
        fprintf(stderr, "client: created identity '%s' len=%d\n", identity,
                ret);
    ret = psk_key2bn(psk_key, psk, max_psk_len);
    if (ret < 0)
        goto out_err;
    psk_len = ret;
 out_err:
    return psk_len;
}

static unsigned int psk_server_callback(SSL *ssl, const char *identity,
                                        unsigned char *psk,
                                        unsigned int max_psk_len)
{
    unsigned int psk_len = 0;

    if (strcmp(identity, "Client_identity") != 0) {
        BIO_printf(bio_err, "server: PSK error: client identity not found\n");
        return 0;
    }
    psk_len = psk_key2bn(psk_key, psk, max_psk_len);
    return psk_len;
}
#endif
                                                                                                                                                                                   node-23.7.0/deps/openssl/openssl/test/ssl_test.c                                                    0000664 0000000 0000000 00000047701 14746647661 0021652 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright 2016-2021 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

#include <stdio.h>
#include <string.h>

#include <openssl/conf.h>
#include <openssl/err.h>
#include <openssl/ssl.h>
#include <openssl/provider.h>

#include "helpers/handshake.h"
#include "helpers/ssl_test_ctx.h"
#include "testutil.h"

static CONF *conf = NULL;
static OSSL_PROVIDER *defctxnull = NULL, *thisprov = NULL;
static OSSL_LIB_CTX *libctx = NULL;

/* Currently the section names are of the form test-<number>, e.g. test-15. */
#define MAX_TESTCASE_NAME_LENGTH 100

static const char *print_alert(int alert)
{
    return alert ? SSL_alert_desc_string_long(alert) : "no alert";
}

static int check_result(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)
{
    if (!TEST_int_eq(result->result, test_ctx->expected_result)) {
        TEST_info("ExpectedResult mismatch: expected %s, got %s.",
                  ssl_test_result_name(test_ctx->expected_result),
                  ssl_test_result_name(result->result));
        return 0;
    }
    return 1;
}

static int check_alerts(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)
{
    if (!TEST_int_eq(result->client_alert_sent,
                     result->client_alert_received)) {
        TEST_info("Client sent alert %s but server received %s.",
                  print_alert(result->client_alert_sent),
                  print_alert(result->client_alert_received));
        /*
         * We can't bail here because the peer doesn't always get far enough
         * to process a received alert. Specifically, in protocol version
         * negotiation tests, we have the following scenario.
         * Client supports TLS v1.2 only; Server supports TLS v1.1.
         * Client proposes TLS v1.2; server responds with 1.1;
         * Client now sends a protocol alert, using TLS v1.2 in the header.
         * The server, however, rejects the alert because of version mismatch
         * in the record layer; therefore, the server appears to never
         * receive the alert.
         */
        /* return 0; */
    }

    if (!TEST_int_eq(result->server_alert_sent,
                     result->server_alert_received)) {
        TEST_info("Server sent alert %s but client received %s.",
                  print_alert(result->server_alert_sent),
                  print_alert(result->server_alert_received));
        /* return 0; */
    }

    /* Tolerate an alert if one wasn't explicitly specified in the test. */
    if (test_ctx->expected_client_alert
        /*
         * The info callback alert value is computed as
         * (s->s3->send_alert[0] << 8) | s->s3->send_alert[1]
         * where the low byte is the alert code and the high byte is other stuff.
         */
        && (result->client_alert_sent & 0xff) != test_ctx->expected_client_alert) {
        TEST_error("ClientAlert mismatch: expected %s, got %s.",
                   print_alert(test_ctx->expected_client_alert),
                   print_alert(result->client_alert_sent));
        return 0;
    }

    if (test_ctx->expected_server_alert
        && (result->server_alert_sent & 0xff) != test_ctx->expected_server_alert) {
        TEST_error("ServerAlert mismatch: expected %s, got %s.",
                   print_alert(test_ctx->expected_server_alert),
                   print_alert(result->server_alert_sent));
        return 0;
    }

    if (!TEST_int_le(result->client_num_fatal_alerts_sent, 1))
        return 0;
    if (!TEST_int_le(result->server_num_fatal_alerts_sent, 1))
        return 0;
    return 1;
}

static int check_protocol(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)
{
    if (!TEST_int_eq(result->client_protocol, result->server_protocol)) {
        TEST_info("Client has protocol %s but server has %s.",
                  ssl_protocol_name(result->client_protocol),
                  ssl_protocol_name(result->server_protocol));
        return 0;
    }

    if (test_ctx->expected_protocol) {
        if (!TEST_int_eq(result->client_protocol,
                         test_ctx->expected_protocol)) {
            TEST_info("Protocol mismatch: expected %s, got %s.\n",
                      ssl_protocol_name(test_ctx->expected_protocol),
                      ssl_protocol_name(result->client_protocol));
            return 0;
        }
    }
    return 1;
}

static int check_servername(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)
{
    if (!TEST_int_eq(result->servername, test_ctx->expected_servername)) {
      TEST_info("Client ServerName mismatch, expected %s, got %s.",
                ssl_servername_name(test_ctx->expected_servername),
                ssl_servername_name(result->servername));
      return 0;
    }
  return 1;
}

static int check_session_ticket(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)
{
    if (test_ctx->session_ticket_expected == SSL_TEST_SESSION_TICKET_IGNORE)
        return 1;
    if (!TEST_int_eq(result->session_ticket,
                     test_ctx->session_ticket_expected)) {
        TEST_info("Client SessionTicketExpected mismatch, expected %s, got %s.",
                  ssl_session_ticket_name(test_ctx->session_ticket_expected),
                  ssl_session_ticket_name(result->session_ticket));
        return 0;
    }
    return 1;
}

static int check_session_id(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)
{
    if (test_ctx->session_id_expected == SSL_TEST_SESSION_ID_IGNORE)
        return 1;
    if (!TEST_int_eq(result->session_id, test_ctx->session_id_expected)) {
        TEST_info("Client SessionIdExpected mismatch, expected %s, got %s\n.",
                ssl_session_id_name(test_ctx->session_id_expected),
                ssl_session_id_name(result->session_id));
        return 0;
    }
    return 1;
}

static int check_compression(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)
{
    if (!TEST_int_eq(result->compression, test_ctx->compression_expected))
        return 0;
    return 1;
}
#ifndef OPENSSL_NO_NEXTPROTONEG
static int check_npn(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)
{
    int ret = 1;
    if (!TEST_str_eq(result->client_npn_negotiated,
                     result->server_npn_negotiated))
        ret = 0;
    if (!TEST_str_eq(test_ctx->expected_npn_protocol,
                     result->client_npn_negotiated))
        ret = 0;
    return ret;
}
#endif

static int check_alpn(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)
{
    int ret = 1;
    if (!TEST_str_eq(result->client_alpn_negotiated,
                     result->server_alpn_negotiated))
        ret = 0;
    if (!TEST_str_eq(test_ctx->expected_alpn_protocol,
                     result->client_alpn_negotiated))
        ret = 0;
    return ret;
}

static int check_session_ticket_app_data(HANDSHAKE_RESULT *result,
                                         SSL_TEST_CTX *test_ctx)
{
    size_t result_len = 0;
    size_t expected_len = 0;

    /* consider empty and NULL strings to be the same */
    if (result->result_session_ticket_app_data != NULL)
        result_len = strlen(result->result_session_ticket_app_data);
    if (test_ctx->expected_session_ticket_app_data != NULL)
        expected_len = strlen(test_ctx->expected_session_ticket_app_data);
    if (result_len == 0 && expected_len == 0)
        return 1;

    if (!TEST_str_eq(result->result_session_ticket_app_data,
                     test_ctx->expected_session_ticket_app_data))
        return 0;

    return 1;
}

static int check_resumption(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)
{
    if (!TEST_int_eq(result->client_resumed, result->server_resumed))
        return 0;
    if (!TEST_int_eq(result->client_resumed, test_ctx->resumption_expected))
        return 0;
    return 1;
}

static int check_nid(const char *name, int expected_nid, int nid)
{
    if (expected_nid == 0 || expected_nid == nid)
        return 1;
    TEST_error("%s type mismatch, %s vs %s\n",
               name, OBJ_nid2ln(expected_nid),
               nid == NID_undef ? "absent" : OBJ_nid2ln(nid));
    return 0;
}

static void print_ca_names(STACK_OF(X509_NAME) *names)
{
    int i;

    if (names == NULL || sk_X509_NAME_num(names) == 0) {
        TEST_note("    <empty>");
        return;
    }
    for (i = 0; i < sk_X509_NAME_num(names); i++) {
        X509_NAME_print_ex(bio_err, sk_X509_NAME_value(names, i), 4,
                           XN_FLAG_ONELINE);
        BIO_puts(bio_err, "\n");
    }
}

static int check_ca_names(const char *name,
                          STACK_OF(X509_NAME) *expected_names,
                          STACK_OF(X509_NAME) *names)
{
    int i;

    if (expected_names == NULL)
        return 1;
    if (names == NULL || sk_X509_NAME_num(names) == 0) {
        if (TEST_int_eq(sk_X509_NAME_num(expected_names), 0))
            return 1;
        goto err;
    }
    if (sk_X509_NAME_num(names) != sk_X509_NAME_num(expected_names))
        goto err;
    for (i = 0; i < sk_X509_NAME_num(names); i++) {
        if (!TEST_int_eq(X509_NAME_cmp(sk_X509_NAME_value(names, i),
                                       sk_X509_NAME_value(expected_names, i)),
                         0)) {
            goto err;
        }
    }
    return 1;
err:
    TEST_info("%s: list mismatch", name);
    TEST_note("Expected Names:");
    print_ca_names(expected_names);
    TEST_note("Received Names:");
    print_ca_names(names);
    return 0;
}

static int check_tmp_key(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)
{
    return check_nid("Tmp key", test_ctx->expected_tmp_key_type,
                     result->tmp_key_type);
}

static int check_server_cert_type(HANDSHAKE_RESULT *result,
                                  SSL_TEST_CTX *test_ctx)
{
    return check_nid("Server certificate", test_ctx->expected_server_cert_type,
                     result->server_cert_type);
}

static int check_server_sign_hash(HANDSHAKE_RESULT *result,
                                  SSL_TEST_CTX *test_ctx)
{
    return check_nid("Server signing hash", test_ctx->expected_server_sign_hash,
                     result->server_sign_hash);
}

static int check_server_sign_type(HANDSHAKE_RESULT *result,
                                  SSL_TEST_CTX *test_ctx)
{
    return check_nid("Server signing", test_ctx->expected_server_sign_type,
                     result->server_sign_type);
}

static int check_server_ca_names(HANDSHAKE_RESULT *result,
                                 SSL_TEST_CTX *test_ctx)
{
    return check_ca_names("Server CA names",
                          test_ctx->expected_server_ca_names,
                          result->server_ca_names);
}

static int check_client_cert_type(HANDSHAKE_RESULT *result,
                                  SSL_TEST_CTX *test_ctx)
{
    return check_nid("Client certificate", test_ctx->expected_client_cert_type,
                     result->client_cert_type);
}

static int check_client_sign_hash(HANDSHAKE_RESULT *result,
                                  SSL_TEST_CTX *test_ctx)
{
    return check_nid("Client signing hash", test_ctx->expected_client_sign_hash,
                     result->client_sign_hash);
}

static int check_client_sign_type(HANDSHAKE_RESULT *result,
                                  SSL_TEST_CTX *test_ctx)
{
    return check_nid("Client signing", test_ctx->expected_client_sign_type,
                     result->client_sign_type);
}

static int check_client_ca_names(HANDSHAKE_RESULT *result,
                                 SSL_TEST_CTX *test_ctx)
{
    return check_ca_names("Client CA names",
                          test_ctx->expected_client_ca_names,
                          result->client_ca_names);
}

static int check_cipher(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)
{
    if (test_ctx->expected_cipher == NULL)
        return 1;
    if (!TEST_ptr(result->cipher))
        return 0;
    if (!TEST_str_eq(test_ctx->expected_cipher,
                     result->cipher))
        return 0;
    return 1;
}

/*
 * This could be further simplified by constructing an expected
 * HANDSHAKE_RESULT, and implementing comparison methods for
 * its fields.
 */
static int check_test(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)
{
    int ret = 1;
    ret &= check_result(result, test_ctx);
    ret &= check_alerts(result, test_ctx);
    if (result->result == SSL_TEST_SUCCESS) {
        ret &= check_protocol(result, test_ctx);
        ret &= check_servername(result, test_ctx);
        ret &= check_session_ticket(result, test_ctx);
        ret &= check_compression(result, test_ctx);
        ret &= check_session_id(result, test_ctx);
        ret &= (result->session_ticket_do_not_call == 0);
#ifndef OPENSSL_NO_NEXTPROTONEG
        ret &= check_npn(result, test_ctx);
#endif
        ret &= check_cipher(result, test_ctx);
        ret &= check_alpn(result, test_ctx);
        ret &= check_session_ticket_app_data(result, test_ctx);
        ret &= check_resumption(result, test_ctx);
        ret &= check_tmp_key(result, test_ctx);
        ret &= check_server_cert_type(result, test_ctx);
        ret &= check_server_sign_hash(result, test_ctx);
        ret &= check_server_sign_type(result, test_ctx);
        ret &= check_server_ca_names(result, test_ctx);
        ret &= check_client_cert_type(result, test_ctx);
        ret &= check_client_sign_hash(result, test_ctx);
        ret &= check_client_sign_type(result, test_ctx);
        ret &= check_client_ca_names(result, test_ctx);
    }
    return ret;
}

static int test_handshake(int idx)
{
    int ret = 0;
    SSL_CTX *server_ctx = NULL, *server2_ctx = NULL, *client_ctx = NULL,
        *resume_server_ctx = NULL, *resume_client_ctx = NULL;
    SSL_TEST_CTX *test_ctx = NULL;
    HANDSHAKE_RESULT *result = NULL;
    char test_app[MAX_TESTCASE_NAME_LENGTH];

    BIO_snprintf(test_app, sizeof(test_app), "test-%d", idx);

    test_ctx = SSL_TEST_CTX_create(conf, test_app, libctx);
    if (!TEST_ptr(test_ctx))
        goto err;

#ifndef OPENSSL_NO_DTLS
    if (test_ctx->method == SSL_TEST_METHOD_DTLS) {
        server_ctx = SSL_CTX_new_ex(libctx, NULL, DTLS_server_method());
        if (!TEST_true(SSL_CTX_set_options(server_ctx,
                        SSL_OP_ALLOW_CLIENT_RENEGOTIATION))
                || !TEST_true(SSL_CTX_set_max_proto_version(server_ctx, 0)))
            goto err;
        if (test_ctx->extra.server.servername_callback !=
            SSL_TEST_SERVERNAME_CB_NONE) {
            if (!TEST_ptr(server2_ctx =
                            SSL_CTX_new_ex(libctx, NULL, DTLS_server_method()))
                    || !TEST_true(SSL_CTX_set_options(server2_ctx,
                            SSL_OP_ALLOW_CLIENT_RENEGOTIATION)))
                goto err;
        }
        client_ctx = SSL_CTX_new_ex(libctx, NULL, DTLS_client_method());
        if (!TEST_true(SSL_CTX_set_max_proto_version(client_ctx, 0)))
            goto err;
        if (test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_RESUME) {
            resume_server_ctx = SSL_CTX_new_ex(libctx, NULL,
                                               DTLS_server_method());
            if (!TEST_true(SSL_CTX_set_max_proto_version(resume_server_ctx, 0))
                    || !TEST_true(SSL_CTX_set_options(resume_server_ctx,
                            SSL_OP_ALLOW_CLIENT_RENEGOTIATION)))
                goto err;
            resume_client_ctx = SSL_CTX_new_ex(libctx, NULL,
                                               DTLS_client_method());
            if (!TEST_true(SSL_CTX_set_max_proto_version(resume_client_ctx, 0)))
                goto err;
            if (!TEST_ptr(resume_server_ctx)
                    || !TEST_ptr(resume_client_ctx))
                goto err;
        }
    }
#endif
    if (test_ctx->method == SSL_TEST_METHOD_TLS) {
#if !defined(OPENSSL_NO_TLS1_3) \
    && defined(OPENSSL_NO_EC) \
    && defined(OPENSSL_NO_DH)
        /* Without ec or dh there are no built-in groups for TLSv1.3 */
        int maxversion = TLS1_2_VERSION;
#else
        int maxversion = 0;
#endif

        server_ctx = SSL_CTX_new_ex(libctx, NULL, TLS_server_method());
        if (!TEST_true(SSL_CTX_set_max_proto_version(server_ctx, maxversion))
                || !TEST_true(SSL_CTX_set_options(server_ctx,
                            SSL_OP_ALLOW_CLIENT_RENEGOTIATION)))
            goto err;
        /* SNI on resumption isn't supported/tested yet. */
        if (test_ctx->extra.server.servername_callback !=
            SSL_TEST_SERVERNAME_CB_NONE) {
            if (!TEST_ptr(server2_ctx =
                            SSL_CTX_new_ex(libctx, NULL, TLS_server_method()))
                    || !TEST_true(SSL_CTX_set_options(server2_ctx,
                            SSL_OP_ALLOW_CLIENT_RENEGOTIATION)))
                goto err;
            if (!TEST_true(SSL_CTX_set_max_proto_version(server2_ctx,
                                                         maxversion)))
                goto err;
        }
        client_ctx = SSL_CTX_new_ex(libctx, NULL, TLS_client_method());
        if (!TEST_true(SSL_CTX_set_max_proto_version(client_ctx, maxversion)))
            goto err;

        if (test_ctx->handshake_mode == SSL_TEST_HANDSHAKE_RESUME) {
            resume_server_ctx = SSL_CTX_new_ex(libctx, NULL,
                                               TLS_server_method());
            if (!TEST_true(SSL_CTX_set_max_proto_version(resume_server_ctx,
                                                         maxversion))
                    || !TEST_true(SSL_CTX_set_options(resume_server_ctx,
                            SSL_OP_ALLOW_CLIENT_RENEGOTIATION)))
                goto err;
            resume_client_ctx = SSL_CTX_new_ex(libctx, NULL,
                                               TLS_client_method());
            if (!TEST_true(SSL_CTX_set_max_proto_version(resume_client_ctx,
                                                         maxversion)))
                goto err;
            if (!TEST_ptr(resume_server_ctx)
                    || !TEST_ptr(resume_client_ctx))
                goto err;
        }
    }

#ifdef OPENSSL_NO_AUTOLOAD_CONFIG
    if (!TEST_true(OPENSSL_init_ssl(OPENSSL_INIT_LOAD_CONFIG, NULL)))
        goto err;
#endif

    if (!TEST_ptr(server_ctx)
            || !TEST_ptr(client_ctx)
            || !TEST_int_gt(CONF_modules_load(conf, test_app, 0),  0))
        goto err;

    if (!SSL_CTX_config(server_ctx, "server")
        || !SSL_CTX_config(client_ctx, "client")) {
        goto err;
    }

    if (server2_ctx != NULL && !SSL_CTX_config(server2_ctx, "server2"))
        goto err;
    if (resume_server_ctx != NULL
        && !SSL_CTX_config(resume_server_ctx, "resume-server"))
        goto err;
    if (resume_client_ctx != NULL
        && !SSL_CTX_config(resume_client_ctx, "resume-client"))
        goto err;

    result = do_handshake(server_ctx, server2_ctx, client_ctx,
                          resume_server_ctx, resume_client_ctx, test_ctx);

    if (result != NULL)
        ret = check_test(result, test_ctx);

err:
    CONF_modules_unload(0);
    SSL_CTX_free(server_ctx);
    SSL_CTX_free(server2_ctx);
    SSL_CTX_free(client_ctx);
    SSL_CTX_free(resume_server_ctx);
    SSL_CTX_free(resume_client_ctx);
    SSL_TEST_CTX_free(test_ctx);
    HANDSHAKE_RESULT_free(result);
    return ret;
}

#define USAGE "conf_file module_name [module_conf_file]\n"
OPT_TEST_DECLARE_USAGE(USAGE)

int setup_tests(void)
{
    long num_tests;

    if (!test_skip_common_options()) {
        TEST_error("Error parsing test options\n");
        return 0;
    }

    if (!TEST_ptr(conf = NCONF_new(NULL))
            /* argv[1] should point to the test conf file */
            || !TEST_int_gt(NCONF_load(conf, test_get_argument(0), NULL), 0)
            || !TEST_int_ne(NCONF_get_number_e(conf, NULL, "num_tests",
                                               &num_tests), 0)) {
        TEST_error("usage: ssl_test %s", USAGE);
        return 0;
    }

    if (!test_arg_libctx(&libctx, &defctxnull, &thisprov, 1, USAGE))
        return 0;

    ADD_ALL_TESTS(test_handshake, (int)num_tests);
    return 1;
}

void cleanup_tests(void)
{
    NCONF_free(conf);
    OSSL_PROVIDER_unload(defctxnull);
    OSSL_PROVIDER_unload(thisprov);
    OSSL_LIB_CTX_free(libctx);
}
                                                               node-23.7.0/deps/openssl/openssl/test/ssl_test.tmpl                                                 0000664 0000000 0000000 00000010510 14746647661 0022370 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        [{-$testname-}]
ssl_conf = {-$testname-}-ssl

[{-$testname-}-ssl]
server = {-$testname-}-server
client = {-$testname-}-client{-
    # The following sections are optional.
    $OUT = "";
    if (%server2) {
        $OUT .= "\nserver2 = $testname-server2";
    } elsif ($reuse_server2) {
        $OUT .= "\nserver2 = $testname-server";
    }
    if (%resume_server) {
        $OUT .= "\nresume-server = $testname-resume-server";
    } elsif ($reuse_resume_server) {
        $OUT .= "\nresume-server = $testname-server";
    }
    if (%resume_client) {
        $OUT .= "\nresume-client = $testname-resume-client";
    } elsif ($reuse_resume_client) {
        $OUT .= "\nresume-client = $testname-client";
    }
-}

[{-$testname-}-server]
{-
    foreach my $key (sort keys %server) {
        # Emitted in the test section.
        next if ($key eq "extra");
        $OUT .= qq{$key} . " = " . qq{$server{$key}\n} if defined $server{$key};
    }
    if (%server2) {
        $OUT .= "\n[$testname-server2]\n";
        foreach my $key (sort keys %server2) {
            next if ($key eq "extra");
            $OUT .= qq{$key} . " = " . qq{$server2{$key}\n} if defined $server2{$key};
        }
    }
    if (%resume_server) {
        $OUT .= "\n[$testname-resume-server]\n";
        foreach my $key (sort keys %resume_server) {
            next if ($key eq "extra");
            $OUT .= qq{$key} . " = " . qq{$resume_server{$key}\n} if defined $resume_server{$key};
        }
    }
-}
[{-$testname-}-client]
{-
    foreach my $key (sort keys %client) {
        next if ($key eq "extra");
        $OUT .= qq{$key} . " = " . qq{$client{$key}\n} if defined $client{$key};
    }
    if (%resume_client) {
        $OUT .= "\n[$testname-resume-client]\n";
        foreach my $key (sort keys %resume_client) {
	    next if ($key eq "extra");
            $OUT .= qq{$key} . " = " . qq{$resume_client{$key}\n} if defined $resume_client{$key};
        }
    }
-}
[test-{-$idx-}]
{-
    foreach my $key (sort keys %test) {
        $OUT .= qq{$key} ." = " . qq{$test{$key}\n} if defined $test{$key};
    }

    # The extra server/client configuration sections.
    if ($server{"extra"}) {
       $OUT .= "server = $testname-server-extra\n";
    }
    if (%server2 && $server2{"extra"}) {
       $OUT .= "server2 = $testname-server2-extra\n";
    } elsif ($reuse_server2 && $server{"extra"}) {
       $OUT .= "server2 = $testname-server-extra\n";
    }
    if (%resume_server && $resume_server{"extra"}) {
       $OUT .= "resume-server = $testname-resume-server-extra\n";
    } elsif ($reuse_resume_server && $server{"extra"}) {
       $OUT .= "resume-server = $testname-server-extra\n";
    }
    if ($client{"extra"}) {
       $OUT .= "client = $testname-client-extra\n";
    }
    if (%resume_client && $resume_client{"extra"}) {
       $OUT .= "resume-client = $testname-resume-client-extra\n";
    } elsif ($reuse_resume_client && $client{"extra"}) {
       $OUT .= "resume-client = $testname-client-extra\n";
    }

    if ($server{"extra"}) {
        $OUT .= "\n[$testname-server-extra]\n";
        foreach my $key (sort keys %{$server{"extra"}}) {
            $OUT .= qq{$key} . " = " . qq{$server{"extra"}{$key}\n}
	    	 if defined $server{"extra"}{$key};
        }
    }
    if (%server2 && $server2{"extra"}) {
        $OUT .= "\n[$testname-server2-extra]\n";
        foreach my $key (sort keys %{$server2{"extra"}}) {
            $OUT .= qq{$key} . " = " . qq{$server2{"extra"}{$key}\n}
	    	 if defined $server2{"extra"}{$key};
        }
    }
   if (%resume_server && $resume_server{"extra"}) {
        $OUT .= "\n[$testname-resume-server-extra]\n";
        foreach my $key (sort keys %{$resume_server{"extra"}}) {
            $OUT .= qq{$key} . " = " . qq{$resume_server{"extra"}{$key}\n}
	    	 if defined $resume_server{"extra"}{$key};
        }
    }
   if ($client{"extra"}) {
        $OUT .= "\n[$testname-client-extra]\n";
        foreach my $key (sort keys %{$client{"extra"}}) {
            $OUT .= qq{$key} . " = " . qq{$client{"extra"}{$key}\n}
	    	 if defined $client{"extra"}{$key};
        }
   }
   if (%resume_client && $resume_client{"extra"}) {
        $OUT .= "\n[$testname-resume-client-extra]\n";
        foreach my $key (sort keys %{$resume_client{"extra"}}) {
            $OUT .= qq{$key} . " = " . qq{$resume_client{"extra"}{$key}\n}
	    	 if defined $resume_client{"extra"}{$key};
        }
    }
-}
                                                                                                                                                                                        node-23.7.0/deps/openssl/openssl/test/ssl_test_ctx_test.c                                           0000664 0000000 0000000 00000022211 14746647661 0023554 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

/*
 * Ideally, CONF should offer standard parsing methods and cover them
 * in tests. But since we have no CONF tests, we use a custom test for now.
 */

#include <stdio.h>
#include <string.h>

#include "internal/nelem.h"
#include "helpers/ssl_test_ctx.h"
#include "testutil.h"
#include <openssl/e_os2.h>
#include <openssl/err.h>
#include <openssl/conf.h>
#include <openssl/ssl.h>

static CONF *conf = NULL;

typedef struct ssl_test_ctx_test_fixture {
    const char *test_case_name;
    const char *test_section;
    /* Expected parsed configuration. */
    SSL_TEST_CTX *expected_ctx;
} SSL_TEST_CTX_TEST_FIXTURE;


static int clientconf_eq(SSL_TEST_CLIENT_CONF *conf1,
                         SSL_TEST_CLIENT_CONF *conf2)
{
    if (!TEST_int_eq(conf1->verify_callback, conf2->verify_callback)
            || !TEST_int_eq(conf1->servername, conf2->servername)
            || !TEST_str_eq(conf1->npn_protocols, conf2->npn_protocols)
            || !TEST_str_eq(conf1->alpn_protocols, conf2->alpn_protocols)
            || !TEST_int_eq(conf1->ct_validation, conf2->ct_validation)
            || !TEST_int_eq(conf1->max_fragment_len_mode,
                            conf2->max_fragment_len_mode))
        return 0;
    return 1;
}

static int serverconf_eq(SSL_TEST_SERVER_CONF *serv,
                         SSL_TEST_SERVER_CONF *serv2)
{
    if (!TEST_int_eq(serv->servername_callback, serv2->servername_callback)
            || !TEST_str_eq(serv->npn_protocols, serv2->npn_protocols)
            || !TEST_str_eq(serv->alpn_protocols, serv2->alpn_protocols)
            || !TEST_int_eq(serv->broken_session_ticket,
                            serv2->broken_session_ticket)
            || !TEST_str_eq(serv->session_ticket_app_data,
                            serv2->session_ticket_app_data)
            || !TEST_int_eq(serv->cert_status, serv2->cert_status))
        return 0;
    return 1;
}

static int extraconf_eq(SSL_TEST_EXTRA_CONF *extra,
                        SSL_TEST_EXTRA_CONF *extra2)
{
    if (!TEST_true(clientconf_eq(&extra->client, &extra2->client))
            || !TEST_true(serverconf_eq(&extra->server, &extra2->server))
            || !TEST_true(serverconf_eq(&extra->server2, &extra2->server2)))
        return 0;
    return 1;
}

static int testctx_eq(SSL_TEST_CTX *ctx, SSL_TEST_CTX *ctx2)
{
    if (!TEST_int_eq(ctx->method, ctx2->method)
            || !TEST_int_eq(ctx->handshake_mode, ctx2->handshake_mode)
            || !TEST_int_eq(ctx->app_data_size, ctx2->app_data_size)
            || !TEST_int_eq(ctx->max_fragment_size, ctx2->max_fragment_size)
            || !extraconf_eq(&ctx->extra, &ctx2->extra)
            || !extraconf_eq(&ctx->resume_extra, &ctx2->resume_extra)
            || !TEST_int_eq(ctx->expected_result, ctx2->expected_result)
            || !TEST_int_eq(ctx->expected_client_alert,
                            ctx2->expected_client_alert)
            || !TEST_int_eq(ctx->expected_server_alert,
                            ctx2->expected_server_alert)
            || !TEST_int_eq(ctx->expected_protocol, ctx2->expected_protocol)
            || !TEST_int_eq(ctx->expected_servername, ctx2->expected_servername)
            || !TEST_int_eq(ctx->session_ticket_expected,
                            ctx2->session_ticket_expected)
            || !TEST_int_eq(ctx->compression_expected,
                            ctx2->compression_expected)
            || !TEST_str_eq(ctx->expected_npn_protocol,
                            ctx2->expected_npn_protocol)
            || !TEST_str_eq(ctx->expected_alpn_protocol,
                            ctx2->expected_alpn_protocol)
            || !TEST_str_eq(ctx->expected_cipher,
                            ctx2->expected_cipher)
            || !TEST_str_eq(ctx->expected_session_ticket_app_data,
                            ctx2->expected_session_ticket_app_data)
            || !TEST_int_eq(ctx->resumption_expected,
                            ctx2->resumption_expected)
            || !TEST_int_eq(ctx->session_id_expected,
                            ctx2->session_id_expected))
        return 0;
    return 1;
}

static SSL_TEST_CTX_TEST_FIXTURE *set_up(const char *const test_case_name)
{
    SSL_TEST_CTX_TEST_FIXTURE *fixture;

    if (!TEST_ptr(fixture = OPENSSL_zalloc(sizeof(*fixture))))
        return NULL;
    fixture->test_case_name = test_case_name;
    if (!TEST_ptr(fixture->expected_ctx = SSL_TEST_CTX_new(NULL))) {
        OPENSSL_free(fixture);
        return NULL;
    }
    return fixture;
}

static int execute_test(SSL_TEST_CTX_TEST_FIXTURE *fixture)
{
    int success = 0;
    SSL_TEST_CTX *ctx;

    if (!TEST_ptr(ctx = SSL_TEST_CTX_create(conf, fixture->test_section,
                                            fixture->expected_ctx->libctx))
            || !testctx_eq(ctx, fixture->expected_ctx))
        goto err;

    success = 1;
 err:
    SSL_TEST_CTX_free(ctx);
    return success;
}

static void tear_down(SSL_TEST_CTX_TEST_FIXTURE *fixture)
{
    SSL_TEST_CTX_free(fixture->expected_ctx);
    OPENSSL_free(fixture);
}

#define SETUP_SSL_TEST_CTX_TEST_FIXTURE() \
    SETUP_TEST_FIXTURE(SSL_TEST_CTX_TEST_FIXTURE, set_up);
#define EXECUTE_SSL_TEST_CTX_TEST() \
    EXECUTE_TEST(execute_test, tear_down)

static int test_empty_configuration(void)
{
    SETUP_SSL_TEST_CTX_TEST_FIXTURE();
    fixture->test_section = "ssltest_default";
    fixture->expected_ctx->expected_result = SSL_TEST_SUCCESS;
    EXECUTE_SSL_TEST_CTX_TEST();
    return result;
}

static int test_good_configuration(void)
{
    SETUP_SSL_TEST_CTX_TEST_FIXTURE();
    fixture->test_section = "ssltest_good";
    fixture->expected_ctx->method = SSL_TEST_METHOD_DTLS;
    fixture->expected_ctx->handshake_mode = SSL_TEST_HANDSHAKE_RESUME;
    fixture->expected_ctx->app_data_size = 1024;
    fixture->expected_ctx->max_fragment_size = 2048;

    fixture->expected_ctx->expected_result = SSL_TEST_SERVER_FAIL;
    fixture->expected_ctx->expected_client_alert = SSL_AD_UNKNOWN_CA;
    fixture->expected_ctx->expected_server_alert = 0;  /* No alert. */
    fixture->expected_ctx->expected_protocol = TLS1_1_VERSION;
    fixture->expected_ctx->expected_servername = SSL_TEST_SERVERNAME_SERVER2;
    fixture->expected_ctx->session_ticket_expected = SSL_TEST_SESSION_TICKET_YES;
    fixture->expected_ctx->compression_expected = SSL_TEST_COMPRESSION_NO;
    fixture->expected_ctx->session_id_expected = SSL_TEST_SESSION_ID_IGNORE;
    fixture->expected_ctx->resumption_expected = 1;

    fixture->expected_ctx->extra.client.verify_callback =
        SSL_TEST_VERIFY_REJECT_ALL;
    fixture->expected_ctx->extra.client.servername = SSL_TEST_SERVERNAME_SERVER2;
    fixture->expected_ctx->extra.client.npn_protocols =
        OPENSSL_strdup("foo,bar");
    if (!TEST_ptr(fixture->expected_ctx->extra.client.npn_protocols))
        goto err;
    fixture->expected_ctx->extra.client.max_fragment_len_mode = 0;

    fixture->expected_ctx->extra.server.servername_callback =
        SSL_TEST_SERVERNAME_IGNORE_MISMATCH;
    fixture->expected_ctx->extra.server.broken_session_ticket = 1;

    fixture->expected_ctx->resume_extra.server2.alpn_protocols =
        OPENSSL_strdup("baz");
    if (!TEST_ptr(fixture->expected_ctx->resume_extra.server2.alpn_protocols))
        goto err;

    fixture->expected_ctx->resume_extra.client.ct_validation =
        SSL_TEST_CT_VALIDATION_STRICT;

    EXECUTE_SSL_TEST_CTX_TEST();
    return result;

err:
    tear_down(fixture);
    return 0;
}

static const char *bad_configurations[] = {
    "ssltest_unknown_option",
    "ssltest_wrong_section",
    "ssltest_unknown_expected_result",
    "ssltest_unknown_alert",
    "ssltest_unknown_protocol",
    "ssltest_unknown_verify_callback",
    "ssltest_unknown_servername",
    "ssltest_unknown_servername_callback",
    "ssltest_unknown_session_ticket_expected",
    "ssltest_unknown_compression_expected",
    "ssltest_unknown_session_id_expected",
    "ssltest_unknown_method",
    "ssltest_unknown_handshake_mode",
    "ssltest_unknown_resumption_expected",
    "ssltest_unknown_ct_validation",
    "ssltest_invalid_max_fragment_len",
};

static int test_bad_configuration(int idx)
{
    SSL_TEST_CTX *ctx;

    if (!TEST_ptr_null(ctx = SSL_TEST_CTX_create(conf,
                                                 bad_configurations[idx], NULL))) {
        SSL_TEST_CTX_free(ctx);
        return 0;
    }

    return 1;
}

OPT_TEST_DECLARE_USAGE("conf_file\n")

int setup_tests(void)
{
    if (!test_skip_common_options()) {
        TEST_error("Error parsing test options\n");
        return 0;
    }

    if (!TEST_ptr(conf = NCONF_new(NULL)))
        return 0;
    /* argument should point to test/ssl_test_ctx_test.cnf */
    if (!TEST_int_gt(NCONF_load(conf, test_get_argument(0), NULL), 0))
        return 0;

    ADD_TEST(test_empty_configuration);
    ADD_TEST(test_good_configuration);
    ADD_ALL_TESTS(test_bad_configuration, OSSL_NELEM(bad_configurations));
    return 1;
}

void cleanup_tests(void)
{
    NCONF_free(conf);
}
                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/openssl/openssl/test/ssl_test_ctx_test.cnf                                         0000664 0000000 0000000 00000004005 14746647661 0024101 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        [ssltest_default]

[ssltest_good]
client = ssltest_good_client_extra
server = ssltest_good_server_extra
resume-server2 = ssltest_good_resume_server2_extra
resume-client = ssltest_good_resume_client_extra

Method = DTLS
HandshakeMode = Resume
ApplicationData = 1024
MaxFragmentSize = 2048

ExpectedResult = ServerFail
ExpectedClientAlert = UnknownCA
ExpectedProtocol = TLSv1.1
ExpectedServerName = server2
SessionTicketExpected = Yes
ResumptionExpected = Yes

[ssltest_good_client_extra]
VerifyCallback = RejectAll
ServerName = server2
NPNProtocols = foo,bar

[ssltest_good_resume_client_extra]
CTValidation = Strict

[ssltest_good_server_extra]
ServerNameCallback = IgnoreMismatch
BrokenSessionTicket = Yes

[ssltest_good_resume_server2_extra]
ALPNProtocols = baz

[ssltest_unknown_option]
UnknownOption = Foo

[ssltest_wrong_section]
server = ssltest_wrong_section_server

[ssltest_wrong_section_server]
VerifyCallback = RejectAll

[ssltest_unknown_expected_result]
ExpectedResult = Foo

[ssltest_unknown_alert]
ExpectedServerAlert = Foo

[ssltest_unknown_protocol]
Protocol = Foo

[ssltest_unknown_verify_callback]
client = ssltest_unknown_verify_callback_client

[ssltest_unknown_verify_callback_client]
VerifyCallback = Foo

[ssltest_unknown_servername]
client = ssltest_unknown_servername_client

[ssltest_unknown_servername_client]
ServerName = Foo

[ssltest_unknown_servername_callback]
server = ssltest_unknown_servername_server

[ssltest_unknown_servername_server]
ServerNameCallback = Foo

[ssltest_unknown_session_ticket_expected]
SessionTicketExpected = Foo

[ssltest_unknown_compression_expected]
CompressionExpected = Foo

[ssltest_unknown_session_id_expected]
SessionIdExpected = Foo

[ssltest_unknown_method]
Method = TLS2

[ssltest_unknown_handshake_mode]
HandshakeMode = Foo

[ssltest_unknown_resumption_expected]
ResumptionExpected = Foo

[ssltest_unknown_ct_validation]
client = ssltest_unknown_ct_validation_client

[ssltest_unknown_ct_validation_client]
CTCallback = Foo

[ssltest_invalid_max_fragment_len]
MaxFragmentLenExt = 421
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/openssl/openssl/test/sslapitest.c                                                  0000664 0000000 0000000 00001415713 14746647661 0022210 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright 2016-2024 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

/*
 * We need access to the deprecated low level HMAC APIs for legacy purposes
 * when the deprecated calls are not hidden
 */
#ifndef OPENSSL_NO_DEPRECATED_3_0
# define OPENSSL_SUPPRESS_DEPRECATED
#endif

#include <stdio.h>
#include <string.h>

#include <openssl/opensslconf.h>
#include <openssl/bio.h>
#include <openssl/crypto.h>
#include <openssl/ssl.h>
#include <openssl/ocsp.h>
#include <openssl/srp.h>
#include <openssl/txt_db.h>
#include <openssl/aes.h>
#include <openssl/rand.h>
#include <openssl/core_names.h>
#include <openssl/core_dispatch.h>
#include <openssl/provider.h>
#include <openssl/param_build.h>
#include <openssl/x509v3.h>
#include <openssl/dh.h>
#include <openssl/engine.h>

#include "helpers/ssltestlib.h"
#include "testutil.h"
#include "testutil/output.h"
#include "internal/nelem.h"
#include "internal/ktls.h"
#include "../ssl/ssl_local.h"
#include "filterprov.h"

#undef OSSL_NO_USABLE_TLS1_3
#if defined(OPENSSL_NO_TLS1_3) \
    || (defined(OPENSSL_NO_EC) && defined(OPENSSL_NO_DH))
/*
 * If we don't have ec or dh then there are no built-in groups that are usable
 * with TLSv1.3
 */
# define OSSL_NO_USABLE_TLS1_3
#endif

/* Defined in tls-provider.c */
int tls_provider_init(const OSSL_CORE_HANDLE *handle,
                      const OSSL_DISPATCH *in,
                      const OSSL_DISPATCH **out,
                      void **provctx);

static OSSL_LIB_CTX *libctx = NULL;
static OSSL_PROVIDER *defctxnull = NULL;

#ifndef OSSL_NO_USABLE_TLS1_3

static SSL_SESSION *clientpsk = NULL;
static SSL_SESSION *serverpsk = NULL;
static const char *pskid = "Identity";
static const char *srvid;

static int use_session_cb(SSL *ssl, const EVP_MD *md, const unsigned char **id,
                          size_t *idlen, SSL_SESSION **sess);
static int find_session_cb(SSL *ssl, const unsigned char *identity,
                           size_t identity_len, SSL_SESSION **sess);

static int use_session_cb_cnt = 0;
static int find_session_cb_cnt = 0;

static SSL_SESSION *create_a_psk(SSL *ssl, size_t mdsize);
#endif

static char *certsdir = NULL;
static char *cert = NULL;
static char *privkey = NULL;
static char *cert2 = NULL;
static char *privkey2 = NULL;
static char *cert1024 = NULL;
static char *privkey1024 = NULL;
static char *cert3072 = NULL;
static char *privkey3072 = NULL;
static char *cert4096 = NULL;
static char *privkey4096 = NULL;
static char *cert8192 = NULL;
static char *privkey8192 = NULL;
static char *srpvfile = NULL;
static char *tmpfilename = NULL;
static char *dhfile = NULL;

static int is_fips = 0;

#define LOG_BUFFER_SIZE 2048
static char server_log_buffer[LOG_BUFFER_SIZE + 1] = {0};
static size_t server_log_buffer_index = 0;
static char client_log_buffer[LOG_BUFFER_SIZE + 1] = {0};
static size_t client_log_buffer_index = 0;
static int error_writing_log = 0;

#ifndef OPENSSL_NO_OCSP
static const unsigned char orespder[] = "Dummy OCSP Response";
static int ocsp_server_called = 0;
static int ocsp_client_called = 0;

static int cdummyarg = 1;
static X509 *ocspcert = NULL;
#endif

#define NUM_EXTRA_CERTS 40
#define CLIENT_VERSION_LEN      2

/*
 * This structure is used to validate that the correct number of log messages
 * of various types are emitted when emitting secret logs.
 */
struct sslapitest_log_counts {
    unsigned int rsa_key_exchange_count;
    unsigned int master_secret_count;
    unsigned int client_early_secret_count;
    unsigned int client_handshake_secret_count;
    unsigned int server_handshake_secret_count;
    unsigned int client_application_secret_count;
    unsigned int server_application_secret_count;
    unsigned int early_exporter_secret_count;
    unsigned int exporter_secret_count;
};


static int hostname_cb(SSL *s, int *al, void *arg)
{
    const char *hostname = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);

    if (hostname != NULL && (strcmp(hostname, "goodhost") == 0
                             || strcmp(hostname, "altgoodhost") == 0))
        return  SSL_TLSEXT_ERR_OK;

    return SSL_TLSEXT_ERR_NOACK;
}

static void client_keylog_callback(const SSL *ssl, const char *line)
{
    int line_length = strlen(line);

    /* If the log doesn't fit, error out. */
    if (client_log_buffer_index + line_length > sizeof(client_log_buffer) - 1) {
        TEST_info("Client log too full");
        error_writing_log = 1;
        return;
    }

    strcat(client_log_buffer, line);
    client_log_buffer_index += line_length;
    client_log_buffer[client_log_buffer_index++] = '\n';
}

static void server_keylog_callback(const SSL *ssl, const char *line)
{
    int line_length = strlen(line);

    /* If the log doesn't fit, error out. */
    if (server_log_buffer_index + line_length > sizeof(server_log_buffer) - 1) {
        TEST_info("Server log too full");
        error_writing_log = 1;
        return;
    }

    strcat(server_log_buffer, line);
    server_log_buffer_index += line_length;
    server_log_buffer[server_log_buffer_index++] = '\n';
}

static int compare_hex_encoded_buffer(const char *hex_encoded,
                                      size_t hex_length,
                                      const uint8_t *raw,
                                      size_t raw_length)
{
    size_t i, j;
    char hexed[3];

    if (!TEST_size_t_eq(raw_length * 2, hex_length))
        return 1;

    for (i = j = 0; i < raw_length && j + 1 < hex_length; i++, j += 2) {
        sprintf(hexed, "%02x", raw[i]);
        if (!TEST_int_eq(hexed[0], hex_encoded[j])
                || !TEST_int_eq(hexed[1], hex_encoded[j + 1]))
            return 1;
    }

    return 0;
}

static int test_keylog_output(char *buffer, const SSL *ssl,
                              const SSL_SESSION *session,
                              struct sslapitest_log_counts *expected)
{
    char *token = NULL;
    unsigned char actual_client_random[SSL3_RANDOM_SIZE] = {0};
    size_t client_random_size = SSL3_RANDOM_SIZE;
    unsigned char actual_master_key[SSL_MAX_MASTER_KEY_LENGTH] = {0};
    size_t master_key_size = SSL_MAX_MASTER_KEY_LENGTH;
    unsigned int rsa_key_exchange_count = 0;
    unsigned int master_secret_count = 0;
    unsigned int client_early_secret_count = 0;
    unsigned int client_handshake_secret_count = 0;
    unsigned int server_handshake_secret_count = 0;
    unsigned int client_application_secret_count = 0;
    unsigned int server_application_secret_count = 0;
    unsigned int early_exporter_secret_count = 0;
    unsigned int exporter_secret_count = 0;

    for (token = strtok(buffer, " \n"); token != NULL;
         token = strtok(NULL, " \n")) {
        if (strcmp(token, "RSA") == 0) {
            /*
             * Premaster secret. Tokens should be: 16 ASCII bytes of
             * hex-encoded encrypted secret, then the hex-encoded pre-master
             * secret.
             */
            if (!TEST_ptr(token = strtok(NULL, " \n")))
                return 0;
            if (!TEST_size_t_eq(strlen(token), 16))
                return 0;
            if (!TEST_ptr(token = strtok(NULL, " \n")))
                return 0;
            /*
             * We can't sensibly check the log because the premaster secret is
             * transient, and OpenSSL doesn't keep hold of it once the master
             * secret is generated.
             */
            rsa_key_exchange_count++;
        } else if (strcmp(token, "CLIENT_RANDOM") == 0) {
            /*
             * Master secret. Tokens should be: 64 ASCII bytes of hex-encoded
             * client random, then the hex-encoded master secret.
             */
            client_random_size = SSL_get_client_random(ssl,
                                                       actual_client_random,
                                                       SSL3_RANDOM_SIZE);
            if (!TEST_size_t_eq(client_random_size, SSL3_RANDOM_SIZE))
                return 0;

            if (!TEST_ptr(token = strtok(NULL, " \n")))
                return 0;
            if (!TEST_size_t_eq(strlen(token), 64))
                return 0;
            if (!TEST_false(compare_hex_encoded_buffer(token, 64,
                                                       actual_client_random,
                                                       client_random_size)))
                return 0;

            if (!TEST_ptr(token = strtok(NULL, " \n")))
                return 0;
            master_key_size = SSL_SESSION_get_master_key(session,
                                                         actual_master_key,
                                                         master_key_size);
            if (!TEST_size_t_ne(master_key_size, 0))
                return 0;
            if (!TEST_false(compare_hex_encoded_buffer(token, strlen(token),
                                                       actual_master_key,
                                                       master_key_size)))
                return 0;
            master_secret_count++;
        } else if (strcmp(token, "CLIENT_EARLY_TRAFFIC_SECRET") == 0
                    || strcmp(token, "CLIENT_HANDSHAKE_TRAFFIC_SECRET") == 0
                    || strcmp(token, "SERVER_HANDSHAKE_TRAFFIC_SECRET") == 0
                    || strcmp(token, "CLIENT_TRAFFIC_SECRET_0") == 0
                    || strcmp(token, "SERVER_TRAFFIC_SECRET_0") == 0
                    || strcmp(token, "EARLY_EXPORTER_SECRET") == 0
                    || strcmp(token, "EXPORTER_SECRET") == 0) {
            /*
             * TLSv1.3 secret. Tokens should be: 64 ASCII bytes of hex-encoded
             * client random, and then the hex-encoded secret. In this case,
             * we treat all of these secrets identically and then just
             * distinguish between them when counting what we saw.
             */
            if (strcmp(token, "CLIENT_EARLY_TRAFFIC_SECRET") == 0)
                client_early_secret_count++;
            else if (strcmp(token, "CLIENT_HANDSHAKE_TRAFFIC_SECRET") == 0)
                client_handshake_secret_count++;
            else if (strcmp(token, "SERVER_HANDSHAKE_TRAFFIC_SECRET") == 0)
                server_handshake_secret_count++;
            else if (strcmp(token, "CLIENT_TRAFFIC_SECRET_0") == 0)
                client_application_secret_count++;
            else if (strcmp(token, "SERVER_TRAFFIC_SECRET_0") == 0)
                server_application_secret_count++;
            else if (strcmp(token, "EARLY_EXPORTER_SECRET") == 0)
                early_exporter_secret_count++;
            else if (strcmp(token, "EXPORTER_SECRET") == 0)
                exporter_secret_count++;

            client_random_size = SSL_get_client_random(ssl,
                                                       actual_client_random,
                                                       SSL3_RANDOM_SIZE);
            if (!TEST_size_t_eq(client_random_size, SSL3_RANDOM_SIZE))
                return 0;

            if (!TEST_ptr(token = strtok(NULL, " \n")))
                return 0;
            if (!TEST_size_t_eq(strlen(token), 64))
                return 0;
            if (!TEST_false(compare_hex_encoded_buffer(token, 64,
                                                       actual_client_random,
                                                       client_random_size)))
                return 0;

            if (!TEST_ptr(token = strtok(NULL, " \n")))
                return 0;
        } else {
            TEST_info("Unexpected token %s\n", token);
            return 0;
        }
    }

    /* Got what we expected? */
    if (!TEST_size_t_eq(rsa_key_exchange_count,
                        expected->rsa_key_exchange_count)
            || !TEST_size_t_eq(master_secret_count,
                               expected->master_secret_count)
            || !TEST_size_t_eq(client_early_secret_count,
                               expected->client_early_secret_count)
            || !TEST_size_t_eq(client_handshake_secret_count,
                               expected->client_handshake_secret_count)
            || !TEST_size_t_eq(server_handshake_secret_count,
                               expected->server_handshake_secret_count)
            || !TEST_size_t_eq(client_application_secret_count,
                               expected->client_application_secret_count)
            || !TEST_size_t_eq(server_application_secret_count,
                               expected->server_application_secret_count)
            || !TEST_size_t_eq(early_exporter_secret_count,
                               expected->early_exporter_secret_count)
            || !TEST_size_t_eq(exporter_secret_count,
                               expected->exporter_secret_count))
        return 0;
    return 1;
}

#if !defined(OPENSSL_NO_TLS1_2) || defined(OSSL_NO_USABLE_TLS1_3)
static int test_keylog(void)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    struct sslapitest_log_counts expected;

    /* Clean up logging space */
    memset(&expected, 0, sizeof(expected));
    memset(client_log_buffer, 0, sizeof(client_log_buffer));
    memset(server_log_buffer, 0, sizeof(server_log_buffer));
    client_log_buffer_index = 0;
    server_log_buffer_index = 0;
    error_writing_log = 0;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey)))
        return 0;

    /* We cannot log the master secret for TLSv1.3, so we should forbid it. */
    SSL_CTX_set_options(cctx, SSL_OP_NO_TLSv1_3);
    SSL_CTX_set_options(sctx, SSL_OP_NO_TLSv1_3);

    /* We also want to ensure that we use RSA-based key exchange. */
    if (!TEST_true(SSL_CTX_set_cipher_list(cctx, "RSA")))
        goto end;

    if (!TEST_true(SSL_CTX_get_keylog_callback(cctx) == NULL)
            || !TEST_true(SSL_CTX_get_keylog_callback(sctx) == NULL))
        goto end;
    SSL_CTX_set_keylog_callback(cctx, client_keylog_callback);
    if (!TEST_true(SSL_CTX_get_keylog_callback(cctx)
                   == client_keylog_callback))
        goto end;
    SSL_CTX_set_keylog_callback(sctx, server_keylog_callback);
    if (!TEST_true(SSL_CTX_get_keylog_callback(sctx)
                   == server_keylog_callback))
        goto end;

    /* Now do a handshake and check that the logs have been written to. */
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE))
            || !TEST_false(error_writing_log)
            || !TEST_int_gt(client_log_buffer_index, 0)
            || !TEST_int_gt(server_log_buffer_index, 0))
        goto end;

    /*
     * Now we want to test that our output data was vaguely sensible. We
     * do that by using strtok and confirming that we have more or less the
     * data we expect. For both client and server, we expect to see one master
     * secret. The client should also see an RSA key exchange.
     */
    expected.rsa_key_exchange_count = 1;
    expected.master_secret_count = 1;
    if (!TEST_true(test_keylog_output(client_log_buffer, clientssl,
                                      SSL_get_session(clientssl), &expected)))
        goto end;

    expected.rsa_key_exchange_count = 0;
    if (!TEST_true(test_keylog_output(server_log_buffer, serverssl,
                                      SSL_get_session(serverssl), &expected)))
        goto end;

    testresult = 1;

end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}
#endif

#ifndef OSSL_NO_USABLE_TLS1_3
static int test_keylog_no_master_key(void)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    SSL_SESSION *sess = NULL;
    int testresult = 0;
    struct sslapitest_log_counts expected;
    unsigned char buf[1];
    size_t readbytes, written;

    /* Clean up logging space */
    memset(&expected, 0, sizeof(expected));
    memset(client_log_buffer, 0, sizeof(client_log_buffer));
    memset(server_log_buffer, 0, sizeof(server_log_buffer));
    client_log_buffer_index = 0;
    server_log_buffer_index = 0;
    error_writing_log = 0;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey))
        || !TEST_true(SSL_CTX_set_max_early_data(sctx,
                                                 SSL3_RT_MAX_PLAIN_LENGTH)))
        return 0;

    if (!TEST_true(SSL_CTX_get_keylog_callback(cctx) == NULL)
            || !TEST_true(SSL_CTX_get_keylog_callback(sctx) == NULL))
        goto end;

    SSL_CTX_set_keylog_callback(cctx, client_keylog_callback);
    if (!TEST_true(SSL_CTX_get_keylog_callback(cctx)
                   == client_keylog_callback))
        goto end;

    SSL_CTX_set_keylog_callback(sctx, server_keylog_callback);
    if (!TEST_true(SSL_CTX_get_keylog_callback(sctx)
                   == server_keylog_callback))
        goto end;

    /* Now do a handshake and check that the logs have been written to. */
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE))
            || !TEST_false(error_writing_log))
        goto end;

    /*
     * Now we want to test that our output data was vaguely sensible. For this
     * test, we expect no CLIENT_RANDOM entry because it doesn't make sense for
     * TLSv1.3, but we do expect both client and server to emit keys.
     */
    expected.client_handshake_secret_count = 1;
    expected.server_handshake_secret_count = 1;
    expected.client_application_secret_count = 1;
    expected.server_application_secret_count = 1;
    expected.exporter_secret_count = 1;
    if (!TEST_true(test_keylog_output(client_log_buffer, clientssl,
                                      SSL_get_session(clientssl), &expected))
            || !TEST_true(test_keylog_output(server_log_buffer, serverssl,
                                             SSL_get_session(serverssl),
                                             &expected)))
        goto end;

    /* Terminate old session and resume with early data. */
    sess = SSL_get1_session(clientssl);
    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    /* Reset key log */
    memset(client_log_buffer, 0, sizeof(client_log_buffer));
    memset(server_log_buffer, 0, sizeof(server_log_buffer));
    client_log_buffer_index = 0;
    server_log_buffer_index = 0;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl, sess))
            /* Here writing 0 length early data is enough. */
            || !TEST_true(SSL_write_early_data(clientssl, NULL, 0, &written))
            || !TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                                &readbytes),
                            SSL_READ_EARLY_DATA_ERROR)
            || !TEST_int_eq(SSL_get_early_data_status(serverssl),
                            SSL_EARLY_DATA_ACCEPTED)
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                          SSL_ERROR_NONE))
            || !TEST_true(SSL_session_reused(clientssl)))
        goto end;

    /* In addition to the previous entries, expect early secrets. */
    expected.client_early_secret_count = 1;
    expected.early_exporter_secret_count = 1;
    if (!TEST_true(test_keylog_output(client_log_buffer, clientssl,
                                      SSL_get_session(clientssl), &expected))
            || !TEST_true(test_keylog_output(server_log_buffer, serverssl,
                                             SSL_get_session(serverssl),
                                             &expected)))
        goto end;

    testresult = 1;

end:
    SSL_SESSION_free(sess);
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}
#endif

static int verify_retry_cb(X509_STORE_CTX *ctx, void *arg)
{
    int res = X509_verify_cert(ctx);
    int idx = SSL_get_ex_data_X509_STORE_CTX_idx();
    SSL *ssl;

    /* this should not happen but check anyway */
    if (idx < 0
        || (ssl = X509_STORE_CTX_get_ex_data(ctx, idx)) == NULL)
        return 0;

    if (res == 0 && X509_STORE_CTX_get_error(ctx) ==
        X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)
        /* indicate SSL_ERROR_WANT_RETRY_VERIFY */
        return SSL_set_retry_verify(ssl);

    return res;
}

static int test_client_cert_verify_cb(void)
{
    /* server key, cert, chain, and root */
    char *skey = test_mk_file_path(certsdir, "leaf.key");
    char *leaf = test_mk_file_path(certsdir, "leaf.pem");
    char *int2 = test_mk_file_path(certsdir, "subinterCA.pem");
    char *int1 = test_mk_file_path(certsdir, "interCA.pem");
    char *root = test_mk_file_path(certsdir, "rootCA.pem");
    X509 *crt1 = NULL, *crt2 = NULL;
    STACK_OF(X509) *server_chain;
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, NULL, NULL)))
        goto end;
    if (!TEST_int_eq(SSL_CTX_use_certificate_chain_file(sctx, leaf), 1)
            || !TEST_int_eq(SSL_CTX_use_PrivateKey_file(sctx, skey,
                                                        SSL_FILETYPE_PEM), 1)
            || !TEST_int_eq(SSL_CTX_check_private_key(sctx), 1))
        goto end;
    if (!TEST_true(SSL_CTX_load_verify_locations(cctx, root, NULL)))
        goto end;
    SSL_CTX_set_verify(cctx, SSL_VERIFY_PEER, NULL);
    SSL_CTX_set_cert_verify_callback(cctx, verify_retry_cb, NULL);
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL)))
        goto end;

    /* attempt SSL_connect() with incomplete server chain */
    if (!TEST_false(create_ssl_connection(serverssl, clientssl,
                                          SSL_ERROR_WANT_RETRY_VERIFY)))
        goto end;

    /* application provides intermediate certs needed to verify server cert */
    if (!TEST_ptr((crt1 = load_cert_pem(int1, libctx)))
        || !TEST_ptr((crt2 = load_cert_pem(int2, libctx)))
        || !TEST_ptr((server_chain = SSL_get_peer_cert_chain(clientssl))))
        goto end;
    /* add certs in reverse order to demonstrate real chain building */
    if (!TEST_true(sk_X509_push(server_chain, crt1)))
        goto end;
    crt1 = NULL;
    if (!TEST_true(sk_X509_push(server_chain, crt2)))
        goto end;
    crt2 = NULL;

    /* continue SSL_connect(), must now succeed with completed server chain */
    if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                         SSL_ERROR_NONE)))
        goto end;

    testresult = 1;

end:
    X509_free(crt1);
    X509_free(crt2);
    if (clientssl != NULL) {
        SSL_shutdown(clientssl);
        SSL_free(clientssl);
    }
    if (serverssl != NULL) {
        SSL_shutdown(serverssl);
        SSL_free(serverssl);
    }
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    OPENSSL_free(skey);
    OPENSSL_free(leaf);
    OPENSSL_free(int2);
    OPENSSL_free(int1);
    OPENSSL_free(root);

    return testresult;
}

static int test_ssl_build_cert_chain(void)
{
    int ret = 0;
    SSL_CTX *ssl_ctx = NULL;
    SSL *ssl = NULL;
    char *skey = test_mk_file_path(certsdir, "leaf.key");
    char *leaf_chain = test_mk_file_path(certsdir, "leaf-chain.pem");

    if (!TEST_ptr(ssl_ctx = SSL_CTX_new_ex(libctx, NULL, TLS_server_method())))
        goto end;
    if (!TEST_ptr(ssl = SSL_new(ssl_ctx)))
        goto end;
    /* leaf_chain contains leaf + subinterCA + interCA + rootCA */
    if (!TEST_int_eq(SSL_use_certificate_chain_file(ssl, leaf_chain), 1)
        || !TEST_int_eq(SSL_use_PrivateKey_file(ssl, skey, SSL_FILETYPE_PEM), 1)
        || !TEST_int_eq(SSL_check_private_key(ssl), 1))
        goto end;
    if (!TEST_true(SSL_build_cert_chain(ssl, SSL_BUILD_CHAIN_FLAG_NO_ROOT
                                             | SSL_BUILD_CHAIN_FLAG_CHECK)))
        goto end;
    ret = 1;
end:
    SSL_free(ssl);
    SSL_CTX_free(ssl_ctx);
    OPENSSL_free(leaf_chain);
    OPENSSL_free(skey);
    return ret;
}

static int get_password_cb(char *buf, int size, int rw_flag, void *userdata)
{
    static const char pass[] = "testpass";

    if (!TEST_int_eq(size, PEM_BUFSIZE))
        return -1;

    memcpy(buf, pass, sizeof(pass) - 1);
    return sizeof(pass) - 1;
}

static int test_ssl_ctx_build_cert_chain(void)
{
    int ret = 0;
    SSL_CTX *ctx = NULL;
    char *skey = test_mk_file_path(certsdir, "leaf-encrypted.key");
    char *leaf_chain = test_mk_file_path(certsdir, "leaf-chain.pem");

    if (!TEST_ptr(ctx = SSL_CTX_new_ex(libctx, NULL, TLS_server_method())))
        goto end;
    SSL_CTX_set_default_passwd_cb(ctx, get_password_cb);
    /* leaf_chain contains leaf + subinterCA + interCA + rootCA */
    if (!TEST_int_eq(SSL_CTX_use_certificate_chain_file(ctx, leaf_chain), 1)
        || !TEST_int_eq(SSL_CTX_use_PrivateKey_file(ctx, skey,
                                                    SSL_FILETYPE_PEM), 1)
        || !TEST_int_eq(SSL_CTX_check_private_key(ctx), 1))
        goto end;
    if (!TEST_true(SSL_CTX_build_cert_chain(ctx, SSL_BUILD_CHAIN_FLAG_NO_ROOT
                                                | SSL_BUILD_CHAIN_FLAG_CHECK)))
        goto end;
    ret = 1;
end:
    SSL_CTX_free(ctx);
    OPENSSL_free(leaf_chain);
    OPENSSL_free(skey);
    return ret;
}

#ifndef OPENSSL_NO_TLS1_2
static int full_client_hello_callback(SSL *s, int *al, void *arg)
{
    int *ctr = arg;
    const unsigned char *p;
    int *exts;
    /* We only configure two ciphers, but the SCSV is added automatically. */
#ifdef OPENSSL_NO_EC
    const unsigned char expected_ciphers[] = {0x00, 0x9d, 0x00, 0xff};
#else
    const unsigned char expected_ciphers[] = {0x00, 0x9d, 0xc0,
                                              0x2c, 0x00, 0xff};
#endif
    const int expected_extensions[] = {
#ifndef OPENSSL_NO_EC
                                       11, 10,
#endif
                                       35, 22, 23, 13};
    size_t len;

    /* Make sure we can defer processing and get called back. */
    if ((*ctr)++ == 0)
        return SSL_CLIENT_HELLO_RETRY;

    len = SSL_client_hello_get0_ciphers(s, &p);
    if (!TEST_mem_eq(p, len, expected_ciphers, sizeof(expected_ciphers))
            || !TEST_size_t_eq(
                       SSL_client_hello_get0_compression_methods(s, &p), 1)
            || !TEST_int_eq(*p, 0))
        return SSL_CLIENT_HELLO_ERROR;
    if (!SSL_client_hello_get1_extensions_present(s, &exts, &len))
        return SSL_CLIENT_HELLO_ERROR;
    if (len != OSSL_NELEM(expected_extensions) ||
        memcmp(exts, expected_extensions, len * sizeof(*exts)) != 0) {
        printf("ClientHello callback expected extensions mismatch\n");
        OPENSSL_free(exts);
        return SSL_CLIENT_HELLO_ERROR;
    }
    OPENSSL_free(exts);
    return SSL_CLIENT_HELLO_SUCCESS;
}

static int test_client_hello_cb(void)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testctr = 0, testresult = 0;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey)))
        goto end;
    SSL_CTX_set_client_hello_cb(sctx, full_client_hello_callback, &testctr);

    /* The gimpy cipher list we configure can't do TLS 1.3. */
    SSL_CTX_set_max_proto_version(cctx, TLS1_2_VERSION);

    if (!TEST_true(SSL_CTX_set_cipher_list(cctx,
                        "AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384"))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                             &clientssl, NULL, NULL))
            || !TEST_false(create_ssl_connection(serverssl, clientssl,
                        SSL_ERROR_WANT_CLIENT_HELLO_CB))
                /*
                 * Passing a -1 literal is a hack since
                 * the real value was lost.
                 * */
            || !TEST_int_eq(SSL_get_error(serverssl, -1),
                            SSL_ERROR_WANT_CLIENT_HELLO_CB)
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    testresult = 1;

end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

static int test_no_ems(void)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;

    if (!create_ssl_ctx_pair(libctx, TLS_server_method(), TLS_client_method(),
                             TLS1_VERSION, TLS1_2_VERSION,
                             &sctx, &cctx, cert, privkey)) {
        printf("Unable to create SSL_CTX pair\n");
        goto end;
    }

    SSL_CTX_set_options(sctx, SSL_OP_NO_EXTENDED_MASTER_SECRET);

    if (!create_ssl_objects(sctx, cctx, &serverssl, &clientssl, NULL, NULL)) {
        printf("Unable to create SSL objects\n");
        goto end;
    }

    if (!create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)) {
        printf("Creating SSL connection failed\n");
        goto end;
    }

    if (SSL_get_extms_support(serverssl)) {
        printf("Server reports Extended Master Secret support\n");
        goto end;
    }

    if (SSL_get_extms_support(clientssl)) {
        printf("Client reports Extended Master Secret support\n");
        goto end;
    }
    testresult = 1;

end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

/*
 * Very focused test to exercise a single case in the server-side state
 * machine, when the ChangeCipherState message needs to actually change
 * from one cipher to a different cipher (i.e., not changing from null
 * encryption to real encryption).
 */
static int test_ccs_change_cipher(void)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    SSL_SESSION *sess = NULL, *sesspre, *sesspost;
    int testresult = 0;
    int i;
    unsigned char buf;
    size_t readbytes;

    /*
     * Create a conection so we can resume and potentially (but not) use
     * a different cipher in the second connection.
     */
    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       TLS1_VERSION, TLS1_2_VERSION,
                                       &sctx, &cctx, cert, privkey))
            || !TEST_true(SSL_CTX_set_options(sctx, SSL_OP_NO_TICKET))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                          NULL, NULL))
            || !TEST_true(SSL_set_cipher_list(clientssl, "AES128-GCM-SHA256"))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE))
            || !TEST_ptr(sesspre = SSL_get0_session(serverssl))
            || !TEST_ptr(sess = SSL_get1_session(clientssl)))
        goto end;

    shutdown_ssl_connection(serverssl, clientssl);
    serverssl = clientssl = NULL;

    /* Resume, preferring a different cipher. Our server will force the
     * same cipher to be used as the initial handshake. */
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                          NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl, sess))
            || !TEST_true(SSL_set_cipher_list(clientssl, "AES256-GCM-SHA384:AES128-GCM-SHA256"))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE))
            || !TEST_true(SSL_session_reused(clientssl))
            || !TEST_true(SSL_session_reused(serverssl))
            || !TEST_ptr(sesspost = SSL_get0_session(serverssl))
            || !TEST_ptr_eq(sesspre, sesspost)
            || !TEST_int_eq(TLS1_CK_RSA_WITH_AES_128_GCM_SHA256,
                            SSL_CIPHER_get_id(SSL_get_current_cipher(clientssl))))
        goto end;
    shutdown_ssl_connection(serverssl, clientssl);
    serverssl = clientssl = NULL;

    /*
     * Now create a fresh connection and try to renegotiate a different
     * cipher on it.
     */
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL))
            || !TEST_true(SSL_set_cipher_list(clientssl, "AES128-GCM-SHA256"))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE))
            || !TEST_ptr(sesspre = SSL_get0_session(serverssl))
            || !TEST_true(SSL_set_cipher_list(clientssl, "AES256-GCM-SHA384"))
            || !TEST_true(SSL_renegotiate(clientssl))
            || !TEST_true(SSL_renegotiate_pending(clientssl)))
        goto end;
    /* Actually drive the renegotiation. */
    for (i = 0; i < 3; i++) {
        if (SSL_read_ex(clientssl, &buf, sizeof(buf), &readbytes) > 0) {
            if (!TEST_ulong_eq(readbytes, 0))
                goto end;
        } else if (!TEST_int_eq(SSL_get_error(clientssl, 0),
                                SSL_ERROR_WANT_READ)) {
            goto end;
        }
        if (SSL_read_ex(serverssl, &buf, sizeof(buf), &readbytes) > 0) {
            if (!TEST_ulong_eq(readbytes, 0))
                goto end;
        } else if (!TEST_int_eq(SSL_get_error(serverssl, 0),
                                SSL_ERROR_WANT_READ)) {
            goto end;
        }
    }
    /* sesspre and sesspost should be different since the cipher changed. */
    if (!TEST_false(SSL_renegotiate_pending(clientssl))
            || !TEST_false(SSL_session_reused(clientssl))
            || !TEST_false(SSL_session_reused(serverssl))
            || !TEST_ptr(sesspost = SSL_get0_session(serverssl))
            || !TEST_ptr_ne(sesspre, sesspost)
            || !TEST_int_eq(TLS1_CK_RSA_WITH_AES_256_GCM_SHA384,
                            SSL_CIPHER_get_id(SSL_get_current_cipher(clientssl))))
        goto end;

    shutdown_ssl_connection(serverssl, clientssl);
    serverssl = clientssl = NULL;

    testresult = 1;

end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    SSL_SESSION_free(sess);

    return testresult;
}
#endif

static int add_large_cert_chain(SSL_CTX *sctx)
{
    BIO *certbio = NULL;
    X509 *chaincert = NULL;
    int certlen;
    int ret = 0;
    int i;

    if (!TEST_ptr(certbio = BIO_new_file(cert, "r")))
        goto end;

    if (!TEST_ptr(chaincert = X509_new_ex(libctx, NULL)))
        goto end;

    if (PEM_read_bio_X509(certbio, &chaincert, NULL, NULL) == NULL)
        goto end;
    BIO_free(certbio);
    certbio = NULL;

    /*
     * We assume the supplied certificate is big enough so that if we add
     * NUM_EXTRA_CERTS it will make the overall message large enough. The
     * default buffer size is requested to be 16k, but due to the way BUF_MEM
     * works, it ends up allocating a little over 21k (16 * 4/3). So, in this
     * test we need to have a message larger than that.
     */
    certlen = i2d_X509(chaincert, NULL);
    OPENSSL_assert(certlen * NUM_EXTRA_CERTS >
                   (SSL3_RT_MAX_PLAIN_LENGTH * 4) / 3);
    for (i = 0; i < NUM_EXTRA_CERTS; i++) {
        if (!X509_up_ref(chaincert))
            goto end;
        if (!SSL_CTX_add_extra_chain_cert(sctx, chaincert)) {
            X509_free(chaincert);
            goto end;
        }
    }

    ret = 1;
 end:
    BIO_free(certbio);
    X509_free(chaincert);
    return ret;
}

static int execute_test_large_message(const SSL_METHOD *smeth,
                                      const SSL_METHOD *cmeth,
                                      int min_version, int max_version,
                                      int read_ahead)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;

    if (!TEST_true(create_ssl_ctx_pair(libctx, smeth, cmeth, min_version,
                                       max_version, &sctx, &cctx, cert,
                                       privkey)))
        goto end;

#ifdef OPENSSL_NO_DTLS1_2
    if (smeth == DTLS_server_method()) {
        /*
         * Default sigalgs are SHA1 based in <DTLS1.2 which is in security
         * level 0
         */
        if (!TEST_true(SSL_CTX_set_cipher_list(sctx, "DEFAULT:@SECLEVEL=0"))
                || !TEST_true(SSL_CTX_set_cipher_list(cctx,
                                                    "DEFAULT:@SECLEVEL=0")))
            goto end;
    }
#endif

    if (read_ahead) {
        /*
         * Test that read_ahead works correctly when dealing with large
         * records
         */
        SSL_CTX_set_read_ahead(cctx, 1);
    }

    if (!add_large_cert_chain(sctx))
        goto end;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    /*
     * Calling SSL_clear() first is not required but this tests that SSL_clear()
     * doesn't leak.
     */
    if (!TEST_true(SSL_clear(serverssl)))
        goto end;

    testresult = 1;
 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

#if !defined(OPENSSL_NO_SOCK) && !defined(OPENSSL_NO_KTLS) && \
    !(defined(OSSL_NO_USABLE_TLS1_3) && defined(OPENSSL_NO_TLS1_2))
/* sock must be connected */
static int ktls_chk_platform(int sock)
{
    if (!ktls_enable(sock))
        return 0;
    return 1;
}

static int ping_pong_query(SSL *clientssl, SSL *serverssl)
{
    static char count = 1;
    unsigned char cbuf[16000] = {0};
    unsigned char sbuf[16000];
    size_t err = 0;
    char crec_wseq_before[SEQ_NUM_SIZE];
    char crec_wseq_after[SEQ_NUM_SIZE];
    char crec_rseq_before[SEQ_NUM_SIZE];
    char crec_rseq_after[SEQ_NUM_SIZE];
    char srec_wseq_before[SEQ_NUM_SIZE];
    char srec_wseq_after[SEQ_NUM_SIZE];
    char srec_rseq_before[SEQ_NUM_SIZE];
    char srec_rseq_after[SEQ_NUM_SIZE];

    cbuf[0] = count++;
    memcpy(crec_wseq_before, &clientssl->rlayer.write_sequence, SEQ_NUM_SIZE);
    memcpy(crec_rseq_before, &clientssl->rlayer.read_sequence, SEQ_NUM_SIZE);
    memcpy(srec_wseq_before, &serverssl->rlayer.write_sequence, SEQ_NUM_SIZE);
    memcpy(srec_rseq_before, &serverssl->rlayer.read_sequence, SEQ_NUM_SIZE);

    if (!TEST_true(SSL_write(clientssl, cbuf, sizeof(cbuf)) == sizeof(cbuf)))
        goto end;

    while ((err = SSL_read(serverssl, &sbuf, sizeof(sbuf))) != sizeof(sbuf)) {
        if (SSL_get_error(serverssl, err) != SSL_ERROR_WANT_READ) {
            goto end;
        }
    }

    if (!TEST_true(SSL_write(serverssl, sbuf, sizeof(sbuf)) == sizeof(sbuf)))
        goto end;

    while ((err = SSL_read(clientssl, &cbuf, sizeof(cbuf))) != sizeof(cbuf)) {
        if (SSL_get_error(clientssl, err) != SSL_ERROR_WANT_READ) {
            goto end;
        }
    }

    memcpy(crec_wseq_after, &clientssl->rlayer.write_sequence, SEQ_NUM_SIZE);
    memcpy(crec_rseq_after, &clientssl->rlayer.read_sequence, SEQ_NUM_SIZE);
    memcpy(srec_wseq_after, &serverssl->rlayer.write_sequence, SEQ_NUM_SIZE);
    memcpy(srec_rseq_after, &serverssl->rlayer.read_sequence, SEQ_NUM_SIZE);

    /* verify the payload */
    if (!TEST_mem_eq(cbuf, sizeof(cbuf), sbuf, sizeof(sbuf)))
        goto end;

    /*
     * If ktls is used then kernel sequences are used instead of
     * OpenSSL sequences
     */
    if (!BIO_get_ktls_send(clientssl->wbio)) {
        if (!TEST_mem_ne(crec_wseq_before, SEQ_NUM_SIZE,
                         crec_wseq_after, SEQ_NUM_SIZE))
            goto end;
    } else {
        if (!TEST_mem_eq(crec_wseq_before, SEQ_NUM_SIZE,
                         crec_wseq_after, SEQ_NUM_SIZE))
            goto end;
    }

    if (!BIO_get_ktls_send(serverssl->wbio)) {
        if (!TEST_mem_ne(srec_wseq_before, SEQ_NUM_SIZE,
                         srec_wseq_after, SEQ_NUM_SIZE))
            goto end;
    } else {
        if (!TEST_mem_eq(srec_wseq_before, SEQ_NUM_SIZE,
                         srec_wseq_after, SEQ_NUM_SIZE))
            goto end;
    }

    if (!BIO_get_ktls_recv(clientssl->wbio)) {
        if (!TEST_mem_ne(crec_rseq_before, SEQ_NUM_SIZE,
                         crec_rseq_after, SEQ_NUM_SIZE))
            goto end;
    } else {
        if (!TEST_mem_eq(crec_rseq_before, SEQ_NUM_SIZE,
                         crec_rseq_after, SEQ_NUM_SIZE))
            goto end;
    }

    if (!BIO_get_ktls_recv(serverssl->wbio)) {
        if (!TEST_mem_ne(srec_rseq_before, SEQ_NUM_SIZE,
                         srec_rseq_after, SEQ_NUM_SIZE))
            goto end;
    } else {
        if (!TEST_mem_eq(srec_rseq_before, SEQ_NUM_SIZE,
                         srec_rseq_after, SEQ_NUM_SIZE))
            goto end;
    }

    return 1;
end:
    return 0;
}

static int execute_test_ktls(int cis_ktls, int sis_ktls,
                             int tls_version, const char *cipher)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int ktls_used = 0, testresult = 0;
    int cfd = -1, sfd = -1;
    int rx_supported;

    if (!TEST_true(create_test_sockets(&cfd, &sfd)))
        goto end;

    /* Skip this test if the platform does not support ktls */
    if (!ktls_chk_platform(cfd)) {
        testresult = TEST_skip("Kernel does not support KTLS");
        goto end;
    }

    if (is_fips && strstr(cipher, "CHACHA") != NULL) {
        testresult = TEST_skip("CHACHA is not supported in FIPS");
        goto end;
    }

    /* Create a session based on SHA-256 */
    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       tls_version, tls_version,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    if (tls_version == TLS1_3_VERSION) {
        if (!TEST_true(SSL_CTX_set_ciphersuites(cctx, cipher))
            || !TEST_true(SSL_CTX_set_ciphersuites(sctx, cipher)))
            goto end;
    } else {
        if (!TEST_true(SSL_CTX_set_cipher_list(cctx, cipher))
            || !TEST_true(SSL_CTX_set_cipher_list(sctx, cipher)))
            goto end;
    }

    if (!TEST_true(create_ssl_objects2(sctx, cctx, &serverssl,
                                       &clientssl, sfd, cfd)))
        goto end;

    if (cis_ktls) {
        if (!TEST_true(SSL_set_options(clientssl, SSL_OP_ENABLE_KTLS)))
            goto end;
    }

    if (sis_ktls) {
        if (!TEST_true(SSL_set_options(serverssl, SSL_OP_ENABLE_KTLS)))
            goto end;
    }

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    /*
     * The running kernel may not support a given cipher suite
     * or direction, so just check that KTLS isn't used when it
     * isn't enabled.
     */
    if (!cis_ktls) {
        if (!TEST_false(BIO_get_ktls_send(clientssl->wbio)))
            goto end;
    } else {
        if (BIO_get_ktls_send(clientssl->wbio))
            ktls_used = 1;
    }

    if (!sis_ktls) {
        if (!TEST_false(BIO_get_ktls_send(serverssl->wbio)))
            goto end;
    } else {
        if (BIO_get_ktls_send(serverssl->wbio))
            ktls_used = 1;
    }

#if defined(OPENSSL_NO_KTLS_RX)
    rx_supported = 0;
#else
    rx_supported = (tls_version != TLS1_3_VERSION);
#endif
    if (!cis_ktls || !rx_supported) {
        if (!TEST_false(BIO_get_ktls_recv(clientssl->rbio)))
            goto end;
    } else {
        if (BIO_get_ktls_send(clientssl->rbio))
            ktls_used = 1;
    }

    if (!sis_ktls || !rx_supported) {
        if (!TEST_false(BIO_get_ktls_recv(serverssl->rbio)))
            goto end;
    } else {
        if (BIO_get_ktls_send(serverssl->rbio))
            ktls_used = 1;
    }

    if ((cis_ktls || sis_ktls) && !ktls_used) {
        testresult = TEST_skip("KTLS not supported for %s cipher %s",
                               tls_version == TLS1_3_VERSION ? "TLS 1.3" :
                               "TLS 1.2", cipher);
        goto end;
    }

    if (!TEST_true(ping_pong_query(clientssl, serverssl)))
        goto end;

    testresult = 1;
end:
    if (clientssl) {
        SSL_shutdown(clientssl);
        SSL_free(clientssl);
    }
    if (serverssl) {
        SSL_shutdown(serverssl);
        SSL_free(serverssl);
    }
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    serverssl = clientssl = NULL;
    if (cfd != -1)
        close(cfd);
    if (sfd != -1)
        close(sfd);
    return testresult;
}

#define SENDFILE_SZ                     (16 * 4096)
#define SENDFILE_CHUNK                  (4 * 4096)
#define min(a,b)                        ((a) > (b) ? (b) : (a))

static int execute_test_ktls_sendfile(int tls_version, const char *cipher)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    unsigned char *buf, *buf_dst;
    BIO *out = NULL, *in = NULL;
    int cfd = -1, sfd = -1, ffd, err;
    ssize_t chunk_size = 0;
    off_t chunk_off = 0;
    int testresult = 0;
    FILE *ffdp;

    buf = OPENSSL_zalloc(SENDFILE_SZ);
    buf_dst = OPENSSL_zalloc(SENDFILE_SZ);
    if (!TEST_ptr(buf) || !TEST_ptr(buf_dst)
        || !TEST_true(create_test_sockets(&cfd, &sfd)))
        goto end;

    /* Skip this test if the platform does not support ktls */
    if (!ktls_chk_platform(sfd)) {
        testresult = TEST_skip("Kernel does not support KTLS");
        goto end;
    }

    if (is_fips && strstr(cipher, "CHACHA") != NULL) {
        testresult = TEST_skip("CHACHA is not supported in FIPS");
        goto end;
    }

    /* Create a session based on SHA-256 */
    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       tls_version, tls_version,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    if (tls_version == TLS1_3_VERSION) {
        if (!TEST_true(SSL_CTX_set_ciphersuites(cctx, cipher))
            || !TEST_true(SSL_CTX_set_ciphersuites(sctx, cipher)))
            goto end;
    } else {
        if (!TEST_true(SSL_CTX_set_cipher_list(cctx, cipher))
            || !TEST_true(SSL_CTX_set_cipher_list(sctx, cipher)))
            goto end;
    }

    if (!TEST_true(create_ssl_objects2(sctx, cctx, &serverssl,
                                       &clientssl, sfd, cfd)))
        goto end;

    if (!TEST_true(SSL_set_options(serverssl, SSL_OP_ENABLE_KTLS)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                         SSL_ERROR_NONE)))
        goto end;

    if (!BIO_get_ktls_send(serverssl->wbio)) {
        testresult = TEST_skip("Failed to enable KTLS for %s cipher %s",
                               tls_version == TLS1_3_VERSION ? "TLS 1.3" :
                               "TLS 1.2", cipher);
        goto end;
    }

    if (!TEST_int_gt(RAND_bytes_ex(libctx, buf, SENDFILE_SZ, 0), 0))
        goto end;

    out = BIO_new_file(tmpfilename, "wb");
    if (!TEST_ptr(out))
        goto end;

    if (BIO_write(out, buf, SENDFILE_SZ) != SENDFILE_SZ)
        goto end;

    BIO_free(out);
    out = NULL;
    in = BIO_new_file(tmpfilename, "rb");
    BIO_get_fp(in, &ffdp);
    ffd = fileno(ffdp);

    while (chunk_off < SENDFILE_SZ) {
        chunk_size = min(SENDFILE_CHUNK, SENDFILE_SZ - chunk_off);
        while ((err = SSL_sendfile(serverssl,
                                   ffd,
                                   chunk_off,
                                   chunk_size,
                                   0)) != chunk_size) {
            if (SSL_get_error(serverssl, err) != SSL_ERROR_WANT_WRITE)
                goto end;
        }
        while ((err = SSL_read(clientssl,
                               buf_dst + chunk_off,
                               chunk_size)) != chunk_size) {
            if (SSL_get_error(clientssl, err) != SSL_ERROR_WANT_READ)
                goto end;
        }

        /* verify the payload */
        if (!TEST_mem_eq(buf_dst + chunk_off,
                         chunk_size,
                         buf + chunk_off,
                         chunk_size))
            goto end;

        chunk_off += chunk_size;
    }

    testresult = 1;
end:
    if (clientssl) {
        SSL_shutdown(clientssl);
        SSL_free(clientssl);
    }
    if (serverssl) {
        SSL_shutdown(serverssl);
        SSL_free(serverssl);
    }
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    serverssl = clientssl = NULL;
    BIO_free(out);
    BIO_free(in);
    if (cfd != -1)
        close(cfd);
    if (sfd != -1)
        close(sfd);
    OPENSSL_free(buf);
    OPENSSL_free(buf_dst);
    return testresult;
}

static struct ktls_test_cipher {
    int tls_version;
    const char *cipher;
} ktls_test_ciphers[] = {
# if !defined(OPENSSL_NO_TLS1_2)
#  ifdef OPENSSL_KTLS_AES_GCM_128
    { TLS1_2_VERSION, "AES128-GCM-SHA256" },
#  endif
#  ifdef OPENSSL_KTLS_AES_CCM_128
    { TLS1_2_VERSION, "AES128-CCM"},
#  endif
#  ifdef OPENSSL_KTLS_AES_GCM_256
    { TLS1_2_VERSION, "AES256-GCM-SHA384"},
#  endif
#  ifdef OPENSSL_KTLS_CHACHA20_POLY1305
#    ifndef OPENSSL_NO_EC
    { TLS1_2_VERSION, "ECDHE-RSA-CHACHA20-POLY1305"},
#    endif
#  endif
# endif
# if !defined(OSSL_NO_USABLE_TLS1_3)
#  ifdef OPENSSL_KTLS_AES_GCM_128
    { TLS1_3_VERSION, "TLS_AES_128_GCM_SHA256" },
#  endif
#  ifdef OPENSSL_KTLS_AES_CCM_128
    { TLS1_3_VERSION, "TLS_AES_128_CCM_SHA256" },
#  endif
#  ifdef OPENSSL_KTLS_AES_GCM_256
    { TLS1_3_VERSION, "TLS_AES_256_GCM_SHA384" },
#  endif
#  ifdef OPENSSL_KTLS_CHACHA20_POLY1305
    { TLS1_3_VERSION, "TLS_CHACHA20_POLY1305_SHA256" },
#  endif
# endif
};

#define NUM_KTLS_TEST_CIPHERS \
    (sizeof(ktls_test_ciphers) / sizeof(ktls_test_ciphers[0]))

static int test_ktls(int test)
{
    struct ktls_test_cipher *cipher;
    int cis_ktls, sis_ktls;

    OPENSSL_assert(test / 4 < (int)NUM_KTLS_TEST_CIPHERS);
    cipher = &ktls_test_ciphers[test / 4];

    cis_ktls = (test & 1) != 0;
    sis_ktls = (test & 2) != 0;

    return execute_test_ktls(cis_ktls, sis_ktls, cipher->tls_version,
                             cipher->cipher);
}

static int test_ktls_sendfile(int tst)
{
    struct ktls_test_cipher *cipher;

    OPENSSL_assert(tst < (int)NUM_KTLS_TEST_CIPHERS);
    cipher = &ktls_test_ciphers[tst];

    return execute_test_ktls_sendfile(cipher->tls_version, cipher->cipher);
}
#endif

static int test_large_message_tls(void)
{
    return execute_test_large_message(TLS_server_method(), TLS_client_method(),
                                      TLS1_VERSION, 0, 0);
}

static int test_large_message_tls_read_ahead(void)
{
    return execute_test_large_message(TLS_server_method(), TLS_client_method(),
                                      TLS1_VERSION, 0, 1);
}

#ifndef OPENSSL_NO_DTLS
static int test_large_message_dtls(void)
{
# ifdef OPENSSL_NO_DTLS1_2
    /* Not supported in the FIPS provider */
    if (is_fips)
        return 1;
# endif
    /*
     * read_ahead is not relevant to DTLS because DTLS always acts as if
     * read_ahead is set.
     */
    return execute_test_large_message(DTLS_server_method(),
                                      DTLS_client_method(),
                                      DTLS1_VERSION, 0, 0);
}
#endif

/*
 * Test we can successfully send the maximum amount of application data. We
 * test each protocol version individually, each with and without EtM enabled.
 * TLSv1.3 doesn't use EtM so technically it is redundant to test both but it is
 * simpler this way. We also test all combinations with and without the
 * SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS option which affects the size of the
 * underlying buffer.
 */
static int test_large_app_data(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0, prot;
    unsigned char *msg, *buf = NULL;
    size_t written, readbytes;
    const SSL_METHOD *smeth = TLS_server_method();
    const SSL_METHOD *cmeth = TLS_client_method();

    switch (tst >> 2) {
    case 0:
#ifndef OSSL_NO_USABLE_TLS1_3
        prot = TLS1_3_VERSION;
        break;
#else
        return 1;
#endif

    case 1:
#ifndef OPENSSL_NO_TLS1_2
        prot = TLS1_2_VERSION;
        break;
#else
        return 1;
#endif

    case 2:
#ifndef OPENSSL_NO_TLS1_1
        prot = TLS1_1_VERSION;
        break;
#else
        return 1;
#endif

    case 3:
#ifndef OPENSSL_NO_TLS1
        prot = TLS1_VERSION;
        break;
#else
        return 1;
#endif

    case 4:
#ifndef OPENSSL_NO_SSL3
        prot = SSL3_VERSION;
        break;
#else
        return 1;
#endif

    case 5:
#ifndef OPENSSL_NO_DTLS1_2
        prot = DTLS1_2_VERSION;
        smeth = DTLS_server_method();
        cmeth = DTLS_client_method();
        break;
#else
        return 1;
#endif

    case 6:
#ifndef OPENSSL_NO_DTLS1
        prot = DTLS1_VERSION;
        smeth = DTLS_server_method();
        cmeth = DTLS_client_method();
        break;
#else
        return 1;
#endif

    default:
        /* Shouldn't happen */
        return 0;
    }

    if ((prot < TLS1_2_VERSION || prot == DTLS1_VERSION) && is_fips)
        return 1;

    /* Maximal sized message of zeros */
    msg = OPENSSL_zalloc(SSL3_RT_MAX_PLAIN_LENGTH);
    if (!TEST_ptr(msg))
        goto end;

    buf = OPENSSL_malloc(SSL3_RT_MAX_PLAIN_LENGTH + 1);
    if (!TEST_ptr(buf))
        goto end;
    /* Set whole buffer to all bits set */
    memset(buf, 0xff, SSL3_RT_MAX_PLAIN_LENGTH + 1);

    if (!TEST_true(create_ssl_ctx_pair(libctx, smeth, cmeth, prot, prot,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    if (prot < TLS1_2_VERSION || prot == DTLS1_VERSION) {
        /* Older protocol versions need SECLEVEL=0 due to SHA1 usage */
        if (!TEST_true(SSL_CTX_set_cipher_list(cctx, "DEFAULT:@SECLEVEL=0"))
                || !TEST_true(SSL_CTX_set_cipher_list(sctx,
                                                      "DEFAULT:@SECLEVEL=0")))
        goto end;
    }

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL)))
        goto end;

    if ((tst & 1) != 0) {
        /* Setting this option gives us a minimally sized underlying buffer */
        if (!TEST_true(SSL_set_options(serverssl,
                                       SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))
                || !TEST_true(SSL_set_options(clientssl,
                                              SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS)))
            goto end;
    }

    if ((tst & 2) != 0) {
        /*
         * Setting this option means the MAC is added before encryption
         * giving us a larger record for the encryption process
         */
        if (!TEST_true(SSL_set_options(serverssl, SSL_OP_NO_ENCRYPT_THEN_MAC))
                || !TEST_true(SSL_set_options(clientssl,
                                              SSL_OP_NO_ENCRYPT_THEN_MAC)))
            goto end;
    }

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    if (!TEST_true(SSL_write_ex(clientssl, msg, SSL3_RT_MAX_PLAIN_LENGTH,
                                &written))
            || !TEST_size_t_eq(written, SSL3_RT_MAX_PLAIN_LENGTH))
        goto end;

    /* We provide a buffer slightly larger than what we are actually expecting */
    if (!TEST_true(SSL_read_ex(serverssl, buf, SSL3_RT_MAX_PLAIN_LENGTH + 1,
                               &readbytes)))
        goto end;

    if (!TEST_mem_eq(msg, written, buf, readbytes))
        goto end;

    testresult = 1;
end:
    OPENSSL_free(msg);
    OPENSSL_free(buf);
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

#if !defined(OPENSSL_NO_TLS1_2) || !defined(OSSL_NO_USABLE_TLS1_3) \
    || !defined(OPENSSL_NO_DTLS)
static int execute_cleanse_plaintext(const SSL_METHOD *smeth,
                                     const SSL_METHOD *cmeth,
                                     int min_version, int max_version)
{
    size_t i;
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    SSL3_RECORD *rr;
    void *zbuf;

    static unsigned char cbuf[16000];
    static unsigned char sbuf[16000];

    if (!TEST_true(create_ssl_ctx_pair(libctx,
                                       smeth, cmeth,
                                       min_version, max_version,
                                       &sctx, &cctx, cert,
                                       privkey)))
        goto end;

# ifdef OPENSSL_NO_DTLS1_2
    if (smeth == DTLS_server_method()) {
        /* Not supported in the FIPS provider */
        if (is_fips) {
            testresult = 1;
            goto end;
        };
        /*
         * Default sigalgs are SHA1 based in <DTLS1.2 which is in security
         * level 0
         */
        if (!TEST_true(SSL_CTX_set_cipher_list(sctx, "DEFAULT:@SECLEVEL=0"))
                || !TEST_true(SSL_CTX_set_cipher_list(cctx,
                                                    "DEFAULT:@SECLEVEL=0")))
            goto end;
    }
# endif

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL)))
        goto end;

    if (!TEST_true(SSL_set_options(serverssl, SSL_OP_CLEANSE_PLAINTEXT)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                         SSL_ERROR_NONE)))
        goto end;

    for (i = 0; i < sizeof(cbuf); i++) {
        cbuf[i] = i & 0xff;
    }

    if (!TEST_int_eq(SSL_write(clientssl, cbuf, sizeof(cbuf)), sizeof(cbuf)))
        goto end;

    if (!TEST_int_eq(SSL_peek(serverssl, &sbuf, sizeof(sbuf)), sizeof(sbuf)))
        goto end;

    if (!TEST_mem_eq(cbuf, sizeof(cbuf), sbuf, sizeof(sbuf)))
        goto end;

    /*
     * Since we called SSL_peek(), we know the data in the record
     * layer is a plaintext record. We can gather the pointer to check
     * for zeroization after SSL_read().
     */
    rr = serverssl->rlayer.rrec;
    zbuf = &rr->data[rr->off];
    if (!TEST_int_eq(rr->length, sizeof(cbuf)))
        goto end;

    /*
     * After SSL_peek() the plaintext must still be stored in the
     * record.
     */
    if (!TEST_mem_eq(cbuf, sizeof(cbuf), zbuf, sizeof(cbuf)))
        goto end;

    memset(sbuf, 0, sizeof(sbuf));
    if (!TEST_int_eq(SSL_read(serverssl, &sbuf, sizeof(sbuf)), sizeof(sbuf)))
        goto end;

    if (!TEST_mem_eq(cbuf, sizeof(cbuf), sbuf, sizeof(cbuf)))
        goto end;

    /* Check if rbuf is cleansed */
    memset(cbuf, 0, sizeof(cbuf));
    if (!TEST_mem_eq(cbuf, sizeof(cbuf), zbuf, sizeof(cbuf)))
        goto end;

    testresult = 1;
 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}
#endif /*
        * !defined(OPENSSL_NO_TLS1_2) || !defined(OSSL_NO_USABLE_TLS1_3)
        * || !defined(OPENSSL_NO_DTLS)
        */

static int test_cleanse_plaintext(void)
{
#if !defined(OPENSSL_NO_TLS1_2)
    if (!TEST_true(execute_cleanse_plaintext(TLS_server_method(),
                                             TLS_client_method(),
                                             TLS1_2_VERSION,
                                             TLS1_2_VERSION)))
        return 0;

#endif

#if !defined(OSSL_NO_USABLE_TLS1_3)
    if (!TEST_true(execute_cleanse_plaintext(TLS_server_method(),
                                             TLS_client_method(),
                                             TLS1_3_VERSION,
                                             TLS1_3_VERSION)))
        return 0;
#endif

#if !defined(OPENSSL_NO_DTLS)

    if (!TEST_true(execute_cleanse_plaintext(DTLS_server_method(),
                                             DTLS_client_method(),
                                             DTLS1_VERSION,
                                             0)))
        return 0;
#endif
    return 1;
}

#ifndef OPENSSL_NO_OCSP
static int ocsp_server_cb(SSL *s, void *arg)
{
    int *argi = (int *)arg;
    unsigned char *copy = NULL;
    STACK_OF(OCSP_RESPID) *ids = NULL;
    OCSP_RESPID *id = NULL;

    if (*argi == 2) {
        /* In this test we are expecting exactly 1 OCSP_RESPID */
        SSL_get_tlsext_status_ids(s, &ids);
        if (ids == NULL || sk_OCSP_RESPID_num(ids) != 1)
            return SSL_TLSEXT_ERR_ALERT_FATAL;

        id = sk_OCSP_RESPID_value(ids, 0);
        if (id == NULL || !OCSP_RESPID_match_ex(id, ocspcert, libctx, NULL))
            return SSL_TLSEXT_ERR_ALERT_FATAL;
    } else if (*argi != 1) {
        return SSL_TLSEXT_ERR_ALERT_FATAL;
    }

    if (!TEST_ptr(copy = OPENSSL_memdup(orespder, sizeof(orespder))))
        return SSL_TLSEXT_ERR_ALERT_FATAL;

    if (!TEST_true(SSL_set_tlsext_status_ocsp_resp(s, copy,
                                                   sizeof(orespder)))) {
        OPENSSL_free(copy);
        return SSL_TLSEXT_ERR_ALERT_FATAL;
    }
    ocsp_server_called = 1;
    return SSL_TLSEXT_ERR_OK;
}

static int ocsp_client_cb(SSL *s, void *arg)
{
    int *argi = (int *)arg;
    const unsigned char *respderin;
    size_t len;

    if (*argi != 1 && *argi != 2)
        return 0;

    len = SSL_get_tlsext_status_ocsp_resp(s, &respderin);
    if (!TEST_mem_eq(orespder, len, respderin, len))
        return 0;

    ocsp_client_called = 1;
    return 1;
}

static int test_tlsext_status_type(void)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    STACK_OF(OCSP_RESPID) *ids = NULL;
    OCSP_RESPID *id = NULL;
    BIO *certbio = NULL;

    if (!create_ssl_ctx_pair(libctx, TLS_server_method(), TLS_client_method(),
                             TLS1_VERSION, 0,
                             &sctx, &cctx, cert, privkey))
        return 0;

    if (SSL_CTX_get_tlsext_status_type(cctx) != -1)
        goto end;

    /* First just do various checks getting and setting tlsext_status_type */

    clientssl = SSL_new(cctx);
    if (!TEST_int_eq(SSL_get_tlsext_status_type(clientssl), -1)
            || !TEST_true(SSL_set_tlsext_status_type(clientssl,
                                                      TLSEXT_STATUSTYPE_ocsp))
            || !TEST_int_eq(SSL_get_tlsext_status_type(clientssl),
                            TLSEXT_STATUSTYPE_ocsp))
        goto end;

    SSL_free(clientssl);
    clientssl = NULL;

    if (!SSL_CTX_set_tlsext_status_type(cctx, TLSEXT_STATUSTYPE_ocsp)
     || SSL_CTX_get_tlsext_status_type(cctx) != TLSEXT_STATUSTYPE_ocsp)
        goto end;

    clientssl = SSL_new(cctx);
    if (SSL_get_tlsext_status_type(clientssl) != TLSEXT_STATUSTYPE_ocsp)
        goto end;
    SSL_free(clientssl);
    clientssl = NULL;

    /*
     * Now actually do a handshake and check OCSP information is exchanged and
     * the callbacks get called
     */
    SSL_CTX_set_tlsext_status_cb(cctx, ocsp_client_cb);
    SSL_CTX_set_tlsext_status_arg(cctx, &cdummyarg);
    SSL_CTX_set_tlsext_status_cb(sctx, ocsp_server_cb);
    SSL_CTX_set_tlsext_status_arg(sctx, &cdummyarg);
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE))
            || !TEST_true(ocsp_client_called)
            || !TEST_true(ocsp_server_called))
        goto end;
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = NULL;
    clientssl = NULL;

    /* Try again but this time force the server side callback to fail */
    ocsp_client_called = 0;
    ocsp_server_called = 0;
    cdummyarg = 0;
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL))
                /* This should fail because the callback will fail */
            || !TEST_false(create_ssl_connection(serverssl, clientssl,
                                                 SSL_ERROR_NONE))
            || !TEST_false(ocsp_client_called)
            || !TEST_false(ocsp_server_called))
        goto end;
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = NULL;
    clientssl = NULL;

    /*
     * This time we'll get the client to send an OCSP_RESPID that it will
     * accept.
     */
    ocsp_client_called = 0;
    ocsp_server_called = 0;
    cdummyarg = 2;
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL)))
        goto end;

    /*
     * We'll just use any old cert for this test - it doesn't have to be an OCSP
     * specific one. We'll use the server cert.
     */
    if (!TEST_ptr(certbio = BIO_new_file(cert, "r"))
            || !TEST_ptr(id = OCSP_RESPID_new())
            || !TEST_ptr(ids = sk_OCSP_RESPID_new_null())
            || !TEST_ptr(ocspcert = X509_new_ex(libctx, NULL))
            || !TEST_ptr(PEM_read_bio_X509(certbio, &ocspcert, NULL, NULL))
            || !TEST_true(OCSP_RESPID_set_by_key_ex(id, ocspcert, libctx, NULL))
            || !TEST_true(sk_OCSP_RESPID_push(ids, id)))
        goto end;
    id = NULL;
    SSL_set_tlsext_status_ids(clientssl, ids);
    /* Control has been transferred */
    ids = NULL;

    BIO_free(certbio);
    certbio = NULL;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                         SSL_ERROR_NONE))
            || !TEST_true(ocsp_client_called)
            || !TEST_true(ocsp_server_called))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    sk_OCSP_RESPID_pop_free(ids, OCSP_RESPID_free);
    OCSP_RESPID_free(id);
    BIO_free(certbio);
    X509_free(ocspcert);
    ocspcert = NULL;

    return testresult;
}
#endif

#if !defined(OSSL_NO_USABLE_TLS1_3) || !defined(OPENSSL_NO_TLS1_2)
static int new_called, remove_called, get_called;

static int new_session_cb(SSL *ssl, SSL_SESSION *sess)
{
    new_called++;
    /*
     * sess has been up-refed for us, but we don't actually need it so free it
     * immediately.
     */
    SSL_SESSION_free(sess);
    return 1;
}

static void remove_session_cb(SSL_CTX *ctx, SSL_SESSION *sess)
{
    remove_called++;
}

static SSL_SESSION *get_sess_val = NULL;

static SSL_SESSION *get_session_cb(SSL *ssl, const unsigned char *id, int len,
                                   int *copy)
{
    get_called++;
    *copy = 1;
    return get_sess_val;
}

static int execute_test_session(int maxprot, int use_int_cache,
                                int use_ext_cache, long s_options)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *serverssl1 = NULL, *clientssl1 = NULL;
    SSL *serverssl2 = NULL, *clientssl2 = NULL;
# ifndef OPENSSL_NO_TLS1_1
    SSL *serverssl3 = NULL, *clientssl3 = NULL;
# endif
    SSL_SESSION *sess1 = NULL, *sess2 = NULL;
    int testresult = 0, numnewsesstick = 1;

    new_called = remove_called = 0;

    /* TLSv1.3 sends 2 NewSessionTickets */
    if (maxprot == TLS1_3_VERSION)
        numnewsesstick = 2;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey)))
        return 0;

    /*
     * Only allow the max protocol version so we can force a connection failure
     * later
     */
    SSL_CTX_set_min_proto_version(cctx, maxprot);
    SSL_CTX_set_max_proto_version(cctx, maxprot);

    /* Set up session cache */
    if (use_ext_cache) {
        SSL_CTX_sess_set_new_cb(cctx, new_session_cb);
        SSL_CTX_sess_set_remove_cb(cctx, remove_session_cb);
    }
    if (use_int_cache) {
        /* Also covers instance where both are set */
        SSL_CTX_set_session_cache_mode(cctx, SSL_SESS_CACHE_CLIENT);
    } else {
        SSL_CTX_set_session_cache_mode(cctx,
                                       SSL_SESS_CACHE_CLIENT
                                       | SSL_SESS_CACHE_NO_INTERNAL_STORE);
    }

    if (s_options) {
        SSL_CTX_set_options(sctx, s_options);
    }

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl1, &clientssl1,
                                      NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl1, clientssl1,
                                                SSL_ERROR_NONE))
            || !TEST_ptr(sess1 = SSL_get1_session(clientssl1)))
        goto end;

    /* Should fail because it should already be in the cache */
    if (use_int_cache && !TEST_false(SSL_CTX_add_session(cctx, sess1)))
        goto end;
    if (use_ext_cache
            && (!TEST_int_eq(new_called, numnewsesstick)

                || !TEST_int_eq(remove_called, 0)))
        goto end;

    new_called = remove_called = 0;
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl2,
                                      &clientssl2, NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl2, sess1))
            || !TEST_true(create_ssl_connection(serverssl2, clientssl2,
                                                SSL_ERROR_NONE))
            || !TEST_true(SSL_session_reused(clientssl2)))
        goto end;

    if (maxprot == TLS1_3_VERSION) {
        /*
         * In TLSv1.3 we should have created a new session even though we have
         * resumed. Since we attempted a resume we should also have removed the
         * old ticket from the cache so that we try to only use tickets once.
         */
        if (use_ext_cache
                && (!TEST_int_eq(new_called, 1)
                    || !TEST_int_eq(remove_called, 1)))
            goto end;
    } else {
        /*
         * In TLSv1.2 we expect to have resumed so no sessions added or
         * removed.
         */
        if (use_ext_cache
                && (!TEST_int_eq(new_called, 0)
                    || !TEST_int_eq(remove_called, 0)))
            goto end;
    }

    SSL_SESSION_free(sess1);
    if (!TEST_ptr(sess1 = SSL_get1_session(clientssl2)))
        goto end;
    shutdown_ssl_connection(serverssl2, clientssl2);
    serverssl2 = clientssl2 = NULL;

    new_called = remove_called = 0;
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl2,
                                      &clientssl2, NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl2, clientssl2,
                                                SSL_ERROR_NONE)))
        goto end;

    if (!TEST_ptr(sess2 = SSL_get1_session(clientssl2)))
        goto end;

    if (use_ext_cache
            && (!TEST_int_eq(new_called, numnewsesstick)
                || !TEST_int_eq(remove_called, 0)))
        goto end;

    new_called = remove_called = 0;
    /*
     * This should clear sess2 from the cache because it is a "bad" session.
     * See SSL_set_session() documentation.
     */
    if (!TEST_true(SSL_set_session(clientssl2, sess1)))
        goto end;
    if (use_ext_cache
            && (!TEST_int_eq(new_called, 0) || !TEST_int_eq(remove_called, 1)))
        goto end;
    if (!TEST_ptr_eq(SSL_get_session(clientssl2), sess1))
        goto end;

    if (use_int_cache) {
        /* Should succeeded because it should not already be in the cache */
        if (!TEST_true(SSL_CTX_add_session(cctx, sess2))
                || !TEST_true(SSL_CTX_remove_session(cctx, sess2)))
            goto end;
    }

    new_called = remove_called = 0;
    /* This shouldn't be in the cache so should fail */
    if (!TEST_false(SSL_CTX_remove_session(cctx, sess2)))
        goto end;

    if (use_ext_cache
            && (!TEST_int_eq(new_called, 0) || !TEST_int_eq(remove_called, 1)))
        goto end;

# if !defined(OPENSSL_NO_TLS1_1)
    new_called = remove_called = 0;
    /* Force a connection failure */
    SSL_CTX_set_max_proto_version(sctx, TLS1_1_VERSION);
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl3,
                                      &clientssl3, NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl3, sess1))
            /* This should fail because of the mismatched protocol versions */
            || !TEST_false(create_ssl_connection(serverssl3, clientssl3,
                                                 SSL_ERROR_NONE)))
        goto end;

    /* We should have automatically removed the session from the cache */
    if (use_ext_cache
            && (!TEST_int_eq(new_called, 0) || !TEST_int_eq(remove_called, 1)))
        goto end;

    /* Should succeed because it should not already be in the cache */
    if (use_int_cache && !TEST_true(SSL_CTX_add_session(cctx, sess2)))
        goto end;
# endif

    /* Now do some tests for server side caching */
    if (use_ext_cache) {
        SSL_CTX_sess_set_new_cb(cctx, NULL);
        SSL_CTX_sess_set_remove_cb(cctx, NULL);
        SSL_CTX_sess_set_new_cb(sctx, new_session_cb);
        SSL_CTX_sess_set_remove_cb(sctx, remove_session_cb);
        SSL_CTX_sess_set_get_cb(sctx, get_session_cb);
        get_sess_val = NULL;
    }

    SSL_CTX_set_session_cache_mode(cctx, 0);
    /* Internal caching is the default on the server side */
    if (!use_int_cache)
        SSL_CTX_set_session_cache_mode(sctx,
                                       SSL_SESS_CACHE_SERVER
                                       | SSL_SESS_CACHE_NO_INTERNAL_STORE);

    SSL_free(serverssl1);
    SSL_free(clientssl1);
    serverssl1 = clientssl1 = NULL;
    SSL_free(serverssl2);
    SSL_free(clientssl2);
    serverssl2 = clientssl2 = NULL;
    SSL_SESSION_free(sess1);
    sess1 = NULL;
    SSL_SESSION_free(sess2);
    sess2 = NULL;

    SSL_CTX_set_max_proto_version(sctx, maxprot);
    if (maxprot == TLS1_2_VERSION)
        SSL_CTX_set_options(sctx, SSL_OP_NO_TICKET);
    new_called = remove_called = get_called = 0;
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl1, &clientssl1,
                                      NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl1, clientssl1,
                                                SSL_ERROR_NONE))
            || !TEST_ptr(sess1 = SSL_get1_session(clientssl1))
            || !TEST_ptr(sess2 = SSL_get1_session(serverssl1)))
        goto end;

    if (use_int_cache) {
        if (maxprot == TLS1_3_VERSION && !use_ext_cache) {
            /*
             * In TLSv1.3 it should not have been added to the internal cache,
             * except in the case where we also have an external cache (in that
             * case it gets added to the cache in order to generate remove
             * events after timeout).
             */
            if (!TEST_false(SSL_CTX_remove_session(sctx, sess2)))
                goto end;
        } else {
            /* Should fail because it should already be in the cache */
            if (!TEST_false(SSL_CTX_add_session(sctx, sess2)))
                goto end;
        }
    }

    if (use_ext_cache) {
        SSL_SESSION *tmp = sess2;

        if (!TEST_int_eq(new_called, numnewsesstick)
                || !TEST_int_eq(remove_called, 0)
                || !TEST_int_eq(get_called, 0))
            goto end;
        /*
         * Delete the session from the internal cache to force a lookup from
         * the external cache. We take a copy first because
         * SSL_CTX_remove_session() also marks the session as non-resumable.
         */
        if (use_int_cache && maxprot != TLS1_3_VERSION) {
            if (!TEST_ptr(tmp = SSL_SESSION_dup(sess2))
                || !TEST_true(sess2->owner != NULL)
                || !TEST_true(tmp->owner == NULL)
                || !TEST_true(SSL_CTX_remove_session(sctx, sess2)))
                goto end;
            SSL_SESSION_free(sess2);
        }
        sess2 = tmp;
    }

    new_called = remove_called = get_called = 0;
    get_sess_val = sess2;
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl2,
                                      &clientssl2, NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl2, sess1))
            || !TEST_true(create_ssl_connection(serverssl2, clientssl2,
                                                SSL_ERROR_NONE))
            || !TEST_true(SSL_session_reused(clientssl2)))
        goto end;

    if (use_ext_cache) {
        if (!TEST_int_eq(remove_called, 0))
            goto end;

        if (maxprot == TLS1_3_VERSION) {
            if (!TEST_int_eq(new_called, 1)
                    || !TEST_int_eq(get_called, 0))
                goto end;
        } else {
            if (!TEST_int_eq(new_called, 0)
                    || !TEST_int_eq(get_called, 1))
                goto end;
        }
    }
    /*
     * Make a small cache, force out all other sessions but
     * sess2, try to add sess1, which should succeed. Then
     * make sure it's there by checking the owners. Despite
     * the timeouts, sess1 should have kicked out sess2
     */

    /* Make sess1 expire before sess2 */
    if (!TEST_long_gt(SSL_SESSION_set_time(sess1, 1000), 0)
            || !TEST_long_gt(SSL_SESSION_set_timeout(sess1, 1000), 0)
            || !TEST_long_gt(SSL_SESSION_set_time(sess2, 2000), 0)
            || !TEST_long_gt(SSL_SESSION_set_timeout(sess2, 2000), 0))
        goto end;

    if (!TEST_long_ne(SSL_CTX_sess_set_cache_size(sctx, 1), 0))
        goto end;

    /* Don't care about results - cache should only be sess2 at end */
    SSL_CTX_add_session(sctx, sess1);
    SSL_CTX_add_session(sctx, sess2);

    /* Now add sess1, and make sure it remains, despite timeout */
    if (!TEST_true(SSL_CTX_add_session(sctx, sess1))
            || !TEST_ptr(sess1->owner)
            || !TEST_ptr_null(sess2->owner))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl1);
    SSL_free(clientssl1);
    SSL_free(serverssl2);
    SSL_free(clientssl2);
# ifndef OPENSSL_NO_TLS1_1
    SSL_free(serverssl3);
    SSL_free(clientssl3);
# endif
    SSL_SESSION_free(sess1);
    SSL_SESSION_free(sess2);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}
#endif /* !defined(OSSL_NO_USABLE_TLS1_3) || !defined(OPENSSL_NO_TLS1_2) */

static int test_session_with_only_int_cache(void)
{
#ifndef OSSL_NO_USABLE_TLS1_3
    if (!execute_test_session(TLS1_3_VERSION, 1, 0, 0))
        return 0;
#endif

#ifndef OPENSSL_NO_TLS1_2
    return execute_test_session(TLS1_2_VERSION, 1, 0, 0);
#else
    return 1;
#endif
}

static int test_session_with_only_ext_cache(void)
{
#ifndef OSSL_NO_USABLE_TLS1_3
    if (!execute_test_session(TLS1_3_VERSION, 0, 1, 0))
        return 0;
#endif

#ifndef OPENSSL_NO_TLS1_2
    return execute_test_session(TLS1_2_VERSION, 0, 1, 0);
#else
    return 1;
#endif
}

static int test_session_with_both_cache(void)
{
#ifndef OSSL_NO_USABLE_TLS1_3
    if (!execute_test_session(TLS1_3_VERSION, 1, 1, 0))
        return 0;
#endif

#ifndef OPENSSL_NO_TLS1_2
    return execute_test_session(TLS1_2_VERSION, 1, 1, 0);
#else
    return 1;
#endif
}

static int test_session_wo_ca_names(void)
{
#ifndef OSSL_NO_USABLE_TLS1_3
    if (!execute_test_session(TLS1_3_VERSION, 1, 0, SSL_OP_DISABLE_TLSEXT_CA_NAMES))
        return 0;
#endif

#ifndef OPENSSL_NO_TLS1_2
    return execute_test_session(TLS1_2_VERSION, 1, 0, SSL_OP_DISABLE_TLSEXT_CA_NAMES);
#else
    return 1;
#endif
}

#ifndef OSSL_NO_USABLE_TLS1_3
static SSL_SESSION *sesscache[6];
static int do_cache;

static int new_cachesession_cb(SSL *ssl, SSL_SESSION *sess)
{
    if (do_cache) {
        sesscache[new_called] = sess;
    } else {
        /* We don't need the reference to the session, so free it */
        SSL_SESSION_free(sess);
    }
    new_called++;

    return 1;
}

static int post_handshake_verify(SSL *sssl, SSL *cssl)
{
    SSL_set_verify(sssl, SSL_VERIFY_PEER, NULL);
    if (!TEST_true(SSL_verify_client_post_handshake(sssl)))
        return 0;

    /* Start handshake on the server and client */
    if (!TEST_int_eq(SSL_do_handshake(sssl), 1)
            || !TEST_int_le(SSL_read(cssl, NULL, 0), 0)
            || !TEST_int_le(SSL_read(sssl, NULL, 0), 0)
            || !TEST_true(create_ssl_connection(sssl, cssl,
                                                SSL_ERROR_NONE)))
        return 0;

    return 1;
}

static int setup_ticket_test(int stateful, int idx, SSL_CTX **sctx,
                             SSL_CTX **cctx)
{
    int sess_id_ctx = 1;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       sctx, cctx, cert, privkey))
            || !TEST_true(SSL_CTX_set_num_tickets(*sctx, idx))
            || !TEST_true(SSL_CTX_set_session_id_context(*sctx,
                                                         (void *)&sess_id_ctx,
                                                         sizeof(sess_id_ctx))))
        return 0;

    if (stateful)
        SSL_CTX_set_options(*sctx, SSL_OP_NO_TICKET);

    SSL_CTX_set_session_cache_mode(*cctx, SSL_SESS_CACHE_CLIENT
                                          | SSL_SESS_CACHE_NO_INTERNAL_STORE);
    SSL_CTX_sess_set_new_cb(*cctx, new_cachesession_cb);

    return 1;
}

static int check_resumption(int idx, SSL_CTX *sctx, SSL_CTX *cctx, int succ)
{
    SSL *serverssl = NULL, *clientssl = NULL;
    int i;

    /* Test that we can resume with all the tickets we got given */
    for (i = 0; i < idx * 2; i++) {
        new_called = 0;
        if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                              &clientssl, NULL, NULL))
                || !TEST_true(SSL_set_session(clientssl, sesscache[i])))
            goto end;

        SSL_set_post_handshake_auth(clientssl, 1);

        if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                                    SSL_ERROR_NONE)))
            goto end;

        /*
         * Following a successful resumption we only get 1 ticket. After a
         * failed one we should get idx tickets.
         */
        if (succ) {
            if (!TEST_true(SSL_session_reused(clientssl))
                    || !TEST_int_eq(new_called, 1))
                goto end;
        } else {
            if (!TEST_false(SSL_session_reused(clientssl))
                    || !TEST_int_eq(new_called, idx))
                goto end;
        }

        new_called = 0;
        /* After a post-handshake authentication we should get 1 new ticket */
        if (succ
                && (!post_handshake_verify(serverssl, clientssl)
                    || !TEST_int_eq(new_called, 1)))
            goto end;

        SSL_shutdown(clientssl);
        SSL_shutdown(serverssl);
        SSL_free(serverssl);
        SSL_free(clientssl);
        serverssl = clientssl = NULL;
        SSL_SESSION_free(sesscache[i]);
        sesscache[i] = NULL;
    }

    return 1;

 end:
    SSL_free(clientssl);
    SSL_free(serverssl);
    return 0;
}

static int test_tickets(int stateful, int idx)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *serverssl = NULL, *clientssl = NULL;
    int testresult = 0;
    size_t j;

    /* idx is the test number, but also the number of tickets we want */

    new_called = 0;
    do_cache = 1;

    if (!setup_ticket_test(stateful, idx, &sctx, &cctx))
        goto end;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                          &clientssl, NULL, NULL)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE))
               /* Check we got the number of tickets we were expecting */
            || !TEST_int_eq(idx, new_called))
        goto end;

    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    clientssl = serverssl = NULL;
    sctx = cctx = NULL;

    /*
     * Now we try to resume with the tickets we previously created. The
     * resumption attempt is expected to fail (because we're now using a new
     * SSL_CTX). We should see idx number of tickets issued again.
     */

    /* Stop caching sessions - just count them */
    do_cache = 0;

    if (!setup_ticket_test(stateful, idx, &sctx, &cctx))
        goto end;

    if (!check_resumption(idx, sctx, cctx, 0))
        goto end;

    /* Start again with caching sessions */
    new_called = 0;
    do_cache = 1;
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    sctx = cctx = NULL;

    if (!setup_ticket_test(stateful, idx, &sctx, &cctx))
        goto end;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                          &clientssl, NULL, NULL)))
        goto end;

    SSL_set_post_handshake_auth(clientssl, 1);

    if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE))
               /* Check we got the number of tickets we were expecting */
            || !TEST_int_eq(idx, new_called))
        goto end;

    /* After a post-handshake authentication we should get new tickets issued */
    if (!post_handshake_verify(serverssl, clientssl)
            || !TEST_int_eq(idx * 2, new_called))
        goto end;

    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    /* Stop caching sessions - just count them */
    do_cache = 0;

    /*
     * Check we can resume with all the tickets we created. This time around the
     * resumptions should all be successful.
     */
    if (!check_resumption(idx, sctx, cctx, 1))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    for (j = 0; j < OSSL_NELEM(sesscache); j++) {
        SSL_SESSION_free(sesscache[j]);
        sesscache[j] = NULL;
    }
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

static int test_stateless_tickets(int idx)
{
    return test_tickets(0, idx);
}

static int test_stateful_tickets(int idx)
{
    return test_tickets(1, idx);
}

static int test_psk_tickets(void)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *serverssl = NULL, *clientssl = NULL;
    int testresult = 0;
    int sess_id_ctx = 1;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, NULL, NULL))
            || !TEST_true(SSL_CTX_set_session_id_context(sctx,
                                                         (void *)&sess_id_ctx,
                                                         sizeof(sess_id_ctx))))
        goto end;

    SSL_CTX_set_session_cache_mode(cctx, SSL_SESS_CACHE_CLIENT
                                         | SSL_SESS_CACHE_NO_INTERNAL_STORE);
    SSL_CTX_set_psk_use_session_callback(cctx, use_session_cb);
    SSL_CTX_set_psk_find_session_callback(sctx, find_session_cb);
    SSL_CTX_sess_set_new_cb(cctx, new_session_cb);
    use_session_cb_cnt = 0;
    find_session_cb_cnt = 0;
    srvid = pskid;
    new_called = 0;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL)))
        goto end;
    clientpsk = serverpsk = create_a_psk(clientssl, SHA384_DIGEST_LENGTH);
    if (!TEST_ptr(clientpsk))
        goto end;
    SSL_SESSION_up_ref(clientpsk);

    if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE))
            || !TEST_int_eq(1, find_session_cb_cnt)
            || !TEST_int_eq(1, use_session_cb_cnt)
               /* We should always get 1 ticket when using external PSK */
            || !TEST_int_eq(1, new_called))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    SSL_SESSION_free(clientpsk);
    SSL_SESSION_free(serverpsk);
    clientpsk = serverpsk = NULL;

    return testresult;
}

static int test_extra_tickets(int idx)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *serverssl = NULL, *clientssl = NULL;
    BIO *bretry = BIO_new(bio_s_always_retry());
    BIO *tmp = NULL;
    int testresult = 0;
    int stateful = 0;
    size_t nbytes;
    unsigned char c, buf[1];

    new_called = 0;
    do_cache = 1;

    if (idx >= 3) {
        idx -= 3;
        stateful = 1;
    }

    if (!TEST_ptr(bretry) || !setup_ticket_test(stateful, idx, &sctx, &cctx))
        goto end;
    SSL_CTX_sess_set_new_cb(sctx, new_session_cb);
    /* setup_ticket_test() uses new_cachesession_cb which we don't need. */
    SSL_CTX_sess_set_new_cb(cctx, new_session_cb);

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                          &clientssl, NULL, NULL)))
        goto end;

    /*
     * Note that we have new_session_cb on both sctx and cctx, so new_called is
     * incremented by both client and server.
     */
    if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE))
               /* Check we got the number of tickets we were expecting */
            || !TEST_int_eq(idx * 2, new_called)
            || !TEST_true(SSL_new_session_ticket(serverssl))
            || !TEST_true(SSL_new_session_ticket(serverssl))
            || !TEST_int_eq(idx * 2, new_called))
        goto end;

    /* Now try a (real) write to actually send the tickets */
    c = '1';
    if (!TEST_true(SSL_write_ex(serverssl, &c, 1, &nbytes))
            || !TEST_size_t_eq(1, nbytes)
            || !TEST_int_eq(idx * 2 + 2, new_called)
            || !TEST_true(SSL_read_ex(clientssl, buf, sizeof(buf), &nbytes))
            || !TEST_int_eq(idx * 2 + 4, new_called)
            || !TEST_int_eq(sizeof(buf), nbytes)
            || !TEST_int_eq(c, buf[0])
            || !TEST_false(SSL_read_ex(clientssl, buf, sizeof(buf), &nbytes)))
        goto end;

    /* Try with only requesting one new ticket, too */
    c = '2';
    new_called = 0;
    if (!TEST_true(SSL_new_session_ticket(serverssl))
            || !TEST_true(SSL_write_ex(serverssl, &c, sizeof(c), &nbytes))
            || !TEST_size_t_eq(sizeof(c), nbytes)
            || !TEST_int_eq(1, new_called)
            || !TEST_true(SSL_read_ex(clientssl, buf, sizeof(buf), &nbytes))
            || !TEST_int_eq(2, new_called)
            || !TEST_size_t_eq(sizeof(buf), nbytes)
            || !TEST_int_eq(c, buf[0]))
        goto end;

    /* Do it again but use dummy writes to drive the ticket generation */
    c = '3';
    new_called = 0;
    if (!TEST_true(SSL_new_session_ticket(serverssl))
            || !TEST_true(SSL_new_session_ticket(serverssl))
            || !TEST_true(SSL_write_ex(serverssl, &c, 0, &nbytes))
            || !TEST_size_t_eq(0, nbytes)
            || !TEST_int_eq(2, new_called)
            || !TEST_false(SSL_read_ex(clientssl, buf, sizeof(buf), &nbytes))
            || !TEST_int_eq(4, new_called))
        goto end;

    /* Once more, but with SSL_do_handshake() to drive the ticket generation */
    c = '4';
    new_called = 0;
    if (!TEST_true(SSL_new_session_ticket(serverssl))
            || !TEST_true(SSL_new_session_ticket(serverssl))
            || !TEST_true(SSL_do_handshake(serverssl))
            || !TEST_int_eq(2, new_called)
            || !TEST_false(SSL_read_ex(clientssl, buf, sizeof(buf), &nbytes))
            || !TEST_int_eq(4, new_called))
        goto end;

    /*
     * Use the always-retry BIO to exercise the logic that forces ticket
     * generation to wait until a record boundary.
     */
    c = '5';
    new_called = 0;
    tmp = SSL_get_wbio(serverssl);
    if (!TEST_ptr(tmp) || !TEST_true(BIO_up_ref(tmp))) {
        tmp = NULL;
        goto end;
    }
    SSL_set0_wbio(serverssl, bretry);
    bretry = NULL;
    if (!TEST_false(SSL_write_ex(serverssl, &c, 1, &nbytes))
            || !TEST_int_eq(SSL_get_error(serverssl, 0), SSL_ERROR_WANT_WRITE)
            || !TEST_size_t_eq(nbytes, 0))
        goto end;
    /* Restore a BIO that will let the write succeed */
    SSL_set0_wbio(serverssl, tmp);
    tmp = NULL;
    /*
     * These calls should just queue the request and not send anything
     * even if we explicitly try to hit the state machine.
     */
    if (!TEST_true(SSL_new_session_ticket(serverssl))
            || !TEST_true(SSL_new_session_ticket(serverssl))
            || !TEST_int_eq(0, new_called)
            || !TEST_true(SSL_do_handshake(serverssl))
            || !TEST_int_eq(0, new_called))
        goto end;
    /* Re-do the write; still no tickets sent */
    if (!TEST_true(SSL_write_ex(serverssl, &c, 1, &nbytes))
            || !TEST_size_t_eq(1, nbytes)
            || !TEST_int_eq(0, new_called)
            || !TEST_true(SSL_read_ex(clientssl, buf, sizeof(buf), &nbytes))
            || !TEST_int_eq(0, new_called)
            || !TEST_int_eq(sizeof(buf), nbytes)
            || !TEST_int_eq(c, buf[0])
            || !TEST_false(SSL_read_ex(clientssl, buf, sizeof(buf), &nbytes)))
        goto end;
    /* Even trying to hit the state machine now will still not send tickets */
    if (!TEST_true(SSL_do_handshake(serverssl))
            || !TEST_int_eq(0, new_called))
        goto end;
    /* Now the *next* write should send the tickets */
    c = '6';
    if (!TEST_true(SSL_write_ex(serverssl, &c, 1, &nbytes))
            || !TEST_size_t_eq(1, nbytes)
            || !TEST_int_eq(2, new_called)
            || !TEST_true(SSL_read_ex(clientssl, buf, sizeof(buf), &nbytes))
            || !TEST_int_eq(4, new_called)
            || !TEST_int_eq(sizeof(buf), nbytes)
            || !TEST_int_eq(c, buf[0])
            || !TEST_false(SSL_read_ex(clientssl, buf, sizeof(buf), &nbytes)))
        goto end;

    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    testresult = 1;

 end:
    BIO_free(bretry);
    BIO_free(tmp);
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    clientssl = serverssl = NULL;
    sctx = cctx = NULL;
    return testresult;
}
#endif

#define USE_NULL            0
#define USE_BIO_1           1
#define USE_BIO_2           2
#define USE_DEFAULT         3

#define CONNTYPE_CONNECTION_SUCCESS  0
#define CONNTYPE_CONNECTION_FAIL     1
#define CONNTYPE_NO_CONNECTION       2

#define TOTAL_NO_CONN_SSL_SET_BIO_TESTS         (3 * 3 * 3 * 3)
#define TOTAL_CONN_SUCCESS_SSL_SET_BIO_TESTS    (2 * 2)
#if !defined(OSSL_NO_USABLE_TLS1_3) && !defined(OPENSSL_NO_TLS1_2)
# define TOTAL_CONN_FAIL_SSL_SET_BIO_TESTS       (2 * 2)
#else
# define TOTAL_CONN_FAIL_SSL_SET_BIO_TESTS       0
#endif

#define TOTAL_SSL_SET_BIO_TESTS TOTAL_NO_CONN_SSL_SET_BIO_TESTS \
                                + TOTAL_CONN_SUCCESS_SSL_SET_BIO_TESTS \
                                + TOTAL_CONN_FAIL_SSL_SET_BIO_TESTS

static void setupbio(BIO **res, BIO *bio1, BIO *bio2, int type)
{
    switch (type) {
    case USE_NULL:
        *res = NULL;
        break;
    case USE_BIO_1:
        *res = bio1;
        break;
    case USE_BIO_2:
        *res = bio2;
        break;
    }
}


/*
 * Tests calls to SSL_set_bio() under various conditions.
 *
 * For the first 3 * 3 * 3 * 3 = 81 tests we do 2 calls to SSL_set_bio() with
 * various combinations of valid BIOs or NULL being set for the rbio/wbio. We
 * then do more tests where we create a successful connection first using our
 * standard connection setup functions, and then call SSL_set_bio() with
 * various combinations of valid BIOs or NULL. We then repeat these tests
 * following a failed connection. In this last case we are looking to check that
 * SSL_set_bio() functions correctly in the case where s->bbio is not NULL.
 */
static int test_ssl_set_bio(int idx)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    BIO *bio1 = NULL;
    BIO *bio2 = NULL;
    BIO *irbio = NULL, *iwbio = NULL, *nrbio = NULL, *nwbio = NULL;
    SSL *serverssl = NULL, *clientssl = NULL;
    int initrbio, initwbio, newrbio, newwbio, conntype;
    int testresult = 0;

    if (idx < TOTAL_NO_CONN_SSL_SET_BIO_TESTS) {
        initrbio = idx % 3;
        idx /= 3;
        initwbio = idx % 3;
        idx /= 3;
        newrbio = idx % 3;
        idx /= 3;
        newwbio = idx % 3;
        conntype = CONNTYPE_NO_CONNECTION;
    } else {
        idx -= TOTAL_NO_CONN_SSL_SET_BIO_TESTS;
        initrbio = initwbio = USE_DEFAULT;
        newrbio = idx % 2;
        idx /= 2;
        newwbio = idx % 2;
        idx /= 2;
        conntype = idx % 2;
    }

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    if (conntype == CONNTYPE_CONNECTION_FAIL) {
        /*
         * We won't ever get here if either TLSv1.3 or TLSv1.2 is disabled
         * because we reduced the number of tests in the definition of
         * TOTAL_CONN_FAIL_SSL_SET_BIO_TESTS to avoid this scenario. By setting
         * mismatched protocol versions we will force a connection failure.
         */
        SSL_CTX_set_min_proto_version(sctx, TLS1_3_VERSION);
        SSL_CTX_set_max_proto_version(cctx, TLS1_2_VERSION);
    }

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL)))
        goto end;

    if (initrbio == USE_BIO_1
            || initwbio == USE_BIO_1
            || newrbio == USE_BIO_1
            || newwbio == USE_BIO_1) {
        if (!TEST_ptr(bio1 = BIO_new(BIO_s_mem())))
            goto end;
    }

    if (initrbio == USE_BIO_2
            || initwbio == USE_BIO_2
            || newrbio == USE_BIO_2
            || newwbio == USE_BIO_2) {
        if (!TEST_ptr(bio2 = BIO_new(BIO_s_mem())))
            goto end;
    }

    if (initrbio != USE_DEFAULT) {
        setupbio(&irbio, bio1, bio2, initrbio);
        setupbio(&iwbio, bio1, bio2, initwbio);
        SSL_set_bio(clientssl, irbio, iwbio);

        /*
         * We want to maintain our own refs to these BIO, so do an up ref for
         * each BIO that will have ownership transferred in the SSL_set_bio()
         * call
         */
        if (irbio != NULL)
            BIO_up_ref(irbio);
        if (iwbio != NULL && iwbio != irbio)
            BIO_up_ref(iwbio);
    }

    if (conntype != CONNTYPE_NO_CONNECTION
            && !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)
                          == (conntype == CONNTYPE_CONNECTION_SUCCESS)))
        goto end;

    setupbio(&nrbio, bio1, bio2, newrbio);
    setupbio(&nwbio, bio1, bio2, newwbio);

    /*
     * We will (maybe) transfer ownership again so do more up refs.
     * SSL_set_bio() has some really complicated ownership rules where BIOs have
     * already been set!
     */
    if (nrbio != NULL
            && nrbio != irbio
            && (nwbio != iwbio || nrbio != nwbio))
        BIO_up_ref(nrbio);
    if (nwbio != NULL
            && nwbio != nrbio
            && (nwbio != iwbio || (nwbio == iwbio && irbio == iwbio)))
        BIO_up_ref(nwbio);

    SSL_set_bio(clientssl, nrbio, nwbio);

    testresult = 1;

 end:
    BIO_free(bio1);
    BIO_free(bio2);

    /*
     * This test is checking that the ref counting for SSL_set_bio is correct.
     * If we get here and we did too many frees then we will fail in the above
     * functions.
     */
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

typedef enum { NO_BIO_CHANGE, CHANGE_RBIO, CHANGE_WBIO } bio_change_t;

static int execute_test_ssl_bio(int pop_ssl, bio_change_t change_bio)
{
    BIO *sslbio = NULL, *membio1 = NULL, *membio2 = NULL;
    SSL_CTX *ctx;
    SSL *ssl = NULL;
    int testresult = 0;

    if (!TEST_ptr(ctx = SSL_CTX_new_ex(libctx, NULL, TLS_method()))
            || !TEST_ptr(ssl = SSL_new(ctx))
            || !TEST_ptr(sslbio = BIO_new(BIO_f_ssl()))
            || !TEST_ptr(membio1 = BIO_new(BIO_s_mem())))
        goto end;

    BIO_set_ssl(sslbio, ssl, BIO_CLOSE);

    /*
     * If anything goes wrong here then we could leak memory.
     */
    BIO_push(sslbio, membio1);

    /* Verify changing the rbio/wbio directly does not cause leaks */
    if (change_bio != NO_BIO_CHANGE) {
        if (!TEST_ptr(membio2 = BIO_new(BIO_s_mem()))) {
            ssl = NULL;
            goto end;
        }
        if (change_bio == CHANGE_RBIO)
            SSL_set0_rbio(ssl, membio2);
        else
            SSL_set0_wbio(ssl, membio2);
    }
    ssl = NULL;

    if (pop_ssl)
        BIO_pop(sslbio);
    else
        BIO_pop(membio1);

    testresult = 1;
 end:
    BIO_free(membio1);
    BIO_free(sslbio);
    SSL_free(ssl);
    SSL_CTX_free(ctx);

    return testresult;
}

static int test_ssl_bio_pop_next_bio(void)
{
    return execute_test_ssl_bio(0, NO_BIO_CHANGE);
}

static int test_ssl_bio_pop_ssl_bio(void)
{
    return execute_test_ssl_bio(1, NO_BIO_CHANGE);
}

static int test_ssl_bio_change_rbio(void)
{
    return execute_test_ssl_bio(0, CHANGE_RBIO);
}

static int test_ssl_bio_change_wbio(void)
{
    return execute_test_ssl_bio(0, CHANGE_WBIO);
}

#if !defined(OPENSSL_NO_TLS1_2) || defined(OSSL_NO_USABLE_TLS1_3)
typedef struct {
    /* The list of sig algs */
    const int *list;
    /* The length of the list */
    size_t listlen;
    /* A sigalgs list in string format */
    const char *liststr;
    /* Whether setting the list should succeed */
    int valid;
    /* Whether creating a connection with the list should succeed */
    int connsuccess;
} sigalgs_list;

static const int validlist1[] = {NID_sha256, EVP_PKEY_RSA};
# ifndef OPENSSL_NO_EC
static const int validlist2[] = {NID_sha256, EVP_PKEY_RSA, NID_sha512, EVP_PKEY_EC};
static const int validlist3[] = {NID_sha512, EVP_PKEY_EC};
# endif
static const int invalidlist1[] = {NID_undef, EVP_PKEY_RSA};
static const int invalidlist2[] = {NID_sha256, NID_undef};
static const int invalidlist3[] = {NID_sha256, EVP_PKEY_RSA, NID_sha256};
static const int invalidlist4[] = {NID_sha256};
static const sigalgs_list testsigalgs[] = {
    {validlist1, OSSL_NELEM(validlist1), NULL, 1, 1},
# ifndef OPENSSL_NO_EC
    {validlist2, OSSL_NELEM(validlist2), NULL, 1, 1},
    {validlist3, OSSL_NELEM(validlist3), NULL, 1, 0},
# endif
    {NULL, 0, "RSA+SHA256", 1, 1},
# ifndef OPENSSL_NO_EC
    {NULL, 0, "RSA+SHA256:ECDSA+SHA512", 1, 1},
    {NULL, 0, "ECDSA+SHA512", 1, 0},
# endif
    {invalidlist1, OSSL_NELEM(invalidlist1), NULL, 0, 0},
    {invalidlist2, OSSL_NELEM(invalidlist2), NULL, 0, 0},
    {invalidlist3, OSSL_NELEM(invalidlist3), NULL, 0, 0},
    {invalidlist4, OSSL_NELEM(invalidlist4), NULL, 0, 0},
    {NULL, 0, "RSA", 0, 0},
    {NULL, 0, "SHA256", 0, 0},
    {NULL, 0, "RSA+SHA256:SHA256", 0, 0},
    {NULL, 0, "Invalid", 0, 0}
};

static int test_set_sigalgs(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    const sigalgs_list *curr;
    int testctx;

    /* Should never happen */
    if (!TEST_size_t_le((size_t)idx, OSSL_NELEM(testsigalgs) * 2))
        return 0;

    testctx = ((size_t)idx < OSSL_NELEM(testsigalgs));
    curr = testctx ? &testsigalgs[idx]
                   : &testsigalgs[idx - OSSL_NELEM(testsigalgs)];

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey)))
        return 0;

    SSL_CTX_set_max_proto_version(cctx, TLS1_2_VERSION);

    if (testctx) {
        int ret;

        if (curr->list != NULL)
            ret = SSL_CTX_set1_sigalgs(cctx, curr->list, curr->listlen);
        else
            ret = SSL_CTX_set1_sigalgs_list(cctx, curr->liststr);

        if (!ret) {
            if (curr->valid)
                TEST_info("Failure setting sigalgs in SSL_CTX (%d)\n", idx);
            else
                testresult = 1;
            goto end;
        }
        if (!curr->valid) {
            TEST_info("Not-failed setting sigalgs in SSL_CTX (%d)\n", idx);
            goto end;
        }
    }

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL)))
        goto end;

    if (!testctx) {
        int ret;

        if (curr->list != NULL)
            ret = SSL_set1_sigalgs(clientssl, curr->list, curr->listlen);
        else
            ret = SSL_set1_sigalgs_list(clientssl, curr->liststr);
        if (!ret) {
            if (curr->valid)
                TEST_info("Failure setting sigalgs in SSL (%d)\n", idx);
            else
                testresult = 1;
            goto end;
        }
        if (!curr->valid)
            goto end;
    }

    if (!TEST_int_eq(create_ssl_connection(serverssl, clientssl,
                                           SSL_ERROR_NONE),
                curr->connsuccess))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}
#endif

#ifndef OSSL_NO_USABLE_TLS1_3
static int psk_client_cb_cnt = 0;
static int psk_server_cb_cnt = 0;

static int use_session_cb(SSL *ssl, const EVP_MD *md, const unsigned char **id,
                          size_t *idlen, SSL_SESSION **sess)
{
    switch (++use_session_cb_cnt) {
    case 1:
        /* The first call should always have a NULL md */
        if (md != NULL)
            return 0;
        break;

    case 2:
        /* The second call should always have an md */
        if (md == NULL)
            return 0;
        break;

    default:
        /* We should only be called a maximum of twice */
        return 0;
    }

    if (clientpsk != NULL)
        SSL_SESSION_up_ref(clientpsk);

    *sess = clientpsk;
    *id = (const unsigned char *)pskid;
    *idlen = strlen(pskid);

    return 1;
}

#ifndef OPENSSL_NO_PSK
static unsigned int psk_client_cb(SSL *ssl, const char *hint, char *id,
                                  unsigned int max_id_len,
                                  unsigned char *psk,
                                  unsigned int max_psk_len)
{
    unsigned int psklen = 0;

    psk_client_cb_cnt++;

    if (strlen(pskid) + 1 > max_id_len)
        return 0;

    /* We should only ever be called a maximum of twice per connection */
    if (psk_client_cb_cnt > 2)
        return 0;

    if (clientpsk == NULL)
        return 0;

    /* We'll reuse the PSK we set up for TLSv1.3 */
    if (SSL_SESSION_get_master_key(clientpsk, NULL, 0) > max_psk_len)
        return 0;
    psklen = SSL_SESSION_get_master_key(clientpsk, psk, max_psk_len);
    strncpy(id, pskid, max_id_len);

    return psklen;
}
#endif /* OPENSSL_NO_PSK */

static int find_session_cb(SSL *ssl, const unsigned char *identity,
                           size_t identity_len, SSL_SESSION **sess)
{
    find_session_cb_cnt++;

    /* We should only ever be called a maximum of twice per connection */
    if (find_session_cb_cnt > 2)
        return 0;

    if (serverpsk == NULL)
        return 0;

    /* Identity should match that set by the client */
    if (strlen(srvid) != identity_len
            || strncmp(srvid, (const char *)identity, identity_len) != 0) {
        /* No PSK found, continue but without a PSK */
        *sess = NULL;
        return 1;
    }

    SSL_SESSION_up_ref(serverpsk);
    *sess = serverpsk;

    return 1;
}

#ifndef OPENSSL_NO_PSK
static unsigned int psk_server_cb(SSL *ssl, const char *identity,
                                  unsigned char *psk, unsigned int max_psk_len)
{
    unsigned int psklen = 0;

    psk_server_cb_cnt++;

    /* We should only ever be called a maximum of twice per connection */
    if (find_session_cb_cnt > 2)
        return 0;

    if (serverpsk == NULL)
        return 0;

    /* Identity should match that set by the client */
    if (strcmp(srvid, identity) != 0) {
        return 0;
    }

    /* We'll reuse the PSK we set up for TLSv1.3 */
    if (SSL_SESSION_get_master_key(serverpsk, NULL, 0) > max_psk_len)
        return 0;
    psklen = SSL_SESSION_get_master_key(serverpsk, psk, max_psk_len);

    return psklen;
}
#endif /* OPENSSL_NO_PSK */

#define MSG1    "Hello"
#define MSG2    "World."
#define MSG3    "This"
#define MSG4    "is"
#define MSG5    "a"
#define MSG6    "test"
#define MSG7    "message."

#define TLS13_AES_128_GCM_SHA256_BYTES  ((const unsigned char *)"\x13\x01")
#define TLS13_AES_256_GCM_SHA384_BYTES  ((const unsigned char *)"\x13\x02")
#define TLS13_CHACHA20_POLY1305_SHA256_BYTES ((const unsigned char *)"\x13\x03")
#define TLS13_AES_128_CCM_SHA256_BYTES ((const unsigned char *)"\x13\x04")
#define TLS13_AES_128_CCM_8_SHA256_BYTES ((const unsigned char *)"\x13\05")


static SSL_SESSION *create_a_psk(SSL *ssl, size_t mdsize)
{
    const SSL_CIPHER *cipher = NULL;
    const unsigned char key[] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2c, 0x2d, 0x2e, 0x2f /* SHA384_DIGEST_LENGTH bytes */
    };
    SSL_SESSION *sess = NULL;

    if (mdsize == SHA384_DIGEST_LENGTH) {
        cipher = SSL_CIPHER_find(ssl, TLS13_AES_256_GCM_SHA384_BYTES);
    } else if (mdsize == SHA256_DIGEST_LENGTH) {
        /*
         * Any ciphersuite using SHA256 will do - it will be compatible with
         * the actual ciphersuite selected as long as it too is based on SHA256
         */
        cipher = SSL_CIPHER_find(ssl, TLS13_AES_128_GCM_SHA256_BYTES);
    } else {
        /* Should not happen */
        return NULL;
    }
    sess = SSL_SESSION_new();
    if (!TEST_ptr(sess)
            || !TEST_ptr(cipher)
            || !TEST_true(SSL_SESSION_set1_master_key(sess, key, mdsize))
            || !TEST_true(SSL_SESSION_set_cipher(sess, cipher))
            || !TEST_true(
                    SSL_SESSION_set_protocol_version(sess,
                                                     TLS1_3_VERSION))) {
        SSL_SESSION_free(sess);
        return NULL;
    }
    return sess;
}

/*
 * Helper method to setup objects for early data test. Caller frees objects on
 * error.
 */
static int setupearly_data_test(SSL_CTX **cctx, SSL_CTX **sctx, SSL **clientssl,
                                SSL **serverssl, SSL_SESSION **sess, int idx,
                                size_t mdsize)
{
    if (*sctx == NULL
            && !TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                              TLS_client_method(),
                                              TLS1_VERSION, 0,
                                              sctx, cctx, cert, privkey)))
        return 0;

    if (!TEST_true(SSL_CTX_set_max_early_data(*sctx, SSL3_RT_MAX_PLAIN_LENGTH)))
        return 0;

    if (idx == 1) {
        /* When idx == 1 we repeat the tests with read_ahead set */
        SSL_CTX_set_read_ahead(*cctx, 1);
        SSL_CTX_set_read_ahead(*sctx, 1);
    } else if (idx == 2) {
        /* When idx == 2 we are doing early_data with a PSK. Set up callbacks */
        SSL_CTX_set_psk_use_session_callback(*cctx, use_session_cb);
        SSL_CTX_set_psk_find_session_callback(*sctx, find_session_cb);
        use_session_cb_cnt = 0;
        find_session_cb_cnt = 0;
        srvid = pskid;
    }

    if (!TEST_true(create_ssl_objects(*sctx, *cctx, serverssl, clientssl,
                                      NULL, NULL)))
        return 0;

    /*
     * For one of the run throughs (doesn't matter which one), we'll try sending
     * some SNI data in the initial ClientHello. This will be ignored (because
     * there is no SNI cb set up by the server), so it should not impact
     * early_data.
     */
    if (idx == 1
            && !TEST_true(SSL_set_tlsext_host_name(*clientssl, "localhost")))
        return 0;

    if (idx == 2) {
        clientpsk = create_a_psk(*clientssl, mdsize);
        if (!TEST_ptr(clientpsk)
                   /*
                    * We just choose an arbitrary value for max_early_data which
                    * should be big enough for testing purposes.
                    */
                || !TEST_true(SSL_SESSION_set_max_early_data(clientpsk,
                                                             0x100))
                || !TEST_true(SSL_SESSION_up_ref(clientpsk))) {
            SSL_SESSION_free(clientpsk);
            clientpsk = NULL;
            return 0;
        }
        serverpsk = clientpsk;

        if (sess != NULL) {
            if (!TEST_true(SSL_SESSION_up_ref(clientpsk))) {
                SSL_SESSION_free(clientpsk);
                SSL_SESSION_free(serverpsk);
                clientpsk = serverpsk = NULL;
                return 0;
            }
            *sess = clientpsk;
        }
        return 1;
    }

    if (sess == NULL)
        return 1;

    if (!TEST_true(create_ssl_connection(*serverssl, *clientssl,
                                         SSL_ERROR_NONE)))
        return 0;

    *sess = SSL_get1_session(*clientssl);
    SSL_shutdown(*clientssl);
    SSL_shutdown(*serverssl);
    SSL_free(*serverssl);
    SSL_free(*clientssl);
    *serverssl = *clientssl = NULL;

    if (!TEST_true(create_ssl_objects(*sctx, *cctx, serverssl,
                                      clientssl, NULL, NULL))
            || !TEST_true(SSL_set_session(*clientssl, *sess)))
        return 0;

    return 1;
}

static int check_early_data_timeout(time_t timer)
{
    int res = 0;

    /*
     * Early data is time sensitive. We have an approx 8 second allowance
     * between writing the early data and reading it. If we exceed that time
     * then this test will fail. This can sometimes (rarely) occur in normal CI
     * operation. We can try and detect this and just ignore the result of this
     * test if it has taken too long. We assume anything over 7 seconds is too
     * long
     */
    timer = time(NULL) - timer;
    if (timer >= 7)
        res = TEST_skip("Test took too long, ignoring result");

    return res;
}

static int test_early_data_read_write(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    SSL_SESSION *sess = NULL;
    unsigned char buf[20], data[1024];
    size_t readbytes, written, eoedlen, rawread, rawwritten;
    BIO *rbio;
    time_t timer;

    if (!TEST_true(setupearly_data_test(&cctx, &sctx, &clientssl,
                                        &serverssl, &sess, idx,
                                        SHA384_DIGEST_LENGTH)))
        goto end;

    /* Write and read some early data */
    timer = time(NULL);
    if (!TEST_true(SSL_write_early_data(clientssl, MSG1, strlen(MSG1),
                                        &written))
            || !TEST_size_t_eq(written, strlen(MSG1)))
        goto end;

    if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                         &readbytes),
                     SSL_READ_EARLY_DATA_SUCCESS)) {
        testresult = check_early_data_timeout(timer);
        goto end;
    }

    if (!TEST_mem_eq(MSG1, readbytes, buf, strlen(MSG1))
            || !TEST_int_eq(SSL_get_early_data_status(serverssl),
                            SSL_EARLY_DATA_ACCEPTED))
        goto end;

    /*
     * Server should be able to write data, and client should be able to
     * read it.
     */
    if (!TEST_true(SSL_write_early_data(serverssl, MSG2, strlen(MSG2),
                                        &written))
            || !TEST_size_t_eq(written, strlen(MSG2))
            || !TEST_true(SSL_read_ex(clientssl, buf, sizeof(buf), &readbytes))
            || !TEST_mem_eq(buf, readbytes, MSG2, strlen(MSG2)))
        goto end;

    /* Even after reading normal data, client should be able write early data */
    if (!TEST_true(SSL_write_early_data(clientssl, MSG3, strlen(MSG3),
                                        &written))
            || !TEST_size_t_eq(written, strlen(MSG3)))
        goto end;

    /* Server should still be able read early data after writing data */
    if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                         &readbytes),
                     SSL_READ_EARLY_DATA_SUCCESS)
            || !TEST_mem_eq(buf, readbytes, MSG3, strlen(MSG3)))
        goto end;

    /* Write more data from server and read it from client */
    if (!TEST_true(SSL_write_early_data(serverssl, MSG4, strlen(MSG4),
                                        &written))
            || !TEST_size_t_eq(written, strlen(MSG4))
            || !TEST_true(SSL_read_ex(clientssl, buf, sizeof(buf), &readbytes))
            || !TEST_mem_eq(buf, readbytes, MSG4, strlen(MSG4)))
        goto end;

    /*
     * If client writes normal data it should mean writing early data is no
     * longer possible.
     */
    if (!TEST_true(SSL_write_ex(clientssl, MSG5, strlen(MSG5), &written))
            || !TEST_size_t_eq(written, strlen(MSG5))
            || !TEST_int_eq(SSL_get_early_data_status(clientssl),
                            SSL_EARLY_DATA_ACCEPTED))
        goto end;

    /*
     * At this point the client has written EndOfEarlyData, ClientFinished and
     * normal (fully protected) data. We are going to cause a delay between the
     * arrival of EndOfEarlyData and ClientFinished. We read out all the data
     * in the read BIO, and then just put back the EndOfEarlyData message.
     */
    rbio = SSL_get_rbio(serverssl);
    if (!TEST_true(BIO_read_ex(rbio, data, sizeof(data), &rawread))
            || !TEST_size_t_lt(rawread, sizeof(data))
            || !TEST_size_t_gt(rawread, SSL3_RT_HEADER_LENGTH))
        goto end;

    /* Record length is in the 4th and 5th bytes of the record header */
    eoedlen = SSL3_RT_HEADER_LENGTH + (data[3] << 8 | data[4]);
    if (!TEST_true(BIO_write_ex(rbio, data, eoedlen, &rawwritten))
            || !TEST_size_t_eq(rawwritten, eoedlen))
        goto end;

    /* Server should be told that there is no more early data */
    if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                         &readbytes),
                     SSL_READ_EARLY_DATA_FINISH)
            || !TEST_size_t_eq(readbytes, 0))
        goto end;

    /*
     * Server has not finished init yet, so should still be able to write early
     * data.
     */
    if (!TEST_true(SSL_write_early_data(serverssl, MSG6, strlen(MSG6),
                                        &written))
            || !TEST_size_t_eq(written, strlen(MSG6)))
        goto end;

    /* Push the ClientFinished and the normal data back into the server rbio */
    if (!TEST_true(BIO_write_ex(rbio, data + eoedlen, rawread - eoedlen,
                                &rawwritten))
            || !TEST_size_t_eq(rawwritten, rawread - eoedlen))
        goto end;

    /* Server should be able to read normal data */
    if (!TEST_true(SSL_read_ex(serverssl, buf, sizeof(buf), &readbytes))
            || !TEST_size_t_eq(readbytes, strlen(MSG5)))
        goto end;

    /* Client and server should not be able to write/read early data now */
    if (!TEST_false(SSL_write_early_data(clientssl, MSG6, strlen(MSG6),
                                         &written)))
        goto end;
    ERR_clear_error();
    if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                         &readbytes),
                     SSL_READ_EARLY_DATA_ERROR))
        goto end;
    ERR_clear_error();

    /* Client should be able to read the data sent by the server */
    if (!TEST_true(SSL_read_ex(clientssl, buf, sizeof(buf), &readbytes))
            || !TEST_mem_eq(buf, readbytes, MSG6, strlen(MSG6)))
        goto end;

    /*
     * Make sure we process the two NewSessionTickets. These arrive
     * post-handshake. We attempt reads which we do not expect to return any
     * data.
     */
    if (!TEST_false(SSL_read_ex(clientssl, buf, sizeof(buf), &readbytes))
            || !TEST_false(SSL_read_ex(clientssl, buf, sizeof(buf),
                           &readbytes)))
        goto end;

    /* Server should be able to write normal data */
    if (!TEST_true(SSL_write_ex(serverssl, MSG7, strlen(MSG7), &written))
            || !TEST_size_t_eq(written, strlen(MSG7))
            || !TEST_true(SSL_read_ex(clientssl, buf, sizeof(buf), &readbytes))
            || !TEST_mem_eq(buf, readbytes, MSG7, strlen(MSG7)))
        goto end;

    SSL_SESSION_free(sess);
    sess = SSL_get1_session(clientssl);
    use_session_cb_cnt = 0;
    find_session_cb_cnt = 0;

    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl, sess)))
        goto end;

    /* Write and read some early data */
    if (!TEST_true(SSL_write_early_data(clientssl, MSG1, strlen(MSG1),
                                        &written))
            || !TEST_size_t_eq(written, strlen(MSG1))
            || !TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                                &readbytes),
                            SSL_READ_EARLY_DATA_SUCCESS)
            || !TEST_mem_eq(buf, readbytes, MSG1, strlen(MSG1)))
        goto end;

    if (!TEST_int_gt(SSL_connect(clientssl), 0)
            || !TEST_int_gt(SSL_accept(serverssl), 0))
        goto end;

    /* Client and server should not be able to write/read early data now */
    if (!TEST_false(SSL_write_early_data(clientssl, MSG6, strlen(MSG6),
                                         &written)))
        goto end;
    ERR_clear_error();
    if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                         &readbytes),
                     SSL_READ_EARLY_DATA_ERROR))
        goto end;
    ERR_clear_error();

    /* Client and server should be able to write/read normal data */
    if (!TEST_true(SSL_write_ex(clientssl, MSG5, strlen(MSG5), &written))
            || !TEST_size_t_eq(written, strlen(MSG5))
            || !TEST_true(SSL_read_ex(serverssl, buf, sizeof(buf), &readbytes))
            || !TEST_size_t_eq(readbytes, strlen(MSG5)))
        goto end;

    testresult = 1;

 end:
    SSL_SESSION_free(sess);
    SSL_SESSION_free(clientpsk);
    SSL_SESSION_free(serverpsk);
    clientpsk = serverpsk = NULL;
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

static int allow_ed_cb_called = 0;

static int allow_early_data_cb(SSL *s, void *arg)
{
    int *usecb = (int *)arg;

    allow_ed_cb_called++;

    if (*usecb == 1)
        return 0;

    return 1;
}

/*
 * idx == 0: Standard early_data setup
 * idx == 1: early_data setup using read_ahead
 * usecb == 0: Don't use a custom early data callback
 * usecb == 1: Use a custom early data callback and reject the early data
 * usecb == 2: Use a custom early data callback and accept the early data
 * confopt == 0: Configure anti-replay directly
 * confopt == 1: Configure anti-replay using SSL_CONF
 */
static int test_early_data_replay_int(int idx, int usecb, int confopt)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    SSL_SESSION *sess = NULL;
    size_t readbytes, written;
    unsigned char buf[20];
    time_t timer;

    allow_ed_cb_called = 0;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey)))
        return 0;

    if (usecb > 0) {
        if (confopt == 0) {
            SSL_CTX_set_options(sctx, SSL_OP_NO_ANTI_REPLAY);
        } else {
            SSL_CONF_CTX *confctx = SSL_CONF_CTX_new();

            if (!TEST_ptr(confctx))
                goto end;
            SSL_CONF_CTX_set_flags(confctx, SSL_CONF_FLAG_FILE
                                            | SSL_CONF_FLAG_SERVER);
            SSL_CONF_CTX_set_ssl_ctx(confctx, sctx);
            if (!TEST_int_eq(SSL_CONF_cmd(confctx, "Options", "-AntiReplay"),
                             2)) {
                SSL_CONF_CTX_free(confctx);
                goto end;
            }
            SSL_CONF_CTX_free(confctx);
        }
        SSL_CTX_set_allow_early_data_cb(sctx, allow_early_data_cb, &usecb);
    }

    if (!TEST_true(setupearly_data_test(&cctx, &sctx, &clientssl,
                                        &serverssl, &sess, idx,
                                        SHA384_DIGEST_LENGTH)))
        goto end;

    /*
     * The server is configured to accept early data. Create a connection to
     * "use up" the ticket
     */
    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE))
            || !TEST_true(SSL_session_reused(clientssl)))
        goto end;

    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl, sess)))
        goto end;

    /* Write and read some early data */
    timer = time(NULL);
    if (!TEST_true(SSL_write_early_data(clientssl, MSG1, strlen(MSG1),
                                        &written))
            || !TEST_size_t_eq(written, strlen(MSG1)))
        goto end;

    if (usecb <= 1) {
        if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                             &readbytes),
                         SSL_READ_EARLY_DATA_FINISH)
                   /*
                    * The ticket was reused, so the we should have rejected the
                    * early data
                    */
                || !TEST_int_eq(SSL_get_early_data_status(serverssl),
                                SSL_EARLY_DATA_REJECTED))
            goto end;
    } else {
        /* In this case the callback decides to accept the early data */
        if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                             &readbytes),
                         SSL_READ_EARLY_DATA_SUCCESS)) {
            testresult = check_early_data_timeout(timer);
            goto end;
        }
        if (!TEST_mem_eq(MSG1, strlen(MSG1), buf, readbytes)
                   /*
                    * Server will have sent its flight so client can now send
                    * end of early data and complete its half of the handshake
                    */
                || !TEST_int_gt(SSL_connect(clientssl), 0)
                || !TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                             &readbytes),
                                SSL_READ_EARLY_DATA_FINISH)
                || !TEST_int_eq(SSL_get_early_data_status(serverssl),
                                SSL_EARLY_DATA_ACCEPTED))
            goto end;
    }

    /* Complete the connection */
    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE))
            || !TEST_int_eq(SSL_session_reused(clientssl), (usecb > 0) ? 1 : 0)
            || !TEST_int_eq(allow_ed_cb_called, usecb > 0 ? 1 : 0))
        goto end;

    testresult = 1;

 end:
    SSL_SESSION_free(sess);
    SSL_SESSION_free(clientpsk);
    SSL_SESSION_free(serverpsk);
    clientpsk = serverpsk = NULL;
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

static int test_early_data_replay(int idx)
{
    int ret = 1, usecb, confopt;

    for (usecb = 0; usecb < 3; usecb++) {
        for (confopt = 0; confopt < 2; confopt++)
            ret &= test_early_data_replay_int(idx, usecb, confopt);
    }

    return ret;
}

static const char *ciphersuites[] = {
    "TLS_AES_128_CCM_8_SHA256",
    "TLS_AES_128_GCM_SHA256",
    "TLS_AES_256_GCM_SHA384",
    "TLS_AES_128_CCM_SHA256",
#if !defined(OPENSSL_NO_CHACHA) && !defined(OPENSSL_NO_POLY1305)
    "TLS_CHACHA20_POLY1305_SHA256"
#endif
};

/*
 * Helper function to test that a server attempting to read early data can
 * handle a connection from a client where the early data should be skipped.
 * testtype: 0 == No HRR
 * testtype: 1 == HRR
 * testtype: 2 == HRR, invalid early_data sent after HRR
 * testtype: 3 == recv_max_early_data set to 0
 */
static int early_data_skip_helper(int testtype, int cipher, int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    SSL_SESSION *sess = NULL;
    unsigned char buf[20];
    size_t readbytes, written;

    if (is_fips && cipher == 4)
        return 1;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                              TLS_client_method(),
                                              TLS1_VERSION, 0,
                                              &sctx, &cctx, cert, privkey)))
        goto end;

    if (cipher == 0) {
        SSL_CTX_set_security_level(sctx, 0);
        SSL_CTX_set_security_level(cctx, 0);
    }

    if (!TEST_true(SSL_CTX_set_ciphersuites(sctx, ciphersuites[cipher]))
            || !TEST_true(SSL_CTX_set_ciphersuites(cctx, ciphersuites[cipher])))
        goto end;

    if (!TEST_true(setupearly_data_test(&cctx, &sctx, &clientssl,
                                        &serverssl, &sess, idx,
                                        cipher == 2 ? SHA384_DIGEST_LENGTH
                                                    : SHA256_DIGEST_LENGTH)))
        goto end;

    if (testtype == 1 || testtype == 2) {
        /* Force an HRR to occur */
#if defined(OPENSSL_NO_EC)
        if (!TEST_true(SSL_set1_groups_list(serverssl, "ffdhe3072")))
            goto end;
#else
        if (!TEST_true(SSL_set1_groups_list(serverssl, "P-384")))
            goto end;
#endif
    } else if (idx == 2) {
        /*
         * We force early_data rejection by ensuring the PSK identity is
         * unrecognised
         */
        srvid = "Dummy Identity";
    } else {
        /*
         * Deliberately corrupt the creation time. We take 20 seconds off the
         * time. It could be any value as long as it is not within tolerance.
         * This should mean the ticket is rejected.
         */
        if (!TEST_true(SSL_SESSION_set_time(sess, (long)(time(NULL) - 20))))
            goto end;
    }

    if (testtype == 3
            && !TEST_true(SSL_set_recv_max_early_data(serverssl, 0)))
        goto end;

    /* Write some early data */
    if (!TEST_true(SSL_write_early_data(clientssl, MSG1, strlen(MSG1),
                                        &written))
            || !TEST_size_t_eq(written, strlen(MSG1)))
        goto end;

    /* Server should reject the early data */
    if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                         &readbytes),
                     SSL_READ_EARLY_DATA_FINISH)
            || !TEST_size_t_eq(readbytes, 0)
            || !TEST_int_eq(SSL_get_early_data_status(serverssl),
                            SSL_EARLY_DATA_REJECTED))
        goto end;

    switch (testtype) {
    case 0:
        /* Nothing to do */
        break;

    case 1:
        /*
         * Finish off the handshake. We perform the same writes and reads as
         * further down but we expect them to fail due to the incomplete
         * handshake.
         */
        if (!TEST_false(SSL_write_ex(clientssl, MSG2, strlen(MSG2), &written))
                || !TEST_false(SSL_read_ex(serverssl, buf, sizeof(buf),
                               &readbytes)))
            goto end;
        break;

    case 2:
        {
            BIO *wbio = SSL_get_wbio(clientssl);
            /* A record that will appear as bad early_data */
            const unsigned char bad_early_data[] = {
                0x17, 0x03, 0x03, 0x00, 0x01, 0x00
            };

            /*
             * We force the client to attempt a write. This will fail because
             * we're still in the handshake. It will cause the second
             * ClientHello to be sent.
             */
            if (!TEST_false(SSL_write_ex(clientssl, MSG2, strlen(MSG2),
                                         &written)))
                goto end;

            /*
             * Inject some early_data after the second ClientHello. This should
             * cause the server to fail
             */
            if (!TEST_true(BIO_write_ex(wbio, bad_early_data,
                                        sizeof(bad_early_data), &written)))
                goto end;
        }
        /* fallthrough */

    case 3:
        /*
         * This client has sent more early_data than we are willing to skip
         * (case 3) or sent invalid early_data (case 2) so the connection should
         * abort.
         */
        if (!TEST_false(SSL_read_ex(serverssl, buf, sizeof(buf), &readbytes))
                || !TEST_int_eq(SSL_get_error(serverssl, 0), SSL_ERROR_SSL))
            goto end;

        /* Connection has failed - nothing more to do */
        testresult = 1;
        goto end;

    default:
        TEST_error("Invalid test type");
        goto end;
    }

    ERR_clear_error();
    /*
     * Should be able to send normal data despite rejection of early data. The
     * early_data should be skipped.
     */
    if (!TEST_true(SSL_write_ex(clientssl, MSG2, strlen(MSG2), &written))
            || !TEST_size_t_eq(written, strlen(MSG2))
            || !TEST_int_eq(SSL_get_early_data_status(clientssl),
                            SSL_EARLY_DATA_REJECTED)
            || !TEST_true(SSL_read_ex(serverssl, buf, sizeof(buf), &readbytes))
            || !TEST_mem_eq(buf, readbytes, MSG2, strlen(MSG2)))
        goto end;

    /*
     * Failure to decrypt early data records should not leave spurious errors
     * on the error stack
     */
    if (!TEST_long_eq(ERR_peek_error(), 0))
        goto end;

    testresult = 1;

 end:
    SSL_SESSION_free(clientpsk);
    SSL_SESSION_free(serverpsk);
    clientpsk = serverpsk = NULL;
    SSL_SESSION_free(sess);
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

/*
 * Test that a server attempting to read early data can handle a connection
 * from a client where the early data is not acceptable.
 */
static int test_early_data_skip(int idx)
{
    return early_data_skip_helper(0,
                                  idx % OSSL_NELEM(ciphersuites),
                                  idx / OSSL_NELEM(ciphersuites));
}

/*
 * Test that a server attempting to read early data can handle a connection
 * from a client where an HRR occurs.
 */
static int test_early_data_skip_hrr(int idx)
{
    return early_data_skip_helper(1,
                                  idx % OSSL_NELEM(ciphersuites),
                                  idx / OSSL_NELEM(ciphersuites));
}

/*
 * Test that a server attempting to read early data can handle a connection
 * from a client where an HRR occurs and correctly fails if early_data is sent
 * after the HRR
 */
static int test_early_data_skip_hrr_fail(int idx)
{
    return early_data_skip_helper(2,
                                  idx % OSSL_NELEM(ciphersuites),
                                  idx / OSSL_NELEM(ciphersuites));
}

/*
 * Test that a server attempting to read early data will abort if it tries to
 * skip over too much.
 */
static int test_early_data_skip_abort(int idx)
{
    return early_data_skip_helper(3,
                                  idx % OSSL_NELEM(ciphersuites),
                                  idx / OSSL_NELEM(ciphersuites));
}

/*
 * Test that a server attempting to read early data can handle a connection
 * from a client that doesn't send any.
 */
static int test_early_data_not_sent(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    SSL_SESSION *sess = NULL;
    unsigned char buf[20];
    size_t readbytes, written;

    if (!TEST_true(setupearly_data_test(&cctx, &sctx, &clientssl,
                                        &serverssl, &sess, idx,
                                        SHA384_DIGEST_LENGTH)))
        goto end;

    /* Write some data - should block due to handshake with server */
    SSL_set_connect_state(clientssl);
    if (!TEST_false(SSL_write_ex(clientssl, MSG1, strlen(MSG1), &written)))
        goto end;

    /* Server should detect that early data has not been sent */
    if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                         &readbytes),
                     SSL_READ_EARLY_DATA_FINISH)
            || !TEST_size_t_eq(readbytes, 0)
            || !TEST_int_eq(SSL_get_early_data_status(serverssl),
                            SSL_EARLY_DATA_NOT_SENT)
            || !TEST_int_eq(SSL_get_early_data_status(clientssl),
                            SSL_EARLY_DATA_NOT_SENT))
        goto end;

    /* Continue writing the message we started earlier */
    if (!TEST_true(SSL_write_ex(clientssl, MSG1, strlen(MSG1), &written))
            || !TEST_size_t_eq(written, strlen(MSG1))
            || !TEST_true(SSL_read_ex(serverssl, buf, sizeof(buf), &readbytes))
            || !TEST_mem_eq(buf, readbytes, MSG1, strlen(MSG1))
            || !SSL_write_ex(serverssl, MSG2, strlen(MSG2), &written)
            || !TEST_size_t_eq(written, strlen(MSG2)))
        goto end;

    if (!TEST_true(SSL_read_ex(clientssl, buf, sizeof(buf), &readbytes))
            || !TEST_mem_eq(buf, readbytes, MSG2, strlen(MSG2)))
        goto end;

    testresult = 1;

 end:
    SSL_SESSION_free(sess);
    SSL_SESSION_free(clientpsk);
    SSL_SESSION_free(serverpsk);
    clientpsk = serverpsk = NULL;
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

static const char *servalpn;

static int alpn_select_cb(SSL *ssl, const unsigned char **out,
                          unsigned char *outlen, const unsigned char *in,
                          unsigned int inlen, void *arg)
{
    unsigned int protlen = 0;
    const unsigned char *prot;

    for (prot = in; prot < in + inlen; prot += protlen) {
        protlen = *prot++;
        if (in + inlen < prot + protlen)
            return SSL_TLSEXT_ERR_NOACK;

        if (protlen == strlen(servalpn)
                && memcmp(prot, servalpn, protlen) == 0) {
            *out = prot;
            *outlen = protlen;
            return SSL_TLSEXT_ERR_OK;
        }
    }

    return SSL_TLSEXT_ERR_NOACK;
}

/* Test that a PSK can be used to send early_data */
static int test_early_data_psk(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    SSL_SESSION *sess = NULL;
    unsigned char alpnlist[] = {
        0x08, 'g', 'o', 'o', 'd', 'a', 'l', 'p', 'n', 0x07, 'b', 'a', 'd', 'a',
        'l', 'p', 'n'
    };
#define GOODALPNLEN     9
#define BADALPNLEN      8
#define GOODALPN        (alpnlist)
#define BADALPN         (alpnlist + GOODALPNLEN)
    int err = 0;
    unsigned char buf[20];
    size_t readbytes, written;
    int readearlyres = SSL_READ_EARLY_DATA_SUCCESS, connectres = 1;
    int edstatus = SSL_EARLY_DATA_ACCEPTED;

    /* We always set this up with a final parameter of "2" for PSK */
    if (!TEST_true(setupearly_data_test(&cctx, &sctx, &clientssl,
                                        &serverssl, &sess, 2,
                                        SHA384_DIGEST_LENGTH)))
        goto end;

    servalpn = "goodalpn";

    /*
     * Note: There is no test for inconsistent SNI with late client detection.
     * This is because servers do not acknowledge SNI even if they are using
     * it in a resumption handshake - so it is not actually possible for a
     * client to detect a problem.
     */
    switch (idx) {
    case 0:
        /* Set inconsistent SNI (early client detection) */
        err = SSL_R_INCONSISTENT_EARLY_DATA_SNI;
        if (!TEST_true(SSL_SESSION_set1_hostname(sess, "goodhost"))
                || !TEST_true(SSL_set_tlsext_host_name(clientssl, "badhost")))
            goto end;
        break;

    case 1:
        /* Set inconsistent ALPN (early client detection) */
        err = SSL_R_INCONSISTENT_EARLY_DATA_ALPN;
        /* SSL_set_alpn_protos returns 0 for success and 1 for failure */
        if (!TEST_true(SSL_SESSION_set1_alpn_selected(sess, GOODALPN,
                                                      GOODALPNLEN))
                || !TEST_false(SSL_set_alpn_protos(clientssl, BADALPN,
                                                   BADALPNLEN)))
            goto end;
        break;

    case 2:
        /*
         * Set invalid protocol version. Technically this affects PSKs without
         * early_data too, but we test it here because it is similar to the
         * SNI/ALPN consistency tests.
         */
        err = SSL_R_BAD_PSK;
        if (!TEST_true(SSL_SESSION_set_protocol_version(sess, TLS1_2_VERSION)))
            goto end;
        break;

    case 3:
        /*
         * Set inconsistent SNI (server side). In this case the connection
         * will succeed and accept early_data. In TLSv1.3 on the server side SNI
         * is associated with each handshake - not the session. Therefore it
         * should not matter that we used a different server name last time.
         */
        SSL_SESSION_free(serverpsk);
        serverpsk = SSL_SESSION_dup(clientpsk);
        if (!TEST_ptr(serverpsk)
                || !TEST_true(SSL_SESSION_set1_hostname(serverpsk, "badhost")))
            goto end;
        /* Fall through */
    case 4:
        /* Set consistent SNI */
        if (!TEST_true(SSL_SESSION_set1_hostname(sess, "goodhost"))
                || !TEST_true(SSL_set_tlsext_host_name(clientssl, "goodhost"))
                || !TEST_true(SSL_CTX_set_tlsext_servername_callback(sctx,
                                hostname_cb)))
            goto end;
        break;

    case 5:
        /*
         * Set inconsistent ALPN (server detected). In this case the connection
         * will succeed but reject early_data.
         */
        servalpn = "badalpn";
        edstatus = SSL_EARLY_DATA_REJECTED;
        readearlyres = SSL_READ_EARLY_DATA_FINISH;
        /* Fall through */
    case 6:
        /*
         * Set consistent ALPN.
         * SSL_set_alpn_protos returns 0 for success and 1 for failure. It
         * accepts a list of protos (each one length prefixed).
         * SSL_set1_alpn_selected accepts a single protocol (not length
         * prefixed)
         */
        if (!TEST_true(SSL_SESSION_set1_alpn_selected(sess, GOODALPN + 1,
                                                      GOODALPNLEN - 1))
                || !TEST_false(SSL_set_alpn_protos(clientssl, GOODALPN,
                                                   GOODALPNLEN)))
            goto end;

        SSL_CTX_set_alpn_select_cb(sctx, alpn_select_cb, NULL);
        break;

    case 7:
        /* Set inconsistent ALPN (late client detection) */
        SSL_SESSION_free(serverpsk);
        serverpsk = SSL_SESSION_dup(clientpsk);
        if (!TEST_ptr(serverpsk)
                || !TEST_true(SSL_SESSION_set1_alpn_selected(clientpsk,
                                                             BADALPN + 1,
                                                             BADALPNLEN - 1))
                || !TEST_true(SSL_SESSION_set1_alpn_selected(serverpsk,
                                                             GOODALPN + 1,
                                                             GOODALPNLEN - 1))
                || !TEST_false(SSL_set_alpn_protos(clientssl, alpnlist,
                                                   sizeof(alpnlist))))
            goto end;
        SSL_CTX_set_alpn_select_cb(sctx, alpn_select_cb, NULL);
        edstatus = SSL_EARLY_DATA_ACCEPTED;
        readearlyres = SSL_READ_EARLY_DATA_SUCCESS;
        /* SSL_connect() call should fail */
        connectres = -1;
        break;

    default:
        TEST_error("Bad test index");
        goto end;
    }

    SSL_set_connect_state(clientssl);
    if (err != 0) {
        if (!TEST_false(SSL_write_early_data(clientssl, MSG1, strlen(MSG1),
                                            &written))
                || !TEST_int_eq(SSL_get_error(clientssl, 0), SSL_ERROR_SSL)
                || !TEST_int_eq(ERR_GET_REASON(ERR_get_error()), err))
            goto end;
    } else {
        time_t timer = time(NULL);

        if (!TEST_true(SSL_write_early_data(clientssl, MSG1, strlen(MSG1),
                                            &written)))
            goto end;

        if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                             &readbytes), readearlyres)) {
            testresult = check_early_data_timeout(timer);
            goto end;
        }

        if ((readearlyres == SSL_READ_EARLY_DATA_SUCCESS
                    && !TEST_mem_eq(buf, readbytes, MSG1, strlen(MSG1)))
                || !TEST_int_eq(SSL_get_early_data_status(serverssl), edstatus)
                || !TEST_int_eq(SSL_connect(clientssl), connectres))
            goto end;
    }

    testresult = 1;

 end:
    SSL_SESSION_free(sess);
    SSL_SESSION_free(clientpsk);
    SSL_SESSION_free(serverpsk);
    clientpsk = serverpsk = NULL;
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

/*
 * Test TLSv1.3 PSK can be used to send early_data with all 5 ciphersuites
 * idx == 0: Test with TLS1_3_RFC_AES_128_GCM_SHA256
 * idx == 1: Test with TLS1_3_RFC_AES_256_GCM_SHA384
 * idx == 2: Test with TLS1_3_RFC_CHACHA20_POLY1305_SHA256,
 * idx == 3: Test with TLS1_3_RFC_AES_128_CCM_SHA256
 * idx == 4: Test with TLS1_3_RFC_AES_128_CCM_8_SHA256
 */
static int test_early_data_psk_with_all_ciphers(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    SSL_SESSION *sess = NULL;
    unsigned char buf[20];
    size_t readbytes, written;
    const SSL_CIPHER *cipher;
    time_t timer;
    const char *cipher_str[] = {
        TLS1_3_RFC_AES_128_GCM_SHA256,
        TLS1_3_RFC_AES_256_GCM_SHA384,
# if !defined(OPENSSL_NO_CHACHA) && !defined(OPENSSL_NO_POLY1305)
        TLS1_3_RFC_CHACHA20_POLY1305_SHA256,
# else
        NULL,
# endif
        TLS1_3_RFC_AES_128_CCM_SHA256,
        TLS1_3_RFC_AES_128_CCM_8_SHA256
    };
    const unsigned char *cipher_bytes[] = {
        TLS13_AES_128_GCM_SHA256_BYTES,
        TLS13_AES_256_GCM_SHA384_BYTES,
# if !defined(OPENSSL_NO_CHACHA) && !defined(OPENSSL_NO_POLY1305)
        TLS13_CHACHA20_POLY1305_SHA256_BYTES,
# else
        NULL,
# endif
        TLS13_AES_128_CCM_SHA256_BYTES,
        TLS13_AES_128_CCM_8_SHA256_BYTES
    };

    if (cipher_str[idx] == NULL)
        return 1;
    /* Skip ChaCha20Poly1305 as currently FIPS module does not support it */
    if (idx == 2 && is_fips == 1)
        return 1;

    /* We always set this up with a final parameter of "2" for PSK */
    if (!TEST_true(setupearly_data_test(&cctx, &sctx, &clientssl,
                                        &serverssl, &sess, 2,
                                        SHA384_DIGEST_LENGTH)))
        goto end;

    if (!TEST_true(SSL_set_ciphersuites(clientssl, cipher_str[idx]))
            || !TEST_true(SSL_set_ciphersuites(serverssl, cipher_str[idx])))
        goto end;

    /*
     * 'setupearly_data_test' creates only one instance of SSL_SESSION
     * and assigns to both client and server with incremented reference
     * and the same instance is updated in 'sess'.
     * So updating ciphersuite in 'sess' which will get reflected in
     * PSK handshake using psk use sess and find sess cb.
     */
    cipher = SSL_CIPHER_find(clientssl, cipher_bytes[idx]);
    if (!TEST_ptr(cipher) || !TEST_true(SSL_SESSION_set_cipher(sess, cipher)))
        goto end;

    SSL_set_connect_state(clientssl);
    timer = time(NULL);
    if (!TEST_true(SSL_write_early_data(clientssl, MSG1, strlen(MSG1),
                                        &written)))
        goto end;

    if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                         &readbytes),
                                         SSL_READ_EARLY_DATA_SUCCESS)) {
        testresult = check_early_data_timeout(timer);
        goto end;
    }

    if (!TEST_mem_eq(buf, readbytes, MSG1, strlen(MSG1))
            || !TEST_int_eq(SSL_get_early_data_status(serverssl),
                                                      SSL_EARLY_DATA_ACCEPTED)
            || !TEST_int_eq(SSL_connect(clientssl), 1)
            || !TEST_int_eq(SSL_accept(serverssl), 1))
        goto end;

    /* Send some normal data from client to server */
    if (!TEST_true(SSL_write_ex(clientssl, MSG2, strlen(MSG2), &written))
            || !TEST_size_t_eq(written, strlen(MSG2)))
        goto end;

    if (!TEST_true(SSL_read_ex(serverssl, buf, sizeof(buf), &readbytes))
            || !TEST_mem_eq(buf, readbytes, MSG2, strlen(MSG2)))
        goto end;

    testresult = 1;
 end:
    SSL_SESSION_free(sess);
    SSL_SESSION_free(clientpsk);
    SSL_SESSION_free(serverpsk);
    clientpsk = serverpsk = NULL;
    if (clientssl != NULL)
        SSL_shutdown(clientssl);
    if (serverssl != NULL)
        SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

/*
 * Test that a server that doesn't try to read early data can handle a
 * client sending some.
 */
static int test_early_data_not_expected(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    SSL_SESSION *sess = NULL;
    unsigned char buf[20];
    size_t readbytes, written;

    if (!TEST_true(setupearly_data_test(&cctx, &sctx, &clientssl,
                                        &serverssl, &sess, idx,
                                        SHA384_DIGEST_LENGTH)))
        goto end;

    /* Write some early data */
    if (!TEST_true(SSL_write_early_data(clientssl, MSG1, strlen(MSG1),
                                        &written)))
        goto end;

    /*
     * Server should skip over early data and then block waiting for client to
     * continue handshake
     */
    if (!TEST_int_le(SSL_accept(serverssl), 0)
     || !TEST_int_gt(SSL_connect(clientssl), 0)
     || !TEST_int_eq(SSL_get_early_data_status(serverssl),
                     SSL_EARLY_DATA_REJECTED)
     || !TEST_int_gt(SSL_accept(serverssl), 0)
     || !TEST_int_eq(SSL_get_early_data_status(clientssl),
                     SSL_EARLY_DATA_REJECTED))
        goto end;

    /* Send some normal data from client to server */
    if (!TEST_true(SSL_write_ex(clientssl, MSG2, strlen(MSG2), &written))
            || !TEST_size_t_eq(written, strlen(MSG2)))
        goto end;

    if (!TEST_true(SSL_read_ex(serverssl, buf, sizeof(buf), &readbytes))
            || !TEST_mem_eq(buf, readbytes, MSG2, strlen(MSG2)))
        goto end;

    testresult = 1;

 end:
    SSL_SESSION_free(sess);
    SSL_SESSION_free(clientpsk);
    SSL_SESSION_free(serverpsk);
    clientpsk = serverpsk = NULL;
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}


# ifndef OPENSSL_NO_TLS1_2
/*
 * Test that a server attempting to read early data can handle a connection
 * from a TLSv1.2 client.
 */
static int test_early_data_tls1_2(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    unsigned char buf[20];
    size_t readbytes, written;

    if (!TEST_true(setupearly_data_test(&cctx, &sctx, &clientssl,
                                        &serverssl, NULL, idx,
                                        SHA384_DIGEST_LENGTH)))
        goto end;

    /* Write some data - should block due to handshake with server */
    SSL_set_max_proto_version(clientssl, TLS1_2_VERSION);
    SSL_set_connect_state(clientssl);
    if (!TEST_false(SSL_write_ex(clientssl, MSG1, strlen(MSG1), &written)))
        goto end;

    /*
     * Server should do TLSv1.2 handshake. First it will block waiting for more
     * messages from client after ServerDone. Then SSL_read_early_data should
     * finish and detect that early data has not been sent
     */
    if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                         &readbytes),
                     SSL_READ_EARLY_DATA_ERROR))
        goto end;

    /*
     * Continue writing the message we started earlier. Will still block waiting
     * for the CCS/Finished from server
     */
    if (!TEST_false(SSL_write_ex(clientssl, MSG1, strlen(MSG1), &written))
            || !TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                                &readbytes),
                            SSL_READ_EARLY_DATA_FINISH)
            || !TEST_size_t_eq(readbytes, 0)
            || !TEST_int_eq(SSL_get_early_data_status(serverssl),
                            SSL_EARLY_DATA_NOT_SENT))
        goto end;

    /* Continue writing the message we started earlier */
    if (!TEST_true(SSL_write_ex(clientssl, MSG1, strlen(MSG1), &written))
            || !TEST_size_t_eq(written, strlen(MSG1))
            || !TEST_int_eq(SSL_get_early_data_status(clientssl),
                            SSL_EARLY_DATA_NOT_SENT)
            || !TEST_true(SSL_read_ex(serverssl, buf, sizeof(buf), &readbytes))
            || !TEST_mem_eq(buf, readbytes, MSG1, strlen(MSG1))
            || !TEST_true(SSL_write_ex(serverssl, MSG2, strlen(MSG2), &written))
            || !TEST_size_t_eq(written, strlen(MSG2))
            || !SSL_read_ex(clientssl, buf, sizeof(buf), &readbytes)
            || !TEST_mem_eq(buf, readbytes, MSG2, strlen(MSG2)))
        goto end;

    testresult = 1;

 end:
    SSL_SESSION_free(clientpsk);
    SSL_SESSION_free(serverpsk);
    clientpsk = serverpsk = NULL;
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}
# endif /* OPENSSL_NO_TLS1_2 */

/*
 * Test configuring the TLSv1.3 ciphersuites
 *
 * Test 0: Set a default ciphersuite in the SSL_CTX (no explicit cipher_list)
 * Test 1: Set a non-default ciphersuite in the SSL_CTX (no explicit cipher_list)
 * Test 2: Set a default ciphersuite in the SSL (no explicit cipher_list)
 * Test 3: Set a non-default ciphersuite in the SSL (no explicit cipher_list)
 * Test 4: Set a default ciphersuite in the SSL_CTX (SSL_CTX cipher_list)
 * Test 5: Set a non-default ciphersuite in the SSL_CTX (SSL_CTX cipher_list)
 * Test 6: Set a default ciphersuite in the SSL (SSL_CTX cipher_list)
 * Test 7: Set a non-default ciphersuite in the SSL (SSL_CTX cipher_list)
 * Test 8: Set a default ciphersuite in the SSL (SSL cipher_list)
 * Test 9: Set a non-default ciphersuite in the SSL (SSL cipher_list)
 */
static int test_set_ciphersuite(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey))
            || !TEST_true(SSL_CTX_set_ciphersuites(sctx,
                           "TLS_AES_128_GCM_SHA256:TLS_AES_128_CCM_SHA256")))
        goto end;

    if (idx >=4 && idx <= 7) {
        /* SSL_CTX explicit cipher list */
        if (!TEST_true(SSL_CTX_set_cipher_list(cctx, "AES256-GCM-SHA384")))
            goto end;
    }

    if (idx == 0 || idx == 4) {
        /* Default ciphersuite */
        if (!TEST_true(SSL_CTX_set_ciphersuites(cctx,
                                                "TLS_AES_128_GCM_SHA256")))
            goto end;
    } else if (idx == 1 || idx == 5) {
        /* Non default ciphersuite */
        if (!TEST_true(SSL_CTX_set_ciphersuites(cctx,
                                                "TLS_AES_128_CCM_SHA256")))
            goto end;
    }

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                          &clientssl, NULL, NULL)))
        goto end;

    if (idx == 8 || idx == 9) {
        /* SSL explicit cipher list */
        if (!TEST_true(SSL_set_cipher_list(clientssl, "AES256-GCM-SHA384")))
            goto end;
    }

    if (idx == 2 || idx == 6 || idx == 8) {
        /* Default ciphersuite */
        if (!TEST_true(SSL_set_ciphersuites(clientssl,
                                            "TLS_AES_128_GCM_SHA256")))
            goto end;
    } else if (idx == 3 || idx == 7 || idx == 9) {
        /* Non default ciphersuite */
        if (!TEST_true(SSL_set_ciphersuites(clientssl,
                                            "TLS_AES_128_CCM_SHA256")))
            goto end;
    }

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

static int test_ciphersuite_change(void)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    SSL_SESSION *clntsess = NULL;
    int testresult = 0;
    const SSL_CIPHER *aes_128_gcm_sha256 = NULL;

    /* Create a session based on SHA-256 */
    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey))
            || !TEST_true(SSL_CTX_set_ciphersuites(sctx,
                                                   "TLS_AES_128_GCM_SHA256:"
                                                   "TLS_AES_256_GCM_SHA384:"
                                                   "TLS_AES_128_CCM_SHA256"))
            || !TEST_true(SSL_CTX_set_ciphersuites(cctx,
                                                   "TLS_AES_128_GCM_SHA256"))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                          &clientssl, NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    clntsess = SSL_get1_session(clientssl);
    /* Save for later */
    aes_128_gcm_sha256 = SSL_SESSION_get0_cipher(clntsess);
    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    /* Check we can resume a session with a different SHA-256 ciphersuite */
    if (!TEST_true(SSL_CTX_set_ciphersuites(cctx,
                                            "TLS_AES_128_CCM_SHA256"))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                             &clientssl, NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl, clntsess))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE))
            || !TEST_true(SSL_session_reused(clientssl)))
        goto end;

    SSL_SESSION_free(clntsess);
    clntsess = SSL_get1_session(clientssl);
    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    /*
     * Check attempting to resume a SHA-256 session with no SHA-256 ciphersuites
     * succeeds but does not resume.
     */
    if (!TEST_true(SSL_CTX_set_ciphersuites(cctx, "TLS_AES_256_GCM_SHA384"))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl, clntsess))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_SSL))
            || !TEST_false(SSL_session_reused(clientssl)))
        goto end;

    SSL_SESSION_free(clntsess);
    clntsess = NULL;
    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    /* Create a session based on SHA384 */
    if (!TEST_true(SSL_CTX_set_ciphersuites(cctx, "TLS_AES_256_GCM_SHA384"))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                          &clientssl, NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    clntsess = SSL_get1_session(clientssl);
    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    if (!TEST_true(SSL_CTX_set_ciphersuites(cctx,
                   "TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384"))
            || !TEST_true(SSL_CTX_set_ciphersuites(sctx,
                                                   "TLS_AES_256_GCM_SHA384"))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl, clntsess))
               /*
                * We use SSL_ERROR_WANT_READ below so that we can pause the
                * connection after the initial ClientHello has been sent to
                * enable us to make some session changes.
                */
            || !TEST_false(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_WANT_READ)))
        goto end;

    /* Trick the client into thinking this session is for a different digest */
    clntsess->cipher = aes_128_gcm_sha256;
    clntsess->cipher_id = clntsess->cipher->id;

    /*
     * Continue the previously started connection. Server has selected a SHA-384
     * ciphersuite, but client thinks the session is for SHA-256, so it should
     * bail out.
     */
    if (!TEST_false(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_SSL))
            || !TEST_int_eq(ERR_GET_REASON(ERR_get_error()),
                            SSL_R_CIPHERSUITE_DIGEST_HAS_CHANGED))
        goto end;

    testresult = 1;

 end:
    SSL_SESSION_free(clntsess);
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

/*
 * Test TLSv1.3 Key exchange
 * Test 0 = Test all ECDHE Key exchange with TLSv1.3 client and server
 * Test 1 = Test NID_X9_62_prime256v1 with TLSv1.3 client and server
 * Test 2 = Test NID_secp384r1 with TLSv1.3 client and server
 * Test 3 = Test NID_secp521r1 with TLSv1.3 client and server
 * Test 4 = Test NID_X25519 with TLSv1.3 client and server
 * Test 5 = Test NID_X448 with TLSv1.3 client and server
 * Test 6 = Test all FFDHE Key exchange with TLSv1.3 client and server
 * Test 7 = Test NID_ffdhe2048 with TLSv1.3 client and server
 * Test 8 = Test NID_ffdhe3072 with TLSv1.3 client and server
 * Test 9 = Test NID_ffdhe4096 with TLSv1.3 client and server
 * Test 10 = Test NID_ffdhe6144 with TLSv1.3 client and server
 * Test 11 = Test NID_ffdhe8192 with TLSv1.3 client and server
 * Test 12 = Test all ECDHE with TLSv1.2 client and server
 * Test 13 = Test all FFDHE with TLSv1.2 client and server
 */
# ifndef OPENSSL_NO_EC
static int ecdhe_kexch_groups[] = {NID_X9_62_prime256v1, NID_secp384r1,
                                   NID_secp521r1, NID_X25519, NID_X448};
# endif
# ifndef OPENSSL_NO_DH
static int ffdhe_kexch_groups[] = {NID_ffdhe2048, NID_ffdhe3072, NID_ffdhe4096,
                                   NID_ffdhe6144, NID_ffdhe8192};
# endif
static int test_key_exchange(int idx)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *serverssl = NULL, *clientssl = NULL;
    int testresult = 0;
    int kexch_alg;
    int *kexch_groups = &kexch_alg;
    int kexch_groups_size = 1;
    int max_version = TLS1_3_VERSION;
    char *kexch_name0 = NULL;

    switch (idx) {
# ifndef OPENSSL_NO_EC
# ifndef OPENSSL_NO_TLS1_2
        case 12:
            max_version = TLS1_2_VERSION;
# endif
            /* Fall through */
        case 0:
            kexch_groups = ecdhe_kexch_groups;
            kexch_groups_size = OSSL_NELEM(ecdhe_kexch_groups);
            kexch_name0 = "secp256r1";
            break;
        case 1:
            kexch_alg = NID_X9_62_prime256v1;
            kexch_name0 = "secp256r1";
            break;
        case 2:
            kexch_alg = NID_secp384r1;
            kexch_name0 = "secp384r1";
            break;
        case 3:
            kexch_alg = NID_secp521r1;
            kexch_name0 = "secp521r1";
            break;
        case 4:
            if (is_fips)
                return TEST_skip("X25519 might not be supported by fips provider.");
            kexch_alg = NID_X25519;
            kexch_name0 = "x25519";
            break;
        case 5:
            if (is_fips)
                return TEST_skip("X448 might not be supported by fips provider.");
            kexch_alg = NID_X448;
            kexch_name0 = "x448";
            break;
# endif
# ifndef OPENSSL_NO_DH
# ifndef OPENSSL_NO_TLS1_2
        case 13:
            max_version = TLS1_2_VERSION;
            kexch_name0 = "ffdhe2048";
# endif
            /* Fall through */
        case 6:
            kexch_groups = ffdhe_kexch_groups;
            kexch_groups_size = OSSL_NELEM(ffdhe_kexch_groups);
            kexch_name0 = "ffdhe2048";
            break;
        case 7:
            kexch_alg = NID_ffdhe2048;
            kexch_name0 = "ffdhe2048";
            break;
        case 8:
            kexch_alg = NID_ffdhe3072;
            kexch_name0 = "ffdhe3072";
            break;
        case 9:
            kexch_alg = NID_ffdhe4096;
            kexch_name0 = "ffdhe4096";
            break;
        case 10:
            kexch_alg = NID_ffdhe6144;
            kexch_name0 = "ffdhe6144";
            break;
        case 11:
            kexch_alg = NID_ffdhe8192;
            kexch_name0 = "ffdhe8192";
            break;
# endif
        default:
            /* We're skipping this test */
            return 1;
    }

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION,
                                       max_version, &sctx, &cctx, cert,
                                       privkey)))
        goto end;

    if (!TEST_true(SSL_CTX_set_ciphersuites(sctx,
                   TLS1_3_RFC_AES_128_GCM_SHA256)))
        goto end;

    if (!TEST_true(SSL_CTX_set_ciphersuites(cctx,
                   TLS1_3_RFC_AES_128_GCM_SHA256)))
        goto end;

    if (!TEST_true(SSL_CTX_set_cipher_list(sctx,
                   TLS1_TXT_ECDHE_RSA_WITH_AES_128_GCM_SHA256 ":"
                   TLS1_TXT_DHE_RSA_WITH_AES_128_GCM_SHA256))
            || !TEST_true(SSL_CTX_set_dh_auto(sctx, 1)))
        goto end;

    /*
     * Must include an EC ciphersuite so that we send supported groups in
     * TLSv1.2
     */
# ifndef OPENSSL_NO_TLS1_2
    if (!TEST_true(SSL_CTX_set_cipher_list(cctx,
                   TLS1_TXT_ECDHE_RSA_WITH_AES_128_GCM_SHA256 ":"
                   TLS1_TXT_DHE_RSA_WITH_AES_128_GCM_SHA256)))
        goto end;
# endif

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL)))
        goto end;

    if (!TEST_true(SSL_set1_groups(serverssl, kexch_groups, kexch_groups_size))
        || !TEST_true(SSL_set1_groups(clientssl, kexch_groups, kexch_groups_size)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    /*
     * If Handshake succeeds the negotiated kexch alg should be the first one in
     * configured, except in the case of FFDHE groups (idx 13), which are
     * TLSv1.3 only so we expect no shared group to exist.
     */
    if (!TEST_int_eq(SSL_get_shared_group(serverssl, 0),
                     idx == 13 ? 0 : kexch_groups[0]))
        goto end;

    if (!TEST_str_eq(SSL_group_to_name(serverssl, kexch_groups[0]),
                     kexch_name0))
        goto end;

    /* We don't implement RFC 7919 named groups for TLS 1.2. */
    if (idx != 13) {
        if (!TEST_int_eq(SSL_get_negotiated_group(serverssl), kexch_groups[0]))
            goto end;
        if (!TEST_int_eq(SSL_get_negotiated_group(clientssl), kexch_groups[0]))
            goto end;
    }

    testresult = 1;
 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

# if !defined(OPENSSL_NO_TLS1_2) \
     && !defined(OPENSSL_NO_EC)  \
     && !defined(OPENSSL_NO_DH)
static int set_ssl_groups(SSL *serverssl, SSL *clientssl, int clientmulti,
                          int isecdhe, int idx)
{
    int kexch_alg;
    int *kexch_groups = &kexch_alg;
    int numec, numff;

    numec = OSSL_NELEM(ecdhe_kexch_groups);
    numff = OSSL_NELEM(ffdhe_kexch_groups);
    if (isecdhe)
        kexch_alg = ecdhe_kexch_groups[idx];
    else
        kexch_alg = ffdhe_kexch_groups[idx];

    if (clientmulti) {
        if (!TEST_true(SSL_set1_groups(serverssl, kexch_groups, 1)))
            return 0;
        if (isecdhe) {
            if (!TEST_true(SSL_set1_groups(clientssl, ecdhe_kexch_groups,
                                           numec)))
                return 0;
        } else {
            if (!TEST_true(SSL_set1_groups(clientssl, ffdhe_kexch_groups,
                                           numff)))
                return 0;
        }
    } else {
        if (!TEST_true(SSL_set1_groups(clientssl, kexch_groups, 1)))
            return 0;
        if (isecdhe) {
            if (!TEST_true(SSL_set1_groups(serverssl, ecdhe_kexch_groups,
                                           numec)))
                return 0;
        } else {
            if (!TEST_true(SSL_set1_groups(serverssl, ffdhe_kexch_groups,
                                           numff)))
                return 0;
        }
    }
    return 1;
}

/*-
 * Test the SSL_get_negotiated_group() API across a battery of scenarios.
 * Run through both the ECDHE and FFDHE group lists used in the previous
 * test, for both TLS 1.2 and TLS 1.3, negotiating each group in turn,
 * confirming the expected result; then perform a resumption handshake
 * while offering the same group list, and another resumption handshake
 * offering a different group list.  The returned value should be the
 * negotiated group for the initial handshake; for TLS 1.3 resumption
 * handshakes the returned value will be negotiated on the resumption
 * handshake itself, but for TLS 1.2 resumption handshakes the value will
 * be cached in the session from the original handshake, regardless of what
 * was offered in the resumption ClientHello.
 *
 * Using E for the number of EC groups and F for the number of FF groups:
 * E tests of ECDHE with TLS 1.3, server only has one group
 * F tests of FFDHE with TLS 1.3, server only has one group
 * E tests of ECDHE with TLS 1.2, server only has one group
 * F tests of FFDHE with TLS 1.2, server only has one group
 * E tests of ECDHE with TLS 1.3, client sends only one group
 * F tests of FFDHE with TLS 1.3, client sends only one group
 * E tests of ECDHE with TLS 1.2, client sends only one group
 * F tests of FFDHE with TLS 1.2, client sends only one group
 */
static int test_negotiated_group(int idx)
{
    int clientmulti, istls13, isecdhe, numec, numff, numgroups;
    int expectednid;
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *serverssl = NULL, *clientssl = NULL;
    SSL_SESSION *origsess = NULL;
    int testresult = 0;
    int kexch_alg;
    int max_version = TLS1_3_VERSION;

    numec = OSSL_NELEM(ecdhe_kexch_groups);
    numff = OSSL_NELEM(ffdhe_kexch_groups);
    numgroups = numec + numff;
    clientmulti = (idx < 2 * numgroups);
    idx = idx % (2 * numgroups);
    istls13 = (idx < numgroups);
    idx = idx % numgroups;
    isecdhe = (idx < numec);
    if (!isecdhe)
        idx -= numec;
    /* Now 'idx' is an index into ecdhe_kexch_groups or ffdhe_kexch_groups */
    if (isecdhe)
        kexch_alg = ecdhe_kexch_groups[idx];
    else
        kexch_alg = ffdhe_kexch_groups[idx];
    /* We expect nothing for the unimplemented TLS 1.2 FFDHE named groups */
    if (!istls13 && !isecdhe)
        expectednid = NID_undef;
    else
        expectednid = kexch_alg;

    if (is_fips && (kexch_alg == NID_X25519 || kexch_alg == NID_X448))
        return TEST_skip("X25519 and X448 might not be available in fips provider.");

    if (!istls13)
        max_version = TLS1_2_VERSION;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION,
                                       max_version, &sctx, &cctx, cert,
                                       privkey)))
        goto end;

    /*
     * Force (EC)DHE ciphers for TLS 1.2.
     * Be sure to enable auto tmp DH so that FFDHE can succeed.
     */
    if (!TEST_true(SSL_CTX_set_cipher_list(sctx,
                   TLS1_TXT_ECDHE_RSA_WITH_AES_128_GCM_SHA256 ":"
                   TLS1_TXT_DHE_RSA_WITH_AES_128_GCM_SHA256))
            || !TEST_true(SSL_CTX_set_dh_auto(sctx, 1)))
        goto end;
    if (!TEST_true(SSL_CTX_set_cipher_list(cctx,
                   TLS1_TXT_ECDHE_RSA_WITH_AES_128_GCM_SHA256 ":"
                   TLS1_TXT_DHE_RSA_WITH_AES_128_GCM_SHA256)))
        goto end;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL)))
        goto end;

    if (!TEST_true(set_ssl_groups(serverssl, clientssl, clientmulti, isecdhe,
                                  idx)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    /* Initial handshake; always the configured one */
    if (!TEST_uint_eq(SSL_get_negotiated_group(clientssl), expectednid)
            || !TEST_uint_eq(SSL_get_negotiated_group(serverssl), expectednid))
        goto end;

    if (!TEST_ptr((origsess = SSL_get1_session(clientssl))))
        goto end;

    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    /* First resumption attempt; use the same config as initial handshake */
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl, origsess))
            || !TEST_true(set_ssl_groups(serverssl, clientssl, clientmulti,
                                         isecdhe, idx)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE))
            || !TEST_true(SSL_session_reused(clientssl)))
        goto end;

    /* Still had better agree, since nothing changed... */
    if (!TEST_uint_eq(SSL_get_negotiated_group(clientssl), expectednid)
            || !TEST_uint_eq(SSL_get_negotiated_group(serverssl), expectednid))
        goto end;

    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    /*-
     * Second resumption attempt
     * The party that picks one group changes it, which we effectuate by
     * changing 'idx' and updating what we expect.
     */
    if (idx == 0)
        idx = 1;
    else
        idx--;
    if (istls13) {
        if (isecdhe)
            expectednid = ecdhe_kexch_groups[idx];
        else
            expectednid = ffdhe_kexch_groups[idx];
        /* Verify that we are changing what we expect. */
        if (!TEST_int_ne(expectednid, kexch_alg))
            goto end;
    } else {
        /* TLS 1.2 only supports named groups for ECDHE. */
        if (isecdhe)
            expectednid = kexch_alg;
        else
            expectednid = 0;
    }
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl, origsess))
            || !TEST_true(set_ssl_groups(serverssl, clientssl, clientmulti,
                                         isecdhe, idx)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE))
            || !TEST_true(SSL_session_reused(clientssl)))
        goto end;

    /* Check that we get what we expected */
    if (!TEST_uint_eq(SSL_get_negotiated_group(clientssl), expectednid)
            || !TEST_uint_eq(SSL_get_negotiated_group(serverssl), expectednid))
        goto end;

    testresult = 1;
 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    SSL_SESSION_free(origsess);
    return testresult;
}
# endif /* !defined(OPENSSL_NO_EC) && !defined(OPENSSL_NO_DH) */

/*
 * Test TLSv1.3 Cipher Suite
 * Test 0 = Set TLS1.3 cipher on context
 * Test 1 = Set TLS1.3 cipher on SSL
 * Test 2 = Set TLS1.3 and TLS1.2 cipher on context
 * Test 3 = Set TLS1.3 and TLS1.2 cipher on SSL
 */
static int test_tls13_ciphersuite(int idx)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *serverssl = NULL, *clientssl = NULL;
    static const struct {
        const char *ciphername;
        int fipscapable;
    } t13_ciphers[] = {
        { TLS1_3_RFC_AES_128_GCM_SHA256, 1 },
        { TLS1_3_RFC_AES_256_GCM_SHA384, 1 },
        { TLS1_3_RFC_AES_128_CCM_SHA256, 1 },
# if !defined(OPENSSL_NO_CHACHA) && !defined(OPENSSL_NO_POLY1305)
        { TLS1_3_RFC_CHACHA20_POLY1305_SHA256, 0 },
        { TLS1_3_RFC_AES_256_GCM_SHA384
          ":" TLS1_3_RFC_CHACHA20_POLY1305_SHA256, 0 },
# endif
        { TLS1_3_RFC_AES_128_CCM_8_SHA256 ":" TLS1_3_RFC_AES_128_CCM_SHA256, 1 }
    };
    const char *t13_cipher = NULL;
    const char *t12_cipher = NULL;
    const char *negotiated_scipher;
    const char *negotiated_ccipher;
    int set_at_ctx = 0;
    int set_at_ssl = 0;
    int testresult = 0;
    int max_ver;
    size_t i;

    switch (idx) {
        case 0:
            set_at_ctx = 1;
            break;
        case 1:
            set_at_ssl = 1;
            break;
        case 2:
            set_at_ctx = 1;
            t12_cipher = TLS1_TXT_RSA_WITH_AES_128_SHA256;
            break;
        case 3:
            set_at_ssl = 1;
            t12_cipher = TLS1_TXT_RSA_WITH_AES_128_SHA256;
            break;
    }

    for (max_ver = TLS1_2_VERSION; max_ver <= TLS1_3_VERSION; max_ver++) {
# ifdef OPENSSL_NO_TLS1_2
        if (max_ver == TLS1_2_VERSION)
            continue;
# endif
        for (i = 0; i < OSSL_NELEM(t13_ciphers); i++) {
            if (is_fips && !t13_ciphers[i].fipscapable)
                continue;
            t13_cipher = t13_ciphers[i].ciphername;
            if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                               TLS_client_method(),
                                               TLS1_VERSION, max_ver,
                                               &sctx, &cctx, cert, privkey)))
                goto end;

            if (set_at_ctx) {
                if (!TEST_true(SSL_CTX_set_ciphersuites(sctx, t13_cipher))
                    || !TEST_true(SSL_CTX_set_ciphersuites(cctx, t13_cipher)))
                    goto end;
                if (t12_cipher != NULL) {
                    if (!TEST_true(SSL_CTX_set_cipher_list(sctx, t12_cipher))
                        || !TEST_true(SSL_CTX_set_cipher_list(cctx,
                                                              t12_cipher)))
                        goto end;
                }
            }

            if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                              &clientssl, NULL, NULL)))
                goto end;

            if (set_at_ssl) {
                if (!TEST_true(SSL_set_ciphersuites(serverssl, t13_cipher))
                    || !TEST_true(SSL_set_ciphersuites(clientssl, t13_cipher)))
                    goto end;
                if (t12_cipher != NULL) {
                    if (!TEST_true(SSL_set_cipher_list(serverssl, t12_cipher))
                        || !TEST_true(SSL_set_cipher_list(clientssl,
                                                          t12_cipher)))
                        goto end;
                }
            }

            if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                                 SSL_ERROR_NONE)))
                goto end;

            negotiated_scipher = SSL_CIPHER_get_name(SSL_get_current_cipher(
                                                                 serverssl));
            negotiated_ccipher = SSL_CIPHER_get_name(SSL_get_current_cipher(
                                                                 clientssl));
            if (!TEST_str_eq(negotiated_scipher, negotiated_ccipher))
                goto end;

            /*
             * TEST_strn_eq is used below because t13_cipher can contain
             * multiple ciphersuites
             */
            if (max_ver == TLS1_3_VERSION
                && !TEST_strn_eq(t13_cipher, negotiated_scipher,
                                 strlen(negotiated_scipher)))
                goto end;

# ifndef OPENSSL_NO_TLS1_2
            /* Below validation is not done when t12_cipher is NULL */
            if (max_ver == TLS1_2_VERSION && t12_cipher != NULL
                && !TEST_str_eq(t12_cipher, negotiated_scipher))
                goto end;
# endif

            SSL_free(serverssl);
            serverssl = NULL;
            SSL_free(clientssl);
            clientssl = NULL;
            SSL_CTX_free(sctx);
            sctx = NULL;
            SSL_CTX_free(cctx);
            cctx = NULL;
        }
    }

    testresult = 1;
 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

/*
 * Test TLSv1.3 PSKs
 * Test 0 = Test new style callbacks
 * Test 1 = Test both new and old style callbacks
 * Test 2 = Test old style callbacks
 * Test 3 = Test old style callbacks with no certificate
 */
static int test_tls13_psk(int idx)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *serverssl = NULL, *clientssl = NULL;
    const SSL_CIPHER *cipher = NULL;
    const unsigned char key[] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
        0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
        0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f
    };
    int testresult = 0;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, idx == 3 ? NULL : cert,
                                       idx == 3 ? NULL : privkey)))
        goto end;

    if (idx != 3) {
        /*
         * We use a ciphersuite with SHA256 to ease testing old style PSK
         * callbacks which will always default to SHA256. This should not be
         * necessary if we have no cert/priv key. In that case the server should
         * prefer SHA256 automatically.
         */
        if (!TEST_true(SSL_CTX_set_ciphersuites(cctx,
                                                "TLS_AES_128_GCM_SHA256")))
            goto end;
    } else {
        /*
         * As noted above the server should prefer SHA256 automatically. However
         * we are careful not to offer TLS_CHACHA20_POLY1305_SHA256 so this same
         * code works even if we are testing with only the FIPS provider loaded.
         */
        if (!TEST_true(SSL_CTX_set_ciphersuites(cctx,
                                                "TLS_AES_256_GCM_SHA384:"
                                                "TLS_AES_128_GCM_SHA256")))
            goto end;
    }

    /*
     * Test 0: New style callbacks only
     * Test 1: New and old style callbacks (only the new ones should be used)
     * Test 2: Old style callbacks only
     */
    if (idx == 0 || idx == 1) {
        SSL_CTX_set_psk_use_session_callback(cctx, use_session_cb);
        SSL_CTX_set_psk_find_session_callback(sctx, find_session_cb);
    }
#ifndef OPENSSL_NO_PSK
    if (idx >= 1) {
        SSL_CTX_set_psk_client_callback(cctx, psk_client_cb);
        SSL_CTX_set_psk_server_callback(sctx, psk_server_cb);
    }
#endif
    srvid = pskid;
    use_session_cb_cnt = 0;
    find_session_cb_cnt = 0;
    psk_client_cb_cnt = 0;
    psk_server_cb_cnt = 0;

    if (idx != 3) {
        /*
         * Check we can create a connection if callback decides not to send a
         * PSK
         */
        if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                                 NULL, NULL))
                || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                    SSL_ERROR_NONE))
                || !TEST_false(SSL_session_reused(clientssl))
                || !TEST_false(SSL_session_reused(serverssl)))
            goto end;

        if (idx == 0 || idx == 1) {
            if (!TEST_true(use_session_cb_cnt == 1)
                    || !TEST_true(find_session_cb_cnt == 0)
                       /*
                        * If no old style callback then below should be 0
                        * otherwise 1
                        */
                    || !TEST_true(psk_client_cb_cnt == idx)
                    || !TEST_true(psk_server_cb_cnt == 0))
                goto end;
        } else {
            if (!TEST_true(use_session_cb_cnt == 0)
                    || !TEST_true(find_session_cb_cnt == 0)
                    || !TEST_true(psk_client_cb_cnt == 1)
                    || !TEST_true(psk_server_cb_cnt == 0))
                goto end;
        }

        shutdown_ssl_connection(serverssl, clientssl);
        serverssl = clientssl = NULL;
        use_session_cb_cnt = psk_client_cb_cnt = 0;
    }

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL)))
        goto end;

    /* Create the PSK */
    cipher = SSL_CIPHER_find(clientssl, TLS13_AES_128_GCM_SHA256_BYTES);
    clientpsk = SSL_SESSION_new();
    if (!TEST_ptr(clientpsk)
            || !TEST_ptr(cipher)
            || !TEST_true(SSL_SESSION_set1_master_key(clientpsk, key,
                                                      sizeof(key)))
            || !TEST_true(SSL_SESSION_set_cipher(clientpsk, cipher))
            || !TEST_true(SSL_SESSION_set_protocol_version(clientpsk,
                                                           TLS1_3_VERSION))
            || !TEST_true(SSL_SESSION_up_ref(clientpsk)))
        goto end;
    serverpsk = clientpsk;

    /* Check we can create a connection and the PSK is used */
    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE))
            || !TEST_true(SSL_session_reused(clientssl))
            || !TEST_true(SSL_session_reused(serverssl)))
        goto end;

    if (idx == 0 || idx == 1) {
        if (!TEST_true(use_session_cb_cnt == 1)
                || !TEST_true(find_session_cb_cnt == 1)
                || !TEST_true(psk_client_cb_cnt == 0)
                || !TEST_true(psk_server_cb_cnt == 0))
            goto end;
    } else {
        if (!TEST_true(use_session_cb_cnt == 0)
                || !TEST_true(find_session_cb_cnt == 0)
                || !TEST_true(psk_client_cb_cnt == 1)
                || !TEST_true(psk_server_cb_cnt == 1))
            goto end;
    }

    shutdown_ssl_connection(serverssl, clientssl);
    serverssl = clientssl = NULL;
    use_session_cb_cnt = find_session_cb_cnt = 0;
    psk_client_cb_cnt = psk_server_cb_cnt = 0;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL)))
        goto end;

    /* Force an HRR */
#if defined(OPENSSL_NO_EC)
    if (!TEST_true(SSL_set1_groups_list(serverssl, "ffdhe3072")))
        goto end;
#else
    if (!TEST_true(SSL_set1_groups_list(serverssl, "P-384")))
        goto end;
#endif

    /*
     * Check we can create a connection, the PSK is used and the callbacks are
     * called twice.
     */
    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE))
            || !TEST_true(SSL_session_reused(clientssl))
            || !TEST_true(SSL_session_reused(serverssl)))
        goto end;

    if (idx == 0 || idx == 1) {
        if (!TEST_true(use_session_cb_cnt == 2)
                || !TEST_true(find_session_cb_cnt == 2)
                || !TEST_true(psk_client_cb_cnt == 0)
                || !TEST_true(psk_server_cb_cnt == 0))
            goto end;
    } else {
        if (!TEST_true(use_session_cb_cnt == 0)
                || !TEST_true(find_session_cb_cnt == 0)
                || !TEST_true(psk_client_cb_cnt == 2)
                || !TEST_true(psk_server_cb_cnt == 2))
            goto end;
    }

    shutdown_ssl_connection(serverssl, clientssl);
    serverssl = clientssl = NULL;
    use_session_cb_cnt = find_session_cb_cnt = 0;
    psk_client_cb_cnt = psk_server_cb_cnt = 0;

    if (idx != 3) {
        /*
         * Check that if the server rejects the PSK we can still connect, but with
         * a full handshake
         */
        srvid = "Dummy Identity";
        if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                                 NULL, NULL))
                || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                    SSL_ERROR_NONE))
                || !TEST_false(SSL_session_reused(clientssl))
                || !TEST_false(SSL_session_reused(serverssl)))
            goto end;

        if (idx == 0 || idx == 1) {
            if (!TEST_true(use_session_cb_cnt == 1)
                    || !TEST_true(find_session_cb_cnt == 1)
                    || !TEST_true(psk_client_cb_cnt == 0)
                       /*
                        * If no old style callback then below should be 0
                        * otherwise 1
                        */
                    || !TEST_true(psk_server_cb_cnt == idx))
                goto end;
        } else {
            if (!TEST_true(use_session_cb_cnt == 0)
                    || !TEST_true(find_session_cb_cnt == 0)
                    || !TEST_true(psk_client_cb_cnt == 1)
                    || !TEST_true(psk_server_cb_cnt == 1))
                goto end;
        }

        shutdown_ssl_connection(serverssl, clientssl);
        serverssl = clientssl = NULL;
    }
    testresult = 1;

 end:
    SSL_SESSION_free(clientpsk);
    SSL_SESSION_free(serverpsk);
    clientpsk = serverpsk = NULL;
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

static unsigned char cookie_magic_value[] = "cookie magic";

static int generate_cookie_callback(SSL *ssl, unsigned char *cookie,
                                    unsigned int *cookie_len)
{
    /*
     * Not suitable as a real cookie generation function but good enough for
     * testing!
     */
    memcpy(cookie, cookie_magic_value, sizeof(cookie_magic_value) - 1);
    *cookie_len = sizeof(cookie_magic_value) - 1;

    return 1;
}

static int verify_cookie_callback(SSL *ssl, const unsigned char *cookie,
                                  unsigned int cookie_len)
{
    if (cookie_len == sizeof(cookie_magic_value) - 1
        && memcmp(cookie, cookie_magic_value, cookie_len) == 0)
        return 1;

    return 0;
}

static int generate_stateless_cookie_callback(SSL *ssl, unsigned char *cookie,
                                        size_t *cookie_len)
{
    unsigned int temp;
    int res = generate_cookie_callback(ssl, cookie, &temp);
    *cookie_len = temp;
    return res;
}

static int verify_stateless_cookie_callback(SSL *ssl, const unsigned char *cookie,
                                      size_t cookie_len)
{
    return verify_cookie_callback(ssl, cookie, cookie_len);
}

static int test_stateless(void)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *serverssl = NULL, *clientssl = NULL;
    int testresult = 0;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    /* The arrival of CCS messages can confuse the test */
    SSL_CTX_clear_options(cctx, SSL_OP_ENABLE_MIDDLEBOX_COMPAT);

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL))
               /* Send the first ClientHello */
            || !TEST_false(create_ssl_connection(serverssl, clientssl,
                                                 SSL_ERROR_WANT_READ))
               /*
                * This should fail with a -1 return because we have no callbacks
                * set up
                */
            || !TEST_int_eq(SSL_stateless(serverssl), -1))
        goto end;

    /* Fatal error so abandon the connection from this client */
    SSL_free(clientssl);
    clientssl = NULL;

    /* Set up the cookie generation and verification callbacks */
    SSL_CTX_set_stateless_cookie_generate_cb(sctx, generate_stateless_cookie_callback);
    SSL_CTX_set_stateless_cookie_verify_cb(sctx, verify_stateless_cookie_callback);

    /*
     * Create a new connection from the client (we can reuse the server SSL
     * object).
     */
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
               /* Send the first ClientHello */
            || !TEST_false(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_WANT_READ))
               /* This should fail because there is no cookie */
            || !TEST_int_eq(SSL_stateless(serverssl), 0))
        goto end;

    /* Abandon the connection from this client */
    SSL_free(clientssl);
    clientssl = NULL;

    /*
     * Now create a connection from a new client but with the same server SSL
     * object
     */
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
               /* Send the first ClientHello */
            || !TEST_false(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_WANT_READ))
               /* This should fail because there is no cookie */
            || !TEST_int_eq(SSL_stateless(serverssl), 0)
               /* Send the second ClientHello */
            || !TEST_false(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_WANT_READ))
               /* This should succeed because a cookie is now present */
            || !TEST_int_eq(SSL_stateless(serverssl), 1)
               /* Complete the connection */
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    shutdown_ssl_connection(serverssl, clientssl);
    serverssl = clientssl = NULL;
    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;

}
#endif /* OSSL_NO_USABLE_TLS1_3 */

static int clntaddoldcb = 0;
static int clntparseoldcb = 0;
static int srvaddoldcb = 0;
static int srvparseoldcb = 0;
static int clntaddnewcb = 0;
static int clntparsenewcb = 0;
static int srvaddnewcb = 0;
static int srvparsenewcb = 0;
static int snicb = 0;

#define TEST_EXT_TYPE1  0xff00

static int old_add_cb(SSL *s, unsigned int ext_type, const unsigned char **out,
                      size_t *outlen, int *al, void *add_arg)
{
    int *server = (int *)add_arg;
    unsigned char *data;

    if (SSL_is_server(s))
        srvaddoldcb++;
    else
        clntaddoldcb++;

    if (*server != SSL_is_server(s)
            || (data = OPENSSL_malloc(sizeof(*data))) == NULL)
        return -1;

    *data = 1;
    *out = data;
    *outlen = sizeof(char);
    return 1;
}

static void old_free_cb(SSL *s, unsigned int ext_type, const unsigned char *out,
                        void *add_arg)
{
    OPENSSL_free((unsigned char *)out);
}

static int old_parse_cb(SSL *s, unsigned int ext_type, const unsigned char *in,
                        size_t inlen, int *al, void *parse_arg)
{
    int *server = (int *)parse_arg;

    if (SSL_is_server(s))
        srvparseoldcb++;
    else
        clntparseoldcb++;

    if (*server != SSL_is_server(s)
            || inlen != sizeof(char)
            || *in != 1)
        return -1;

    return 1;
}

static int new_add_cb(SSL *s, unsigned int ext_type, unsigned int context,
                      const unsigned char **out, size_t *outlen, X509 *x,
                      size_t chainidx, int *al, void *add_arg)
{
    int *server = (int *)add_arg;
    unsigned char *data;

    if (SSL_is_server(s))
        srvaddnewcb++;
    else
        clntaddnewcb++;

    if (*server != SSL_is_server(s)
            || (data = OPENSSL_malloc(sizeof(*data))) == NULL)
        return -1;

    *data = 1;
    *out = data;
    *outlen = sizeof(*data);
    return 1;
}

static void new_free_cb(SSL *s, unsigned int ext_type, unsigned int context,
                        const unsigned char *out, void *add_arg)
{
    OPENSSL_free((unsigned char *)out);
}

static int new_parse_cb(SSL *s, unsigned int ext_type, unsigned int context,
                        const unsigned char *in, size_t inlen, X509 *x,
                        size_t chainidx, int *al, void *parse_arg)
{
    int *server = (int *)parse_arg;

    if (SSL_is_server(s))
        srvparsenewcb++;
    else
        clntparsenewcb++;

    if (*server != SSL_is_server(s)
            || inlen != sizeof(char) || *in != 1)
        return -1;

    return 1;
}

static int sni_cb(SSL *s, int *al, void *arg)
{
    SSL_CTX *ctx = (SSL_CTX *)arg;

    if (SSL_set_SSL_CTX(s, ctx) == NULL) {
        *al = SSL_AD_INTERNAL_ERROR;
        return SSL_TLSEXT_ERR_ALERT_FATAL;
    }
    snicb++;
    return SSL_TLSEXT_ERR_OK;
}

static int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)
{
    return 1;
}

/*
 * Custom call back tests.
 * Test 0: Old style callbacks in TLSv1.2
 * Test 1: New style callbacks in TLSv1.2
 * Test 2: New style callbacks in TLSv1.2 with SNI
 * Test 3: New style callbacks in TLSv1.3. Extensions in CH and EE
 * Test 4: New style callbacks in TLSv1.3. Extensions in CH, SH, EE, Cert + NST
 * Test 5: New style callbacks in TLSv1.3. Extensions in CR + Client Cert
 */
static int test_custom_exts(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL, *sctx2 = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    static int server = 1;
    static int client = 0;
    SSL_SESSION *sess = NULL;
    unsigned int context;

#if defined(OPENSSL_NO_TLS1_2) && !defined(OSSL_NO_USABLE_TLS1_3)
    /* Skip tests for TLSv1.2 and below in this case */
    if (tst < 3)
        return 1;
#endif

    /* Reset callback counters */
    clntaddoldcb = clntparseoldcb = srvaddoldcb = srvparseoldcb = 0;
    clntaddnewcb = clntparsenewcb = srvaddnewcb = srvparsenewcb = 0;
    snicb = 0;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    if (tst == 2
            && !TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(), NULL,
                                              TLS1_VERSION, 0,
                                              &sctx2, NULL, cert, privkey)))
        goto end;


    if (tst < 3) {
        SSL_CTX_set_options(cctx, SSL_OP_NO_TLSv1_3);
        SSL_CTX_set_options(sctx, SSL_OP_NO_TLSv1_3);
        if (sctx2 != NULL)
            SSL_CTX_set_options(sctx2, SSL_OP_NO_TLSv1_3);
    }

    if (tst == 5) {
        context = SSL_EXT_TLS1_3_CERTIFICATE_REQUEST
                  | SSL_EXT_TLS1_3_CERTIFICATE;
        SSL_CTX_set_verify(sctx,
                           SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
                           verify_cb);
        if (!TEST_int_eq(SSL_CTX_use_certificate_file(cctx, cert,
                                                      SSL_FILETYPE_PEM), 1)
                || !TEST_int_eq(SSL_CTX_use_PrivateKey_file(cctx, privkey,
                                                            SSL_FILETYPE_PEM), 1)
                || !TEST_int_eq(SSL_CTX_check_private_key(cctx), 1))
            goto end;
    } else if (tst == 4) {
        context = SSL_EXT_CLIENT_HELLO
                  | SSL_EXT_TLS1_2_SERVER_HELLO
                  | SSL_EXT_TLS1_3_SERVER_HELLO
                  | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS
                  | SSL_EXT_TLS1_3_CERTIFICATE
                  | SSL_EXT_TLS1_3_NEW_SESSION_TICKET;
    } else {
        context = SSL_EXT_CLIENT_HELLO
                  | SSL_EXT_TLS1_2_SERVER_HELLO
                  | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS;
    }

    /* Create a client side custom extension */
    if (tst == 0) {
        if (!TEST_true(SSL_CTX_add_client_custom_ext(cctx, TEST_EXT_TYPE1,
                                                     old_add_cb, old_free_cb,
                                                     &client, old_parse_cb,
                                                     &client)))
            goto end;
    } else {
        if (!TEST_true(SSL_CTX_add_custom_ext(cctx, TEST_EXT_TYPE1, context,
                                              new_add_cb, new_free_cb,
                                              &client, new_parse_cb, &client)))
            goto end;
    }

    /* Should not be able to add duplicates */
    if (!TEST_false(SSL_CTX_add_client_custom_ext(cctx, TEST_EXT_TYPE1,
                                                  old_add_cb, old_free_cb,
                                                  &client, old_parse_cb,
                                                  &client))
            || !TEST_false(SSL_CTX_add_custom_ext(cctx, TEST_EXT_TYPE1,
                                                  context, new_add_cb,
                                                  new_free_cb, &client,
                                                  new_parse_cb, &client)))
        goto end;

    /* Create a server side custom extension */
    if (tst == 0) {
        if (!TEST_true(SSL_CTX_add_server_custom_ext(sctx, TEST_EXT_TYPE1,
                                                     old_add_cb, old_free_cb,
                                                     &server, old_parse_cb,
                                                     &server)))
            goto end;
    } else {
        if (!TEST_true(SSL_CTX_add_custom_ext(sctx, TEST_EXT_TYPE1, context,
                                              new_add_cb, new_free_cb,
                                              &server, new_parse_cb, &server)))
            goto end;
        if (sctx2 != NULL
                && !TEST_true(SSL_CTX_add_custom_ext(sctx2, TEST_EXT_TYPE1,
                                                     context, new_add_cb,
                                                     new_free_cb, &server,
                                                     new_parse_cb, &server)))
            goto end;
    }

    /* Should not be able to add duplicates */
    if (!TEST_false(SSL_CTX_add_server_custom_ext(sctx, TEST_EXT_TYPE1,
                                                  old_add_cb, old_free_cb,
                                                  &server, old_parse_cb,
                                                  &server))
            || !TEST_false(SSL_CTX_add_custom_ext(sctx, TEST_EXT_TYPE1,
                                                  context, new_add_cb,
                                                  new_free_cb, &server,
                                                  new_parse_cb, &server)))
        goto end;

    if (tst == 2) {
        /* Set up SNI */
        if (!TEST_true(SSL_CTX_set_tlsext_servername_callback(sctx, sni_cb))
                || !TEST_true(SSL_CTX_set_tlsext_servername_arg(sctx, sctx2)))
            goto end;
    }

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    if (tst == 0) {
        if (clntaddoldcb != 1
                || clntparseoldcb != 1
                || srvaddoldcb != 1
                || srvparseoldcb != 1)
            goto end;
    } else if (tst == 1 || tst == 2 || tst == 3) {
        if (clntaddnewcb != 1
                || clntparsenewcb != 1
                || srvaddnewcb != 1
                || srvparsenewcb != 1
                || (tst != 2 && snicb != 0)
                || (tst == 2 && snicb != 1))
            goto end;
    } else if (tst == 5) {
        if (clntaddnewcb != 1
                || clntparsenewcb != 1
                || srvaddnewcb != 1
                || srvparsenewcb != 1)
            goto end;
    } else {
        /* In this case there 2 NewSessionTicket messages created */
        if (clntaddnewcb != 1
                || clntparsenewcb != 5
                || srvaddnewcb != 5
                || srvparsenewcb != 1)
            goto end;
    }

    sess = SSL_get1_session(clientssl);
    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    if (tst == 3 || tst == 5) {
        /* We don't bother with the resumption aspects for these tests */
        testresult = 1;
        goto end;
    }

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl, sess))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                               SSL_ERROR_NONE)))
        goto end;

    /*
     * For a resumed session we expect to add the ClientHello extension. For the
     * old style callbacks we ignore it on the server side because they set
     * SSL_EXT_IGNORE_ON_RESUMPTION. The new style callbacks do not ignore
     * them.
     */
    if (tst == 0) {
        if (clntaddoldcb != 2
                || clntparseoldcb != 1
                || srvaddoldcb != 1
                || srvparseoldcb != 1)
            goto end;
    } else if (tst == 1 || tst == 2 || tst == 3) {
        if (clntaddnewcb != 2
                || clntparsenewcb != 2
                || srvaddnewcb != 2
                || srvparsenewcb != 2)
            goto end;
    } else {
        /*
         * No Certificate message extensions in the resumption handshake,
         * 2 NewSessionTickets in the initial handshake, 1 in the resumption
         */
        if (clntaddnewcb != 2
                || clntparsenewcb != 8
                || srvaddnewcb != 8
                || srvparsenewcb != 2)
            goto end;
    }

    testresult = 1;

end:
    SSL_SESSION_free(sess);
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx2);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

#if !defined(OPENSSL_NO_TLS1_2) && !defined(OSSL_NO_USABLE_TLS1_3)

#define  SYNTHV1CONTEXT     (SSL_EXT_TLS1_2_AND_BELOW_ONLY \
                             | SSL_EXT_CLIENT_HELLO \
                             | SSL_EXT_TLS1_2_SERVER_HELLO \
                             | SSL_EXT_IGNORE_ON_RESUMPTION)

#define TLS13CONTEXT (SSL_EXT_TLS1_3_CERTIFICATE \
                      | SSL_EXT_TLS1_2_SERVER_HELLO \
                      | SSL_EXT_CLIENT_HELLO)

#define SERVERINFO_CUSTOM                                 \
    0x00, (char)TLSEXT_TYPE_signed_certificate_timestamp, \
    0x00, 0x03,                                           \
    0x04, 0x05, 0x06                                      \

static const unsigned char serverinfo_custom_tls13[] = {
    0x00, 0x00, (TLS13CONTEXT >> 8) & 0xff, TLS13CONTEXT & 0xff,
    SERVERINFO_CUSTOM
};
static const unsigned char serverinfo_custom_v2[] = {
    0x00, 0x00, (SYNTHV1CONTEXT >> 8) & 0xff,  SYNTHV1CONTEXT & 0xff,
    SERVERINFO_CUSTOM
};
static const unsigned char serverinfo_custom_v1[] = {
    SERVERINFO_CUSTOM
};
static const size_t serverinfo_custom_tls13_len = sizeof(serverinfo_custom_tls13);
static const size_t serverinfo_custom_v2_len = sizeof(serverinfo_custom_v2);
static const size_t serverinfo_custom_v1_len = sizeof(serverinfo_custom_v1);

static int serverinfo_custom_parse_cb(SSL *s, unsigned int ext_type,
                                      unsigned int context,
                                      const unsigned char *in,
                                      size_t inlen, X509 *x,
                                      size_t chainidx, int *al,
                                      void *parse_arg)
{
    const size_t len = serverinfo_custom_v1_len;
    const unsigned char *si = &serverinfo_custom_v1[len - 3];
    int *p_cb_result = (int*)parse_arg;
    *p_cb_result = TEST_mem_eq(in, inlen, si, 3);
    return 1;
}

static int test_serverinfo_custom(const int idx)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    int cb_result = 0;

    /*
     * Following variables are set in the switch statement
     *  according to the test iteration.
     * Default values do not make much sense: test would fail with them.
     */
    int serverinfo_version = 0;
    int protocol_version = 0;
    unsigned int extension_context = 0;
    const unsigned char *si = NULL;
    size_t si_len = 0;

    const int call_use_serverinfo_ex = idx > 0;
    switch (idx) {
    case 0: /* FALLTHROUGH */
    case 1:
        serverinfo_version = SSL_SERVERINFOV1;
        protocol_version = TLS1_2_VERSION;
        extension_context = SYNTHV1CONTEXT;
        si = serverinfo_custom_v1;
        si_len = serverinfo_custom_v1_len;
        break;
    case 2:
        serverinfo_version = SSL_SERVERINFOV2;
        protocol_version = TLS1_2_VERSION;
        extension_context = SYNTHV1CONTEXT;
        si = serverinfo_custom_v2;
        si_len = serverinfo_custom_v2_len;
        break;
    case 3:
        serverinfo_version = SSL_SERVERINFOV2;
        protocol_version = TLS1_3_VERSION;
        extension_context = TLS13CONTEXT;
        si = serverinfo_custom_tls13;
        si_len = serverinfo_custom_tls13_len;
        break;
    }

    if (!TEST_true(create_ssl_ctx_pair(libctx,
                                       TLS_method(),
                                       TLS_method(),
                                       protocol_version,
                                       protocol_version,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    if (call_use_serverinfo_ex) {
        if (!TEST_true(SSL_CTX_use_serverinfo_ex(sctx, serverinfo_version,
                                                 si, si_len)))
            goto end;
    } else {
        if (!TEST_true(SSL_CTX_use_serverinfo(sctx, si, si_len)))
            goto end;
    }

    if (!TEST_true(SSL_CTX_add_custom_ext(cctx, TLSEXT_TYPE_signed_certificate_timestamp,
                                          extension_context,
                                          NULL, NULL, NULL,
                                          serverinfo_custom_parse_cb,
                                          &cb_result))
        || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                         NULL, NULL))
        || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                            SSL_ERROR_NONE))
        || !TEST_int_eq(SSL_do_handshake(clientssl), 1))
        goto end;

    if (!TEST_true(cb_result))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}
#endif

/*
 * Test that SSL_export_keying_material() produces expected results. There are
 * no test vectors so all we do is test that both sides of the communication
 * produce the same results for different protocol versions.
 */
#define SMALL_LABEL_LEN 10
#define LONG_LABEL_LEN  249
static int test_export_key_mat(int tst)
{
    int testresult = 0;
    SSL_CTX *cctx = NULL, *sctx = NULL, *sctx2 = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    const char label[LONG_LABEL_LEN + 1] = "test label";
    const unsigned char context[] = "context";
    const unsigned char *emptycontext = NULL;
    unsigned char ckeymat1[80], ckeymat2[80], ckeymat3[80];
    unsigned char skeymat1[80], skeymat2[80], skeymat3[80];
    size_t labellen;
    const int protocols[] = {
        TLS1_VERSION,
        TLS1_1_VERSION,
        TLS1_2_VERSION,
        TLS1_3_VERSION,
        TLS1_3_VERSION,
        TLS1_3_VERSION
    };

#ifdef OPENSSL_NO_TLS1
    if (tst == 0)
        return 1;
#endif
#ifdef OPENSSL_NO_TLS1_1
    if (tst == 1)
        return 1;
#endif
    if (is_fips && (tst == 0 || tst == 1))
        return 1;
#ifdef OPENSSL_NO_TLS1_2
    if (tst == 2)
        return 1;
#endif
#ifdef OSSL_NO_USABLE_TLS1_3
    if (tst >= 3)
        return 1;
#endif
    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    OPENSSL_assert(tst >= 0 && (size_t)tst < OSSL_NELEM(protocols));
    SSL_CTX_set_max_proto_version(cctx, protocols[tst]);
    SSL_CTX_set_min_proto_version(cctx, protocols[tst]);
    if ((protocols[tst] < TLS1_2_VERSION) &&
        (!SSL_CTX_set_cipher_list(cctx, "DEFAULT:@SECLEVEL=0")
        || !SSL_CTX_set_cipher_list(sctx, "DEFAULT:@SECLEVEL=0")))
        goto end;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl, NULL,
                                      NULL)))
        goto end;

    /*
     * Premature call of SSL_export_keying_material should just fail.
     */
    if (!TEST_int_le(SSL_export_keying_material(clientssl, ckeymat1,
                                                sizeof(ckeymat1), label,
                                                SMALL_LABEL_LEN + 1, context,
                                                sizeof(context) - 1, 1), 0))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                         SSL_ERROR_NONE)))
        goto end;

    if (tst == 5) {
        /*
         * TLSv1.3 imposes a maximum label len of 249 bytes. Check we fail if we
         * go over that.
         */
        if (!TEST_int_le(SSL_export_keying_material(clientssl, ckeymat1,
                                                    sizeof(ckeymat1), label,
                                                    LONG_LABEL_LEN + 1, context,
                                                    sizeof(context) - 1, 1), 0))
            goto end;

        testresult = 1;
        goto end;
    } else if (tst == 4) {
        labellen = LONG_LABEL_LEN;
    } else {
        labellen = SMALL_LABEL_LEN;
    }

    if (!TEST_int_eq(SSL_export_keying_material(clientssl, ckeymat1,
                                                sizeof(ckeymat1), label,
                                                labellen, context,
                                                sizeof(context) - 1, 1), 1)
            || !TEST_int_eq(SSL_export_keying_material(clientssl, ckeymat2,
                                                       sizeof(ckeymat2), label,
                                                       labellen,
                                                       emptycontext,
                                                       0, 1), 1)
            || !TEST_int_eq(SSL_export_keying_material(clientssl, ckeymat3,
                                                       sizeof(ckeymat3), label,
                                                       labellen,
                                                       NULL, 0, 0), 1)
            || !TEST_int_eq(SSL_export_keying_material(serverssl, skeymat1,
                                                       sizeof(skeymat1), label,
                                                       labellen,
                                                       context,
                                                       sizeof(context) -1, 1),
                            1)
            || !TEST_int_eq(SSL_export_keying_material(serverssl, skeymat2,
                                                       sizeof(skeymat2), label,
                                                       labellen,
                                                       emptycontext,
                                                       0, 1), 1)
            || !TEST_int_eq(SSL_export_keying_material(serverssl, skeymat3,
                                                       sizeof(skeymat3), label,
                                                       labellen,
                                                       NULL, 0, 0), 1)
               /*
                * Check that both sides created the same key material with the
                * same context.
                */
            || !TEST_mem_eq(ckeymat1, sizeof(ckeymat1), skeymat1,
                            sizeof(skeymat1))
               /*
                * Check that both sides created the same key material with an
                * empty context.
                */
            || !TEST_mem_eq(ckeymat2, sizeof(ckeymat2), skeymat2,
                            sizeof(skeymat2))
               /*
                * Check that both sides created the same key material without a
                * context.
                */
            || !TEST_mem_eq(ckeymat3, sizeof(ckeymat3), skeymat3,
                            sizeof(skeymat3))
               /* Different contexts should produce different results */
            || !TEST_mem_ne(ckeymat1, sizeof(ckeymat1), ckeymat2,
                            sizeof(ckeymat2)))
        goto end;

    /*
     * Check that an empty context and no context produce different results in
     * protocols less than TLSv1.3. In TLSv1.3 they should be the same.
     */
    if ((tst < 3 && !TEST_mem_ne(ckeymat2, sizeof(ckeymat2), ckeymat3,
                                  sizeof(ckeymat3)))
            || (tst >= 3 && !TEST_mem_eq(ckeymat2, sizeof(ckeymat2), ckeymat3,
                                         sizeof(ckeymat3))))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx2);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

#ifndef OSSL_NO_USABLE_TLS1_3
/*
 * Test that SSL_export_keying_material_early() produces expected
 * results. There are no test vectors so all we do is test that both
 * sides of the communication produce the same results for different
 * protocol versions.
 */
static int test_export_key_mat_early(int idx)
{
    static const char label[] = "test label";
    static const unsigned char context[] = "context";
    int testresult = 0;
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    SSL_SESSION *sess = NULL;
    const unsigned char *emptycontext = NULL;
    unsigned char ckeymat1[80], ckeymat2[80];
    unsigned char skeymat1[80], skeymat2[80];
    unsigned char buf[1];
    size_t readbytes, written;

    if (!TEST_true(setupearly_data_test(&cctx, &sctx, &clientssl, &serverssl,
                                        &sess, idx, SHA384_DIGEST_LENGTH)))
        goto end;

    /* Here writing 0 length early data is enough. */
    if (!TEST_true(SSL_write_early_data(clientssl, NULL, 0, &written))
            || !TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
                                                &readbytes),
                            SSL_READ_EARLY_DATA_ERROR)
            || !TEST_int_eq(SSL_get_early_data_status(serverssl),
                            SSL_EARLY_DATA_ACCEPTED))
        goto end;

    if (!TEST_int_eq(SSL_export_keying_material_early(
                     clientssl, ckeymat1, sizeof(ckeymat1), label,
                     sizeof(label) - 1, context, sizeof(context) - 1), 1)
            || !TEST_int_eq(SSL_export_keying_material_early(
                            clientssl, ckeymat2, sizeof(ckeymat2), label,
                            sizeof(label) - 1, emptycontext, 0), 1)
            || !TEST_int_eq(SSL_export_keying_material_early(
                            serverssl, skeymat1, sizeof(skeymat1), label,
                            sizeof(label) - 1, context, sizeof(context) - 1), 1)
            || !TEST_int_eq(SSL_export_keying_material_early(
                            serverssl, skeymat2, sizeof(skeymat2), label,
                            sizeof(label) - 1, emptycontext, 0), 1)
               /*
                * Check that both sides created the same key material with the
                * same context.
                */
            || !TEST_mem_eq(ckeymat1, sizeof(ckeymat1), skeymat1,
                            sizeof(skeymat1))
               /*
                * Check that both sides created the same key material with an
                * empty context.
                */
            || !TEST_mem_eq(ckeymat2, sizeof(ckeymat2), skeymat2,
                            sizeof(skeymat2))
               /* Different contexts should produce different results */
            || !TEST_mem_ne(ckeymat1, sizeof(ckeymat1), ckeymat2,
                            sizeof(ckeymat2)))
        goto end;

    testresult = 1;

 end:
    SSL_SESSION_free(sess);
    SSL_SESSION_free(clientpsk);
    SSL_SESSION_free(serverpsk);
    clientpsk = serverpsk = NULL;
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

#define NUM_KEY_UPDATE_MESSAGES 40
/*
 * Test KeyUpdate.
 */
static int test_key_update(void)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0, i, j;
    char buf[20];
    static char *mess = "A test message";

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       TLS1_3_VERSION,
                                       0,
                                       &sctx, &cctx, cert, privkey))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    for (j = 0; j < 2; j++) {
        /* Send lots of KeyUpdate messages */
        for (i = 0; i < NUM_KEY_UPDATE_MESSAGES; i++) {
            if (!TEST_true(SSL_key_update(clientssl,
                                          (j == 0)
                                          ? SSL_KEY_UPDATE_NOT_REQUESTED
                                          : SSL_KEY_UPDATE_REQUESTED))
                    || !TEST_true(SSL_do_handshake(clientssl)))
                goto end;
        }

        /* Check that sending and receiving app data is ok */
        if (!TEST_int_eq(SSL_write(clientssl, mess, strlen(mess)), strlen(mess))
                || !TEST_int_eq(SSL_read(serverssl, buf, sizeof(buf)),
                                         strlen(mess)))
            goto end;

        if (!TEST_int_eq(SSL_write(serverssl, mess, strlen(mess)), strlen(mess))
                || !TEST_int_eq(SSL_read(clientssl, buf, sizeof(buf)),
                                         strlen(mess)))
            goto end;
    }

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

/*
 * Test we can handle a KeyUpdate (update requested) message while
 * write data is pending in peer.
 * Test 0: Client sends KeyUpdate while Server is writing
 * Test 1: Server sends KeyUpdate while Client is writing
 */
static int test_key_update_peer_in_write(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    char buf[20];
    static char *mess = "A test message";
    BIO *bretry = BIO_new(bio_s_always_retry());
    BIO *tmp = NULL;
    SSL *peerupdate = NULL, *peerwrite = NULL;

    if (!TEST_ptr(bretry)
            || !TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                              TLS_client_method(),
                                              TLS1_3_VERSION,
                                              0,
                                              &sctx, &cctx, cert, privkey))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    peerupdate = tst == 0 ? clientssl : serverssl;
    peerwrite = tst == 0 ? serverssl : clientssl;

    if (!TEST_true(SSL_key_update(peerupdate, SSL_KEY_UPDATE_REQUESTED))
            || !TEST_int_eq(SSL_do_handshake(peerupdate), 1))
        goto end;

    /* Swap the writing endpoint's write BIO to force a retry */
    tmp = SSL_get_wbio(peerwrite);
    if (!TEST_ptr(tmp) || !TEST_true(BIO_up_ref(tmp))) {
        tmp = NULL;
        goto end;
    }
    SSL_set0_wbio(peerwrite, bretry);
    bretry = NULL;

    /* Write data that we know will fail with SSL_ERROR_WANT_WRITE */
    if (!TEST_int_eq(SSL_write(peerwrite, mess, strlen(mess)), -1)
            || !TEST_int_eq(SSL_get_error(peerwrite, 0), SSL_ERROR_WANT_WRITE))
        goto end;

    /* Reinstate the original writing endpoint's write BIO */
    SSL_set0_wbio(peerwrite, tmp);
    tmp = NULL;

    /* Now read some data - we will read the key update */
    if (!TEST_int_eq(SSL_read(peerwrite, buf, sizeof(buf)), -1)
            || !TEST_int_eq(SSL_get_error(peerwrite, 0), SSL_ERROR_WANT_READ))
        goto end;

    /*
     * Complete the write we started previously and read it from the other
     * endpoint
     */
    if (!TEST_int_eq(SSL_write(peerwrite, mess, strlen(mess)), strlen(mess))
            || !TEST_int_eq(SSL_read(peerupdate, buf, sizeof(buf)), strlen(mess)))
        goto end;

    /* Write more data to ensure we send the KeyUpdate message back */
    if (!TEST_int_eq(SSL_write(peerwrite, mess, strlen(mess)), strlen(mess))
            || !TEST_int_eq(SSL_read(peerupdate, buf, sizeof(buf)), strlen(mess)))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    BIO_free(bretry);
    BIO_free(tmp);

    return testresult;
}

/*
 * Test we can handle a KeyUpdate (update requested) message while
 * peer read data is pending after peer accepted keyupdate(the msg header
 * had been read 5 bytes).
 * Test 0: Client sends KeyUpdate while Server is reading
 * Test 1: Server sends KeyUpdate while Client is reading
 */
static int test_key_update_peer_in_read(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    char prbuf[515], lwbuf[515] = {0};
    static char *mess = "A test message";
    BIO *lbio = NULL, *pbio = NULL;
    SSL *local = NULL, *peer = NULL;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                              TLS_client_method(),
                                              TLS1_3_VERSION,
                                              0,
                                              &sctx, &cctx, cert, privkey))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    local = tst == 0 ? clientssl : serverssl;
    peer = tst == 0 ? serverssl : clientssl;

    if (!TEST_int_eq(BIO_new_bio_pair(&lbio, 512, &pbio, 512), 1))
        goto end;

    SSL_set_bio(local, lbio, lbio);
    SSL_set_bio(peer, pbio, pbio);

    /*
     * we first write keyupdate msg then appdata in local
     * write data in local will fail with SSL_ERROR_WANT_WRITE,because
     * lwbuf app data msg size + key updata msg size > 512(the size of
     * the bio pair buffer)
     */
    if (!TEST_true(SSL_key_update(local, SSL_KEY_UPDATE_REQUESTED))
            || !TEST_int_eq(SSL_write(local, lwbuf, sizeof(lwbuf)), -1)
            || !TEST_int_eq(SSL_get_error(local, -1), SSL_ERROR_WANT_WRITE))
        goto end;

    /*
     * first read keyupdate msg in peer in peer
     * then read appdata that we know will fail with SSL_ERROR_WANT_READ
     */
    if (!TEST_int_eq(SSL_read(peer, prbuf, sizeof(prbuf)), -1)
            || !TEST_int_eq(SSL_get_error(peer, -1), SSL_ERROR_WANT_READ))
        goto end;

    /* Now write some data in peer - we will write the key update */
    if (!TEST_int_eq(SSL_write(peer, mess, strlen(mess)), strlen(mess)))
        goto end;

    /*
     * write data in local previously that we will complete
     * read data in peer previously that we will complete
     */
    if (!TEST_int_eq(SSL_write(local, lwbuf, sizeof(lwbuf)), sizeof(lwbuf))
            || !TEST_int_eq(SSL_read(peer, prbuf, sizeof(prbuf)), sizeof(prbuf)))
        goto end;

    /* check that sending and receiving appdata ok */
    if (!TEST_int_eq(SSL_write(local, mess, strlen(mess)), strlen(mess))
            || !TEST_int_eq(SSL_read(peer, prbuf, sizeof(prbuf)), strlen(mess)))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

/*
 * Test we can't send a KeyUpdate (update requested) message while
 * local write data is pending.
 * Test 0: Client sends KeyUpdate while Client is writing
 * Test 1: Server sends KeyUpdate while Server is writing
 */
static int test_key_update_local_in_write(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    char buf[20];
    static char *mess = "A test message";
    BIO *bretry = BIO_new(bio_s_always_retry());
    BIO *tmp = NULL;
    SSL *local = NULL, *peer = NULL;

    if (!TEST_ptr(bretry)
            || !TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                              TLS_client_method(),
                                              TLS1_3_VERSION,
                                              0,
                                              &sctx, &cctx, cert, privkey))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    local = tst == 0 ? clientssl : serverssl;
    peer = tst == 0 ? serverssl : clientssl;

    /* Swap the writing endpoint's write BIO to force a retry */
    tmp = SSL_get_wbio(local);
    if (!TEST_ptr(tmp) || !TEST_true(BIO_up_ref(tmp))) {
        tmp = NULL;
        goto end;
    }
    SSL_set0_wbio(local, bretry);
    bretry = NULL;

    /* write data in local will fail with SSL_ERROR_WANT_WRITE */
    if (!TEST_int_eq(SSL_write(local, mess, strlen(mess)), -1)
            || !TEST_int_eq(SSL_get_error(local, -1), SSL_ERROR_WANT_WRITE))
        goto end;

    /* Reinstate the original writing endpoint's write BIO */
    SSL_set0_wbio(local, tmp);
    tmp = NULL;

    /* SSL_key_update will fail, because writing in local*/
    if (!TEST_false(SSL_key_update(local, SSL_KEY_UPDATE_REQUESTED))
        || !TEST_int_eq(ERR_GET_REASON(ERR_peek_error()), SSL_R_BAD_WRITE_RETRY))
    goto end;

    ERR_clear_error();
    /* write data in local previously that we will complete */
    if (!TEST_int_eq(SSL_write(local, mess, strlen(mess)), strlen(mess)))
        goto end;

    /* SSL_key_update will succeed because there is no pending write data */
    if (!TEST_true(SSL_key_update(local, SSL_KEY_UPDATE_REQUESTED))
        || !TEST_int_eq(SSL_do_handshake(local), 1))
        goto end;

    /*
     * we write some appdata in local
     * read data in peer - we will read the keyupdate msg
     */
    if (!TEST_int_eq(SSL_write(local, mess, strlen(mess)), strlen(mess))
        || !TEST_int_eq(SSL_read(peer, buf, sizeof(buf)), strlen(mess)))
        goto end;

    /* Write more peer more data to ensure we send the keyupdate message back */
    if (!TEST_int_eq(SSL_write(peer, mess, strlen(mess)), strlen(mess))
            || !TEST_int_eq(SSL_read(local, buf, sizeof(buf)), strlen(mess)))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    BIO_free(bretry);
    BIO_free(tmp);

    return testresult;
}

/*
 * Test we can handle a KeyUpdate (update requested) message while
 * local read data is pending(the msg header had been read 5 bytes).
 * Test 0: Client sends KeyUpdate while Client is reading
 * Test 1: Server sends KeyUpdate while Server is reading
 */
static int test_key_update_local_in_read(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    char lrbuf[515], pwbuf[515] = {0}, prbuf[20];
    static char *mess = "A test message";
    BIO *lbio = NULL, *pbio = NULL;
    SSL *local = NULL, *peer = NULL;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                              TLS_client_method(),
                                              TLS1_3_VERSION,
                                              0,
                                              &sctx, &cctx, cert, privkey))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    local = tst == 0 ? clientssl : serverssl;
    peer = tst == 0 ? serverssl : clientssl;

    if (!TEST_int_eq(BIO_new_bio_pair(&lbio, 512, &pbio, 512), 1))
        goto end;

    SSL_set_bio(local, lbio, lbio);
    SSL_set_bio(peer, pbio, pbio);

    /* write app data in peer will fail with SSL_ERROR_WANT_WRITE */
    if (!TEST_int_eq(SSL_write(peer, pwbuf, sizeof(pwbuf)), -1)
        || !TEST_int_eq(SSL_get_error(peer, -1), SSL_ERROR_WANT_WRITE))
        goto end;

    /* read appdata in local will fail with SSL_ERROR_WANT_READ */
    if (!TEST_int_eq(SSL_read(local, lrbuf, sizeof(lrbuf)), -1)
            || !TEST_int_eq(SSL_get_error(local, -1), SSL_ERROR_WANT_READ))
        goto end;

    /* SSL_do_handshake will send keyupdate msg */
    if (!TEST_true(SSL_key_update(local, SSL_KEY_UPDATE_REQUESTED))
            || !TEST_int_eq(SSL_do_handshake(local), 1))
        goto end;

    /*
     * write data in peer previously that we will complete
     * read data in local previously that we will complete
     */
    if (!TEST_int_eq(SSL_write(peer, pwbuf, sizeof(pwbuf)), sizeof(pwbuf))
        || !TEST_int_eq(SSL_read(local, lrbuf, sizeof(lrbuf)), sizeof(lrbuf)))
        goto end;

    /*
     * write data in local
     * read data in peer - we will read the key update
     */
    if (!TEST_int_eq(SSL_write(local, mess, strlen(mess)), strlen(mess))
        || !TEST_int_eq(SSL_read(peer, prbuf, sizeof(prbuf)), strlen(mess)))
        goto end;

  /* Write more peer data to ensure we send the keyupdate message back */
    if (!TEST_int_eq(SSL_write(peer, mess, strlen(mess)), strlen(mess))
            || !TEST_int_eq(SSL_read(local, lrbuf, sizeof(lrbuf)), strlen(mess)))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}
#endif /* OSSL_NO_USABLE_TLS1_3 */

static int test_ssl_clear(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;

#ifdef OPENSSL_NO_TLS1_2
    if (idx == 1)
        return 1;
#endif

    /* Create an initial connection */
    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey))
            || (idx == 1
                && !TEST_true(SSL_CTX_set_max_proto_version(cctx,
                                                            TLS1_2_VERSION)))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                          &clientssl, NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    serverssl = NULL;

    /* Clear clientssl - we're going to reuse the object */
    if (!TEST_true(SSL_clear(clientssl)))
        goto end;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE))
            || !TEST_true(SSL_session_reused(clientssl)))
        goto end;

    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

/* Parse CH and retrieve any MFL extension value if present */
static int get_MFL_from_client_hello(BIO *bio, int *mfl_codemfl_code)
{
    long len;
    unsigned char *data;
    PACKET pkt, pkt2, pkt3;
    unsigned int MFL_code = 0, type = 0;

    if (!TEST_uint_gt( len = BIO_get_mem_data( bio, (char **) &data ), 0 ) )
        goto end;

    memset(&pkt, 0, sizeof(pkt));
    memset(&pkt2, 0, sizeof(pkt2));
    memset(&pkt3, 0, sizeof(pkt3));

    if (!TEST_long_gt(len, 0)
            || !TEST_true( PACKET_buf_init( &pkt, data, len ) )
               /* Skip the record header */
            || !PACKET_forward(&pkt, SSL3_RT_HEADER_LENGTH)
               /* Skip the handshake message header */
            || !TEST_true(PACKET_forward(&pkt, SSL3_HM_HEADER_LENGTH))
               /* Skip client version and random */
            || !TEST_true(PACKET_forward(&pkt, CLIENT_VERSION_LEN
                                               + SSL3_RANDOM_SIZE))
               /* Skip session id */
            || !TEST_true(PACKET_get_length_prefixed_1(&pkt, &pkt2))
               /* Skip ciphers */
            || !TEST_true(PACKET_get_length_prefixed_2(&pkt, &pkt2))
               /* Skip compression */
            || !TEST_true(PACKET_get_length_prefixed_1(&pkt, &pkt2))
               /* Extensions len */
            || !TEST_true(PACKET_as_length_prefixed_2(&pkt, &pkt2)))
        goto end;

    /* Loop through all extensions */
    while (PACKET_remaining(&pkt2)) {
        if (!TEST_true(PACKET_get_net_2(&pkt2, &type))
                || !TEST_true(PACKET_get_length_prefixed_2(&pkt2, &pkt3)))
            goto end;

        if (type == TLSEXT_TYPE_max_fragment_length) {
            if (!TEST_uint_ne(PACKET_remaining(&pkt3), 0)
                    || !TEST_true(PACKET_get_1(&pkt3, &MFL_code)))
                goto end;

            *mfl_codemfl_code = MFL_code;
            return 1;
        }
    }

 end:
    return 0;
}

/* Maximum-Fragment-Length TLS extension mode to test */
static const unsigned char max_fragment_len_test[] = {
    TLSEXT_max_fragment_length_512,
    TLSEXT_max_fragment_length_1024,
    TLSEXT_max_fragment_length_2048,
    TLSEXT_max_fragment_length_4096
};

static int test_max_fragment_len_ext(int idx_tst)
{
    SSL_CTX *ctx = NULL;
    SSL *con = NULL;
    int testresult = 0, MFL_mode = 0;
    BIO *rbio, *wbio;

    if (!TEST_true(create_ssl_ctx_pair(libctx, NULL, TLS_client_method(),
                                       TLS1_VERSION, 0, NULL, &ctx, NULL,
                                       NULL)))
        return 0;

    if (!TEST_true(SSL_CTX_set_tlsext_max_fragment_length(
                   ctx, max_fragment_len_test[idx_tst])))
        goto end;

    con = SSL_new(ctx);
    if (!TEST_ptr(con))
        goto end;

    rbio = BIO_new(BIO_s_mem());
    wbio = BIO_new(BIO_s_mem());
    if (!TEST_ptr(rbio)|| !TEST_ptr(wbio)) {
        BIO_free(rbio);
        BIO_free(wbio);
        goto end;
    }

    SSL_set_bio(con, rbio, wbio);

    if (!TEST_int_le(SSL_connect(con), 0)) {
        /* This shouldn't succeed because we don't have a server! */
        goto end;
    }

    if (!TEST_true(get_MFL_from_client_hello(wbio, &MFL_mode)))
        /* no MFL in client hello */
        goto end;
    if (!TEST_true(max_fragment_len_test[idx_tst] == MFL_mode))
        goto end;

    testresult = 1;

end:
    SSL_free(con);
    SSL_CTX_free(ctx);

    return testresult;
}

#ifndef OSSL_NO_USABLE_TLS1_3
static int test_pha_key_update(void)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey)))
        return 0;

    if (!TEST_true(SSL_CTX_set_min_proto_version(sctx, TLS1_3_VERSION))
        || !TEST_true(SSL_CTX_set_max_proto_version(sctx, TLS1_3_VERSION))
        || !TEST_true(SSL_CTX_set_min_proto_version(cctx, TLS1_3_VERSION))
        || !TEST_true(SSL_CTX_set_max_proto_version(cctx, TLS1_3_VERSION)))
        goto end;

    SSL_CTX_set_post_handshake_auth(cctx, 1);

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                         SSL_ERROR_NONE)))
        goto end;

    SSL_set_verify(serverssl, SSL_VERIFY_PEER, NULL);
    if (!TEST_true(SSL_verify_client_post_handshake(serverssl)))
        goto end;

    if (!TEST_true(SSL_key_update(clientssl, SSL_KEY_UPDATE_NOT_REQUESTED)))
        goto end;

    /* Start handshake on the server */
    if (!TEST_int_eq(SSL_do_handshake(serverssl), 1))
        goto end;

    /* Starts with SSL_connect(), but it's really just SSL_do_handshake() */
    if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                         SSL_ERROR_NONE)))
        goto end;

    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}
#endif

#if !defined(OPENSSL_NO_SRP) && !defined(OPENSSL_NO_TLS1_2)

static SRP_VBASE *vbase = NULL;

static int ssl_srp_cb(SSL *s, int *ad, void *arg)
{
    int ret = SSL3_AL_FATAL;
    char *username;
    SRP_user_pwd *user = NULL;

    username = SSL_get_srp_username(s);
    if (username == NULL) {
        *ad = SSL_AD_INTERNAL_ERROR;
        goto err;
    }

    user = SRP_VBASE_get1_by_user(vbase, username);
    if (user == NULL) {
        *ad = SSL_AD_INTERNAL_ERROR;
        goto err;
    }

    if (SSL_set_srp_server_param(s, user->N, user->g, user->s, user->v,
                                 user->info) <= 0) {
        *ad = SSL_AD_INTERNAL_ERROR;
        goto err;
    }

    ret = 0;

 err:
    SRP_user_pwd_free(user);
    return ret;
}

static int create_new_vfile(char *userid, char *password, const char *filename)
{
    char *gNid = NULL;
    OPENSSL_STRING *row = OPENSSL_zalloc(sizeof(row) * (DB_NUMBER + 1));
    TXT_DB *db = NULL;
    int ret = 0;
    BIO *out = NULL, *dummy = BIO_new_mem_buf("", 0);
    size_t i;

    if (!TEST_ptr(dummy) || !TEST_ptr(row))
        goto end;

    gNid = SRP_create_verifier_ex(userid, password, &row[DB_srpsalt],
                                  &row[DB_srpverifier], NULL, NULL, libctx, NULL);
    if (!TEST_ptr(gNid))
        goto end;

    /*
     * The only way to create an empty TXT_DB is to provide a BIO with no data
     * in it!
     */
    db = TXT_DB_read(dummy, DB_NUMBER);
    if (!TEST_ptr(db))
        goto end;

    out = BIO_new_file(filename, "w");
    if (!TEST_ptr(out))
        goto end;

    row[DB_srpid] = OPENSSL_strdup(userid);
    row[DB_srptype] = OPENSSL_strdup("V");
    row[DB_srpgN] = OPENSSL_strdup(gNid);

    if (!TEST_ptr(row[DB_srpid])
            || !TEST_ptr(row[DB_srptype])
            || !TEST_ptr(row[DB_srpgN])
            || !TEST_true(TXT_DB_insert(db, row)))
        goto end;

    row = NULL;

    if (TXT_DB_write(out, db) <= 0)
        goto end;

    ret = 1;
 end:
    if (row != NULL) {
        for (i = 0; i < DB_NUMBER; i++)
            OPENSSL_free(row[i]);
    }
    OPENSSL_free(row);
    BIO_free(dummy);
    BIO_free(out);
    TXT_DB_free(db);

    return ret;
}

static int create_new_vbase(char *userid, char *password)
{
    BIGNUM *verifier = NULL, *salt = NULL;
    const SRP_gN *lgN = NULL;
    SRP_user_pwd *user_pwd = NULL;
    int ret = 0;

    lgN = SRP_get_default_gN(NULL);
    if (!TEST_ptr(lgN))
        goto end;

    if (!TEST_true(SRP_create_verifier_BN_ex(userid, password, &salt, &verifier,
                                             lgN->N, lgN->g, libctx, NULL)))
        goto end;

    user_pwd = OPENSSL_zalloc(sizeof(*user_pwd));
    if (!TEST_ptr(user_pwd))
        goto end;

    user_pwd->N = lgN->N;
    user_pwd->g = lgN->g;
    user_pwd->id = OPENSSL_strdup(userid);
    if (!TEST_ptr(user_pwd->id))
        goto end;

    user_pwd->v = verifier;
    user_pwd->s = salt;
    verifier = salt = NULL;

    if (sk_SRP_user_pwd_insert(vbase->users_pwd, user_pwd, 0) == 0)
        goto end;
    user_pwd = NULL;

    ret = 1;
end:
    SRP_user_pwd_free(user_pwd);
    BN_free(salt);
    BN_free(verifier);

    return ret;
}

/*
 * SRP tests
 *
 * Test 0: Simple successful SRP connection, new vbase
 * Test 1: Connection failure due to bad password, new vbase
 * Test 2: Simple successful SRP connection, vbase loaded from existing file
 * Test 3: Connection failure due to bad password, vbase loaded from existing
 *         file
 * Test 4: Simple successful SRP connection, vbase loaded from new file
 * Test 5: Connection failure due to bad password, vbase loaded from new file
 */
static int test_srp(int tst)
{
    char *userid = "test", *password = "password", *tstsrpfile;
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int ret, testresult = 0;

    vbase = SRP_VBASE_new(NULL);
    if (!TEST_ptr(vbase))
        goto end;

    if (tst == 0 || tst == 1) {
        if (!TEST_true(create_new_vbase(userid, password)))
            goto end;
    } else {
        if (tst == 4 || tst == 5) {
            if (!TEST_true(create_new_vfile(userid, password, tmpfilename)))
                goto end;
            tstsrpfile = tmpfilename;
        } else {
            tstsrpfile = srpvfile;
        }
        if (!TEST_int_eq(SRP_VBASE_init(vbase, tstsrpfile), SRP_NO_ERROR))
            goto end;
    }

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    if (!TEST_int_gt(SSL_CTX_set_srp_username_callback(sctx, ssl_srp_cb), 0)
            || !TEST_true(SSL_CTX_set_cipher_list(cctx, "SRP-AES-128-CBC-SHA"))
            || !TEST_true(SSL_CTX_set_max_proto_version(sctx, TLS1_2_VERSION))
            || !TEST_true(SSL_CTX_set_max_proto_version(cctx, TLS1_2_VERSION))
            || !TEST_int_gt(SSL_CTX_set_srp_username(cctx, userid), 0))
        goto end;

    if (tst % 2 == 1) {
        if (!TEST_int_gt(SSL_CTX_set_srp_password(cctx, "badpass"), 0))
            goto end;
    } else {
        if (!TEST_int_gt(SSL_CTX_set_srp_password(cctx, password), 0))
            goto end;
    }

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL)))
        goto end;

    ret = create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE);
    if (ret) {
        if (!TEST_true(tst % 2 == 0))
            goto end;
    } else {
        if (!TEST_true(tst % 2 == 1))
            goto end;
    }

    testresult = 1;

 end:
    SRP_VBASE_free(vbase);
    vbase = NULL;
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}
#endif

static int info_cb_failed = 0;
static int info_cb_offset = 0;
static int info_cb_this_state = -1;

static struct info_cb_states_st {
    int where;
    const char *statestr;
} info_cb_states[][60] = {
    {
        /* TLSv1.2 server followed by resumption */
        {SSL_CB_HANDSHAKE_START, NULL}, {SSL_CB_LOOP, "PINIT"},
        {SSL_CB_LOOP, "PINIT"}, {SSL_CB_LOOP, "TRCH"}, {SSL_CB_LOOP, "TWSH"},
        {SSL_CB_LOOP, "TWSC"}, {SSL_CB_LOOP, "TWSKE"}, {SSL_CB_LOOP, "TWSD"},
        {SSL_CB_EXIT, NULL}, {SSL_CB_LOOP, "TWSD"}, {SSL_CB_LOOP, "TRCKE"},
        {SSL_CB_LOOP, "TRCCS"}, {SSL_CB_LOOP, "TRFIN"}, {SSL_CB_LOOP, "TWST"},
        {SSL_CB_LOOP, "TWCCS"}, {SSL_CB_LOOP, "TWFIN"},
        {SSL_CB_HANDSHAKE_DONE, NULL}, {SSL_CB_EXIT, NULL},
        {SSL_CB_ALERT, NULL}, {SSL_CB_HANDSHAKE_START, NULL},
        {SSL_CB_LOOP, "PINIT"}, {SSL_CB_LOOP, "PINIT"}, {SSL_CB_LOOP, "TRCH"},
        {SSL_CB_LOOP, "TWSH"}, {SSL_CB_LOOP, "TWCCS"}, {SSL_CB_LOOP, "TWFIN"},
        {SSL_CB_EXIT, NULL}, {SSL_CB_LOOP, "TWFIN"}, {SSL_CB_LOOP, "TRCCS"},
        {SSL_CB_LOOP, "TRFIN"}, {SSL_CB_HANDSHAKE_DONE, NULL},
        {SSL_CB_EXIT, NULL}, {0, NULL},
    }, {
        /* TLSv1.2 client followed by resumption */
        {SSL_CB_HANDSHAKE_START, NULL}, {SSL_CB_LOOP, "PINIT"},
        {SSL_CB_LOOP, "TWCH"}, {SSL_CB_EXIT, NULL}, {SSL_CB_LOOP, "TWCH"},
        {SSL_CB_LOOP, "TRSH"}, {SSL_CB_LOOP, "TRSC"}, {SSL_CB_LOOP, "TRSKE"},
        {SSL_CB_LOOP, "TRSD"}, {SSL_CB_LOOP, "TWCKE"}, {SSL_CB_LOOP, "TWCCS"},
        {SSL_CB_LOOP, "TWFIN"}, {SSL_CB_EXIT, NULL}, {SSL_CB_LOOP, "TWFIN"},
        {SSL_CB_LOOP, "TRST"}, {SSL_CB_LOOP, "TRCCS"}, {SSL_CB_LOOP, "TRFIN"},
        {SSL_CB_HANDSHAKE_DONE, NULL}, {SSL_CB_EXIT, NULL}, {SSL_CB_ALERT, NULL},
        {SSL_CB_HANDSHAKE_START, NULL}, {SSL_CB_LOOP, "PINIT"},
        {SSL_CB_LOOP, "TWCH"}, {SSL_CB_EXIT, NULL}, {SSL_CB_LOOP, "TWCH"},
        {SSL_CB_LOOP, "TRSH"}, {SSL_CB_LOOP, "TRCCS"}, {SSL_CB_LOOP, "TRFIN"},
        {SSL_CB_LOOP, "TWCCS"},  {SSL_CB_LOOP, "TWFIN"},
        {SSL_CB_HANDSHAKE_DONE, NULL}, {SSL_CB_EXIT, NULL}, {0, NULL},
    }, {
        /* TLSv1.3 server followed by resumption */
        {SSL_CB_HANDSHAKE_START, NULL}, {SSL_CB_LOOP, "PINIT"},
        {SSL_CB_LOOP, "PINIT"}, {SSL_CB_LOOP, "TRCH"}, {SSL_CB_LOOP, "TWSH"},
        {SSL_CB_LOOP, "TWCCS"}, {SSL_CB_LOOP, "TWEE"}, {SSL_CB_LOOP, "TWSC"},
        {SSL_CB_LOOP, "TWSCV"}, {SSL_CB_LOOP, "TWFIN"}, {SSL_CB_LOOP, "TED"},
        {SSL_CB_EXIT, NULL}, {SSL_CB_LOOP, "TED"}, {SSL_CB_LOOP, "TRFIN"},
        {SSL_CB_HANDSHAKE_DONE, NULL}, {SSL_CB_LOOP, "TWST"},
        {SSL_CB_LOOP, "TWST"}, {SSL_CB_EXIT, NULL}, {SSL_CB_ALERT, NULL},
        {SSL_CB_HANDSHAKE_START, NULL}, {SSL_CB_LOOP, "PINIT"},
        {SSL_CB_LOOP, "PINIT"}, {SSL_CB_LOOP, "TRCH"}, {SSL_CB_LOOP, "TWSH"},
        {SSL_CB_LOOP, "TWCCS"}, {SSL_CB_LOOP, "TWEE"}, {SSL_CB_LOOP, "TWFIN"},
        {SSL_CB_LOOP, "TED"}, {SSL_CB_EXIT, NULL}, {SSL_CB_LOOP, "TED"},
        {SSL_CB_LOOP, "TRFIN"}, {SSL_CB_HANDSHAKE_DONE, NULL},
        {SSL_CB_LOOP, "TWST"}, {SSL_CB_EXIT, NULL}, {0, NULL},
    }, {
        /* TLSv1.3 client followed by resumption */
        {SSL_CB_HANDSHAKE_START, NULL}, {SSL_CB_LOOP, "PINIT"},
        {SSL_CB_LOOP, "TWCH"}, {SSL_CB_EXIT, NULL}, {SSL_CB_LOOP, "TWCH"},
        {SSL_CB_LOOP, "TRSH"}, {SSL_CB_LOOP, "TREE"}, {SSL_CB_LOOP, "TRSC"},
        {SSL_CB_LOOP, "TRSCV"}, {SSL_CB_LOOP, "TRFIN"}, {SSL_CB_LOOP, "TWCCS"},
        {SSL_CB_LOOP, "TWFIN"},  {SSL_CB_HANDSHAKE_DONE, NULL},
        {SSL_CB_EXIT, NULL}, {SSL_CB_LOOP, "SSLOK"}, {SSL_CB_LOOP, "SSLOK"},
        {SSL_CB_LOOP, "TRST"}, {SSL_CB_EXIT, NULL}, {SSL_CB_LOOP, "SSLOK"},
        {SSL_CB_LOOP, "SSLOK"}, {SSL_CB_LOOP, "TRST"}, {SSL_CB_EXIT, NULL},
        {SSL_CB_ALERT, NULL}, {SSL_CB_HANDSHAKE_START, NULL},
        {SSL_CB_LOOP, "PINIT"}, {SSL_CB_LOOP, "TWCH"}, {SSL_CB_EXIT, NULL},
        {SSL_CB_LOOP, "TWCH"}, {SSL_CB_LOOP, "TRSH"},  {SSL_CB_LOOP, "TREE"},
        {SSL_CB_LOOP, "TRFIN"}, {SSL_CB_LOOP, "TWCCS"}, {SSL_CB_LOOP, "TWFIN"},
        {SSL_CB_HANDSHAKE_DONE, NULL}, {SSL_CB_EXIT, NULL},
        {SSL_CB_LOOP, "SSLOK"}, {SSL_CB_LOOP, "SSLOK"}, {SSL_CB_LOOP, "TRST"},
        {SSL_CB_EXIT, NULL}, {0, NULL},
    }, {
        /* TLSv1.3 server, early_data */
        {SSL_CB_HANDSHAKE_START, NULL}, {SSL_CB_LOOP, "PINIT"},
        {SSL_CB_LOOP, "PINIT"}, {SSL_CB_LOOP, "TRCH"}, {SSL_CB_LOOP, "TWSH"},
        {SSL_CB_LOOP, "TWCCS"}, {SSL_CB_LOOP, "TWEE"}, {SSL_CB_LOOP, "TWFIN"},
        {SSL_CB_HANDSHAKE_DONE, NULL}, {SSL_CB_EXIT, NULL},
        {SSL_CB_HANDSHAKE_START, NULL}, {SSL_CB_LOOP, "TED"},
        {SSL_CB_LOOP, "TED"}, {SSL_CB_LOOP, "TWEOED"}, {SSL_CB_LOOP, "TRFIN"},
        {SSL_CB_HANDSHAKE_DONE, NULL}, {SSL_CB_LOOP, "TWST"},
        {SSL_CB_EXIT, NULL}, {0, NULL},
    }, {
        /* TLSv1.3 client, early_data */
        {SSL_CB_HANDSHAKE_START, NULL}, {SSL_CB_LOOP, "PINIT"},
        {SSL_CB_LOOP, "TWCH"}, {SSL_CB_LOOP, "TWCCS"},
        {SSL_CB_HANDSHAKE_DONE, NULL}, {SSL_CB_EXIT, NULL},
        {SSL_CB_HANDSHAKE_START, NULL}, {SSL_CB_LOOP, "TED"},
        {SSL_CB_LOOP, "TED"}, {SSL_CB_LOOP, "TRSH"}, {SSL_CB_LOOP, "TREE"},
        {SSL_CB_LOOP, "TRFIN"}, {SSL_CB_LOOP, "TPEDE"}, {SSL_CB_LOOP, "TWEOED"},
        {SSL_CB_LOOP, "TWFIN"}, {SSL_CB_HANDSHAKE_DONE, NULL},
        {SSL_CB_EXIT, NULL}, {SSL_CB_LOOP, "SSLOK"}, {SSL_CB_LOOP, "SSLOK"},
        {SSL_CB_LOOP, "TRST"}, {SSL_CB_EXIT, NULL}, {0, NULL},
    }, {
        {0, NULL},
    }
};

static void sslapi_info_callback(const SSL *s, int where, int ret)
{
    struct info_cb_states_st *state = info_cb_states[info_cb_offset];

    /* We do not ever expect a connection to fail in this test */
    if (!TEST_false(ret == 0)) {
        info_cb_failed = 1;
        return;
    }

    /*
     * Do some sanity checks. We never expect these things to happen in this
     * test
     */
    if (!TEST_false((SSL_is_server(s) && (where & SSL_ST_CONNECT) != 0))
            || !TEST_false(!SSL_is_server(s) && (where & SSL_ST_ACCEPT) != 0)
            || !TEST_int_ne(state[++info_cb_this_state].where, 0)) {
        info_cb_failed = 1;
        return;
    }

    /* Now check we're in the right state */
    if (!TEST_true((where & state[info_cb_this_state].where) != 0)) {
        info_cb_failed = 1;
        return;
    }
    if ((where & SSL_CB_LOOP) != 0
            && !TEST_int_eq(strcmp(SSL_state_string(s),
                            state[info_cb_this_state].statestr), 0)) {
        info_cb_failed = 1;
        return;
    }

    /*
     * Check that, if we've got SSL_CB_HANDSHAKE_DONE we are not in init
     */
    if ((where & SSL_CB_HANDSHAKE_DONE)
            && SSL_in_init((SSL *)s) != 0) {
        info_cb_failed = 1;
        return;
    }
}

/*
 * Test the info callback gets called when we expect it to.
 *
 * Test 0: TLSv1.2, server
 * Test 1: TLSv1.2, client
 * Test 2: TLSv1.3, server
 * Test 3: TLSv1.3, client
 * Test 4: TLSv1.3, server, early_data
 * Test 5: TLSv1.3, client, early_data
 */
static int test_info_callback(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    SSL_SESSION *clntsess = NULL;
    int testresult = 0;
    int tlsvers;

    if (tst < 2) {
/* We need either ECDHE or DHE for the TLSv1.2 test to work */
#if !defined(OPENSSL_NO_TLS1_2) && (!defined(OPENSSL_NO_EC) \
                                    || !defined(OPENSSL_NO_DH))
        tlsvers = TLS1_2_VERSION;
#else
        return 1;
#endif
    } else {
#ifndef OSSL_NO_USABLE_TLS1_3
        tlsvers = TLS1_3_VERSION;
#else
        return 1;
#endif
    }

    /* Reset globals */
    info_cb_failed = 0;
    info_cb_this_state = -1;
    info_cb_offset = tst;

#ifndef OSSL_NO_USABLE_TLS1_3
    if (tst >= 4) {
        SSL_SESSION *sess = NULL;
        size_t written, readbytes;
        unsigned char buf[80];
        time_t timer;

        /* early_data tests */
        if (!TEST_true(setupearly_data_test(&cctx, &sctx, &clientssl,
                                            &serverssl, &sess, 0,
                                            SHA384_DIGEST_LENGTH)))
            goto end;

        /* We don't actually need this reference */
        SSL_SESSION_free(sess);

        SSL_set_info_callback((tst % 2) == 0 ? serverssl : clientssl,
                              sslapi_info_callback);

        /* Write and read some early data and then complete the connection */
        timer = time(NULL);
        if (!TEST_true(SSL_write_early_data(clientssl, MSG1, strlen(MSG1),
                                            &written))
                || !TEST_size_t_eq(written, strlen(MSG1)))
            goto end;

        if (!TEST_int_eq(SSL_read_early_data(serverssl, buf,
                                             sizeof(buf), &readbytes),
                         SSL_READ_EARLY_DATA_SUCCESS)) {
            testresult = check_early_data_timeout(timer);
            goto end;
        }

        if (!TEST_mem_eq(MSG1, readbytes, buf, strlen(MSG1))
                || !TEST_int_eq(SSL_get_early_data_status(serverssl),
                                SSL_EARLY_DATA_ACCEPTED)
                || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                    SSL_ERROR_NONE))
                || !TEST_false(info_cb_failed))
            goto end;

        testresult = 1;
        goto end;
    }
#endif

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       tlsvers, tlsvers, &sctx, &cctx, cert,
                                       privkey)))
        goto end;

    if (!TEST_true(SSL_CTX_set_dh_auto(sctx, 1)))
        goto end;

    /*
     * For even numbered tests we check the server callbacks. For odd numbers we
     * check the client.
     */
    SSL_CTX_set_info_callback((tst % 2) == 0 ? sctx : cctx,
                              sslapi_info_callback);

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                          &clientssl, NULL, NULL))
        || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                            SSL_ERROR_NONE))
        || !TEST_false(info_cb_failed))
    goto end;



    clntsess = SSL_get1_session(clientssl);
    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    /* Now do a resumption */
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl, NULL,
                                      NULL))
            || !TEST_true(SSL_set_session(clientssl, clntsess))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE))
            || !TEST_true(SSL_session_reused(clientssl))
            || !TEST_false(info_cb_failed))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_SESSION_free(clntsess);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

static int test_ssl_pending(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    char msg[] = "A test message";
    char buf[5];
    size_t written, readbytes;

    if (tst == 0) {
        if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                           TLS_client_method(),
                                           TLS1_VERSION, 0,
                                           &sctx, &cctx, cert, privkey)))
            goto end;
    } else {
#ifndef OPENSSL_NO_DTLS
        if (!TEST_true(create_ssl_ctx_pair(libctx, DTLS_server_method(),
                                           DTLS_client_method(),
                                           DTLS1_VERSION, 0,
                                           &sctx, &cctx, cert, privkey)))
            goto end;

# ifdef OPENSSL_NO_DTLS1_2
        /* Not supported in the FIPS provider */
        if (is_fips) {
            testresult = 1;
            goto end;
        };
        /*
         * Default sigalgs are SHA1 based in <DTLS1.2 which is in security
         * level 0
         */
        if (!TEST_true(SSL_CTX_set_cipher_list(sctx, "DEFAULT:@SECLEVEL=0"))
                || !TEST_true(SSL_CTX_set_cipher_list(cctx,
                                                    "DEFAULT:@SECLEVEL=0")))
            goto end;
# endif
#else
        return 1;
#endif
    }

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    if (!TEST_int_eq(SSL_pending(clientssl), 0)
            || !TEST_false(SSL_has_pending(clientssl))
            || !TEST_int_eq(SSL_pending(serverssl), 0)
            || !TEST_false(SSL_has_pending(serverssl))
            || !TEST_true(SSL_write_ex(serverssl, msg, sizeof(msg), &written))
            || !TEST_size_t_eq(written, sizeof(msg))
            || !TEST_true(SSL_read_ex(clientssl, buf, sizeof(buf), &readbytes))
            || !TEST_size_t_eq(readbytes, sizeof(buf))
            || !TEST_int_eq(SSL_pending(clientssl), (int)(written - readbytes))
            || !TEST_true(SSL_has_pending(clientssl)))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

static struct {
    unsigned int maxprot;
    const char *clntciphers;
    const char *clnttls13ciphers;
    const char *srvrciphers;
    const char *srvrtls13ciphers;
    const char *shared;
    const char *fipsshared;
} shared_ciphers_data[] = {
/*
 * We can't establish a connection (even in TLSv1.1) with these ciphersuites if
 * TLSv1.3 is enabled but TLSv1.2 is disabled.
 */
#if defined(OSSL_NO_USABLE_TLS1_3) || !defined(OPENSSL_NO_TLS1_2)
    {
        TLS1_2_VERSION,
        "AES128-SHA:AES256-SHA",
        NULL,
        "AES256-SHA:DHE-RSA-AES128-SHA",
        NULL,
        "AES256-SHA",
        "AES256-SHA"
    },
# if !defined(OPENSSL_NO_CHACHA) \
     && !defined(OPENSSL_NO_POLY1305) \
     && !defined(OPENSSL_NO_EC)
    {
        TLS1_2_VERSION,
        "AES128-SHA:ECDHE-RSA-CHACHA20-POLY1305",
        NULL,
        "AES128-SHA:ECDHE-RSA-CHACHA20-POLY1305",
        NULL,
        "AES128-SHA:ECDHE-RSA-CHACHA20-POLY1305",
        "AES128-SHA"
    },
# endif
    {
        TLS1_2_VERSION,
        "AES128-SHA:DHE-RSA-AES128-SHA:AES256-SHA",
        NULL,
        "AES128-SHA:DHE-RSA-AES256-SHA:AES256-SHA",
        NULL,
        "AES128-SHA:AES256-SHA",
        "AES128-SHA:AES256-SHA"
    },
    {
        TLS1_2_VERSION,
        "AES128-SHA:AES256-SHA",
        NULL,
        "AES128-SHA:DHE-RSA-AES128-SHA",
        NULL,
        "AES128-SHA",
        "AES128-SHA"
    },
#endif
/*
 * This test combines TLSv1.3 and TLSv1.2 ciphersuites so they must both be
 * enabled.
 */
#if !defined(OSSL_NO_USABLE_TLS1_3) && !defined(OPENSSL_NO_TLS1_2) \
    && !defined(OPENSSL_NO_CHACHA) && !defined(OPENSSL_NO_POLY1305)
    {
        TLS1_3_VERSION,
        "AES128-SHA:AES256-SHA",
        NULL,
        "AES256-SHA:AES128-SHA256",
        NULL,
        "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:"
        "TLS_AES_128_GCM_SHA256:AES256-SHA",
        "TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256:AES256-SHA"
    },
#endif
#ifndef OSSL_NO_USABLE_TLS1_3
    {
        TLS1_3_VERSION,
        "AES128-SHA",
        "TLS_AES_256_GCM_SHA384",
        "AES256-SHA",
        "TLS_AES_256_GCM_SHA384",
        "TLS_AES_256_GCM_SHA384",
        "TLS_AES_256_GCM_SHA384"
    },
#endif
};

static int int_test_ssl_get_shared_ciphers(int tst, int clnt)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    char buf[1024];
    OSSL_LIB_CTX *tmplibctx = OSSL_LIB_CTX_new();

    if (!TEST_ptr(tmplibctx))
        goto end;

    /*
     * Regardless of whether we're testing with the FIPS provider loaded into
     * libctx, we want one peer to always use the full set of ciphersuites
     * available. Therefore we use a separate libctx with the default provider
     * loaded into it. We run the same tests twice - once with the client side
     * having the full set of ciphersuites and once with the server side.
     */
    if (clnt) {
        cctx = SSL_CTX_new_ex(tmplibctx, NULL, TLS_client_method());
        if (!TEST_ptr(cctx))
            goto end;
    } else {
        sctx = SSL_CTX_new_ex(tmplibctx, NULL, TLS_server_method());
        if (!TEST_ptr(sctx))
            goto end;
    }

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       TLS1_VERSION,
                                       shared_ciphers_data[tst].maxprot,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    if (!TEST_true(SSL_CTX_set_cipher_list(cctx,
                                        shared_ciphers_data[tst].clntciphers))
            || (shared_ciphers_data[tst].clnttls13ciphers != NULL
                && !TEST_true(SSL_CTX_set_ciphersuites(cctx,
                                    shared_ciphers_data[tst].clnttls13ciphers)))
            || !TEST_true(SSL_CTX_set_cipher_list(sctx,
                                        shared_ciphers_data[tst].srvrciphers))
            || (shared_ciphers_data[tst].srvrtls13ciphers != NULL
                && !TEST_true(SSL_CTX_set_ciphersuites(sctx,
                                    shared_ciphers_data[tst].srvrtls13ciphers))))
        goto end;


    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    if (!TEST_ptr(SSL_get_shared_ciphers(serverssl, buf, sizeof(buf)))
            || !TEST_int_eq(strcmp(buf,
                                   is_fips
                                   ? shared_ciphers_data[tst].fipsshared
                                   : shared_ciphers_data[tst].shared),
                                   0)) {
        TEST_info("Shared ciphers are: %s\n", buf);
        goto end;
    }

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    OSSL_LIB_CTX_free(tmplibctx);

    return testresult;
}

static int test_ssl_get_shared_ciphers(int tst)
{
    return int_test_ssl_get_shared_ciphers(tst, 0)
           && int_test_ssl_get_shared_ciphers(tst, 1);
}


static const char *appdata = "Hello World";
static int gen_tick_called, dec_tick_called, tick_key_cb_called;
static int tick_key_renew = 0;
static SSL_TICKET_RETURN tick_dec_ret = SSL_TICKET_RETURN_ABORT;

static int gen_tick_cb(SSL *s, void *arg)
{
    gen_tick_called = 1;

    return SSL_SESSION_set1_ticket_appdata(SSL_get_session(s), appdata,
                                           strlen(appdata));
}

static SSL_TICKET_RETURN dec_tick_cb(SSL *s, SSL_SESSION *ss,
                                     const unsigned char *keyname,
                                     size_t keyname_length,
                                     SSL_TICKET_STATUS status,
                                     void *arg)
{
    void *tickdata;
    size_t tickdlen;

    dec_tick_called = 1;

    if (status == SSL_TICKET_EMPTY)
        return SSL_TICKET_RETURN_IGNORE_RENEW;

    if (!TEST_true(status == SSL_TICKET_SUCCESS
                   || status == SSL_TICKET_SUCCESS_RENEW))
        return SSL_TICKET_RETURN_ABORT;

    if (!TEST_true(SSL_SESSION_get0_ticket_appdata(ss, &tickdata,
                                                   &tickdlen))
            || !TEST_size_t_eq(tickdlen, strlen(appdata))
            || !TEST_int_eq(memcmp(tickdata, appdata, tickdlen), 0))
        return SSL_TICKET_RETURN_ABORT;

    if (tick_key_cb_called)  {
        /* Don't change what the ticket key callback wanted to do */
        switch (status) {
        case SSL_TICKET_NO_DECRYPT:
            return SSL_TICKET_RETURN_IGNORE_RENEW;

        case SSL_TICKET_SUCCESS:
            return SSL_TICKET_RETURN_USE;

        case SSL_TICKET_SUCCESS_RENEW:
            return SSL_TICKET_RETURN_USE_RENEW;

        default:
            return SSL_TICKET_RETURN_ABORT;
        }
    }
    return tick_dec_ret;

}

#ifndef OPENSSL_NO_DEPRECATED_3_0
static int tick_key_cb(SSL *s, unsigned char key_name[16],
                       unsigned char iv[EVP_MAX_IV_LENGTH], EVP_CIPHER_CTX *ctx,
                       HMAC_CTX *hctx, int enc)
{
    const unsigned char tick_aes_key[16] = "0123456789abcdef";
    const unsigned char tick_hmac_key[16] = "0123456789abcdef";
    EVP_CIPHER *aes128cbc;
    EVP_MD *sha256;
    int ret;

    tick_key_cb_called = 1;

    if (tick_key_renew == -1)
        return 0;

    aes128cbc = EVP_CIPHER_fetch(libctx, "AES-128-CBC", NULL);
    if (!TEST_ptr(aes128cbc))
        return 0;
    sha256 = EVP_MD_fetch(libctx, "SHA-256", NULL);
    if (!TEST_ptr(sha256)) {
        EVP_CIPHER_free(aes128cbc);
        return 0;
    }

    memset(iv, 0, AES_BLOCK_SIZE);
    memset(key_name, 0, 16);
    if (aes128cbc == NULL
            || sha256 == NULL
            || !EVP_CipherInit_ex(ctx, aes128cbc, NULL, tick_aes_key, iv, enc)
            || !HMAC_Init_ex(hctx, tick_hmac_key, sizeof(tick_hmac_key), sha256,
                             NULL))
        ret = -1;
    else
        ret = tick_key_renew ? 2 : 1;

    EVP_CIPHER_free(aes128cbc);
    EVP_MD_free(sha256);

    return ret;
}
#endif

static int tick_key_evp_cb(SSL *s, unsigned char key_name[16],
                           unsigned char iv[EVP_MAX_IV_LENGTH],
                           EVP_CIPHER_CTX *ctx, EVP_MAC_CTX *hctx, int enc)
{
    const unsigned char tick_aes_key[16] = "0123456789abcdef";
    unsigned char tick_hmac_key[16] = "0123456789abcdef";
    OSSL_PARAM params[2];
    EVP_CIPHER *aes128cbc;
    int ret;

    tick_key_cb_called = 1;

    if (tick_key_renew == -1)
        return 0;

    aes128cbc = EVP_CIPHER_fetch(libctx, "AES-128-CBC", NULL);
    if (!TEST_ptr(aes128cbc))
        return 0;

    memset(iv, 0, AES_BLOCK_SIZE);
    memset(key_name, 0, 16);
    params[0] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,
                                                 "SHA256", 0);
    params[1] = OSSL_PARAM_construct_end();
    if (aes128cbc == NULL
            || !EVP_CipherInit_ex(ctx, aes128cbc, NULL, tick_aes_key, iv, enc)
            || !EVP_MAC_init(hctx, tick_hmac_key, sizeof(tick_hmac_key),
                             params))
        ret = -1;
    else
        ret = tick_key_renew ? 2 : 1;

    EVP_CIPHER_free(aes128cbc);

    return ret;
}

/*
 * Test the various ticket callbacks
 * Test 0: TLSv1.2, no ticket key callback, no ticket, no renewal
 * Test 1: TLSv1.3, no ticket key callback, no ticket, no renewal
 * Test 2: TLSv1.2, no ticket key callback, no ticket, renewal
 * Test 3: TLSv1.3, no ticket key callback, no ticket, renewal
 * Test 4: TLSv1.2, no ticket key callback, ticket, no renewal
 * Test 5: TLSv1.3, no ticket key callback, ticket, no renewal
 * Test 6: TLSv1.2, no ticket key callback, ticket, renewal
 * Test 7: TLSv1.3, no ticket key callback, ticket, renewal
 * Test 8: TLSv1.2, old ticket key callback, ticket, no renewal
 * Test 9: TLSv1.3, old ticket key callback, ticket, no renewal
 * Test 10: TLSv1.2, old ticket key callback, ticket, renewal
 * Test 11: TLSv1.3, old ticket key callback, ticket, renewal
 * Test 12: TLSv1.2, old ticket key callback, no ticket
 * Test 13: TLSv1.3, old ticket key callback, no ticket
 * Test 14: TLSv1.2, ticket key callback, ticket, no renewal
 * Test 15: TLSv1.3, ticket key callback, ticket, no renewal
 * Test 16: TLSv1.2, ticket key callback, ticket, renewal
 * Test 17: TLSv1.3, ticket key callback, ticket, renewal
 * Test 18: TLSv1.2, ticket key callback, no ticket
 * Test 19: TLSv1.3, ticket key callback, no ticket
 */
static int test_ticket_callbacks(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    SSL_SESSION *clntsess = NULL;
    int testresult = 0;

#ifdef OPENSSL_NO_TLS1_2
    if (tst % 2 == 0)
        return 1;
#endif
#ifdef OSSL_NO_USABLE_TLS1_3
    if (tst % 2 == 1)
        return 1;
#endif
#ifdef OPENSSL_NO_DEPRECATED_3_0
    if (tst >= 8 && tst <= 13)
        return 1;
#endif

    gen_tick_called = dec_tick_called = tick_key_cb_called = 0;

    /* Which tests the ticket key callback should request renewal for */
    
    if (tst == 10 || tst == 11 || tst == 16 || tst == 17)
        tick_key_renew = 1;
    else if (tst == 12 || tst == 13 || tst == 18 || tst == 19)
        tick_key_renew = -1; /* abort sending the ticket/0-length ticket */
    else
        tick_key_renew = 0;

    /* Which tests the decrypt ticket callback should request renewal for */
    switch (tst) {
    case 0:
    case 1:
        tick_dec_ret = SSL_TICKET_RETURN_IGNORE;
        break;

    case 2:
    case 3:
        tick_dec_ret = SSL_TICKET_RETURN_IGNORE_RENEW;
        break;

    case 4:
    case 5:
        tick_dec_ret = SSL_TICKET_RETURN_USE;
        break;

    case 6:
    case 7:
        tick_dec_ret = SSL_TICKET_RETURN_USE_RENEW;
        break;

    default:
        tick_dec_ret = SSL_TICKET_RETURN_ABORT;
    }

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       TLS1_VERSION,
                                       ((tst % 2) == 0) ? TLS1_2_VERSION
                                                        : TLS1_3_VERSION,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    /*
     * We only want sessions to resume from tickets - not the session cache. So
     * switch the cache off.
     */
    if (!TEST_true(SSL_CTX_set_session_cache_mode(sctx, SSL_SESS_CACHE_OFF)))
        goto end;

    if (!TEST_true(SSL_CTX_set_session_ticket_cb(sctx, gen_tick_cb, dec_tick_cb,
                                                 NULL)))
        goto end;

    if (tst >= 14) {
        if (!TEST_true(SSL_CTX_set_tlsext_ticket_key_evp_cb(sctx, tick_key_evp_cb)))
            goto end;
#ifndef OPENSSL_NO_DEPRECATED_3_0
    } else if (tst >= 8) {
        if (!TEST_true(SSL_CTX_set_tlsext_ticket_key_cb(sctx, tick_key_cb)))
            goto end;
#endif
    }

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    /*
     * The decrypt ticket key callback in TLSv1.2 should be called even though
     * we have no ticket yet, because it gets called with a status of
     * SSL_TICKET_EMPTY (the client indicates support for tickets but does not
     * actually send any ticket data). This does not happen in TLSv1.3 because
     * it is not valid to send empty ticket data in TLSv1.3.
     */
    if (!TEST_int_eq(gen_tick_called, 1)
            || !TEST_int_eq(dec_tick_called, ((tst % 2) == 0) ? 1 : 0))
        goto end;

    gen_tick_called = dec_tick_called = 0;

    clntsess = SSL_get1_session(clientssl);
    SSL_shutdown(clientssl);
    SSL_shutdown(serverssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    /* Now do a resumption */
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl, NULL,
                                      NULL))
            || !TEST_true(SSL_set_session(clientssl, clntsess))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    if (tick_dec_ret == SSL_TICKET_RETURN_IGNORE
            || tick_dec_ret == SSL_TICKET_RETURN_IGNORE_RENEW
            || tick_key_renew == -1) {
        if (!TEST_false(SSL_session_reused(clientssl)))
            goto end;
    } else {
        if (!TEST_true(SSL_session_reused(clientssl)))
            goto end;
    }

    if (!TEST_int_eq(gen_tick_called,
                     (tick_key_renew
                      || tick_dec_ret == SSL_TICKET_RETURN_IGNORE_RENEW
                      || tick_dec_ret == SSL_TICKET_RETURN_USE_RENEW)
                     ? 1 : 0)
               /* There is no ticket to decrypt in tests 13 and 19 */
            || !TEST_int_eq(dec_tick_called, (tst == 13 || tst == 19) ? 0 : 1))
        goto end;

    testresult = 1;

 end:
    SSL_SESSION_free(clntsess);
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

/*
 * Test incorrect shutdown.
 * Test 0: client does not shutdown properly,
 *         server does not set SSL_OP_IGNORE_UNEXPECTED_EOF,
 *         server should get SSL_ERROR_SSL
 * Test 1: client does not shutdown properly,
 *         server sets SSL_OP_IGNORE_UNEXPECTED_EOF,
 *         server should get SSL_ERROR_ZERO_RETURN
 */
static int test_incorrect_shutdown(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    char buf[80];
    BIO *c2s;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), 0, 0,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    if (tst == 1)
        SSL_CTX_set_options(sctx, SSL_OP_IGNORE_UNEXPECTED_EOF);

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                            NULL, NULL)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                              SSL_ERROR_NONE)))
        goto end;

    c2s = SSL_get_rbio(serverssl);
    BIO_set_mem_eof_return(c2s, 0);

    if (!TEST_false(SSL_read(serverssl, buf, sizeof(buf))))
        goto end;

    if (tst == 0 && !TEST_int_eq(SSL_get_error(serverssl, 0), SSL_ERROR_SSL) )
        goto end;
    if (tst == 1 && !TEST_int_eq(SSL_get_error(serverssl, 0), SSL_ERROR_ZERO_RETURN) )
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

/*
 * Test bi-directional shutdown.
 * Test 0: TLSv1.2
 * Test 1: TLSv1.2, server continues to read/write after client shutdown
 * Test 2: TLSv1.3, no pending NewSessionTicket messages
 * Test 3: TLSv1.3, pending NewSessionTicket messages
 * Test 4: TLSv1.3, server continues to read/write after client shutdown, server
 *                  sends key update, client reads it
 * Test 5: TLSv1.3, server continues to read/write after client shutdown, server
 *                  sends CertificateRequest, client reads and ignores it
 * Test 6: TLSv1.3, server continues to read/write after client shutdown, client
 *                  doesn't read it
 */
static int test_shutdown(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    char msg[] = "A test message";
    char buf[80];
    size_t written, readbytes;
    SSL_SESSION *sess;

#ifdef OPENSSL_NO_TLS1_2
    if (tst <= 1)
        return 1;
#endif
#ifdef OSSL_NO_USABLE_TLS1_3
    if (tst >= 2)
        return 1;
#endif

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       TLS1_VERSION,
                                       (tst <= 1) ? TLS1_2_VERSION
                                                  : TLS1_3_VERSION,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    if (tst == 5)
        SSL_CTX_set_post_handshake_auth(cctx, 1);

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL)))
        goto end;

    if (tst == 3) {
        if (!TEST_true(create_bare_ssl_connection(serverssl, clientssl,
                                                  SSL_ERROR_NONE, 1))
                || !TEST_ptr_ne(sess = SSL_get_session(clientssl), NULL)
                || !TEST_false(SSL_SESSION_is_resumable(sess)))
            goto end;
    } else if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                              SSL_ERROR_NONE))
            || !TEST_ptr_ne(sess = SSL_get_session(clientssl), NULL)
            || !TEST_true(SSL_SESSION_is_resumable(sess))) {
        goto end;
    }

    if (!TEST_int_eq(SSL_shutdown(clientssl), 0))
        goto end;

    if (tst >= 4) {
        /*
         * Reading on the server after the client has sent close_notify should
         * fail and provide SSL_ERROR_ZERO_RETURN
         */
        if (!TEST_false(SSL_read_ex(serverssl, buf, sizeof(buf), &readbytes))
                || !TEST_int_eq(SSL_get_error(serverssl, 0),
                                SSL_ERROR_ZERO_RETURN)
                || !TEST_int_eq(SSL_get_shutdown(serverssl),
                                SSL_RECEIVED_SHUTDOWN)
                   /*
                    * Even though we're shutdown on receive we should still be
                    * able to write.
                    */
                || !TEST_true(SSL_write(serverssl, msg, sizeof(msg))))
            goto end;
        if (tst == 4
                && !TEST_true(SSL_key_update(serverssl,
                                             SSL_KEY_UPDATE_REQUESTED)))
            goto end;
        if (tst == 5) {
            SSL_set_verify(serverssl, SSL_VERIFY_PEER, NULL);
            if (!TEST_true(SSL_verify_client_post_handshake(serverssl)))
                goto end;
        }
        if ((tst == 4 || tst == 5)
                && !TEST_true(SSL_write(serverssl, msg, sizeof(msg))))
            goto end;
        if (!TEST_int_eq(SSL_shutdown(serverssl), 1))
            goto end;
        if (tst == 4 || tst == 5) {
            /* Should still be able to read data from server */
            if (!TEST_true(SSL_read_ex(clientssl, buf, sizeof(buf),
                                       &readbytes))
                    || !TEST_size_t_eq(readbytes, sizeof(msg))
                    || !TEST_int_eq(memcmp(msg, buf, readbytes), 0)
                    || !TEST_true(SSL_read_ex(clientssl, buf, sizeof(buf),
                                              &readbytes))
                    || !TEST_size_t_eq(readbytes, sizeof(msg))
                    || !TEST_int_eq(memcmp(msg, buf, readbytes), 0))
                goto end;
        }
    }

    /* Writing on the client after sending close_notify shouldn't be possible */
    if (!TEST_false(SSL_write_ex(clientssl, msg, sizeof(msg), &written)))
        goto end;

    if (tst < 4) {
        /*
         * For these tests the client has sent close_notify but it has not yet
         * been received by the server. The server has not sent close_notify
         * yet.
         */
        if (!TEST_int_eq(SSL_shutdown(serverssl), 0)
                   /*
                    * Writing on the server after sending close_notify shouldn't
                    * be possible.
                    */
                || !TEST_false(SSL_write_ex(serverssl, msg, sizeof(msg), &written))
                || !TEST_int_eq(SSL_shutdown(clientssl), 1)
                || !TEST_ptr_ne(sess = SSL_get_session(clientssl), NULL)
                || !TEST_true(SSL_SESSION_is_resumable(sess))
                || !TEST_int_eq(SSL_shutdown(serverssl), 1))
            goto end;
    } else if (tst == 4 || tst == 5) {
        /*
         * In this test the client has sent close_notify and it has been
         * received by the server which has responded with a close_notify. The
         * client needs to read the close_notify sent by the server.
         */
        if (!TEST_int_eq(SSL_shutdown(clientssl), 1)
                || !TEST_ptr_ne(sess = SSL_get_session(clientssl), NULL)
                || !TEST_true(SSL_SESSION_is_resumable(sess)))
            goto end;
    } else {
        /*
         * tst == 6
         *
         * The client has sent close_notify and is expecting a close_notify
         * back, but instead there is application data first. The shutdown
         * should fail with a fatal error.
         */
        if (!TEST_int_eq(SSL_shutdown(clientssl), -1)
                || !TEST_int_eq(SSL_get_error(clientssl, -1), SSL_ERROR_SSL))
            goto end;
    }

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

#if !defined(OPENSSL_NO_TLS1_2) || !defined(OSSL_NO_USABLE_TLS1_3)
static int cert_cb_cnt;

static int cert_cb(SSL *s, void *arg)
{
    SSL_CTX *ctx = (SSL_CTX *)arg;
    BIO *in = NULL;
    EVP_PKEY *pkey = NULL;
    X509 *x509 = NULL, *rootx = NULL;
    STACK_OF(X509) *chain = NULL;
    char *rootfile = NULL, *ecdsacert = NULL, *ecdsakey = NULL;
    int ret = 0;

    if (cert_cb_cnt == 0) {
        /* Suspend the handshake */
        cert_cb_cnt++;
        return -1;
    } else if (cert_cb_cnt == 1) {
        /*
         * Update the SSL_CTX, set the certificate and private key and then
         * continue the handshake normally.
         */
        if (ctx != NULL && !TEST_ptr(SSL_set_SSL_CTX(s, ctx)))
            return 0;

        if (!TEST_true(SSL_use_certificate_file(s, cert, SSL_FILETYPE_PEM))
                || !TEST_true(SSL_use_PrivateKey_file(s, privkey,
                                                      SSL_FILETYPE_PEM))
                || !TEST_true(SSL_check_private_key(s)))
            return 0;
        cert_cb_cnt++;
        return 1;
    } else if (cert_cb_cnt == 3) {
        int rv;

        rootfile = test_mk_file_path(certsdir, "rootcert.pem");
        ecdsacert = test_mk_file_path(certsdir, "server-ecdsa-cert.pem");
        ecdsakey = test_mk_file_path(certsdir, "server-ecdsa-key.pem");
        if (!TEST_ptr(rootfile) || !TEST_ptr(ecdsacert) || !TEST_ptr(ecdsakey))
            goto out;
        chain = sk_X509_new_null();
        if (!TEST_ptr(chain))
            goto out;
        if (!TEST_ptr(in = BIO_new(BIO_s_file()))
                || !TEST_int_gt(BIO_read_filename(in, rootfile), 0)
                || !TEST_ptr(rootx = X509_new_ex(libctx, NULL))
                || !TEST_ptr(PEM_read_bio_X509(in, &rootx, NULL, NULL))
                || !TEST_true(sk_X509_push(chain, rootx)))
            goto out;
        rootx = NULL;
        BIO_free(in);
        if (!TEST_ptr(in = BIO_new(BIO_s_file()))
                || !TEST_int_gt(BIO_read_filename(in, ecdsacert), 0)
                || !TEST_ptr(x509 = X509_new_ex(libctx, NULL))
                || !TEST_ptr(PEM_read_bio_X509(in, &x509, NULL, NULL)))
            goto out;
        BIO_free(in);
        if (!TEST_ptr(in = BIO_new(BIO_s_file()))
                || !TEST_int_gt(BIO_read_filename(in, ecdsakey), 0)
                || !TEST_ptr(pkey = PEM_read_bio_PrivateKey_ex(in, NULL,
                                                               NULL, NULL,
                                                               libctx, NULL)))
            goto out;
        rv = SSL_check_chain(s, x509, pkey, chain);
        /*
         * If the cert doesn't show as valid here (e.g., because we don't
         * have any shared sigalgs), then we will not set it, and there will
         * be no certificate at all on the SSL or SSL_CTX.  This, in turn,
         * will cause tls_choose_sigalgs() to fail the connection.
         */
        if ((rv & (CERT_PKEY_VALID | CERT_PKEY_CA_SIGNATURE))
                == (CERT_PKEY_VALID | CERT_PKEY_CA_SIGNATURE)) {
            if (!SSL_use_cert_and_key(s, x509, pkey, NULL, 1))
                goto out;
        }

        ret = 1;
    }

    /* Abort the handshake */
 out:
    OPENSSL_free(ecdsacert);
    OPENSSL_free(ecdsakey);
    OPENSSL_free(rootfile);
    BIO_free(in);
    EVP_PKEY_free(pkey);
    X509_free(x509);
    X509_free(rootx);
    sk_X509_pop_free(chain, X509_free);
    return ret;
}

/*
 * Test the certificate callback.
 * Test 0: Callback fails
 * Test 1: Success - no SSL_set_SSL_CTX() in the callback
 * Test 2: Success - SSL_set_SSL_CTX() in the callback
 * Test 3: Success - Call SSL_check_chain from the callback
 * Test 4: Failure - SSL_check_chain fails from callback due to bad cert in the
 *                   chain
 * Test 5: Failure - SSL_check_chain fails from callback due to bad ee cert
 */
static int test_cert_cb_int(int prot, int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL, *snictx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0, ret;

#ifdef OPENSSL_NO_EC
    /* We use an EC cert in these tests, so we skip in a no-ec build */
    if (tst >= 3)
        return 1;
#endif

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       TLS1_VERSION,
                                       prot,
                                       &sctx, &cctx, NULL, NULL)))
        goto end;

    if (tst == 0)
        cert_cb_cnt = -1;
    else if (tst >= 3)
        cert_cb_cnt = 3;
    else
        cert_cb_cnt = 0;

    if (tst == 2) {
        snictx = SSL_CTX_new_ex(libctx, NULL, TLS_server_method());
        if (!TEST_ptr(snictx))
            goto end;
    }

    SSL_CTX_set_cert_cb(sctx, cert_cb, snictx);

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL)))
        goto end;

    if (tst == 4) {
        /*
         * We cause SSL_check_chain() to fail by specifying sig_algs that
         * the chain doesn't meet (the root uses an RSA cert)
         */
        if (!TEST_true(SSL_set1_sigalgs_list(clientssl,
                                             "ecdsa_secp256r1_sha256")))
            goto end;
    } else if (tst == 5) {
        /*
         * We cause SSL_check_chain() to fail by specifying sig_algs that
         * the ee cert doesn't meet (the ee uses an ECDSA cert)
         */
        if (!TEST_true(SSL_set1_sigalgs_list(clientssl,
                           "rsa_pss_rsae_sha256:rsa_pkcs1_sha256")))
            goto end;
    }

    ret = create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE);
    if (!TEST_true(tst == 0 || tst == 4 || tst == 5 ? !ret : ret)
            || (tst > 0
                && !TEST_int_eq((cert_cb_cnt - 2) * (cert_cb_cnt - 3), 0))) {
        goto end;
    }

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    SSL_CTX_free(snictx);

    return testresult;
}
#endif

static int test_cert_cb(int tst)
{
    int testresult = 1;

#ifndef OPENSSL_NO_TLS1_2
    testresult &= test_cert_cb_int(TLS1_2_VERSION, tst);
#endif
#ifndef OSSL_NO_USABLE_TLS1_3
    testresult &= test_cert_cb_int(TLS1_3_VERSION, tst);
#endif

    return testresult;
}

static int client_cert_cb(SSL *ssl, X509 **x509, EVP_PKEY **pkey)
{
    X509 *xcert;
    EVP_PKEY *privpkey;
    BIO *in = NULL;
    BIO *priv_in = NULL;

    /* Check that SSL_get0_peer_certificate() returns something sensible */
    if (!TEST_ptr(SSL_get0_peer_certificate(ssl)))
        return 0;

    in = BIO_new_file(cert, "r");
    if (!TEST_ptr(in))
        return 0;

    if (!TEST_ptr(xcert = X509_new_ex(libctx, NULL))
            || !TEST_ptr(PEM_read_bio_X509(in, &xcert, NULL, NULL))
            || !TEST_ptr(priv_in = BIO_new_file(privkey, "r"))
            || !TEST_ptr(privpkey = PEM_read_bio_PrivateKey_ex(priv_in, NULL,
                                                               NULL, NULL,
                                                               libctx, NULL)))
        goto err;

    *x509 = xcert;
    *pkey = privpkey;

    BIO_free(in);
    BIO_free(priv_in);
    return 1;
err:
    X509_free(xcert);
    BIO_free(in);
    BIO_free(priv_in);
    return 0;
}

static int test_client_cert_cb(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;

#ifdef OPENSSL_NO_TLS1_2
    if (tst == 0)
        return 1;
#endif
#ifdef OSSL_NO_USABLE_TLS1_3
    if (tst == 1)
        return 1;
#endif

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       TLS1_VERSION,
                                       tst == 0 ? TLS1_2_VERSION
                                                : TLS1_3_VERSION,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    /*
     * Test that setting a client_cert_cb results in a client certificate being
     * sent.
     */
    SSL_CTX_set_client_cert_cb(cctx, client_cert_cb);
    SSL_CTX_set_verify(sctx,
                       SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
                       verify_cb);

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

#if !defined(OPENSSL_NO_TLS1_2) || !defined(OSSL_NO_USABLE_TLS1_3)
/*
 * Test setting certificate authorities on both client and server.
 *
 * Test 0: SSL_CTX_set0_CA_list() only
 * Test 1: Both SSL_CTX_set0_CA_list() and SSL_CTX_set_client_CA_list()
 * Test 2: Only SSL_CTX_set_client_CA_list()
 */
static int test_ca_names_int(int prot, int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    size_t i;
    X509_NAME *name[] = { NULL, NULL, NULL, NULL };
    char *strnames[] = { "Jack", "Jill", "John", "Joanne" };
    STACK_OF(X509_NAME) *sk1 = NULL, *sk2 = NULL;
    const STACK_OF(X509_NAME) *sktmp = NULL;

    for (i = 0; i < OSSL_NELEM(name); i++) {
        name[i] = X509_NAME_new();
        if (!TEST_ptr(name[i])
                || !TEST_true(X509_NAME_add_entry_by_txt(name[i], "CN",
                                                         MBSTRING_ASC,
                                                         (unsigned char *)
                                                         strnames[i],
                                                         -1, -1, 0)))
            goto end;
    }

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       TLS1_VERSION,
                                       prot,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    SSL_CTX_set_verify(sctx, SSL_VERIFY_PEER, NULL);

    if (tst == 0 || tst == 1) {
        if (!TEST_ptr(sk1 = sk_X509_NAME_new_null())
                || !TEST_true(sk_X509_NAME_push(sk1, X509_NAME_dup(name[0])))
                || !TEST_true(sk_X509_NAME_push(sk1, X509_NAME_dup(name[1])))
                || !TEST_ptr(sk2 = sk_X509_NAME_new_null())
                || !TEST_true(sk_X509_NAME_push(sk2, X509_NAME_dup(name[0])))
                || !TEST_true(sk_X509_NAME_push(sk2, X509_NAME_dup(name[1]))))
            goto end;

        SSL_CTX_set0_CA_list(sctx, sk1);
        SSL_CTX_set0_CA_list(cctx, sk2);
        sk1 = sk2 = NULL;
    }
    if (tst == 1 || tst == 2) {
        if (!TEST_ptr(sk1 = sk_X509_NAME_new_null())
                || !TEST_true(sk_X509_NAME_push(sk1, X509_NAME_dup(name[2])))
                || !TEST_true(sk_X509_NAME_push(sk1, X509_NAME_dup(name[3])))
                || !TEST_ptr(sk2 = sk_X509_NAME_new_null())
                || !TEST_true(sk_X509_NAME_push(sk2, X509_NAME_dup(name[2])))
                || !TEST_true(sk_X509_NAME_push(sk2, X509_NAME_dup(name[3]))))
            goto end;

        SSL_CTX_set_client_CA_list(sctx, sk1);
        SSL_CTX_set_client_CA_list(cctx, sk2);
        sk1 = sk2 = NULL;
    }

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    /*
     * We only expect certificate authorities to have been sent to the server
     * if we are using TLSv1.3 and SSL_set0_CA_list() was used
     */
    sktmp = SSL_get0_peer_CA_list(serverssl);
    if (prot == TLS1_3_VERSION
            && (tst == 0 || tst == 1)) {
        if (!TEST_ptr(sktmp)
                || !TEST_int_eq(sk_X509_NAME_num(sktmp), 2)
                || !TEST_int_eq(X509_NAME_cmp(sk_X509_NAME_value(sktmp, 0),
                                              name[0]), 0)
                || !TEST_int_eq(X509_NAME_cmp(sk_X509_NAME_value(sktmp, 1),
                                              name[1]), 0))
            goto end;
    } else if (!TEST_ptr_null(sktmp)) {
        goto end;
    }

    /*
     * In all tests we expect certificate authorities to have been sent to the
     * client. However, SSL_set_client_CA_list() should override
     * SSL_set0_CA_list()
     */
    sktmp = SSL_get0_peer_CA_list(clientssl);
    if (!TEST_ptr(sktmp)
            || !TEST_int_eq(sk_X509_NAME_num(sktmp), 2)
            || !TEST_int_eq(X509_NAME_cmp(sk_X509_NAME_value(sktmp, 0),
                                          name[tst == 0 ? 0 : 2]), 0)
            || !TEST_int_eq(X509_NAME_cmp(sk_X509_NAME_value(sktmp, 1),
                                          name[tst == 0 ? 1 : 3]), 0))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    for (i = 0; i < OSSL_NELEM(name); i++)
        X509_NAME_free(name[i]);
    sk_X509_NAME_pop_free(sk1, X509_NAME_free);
    sk_X509_NAME_pop_free(sk2, X509_NAME_free);

    return testresult;
}
#endif

static int test_ca_names(int tst)
{
    int testresult = 1;

#ifndef OPENSSL_NO_TLS1_2
    testresult &= test_ca_names_int(TLS1_2_VERSION, tst);
#endif
#ifndef OSSL_NO_USABLE_TLS1_3
    testresult &= test_ca_names_int(TLS1_3_VERSION, tst);
#endif

    return testresult;
}

#ifndef OPENSSL_NO_TLS1_2
static const char *multiblock_cipherlist_data[]=
{
    "AES128-SHA",
    "AES128-SHA256",
    "AES256-SHA",
    "AES256-SHA256",
};

/* Reduce the fragment size - so the multiblock test buffer can be small */
# define MULTIBLOCK_FRAGSIZE 512

static int test_multiblock_write(int test_index)
{
    static const char *fetchable_ciphers[]=
    {
        "AES-128-CBC-HMAC-SHA1",
        "AES-128-CBC-HMAC-SHA256",
        "AES-256-CBC-HMAC-SHA1",
        "AES-256-CBC-HMAC-SHA256"
    };
    const char *cipherlist = multiblock_cipherlist_data[test_index];
    const SSL_METHOD *smeth = TLS_server_method();
    const SSL_METHOD *cmeth = TLS_client_method();
    int min_version = TLS1_VERSION;
    int max_version = TLS1_2_VERSION; /* Don't select TLS1_3 */
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;

    /*
     * Choose a buffer large enough to perform a multi-block operation
     * i.e: write_len >= 4 * frag_size
     * 9 * is chosen so that multiple multiblocks are used + some leftover.
     */
    unsigned char msg[MULTIBLOCK_FRAGSIZE * 9];
    unsigned char buf[sizeof(msg)], *p = buf;
    size_t readbytes, written, len;
    EVP_CIPHER *ciph = NULL;

    /*
     * Check if the cipher exists before attempting to use it since it only has
     * a hardware specific implementation.
     */
    ciph = EVP_CIPHER_fetch(libctx, fetchable_ciphers[test_index], "");
    if (ciph == NULL) {
        TEST_skip("Multiblock cipher is not available for %s", cipherlist);
        return 1;
    }
    EVP_CIPHER_free(ciph);

    /* Set up a buffer with some data that will be sent to the client */
    RAND_bytes(msg, sizeof(msg));

    if (!TEST_true(create_ssl_ctx_pair(libctx, smeth, cmeth, min_version,
                                       max_version, &sctx, &cctx, cert,
                                       privkey)))
        goto end;

    if (!TEST_true(SSL_CTX_set_max_send_fragment(sctx, MULTIBLOCK_FRAGSIZE)))
        goto end;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL)))
            goto end;

    /* settings to force it to use AES-CBC-HMAC_SHA */
    SSL_set_options(serverssl, SSL_OP_NO_ENCRYPT_THEN_MAC);
    if (!TEST_true(SSL_CTX_set_cipher_list(cctx, cipherlist)))
       goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    if (!TEST_true(SSL_write_ex(serverssl, msg, sizeof(msg), &written))
        || !TEST_size_t_eq(written, sizeof(msg)))
        goto end;

    len = written;
    while (len > 0) {
        if (!TEST_true(SSL_read_ex(clientssl, p, MULTIBLOCK_FRAGSIZE, &readbytes)))
            goto end;
        p += readbytes;
        len -= readbytes;
    }
    if (!TEST_mem_eq(msg, sizeof(msg), buf, sizeof(buf)))
        goto end;

    testresult = 1;
end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}
#endif /* OPENSSL_NO_TLS1_2 */

static int test_session_timeout(int test)
{
    /*
     * Test session ordering and timeout
     * Can't explicitly test performance of the new code,
     * but can test to see if the ordering of the sessions
     * are correct, and they they are removed as expected
     */
    SSL_SESSION *early = NULL;
    SSL_SESSION *middle = NULL;
    SSL_SESSION *late = NULL;
    SSL_CTX *ctx;
    int testresult = 0;
    long now = (long)time(NULL);
#define TIMEOUT 10

    if (!TEST_ptr(ctx = SSL_CTX_new_ex(libctx, NULL, TLS_method()))
        || !TEST_ptr(early = SSL_SESSION_new())
        || !TEST_ptr(middle = SSL_SESSION_new())
        || !TEST_ptr(late = SSL_SESSION_new()))
        goto end;

    /* assign unique session ids */
    early->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
    memset(early->session_id, 1, SSL3_SSL_SESSION_ID_LENGTH);
    middle->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
    memset(middle->session_id, 2, SSL3_SSL_SESSION_ID_LENGTH);
    late->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
    memset(late->session_id, 3, SSL3_SSL_SESSION_ID_LENGTH);

    if (!TEST_int_eq(SSL_CTX_add_session(ctx, early), 1)
        || !TEST_int_eq(SSL_CTX_add_session(ctx, middle), 1)
        || !TEST_int_eq(SSL_CTX_add_session(ctx, late), 1))
        goto end;

    /* Make sure they are all added */
    if (!TEST_ptr(early->prev)
        || !TEST_ptr(middle->prev)
        || !TEST_ptr(late->prev))
        goto end;

    if (!TEST_int_ne(SSL_SESSION_set_time(early, now - 10), 0)
        || !TEST_int_ne(SSL_SESSION_set_time(middle, now), 0)
        || !TEST_int_ne(SSL_SESSION_set_time(late, now + 10), 0))
        goto end;

    if (!TEST_int_ne(SSL_SESSION_set_timeout(early, TIMEOUT), 0)
        || !TEST_int_ne(SSL_SESSION_set_timeout(middle, TIMEOUT), 0)
        || !TEST_int_ne(SSL_SESSION_set_timeout(late, TIMEOUT), 0))
        goto end;

    /* Make sure they are all still there */
    if (!TEST_ptr(early->prev)
        || !TEST_ptr(middle->prev)
        || !TEST_ptr(late->prev))
        goto end;

    /* Make sure they are in the expected order */
    if (!TEST_ptr_eq(late->next, middle)
        || !TEST_ptr_eq(middle->next, early)
        || !TEST_ptr_eq(early->prev, middle)
        || !TEST_ptr_eq(middle->prev, late))
        goto end;

    /* This should remove "early" */
    SSL_CTX_flush_sessions(ctx, now + TIMEOUT - 1);
    if (!TEST_ptr_null(early->prev)
        || !TEST_ptr(middle->prev)
        || !TEST_ptr(late->prev))
        goto end;

    /* This should remove "middle" */
    SSL_CTX_flush_sessions(ctx, now + TIMEOUT + 1);
    if (!TEST_ptr_null(early->prev)
        || !TEST_ptr_null(middle->prev)
        || !TEST_ptr(late->prev))
        goto end;

    /* This should remove "late" */
    SSL_CTX_flush_sessions(ctx, now + TIMEOUT + 11);
    if (!TEST_ptr_null(early->prev)
        || !TEST_ptr_null(middle->prev)
        || !TEST_ptr_null(late->prev))
        goto end;

    /* Add them back in again */
    if (!TEST_int_eq(SSL_CTX_add_session(ctx, early), 1)
        || !TEST_int_eq(SSL_CTX_add_session(ctx, middle), 1)
        || !TEST_int_eq(SSL_CTX_add_session(ctx, late), 1))
        goto end;

    /* Make sure they are all added */
    if (!TEST_ptr(early->prev)
        || !TEST_ptr(middle->prev)
        || !TEST_ptr(late->prev))
        goto end;

    /* This should remove all of them */
    SSL_CTX_flush_sessions(ctx, 0);
    if (!TEST_ptr_null(early->prev)
        || !TEST_ptr_null(middle->prev)
        || !TEST_ptr_null(late->prev))
        goto end;

    (void)SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_UPDATE_TIME
                                         | SSL_CTX_get_session_cache_mode(ctx));

    /* make sure |now| is NOT  equal to the current time */
    now -= 10;
    if (!TEST_int_ne(SSL_SESSION_set_time(early, now), 0)
        || !TEST_int_eq(SSL_CTX_add_session(ctx, early), 1)
        || !TEST_long_ne(SSL_SESSION_get_time(early), now))
        goto end;

    testresult = 1;
 end:
    SSL_CTX_free(ctx);
    SSL_SESSION_free(early);
    SSL_SESSION_free(middle);
    SSL_SESSION_free(late);
    return testresult;
}

/*
 * Test that a session cache overflow works as expected
 * Test 0: TLSv1.3, timeout on new session later than old session
 * Test 1: TLSv1.2, timeout on new session later than old session
 * Test 2: TLSv1.3, timeout on new session earlier than old session
 * Test 3: TLSv1.2, timeout on new session earlier than old session
 */
#if !defined(OSSL_NO_USABLE_TLS1_3) || !defined(OPENSSL_NO_TLS1_2)
static int test_session_cache_overflow(int idx)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *serverssl = NULL, *clientssl = NULL;
    int testresult = 0;
    SSL_SESSION *sess = NULL;

#ifdef OSSL_NO_USABLE_TLS1_3
    /* If no TLSv1.3 available then do nothing in this case */
    if (idx % 2 == 0)
        return TEST_skip("No TLSv1.3 available");
#endif
#ifdef OPENSSL_NO_TLS1_2
    /* If no TLSv1.2 available then do nothing in this case */
    if (idx % 2 == 1)
        return TEST_skip("No TLSv1.2 available");
#endif

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION,
                                       (idx % 2 == 0) ? TLS1_3_VERSION
                                                      : TLS1_2_VERSION,
                                       &sctx, &cctx, cert, privkey))
            || !TEST_true(SSL_CTX_set_options(sctx, SSL_OP_NO_TICKET)))
        goto end;

    SSL_CTX_sess_set_get_cb(sctx, get_session_cb);
    get_sess_val = NULL;

    SSL_CTX_sess_set_cache_size(sctx, 1);

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    if (idx > 1) {
        sess = SSL_get_session(serverssl);
        if (!TEST_ptr(sess))
            goto end;

        /*
         * Cause this session to have a longer timeout than the next session to
         * be added.
         */
        if (!TEST_true(SSL_SESSION_set_timeout(sess, LONG_MAX / 2))) {
            sess = NULL;
            goto end;
        }
        sess = NULL;
    }

    SSL_shutdown(serverssl);
    SSL_shutdown(clientssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    /*
     * Session cache size is 1 and we already populated the cache with a session
     * so the next connection should cause an overflow.
     */

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    /*
     * The session we just negotiated may have been already removed from the
     * internal cache - but we will return it anyway from our external cache.
     */
    get_sess_val = SSL_get_session(serverssl);
    if (!TEST_ptr(get_sess_val))
        goto end;
    sess = SSL_get1_session(clientssl);
    if (!TEST_ptr(sess))
        goto end;

    SSL_shutdown(serverssl);
    SSL_shutdown(clientssl);
    SSL_free(serverssl);
    SSL_free(clientssl);
    serverssl = clientssl = NULL;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL)))
        goto end;

    if (!TEST_true(SSL_set_session(clientssl, sess)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    SSL_SESSION_free(sess);

    return testresult;
}
#endif /* !defined(OSSL_NO_USABLE_TLS1_3) || !defined(OPENSSL_NO_TLS1_2) */

/*
 * Test 0: Client sets servername and server acknowledges it (TLSv1.2)
 * Test 1: Client sets servername and server does not acknowledge it (TLSv1.2)
 * Test 2: Client sets inconsistent servername on resumption (TLSv1.2)
 * Test 3: Client does not set servername on initial handshake (TLSv1.2)
 * Test 4: Client does not set servername on resumption handshake (TLSv1.2)
 * Test 5: Client sets servername and server acknowledges it (TLSv1.3)
 * Test 6: Client sets servername and server does not acknowledge it (TLSv1.3)
 * Test 7: Client sets inconsistent servername on resumption (TLSv1.3)
 * Test 8: Client does not set servername on initial handshake(TLSv1.3)
 * Test 9: Client does not set servername on resumption handshake (TLSv1.3)
 */
static int test_servername(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    SSL_SESSION *sess = NULL;
    const char *sexpectedhost = NULL, *cexpectedhost = NULL;

#ifdef OPENSSL_NO_TLS1_2
    if (tst <= 4)
        return 1;
#endif
#ifdef OSSL_NO_USABLE_TLS1_3
    if (tst >= 5)
        return 1;
#endif

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       TLS1_VERSION,
                                       (tst <= 4) ? TLS1_2_VERSION
                                                  : TLS1_3_VERSION,
                                       &sctx, &cctx, cert, privkey))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL)))
        goto end;

    if (tst != 1 && tst != 6) {
        if (!TEST_true(SSL_CTX_set_tlsext_servername_callback(sctx,
                                                              hostname_cb)))
            goto end;
    }

    if (tst != 3 && tst != 8) {
        if (!TEST_true(SSL_set_tlsext_host_name(clientssl, "goodhost")))
            goto end;
        sexpectedhost = cexpectedhost = "goodhost";
    }

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    if (!TEST_str_eq(SSL_get_servername(clientssl, TLSEXT_NAMETYPE_host_name),
                     cexpectedhost)
            || !TEST_str_eq(SSL_get_servername(serverssl,
                                               TLSEXT_NAMETYPE_host_name),
                            sexpectedhost))
        goto end;

    /* Now repeat with a resumption handshake */

    if (!TEST_int_eq(SSL_shutdown(clientssl), 0)
            || !TEST_ptr_ne(sess = SSL_get1_session(clientssl), NULL)
            || !TEST_true(SSL_SESSION_is_resumable(sess))
            || !TEST_int_eq(SSL_shutdown(serverssl), 0))
        goto end;

    SSL_free(clientssl);
    SSL_free(serverssl);
    clientssl = serverssl = NULL;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl, NULL,
                                      NULL)))
        goto end;

    if (!TEST_true(SSL_set_session(clientssl, sess)))
        goto end;

    sexpectedhost = cexpectedhost = "goodhost";
    if (tst == 2 || tst == 7) {
        /* Set an inconsistent hostname */
        if (!TEST_true(SSL_set_tlsext_host_name(clientssl, "altgoodhost")))
            goto end;
        /*
         * In TLSv1.2 we expect the hostname from the original handshake, in
         * TLSv1.3 we expect the hostname from this handshake
         */
        if (tst == 7)
            sexpectedhost = cexpectedhost = "altgoodhost";

        if (!TEST_str_eq(SSL_get_servername(clientssl,
                                            TLSEXT_NAMETYPE_host_name),
                         "altgoodhost"))
            goto end;
    } else if (tst == 4 || tst == 9) {
        /*
         * A TLSv1.3 session does not associate a session with a servername,
         * but a TLSv1.2 session does.
         */
        if (tst == 9)
            sexpectedhost = cexpectedhost = NULL;

        if (!TEST_str_eq(SSL_get_servername(clientssl,
                                            TLSEXT_NAMETYPE_host_name),
                         cexpectedhost))
            goto end;
    } else {
        if (!TEST_true(SSL_set_tlsext_host_name(clientssl, "goodhost")))
            goto end;
        /*
         * In a TLSv1.2 resumption where the hostname was not acknowledged
         * we expect the hostname on the server to be empty. On the client we
         * return what was requested in this case.
         *
         * Similarly if the client didn't set a hostname on an original TLSv1.2
         * session but is now, the server hostname will be empty, but the client
         * is as we set it.
         */
        if (tst == 1 || tst == 3)
            sexpectedhost = NULL;

        if (!TEST_str_eq(SSL_get_servername(clientssl,
                                            TLSEXT_NAMETYPE_host_name),
                         "goodhost"))
            goto end;
    }

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    if (!TEST_true(SSL_session_reused(clientssl))
            || !TEST_true(SSL_session_reused(serverssl))
            || !TEST_str_eq(SSL_get_servername(clientssl,
                                               TLSEXT_NAMETYPE_host_name),
                            cexpectedhost)
            || !TEST_str_eq(SSL_get_servername(serverssl,
                                               TLSEXT_NAMETYPE_host_name),
                            sexpectedhost))
        goto end;

    testresult = 1;

 end:
    SSL_SESSION_free(sess);
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

#if !defined(OPENSSL_NO_EC) \
    && (!defined(OSSL_NO_USABLE_TLS1_3) || !defined(OPENSSL_NO_TLS1_2))
/*
 * Test that if signature algorithms are not available, then we do not offer or
 * accept them.
 * Test 0: Two RSA sig algs available: both RSA sig algs shared
 * Test 1: The client only has SHA2-256: only SHA2-256 algorithms shared
 * Test 2: The server only has SHA2-256: only SHA2-256 algorithms shared
 * Test 3: An RSA and an ECDSA sig alg available: both sig algs shared
 * Test 4: The client only has an ECDSA sig alg: only ECDSA algorithms shared
 * Test 5: The server only has an ECDSA sig alg: only ECDSA algorithms shared
 */
static int test_sigalgs_available(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    OSSL_LIB_CTX *tmpctx = OSSL_LIB_CTX_new();
    OSSL_LIB_CTX *clientctx = libctx, *serverctx = libctx;
    OSSL_PROVIDER *filterprov = NULL;
    int sig, hash;

    if (!TEST_ptr(tmpctx))
        goto end;

    if (idx != 0 && idx != 3) {
        if (!TEST_true(OSSL_PROVIDER_add_builtin(tmpctx, "filter",
                                                 filter_provider_init)))
            goto end;

        filterprov = OSSL_PROVIDER_load(tmpctx, "filter");
        if (!TEST_ptr(filterprov))
            goto end;

        if (idx < 3) {
            /*
             * Only enable SHA2-256 so rsa_pss_rsae_sha384 should not be offered
             * or accepted for the peer that uses this libctx. Note that libssl
             * *requires* SHA2-256 to be available so we cannot disable that. We
             * also need SHA1 for our certificate.
             */
            if (!TEST_true(filter_provider_set_filter(OSSL_OP_DIGEST,
                                                      "SHA2-256:SHA1")))
                goto end;
        } else {
            if (!TEST_true(filter_provider_set_filter(OSSL_OP_SIGNATURE,
                                                      "ECDSA"))
                    || !TEST_true(filter_provider_set_filter(OSSL_OP_KEYMGMT,
                                                             "EC:X25519:X448")))
                goto end;
        }

        if (idx == 1 || idx == 4)
            clientctx = tmpctx;
        else
            serverctx = tmpctx;
    }

    cctx = SSL_CTX_new_ex(clientctx, NULL, TLS_client_method());
    sctx = SSL_CTX_new_ex(serverctx, NULL, TLS_server_method());
    if (!TEST_ptr(cctx) || !TEST_ptr(sctx))
        goto end;

    if (idx != 5) {
        if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                           TLS_client_method(),
                                           TLS1_VERSION,
                                           0,
                                           &sctx, &cctx, cert, privkey)))
            goto end;
    } else {
        if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                           TLS_client_method(),
                                           TLS1_VERSION,
                                           0,
                                           &sctx, &cctx, cert2, privkey2)))
            goto end;
    }

    /* Ensure we only use TLSv1.2 ciphersuites based on SHA256 */
    if (idx < 4) {
        if (!TEST_true(SSL_CTX_set_cipher_list(cctx,
                                               "ECDHE-RSA-AES128-GCM-SHA256")))
            goto end;
    } else {
        if (!TEST_true(SSL_CTX_set_cipher_list(cctx,
                                               "ECDHE-ECDSA-AES128-GCM-SHA256")))
            goto end;
    }

    if (idx < 3) {
        if (!SSL_CTX_set1_sigalgs_list(cctx,
                                       "rsa_pss_rsae_sha384"
                                       ":rsa_pss_rsae_sha256")
                || !SSL_CTX_set1_sigalgs_list(sctx,
                                              "rsa_pss_rsae_sha384"
                                              ":rsa_pss_rsae_sha256"))
            goto end;
    } else {
        if (!SSL_CTX_set1_sigalgs_list(cctx, "rsa_pss_rsae_sha256:ECDSA+SHA256")
                || !SSL_CTX_set1_sigalgs_list(sctx,
                                              "rsa_pss_rsae_sha256:ECDSA+SHA256"))
            goto end;
    }

    if (idx != 5
        && (!TEST_int_eq(SSL_CTX_use_certificate_file(sctx, cert2,
                                                      SSL_FILETYPE_PEM), 1)
            || !TEST_int_eq(SSL_CTX_use_PrivateKey_file(sctx,
                                                        privkey2,
                                                        SSL_FILETYPE_PEM), 1)
            || !TEST_int_eq(SSL_CTX_check_private_key(sctx), 1)))
        goto end;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    /* For tests 0 and 3 we expect 2 shared sigalgs, otherwise exactly 1 */
    if (!TEST_int_eq(SSL_get_shared_sigalgs(serverssl, 0, &sig, &hash, NULL,
                                            NULL, NULL),
                     (idx == 0 || idx == 3) ? 2 : 1))
        goto end;

    if (!TEST_int_eq(hash, idx == 0 ? NID_sha384 : NID_sha256))
        goto end;

    if (!TEST_int_eq(sig, (idx == 4 || idx == 5) ? EVP_PKEY_EC
                                                 : NID_rsassaPss))
        goto end;

    testresult = filter_provider_check_clean_finish();

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    OSSL_PROVIDER_unload(filterprov);
    OSSL_LIB_CTX_free(tmpctx);

    return testresult;
}
#endif /*
        * !defined(OPENSSL_NO_EC) \
        * && (!defined(OSSL_NO_USABLE_TLS1_3) || !defined(OPENSSL_NO_TLS1_2))
        */

#ifndef OPENSSL_NO_TLS1_3
/* This test can run in TLSv1.3 even if ec and dh are disabled */
static int test_pluggable_group(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    OSSL_PROVIDER *tlsprov = OSSL_PROVIDER_load(libctx, "tls-provider");
    /* Check that we are not impacted by a provider without any groups */
    OSSL_PROVIDER *legacyprov = OSSL_PROVIDER_load(libctx, "legacy");
    const char *group_name = idx == 0 ? "xorkemgroup" : "xorgroup";

    if (!TEST_ptr(tlsprov))
        goto end;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       TLS1_3_VERSION,
                                       TLS1_3_VERSION,
                                       &sctx, &cctx, cert, privkey))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL)))
        goto end;

    /* ensure GROUPLIST_INCREMENT (=40) logic triggers: */
    if (!TEST_true(SSL_set1_groups_list(serverssl, "xorgroup:xorkemgroup:dummy1:dummy2:dummy3:dummy4:dummy5:dummy6:dummy7:dummy8:dummy9:dummy10:dummy11:dummy12:dummy13:dummy14:dummy15:dummy16:dummy17:dummy18:dummy19:dummy20:dummy21:dummy22:dummy23:dummy24:dummy25:dummy26:dummy27:dummy28:dummy29:dummy30:dummy31:dummy32:dummy33:dummy34:dummy35:dummy36:dummy37:dummy38:dummy39:dummy40:dummy41:dummy42:dummy43"))
    /* removing a single algorithm from the list makes the test pass */
            || !TEST_true(SSL_set1_groups_list(clientssl, group_name)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    if (!TEST_str_eq(group_name,
                     SSL_group_to_name(serverssl, SSL_get_shared_group(serverssl, 0))))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    OSSL_PROVIDER_unload(tlsprov);
    OSSL_PROVIDER_unload(legacyprov);

    return testresult;
}
#endif

#ifndef OPENSSL_NO_TLS1_2
static int test_ssl_dup(void)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL, *client2ssl = NULL;
    int testresult = 0;
    BIO *rbio = NULL, *wbio = NULL;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       0,
                                       0,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                             NULL, NULL)))
        goto end;

    if (!TEST_true(SSL_set_min_proto_version(clientssl, TLS1_2_VERSION))
            || !TEST_true(SSL_set_max_proto_version(clientssl, TLS1_2_VERSION)))
        goto end;

    client2ssl = SSL_dup(clientssl);
    rbio = SSL_get_rbio(clientssl);
    if (!TEST_ptr(rbio)
            || !TEST_true(BIO_up_ref(rbio)))
        goto end;
    SSL_set0_rbio(client2ssl, rbio);
    rbio = NULL;

    wbio = SSL_get_wbio(clientssl);
    if (!TEST_ptr(wbio) || !TEST_true(BIO_up_ref(wbio)))
        goto end;
    SSL_set0_wbio(client2ssl, wbio);
    rbio = NULL;

    if (!TEST_ptr(client2ssl)
               /* Handshake not started so pointers should be different */
            || !TEST_ptr_ne(clientssl, client2ssl))
        goto end;

    if (!TEST_int_eq(SSL_get_min_proto_version(client2ssl), TLS1_2_VERSION)
            || !TEST_int_eq(SSL_get_max_proto_version(client2ssl), TLS1_2_VERSION))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, client2ssl, SSL_ERROR_NONE)))
        goto end;

    SSL_free(clientssl);
    clientssl = SSL_dup(client2ssl);
    if (!TEST_ptr(clientssl)
               /* Handshake has finished so pointers should be the same */
            || !TEST_ptr_eq(clientssl, client2ssl))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_free(client2ssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

# ifndef OPENSSL_NO_DH

static EVP_PKEY *tmp_dh_params = NULL;

/* Helper function for the test_set_tmp_dh() tests */
static EVP_PKEY *get_tmp_dh_params(void)
{
    if (tmp_dh_params == NULL) {
        BIGNUM *p = NULL;
        OSSL_PARAM_BLD *tmpl = NULL;
        EVP_PKEY_CTX *pctx = NULL;
        OSSL_PARAM *params = NULL;
        EVP_PKEY *dhpkey = NULL;

        p = BN_get_rfc3526_prime_2048(NULL);
        if (!TEST_ptr(p))
            goto end;

        pctx = EVP_PKEY_CTX_new_from_name(libctx, "DH", NULL);
        if (!TEST_ptr(pctx)
                || !TEST_int_eq(EVP_PKEY_fromdata_init(pctx), 1))
            goto end;

        tmpl = OSSL_PARAM_BLD_new();
        if (!TEST_ptr(tmpl)
                || !TEST_true(OSSL_PARAM_BLD_push_BN(tmpl,
                                                        OSSL_PKEY_PARAM_FFC_P,
                                                        p))
                || !TEST_true(OSSL_PARAM_BLD_push_uint(tmpl,
                                                        OSSL_PKEY_PARAM_FFC_G,
                                                        2)))
            goto end;

        params = OSSL_PARAM_BLD_to_param(tmpl);
        if (!TEST_ptr(params)
                || !TEST_int_eq(EVP_PKEY_fromdata(pctx, &dhpkey,
                                                  EVP_PKEY_KEY_PARAMETERS,
                                                  params), 1))
            goto end;

        tmp_dh_params = dhpkey;
    end:
        BN_free(p);
        EVP_PKEY_CTX_free(pctx);
        OSSL_PARAM_BLD_free(tmpl);
        OSSL_PARAM_free(params);
    }

    if (tmp_dh_params != NULL && !EVP_PKEY_up_ref(tmp_dh_params))
        return NULL;

    return tmp_dh_params;
}

#  ifndef OPENSSL_NO_DEPRECATED_3_0
/* Callback used by test_set_tmp_dh() */
static DH *tmp_dh_callback(SSL *s, int is_export, int keylen)
{
    EVP_PKEY *dhpkey = get_tmp_dh_params();
    DH *ret = NULL;

    if (!TEST_ptr(dhpkey))
        return NULL;

    /*
     * libssl does not free the returned DH, so we free it now knowing that even
     * after we free dhpkey, there will still be a reference to the owning
     * EVP_PKEY in tmp_dh_params, and so the DH object will live for the length
     * of time we need it for.
     */
    ret = EVP_PKEY_get1_DH(dhpkey);
    DH_free(ret);

    EVP_PKEY_free(dhpkey);

    return ret;
}
#  endif

/*
 * Test the various methods for setting temporary DH parameters
 *
 * Test  0: Default (no auto) setting
 * Test  1: Explicit SSL_CTX auto off
 * Test  2: Explicit SSL auto off
 * Test  3: Explicit SSL_CTX auto on
 * Test  4: Explicit SSL auto on
 * Test  5: Explicit SSL_CTX auto off, custom DH params via EVP_PKEY
 * Test  6: Explicit SSL auto off, custom DH params via EVP_PKEY
 *
 * The following are testing deprecated APIs, so we only run them if available
 * Test  7: Explicit SSL_CTX auto off, custom DH params via DH
 * Test  8: Explicit SSL auto off, custom DH params via DH
 * Test  9: Explicit SSL_CTX auto off, custom DH params via callback
 * Test 10: Explicit SSL auto off, custom DH params via callback
 */
static int test_set_tmp_dh(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    int dhauto = (idx == 3 || idx == 4) ? 1 : 0;
    int expected = (idx <= 2) ? 0 : 1;
    EVP_PKEY *dhpkey = NULL;
#  ifndef OPENSSL_NO_DEPRECATED_3_0
    DH *dh = NULL;
#  else

    if (idx >= 7)
        return 1;
#  endif

    if (idx >= 5 && idx <= 8) {
        dhpkey = get_tmp_dh_params();
        if (!TEST_ptr(dhpkey))
            goto end;
    }
#  ifndef OPENSSL_NO_DEPRECATED_3_0
    if (idx == 7 || idx == 8) {
        dh = EVP_PKEY_get1_DH(dhpkey);
        if (!TEST_ptr(dh))
            goto end;
    }
#  endif

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       0,
                                       0,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    if ((idx & 1) == 1) {
        if (!TEST_true(SSL_CTX_set_dh_auto(sctx, dhauto)))
            goto end;
    }

    if (idx == 5) {
        if (!TEST_true(SSL_CTX_set0_tmp_dh_pkey(sctx, dhpkey)))
            goto end;
        dhpkey = NULL;
    }
#  ifndef OPENSSL_NO_DEPRECATED_3_0
    else if (idx == 7) {
        if (!TEST_true(SSL_CTX_set_tmp_dh(sctx, dh)))
            goto end;
    } else if (idx == 9) {
        SSL_CTX_set_tmp_dh_callback(sctx, tmp_dh_callback);
    }
#  endif

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL)))
        goto end;

    if ((idx & 1) == 0 && idx != 0) {
        if (!TEST_true(SSL_set_dh_auto(serverssl, dhauto)))
            goto end;
    }
    if (idx == 6) {
        if (!TEST_true(SSL_set0_tmp_dh_pkey(serverssl, dhpkey)))
            goto end;
        dhpkey = NULL;
    }
#  ifndef OPENSSL_NO_DEPRECATED_3_0
    else if (idx == 8) {
        if (!TEST_true(SSL_set_tmp_dh(serverssl, dh)))
            goto end;
    } else if (idx == 10) {
        SSL_set_tmp_dh_callback(serverssl, tmp_dh_callback);
    }
#  endif

    if (!TEST_true(SSL_set_min_proto_version(serverssl, TLS1_2_VERSION))
            || !TEST_true(SSL_set_max_proto_version(serverssl, TLS1_2_VERSION))
            || !TEST_true(SSL_set_cipher_list(serverssl, "DHE-RSA-AES128-SHA")))
        goto end;

    /*
     * If autoon then we should succeed. Otherwise we expect failure because
     * there are no parameters
     */
    if (!TEST_int_eq(create_ssl_connection(serverssl, clientssl,
                                           SSL_ERROR_NONE), expected))
        goto end;

    testresult = 1;

 end:
#  ifndef OPENSSL_NO_DEPRECATED_3_0
    DH_free(dh);
#  endif
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    EVP_PKEY_free(dhpkey);

    return testresult;
}

/*
 * Test the auto DH keys are appropriately sized
 */
static int test_dh_auto(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    EVP_PKEY *tmpkey = NULL;
    char *thiscert = NULL, *thiskey = NULL;
    size_t expdhsize = 0;
    const char *ciphersuite = "DHE-RSA-AES128-SHA";

    switch (idx) {
    case 0:
        /* The FIPS provider doesn't support this DH size - so we ignore it */
        if (is_fips)
            return 1;
        thiscert = cert1024;
        thiskey = privkey1024;
        expdhsize = 1024;
        break;
    case 1:
        /* 2048 bit prime */
        thiscert = cert;
        thiskey = privkey;
        expdhsize = 2048;
        break;
    case 2:
        thiscert = cert3072;
        thiskey = privkey3072;
        expdhsize = 3072;
        break;
    case 3:
        thiscert = cert4096;
        thiskey = privkey4096;
        expdhsize = 4096;
        break;
    case 4:
        thiscert = cert8192;
        thiskey = privkey8192;
        expdhsize = 8192;
        break;
    /* No certificate cases */
    case 5:
        /* The FIPS provider doesn't support this DH size - so we ignore it */
        if (is_fips)
            return 1;
        ciphersuite = "ADH-AES128-SHA256:@SECLEVEL=0";
        expdhsize = 1024;
        break;
    case 6:
        ciphersuite = "ADH-AES256-SHA256:@SECLEVEL=0";
        expdhsize = 3072;
        break;
    default:
        TEST_error("Invalid text index");
        goto end;
    }

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(),
                                       0,
                                       0,
                                       &sctx, &cctx, thiscert, thiskey)))
        goto end;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                      NULL, NULL)))
        goto end;

    if (!TEST_true(SSL_set_dh_auto(serverssl, 1))
            || !TEST_true(SSL_set_min_proto_version(serverssl, TLS1_2_VERSION))
            || !TEST_true(SSL_set_max_proto_version(serverssl, TLS1_2_VERSION))
            || !TEST_true(SSL_set_cipher_list(serverssl, ciphersuite))
            || !TEST_true(SSL_set_cipher_list(clientssl, ciphersuite)))
        goto end;

    /*
     * Send the server's first flight. At this point the server has created the
     * temporary DH key but hasn't finished using it yet. Once used it is
     * removed, so we cannot test it.
     */
    if (!TEST_int_le(SSL_connect(clientssl), 0)
            || !TEST_int_le(SSL_accept(serverssl), 0))
        goto end;

    if (!TEST_int_gt(SSL_get_tmp_key(serverssl, &tmpkey), 0))
        goto end;
    if (!TEST_size_t_eq(EVP_PKEY_get_bits(tmpkey), expdhsize))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    EVP_PKEY_free(tmpkey);

    return testresult;

}
# endif /* OPENSSL_NO_DH */
#endif /* OPENSSL_NO_TLS1_2 */

#ifndef OSSL_NO_USABLE_TLS1_3
/*
 * Test that setting an SNI callback works with TLSv1.3. Specifically we check
 * that it works even without a certificate configured for the original
 * SSL_CTX
 */
static int test_sni_tls13(void)
{
    SSL_CTX *cctx = NULL, *sctx = NULL, *sctx2 = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;

    /* Reset callback counter */
    snicb = 0;

    /* Create an initial SSL_CTX with no certificate configured */
    sctx = SSL_CTX_new_ex(libctx, NULL, TLS_server_method());
    if (!TEST_ptr(sctx))
        goto end;
    /* Require TLSv1.3 as a minimum */
    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_3_VERSION, 0,
                                       &sctx2, &cctx, cert, privkey)))
        goto end;

    /* Set up SNI */
    if (!TEST_true(SSL_CTX_set_tlsext_servername_callback(sctx, sni_cb))
            || !TEST_true(SSL_CTX_set_tlsext_servername_arg(sctx, sctx2)))
        goto end;

    /*
     * Connection should still succeed because the final SSL_CTX has the right
     * certificates configured.
     */
    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL))
            || !TEST_true(create_ssl_connection(serverssl, clientssl,
                                                SSL_ERROR_NONE)))
        goto end;

    /* We should have had the SNI callback called exactly once */
    if (!TEST_int_eq(snicb, 1))
        goto end;

    testresult = 1;

end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx2);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

/*
 * Test that the lifetime hint of a TLSv1.3 ticket is no more than 1 week
 * 0 = TLSv1.2
 * 1 = TLSv1.3
 */
static int test_ticket_lifetime(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    int version = TLS1_3_VERSION;

#define ONE_WEEK_SEC (7 * 24 * 60 * 60)
#define TWO_WEEK_SEC (2 * ONE_WEEK_SEC)

    if (idx == 0) {
#ifdef OPENSSL_NO_TLS1_2
        return TEST_skip("TLS 1.2 is disabled.");
#else
        version = TLS1_2_VERSION;
#endif
    }

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), version, version,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL)))
        goto end;

    /*
     * Set the timeout to be more than 1 week
     * make sure the returned value is the default
     */
    if (!TEST_long_eq(SSL_CTX_set_timeout(sctx, TWO_WEEK_SEC),
                      SSL_get_default_timeout(serverssl)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    if (idx == 0) {
        /* TLSv1.2 uses the set value */
        if (!TEST_ulong_eq(SSL_SESSION_get_ticket_lifetime_hint(SSL_get_session(clientssl)), TWO_WEEK_SEC))
            goto end;
    } else {
        /* TLSv1.3 uses the limited value */
        if (!TEST_ulong_le(SSL_SESSION_get_ticket_lifetime_hint(SSL_get_session(clientssl)), ONE_WEEK_SEC))
            goto end;
    }
    testresult = 1;

end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}
#endif
/*
 * Test that setting an ALPN does not violate RFC
 */
static int test_set_alpn(void)
{
    SSL_CTX *ctx = NULL;
    SSL *ssl = NULL;
    int testresult = 0;

    unsigned char bad0[] = { 0x00, 'b', 'a', 'd' };
    unsigned char good[] = { 0x04, 'g', 'o', 'o', 'd' };
    unsigned char bad1[] = { 0x01, 'b', 'a', 'd' };
    unsigned char bad2[] = { 0x03, 'b', 'a', 'd', 0x00};
    unsigned char bad3[] = { 0x03, 'b', 'a', 'd', 0x01, 'b', 'a', 'd'};
    unsigned char bad4[] = { 0x03, 'b', 'a', 'd', 0x06, 'b', 'a', 'd'};

    /* Create an initial SSL_CTX with no certificate configured */
    ctx = SSL_CTX_new_ex(libctx, NULL, TLS_server_method());
    if (!TEST_ptr(ctx))
        goto end;

    /* the set_alpn functions return 0 (false) on success, non-zero (true) on failure */
    if (!TEST_false(SSL_CTX_set_alpn_protos(ctx, NULL, 2)))
        goto end;
    if (!TEST_false(SSL_CTX_set_alpn_protos(ctx, good, 0)))
        goto end;
    if (!TEST_false(SSL_CTX_set_alpn_protos(ctx, good, sizeof(good))))
        goto end;
    if (!TEST_true(SSL_CTX_set_alpn_protos(ctx, good, 1)))
        goto end;
    if (!TEST_true(SSL_CTX_set_alpn_protos(ctx, bad0, sizeof(bad0))))
        goto end;
    if (!TEST_true(SSL_CTX_set_alpn_protos(ctx, bad1, sizeof(bad1))))
        goto end;
    if (!TEST_true(SSL_CTX_set_alpn_protos(ctx, bad2, sizeof(bad2))))
        goto end;
    if (!TEST_true(SSL_CTX_set_alpn_protos(ctx, bad3, sizeof(bad3))))
        goto end;
    if (!TEST_true(SSL_CTX_set_alpn_protos(ctx, bad4, sizeof(bad4))))
        goto end;

    ssl = SSL_new(ctx);
    if (!TEST_ptr(ssl))
        goto end;

    if (!TEST_false(SSL_set_alpn_protos(ssl, NULL, 2)))
        goto end;
    if (!TEST_false(SSL_set_alpn_protos(ssl, good, 0)))
        goto end;
    if (!TEST_false(SSL_set_alpn_protos(ssl, good, sizeof(good))))
        goto end;
    if (!TEST_true(SSL_set_alpn_protos(ssl, good, 1)))
        goto end;
    if (!TEST_true(SSL_set_alpn_protos(ssl, bad0, sizeof(bad0))))
        goto end;
    if (!TEST_true(SSL_set_alpn_protos(ssl, bad1, sizeof(bad1))))
        goto end;
    if (!TEST_true(SSL_set_alpn_protos(ssl, bad2, sizeof(bad2))))
        goto end;
    if (!TEST_true(SSL_set_alpn_protos(ssl, bad3, sizeof(bad3))))
        goto end;
    if (!TEST_true(SSL_set_alpn_protos(ssl, bad4, sizeof(bad4))))
        goto end;

    testresult = 1;

end:
    SSL_free(ssl);
    SSL_CTX_free(ctx);
    return testresult;
}

/*
 * Test SSL_CTX_set1_verify/chain_cert_store and SSL_CTX_get_verify/chain_cert_store.
 */
static int test_set_verify_cert_store_ssl_ctx(void)
{
   SSL_CTX *ctx = NULL;
   int testresult = 0;
   X509_STORE *store = NULL, *new_store = NULL,
              *cstore = NULL, *new_cstore = NULL;

   /* Create an initial SSL_CTX. */
   ctx = SSL_CTX_new_ex(libctx, NULL, TLS_server_method());
   if (!TEST_ptr(ctx))
       goto end;

   /* Retrieve verify store pointer. */
   if (!TEST_true(SSL_CTX_get0_verify_cert_store(ctx, &store)))
       goto end;

   /* Retrieve chain store pointer. */
   if (!TEST_true(SSL_CTX_get0_chain_cert_store(ctx, &cstore)))
       goto end;

   /* We haven't set any yet, so this should be NULL. */
   if (!TEST_ptr_null(store) || !TEST_ptr_null(cstore))
       goto end;

   /* Create stores. We use separate stores so pointers are different. */
   new_store = X509_STORE_new();
   if (!TEST_ptr(new_store))
       goto end;

   new_cstore = X509_STORE_new();
   if (!TEST_ptr(new_cstore))
       goto end;

   /* Set stores. */
   if (!TEST_true(SSL_CTX_set1_verify_cert_store(ctx, new_store)))
       goto end;

   if (!TEST_true(SSL_CTX_set1_chain_cert_store(ctx, new_cstore)))
       goto end;

   /* Should be able to retrieve the same pointer. */
   if (!TEST_true(SSL_CTX_get0_verify_cert_store(ctx, &store)))
       goto end;

   if (!TEST_true(SSL_CTX_get0_chain_cert_store(ctx, &cstore)))
       goto end;

   if (!TEST_ptr_eq(store, new_store) || !TEST_ptr_eq(cstore, new_cstore))
       goto end;

   /* Should be able to unset again. */
   if (!TEST_true(SSL_CTX_set1_verify_cert_store(ctx, NULL)))
       goto end;

   if (!TEST_true(SSL_CTX_set1_chain_cert_store(ctx, NULL)))
       goto end;

   /* Should now be NULL. */
   if (!TEST_true(SSL_CTX_get0_verify_cert_store(ctx, &store)))
       goto end;

   if (!TEST_true(SSL_CTX_get0_chain_cert_store(ctx, &cstore)))
       goto end;

   if (!TEST_ptr_null(store) || !TEST_ptr_null(cstore))
       goto end;

   testresult = 1;

end:
   X509_STORE_free(new_store);
   X509_STORE_free(new_cstore);
   SSL_CTX_free(ctx);
   return testresult;
}

/*
 * Test SSL_set1_verify/chain_cert_store and SSL_get_verify/chain_cert_store.
 */
static int test_set_verify_cert_store_ssl(void)
{
   SSL_CTX *ctx = NULL;
   SSL *ssl = NULL;
   int testresult = 0;
   X509_STORE *store = NULL, *new_store = NULL,
              *cstore = NULL, *new_cstore = NULL;

   /* Create an initial SSL_CTX. */
   ctx = SSL_CTX_new_ex(libctx, NULL, TLS_server_method());
   if (!TEST_ptr(ctx))
       goto end;

   /* Create an SSL object. */
   ssl = SSL_new(ctx);
   if (!TEST_ptr(ssl))
       goto end;

   /* Retrieve verify store pointer. */
   if (!TEST_true(SSL_get0_verify_cert_store(ssl, &store)))
       goto end;

   /* Retrieve chain store pointer. */
   if (!TEST_true(SSL_get0_chain_cert_store(ssl, &cstore)))
       goto end;

   /* We haven't set any yet, so this should be NULL. */
   if (!TEST_ptr_null(store) || !TEST_ptr_null(cstore))
       goto end;

   /* Create stores. We use separate stores so pointers are different. */
   new_store = X509_STORE_new();
   if (!TEST_ptr(new_store))
       goto end;

   new_cstore = X509_STORE_new();
   if (!TEST_ptr(new_cstore))
       goto end;

   /* Set stores. */
   if (!TEST_true(SSL_set1_verify_cert_store(ssl, new_store)))
       goto end;

   if (!TEST_true(SSL_set1_chain_cert_store(ssl, new_cstore)))
       goto end;

   /* Should be able to retrieve the same pointer. */
   if (!TEST_true(SSL_get0_verify_cert_store(ssl, &store)))
       goto end;

   if (!TEST_true(SSL_get0_chain_cert_store(ssl, &cstore)))
       goto end;

   if (!TEST_ptr_eq(store, new_store) || !TEST_ptr_eq(cstore, new_cstore))
       goto end;

   /* Should be able to unset again. */
   if (!TEST_true(SSL_set1_verify_cert_store(ssl, NULL)))
       goto end;

   if (!TEST_true(SSL_set1_chain_cert_store(ssl, NULL)))
       goto end;

   /* Should now be NULL. */
   if (!TEST_true(SSL_get0_verify_cert_store(ssl, &store)))
       goto end;

   if (!TEST_true(SSL_get0_chain_cert_store(ssl, &cstore)))
       goto end;

   if (!TEST_ptr_null(store) || !TEST_ptr_null(cstore))
       goto end;

   testresult = 1;

end:
   X509_STORE_free(new_store);
   X509_STORE_free(new_cstore);
   SSL_free(ssl);
   SSL_CTX_free(ctx);
   return testresult;
}


static int test_inherit_verify_param(void)
{
    int testresult = 0;

    SSL_CTX *ctx = NULL;
    X509_VERIFY_PARAM *cp = NULL;
    SSL *ssl = NULL;
    X509_VERIFY_PARAM *sp = NULL;
    int hostflags = X509_CHECK_FLAG_NEVER_CHECK_SUBJECT;

    ctx = SSL_CTX_new_ex(libctx, NULL, TLS_server_method());
    if (!TEST_ptr(ctx))
        goto end;

    cp = SSL_CTX_get0_param(ctx);
    if (!TEST_ptr(cp))
        goto end;
    if (!TEST_int_eq(X509_VERIFY_PARAM_get_hostflags(cp), 0))
        goto end;

    X509_VERIFY_PARAM_set_hostflags(cp, hostflags);

    ssl = SSL_new(ctx);
    if (!TEST_ptr(ssl))
        goto end;

    sp = SSL_get0_param(ssl);
    if (!TEST_ptr(sp))
        goto end;
    if (!TEST_int_eq(X509_VERIFY_PARAM_get_hostflags(sp), hostflags))
        goto end;

    testresult = 1;

 end:
    SSL_free(ssl);
    SSL_CTX_free(ctx);

    return testresult;
}

static int test_load_dhfile(void)
{
#ifndef OPENSSL_NO_DH
    int testresult = 0;

    SSL_CTX *ctx = NULL;
    SSL_CONF_CTX *cctx = NULL;

    if (dhfile == NULL)
        return 1;

    if (!TEST_ptr(ctx = SSL_CTX_new_ex(libctx, NULL, TLS_client_method()))
        || !TEST_ptr(cctx = SSL_CONF_CTX_new()))
        goto end;

    SSL_CONF_CTX_set_ssl_ctx(cctx, ctx);
    SSL_CONF_CTX_set_flags(cctx,
                           SSL_CONF_FLAG_CERTIFICATE
                           | SSL_CONF_FLAG_SERVER
                           | SSL_CONF_FLAG_FILE);

    if (!TEST_int_eq(SSL_CONF_cmd(cctx, "DHParameters", dhfile), 2))
        goto end;

    testresult = 1;
end:
    SSL_CONF_CTX_free(cctx);
    SSL_CTX_free(ctx);

    return testresult;
#else
    return TEST_skip("DH not supported by this build");
#endif
}

#if !defined(OPENSSL_NO_TLS1_2) && !defined(OPENSSL_NO_DYNAMIC_ENGINE)
/*
 * Test TLSv1.2 with a pipeline capable cipher. TLSv1.3 and DTLS do not
 * support this yet. The only pipeline capable cipher that we have is in the
 * dasync engine (providers don't support this yet), so we have to use
 * deprecated APIs for this test.
 *
 * Test 0: Client has pipelining enabled, server does not
 * Test 1: Server has pipelining enabled, client does not
 * Test 2: Client has pipelining enabled, server does not: not enough data to
 *         fill all the pipelines
 * Test 3: Client has pipelining enabled, server does not: not enough data to
 *         fill all the pipelines by more than a full pipeline's worth
 * Test 4: Client has pipelining enabled, server does not: more data than all
 *         the available pipelines can take
 * Test 5: Client has pipelining enabled, server does not: Maximum size pipeline
 * Test 6: Repeat of test 0, but the engine is loaded late (after the SSL_CTX
 *         is created)
 */
static int test_pipelining(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL, *peera, *peerb;
    int testresult = 0, numreads;
    /* A 55 byte message */
    unsigned char *msg = (unsigned char *)
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz123";
    size_t written, readbytes, offset, msglen, fragsize = 10, numpipes = 5;
    size_t expectedreads;
    unsigned char *buf = NULL;
    ENGINE *e = NULL;

    if (idx != 6) {
        e = load_dasync();
        if (e == NULL)
            return 0;
    }

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), 0,
                                       TLS1_2_VERSION, &sctx, &cctx, cert,
                                       privkey)))
        goto end;

    if (idx == 6) {
        e = load_dasync();
        if (e == NULL)
            goto end;
        /* Now act like test 0 */
        idx = 0;
    }

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL)))
        goto end;

    if (!TEST_true(SSL_set_cipher_list(clientssl, "AES128-SHA")))
        goto end;

    /* peera is always configured for pipelining, while peerb is not. */
    if (idx == 1) {
        peera = serverssl;
        peerb = clientssl;

    } else {
        peera = clientssl;
        peerb = serverssl;
    }

    if (idx == 5) {
        numpipes = 2;
        /* Maximum allowed fragment size */
        fragsize = SSL3_RT_MAX_PLAIN_LENGTH;
        msglen = fragsize * numpipes;
        msg = OPENSSL_malloc(msglen);
        if (!TEST_ptr(msg))
            goto end;
        if (!TEST_int_gt(RAND_bytes_ex(libctx, msg, msglen, 0), 0))
            goto end;
    } else if (idx == 4) {
        msglen = 55;
    } else {
        msglen = 50;
    }
    if (idx == 2)
        msglen -= 2; /* Send 2 less bytes */
    else if (idx == 3)
        msglen -= 12; /* Send 12 less bytes */

    buf = OPENSSL_malloc(msglen);
    if (!TEST_ptr(buf))
        goto end;

    if (idx == 5) {
        /*
         * Test that setting a split send fragment longer than the maximum
         * allowed fails
         */
        if (!TEST_false(SSL_set_split_send_fragment(peera, fragsize + 1)))
            goto end;
    }

    /*
     * In the normal case. We have 5 pipelines with 10 bytes per pipeline
     * (50 bytes in total). This is a ridiculously small number of bytes -
     * but sufficient for our purposes
     */
    if (!TEST_true(SSL_set_max_pipelines(peera, numpipes))
            || !TEST_true(SSL_set_split_send_fragment(peera, fragsize)))
        goto end;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    /* Write some data from peera to peerb */
    if (!TEST_true(SSL_write_ex(peera, msg, msglen, &written))
        || !TEST_size_t_eq(written, msglen))
        goto end;

    /*
     * If the pipelining code worked, then we expect all |numpipes| pipelines to
     * have been used - except in test 3 where only |numpipes - 1| pipelines
     * will be used. This will result in |numpipes| records (|numpipes - 1| for
     * test 3) having been sent to peerb. Since peerb is not using read_ahead we
     * expect this to be read in |numpipes| or |numpipes - 1| separate
     * SSL_read_ex calls. In the case of test 4, there is then one additional
     * read for left over data that couldn't fit in the previous pipelines
     */
    for (offset = 0, numreads = 0;
         offset < msglen;
         offset += readbytes, numreads++) {
        if (!TEST_true(SSL_read_ex(peerb, buf + offset,
                                   msglen - offset, &readbytes)))
            goto end;
    }

    expectedreads = idx == 4 ? numpipes + 1
                             : (idx == 3 ? numpipes - 1 : numpipes);
    if (!TEST_mem_eq(msg, msglen, buf, offset)
            || !TEST_int_eq(numreads, expectedreads))
        goto end;

    /*
     * Write some data from peerb to peera. We do this in up to |numpipes + 1|
     * chunks to exercise the read pipelining code on peera.
     */
    for (offset = 0; offset < msglen; offset += fragsize) {
        size_t sendlen = msglen - offset;

        if (sendlen > fragsize)
            sendlen = fragsize;
        if (!TEST_true(SSL_write_ex(peerb, msg + offset, sendlen, &written))
                || !TEST_size_t_eq(written, sendlen))
            goto end;
    }

    /*
     * The data was written in |numpipes|, |numpipes - 1| or |numpipes + 1|
     * separate chunks (depending on which test we are running). If the
     * pipelining is working then we expect peera to read up to numpipes chunks
     * and process them in parallel, giving back the complete result in a single
     * call to SSL_read_ex
     */
    if (!TEST_true(SSL_read_ex(peera, buf, msglen, &readbytes))
            || !TEST_size_t_le(readbytes, msglen))
        goto end;

    if (idx == 4) {
        size_t readbytes2;

        if (!TEST_true(SSL_read_ex(peera, buf + readbytes,
                                   msglen - readbytes, &readbytes2)))
            goto end;
        readbytes += readbytes2;
        if (!TEST_size_t_le(readbytes, msglen))
            goto end;
    }

    if (!TEST_mem_eq(msg, msglen, buf, readbytes))
        goto end;

    testresult = 1;
end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    if (e != NULL) {
        ENGINE_unregister_ciphers(e);
        ENGINE_finish(e);
        ENGINE_free(e);
    }
    OPENSSL_free(buf);
    if (fragsize == SSL3_RT_MAX_PLAIN_LENGTH)
        OPENSSL_free(msg);
    return testresult;
}
#endif /* !defined(OPENSSL_NO_TLS1_2) && !defined(OPENSSL_NO_DYNAMIC_ENGINE) */

/*
 * Force a write retry during handshaking. We test various combinations of
 * scenarios. We test a large certificate message which will fill the buffering
 * BIO used in the handshake. We try with client auth on and off. Finally we
 * also try a BIO that indicates retry via a 0 return. BIO_write() is documented
 * to indicate retry via -1 - but sometimes BIOs don't do that.
 *
 * Test 0: Standard certificate message
 * Test 1: Large certificate message
 * Test 2: Standard cert, verify peer
 * Test 3: Large cert, verify peer
 * Test 4: Standard cert, BIO returns 0 on retry
 * Test 5: Large cert, BIO returns 0 on retry
 * Test 6: Standard cert, verify peer, BIO returns 0 on retry
 * Test 7: Large cert, verify peer, BIO returns 0 on retry
 * Test 8-15: Repeat of above with TLSv1.2
 */
static int test_handshake_retry(int idx)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    BIO *tmp = NULL, *bretry = BIO_new(bio_s_always_retry());
    int maxversion = 0;

    if (!TEST_ptr(bretry))
        goto end;

#ifndef OPENSSL_NO_TLS1_2
    if ((idx & 8) == 8)
        maxversion = TLS1_2_VERSION;
#else
    if ((idx & 8) == 8)
        return TEST_skip("No TLSv1.2");
#endif

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), 0, maxversion,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    /*
     * Add a large amount of data to fill the buffering BIO used by the SSL
     * object
     */
    if ((idx & 1) == 1 && !add_large_cert_chain(sctx))
        goto end;

    /*
     * We don't actually configure a client cert, but neither do we fail if one
     * isn't present.
     */
    if ((idx & 2) == 2)
        SSL_CTX_set_verify(sctx, SSL_VERIFY_PEER, NULL);

    if ((idx & 4) == 4)
        set_always_retry_err_val(0);

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                      &clientssl, NULL, NULL)))
        goto end;

    tmp = SSL_get_wbio(serverssl);
    if (!TEST_ptr(tmp) || !TEST_true(BIO_up_ref(tmp))) {
        tmp = NULL;
        goto end;
    }
    SSL_set0_wbio(serverssl, bretry);
    bretry = NULL;

    if (!TEST_int_eq(SSL_connect(clientssl), -1))
        goto end;

    if (!TEST_int_eq(SSL_accept(serverssl), -1)
            || !TEST_int_eq(SSL_get_error(serverssl, -1), SSL_ERROR_WANT_WRITE))
        goto end;

    /* Restore a BIO that will let the write succeed */
    SSL_set0_wbio(serverssl, tmp);
    tmp = NULL;

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
        goto end;

    testresult = 1;
end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    BIO_free(bretry);
    BIO_free(tmp);
    set_always_retry_err_val(-1);
    return testresult;
}

struct resume_servername_cb_data {
    int i;
    SSL_CTX *cctx;
    SSL_CTX *sctx;
    SSL_SESSION *sess;
    int recurse;
};

/*
 * Servername callback. We use it here to run another complete handshake using
 * the same session - and mark the session as not_resuamble at the end
 */
static int resume_servername_cb(SSL *s, int *ad, void *arg)
{
    struct resume_servername_cb_data *cbdata = arg;
    SSL *serverssl = NULL, *clientssl = NULL;
    int ret = SSL_TLSEXT_ERR_ALERT_FATAL;

    if (cbdata->recurse)
        return SSL_TLSEXT_ERR_ALERT_FATAL;

    if ((cbdata->i % 3) != 1)
        return SSL_TLSEXT_ERR_OK;

    cbdata->recurse = 1;

    if (!TEST_true(create_ssl_objects(cbdata->sctx, cbdata->cctx, &serverssl,
                                      &clientssl, NULL, NULL))
            || !TEST_true(SSL_set_session(clientssl, cbdata->sess)))
        goto end;

    ERR_set_mark();
    /*
     * We expect this to fail - because the servername cb will fail. This will
     * mark the session as not_resumable.
     */
    if (!TEST_false(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE))) {
        ERR_clear_last_mark();
        goto end;
    }
    ERR_pop_to_mark();

    ret = SSL_TLSEXT_ERR_OK;
 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    cbdata->recurse = 0;
    return ret;
}

/*
 * Test multiple resumptions and cache size handling
 * Test 0: TLSv1.3 (max_early_data set)
 * Test 1: TLSv1.3 (SSL_OP_NO_TICKET set)
 * Test 2: TLSv1.3 (max_early_data and SSL_OP_NO_TICKET set)
 * Test 3: TLSv1.3 (SSL_OP_NO_TICKET, simultaneous resumes)
 * Test 4: TLSv1.2
 */
static int test_multi_resume(int idx)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *serverssl = NULL, *clientssl = NULL;
    SSL_SESSION *sess = NULL;
    int max_version = TLS1_3_VERSION;
    int i, testresult = 0;
    struct resume_servername_cb_data cbdata;

#if defined(OPENSSL_NO_TLS1_2)
    if (idx == 4)
        return TEST_skip("TLSv1.2 is disabled in this build");
#else
    if (idx == 4)
        max_version = TLS1_2_VERSION;
#endif
#if defined(OSSL_NO_USABLE_TLS1_3)
    if (idx != 4)
        return TEST_skip("No usable TLSv1.3 in this build");
#endif

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), TLS1_VERSION,
                                       max_version, &sctx, &cctx, cert,
                                       privkey)))
        goto end;

    /*
     * TLSv1.3 only uses a session cache if either max_early_data > 0 (used for
     * replay protection), or if SSL_OP_NO_TICKET is in use
     */
    if (idx == 0 || idx == 2)  {
        if (!TEST_true(SSL_CTX_set_max_early_data(sctx, 1024)))
            goto end;
    }
    if (idx == 1 || idx == 2 || idx == 3)
        SSL_CTX_set_options(sctx, SSL_OP_NO_TICKET);

    SSL_CTX_sess_set_cache_size(sctx, 5);

    if (idx == 3) {
        SSL_CTX_set_tlsext_servername_callback(sctx, resume_servername_cb);
        SSL_CTX_set_tlsext_servername_arg(sctx, &cbdata);
        cbdata.cctx = cctx;
        cbdata.sctx = sctx;
        cbdata.recurse = 0;
    }

    for (i = 0; i < 30; i++) {
        if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,
                                                NULL, NULL))
                || !TEST_true(SSL_set_session(clientssl, sess)))
            goto end;

        /*
         * Check simultaneous resumes. We pause the connection part way through
         * the handshake by (mis)using the servername_cb. The pause occurs after
         * session resumption has already occurred, but before any session
         * tickets have been issued. While paused we run another complete
         * handshake resuming the same session.
         */
        if (idx == 3) {
            cbdata.i = i;
            cbdata.sess = sess;
        }

        /*
         * Recreate a bug where dynamically changing the max_early_data value
         * can cause sessions in the session cache which cannot be deleted.
         */
        if ((idx == 0 || idx == 2) && (i % 3) == 2)
            SSL_set_max_early_data(serverssl, 0);

        if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
            goto end;

        if (sess == NULL || (idx == 0 && (i % 3) == 2)) {
            if (!TEST_false(SSL_session_reused(clientssl)))
                goto end;
        } else {
            if (!TEST_true(SSL_session_reused(clientssl)))
                goto end;
        }
        SSL_SESSION_free(sess);

        /* Do a full handshake, followed by two resumptions */
        if ((i % 3) == 2) {
            sess = NULL;
        } else {
            if (!TEST_ptr((sess = SSL_get1_session(clientssl))))
                goto end;
        }

        SSL_shutdown(clientssl);
        SSL_shutdown(serverssl);
        SSL_free(serverssl);
        SSL_free(clientssl);
        serverssl = clientssl = NULL;
    }

    /* We should never exceed the session cache size limit */
    if (!TEST_long_le(SSL_CTX_sess_number(sctx), 5))
        goto end;

    testresult = 1;
 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    SSL_SESSION_free(sess);
    return testresult;
}
#ifndef OPENSSL_NO_QUIC
static int test_quic_set_encryption_secrets(SSL *ssl,
                                            OSSL_ENCRYPTION_LEVEL level,
                                            const uint8_t *read_secret,
                                            const uint8_t *write_secret,
                                            size_t secret_len)
{
    test_printf_stderr("quic_set_encryption_secrets() %s, lvl=%d, len=%zd\n",
                       ssl->server ? "server" : "client", level, secret_len);
    return 1;
}

static int test_quic_add_handshake_data(SSL *ssl, OSSL_ENCRYPTION_LEVEL level,
                                        const uint8_t *data, size_t len)
{
    SSL *peer = (SSL*)SSL_get_app_data(ssl);

    TEST_info("quic_add_handshake_data() %s, lvl=%d, *data=0x%02X, len=%zd\n",
              ssl->server ? "server" : "client", level, (int)*data, len);
    if (!TEST_ptr(peer))
        return 0;

    /* We're called with what is locally written; this gives it to the peer */
    if (!TEST_true(SSL_provide_quic_data(peer, level, data, len))) {
        ERR_print_errors_fp(stderr);
        return 0;
    }

    return 1;
}

static int test_quic_flush_flight(SSL *ssl)
{
    test_printf_stderr("quic_flush_flight() %s\n", ssl->server ? "server" : "client");
    return 1;
}

static int test_quic_send_alert(SSL *ssl, enum ssl_encryption_level_t level, uint8_t alert)
{
    test_printf_stderr("quic_send_alert() %s, lvl=%d, alert=%d\n",
                       ssl->server ? "server" : "client", level, alert);
    return 1;
}

static SSL_QUIC_METHOD quic_method = {
    test_quic_set_encryption_secrets,
    test_quic_add_handshake_data,
    test_quic_flush_flight,
    test_quic_send_alert,
};

static int test_quic_api_set_versions(SSL *ssl, int ver)
{
    SSL_set_quic_transport_version(ssl, ver);
    return 1;
}

static int test_quic_api_version(int clnt, int srvr)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;

    static const char *server_str = "SERVER";
    static const char *client_str = "CLIENT";
    const uint8_t *peer_str;
    size_t peer_str_len;

    TEST_info("original clnt=0x%X, srvr=0x%X\n", clnt, srvr);

    if (!TEST_true(create_ssl_ctx_pair(libctx,
                                       TLS_server_method(),
                                       TLS_client_method(),
                                       TLS1_3_VERSION, 0,
                                       &sctx, &cctx, cert, privkey))
            || !TEST_true(SSL_CTX_set_quic_method(sctx, &quic_method))
            || !TEST_true(SSL_CTX_set_quic_method(cctx, &quic_method))
            || !TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
                                             &clientssl, NULL, NULL))
            || !TEST_true(SSL_set_quic_transport_params(serverssl,
                                                        (unsigned char*)server_str,
                                                        strlen(server_str)+1))
            || !TEST_true(SSL_set_quic_transport_params(clientssl,
                                                        (unsigned char*)client_str,
                                                        strlen(client_str)+1))
            || !TEST_true(SSL_set_app_data(serverssl, clientssl))
            || !TEST_true(SSL_set_app_data(clientssl, serverssl))
            || !TEST_true(test_quic_api_set_versions(clientssl, clnt))
            || !TEST_true(test_quic_api_set_versions(serverssl, srvr))
            || !TEST_true(create_bare_ssl_connection(serverssl, clientssl,
                                                     SSL_ERROR_NONE, 0))
            || !TEST_true(SSL_version(serverssl) == TLS1_3_VERSION)
            || !TEST_true(SSL_version(clientssl) == TLS1_3_VERSION)
            || !(TEST_int_eq(SSL_quic_read_level(clientssl), ssl_encryption_application))
            || !(TEST_int_eq(SSL_quic_read_level(serverssl), ssl_encryption_application))
            || !(TEST_int_eq(SSL_quic_write_level(clientssl), ssl_encryption_application))
            || !(TEST_int_eq(SSL_quic_write_level(serverssl), ssl_encryption_application)))
        goto end;

    SSL_get_peer_quic_transport_params(serverssl, &peer_str, &peer_str_len);
    if (!TEST_mem_eq(peer_str, peer_str_len, client_str, strlen(client_str)+1))
        goto end;
    SSL_get_peer_quic_transport_params(clientssl, &peer_str, &peer_str_len);
    if (!TEST_mem_eq(peer_str, peer_str_len, server_str, strlen(server_str)+1))
        goto end;

    /* Deal with two NewSessionTickets */
    if (!TEST_true(SSL_process_quic_post_handshake(clientssl)))
        goto end;

    /* Dummy handshake call should succeed */
    if (!TEST_true(SSL_do_handshake(clientssl)))
        goto end;
    /* Test that we (correctly) fail to send KeyUpdate */
    if (!TEST_true(SSL_key_update(clientssl, SSL_KEY_UPDATE_NOT_REQUESTED))
            || !TEST_int_le(SSL_do_handshake(clientssl), 0))
        goto end;
    if (!TEST_true(SSL_key_update(serverssl, SSL_KEY_UPDATE_NOT_REQUESTED))
            || !TEST_int_le(SSL_do_handshake(serverssl), 0))
        goto end;

    TEST_info("original clnt=0x%X, srvr=0x%X\n", clnt, srvr);
    if (srvr == 0 && clnt == 0)
        srvr = clnt = TLSEXT_TYPE_quic_transport_parameters;
    else if (srvr == 0)
        srvr = clnt;
    else if (clnt == 0)
        clnt = srvr;
    TEST_info("expected clnt=0x%X, srvr=0x%X\n", clnt, srvr);
    if (!TEST_int_eq(SSL_get_peer_quic_transport_version(serverssl), clnt))
        goto end;
    if (!TEST_int_eq(SSL_get_peer_quic_transport_version(clientssl), srvr))
        goto end;

    testresult = 1;

 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

static int test_quic_api(int tst)
{
    SSL_CTX *sctx = NULL;
    SSL *serverssl = NULL;
    int testresult = 0;
    static int clnt_params[] = { 0,
                                 TLSEXT_TYPE_quic_transport_parameters_draft,
                                 TLSEXT_TYPE_quic_transport_parameters,
                                 0,
                                 TLSEXT_TYPE_quic_transport_parameters_draft,
                                 TLSEXT_TYPE_quic_transport_parameters,
                                 0,
                                 TLSEXT_TYPE_quic_transport_parameters_draft,
                                 TLSEXT_TYPE_quic_transport_parameters };
    static int srvr_params[] = { 0,
                                 0,
                                 0,
                                 TLSEXT_TYPE_quic_transport_parameters_draft,
                                 TLSEXT_TYPE_quic_transport_parameters_draft,
                                 TLSEXT_TYPE_quic_transport_parameters_draft,
                                 TLSEXT_TYPE_quic_transport_parameters,
                                 TLSEXT_TYPE_quic_transport_parameters,
                                 TLSEXT_TYPE_quic_transport_parameters };
    static int results[] = { 1, 1, 1, 1, 1, 0, 1, 0, 1 };

    /* Failure cases:
     * test 6/[5] clnt = parameters, srvr = draft
     * test 8/[7] clnt = draft, srvr = parameters
     */

    /* Clean up logging space */
    memset(client_log_buffer, 0, sizeof(client_log_buffer));
    memset(server_log_buffer, 0, sizeof(server_log_buffer));
    client_log_buffer_index = 0;
    server_log_buffer_index = 0;
    error_writing_log = 0;

    if (!TEST_ptr(sctx = SSL_CTX_new_ex(libctx, NULL, TLS_server_method()))
            || !TEST_true(SSL_CTX_set_quic_method(sctx, &quic_method))
            || !TEST_ptr(sctx->quic_method)
            || !TEST_ptr(serverssl = SSL_new(sctx))
            || !TEST_true(SSL_IS_QUIC(serverssl))
            || !TEST_true(SSL_set_quic_method(serverssl, NULL))
            || !TEST_false(SSL_IS_QUIC(serverssl))
            || !TEST_true(SSL_set_quic_method(serverssl, &quic_method))
            || !TEST_true(SSL_IS_QUIC(serverssl)))
        goto end;

    if (!TEST_int_eq(test_quic_api_version(clnt_params[tst], srvr_params[tst]), results[tst]))
        goto end;

    testresult = 1;

end:
    SSL_CTX_free(sctx);
    sctx = NULL;
    SSL_free(serverssl);
    serverssl = NULL;
    return testresult;
}

# ifndef OSSL_NO_USABLE_TLS1_3
/*
 * Helper method to setup objects for QUIC early data test. Caller
 * frees objects on error.
 */
static int quic_setupearly_data_test(SSL_CTX **cctx, SSL_CTX **sctx,
                                     SSL **clientssl, SSL **serverssl,
                                     SSL_SESSION **sess, int idx)
{
    static const char *server_str = "SERVER";
    static const char *client_str = "CLIENT";

    if (*sctx == NULL
            && (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                               TLS_client_method(),
                                               TLS1_3_VERSION, 0,
                                               sctx, cctx, cert, privkey))
                || !TEST_true(SSL_CTX_set_quic_method(*sctx, &quic_method))
                || !TEST_true(SSL_CTX_set_quic_method(*cctx, &quic_method))
                || !TEST_true(SSL_CTX_set_max_early_data(*sctx, 0xffffffffu))))
        return 0;

    if (idx == 1) {
        /* When idx == 1 we repeat the tests with read_ahead set */
        SSL_CTX_set_read_ahead(*cctx, 1);
        SSL_CTX_set_read_ahead(*sctx, 1);
    } else if (idx == 2) {
        /* When idx == 2 we are doing early_data with a PSK. Set up callbacks */
        SSL_CTX_set_psk_use_session_callback(*cctx, use_session_cb);
        SSL_CTX_set_psk_find_session_callback(*sctx, find_session_cb);
        use_session_cb_cnt = 0;
        find_session_cb_cnt = 0;
        srvid = pskid;
    }

    if (!TEST_true(create_ssl_objects(*sctx, *cctx, serverssl, clientssl,
                                      NULL, NULL))
            || !TEST_true(SSL_set_quic_transport_params(*serverssl,
                                                        (unsigned char*)server_str,
                                                        strlen(server_str)+1))
            || !TEST_true(SSL_set_quic_transport_params(*clientssl,
                                                        (unsigned char*)client_str,
                                                        strlen(client_str)+1))
            || !TEST_true(SSL_set_app_data(*serverssl, *clientssl))
            || !TEST_true(SSL_set_app_data(*clientssl, *serverssl)))
        return 0;

    /*
     * For one of the run throughs (doesn't matter which one), we'll try sending
     * some SNI data in the initial ClientHello. This will be ignored (because
     * there is no SNI cb set up by the server), so it should not impact
     * early_data.
     */
    if (idx == 1
            && !TEST_true(SSL_set_tlsext_host_name(*clientssl, "localhost")))
        return 0;

    if (idx == 2) {
        clientpsk = create_a_psk(*clientssl, SHA256_DIGEST_LENGTH);
        if (!TEST_ptr(clientpsk)
                || !TEST_true(SSL_SESSION_set_max_early_data(clientpsk,
                                                             0xffffffffu))
                || !TEST_true(SSL_SESSION_up_ref(clientpsk))) {
            SSL_SESSION_free(clientpsk);
            clientpsk = NULL;
            return 0;
        }
        serverpsk = clientpsk;

        if (sess != NULL) {
            if (!TEST_true(SSL_SESSION_up_ref(clientpsk))) {
                SSL_SESSION_free(clientpsk);
                SSL_SESSION_free(serverpsk);
                clientpsk = serverpsk = NULL;
                return 0;
            }
            *sess = clientpsk;
        }

        SSL_set_quic_early_data_enabled(*serverssl, 1);
        SSL_set_quic_early_data_enabled(*clientssl, 1);

        return 1;
    }

    if (sess == NULL)
        return 1;

    if (!TEST_true(create_bare_ssl_connection(*serverssl, *clientssl,
                                              SSL_ERROR_NONE, 0)))
        return 0;

    /* Deal with two NewSessionTickets */
    if (!TEST_true(SSL_process_quic_post_handshake(*clientssl)))
        return 0;

    *sess = SSL_get1_session(*clientssl);
    SSL_shutdown(*clientssl);
    SSL_shutdown(*serverssl);
    SSL_free(*serverssl);
    SSL_free(*clientssl);
    *serverssl = *clientssl = NULL;

    if (!TEST_true(create_ssl_objects(*sctx, *cctx, serverssl,
                                      clientssl, NULL, NULL))
            || !TEST_true(SSL_set_session(*clientssl, *sess))
            || !TEST_true(SSL_set_quic_transport_params(*serverssl,
                                                        (unsigned char*)server_str,
                                                        strlen(server_str)+1))
            || !TEST_true(SSL_set_quic_transport_params(*clientssl,
                                                        (unsigned char*)client_str,
                                                        strlen(client_str)+1))
            || !TEST_true(SSL_set_app_data(*serverssl, *clientssl))
            || !TEST_true(SSL_set_app_data(*clientssl, *serverssl)))
        return 0;

    SSL_set_quic_early_data_enabled(*serverssl, 1);
    SSL_set_quic_early_data_enabled(*clientssl, 1);

    return 1;
}

static int test_quic_early_data(int tst)
{
    SSL_CTX *cctx = NULL, *sctx = NULL;
    SSL *clientssl = NULL, *serverssl = NULL;
    int testresult = 0;
    SSL_SESSION *sess = NULL;

    if (!TEST_true(quic_setupearly_data_test(&cctx, &sctx, &clientssl,
                                             &serverssl, &sess, tst)))
        goto end;

    if (!TEST_true(create_bare_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE, 0))
            || !TEST_true(SSL_get_early_data_status(serverssl)))
        goto end;

    testresult = 1;

 end:
    SSL_SESSION_free(sess);
    SSL_SESSION_free(clientpsk);
    SSL_SESSION_free(serverpsk);
    clientpsk = serverpsk = NULL;
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}
# endif /* OSSL_NO_USABLE_TLS1_3 */
#endif /* OPENSSL_NO_QUIC */

static struct next_proto_st {
    int serverlen;
    unsigned char server[40];
    int clientlen;
    unsigned char client[40];
    int expected_ret;
    size_t selectedlen;
    unsigned char selected[40];
} next_proto_tests[] = {
    {
        4, { 3, 'a', 'b', 'c' },
        4, { 3, 'a', 'b', 'c' },
        OPENSSL_NPN_NEGOTIATED,
        3, { 'a', 'b', 'c' }
    },
    {
        7, { 3, 'a', 'b', 'c', 2, 'a', 'b' },
        4, { 3, 'a', 'b', 'c' },
        OPENSSL_NPN_NEGOTIATED,
        3, { 'a', 'b', 'c' }
    },
    {
        7, { 2, 'a', 'b', 3, 'a', 'b', 'c', },
        4, { 3, 'a', 'b', 'c' },
        OPENSSL_NPN_NEGOTIATED,
        3, { 'a', 'b', 'c' }
    },
    {
        4, { 3, 'a', 'b', 'c' },
        7, { 3, 'a', 'b', 'c', 2, 'a', 'b', },
        OPENSSL_NPN_NEGOTIATED,
        3, { 'a', 'b', 'c' }
    },
    {
        4, { 3, 'a', 'b', 'c' },
        7, { 2, 'a', 'b', 3, 'a', 'b', 'c'},
        OPENSSL_NPN_NEGOTIATED,
        3, { 'a', 'b', 'c' }
    },
    {
        7, { 2, 'b', 'c', 3, 'a', 'b', 'c' },
        7, { 2, 'a', 'b', 3, 'a', 'b', 'c'},
        OPENSSL_NPN_NEGOTIATED,
        3, { 'a', 'b', 'c' }
    },
    {
        10, { 2, 'b', 'c', 3, 'a', 'b', 'c', 2, 'a', 'b' },
        7, { 2, 'a', 'b', 3, 'a', 'b', 'c'},
        OPENSSL_NPN_NEGOTIATED,
        3, { 'a', 'b', 'c' }
    },
    {
        4, { 3, 'b', 'c', 'd' },
        4, { 3, 'a', 'b', 'c' },
        OPENSSL_NPN_NO_OVERLAP,
        3, { 'a', 'b', 'c' }
    },
    {
        0, { 0 },
        4, { 3, 'a', 'b', 'c' },
        OPENSSL_NPN_NO_OVERLAP,
        3, { 'a', 'b', 'c' }
    },
    {
        -1, { 0 },
        4, { 3, 'a', 'b', 'c' },
        OPENSSL_NPN_NO_OVERLAP,
        3, { 'a', 'b', 'c' }
    },
    {
        4, { 3, 'a', 'b', 'c' },
        0, { 0 },
        OPENSSL_NPN_NO_OVERLAP,
        0, { 0 }
    },
    {
        4, { 3, 'a', 'b', 'c' },
        -1, { 0 },
        OPENSSL_NPN_NO_OVERLAP,
        0, { 0 }
    },
    {
        3, { 3, 'a', 'b', 'c' },
        4, { 3, 'a', 'b', 'c' },
        OPENSSL_NPN_NO_OVERLAP,
        3, { 'a', 'b', 'c' }
    },
    {
        4, { 3, 'a', 'b', 'c' },
        3, { 3, 'a', 'b', 'c' },
        OPENSSL_NPN_NO_OVERLAP,
        0, { 0 }
    }
};

static int test_select_next_proto(int idx)
{
    struct next_proto_st *np = &next_proto_tests[idx];
    int ret = 0;
    unsigned char *out, *client, *server;
    unsigned char outlen;
    unsigned int clientlen, serverlen;

    if (np->clientlen == -1) {
        client = NULL;
        clientlen = 0;
    } else {
        client = np->client;
        clientlen = (unsigned int)np->clientlen;
    }
    if (np->serverlen == -1) {
        server = NULL;
        serverlen = 0;
    } else {
        server = np->server;
        serverlen = (unsigned int)np->serverlen;
    }

    if (!TEST_int_eq(SSL_select_next_proto(&out, &outlen, server, serverlen,
                                           client, clientlen),
                     np->expected_ret))
        goto err;

    if (np->selectedlen == 0) {
        if (!TEST_ptr_null(out) || !TEST_uchar_eq(outlen, 0))
            goto err;
    } else {
        if (!TEST_mem_eq(out, outlen, np->selected, np->selectedlen))
            goto err;
    }

    ret = 1;
 err:
    return ret;
}

static const unsigned char fooprot[] = {3, 'f', 'o', 'o' };
static const unsigned char barprot[] = {3, 'b', 'a', 'r' };

#if !defined(OPENSSL_NO_TLS1_2) && !defined(OPENSSL_NO_NEXTPROTONEG)
static int npn_advert_cb(SSL *ssl, const unsigned char **out,
                         unsigned int *outlen, void *arg)
{
    int *idx = (int *)arg;

    switch (*idx) {
    default:
    case 0:
        *out = fooprot;
        *outlen = sizeof(fooprot);
        return SSL_TLSEXT_ERR_OK;

    case 1:
        *outlen = 0;
        return SSL_TLSEXT_ERR_OK;

    case 2:
        return SSL_TLSEXT_ERR_NOACK;
    }
}

static int npn_select_cb(SSL *s, unsigned char **out, unsigned char *outlen,
                         const unsigned char *in, unsigned int inlen, void *arg)
{
    int *idx = (int *)arg;

    switch (*idx) {
    case 0:
    case 1:
        *out = (unsigned char *)(fooprot + 1);
        *outlen = *fooprot;
        return SSL_TLSEXT_ERR_OK;

    case 3:
        *out = (unsigned char *)(barprot + 1);
        *outlen = *barprot;
        return SSL_TLSEXT_ERR_OK;

    case 4:
        *outlen = 0;
        return SSL_TLSEXT_ERR_OK;

    default:
    case 2:
        return SSL_TLSEXT_ERR_ALERT_FATAL;
    }
}

/*
 * Test the NPN callbacks
 * Test 0: advert = foo, select = foo
 * Test 1: advert = <empty>, select = foo
 * Test 2: no advert
 * Test 3: advert = foo, select = bar
 * Test 4: advert = foo, select = <empty> (should fail)
 */
static int test_npn(int idx)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *serverssl = NULL, *clientssl = NULL;
    int testresult = 0;

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), 0, TLS1_2_VERSION,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    SSL_CTX_set_next_protos_advertised_cb(sctx, npn_advert_cb, &idx);
    SSL_CTX_set_next_proto_select_cb(cctx, npn_select_cb, &idx);

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl, NULL,
                                      NULL)))
        goto end;

    if (idx == 4) {
        /* We don't allow empty selection of NPN, so this should fail */
        if (!TEST_false(create_ssl_connection(serverssl, clientssl,
                                              SSL_ERROR_NONE)))
            goto end;
    } else {
        const unsigned char *prot;
        unsigned int protlen;

        if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                             SSL_ERROR_NONE)))
            goto end;

        SSL_get0_next_proto_negotiated(serverssl, &prot, &protlen);
        switch (idx) {
        case 0:
        case 1:
            if (!TEST_mem_eq(prot, protlen, fooprot + 1, *fooprot))
                goto end;
            break;
        case 2:
            if (!TEST_uint_eq(protlen, 0))
                goto end;
            break;
        case 3:
            if (!TEST_mem_eq(prot, protlen, barprot + 1, *barprot))
                goto end;
            break;
        default:
            TEST_error("Should not get here");
            goto end;
        }
    }

    testresult = 1;
 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}
#endif /* !defined(OPENSSL_NO_TLS1_2) && !defined(OPENSSL_NO_NEXTPROTONEG) */

static int alpn_select_cb2(SSL *ssl, const unsigned char **out,
                           unsigned char *outlen, const unsigned char *in,
                           unsigned int inlen, void *arg)
{
    int *idx = (int *)arg;

    switch (*idx) {
    case 0:
        *out = (unsigned char *)(fooprot + 1);
        *outlen = *fooprot;
        return SSL_TLSEXT_ERR_OK;

    case 2:
        *out = (unsigned char *)(barprot + 1);
        *outlen = *barprot;
        return SSL_TLSEXT_ERR_OK;

    case 3:
        *outlen = 0;
        return SSL_TLSEXT_ERR_OK;

    default:
    case 1:
        return SSL_TLSEXT_ERR_ALERT_FATAL;
    }
    return 0;
}

/*
 * Test the ALPN callbacks
 * Test 0: client = foo, select = foo
 * Test 1: client = <empty>, select = none
 * Test 2: client = foo, select = bar (should fail)
 * Test 3: client = foo, select = <empty> (should fail)
 */
static int test_alpn(int idx)
{
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *serverssl = NULL, *clientssl = NULL;
    int testresult = 0;
    const unsigned char *prots = fooprot;
    unsigned int protslen = sizeof(fooprot);

    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),
                                       TLS_client_method(), 0, 0,
                                       &sctx, &cctx, cert, privkey)))
        goto end;

    SSL_CTX_set_alpn_select_cb(sctx, alpn_select_cb2, &idx);

    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl, NULL,
                                      NULL)))
        goto end;

    if (idx == 1) {
        prots = NULL;
        protslen = 0;
    }

    /* SSL_set_alpn_protos returns 0 for success! */
    if (!TEST_false(SSL_set_alpn_protos(clientssl, prots, protslen)))
        goto end;

    if (idx == 2 || idx == 3) {
        /* We don't allow empty selection of NPN, so this should fail */
        if (!TEST_false(create_ssl_connection(serverssl, clientssl,
                                              SSL_ERROR_NONE)))
            goto end;
    } else {
        const unsigned char *prot;
        unsigned int protlen;

        if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                             SSL_ERROR_NONE)))
            goto end;

        SSL_get0_alpn_selected(clientssl, &prot, &protlen);
        switch (idx) {
        case 0:
            if (!TEST_mem_eq(prot, protlen, fooprot + 1, *fooprot))
                goto end;
            break;
        case 1:
            if (!TEST_uint_eq(protlen, 0))
                goto end;
            break;
        default:
            TEST_error("Should not get here");
            goto end;
        }
    }

    testresult = 1;
 end:
    SSL_free(serverssl);
    SSL_free(clientssl);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);

    return testresult;
}

OPT_TEST_DECLARE_USAGE("certfile privkeyfile srpvfile tmpfile provider config dhfile\n")

int setup_tests(void)
{
    char *modulename;
    char *configfile;

    libctx = OSSL_LIB_CTX_new();
    if (!TEST_ptr(libctx))
        return 0;

    defctxnull = OSSL_PROVIDER_load(NULL, "null");

    /*
     * Verify that the default and fips providers in the default libctx are not
     * available
     */
    if (!TEST_false(OSSL_PROVIDER_available(NULL, "default"))
            || !TEST_false(OSSL_PROVIDER_available(NULL, "fips")))
        return 0;

    if (!test_skip_common_options()) {
        TEST_error("Error parsing test options\n");
        return 0;
    }

    if (!TEST_ptr(certsdir = test_get_argument(0))
            || !TEST_ptr(srpvfile = test_get_argument(1))
            || !TEST_ptr(tmpfilename = test_get_argument(2))
            || !TEST_ptr(modulename = test_get_argument(3))
            || !TEST_ptr(configfile = test_get_argument(4))
            || !TEST_ptr(dhfile = test_get_argument(5)))
        return 0;

    if (!TEST_true(OSSL_LIB_CTX_load_config(libctx, configfile)))
        return 0;

    /* Check we have the expected provider available */
    if (!TEST_true(OSSL_PROVIDER_available(libctx, modulename)))
        return 0;

    /* Check the default provider is not available */
    if (strcmp(modulename, "default") != 0
            && !TEST_false(OSSL_PROVIDER_available(libctx, "default")))
        return 0;

    if (strcmp(modulename, "fips") == 0)
        is_fips = 1;

    /*
     * We add, but don't load the test "tls-provider". We'll load it when we
     * need it.
     */
    if (!TEST_true(OSSL_PROVIDER_add_builtin(libctx, "tls-provider",
                                             tls_provider_init)))
        return 0;


    if (getenv("OPENSSL_TEST_GETCOUNTS") != NULL) {
#ifdef OPENSSL_NO_CRYPTO_MDEBUG
        TEST_error("not supported in this build");
        return 0;
#else
        int i, mcount, rcount, fcount;

        for (i = 0; i < 4; i++)
            test_export_key_mat(i);
        CRYPTO_get_alloc_counts(&mcount, &rcount, &fcount);
        test_printf_stdout("malloc %d realloc %d free %d\n",
                mcount, rcount, fcount);
        return 1;
#endif
    }

    cert = test_mk_file_path(certsdir, "servercert.pem");
    if (cert == NULL)
        goto err;

    privkey = test_mk_file_path(certsdir, "serverkey.pem");
    if (privkey == NULL)
        goto err;

    cert2 = test_mk_file_path(certsdir, "server-ecdsa-cert.pem");
    if (cert2 == NULL)
        goto err;

    privkey2 = test_mk_file_path(certsdir, "server-ecdsa-key.pem");
    if (privkey2 == NULL)
        goto err;

    cert1024 = test_mk_file_path(certsdir, "ee-cert-1024.pem");
    if (cert1024 == NULL)
        goto err;

    privkey1024 = test_mk_file_path(certsdir, "ee-key-1024.pem");
    if (privkey1024 == NULL)
        goto err;

    cert3072 = test_mk_file_path(certsdir, "ee-cert-3072.pem");
    if (cert3072 == NULL)
        goto err;

    privkey3072 = test_mk_file_path(certsdir, "ee-key-3072.pem");
    if (privkey3072 == NULL)
        goto err;

    cert4096 = test_mk_file_path(certsdir, "ee-cert-4096.pem");
    if (cert4096 == NULL)
        goto err;

    privkey4096 = test_mk_file_path(certsdir, "ee-key-4096.pem");
    if (privkey4096 == NULL)
        goto err;

    cert8192 = test_mk_file_path(certsdir, "ee-cert-8192.pem");
    if (cert8192 == NULL)
        goto err;

    privkey8192 = test_mk_file_path(certsdir, "ee-key-8192.pem");
    if (privkey8192 == NULL)
        goto err;

#if !defined(OPENSSL_NO_KTLS) && !defined(OPENSSL_NO_SOCK)
# if !defined(OPENSSL_NO_TLS1_2) || !defined(OSSL_NO_USABLE_TLS1_3)
    ADD_ALL_TESTS(test_ktls, NUM_KTLS_TEST_CIPHERS * 4);
    ADD_ALL_TESTS(test_ktls_sendfile, NUM_KTLS_TEST_CIPHERS);
# endif
#endif
    ADD_TEST(test_large_message_tls);
    ADD_TEST(test_large_message_tls_read_ahead);
#ifndef OPENSSL_NO_DTLS
    ADD_TEST(test_large_message_dtls);
#endif
    ADD_ALL_TESTS(test_large_app_data, 28);
    ADD_TEST(test_cleanse_plaintext);
#ifndef OPENSSL_NO_OCSP
    ADD_TEST(test_tlsext_status_type);
#endif
    ADD_TEST(test_session_with_only_int_cache);
    ADD_TEST(test_session_with_only_ext_cache);
    ADD_TEST(test_session_with_both_cache);
    ADD_TEST(test_session_wo_ca_names);
#ifndef OSSL_NO_USABLE_TLS1_3
    ADD_ALL_TESTS(test_stateful_tickets, 3);
    ADD_ALL_TESTS(test_stateless_tickets, 3);
    ADD_TEST(test_psk_tickets);
    ADD_ALL_TESTS(test_extra_tickets, 6);
#endif
    ADD_ALL_TESTS(test_ssl_set_bio, TOTAL_SSL_SET_BIO_TESTS);
    ADD_TEST(test_ssl_bio_pop_next_bio);
    ADD_TEST(test_ssl_bio_pop_ssl_bio);
    ADD_TEST(test_ssl_bio_change_rbio);
    ADD_TEST(test_ssl_bio_change_wbio);
#if !defined(OPENSSL_NO_TLS1_2) || defined(OSSL_NO_USABLE_TLS1_3)
    ADD_ALL_TESTS(test_set_sigalgs, OSSL_NELEM(testsigalgs) * 2);
    ADD_TEST(test_keylog);
#endif
#ifndef OSSL_NO_USABLE_TLS1_3
    ADD_TEST(test_keylog_no_master_key);
#endif
    ADD_TEST(test_client_cert_verify_cb);
    ADD_TEST(test_ssl_build_cert_chain);
    ADD_TEST(test_ssl_ctx_build_cert_chain);
#ifndef OPENSSL_NO_TLS1_2
    ADD_TEST(test_client_hello_cb);
    ADD_TEST(test_no_ems);
    ADD_TEST(test_ccs_change_cipher);
#endif
#ifndef OSSL_NO_USABLE_TLS1_3
    ADD_ALL_TESTS(test_early_data_read_write, 6);
    /*
     * We don't do replay tests for external PSK. Replay protection isn't used
     * in that scenario.
     */
    ADD_ALL_TESTS(test_early_data_replay, 2);
    ADD_ALL_TESTS(test_early_data_skip, OSSL_NELEM(ciphersuites) * 3);
    ADD_ALL_TESTS(test_early_data_skip_hrr, OSSL_NELEM(ciphersuites) * 3);
    ADD_ALL_TESTS(test_early_data_skip_hrr_fail, OSSL_NELEM(ciphersuites) * 3);
    ADD_ALL_TESTS(test_early_data_skip_abort, OSSL_NELEM(ciphersuites) * 3);
    ADD_ALL_TESTS(test_early_data_not_sent, 3);
    ADD_ALL_TESTS(test_early_data_psk, 8);
    ADD_ALL_TESTS(test_early_data_psk_with_all_ciphers, 5);
    ADD_ALL_TESTS(test_early_data_not_expected, 3);
# ifndef OPENSSL_NO_TLS1_2
    ADD_ALL_TESTS(test_early_data_tls1_2, 3);
# endif
#endif
#ifndef OSSL_NO_USABLE_TLS1_3
    ADD_ALL_TESTS(test_set_ciphersuite, 10);
    ADD_TEST(test_ciphersuite_change);
    ADD_ALL_TESTS(test_tls13_ciphersuite, 4);
# ifdef OPENSSL_NO_PSK
    ADD_ALL_TESTS(test_tls13_psk, 1);
# else
    ADD_ALL_TESTS(test_tls13_psk, 4);
# endif  /* OPENSSL_NO_PSK */
# ifndef OPENSSL_NO_TLS1_2
    /* Test with both TLSv1.3 and 1.2 versions */
    ADD_ALL_TESTS(test_key_exchange, 14);
#  if !defined(OPENSSL_NO_EC) && !defined(OPENSSL_NO_DH)
    ADD_ALL_TESTS(test_negotiated_group,
                  4 * (OSSL_NELEM(ecdhe_kexch_groups)
                       + OSSL_NELEM(ffdhe_kexch_groups)));
#  endif
# else
    /* Test with only TLSv1.3 versions */
    ADD_ALL_TESTS(test_key_exchange, 12);
# endif
    ADD_ALL_TESTS(test_custom_exts, 6);
    ADD_TEST(test_stateless);
    ADD_TEST(test_pha_key_update);
#else
    ADD_ALL_TESTS(test_custom_exts, 3);
#endif
    ADD_ALL_TESTS(test_export_key_mat, 6);
#ifndef OSSL_NO_USABLE_TLS1_3
    ADD_ALL_TESTS(test_export_key_mat_early, 3);
    ADD_TEST(test_key_update);
    ADD_ALL_TESTS(test_key_update_peer_in_write, 2);
    ADD_ALL_TESTS(test_key_update_peer_in_read, 2);
    ADD_ALL_TESTS(test_key_update_local_in_write, 2);
    ADD_ALL_TESTS(test_key_update_local_in_read, 2);
#endif
    ADD_ALL_TESTS(test_ssl_clear, 2);
    ADD_ALL_TESTS(test_max_fragment_len_ext, OSSL_NELEM(max_fragment_len_test));
#if !defined(OPENSSL_NO_SRP) && !defined(OPENSSL_NO_TLS1_2)
    ADD_ALL_TESTS(test_srp, 6);
#endif
    ADD_ALL_TESTS(test_info_callback, 6);
    ADD_ALL_TESTS(test_ssl_pending, 2);
    ADD_ALL_TESTS(test_ssl_get_shared_ciphers, OSSL_NELEM(shared_ciphers_data));
    ADD_ALL_TESTS(test_ticket_callbacks, 20);
    ADD_ALL_TESTS(test_shutdown, 7);
    ADD_ALL_TESTS(test_incorrect_shutdown, 2);
    ADD_ALL_TESTS(test_cert_cb, 6);
    ADD_ALL_TESTS(test_client_cert_cb, 2);
    ADD_ALL_TESTS(test_ca_names, 3);
#ifndef OPENSSL_NO_TLS1_2
    ADD_ALL_TESTS(test_multiblock_write, OSSL_NELEM(multiblock_cipherlist_data));
#endif
    ADD_ALL_TESTS(test_servername, 10);
#if !defined(OPENSSL_NO_EC) \
    && (!defined(OSSL_NO_USABLE_TLS1_3) || !defined(OPENSSL_NO_TLS1_2))
    ADD_ALL_TESTS(test_sigalgs_available, 6);
#endif
#ifndef OPENSSL_NO_TLS1_3
    ADD_ALL_TESTS(test_pluggable_group, 2);
#endif
#ifndef OPENSSL_NO_TLS1_2
    ADD_TEST(test_ssl_dup);
# ifndef OPENSSL_NO_DH
    ADD_ALL_TESTS(test_set_tmp_dh, 11);
    ADD_ALL_TESTS(test_dh_auto, 7);
# endif
#endif
#ifndef OSSL_NO_USABLE_TLS1_3
    ADD_TEST(test_sni_tls13);
    ADD_ALL_TESTS(test_ticket_lifetime, 2);
#endif
    ADD_TEST(test_inherit_verify_param);
    ADD_TEST(test_set_alpn);
    ADD_TEST(test_set_verify_cert_store_ssl_ctx);
    ADD_TEST(test_set_verify_cert_store_ssl);
    ADD_ALL_TESTS(test_session_timeout, 1);
#if !defined(OSSL_NO_USABLE_TLS1_3) || !defined(OPENSSL_NO_TLS1_2)
    ADD_ALL_TESTS(test_session_cache_overflow, 4);
#endif
    ADD_TEST(test_load_dhfile);
#if !defined(OPENSSL_NO_TLS1_2) && !defined(OSSL_NO_USABLE_TLS1_3)
    ADD_ALL_TESTS(test_serverinfo_custom, 4);
#endif
#if !defined(OPENSSL_NO_TLS1_2) && !defined(OPENSSL_NO_DYNAMIC_ENGINE)
    ADD_ALL_TESTS(test_pipelining, 7);
#endif
    ADD_ALL_TESTS(test_handshake_retry, 16);
    ADD_ALL_TESTS(test_multi_resume, 5);
    ADD_ALL_TESTS(test_select_next_proto, OSSL_NELEM(next_proto_tests));
#if !defined(OPENSSL_NO_TLS1_2) && !defined(OPENSSL_NO_NEXTPROTONEG)
    ADD_ALL_TESTS(test_npn, 5);
#endif
    ADD_ALL_TESTS(test_alpn, 4);
#ifndef OPENSSL_NO_QUIC
    ADD_ALL_TESTS(test_quic_api, 9);
# ifndef OSSL_NO_USABLE_TLS1_3
    ADD_ALL_TESTS(test_quic_early_data, 3);
# endif
#endif
    return 1;

 err:
    OPENSSL_free(cert);
    OPENSSL_free(privkey);
    OPENSSL_free(cert2);
    OPENSSL_free(privkey2);
    return 0;
}

void cleanup_tests(void)
{
# if !defined(OPENSSL_NO_TLS1_2) && !defined(OPENSSL_NO_DH)
    EVP_PKEY_free(tmp_dh_params);
#endif
    OPENSSL_free(cert);
    OPENSSL_free(privkey);
    OPENSSL_free(cert2);
    OPENSSL_free(privkey2);
    OPENSSL_free(cert1024);
    OPENSSL_free(privkey1024);
    OPENSSL_free(cert3072);
    OPENSSL_free(privkey3072);
    OPENSSL_free(cert4096);
    OPENSSL_free(privkey4096);
    OPENSSL_free(cert8192);
    OPENSSL_free(privkey8192);
    bio_s_mempacket_test_free();
    bio_s_always_retry_free();
    OSSL_PROVIDER_unload(defctxnull);
    OSSL_LIB_CTX_free(libctx);
}
                                                     node-23.7.0/deps/openssl/openssl/test/sslbuffertest.c                                               0000664 0000000 0000000 00000025204 14746647661 0022677 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright 2016-2024 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * https://www.openssl.org/source/license.html
 * or in the file LICENSE in the source distribution.
 */

/*
 * We need access to the deprecated low level Engine APIs for legacy purposes
 * when the deprecated calls are not hidden
 */
#ifndef OPENSSL_NO_DEPRECATED_3_0
# define OPENSSL_SUPPRESS_DEPRECATED
#endif

#include <string.h>
#include <openssl/ssl.h>
#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/engine.h>

#include "internal/packet.h"

#include "helpers/ssltestlib.h"
#include "testutil.h"

struct async_ctrs {
    unsigned int rctr;
    unsigned int wctr;
};

static SSL_CTX *serverctx = NULL;
static SSL_CTX *clientctx = NULL;

#define MAX_ATTEMPTS    100


/*
 * There are 9 passes in the tests
 * 0 = control test
 * tests during writes
 * 1 = free buffers
 * 2 = + allocate buffers after free
 * 3 = + allocate buffers again
 * 4 = + free buffers after allocation
 * tests during reads
 * 5 = + free buffers
 * 6 = + free buffers again
 * 7 = + allocate buffers after free
 * 8 = + free buffers after allocation
 */
static int test_func(int test)
{
    int result = 0;
    SSL *serverssl = NULL, *clientssl = NULL;
    int ret;
    size_t i, j;
    const char testdata[] = "Test data";
    char buf[sizeof(testdata)];

    if (!TEST_true(create_ssl_objects(serverctx, clientctx, &serverssl, &clientssl,
                                      NULL, NULL))) {
        TEST_error("Test %d failed: Create SSL objects failed\n", test);
        goto end;
    }

    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE))) {
        TEST_error("Test %d failed: Create SSL connection failed\n", test);
        goto end;
    }

    /*
     * Send and receive some test data. Do the whole thing twice to ensure
     * we hit at least one async event in both reading and writing
     */
    for (j = 0; j < 2; j++) {
        int len;

        /*

         * Write some test data. It should never take more than 2 attempts
         * (the first one might be a retryable fail).
         */
        for (ret = -1, i = 0, len = 0; len != sizeof(testdata) && i < 2;
             i++) {
            /* test == 0 mean to free/allocate = control */
            if (test >= 1 && !TEST_true(SSL_free_buffers(clientssl)))
                goto end;
            if (test >= 2 && !TEST_true(SSL_alloc_buffers(clientssl)))
                goto end;
            /* allocate a second time */
            if (test >= 3 && !TEST_true(SSL_alloc_buffers(clientssl)))
                goto end;
            if (test >= 4 && !TEST_true(SSL_free_buffers(clientssl)))
                goto end;

            ret = SSL_write(clientssl, testdata + len,
                            sizeof(testdata) - len);
            if (ret > 0) {
                len += ret;
            } else {
                int ssl_error = SSL_get_error(clientssl, ret);

                if (ssl_error == SSL_ERROR_SYSCALL ||
                    ssl_error == SSL_ERROR_SSL) {
                    TEST_error("Test %d failed: Failed to write app data\n", test);
                    goto end;
                }
            }
        }
        if (!TEST_size_t_eq(len, sizeof(testdata)))
            goto end;
        /*
         * Now read the test data. It may take more attempts here because
         * it could fail once for each byte read, including all overhead
         * bytes from the record header/padding etc.
         */
        for (ret = -1, i = 0, len = 0; len != sizeof(testdata) &&
                 i < MAX_ATTEMPTS; i++)
        {
            if (test >= 5 && !TEST_true(SSL_free_buffers(serverssl)))
                goto end;
            /* free a second time */
            if (test >= 6 && !TEST_true(SSL_free_buffers(serverssl)))
                goto end;
            if (test >= 7 && !TEST_true(SSL_alloc_buffers(serverssl)))
                goto end;
            if (test >= 8 && !TEST_true(SSL_free_buffers(serverssl)))
                goto end;

            ret = SSL_read(serverssl, buf + len, sizeof(buf) - len);
            if (ret > 0) {
                len += ret;
            } else {
                int ssl_error = SSL_get_error(serverssl, ret);

                if (ssl_error == SSL_ERROR_SYSCALL ||
                    ssl_error == SSL_ERROR_SSL) {
                    TEST_error("Test %d failed: Failed to read app data\n", test);
                    goto end;
                }
            }
        }
        if (!TEST_mem_eq(buf, len, testdata, sizeof(testdata)))
            goto end;
    }

    result = 1;
 end:
    if (!result)
        ERR_print_errors_fp(stderr);

    SSL_free(clientssl);
    SSL_free(serverssl);

    return result;
}

/*
 * Test that attempting to free the buffers at points where they cannot be freed
 * works as expected
 * Test 0: Attempt to free buffers after a full record has been processed, but
 *         the application has only performed a partial read
 * Test 1: Attempt to free buffers after only a partial record header has been
 *         received
 * Test 2: Attempt to free buffers after a full record header but no record body
 * Test 3: Attempt to free buffers after a full record hedaer and partial record
 *         body
 * Test 4-7: We repeat tests 0-3 but including data from a second pipelined
 *           record
 */
static int test_free_buffers(int test)
{
    int result = 0;
    SSL *serverssl = NULL, *clientssl = NULL;
    const char testdata[] = "Test data";
    char buf[120];
    size_t written, readbytes;
    int i, pipeline = test > 3;
    ENGINE *e = NULL;

    if (pipeline) {
        e = load_dasync();
        if (e == NULL)
            goto end;
        test -= 4;
    }

    if (!TEST_true(create_ssl_objects(serverctx, clientctx, &serverssl,
                                      &clientssl, NULL, NULL)))
        goto end;

    if (pipeline) {
        if (!TEST_true(SSL_set_cipher_list(serverssl, "AES128-SHA"))
                || !TEST_true(SSL_set_max_proto_version(serverssl,
                                                        TLS1_2_VERSION))
                || !TEST_true(SSL_set_max_pipelines(serverssl, 2)))
            goto end;
    }

    if (!TEST_true(create_ssl_connection(serverssl, clientssl,
                                         SSL_ERROR_NONE)))
        goto end;

    /*
     * For the non-pipeline case we write one record. For pipelining we write
     * two records.
     */
    for (i = 0; i <= pipeline; i++) {
        if (!TEST_true(SSL_write_ex(clientssl, testdata, strlen(testdata),
                                    &written)))
            goto end;
    }

    if (test == 0) {
        size_t readlen = 1;

        /*
         * Deliberately only read the first byte - so the remaining bytes are
         * still buffered. In the pipelining case we read as far as the first
         * byte from the second record.
         */
        if (pipeline)
            readlen += strlen(testdata);

        if (!TEST_true(SSL_read_ex(serverssl, buf, readlen, &readbytes))
                || !TEST_size_t_eq(readlen, readbytes))
            goto end;
    } else {
        BIO *tmp;
        size_t partial_len;

        /* Remove all the data that is pending for read by the server */
        tmp = SSL_get_rbio(serverssl);
        if (!TEST_true(BIO_read_ex(tmp, buf, sizeof(buf), &readbytes))
                || !TEST_size_t_lt(readbytes, sizeof(buf))
                || !TEST_size_t_gt(readbytes, SSL3_RT_HEADER_LENGTH))
            goto end;

        switch(test) {
        case 1:
            partial_len = SSL3_RT_HEADER_LENGTH - 1;
            break;
        case 2:
            partial_len = SSL3_RT_HEADER_LENGTH;
            break;
        case 3:
            partial_len = readbytes - 1;
            break;
        default:
            TEST_error("Invalid test index");
            goto end;
        }

        if (pipeline) {
            /* We happen to know the first record is 57 bytes long */
            const size_t first_rec_len = 57;

            if (test != 3)
                partial_len += first_rec_len;

            /*
             * Sanity check. If we got the record len right then this should
             * never fail.
             */
            if (!TEST_int_eq(buf[first_rec_len], SSL3_RT_APPLICATION_DATA))
                goto end;
        }

        /*
         * Put back just the partial record (plus the whole initial record in
         * the pipelining case)
         */
        if (!TEST_true(BIO_write_ex(tmp, buf, partial_len, &written)))
            goto end;

        if (pipeline) {
            /*
             * Attempt a read. This should pass but only return data from the
             * first record. Only a partial record is available for the second
             * record.
             */
            if (!TEST_true(SSL_read_ex(serverssl, buf, sizeof(buf),
                                        &readbytes))
                    || !TEST_size_t_eq(readbytes, strlen(testdata)))
                goto end;
        } else {
            /*
            * Attempt a read. This should fail because only a partial record is
            * available.
            */
            if (!TEST_false(SSL_read_ex(serverssl, buf, sizeof(buf),
                                        &readbytes)))
                goto end;
        }
    }

    /*
     * Attempting to free the buffers at this point should fail because they are
     * still in use
     */
    if (!TEST_false(SSL_free_buffers(serverssl)))
        goto end;

    result = 1;
 end:
    SSL_free(clientssl);
    SSL_free(serverssl);
#ifndef OPENSSL_NO_DYNAMIC_ENGINE
    if (e != NULL) {
        ENGINE_unregister_ciphers(e);
        ENGINE_finish(e);
        ENGINE_free(e);
    }
#endif
    return result;
}

OPT_TEST_DECLARE_USAGE("certfile privkeyfile\n")

int setup_tests(void)
{
    char *cert, *pkey;

    if (!test_skip_common_options()) {
        TEST_error("Error parsing test options\n");
        return 0;
    }

    if (!TEST_ptr(cert = test_get_argument(0))
            || !TEST_ptr(pkey = test_get_argument(1)))
        return 0;

    if (!create_ssl_ctx_pair(NULL, TLS_server_method(), TLS_client_method(),
                             TLS1_VERSION, 0,
                             &serverctx, &clientctx, cert, pkey)) {
        TEST_error("Failed to create SSL_CTX pair\n");
        return 0;
    }

    ADD_ALL_TESTS(test_func, 9);
#if !defined(OPENSSL_NO_TLS1_2) && !defined(OPENSSL_NO_DYNAMIC_ENGINE)
    ADD_ALL_TESTS(test_free_buffers, 8);
#else
    ADD_ALL_TESTS(test_free_buffers, 4);
#endif
    return 1;
}

void cleanup_tests(void)
{
    SSL_CTX_free(clientctx);
    SSL_CTX_free(serverctx);
}
                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/openssl/openssl/test/sslcorrupttest.c                                              0000664 0000000 0000000 00000016532 14746647661 0023130 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright 2016-2022 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

#include <string.h>
#include "helpers/ssltestlib.h"
#include "testutil.h"

static int docorrupt = 0;

static void copy_flags(BIO *bio)
{
    int flags;
    BIO *next = BIO_next(bio);

    flags = BIO_test_flags(next, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);
    BIO_clear_flags(bio, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);
    BIO_set_flags(bio, flags);
}

static int tls_corrupt_read(BIO *bio, char *out, int outl)
{
    int ret;
    BIO *next = BIO_next(bio);

    ret = BIO_read(next, out, outl);
    copy_flags(bio);

    return ret;
}

static int tls_corrupt_write(BIO *bio, const char *in, int inl)
{
    int ret;
    BIO *next = BIO_next(bio);
    char *copy;

    if (docorrupt) {
        if (!TEST_ptr(copy = OPENSSL_memdup(in, inl)))
            return 0;
        /* corrupt last bit of application data */
        copy[inl-1] ^= 1;
        ret = BIO_write(next, copy, inl);
        OPENSSL_free(copy);
    } else {
        ret = BIO_write(next, in, inl);
    }
    copy_flags(bio);

    return ret;
}

static long tls_corrupt_ctrl(BIO *bio, int cmd, long num, void *ptr)
{
    long ret;
    BIO *next = BIO_next(bio);

    if (next == NULL)
        return 0;

    switch (cmd) {
    case BIO_CTRL_DUP:
        ret = 0L;
        break;
    default:
        ret = BIO_ctrl(next, cmd, num, ptr);
        break;
    }
    return ret;
}

static int tls_corrupt_gets(BIO *bio, char *buf, int size)
{
    /* We don't support this - not needed anyway */
    return -1;
}

static int tls_corrupt_puts(BIO *bio, const char *str)
{
    /* We don't support this - not needed anyway */
    return -1;
}

static int tls_corrupt_new(BIO *bio)
{
    BIO_set_init(bio, 1);

    return 1;
}

static int tls_corrupt_free(BIO *bio)
{
    BIO_set_init(bio, 0);

    return 1;
}

#define BIO_TYPE_CUSTOM_FILTER  (0x80 | BIO_TYPE_FILTER)

static BIO_METHOD *method_tls_corrupt = NULL;

/* Note: Not thread safe! */
static const BIO_METHOD *bio_f_tls_corrupt_filter(void)
{
    if (method_tls_corrupt == NULL) {
        method_tls_corrupt = BIO_meth_new(BIO_TYPE_CUSTOM_FILTER,
                                          "TLS corrupt filter");
        if (   method_tls_corrupt == NULL
            || !BIO_meth_set_write(method_tls_corrupt, tls_corrupt_write)
            || !BIO_meth_set_read(method_tls_corrupt, tls_corrupt_read)
            || !BIO_meth_set_puts(method_tls_corrupt, tls_corrupt_puts)
            || !BIO_meth_set_gets(method_tls_corrupt, tls_corrupt_gets)
            || !BIO_meth_set_ctrl(method_tls_corrupt, tls_corrupt_ctrl)
            || !BIO_meth_set_create(method_tls_corrupt, tls_corrupt_new)
            || !BIO_meth_set_destroy(method_tls_corrupt, tls_corrupt_free))
            return NULL;
    }
    return method_tls_corrupt;
}

static void bio_f_tls_corrupt_filter_free(void)
{
    BIO_meth_free(method_tls_corrupt);
}

/*
 * The test is supposed to be executed with RSA key, customarily
 * with apps/server.pem used even in other tests. For this reason
 * |cipher_list| is initialized with RSA ciphers' names. This
 * naturally means that if test is to be re-purposed for other
 * type of key, then NID_auth_* filter below would need adjustment.
 */
static const char **cipher_list = NULL;

static int setup_cipher_list(void)
{
    SSL_CTX *ctx = NULL;
    SSL *ssl = NULL;
    STACK_OF(SSL_CIPHER) *sk_ciphers = NULL;
    int i, j, numciphers = 0;

    if (!TEST_ptr(ctx = SSL_CTX_new(TLS_server_method()))
            || !TEST_ptr(ssl = SSL_new(ctx))
            || !TEST_ptr(sk_ciphers = SSL_get1_supported_ciphers(ssl)))
        goto err;

    /*
     * The |cipher_list| will be filled only with names of RSA ciphers,
     * so that some of the allocated space will be wasted, but the loss
     * is deemed acceptable...
     */
    cipher_list = OPENSSL_malloc(sk_SSL_CIPHER_num(sk_ciphers) *
                                 sizeof(cipher_list[0]));
    if (!TEST_ptr(cipher_list))
        goto err;

    for (j = 0, i = 0; i < sk_SSL_CIPHER_num(sk_ciphers); i++) {
        const SSL_CIPHER *cipher = sk_SSL_CIPHER_value(sk_ciphers, i);

        if (SSL_CIPHER_get_auth_nid(cipher) == NID_auth_rsa)
            cipher_list[j++] = SSL_CIPHER_get_name(cipher);
    }
    if (TEST_int_ne(j, 0))
        numciphers = j;

err:
    sk_SSL_CIPHER_free(sk_ciphers);
    SSL_free(ssl);
    SSL_CTX_free(ctx);

    return numciphers;
}

static char *cert = NULL;
static char *privkey = NULL;

static int test_ssl_corrupt(int testidx)
{
    static unsigned char junk[16000] = { 0 };
    SSL_CTX *sctx = NULL, *cctx = NULL;
    SSL *server = NULL, *client = NULL;
    BIO *c_to_s_fbio;
    int testresult = 0;
    STACK_OF(SSL_CIPHER) *ciphers;
    const SSL_CIPHER *currcipher;
    int err;

    docorrupt = 0;

    TEST_info("Starting #%d, %s", testidx, cipher_list[testidx]);

    if (!TEST_true(create_ssl_ctx_pair(NULL, TLS_server_method(),
                                       TLS_client_method(),
                                       TLS1_VERSION, 0,
                                       &sctx, &cctx, cert, privkey)))
        return 0;

    if (!TEST_true(SSL_CTX_set_dh_auto(sctx, 1))
            || !TEST_true(SSL_CTX_set_cipher_list(cctx, cipher_list[testidx]))
            || !TEST_true(SSL_CTX_set_ciphersuites(cctx, ""))
            || !TEST_ptr(ciphers = SSL_CTX_get_ciphers(cctx))
            || !TEST_int_eq(sk_SSL_CIPHER_num(ciphers), 1)
            || !TEST_ptr(currcipher = sk_SSL_CIPHER_value(ciphers, 0)))
        goto end;

    /*
     * No ciphers we are using are TLSv1.3 compatible so we should not attempt
     * to negotiate TLSv1.3
     */
    if (!TEST_true(SSL_CTX_set_max_proto_version(cctx, TLS1_2_VERSION)))
        goto end;

    if (!TEST_ptr(c_to_s_fbio = BIO_new(bio_f_tls_corrupt_filter())))
        goto end;

    /* BIO is freed by create_ssl_connection on error */
    if (!TEST_true(create_ssl_objects(sctx, cctx, &server, &client, NULL,
                                      c_to_s_fbio)))
        goto end;

    if (!TEST_true(create_ssl_connection(server, client, SSL_ERROR_NONE)))
        goto end;

    docorrupt = 1;

    if (!TEST_int_ge(SSL_write(client, junk, sizeof(junk)), 0))
        goto end;

    if (!TEST_int_lt(SSL_read(server, junk, sizeof(junk)), 0))
        goto end;

    do {
        err = ERR_get_error();

        if (err == 0) {
            TEST_error("Decryption failed or bad record MAC not seen");
            goto end;
        }
    } while (ERR_GET_REASON(err) != SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);

    testresult = 1;
 end:
    SSL_free(server);
    SSL_free(client);
    SSL_CTX_free(sctx);
    SSL_CTX_free(cctx);
    return testresult;
}

OPT_TEST_DECLARE_USAGE("certfile privkeyfile\n")

int setup_tests(void)
{
    int n;

    if (!test_skip_common_options()) {
        TEST_error("Error parsing test options\n");
        return 0;
    }

    if (!TEST_ptr(cert = test_get_argument(0))
            || !TEST_ptr(privkey = test_get_argument(1)))
        return 0;

    n = setup_cipher_list();
    if (n > 0)
        ADD_ALL_TESTS(test_ssl_corrupt, n);
    return 1;
}

void cleanup_tests(void)
{
    bio_f_tls_corrupt_filter_free();
    OPENSSL_free(cipher_list);
}
                                                                                                                                                                      node-23.7.0/deps/openssl/openssl/test/stack_test.c                                                  0000664 0000000 0000000 00000022675 14746647661 0022161 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright 2017-2021 The OpenSSL Project Authors. All Rights Reserved.
 * Copyright (c) 2017, Oracle and/or its affiliates.  All rights reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

#include <stdio.h>
#include <string.h>

#include <openssl/opensslconf.h>
#include <openssl/safestack.h>
#include <openssl/err.h>
#include <openssl/crypto.h>

#include "internal/nelem.h"
#include "testutil.h"

/* The macros below generate unused functions which error out one of the clang
 * builds.  We disable this check here.
 */
#ifdef __clang__
#pragma clang diagnostic ignored "-Wunused-function"
#endif

typedef struct {
    int n;
    char c;
} SS;

typedef union {
    int n;
    char c;
} SU;

DEFINE_SPECIAL_STACK_OF(sint, int)
DEFINE_SPECIAL_STACK_OF_CONST(uchar, unsigned char)
DEFINE_STACK_OF(SS)
DEFINE_STACK_OF_CONST(SU)

static int int_compare(const int *const *a, const int *const *b)
{
    if (**a < **b)
        return -1;
    if (**a > **b)
        return 1;
    return 0;
}

static int test_int_stack(int reserve)
{
    static int v[] = { 1, 2, -4, 16, 999, 1, -173, 1, 9 };
    static int notpresent = -1;
    const int n = OSSL_NELEM(v);
    static struct {
        int value;
        int unsorted;
        int sorted;
        int ex;
    } finds[] = {
        { 2,    1,  5,  5   },
        { 9,    7,  6,  6   },
        { -173, 5,  0,  0   },
        { 999,  3,  8,  8   },
        { 0,   -1, -1,  1   }
    };
    const int n_finds = OSSL_NELEM(finds);
    static struct {
        int value;
        int ex;
    } exfinds[] = {
        { 3,    5   },
        { 1000, 8   },
        { 20,   8   },
        { -999, 0   },
        { -5,   0   },
        { 8,    5   }
    };
    const int n_exfinds = OSSL_NELEM(exfinds);
    STACK_OF(sint) *s = sk_sint_new_null();
    int i;
    int testresult = 0;

    if (!TEST_ptr(s)
        || (reserve > 0 && !TEST_true(sk_sint_reserve(s, 5 * reserve))))
        goto end;

    /* Check push and num */
    for (i = 0; i < n; i++) {
        if (!TEST_int_eq(sk_sint_num(s), i)) {
            TEST_info("int stack size %d", i);
            goto end;
        }
        sk_sint_push(s, v + i);
    }
    if (!TEST_int_eq(sk_sint_num(s), n))
        goto end;

    /* check the values */
    for (i = 0; i < n; i++)
        if (!TEST_ptr_eq(sk_sint_value(s, i), v + i)) {
            TEST_info("int value %d", i);
            goto end;
        }

    /* find unsorted -- the pointers are compared */
    for (i = 0; i < n_finds; i++) {
        int *val = (finds[i].unsorted == -1) ? &notpresent
                                             : v + finds[i].unsorted;

        if (!TEST_int_eq(sk_sint_find(s, val), finds[i].unsorted)) {
            TEST_info("int unsorted find %d", i);
            goto end;
        }
    }

    /* find_ex unsorted */
    for (i = 0; i < n_finds; i++) {
        int *val = (finds[i].unsorted == -1) ? &notpresent
                                             : v + finds[i].unsorted;

        if (!TEST_int_eq(sk_sint_find_ex(s, val), finds[i].unsorted)) {
            TEST_info("int unsorted find_ex %d", i);
            goto end;
        }
    }

    /* sorting */
    if (!TEST_false(sk_sint_is_sorted(s)))
        goto end;
    (void)sk_sint_set_cmp_func(s, &int_compare);
    sk_sint_sort(s);
    if (!TEST_true(sk_sint_is_sorted(s)))
        goto end;

    /* find sorted -- the value is matched so we don't need to locate it */
    for (i = 0; i < n_finds; i++)
        if (!TEST_int_eq(sk_sint_find(s, &finds[i].value), finds[i].sorted)) {
            TEST_info("int sorted find %d", i);
            goto end;
        }

    /* find_ex sorted */
    for (i = 0; i < n_finds; i++)
        if (!TEST_int_eq(sk_sint_find_ex(s, &finds[i].value), finds[i].ex)) {
            TEST_info("int sorted find_ex present %d", i);
            goto end;
        }
    for (i = 0; i < n_exfinds; i++)
        if (!TEST_int_eq(sk_sint_find_ex(s, &exfinds[i].value), exfinds[i].ex)){
            TEST_info("int sorted find_ex absent %d", i);
            goto end;
        }

    /* shift */
    if (!TEST_ptr_eq(sk_sint_shift(s), v + 6))
        goto end;

    testresult = 1;
end:
    sk_sint_free(s);
    return testresult;
}

static int uchar_compare(const unsigned char *const *a,
                         const unsigned char *const *b)
{
    return **a - (signed int)**b;
}

static int test_uchar_stack(int reserve)
{
    static const unsigned char v[] = { 1, 3, 7, 5, 255, 0 };
    const int n = OSSL_NELEM(v);
    STACK_OF(uchar) *s = sk_uchar_new(&uchar_compare), *r = NULL;
    int i;
    int testresult = 0;

    if (!TEST_ptr(s)
        || (reserve > 0 && !TEST_true(sk_uchar_reserve(s, 5 * reserve))))
        goto end;

    /* unshift and num */
    for (i = 0; i < n; i++) {
        if (!TEST_int_eq(sk_uchar_num(s), i)) {
            TEST_info("uchar stack size %d", i);
            goto end;
        }
        sk_uchar_unshift(s, v + i);
    }
    if (!TEST_int_eq(sk_uchar_num(s), n))
        goto end;

    /* dup */
    r = sk_uchar_dup(NULL);
    if (sk_uchar_num(r) != 0)
        goto end;
    sk_uchar_free(r);
    r = sk_uchar_dup(s);
    if (!TEST_int_eq(sk_uchar_num(r), n))
        goto end;
    sk_uchar_sort(r);

    /* pop */
    for (i = 0; i < n; i++)
        if (!TEST_ptr_eq(sk_uchar_pop(s), v + i)) {
            TEST_info("uchar pop %d", i);
            goto end;
        }

    /* free -- we rely on the debug malloc to detect leakage here */
    sk_uchar_free(s);
    s = NULL;

    /* dup again */
    if (!TEST_int_eq(sk_uchar_num(r), n))
        goto end;

    /* zero */
    sk_uchar_zero(r);
    if (!TEST_int_eq(sk_uchar_num(r), 0))
        goto end;

    /* insert */
    sk_uchar_insert(r, v, 0);
    sk_uchar_insert(r, v + 2, -1);
    sk_uchar_insert(r, v + 1, 1);
    for (i = 0; i < 3; i++)
        if (!TEST_ptr_eq(sk_uchar_value(r, i), v + i)) {
            TEST_info("uchar insert %d", i);
            goto end;
        }

    /* delete */
    if (!TEST_ptr_null(sk_uchar_delete(r, 12)))
        goto end;
    if (!TEST_ptr_eq(sk_uchar_delete(r, 1), v + 1))
        goto end;

    /* set */
    (void)sk_uchar_set(r, 1, v + 1);
    for (i = 0; i < 2; i++)
        if (!TEST_ptr_eq(sk_uchar_value(r, i), v + i)) {
            TEST_info("uchar set %d", i);
            goto end;
        }

    testresult = 1;
end:
    sk_uchar_free(r);
    sk_uchar_free(s);
    return testresult;
}

static SS *SS_copy(const SS *p)
{
    SS *q = OPENSSL_malloc(sizeof(*q));

    if (q != NULL)
        memcpy(q, p, sizeof(*q));
    return q;
}

static void SS_free(SS *p) {
    OPENSSL_free(p);
}

static int test_SS_stack(void)
{
    STACK_OF(SS) *s = sk_SS_new_null();
    STACK_OF(SS) *r = NULL;
    SS *v[10], *p;
    const int n = OSSL_NELEM(v);
    int i;
    int testresult = 0;

    /* allocate and push */
    for (i = 0; i < n; i++) {
        v[i] = OPENSSL_malloc(sizeof(*v[i]));

        if (!TEST_ptr(v[i]))
            goto end;
        v[i]->n = i;
        v[i]->c = 'A' + i;
        if (!TEST_int_eq(sk_SS_num(s), i)) {
            TEST_info("SS stack size %d", i);
            goto end;
        }
        sk_SS_push(s, v[i]);
    }
    if (!TEST_int_eq(sk_SS_num(s), n))
        goto end;

    /* deepcopy */
    r = sk_SS_deep_copy(NULL, &SS_copy, &SS_free);
    if (sk_SS_num(r) != 0)
        goto end;
    sk_SS_free(r);
    r = sk_SS_deep_copy(s, &SS_copy, &SS_free);
    if (!TEST_ptr(r))
        goto end;
    for (i = 0; i < n; i++) {
        p = sk_SS_value(r, i);
        if (!TEST_ptr_ne(p, v[i])) {
            TEST_info("SS deepcopy non-copy %d", i);
            goto end;
        }
        if (!TEST_int_eq(p->n, v[i]->n)) {
            TEST_info("test SS deepcopy int %d", i);
            goto end;
        }
        if (!TEST_char_eq(p->c, v[i]->c)) {
            TEST_info("SS deepcopy char %d", i);
            goto end;
        }
    }

    /* pop_free - we rely on the malloc debug to catch the leak */
    sk_SS_pop_free(r, &SS_free);
    r = NULL;

    /* delete_ptr */
    p = sk_SS_delete_ptr(s, v[3]);
    if (!TEST_ptr(p))
        goto end;
    SS_free(p);
    if (!TEST_int_eq(sk_SS_num(s), n - 1))
        goto end;
    for (i = 0; i < n-1; i++)
        if (!TEST_ptr_eq(sk_SS_value(s, i), v[i<3 ? i : 1+i])) {
            TEST_info("SS delete ptr item %d", i);
            goto end;
        }

    testresult = 1;
end:
    sk_SS_pop_free(r, &SS_free);
    sk_SS_pop_free(s, &SS_free);
    return testresult;
}

static int test_SU_stack(void)
{
    STACK_OF(SU) *s = sk_SU_new_null();
    SU v[10];
    const int n = OSSL_NELEM(v);
    int i;
    int testresult = 0;

    /* allocate and push */
    for (i = 0; i < n; i++) {
        if ((i & 1) == 0)
            v[i].n = i;
        else
            v[i].c = 'A' + i;
        if (!TEST_int_eq(sk_SU_num(s), i)) {
            TEST_info("SU stack size %d", i);
            goto end;
        }
        sk_SU_push(s, v + i);
    }
    if (!TEST_int_eq(sk_SU_num(s), n))
        goto end;

    /* check the pointers are correct */
    for (i = 0; i < n; i++)
        if (!TEST_ptr_eq(sk_SU_value(s, i),  v + i)) {
            TEST_info("SU pointer check %d", i);
            goto end;
        }

    testresult = 1;
end:
    sk_SU_free(s);
    return testresult;
}

int setup_tests(void)
{
    ADD_ALL_TESTS(test_int_stack, 4);
    ADD_ALL_TESTS(test_uchar_stack, 4);
    ADD_TEST(test_SS_stack);
    ADD_TEST(test_SU_stack);
    return 1;
}
                                                                   node-23.7.0/deps/openssl/openssl/test/sysdefault.cnf                                                0000664 0000000 0000000 00000000670 14746647661 0022513 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Configuration file to test system default SSL configuration

# Comment out the next line to ignore configuration errors
config_diagnostics = 1

openssl_conf = default_conf

[ default_conf ]

ssl_conf = ssl_sect
oid_section = oid_sect

[oid_sect]
new-sig-oid = 1.1.1.1.1.1.1.1.1.1.1.1.1.1

[ssl_sect]

system_default = ssl_default_sect

[ssl_default_sect]
SignatureAlgorithms = RSA+SHA256:nonex
MaxProtocol = TLSv1.2
MinProtocol = TLSv1.2
                                                                        node-23.7.0/deps/openssl/openssl/test/sysdefaulttest.c                                              0000664 0000000 0000000 00000002227 14746647661 0023067 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright 2016-2018 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

#include <stdio.h>
#include <openssl/opensslconf.h>

#include <string.h>
#include <openssl/evp.h>
#include <openssl/ssl.h>
#include <openssl/tls1.h>
#include "testutil.h"

static SSL_CTX *ctx;

static int test_func(void)
{
    if (!TEST_int_eq(SSL_CTX_get_min_proto_version(ctx), TLS1_2_VERSION)
        && !TEST_int_eq(SSL_CTX_get_max_proto_version(ctx), TLS1_2_VERSION)) {
        TEST_info("min/max version setting incorrect");
        return 0;
    }
    return 1;
}

int global_init(void)
{
    if (!OPENSSL_init_ssl(OPENSSL_INIT_ENGINE_ALL_BUILTIN
                          | OPENSSL_INIT_LOAD_CONFIG, NULL))
        return 0;
    return 1;
}

int setup_tests(void)
{
    if (!TEST_ptr(ctx = SSL_CTX_new(TLS_method())))
        return 0;
    ADD_TEST(test_func);
    return 1;
}

void cleanup_tests(void)
{
    SSL_CTX_free(ctx);
}
                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/openssl/openssl/test/test.cnf                                                      0000664 0000000 0000000 00000004404 14746647661 0021306 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        
####################################################################
[ ca ]
default_ca	= CA_default		# The default ca section

####################################################################
[ CA_default ]

dir		= ./demoCA		# Where everything is kept
certs		= $dir/certs		# Where the issued certs are kept
crl_dir		= $dir/crl		# Where the issued crl are kept
database	= $dir/index.txt	# database index file.
new_certs_dir	= $dir/new_certs	# default place for new certs.

certificate	= $dir/CAcert.pem 	# The CA certificate
serial		= $dir/serial 		# The current serial number
crl		= $dir/crl.pem 		# The current CRL
private_key	= $dir/private/CAkey.pem# The private key

default_days	= 365			# how long to certify for
default_crl_days= 30			# how long before next CRL
default_md	= md5			# which md to use.

# A few difference way of specifying how similar the request should look
# For type CA, the listed attributes must be the same, and the optional
# and supplied fields are just that :-)
policy		= policy_match

# For the CA policy
[ policy_match ]
countryName		= match
stateOrProvinceName	= match
organizationName	= match
organizationalUnitName	= optional
commonName		= supplied
emailAddress		= optional

# For the 'anything' policy
# At this point in time, you must list all acceptable 'object'
# types.
[ policy_anything ]
countryName		= optional
stateOrProvinceName	= optional
localityName		= optional
organizationName	= optional
organizationalUnitName	= optional
commonName		= supplied
emailAddress		= optional

####################################################################
[ req ]
distinguished_name	= req_distinguished_name
encrypt_rsa_key		= no

# Make altreq be identical to req
[ altreq ]
distinguished_name	= req_distinguished_name
encrypt_rsa_key		= no

[ req_distinguished_name ]
countryName			= C field
countryName_value		= AU
stateOrProvinceName		= SP field
stateOrProvinceName_value	=
localityName			= L field
localityName_value		= Brisbane
organizationName		= O field
organizationName_value		= CryptSoft Pty Ltd
organizationalUnitName		= OU field
organizationalUnitName_value	= .
commonName			= CN field
commonName_value		= Eric Young
emailAddress			= email field
emailAddress_value		= eay@mincom.oz.au

[ dirname_sec ]
C  = UK
O  = My Organization
OU = My Unit
CN = My Name
                                                                                                                                                                                                                                                            node-23.7.0/deps/openssl/openssl/test/test_asn1_parse.cnf                                           0000664 0000000 0000000 00000000360 14746647661 0023417 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        openssl_conf = openssl_init

# Comment out the next line to ignore configuration errors
config_diagnostics = 1

[openssl_init]
oid_section = oids

[oids]
testoid1 = 1.2.3.4.1
testoid2 = A Very Long OID Name, 1.2.3.4.2
testoid3 = ,1.2.3.4.3
                                                                                                                                                                                                                                                                                node-23.7.0/deps/openssl/openssl/test/test_test.c                                                   0000664 0000000 0000000 00000044342 14746647661 0022026 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright 2017-2022 The OpenSSL Project Authors. All Rights Reserved.
 * Copyright (c) 2017, Oracle and/or its affiliates.  All rights reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

#include <stdio.h>
#include <string.h>

#include <openssl/opensslconf.h>
#include <openssl/err.h>
#include <openssl/crypto.h>
#include <openssl/bn.h>

#include "internal/nelem.h"
#include "testutil.h"

#define TEST(expected, test) test_case((expected), #test, (test))

static int test_case(int expected, const char *test, int result)
{
    if (result != expected) {
        fprintf(stderr, "# FATAL: %s != %d\n", test, expected);
        return 0;
    }
    return 1;
}

static int test_int(void)
{
    if (!TEST(1, TEST_int_eq(1, 1))
        || !TEST(0, TEST_int_eq(1, -1))
        || !TEST(1, TEST_int_ne(1, 2))
        || !TEST(0, TEST_int_ne(3, 3))
        || !TEST(1, TEST_int_lt(4, 9))
        || !TEST(0, TEST_int_lt(9, 4))
        || !TEST(1, TEST_int_le(4, 9))
        || !TEST(1, TEST_int_le(5, 5))
        || !TEST(0, TEST_int_le(9, 4))
        || !TEST(1, TEST_int_gt(8, 5))
        || !TEST(0, TEST_int_gt(5, 8))
        || !TEST(1, TEST_int_ge(8, 5))
        || !TEST(1, TEST_int_ge(6, 6))
        || !TEST(0, TEST_int_ge(5, 8)))
        goto err;
    return 1;

err:
    return 0;
}

static int test_uint(void)
{
    if (!TEST(1, TEST_uint_eq(3u, 3u))
        || !TEST(0, TEST_uint_eq(3u, 5u))
        || !TEST(1, TEST_uint_ne(4u, 2u))
        || !TEST(0, TEST_uint_ne(6u, 6u))
        || !TEST(1, TEST_uint_lt(5u, 9u))
        || !TEST(0, TEST_uint_lt(9u, 5u))
        || !TEST(1, TEST_uint_le(5u, 9u))
        || !TEST(1, TEST_uint_le(7u, 7u))
        || !TEST(0, TEST_uint_le(9u, 5u))
        || !TEST(1, TEST_uint_gt(11u, 1u))
        || !TEST(0, TEST_uint_gt(1u, 11u))
        || !TEST(1, TEST_uint_ge(11u, 1u))
        || !TEST(1, TEST_uint_ge(6u, 6u))
        || !TEST(0, TEST_uint_ge(1u, 11u)))
        goto err;
    return 1;

err:
    return 0;
}

static int test_char(void)
{
    if (!TEST(1, TEST_char_eq('a', 'a'))
        || !TEST(0, TEST_char_eq('a', 'A'))
        || !TEST(1, TEST_char_ne('a', 'c'))
        || !TEST(0, TEST_char_ne('e', 'e'))
        || !TEST(1, TEST_char_lt('i', 'x'))
        || !TEST(0, TEST_char_lt('x', 'i'))
        || !TEST(1, TEST_char_le('i', 'x'))
        || !TEST(1, TEST_char_le('n', 'n'))
        || !TEST(0, TEST_char_le('x', 'i'))
        || !TEST(1, TEST_char_gt('w', 'n'))
        || !TEST(0, TEST_char_gt('n', 'w'))
        || !TEST(1, TEST_char_ge('w', 'n'))
        || !TEST(1, TEST_char_ge('p', 'p'))
        || !TEST(0, TEST_char_ge('n', 'w')))
        goto err;
    return 1;

err:
    return 0;
}

static int test_uchar(void)
{
    if (!TEST(1, TEST_uchar_eq(49, 49))
        || !TEST(0, TEST_uchar_eq(49, 60))
        || !TEST(1, TEST_uchar_ne(50, 2))
        || !TEST(0, TEST_uchar_ne(66, 66))
        || !TEST(1, TEST_uchar_lt(60, 80))
        || !TEST(0, TEST_uchar_lt(80, 60))
        || !TEST(1, TEST_uchar_le(60, 80))
        || !TEST(1, TEST_uchar_le(78, 78))
        || !TEST(0, TEST_uchar_le(80, 60))
        || !TEST(1, TEST_uchar_gt(88, 37))
        || !TEST(0, TEST_uchar_gt(37, 88))
        || !TEST(1, TEST_uchar_ge(88, 37))
        || !TEST(1, TEST_uchar_ge(66, 66))
        || !TEST(0, TEST_uchar_ge(37, 88)))
        goto err;
    return 1;

err:
    return 0;
}

static int test_long(void)
{
    if (!TEST(1, TEST_long_eq(123l, 123l))
        || !TEST(0, TEST_long_eq(123l, -123l))
        || !TEST(1, TEST_long_ne(123l, 500l))
        || !TEST(0, TEST_long_ne(1000l, 1000l))
        || !TEST(1, TEST_long_lt(-8923l, 102934563l))
        || !TEST(0, TEST_long_lt(102934563l, -8923l))
        || !TEST(1, TEST_long_le(-8923l, 102934563l))
        || !TEST(1, TEST_long_le(12345l, 12345l))
        || !TEST(0, TEST_long_le(102934563l, -8923l))
        || !TEST(1, TEST_long_gt(84325677l, 12345l))
        || !TEST(0, TEST_long_gt(12345l, 84325677l))
        || !TEST(1, TEST_long_ge(84325677l, 12345l))
        || !TEST(1, TEST_long_ge(465869l, 465869l))
        || !TEST(0, TEST_long_ge(12345l, 84325677l)))
        goto err;
    return 1;

err:
    return 0;
}

static int test_ulong(void)
{
    if (!TEST(1, TEST_ulong_eq(919ul, 919ul))
        || !TEST(0, TEST_ulong_eq(919ul, 10234ul))
        || !TEST(1, TEST_ulong_ne(8190ul, 66ul))
        || !TEST(0, TEST_ulong_ne(10555ul, 10555ul))
        || !TEST(1, TEST_ulong_lt(10234ul, 1000000ul))
        || !TEST(0, TEST_ulong_lt(1000000ul, 10234ul))
        || !TEST(1, TEST_ulong_le(10234ul, 1000000ul))
        || !TEST(1, TEST_ulong_le(100000ul, 100000ul))
        || !TEST(0, TEST_ulong_le(1000000ul, 10234ul))
        || !TEST(1, TEST_ulong_gt(100000000ul, 22ul))
        || !TEST(0, TEST_ulong_gt(22ul, 100000000ul))
        || !TEST(1, TEST_ulong_ge(100000000ul, 22ul))
        || !TEST(1, TEST_ulong_ge(10555ul, 10555ul))
        || !TEST(0, TEST_ulong_ge(22ul, 100000000ul)))
        goto err;
    return 1;

err:
    return 0;
}

static int test_size_t(void)
{
    if (!TEST(1, TEST_size_t_eq((size_t)10, (size_t)10))
        || !TEST(0, TEST_size_t_eq((size_t)10, (size_t)12))
        || !TEST(1, TEST_size_t_ne((size_t)10, (size_t)12))
        || !TEST(0, TEST_size_t_ne((size_t)24, (size_t)24))
        || !TEST(1, TEST_size_t_lt((size_t)30, (size_t)88))
        || !TEST(0, TEST_size_t_lt((size_t)88, (size_t)30))
        || !TEST(1, TEST_size_t_le((size_t)30, (size_t)88))
        || !TEST(1, TEST_size_t_le((size_t)33, (size_t)33))
        || !TEST(0, TEST_size_t_le((size_t)88, (size_t)30))
        || !TEST(1, TEST_size_t_gt((size_t)52, (size_t)33))
        || !TEST(0, TEST_size_t_gt((size_t)33, (size_t)52))
        || !TEST(1, TEST_size_t_ge((size_t)52, (size_t)33))
        || !TEST(1, TEST_size_t_ge((size_t)38, (size_t)38))
        || !TEST(0, TEST_size_t_ge((size_t)33, (size_t)52)))
        goto err;
    return 1;

err:
    return 0;
}

static int test_time_t(void)
{
    if (!TEST(1, TEST_time_t_eq((time_t)10, (time_t)10))
        || !TEST(0, TEST_time_t_eq((time_t)10, (time_t)12))
        || !TEST(1, TEST_time_t_ne((time_t)10, (time_t)12))
        || !TEST(0, TEST_time_t_ne((time_t)24, (time_t)24))
        || !TEST(1, TEST_time_t_lt((time_t)30, (time_t)88))
        || !TEST(0, TEST_time_t_lt((time_t)88, (time_t)30))
        || !TEST(1, TEST_time_t_le((time_t)30, (time_t)88))
        || !TEST(1, TEST_time_t_le((time_t)33, (time_t)33))
        || !TEST(0, TEST_time_t_le((time_t)88, (time_t)30))
        || !TEST(1, TEST_time_t_gt((time_t)52, (time_t)33))
        || !TEST(0, TEST_time_t_gt((time_t)33, (time_t)52))
        || !TEST(1, TEST_time_t_ge((time_t)52, (time_t)33))
        || !TEST(1, TEST_time_t_ge((time_t)38, (time_t)38))
        || !TEST(0, TEST_time_t_ge((time_t)33, (time_t)52)))
        goto err;
    return 1;

err:
    return 0;
}

static int test_pointer(void)
{
    int x = 0;
    char y = 1;

    if (!TEST(1, TEST_ptr(&y))
        || !TEST(0, TEST_ptr(NULL))
        || !TEST(0, TEST_ptr_null(&y))
        || !TEST(1, TEST_ptr_null(NULL))
        || !TEST(1, TEST_ptr_eq(NULL, NULL))
        || !TEST(0, TEST_ptr_eq(NULL, &y))
        || !TEST(0, TEST_ptr_eq(&y, NULL))
        || !TEST(0, TEST_ptr_eq(&y, &x))
        || !TEST(1, TEST_ptr_eq(&x, &x))
        || !TEST(0, TEST_ptr_ne(NULL, NULL))
        || !TEST(1, TEST_ptr_ne(NULL, &y))
        || !TEST(1, TEST_ptr_ne(&y, NULL))
        || !TEST(1, TEST_ptr_ne(&y, &x))
        || !TEST(0, TEST_ptr_ne(&x, &x)))
        goto err;
    return 1;

err:
    return 0;
}

static int test_bool(void)
{
    if (!TEST(0, TEST_true(0))
        || !TEST(1, TEST_true(1))
        || !TEST(1, TEST_false(0))
        || !TEST(0, TEST_false(1)))
        goto err;
    return 1;

err:
    return 0;
}

static int test_string(void)
{
    static char buf[] = "abc";

    if (!TEST(1, TEST_str_eq(NULL, NULL))
        || !TEST(1, TEST_str_eq("abc", buf))
        || !TEST(0, TEST_str_eq("abc", NULL))
        || !TEST(0, TEST_str_eq("abc", ""))
        || !TEST(0, TEST_str_eq(NULL, buf))
        || !TEST(0, TEST_str_ne(NULL, NULL))
        || !TEST(0, TEST_str_eq("", NULL))
        || !TEST(0, TEST_str_eq(NULL, ""))
        || !TEST(0, TEST_str_ne("", ""))
        || !TEST(0, TEST_str_eq("\1\2\3\4\5", "\1x\3\6\5"))
        || !TEST(0, TEST_str_ne("abc", buf))
        || !TEST(1, TEST_str_ne("abc", NULL))
        || !TEST(1, TEST_str_ne(NULL, buf))
        || !TEST(0, TEST_str_eq("abcdef", "abcdefghijk")))
        goto err;
    return 1;

err:
    return 0;
}

static int test_memory(void)
{
    static char buf[] = "xyz";

    if (!TEST(1, TEST_mem_eq(NULL, 0, NULL, 0))
        || !TEST(1, TEST_mem_eq(NULL, 1, NULL, 2))
        || !TEST(0, TEST_mem_eq(NULL, 0, "xyz", 3))
        || !TEST(0, TEST_mem_eq(NULL, 7, "abc", 3))
        || !TEST(0, TEST_mem_ne(NULL, 0, NULL, 0))
        || !TEST(0, TEST_mem_eq(NULL, 0, "", 0))
        || !TEST(0, TEST_mem_eq("", 0, NULL, 0))
        || !TEST(0, TEST_mem_ne("", 0, "", 0))
        || !TEST(0, TEST_mem_eq("xyz", 3, NULL, 0))
        || !TEST(0, TEST_mem_eq("xyz", 3, buf, sizeof(buf)))
        || !TEST(1, TEST_mem_eq("xyz", 4, buf, sizeof(buf))))
        goto err;
    return 1;

err:
    return 0;
}

static int test_memory_overflow(void)
{
    /* Verify that the memory printing overflows without walking the stack */
    const char *p = "1234567890123456789012345678901234567890123456789012";
    const char *q = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

    return TEST(0, TEST_mem_eq(p, strlen(p), q, strlen(q)));
}

static int test_bignum(void)
{
    BIGNUM *a = NULL, *b = NULL, *c = NULL;
    int r = 0;

    if (!TEST(1, TEST_int_eq(BN_dec2bn(&a, "0"), 1))
        || !TEST(1, TEST_BN_eq_word(a, 0))
        || !TEST(0, TEST_BN_eq_word(a, 30))
        || !TEST(1, TEST_BN_abs_eq_word(a, 0))
        || !TEST(0, TEST_BN_eq_one(a))
        || !TEST(1, TEST_BN_eq_zero(a))
        || !TEST(0, TEST_BN_ne_zero(a))
        || !TEST(1, TEST_BN_le_zero(a))
        || !TEST(0, TEST_BN_lt_zero(a))
        || !TEST(1, TEST_BN_ge_zero(a))
        || !TEST(0, TEST_BN_gt_zero(a))
        || !TEST(1, TEST_BN_even(a))
        || !TEST(0, TEST_BN_odd(a))
        || !TEST(1, TEST_BN_eq(b, c))
        || !TEST(0, TEST_BN_eq(a, b))
        || !TEST(0, TEST_BN_ne(NULL, c))
        || !TEST(1, TEST_int_eq(BN_dec2bn(&b, "1"), 1))
        || !TEST(1, TEST_BN_eq_word(b, 1))
        || !TEST(1, TEST_BN_eq_one(b))
        || !TEST(0, TEST_BN_abs_eq_word(b, 0))
        || !TEST(1, TEST_BN_abs_eq_word(b, 1))
        || !TEST(0, TEST_BN_eq_zero(b))
        || !TEST(1, TEST_BN_ne_zero(b))
        || !TEST(0, TEST_BN_le_zero(b))
        || !TEST(0, TEST_BN_lt_zero(b))
        || !TEST(1, TEST_BN_ge_zero(b))
        || !TEST(1, TEST_BN_gt_zero(b))
        || !TEST(0, TEST_BN_even(b))
        || !TEST(1, TEST_BN_odd(b))
        || !TEST(1, TEST_int_eq(BN_dec2bn(&c, "-334739439"), 10))
        || !TEST(0, TEST_BN_eq_word(c, 334739439))
        || !TEST(1, TEST_BN_abs_eq_word(c, 334739439))
        || !TEST(0, TEST_BN_eq_zero(c))
        || !TEST(1, TEST_BN_ne_zero(c))
        || !TEST(1, TEST_BN_le_zero(c))
        || !TEST(1, TEST_BN_lt_zero(c))
        || !TEST(0, TEST_BN_ge_zero(c))
        || !TEST(0, TEST_BN_gt_zero(c))
        || !TEST(0, TEST_BN_even(c))
        || !TEST(1, TEST_BN_odd(c))
        || !TEST(1, TEST_BN_eq(a, a))
        || !TEST(0, TEST_BN_ne(a, a))
        || !TEST(0, TEST_BN_eq(a, b))
        || !TEST(1, TEST_BN_ne(a, b))
        || !TEST(0, TEST_BN_lt(a, c))
        || !TEST(1, TEST_BN_lt(c, b))
        || !TEST(0, TEST_BN_lt(b, c))
        || !TEST(0, TEST_BN_le(a, c))
        || !TEST(1, TEST_BN_le(c, b))
        || !TEST(0, TEST_BN_le(b, c))
        || !TEST(1, TEST_BN_gt(a, c))
        || !TEST(0, TEST_BN_gt(c, b))
        || !TEST(1, TEST_BN_gt(b, c))
        || !TEST(1, TEST_BN_ge(a, c))
        || !TEST(0, TEST_BN_ge(c, b))
        || !TEST(1, TEST_BN_ge(b, c)))
        goto err;

    r = 1;
err:
    BN_free(a);
    BN_free(b);
    BN_free(c);
    return r;
}

static int test_long_output(void)
{
    const char *p 