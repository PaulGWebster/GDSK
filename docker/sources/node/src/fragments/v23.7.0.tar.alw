on counts (as opposed to branch hints), which are embedded into
  # the `--trace-turbo` .json file from `mksnapshot`.
  v8_log_builtins_block_count_input = ""

  # This build flag is used to control whether reorder builtins acoording to
  # the call graph with C3 algorithm based builtin PGO profiling.
  v8_enable_builtins_reordering = true

  # Provides the given V8 log file as an input to mksnapshot, where it can be
  # used for profile-guided optimization of builtins.
  #
  # To do profile-guided optimizations of builtins:
  # 1. Build with v8_enable_builtins_profiling = true
  # 2. Run your chosen workload with the --turbo-profiling-output flag.
  #    For Chrome, the invocation might look like this:
  #      chrome --no-sandbox --disable-extensions
  #        --js-flags="--turbo-profiling-output=v8.builtins.pgo"
  #        "http://localhost/test-suite"
  # 3. Run tools/builtins-pgo/get_hints.py to produce the branch hints,
  #    selecting min_count and threshold_ratio as you wish.
  # 4. Optionally repeat steps 2-3 for additional workloads, and use
  #    tools/builtins-pgo/combine_hints.py to combine the hints produced in
  #    step 3 into a single file.
  # 5. Build again with v8_builtins_profiling_log_file set to the file created
  #    in step 3 or 4.
  v8_builtins_profiling_log_file = "default"

  # Enables various testing features.
  v8_enable_test_features = ""

  # Enable short builtins call instruction sequences by un-embedding builtins.
  # Sets -dV8_SHORT_BUILTIN_CALLS
  v8_enable_short_builtin_calls = ""

  # Enable support for external code range relative to the pointer compression
  # cage.
  # Sets -dV8_EXTERNAL_CODE_SPACE
  v8_enable_external_code_space = ""

  # With post mortem support enabled, metadata is embedded into libv8 that
  # describes various parameters of the VM for use by debuggers. See
  # tools/gen-postmortem-metadata.py for details.
  v8_postmortem_support = false

  # Use Siphash as added protection against hash flooding attacks.
  v8_use_siphash = false

  # Switches off inlining in V8.
  v8_no_inline = false

  # Override OS page size when generating snapshot
  v8_os_page_size = "0"

  # Similar to vfp but on MIPS.
  v8_can_use_fpu_instructions = true

  # Similar to the ARM hard float ABI but on MIPS.
  v8_use_mips_abi_hardfloat = true

  # Controls the threshold for on-heap/off-heap Typed Arrays.
  v8_typed_array_max_size_in_heap = 64

  v8_enable_gdbjit = ((v8_current_cpu == "x86" || v8_current_cpu == "x64") &&
                      (is_linux || is_chromeos || is_mac)) ||
                     (v8_current_cpu == "ppc64" && (is_linux || is_chromeos))

  # Check that each header can be included in isolation (requires also
  # setting the "check_v8_header_includes" gclient variable to run a
  # specific hook).
  v8_check_header_includes = false

  # Enable sharing read-only space across isolates.
  # Sets -DV8_SHARED_RO_HEAP.
  v8_enable_shared_ro_heap = ""

  # Enable lazy source positions by default.
  v8_enable_lazy_source_positions = true

  # Enable third party HEAP library
  v8_enable_third_party_heap = false

  # Libaries used by third party heap
  v8_third_party_heap_libs = []

  # Source code used by third party heap
  v8_third_party_heap_files = []

  # Disable write barriers when GCs are non-incremental and
  # heap has single generation.
  v8_disable_write_barriers = false

  # Ensure that write barriers are always used.
  # Useful for debugging purposes.
  v8_enable_unconditional_write_barriers = false

  # Redirect allocation in young generation so that there will be
  # only one single generation.
  v8_enable_single_generation = ""

  # Use token threaded dispatch for the regular expression interpreter.
  # Use switch-based dispatch if this is false
  v8_enable_regexp_interpreter_threaded_dispatch = true

  # Enforce equality of builtins hashes from compatible architectures.
  v8_verify_builtins_compatibility = false

  # Check mksnapshot determinism by running it multiple times.
  v8_verify_deterministic_mksnapshot = false

  # Enable additional targets necessary for verification of torque
  # file generation
  v8_verify_torque_generation_invariance = false

  # Generate comments describing the Torque intermediate representation.
  v8_annotate_torque_ir = false

  # Enable snapshot compression (enabled by default for desktop) devices.
  v8_enable_snapshot_compression =
      target_os == "android" || target_os == "chromeos" ||
      target_os == "fuchsia"

  # Enable control-flow integrity features, such as pointer authentication for
  # ARM64. Enable it by default for simulator builds and when native code
  # supports it as well.
  v8_control_flow_integrity =
      v8_current_cpu == "arm64" &&
      (target_is_simulator || arm_control_flow_integrity != "none")

  # Enable heap reservation of size 4GB. Only possible for 64bit archs.
  cppgc_enable_caged_heap =
      v8_current_cpu == "x64" || v8_current_cpu == "arm64" ||
      v8_current_cpu == "loong64" || v8_current_cpu == "riscv64"

  # Enables additional heap verification phases and checks.
  cppgc_enable_verify_heap = ""

  # Enable allocations during prefinalizer invocations.
  cppgc_allow_allocations_in_prefinalizers = false

  # Enable V8 zone compression experimental feature.
  # Sets -DV8_COMPRESS_ZONES.
  v8_enable_zone_compression = ""

  # Enable the V8 sandbox.
  # Sets -DV8_ENABLE_SANDBOX.
  v8_enable_sandbox = ""

  # Explicitly disable leaptiering (on builds where it would otherwise be enabled).
  v8_disable_leaptiering = ""

  # Enable the memory corruption API. Useful for testing the sandbox.
  # The memory corruption API is only exposed to JavaScript if sandbox testing
  # mode is enabled at runtime, for example via --sandbox-fuzzing.
  # WARNING This will enable builtins that (by design) cause memory corruption.
  # Sets -DV8_ENABLE_MEMORY_CORRUPTION_API
  v8_enable_memory_corruption_api = false

  # Experimental feature for collecting per-class zone memory stats.
  # Requires use_rtti = true
  v8_enable_precise_zone_stats = false

  # Experimental feature that uses SwissNameDictionary instead of NameDictionary
  # as the backing store for all dictionary mode objects.
  v8_enable_swiss_name_dictionary = false

  # If enabled then macro definitions that are used in externally visible
  # header files are placed in a separate header file v8-gn.h.
  v8_generate_external_defines_header = false

  # Experimental feature for tracking constness of properties in non-global
  # dictionaries. Enabling this also always keeps prototypes in dict mode,
  # meaning that they are not switched to fast mode.
  # Sets -DV8_DICT_PROPERTY_CONST_TRACKING
  v8_dict_property_const_tracking = false

  # Enable map packing & unpacking (sets -dV8_MAP_PACKING).
  v8_enable_map_packing = false

  # Allow for JS promise hooks (instead of just C++).
  v8_enable_javascript_promise_hooks = false

  # Allow embedder data to be saved on continuations. Used to support
  # TaskAttribution and `scheduler.yield()`.
  # The flag enables disabling the feature, to test this data's overhead.
  v8_enable_continuation_preserved_embedder_data = true

  # Enable allocation folding globally (sets -dV8_ALLOCATION_FOLDING).
  # When it's disabled, the --turbo-allocation-folding runtime flag will be ignored.
  v8_enable_allocation_folding = true

  # Enable runtime verification of heap snapshots produced for devtools.
  v8_enable_heap_snapshot_verify = ""

  # Enable global allocation site tracking.
  v8_allocation_site_tracking = true

  # TODO(cbruni, v8:12302): Remove once API is migrated
  # Enable legacy mode for ScriptOrModule's lifetime. By default it's a
  # temporary object, if enabled it will be kept alive by the parent Script.
  # This is only used by nodejs.
  v8_scriptormodule_legacy_lifetime = false

  # WebAssembly interpreter (DrumBrake)  build flag.
  v8_enable_drumbrake = false

  # Enable Wasm interpreter tracing.
  v8_enable_drumbrake_tracing = false

  # On non-Desktop platforms, enable explicit bounds checks in the Wasm
  # interpreter, where the bounds checking is done in the instruction handler,
  # not using an unhandled exception filter (which also doesn't work with Win-ASAN).
  v8_drumbrake_bounds_checks =
      (is_win && (is_asan || is_ubsan || is_msan || is_tsan)) ||
      !(is_win || is_linux || is_mac) || v8_current_cpu != "x64"

  # Enables pointer compression for 8GB heaps.
  # Sets -DV8_COMPRESS_POINTERS_8GB.
  v8_enable_pointer_compression_8gb = ""

  # Compile V8 using zlib as dependency.
  # Sets -DV8_USE_ZLIB
  v8_use_zlib = true

  # Make ValueDeserializer crash if the data to deserialize is invalid.
  v8_value_deserializer_hard_fail = false

  # Enable jitless mode, including compile-time optimizations. Note that even
  # when this is set to 'false', one can run V8 in jitless mode at runtime by
  # passing the `--jitless` flag; but then you miss out on compile-time
  # optimizations.
  v8_jitless = v8_enable_lite_mode

  # Enable Sparkplug
  # Sets -DV8_ENABLE_SPARKPLUG.
  v8_enable_sparkplug = ""

  # Enable Maglev's graph printer.
  # Sets -DV8_ENABLE_MAGLEV_GRAPH_PRINTER.
  v8_enable_maglev_graph_printer = !build_with_chromium

  # Enable slow tracing, e.g., tracing on every instruction or Turbofan node.
  # Sets -DV8_ENABLE_SLOW_TRACING.
  v8_enable_slow_tracing = is_debug

  # Enable jump table switch for built-in.
  v8_enable_builtin_jump_table_switch = v8_current_cpu == "x64"

  v8_shortcut_strings_in_minor_ms = false

  # Whether custom embedder snapshots may extend (= allocate new objects in)
  # ReadOnlySpace.
  v8_enable_extensible_ro_snapshot = true

  # Enable Turboshaft CSA pipeline.
  v8_enable_turboshaft_csa = false

  # Use sticky mark-bits for separating object generations.
  v8_enable_sticky_mark_bits = false

  # Use the experimental TSA-based definition for some builtins.
  v8_enable_experimental_tsa_builtins = false

  v8_dcheck_always_on = dcheck_always_on
}

# Derived defaults.
if (cppgc_enable_verify_heap == "") {
  cppgc_enable_verify_heap = v8_enable_debugging_features || v8_dcheck_always_on
}
if (v8_enable_verify_heap == "") {
  v8_enable_verify_heap = v8_enable_debugging_features
}
if (v8_enable_object_print == "") {
  v8_enable_object_print = v8_enable_debugging_features
}
if (v8_enable_disassembler == "") {
  v8_enable_disassembler = v8_enable_debugging_features
}
if (v8_enable_trace_maps == "") {
  v8_enable_trace_maps = v8_enable_debugging_features
}
if (v8_enable_test_features == "") {
  v8_enable_test_features = v8_enable_debugging_features || v8_dcheck_always_on
}
if (v8_enable_v8_checks == "") {
  v8_enable_v8_checks = v8_enable_debugging_features
}
if (v8_enable_heap_snapshot_verify == "") {
  v8_enable_heap_snapshot_verify =
      v8_enable_debugging_features || v8_dcheck_always_on
}
if (v8_enable_snapshot_code_comments) {
  assert(v8_code_comments == true || v8_code_comments == "",
         "v8_enable_snapshot_code_comments conflicts with v8_code_comments.")
  v8_code_comments = true
} else if (v8_code_comments == "") {
  v8_code_comments = v8_enable_debugging_features
}
if (v8_enable_debug_code == "") {
  v8_enable_debug_code = v8_enable_debugging_features
}
if (v8_enable_snapshot_native_code_counters == "") {
  v8_enable_snapshot_native_code_counters = v8_enable_debugging_features
}

if (v8_enable_drumbrake && v8_enable_webassembly) {
  assert(
      is_drumbrake_supported,
      "DrumBrake is only available on x64, arm64 on Windows, Linux and MacOS.")
}

# Toggle pointer compression for correctness fuzzing when building the
# clang_x64_pointer_compression toolchain. We'll correctness-compare the
# default build with the clang_x64_pointer_compression build.
if (v8_multi_arch_build &&
    rebase_path(get_label_info(":d8", "root_out_dir"), root_build_dir) ==
    "clang_x64_pointer_compression") {
  v8_enable_pointer_compression = !v8_enable_pointer_compression
}

# Ensure the sandbox is on/off in the same way as pointer compression for
# correctness fuzzing builds.
if (v8_multi_arch_build) {
  v8_enable_sandbox = v8_enable_pointer_compression
}
if (v8_enable_pointer_compression_shared_cage == "") {
  v8_enable_pointer_compression_shared_cage = v8_enable_pointer_compression
}
if (v8_enable_pointer_compression_8gb == "") {
  v8_enable_pointer_compression_8gb = false
}
if (v8_enable_fast_torque == "") {
  v8_enable_fast_torque = v8_enable_fast_mksnapshot
}
if (v8_enable_zone_compression == "") {
  v8_enable_zone_compression = false
}
if (v8_enable_short_builtin_calls == "") {
  v8_enable_short_builtin_calls =
      v8_current_cpu == "x64" || v8_current_cpu == "arm64"
}
if (v8_enable_external_code_space == "") {
  v8_enable_external_code_space =
      v8_enable_pointer_compression &&
      v8_enable_pointer_compression_shared_cage &&
      (v8_current_cpu == "x64" || v8_current_cpu == "arm64")
}
if (v8_enable_sparkplug == "") {
  v8_enable_sparkplug = !v8_jitless
}
if (v8_enable_maglev == "") {
  v8_enable_maglev = v8_enable_turbofan &&
                     (v8_current_cpu == "arm" || v8_current_cpu == "x64" ||
                      v8_current_cpu == "arm64")
}
assert(v8_enable_turbofan || !v8_enable_maglev,
       "Maglev is not available when Turbofan is disabled.")

assert(!v8_jitless || (!v8_enable_sparkplug && !v8_enable_maglev &&
                           !v8_enable_turbofan && !v8_enable_webassembly),
       "Sparkplug, Maglev, Turbofan and Wasm are not available in jitless mode")

if (v8_enable_single_generation == "") {
  v8_enable_single_generation = v8_disable_write_barriers
}
if (v8_enable_atomic_object_field_writes == "") {
  v8_enable_atomic_object_field_writes = v8_enable_concurrent_marking
}
if (v8_enable_third_party_heap) {
  v8_disable_write_barriers = true
  v8_enable_single_generation = true
  v8_enable_shared_ro_heap = false
  v8_enable_pointer_compression = false
  v8_enable_pointer_compression_shared_cage = false
  v8_enable_allocation_folding = false
}
if (v8_enable_single_generation) {
  v8_allocation_site_tracking = false
}
assert(!v8_enable_concurrent_marking || v8_enable_atomic_object_field_writes,
       "Concurrent marking requires atomic object field writes.")
if (v8_enable_trace_unoptimized == "") {
  v8_enable_trace_unoptimized =
      v8_enable_trace_ignition || v8_enable_trace_baseline_exec
}
assert(!v8_enable_trace_ignition || v8_enable_trace_unoptimized,
       "Ignition tracing requires unoptimized tracing to be enabled.")
assert(!v8_enable_trace_baseline_exec || v8_enable_trace_unoptimized,
       "Baseline tracing requires unoptimized tracing to be enabled.")
assert(
    v8_enable_debugging_features == true || v8_dcheck_always_on ||
        !v8_enable_slow_dchecks,
    "v8_enable_slow_dchecks requires v8_enable_debugging_features or dcheck_always_on.")

if (v8_enable_short_builtin_calls &&
    (!v8_enable_pointer_compression && v8_current_cpu != "x64")) {
  # Disable short calls when pointer compression is not enabled, except x64,
  # where short builtin calls can still be enabled if the code range is
  # guaranteed to be close enough to embedded builtins.
  v8_enable_short_builtin_calls = false
}
if (v8_enable_shared_ro_heap == "") {
  v8_enable_shared_ro_heap = !v8_enable_pointer_compression ||
                             v8_enable_pointer_compression_shared_cage
}

if (v8_enable_sandbox == "") {
  # TODO(saelo, v8:11880) remove dependency on v8_enable_external_code_space
  # once that is enabled everywhere by default.
  # TODO(chromium:1325784) the sandbox is not currently supported in Chromium
  # on Fuchsia.
  v8_enable_sandbox = v8_enable_pointer_compression_shared_cage &&
                      v8_enable_external_code_space && target_os != "fuchsia"
}

if (v8_disable_leaptiering == "") {
  v8_disable_leaptiering = false
}

if (v8_enable_static_roots == "") {
  # Static roots are only valid for builds with pointer compression and a
  # shared read-only heap.
  # TODO(olivf, v8:13466) Some configurations could be supported if we
  # introduce different static root files for different build configurations:
  # Non-wasm and non-i18n builds have fewer read only roots. Configurations
  # without external code space allocate read only roots at a further
  # location relative to the cage base.
  v8_enable_static_roots =
      v8_enable_pointer_compression && v8_enable_shared_ro_heap &&
      v8_enable_pointer_compression_shared_cage &&
      v8_enable_external_code_space && v8_enable_webassembly &&
      v8_enable_i18n_support
}

assert(!v8_enable_static_roots ||
           (v8_enable_pointer_compression && v8_enable_shared_ro_heap &&
                v8_enable_pointer_compression_shared_cage &&
                v8_enable_external_code_space && v8_enable_webassembly &&
                v8_enable_i18n_support),
       "Trying to enable static roots in a configuration that is not supported")

assert(
    !(v8_enable_static_roots && v8_enable_static_roots_generation),
    "Static root values must be generated in a build that does not rely on static roots itself")

if (v8_builtins_profiling_log_file == "default") {
  v8_builtins_profiling_log_file = ""

  # The existing profile can be used only when
  # * `v8_enable_builtins_optimization` - this switch enables builtins PGO,
  # * `!v8_enable_builtins_profiling` - don't use the profiles when generating
  #    a new one,
  # * `!is_debug && !dcheck_always_on` - these modes add more checks to
  #   the builtins control flow which makes the builtins code different,
  # * `v8_enable_pointer_compression` - it changes the objects layouts,
  # * `v8_enable_sandbox && v8_enable_external_code_space` because they affect
  #   the way how external pointer values are accessed,
  # * `v8_enable_webassembly` because it changes the set of opcodes which
  #   affects graphs hashes.
  if (v8_enable_builtins_optimization && !v8_enable_builtins_profiling &&
      !is_debug && !v8_dcheck_always_on && v8_enable_webassembly) {
    # This is about function arguments evaluation order on the machine building
    # mksnapshot, which makes node IDs not predictable for subgraphs like
    # Op1(Op2(), Op3()) and as a result different graph hashes.
    # Clang uses left-to-right order everywhere except Windows, otherwise the
    # order is right-to-left.
    # TODO(crbug.com/v8/13647): Remove once this issue is fixed in CSA.
    if (!is_clang || host_os == "win") {
      pgo_profile_suffix = "-rl"
    } else {
      pgo_profile_suffix = ""
    }
    if ((v8_current_cpu == "x64" || v8_current_cpu == "arm64") &&
        v8_enable_pointer_compression && v8_enable_external_code_space &&
        v8_enable_sandbox) {
      # Note, currently x64 profile can be applied to arm64 but not the other
      # way round.
      v8_builtins_profiling_log_file =
          "tools/builtins-pgo/profiles/x64" + pgo_profile_suffix + ".profile"
    } else if (v8_current_cpu == "x86" || v8_current_cpu == "arm") {
      # Note, x86 profile can be applied to arm but not the other way round.
      v8_builtins_profiling_log_file =
          "tools/builtins-pgo/profiles/x86" + pgo_profile_suffix + ".profile"
    }
  }
}

if (v8_enable_webassembly && !target_is_simulator && v8_current_cpu == "x64") {
  v8_enable_wasm_simd256_revec = true
}

assert(!v8_disable_write_barriers || v8_enable_single_generation,
       "Disabling write barriers works only with single generation")

assert(v8_current_cpu == "arm64" || !v8_control_flow_integrity,
       "Control-flow integrity is only supported on arm64")

if (v8_enable_shared_ro_heap && v8_enable_pointer_compression &&
    !v8_enable_pointer_compression_shared_cage) {
  assert(
      is_linux || is_chromeos || is_android,
      "Sharing read-only heap with pointer compression is only supported on Linux or Android")
}

assert(!v8_enable_map_packing || !v8_enable_pointer_compression,
       "Map packing does not support pointer compression")

assert(!v8_enable_map_packing || v8_current_cpu == "x64",
       "Map packing is only supported on x64")

assert(!v8_enable_external_code_space || v8_enable_pointer_compression,
       "External code space feature requires pointer compression")

assert(!v8_enable_pointer_compression_8gb || v8_enable_pointer_compression,
       "Pointer compression for 8GB cages requires pointer compression")

assert(!v8_enable_sandbox || v8_enable_pointer_compression_shared_cage,
       "The sandbox requires the shared pointer compression cage")

assert(!v8_enable_sandbox || v8_enable_external_code_space,
       "The sandbox requires the external code space")

assert(!v8_enable_sandbox || !v8_enable_third_party_heap,
       "The sandbox is incompatible with the third-party heap")

assert(!v8_enable_memory_corruption_api || v8_enable_sandbox,
       "The Memory Corruption API requires the sandbox")

assert(
    !v8_enable_pointer_compression_shared_cage || v8_enable_pointer_compression,
    "Can't share a pointer compression cage if pointers aren't compressed")

assert(
    !v8_enable_pointer_compression_shared_cage || v8_current_cpu == "x64" ||
        v8_current_cpu == "arm64" || v8_current_cpu == "riscv64" ||
        v8_current_cpu == "ppc64" || v8_current_cpu == "s390x" ||
        v8_current_cpu == "loong64",
    "Sharing a pointer compression cage is only supported on x64, arm64, ppc64, s390x, riscv64 and loong64")

assert(!v8_enable_unconditional_write_barriers || !v8_disable_write_barriers,
       "Write barriers can't be both enabled and disabled")

assert(!cppgc_enable_caged_heap || v8_current_cpu == "x64" ||
           v8_current_cpu == "arm64" || v8_current_cpu == "loong64" ||
           v8_current_cpu == "riscv64",
       "CppGC caged heap requires 64bit platforms")

assert(!cppgc_enable_young_generation || cppgc_enable_caged_heap,
       "Young generation in CppGC requires caged heap")

assert(!cppgc_enable_pointer_compression || cppgc_enable_caged_heap,
       "Pointer compression in CppGC requires caged heap")

if (v8_enable_single_generation == true) {
  assert(
      v8_enable_unconditional_write_barriers || v8_disable_write_barriers,
      "Requires unconditional write barriers or none (which disables incremental marking)")
}

assert(!v8_enable_snapshot_compression || v8_use_zlib,
       "Snapshot compression requires zlib")

if (v8_expose_public_symbols == "") {
  v8_expose_public_symbols = v8_expose_symbols
}

v8_random_seed = "314159265"
v8_toolset_for_shell = "host"

###############################################################################
# Configurations
#

config("internal_config_base") {
  # Only targets in this file and its subdirs can depend on this.
  visibility = [ "./*" ]

  configs = [ ":v8_tracing_config" ]

  include_dirs = [
    ".",
    "include",
    "$target_gen_dir",
  ]
}

config("internal_config") {
  defines = []

  # Only targets in this file and its subdirs can depend on this.
  visibility = [ "./*" ]

  configs = [
    "//build/config/compiler:wexit_time_destructors",
    ":internal_config_base",
    ":v8_header_features",
    ":cppgc_header_features",
  ]

  if (is_component_build) {
    defines += [ "BUILDING_V8_SHARED_PRIVATE" ]
  } else if (v8_expose_public_symbols) {
    defines += [ "BUILDING_V8_SHARED" ]
  }

  if (v8_current_cpu == "riscv64" || v8_current_cpu == "riscv32") {
    if (!is_clang) {
      libs = [ "atomic" ]
    }
  }
}

# Should be applied to all targets that write trace events.
config("v8_tracing_config") {
  if (v8_use_perfetto) {
    include_dirs = [
      "//third_party/perfetto/include",
      "$root_gen_dir/third_party/perfetto",
      "$root_gen_dir/third_party/perfetto/build_config",
    ]
  }
}

# This config should be applied to code using the libplatform.
config("libplatform_config") {
  include_dirs = [ "include" ]
  if (is_component_build) {
    defines = [ "USING_V8_PLATFORM_SHARED" ]
  }
}

# This config should be applied to code using the libbase.
config("libbase_config") {
  if (is_component_build) {
    defines = [ "USING_V8_BASE_SHARED" ]
  }
  libs = []
  if (is_android && current_toolchain != host_toolchain) {
    libs += [ "log" ]
  }
}

config("zoslib_config") {
  if (current_os == "zos") {
    configs = [ "//third_party/zoslib:zoslib_config" ]
  }
}

# Standalone cppgc cannot be built within chrome or with perfetto.
assert(!cppgc_is_standalone || !build_with_chromium)
assert(!cppgc_is_standalone || !v8_use_perfetto)

# This config should be applied to code using the cppgc_base.
config("cppgc_base_config") {
  defines = []
  if (cppgc_is_standalone) {
    defines += [ "CPPGC_IS_STANDALONE" ]
  }
}

# This config is only applied to v8_headers and is the basis for external_config
# but without setting the USING_V8_SHARED define, which means v8_headers can be
# used inside v8 itself.
config("headers_config") {
  defines = []
  configs = [
    ":v8_header_features",
    ":cppgc_header_features",
  ]
  include_dirs = [ "include" ]
}

# This config should only be applied to code using V8 and not any V8 code
# itself.
config("external_config") {
  configs = [ ":headers_config" ]
  defines = []
  if (is_component_build) {
    defines += [
      "USING_V8_SHARED",
      "USING_V8_SHARED_PRIVATE",
    ]
  }

  if (current_cpu == "riscv64" || current_cpu == "riscv32") {
    if (!is_clang) {
      libs = [ "atomic" ]
    }
  }
}

# This config should only be applied to code that needs to be explicitly
# aware of whether we are using startup data or not.
config("external_startup_data") {
  if (v8_use_external_startup_data) {
    defines = [ "V8_USE_EXTERNAL_STARTUP_DATA" ]
  }
}

# List of defines that can appear in externally visible header files and that
# are controlled by args.gn.
# Make sure the |v8_generate_features_json| action is also updated when adding
# or removing defines below.
external_v8_defines = [
  "V8_ARRAY_BUFFER_INTERNAL_FIELD_COUNT=${v8_array_buffer_internal_field_count}",
  "V8_ARRAY_BUFFER_VIEW_INTERNAL_FIELD_COUNT=${v8_array_buffer_view_internal_field_count}",
  "V8_PROMISE_INTERNAL_FIELD_COUNT=${v8_promise_internal_field_count}",
  "V8_ENABLE_CHECKS",
  "V8_COMPRESS_POINTERS",
  "V8_COMPRESS_POINTERS_IN_SHARED_CAGE",
  "V8_31BIT_SMIS_ON_64BIT_ARCH",
  "V8_COMPRESS_ZONES",
  "V8_ENABLE_SANDBOX",
  "V8_DEPRECATION_WARNINGS",
  "V8_IMMINENT_DEPRECATION_WARNINGS",
  "V8_USE_PERFETTO",
  "V8_MAP_PACKING",
  "V8_IS_TSAN",
  "V8_ENABLE_CONSERVATIVE_STACK_SCANNING",
  "V8_ENABLE_DIRECT_HANDLE",
  "V8_MINORMS_STRING_SHORTCUTTING",
  "V8_HAVE_TARGET_OS",
  "V8_TARGET_OS_ANDROID",
  "V8_TARGET_OS_FUCHSIA",
  "V8_TARGET_OS_IOS",
  "V8_TARGET_OS_LINUX",
  "V8_TARGET_OS_MACOS",
  "V8_TARGET_OS_WIN",
  "V8_TARGET_OS_CHROMEOS",
]

enabled_external_v8_defines = [
  "V8_ARRAY_BUFFER_INTERNAL_FIELD_COUNT=${v8_array_buffer_internal_field_count}",
  "V8_ARRAY_BUFFER_VIEW_INTERNAL_FIELD_COUNT=${v8_array_buffer_view_internal_field_count}",
  "V8_PROMISE_INTERNAL_FIELD_COUNT=${v8_promise_internal_field_count}",
]

if (v8_enable_v8_checks) {
  enabled_external_v8_defines += [ "V8_ENABLE_CHECKS" ]
}
if (v8_enable_pointer_compression) {
  enabled_external_v8_defines += [ "V8_COMPRESS_POINTERS" ]
  if (v8_enable_pointer_compression_shared_cage) {
    enabled_external_v8_defines += [ "V8_COMPRESS_POINTERS_IN_SHARED_CAGE" ]
  }
}
if (v8_enable_pointer_compression || v8_enable_31bit_smis_on_64bit_arch) {
  enabled_external_v8_defines += [ "V8_31BIT_SMIS_ON_64BIT_ARCH" ]
}
if (v8_enable_zone_compression) {
  enabled_external_v8_defines += [ "V8_COMPRESS_ZONES" ]
}
if (v8_enable_sandbox) {
  enabled_external_v8_defines += [ "V8_ENABLE_SANDBOX" ]
}
if (v8_deprecation_warnings) {
  enabled_external_v8_defines += [ "V8_DEPRECATION_WARNINGS" ]
}
if (v8_imminent_deprecation_warnings) {
  enabled_external_v8_defines += [ "V8_IMMINENT_DEPRECATION_WARNINGS" ]
}
if (v8_use_perfetto) {
  enabled_external_v8_defines += [ "V8_USE_PERFETTO" ]
}
if (v8_enable_map_packing) {
  enabled_external_v8_defines += [ "V8_MAP_PACKING" ]
}
if (is_tsan) {
  enabled_external_v8_defines += [ "V8_IS_TSAN" ]
}
if (v8_enable_conservative_stack_scanning) {
  enabled_external_v8_defines += [ "V8_ENABLE_CONSERVATIVE_STACK_SCANNING" ]
}
if (v8_enable_direct_handle) {
  enabled_external_v8_defines += [ "V8_ENABLE_DIRECT_HANDLE" ]
}
if (v8_shortcut_strings_in_minor_ms) {
  enabled_external_v8_defines += [ "V8_MINORMS_STRING_SHORTCUTTING" ]
}

# V8_TARGET_OS_ defines. The target OS may differ from host OS e.g. in
# mksnapshot. We additionally set V8_HAVE_TARGET_OS to determine that a
# target OS has in fact been set; otherwise we internally assume that target
# OS == host OS (see v8config.h).
if (target_os == "android") {
  enabled_external_v8_defines += [ "V8_HAVE_TARGET_OS" ]
  enabled_external_v8_defines += [ "V8_TARGET_OS_ANDROID" ]
} else if (target_os == "fuchsia") {
  enabled_external_v8_defines += [ "V8_HAVE_TARGET_OS" ]
  enabled_external_v8_defines += [ "V8_TARGET_OS_FUCHSIA" ]
} else if (target_os == "ios") {
  enabled_external_v8_defines += [ "V8_HAVE_TARGET_OS" ]
  enabled_external_v8_defines += [ "V8_TARGET_OS_IOS" ]
} else if (target_os == "linux") {
  enabled_external_v8_defines += [ "V8_HAVE_TARGET_OS" ]
  enabled_external_v8_defines += [ "V8_TARGET_OS_LINUX" ]
} else if (target_os == "mac") {
  enabled_external_v8_defines += [ "V8_HAVE_TARGET_OS" ]
  enabled_external_v8_defines += [ "V8_TARGET_OS_MACOS" ]
} else if (target_os == "win") {
  enabled_external_v8_defines += [ "V8_HAVE_TARGET_OS" ]
  enabled_external_v8_defines += [ "V8_TARGET_OS_WIN" ]
} else if (target_os == "chromeos") {
  enabled_external_v8_defines += [ "V8_HAVE_TARGET_OS" ]
  enabled_external_v8_defines += [ "V8_TARGET_OS_CHROMEOS" ]
}

disabled_external_v8_defines = external_v8_defines - enabled_external_v8_defines

# Put defines that are used in public headers here; public headers are
# defined in "v8_headers" and are included by embedders of V8.
config("v8_header_features") {
  visibility = [ ":*" ]

  if (v8_generate_external_defines_header) {
    defines = [ "V8_GN_HEADER" ]
  } else {
    defines = enabled_external_v8_defines
  }
}

# List of defines that can appear in externally visible cppgc header files and
# that are controlled by args.gn.
external_cppgc_defines = [
  "CPPGC_SUPPORTS_OBJECT_NAMES",
  "CPPGC_CAGED_HEAP",
  "CPPGC_SLIM_WRITE_BARRIER",
  "CPPGC_YOUNG_GENERATION",
  "CPPGC_POINTER_COMPRESSION",
  "CPPGC_ENABLE_LARGER_CAGE",
]

enabled_external_cppgc_defines = []

if (cppgc_enable_object_names) {
  enabled_external_cppgc_defines += [ "CPPGC_SUPPORTS_OBJECT_NAMES" ]
}
if (cppgc_enable_caged_heap) {
  enabled_external_cppgc_defines += [ "CPPGC_CAGED_HEAP" ]

  # Always enable young generation compile time flag if caged heap is enabled.
  cppgc_enable_young_generation = true

  # Pointer compression regresses binary size on Fuchsia by about 300K.
  # However, the change improves Oilpan memory by 15-20% (2-4% of PMF),
  # which is beneficial for memory-impoverished platforms.
  cppgc_enable_pointer_compression = true
}
if (cppgc_enable_young_generation) {
  enabled_external_cppgc_defines += [ "CPPGC_YOUNG_GENERATION" ]
}
if (cppgc_enable_pointer_compression) {
  enabled_external_cppgc_defines += [ "CPPGC_POINTER_COMPRESSION" ]
}
if (cppgc_enable_2gb_cage) {
  enabled_external_cppgc_defines += [ "CPPGC_2GB_CAGE" ]
}
if (cppgc_enable_larger_cage) {
  enabled_external_cppgc_defines += [ "CPPGC_ENABLE_LARGER_CAGE" ]
}
if (cppgc_enable_slim_write_barrier) {
  enabled_external_cppgc_defines += [ "CPPGC_SLIM_WRITE_BARRIER" ]
}

disabled_external_cppgc_defines =
    external_cppgc_defines - enabled_external_cppgc_defines

config("cppgc_header_features") {
  visibility = [ ":*" ]

  if (v8_generate_external_defines_header) {
    defines = [ "V8_GN_HEADER" ]
  } else {
    defines = enabled_external_cppgc_defines
  }
}

enabled_external_defines =
    enabled_external_v8_defines + enabled_external_cppgc_defines
disabled_external_defines =
    disabled_external_v8_defines + disabled_external_cppgc_defines

# Put defines here that are only used in our internal files and NEVER in
# external headers that embedders (such as chromium and node) might include.
config("features") {
  # Only targets in this file and its subdirs can depend on this.
  visibility = [ "./*" ]

  defines =
      [ "V8_TYPED_ARRAY_MAX_SIZE_IN_HEAP=${v8_typed_array_max_size_in_heap}" ]

  configs = [
    ":v8_header_features",
    ":cppgc_header_features",
  ]

  if (cppgc_enable_verify_heap) {
    defines += [ "CPPGC_VERIFY_HEAP" ]
  }

  if (cppgc_allow_allocations_in_prefinalizers) {
    defines += [ "CPPGC_ALLOW_ALLOCATIONS_IN_PREFINALIZERS" ]
  }

  if (v8_enable_pointer_compression &&
      !v8_enable_pointer_compression_shared_cage) {
    defines += [ "V8_COMPRESS_POINTERS_IN_MULTIPLE_CAGES" ]
  }

  if (v8_embedder_string != "") {
    defines += [ "V8_EMBEDDER_STRING=\"$v8_embedder_string\"" ]
  }
  if (v8_enable_disassembler || v8_log_builtins_block_count_input != "") {
    defines += [ "ENABLE_DISASSEMBLER" ]
  }
  if (v8_log_builtins_block_count_input != "") {
    defines += [ "LOG_BUILTIN_BLOCK_COUNT" ]
  }
  if (v8_enable_future) {
    defines += [ "V8_ENABLE_FUTURE" ]
  }
  if (v8_enable_lite_mode) {
    defines += [ "V8_LITE_MODE" ]
  }
  if (v8_enable_gdbjit) {
    defines += [ "ENABLE_GDB_JIT_INTERFACE" ]
  }
  if (v8_enable_vtunejit) {
    defines += [ "ENABLE_VTUNE_JIT_INTERFACE" ]
  }
  if (v8_enable_vtunetracemark) {
    defines += [ "ENABLE_VTUNE_TRACEMARK" ]
  }
  if (v8_enable_hugepage) {
    defines += [ "ENABLE_HUGEPAGE" ]
  }
  if (v8_enable_private_mapping_fork_optimization) {
    defines += [ "V8_ENABLE_PRIVATE_MAPPING_FORK_OPTIMIZATION" ]
  }
  if (v8_enable_object_print) {
    defines += [ "OBJECT_PRINT" ]
  }
  if (v8_enable_verify_heap) {
    defines += [ "VERIFY_HEAP" ]
  }
  if (v8_enable_verify_predictable) {
    defines += [ "VERIFY_PREDICTABLE" ]
  }
  if (v8_enable_trace_maps) {
    defines += [ "V8_TRACE_MAPS" ]
  }
  if (v8_enable_trace_unoptimized) {
    defines += [ "V8_TRACE_UNOPTIMIZED" ]
  }
  if (v8_enable_trace_feedback_updates) {
    defines += [ "V8_TRACE_FEEDBACK_UPDATES" ]
  }
  if (v8_enable_test_features) {
    defines += [ "V8_ENABLE_ALLOCATION_TIMEOUT" ]
    defines += [ "V8_ENABLE_FORCE_SLOW_PATH" ]
    defines += [ "V8_ENABLE_DOUBLE_CONST_STORE_CHECK" ]
  }
  if (v8_enable_i18n_support) {
    defines += [ "V8_INTL_SUPPORT" ]
  }
  if (v8_enable_handle_zapping) {
    defines += [ "ENABLE_HANDLE_ZAPPING" ]
  }
  if (v8_code_comments == true) {
    defines += [ "V8_CODE_COMMENTS" ]
  }
  if (v8_enable_debug_code) {
    defines += [ "V8_ENABLE_DEBUG_CODE" ]
  }
  if (v8_enable_heap_snapshot_verify) {
    defines += [ "V8_ENABLE_HEAP_SNAPSHOT_VERIFY" ]
  }
  if (v8_enable_snapshot_native_code_counters) {
    defines += [ "V8_SNAPSHOT_NATIVE_CODE_COUNTERS" ]
  }
  if (v8_enable_single_generation) {
    defines += [ "V8_ENABLE_SINGLE_GENERATION" ]
  }
  if (v8_disable_write_barriers) {
    defines += [ "V8_DISABLE_WRITE_BARRIERS" ]
  }
  if (v8_enable_third_party_heap) {
    defines += [ "V8_ENABLE_THIRD_PARTY_HEAP" ]
  }
  if (v8_use_external_startup_data) {
    defines += [ "V8_USE_EXTERNAL_STARTUP_DATA" ]
  }
  if (v8_enable_atomic_object_field_writes) {
    defines += [ "V8_ATOMIC_OBJECT_FIELD_WRITES" ]
  }
  if (v8_enable_ignition_dispatch_counting) {
    defines += [ "V8_IGNITION_DISPATCH_COUNTING" ]
  }
  if (v8_enable_lazy_source_positions) {
    defines += [ "V8_ENABLE_LAZY_SOURCE_POSITIONS" ]
  }
  if (v8_use_siphash) {
    defines += [ "V8_USE_SIPHASH" ]
  }
  if (v8_enable_shared_ro_heap) {
    defines += [ "V8_SHARED_RO_HEAP" ]
  }
  if (v8_win64_unwinding_info) {
    defines += [ "V8_WIN64_UNWINDING_INFO" ]
  }
  if (v8_enable_regexp_interpreter_threaded_dispatch) {
    defines += [ "V8_ENABLE_REGEXP_INTERPRETER_THREADED_DISPATCH" ]
  }
  if (v8_enable_snapshot_compression) {
    defines += [ "V8_SNAPSHOT_COMPRESSION" ]
  }
  if (v8_control_flow_integrity) {
    defines += [ "V8_ENABLE_CONTROL_FLOW_INTEGRITY" ]
  }
  if (v8_enable_cet_shadow_stack) {
    defines += [ "V8_ENABLE_CET_SHADOW_STACK" ]
  }
  if (v8_enable_cet_ibt) {
    defines += [ "V8_ENABLE_CET_IBT" ]
  }
  if (v8_enable_wasm_gdb_remote_debugging) {
    defines += [ "V8_ENABLE_WASM_GDB_REMOTE_DEBUGGING" ]
  }
  if (v8_enable_precise_zone_stats) {
    defines += [ "V8_ENABLE_PRECISE_ZONE_STATS" ]
  }
  if (v8_fuzzilli) {
    defines += [ "V8_FUZZILLI" ]
  }
  if (v8_enable_fuzztest) {
    defines += [ "V8_ENABLE_FUZZTEST" ]
  }
  if (v8_enable_short_builtin_calls) {
    defines += [ "V8_SHORT_BUILTIN_CALLS" ]
  }
  if (v8_enable_external_code_space) {
    defines += [ "V8_EXTERNAL_CODE_SPACE" ]
  }
  if (v8_enable_sparkplug) {
    defines += [ "V8_ENABLE_SPARKPLUG" ]
  }
  if (v8_enable_maglev) {
    defines += [ "V8_ENABLE_MAGLEV" ]
  }
  if (v8_enable_turbofan) {
    defines += [ "V8_ENABLE_TURBOFAN" ]
  }
  if (v8_jitless) {
    defines += [ "V8_JITLESS" ]
  }
  if (v8_enable_swiss_name_dictionary) {
    defines += [ "V8_ENABLE_SWISS_NAME_DICTIONARY" ]
  }
  if (v8_enable_system_instrumentation) {
    defines += [ "V8_ENABLE_SYSTEM_INSTRUMENTATION" ]
  }
  if (v8_enable_etw_stack_walking) {
    defines += [ "V8_ENABLE_ETW_STACK_WALKING" ]
  }
  if (v8_etw_guid != "") {
    defines += [ "V8_ETW_GUID=\"$v8_etw_guid\"" ]
  }
  if (v8_enable_webassembly) {
    defines += [ "V8_ENABLE_WEBASSEMBLY" ]
  }
  if (v8_dict_property_const_tracking) {
    defines += [ "V8_DICT_PROPERTY_CONST_TRACKING" ]
  }
  if (v8_enable_javascript_promise_hooks) {
    defines += [ "V8_ENABLE_JAVASCRIPT_PROMISE_HOOKS" ]
  }
  if (v8_enable_continuation_preserved_embedder_data) {
    defines += [ "V8_ENABLE_CONTINUATION_PRESERVED_EMBEDDER_DATA" ]
  }
  if (v8_enable_allocation_folding) {
    defines += [ "V8_ALLOCATION_FOLDING" ]
  }
  if (v8_allocation_site_tracking) {
    defines += [ "V8_ALLOCATION_SITE_TRACKING" ]
  }
  if (v8_scriptormodule_legacy_lifetime) {
    defines += [ "V8_SCRIPTORMODULE_LEGACY_LIFETIME" ]
  }
  if (v8_advanced_bigint_algorithms) {
    defines += [ "V8_ADVANCED_BIGINT_ALGORITHMS" ]
  }
  if (v8_enable_drumbrake) {
    defines += [ "V8_ENABLE_DRUMBRAKE" ]
    if (v8_enable_drumbrake_tracing) {
      defines += [ "V8_ENABLE_DRUMBRAKE_TRACING" ]
    }
    if (v8_drumbrake_bounds_checks) {
      defines += [ "V8_DRUMBRAKE_BOUNDS_CHECKS" ]
    }
  }
  if (v8_enable_memory_corruption_api) {
    defines += [ "V8_ENABLE_MEMORY_CORRUPTION_API" ]
  }
  if (v8_enable_pointer_compression_8gb) {
    defines += [ "V8_COMPRESS_POINTERS_8GB" ]
  }
  if (v8_enable_static_roots) {
    defines += [ "V8_STATIC_ROOTS" ]
  }
  if (v8_enable_static_roots_generation) {
    defines += [ "V8_STATIC_ROOTS_GENERATION" ]
  }
  if (v8_use_zlib) {
    defines += [ "V8_USE_ZLIB" ]
  }
  if (v8_use_libm_trig_functions) {
    defines += [ "V8_USE_LIBM_TRIG_FUNCTIONS" ]
  }
  if (v8_value_deserializer_hard_fail) {
    defines += [ "V8_VALUE_DESERIALIZER_HARD_FAIL" ]
  }
  if (v8_enable_wasm_simd256_revec) {
    defines += [ "V8_ENABLE_WASM_SIMD256_REVEC" ]
  }
  if (v8_enable_maglev_graph_printer) {
    defines += [ "V8_ENABLE_MAGLEV_GRAPH_PRINTER" ]
  }
  if (v8_enable_slow_tracing) {
    defines += [ "V8_ENABLE_SLOW_TRACING" ]
  }
  if (v8_enable_builtin_jump_table_switch) {
    defines += [ "V8_ENABLE_BUILTIN_JUMP_TABLE_SWITCH" ]
  }
  if (v8_enable_extensible_ro_snapshot) {
    defines += [ "V8_ENABLE_EXTENSIBLE_RO_SNAPSHOT" ]
  }
  if (v8_enable_local_off_stack_check) {
    defines += [ "V8_ENABLE_LOCAL_OFF_STACK_CHECK" ]
  }
  if (v8_enable_sticky_mark_bits) {
    defines += [ "V8_ENABLE_STICKY_MARK_BITS" ]
  }
  if (v8_enable_experimental_tsa_builtins) {
    defines += [ "V8_ENABLE_EXPERIMENTAL_TSA_BUILTINS" ]
  }
  if (v8_disable_leaptiering) {
    defines += [ "V8_DISABLE_LEAPTIERING" ]
  }
}

config("toolchain") {
  # Only targets in this file and its subdirs can depend on this.
  visibility = [ "./*" ]

  defines = []
  cflags = []
  ldflags = []

  if (v8_current_cpu == "arm") {
    defines += [ "V8_TARGET_ARCH_ARM" ]
    if (arm_version >= 7) {
      defines += [ "CAN_USE_ARMV7_INSTRUCTIONS" ]
    }
    if (arm_fpu == "vfpv3-d16") {
      defines += [ "CAN_USE_VFP3_INSTRUCTIONS" ]
    } else if (arm_fpu == "vfpv3") {
      defines += [
        "CAN_USE_VFP3_INSTRUCTIONS",
        "CAN_USE_VFP32DREGS",
      ]
    } else if (arm_fpu == "neon") {
      defines += [
        "CAN_USE_VFP3_INSTRUCTIONS",
        "CAN_USE_VFP32DREGS",
        "CAN_USE_NEON",
      ]
    }

    # TODO(infra): Add support for arm_test_noprobe.

    if (current_cpu != "arm") {
      # These defines ares used for the ARM simulator.
      if (arm_float_abi == "hard") {
        defines += [ "USE_EABI_HARDFLOAT=1" ]
      } else if (arm_float_abi == "softfp") {
        defines += [ "USE_EABI_HARDFLOAT=0" ]
      }
    }
  }
  if (v8_current_cpu == "arm64") {
    defines += [ "V8_TARGET_ARCH_ARM64" ]
    if (current_cpu == "arm64" && v8_control_flow_integrity && is_clang) {
      # Mark assembly code as BTI-compatible.
      asmflags = [ "-mmark-bti-property" ]
    }
  }

  # Mips64el simulators.
  if (target_is_simulator && v8_current_cpu == "mips64el") {
    defines += [ "_MIPS_TARGET_SIMULATOR" ]
  }

  if (v8_current_cpu == "mips64el" || v8_current_cpu == "mips64") {
    defines += [ "V8_TARGET_ARCH_MIPS64" ]
    if (v8_can_use_fpu_instructions) {
      defines += [ "CAN_USE_FPU_INSTRUCTIONS" ]
    }
    if (mips_use_msa) {
      defines += [ "_MIPS_MSA" ]
    }
    if (host_byteorder == "little") {
      defines += [ "V8_TARGET_ARCH_MIPS64_LE" ]
    } else if (host_byteorder == "big") {
      defines += [ "V8_TARGET_ARCH_MIPS64_BE" ]
    }
    if (v8_use_mips_abi_hardfloat) {
      defines += [
        "__mips_hard_float=1",
        "CAN_USE_FPU_INSTRUCTIONS",
      ]
    } else {
      defines += [ "__mips_soft_float=1" ]
    }
    if (mips_arch_variant == "r6") {
      defines += [ "_MIPS_ARCH_MIPS64R6" ]
    } else if (mips_arch_variant == "r2") {
      defines += [ "_MIPS_ARCH_MIPS64R2" ]
    }
  }

  # loong64 simulators.
  if (target_is_simulator && v8_current_cpu == "loong64") {
    defines += [ "_LOONG64_TARGET_SIMULATOR" ]
  }
  if (v8_current_cpu == "loong64") {
    defines += [ "V8_TARGET_ARCH_LOONG64" ]
  }

  if (v8_current_cpu == "s390" || v8_current_cpu == "s390x") {
    defines += [ "V8_TARGET_ARCH_S390" ]
    cflags += [ "-ffp-contract=off" ]
    if (v8_current_cpu == "s390x") {
      defines += [ "V8_TARGET_ARCH_S390X" ]
    }
    if (host_byteorder == "little") {
      defines += [ "V8_TARGET_ARCH_S390_LE_SIM" ]
    } else if (current_os != "zos") {
      cflags += [ "-march=z196" ]
    }
  }
  if (v8_current_cpu == "ppc" || v8_current_cpu == "ppc64") {
    if (v8_current_cpu == "ppc") {
      defines += [ "V8_TARGET_ARCH_PPC" ]
    } else if (v8_current_cpu == "ppc64") {
      defines += [ "V8_TARGET_ARCH_PPC64" ]
      cflags += [ "-ffp-contract=off" ]
    }
    if (host_byteorder == "little") {
      defines += [ "V8_TARGET_ARCH_PPC_LE" ]
    } else if (host_byteorder == "big") {
      defines += [ "V8_TARGET_ARCH_PPC_BE" ]
      if (current_os == "aix") {
        cflags += [
          # Work around AIX ceil, trunc and round oddities.
          "-mcpu=power5+",
          "-mfprnd",

          # Work around AIX assembler popcntb bug.
          "-mno-popcntb",
        ]
      }
    }
  }

  # Under simulator build, compiler will not provide __riscv_xlen. Define here
  if (v8_current_cpu == "riscv64" || v8_current_cpu == "riscv32") {
    if (riscv_use_rvv || target_is_simulator) {
      defines += [ "CAN_USE_RVV_INSTRUCTIONS" ]
      defines += [ "RVV_VLEN=${riscv_rvv_vlen}" ]
    }
  }
  if (v8_current_cpu == "riscv64") {
    defines += [ "V8_TARGET_ARCH_RISCV64" ]
    defines += [ "__riscv_xlen=64" ]
    if (!is_clang) {
      cflags += [ "-ffp-contract=off" ]
    }
    if (riscv_use_sv39) {
      defines += [ "RISCV_USE_SV39" ]
    }
  }

  if (v8_current_cpu == "riscv32") {
    defines += [ "V8_TARGET_ARCH_RISCV32" ]
    defines += [ "__riscv_xlen=32" ]
  }

  if (v8_current_cpu == "x86") {
    defines += [ "V8_TARGET_ARCH_IA32" ]
    if (is_win) {
      # Ensure no surprising artifacts from 80bit double math with x86.
      cflags += [ "/arch:SSE2" ]
    }
  }
  if (v8_current_cpu == "x64") {
    defines += [ "V8_TARGET_ARCH_X64" ]
    if (is_win) {
      # Increase the initial stack size. The default is 1MB, this is 2MB. This
      # applies only to executables and shared libraries produced by V8 since
      # ldflags are not pushed to dependants.
      ldflags += [ "/STACK:2097152" ]
    }
  }
  if (is_android && v8_android_log_stdout) {
    defines += [ "V8_ANDROID_LOG_STDOUT" ]
  }

  # TODO(infra): Support v8_enable_prof on Windows.
  # TODO(infra): Add support for compiling with simulators.

  if (v8_enable_debugging_features || v8_dcheck_always_on) {
    defines += [ "DEBUG" ]
    if (v8_enable_slow_dchecks) {
      defines += [ "ENABLE_SLOW_DCHECKS" ]
    }
  } else {
    defines += [ "NDEBUG" ]
  }

  if (v8_enable_verify_csa) {
    defines += [ "ENABLE_VERIFY_CSA" ]
  }

  if (v8_enable_runtime_call_stats) {
    defines += [ "V8_RUNTIME_CALL_STATS" ]
  }

  if (v8_no_inline) {
    if (is_win) {
      cflags += [ "/Ob0" ]
    } else {
      cflags += [
        "-fno-inline-functions",
        "-fno-inline",
      ]
    }
  }

  if (is_clang) {
    cflags += [
      "-Wunreachable-code",

      # TODO(v8:12245): Fix shadowing instances and remove.
      "-Wno-shadow",
    ]

    # TODO(fuchsia:127411): Re-enable once FIDL bindings are compatible.
    if (!is_fuchsia) {
      # Google3 enables this warning, so we should also enable it to find issue
      # earlier. See https://reviews.llvm.org/D56731 for details about this
      # warning.
      cflags += [ "-Wctad-maybe-unsupported" ]
    }
  }

  if (is_clang || !is_win) {
    cflags += [
      # On clang and gcc, disable warnings about offsetof being used on
      # non-standard-layout types. offsetof is only specified for
      # standard-layout types, but its behaviour on non-standard-layout types is
      # implementation defined (rather than UB), and our supported compilers
      # have the expected reasonable behaviour.
      "-Wno-invalid-offsetof",
    ]
  }

  if (is_win) {
    cflags += [
      "/wd4245",  # Conversion with signed/unsigned mismatch.
      "/wd4267",  # Conversion with possible loss of data.
      "/wd4324",  # Padding structure due to alignment.
      "/wd4701",  # Potentially uninitialized local variable.
      "/wd4702",  # Unreachable code.
      "/wd4703",  # Potentially uninitialized local pointer variable.
      "/wd4709",  # Comma operator within array index expr (bugged).
      "/wd4714",  # Function marked forceinline not inlined.

      # MSVC assumes that control can get past an exhaustive switch and then
      # warns if there's no return there (see https://crbug.com/v8/7658)
      "/wd4715",  # Not all control paths return a value.

      "/wd4718",  # Recursive call has no side-effect.
      "/wd4723",  # https://crbug.com/v8/7771
      "/wd4724",  # https://crbug.com/v8/7771
      "/wd4800",  # Forcing value to bool.
    ]
  }

  if (!is_clang && is_win) {
    cflags += [
      "/wd4506",  # Benign "no definition for inline function"

      # Warnings permanently disabled:

      # C4091: 'typedef ': ignored on left of 'X' when no variable is
      #                    declared.
      # This happens in a number of Windows headers. Dumb.
      "/wd4091",

      # C4127: conditional expression is constant
      # This warning can in theory catch dead code and other problems, but
      # triggers in far too many desirable cases where the conditional
      # expression is either set by macros or corresponds some legitimate
      # compile-time constant expression (due to constant template args,
      # conditionals comparing the sizes of different types, etc.).  Some of
      # these can be worked around, but it's not worth it.
      "/wd4127",

      # C4251: 'identifier' : class 'type' needs to have dll-interface to be
      #        used by clients of class 'type2'
      # This is necessary for the shared library build.
      "/wd4251",

      # C4275:  non dll-interface class used as base for dll-interface class
      # This points out a potential (but rare) problem with referencing static
      # fields of a non-exported base, through the base's non-exported inline
      # functions, or directly. The warning is subtle enough that people just
      # suppressed it when they saw it, so it's not worth it.
      "/wd4275",

      # C4312 is a VS 2015 64-bit warning for integer to larger pointer.
      # TODO(brucedawson): fix warnings, crbug.com/554200
      "/wd4312",

      # C4324 warns when padding is added to fulfill alignas requirements,
      # but can trigger in benign cases that are difficult to individually
      # suppress.
      "/wd4324",

      # C4351: new behavior: elements of array 'array' will be default
      #        initialized
      # This is a silly "warning" that basically just alerts you that the
      # compiler is going to actually follow the language spec like it's
      # supposed to, instead of not following it like old buggy versions did.
      # There's absolutely no reason to turn this on.
      "/wd4351",

      # C4355: 'this': used in base member initializer list
      # It's commonly useful to pass |this| to objects in a class' initializer
      # list.  While this warning can catch real bugs, most of the time the
      # constructors in question don't attempt to call methods on the passed-in
      # pointer (until later), and annotating every legit usage of this is
      # simply more hassle than the warning is worth.
      "/wd4355",

      # C4503: 'identifier': decorated name length exceeded, name was
      #        truncated
      # This only means that some long error messages might have truncated
      # identifiers in the presence of lots of templates.  It has no effect on
      # program correctness and there's no real reason to waste time trying to
      # prevent it.
      "/wd4503",

      # Warning C4589 says: "Constructor of abstract class ignores
      # initializer for virtual base class." Disable this warning because it
      # is flaky in VS 2015 RTM. It triggers on compiler generated
      # copy-constructors in some cases.
      "/wd4589",

      # C4611: interaction between 'function' and C++ object destruction is
      #        non-portable
      # This warning is unavoidable when using e.g. setjmp/longjmp.  MSDN
      # suggests using exceptions instead of setjmp/longjmp for C++, but
      # Chromium code compiles without exception support.  We therefore have to
      # use setjmp/longjmp for e.g. JPEG decode error handling, which means we
      # have to turn off this warning (and be careful about how object
      # destruction happens in such cases).
      "/wd4611",

      # Warnings to evaluate and possibly fix/reenable later:

      "/wd4100",  # Unreferenced formal function parameter.
      "/wd4121",  # Alignment of a member was sensitive to packing.
      "/wd4244",  # Conversion: possible loss of data.
      "/wd4505",  # Unreferenced local function has been removed.
      "/wd4510",  # Default constructor could not be generated.
      "/wd4512",  # Assignment operator could not be generated.
      "/wd4610",  # Class can never be instantiated, constructor required.
      "/wd4838",  # Narrowing conversion. Doesn't seem to be very useful.
      "/wd4995",  # 'X': name was marked as #pragma deprecated
      "/wd4996",  # Deprecated function warning.

      # These are variable shadowing warnings that are new in VS2015. We
      # should work through these at some point -- they may be removed from
      # the RTM release in the /W4 set.
      "/wd4456",
      "/wd4457",
      "/wd4458",
      "/wd4459",

      # All of our compilers support the extensions below.
      "/wd4200",  # nonstandard extension used: zero-sized array in struct/union
      "/wd4201",  # nonstandard extension used: nameless struct/union
      "/wd4204",  # nonstandard extension used : non-constant aggregate
                  # initializer

      "/wd4221",  # nonstandard extension used : 'identifier' : cannot be
                  # initialized using address of automatic variable

      # http://crbug.com/588506 - Conversion suppressions waiting on Clang
      # -Wconversion.
      "/wd4245",  # 'conversion' : conversion from 'type1' to 'type2',
                  # signed/unsigned mismatch

      "/wd4267",  # 'var' : conversion from 'size_t' to 'type', possible loss of
                  # data

      "/wd4305",  # 'identifier' : truncation from 'type1' to 'type2'
      "/wd4389",  # 'operator' : signed/unsigned mismatch

      "/wd4702",  # unreachable code

      # http://crbug.com/848979 - MSVC is more conservative than Clang with
      # regards to variables initialized and consumed in different branches.
      "/wd4701",  # Potentially uninitialized local variable 'name' used
      "/wd4703",  # Potentially uninitialized local pointer variable 'name' used

      # http://crbug.com/848979 - Remaining Clang permitted warnings.
      "/wd4661",  # 'identifier' : no suitable definition provided for explicit
                  # template instantiation request

      "/wd4706",  # assignment within conditional expression
                  # MSVC is stricter and requires a boolean expression.

      "/wd4715",  # 'function' : not all control paths return a value'
                  # MSVC does not analyze switch (enum) for completeness.
    ]
  }

  if (!is_clang && !is_win) {
    cflags += [
      # Disable gcc warnings for optimizations based on the assumption that
      # signed overflow does not occur. Generates false positives (see
      # http://crbug.com/v8/6341).
      "-Wno-strict-overflow",

      # GCC assumes that control can get past an exhaustive switch and then
      # warns if there's no return there (see https://crbug.com/v8/7658).
      "-Wno-return-type",

      # Disable gcc warnings for using enum constant in boolean context.
      # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=97266
      "-Wno-int-in-bool-context",

      # Disable gcc deprecation warnings, which are firing on implicit capture
      # of `this` in capture-by-value lambdas and preventing a build roll which
      # enables C++20 (see https://crbug.com/1374227).
      "-Wno-deprecated",

      # Fix build with older versions of GCC
      # Ported from v8 bazel: https://crrev.com/c/3368869
      "-Wno-stringop-overflow",

      # Fix a number of bogus errors with gcc12
      # TODO(miladfarca): re-evaluate for future gcc upgrades
      # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=111499
      "-Wno-stringop-overread",

      # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=104336
      "-Wno-restrict",

      # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105523
      "-Wno-array-bounds",

      # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=108517
      "-Wno-nonnull",

      # Disable dangling pointer warnings, which are often false positives when
      # using scopes.
      "-Wno-dangling-pointer",
    ]
  }

  # Chromium uses a hand-picked subset of UBSan coverage. We want everything.
  if (is_ubsan) {
    cflags += [ "-fsanitize=undefined" ]
  }
}

config("strict_warnings") {
  cflags = []
  if (is_clang) {
    if (v8_current_cpu == "x64" || v8_current_cpu == "arm64" ||
        v8_current_cpu == "mips64el" || v8_current_cpu == "riscv64") {
      cflags += [ "-Wshorten-64-to-32" ]
    }
    cflags += [ "-Wmissing-field-initializers" ]
  }
}

# For code that is hot during mksnapshot. In fast-mksnapshot builds, we
# optimize some files even in debug builds to speed up mksnapshot times.
config("always_turbofanimize") {
  configs = [ ":internal_config" ]

  # TODO(crbug.com/621335) Rework this so that we don't have the confusion
  # between "optimize_speed" and "optimize_max".
  if (((is_posix && !is_android) || is_fuchsia || is_win) && !using_sanitizer) {
    configs += [ "//build/config/compiler:optimize_speed" ]
  } else {
    configs += [ "//build/config/compiler:optimize_max" ]
  }
}

###############################################################################
# Actions
#

# Only for Windows clang builds. Converts the embedded.S file produced by
# mksnapshot into an embedded.cc file with corresponding inline assembly.
template("asm_to_inline_asm") {
  name = target_name
  if (name == "default") {
    suffix = ""
  } else {
    suffix = "_$name"
  }

  action("asm_to_inline_asm_" + name) {
    visibility = [ ":*" ]  # Only targets in this file can depend on this.

    assert(emit_builtins_as_inline_asm)

    script = "tools/snapshot/asm_to_inline_asm.py"
    deps = [ ":run_mksnapshot_" + name ]
    sources = [ "$target_gen_dir/embedded${suffix}.S" ]
    outputs = [ "$target_gen_dir/embedded${suffix}.cc" ]
    args = invoker.args
    args += [
      rebase_path("$target_gen_dir/embedded${suffix}.S", root_build_dir),
      rebase_path("$target_gen_dir/embedded${suffix}.cc", root_build_dir),
    ]
  }
}

if (v8_postmortem_support) {
  action("postmortem-metadata") {
    # Only targets in this file can depend on this.
    visibility = [ ":*" ]

    script = "tools/gen-postmortem-metadata.py"

    # NOSORT
    inputs = [
      "$target_gen_dir/torque-generated/instance-types.h",
      "src/objects/allocation-site.h",
      "src/objects/allocation-site-inl.h",
      "src/objects/cell.h",
      "src/objects/cell-inl.h",
      "src/objects/dependent-code.h",
      "src/objects/dependent-code-inl.h",
      "src/objects/bytecode-array.h",
      "src/objects/bytecode-array-inl.h",
      "src/objects/abstract-code.h",
      "src/objects/abstract-code-inl.h",
      "src/objects/instruction-stream.h",
      "src/objects/instruction-stream-inl.h",
      "src/objects/casting.h",
      "src/objects/code.h",
      "src/objects/code-inl.h",
      "src/objects/data-handler.h",
      "src/objects/data-handler-inl.h",
      "src/objects/deoptimization-data.h",
      "src/objects/deoptimization-data-inl.h",
      "src/objects/descriptor-array.h",
      "src/objects/descriptor-array-inl.h",
      "src/objects/feedback-cell.h",
      "src/objects/feedback-cell-inl.h",
      "src/objects/fixed-array.h",
      "src/objects/fixed-array-inl.h",
      "src/objects/heap-number.h",
      "src/objects/heap-number-inl.h",
      "src/objects/heap-object.h",
      "src/objects/heap-object-inl.h",
      "src/objects/instance-type.h",
      "src/objects/instance-type-checker.h",
      "src/objects/instance-type-inl.h",
      "src/objects/js-array-buffer.h",
      "src/objects/js-array-buffer-inl.h",
      "src/objects/js-array.h",
      "src/objects/js-array-inl.h",
      "src/objects/js-function-inl.h",
      "src/objects/js-function.cc",
      "src/objects/js-function.h",
      "src/objects/js-objects.cc",
      "src/objects/js-objects.h",
      "src/objects/js-objects-inl.h",
      "src/objects/js-promise.h",
      "src/objects/js-promise-inl.h",
      "src/objects/js-raw-json.cc",
      "src/objects/js-raw-json.h",
      "src/objects/js-raw-json-inl.h",
      "src/objects/js-regexp.cc",
      "src/objects/js-regexp.h",
      "src/objects/js-regexp-inl.h",
      "src/objects/js-regexp-string-iterator.h",
      "src/objects/js-regexp-string-iterator-inl.h",
      "src/objects/map.cc",
      "src/objects/map.h",
      "src/objects/map-inl.h",
      "src/objects/megadom-handler.h",
      "src/objects/megadom-handler-inl.h",
      "src/objects/name.h",
      "src/objects/name-inl.h",
      "src/objects/objects.h",
      "src/objects/objects-inl.h",
      "src/objects/oddball.h",
      "src/objects/oddball-inl.h",
      "src/objects/primitive-heap-object.h",
      "src/objects/primitive-heap-object-inl.h",
      "src/objects/scope-info.h",
      "src/objects/scope-info-inl.h",
      "src/objects/script.h",
      "src/objects/script-inl.h",
      "src/objects/shared-function-info.cc",
      "src/objects/shared-function-info.h",
      "src/objects/shared-function-info-inl.h",
      "src/objects/string.cc",
      "src/objects/string-comparator.cc",
      "src/objects/string-comparator.h",
      "src/objects/string.h",
      "src/objects/string-inl.h",
      "src/objects/struct.h",
      "src/objects/struct-inl.h",
      "src/objects/tagged.h",
      "src/objects/union.h",
    ]

    outputs = [ "$target_gen_dir/debug-support.cc" ]

    args = rebase_path(outputs, root_build_dir) +
           rebase_path(inputs, root_build_dir)

    deps = [ ":run_torque" ]
  }
}

torque_files = [
  "src/builtins/aggregate-error.tq",
  "src/builtins/array-at.tq",
  "src/builtins/array-concat.tq",
  "src/builtins/array-copywithin.tq",
  "src/builtins/array-every.tq",
  "src/builtins/array-filter.tq",
  "src/builtins/array-find.tq",
  "src/builtins/array-findindex.tq",
  "src/builtins/array-findlast.tq",
  "src/builtins/array-findlastindex.tq",
  "src/builtins/array-flat.tq",
  "src/builtins/array-foreach.tq",
  "src/builtins/array-from-async.tq",
  "src/builtins/array-from.tq",
  "src/builtins/array-isarray.tq",
  "src/builtins/array-join.tq",
  "src/builtins/array-lastindexof.tq",
  "src/builtins/array-map.tq",
  "src/builtins/array-of.tq",
  "src/builtins/array-reduce-right.tq",
  "src/builtins/array-reduce.tq",
  "src/builtins/array-reverse.tq",
  "src/builtins/array-shift.tq",
  "src/builtins/array-slice.tq",
  "src/builtins/array-some.tq",
  "src/builtins/array-splice.tq",
  "src/builtins/array-to-reversed.tq",
  "src/builtins/array-to-sorted.tq",
  "src/builtins/array-to-spliced.tq",
  "src/builtins/array-unshift.tq",
  "src/builtins/array-with.tq",
  "src/builtins/array.tq",
  "src/builtins/arraybuffer.tq",
  "src/builtins/base.tq",
  "src/builtins/boolean.tq",
  "src/builtins/builtins-bigint.tq",
  "src/builtins/builtins-string.tq",
  "src/builtins/cast.tq",
  "src/builtins/collections.tq",
  "src/builtins/constructor.tq",
  "src/builtins/conversion.tq",
  "src/builtins/convert.tq",
  "src/builtins/console.tq",
  "src/builtins/data-view.tq",
  "src/builtins/finalization-registry.tq",
  "src/builtins/frames.tq",
  "src/builtins/frame-arguments.tq",
  "src/builtins/function.tq",
  "src/builtins/growable-fixed-array.tq",
  "src/builtins/ic-callable.tq",
  "src/builtins/ic.tq",
  "src/builtins/internal-coverage.tq",
  "src/builtins/internal.tq",
  "src/builtins/iterator.tq",
  "src/builtins/iterator-from.tq",
  "src/builtins/iterator-helpers.tq",
  "src/builtins/map-groupby.tq",
  "src/builtins/math.tq",
  "src/builtins/number.tq",
  "src/builtins/object-fromentries.tq",
  "src/builtins/object-groupby.tq",
  "src/builtins/object.tq",
  "src/builtins/promise-abstract-operations.tq",
  "src/builtins/promise-all.tq",
  "src/builtins/promise-all-element-closure.tq",
  "src/builtins/promise-any.tq",
  "src/builtins/promise-constructor.tq",
  "src/builtins/promise-finally.tq",
  "src/builtins/promise-jobs.tq",
  "src/builtins/promise-misc.tq",
  "src/builtins/promise-race.tq",
  "src/builtins/promise-reaction-job.tq",
  "src/builtins/promise-resolve.tq",
  "src/builtins/promise-then.tq",
  "src/builtins/promise-try.tq",
  "src/builtins/promise-withresolvers.tq",
  "src/builtins/proxy-constructor.tq",
  "src/builtins/proxy-delete-property.tq",
  "src/builtins/proxy-get-property.tq",
  "src/builtins/proxy-get-prototype-of.tq",
  "src/builtins/proxy-has-property.tq",
  "src/builtins/proxy-is-extensible.tq",
  "src/builtins/proxy-prevent-extensions.tq",
  "src/builtins/proxy-revocable.tq",
  "src/builtins/proxy-revoke.tq",
  "src/builtins/proxy-set-property.tq",
  "src/builtins/proxy-set-prototype-of.tq",
  "src/builtins/proxy.tq",
  "src/builtins/reflect.tq",
  "src/builtins/regexp-exec.tq",
  "src/builtins/regexp-match-all.tq",
  "src/builtins/regexp-match.tq",
  "src/builtins/regexp-replace.tq",
  "src/builtins/regexp-search.tq",
  "src/builtins/regexp-source.tq",
  "src/builtins/regexp-split.tq",
  "src/builtins/regexp-test.tq",
  "src/builtins/regexp.tq",
  "src/builtins/set-difference.tq",
  "src/builtins/set-intersection.tq",
  "src/builtins/set-is-disjoint-from.tq",
  "src/builtins/set-is-subset-of.tq",
  "src/builtins/set-is-superset-of.tq",
  "src/builtins/set-symmetric-difference.tq",
  "src/builtins/set-union.tq",
  "src/builtins/string-at.tq",
  "src/builtins/string-endswith.tq",
  "src/builtins/string-html.tq",
  "src/builtins/string-includes.tq",
  "src/builtins/string-indexof.tq",
  "src/builtins/string-iswellformed.tq",
  "src/builtins/string-iterator.tq",
  "src/builtins/string-match-search.tq",
  "src/builtins/string-pad.tq",
  "src/builtins/string-repeat.tq",
  "src/builtins/string-replaceall.tq",
  "src/builtins/string-slice.tq",
  "src/builtins/string-startswith.tq",
  "src/builtins/string-substr.tq",
  "src/builtins/string-substring.tq",
  "src/builtins/string-towellformed.tq",
  "src/builtins/string-trim.tq",
  "src/builtins/suppressed-error.tq",
  "src/builtins/symbol.tq",
  "src/builtins/torque-internal.tq",
  "src/builtins/typed-array-at.tq",
  "src/builtins/typed-array-createtypedarray.tq",
  "src/builtins/typed-array-every.tq",
  "src/builtins/typed-array-entries.tq",
  "src/builtins/typed-array-filter.tq",
  "src/builtins/typed-array-find.tq",
  "src/builtins/typed-array-findindex.tq",
  "src/builtins/typed-array-findlast.tq",
  "src/builtins/typed-array-findlastindex.tq",
  "src/builtins/typed-array-foreach.tq",
  "src/builtins/typed-array-from.tq",
  "src/builtins/typed-array-keys.tq",
  "src/builtins/typed-array-of.tq",
  "src/builtins/typed-array-reduce.tq",
  "src/builtins/typed-array-reduceright.tq",
  "src/builtins/typed-array-set.tq",
  "src/builtins/typed-array-slice.tq",
  "src/builtins/typed-array-some.tq",
  "src/builtins/typed-array-sort.tq",
  "src/builtins/typed-array-subarray.tq",
  "src/builtins/typed-array-to-reversed.tq",
  "src/builtins/typed-array-to-sorted.tq",
  "src/builtins/typed-array-values.tq",
  "src/builtins/typed-array-with.tq",
  "src/builtins/typed-array.tq",
  "src/builtins/weak-ref.tq",
  "src/ic/handler-configuration.tq",
  "src/objects/allocation-site.tq",
  "src/objects/api-callbacks.tq",
  "src/objects/arguments.tq",
  "src/objects/bigint.tq",
  "src/objects/call-site-info.tq",
  "src/objects/cell.tq",
  "src/objects/bytecode-array.tq",
  "src/objects/contexts.tq",
  "src/objects/data-handler.tq",
  "src/objects/debug-objects.tq",
  "src/objects/descriptor-array.tq",
  "src/objects/embedder-data-array.tq",
  "src/objects/feedback-cell.tq",
  "src/objects/feedback-vector.tq",
  "src/objects/fixed-array.tq",
  "src/objects/foreign.tq",
  "src/objects/free-space.tq",
  "src/objects/heap-number.tq",
  "src/objects/heap-object.tq",
  "src/objects/js-array-buffer.tq",
  "src/objects/js-array.tq",
  "src/objects/js-atomics-synchronization.tq",
  "src/objects/js-collection-iterator.tq",
  "src/objects/js-collection.tq",
  "src/objects/js-disposable-stack.tq",
  "src/objects/js-function.tq",
  "src/objects/js-generator.tq",
  "src/objects/js-iterator-helpers.tq",
  "src/objects/js-objects.tq",
  "src/objects/js-promise.tq",
  "src/objects/js-proxy.tq",
  "src/objects/js-raw-json.tq",
  "src/objects/js-regexp-string-iterator.tq",
  "src/objects/js-regexp.tq",
  "src/objects/js-shadow-realm.tq",
  "src/objects/js-shared-array.tq",
  "src/objects/js-struct.tq",
  "src/objects/js-temporal-objects.tq",
  "src/objects/js-weak-refs.tq",
  "src/objects/literal-objects.tq",
  "src/objects/map.tq",
  "src/objects/megadom-handler.tq",
  "src/objects/microtask.tq",
  "src/objects/module.tq",
  "src/objects/name.tq",
  "src/objects/oddball.tq",
  "src/objects/hole.tq",
  "src/objects/trusted-object.tq",
  "src/objects/ordered-hash-table.tq",
  "src/objects/primitive-heap-object.tq",
  "src/objects/promise.tq",
  "src/objects/property-array.tq",
  "src/objects/property-cell.tq",
  "src/objects/property-descriptor-object.tq",
  "src/objects/prototype-info.tq",
  "src/objects/regexp-match-info.tq",
  "src/objects/scope-info.tq",
  "src/objects/script.tq",
  "src/objects/shared-function-info.tq",
  "src/objects/source-text-module.tq",
  "src/objects/string.tq",
  "src/objects/struct.tq",
  "src/objects/swiss-hash-table-helpers.tq",
  "src/objects/swiss-name-dictionary.tq",
  "src/objects/synthetic-module.tq",
  "src/objects/template-objects.tq",
  "src/objects/templates.tq",
  "src/objects/torque-defined-classes.tq",
  "src/objects/turbofan-types.tq",
  "src/objects/turboshaft-types.tq",
  "test/torque/test-torque.tq",
  "third_party/v8/builtins/array-sort.tq",
]

if (v8_enable_i18n_support) {
  torque_files += [
    "src/objects/intl-objects.tq",
    "src/objects/js-break-iterator.tq",
    "src/objects/js-collator.tq",
    "src/objects/js-date-time-format.tq",
    "src/objects/js-display-names.tq",
    "src/objects/js-duration-format.tq",
    "src/objects/js-list-format.tq",
    "src/objects/js-locale.tq",
    "src/objects/js-number-format.tq",
    "src/objects/js-plural-rules.tq",
    "src/objects/js-relative-time-format.tq",
    "src/objects/js-segment-iterator.tq",
    "src/objects/js-segmenter.tq",
    "src/objects/js-segments.tq",
  ]
}

if (v8_enable_webassembly) {
  torque_files += [
    "src/builtins/js-to-js.tq",
    "src/builtins/js-to-wasm.tq",
    "src/builtins/wasm.tq",
    "src/builtins/wasm-strings.tq",
    "src/builtins/wasm-to-js.tq",
    "src/debug/debug-wasm-objects.tq",
    "src/wasm/wasm-objects.tq",
  ]
}

# Template for running torque
# When building with v8_verify_torque_generation_invariance=true we need
# to be able to run torque for both 32 and 64 bits in the same build
template("run_torque") {
  if (target_name == "") {
    suffix = ""
  } else {
    suffix = "_$target_name"
  }

  toolchain = invoker.toolchain

  action("run_torque" + suffix) {
    visibility = [
      ":*",
      "test/cctest/:*",
      "tools/debug_helper/:*",
      "tools/gcmole/:*",
    ]

    deps = [ ":torque($toolchain)" ]

    script = "tools/run.py"

    sources = torque_files

    destination_folder = "$target_gen_dir/torque-generated$suffix"

    outputs = [
      "$destination_folder/bit-fields.h",
      "$destination_folder/builtin-definitions.h",
      "$destination_folder/class-debug-readers.cc",
      "$destination_folder/class-debug-readers.h",
      "$destination_folder/class-forward-declarations.h",
      "$destination_folder/class-verifiers.cc",
      "$destination_folder/class-verifiers.h",
      "$destination_folder/csa-types.h",
      "$destination_folder/debug-macros.cc",
      "$destination_folder/debug-macros.h",
      "$destination_folder/enum-verifiers.cc",
      "$destination_folder/exported-macros-assembler.cc",
      "$destination_folder/exported-macros-assembler.h",
      "$destination_folder/factory.cc",
      "$destination_folder/factory.inc",
      "$destination_folder/instance-types.h",
      "$destination_folder/interface-descriptors.inc",
      "$destination_folder/objects-body-descriptors-inl.inc",
      "$destination_folder/objects-printer.cc",
      "$destination_folder/visitor-lists.h",
    ]

    foreach(file, torque_files) {
      filetq = string_replace(file, ".tq", "-tq")
      outputs += [
        "$destination_folder/$filetq-csa.cc",
        "$destination_folder/$filetq-csa.h",
        "$destination_folder/$filetq-inl.inc",
        "$destination_folder/$filetq.cc",
        "$destination_folder/$filetq.inc",
      ]
    }

    args = [
      "./" + rebase_path(
              get_label_info(":torque($toolchain)", "root_out_dir") + "/torque",
              root_build_dir),
      "-o",
      rebase_path("$destination_folder", root_build_dir),
      "-v8-root",
      rebase_path(".", root_build_dir),
    ]
    if (v8_annotate_torque_ir) {
      args += [ "-annotate-ir" ]
    }
    if (defined(invoker.args)) {
      args += invoker.args
    }
    args += torque_files
  }
}

# Default run_torque action
run_torque("") {
  toolchain = v8_generator_toolchain
}

if (v8_verify_torque_generation_invariance) {
  run_torque("x86") {
    toolchain = "//build/toolchain/linux:clang_x86"
  }

  run_torque("x64") {
    args = [ "-m32" ]
    toolchain = "//build/toolchain/linux:clang_x64"
  }

  action("compare_torque_runs") {
    deps = [
      ":run_torque_x64",
      ":run_torque_x86",
    ]
    report_file = "$target_gen_dir/torque_comparison_results.txt"
    script = "tools/compare_torque_output.py"
    args = [
      rebase_path("$target_gen_dir/torque-generated_x64", root_build_dir),
      rebase_path("$target_gen_dir/torque-generated_x86", root_build_dir),
      rebase_path(report_file, root_build_dir),
    ]
    outputs = [ report_file ]
  }
}

group("v8_maybe_icu") {
  if (v8_enable_i18n_support) {
    public_deps = [ v8_icu_path ]
  }
}

group("v8_abseil") {
  public_deps = [ "//third_party/abseil-cpp:absl" ]

  public_configs = [
    "//third_party/abseil-cpp:absl_define_config",
    "//third_party/abseil-cpp:absl_include_config",
  ]
}

group("zoslib") {
  if (current_os == "zos") {
    deps = [ "//third_party/zoslib" ]
  }
}

v8_header_set("torque_runtime_support") {
  visibility = [ ":*" ]

  sources = [ "src/torque/runtime-support.h" ]

  configs = [ ":internal_config" ]
}

v8_source_set("torque_generated_initializers") {
  visibility = [ ":*" ]  # Only targets in this file can depend on this.

  deps = [
    ":generate_bytecode_builtins_list",
    ":run_torque",
    ":v8_base_without_compiler",
    ":v8_tracing",
  ]

  public_deps = [
    ":torque_runtime_support",
    ":v8_abseil",
    ":v8_maybe_icu",
  ]

  sources = [
    "$target_gen_dir/torque-generated/csa-types.h",
    "$target_gen_dir/torque-generated/enum-verifiers.cc",
    "$target_gen_dir/torque-generated/exported-macros-assembler.cc",
    "$target_gen_dir/torque-generated/exported-macros-assembler.h",
  ]
  foreach(file, torque_files) {
    filetq = string_replace(file, ".tq", "-tq")
    sources += [
      "$target_gen_dir/torque-generated/$filetq-csa.cc",
      "$target_gen_dir/torque-generated/$filetq-csa.h",
    ]
  }

  configs = [ ":internal_config" ]

  if (v8_symbol_level > 1) {
    # Symbols cause huge compile time on some bigger torque files, see
    # https://crbug.com/1472715. Thus remove any symbol configs added in v8.gni
    # and instead add the "minimal_symbols" config.
    v8_add_configs -=
        filter_include(v8_add_configs, [ "//build/config/compiler:*symbols" ])
    if (v8_symbol_level == symbol_level) {
      v8_remove_configs += [ "//build/config/compiler:default_symbols" ]
    }
    configs += [ "//build/config/compiler:minimal_symbols" ]
  }
}

v8_source_set("torque_generated_definitions") {
  visibility = [ ":*" ]  # Only targets in this file can depend on this.

  deps = [
    ":generate_bytecode_builtins_list",
    ":run_torque",
    ":v8_internal_headers",
    ":v8_libbase",
    ":v8_tracing",
  ]

  public_deps = [
    ":v8_abseil",
    ":v8_maybe_icu",
  ]

  sources = [
    "$target_gen_dir/torque-generated/class-forward-declarations.h",
    "$target_gen_dir/torque-generated/class-verifiers.cc",
    "$target_gen_dir/torque-generated/class-verifiers.h",
    "$target_gen_dir/torque-generated/factory.cc",
    "$target_gen_dir/torque-generated/objects-printer.cc",
  ]
  foreach(file, torque_files) {
    filetq = string_replace(file, ".tq", "-tq")
    sources += [
      "$target_gen_dir/torque-generated/$filetq-inl.inc",
      "$target_gen_dir/torque-generated/$filetq.cc",
      "$target_gen_dir/torque-generated/$filetq.inc",
    ]
  }

  configs = [ ":internal_config" ]
}

action("generate_bytecode_builtins_list") {
  script = "tools/run.py"
  outputs = [ "$target_gen_dir/builtins-generated/bytecodes-builtins-list.h" ]
  deps = [ ":bytecode_builtins_list_generator($v8_generator_toolchain)" ]
  args = [
    "./" + rebase_path(
            get_label_info(
                    ":bytecode_builtins_list_generator($v8_generator_toolchain)",
                    "root_out_dir") + "/bytecode_builtins_list_generator",
            root_build_dir),
    rebase_path("$target_gen_dir/builtins-generated/bytecodes-builtins-list.h",
                root_build_dir),
  ]
}

# Template to generate different V8 snapshots based on different runtime flags.
# Can be invoked with run_mksnapshot(<name>). The target will resolve to
# run_mksnapshot_<name>. If <name> is "default", no file suffixes will be used.
# Otherwise files are suffixed, e.g. embedded_<name>.S and
# snapshot_blob_<name>.bin.
#
# The template exposes the variables:
#   args: additional flags for mksnapshots
#   embedded_suffix: a camel case suffix for method names in the embedded
#       snapshot.
template("run_mksnapshot") {
  name = target_name
  if (name == "default") {
    suffix = ""
  } else {
    suffix = "_$name"
  }
  action("run_mksnapshot_" + name) {
    deps = [ ":mksnapshot($v8_snapshot_toolchain)" ]

    script = "tools/run.py"

    sources = []

    if (icu_use_data_file) {
      deps += [ "//third_party/icu:copy_icudata" ]
      if (host_byteorder == "big") {
        sources += [ "$root_out_dir/icudtb.dat" ]
      } else {
        sources += [ "$root_out_dir/icudtl.dat" ]
      }
    }

    outputs = []

    data = []

    if (current_os != "zos") {
      ext = "S"
    } else {
      ext = "s"
    }

    args = [
      "./" + rebase_path(get_label_info(":mksnapshot($v8_snapshot_toolchain)",
                                        "root_out_dir") + "/mksnapshot",
                         root_build_dir),
      "--turbo_instruction_scheduling",
      "--stress-turbo-late-spilling",

      # In cross builds, the snapshot may be generated for both the host and
      # target toolchains.  The same host binary is used to generate both, so
      # mksnapshot needs to know which target OS to use at runtime.  It's weird,
      # but the target OS is really |current_os|.
      "--target_os=$current_os",
      "--target_arch=$current_cpu",

      "--embedded_src",
      rebase_path("$target_gen_dir/embedded${suffix}.${ext}", root_build_dir),
    ]

    if (v8_log_builtins_block_count_input != "") {
      args += [
        "--trace-turbo",

        "--turbo-log-builtins-count-input",
        v8_log_builtins_block_count_input,
      ]
    }

    if (v8_enable_builtins_profiling) {
      args += [ "--turbo-profiling" ]
    }
    if (v8_enable_builtins_profiling_verbose) {
      args += [ "--turbo-profiling-verbose" ]
    }
    if (v8_builtins_profiling_log_file != "") {
      sources += [ v8_builtins_profiling_log_file ]
      args += [
        "--turbo-profiling-input",
        rebase_path(v8_builtins_profiling_log_file, root_build_dir),

        # Replace this with --warn-about-builtin-profile-data to see the full
        # list of builtins with incompatible profiles.
        "--abort-on-bad-builtin-profile-data",
      ]

      if (!v8_enable_builtins_profiling && v8_enable_builtins_reordering) {
        args += [ "--reorder-builtins" ]
      }
    }

    if (v8_enable_turboshaft_csa) {
      args += [ "--turboshaft-csa" ]
    }

    # This is needed to distinguish between generating code for the simulator
    # and cross-compiling. The latter may need to run code on the host with the
    # simulator but cannot use simulator-specific instructions.
    if (target_is_simulator) {
      args += [ "--target_is_simulator" ]
    }

    args += invoker.args

    outputs += [ "$target_gen_dir/embedded${suffix}.${ext}" ]
    if (invoker.embedded_variant != "") {
      args += [
        "--embedded_variant",
        invoker.embedded_variant,
      ]
    }

    if (v8_random_seed != "0") {
      args += [
        "--random-seed",
        v8_random_seed,
      ]
    }

    if (v8_os_page_size != "0") {
      args += [
        "--v8_os_page_size",
        v8_os_page_size,
      ]
    }

    if (v8_use_external_startup_data) {
      outputs += [ "$root_out_dir/snapshot_blob${suffix}.bin" ]
      data += [ "$root_out_dir/snapshot_blob${suffix}.bin" ]
      args += [
        "--startup_blob",
        rebase_path("$root_out_dir/snapshot_blob${suffix}.bin", root_build_dir),
      ]
    } else {
      outputs += [ "$target_gen_dir/snapshot${suffix}.cc" ]
      args += [
        "--startup_src",
        rebase_path("$target_gen_dir/snapshot${suffix}.cc", root_build_dir),
      ]
    }

    if (v8_embed_script != "") {
      sources += [ v8_embed_script ]
      args += [ rebase_path(v8_embed_script, root_build_dir) ]
    }

    if (v8_enable_snapshot_code_comments) {
      args += [ "--code-comments" ]
    }

    if (v8_enable_snapshot_native_code_counters) {
      args += [ "--native-code-counters" ]
    } else {
      # --native-code-counters is the default in debug mode so make sure we can
      # unset it.
      args += [ "--no-native-code-counters" ]
    }

    if (v8_enable_fast_mksnapshot) {
      args += [ "--no-turbo-verify-allocation" ]

      if (v8_current_cpu == "x86" || v8_current_cpu == "x64") {
        args += [ "--no-turbo-rewrite-far-jumps" ]
      }

      if (v8_enable_debugging_features && v8_enable_slow_dchecks) {
        # mksnapshot only accepts this flag if ENABLE_SLOW_DCHECKS is defined.
        args += [ "--no-enable-slow-asserts" ]
      }
    }

    if (v8_enable_verify_heap) {
      args += [ "--verify-heap" ]
    }
  }
}

run_mksnapshot("default") {
  args = []
  embedded_variant = "Default"
}
if (emit_builtins_as_inline_asm) {
  asm_to_inline_asm("default") {
    args = []
  }
}

if (v8_verify_deterministic_mksnapshot) {
  runs = [
    "run_0",
    "run_1",
    "run_2",
    "run_3",
    "run_4",
    "run_5",
    "run_6",
  ]

  foreach(i, runs) {
    run_mksnapshot(i) {
      args = []
      embedded_variant = "Default"
    }
  }

  action("verify_deterministic_mksnapshot") {
    deps = []
    foreach(i, runs) {
      deps += [ ":run_mksnapshot_$i" ]
    }
    report_file = "$target_gen_dir/mksnapshot_comparison.txt"
    script = "tools/snapshot/compare_mksnapshot_output.py"
    args = [
      rebase_path("$report_file", root_build_dir),
      rebase_path("$target_gen_dir", root_build_dir),
      rebase_path("$root_out_dir", root_build_dir),
      "7",  # Length of the 'runs' list.
    ]
    outputs = [ report_file ]
  }
}

if (v8_verify_builtins_compatibility) {
  # This specifies a separate mksnapshot target for each of:
  # x86, x64, arm, arm64.
  hashes = "builtins_hashes_$v8_current_cpu"
  run_mksnapshot("dump_$v8_current_cpu") {
    args = [
      "--dump-builtins-hashes-to-file",
      hashes,
    ]
    embedded_variant = "Default"
  }

  # This template defines a comparison action for the architecture the pgo
  # profile is made for (e.g. x64) and the architecture the profile is used
  # for (e.g. arm64 with toolchain x64_v8_arm64).
  template("verify_builtins_hashes") {
    forward_variables_from(invoker,
                           [
                             "profile_arch",
                             "target_arch",
                           ])
    profile_toolchain = "//build/toolchain/linux:clang_${profile_arch}"
    target_toolchain =
        "//build/toolchain/linux:clang_${profile_arch}_v8_${target_arch}"
    action("compare_builtins_$target_name") {
      deps = [
        ":run_mksnapshot_dump_${profile_arch}($profile_toolchain)",
        ":run_mksnapshot_dump_${target_arch}($target_toolchain)",
      ]
      report_file = "$root_build_dir/builtins_comparison_$target_name"
      script = "tools/builtins-pgo/assert_builtins_hashes.py"
      args = [
        "builtins_hashes_${profile_arch}",
        "builtins_hashes_${target_arch}",
        rebase_path(report_file, root_build_dir),
      ]
      outputs = [ report_file ]
    }
  }

  verify_builtins_hashes("x86_arm") {
    profile_arch = "x86"
    target_arch = "arm"
  }

  verify_builtins_hashes("x64_arm64") {
    profile_arch = "x64"
    target_arch = "arm64"
  }

  group("verify_all_builtins_hashes") {
    deps = [
      ":compare_builtins_x64_arm64",
      ":compare_builtins_x86_arm",
    ]
  }
}

action("v8_dump_build_config") {
  script = "tools/testrunner/utils/dump_build_config.py"
  outputs = [ "$root_out_dir/v8_build_config.json" ]
  is_DEBUG_defined = v8_enable_debugging_features || v8_dcheck_always_on
  is_full_debug = v8_enable_debugging_features && !v8_optimized_debug

  arch = v8_target_cpu
  if (v8_target_cpu == "x86") {
    arch = "ia32"
  }

  mips_arch_variant_var = ""
  mips_use_msa_var = false
  if (arch == "mips64" || arch == "mips64el") {
    mips_arch_variant_var = mips_arch_variant
    mips_use_msa_var = mips_use_msa
  }

  js_shared_memory =
      v8_enable_shared_ro_heap && (!v8_enable_pointer_compression ||
                                   v8_enable_pointer_compression_shared_cage) &&
      !v8_disable_write_barriers
  simd_mips = mips_arch_variant_var == "r6" && mips_use_msa
  simulator_run = target_cpu != v8_target_cpu
  use_sanitizer = is_asan || is_cfi || is_msan || is_tsan || is_ubsan

  # This lists all build-time switches consumed by the test framework. All
  # switches can be used automatically in the status files as is - no
  # further files need to be modified.
  #
  # Naming conventions: Keep switch names short and remove unnecessary
  # qualifiers. Drop v8_enable_, v8_, is_ where possible.
  # Keep only qualifiers that disambiguate the switches from other things.
  # Examples: has_turbofan disambiguates from the turbofan runtime variant,
  # is_android disambiguates from the android keyword in status files,
  # v8_cfi disambiguates from the global cfi flag.
  args = [
    rebase_path("$root_out_dir/v8_build_config.json", root_build_dir),
    "arch=\"$arch\"",
    "asan=$is_asan",
    "atomic_object_field_writes=$v8_enable_atomic_object_field_writes",
    "cet_shadow_stack=$v8_enable_cet_shadow_stack",
    "cfi=$is_cfi",
    "clang=$is_clang",
    "clang_coverage=$use_clang_coverage",
    "code_comments=$v8_code_comments",
    "component_build=$is_component_build",
    "concurrent_marking=$v8_enable_concurrent_marking",
    "conservative_stack_scanning=$v8_enable_conservative_stack_scanning",
    "current_cpu=\"$current_cpu\"",
    "dcheck_always_on=$v8_dcheck_always_on",
    "debug_code=$v8_enable_debug_code",
    "DEBUG_defined=$is_DEBUG_defined",
    "debugging_features=$v8_enable_debugging_features",
    "dict_property_const_tracking=$v8_dict_property_const_tracking",
    "direct_handle=$v8_enable_direct_handle",
    "disassembler=$v8_enable_disassembler",
    "full_debug=$is_full_debug",
    "gdbjit=$v8_enable_gdbjit",
    "has_jitless=$v8_jitless",
    "has_maglev=$v8_enable_maglev",
    "has_turbofan=$v8_enable_turbofan",
    "has_webassembly=$v8_enable_webassembly",
    "has_wasm_interpreter=$v8_enable_drumbrake",
    "i18n=$v8_enable_i18n_support",
    "is_android=$is_android",
    "is_ios=$is_ios",
    "js_shared_memory=$js_shared_memory",
    "lite_mode=$v8_enable_lite_mode",
    "local_off_stack_check=$v8_enable_local_off_stack_check",
    "mips_arch_variant=\"$mips_arch_variant_var\"",
    "mips_use_msa=$mips_use_msa_var",
    "msan=$is_msan",
    "official_build=$is_official_build",
    "pointer_compression=$v8_enable_pointer_compression",
    "pointer_compression_shared_cage=$v8_enable_pointer_compression_shared_cage",
    "runtime_call_stats=$v8_enable_runtime_call_stats",
    "sandbox=$v8_enable_sandbox",
    "shared_ro_heap=$v8_enable_shared_ro_heap",
    "simd_mips=$simd_mips",
    "simulator_run=$simulator_run",
    "single_generation=$v8_enable_single_generation",
    "slow_dchecks=$v8_enable_slow_dchecks",
    "target_cpu=\"$target_cpu\"",
    "third_party_heap=$v8_enable_third_party_heap",
    "tsan=$is_tsan",
    "ubsan=$is_ubsan",
    "use_sanitizer=$use_sanitizer",
    "v8_cfi=$v8_control_flow_integrity",
    "v8_current_cpu=\"$v8_current_cpu\"",
    "v8_target_cpu=\"$v8_target_cpu\"",
    "verify_csa=$v8_enable_verify_csa",
    "verify_heap=$v8_enable_verify_heap",
    "verify_predictable=$v8_enable_verify_predictable",
    "memory_corruption_api=$v8_enable_memory_corruption_api",
  ]
}

# Generate a json file containing essential V8 build flags.
# This json file is consumed by embedders like Node.js and Electron to provide
# information for building third party modules. There is currently no exact
# rules on which build flags should be outputed in the json file, but anything
# affecting the |external_v8_defines| list must be listed here and added to
# the common.gypi file in Node.js repo.
generated_file("v8_generate_features_json") {
  outputs = [ "$root_out_dir/v8_features.json" ]
  output_conversion = "json"
  contents = {
    v8_deprecation_warnings = v8_deprecation_warnings
    v8_enable_31bit_smis_on_64bit_arch = v8_enable_31bit_smis_on_64bit_arch
    v8_enable_conservative_stack_scanning =
        v8_enable_conservative_stack_scanning
    v8_enable_direct_handle = v8_enable_direct_handle
    v8_enable_extensible_ro_snapshot = v8_enable_extensible_ro_snapshot
    v8_enable_gdbjit = v8_enable_gdbjit
    v8_enable_hugepage = v8_enable_hugepage
    v8_enable_i18n_support = v8_enable_i18n_support
    v8_enable_javascript_promise_hooks = v8_enable_javascript_promise_hooks
    v8_enable_lite_mode = v8_enable_lite_mode
    v8_enable_map_packing = v8_enable_map_packing
    v8_enable_object_print = v8_enable_object_print
    v8_enable_pointer_compression = v8_enable_pointer_compression
    v8_enable_pointer_compression_shared_cage =
        v8_enable_pointer_compression_shared_cage
    v8_enable_sandbox = v8_enable_sandbox
    v8_enable_shared_ro_heap = v8_enable_shared_ro_heap
    v8_enable_short_builtin_calls = v8_enable_short_builtin_calls
    v8_enable_v8_checks = v8_enable_v8_checks
    v8_enable_webassembly = v8_enable_webassembly
    v8_enable_zone_compression = v8_enable_zone_compression
    v8_imminent_deprecation_warnings = v8_imminent_deprecation_warnings
    v8_optimized_debug = v8_optimized_debug
    v8_random_seed = v8_random_seed
    v8_use_perfetto = v8_use_perfetto
    v8_use_siphash = v8_use_siphash
  }
}

###############################################################################
# Source Sets (aka static libraries)
#

v8_source_set("v8_snapshot") {
  # Let external targets depend on v8_snapshot.
  if (v8_use_external_startup_data) {
    visibility = [ ":*" ]  # Targets in this file can depend on this.
  }

  deps = [
    ":v8_internal_headers",
    ":v8_libbase",
    ":v8_tracing",
  ]
  public_deps = [
    # This should be public so downstream targets can declare the snapshot
    # output file as their inputs.
    ":run_mksnapshot_default",
  ]

  # Do not publicize any header to remove build dependency.
  public = []

  sources = [ "src/init/setup-isolate-deserialize.cc" ]
  if (v8_control_flow_integrity) {
    sources += [ "src/deoptimizer/deoptimizer-cfi-builtins.cc" ]
  }
  if (emit_builtins_as_inline_asm) {
    deps += [ ":asm_to_inline_asm_default" ]
    sources += [ "$target_gen_dir/embedded.cc" ]
  } else {
    if (current_os != "zos") {
      sources += [ "$target_gen_dir/embedded.S" ]
    } else {
      sources += [ "$target_gen_dir/embedded.s" ]
    }
  }

  configs = [ ":internal_config" ]

  if (v8_use_external_startup_data) {
    deps += [ ":v8_base" ]

    sources += [ "src/snapshot/snapshot-external.cc" ]
  } else {
    public_deps += [
      ":v8_abseil",
      ":v8_maybe_icu",
    ]

    sources += [ "$target_gen_dir/snapshot.cc" ]
  }
}

v8_source_set("v8_initializers") {
  visibility = [
    ":*",
    "test/cctest:*",
  ]

  allow_circular_includes_from = [ ":torque_generated_initializers" ]

  deps = [
    ":torque_generated_initializers",
    ":v8_base_without_compiler",
    ":v8_shared_internal_headers",
    ":v8_tracing",
  ]

  sources = [
    ### gcmole(all) ###
    "src/builtins/builtins-array-gen.cc",
    "src/builtins/builtins-array-gen.h",
    "src/builtins/builtins-async-function-gen.cc",
    "src/builtins/builtins-async-gen.cc",
    "src/builtins/builtins-async-gen.h",
    "src/builtins/builtins-async-generator-gen.cc",
    "src/builtins/builtins-async-iterator-gen.cc",
    "src/builtins/builtins-bigint-gen.cc",
    "src/builtins/builtins-bigint-gen.h",
    "src/builtins/builtins-call-gen.cc",
    "src/builtins/builtins-call-gen.h",
    "src/builtins/builtins-collections-gen.cc",
    "src/builtins/builtins-collections-gen.h",
    "src/builtins/builtins-constructor-gen.cc",
    "src/builtins/builtins-constructor-gen.h",
    "src/builtins/builtins-constructor.h",
    "src/builtins/builtins-conversion-gen.cc",
    "src/builtins/builtins-data-view-gen.h",
    "src/builtins/builtins-date-gen.cc",
    "src/builtins/builtins-generator-gen.cc",
    "src/builtins/builtins-global-gen.cc",
    "src/builtins/builtins-handler-gen.cc",
    "src/builtins/builtins-ic-gen.cc",
    "src/builtins/builtins-internal-gen.cc",
    "src/builtins/builtins-interpreter-gen.cc",
    "src/builtins/builtins-intl-gen.cc",
    "src/builtins/builtins-iterator-gen.cc",
    "src/builtins/builtins-iterator-gen.h",
    "src/builtins/builtins-lazy-gen.cc",
    "src/builtins/builtins-lazy-gen.h",
    "src/builtins/builtins-microtask-queue-gen.cc",
    "src/builtins/builtins-number-gen.cc",
    "src/builtins/builtins-object-gen.cc",
    "src/builtins/builtins-object-gen.h",
    "src/builtins/builtins-promise-gen.cc",
    "src/builtins/builtins-promise-gen.h",
    "src/builtins/builtins-proxy-gen.cc",
    "src/builtins/builtins-proxy-gen.h",
    "src/builtins/builtins-regexp-gen.cc",
    "src/builtins/builtins-regexp-gen.h",
    "src/builtins/builtins-shadow-realm-gen.cc",
    "src/builtins/builtins-sharedarraybuffer-gen.cc",
    "src/builtins/builtins-string-gen.cc",
    "src/builtins/builtins-string-gen.h",
    "src/builtins/builtins-string-tsa.cc",
    "src/builtins/builtins-temporal-gen.cc",
    "src/builtins/builtins-typed-array-gen.cc",
    "src/builtins/builtins-typed-array-gen.h",
    "src/builtins/builtins-utils-gen.h",
    "src/builtins/growable-fixed-array-gen.cc",
    "src/builtins/growable-fixed-array-gen.h",
    "src/builtins/profile-data-reader.cc",
    "src/builtins/profile-data-reader.h",
    "src/builtins/setup-builtins-internal.cc",
    "src/builtins/torque-csa-header-includes.h",
    "src/codegen/code-stub-assembler-inl.h",
    "src/codegen/code-stub-assembler.cc",
    "src/codegen/code-stub-assembler.h",
    "src/codegen/heap-object-list.h",
    "src/codegen/turboshaft-builtins-assembler-inl.h",
    "src/heap/setup-heap-internal.cc",
    "src/ic/accessor-assembler.cc",
    "src/ic/accessor-assembler.h",
    "src/ic/binary-op-assembler.cc",
    "src/ic/binary-op-assembler.h",
    "src/ic/keyed-store-generic.cc",
    "src/ic/keyed-store-generic.h",
    "src/ic/unary-op-assembler.cc",
    "src/ic/unary-op-assembler.h",
    "src/interpreter/interpreter-assembler.cc",
    "src/interpreter/interpreter-assembler.h",
    "src/interpreter/interpreter-generator.cc",
    "src/interpreter/interpreter-generator.h",
    "src/interpreter/interpreter-intrinsics-generator.cc",
    "src/interpreter/interpreter-intrinsics-generator.h",
    "src/numbers/integer-literal-inl.h",
    "src/numbers/integer-literal.h",
    "third_party/v8/codegen/fp16-inl.h",
  ]

  if (v8_enable_webassembly) {
    sources += [
      "src/builtins/builtins-wasm-gen.cc",
      "src/builtins/builtins-wasm-gen.h",
    ]

    if (v8_enable_drumbrake) {
      if (v8_current_cpu == "x64") {
        sources += [ "src/wasm/interpreter/x64/interpreter-builtins-x64.cc" ]
      } else if (v8_current_cpu == "arm64") {
        sources +=
            [ "src/wasm/interpreter/arm64/interpreter-builtins-arm64.cc" ]
      }
    }
  }

  if (v8_current_cpu == "x86") {
    sources += [
      ### gcmole(ia32) ###
      "src/builtins/ia32/builtins-ia32.cc",
    ]
  } else if (v8_current_cpu == "x64") {
    sources += [
      ### gcmole(x64) ###
      "src/builtins/x64/builtins-x64.cc",
    ]
  } else if (v8_current_cpu == "arm") {
    sources += [
      ### gcmole(arm) ###
      "src/builtins/arm/builtins-arm.cc",
    ]
  } else if (v8_current_cpu == "arm64") {
    sources += [
      ### gcmole(arm64) ###
      "src/builtins/arm64/builtins-arm64.cc",
    ]
  } else if (v8_current_cpu == "mips64" || v8_current_cpu == "mips64el") {
    sources += [
      ### gcmole(mips64el) ###
      "src/builtins/mips64/builtins-mips64.cc",
    ]
  } else if (v8_current_cpu == "loong64") {
    sources += [
      ### gcmole(loong64) ###
      "src/builtins/loong64/builtins-loong64.cc",
    ]
  } else if (v8_current_cpu == "ppc") {
    sources += [
      ### gcmole(ppc) ###
      "src/builtins/ppc/builtins-ppc.cc",
    ]
  } else if (v8_current_cpu == "ppc64") {
    sources += [
      ### gcmole(ppc64) ###
      "src/builtins/ppc/builtins-ppc.cc",
    ]
  } else if (v8_current_cpu == "s390" || v8_current_cpu == "s390x") {
    sources += [
      ### gcmole(s390) ###
      "src/builtins/s390/builtins-s390.cc",
    ]
  } else if (v8_current_cpu == "riscv64") {
    sources += [
      ### gcmole(riscv64) ###
      "src/builtins/riscv/builtins-riscv.cc",
    ]
  } else if (v8_current_cpu == "riscv32") {
    sources += [
      ### gcmole(riscv32) ###
      "src/builtins/riscv/builtins-riscv.cc",
    ]
  }

  if (!v8_enable_i18n_support) {
    sources -= [ "src/builtins/builtins-intl-gen.cc" ]
  }

  configs = [ ":internal_config" ]
}

v8_source_set("v8_init") {
  visibility = [ ":*" ]  # Only targets in this file can depend on this.

  deps = [
    ":v8_base_without_compiler",
    ":v8_initializers",
    ":v8_tracing",
  ]

  sources = [
    ### gcmole(all) ###
    "src/init/setup-isolate-full.cc",
  ]

  public_deps = [
    ":v8_abseil",
    ":v8_maybe_icu",
  ]

  configs = [ ":internal_config" ]
}

# This is split out to be a non-code containing target that the Chromium browser
# DLL can depend upon to get only a version string.
v8_header_set("v8_version") {
  configs = [ ":internal_config" ]

  sources = [
    "include/v8-value-serializer-version.h",
    "include/v8-version-string.h",
    "include/v8-version.h",
  ]
}

v8_header_set("v8_config_headers") {
  configs = [ ":internal_config" ]

  sources = [
    "include/v8-platform.h",
    "include/v8-source-location.h",
    "include/v8config.h",
  ]

  deps = []

  if (v8_generate_external_defines_header) {
    sources += [ "$target_gen_dir/include/v8-gn.h" ]
    deps += [ ":gen_v8_gn" ]
  }
}

# This is split out to be a non-code containing target that the Chromium browser
# can depend upon to get basic v8 types.
v8_header_set("v8_headers") {
  configs = [ ":internal_config" ]
  public_configs = [ ":headers_config" ]

  sources = [
    "include/v8-array-buffer.h",
    "include/v8-callbacks.h",
    "include/v8-container.h",
    "include/v8-context.h",
    "include/v8-cppgc.h",
    "include/v8-data.h",
    "include/v8-date.h",
    "include/v8-debug.h",
    "include/v8-embedder-heap.h",
    "include/v8-embedder-state-scope.h",
    "include/v8-exception.h",
    "include/v8-extension.h",
    "include/v8-external.h",
    "include/v8-fast-api-calls.h",
    "include/v8-forward.h",
    "include/v8-function-callback.h",
    "include/v8-function.h",
    "include/v8-handle-base.h",
    "include/v8-initialization.h",
    "include/v8-internal.h",
    "include/v8-isolate.h",
    "include/v8-json.h",
    "include/v8-local-handle.h",
    "include/v8-locker.h",
    "include/v8-maybe.h",
    "include/v8-memory-span.h",
    "include/v8-message.h",
    "include/v8-microtask-queue.h",
    "include/v8-microtask.h",
    "include/v8-object.h",
    "include/v8-persistent-handle.h",
    "include/v8-primitive-object.h",
    "include/v8-primitive.h",
    "include/v8-profiler.h",
    "include/v8-promise.h",
    "include/v8-proxy.h",
    "include/v8-regexp.h",
    "include/v8-sandbox.h",
    "include/v8-script.h",
    "include/v8-snapshot.h",
    "include/v8-statistics.h",
    "include/v8-template.h",
    "include/v8-traced-handle.h",
    "include/v8-typed-array.h",
    "include/v8-unwinder.h",
    "include/v8-util.h",
    "include/v8-value-serializer.h",
    "include/v8-value.h",
    "include/v8-wasm.h",
    "include/v8-weak-callback-info.h",
    "include/v8.h",
  ]

  sources += [
    # The following headers cannot be platform-specific. The include validation
    # of `gn gen $dir --check` requires all header files to be available on all
    # platforms.
    "include/v8-wasm-trap-handler-posix.h",
    "include/v8-wasm-trap-handler-win.h",
  ]

  public_deps = [ ":v8_config_headers" ]

  deps = [
    ":cppgc_headers",
    ":v8_version",
  ]
}

if (v8_generate_external_defines_header) {
  action("gen_v8_gn") {
    visibility = [ ":*" ]

    script = "tools/gen-v8-gn.py"
    outputs = [ "$target_gen_dir/include/v8-gn.h" ]

    args = [
      "-o",
      rebase_path("$target_gen_dir/include/v8-gn.h", root_build_dir),
    ]
    foreach(define, enabled_external_defines) {
      args += [
        "-p",
        define,
      ]
    }
    foreach(define, disabled_external_defines) {
      args += [
        "-n",
        define,
      ]
    }
  }
}

# This is split out to share basic headers with Torque and everything else:(
v8_header_set("v8_shared_internal_headers") {
  visibility = [
    ":*",
    "test/*",
    "tools/*",
  ]
  configs = [ ":internal_config" ]

  sources = [
    "src/common/globals.h",
    "src/wasm/wasm-constants.h",
    "src/wasm/wasm-limits.h",
  ]

  deps = [
    ":v8_headers",
    ":v8_libbase",
  ]
}

v8_header_set("v8_flags") {
  visibility = [
    ":*",
    "tools/*",
  ]

  configs = [ ":internal_config" ]

  sources = [
    "src/flags/flag-definitions.h",
    "src/flags/flags-impl.h",
    "src/flags/flags.h",
  ]

  deps = [
    ":v8_libbase",
    ":v8_shared_internal_headers",
  ]
}

v8_header_set("v8_internal_headers") {
  configs = [ ":internal_config" ]

  public_configs = [ "src/inspector:inspector_config" ]

  sources = [
    ### gcmole(all) ###
    "$target_gen_dir/builtins-generated/bytecodes-builtins-list.h",
    "include/cppgc/common.h",
    "include/v8-inspector-protocol.h",
    "include/v8-inspector.h",
    "include/v8-metrics.h",
    "include/v8-unwinder-state.h",
    "include/v8-wasm-trap-handler-posix.h",
    "src/api/api-arguments-inl.h",
    "src/api/api-arguments.h",
    "src/api/api-inl.h",
    "src/api/api-macros-undef.h",
    "src/api/api-macros.h",
    "src/api/api-natives.h",
    "src/api/api.h",
    "src/ast/ast-function-literal-id-reindexer.h",
    "src/ast/ast-source-ranges.h",
    "src/ast/ast-traversal-visitor.h",
    "src/ast/ast-value-factory.h",
    "src/ast/ast.h",
    "src/ast/modules.h",
    "src/ast/prettyprinter.h",
    "src/ast/scopes.h",
    "src/ast/source-range-ast-visitor.h",
    "src/ast/variables.h",
    "src/baseline/baseline.h",
    "src/baseline/bytecode-offset-iterator.h",
    "src/builtins/accessors.h",
    "src/builtins/builtins-constructor.h",
    "src/builtins/builtins-definitions.h",
    "src/builtins/builtins-descriptors.h",
    "src/builtins/builtins-inl.h",
    "src/builtins/builtins-promise.h",
    "src/builtins/builtins-utils-inl.h",
    "src/builtins/builtins-utils.h",
    "src/builtins/builtins.h",
    "src/builtins/constants-table-builder.h",
    "src/builtins/data-view-ops.h",
    "src/builtins/profile-data-reader.h",
    "src/codegen/aligned-slot-allocator.h",
    "src/codegen/assembler-arch.h",
    "src/codegen/assembler-inl.h",
    "src/codegen/assembler.h",
    "src/codegen/atomic-memory-order.h",
    "src/codegen/background-merge-task.h",
    "src/codegen/bailout-reason.h",
    "src/codegen/callable.h",
    "src/codegen/code-comments.h",
    "src/codegen/code-desc.h",
    "src/codegen/code-factory.h",
    "src/codegen/code-reference.h",
    "src/codegen/compilation-cache.h",
    "src/codegen/compiler.h",
    "src/codegen/constant-pool.h",
    "src/codegen/constants-arch.h",
    "src/codegen/cpu-features.h",
    "src/codegen/external-reference-encoder.h",
    "src/codegen/external-reference-table.h",
    "src/codegen/external-reference.h",
    "src/codegen/flush-instruction-cache.h",
    "src/codegen/handler-table.h",
    "src/codegen/interface-descriptors-inl.h",
    "src/codegen/interface-descriptors.h",
    "src/codegen/label.h",
    "src/codegen/linkage-location.h",
    "src/codegen/machine-type.h",
    "src/codegen/macro-assembler-base.h",
    "src/codegen/macro-assembler-inl.h",
    "src/codegen/macro-assembler.h",
    "src/codegen/maglev-safepoint-table.h",
    "src/codegen/optimized-compilation-info.h",
    "src/codegen/pending-optimization-table.h",
    "src/codegen/register-arch.h",
    "src/codegen/register-base.h",
    "src/codegen/register-configuration.h",
    "src/codegen/register.h",
    "src/codegen/reglist-base.h",
    "src/codegen/reglist.h",
    "src/codegen/reloc-info-inl.h",
    "src/codegen/reloc-info.h",
    "src/codegen/safepoint-table-base.h",
    "src/codegen/safepoint-table.h",
    "src/codegen/script-details.h",
    "src/codegen/signature.h",
    "src/codegen/source-position-table.h",
    "src/codegen/source-position.h",
    "src/codegen/tick-counter.h",
    "src/codegen/tnode.h",
    "src/codegen/unoptimized-compilation-info.h",
    "src/common/assert-scope.h",
    "src/common/checks.h",
    "src/common/code-memory-access-inl.h",
    "src/common/code-memory-access.h",
    "src/common/high-allocation-throughput-scope.h",
    "src/common/message-template.h",
    "src/common/operation.h",
    "src/common/ptr-compr-inl.h",
    "src/common/ptr-compr.h",
    "src/common/segmented-table-inl.h",
    "src/common/segmented-table.h",
    "src/common/simd128.h",
    "src/compiler-dispatcher/lazy-compile-dispatcher.h",
    "src/compiler-dispatcher/optimizing-compile-dispatcher.h",
    "src/compiler/access-builder.h",
    "src/compiler/access-info.h",
    "src/compiler/add-type-assertions-reducer.h",
    "src/compiler/all-nodes.h",
    "src/compiler/allocation-builder-inl.h",
    "src/compiler/allocation-builder.h",
    "src/compiler/backend/bitcast-elider.h",
    "src/compiler/backend/code-generator-impl.h",
    "src/compiler/backend/code-generator.h",
    "src/compiler/backend/frame-elider.h",
    "src/compiler/backend/gap-resolver.h",
    "src/compiler/backend/instruction-codes.h",
    "src/compiler/backend/instruction-scheduler.h",
    "src/compiler/backend/instruction-selector-adapter.h",
    "src/compiler/backend/instruction-selector-impl.h",
    "src/compiler/backend/instruction-selector.h",
    "src/compiler/backend/instruction.h",
    "src/compiler/backend/jump-threading.h",
    "src/compiler/backend/move-optimizer.h",
    "src/compiler/backend/register-allocation.h",
    "src/compiler/backend/register-allocator-verifier.h",
    "src/compiler/backend/register-allocator.h",
    "src/compiler/backend/spill-placer.h",
    "src/compiler/backend/unwinding-info-writer.h",
    "src/compiler/basic-block-instrumentor.h",
    "src/compiler/branch-condition-duplicator.h",
    "src/compiler/branch-elimination.h",
    "src/compiler/bytecode-analysis.h",
    "src/compiler/bytecode-graph-builder.h",
    "src/compiler/bytecode-liveness-map.h",
    "src/compiler/checkpoint-elimination.h",
    "src/compiler/code-assembler.h",
    "src/compiler/common-node-cache.h",
    "src/compiler/common-operator-reducer.h",
    "src/compiler/common-operator.h",
    "src/compiler/compilation-dependencies.h",
    "src/compiler/compiler-source-position-table.h",
    "src/compiler/const-tracking-let-helpers.h",
    "src/compiler/constant-folding-reducer.h",
    "src/compiler/control-equivalence.h",
    "src/compiler/control-path-state.h",
    "src/compiler/csa-load-elimination.h",
    "src/compiler/dead-code-elimination.h",
    "src/compiler/decompression-optimizer.h",
    "src/compiler/diamond.h",
    "src/compiler/escape-analysis-reducer.h",
    "src/compiler/escape-analysis.h",
    "src/compiler/fast-api-calls.h",
    "src/compiler/feedback-source.h",
    "src/compiler/frame-states.h",
    "src/compiler/frame.h",
    "src/compiler/functional-list.h",
    "src/compiler/globals.h",
    "src/compiler/graph-assembler.h",
    "src/compiler/graph-reducer.h",
    "src/compiler/graph-trimmer.h",
    "src/compiler/graph-visualizer.h",
    "src/compiler/graph-zone-traits.h",
    "src/compiler/graph.h",
    "src/compiler/heap-refs.h",
    "src/compiler/js-call-reducer.h",
    "src/compiler/js-context-specialization.h",
    "src/compiler/js-create-lowering.h",
    "src/compiler/js-generic-lowering.h",
    "src/compiler/js-graph.h",
    "src/compiler/js-heap-broker-inl.h",
    "src/compiler/js-heap-broker.h",
    "src/compiler/js-inlining-heuristic.h",
    "src/compiler/js-inlining.h",
    "src/compiler/js-intrinsic-lowering.h",
    "src/compiler/js-native-context-specialization.h",
    "src/compiler/js-operator.h",
    "src/compiler/js-type-hint-lowering.h",
    "src/compiler/js-typed-lowering.h",
    "src/compiler/late-escape-analysis.h",
    "src/compiler/linkage.h",
    "src/compiler/load-elimination.h",
    "src/compiler/loop-analysis.h",
    "src/compiler/loop-peeling.h",
    "src/compiler/loop-unrolling.h",
    "src/compiler/loop-variable-optimizer.h",
    "src/compiler/machine-graph-verifier.h",
    "src/compiler/machine-graph.h",
    "src/compiler/machine-operator-reducer.h",
    "src/compiler/machine-operator.h",
    "src/compiler/map-inference.h",
    "src/compiler/memory-lowering.h",
    "src/compiler/memory-optimizer.h",
    "src/compiler/node-aux-data.h",
    "src/compiler/node-cache.h",
    "src/compiler/node-marker.h",
    "src/compiler/node-matchers.h",
    "src/compiler/node-observer.h",
    "src/compiler/node-origin-table.h",
    "src/compiler/node-properties.h",
    "src/compiler/node.h",
    "src/compiler/opcodes.h",
    "src/compiler/operation-typer.h",
    "src/compiler/operator-properties.h",
    "src/compiler/operator.h",
    "src/compiler/osr.h",
    "src/compiler/pair-load-store-reducer.h",
    "src/compiler/per-isolate-compiler-cache.h",
    "src/compiler/persistent-map.h",
    "src/compiler/phase.h",
    "src/compiler/pipeline-data-inl.h",
    "src/compiler/pipeline-statistics.h",
    "src/compiler/pipeline.h",
    "src/compiler/processed-feedback.h",
    "src/compiler/property-access-builder.h",
    "src/compiler/raw-machine-assembler.h",
    "src/compiler/redundancy-elimination.h",
    "src/compiler/refs-map.h",
    "src/compiler/representation-change.h",
    "src/compiler/schedule.h",
    "src/compiler/scheduler.h",
    "src/compiler/select-lowering.h",
    "src/compiler/simplified-lowering-verifier.h",
    "src/compiler/simplified-lowering.h",
    "src/compiler/simplified-operator-reducer.h",
    "src/compiler/simplified-operator.h",
    "src/compiler/state-values-utils.h",
    "src/compiler/string-builder-optimizer.h",
    "src/compiler/turbofan.h",
    "src/compiler/turboshaft/access-builder.h",
    "src/compiler/turboshaft/analyzer-iterator.h",
    "src/compiler/turboshaft/assembler.h",
    "src/compiler/turboshaft/assert-types-reducer.h",
    "src/compiler/turboshaft/block-instrumentation-phase.h",
    "src/compiler/turboshaft/block-instrumentation-reducer.h",
    "src/compiler/turboshaft/branch-elimination-reducer.h",
    "src/compiler/turboshaft/build-graph-phase.h",
    "src/compiler/turboshaft/builtin-call-descriptors.h",
    "src/compiler/turboshaft/code-elimination-and-simplification-phase.h",
    "src/compiler/turboshaft/copying-phase.h",
    "src/compiler/turboshaft/csa-optimize-phase.h",
    "src/compiler/turboshaft/dataview-lowering-reducer.h",
    "src/compiler/turboshaft/dead-code-elimination-reducer.h",
    "src/compiler/turboshaft/debug-feature-lowering-phase.h",
    "src/compiler/turboshaft/debug-feature-lowering-reducer.h",
    "src/compiler/turboshaft/decompression-optimization-phase.h",
    "src/compiler/turboshaft/decompression-optimization.h",
    "src/compiler/turboshaft/define-assembler-macros.inc",
    "src/compiler/turboshaft/deopt-data.h",
    "src/compiler/turboshaft/duplication-optimization-reducer.h",
    "src/compiler/turboshaft/explicit-truncation-reducer.h",
    "src/compiler/turboshaft/fast-api-call-lowering-reducer.h",
    "src/compiler/turboshaft/fast-hash.h",
    "src/compiler/turboshaft/graph-builder.h",
    "src/compiler/turboshaft/graph-visualizer.h",
    "src/compiler/turboshaft/graph.h",
    "src/compiler/turboshaft/index.h",
    "src/compiler/turboshaft/instruction-selection-normalization-reducer.h",
    "src/compiler/turboshaft/instruction-selection-phase.h",
    "src/compiler/turboshaft/js-generic-lowering-reducer.h",
    "src/compiler/turboshaft/late-escape-analysis-reducer.h",
    "src/compiler/turboshaft/late-load-elimination-reducer.h",
    "src/compiler/turboshaft/layered-hash-map.h",
    "src/compiler/turboshaft/load-store-simplification-reducer.h",
    "src/compiler/turboshaft/loop-finder.h",
    "src/compiler/turboshaft/loop-peeling-phase.h",
    "src/compiler/turboshaft/loop-peeling-reducer.h",
    "src/compiler/turboshaft/loop-unrolling-phase.h",
    "src/compiler/turboshaft/loop-unrolling-reducer.h",
    "src/compiler/turboshaft/machine-lowering-phase.h",
    "src/compiler/turboshaft/machine-lowering-reducer-inl.h",
    "src/compiler/turboshaft/machine-optimization-reducer.h",
    "src/compiler/turboshaft/maglev-early-lowering-reducer-inl.h",
    "src/compiler/turboshaft/maglev-graph-building-phase.h",
    "src/compiler/turboshaft/memory-optimization-reducer.h",
    "src/compiler/turboshaft/operation-matcher.h",
    "src/compiler/turboshaft/operations.h",
    "src/compiler/turboshaft/opmasks.h",
    "src/compiler/turboshaft/optimize-phase.h",
    "src/compiler/turboshaft/phase.h",
    "src/compiler/turboshaft/pipelines.h",
    "src/compiler/turboshaft/pretenuring-propagation-reducer.h",
    "src/compiler/turboshaft/recreate-schedule-phase.h",
    "src/compiler/turboshaft/recreate-schedule.h",
    "src/compiler/turboshaft/reducer-traits.h",
    "src/compiler/turboshaft/register-allocation-phase.h",
    "src/compiler/turboshaft/representations.h",
    "src/compiler/turboshaft/required-optimization-reducer.h",
    "src/compiler/turboshaft/runtime-call-descriptors.h",
    "src/compiler/turboshaft/select-lowering-reducer.h",
    "src/compiler/turboshaft/sidetable.h",
    "src/compiler/turboshaft/simplified-lowering-phase.h",
    "src/compiler/turboshaft/simplified-lowering-reducer.h",
    "src/compiler/turboshaft/simplify-tf-loops.h",
    "src/compiler/turboshaft/snapshot-table-opindex.h",
    "src/compiler/turboshaft/snapshot-table.h",
    "src/compiler/turboshaft/stack-check-lowering-reducer.h",
    "src/compiler/turboshaft/store-store-elimination-phase.h",
    "src/compiler/turboshaft/store-store-elimination-reducer-inl.h",
    "src/compiler/turboshaft/string-view.h",
    "src/compiler/turboshaft/structural-optimization-reducer.h",
    "src/compiler/turboshaft/tracing.h",
    "src/compiler/turboshaft/type-assertions-phase.h",
    "src/compiler/turboshaft/type-inference-analysis.h",
    "src/compiler/turboshaft/type-inference-reducer.h",
    "src/compiler/turboshaft/type-parser.h",
    "src/compiler/turboshaft/typed-optimizations-phase.h",
    "src/compiler/turboshaft/typed-optimizations-reducer.h",
    "src/compiler/turboshaft/typer.h",
    "src/compiler/turboshaft/types.h",
    "src/compiler/turboshaft/undef-assembler-macros.inc",
    "src/compiler/turboshaft/uniform-reducer-adapter.h",
    "src/compiler/turboshaft/use-map.h",
    "src/compiler/turboshaft/utils.h",
    "src/compiler/turboshaft/value-numbering-reducer.h",
    "src/compiler/turboshaft/variable-reducer.h",
    "src/compiler/turboshaft/wasm-dead-code-elimination-phase.h",
    "src/compiler/turboshaft/zone-with-name.h",
    "src/compiler/type-cache.h",
    "src/compiler/type-narrowing-reducer.h",
    "src/compiler/typed-optimization.h",
    "src/compiler/typer.h",
    "src/compiler/types.h",
    "src/compiler/use-info.h",
    "src/compiler/value-numbering-reducer.h",
    "src/compiler/verifier.h",
    "src/compiler/write-barrier-kind.h",
    "src/compiler/zone-stats.h",
    "src/date/date.h",
    "src/date/dateparser-inl.h",
    "src/date/dateparser.h",
    "src/debug/debug-coverage.h",
    "src/debug/debug-evaluate.h",
    "src/debug/debug-frames.h",
    "src/debug/debug-interface.h",
    "src/debug/debug-property-iterator.h",
    "src/debug/debug-scope-iterator.h",
    "src/debug/debug-scopes.h",
    "src/debug/debug-stack-trace-iterator.h",
    "src/debug/debug.h",
    "src/debug/interface-types.h",
    "src/debug/liveedit-diff.h",
    "src/debug/liveedit.h",
    "src/deoptimizer/deoptimize-reason.h",
    "src/deoptimizer/deoptimized-frame-info.h",
    "src/deoptimizer/deoptimizer.h",
    "src/deoptimizer/frame-description.h",
    "src/deoptimizer/frame-translation-builder.h",
    "src/deoptimizer/materialized-object-store.h",
    "src/deoptimizer/translated-state.h",
    "src/deoptimizer/translation-opcode.h",
    "src/diagnostics/basic-block-profiler.h",
    "src/diagnostics/code-tracer.h",
    "src/diagnostics/compilation-statistics.h",
    "src/diagnostics/disasm.h",
    "src/diagnostics/disassembler.h",
    "src/diagnostics/eh-frame.h",
    "src/diagnostics/gdb-jit.h",
    "src/diagnostics/perf-jit.h",
    "src/diagnostics/unwinder.h",
    "src/execution/arguments-inl.h",
    "src/execution/arguments.h",
    "src/execution/clobber-registers.h",
    "src/execution/embedder-state.h",
    "src/execution/encoded-c-signature.h",
    "src/execution/execution.h",
    "src/execution/frame-constants.h",
    "src/execution/frames-inl.h",
    "src/execution/frames.h",
    "src/execution/futex-emulation.h",
    "src/execution/interrupts-scope.h",
    "src/execution/isolate-data.h",
    "src/execution/isolate-inl.h",
    "src/execution/isolate-utils-inl.h",
    "src/execution/isolate-utils.h",
    "src/execution/isolate.h",
    "src/execution/local-isolate-inl.h",
    "src/execution/local-isolate.h",
    "src/execution/messages.h",
    "src/execution/microtask-queue.h",
    "src/execution/pointer-authentication.h",
    "src/execution/protectors-inl.h",
    "src/execution/protectors.h",
    "src/execution/shared-mutex-guard-if-off-thread.h",
    "src/execution/simulator-base.h",
    "src/execution/simulator.h",
    "src/execution/stack-guard.h",
    "src/execution/thread-id.h",
    "src/execution/thread-local-top.h",
    "src/execution/tiering-manager.h",
    "src/execution/v8threads.h",
    "src/execution/vm-state-inl.h",
    "src/execution/vm-state.h",
    "src/extensions/cputracemark-extension.h",
    "src/extensions/externalize-string-extension.h",
    "src/extensions/gc-extension.h",
    "src/extensions/ignition-statistics-extension.h",
    "src/extensions/statistics-extension.h",
    "src/extensions/trigger-failure-extension.h",
    "src/handles/global-handles-inl.h",
    "src/handles/global-handles.h",
    "src/handles/handles-inl.h",
    "src/handles/handles.h",
    "src/handles/local-handles-inl.h",
    "src/handles/local-handles.h",
    "src/handles/maybe-handles-inl.h",
    "src/handles/maybe-handles.h",
    "src/handles/persistent-handles.h",
    "src/handles/shared-object-conveyor-handles.h",
    "src/handles/traced-handles-inl.h",
    "src/handles/traced-handles.h",
    "src/heap/allocation-observer.h",
    "src/heap/allocation-result.h",
    "src/heap/allocation-stats.h",
    "src/heap/array-buffer-sweeper.h",
    "src/heap/base-space.h",
    "src/heap/code-range.h",
    "src/heap/code-stats.h",
    "src/heap/collection-barrier.h",
    "src/heap/combined-heap.h",
    "src/heap/concurrent-marking.h",
    "src/heap/cppgc-js/cpp-heap.h",
    "src/heap/cppgc-js/cpp-marking-state-inl.h",
    "src/heap/cppgc-js/cpp-marking-state.h",
    "src/heap/cppgc-js/cpp-snapshot.h",
    "src/heap/cppgc-js/cross-heap-remembered-set.h",
    "src/heap/cppgc-js/unified-heap-marking-state-inl.h",
    "src/heap/cppgc-js/unified-heap-marking-state.h",
    "src/heap/cppgc-js/unified-heap-marking-verifier.h",
    "src/heap/cppgc-js/unified-heap-marking-visitor.h",
    "src/heap/ephemeron-remembered-set.h",
    "src/heap/evacuation-allocator-inl.h",
    "src/heap/evacuation-allocator.h",
    "src/heap/evacuation-verifier-inl.h",
    "src/heap/evacuation-verifier.h",
    "src/heap/factory-base-inl.h",
    "src/heap/factory-base.h",
    "src/heap/factory-inl.h",
    "src/heap/factory.h",
    "src/heap/finalization-registry-cleanup-task.h",
    "src/heap/free-list-inl.h",
    "src/heap/free-list.h",
    "src/heap/gc-callbacks.h",
    "src/heap/gc-tracer-inl.h",
    "src/heap/gc-tracer.h",
    "src/heap/heap-allocator-inl.h",
    "src/heap/heap-allocator.h",
    "src/heap/heap-controller.h",
    "src/heap/heap-inl.h",
    "src/heap/heap-layout-tracer.h",
    "src/heap/heap-write-barrier-inl.h",
    "src/heap/heap-write-barrier.h",
    "src/heap/heap.h",
    "src/heap/incremental-marking-inl.h",
    "src/heap/incremental-marking-job.h",
    "src/heap/incremental-marking.h",
    "src/heap/index-generator.h",
    "src/heap/large-page-metadata-inl.h",
    "src/heap/large-page-metadata.h",
    "src/heap/large-spaces.h",
    "src/heap/linear-allocation-area.h",
    "src/heap/list.h",
    "src/heap/local-factory-inl.h",
    "src/heap/local-factory.h",
    "src/heap/local-heap-inl.h",
    "src/heap/local-heap.h",
    "src/heap/main-allocator-inl.h",
    "src/heap/main-allocator.h",
    "src/heap/mark-compact-inl.h",
    "src/heap/mark-compact.h",
    "src/heap/mark-sweep-utilities.h",
    "src/heap/marking-barrier-inl.h",
    "src/heap/marking-barrier.h",
    "src/heap/marking-inl.h",
    "src/heap/marking-state-inl.h",
    "src/heap/marking-state.h",
    "src/heap/marking-visitor-inl.h",
    "src/heap/marking-visitor.h",
    "src/heap/marking-worklist-inl.h",
    "src/heap/marking-worklist.h",
    "src/heap/marking.h",
    "src/heap/memory-allocator.h",
    "src/heap/memory-balancer.h",
    "src/heap/memory-chunk-inl.h",
    "src/heap/memory-chunk-layout.h",
    "src/heap/memory-chunk-metadata-inl.h",
    "src/heap/memory-chunk-metadata.h",
    "src/heap/memory-chunk.h",
    "src/heap/memory-measurement-inl.h",
    "src/heap/memory-measurement.h",
    "src/heap/memory-reducer.h",
    "src/heap/minor-gc-job.h",
    "src/heap/minor-mark-sweep-inl.h",
    "src/heap/minor-mark-sweep.h",
    "src/heap/mutable-page-metadata-inl.h",
    "src/heap/mutable-page-metadata.h",
    "src/heap/new-spaces-inl.h",
    "src/heap/new-spaces.h",
    "src/heap/object-lock-inl.h",
    "src/heap/object-lock.h",
    "src/heap/object-stats.h",
    "src/heap/objects-visiting-inl.h",
    "src/heap/objects-visiting.h",
    "src/heap/page-metadata.h",
    "src/heap/paged-spaces-inl.h",
    "src/heap/paged-spaces.h",
    "src/heap/parallel-work-item.h",
    "src/heap/parked-scope-inl.h",
    "src/heap/parked-scope.h",
    "src/heap/pretenuring-handler-inl.h",
    "src/heap/pretenuring-handler.h",
    "src/heap/progress-bar.h",
    "src/heap/read-only-heap-inl.h",
    "src/heap/read-only-heap.h",
    "src/heap/read-only-promotion.h",
    "src/heap/read-only-spaces.h",
    "src/heap/remembered-set-inl.h",
    "src/heap/remembered-set.h",
    "src/heap/safepoint.h",
    "src/heap/scavenger-inl.h",
    "src/heap/scavenger.h",
    "src/heap/slot-set.h",
    "src/heap/spaces-inl.h",
    "src/heap/spaces.h",
    "src/heap/sweeper.h",
    "src/heap/traced-handles-marking-visitor.h",
    "src/heap/trusted-range.h",
    "src/heap/weak-object-worklists.h",
    "src/heap/young-generation-marking-visitor-inl.h",
    "src/heap/young-generation-marking-visitor.h",
    "src/heap/zapping.h",
    "src/ic/call-optimization.h",
    "src/ic/handler-configuration-inl.h",
    "src/ic/handler-configuration.h",
    "src/ic/ic-inl.h",
    "src/ic/ic-stats.h",
    "src/ic/ic.h",
    "src/ic/stub-cache.h",
    "src/init/bootstrapper.h",
    "src/init/heap-symbols.h",
    "src/init/icu_util.h",
    "src/init/isolate-group.h",
    "src/init/setup-isolate.h",
    "src/init/startup-data-util.h",
    "src/init/v8.h",
    "src/interpreter/block-coverage-builder.h",
    "src/interpreter/bytecode-array-builder.h",
    "src/interpreter/bytecode-array-iterator.h",
    "src/interpreter/bytecode-array-random-iterator.h",
    "src/interpreter/bytecode-array-writer.h",
    "src/interpreter/bytecode-decoder.h",
    "src/interpreter/bytecode-flags-and-tokens.h",
    "src/interpreter/bytecode-generator.h",
    "src/interpreter/bytecode-jump-table.h",
    "src/interpreter/bytecode-label.h",
    "src/interpreter/bytecode-node.h",
    "src/interpreter/bytecode-operands.h",
    "src/interpreter/bytecode-register-allocator.h",
    "src/interpreter/bytecode-register-optimizer.h",
    "src/interpreter/bytecode-register.h",
    "src/interpreter/bytecode-source-info.h",
    "src/interpreter/bytecode-traits.h",
    "src/interpreter/bytecodes.h",
    "src/interpreter/constant-array-builder.h",
    "src/interpreter/control-flow-builders.h",
    "src/interpreter/handler-table-builder.h",
    "src/interpreter/interpreter-generator.h",
    "src/interpreter/interpreter-intrinsics.h",
    "src/interpreter/interpreter.h",
    "src/json/json-parser.h",
    "src/json/json-stringifier.h",
    "src/libsampler/sampler.h",
    "src/logging/code-events.h",
    "src/logging/counters-definitions.h",
    "src/logging/counters-scopes.h",
    "src/logging/counters.h",
    "src/logging/local-logger.h",
    "src/logging/log-file.h",
    "src/logging/log-inl.h",
    "src/logging/log.h",
    "src/logging/metrics.h",
    "src/logging/runtime-call-stats-scope.h",
    "src/logging/runtime-call-stats.h",
    "src/logging/tracing-flags.h",
    "src/numbers/conversions-inl.h",
    "src/numbers/conversions.h",
    "src/numbers/hash-seed-inl.h",
    "src/numbers/math-random.h",
    "src/objects/all-objects-inl.h",
    "src/objects/allocation-site-inl.h",
    "src/objects/allocation-site-scopes-inl.h",
    "src/objects/allocation-site-scopes.h",
    "src/objects/allocation-site.h",
    "src/objects/api-callbacks-inl.h",
    "src/objects/api-callbacks.h",
    "src/objects/arguments-inl.h",
    "src/objects/arguments.h",
    "src/objects/backing-store.h",
    "src/objects/bigint-inl.h",
    "src/objects/bigint.h",
    "src/objects/call-site-info-inl.h",
    "src/objects/call-site-info.h",
    "src/objects/casting.h",
    "src/objects/cell-inl.h",
    "src/objects/cell.h",
    "src/objects/code-inl.h",
    "src/objects/code-kind.h",
    "src/objects/code.h",
    "src/objects/compilation-cache-table-inl.h",
    "src/objects/compilation-cache-table.h",
    "src/objects/compressed-slots-inl.h",
    "src/objects/compressed-slots.h",
    "src/objects/contexts-inl.h",
    "src/objects/contexts.h",
    "src/objects/data-handler-inl.h",
    "src/objects/data-handler.h",
    "src/objects/debug-objects-inl.h",
    "src/objects/debug-objects.h",
    "src/objects/descriptor-array-inl.h",
    "src/objects/descriptor-array.h",
    "src/objects/dictionary-inl.h",
    "src/objects/dictionary.h",
    "src/objects/elements-inl.h",
    "src/objects/elements-kind.h",
    "src/objects/elements.h",
    "src/objects/embedder-data-array-inl.h",
    "src/objects/embedder-data-array.h",
    "src/objects/embedder-data-slot-inl.h",
    "src/objects/embedder-data-slot.h",
    "src/objects/feedback-cell-inl.h",
    "src/objects/feedback-cell.h",
    "src/objects/feedback-vector-inl.h",
    "src/objects/feedback-vector.h",
    "src/objects/field-index-inl.h",
    "src/objects/field-index.h",
    "src/objects/field-type.h",
    "src/objects/fixed-array-inl.h",
    "src/objects/fixed-array.h",
    "src/objects/foreign-inl.h",
    "src/objects/foreign.h",
    "src/objects/free-space-inl.h",
    "src/objects/free-space.h",
    "src/objects/function-kind.h",
    "src/objects/function-syntax-kind.h",
    "src/objects/hash-table-inl.h",
    "src/objects/hash-table.h",
    "src/objects/heap-number-inl.h",
    "src/objects/heap-number.h",
    "src/objects/heap-object-inl.h",
    "src/objects/heap-object.h",
    "src/objects/hole-inl.h",
    "src/objects/hole.h",
    "src/objects/instance-type-checker.h",
    "src/objects/instance-type-inl.h",
    "src/objects/instance-type.h",
    "src/objects/internal-index.h",
    "src/objects/js-array-buffer-inl.h",
    "src/objects/js-array-buffer.h",
    "src/objects/js-array-inl.h",
    "src/objects/js-array.h",
    "src/objects/js-atomics-synchronization-inl.h",
    "src/objects/js-atomics-synchronization.h",
    "src/objects/js-collection-inl.h",
    "src/objects/js-collection-iterator-inl.h",
    "src/objects/js-collection-iterator.h",
    "src/objects/js-collection.h",
    "src/objects/js-disposable-stack-inl.h",
    "src/objects/js-disposable-stack.h",
    "src/objects/js-function-inl.h",
    "src/objects/js-function.h",
    "src/objects/js-generator-inl.h",
    "src/objects/js-generator.h",
    "src/objects/js-iterator-helpers-inl.h",
    "src/objects/js-iterator-helpers.h",
    "src/objects/js-objects-inl.h",
    "src/objects/js-objects.h",
    "src/objects/js-promise-inl.h",
    "src/objects/js-promise.h",
    "src/objects/js-proxy-inl.h",
    "src/objects/js-proxy.h",
    "src/objects/js-raw-json-inl.h",
    "src/objects/js-raw-json.h",
    "src/objects/js-regexp-inl.h",
    "src/objects/js-regexp-string-iterator-inl.h",
    "src/objects/js-regexp-string-iterator.h",
    "src/objects/js-regexp.h",
    "src/objects/js-segments-inl.h",
    "src/objects/js-segments.h",
    "src/objects/js-shadow-realm-inl.h",
    "src/objects/js-shadow-realm.h",
    "src/objects/js-shared-array-inl.h",
    "src/objects/js-shared-array.h",
    "src/objects/js-struct-inl.h",
    "src/objects/js-struct.h",
    "src/objects/js-temporal-objects-inl.h",
    "src/objects/js-temporal-objects.h",
    "src/objects/js-weak-refs-inl.h",
    "src/objects/js-weak-refs.h",
    "src/objects/keys.h",
    "src/objects/literal-objects-inl.h",
    "src/objects/literal-objects.h",
    "src/objects/lookup-cache-inl.h",
    "src/objects/lookup-cache.h",
    "src/objects/lookup-inl.h",
    "src/objects/lookup.h",
    "src/objects/managed-inl.h",
    "src/objects/managed.h",
    "src/objects/map-inl.h",
    "src/objects/map-updater.h",
    "src/objects/map.h",
    "src/objects/maybe-object-inl.h",
    "src/objects/maybe-object.h",
    "src/objects/megadom-handler-inl.h",
    "src/objects/megadom-handler.h",
    "src/objects/microtask-inl.h",
    "src/objects/microtask.h",
    "src/objects/module-inl.h",
    "src/objects/module.h",
    "src/objects/name-inl.h",
    "src/objects/name.h",
    "src/objects/object-list-macros.h",
    "src/objects/object-macros-undef.h",
    "src/objects/object-macros.h",
    "src/objects/object-type.h",
    "src/objects/objects-body-descriptors-inl.h",
    "src/objects/objects-body-descriptors.h",
    "src/objects/objects-definitions.h",
    "src/objects/objects-inl.h",
    "src/objects/objects.h",
    "src/objects/oddball-inl.h",
    "src/objects/oddball.h",
    "src/objects/off-heap-hash-table-inl.h",
    "src/objects/off-heap-hash-table.h",
    "src/objects/option-utils.h",
    "src/objects/ordered-hash-table-inl.h",
    "src/objects/ordered-hash-table.h",
    "src/objects/primitive-heap-object-inl.h",
    "src/objects/primitive-heap-object.h",
    "src/objects/promise-inl.h",
    "src/objects/promise.h",
    "src/objects/property-array-inl.h",
    "src/objects/property-array.h",
    "src/objects/property-cell-inl.h",
    "src/objects/property-cell.h",
    "src/objects/property-descriptor-object-inl.h",
    "src/objects/property-descriptor-object.h",
    "src/objects/property-descriptor.h",
    "src/objects/property-details.h",
    "src/objects/property.h",
    "src/objects/prototype-info-inl.h",
    "src/objects/prototype-info.h",
    "src/objects/prototype-inl.h",
    "src/objects/prototype.h",
    "src/objects/regexp-match-info.h",
    "src/objects/scope-info-inl.h",
    "src/objects/scope-info.h",
    "src/objects/script-inl.h",
    "src/objects/script.h",
    "src/objects/shared-function-info-inl.h",
    "src/objects/shared-function-info.h",
    "src/objects/simd.h",
    "src/objects/slots-atomic-inl.h",
    "src/objects/slots-inl.h",
    "src/objects/slots.h",
    "src/objects/smi-inl.h",
    "src/objects/smi.h",
    "src/objects/source-text-module-inl.h",
    "src/objects/source-text-module.h",
    "src/objects/string-comparator.h",
    "src/objects/string-forwarding-table-inl.h",
    "src/objects/string-forwarding-table.h",
    "src/objects/string-inl.h",
    "src/objects/string-set-inl.h",
    "src/objects/string-set.h",
    "src/objects/string-table-inl.h",
    "src/objects/string-table.h",
    "src/objects/string.h",
    "src/objects/struct-inl.h",
    "src/objects/struct.h",
    "src/objects/swiss-hash-table-helpers.h",
    "src/objects/swiss-name-dictionary-inl.h",
    "src/objects/swiss-name-dictionary.h",
    "src/objects/synthetic-module-inl.h",
    "src/objects/synthetic-module.h",
    "src/objects/tagged-field-inl.h",
    "src/objects/tagged-field.h",
    "src/objects/tagged-impl-inl.h",
    "src/objects/tagged-impl.h",
    "src/objects/tagged-index.h",
    "src/objects/tagged-value-inl.h",
    "src/objects/tagged-value.h",
    "src/objects/tagged.h",
    "src/objects/template-objects-inl.h",
    "src/objects/template-objects.h",
    "src/objects/templates-inl.h",
    "src/objects/templates.h",
    "src/objects/torque-defined-classes-inl.h",
    "src/objects/torque-defined-classes.h",
    "src/objects/transitions-inl.h",
    "src/objects/transitions.h",
    "src/objects/trusted-object-inl.h",
    "src/objects/trusted-object.h",
    "src/objects/turbofan-types-inl.h",
    "src/objects/turbofan-types.h",
    "src/objects/turboshaft-types-inl.h",
    "src/objects/turboshaft-types.h",
    "src/objects/type-hints.h",
    "src/objects/union.h",
    "src/objects/value-serializer.h",
    "src/objects/visitors-inl.h",
    "src/objects/visitors.h",
    "src/objects/waiter-queue-node.h",
    "src/parsing/expression-scope.h",
    "src/parsing/func-name-inferrer.h",
    "src/parsing/import-assertions.h",
    "src/parsing/keywords-gen.h",
    "src/parsing/literal-buffer.h",
    "src/parsing/parse-info.h",
    "src/parsing/parser-base.h",
    "src/parsing/parser.h",
    "src/parsing/parsing.h",
    "src/parsing/pending-compilation-error-handler.h",
    "src/parsing/preparse-data-impl.h",
    "src/parsing/preparse-data.h",
    "src/parsing/preparser-logger.h",
    "src/parsing/preparser.h",
    "src/parsing/rewriter.h",
    "src/parsing/scanner-character-streams.h",
    "src/parsing/scanner-inl.h",
    "src/parsing/scanner.h",
    "src/parsing/token.h",
    "src/profiler/allocation-tracker.h",
    "src/profiler/circular-queue-inl.h",
    "src/profiler/circular-queue.h",
    "src/profiler/cpu-profiler-inl.h",
    "src/profiler/cpu-profiler.h",
    "src/profiler/heap-profiler.h",
    "src/profiler/heap-snapshot-generator-inl.h",
    "src/profiler/heap-snapshot-generator.h",
    "src/profiler/output-stream-writer.h",
    "src/profiler/profile-generator-inl.h",
    "src/profiler/profile-generator.h",
    "src/profiler/profiler-listener.h",
    "src/profiler/profiler-stats.h",
    "src/profiler/sampling-heap-profiler.h",
    "src/profiler/strings-storage.h",
    "src/profiler/symbolizer.h",
    "src/profiler/tick-sample.h",
    "src/profiler/tracing-cpu-profiler.h",
    "src/profiler/weak-code-registry.h",
    "src/regexp/experimental/experimental-bytecode.h",
    "src/regexp/experimental/experimental-compiler.h",
    "src/regexp/experimental/experimental-interpreter.h",
    "src/regexp/experimental/experimental.h",
    "src/regexp/regexp-ast.h",
    "src/regexp/regexp-bytecode-generator-inl.h",
    "src/regexp/regexp-bytecode-generator.h",
    "src/regexp/regexp-bytecode-peephole.h",
    "src/regexp/regexp-bytecodes.h",
    "src/regexp/regexp-compiler.h",
    "src/regexp/regexp-dotprinter.h",
    "src/regexp/regexp-error.h",
    "src/regexp/regexp-flags.h",
    "src/regexp/regexp-interpreter.h",
    "src/regexp/regexp-macro-assembler-arch.h",
    "src/regexp/regexp-macro-assembler-tracer.h",
    "src/regexp/regexp-macro-assembler.h",
    "src/regexp/regexp-nodes.h",
    "src/regexp/regexp-parser.h",
    "src/regexp/regexp-stack.h",
    "src/regexp/regexp-utils.h",
    "src/regexp/regexp.h",
    "src/regexp/special-case.h",
    "src/roots/roots-inl.h",
    "src/roots/roots.h",
    "src/roots/static-roots.h",
    "src/runtime/runtime-utils.h",
    "src/runtime/runtime.h",
    "src/sandbox/bounded-size-inl.h",
    "src/sandbox/bounded-size.h",
    "src/sandbox/check.h",
    "src/sandbox/code-entrypoint-tag.h",
    "src/sandbox/code-pointer-inl.h",
    "src/sandbox/code-pointer-table-inl.h",
    "src/sandbox/code-pointer-table.h",
    "src/sandbox/code-pointer.h",
    "src/sandbox/compactible-external-entity-table-inl.h",
    "src/sandbox/compactible-external-entity-table.h",
    "src/sandbox/cppheap-pointer-inl.h",
    "src/sandbox/cppheap-pointer-table-inl.h",
    "src/sandbox/cppheap-pointer-table.h",
    "src/sandbox/external-buffer-inl.h",
    "src/sandbox/external-buffer-table-inl.h",
    "src/sandbox/external-buffer-table.h",
    "src/sandbox/external-buffer-tag.h",
    "src/sandbox/external-buffer.h",
    "src/sandbox/external-entity-table-inl.h",
    "src/sandbox/external-entity-table.h",
    "src/sandbox/external-pointer-inl.h",
    "src/sandbox/external-pointer-table-inl.h",
    "src/sandbox/external-pointer-table.h",
    "src/sandbox/external-pointer.h",
    "src/sandbox/hardware-support.h",
    "src/sandbox/indirect-pointer-inl.h",
    "src/sandbox/indirect-pointer-tag.h",
    "src/sandbox/indirect-pointer.h",
    "src/sandbox/isolate-inl.h",
    "src/sandbox/isolate.h",
    "src/sandbox/js-dispatch-table-inl.h",
    "src/sandbox/js-dispatch-table.h",
    "src/sandbox/sandbox.h",
    "src/sandbox/sandboxed-pointer-inl.h",
    "src/sandbox/sandboxed-pointer.h",
    "src/sandbox/tagged-payload.h",
    "src/sandbox/testing.h",
    "src/sandbox/trusted-pointer-table-inl.h",
    "src/sandbox/trusted-pointer-table.h",
    "src/snapshot/code-serializer.h",
    "src/snapshot/context-deserializer.h",
    "src/snapshot/context-serializer.h",
    "src/snapshot/deserializer.h",
    "src/snapshot/embedded/embedded-data-inl.h",
    "src/snapshot/embedded/embedded-data.h",
    "src/snapshot/embedded/embedded-file-writer-interface.h",
    "src/snapshot/object-deserializer.h",
    "src/snapshot/read-only-deserializer.h",
    "src/snapshot/read-only-serializer-deserializer.h",
    "src/snapshot/read-only-serializer.h",
    "src/snapshot/references.h",
    "src/snapshot/roots-serializer.h",
    "src/snapshot/serializer-deserializer.h",
    "src/snapshot/serializer-inl.h",
    "src/snapshot/serializer.h",
    "src/snapshot/shared-heap-deserializer.h",
    "src/snapshot/shared-heap-serializer.h",
    "src/snapshot/snapshot-data.h",
    "src/snapshot/snapshot-source-sink.h",
    "src/snapshot/snapshot-utils.h",
    "src/snapshot/snapshot.h",
    "src/snapshot/sort-builtins.h",
    "src/snapshot/startup-deserializer.h",
    "src/snapshot/startup-serializer.h",
    "src/strings/char-predicates-inl.h",
    "src/strings/char-predicates.h",
    "src/strings/string-builder-inl.h",
    "src/strings/string-builder.h",
    "src/strings/string-case.h",
    "src/strings/string-hasher-inl.h",
    "src/strings/string-hasher.h",
    "src/strings/string-search.h",
    "src/strings/string-stream.h",
    "src/strings/unicode-decoder.h",
    "src/strings/unicode-inl.h",
    "src/strings/unicode.h",
    "src/strings/uri.h",
    "src/tasks/cancelable-task.h",
    "src/tasks/operations-barrier.h",
    "src/tasks/task-utils.h",
    "src/temporal/temporal-parser.h",
    "src/third_party/siphash/halfsiphash.h",
    "src/third_party/utf8-decoder/utf8-decoder.h",
    "src/torque/runtime-macro-shims.h",
    "src/tracing/trace-event-no-perfetto.h",
    "src/tracing/trace-event.h",
    "src/tracing/traced-value.h",
    "src/tracing/tracing-category-observer.h",
    "src/utils/address-map.h",
    "src/utils/allocation.h",
    "src/utils/bit-vector.h",
    "src/utils/boxed-float.h",
    "src/utils/detachable-vector.h",
    "src/utils/hex-format.h",
    "src/utils/identity-map.h",
    "src/utils/locked-queue-inl.h",
    "src/utils/locked-queue.h",
    "src/utils/memcopy.h",
    "src/utils/ostreams.h",
    "src/utils/scoped-list.h",
    "src/utils/sha-256.h",
    "src/utils/sparse-bit-vector.h",
    "src/utils/utils-inl.h",
    "src/utils/utils.h",
    "src/utils/version.h",
    "src/zone/accounting-allocator.h",
    "src/zone/compressed-zone-ptr.h",
    "src/zone/type-stats.h",
    "src/zone/zone-allocator.h",
    "src/zone/zone-chunk-list.h",
    "src/zone/zone-compact-set.h",
    "src/zone/zone-compression.h",
    "src/zone/zone-containers.h",
    "src/zone/zone-hashmap.h",
    "src/zone/zone-list-inl.h",
    "src/zone/zone-list.h",
    "src/zone/zone-segment.h",
    "src/zone/zone-type-traits.h",
    "src/zone/zone-utils.h",
    "src/zone/zone.h",
  ]

  if (v8_enable_snapshot_compression) {
    sources += [ "src/snapshot/snapshot-compression.h" ]
  }

  if (v8_use_perfetto) {
    sources -= [ "src/tracing/trace-event-no-perfetto.h" ]
    sources += [
      "src/tracing/code-data-source.h",
      "src/tracing/code-trace-context.h",
      "src/tracing/perfetto-logger.h",
      "src/tracing/perfetto-utils.h",
    ]
  }

  if (v8_enable_sparkplug) {
    sources += [
      "src/baseline/baseline-assembler-inl.h",
      "src/baseline/baseline-assembler.h",
      "src/baseline/baseline-batch-compiler.h",
      "src/baseline/baseline-compiler.h",
    ]
  }

  if (v8_enable_maglev) {
    sources += [
      "src/maglev/maglev-assembler-inl.h",
      "src/maglev/maglev-assembler.h",
      "src/maglev/maglev-basic-block.h",
      "src/maglev/maglev-code-gen-state.h",
      "src/maglev/maglev-code-generator.h",
      "src/maglev/maglev-compilation-info.h",
      "src/maglev/maglev-compilation-unit.h",
      "src/maglev/maglev-compiler.h",
      "src/maglev/maglev-concurrent-dispatcher.h",
      "src/maglev/maglev-graph-builder.h",
      "src/maglev/maglev-graph-labeller.h",
      "src/maglev/maglev-graph-printer.h",
      "src/maglev/maglev-graph-processor.h",
      "src/maglev/maglev-graph-verifier.h",
      "src/maglev/maglev-graph.h",
      "src/maglev/maglev-interpreter-frame-state.h",
      "src/maglev/maglev-ir-inl.h",
      "src/maglev/maglev-ir.h",
      "src/maglev/maglev-phi-representation-selector.h",
      "src/maglev/maglev-pipeline-statistics.h",
      "src/maglev/maglev-post-hoc-optimizations-processors.h",
      "src/maglev/maglev-pre-regalloc-codegen-processors.h",
      "src/maglev/maglev-regalloc-data.h",
      "src/maglev/maglev-regalloc.h",
      "src/maglev/maglev-register-frame-array.h",
      "src/maglev/maglev.h",
    ]
    if (v8_current_cpu == "arm") {
      sources += [ "src/maglev/arm/maglev-assembler-arm-inl.h" ]
    } else if (v8_current_cpu == "arm64") {
      sources += [ "src/maglev/arm64/maglev-assembler-arm64-inl.h" ]
    } else if (v8_current_cpu == "x64") {
      sources += [ "src/maglev/x64/maglev-assembler-x64-inl.h" ]
    } else if (v8_current_cpu == "s390x") {
      sources += [ "src/maglev/s390/maglev-assembler-s390-inl.h" ]
    }
  }

  if (v8_enable_webassembly) {
    sources += [
      "src/asmjs/asm-js.h",
      "src/asmjs/asm-names.h",
      "src/asmjs/asm-parser.h",
      "src/asmjs/asm-scanner.h",
      "src/asmjs/asm-types.h",
      "src/compiler/int64-lowering.h",
      "src/compiler/turboshaft/int64-lowering-phase.h",
      "src/compiler/turboshaft/int64-lowering-reducer.h",
      "src/compiler/turboshaft/wasm-assembler-helpers.h",
      "src/compiler/turboshaft/wasm-gc-optimize-phase.h",
      "src/compiler/turboshaft/wasm-gc-typed-optimization-reducer.h",
      "src/compiler/turboshaft/wasm-js-lowering-reducer.h",
      "src/compiler/turboshaft/wasm-load-elimination-reducer.h",
      "src/compiler/turboshaft/wasm-lowering-phase.h",
      "src/compiler/turboshaft/wasm-lowering-reducer.h",
      "src/compiler/turboshaft/wasm-optimize-phase.h",
      "src/compiler/turboshaft/wasm-turboshaft-compiler.h",
      "src/compiler/wasm-address-reassociation.h",
      "src/compiler/wasm-call-descriptors.h",
      "src/compiler/wasm-compiler-definitions.h",
      "src/compiler/wasm-compiler.h",
      "src/compiler/wasm-escape-analysis.h",
      "src/compiler/wasm-gc-lowering.h",
      "src/compiler/wasm-gc-operator-reducer.h",
      "src/compiler/wasm-graph-assembler.h",
      "src/compiler/wasm-inlining-into-js.h",
      "src/compiler/wasm-inlining.h",
      "src/compiler/wasm-js-lowering.h",
      "src/compiler/wasm-load-elimination.h",
      "src/compiler/wasm-loop-peeling.h",
      "src/compiler/wasm-typer.h",
      "src/debug/debug-wasm-objects-inl.h",
      "src/debug/debug-wasm-objects.h",
      "src/third_party/utf8-decoder/generalized-utf8-decoder.h",
      "src/trap-handler/trap-handler-internal.h",
      "src/trap-handler/trap-handler.h",
      "src/wasm/baseline/liftoff-assembler-defs.h",
      "src/wasm/baseline/liftoff-assembler-inl.h",
      "src/wasm/baseline/liftoff-assembler.h",
      "src/wasm/baseline/liftoff-compiler.h",
      "src/wasm/baseline/liftoff-register.h",
      "src/wasm/baseline/liftoff-varstate.h",
      "src/wasm/baseline/parallel-move-inl.h",
      "src/wasm/baseline/parallel-move.h",
      "src/wasm/canonical-types.h",
      "src/wasm/code-space-access.h",
      "src/wasm/compilation-environment-inl.h",
      "src/wasm/compilation-environment.h",
      "src/wasm/constant-expression-interface.h",
      "src/wasm/constant-expression.h",
      "src/wasm/decoder.h",
      "src/wasm/float16.h",
      "src/wasm/function-body-decoder-impl.h",
      "src/wasm/function-body-decoder.h",
      "src/wasm/function-compiler.h",
      "src/wasm/fuzzing/random-module-generation.h",
      "src/wasm/graph-builder-interface.h",
      "src/wasm/inlining-tree.h",
      "src/wasm/jump-table-assembler.h",
      "src/wasm/leb-helper.h",
      "src/wasm/local-decl-encoder.h",
      "src/wasm/memory-tracing.h",
      "src/wasm/module-compiler.h",
      "src/wasm/module-decoder-impl.h",
      "src/wasm/module-decoder.h",
      "src/wasm/module-instantiate.h",
      "src/wasm/names-provider.h",
      "src/wasm/object-access.h",
      "src/wasm/pgo.h",
      "src/wasm/serialized-signature-inl.h",
      "src/wasm/signature-hashing.h",
      "src/wasm/simd-shuffle.h",
      "src/wasm/stacks.h",
      "src/wasm/std-object-sizes.h",
      "src/wasm/streaming-decoder.h",
      "src/wasm/string-builder-multiline.h",
      "src/wasm/string-builder.h",
      "src/wasm/struct-types.h",
      "src/wasm/turboshaft-graph-interface.h",
      "src/wasm/value-type.h",
      "src/wasm/wasm-arguments.h",
      "src/wasm/wasm-builtin-list.h",
      "src/wasm/wasm-code-manager.h",
      "src/wasm/wasm-debug.h",
      "src/wasm/wasm-deopt-data.h",
      "src/wasm/wasm-disassembler-impl.h",
      "src/wasm/wasm-disassembler.h",
      "src/wasm/wasm-engine.h",
      "src/wasm/wasm-external-refs.h",
      "src/wasm/wasm-feature-flags.h",
      "src/wasm/wasm-features.h",
      "src/wasm/wasm-import-wrapper-cache.h",
      "src/wasm/wasm-init-expr.h",
      "src/wasm/wasm-js.h",
      "src/wasm/wasm-linkage.h",
      "src/wasm/wasm-module-builder.h",
      "src/wasm/wasm-module-sourcemap.h",
      "src/wasm/wasm-module.h",
      "src/wasm/wasm-objects-inl.h",
      "src/wasm/wasm-objects.h",
      "src/wasm/wasm-opcodes-inl.h",
      "src/wasm/wasm-opcodes.h",
      "src/wasm/wasm-result.h",
      "src/wasm/wasm-serialization.h",
      "src/wasm/wasm-subtyping.h",
      "src/wasm/wasm-tier.h",
      "src/wasm/wasm-value.h",
      "src/wasm/well-known-imports.h",
    ]

    if (v8_enable_drumbrake) {
      sources += [
        "src/wasm/interpreter/instruction-handlers.h",
        "src/wasm/interpreter/wasm-interpreter-inl.h",
        "src/wasm/interpreter/wasm-interpreter-objects-inl.h",
        "src/wasm/interpreter/wasm-interpreter-objects.h",
        "src/wasm/interpreter/wasm-interpreter-runtime-inl.h",
        "src/wasm/interpreter/wasm-interpreter-runtime.h",
        "src/wasm/interpreter/wasm-interpreter.h",
      ]
    }
  }

  if (v8_enable_wasm_simd256_revec) {
    sources += [
      "src/compiler/linear-scheduler.h",
      "src/compiler/revectorizer.h",
      "src/compiler/turboshaft/wasm-revec-phase.h",
      "src/compiler/turboshaft/wasm-revec-reducer.h",
    ]
  }

  if (!v8_enable_third_party_heap) {
    sources += filter_include(v8_third_party_heap_files, [ "*.h" ])
  } else {
    sources += [ "src/heap/third-party/heap-api.h" ]
  }

  if (v8_enable_i18n_support) {
    sources += [
      "src/objects/intl-objects.h",
      "src/objects/js-break-iterator-inl.h",
      "src/objects/js-break-iterator.h",
      "src/objects/js-collator-inl.h",
      "src/objects/js-collator.h",
      "src/objects/js-date-time-format-inl.h",
      "src/objects/js-date-time-format.h",
      "src/objects/js-display-names-inl.h",
      "src/objects/js-display-names.h",
      "src/objects/js-duration-format-inl.h",
      "src/objects/js-duration-format.h",
      "src/objects/js-list-format-inl.h",
      "src/objects/js-list-format.h",
      "src/objects/js-locale-inl.h",
      "src/objects/js-locale.h",
      "src/objects/js-number-format-inl.h",
      "src/objects/js-number-format.h",
      "src/objects/js-plural-rules-inl.h",
      "src/objects/js-plural-rules.h",
      "src/objects/js-relative-time-format-inl.h",
      "src/objects/js-relative-time-format.h",
      "src/objects/js-segment-iterator-inl.h",
      "src/objects/js-segment-iterator.h",
      "src/objects/js-segmenter-inl.h",
      "src/objects/js-segmenter.h",
    ]
  }

  if (!v8_control_flow_integrity) {
    sources += [ "src/execution/pointer-authentication-dummy.h" ]
  }

  if (v8_enable_conservative_stack_scanning) {
    sources += [ "src/heap/conservative-stack-visitor.h" ]
  }

  if (v8_enable_wasm_gdb_remote_debugging) {
    sources += [
      "src/debug/wasm/gdb-server/gdb-remote-util.h",
      "src/debug/wasm/gdb-server/gdb-server-thread.h",
      "src/debug/wasm/gdb-server/gdb-server.h",
      "src/debug/wasm/gdb-server/packet.h",
      "src/debug/wasm/gdb-server/session.h",
      "src/debug/wasm/gdb-server/target.h",
      "src/debug/wasm/gdb-server/transport.h",
      "src/debug/wasm/gdb-server/wasm-module-debug.h",
    ]
  }

  if (v8_enable_heap_snapshot_verify) {
    sources += [ "src/heap/reference-summarizer.h" ]
  }

  if (v8_current_cpu == "x86") {
    sources += [
      ### gcmole(ia32) ###
      "src/baseline/ia32/baseline-assembler-ia32-inl.h",
      "src/baseline/ia32/baseline-compiler-ia32-inl.h",
      "src/codegen/ia32/assembler-ia32-inl.h",
      "src/codegen/ia32/assembler-ia32.h",
      "src/codegen/ia32/constants-ia32.h",
      "src/codegen/ia32/interface-descriptors-ia32-inl.h",
      "src/codegen/ia32/macro-assembler-ia32.h",
      "src/codegen/ia32/register-ia32.h",
      "src/codegen/ia32/reglist-ia32.h",
      "src/codegen/ia32/sse-instr.h",
      "src/codegen/shared-ia32-x64/macro-assembler-shared-ia32-x64.h",
      "src/compiler/backend/ia32/instruction-codes-ia32.h",
      "src/execution/ia32/frame-constants-ia32.h",
      "src/regexp/ia32/regexp-macro-assembler-ia32.h",
      "src/wasm/baseline/ia32/liftoff-assembler-ia32-inl.h",
    ]
    if (v8_enable_sparkplug) {
      sources += [
        "src/baseline/ia32/baseline-assembler-ia32-inl.h",
        "src/baseline/ia32/baseline-compiler-ia32-inl.h",
      ]
    }
  } else if (v8_current_cpu == "x64") {
    sources += [
      ### gcmole(x64) ###
      "src/codegen/shared-ia32-x64/macro-assembler-shared-ia32-x64.h",
      "src/codegen/x64/assembler-x64-inl.h",
      "src/codegen/x64/assembler-x64.h",
      "src/codegen/x64/constants-x64.h",
      "src/codegen/x64/fma-instr.h",
      "src/codegen/x64/interface-descriptors-x64-inl.h",
      "src/codegen/x64/macro-assembler-x64.h",
      "src/codegen/x64/register-x64.h",
      "src/codegen/x64/reglist-x64.h",
      "src/codegen/x64/sse-instr.h",
      "src/compiler/backend/x64/instruction-codes-x64.h",
      "src/compiler/backend/x64/unwinding-info-writer-x64.h",
      "src/execution/x64/frame-constants-x64.h",
      "src/regexp/x64/regexp-macro-assembler-x64.h",
      "src/third_party/valgrind/valgrind.h",
      "src/wasm/baseline/x64/liftoff-assembler-x64-inl.h",
    ]

    if (is_win) {
      sources += [ "src/diagnostics/unwinding-info-win64.h" ]
    }

    if (v8_enable_sparkplug) {
      sources += [
        "src/baseline/x64/baseline-assembler-x64-inl.h",
        "src/baseline/x64/baseline-compiler-x64-inl.h",
      ]
    }

    if (v8_enable_webassembly) {
      # iOS Xcode simulator builds run on an x64 target. iOS and macOS are both
      # based on Darwin and thus POSIX-compliant to a similar degree.
      if (is_linux || is_chromeos || is_mac || is_ios ||
          target_os == "freebsd") {
        sources += [ "src/trap-handler/handler-inside-posix.h" ]
      } else if (is_win) {
        sources += [ "src/trap-handler/handler-inside-win.h" ]
      }
    }
  } else if (v8_current_cpu == "arm") {
    sources += [
      ### gcmole(arm) ###
      "src/codegen/arm/assembler-arm-inl.h",
      "src/codegen/arm/assembler-arm.h",
      "src/codegen/arm/constants-arm.h",
      "src/codegen/arm/interface-descriptors-arm-inl.h",
      "src/codegen/arm/macro-assembler-arm.h",
      "src/codegen/arm/register-arm.h",
      "src/codegen/arm/reglist-arm.h",
      "src/compiler/backend/arm/instruction-codes-arm.h",
      "src/compiler/backend/arm/unwinding-info-writer-arm.h",
      "src/execution/arm/frame-constants-arm.h",
      "src/execution/arm/simulator-arm.h",
      "src/regexp/arm/regexp-macro-assembler-arm.h",
      "src/wasm/baseline/arm/liftoff-assembler-arm-inl.h",
    ]

    if (v8_enable_sparkplug) {
      sources += [
        "src/baseline/arm/baseline-assembler-arm-inl.h",
        "src/baseline/arm/baseline-compiler-arm-inl.h",
      ]
    }
  } else if (v8_current_cpu == "arm64") {
    sources += [
      ### gcmole(arm64) ###
      "src/codegen/arm64/assembler-arm64-inl.h",
      "src/codegen/arm64/assembler-arm64.h",
      "src/codegen/arm64/constants-arm64.h",
      "src/codegen/arm64/decoder-arm64-inl.h",
      "src/codegen/arm64/decoder-arm64.h",
      "src/codegen/arm64/instructions-arm64.h",
      "src/codegen/arm64/interface-descriptors-arm64-inl.h",
      "src/codegen/arm64/macro-assembler-arm64-inl.h",
      "src/codegen/arm64/macro-assembler-arm64.h",
      "src/codegen/arm64/register-arm64.h",
      "src/codegen/arm64/reglist-arm64.h",
      "src/codegen/arm64/utils-arm64.h",
      "src/compiler/backend/arm64/instruction-codes-arm64.h",
      "src/compiler/backend/arm64/unwinding-info-writer-arm64.h",
      "src/diagnostics/arm64/disasm-arm64.h",
      "src/execution/arm64/frame-constants-arm64.h",
      "src/execution/arm64/simulator-arm64.h",
      "src/regexp/arm64/regexp-macro-assembler-arm64.h",
      "src/wasm/baseline/arm64/liftoff-assembler-arm64-inl.h",
    ]
    if (v8_control_flow_integrity) {
      sources += [ "src/execution/arm64/pointer-authentication-arm64.h" ]
    }
    if (v8_enable_sparkplug) {
      sources += [
        "src/baseline/arm64/baseline-assembler-arm64-inl.h",
        "src/baseline/arm64/baseline-compiler-arm64-inl.h",
      ]
    }
    if (v8_enable_webassembly) {
      # Trap handling is enabled on arm64 Mac and Linux and in simulators on
      # x64 on Linux and Mac.
      if ((current_cpu == "arm64" &&
           (is_linux || is_chromeos || is_mac || is_ios)) ||
          (current_cpu == "x64" && (is_linux || is_chromeos || is_mac))) {
        sources += [ "src/trap-handler/handler-inside-posix.h" ]
      }
      if (current_cpu == "x64" &&
          (is_linux || is_chromeos || is_mac || is_win)) {
        sources += [ "src/trap-handler/trap-handler-simulator.h" ]
      }
    }
    if (is_win) {
      sources += [ "src/diagnostics/unwinding-info-win64.h" ]
    }
  } else if (v8_current_cpu == "mips64" || v8_current_cpu == "mips64el") {
    sources += [
      ### gcmole(mips64el) ###
      "src/codegen/mips64/assembler-mips64-inl.h",
      "src/codegen/mips64/assembler-mips64.h",
      "src/codegen/mips64/constants-mips64.h",
      "src/codegen/mips64/macro-assembler-mips64.h",
      "src/codegen/mips64/register-mips64.h",
      "src/codegen/mips64/reglist-mips64.h",
      "src/compiler/backend/mips64/instruction-codes-mips64.h",
      "src/execution/mips64/frame-constants-mips64.h",
      "src/execution/mips64/simulator-mips64.h",
      "src/regexp/mips64/regexp-macro-assembler-mips64.h",
      "src/wasm/baseline/mips64/liftoff-assembler-mips64-inl.h",
    ]
    if (v8_enable_sparkplug) {
      sources += [
        "src/baseline/mips64/baseline-assembler-mips64-inl.h",
        "src/baseline/mips64/baseline-compiler-mips64-inl.h",
      ]
    }
  } else if (v8_current_cpu == "loong64") {
    sources += [
      ### gcmole(loong64) ###
      "src/codegen/loong64/assembler-loong64-inl.h",
      "src/codegen/loong64/assembler-loong64.h",
      "src/codegen/loong64/constants-loong64.h",
      "src/codegen/loong64/macro-assembler-loong64.h",
      "src/codegen/loong64/register-loong64.h",
      "src/codegen/loong64/reglist-loong64.h",
      "src/compiler/backend/loong64/instruction-codes-loong64.h",
      "src/execution/loong64/frame-constants-loong64.h",
      "src/execution/loong64/simulator-loong64.h",
      "src/regexp/loong64/regexp-macro-assembler-loong64.h",
      "src/wasm/baseline/loong64/liftoff-assembler-loong64-inl.h",
    ]
    if (v8_enable_sparkplug) {
      sources += [
        "src/baseline/loong64/baseline-assembler-loong64-inl.h",
        "src/baseline/loong64/baseline-compiler-loong64-inl.h",
      ]
    }
    if (v8_enable_webassembly) {
      # Trap handling is enabled on loong64 Linux and in simulators on
      # x64 on Linux.
      if ((current_cpu == "loong64" && is_linux) ||
          (current_cpu == "x64" && is_linux)) {
        sources += [ "src/trap-handler/handler-inside-posix.h" ]
      }
      if (current_cpu == "x64" && is_linux) {
        sources += [ "src/trap-handler/trap-handler-simulator.h" ]
      }
    }
  } else if (v8_current_cpu == "ppc") {
    sources += [
      ### gcmole(ppc) ###
      "src/codegen/ppc/assembler-ppc-inl.h",
      "src/codegen/ppc/assembler-ppc.h",
      "src/codegen/ppc/constants-ppc.h",
      "src/codegen/ppc/interface-descriptors-ppc-inl.h",
      "src/codegen/ppc/macro-assembler-ppc.h",
      "src/codegen/ppc/register-ppc.h",
      "src/codegen/ppc/reglist-ppc.h",
      "src/compiler/backend/ppc/instruction-codes-ppc.h",
      "src/compiler/backend/ppc/unwinding-info-writer-ppc.h",
      "src/execution/ppc/frame-constants-ppc.h",
      "src/execution/ppc/simulator-ppc.h",
      "src/regexp/ppc/regexp-macro-assembler-ppc.h",
      "src/wasm/baseline/ppc/liftoff-assembler-ppc-inl.h",
    ]
  } else if (v8_current_cpu == "ppc64") {
    sources += [
      ### gcmole(ppc64) ###
      "src/codegen/ppc/assembler-ppc-inl.h",
      "src/codegen/ppc/assembler-ppc.h",
      "src/codegen/ppc/constants-ppc.h",
      "src/codegen/ppc/interface-descriptors-ppc-inl.h",
      "src/codegen/ppc/macro-assembler-ppc.h",
      "src/codegen/ppc/register-ppc.h",
      "src/codegen/ppc/reglist-ppc.h",
      "src/compiler/backend/ppc/instruction-codes-ppc.h",
      "src/compiler/backend/ppc/unwinding-info-writer-ppc.h",
      "src/execution/ppc/frame-constants-ppc.h",
      "src/execution/ppc/simulator-ppc.h",
      "src/regexp/ppc/regexp-macro-assembler-ppc.h",
      "src/wasm/baseline/ppc/liftoff-assembler-ppc-inl.h",
    ]
    if (v8_enable_sparkplug) {
      sources += [
        "src/baseline/ppc/baseline-assembler-ppc-inl.h",
        "src/baseline/ppc/baseline-compiler-ppc-inl.h",
      ]
    }
  } else if (v8_current_cpu == "s390" || v8_current_cpu == "s390x") {
    sources += [
      ### gcmole(s390) ###
      "src/codegen/s390/assembler-s390-inl.h",
      "src/codegen/s390/assembler-s390.h",
      "src/codegen/s390/constants-s390.h",
      "src/codegen/s390/interface-descriptors-s390-inl.h",
      "src/codegen/s390/macro-assembler-s390.h",
      "src/codegen/s390/register-s390.h",
      "src/codegen/s390/reglist-s390.h",
      "src/compiler/backend/s390/instruction-codes-s390.h",
      "src/compiler/backend/s390/unwinding-info-writer-s390.h",
      "src/execution/s390/frame-constants-s390.h",
      "src/execution/s390/simulator-s390.h",
      "src/regexp/s390/regexp-macro-assembler-s390.h",
      "src/wasm/baseline/s390/liftoff-assembler-s390-inl.h",
    ]
    if (v8_enable_sparkplug) {
      sources += [
        "src/baseline/s390/baseline-assembler-s390-inl.h",
        "src/baseline/s390/baseline-compiler-s390-inl.h",
      ]
    }
  } else if (v8_current_cpu == "riscv64") {
    sources += [
      ### gcmole(riscv64) ###
      "src/baseline/riscv/baseline-assembler-riscv-inl.h",
      "src/baseline/riscv/baseline-compiler-riscv-inl.h",
      "src/codegen/riscv/assembler-riscv-inl.h",
      "src/codegen/riscv/assembler-riscv.h",
      "src/codegen/riscv/base-assembler-riscv.h",
      "src/codegen/riscv/base-constants-riscv.h",
      "src/codegen/riscv/base-riscv-i.h",
      "src/codegen/riscv/constant-riscv-a.h",
      "src/codegen/riscv/constant-riscv-b.h",
      "src/codegen/riscv/constant-riscv-c.h",
      "src/codegen/riscv/constant-riscv-d.h",
      "src/codegen/riscv/constant-riscv-f.h",
      "src/codegen/riscv/constant-riscv-m.h",
      "src/codegen/riscv/constant-riscv-v.h",
      "src/codegen/riscv/constant-riscv-zicond.h",
      "src/codegen/riscv/constant-riscv-zicsr.h",
      "src/codegen/riscv/constant-riscv-zifencei.h",
      "src/codegen/riscv/constants-riscv.h",
      "src/codegen/riscv/extension-riscv-a.h",
      "src/codegen/riscv/extension-riscv-b.h",
      "src/codegen/riscv/extension-riscv-c.h",
      "src/codegen/riscv/extension-riscv-d.h",
      "src/codegen/riscv/extension-riscv-f.h",
      "src/codegen/riscv/extension-riscv-inl.h",
      "src/codegen/riscv/extension-riscv-m.h",
      "src/codegen/riscv/extension-riscv-v.h",
      "src/codegen/riscv/extension-riscv-zicond.h",
      "src/codegen/riscv/extension-riscv-zicsr.h",
      "src/codegen/riscv/extension-riscv-zifencei.h",
      "src/codegen/riscv/interface-descriptors-riscv-inl.h",
      "src/codegen/riscv/macro-assembler-riscv.h",
      "src/codegen/riscv/register-riscv.h",
      "src/codegen/riscv/reglist-riscv.h",
      "src/compiler/backend/riscv/instruction-codes-riscv.h",
      "src/execution/riscv/frame-constants-riscv.h",
      "src/execution/riscv/simulator-riscv.h",
      "src/regexp/riscv/regexp-macro-assembler-riscv.h",
      "src/wasm/baseline/riscv/liftoff-assembler-riscv64-inl.h",
    ]
    if (v8_enable_sparkplug) {
      sources += [
        "src/baseline/riscv/baseline-assembler-riscv-inl.h",
        "src/baseline/riscv/baseline-compiler-riscv-inl.h",
      ]
    }
    if (v8_enable_webassembly) {
      # Trap handling is enabled on riscv64 Linux and in simulators on
      # x64 on Linux.
      if ((current_cpu == "riscv64" && is_linux) ||
          (current_cpu == "x64" && is_linux)) {
        sources += [ "src/trap-handler/handler-inside-posix.h" ]
      }
      if (current_cpu == "x64" && is_linux) {
        sources += [ "src/trap-handler/trap-handler-simulator.h" ]
      }
    }
  } else if (v8_current_cpu == "riscv32") {
    sources += [
      ### gcmole(riscv32) ###
      "src/codegen/riscv/assembler-riscv-inl.h",
      "src/codegen/riscv/assembler-riscv.h",
      "src/codegen/riscv/base-assembler-riscv.h",
      "src/codegen/riscv/base-constants-riscv.h",
      "src/codegen/riscv/base-riscv-i.h",
      "src/codegen/riscv/constant-riscv-a.h",
      "src/codegen/riscv/constant-riscv-b.h",
      "src/codegen/riscv/constant-riscv-c.h",
      "src/codegen/riscv/constant-riscv-d.h",
      "src/codegen/riscv/constant-riscv-f.h",
      "src/codegen/riscv/constant-riscv-i.h",
      "src/codegen/riscv/constant-riscv-m.h",
      "src/codegen/riscv/constant-riscv-v.h",
      "src/codegen/riscv/constant-riscv-zicsr.h",
      "src/codegen/riscv/constant-riscv-zifencei.h",
      "src/codegen/riscv/constants-riscv.h",
      "src/codegen/riscv/extension-riscv-a.h",
      "src/codegen/riscv/extension-riscv-b.h",
      "src/codegen/riscv/extension-riscv-c.h",
      "src/codegen/riscv/extension-riscv-d.h",
      "src/codegen/riscv/extension-riscv-f.h",
      "src/codegen/riscv/extension-riscv-inl.h",
      "src/codegen/riscv/extension-riscv-m.h",
      "src/codegen/riscv/extension-riscv-v.h",
      "src/codegen/riscv/extension-riscv-zicsr.h",
      "src/codegen/riscv/extension-riscv-zifencei.h",
      "src/codegen/riscv/interface-descriptors-riscv-inl.h",
      "src/codegen/riscv/macro-assembler-riscv.h",
      "src/codegen/riscv/register-riscv.h",
      "src/codegen/riscv/reglist-riscv.h",
      "src/compiler/backend/riscv/instruction-codes-riscv.h",
      "src/execution/riscv/frame-constants-riscv.h",
      "src/execution/riscv/simulator-riscv.h",
      "src/regexp/riscv/regexp-macro-assembler-riscv.h",
      "src/wasm/baseline/riscv32/liftoff-assembler-riscv32-inl.h",
    ]
    if (v8_enable_sparkplug) {
      sources += [
        "src/baseline/riscv/baseline-assembler-riscv-inl.h",
        "src/baseline/riscv/baseline-compiler-riscv-inl.h",
      ]
    }
  }

  frameworks = []
  if (is_ios) {
    frameworks += [ "BrowserEngineKit.framework" ]
  }

  public_deps = [
    ":torque_runtime_support",
    ":v8_flags",
    ":v8_headers",
    ":v8_maybe_icu",
    ":v8_shared_internal_headers",
    "//third_party/fp16",
  ]

  deps = [
    ":cppgc_headers",
    ":generate_bytecode_builtins_list",
    ":run_torque",
    ":v8_abseil",
    ":v8_heap_base_headers",
    ":v8_libbase",
  ]
}

v8_compiler_sources = [
  ### gcmole(all) ###
  "src/compiler/access-builder.cc",
  "src/compiler/access-info.cc",
  "src/compiler/add-type-assertions-reducer.cc",
  "src/compiler/all-nodes.cc",
  "src/compiler/backend/bitcast-elider.cc",
  "src/compiler/backend/code-generator.cc",
  "src/compiler/backend/frame-elider.cc",
  "src/compiler/backend/gap-resolver.cc",
  "src/compiler/backend/instruction-scheduler.cc",
  "src/compiler/backend/instruction-selector.cc",
  "src/compiler/backend/instruction.cc",
  "src/compiler/backend/jump-threading.cc",
  "src/compiler/backend/move-optimizer.cc",
  "src/compiler/backend/register-allocator-verifier.cc",
  "src/compiler/backend/register-allocator.cc",
  "src/compiler/backend/spill-placer.cc",
  "src/compiler/basic-block-instrumentor.cc",
  "src/compiler/branch-condition-duplicator.cc",
  "src/compiler/branch-elimination.cc",
  "src/compiler/bytecode-analysis.cc",
  "src/compiler/bytecode-graph-builder.cc",
  "src/compiler/bytecode-liveness-map.cc",
  "src/compiler/c-linkage.cc",
  "src/compiler/checkpoint-elimination.cc",
  "src/compiler/code-assembler.cc",
  "src/compiler/common-node-cache.cc",
  "src/compiler/common-operator-reducer.cc",
  "src/compiler/common-operator.cc",
  "src/compiler/compilation-dependencies.cc",
  "src/compiler/compiler-source-position-table.cc",
  "src/compiler/const-tracking-let-helpers.cc",
  "src/compiler/constant-folding-reducer.cc",
  "src/compiler/control-equivalence.cc",
  "src/compiler/csa-load-elimination.cc",
  "src/compiler/dead-code-elimination.cc",
  "src/compiler/decompression-optimizer.cc",
  "src/compiler/escape-analysis-reducer.cc",
  "src/compiler/escape-analysis.cc",
  "src/compiler/fast-api-calls.cc",
  "src/compiler/feedback-source.cc",
  "src/compiler/frame-states.cc",
  "src/compiler/frame.cc",
  "src/compiler/graph-assembler.cc",
  "src/compiler/graph-reducer.cc",
  "src/compiler/graph-trimmer.cc",
  "src/compiler/graph-visualizer.cc",
  "src/compiler/graph.cc",
  "src/compiler/heap-refs.cc",
  "src/compiler/js-call-reducer.cc",
  "src/compiler/js-context-specialization.cc",
  "src/compiler/js-create-lowering.cc",
  "src/compiler/js-generic-lowering.cc",
  "src/compiler/js-graph.cc",
  "src/compiler/js-heap-broker.cc",
  "src/compiler/js-inlining-heuristic.cc",
  "src/compiler/js-inlining.cc",
  "src/compiler/js-intrinsic-lowering.cc",
  "src/compiler/js-native-context-specialization.cc",
  "src/compiler/js-operator.cc",
  "src/compiler/js-type-hint-lowering.cc",
  "src/compiler/js-typed-lowering.cc",
  "src/compiler/late-escape-analysis.cc",
  "src/compiler/linkage.cc",
  "src/compiler/load-elimination.cc",
  "src/compiler/loop-analysis.cc",
  "src/compiler/loop-peeling.cc",
  "src/compiler/loop-unrolling.cc",
  "src/compiler/loop-variable-optimizer.cc",
  "src/compiler/machine-graph-verifier.cc",
  "src/compiler/machine-graph.cc",
  "src/compiler/machine-operator-reducer.cc",
  "src/compiler/machine-operator.cc",
  "src/compiler/map-inference.cc",
  "src/compiler/memory-lowering.cc",
  "src/compiler/memory-optimizer.cc",
  "src/compiler/node-marker.cc",
  "src/compiler/node-matchers.cc",
  "src/compiler/node-observer.cc",
  "src/compiler/node-origin-table.cc",
  "src/compiler/node-properties.cc",
  "src/compiler/node.cc",
  "src/compiler/opcodes.cc",
  "src/compiler/operation-typer.cc",
  "src/compiler/operator-properties.cc",
  "src/compiler/operator.cc",
  "src/compiler/osr.cc",
  "src/compiler/pair-load-store-reducer.cc",
  "src/compiler/pipeline-statistics.cc",
  "src/compiler/pipeline.cc",
  "src/compiler/property-access-builder.cc",
  "src/compiler/raw-machine-assembler.cc",
  "src/compiler/redundancy-elimination.cc",
  "src/compiler/refs-map.cc",
  "src/compiler/representation-change.cc",
  "src/compiler/schedule.cc",
  "src/compiler/scheduler.cc",
  "src/compiler/select-lowering.cc",
  "src/compiler/simplified-lowering-verifier.cc",
  "src/compiler/simplified-lowering.cc",
  "src/compiler/simplified-operator-reducer.cc",
  "src/compiler/simplified-operator.cc",
  "src/compiler/state-values-utils.cc",
  "src/compiler/string-builder-optimizer.cc",
  "src/compiler/turbofan-enabled.cc",
  "src/compiler/type-cache.cc",
  "src/compiler/type-narrowing-reducer.cc",
  "src/compiler/typed-optimization.cc",
  "src/compiler/typer.cc",
  "src/compiler/types.cc",
  "src/compiler/value-numbering-reducer.cc",
  "src/compiler/verifier.cc",
  "src/compiler/zone-stats.cc",
]

if (v8_current_cpu == "x86") {
  v8_compiler_sources += [
    ### gcmole(ia32) ###
    "src/compiler/backend/ia32/code-generator-ia32.cc",
    "src/compiler/backend/ia32/instruction-scheduler-ia32.cc",
    "src/compiler/backend/ia32/instruction-selector-ia32.cc",
  ]
} else if (v8_current_cpu == "x64") {
  v8_compiler_sources += [
    ### gcmole(x64) ###
    "src/compiler/backend/x64/code-generator-x64.cc",
    "src/compiler/backend/x64/instruction-scheduler-x64.cc",
    "src/compiler/backend/x64/instruction-selector-x64.cc",
    "src/compiler/backend/x64/unwinding-info-writer-x64.cc",
  ]
} else if (v8_current_cpu == "arm") {
  v8_compiler_sources += [
    ### gcmole(arm) ###
    "src/compiler/backend/arm/code-generator-arm.cc",
    "src/compiler/backend/arm/instruction-scheduler-arm.cc",
    "src/compiler/backend/arm/instruction-selector-arm.cc",
    "src/compiler/backend/arm/unwinding-info-writer-arm.cc",
  ]
} else if (v8_current_cpu == "arm64") {
  v8_compiler_sources += [
    ### gcmole(arm64) ###
    "src/compiler/backend/arm64/code-generator-arm64.cc",
    "src/compiler/backend/arm64/instruction-scheduler-arm64.cc",
    "src/compiler/backend/arm64/instruction-selector-arm64.cc",
    "src/compiler/backend/arm64/unwinding-info-writer-arm64.cc",
  ]
} else if (v8_current_cpu == "mips64" || v8_current_cpu == "mips64el") {
  v8_compiler_sources += [
    ### gcmole(mips64el) ###
    "src/compiler/backend/mips64/code-generator-mips64.cc",
    "src/compiler/backend/mips64/instruction-scheduler-mips64.cc",
    "src/compiler/backend/mips64/instruction-selector-mips64.cc",
  ]
} else if (v8_current_cpu == "loong64") {
  v8_compiler_sources += [
    ### gcmole(loong64) ###
    "src/compiler/backend/loong64/code-generator-loong64.cc",
    "src/compiler/backend/loong64/instruction-scheduler-loong64.cc",
    "src/compiler/backend/loong64/instruction-selector-loong64.cc",
  ]
} else if (v8_current_cpu == "ppc") {
  v8_compiler_sources += [
    ### gcmole(ppc) ###
    "src/compiler/backend/ppc/code-generator-ppc.cc",
    "src/compiler/backend/ppc/instruction-scheduler-ppc.cc",
    "src/compiler/backend/ppc/instruction-selector-ppc.cc",
    "src/compiler/backend/ppc/unwinding-info-writer-ppc.cc",
  ]
} else if (v8_current_cpu == "ppc64") {
  v8_compiler_sources += [
    ### gcmole(ppc64) ###
    "src/compiler/backend/ppc/code-generator-ppc.cc",
    "src/compiler/backend/ppc/instruction-scheduler-ppc.cc",
    "src/compiler/backend/ppc/instruction-selector-ppc.cc",
    "src/compiler/backend/ppc/unwinding-info-writer-ppc.cc",
  ]
} else if (v8_current_cpu == "s390" || v8_current_cpu == "s390x") {
  v8_compiler_sources += [
    ### gcmole(s390) ###
    "src/compiler/backend/s390/code-generator-s390.cc",
    "src/compiler/backend/s390/instruction-scheduler-s390.cc",
    "src/compiler/backend/s390/instruction-selector-s390.cc",
    "src/compiler/backend/s390/unwinding-info-writer-s390.cc",
  ]
} else if (v8_current_cpu == "riscv64") {
  v8_compiler_sources += [
    ### gcmole(riscv64) ###
    "src/compiler/backend/riscv/code-generator-riscv.cc",
    "src/compiler/backend/riscv/instruction-scheduler-riscv.cc",
    "src/compiler/backend/riscv/instruction-selector-riscv64.cc",
  ]
} else if (v8_current_cpu == "riscv32") {
  v8_compiler_sources += [
    ### gcmole(riscv32) ###
    "src/compiler/backend/riscv/code-generator-riscv.cc",
    "src/compiler/backend/riscv/instruction-scheduler-riscv.cc",
    "src/compiler/backend/riscv/instruction-selector-riscv32.cc",
  ]
}

if (v8_enable_webassembly) {
  v8_compiler_sources += [
    "src/compiler/int64-lowering.cc",
    "src/compiler/turboshaft/int64-lowering-phase.cc",
    "src/compiler/turboshaft/wasm-gc-optimize-phase.cc",
    "src/compiler/turboshaft/wasm-gc-typed-optimization-reducer.cc",
    "src/compiler/turboshaft/wasm-lowering-phase.cc",
    "src/compiler/turboshaft/wasm-optimize-phase.cc",
    "src/compiler/turboshaft/wasm-turboshaft-compiler.cc",
    "src/compiler/wasm-address-reassociation.cc",
    "src/compiler/wasm-call-descriptors.cc",
    "src/compiler/wasm-compiler-definitions.cc",
    "src/compiler/wasm-compiler.cc",
    "src/compiler/wasm-escape-analysis.cc",
    "src/compiler/wasm-gc-lowering.cc",
    "src/compiler/wasm-gc-operator-reducer.cc",
    "src/compiler/wasm-graph-assembler.cc",
    "src/compiler/wasm-inlining-into-js.cc",
    "src/compiler/wasm-inlining.cc",
    "src/compiler/wasm-js-lowering.cc",
    "src/compiler/wasm-load-elimination.cc",
    "src/compiler/wasm-loop-peeling.cc",
    "src/compiler/wasm-typer.cc",
  ]
}

if (v8_enable_wasm_simd256_revec) {
  v8_compiler_sources += [
    "src/compiler/linear-scheduler.cc",
    "src/compiler/revectorizer.cc",
    "src/compiler/turboshaft/wasm-revec-phase.cc",
    "src/compiler/turboshaft/wasm-revec-reducer.cc",
  ]
}

# The src/compiler files for use in mksnapshot.
# - These might be built with additional optimizations if
#   v8_enable_fast_mksnapshot is set.
# - We always include Turbofan even if v8_enable_turbofan is unset s.t.
#   builtins can be generated by mksnapshot.
v8_source_set("v8_compiler_for_mksnapshot_source_set") {
  visibility = [ ":*" ]  # Only targets in this file can depend on this.

  sources = v8_compiler_sources

  public_deps = [
    ":generate_bytecode_builtins_list",
    ":run_torque",
    ":v8_abseil",
    ":v8_maybe_icu",
    ":v8_tracing",
  ]

  deps = [
    ":v8_base_without_compiler",
    ":v8_internal_headers",
    ":v8_libbase",
    ":v8_shared_internal_headers",
  ]

  if (is_debug && !v8_optimized_debug && v8_enable_fast_mksnapshot) {
    # The :no_optimize config is added to v8_add_configs in v8.gni.
    remove_configs = [ "//build/config/compiler:no_optimize" ]
    configs = [ ":always_turbofanimize" ]
  } else {
    # Without this else branch, gn fails to generate build files for non-debug
    # builds (because we try to remove a config that is not present).
    # So we include it, even if this config is not used outside of debug builds.
    configs = [ ":internal_config" ]
  }
}

# The src/compiler files with default behavior.
v8_source_set("v8_compiler") {
  visibility = [ ":*" ]  # Only targets in this file can depend on this.

  if (v8_enable_turbofan) {
    sources = v8_compiler_sources
  } else {
    # With Turbofan disabled, we only include the stubbed-out API.
    sources = [ "src/compiler/turbofan-disabled.cc" ]
  }

  public_deps = [
    ":generate_bytecode_builtins_list",
    ":run_torque",
    ":v8_abseil",
    ":v8_internal_headers",
    ":v8_maybe_icu",
    ":v8_tracing",
  ]

  deps = [
    ":v8_base_without_compiler",
    ":v8_libbase",
    ":v8_shared_internal_headers",
  ]

  configs = [ ":internal_config" ]
}

# The src/compiler files with default optimization behavior.
v8_source_set("v8_turboshaft") {
  visibility = [ ":*" ]  # Only targets in this file can depend on this.

  sources = [
    "src/compiler/turboshaft/analyzer-iterator.cc",
    "src/compiler/turboshaft/assembler.cc",
    "src/compiler/turboshaft/block-instrumentation-phase.cc",
    "src/compiler/turboshaft/block-instrumentation-reducer.cc",
    "src/compiler/turboshaft/build-graph-phase.cc",
    "src/compiler/turboshaft/code-elimination-and-simplification-phase.cc",
    "src/compiler/turboshaft/copying-phase.cc",
    "src/compiler/turboshaft/csa-optimize-phase.cc",
    "src/compiler/turboshaft/debug-feature-lowering-phase.cc",
    "src/compiler/turboshaft/decompression-optimization-phase.cc",
    "src/compiler/turboshaft/decompression-optimization.cc",
    "src/compiler/turboshaft/graph-builder.cc",
    "src/compiler/turboshaft/graph-visualizer.cc",
    "src/compiler/turboshaft/graph.cc",
    "src/compiler/turboshaft/instruction-selection-phase.cc",
    "src/compiler/turboshaft/late-escape-analysis-reducer.cc",
    "src/compiler/turboshaft/late-load-elimination-reducer.cc",
    "src/compiler/turboshaft/loop-finder.cc",
    "src/compiler/turboshaft/loop-peeling-phase.cc",
    "src/compiler/turboshaft/loop-unrolling-phase.cc",
    "src/compiler/turboshaft/loop-unrolling-reducer.cc",
    "src/compiler/turboshaft/machine-lowering-phase.cc",
    "src/compiler/turboshaft/maglev-graph-building-phase.cc",
    "src/compiler/turboshaft/memory-optimization-reducer.cc",
    "src/compiler/turboshaft/operations.cc",
    "src/compiler/turboshaft/optimize-phase.cc",
    "src/compiler/turboshaft/phase.cc",
    "src/compiler/turboshaft/pipelines.cc",
    "src/compiler/turboshaft/pretenuring-propagation-reducer.cc",
    "src/compiler/turboshaft/recreate-schedule-phase.cc",
    "src/compiler/turboshaft/recreate-schedule.cc",
    "src/compiler/turboshaft/representations.cc",
    "src/compiler/turboshaft/sidetable.cc",
    "src/compiler/turboshaft/simplified-lowering-phase.cc",
    "src/compiler/turboshaft/simplify-tf-loops.cc",
    "src/compiler/turboshaft/store-store-elimination-phase.cc",
    "src/compiler/turboshaft/type-assertions-phase.cc",
    "src/compiler/turboshaft/type-parser.cc",
    "src/compiler/turboshaft/typed-optimizations-phase.cc",
    "src/compiler/turboshaft/typer.cc",
    "src/compiler/turboshaft/types.cc",
    "src/compiler/turboshaft/use-map.cc",
    "src/compiler/turboshaft/utils.cc",
  ]

  if (!v8_enable_maglev) {
    # When Maglev is not enabled, Turboshaft still needs Maglev's graph builder.
    sources += [
      "src/maglev/maglev-compilation-info.cc",
      "src/maglev/maglev-compilation-unit.cc",
      "src/maglev/maglev-graph-builder.cc",
      "src/maglev/maglev-graph-printer.cc",
      "src/maglev/maglev-interpreter-frame-state.cc",
      "src/maglev/maglev-ir.cc",
      "src/maglev/maglev-phi-representation-selector.cc",
    ]
  }

  public_deps = [
    ":generate_bytecode_builtins_list",
    ":run_torque",
    ":v8_internal_headers",
    ":v8_maybe_icu",
    ":v8_tracing",
  ]

  deps = [
    ":v8_base_without_compiler",
    ":v8_libbase",
    ":v8_shared_internal_headers",
  ]

  configs = [ ":internal_config" ]
}

group("v8_compiler_for_mksnapshot") {
  if ((is_debug && !v8_optimized_debug && v8_enable_fast_mksnapshot) ||
      !v8_enable_turbofan) {
    # mksnapshot needs its own version of the compiler, either because
    # a) we're optimizing for mksnapshot execution speed and the compiler
    #    should be optimized even if the rest of V8 is not; or
    # b) Turbofan is disabled and thus not compiled into the rest of V8, yet
    #    mksnapshot still needs TF to generate builtins.
    deps = [ ":v8_compiler_for_mksnapshot_source_set" ]
  } else {
    deps = [ ":v8_compiler" ]
  }
}

# Any target using trace events must directly or indirectly depend on
# v8_tracing.
group("v8_tracing") {
  if (v8_use_perfetto) {
    if (build_with_chromium) {
      public_deps = [ "//third_party/perfetto:libperfetto" ]
    } else {
      public_deps = [ ":v8_libperfetto" ]
    }
  }
}

v8_source_set("v8_base_without_compiler") {
  # Only targets in this file and gcmole can depend on this.
  visibility = [
    ":*",
    "tools/gcmole/:*",
  ]

  # Split static libraries on windows into two.
  split_count = 2

  sources = [
    ### gcmole(all) ###
    "src/api/api-arguments.cc",
    "src/api/api-natives.cc",
    "src/api/api.cc",
    "src/ast/ast-function-literal-id-reindexer.cc",
    "src/ast/ast-value-factory.cc",
    "src/ast/ast.cc",
    "src/ast/modules.cc",
    "src/ast/prettyprinter.cc",
    "src/ast/scopes.cc",
    "src/ast/source-range-ast-visitor.cc",
    "src/ast/variables.cc",
    "src/baseline/baseline.cc",
    "src/baseline/bytecode-offset-iterator.cc",
    "src/builtins/accessors.cc",
    "src/builtins/builtins-abstract-module-source.cc",
    "src/builtins/builtins-api.cc",
    "src/builtins/builtins-array.cc",
    "src/builtins/builtins-arraybuffer.cc",
    "src/builtins/builtins-async-disposable-stack.cc",
    "src/builtins/builtins-async-module.cc",
    "src/builtins/builtins-atomics-synchronization.cc",
    "src/builtins/builtins-bigint.cc",
    "src/builtins/builtins-callsite.cc",
    "src/builtins/builtins-collections.cc",
    "src/builtins/builtins-console.cc",
    "src/builtins/builtins-dataview.cc",
    "src/builtins/builtins-date.cc",
    "src/builtins/builtins-disposable-stack.cc",
    "src/builtins/builtins-error.cc",
    "src/builtins/builtins-function.cc",
    "src/builtins/builtins-global.cc",
    "src/builtins/builtins-internal.cc",
    "src/builtins/builtins-intl.cc",
    "src/builtins/builtins-json.cc",
    "src/builtins/builtins-number.cc",
    "src/builtins/builtins-object.cc",
    "src/builtins/builtins-reflect.cc",
    "src/builtins/builtins-regexp.cc",
    "src/builtins/builtins-shadow-realm.cc",
    "src/builtins/builtins-shared-array.cc",
    "src/builtins/builtins-sharedarraybuffer.cc",
    "src/builtins/builtins-string.cc",
    "src/builtins/builtins-struct.cc",
    "src/builtins/builtins-symbol.cc",
    "src/builtins/builtins-temporal.cc",
    "src/builtins/builtins-trace.cc",
    "src/builtins/builtins-typed-array.cc",
    "src/builtins/builtins-weak-refs.cc",
    "src/builtins/builtins.cc",
    "src/builtins/constants-table-builder.cc",
    "src/codegen/aligned-slot-allocator.cc",
    "src/codegen/assembler.cc",
    "src/codegen/bailout-reason.cc",
    "src/codegen/code-comments.cc",
    "src/codegen/code-desc.cc",
    "src/codegen/code-factory.cc",
    "src/codegen/code-reference.cc",
    "src/codegen/compilation-cache.cc",
    "src/codegen/compiler.cc",
    "src/codegen/constant-pool.cc",
    "src/codegen/external-reference-encoder.cc",
    "src/codegen/external-reference-table.cc",
    "src/codegen/external-reference.cc",
    "src/codegen/flush-instruction-cache.cc",
    "src/codegen/handler-table.cc",
    "src/codegen/interface-descriptors.cc",
    "src/codegen/machine-type.cc",
    "src/codegen/macro-assembler-base.cc",
    "src/codegen/maglev-safepoint-table.cc",
    "src/codegen/optimized-compilation-info.cc",
    "src/codegen/pending-optimization-table.cc",
    "src/codegen/register-configuration.cc",
    "src/codegen/reloc-info.cc",
    "src/codegen/safepoint-table.cc",
    "src/codegen/source-position-table.cc",
    "src/codegen/source-position.cc",
    "src/codegen/tick-counter.cc",
    "src/codegen/tnode.cc",
    "src/codegen/unoptimized-compilation-info.cc",
    "src/common/assert-scope.cc",
    "src/common/code-memory-access.cc",
    "src/common/ptr-compr.cc",
    "src/compiler-dispatcher/lazy-compile-dispatcher.cc",
    "src/compiler-dispatcher/optimizing-compile-dispatcher.cc",
    "src/date/date.cc",
    "src/date/dateparser.cc",
    "src/debug/debug-coverage.cc",
    "src/debug/debug-evaluate.cc",
    "src/debug/debug-frames.cc",
    "src/debug/debug-interface.cc",
    "src/debug/debug-property-iterator.cc",
    "src/debug/debug-scope-iterator.cc",
    "src/debug/debug-scopes.cc",
    "src/debug/debug-stack-trace-iterator.cc",
    "src/debug/debug.cc",
    "src/debug/liveedit-diff.cc",
    "src/debug/liveedit.cc",
    "src/deoptimizer/deoptimize-reason.cc",
    "src/deoptimizer/deoptimized-frame-info.cc",
    "src/deoptimizer/deoptimizer.cc",
    "src/deoptimizer/frame-translation-builder.cc",
    "src/deoptimizer/materialized-object-store.cc",
    "src/deoptimizer/translated-state.cc",
    "src/diagnostics/basic-block-profiler.cc",
    "src/diagnostics/compilation-statistics.cc",
    "src/diagnostics/disassembler.cc",
    "src/diagnostics/eh-frame.cc",
    "src/diagnostics/gdb-jit.cc",
    "src/diagnostics/objects-debug.cc",
    "src/diagnostics/objects-printer.cc",
    "src/diagnostics/perf-jit.cc",
    "src/diagnostics/unwinder.cc",
    "src/execution/arguments.cc",
    "src/execution/clobber-registers.cc",
    "src/execution/embedder-state.cc",
    "src/execution/encoded-c-signature.cc",
    "src/execution/execution.cc",
    "src/execution/frames.cc",
    "src/execution/futex-emulation.cc",
    "src/execution/interrupts-scope.cc",
    "src/execution/isolate.cc",
    "src/execution/local-isolate.cc",
    "src/execution/messages.cc",
    "src/execution/microtask-queue.cc",
    "src/execution/protectors.cc",
    "src/execution/simulator-base.cc",
    "src/execution/stack-guard.cc",
    "src/execution/thread-id.cc",
    "src/execution/thread-local-top.cc",
    "src/execution/tiering-manager.cc",
    "src/execution/v8threads.cc",
    "src/extensions/cputracemark-extension.cc",
    "src/extensions/externalize-string-extension.cc",
    "src/extensions/gc-extension.cc",
    "src/extensions/ignition-statistics-extension.cc",
    "src/extensions/statistics-extension.cc",
    "src/extensions/trigger-failure-extension.cc",
    "src/flags/flags.cc",
    "src/handles/global-handles.cc",
    "src/handles/handles.cc",
    "src/handles/local-handles.cc",
    "src/handles/persistent-handles.cc",
    "src/handles/shared-object-conveyor-handles.cc",
    "src/handles/traced-handles.cc",
    "src/heap/allocation-observer.cc",
    "src/heap/array-buffer-sweeper.cc",
    "src/heap/code-range.cc",
    "src/heap/code-stats.cc",
    "src/heap/collection-barrier.cc",
    "src/heap/combined-heap.cc",
    "src/heap/concurrent-marking.cc",
    "src/heap/cppgc-js/cpp-heap.cc",
    "src/heap/cppgc-js/cpp-snapshot.cc",
    "src/heap/cppgc-js/cross-heap-remembered-set.cc",
    "src/heap/cppgc-js/unified-heap-marking-state.cc",
    "src/heap/cppgc-js/unified-heap-marking-verifier.cc",
    "src/heap/cppgc-js/unified-heap-marking-visitor.cc",
    "src/heap/ephemeron-remembered-set.cc",
    "src/heap/evacuation-allocator.cc",
    "src/heap/evacuation-verifier.cc",
    "src/heap/factory-base.cc",
    "src/heap/factory.cc",
    "src/heap/finalization-registry-cleanup-task.cc",
    "src/heap/free-list.cc",
    "src/heap/gc-tracer.cc",
    "src/heap/heap-allocator.cc",
    "src/heap/heap-controller.cc",
    "src/heap/heap-layout-tracer.cc",
    "src/heap/heap-verifier.cc",
    "src/heap/heap-write-barrier.cc",
    "src/heap/heap.cc",
    "src/heap/incremental-marking-job.cc",
    "src/heap/incremental-marking.cc",
    "src/heap/index-generator.cc",
    "src/heap/large-page-metadata.cc",
    "src/heap/large-spaces.cc",
    "src/heap/local-factory.cc",
    "src/heap/local-heap.cc",
    "src/heap/main-allocator.cc",
    "src/heap/mark-compact.cc",
    "src/heap/mark-sweep-utilities.cc",
    "src/heap/marking-barrier.cc",
    "src/heap/marking-worklist.cc",
    "src/heap/marking.cc",
    "src/heap/memory-allocator.cc",
    "src/heap/memory-balancer.cc",
    "src/heap/memory-chunk-layout.cc",
    "src/heap/memory-chunk-metadata.cc",
    "src/heap/memory-chunk.cc",
    "src/heap/memory-measurement.cc",
    "src/heap/memory-reducer.cc",
    "src/heap/minor-gc-job.cc",
    "src/heap/minor-mark-sweep.cc",
    "src/heap/mutable-page-metadata.cc",
    "src/heap/new-spaces.cc",
    "src/heap/object-stats.cc",
    "src/heap/objects-visiting.cc",
    "src/heap/page-metadata.cc",
    "src/heap/paged-spaces.cc",
    "src/heap/pretenuring-handler.cc",
    "src/heap/read-only-heap.cc",
    "src/heap/read-only-promotion.cc",
    "src/heap/read-only-spaces.cc",
    "src/heap/safepoint.cc",
    "src/heap/scavenger.cc",
    "src/heap/slot-set.cc",
    "src/heap/spaces.cc",
    "src/heap/stress-scavenge-observer.cc",
    "src/heap/sweeper.cc",
    "src/heap/traced-handles-marking-visitor.cc",
    "src/heap/trusted-range.cc",
    "src/heap/weak-object-worklists.cc",
    "src/heap/zapping.cc",
    "src/ic/call-optimization.cc",
    "src/ic/handler-configuration.cc",
    "src/ic/ic-stats.cc",
    "src/ic/ic.cc",
    "src/ic/stub-cache.cc",
    "src/init/bootstrapper.cc",
    "src/init/icu_util.cc",
    "src/init/isolate-group.cc",
    "src/init/startup-data-util.cc",
    "src/init/v8.cc",
    "src/interpreter/bytecode-array-builder.cc",
    "src/interpreter/bytecode-array-iterator.cc",
    "src/interpreter/bytecode-array-random-iterator.cc",
    "src/interpreter/bytecode-array-writer.cc",
    "src/interpreter/bytecode-decoder.cc",
    "src/interpreter/bytecode-flags-and-tokens.cc",
    "src/interpreter/bytecode-generator.cc",
    "src/interpreter/bytecode-label.cc",
    "src/interpreter/bytecode-node.cc",
    "src/interpreter/bytecode-operands.cc",
    "src/interpreter/bytecode-register-optimizer.cc",
    "src/interpreter/bytecode-register.cc",
    "src/interpreter/bytecode-source-info.cc",
    "src/interpreter/bytecodes.cc",
    "src/interpreter/constant-array-builder.cc",
    "src/interpreter/control-flow-builders.cc",
    "src/interpreter/handler-table-builder.cc",
    "src/interpreter/interpreter-intrinsics.cc",
    "src/interpreter/interpreter.cc",
    "src/json/json-parser.cc",
    "src/json/json-stringifier.cc",
    "src/libsampler/sampler.cc",
    "src/logging/counters.cc",
    "src/logging/local-logger.cc",
    "src/logging/log-file.cc",
    "src/logging/log.cc",
    "src/logging/metrics.cc",
    "src/logging/runtime-call-stats.cc",
    "src/logging/tracing-flags.cc",
    "src/numbers/conversions.cc",
    "src/numbers/math-random.cc",
    "src/objects/abstract-code.cc",
    "src/objects/backing-store.cc",
    "src/objects/bigint.cc",
    "src/objects/bytecode-array.cc",
    "src/objects/call-site-info.cc",
    "src/objects/code-kind.cc",
    "src/objects/code.cc",
    "src/objects/compilation-cache-table.cc",
    "src/objects/contexts.cc",
    "src/objects/debug-objects.cc",
    "src/objects/deoptimization-data.cc",
    "src/objects/dependent-code.cc",
    "src/objects/elements-kind.cc",
    "src/objects/elements.cc",
    "src/objects/embedder-data-array.cc",
    "src/objects/feedback-vector.cc",
    "src/objects/field-type.cc",
    "src/objects/fixed-array.cc",
    "src/objects/instruction-stream.cc",
    "src/objects/intl-objects.cc",
    "src/objects/js-array-buffer.cc",
    "src/objects/js-atomics-synchronization.cc",
    "src/objects/js-break-iterator.cc",
    "src/objects/js-collator.cc",
    "src/objects/js-date-time-format.cc",
    "src/objects/js-display-names.cc",
    "src/objects/js-disposable-stack.cc",
    "src/objects/js-duration-format.cc",
    "src/objects/js-function.cc",
    "src/objects/js-list-format.cc",
    "src/objects/js-locale.cc",
    "src/objects/js-number-format.cc",
    "src/objects/js-objects.cc",
    "src/objects/js-plural-rules.cc",
    "src/objects/js-raw-json.cc",
    "src/objects/js-regexp.cc",
    "src/objects/js-relative-time-format.cc",
    "src/objects/js-segment-iterator.cc",
    "src/objects/js-segmenter.cc",
    "src/objects/js-segments.cc",
    "src/objects/js-struct.cc",
    "src/objects/js-temporal-objects.cc",
    "src/objects/keys.cc",
    "src/objects/literal-objects.cc",
    "src/objects/lookup-cache.cc",
    "src/objects/lookup.cc",
    "src/objects/managed.cc",
    "src/objects/map-updater.cc",
    "src/objects/map.cc",
    "src/objects/module.cc",
    "src/objects/object-type.cc",
    "src/objects/objects.cc",
    "src/objects/option-utils.cc",
    "src/objects/ordered-hash-table.cc",
    "src/objects/property-descriptor.cc",
    "src/objects/property.cc",
    "src/objects/regexp-match-info.cc",
    "src/objects/scope-info.cc",
    "src/objects/shared-function-info.cc",
    "src/objects/simd.cc",
    "src/objects/source-text-module.cc",
    "src/objects/string-comparator.cc",
    "src/objects/string-forwarding-table.cc",
    "src/objects/string-table.cc",
    "src/objects/string.cc",
    "src/objects/swiss-name-dictionary.cc",
    "src/objects/symbol-table.cc",
    "src/objects/synthetic-module.cc",
    "src/objects/tagged-impl.cc",
    "src/objects/template-objects.cc",
    "src/objects/templates.cc",
    "src/objects/transitions.cc",
    "src/objects/type-hints.cc",
    "src/objects/value-serializer.cc",
    "src/objects/visitors.cc",
    "src/objects/waiter-queue-node.cc",
    "src/parsing/func-name-inferrer.cc",
    "src/parsing/import-assertions.cc",
    "src/parsing/literal-buffer.cc",
    "src/parsing/parse-info.cc",
    "src/parsing/parser.cc",
    "src/parsing/parsing.cc",
    "src/parsing/pending-compilation-error-handler.cc",
    "src/parsing/preparse-data.cc",
    "src/parsing/preparser.cc",
    "src/parsing/rewriter.cc",
    "src/parsing/scanner-character-streams.cc",
    "src/parsing/scanner.cc",
    "src/parsing/token.cc",
    "src/profiler/allocation-tracker.cc",
    "src/profiler/cpu-profiler.cc",
    "src/profiler/heap-profiler.cc",
    "src/profiler/heap-snapshot-generator.cc",
    "src/profiler/profile-generator.cc",
    "src/profiler/profiler-listener.cc",
    "src/profiler/profiler-stats.cc",
    "src/profiler/sampling-heap-profiler.cc",
    "src/profiler/strings-storage.cc",
    "src/profiler/symbolizer.cc",
    "src/profiler/tick-sample.cc",
    "src/profiler/tracing-cpu-profiler.cc",
    "src/profiler/weak-code-registry.cc",
    "src/regexp/experimental/experimental-bytecode.cc",
    "src/regexp/experimental/experimental-compiler.cc",
    "src/regexp/experimental/experimental-interpreter.cc",
    "src/regexp/experimental/experimental.cc",
    "src/regexp/regexp-ast.cc",
    "src/regexp/regexp-bytecode-generator.cc",
    "src/regexp/regexp-bytecode-peephole.cc",
    "src/regexp/regexp-bytecodes.cc",
    "src/regexp/regexp-compiler-tonode.cc",
    "src/regexp/regexp-compiler.cc",
    "src/regexp/regexp-dotprinter.cc",
    "src/regexp/regexp-error.cc",
    "src/regexp/regexp-interpreter.cc",
    "src/regexp/regexp-macro-assembler-tracer.cc",
    "src/regexp/regexp-macro-assembler.cc",
    "src/regexp/regexp-parser.cc",
    "src/regexp/regexp-stack.cc",
    "src/regexp/regexp-utils.cc",
    "src/regexp/regexp.cc",
    "src/roots/roots.cc",
    "src/runtime/runtime-array.cc",
    "src/runtime/runtime-atomics.cc",
    "src/runtime/runtime-bigint.cc",
    "src/runtime/runtime-classes.cc",
    "src/runtime/runtime-collections.cc",
    "src/runtime/runtime-compiler.cc",
    "src/runtime/runtime-date.cc",
    "src/runtime/runtime-debug.cc",
    "src/runtime/runtime-forin.cc",
    "src/runtime/runtime-function.cc",
    "src/runtime/runtime-futex.cc",
    "src/runtime/runtime-generator.cc",
    "src/runtime/runtime-internal.cc",
    "src/runtime/runtime-intl.cc",
    "src/runtime/runtime-literals.cc",
    "src/runtime/runtime-module.cc",
    "src/runtime/runtime-numbers.cc",
    "src/runtime/runtime-object.cc",
    "src/runtime/runtime-operators.cc",
    "src/runtime/runtime-promise.cc",
    "src/runtime/runtime-proxy.cc",
    "src/runtime/runtime-regexp.cc",
    "src/runtime/runtime-scopes.cc",
    "src/runtime/runtime-shadow-realm.cc",
    "src/runtime/runtime-strings.cc",
    "src/runtime/runtime-symbol.cc",
    "src/runtime/runtime-temporal.cc",
    "src/runtime/runtime-test.cc",
    "src/runtime/runtime-trace.cc",
    "src/runtime/runtime-typedarray.cc",
    "src/runtime/runtime-weak-refs.cc",
    "src/runtime/runtime.cc",
    "src/sandbox/code-pointer-table.cc",
    "src/sandbox/cppheap-pointer-table.cc",
    "src/sandbox/external-buffer-table.cc",
    "src/sandbox/external-pointer-table.cc",
    "src/sandbox/hardware-support.cc",
    "src/sandbox/js-dispatch-table.cc",
    "src/sandbox/sandbox.cc",
    "src/sandbox/testing.cc",
    "src/sandbox/trusted-pointer-table.cc",
    "src/snapshot/code-serializer.cc",
    "src/snapshot/context-deserializer.cc",
    "src/snapshot/context-serializer.cc",
    "src/snapshot/deserializer.cc",
    "src/snapshot/embedded/embedded-data.cc",
    "src/snapshot/object-deserializer.cc",
    "src/snapshot/read-only-deserializer.cc",
    "src/snapshot/read-only-serializer.cc",
    "src/snapshot/roots-serializer.cc",
    "src/snapshot/serializer-deserializer.cc",
    "src/snapshot/serializer.cc",
    "src/snapshot/shared-heap-deserializer.cc",
    "src/snapshot/shared-heap-serializer.cc",
    "src/snapshot/snapshot-data.cc",
    "src/snapshot/snapshot-source-sink.cc",
    "src/snapshot/snapshot-utils.cc",
    "src/snapshot/snapshot.cc",
    "src/snapshot/sort-builtins.cc",
    "src/snapshot/startup-deserializer.cc",
    "src/snapshot/startup-serializer.cc",
    "src/strings/char-predicates.cc",
    "src/strings/string-builder.cc",
    "src/strings/string-case.cc",
    "src/strings/string-stream.cc",
    "src/strings/unicode-decoder.cc",
    "src/strings/unicode.cc",
    "src/strings/uri.cc",
    "src/tasks/cancelable-task.cc",
    "src/tasks/operations-barrier.cc",
    "src/tasks/task-utils.cc",
    "src/temporal/temporal-parser.cc",
    "src/third_party/siphash/halfsiphash.cc",
    "src/tracing/trace-event.cc",
    "src/tracing/traced-value.cc",
    "src/tracing/tracing-category-observer.cc",
    "src/utils/address-map.cc",
    "src/utils/allocation.cc",
    "src/utils/bit-vector.cc",
    "src/utils/detachable-vector.cc",
    "src/utils/hex-format.cc",
    "src/utils/identity-map.cc",
    "src/utils/memcopy.cc",
    "src/utils/ostreams.cc",
    "src/utils/sha-256.cc",
    "src/utils/utils.cc",
    "src/utils/version.cc",
    "src/zone/accounting-allocator.cc",
    "src/zone/type-stats.cc",
    "src/zone/zone-segment.cc",
    "src/zone/zone.cc",
  ]

  if (v8_enable_snapshot_compression) {
    sources += [ "src/snapshot/snapshot-compression.cc" ]
  }

  if (v8_enable_sparkplug) {
    sources += [
      "src/baseline/baseline-batch-compiler.cc",
      "src/baseline/baseline-compiler.cc",
    ]
  }

  if (v8_enable_maglev) {
    sources += [
      "src/maglev/maglev-assembler.cc",
      "src/maglev/maglev-code-generator.cc",
      "src/maglev/maglev-compilation-info.cc",
      "src/maglev/maglev-compilation-unit.cc",
      "src/maglev/maglev-compiler.cc",
      "src/maglev/maglev-concurrent-dispatcher.cc",
      "src/maglev/maglev-graph-builder.cc",
      "src/maglev/maglev-graph-printer.cc",
      "src/maglev/maglev-interpreter-frame-state.cc",
      "src/maglev/maglev-ir.cc",
      "src/maglev/maglev-phi-representation-selector.cc",
      "src/maglev/maglev-pipeline-statistics.cc",
      "src/maglev/maglev-regalloc.cc",
      "src/maglev/maglev.cc",
    ]
    if (v8_current_cpu == "arm") {
      sources += [
        "src/maglev/arm/maglev-assembler-arm.cc",
        "src/maglev/arm/maglev-ir-arm.cc",
      ]
    } else if (v8_current_cpu == "arm64") {
      sources += [
        "src/maglev/arm64/maglev-assembler-arm64.cc",
        "src/maglev/arm64/maglev-ir-arm64.cc",
      ]
    } else if (v8_current_cpu == "x64") {
      sources += [
        "src/maglev/x64/maglev-assembler-x64.cc",
        "src/maglev/x64/maglev-ir-x64.cc",
      ]
    } else if (v8_current_cpu == "s390x") {
      sources += [
        "src/maglev/s390/maglev-assembler-s390.cc",
        "src/maglev/s390/maglev-ir-s390.cc",
      ]
    }
  }

  if (v8_use_perfetto) {
    sources += [
      "src/tracing/code-data-source.cc",
      "src/tracing/perfetto-logger.cc",
      "src/tracing/perfetto-utils.cc",
    ]
  }

  if (v8_enable_webassembly) {
    sources += [
      ### gcmole(all) ###
      "src/asmjs/asm-js.cc",
      "src/asmjs/asm-parser.cc",
      "src/asmjs/asm-scanner.cc",
      "src/asmjs/asm-types.cc",
      "src/compiler/turboshaft/wasm-dead-code-elimination-phase.cc",
      "src/debug/debug-wasm-objects.cc",
      "src/runtime/runtime-test-wasm.cc",
      "src/runtime/runtime-wasm.cc",
      "src/trap-handler/handler-inside.cc",
      "src/trap-handler/handler-outside.cc",
      "src/trap-handler/handler-shared.cc",
      "src/wasm/baseline/liftoff-assembler.cc",
      "src/wasm/baseline/liftoff-compiler.cc",
      "src/wasm/baseline/parallel-move.cc",
      "src/wasm/canonical-types.cc",
      "src/wasm/code-space-access.cc",
      "src/wasm/constant-expression-interface.cc",
      "src/wasm/constant-expression.cc",
      "src/wasm/function-body-decoder.cc",
      "src/wasm/function-compiler.cc",
      "src/wasm/graph-builder-interface.cc",
      "src/wasm/jump-table-assembler.cc",
      "src/wasm/local-decl-encoder.cc",
      "src/wasm/memory-tracing.cc",
      "src/wasm/module-compiler.cc",
      "src/wasm/module-decoder.cc",
      "src/wasm/module-instantiate.cc",
      "src/wasm/names-provider.cc",
      "src/wasm/pgo.cc",
      "src/wasm/simd-shuffle.cc",
      "src/wasm/stacks.cc",
      "src/wasm/streaming-decoder.cc",
      "src/wasm/sync-streaming-decoder.cc",
      "src/wasm/turboshaft-graph-interface.cc",
      "src/wasm/value-type.cc",
      "src/wasm/wasm-code-manager.cc",
      "src/wasm/wasm-debug.cc",
      "src/wasm/wasm-deopt-data.cc",
      "src/wasm/wasm-disassembler.cc",
      "src/wasm/wasm-engine.cc",
      "src/wasm/wasm-external-refs.cc",
      "src/wasm/wasm-features.cc",
      "src/wasm/wasm-import-wrapper-cache.cc",
      "src/wasm/wasm-js.cc",
      "src/wasm/wasm-module-builder.cc",
      "src/wasm/wasm-module-sourcemap.cc",
      "src/wasm/wasm-module.cc",
      "src/wasm/wasm-objects.cc",
      "src/wasm/wasm-opcodes.cc",
      "src/wasm/wasm-result.cc",
      "src/wasm/wasm-serialization.cc",
      "src/wasm/wasm-subtyping.cc",
      "src/wasm/well-known-imports.cc",
      "src/wasm/wrappers.cc",
    ]
    if (!is_official_build) {
      sources += [
        ### gcmole(all) ###
        "src/wasm/fuzzing/random-module-generation.cc",
      ]
    }

    if (v8_enable_drumbrake) {
      sources += [
        "src/wasm/interpreter/wasm-interpreter-objects.cc",
        "src/wasm/interpreter/wasm-interpreter-runtime.cc",
        "src/wasm/interpreter/wasm-interpreter-simd.cc",
        "src/wasm/interpreter/wasm-interpreter.cc",
      ]
    }
  }

  if (v8_enable_third_party_heap) {
    sources += filter_exclude(v8_third_party_heap_files, [ "*.h" ])
  } else {
    sources += [ "src/heap/third-party/heap-api-stub.cc" ]
  }

  if (v8_enable_conservative_stack_scanning) {
    sources += [ "src/heap/conservative-stack-visitor.cc" ]
  }

  if (v8_enable_wasm_gdb_remote_debugging) {
    sources += [
      "src/debug/wasm/gdb-server/gdb-remote-util.cc",
      "src/debug/wasm/gdb-server/gdb-server-thread.cc",
      "src/debug/wasm/gdb-server/gdb-server.cc",
      "src/debug/wasm/gdb-server/packet.cc",
      "src/debug/wasm/gdb-server/session.cc",
      "src/debug/wasm/gdb-server/target.cc",
      "src/debug/wasm/gdb-server/transport.cc",
      "src/debug/wasm/gdb-server/wasm-module-debug.cc",
    ]
  }

  if (v8_enable_heap_snapshot_verify) {
    sources += [ "src/heap/reference-summarizer.cc" ]
  }

  if (v8_current_cpu == "x86") {
    sources += [
      ### gcmole(ia32) ###
      "src/codegen/ia32/assembler-ia32.cc",
      "src/codegen/ia32/cpu-ia32.cc",
      "src/codegen/ia32/macro-assembler-ia32.cc",
      "src/codegen/shared-ia32-x64/macro-assembler-shared-ia32-x64.cc",
      "src/deoptimizer/ia32/deoptimizer-ia32.cc",
      "src/diagnostics/ia32/disasm-ia32.cc",
      "src/diagnostics/ia32/unwinder-ia32.cc",
      "src/execution/ia32/frame-constants-ia32.cc",
      "src/regexp/ia32/regexp-macro-assembler-ia32.cc",
    ]
  } else if (v8_current_cpu == "x64") {
    sources += [
      ### gcmole(x64) ###
      "src/codegen/shared-ia32-x64/macro-assembler-shared-ia32-x64.cc",
      "src/codegen/x64/assembler-x64.cc",
      "src/codegen/x64/cpu-x64.cc",
      "src/codegen/x64/macro-assembler-x64.cc",
      "src/deoptimizer/x64/deoptimizer-x64.cc",
      "src/diagnostics/x64/disasm-x64.cc",
      "src/diagnostics/x64/eh-frame-x64.cc",
      "src/diagnostics/x64/unwinder-x64.cc",
      "src/execution/x64/frame-constants-x64.cc",
      "src/regexp/x64/regexp-macro-assembler-x64.cc",
    ]

    if (is_win) {
      sources += [ "src/diagnostics/unwinding-info-win64.cc" ]
    }

    if (v8_enable_webassembly) {
      # iOS Xcode simulator builds run on an x64 target. iOS and macOS are both
      # based on Darwin and thus POSIX-compliant to a similar degree.
      if (is_linux || is_chromeos || is_mac || is_ios ||
          target_os == "freebsd") {
        sources += [
          "src/trap-handler/handler-inside-posix.cc",
          "src/trap-handler/handler-outside-posix.cc",
        ]
      } else if (is_win) {
        sources += [
          "src/trap-handler/handler-inside-win.cc",
          "src/trap-handler/handler-outside-win.cc",
        ]
      }
    }
  } else if (v8_current_cpu == "arm") {
    sources += [
      ### gcmole(arm) ###
      "src/codegen/arm/assembler-arm.cc",
      "src/codegen/arm/constants-arm.cc",
      "src/codegen/arm/cpu-arm.cc",
      "src/codegen/arm/macro-assembler-arm.cc",
      "src/deoptimizer/arm/deoptimizer-arm.cc",
      "src/diagnostics/arm/disasm-arm.cc",
      "src/diagnostics/arm/eh-frame-arm.cc",
      "src/diagnostics/arm/unwinder-arm.cc",
      "src/execution/arm/frame-constants-arm.cc",
      "src/execution/arm/simulator-arm.cc",
      "src/regexp/arm/regexp-macro-assembler-arm.cc",
    ]
  } else if (v8_current_cpu == "arm64") {
    sources += [
      ### gcmole(arm64) ###
      "src/codegen/arm64/assembler-arm64.cc",
      "src/codegen/arm64/cpu-arm64.cc",
      "src/codegen/arm64/decoder-arm64.cc",
      "src/codegen/arm64/instructions-arm64-constants.cc",
      "src/codegen/arm64/instructions-arm64.cc",
      "src/codegen/arm64/macro-assembler-arm64.cc",
      "src/codegen/arm64/register-arm64.cc",
      "src/codegen/arm64/utils-arm64.cc",
      "src/deoptimizer/arm64/deoptimizer-arm64.cc",
      "src/diagnostics/arm64/disasm-arm64.cc",
      "src/diagnostics/arm64/eh-frame-arm64.cc",
      "src/diagnostics/arm64/unwinder-arm64.cc",
      "src/execution/arm64/frame-constants-arm64.cc",
      "src/execution/arm64/pointer-auth-arm64.cc",
      "src/execution/arm64/simulator-arm64.cc",
      "src/execution/arm64/simulator-logic-arm64.cc",
      "src/regexp/arm64/regexp-macro-assembler-arm64.cc",
    ]
    if (v8_enable_webassembly) {
      # Trap handling is enabled on arm64 Mac and Linux and in simulators on
      # x64 on Linux, Mac, and Windows.
      if ((current_cpu == "arm64" && (is_linux || is_chromeos || is_apple)) ||
          (current_cpu == "x64" && (is_linux || is_chromeos || is_mac))) {
        sources += [
          "src/trap-handler/handler-inside-posix.cc",
          "src/trap-handler/handler-outside-posix.cc",
        ]
      } else if (current_cpu == "x64" && is_win) {
        sources += [
          "src/trap-handler/handler-inside-win.cc",
          "src/trap-handler/handler-outside-win.cc",
        ]
      }
      if (current_cpu == "x64" &&
          (is_linux || is_chromeos || is_mac || is_win)) {
        sources += [ "src/trap-handler/handler-outside-simulator.cc" ]
      }
    }
    if (is_win) {
      sources += [ "src/diagnostics/unwinding-info-win64.cc" ]
    }
  } else if (v8_current_cpu == "mips64" || v8_current_cpu == "mips64el") {
    sources += [
      ### gcmole(mips64el) ###
      "src/codegen/mips64/assembler-mips64.cc",
      "src/codegen/mips64/constants-mips64.cc",
      "src/codegen/mips64/cpu-mips64.cc",
      "src/codegen/mips64/interface-descriptors-mips64-inl.h",
      "src/codegen/mips64/macro-assembler-mips64.cc",
      "src/deoptimizer/mips64/deoptimizer-mips64.cc",
      "src/diagnostics/mips64/disasm-mips64.cc",
      "src/diagnostics/mips64/unwinder-mips64.cc",
      "src/execution/mips64/frame-constants-mips64.cc",
      "src/execution/mips64/simulator-mips64.cc",
      "src/regexp/mips64/regexp-macro-assembler-mips64.cc",
    ]
  } else if (v8_current_cpu == "loong64") {
    sources += [
      ### gcmole(loong64) ###
      "src/codegen/loong64/assembler-loong64.cc",
      "src/codegen/loong64/constants-loong64.cc",
      "src/codegen/loong64/cpu-loong64.cc",
      "src/codegen/loong64/interface-descriptors-loong64-inl.h",
      "src/codegen/loong64/macro-assembler-loong64.cc",
      "src/deoptimizer/loong64/deoptimizer-loong64.cc",
      "src/diagnostics/loong64/disasm-loong64.cc",
      "src/diagnostics/loong64/unwinder-loong64.cc",
      "src/execution/loong64/frame-constants-loong64.cc",
      "src/execution/loong64/simulator-loong64.cc",
      "src/regexp/loong64/regexp-macro-assembler-loong64.cc",
    ]
    if (v8_enable_webassembly) {
      # Trap handling is enabled on loong64 Linux and in simulators on
      # x64 on Linux.
      if ((current_cpu == "loong64" && is_linux) ||
          (current_cpu == "x64" && is_linux)) {
        sources += [
          "src/trap-handler/handler-inside-posix.cc",
          "src/trap-handler/handler-outside-posix.cc",
        ]
      }
      if (current_cpu == "x64" && is_linux) {
        sources += [ "src/trap-handler/handler-outside-simulator.cc" ]
      }
    }
  } else if (v8_current_cpu == "ppc") {
    sources += [
      ### gcmole(ppc) ###
      "src/codegen/ppc/assembler-ppc.cc",
      "src/codegen/ppc/constants-ppc.cc",
      "src/codegen/ppc/cpu-ppc.cc",
      "src/codegen/ppc/macro-assembler-ppc.cc",
      "src/deoptimizer/ppc/deoptimizer-ppc.cc",
      "src/diagnostics/ppc/disasm-ppc.cc",
      "src/diagnostics/ppc/eh-frame-ppc.cc",
      "src/diagnostics/ppc/unwinder-ppc.cc",
      "src/execution/ppc/frame-constants-ppc.cc",
      "src/execution/ppc/simulator-ppc.cc",
      "src/regexp/ppc/regexp-macro-assembler-ppc.cc",
    ]
  } else if (v8_current_cpu == "ppc64") {
    sources += [
      ### gcmole(ppc64) ###
      "src/codegen/ppc/assembler-ppc.cc",
      "src/codegen/ppc/constants-ppc.cc",
      "src/codegen/ppc/cpu-ppc.cc",
      "src/codegen/ppc/macro-assembler-ppc.cc",
      "src/deoptimizer/ppc/deoptimizer-ppc.cc",
      "src/diagnostics/ppc/disasm-ppc.cc",
      "src/diagnostics/ppc/eh-frame-ppc.cc",
      "src/diagnostics/ppc/unwinder-ppc.cc",
      "src/execution/ppc/frame-constants-ppc.cc",
      "src/execution/ppc/simulator-ppc.cc",
      "src/regexp/ppc/regexp-macro-assembler-ppc.cc",
    ]
  } else if (v8_current_cpu == "s390" || v8_current_cpu == "s390x") {
    sources += [
      ### gcmole(s390) ###
      "src/codegen/s390/assembler-s390.cc",
      "src/codegen/s390/constants-s390.cc",
      "src/codegen/s390/cpu-s390.cc",
      "src/codegen/s390/macro-assembler-s390.cc",
      "src/deoptimizer/s390/deoptimizer-s390.cc",
      "src/diagnostics/s390/disasm-s390.cc",
      "src/diagnostics/s390/eh-frame-s390.cc",
      "src/diagnostics/s390/unwinder-s390.cc",
      "src/execution/s390/frame-constants-s390.cc",
      "src/execution/s390/simulator-s390.cc",
      "src/regexp/s390/regexp-macro-assembler-s390.cc",
    ]
  } else if (v8_current_cpu == "riscv64") {
    sources += [
      ### gcmole(riscv64) ###
      "src/codegen/riscv/assembler-riscv.cc",
      "src/codegen/riscv/base-assembler-riscv.cc",
      "src/codegen/riscv/base-constants-riscv.cc",
      "src/codegen/riscv/base-riscv-i.cc",
      "src/codegen/riscv/cpu-riscv.cc",
      "src/codegen/riscv/extension-riscv-a.cc",
      "src/codegen/riscv/extension-riscv-b.cc",
      "src/codegen/riscv/extension-riscv-c.cc",
      "src/codegen/riscv/extension-riscv-d.cc",
      "src/codegen/riscv/extension-riscv-f.cc",
      "src/codegen/riscv/extension-riscv-m.cc",
      "src/codegen/riscv/extension-riscv-v.cc",
      "src/codegen/riscv/extension-riscv-zicond.cc",
      "src/codegen/riscv/extension-riscv-zicsr.cc",
      "src/codegen/riscv/extension-riscv-zifencei.cc",
      "src/codegen/riscv/macro-assembler-riscv.cc",
      "src/deoptimizer/riscv/deoptimizer-riscv.cc",
      "src/diagnostics/riscv/disasm-riscv.cc",
      "src/diagnostics/riscv/unwinder-riscv.cc",
      "src/execution/riscv/frame-constants-riscv.cc",
      "src/execution/riscv/simulator-riscv.cc",
      "src/regexp/riscv/regexp-macro-assembler-riscv.cc",
    ]
    if (v8_enable_webassembly) {
      # Trap handling is enabled on riscv64 Linux and in simulators on
      # x64 on Linux.
      if ((current_cpu == "riscv64" && is_linux) ||
          (current_cpu == "x64" && is_linux)) {
        sources += [
          "src/trap-handler/handler-inside-posix.cc",
          "src/trap-handler/handler-outside-posix.cc",
        ]
      }
      if (current_cpu == "x64" && is_linux) {
        sources += [ "src/trap-handler/handler-outside-simulator.cc" ]
      }
    }
  } else if (v8_current_cpu == "riscv32") {
    sources += [
      ### gcmole(riscv32) ###
      "src/codegen/riscv/assembler-riscv.cc",
      "src/codegen/riscv/base-assembler-riscv.cc",
      "src/codegen/riscv/base-constants-riscv.cc",
      "src/codegen/riscv/base-riscv-i.cc",
      "src/codegen/riscv/cpu-riscv.cc",
      "src/codegen/riscv/extension-riscv-a.cc",
      "src/codegen/riscv/extension-riscv-b.cc",
      "src/codegen/riscv/extension-riscv-c.cc",
      "src/codegen/riscv/extension-riscv-d.cc",
      "src/codegen/riscv/extension-riscv-f.cc",
      "src/codegen/riscv/extension-riscv-m.cc",
      "src/codegen/riscv/extension-riscv-v.cc",
      "src/codegen/riscv/extension-riscv-zicond.cc",
      "src/codegen/riscv/extension-riscv-zicsr.cc",
      "src/codegen/riscv/extension-riscv-zifencei.cc",
      "src/codegen/riscv/macro-assembler-riscv.cc",
      "src/deoptimizer/riscv/deoptimizer-riscv.cc",
      "src/diagnostics/riscv/disasm-riscv.cc",
      "src/diagnostics/riscv/unwinder-riscv.cc",
      "src/execution/riscv/frame-constants-riscv.cc",
      "src/execution/riscv/simulator-riscv.cc",
      "src/regexp/riscv/regexp-macro-assembler-riscv.cc",
    ]
  }

  # Architecture independent but platform-specific sources
  if (is_win) {
    if (v8_enable_etw_stack_walking) {
      sources += [
        "src/diagnostics/etw-jit-win.cc",
        "src/diagnostics/etw-jit-win.h",
      ]
    }
  }

  configs = [
    ":internal_config",
    ":cppgc_base_config",
  ]

  deps = [
    ":torque_generated_definitions",
    ":v8_bigint",
    ":v8_headers",
    ":v8_heap_base",
    ":v8_libbase",
    ":v8_shared_internal_headers",
    ":v8_tracing",
    ":v8_version",
    "src/inspector:inspector",
  ]

  public_deps = [
    ":cppgc_base",
    ":generate_bytecode_builtins_list",
    ":run_torque",
    ":v8_abseil",
    ":v8_headers",
    ":v8_internal_headers",
    ":v8_maybe_icu",
  ]

  if (v8_fuzzilli) {
    sources += [
      "src/fuzzilli/cov.cc",
      "src/fuzzilli/cov.h",
      "src/fuzzilli/fuzzilli.cc",
      "src/fuzzilli/fuzzilli.h",
    ]
  }

  if (v8_enable_i18n_support) {
    deps += [ ":run_gen-regexp-special-case" ]
    sources += [ "$target_gen_dir/src/regexp/special-case.cc" ]
    if (is_win) {
      deps += [ "$v8_icu_path:icudata" ]
    }
  } else {
    sources -= [
      "src/builtins/builtins-intl.cc",
      "src/objects/intl-objects.cc",
      "src/objects/js-break-iterator.cc",
      "src/objects/js-collator.cc",
      "src/objects/js-date-time-format.cc",
      "src/objects/js-display-names.cc",
      "src/objects/js-duration-format.cc",
      "src/objects/js-list-format.cc",
      "src/objects/js-locale.cc",
      "src/objects/js-number-format.cc",
      "src/objects/js-plural-rules.cc",
      "src/objects/js-relative-time-format.cc",
      "src/objects/js-segment-iterator.cc",
      "src/objects/js-segmenter.cc",
      "src/objects/js-segments.cc",
      "src/runtime/runtime-intl.cc",
      "src/strings/char-predicates.cc",
    ]
  }

  if (v8_use_zlib) {
    deps += [
      "$v8_zlib_path",
      "$v8_zlib_path/google:compression_utils_portable",
    ]
  }

  if (v8_postmortem_support) {
    sources += [ "$target_gen_dir/debug-support.cc" ]
    deps += [ ":postmortem-metadata" ]
  }

  libs = []

  if (v8_enable_third_party_heap) {
    libs += v8_third_party_heap_libs
  }

  # Platforms that don't have CAS support need to link atomic library
  # to implement atomic memory access
  if (v8_current_cpu == "mips64" || v8_current_cpu == "mips64el" ||
      v8_current_cpu == "ppc" || v8_current_cpu == "ppc64" ||
      (current_os != "zos" &&
       (v8_current_cpu == "s390" || v8_current_cpu == "s390x")) ||
      v8_current_cpu == "riscv64" || v8_current_cpu == "riscv32") {
    if (!is_clang) {
      libs += [ "atomic" ]
    }
  }

  if (v8_enable_vtunetracemark && (is_linux || is_chromeos || is_win)) {
    sources += [
      "src/extensions/vtunedomain-support-extension.cc",
      "src/extensions/vtunedomain-support-extension.h",
    ]
    deps += [ "src/third_party/vtune:v8_vtune_trace_mark" ]
  }
}

group("v8_base") {
  public_deps = [
    ":v8_base_without_compiler",
    ":v8_compiler",
  ]

  if (v8_enable_turbofan) {
    public_deps += [ ":v8_turboshaft" ]
  }
}

v8_source_set("torque_base") {
  visibility = [ ":*" ]  # Only targets in this file can depend on this.

  sources = [
    "src/numbers/integer-literal-inl.h",
    "src/numbers/integer-literal.h",
    "src/torque/ast.h",
    "src/torque/cc-generator.cc",
    "src/torque/cc-generator.h",
    "src/torque/cfg.cc",
    "src/torque/cfg.h",
    "src/torque/class-debug-reader-generator.cc",
    "src/torque/constants.h",
    "src/torque/cpp-builder.cc",
    "src/torque/cpp-builder.h",
    "src/torque/csa-generator.cc",
    "src/torque/csa-generator.h",
    "src/torque/declarable.cc",
    "src/torque/declarable.h",
    "src/torque/declaration-visitor.cc",
    "src/torque/declaration-visitor.h",
    "src/torque/declarations.cc",
    "src/torque/declarations.h",
    "src/torque/earley-parser.cc",
    "src/torque/earley-parser.h",
    "src/torque/global-context.cc",
    "src/torque/global-context.h",
    "src/torque/implementation-visitor.cc",
    "src/torque/implementation-visitor.h",
    "src/torque/instance-type-generator.cc",
    "src/torque/instructions.cc",
    "src/torque/instructions.h",
    "src/torque/kythe-data.cc",
    "src/torque/kythe-data.h",
    "src/torque/parameter-difference.h",
    "src/torque/server-data.cc",
    "src/torque/server-data.h",
    "src/torque/source-positions.cc",
    "src/torque/source-positions.h",
    "src/torque/torque-code-generator.cc",
    "src/torque/torque-code-generator.h",
    "src/torque/torque-compiler.cc",
    "src/torque/torque-compiler.h",
    "src/torque/torque-parser.cc",
    "src/torque/torque-parser.h",
    "src/torque/type-inference.cc",
    "src/torque/type-inference.h",
    "src/torque/type-oracle.cc",
    "src/torque/type-oracle.h",
    "src/torque/type-visitor.cc",
    "src/torque/type-visitor.h",
    "src/torque/types.cc",
    "src/torque/types.h",
    "src/torque/utils.cc",
    "src/torque/utils.h",
  ]

  deps = [
    ":v8_flags",
    ":v8_shared_internal_headers",
  ]

  public_deps = [
    ":v8_config_headers",
    ":v8_libbase",
  ]

  # The use of exceptions for Torque in violation of the Chromium style-guide
  # is justified by the fact that it is only used from the non-essential
  # language server and can be removed anytime if it causes problems.
  configs = [
    ":internal_config",
    "//build/config/compiler:exceptions",
    "//build/config/compiler:rtti",
  ]

  remove_configs = [
    "//build/config/compiler:no_exceptions",
    "//build/config/compiler:no_rtti",
  ]

  if (is_debug && !v8_optimized_debug && v8_enable_fast_torque) {
    # The :no_optimize config is added to v8_add_configs in v8.gni.
    remove_configs += [ "//build/config/compiler:no_optimize" ]
    configs += [ ":always_turbofanimize" ]
  }
}

v8_source_set("torque_ls_base") {
  sources = [
    "src/torque/ls/globals.h",
    "src/torque/ls/json-parser.cc",
    "src/torque/ls/json-parser.h",
    "src/torque/ls/json.cc",
    "src/torque/ls/json.h",
    "src/torque/ls/message-handler.cc",
    "src/torque/ls/message-handler.h",
    "src/torque/ls/message-macros.h",
    "src/torque/ls/message-pipe.h",
    "src/torque/ls/message.h",
  ]

  public_deps = [ ":torque_base" ]

  # The use of exceptions for Torque in violation of the Chromium style-guide
  # is justified by the fact that it is only used from the non-essential
  # language server and can be removed anytime if it causes problems.
  configs = [
    ":internal_config",
    "//build/config/compiler:exceptions",
    "//build/config/compiler:rtti",
  ]

  remove_configs = [
    "//build/config/compiler:no_exceptions",
    "//build/config/compiler:no_rtti",
  ]
}

v8_component("v8_libbase") {
  sources = [
    "src/base/abort-mode.cc",
    "src/base/abort-mode.h",
    "src/base/address-region.h",
    "src/base/atomic-utils.h",
    "src/base/atomicops.h",
    "src/base/base-export.h",
    "src/base/bit-field.h",
    "src/base/bits-iterator.h",
    "src/base/bits.cc",
    "src/base/bits.h",
    "src/base/bounded-page-allocator.cc",
    "src/base/bounded-page-allocator.h",
    "src/base/bounds.h",
    "src/base/build_config.h",
    "src/base/compiler-specific.h",
    "src/base/container-utils.h",
    "src/base/contextual.h",
    "src/base/cpu.cc",
    "src/base/cpu.h",
    "src/base/debug/stack_trace.cc",
    "src/base/debug/stack_trace.h",
    "src/base/discriminated-union.h",
    "src/base/division-by-constant.cc",
    "src/base/division-by-constant.h",
    "src/base/doubly-threaded-list.h",
    "src/base/emulated-virtual-address-subspace.cc",
    "src/base/emulated-virtual-address-subspace.h",
    "src/base/enum-set.h",
    "src/base/export-template.h",
    "src/base/file-utils.cc",
    "src/base/file-utils.h",
    "src/base/flags.h",
    "src/base/free_deleter.h",
    "src/base/functional.h",
    "src/base/hashmap-entry.h",
    "src/base/hashmap.h",
    "src/base/ieee754.cc",
    "src/base/ieee754.h",
    "src/base/immediate-crash.h",
    "src/base/intrusive-set.h",
    "src/base/iterator.h",
    "src/base/lazy-instance.h",
    "src/base/logging.cc",
    "src/base/logging.h",
    "src/base/macros.h",
    "src/base/memory.h",
    "src/base/numbers/bignum-dtoa.cc",
    "src/base/numbers/bignum-dtoa.h",
    "src/base/numbers/bignum.cc",
    "src/base/numbers/bignum.h",
    "src/base/numbers/cached-powers.cc",
    "src/base/numbers/cached-powers.h",
    "src/base/numbers/diy-fp.cc",
    "src/base/numbers/diy-fp.h",
    "src/base/numbers/double.h",
    "src/base/numbers/dtoa.cc",
    "src/base/numbers/dtoa.h",
    "src/base/numbers/fast-dtoa.cc",
    "src/base/numbers/fast-dtoa.h",
    "src/base/numbers/fixed-dtoa.cc",
    "src/base/numbers/fixed-dtoa.h",
    "src/base/numbers/strtod.cc",
    "src/base/numbers/strtod.h",
    "src/base/once.cc",
    "src/base/once.h",
    "src/base/overflowing-math.h",
    "src/base/page-allocator.cc",
    "src/base/page-allocator.h",
    "src/base/platform/condition-variable.cc",
    "src/base/platform/condition-variable.h",
    "src/base/platform/elapsed-timer.h",
    "src/base/platform/memory-protection-key.cc",
    "src/base/platform/memory-protection-key.h",
    "src/base/platform/memory.h",
    "src/base/platform/mutex.cc",
    "src/base/platform/mutex.h",
    "src/base/platform/platform.cc",
    "src/base/platform/platform.h",
    "src/base/platform/semaphore.cc",
    "src/base/platform/semaphore.h",
    "src/base/platform/time.cc",
    "src/base/platform/time.h",
    "src/base/platform/wrappers.h",
    "src/base/platform/yield-processor.h",
    "src/base/pointer-with-payload.h",
    "src/base/region-allocator.cc",
    "src/base/region-allocator.h",
    "src/base/ring-buffer.h",
    "src/base/safe_conversions.h",
    "src/base/safe_conversions_arm_impl.h",
    "src/base/safe_conversions_impl.h",
    "src/base/sanitizer/asan.h",
    "src/base/sanitizer/lsan-page-allocator.cc",
    "src/base/sanitizer/lsan-page-allocator.h",
    "src/base/sanitizer/lsan-virtual-address-space.cc",
    "src/base/sanitizer/lsan-virtual-address-space.h",
    "src/base/sanitizer/lsan.h",
    "src/base/sanitizer/msan.h",
    "src/base/sanitizer/tsan.h",
    "src/base/small-map.h",
    "src/base/small-vector.h",
    "src/base/string-format.h",
    "src/base/strings.cc",
    "src/base/strings.h",
    "src/base/sys-info.cc",
    "src/base/sys-info.h",
    "src/base/template-meta-programming/algorithm.h",
    "src/base/template-meta-programming/functional.h",
    "src/base/template-meta-programming/list.h",
    "src/base/template-meta-programming/string-literal.h",
    "src/base/template-utils.h",
    "src/base/threaded-list.h",
    "src/base/timezone-cache.h",
    "src/base/utils/random-number-generator.cc",
    "src/base/utils/random-number-generator.h",
    "src/base/vector.h",
    "src/base/virtual-address-space-page-allocator.cc",
    "src/base/virtual-address-space-page-allocator.h",
    "src/base/virtual-address-space.cc",
    "src/base/virtual-address-space.h",
    "src/base/vlq-base64.cc",
    "src/base/vlq-base64.h",
    "src/base/vlq.h",
  ]

  configs = [ ":internal_config_base" ]

  public_configs = [ ":libbase_config" ]

  deps = [ ":v8_config_headers" ]

  if (current_os == "zos") {
    public_configs += [ ":zoslib_config" ]
    deps += [ ":zoslib" ]
  }

  libs = []

  data = []

  data_deps = []

  defines = []

  if (is_component_build) {
    defines = [ "BUILDING_V8_BASE_SHARED" ]
  }

  if (is_posix || is_fuchsia) {
    sources += [
      "src/base/platform/platform-posix.cc",
      "src/base/platform/platform-posix.h",
    ]
    if (current_os != "aix" && current_os != "zos") {
      sources += [
        "src/base/platform/platform-posix-time.cc",
        "src/base/platform/platform-posix-time.h",
      ]
    }
  }

  if (is_linux || is_chromeos) {
    sources += [
      "src/base/debug/stack_trace_posix.cc",
      "src/base/platform/platform-linux.cc",
      "src/base/platform/platform-linux.h",
    ]

    libs = [
      "dl",
      "rt",
    ]
  } else if (current_os == "aix") {
    sources += [
      "src/base/debug/stack_trace_posix.cc",
      "src/base/platform/platform-aix.cc",
    ]

    libs = [ "dl" ]
  } else if (is_android) {
    if (current_toolchain == host_toolchain) {
      libs = [
        "dl",
        "rt",
      ]
      if (host_os == "mac") {
        sources += [
          "src/base/debug/stack_trace_posix.cc",
          "src/base/platform/platform-darwin.cc",
        ]
      } else {
        sources += [
          "src/base/debug/stack_trace_posix.cc",
          "src/base/platform/platform-linux.cc",
        ]
      }
    } else {
      sources += [
        "src/base/debug/stack_trace_android.cc",
        "src/base/platform/platform-linux.cc",
      ]
    }
  } else if (is_fuchsia) {
    sources += [
      "src/base/debug/stack_trace_fuchsia.cc",
      "src/base/platform/platform-fuchsia.cc",
    ]
    deps += [
      "//third_party/fuchsia-sdk/sdk/fidl/fuchsia.kernel:fuchsia.kernel_cpp",
      "//third_party/fuchsia-sdk/sdk/pkg/component_incoming_cpp",
      "//third_party/fuchsia-sdk/sdk/pkg/zx",
    ]
  } else if (is_mac) {
    sources += [
      "src/base/debug/stack_trace_posix.cc",
      "src/base/platform/platform-darwin.cc",
    ]
  } else if (is_ios) {
    sources += [
      "src/base/debug/stack_trace_posix.cc",
      "src/base/platform/platform-darwin.cc",
    ]
  } else if (is_win) {
    # TODO(infra): Add support for cygwin.
    sources += [
      "src/base/debug/stack_trace_win.cc",
      "src/base/platform/platform-win32.cc",
      "src/base/platform/platform-win32.h",
      "src/base/win32-headers.h",
    ]

    defines += [ "_CRT_RAND_S" ]  # for rand_s()

    libs = [
      "dbghelp.lib",
      "winmm.lib",
      "ws2_32.lib",
    ]

    if (v8_enable_etw_stack_walking) {
      libs += [ "advapi32.lib" ]  # Needed for TraceLoggingProvider.h
    }

    data_deps += [ "//build/win:runtime_libs" ]
  } else if (current_os == "zos") {
    sources += [
      "src/base/debug/stack_trace_zos.cc",
      "src/base/platform/platform-zos.cc",
    ]
  }

  if (v8_current_cpu == "mips64") {
    # Add runtime libs for mips.
    data += [
      "tools/mips_toolchain/sysroot/usr/lib/",
      "tools/mips_toolchain/mips-mti-linux-gnu/lib",
    ]
  }

  if (is_ubsan && (v8_current_cpu == "x86" || v8_current_cpu == "arm")) {
    # Special UBSan 32-bit requirement.
    sources += [ "src/base/ubsan.cc" ]
  }

  if (v8_current_cpu == "riscv64" || v8_current_cpu == "riscv32") {
    if (!is_clang) {
      libs += [ "atomic" ]
    }
  }

  if (is_tsan && !build_with_chromium) {
    data += [ "tools/sanitizers/tsan_suppressions.txt" ]
  }

  if (using_sanitizer && !build_with_chromium) {
    data_deps +=
        [ "//build/config/clang:llvm-symbolizer_data($host_toolchain)" ]
  }

  if (v8_use_libm_trig_functions) {
    deps += [ ":libm" ]
  }

  # TODO(infra): Add support for qnx, freebsd, openbsd, netbsd, and solaris.
}

if (v8_use_libm_trig_functions) {
  source_set("libm") {
    sources = [
      "third_party/glibc/src/sysdeps/ieee754/dbl-64/branred.c",
      "third_party/glibc/src/sysdeps/ieee754/dbl-64/branred.h",
      "third_party/glibc/src/sysdeps/ieee754/dbl-64/dla.h",
      "third_party/glibc/src/sysdeps/ieee754/dbl-64/endian.h",
      "third_party/glibc/src/sysdeps/ieee754/dbl-64/mydefs.h",
      "third_party/glibc/src/sysdeps/ieee754/dbl-64/s_sin.c",
      "third_party/glibc/src/sysdeps/ieee754/dbl-64/sincostab.c",
      "third_party/glibc/src/sysdeps/ieee754/dbl-64/trig.h",
      "third_party/glibc/src/sysdeps/ieee754/dbl-64/usncs.h",
    ]
    configs += [ "//build/config/compiler:no_chromium_code" ]
    configs -= [ "//build/config/compiler:chromium_code" ]
    if (!is_debug) {
      # Build code using -O3, see: crbug.com/1084371.
      configs += [ "//build/config/compiler:optimize_speed" ]
    }
  }
}

v8_component("v8_libplatform") {
  sources = [
    "include/libplatform/libplatform-export.h",
    "include/libplatform/libplatform.h",
    "include/libplatform/v8-tracing.h",
    "src/libplatform/default-foreground-task-runner.cc",
    "src/libplatform/default-foreground-task-runner.h",
    "src/libplatform/default-job.cc",
    "src/libplatform/default-job.h",
    "src/libplatform/default-platform.cc",
    "src/libplatform/default-platform.h",
    "src/libplatform/default-thread-isolated-allocator.cc",
    "src/libplatform/default-thread-isolated-allocator.h",
    "src/libplatform/default-worker-threads-task-runner.cc",
    "src/libplatform/default-worker-threads-task-runner.h",
    "src/libplatform/delayed-task-queue.cc",
    "src/libplatform/delayed-task-queue.h",
    "src/libplatform/task-queue.cc",
    "src/libplatform/task-queue.h",
    "src/libplatform/tracing/trace-buffer.cc",
    "src/libplatform/tracing/trace-buffer.h",
    "src/libplatform/tracing/trace-config.cc",
    "src/libplatform/tracing/trace-object.cc",
    "src/libplatform/tracing/trace-writer.cc",
    "src/libplatform/tracing/trace-writer.h",
    "src/libplatform/tracing/tracing-controller.cc",
    "src/libplatform/worker-thread.cc",
    "src/libplatform/worker-thread.h",
    "src/tracing/trace-event-no-perfetto.h",
  ]

  configs = [ ":internal_config_base" ]

  if (is_component_build) {
    defines = [ "BUILDING_V8_PLATFORM_SHARED" ]
  }

  public_configs = [ ":libplatform_config" ]

  public_deps = []

  deps = [
    ":v8_config_headers",
    ":v8_libbase",
    ":v8_tracing",
  ]

  if (v8_use_perfetto) {
    sources -= [
      "src/libplatform/tracing/trace-buffer.cc",
      "src/libplatform/tracing/trace-buffer.h",
      "src/libplatform/tracing/trace-object.cc",
      "src/libplatform/tracing/trace-writer.cc",
      "src/libplatform/tracing/trace-writer.h",
      "src/tracing/trace-event-no-perfetto.h",
    ]
    sources += [ "src/libplatform/tracing/trace-event-listener.h" ]
  }

  if (v8_enable_system_instrumentation) {
    sources += [ "src/libplatform/tracing/recorder.h" ]
    if (is_mac) {
      sources += [ "src/libplatform/tracing/recorder-mac.cc" ]
    } else if (is_win) {
      sources += [ "src/libplatform/tracing/recorder-win.cc" ]
    }
  }

  if (v8_current_cpu == "riscv64" || v8_current_cpu == "riscv32") {
    if (!is_clang) {
      libs = [ "atomic" ]
    }
  }
}

v8_source_set("fuzzer_support") {
  visibility = [ ":*" ]  # Only targets in this file can depend on this.

  sources = [
    "test/fuzzer/fuzzer-support.cc",
    "test/fuzzer/fuzzer-support.h",
  ]

  configs = [ ":internal_config_base" ]

  public_deps = [
    ":v8",
    ":v8_libbase",
    ":v8_libplatform",
    ":v8_maybe_icu",
  ]
}

v8_source_set("v8_bigint") {
  sources = [
    "src/bigint/bigint-internal.cc",
    "src/bigint/bigint-internal.h",
    "src/bigint/bigint.h",
    "src/bigint/bitwise.cc",
    "src/bigint/digit-arithmetic.h",
    "src/bigint/div-burnikel.cc",
    "src/bigint/div-helpers.cc",
    "src/bigint/div-helpers.h",
    "src/bigint/div-schoolbook.cc",
    "src/bigint/fromstring.cc",
    "src/bigint/mul-karatsuba.cc",
    "src/bigint/mul-schoolbook.cc",
    "src/bigint/tostring.cc",
    "src/bigint/util.h",
    "src/bigint/vector-arithmetic.cc",
    "src/bigint/vector-arithmetic.h",
  ]

  if (v8_advanced_bigint_algorithms) {
    sources += [
      "src/bigint/div-barrett.cc",
      "src/bigint/mul-fft.cc",
      "src/bigint/mul-toom.cc",
    ]
  }

  configs = [ ":internal_config" ]
}

v8_header_set("v8_heap_base_headers") {
  sources = [
    "src/heap/base/active-system-pages.h",
    "src/heap/base/basic-slot-set.h",
    "src/heap/base/bytes.h",
    "src/heap/base/cached-unordered-map.h",
    "src/heap/base/incremental-marking-schedule.h",
    "src/heap/base/memory-tagging.h",
    "src/heap/base/stack.h",
    "src/heap/base/worklist.h",
  ]

  configs = [ ":internal_config" ]

  public_deps = [ ":v8_libbase" ]
}

v8_source_set("v8_heap_base") {
  sources = [
    "src/heap/base/active-system-pages.cc",
    "src/heap/base/incremental-marking-schedule.cc",
    "src/heap/base/memory-tagging.cc",
    "src/heap/base/stack.cc",
    "src/heap/base/worklist.cc",
  ]

  if (is_clang || !is_win) {
    if (current_cpu == "x64") {
      if (is_win) {
        # Prefer a masm version with unwind directives.
        sources += [ "src/heap/base/asm/x64/push_registers_masm.asm" ]
      } else {
        sources += [ "src/heap/base/asm/x64/push_registers_asm.cc" ]
      }
    } else if (current_cpu == "x86") {
      sources += [ "src/heap/base/asm/ia32/push_registers_asm.cc" ]
    } else if (current_cpu == "arm") {
      sources += [ "src/heap/base/asm/arm/push_registers_asm.cc" ]
    } else if (current_cpu == "arm64") {
      sources += [ "src/heap/base/asm/arm64/push_registers_asm.cc" ]
    } else if (current_cpu == "ppc64") {
      sources += [ "src/heap/base/asm/ppc/push_registers_asm.cc" ]
    } else if (current_os == "zos") {
      sources += [ "src/heap/base/asm/zos/push_registers_asm.cc" ]
    } else if (current_cpu == "s390x") {
      sources += [ "src/heap/base/asm/s390/push_registers_asm.cc" ]
    } else if (current_cpu == "mips64el") {
      sources += [ "src/heap/base/asm/mips64/push_registers_asm.cc" ]
    } else if (current_cpu == "loong64") {
      sources += [ "src/heap/base/asm/loong64/push_registers_asm.cc" ]
    } else if (current_cpu == "riscv64" || current_cpu == "riscv32") {
      sources += [ "src/heap/base/asm/riscv/push_registers_asm.cc" ]
    }
  } else if (is_win) {
    if (current_cpu == "x64") {
      sources += [ "src/heap/base/asm/x64/push_registers_masm.asm" ]
    } else if (current_cpu == "x86") {
      sources += [ "src/heap/base/asm/ia32/push_registers_masm.asm" ]
    } else if (current_cpu == "arm64") {
      sources += [ "src/heap/base/asm/arm64/push_registers_masm.S" ]
    }
  }

  configs = [ ":internal_config" ]

  deps = [ ":v8_config_headers" ]

  public_deps = [
    ":v8_heap_base_headers",
    ":v8_libbase",
  ]
}

# This is split out to be a non-code containing target that the Chromium browser
# can depend upon to get basic cppgc types.
v8_header_set("cppgc_headers") {
  configs = [ ":internal_config" ]
  public_configs = [
    ":v8_header_features",
    ":cppgc_header_features",
  ]

  sources = [
    "include/cppgc/allocation.h",
    "include/cppgc/common.h",
    "include/cppgc/cross-thread-persistent.h",
    "include/cppgc/custom-space.h",
    "include/cppgc/default-platform.h",
    "include/cppgc/ephemeron-pair.h",
    "include/cppgc/explicit-management.h",
    "include/cppgc/garbage-collected.h",
    "include/cppgc/heap-consistency.h",
    "include/cppgc/heap-handle.h",
    "include/cppgc/heap-state.h",
    "include/cppgc/heap-statistics.h",
    "include/cppgc/heap.h",
    "include/cppgc/internal/api-constants.h",
    "include/cppgc/internal/atomic-entry-flag.h",
    "include/cppgc/internal/base-page-handle.h",
    "include/cppgc/internal/compiler-specific.h",
    "include/cppgc/internal/finalizer-trait.h",
    "include/cppgc/internal/gc-info.h",
    "include/cppgc/internal/member-storage.h",
    "include/cppgc/internal/name-trait.h",
    "include/cppgc/internal/persistent-node.h",
    "include/cppgc/internal/pointer-policies.h",
    "include/cppgc/internal/write-barrier.h",
    "include/cppgc/liveness-broker.h",
    "include/cppgc/macros.h",
    "include/cppgc/member.h",
    "include/cppgc/name-provider.h",
    "include/cppgc/object-size-trait.h",
    "include/cppgc/persistent.h",
    "include/cppgc/platform.h",
    "include/cppgc/prefinalizer.h",
    "include/cppgc/process-heap-statistics.h",
    "include/cppgc/sentinel-pointer.h",
    "include/cppgc/source-location.h",

    # TODO(v8:11952): Remove the testing header here once depending on both,
    # //v8:v8 and //v8:v8_for_testing does not result in ODR violations.
    "include/cppgc/testing.h",
    "include/cppgc/trace-trait.h",
    "include/cppgc/type-traits.h",
    "include/cppgc/visitor.h",
  ]

  if (cppgc_enable_caged_heap) {
    sources += [ "include/cppgc/internal/caged-heap-local-data.h" ]
    sources += [ "include/cppgc/internal/caged-heap.h" ]
  }

  deps = [
    ":v8_libbase",
    ":v8_libplatform",
  ]

  if (current_os == "zos" && is_component_build) {
    deps += [ ":zoslib" ]
  }

  public_deps = [ ":v8_config_headers" ]
}

v8_source_set("cppgc_base") {
  visibility = [ ":*" ]

  sources = [
    "src/heap/cppgc/allocation.cc",
    "src/heap/cppgc/compaction-worklists.cc",
    "src/heap/cppgc/compaction-worklists.h",
    "src/heap/cppgc/compactor.cc",
    "src/heap/cppgc/compactor.h",
    "src/heap/cppgc/concurrent-marker.cc",
    "src/heap/cppgc/concurrent-marker.h",
    "src/heap/cppgc/explicit-management.cc",
    "src/heap/cppgc/free-list.cc",
    "src/heap/cppgc/free-list.h",
    "src/heap/cppgc/garbage-collector.h",
    "src/heap/cppgc/gc-info-table.cc",
    "src/heap/cppgc/gc-info-table.h",
    "src/heap/cppgc/gc-info.cc",
    "src/heap/cppgc/gc-invoker.cc",
    "src/heap/cppgc/gc-invoker.h",
    "src/heap/cppgc/globals.h",
    "src/heap/cppgc/heap-base.cc",
    "src/heap/cppgc/heap-base.h",
    "src/heap/cppgc/heap-config.h",
    "src/heap/cppgc/heap-consistency.cc",
    "src/heap/cppgc/heap-growing.cc",
    "src/heap/cppgc/heap-growing.h",
    "src/heap/cppgc/heap-object-header.cc",
    "src/heap/cppgc/heap-object-header.h",
    "src/heap/cppgc/heap-page.cc",
    "src/heap/cppgc/heap-page.h",
    "src/heap/cppgc/heap-space.cc",
    "src/heap/cppgc/heap-space.h",
    "src/heap/cppgc/heap-state.cc",
    "src/heap/cppgc/heap-statistics-collector.cc",
    "src/heap/cppgc/heap-statistics-collector.h",
    "src/heap/cppgc/heap-visitor.h",
    "src/heap/cppgc/heap.cc",
    "src/heap/cppgc/heap.h",
    "src/heap/cppgc/liveness-broker.cc",
    "src/heap/cppgc/liveness-broker.h",
    "src/heap/cppgc/logging.cc",
    "src/heap/cppgc/marker.cc",
    "src/heap/cppgc/marker.h",
    "src/heap/cppgc/marking-state.cc",
    "src/heap/cppgc/marking-state.h",
    "src/heap/cppgc/marking-verifier.cc",
    "src/heap/cppgc/marking-verifier.h",
    "src/heap/cppgc/marking-visitor.cc",
    "src/heap/cppgc/marking-visitor.h",
    "src/heap/cppgc/marking-worklists.cc",
    "src/heap/cppgc/marking-worklists.h",
    "src/heap/cppgc/member-storage.cc",
    "src/heap/cppgc/member-storage.h",
    "src/heap/cppgc/memory.cc",
    "src/heap/cppgc/memory.h",
    "src/heap/cppgc/metric-recorder.h",
    "src/heap/cppgc/name-trait.cc",
    "src/heap/cppgc/object-allocator.cc",
    "src/heap/cppgc/object-allocator.h",
    "src/heap/cppgc/object-poisoner.h",
    "src/heap/cppgc/object-size-trait.cc",
    "src/heap/cppgc/object-start-bitmap.h",
    "src/heap/cppgc/object-view.h",
    "src/heap/cppgc/page-memory.cc",
    "src/heap/cppgc/page-memory.h",
    "src/heap/cppgc/persistent-node.cc",
    "src/heap/cppgc/platform.cc",
    "src/heap/cppgc/platform.h",
    "src/heap/cppgc/pointer-policies.cc",
    "src/heap/cppgc/prefinalizer-handler.cc",
    "src/heap/cppgc/prefinalizer-handler.h",
    "src/heap/cppgc/process-heap-statistics.cc",
    "src/heap/cppgc/process-heap-statistics.h",
    "src/heap/cppgc/process-heap.cc",
    "src/heap/cppgc/process-heap.h",
    "src/heap/cppgc/raw-heap.cc",
    "src/heap/cppgc/raw-heap.h",
    "src/heap/cppgc/remembered-set.cc",
    "src/heap/cppgc/remembered-set.h",
    "src/heap/cppgc/stats-collector.cc",
    "src/heap/cppgc/stats-collector.h",
    "src/heap/cppgc/sweeper.cc",
    "src/heap/cppgc/sweeper.h",
    "src/heap/cppgc/task-handle.h",
    "src/heap/cppgc/unmarker.h",

    # TODO(v8:11952): Remove the testing header here once depending on both,
    # //v8:v8 and //v8:v8_for_testing does not result in ODR violations.
    "src/heap/cppgc/testing.cc",
    "src/heap/cppgc/trace-event.h",
    "src/heap/cppgc/trace-trait.cc",
    "src/heap/cppgc/virtual-memory.cc",
    "src/heap/cppgc/virtual-memory.h",
    "src/heap/cppgc/visitor.cc",
    "src/heap/cppgc/visitor.h",
    "src/heap/cppgc/write-barrier.cc",
    "src/heap/cppgc/write-barrier.h",
  ]

  if (cppgc_enable_caged_heap) {
    sources += [
      "src/heap/cppgc/caged-heap-local-data.cc",
      "src/heap/cppgc/caged-heap.cc",
      "src/heap/cppgc/caged-heap.h",
    ]
  }

  configs = [
    ":internal_config",
    ":cppgc_base_config",
  ]

  public_deps = [
    ":cppgc_headers",
    ":v8_heap_base",
    ":v8_libbase",
    ":v8_libplatform",
  ]

  if (cppgc_is_standalone && !v8_use_perfetto) {
    sources += [ "src/tracing/trace-event-no-perfetto.h" ]
  } else {
    public_deps += [ ":v8_tracing" ]
  }

  if (v8_use_perfetto) {
    sources += [
      "src/tracing/trace-categories.cc",
      "src/tracing/trace-categories.h",
    ]
  }
}

if (v8_check_header_includes) {
  # This file will be generated by tools/generate-header-include-checks.py
  # if the "check_v8_header_includes" gclient variable is set.
  import("check-header-includes/sources.gni")
  v8_source_set("check_headers") {
    configs = [ ":internal_config" ]
    sources = check_header_includes_sources

    # Any rules that contain headers files should be added here either directly
    # or indirectly by including something that has it transitively in its
    # public_deps.
    deps = [
      ":d8",
      ":mksnapshot",
      ":torque_base",
      ":torque_ls_base",
      ":v8_base_without_compiler",
      ":v8_bigint",
      ":v8_headers",
      ":v8_initializers",
      ":v8_internal_headers",
      ":v8_libbase",
      ":v8_maybe_icu",
      ":v8_version",
      ":wee8",
      "src/inspector:inspector",
      "src/inspector:inspector_string_conversions",
    ]
  }
}

###############################################################################
# Produce a single static library for embedders
#

if (v8_monolithic) {
  assert(!is_component_build,
         "Set `is_component_build = false` for v8_monolithic.")

  # Using external startup data would produce separate files.
  assert(!v8_use_external_startup_data,
         "Set `v8_use_external_startup_data = false` for v8_monolithic.")
  v8_static_library("v8_monolith") {
    deps = [
      ":v8",
      ":v8_libbase",
      ":v8_libplatform",
      "//build/win:default_exe_manifest",
    ]

    configs = [ ":internal_config" ]
  }
}

if (v8_enable_webassembly) {
  v8_static_library("wee8") {
    deps = [
      ":v8_base",
      ":v8_libbase",
      ":v8_libplatform",
      ":v8_shared_internal_headers",
      ":v8_snapshot",
      "//build/win:default_exe_manifest",
    ]
    if (v8_enable_vtunejit) {
      deps += [ "src/third_party/vtune:v8_vtune" ]
    }

    # TODO: v8dll-main.cc equivalent for shared library builds

    configs = [ ":internal_config" ]

    sources = [
      ### gcmole(all) ###
      "src/wasm/c-api.cc",
      "src/wasm/c-api.h",
      "third_party/wasm-api/wasm.h",
      "third_party/wasm-api/wasm.hh",
    ]
  }
}

###############################################################################
# Executables
#

if (current_toolchain == v8_generator_toolchain) {
  v8_executable("bytecode_builtins_list_generator") {
    visibility = [ ":*" ]  # Only targets in this file can depend on this.

    include_dirs = [ "." ]

    sources = [
      "src/builtins/generate-bytecodes-builtins-list.cc",
      "src/interpreter/bytecode-operands.cc",
      "src/interpreter/bytecode-operands.h",
      "src/interpreter/bytecode-traits.h",
      "src/interpreter/bytecodes.cc",
      "src/interpreter/bytecodes.h",
    ]

    configs = [ ":internal_config" ]

    deps = [
      ":v8_libbase",
      ":v8_shared_internal_headers",
      "//build/win:default_exe_manifest",
    ]
  }
}

if (current_toolchain == v8_snapshot_toolchain) {
  v8_executable("mksnapshot") {
    sources = [
      "src/snapshot/embedded/embedded-empty.cc",
      "src/snapshot/embedded/embedded-file-writer.cc",
      "src/snapshot/embedded/embedded-file-writer.h",
      "src/snapshot/embedded/platform-embedded-file-writer-aix.cc",
      "src/snapshot/embedded/platform-embedded-file-writer-aix.h",
      "src/snapshot/embedded/platform-embedded-file-writer-base.cc",
      "src/snapshot/embedded/platform-embedded-file-writer-base.h",
      "src/snapshot/embedded/platform-embedded-file-writer-generic.cc",
      "src/snapshot/embedded/platform-embedded-file-writer-generic.h",
      "src/snapshot/embedded/platform-embedded-file-writer-mac.cc",
      "src/snapshot/embedded/platform-embedded-file-writer-mac.h",
      "src/snapshot/embedded/platform-embedded-file-writer-win.cc",
      "src/snapshot/embedded/platform-embedded-file-writer-win.h",
      "src/snapshot/embedded/platform-embedded-file-writer-zos.cc",
      "src/snapshot/embedded/platform-embedded-file-writer-zos.h",
      "src/snapshot/mksnapshot.cc",
      "src/snapshot/snapshot-empty.cc",
      "src/snapshot/static-roots-gen.cc",
      "src/snapshot/static-roots-gen.h",
    ]

    if (v8_control_flow_integrity) {
      sources += [ "src/deoptimizer/deoptimizer-cfi-empty.cc" ]
    }

    configs = [
      ":internal_config",
      ":disable_icf",
    ]

    deps = [
      ":v8_base_without_compiler",
      ":v8_compiler_for_mksnapshot",
      ":v8_init",
      ":v8_libbase",
      ":v8_libplatform",
      ":v8_maybe_icu",
      ":v8_shared_internal_headers",
      ":v8_tracing",
      ":v8_turboshaft",
      "//build/win:default_exe_manifest",
    ]
  }

  # This config disables a link time optimization "ICF", which may merge
  # different functions into one if the function signature and body of them are
  # identical.
  #
  # ICF breaks 1:1 mappings of the external references for V8 snapshot, so we
  # disable it while taking a V8 snapshot.
  config("disable_icf") {
    visibility = [ ":*" ]  # Only targets in this file can depend on this.
    if (is_win) {
      ldflags = [ "/OPT:NOICF" ]  # link.exe, but also lld-link.exe.
    } else if (is_apple && !use_lld) {
      ldflags = [ "-Wl,-no_deduplicate" ]  # ld64.
    } else if (use_lld) {
      ldflags = [ "-Wl,--icf=none" ]
    }
  }
}

if (current_toolchain == v8_snapshot_toolchain) {
  v8_executable("torque") {
    visibility = [ ":*" ]  # Only targets in this file can depend on this.

    sources = [ "src/torque/torque.cc" ]

    deps = [
      ":torque_base",
      "//build/win:default_exe_manifest",
    ]

    # The use of exceptions for Torque in violation of the Chromium style-guide
    # is justified by the fact that it is only used from the non-essential
    # language server and can be removed anytime if it causes problems.
    configs = [
      ":internal_config",
      "//build/config/compiler:exceptions",
      "//build/config/compiler:rtti",
    ]

    remove_configs = [
      "//build/config/compiler:no_exceptions",
      "//build/config/compiler:no_rtti",
    ]
  }
}

v8_executable("torque-language-server") {
  visibility = [ ":*" ]  # Only targets in this file can depend on this.

  sources = [ "src/torque/ls/torque-language-server.cc" ]

  deps = [
    ":torque_base",
    ":torque_ls_base",
    "//build/win:default_exe_manifest",
  ]

  # The use of exceptions for Torque in violation of the Chromium style-guide
  # is justified by the fact that it is only used from the non-essential
  # language server and can be removed anytime if it causes problems.
  configs = [
    ":internal_config",
    "//build/config/compiler:exceptions",
    "//build/config/compiler:rtti",
  ]

  remove_configs = [
    "//build/config/compiler:no_exceptions",
    "//build/config/compiler:no_rtti",
  ]
}

if (v8_enable_i18n_support) {
  if (current_toolchain == v8_generator_toolchain) {
    v8_executable("gen-regexp-special-case") {
      visibility = [ ":*" ]  # Only targets in this file can depend on this.

      sources = [
        "src/regexp/gen-regexp-special-case.cc",
        "src/regexp/special-case.h",
      ]

      deps = [
        ":v8_libbase",
        ":v8_shared_internal_headers",
        "//build/win:default_exe_manifest",
        v8_icu_path,
      ]

      configs = [ ":internal_config" ]
    }
  }

  action("run_gen-regexp-special-case") {
    visibility = [ ":*" ]  # Only targets in this file can depend on this.

    script = "tools/run.py"

    deps = [ ":gen-regexp-special-case($v8_generator_toolchain)" ]

    output_file = "$target_gen_dir/src/regexp/special-case.cc"

    outputs = [ output_file ]

    args = [
      "./" + rebase_path(
              get_label_info(
                      ":gen-regexp-special-case($v8_generator_toolchain)",
                      "root_out_dir") + "/gen-regexp-special-case",
              root_build_dir),
      rebase_path(output_file, root_build_dir),
    ]
  }
}

###############################################################################
# Public targets
#

want_v8_shell =
    (current_toolchain == host_toolchain && v8_toolset_for_shell == "host") ||
    (current_toolchain == v8_snapshot_toolchain &&
     v8_toolset_for_shell == "host") ||
    (current_toolchain != host_toolchain && v8_toolset_for_shell == "target")

group("gn_all") {
  testonly = true

  deps = [
    ":d8",
    ":v8_fuzzers",
    ":v8_hello_world",
    ":v8_sample_process",
    "test:gn_all",
    "tools:gn_all",
  ]

  if (v8_custom_deps != "") {
    # Custom dependency from directory under v8/custom_deps.
    deps += [ v8_custom_deps ]
  }

  if (want_v8_shell) {
    deps += [ ":v8_shell" ]
  }

  if (v8_check_header_includes) {
    deps += [ ":check_headers" ]
  }
}

group("v8_python_base") {
  data = [ ".vpython3" ]
}

group("v8_clusterfuzz") {
  testonly = true

  deps = [
    ":d8",
    ":v8_simple_inspector_fuzzer",
    "tools/clusterfuzz/trials:v8_clusterfuzz_resources",
  ]

  if (v8_multi_arch_build) {
    deps += [
      ":d8(//build/toolchain/linux:clang_x64)",
      ":d8(//build/toolchain/linux:clang_x64_v8_arm64)",
      ":d8(//build/toolchain/linux:clang_x86)",
      ":d8(//build/toolchain/linux:clang_x86_v8_arm)",
      ":d8(tools/clusterfuzz/foozzie/toolchain:clang_x64_pointer_compression)",
    ]
  }
}

# Targets we ensure work with gcc. The aim is to keep this list small to have
# a fast overall compile time.
group("v8_gcc_light") {
  testonly = true

  deps = [ ":d8" ]
}

group("v8_archive") {
  testonly = true

  deps = [ ":d8" ]

  if (!is_win) {
    # On windows, cctest doesn't link with v8_static_library.
    deps += [ "test/cctest:cctest" ]
  }
}

# TODO(dglazkov): Remove the "!build_with_chromium" condition once this clause
# is removed from Chromium.
if (is_fuchsia && !build_with_chromium) {
  import("//build/config/fuchsia/generate_runner_scripts.gni")
  import("//third_party/fuchsia-sdk/sdk/build/component.gni")
  import("//third_party/fuchsia-sdk/sdk/build/package.gni")

  fuchsia_component("d8_component") {
    testonly = true
    manifest = "gni/v8.cml"
    data_deps = [ ":d8" ]
  }

  fuchsia_package("d8_pkg") {
    testonly = true
    package_name = "d8"
    deps = [ ":d8_component" ]
  }

  fuchsia_package_installer("d8_fuchsia") {
    testonly = true
    package = ":d8_pkg"
    package_name = "d8"
  }
}

group("v8_fuzzers") {
  testonly = true
  data_deps = [
    ":v8_simple_inspector_fuzzer",
    ":v8_simple_json_fuzzer",
    ":v8_simple_parser_fuzzer",
    ":v8_simple_regexp_fuzzer",
  ]

  if (v8_enable_webassembly) {
    if (!is_official_build) {
      data_deps += [
        ":v8_simple_wasm_compile_all_fuzzer",
        ":v8_simple_wasm_compile_fuzzer",
        ":v8_simple_wasm_compile_simd_fuzzer",
        ":v8_simple_wasm_compile_wasmgc_fuzzer",
        ":v8_simple_wasm_deopt_fuzzer",
        ":v8_simple_wasm_init_expr_fuzzer",
      ]
    }
    data_deps += [
      ":v8_simple_multi_return_fuzzer",
      ":v8_simple_wasm_async_fuzzer",
      ":v8_simple_wasm_code_fuzzer",
      ":v8_simple_wasm_fuzzer",
      ":v8_simple_wasm_streaming_fuzzer",
    ]
  }
}

if (is_component_build) {
  v8_component("v8") {
    sources = [ "src/utils/v8dll-main.cc" ]

    public_deps = [
      ":v8_base",
      ":v8_snapshot",
    ]

    configs = [ ":internal_config" ]

    public_configs = [ ":external_config" ]
  }

  v8_component("v8_for_testing") {
    testonly = true

    sources = [ "src/utils/v8dll-main.cc" ]

    public_deps = [
      ":torque_base",
      ":torque_ls_base",
      ":v8_base",
      ":v8_headers",
      ":v8_snapshot",
    ]

    if (v8_enable_turbofan) {
      # For cctest/test-serialize.
      public_deps += [ ":v8_initializers" ]
    }

    configs = [ ":internal_config" ]

    public_configs = [ ":external_config" ]
  }

  v8_component("cppgc") {
    public_deps = [ ":cppgc_base" ]

    if (!cppgc_is_standalone) {
      deps = [ ":v8" ]
    }

    configs = []
    public_configs = [ ":external_config" ]
  }

  if (cppgc_is_standalone) {
    v8_component("cppgc_for_testing") {
      testonly = true

      public_deps = [ ":cppgc_base" ]

      configs = []
      public_configs = [ ":external_config" ]
    }
  }

  v8_component("v8_heap_base_for_testing") {
    testonly = true

    public_deps = [ ":v8_heap_base" ]

    configs = []
    public_configs = [ ":external_config" ]
  }
} else {
  group("v8") {
    public_deps = [
      ":v8_base",
      ":v8_snapshot",
    ]

    public_configs = [ ":external_config" ]
  }

  group("v8_for_testing") {
    testonly = true

    public_deps = [
      ":torque_base",
      ":torque_ls_base",
      ":v8_base",
      ":v8_snapshot",
    ]

    if (v8_enable_turbofan) {
      # For cctest/test-serialize.
      public_deps += [ ":v8_initializers" ]
    }

    public_configs = [ ":external_config" ]
  }

  group("cppgc") {
    public_deps = [ ":cppgc_base" ]

    if (!cppgc_is_standalone) {
      deps = [ ":v8" ]
    }

    public_configs = [ ":external_config" ]
  }

  if (cppgc_is_standalone) {
    group("cppgc_for_testing") {
      testonly = true

      public_deps = [ ":cppgc_base" ]

      public_configs = [ ":external_config" ]
    }
  }

  group("v8_heap_base_for_testing") {
    testonly = true

    public_deps = [ ":v8_heap_base" ]

    public_configs = [ ":external_config" ]
  }
}

v8_executable("d8") {
  sources = [
    "src/d8/async-hooks-wrapper.cc",
    "src/d8/async-hooks-wrapper.h",
    "src/d8/d8-console.cc",
    "src/d8/d8-console.h",
    "src/d8/d8-js.cc",
    "src/d8/d8-platforms.cc",
    "src/d8/d8-platforms.h",
    "src/d8/d8-test.cc",
    "src/d8/d8.cc",
    "src/d8/d8.h",
  ]

  configs = [
    # Note: don't use :internal_config here because this target will get
    # the :external_config applied to it by virtue of depending on :v8, and
    # you can't have both applied to the same target.
    ":internal_config_base",
    ":v8_tracing_config",
  ]

  deps = [
    ":v8",
    ":v8_libbase",
    ":v8_libplatform",
    ":v8_tracing",
    "//build/win:default_exe_manifest",
  ]

  if (is_posix || is_fuchsia) {
    sources += [ "src/d8/d8-posix.cc" ]
  } else if (is_win) {
    sources += [ "src/d8/d8-windows.cc" ]
  }

  if (v8_correctness_fuzzer) {
    deps += [ "tools/clusterfuzz/foozzie:v8_correctness_fuzzer_resources" ]
  }

  defines = []

  if (v8_enable_vtunejit) {
    deps += [ "src/third_party/vtune:v8_vtune" ]
  }
  if (current_os == "zos" && is_component_build) {
    deps += [ ":zoslib" ]
  }
}

v8_executable("v8_hello_world") {
  sources = [ "samples/hello-world.cc" ]

  configs = [
    # Note: don't use :internal_config here because this target will get
    # the :external_config applied to it by virtue of depending on :v8, and
    # you can't have both applied to the same target.
    ":internal_config_base",
  ]

  deps = [
    ":v8",
    ":v8_libbase",
    ":v8_libplatform",
    "//build/win:default_exe_manifest",
  ]

  # Need to workaround a link error when using devtoolset
  # https://bugzilla.redhat.com/show_bug.cgi?id=2268188
  if ((v8_current_cpu == "ppc64" || v8_current_cpu == "s390x") && is_linux &&
      !is_clang) {
    libs = [ "stdc++" ]
  }
}

v8_executable("v8_sample_process") {
  sources = [ "samples/process.cc" ]

  configs = [
    # Note: don't use :internal_config here because this target will get
    # the :external_config applied to it by virtue of depending on :v8, and
    # you can't have both applied to the same target.
    ":internal_config_base",
  ]

  deps = [
    ":v8",
    ":v8_libbase",
    ":v8_libplatform",
    "//build/win:default_exe_manifest",
  ]
  if (current_os == "zos" && is_component_build) {
    deps += [ ":zoslib" ]
  }
}

if (want_v8_shell) {
  v8_executable("v8_shell") {
    sources = [ "samples/shell.cc" ]

    configs = [
      # Note: don't use :internal_config here because this target will get
      # the :external_config applied to it by virtue of depending on :v8, and
      # you can't have both applied to the same target.
      ":internal_config_base",
    ]

    deps = [
      ":v8",
      ":v8_libbase",
      ":v8_libplatform",
      "//build/win:default_exe_manifest",
    ]
    if (current_os == "zos" && is_component_build) {
      deps += [ ":zoslib" ]
    }
  }
}

v8_executable("cppgc_hello_world") {
  sources = [ "samples/cppgc/hello-world.cc" ]

  if (v8_current_cpu == "riscv64" || v8_current_cpu == "riscv32") {
    if (!is_clang) {
      libs = [ "atomic" ]
    }
  }

  configs = [
    # Note: don't use :internal_config here because this target will get
    # the :external_config applied to it by virtue of depending on :cppgc, and
    # you can't have both applied to the same target.
    ":internal_config_base",
    ":cppgc_base_config",
  ]

  deps = [ ":cppgc" ]
  if (!cppgc_is_standalone) {
    deps += [
      ":v8",
      "//build/win:default_exe_manifest",
    ]
  }
}

template("v8_fuzzer") {
  fuzzer_name = target_name

  v8_source_set(fuzzer_name) {
    sources = invoker.sources

    deps = [ ":fuzzer_support" ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }

    configs = [
      ":external_config",
      ":internal_config_base",
    ]
  }

  v8_executable("v8_simple_${fuzzer_name}") {
    deps = [
      ":${fuzzer_name}",
      "//build/win:default_exe_manifest",
    ]

    sources = [ "test/fuzzer/fuzzer.cc" ]

    configs = [ ":external_config" ]
  }
}

v8_fuzzer("json_fuzzer") {
  sources = [ "test/fuzzer/json.cc" ]
}

v8_fuzzer("parser_fuzzer") {
  sources = [ "test/fuzzer/parser.cc" ]
}

v8_fuzzer("regexp_fuzzer") {
  sources = [ "test/fuzzer/regexp.cc" ]
}

if (v8_enable_webassembly) {
  v8_fuzzer("multi_return_fuzzer") {
    sources = [ "test/fuzzer/multi-return.cc" ]
  }

  v8_source_set("wasm_test_common") {
    sources = [
      "test/common/flag-utils.h",
      "test/common/wasm/flag-utils.h",
      "test/common/wasm/wasm-module-runner.cc",
      "test/common/wasm/wasm-module-runner.h",
    ]

    deps = [
      ":generate_bytecode_builtins_list",
      ":run_torque",
      ":v8_internal_headers",
      ":v8_libbase",
      ":v8_shared_internal_headers",
      ":v8_tracing",
    ]

    public_deps = [
      ":v8_abseil",
      ":v8_maybe_icu",
    ]

    configs = [
      ":external_config",
      ":internal_config_base",
    ]
  }

  v8_source_set("wasm_fuzzer_common") {
    sources = [
      "test/fuzzer/wasm-fuzzer-common.cc",
      "test/fuzzer/wasm-fuzzer-common.h",
      "tools/wasm/mjsunit-module-disassembler-impl.h",
    ]

    deps = [
      ":fuzzer_support",
      ":generate_bytecode_builtins_list",
      ":run_torque",
      ":v8_internal_headers",
      ":v8_tracing",
      ":wasm_test_common",
    ]

    public_deps = [
      ":v8_abseil",
      ":v8_maybe_icu",
    ]

    configs = [
      ":external_config",
      ":internal_config_base",
    ]
  }

  template("v8_wasm_fuzzer") {
    forward_variables_from(invoker, "*")
    v8_fuzzer(target_name) {
      deps = [
        ":wasm_fuzzer_common",
        ":wasm_test_common",
      ]
    }
  }

  v8_wasm_fuzzer("wasm_fuzzer") {
    sources = [ "test/fuzzer/wasm.cc" ]
  }

  v8_wasm_fuzzer("wasm_async_fuzzer") {
    sources = [ "test/fuzzer/wasm-async.cc" ]
  }

  v8_wasm_fuzzer("wasm_code_fuzzer") {
    sources = [
      "test/common/wasm/test-signatures.h",
      "test/fuzzer/wasm-code.cc",
    ]
  }

  v8_wasm_fuzzer("wasm_streaming_fuzzer") {
    sources = [ "test/fuzzer/wasm-streaming.cc" ]
  }

  # Some fuzzers depend on fuzzing functionality linked into the v8 library.
  # For binary size reasons this functionality is not available for official
  # builds, therefore these fuzzers do not function there and should be skipped
  # instead.
  if (!is_official_build) {
    v8_wasm_fuzzer("wasm_compile_all_fuzzer") {
      sources = [
        "test/common/wasm/test-signatures.h",
        "test/fuzzer/wasm-compile-all.cc",
      ]
    }

    v8_wasm_fuzzer("wasm_compile_fuzzer") {
      sources = [
        "test/common/wasm/test-signatures.h",
        "test/fuzzer/wasm-compile.cc",
      ]
    }

    v8_wasm_fuzzer("wasm_compile_simd_fuzzer") {
      sources = [
        "test/common/wasm/test-signatures.h",
        "test/fuzzer/wasm-compile-simd.cc",
      ]
    }

    v8_wasm_fuzzer("wasm_compile_wasmgc_fuzzer") {
      sources = [
        "test/common/wasm/test-signatures.h",
        "test/fuzzer/wasm-compile-wasmgc.cc",
      ]
    }

    v8_wasm_fuzzer("wasm_init_expr_fuzzer") {
      sources = [ "test/fuzzer/wasm-init-expr.cc" ]
    }

    v8_wasm_fuzzer("wasm_deopt_fuzzer") {
      sources = [ "test/fuzzer/wasm-deopt.cc" ]
    }
  }  # !is_official_build
}

v8_fuzzer("inspector_fuzzer") {
  sources = [ "test/fuzzer/inspector-fuzzer.cc" ]
  deps = [ "test/inspector:inspector_test" ]
}

# Target to build all generated .cc files.
group("v8_generated_cc_files") {
  testonly = true

  deps = [
    ":generate_bytecode_builtins_list",
    ":run_torque",
    "src/inspector:v8_generated_cc_files",
  ]
}

# Protobuf targets, used only when building outside of chromium.

if (!build_with_chromium && v8_use_perfetto) {
  v8_component("v8_libperfetto") {
    configs = [ ":v8_tracing_config" ]
    public_configs = [ "//third_party/perfetto/gn:public_config" ]
    deps = [
      "//third_party/perfetto/src/trace_processor:storage_minimal",
      "//third_party/perfetto/src/tracing/core",

      # TODO(skyostil): Support non-POSIX platforms.
      "//third_party/perfetto/protos/perfetto/trace/track_event:zero",
      "//third_party/perfetto/src/tracing:in_process_backend",
      "//third_party/perfetto/src/tracing:platform_impl",
    ]

    public_deps = [
      "//third_party/perfetto/include/perfetto/trace_processor",
      "//third_party/perfetto/protos/perfetto/config:cpp",
      "//third_party/perfetto/protos/perfetto/trace/chrome:zero",
      "//third_party/perfetto/src/trace_processor:export_json",
      "//third_party/perfetto/src/tracing:client_api",
    ]
  }
}  # if (!build_with_chromium && v8_use_perfetto)
                                                                        node-23.7.0/deps/v8/CODE_OF_CONDUCT.md                                                              0000664 0000000 0000000 00000000713 14746647661 0016645 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # V8 Code of Conduct

As part of the Chromium team, the V8 team is committed to preserving and
fostering a diverse, welcoming community. To this end, the [Chromium Code of
Conduct](https://chromium.googlesource.com/chromium/src/+/master/CODE_OF_CONDUCT.md)
applies to our repos and organizations, mailing lists, blog content, and any
other Chromium-supported communication group, as well as any private
communication initiated in the context of these spaces.
                                                     node-23.7.0/deps/v8/COMMON_OWNERS                                                                   0000664 0000000 0000000 00000001551 14746647661 0016057 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        adamk@chromium.org
ahaas@chromium.org
alexschulze@chromium.org
bikineev@chromium.org
bmeurer@chromium.org
cbruni@chromium.org
clemensb@chromium.org
danno@chromium.org
dinfuehr@chromium.org
dlehmann@chromium.org
dmercadier@chromium.org
ecmziegler@chromium.org
evih@chromium.org
gdeepti@chromium.org
hablich@chromium.org
hpayer@chromium.org
ishell@chromium.org
jgruber@chromium.org
jkummerow@chromium.org
leszeks@chromium.org
liviurau@chromium.org
machenbach@chromium.org
manoskouk@chromium.org
marja@chromium.org
mathias@chromium.org
mliedtke@chromium.org
mlippautz@chromium.org
nicohartmann@chromium.org
nikolaos@chromium.org
olivf@chromium.org
omerkatz@chromium.org
pthier@chromium.org
rezvan@chromium.org
sroettger@google.com
syg@chromium.org
szuend@chromium.org
thibaudm@chromium.org
vahl@chromium.org
verwaest@chromium.org
victorgomes@chromium.org
yangguo@chromium.org
                                                                                                                                                       node-23.7.0/deps/v8/DEPS                                                                            0000664 0000000 0000000 00000077251 14746647661 0014537 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Note: The buildbots evaluate this file with CWD set to the parent
# directory and assume that the root of the checkout is in ./v8/, so
# all paths in here must match this assumption.

use_relative_paths = True

gclient_gn_args_file = 'build/config/gclient_args.gni'
gclient_gn_args = [
]

vars = {
  # Fetches only the SDK boot images which match at least one of the whitelist
  # entries in a comma-separated list.
  #
  # Available images:
  #   Emulation:
  #   - terminal.qemu-x64
  #   - terminal.qemu-arm64
  #   - workstation.qemu-x64-release
  #   Hardware:
  #   - minimal.x64
  #   - core.x64-dfv2
  #
  # Since the images are hundreds of MB, default to only downloading the image
  # most commonly useful for developers. Bots and developers that need to use
  # other images (e.g., qemu.arm64) can override this with additional images.
  'checkout_fuchsia_boot_images': "terminal.x64",
  'checkout_fuchsia_product_bundles': '"{checkout_fuchsia_boot_images}" != ""',

  'checkout_centipede_deps': False,
  'checkout_instrumented_libraries': False,
  'checkout_ittapi': False,

  # Fetch the prebuilt binaries for llvm-cov and llvm-profdata. Needed to
  # process the raw profiles produced by instrumented targets (built with
  # the gn arg 'use_clang_coverage').
  'checkout_clang_coverage_tools': False,

  # Fetch clang-tidy into the same bin/ directory as our clang binary.
  'checkout_clang_tidy': False,

  # Fetch clangd into the same bin/ directory as our clang binary.
  'checkout_clangd': False,

  # Fetch and build V8 builtins with PGO profiles
  'checkout_v8_builtins_pgo_profiles': False,

  'android_url': 'https://android.googlesource.com',
  'boringssl_url': 'https://boringssl.googlesource.com',
  'chromium_url': 'https://chromium.googlesource.com',
  'download_gcmole': False,
  'download_jsfunfuzz': False,
  'download_prebuilt_bazel': False,
  'check_v8_header_includes': False,

  # By default, download the fuchsia sdk from the public sdk directory.
  'fuchsia_sdk_cipd_prefix': 'fuchsia/sdk/core/',

  # Used for downloading the Fuchsia SDK without running hooks.
  'checkout_fuchsia_no_hooks': False,

  # reclient CIPD package version
  'reclient_version': 're_client_version:0.157.0.d2566cec-gomaip',

  # Fetch configuration files required for the 'use_remoteexec' gn arg
  'download_remoteexec_cfg': False,

  # RBE instance to use for running remote builds
  'rbe_instance': Str('projects/rbe-chrome-untrusted/instances/default_instance'),

  # RBE project to download rewrapper config files for. Only needed if
  # different from the project used in 'rbe_instance'
  'rewrapper_cfg_project': Str(''),

  # This variable is overrided in Chromium's DEPS file.
  'build_with_chromium': False,

  # GN CIPD package version.
  'gn_version': 'git_revision:54f5b539df8c4e460b18c62a11132d77b5601136',

  # ninja CIPD package version
  # https://chrome-infra-packages.appspot.com/p/infra/3pp/tools/ninja
  'ninja_version': 'version:2@1.12.1.chromium.4',

  # siso CIPD package version
  'siso_version': 'git_revision:87262779ecc3482c8c60b070404b225107212d0d',

  # luci-go CIPD package version.
  'luci_go': 'git_revision:ad7b787aa0ee53a81bc88fb4f7fee7a3ff1e8c29',

  # Three lines of non-changing comments so that
  # the commit queue can handle CLs rolling Fuchsia sdk
  # and whatever else without interference from each other.
  'fuchsia_version': 'version:23.20240815.4.1',

  # Three lines of non-changing comments so that
  # the commit queue can handle CLs rolling android_sdk_build-tools_version
  # and whatever else without interference from each other.
  'android_sdk_build-tools_version': 'DxwAZ3hD551Neu6ycuW5CPnXFrdleRBd93oX1eB_m9YC',
  # Three lines of non-changing comments so that
  # the commit queue can handle CLs rolling android_sdk_emulator_version
  # and whatever else without interference from each other.
  'android_sdk_emulator_version': '9lGp8nTUCRRWGMnI_96HcKfzjnxEJKUcfvfwmA3wXNkC',
  # Three lines of non-changing comments so that
  # the commit queue can handle CLs rolling android_sdk_extras_version
  # and whatever else without interference from each other.
  'android_sdk_extras_version': 'bY55nDqO6FAm6FkGIj09sh2KW9oqAkCGKjYok5nUvBMC',
  # Three lines of non-changing comments so that
  # the commit queue can handle CLs rolling android_sdk_patcher_version
  # and whatever else without interference from each other.
  'android_sdk_patcher_version': 'I6FNMhrXlpB-E1lOhMlvld7xt9lBVNOO83KIluXDyA0C',
  # Three lines of non-changing comments so that
  # the commit queue can handle CLs rolling android_sdk_platform-tools_version
  # and whatever else without interference from each other.
  'android_sdk_platform-tools_version': 'WihaseZR6cojZbkzIqwGhpTp92ztaGfqq8njBU8eTXYC',
  # Three lines of non-changing comments so that
  # the commit queue can handle CLs rolling android_sdk_platforms_version
  # and whatever else without interference from each other.
  'android_sdk_platforms_version': 'kIXA-9XuCfOESodXEdOBkW5f1ytrGWdbp3HFp1I8A_0C',
  # Three lines of non-changing comments so that
  # the commit queue can handle CLs rolling android_sdk_sources_version
  # and whatever else without interference from each other.
  'android_sdk_sources_version': 'qfTSF99e29-w3eIVPpfcif0Em5etyvxuicTDTntWHQMC',
  # Three lines of non-changing comments so that
  # the commit queue can handle CLs rolling android_sdk_tools-lint_version
  # and whatever else without interference from each other.
  'android_sdk_cmdline-tools_version': 'fv6JzkTqfxfIbmsRC8u1b2y0EQO7yQDMDzY3-g0NVu4C',
}

deps = {
  'build':
    Var('chromium_url') + '/chromium/src/build.git' + '@' + '7a468ed1849454cffabf4a64110c24e6f1da2c51',
  'buildtools':
    Var('chromium_url') + '/chromium/src/buildtools.git' + '@' + '60a590902cf146c282f15242401bd8543256e2a2',
  'buildtools/linux64': {
    'packages': [
      {
        'package': 'gn/gn/linux-${{arch}}',
        'version': Var('gn_version'),
      }
    ],
    'dep_type': 'cipd',
    'condition': 'host_os == "linux" and host_cpu != "s390" and host_os != "zos" and host_cpu != "ppc"',
  },
  'buildtools/mac': {
    'packages': [
      {
        'package': 'gn/gn/mac-${{arch}}',
        'version': Var('gn_version'),
      }
    ],
    'dep_type': 'cipd',
    'condition': 'host_os == "mac"',
  },
  'buildtools/win': {
    'packages': [
      {
        'package': 'gn/gn/windows-amd64',
        'version': Var('gn_version'),
      }
    ],
    'dep_type': 'cipd',
    'condition': 'host_os == "win"',
  },
  'buildtools/reclient': {
    'packages': [
      {
        'package': 'infra/rbe/client/${{platform}}',
        'version': Var('reclient_version'),
      }
    ],
    'dep_type': 'cipd',
    'condition': '(host_os == "linux" or host_os == "mac" or host_os == "win") and host_cpu != "s390" and host_os != "zos" and host_cpu != "ppc" and (host_cpu != "arm64" or host_os == "mac")',
  },
  'test/benchmarks/data':
    Var('chromium_url') + '/v8/deps/third_party/benchmarks.git' + '@' + '05d7188267b4560491ff9155c5ee13e207ecd65f',
  'test/mozilla/data':
    Var('chromium_url') + '/v8/deps/third_party/mozilla-tests.git' + '@' + 'f6c578a10ea707b1a8ab0b88943fe5115ce2b9be',
  'test/test262/data':
    Var('chromium_url') + '/external/github.com/tc39/test262.git' + '@' + 'bcb42e339dbac06f2f9902046b1fbf62562e0cd3',
  'third_party/android_platform': {
    'url': Var('chromium_url') + '/chromium/src/third_party/android_platform.git' + '@' + '6337c445f9963ec3914e7e0c5787941d07b46509',
    'condition': 'checkout_android',
  },
  'third_party/android_sdk/public': {
      'packages': [
          {
              'package': 'chromium/third_party/android_sdk/public/build-tools/35.0.0',
              'version': Var('android_sdk_build-tools_version'),
          },
          {
              'package': 'chromium/third_party/android_sdk/public/emulator',
              'version': Var('android_sdk_emulator_version'),
          },
          {
              'package': 'chromium/third_party/android_sdk/public/extras',
              'version': Var('android_sdk_extras_version'),
          },
          {
              'package': 'chromium/third_party/android_sdk/public/patcher',
              'version': Var('android_sdk_patcher_version'),
          },
          {
              'package': 'chromium/third_party/android_sdk/public/platform-tools',
              'version': Var('android_sdk_platform-tools_version'),
          },
          {
              'package': 'chromium/third_party/android_sdk/public/platforms/android-35',
              'version': Var('android_sdk_platforms_version'),
          },
          {
              'package': 'chromium/third_party/android_sdk/public/sources/android-30',
              'version': Var('android_sdk_sources_version'),
          },
          {
              'package': 'chromium/third_party/android_sdk/public/cmdline-tools',
              'version': Var('android_sdk_cmdline-tools_version'),
          },
      ],
      'condition': 'checkout_android',
      'dep_type': 'cipd',
  },
  'third_party/android_toolchain/ndk': {
    'packages': [
      {
        'package': 'chromium/third_party/android_toolchain/android_toolchain',
        'version': 'Idl-vYnWGnM8K3XJhM3h6zjYVDXlnljVz3FE00V9IM8C',
      },
    ],
    'condition': 'checkout_android',
    'dep_type': 'cipd',
  },
  'third_party/boringssl': {
    'url': Var('chromium_url') + '/chromium/src/third_party/boringssl.git' + '@' + '4d98a91cde88f349b96f4018c00053b6699ffd88',
    'condition': "checkout_centipede_deps",
  },
  'third_party/boringssl/src': {
    'url': Var('boringssl_url') + '/boringssl.git' + '@' +  '11f334121fd0d13830fefdf08041183da2d30ef3',
    'condition': "checkout_centipede_deps",
  },
  'third_party/catapult': {
    'url': Var('chromium_url') + '/catapult.git' + '@' + '799e21b232f23f6c1391abfd44fe8ab1dd95bd9b',
    'condition': 'checkout_android',
  },
  'third_party/clang-format/script':
    Var('chromium_url') + '/external/github.com/llvm/llvm-project/clang/tools/clang-format.git' + '@' + '3c0acd2d4e73dd911309d9e970ba09d58bf23a62',
  'third_party/colorama/src': {
    'url': Var('chromium_url') + '/external/colorama.git' + '@' + '3de9f013df4b470069d03d250224062e8cf15c49',
    'condition': 'checkout_android',
  },
  'third_party/cpu_features/src': {
    'url': Var('chromium_url') + '/external/github.com/google/cpu_features.git' + '@' + '936b9ab5515dead115606559502e3864958f7f6e',
    'condition': 'checkout_android',
  },
  'third_party/depot_tools':
    Var('chromium_url') + '/chromium/tools/depot_tools.git' + '@' + '0bc7c4832e4f2d453e4826c9a2e1197e11bd6ec7',
  'third_party/fp16/src':
    Var('chromium_url') + '/external/github.com/Maratyszcza/FP16.git' + '@' + '0a92994d729ff76a58f692d3028ca1b64b145d91',
  'third_party/fuchsia-gn-sdk': {
    'url': Var('chromium_url') + '/chromium/src/third_party/fuchsia-gn-sdk.git' + '@' + '30fee7b68b3675e351fa47303c3b6ef322941ccd',
    'condition': 'checkout_fuchsia',
  },
  # Exists for rolling the Fuchsia SDK. Check out of the SDK should always
  # rely on the hook running |update_sdk.py| script below.
  'third_party/fuchsia-sdk/sdk': {
      'packages': [
          {
              'package': Var('fuchsia_sdk_cipd_prefix') + '${{platform}}',
              'version': Var('fuchsia_version'),
          },
      ],
      'condition': 'checkout_fuchsia_no_hooks',
      'dep_type': 'cipd',
  },
  'third_party/google_benchmark_chrome': {
    'url': Var('chromium_url') + '/chromium/src/third_party/google_benchmark.git' + '@' + 'f049b96d7a50ae19f2748aae7fba7bde705bcd8c',
  },
  'third_party/google_benchmark_chrome/src': {
    'url': Var('chromium_url') + '/external/github.com/google/benchmark.git' + '@' + '344117638c8ff7e239044fd0fa7085839fc03021',
  },
  'third_party/fuzztest':
    Var('chromium_url') + '/chromium/src/third_party/fuzztest.git' + '@' + '69fe98bf87d80fdc773481ae5180c63e431a13a1',
  'third_party/fuzztest/src':
    Var('chromium_url') + '/external/github.com/google/fuzztest.git' + '@' + '32eb84a95951fa3a0148fb3e6a1a02f830ded136',
  'third_party/googletest/src':
    Var('chromium_url') + '/external/github.com/google/googletest.git' + '@' + 'ff233bdd4cac0a0bf6e5cd45bda3406814cb2796',
  'third_party/highway/src':
    Var('chromium_url') + '/external/github.com/google/highway.git' + '@' + '8295336dd70f1201d42c22ab5b0861de38cf8fbf',
  'third_party/icu':
    Var('chromium_url') + '/chromium/deps/icu.git' + '@' + '9408c6fd4a39e6fef0e1c4077602e1c83b15f3fb',
  'third_party/instrumented_libs': {
    'url': Var('chromium_url') + '/chromium/third_party/instrumented_libraries.git' + '@' + 'bb6dbcf2df7a9beb34c3773ef4df161800e3aed9',
    'condition': 'checkout_instrumented_libraries',
  },
  'third_party/ittapi': {
    # Force checkout ittapi libraries to pass v8 header includes check on
    # bots that has check_v8_header_includes enabled.
    'url': Var('chromium_url') + '/external/github.com/intel/ittapi' + '@' + 'a3911fff01a775023a06af8754f9ec1e5977dd97',
    'condition': "checkout_ittapi or check_v8_header_includes",
  },
  'third_party/jinja2':
    Var('chromium_url') + '/chromium/src/third_party/jinja2.git' + '@' + '2f6f2ff5e4c1d727377f5e1b9e1903d871f41e74',
  'third_party/jsoncpp/source':
    Var('chromium_url') + '/external/github.com/open-source-parsers/jsoncpp.git'+ '@' + '42e892d96e47b1f6e29844cc705e148ec4856448',
  'third_party/libc++/src':
    Var('chromium_url') + '/external/github.com/llvm/llvm-project/libcxx.git' + '@' + 'f801c947082a3e0a4b48780303526b73905f6ecd',
  'third_party/libc++abi/src':
    Var('chromium_url') + '/external/github.com/llvm/llvm-project/libcxxabi.git' + '@' + 'eb6567388e89d9730c76dee71d68ac82e4a1abf6',
  'third_party/libunwind/src':
    Var('chromium_url') + '/external/github.com/llvm/llvm-project/libunwind.git' + '@' + '116c20dae60d84a77005697cf29f72783f81b0f9',
  'third_party/llvm-build/Release+Asserts': {
    'dep_type': 'gcs',
    'bucket': 'chromium-browser-clang',
    'objects': [
      {
        'object_name': 'Linux_x64/clang-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': '32ac9d9864a6bd99242f1a97778b3a074ac1151ce3eca369903f2ef5337c787a',
        'size_bytes': 52250752,
        'generation': 1723267014378582,
        'condition': 'host_os == "linux"',
      },
      {
        'object_name': 'Linux_x64/clang-tidy-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': '5fd3fb73ceef73593fa09f8228283aec9f7798b648bf450e87f071a097be213b',
        'size_bytes': 13217676,
        'generation': 1723267014627839,
        'condition': 'host_os == "linux" and checkout_clang_tidy',
      },
      {
        'object_name': 'Linux_x64/clangd-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': '6e1fe97f8b7131591233d8a2df1ff289ffb878c3fc6834c978a86273f7c00b6b',
        'size_bytes': 26125984,
        'generation': 1723267014767012,
        'condition': 'host_os == "linux" and checkout_clangd',
      },
      {
        'object_name': 'Linux_x64/llvm-code-coverage-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': 'ef317481472926d3e2a82e2d2a02cde78685002b4c9923df476108906022d792',
        'size_bytes': 2374748,
        'generation': 1723267015213805,
        'condition': 'host_os == "linux" and checkout_clang_coverage_tools',
      },
      {
        'object_name': 'Linux_x64/llvmobjdump-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': '02be68f7c7c7bf679e1abff2745306b8385275017c89b2b13f638a941785f8c5',
        'size_bytes': 5386480,
        'generation': 1723267014930087,
        'condition': '(checkout_linux or checkout_mac or checkout_android and host_os != "mac")',
      },
      {
        'object_name': 'Mac/clang-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': '5df8a609a7d2511343fbc20af1de3ed1682c3703fc074f21af1bf8bc2f58e491',
        'size_bytes': 47200408,
        'generation': 1723267016534642,
        'condition': 'host_os == "mac" and host_cpu == "x64"',
      },
      {
        'object_name': 'Mac/clang-mac-runtime-library-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': 'ffc72ff3fca85f31340c164aab480bd2babfaa6219ff12e93b81f0056309da55',
        'size_bytes': 869616,
        'generation': 1723267034708598,
        'condition': 'checkout_mac and not host_os == "mac"',
      },
      {
        'object_name': 'Mac/clang-tidy-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': 'd02b9a39491d2ff3a291778de87b2a72f5885d01a8093518cb5612b97353ac2a',
        'size_bytes': 12805336,
        'generation': 1723267016822831,
        'condition': 'host_os == "mac" and host_cpu == "x64" and checkout_clang_tidy',
      },
      {
        'object_name': 'Mac/clangd-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': 'ce09141be75350f0f932fcda14d8b906d2869674d79ef5a10a3e60a9a8d3ccee',
        'size_bytes': 26372428,
        'generation': 1723267016957114,
        'condition': 'host_os == "mac" and host_cpu == "x64" and checkout_clangd',
      },
      {
        'object_name': 'Mac/llvm-code-coverage-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': 'c0ac62ff01f1ce6e5d30134cb0f83fd8eabf858dfb33d07209a6b40d8f1ae789',
        'size_bytes': 2248664,
        'generation': 1723267017743181,
        'condition': 'host_os == "mac" and host_cpu == "x64" and checkout_clang_coverage_tools',
      },
      {
        'object_name': 'Mac_arm64/clang-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': 'f4a384ecdaa051ba4786c9e6c46f9101a751b1a5c5ad4bf0d217c4ba71e0ff30',
        'size_bytes': 42737720,
        'generation': 1723267036349494,
        'condition': 'host_os == "mac" and host_cpu == "arm64"',
      },
      {
        'object_name': 'Mac_arm64/clang-tidy-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': '2769378fd2891af945f8d29b5eaf05b4ab0450b2d086539df1c78c684e64be14',
        'size_bytes': 11740656,
        'generation': 1723267036269250,
        'condition': 'host_os == "mac" and host_cpu == "arm64" and checkout_clang_tidy',
      },
      {
        'object_name': 'Mac_arm64/clangd-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': 'a35dfb99903a487e06d685712e461125978c76ba8eaa99e9f5742e63d3e67444',
        'size_bytes': 23470088,
        'generation': 1723267036383208,
        'condition': 'host_os == "mac" and host_cpu == "arm64" and checkout_clangd',
      },
      {
        'object_name': 'Mac_arm64/llvm-code-coverage-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': '574a0d7c560aae964d8bdcd85f0145077b1324e79eee4a3dd1636ab7aefc59e5',
        'size_bytes': 2010540,
        'generation': 1723267036758678,
        'condition': 'host_os == "mac" and host_cpu == "arm64" and checkout_clang_coverage_tools',
      },
      {
        'object_name': 'Win/clang-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': 'e255af29c29a741cf39c3000b612466ff805a99766d26ac86ec2afcb4ca0c922',
        'size_bytes': 44019080,
        'generation': 1723267056892790,
        'condition': 'host_os == "win"',
      },
      {
        'object_name': 'Win/clang-tidy-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': 'a86aa579fc90a053b94874a8c79daeb7f3bbd77107fb460c6d0a7959cefb7e61',
        'size_bytes': 13055812,
        'generation': 1723267057185720,
        'condition': 'host_os == "win" and checkout_clang_tidy',
      },
      {
        'object_name': 'Win/clang-win-runtime-library-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': '6d89f358769ef50d008194e0ab9e8d4d80b8d6ffc0095ed44aef925d900aa743',
        'size_bytes': 2873772,
        'generation': 1723267074433695,
        'condition': 'checkout_win and not host_os == "win"',
      },
      {
        'object_name': 'Win/clangd-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': 'e2b69a726f794005a333ae66a0ef5c0258872a19bc4506eff23f23fdee75ba5c',
        'size_bytes': 25053884,
        'generation': 1723267057351794,
       'condition': 'host_os == "win" and checkout_clangd',
      },
      {
        'object_name': 'Win/llvm-code-coverage-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': 'e68e7c7ecbc7b2fc4f7ec3e97565a7f12bab1d195d22bc76959f3a88b1462ac1',
        'size_bytes': 2376020,
        'generation': 1723267057803475,
        'condition': 'host_os == "win" and checkout_clang_coverage_tools',
      },
      {
        'object_name': 'Win/llvmobjdump-llvmorg-20-init-1009-g7088a5ed-10.tar.xz',
        'sha256sum': '801714415847b8efea7252b1072b8647f92ba0e946480b3db9b156900e42ab55',
        'size_bytes': 5392812,
        'generation': 1723267057506056,
        'condition': 'checkout_linux or checkout_mac or checkout_android and host_os == "win"',
      },
    ],
  },
  'third_party/logdog/logdog':
    Var('chromium_url') + '/infra/luci/luci-py/client/libs/logdog' + '@' + '0b2078a90f7a638d576b3a7c407d136f2fb62399',
  'third_party/markupsafe':
    Var('chromium_url') + '/chromium/src/third_party/markupsafe.git' + '@' + '6638e9b0a79afc2ff7edd9e84b518fe7d5d5fea9',
  'third_party/ninja': {
    'packages': [
      {
        'package': 'infra/3pp/tools/ninja/${{platform}}',
        'version': Var('ninja_version'),
      }
    ],
    'dep_type': 'cipd',
    'condition': 'host_cpu != "s390" and host_os != "zos" and host_cpu != "ppc"'
  },
  'third_party/perfetto':
    Var('android_url') + '/platform/external/perfetto.git' + '@' + '6fc824d618d2f06b5d9cd8655ba0419b6b3b366e',
  'third_party/protobuf':
    Var('chromium_url') + '/chromium/src/third_party/protobuf.git' + '@' + 'da2fe725b80ac0ba646fbf77d0ce5b4ac236f823',
  'third_party/re2/src':
    Var('chromium_url') + '/external/github.com/google/re2.git' + '@' + '6dcd83d60f7944926bfd308cc13979fc53dd69ca',
  'third_party/requests': {
      'url': Var('chromium_url') + '/external/github.com/kennethreitz/requests.git' + '@' + 'c7e0fc087ceeadb8b4c84a0953a422c474093d6d',
      'condition': 'checkout_android',
  },
  'third_party/siso': {
    'packages': [
      {
        'package': 'infra/build/siso/${{platform}}',
        'version': Var('siso_version'),
      }
    ],
    'dep_type': 'cipd',
    'condition': 'not build_with_chromium and host_cpu != "s390" and host_os != "zos" and host_cpu != "ppc"',
  },
  'third_party/zlib':
    Var('chromium_url') + '/chromium/src/third_party/zlib.git'+ '@' + 'd3aea2341cdeaf7e717bc257a59aa7a9407d318a',
  'tools/clang':
    Var('chromium_url') + '/chromium/src/tools/clang.git' + '@' + '63b7be17f8981d716ea9a0d65bb04654d79548a8',
  'tools/luci-go': {
      'packages': [
        {
          'package': 'infra/tools/luci/isolate/${{platform}}',
          'version': Var('luci_go'),
        },
        {
          'package': 'infra/tools/luci/swarming/${{platform}}',
          'version': Var('luci_go'),
        },
      ],
      'condition': 'host_cpu != "s390" and host_os != "zos" and host_os != "aix"',
      'dep_type': 'cipd',
  },
  'tools/protoc_wrapper':
    Var('chromium_url') + '/chromium/src/tools/protoc_wrapper.git' + '@' + 'dbcbea90c20ae1ece442d8ef64e61c7b10e2b013',
  'third_party/abseil-cpp': {
    'url': Var('chromium_url') + '/chromium/src/third_party/abseil-cpp.git' + '@' + 'ed3733b91e472a1e7a641c1f0c1e6c0ea698e958',
    'condition': 'not build_with_chromium',
  },
  'third_party/zoslib': {
    'url': Var('chromium_url') + '/external/github.com/ibmruntimes/zoslib.git' + '@' + '1e68de6e37efced3738a88536fccb6bbfe2d70b2',
    'condition': 'host_os == "zos"',
  }
}

include_rules = [
  # Everybody can use some things.
  '+include',
  '+unicode',
  '+third_party/fdlibm',
  '+third_party/ittapi/include',
  '+third_party/fp16/src/include',
  '+third_party/v8/codegen',
  '+third_party/fuzztest',
  # Abseil features are allow-listed. Please use your best judgement when adding
  # to this set -- if in doubt, email v8-dev@. For general guidance, refer to
  # the Chromium guidelines (though note that some requirements in V8 may be
  # different to Chromium's):
  # https://chromium.googlesource.com/chromium/src/+/main/styleguide/c++/c++11.md
  '+absl/container/flat_hash_map.h',
  '+absl/container/flat_hash_set.h',
  '+absl/container/btree_map.h',
  '+absl/types/optional.h',
  '+absl/types/variant.h',
  '+absl/status',
  # Some abseil features are explicitly banned.
  '-absl/types/any.h', # Requires RTTI.
  '-absl/types/flags', # Requires RTTI.
]

# checkdeps.py shouldn't check for includes in these directories:
skip_child_includes = [
  'build',
  'third_party',
]

hooks = [
  {
    # Ensure that the DEPS'd "depot_tools" has its self-update capability
    # disabled.
    'name': 'disable_depot_tools_selfupdate',
    'pattern': '.',
    'action': [
        'python3',
        'third_party/depot_tools/update_depot_tools_toggle.py',
        '--disable',
    ],
  },
  {
    # This clobbers when necessary (based on get_landmines.py). It must be the
    # first hook so that other things that get/generate into the output
    # directory will not subsequently be clobbered.
    'name': 'landmines',
    'pattern': '.',
    'action': [
        'python3',
        'build/landmines.py',
        '--landmine-scripts',
        'tools/get_landmines.py',
    ],
  },
  {
    'name': 'bazel',
    'pattern': '.',
    'condition': 'download_prebuilt_bazel',
    'action': [ 'python3',
                'third_party/depot_tools/download_from_google_storage.py',
                '--bucket', 'chromium-v8-prebuilt-bazel/linux',
                '--no_resume',
                '-s', 'tools/bazel/bazel.sha1',
                '--platform=linux*',
    ],
  },
  # Pull dsymutil binaries using checked-in hashes.
  {
    'name': 'dsymutil_mac_arm64',
    'pattern': '.',
    'condition': 'host_os == "mac" and host_cpu == "arm64"',
    'action': [ 'python3',
                'third_party/depot_tools/download_from_google_storage.py',
                '--no_resume',
                '--no_auth',
                '--bucket', 'chromium-browser-clang',
                '-s', 'tools/clang/dsymutil/bin/dsymutil.arm64.sha1',
                '-o', 'tools/clang/dsymutil/bin/dsymutil',
    ],
  },
  {
    'name': 'dsymutil_mac_x64',
    'pattern': '.',
    'condition': 'host_os == "mac" and host_cpu == "x64"',
    'action': [ 'python3',
                'third_party/depot_tools/download_from_google_storage.py',
                '--no_resume',
                '--no_auth',
                '--bucket', 'chromium-browser-clang',
                '-s', 'tools/clang/dsymutil/bin/dsymutil.x64.sha1',
                '-o', 'tools/clang/dsymutil/bin/dsymutil',
    ],
  },
  {
    'name': 'gcmole',
    'pattern': '.',
    'condition': 'download_gcmole',
    'action': [ 'python3',
                'third_party/depot_tools/download_from_google_storage.py',
                '--bucket', 'chrome-v8-gcmole',
                '-u', '--no_resume',
                '-s', 'tools/gcmole/gcmole-tools.tar.gz.sha1',
                '--platform=linux*',
    ],
  },
  {
    'name': 'jsfunfuzz',
    'pattern': '.',
    'condition': 'download_jsfunfuzz',
    'action': [ 'python3',
                'third_party/depot_tools/download_from_google_storage.py',
                '--bucket', 'chrome-v8-jsfunfuzz',
                '-u', '--no_resume',
                '-s', 'tools/jsfunfuzz/jsfunfuzz.tar.gz.sha1',
                '--platform=linux*',
    ],
  },
  {
    'name': 'wasm_spec_tests',
    'pattern': '.',
    'action': [ 'python3',
                'third_party/depot_tools/download_from_google_storage.py',
                '--no_resume',
                '--no_auth',
                '-u',
                '--bucket', 'v8-wasm-spec-tests',
                '-s', 'test/wasm-spec-tests/tests.tar.gz.sha1',
    ],
  },
  {
    'name': 'wasm_js',
    'pattern': '.',
    'action': [ 'python3',
                'third_party/depot_tools/download_from_google_storage.py',
                '--no_resume',
                '--no_auth',
                '-u',
                '--bucket', 'v8-wasm-spec-tests',
                '-s', 'test/wasm-js/tests.tar.gz.sha1',
    ],
  },
  {
    # Case-insensitivity for the Win SDK. Must run before win_toolchain below.
    'name': 'ciopfs_linux',
    'pattern': '.',
    'condition': 'checkout_win and host_os == "linux"',
    'action': [ 'python3',
                'third_party/depot_tools/download_from_google_storage.py',
                '--no_resume',
                '--no_auth',
                '--bucket', 'chromium-browser-clang/ciopfs',
                '-s', 'build/ciopfs.sha1',
    ]
  },
  {
    # Update the Windows toolchain if necessary.
    'name': 'win_toolchain',
    'pattern': '.',
    'condition': 'checkout_win',
    'action': ['python3', 'build/vs_toolchain.py', 'update', '--force'],
  },
  {
    # Update the Mac toolchain if necessary.
    'name': 'mac_toolchain',
    'pattern': '.',
    'condition': 'checkout_mac',
    'action': ['python3', 'build/mac_toolchain.py'],
  },
  {
    # Update LASTCHANGE.
    'name': 'lastchange',
    'pattern': '.',
    'action': ['python3', 'build/util/lastchange.py',
               '-o', 'build/util/LASTCHANGE'],
  },
  {
    'name': 'Download Fuchsia SDK from GCS',
    'pattern': '.',
    'condition': 'checkout_fuchsia',
    'action': [
      'python3',
      'build/fuchsia/update_sdk.py',
      '--cipd-prefix={fuchsia_sdk_cipd_prefix}',
      '--version={fuchsia_version}',
    ],
  },
  {
    'name': 'Download Fuchsia system images',
    'pattern': '.',
    'condition': 'checkout_fuchsia and checkout_fuchsia_product_bundles',
    'action': [
      'python3',
      'build/fuchsia/update_product_bundles.py',
      '{checkout_fuchsia_boot_images}',
    ],
  },
  {
    # Mac does not have llvm-objdump, download it for cross builds in Fuchsia.
    'name': 'llvm-objdump',
    'pattern': '.',
    'condition': 'host_os == "mac" and checkout_fuchsia',
    'action': ['python3', 'tools/clang/scripts/update.py',
               '--package=objdump'],
  },
  {
    'name': 'vpython3_common',
    'pattern': '.',
    'action': [ 'vpython3',
                '-vpython-spec', '.vpython3',
                '-vpython-tool', 'install',
    ],
  },
  {
    'name': 'check_v8_header_includes',
    'pattern': '.',
    'condition': 'check_v8_header_includes',
    'action': [
      'python3',
      'tools/generate-header-include-checks.py',
    ],
  },
  {
    'name': 'checkout_v8_builtins_pgo_profiles',
    'pattern': '.',
    'condition': 'checkout_v8_builtins_pgo_profiles',
    'action': [
      'python3',
      'tools/builtins-pgo/download_profiles.py',
      'download',
      '--quiet',
    ],
  },
  {
    # Clean up build dirs for crbug.com/1337238.
    # After a libc++ roll and revert, .ninja_deps would get into a state
    # that breaks Ninja on Windows.
    # TODO(crbug.com/1337238): Remove in a month or so.
    'name': 'del_ninja_deps_cache',
    'pattern': '.',
    'condition': 'host_os == "win"',
    'action': ['python3', 'build/del_ninja_deps_cache.py'],
  },
  # Configure remote exec cfg files
  {
    'name': 'download_and_configure_reclient_cfgs',
    'pattern': '.',
    'condition': 'download_remoteexec_cfg and not build_with_chromium',
    'action': ['python3',
               'buildtools/reclient_cfgs/configure_reclient_cfgs.py',
               '--rbe_instance',
               Var('rbe_instance'),
               '--reproxy_cfg_template',
               'reproxy.cfg.template',
               '--rewrapper_cfg_project',
               Var('rewrapper_cfg_project'),
               '--quiet',
               ],
  },
  {
    'name': 'configure_reclient_cfgs',
    'pattern': '.',
    'condition': 'not download_remoteexec_cfg and not build_with_chromium',
    'action': ['python3',
               'buildtools/reclient_cfgs/configure_reclient_cfgs.py',
               '--rbe_instance',
               Var('rbe_instance'),
               '--reproxy_cfg_template',
               'reproxy.cfg.template',
               '--rewrapper_cfg_project',
               Var('rewrapper_cfg_project'),
               '--skip_remoteexec_cfg_fetch',
               ],
  },
  # Configure Siso for developer builds.
  {
    'name': 'configure_siso',
    'pattern': '.',
    'condition': 'not build_with_chromium',
    'action': ['python3',
               'build/config/siso/configure_siso.py',
               '--rbe_instance',
               Var('rbe_instance'),
               ],
  },
]

recursedeps = [
  'build',
  'buildtools',
  'third_party/instrumented_libs',
]
                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/DIR_METADATA                                                                    0000664 0000000 0000000 00000000673 14746647661 0015654 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Metadata information for this directory.
#
# For more information on DIR_METADATA files, see:
#   https://source.chromium.org/chromium/infra/infra/+/master:go/src/infra/tools/dirmd/README.md
#
# For the schema of this file, see Metadata message:
#   https://source.chromium.org/chromium/infra/infra/+/master:go/src/infra/tools/dirmd/proto/dir_metadata.proto

monorail {
  component: "Blink>JavaScript"
}
team_email: "v8-dev@googlegroups.com"                                                                     node-23.7.0/deps/v8/ENG_REVIEW_OWNERS                                                               0000664 0000000 0000000 00000000514 14746647661 0016557 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Eng reviewers. This is to define an escalation path for potential
# disagreement among owners. Please consult before adding top-level
# directories.

adamk@chromium.org
danno@chromium.org
gdeepti@chromium.org
hpayer@chromium.org
leszeks@chromium.org
mlippautz@chromium.org
syg@chromium.org
verwaest@chromium.org
vahl@chromium.org
                                                                                                                                                                                    node-23.7.0/deps/v8/INFRA_OWNERS                                                                    0000664 0000000 0000000 00000000137 14746647661 0015725 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        alexschulze@chromium.org
almuthanna@chromium.org
liviurau@chromium.org
machenbach@chromium.org
                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/INTL_OWNERS                                                                     0000664 0000000 0000000 00000000111 14746647661 0015624 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        cira@chromium.org
mnita@google.com
jshin@chromium.org
ftang@chromium.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/LICENSE                                                                         0000664 0000000 0000000 00000006032 14746647661 0015053 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        This license applies to all parts of V8 that are not externally
maintained libraries.  The externally maintained libraries used by V8
are:

  - PCRE test suite, located in
    test/mjsunit/third_party/regexp-pcre/regexp-pcre.js.  This is based on the
    test suite from PCRE-7.3, which is copyrighted by the University
    of Cambridge and Google, Inc.  The copyright notice and license
    are embedded in regexp-pcre.js.

  - Layout tests, located in test/mjsunit/third_party/object-keys.  These are
    based on layout tests from webkit.org which are copyrighted by
    Apple Computer, Inc. and released under a 3-clause BSD license.

  - Strongtalk assembler, the basis of the files assembler-arm-inl.h,
    assembler-arm.cc, assembler-arm.h, assembler-ia32-inl.h,
    assembler-ia32.cc, assembler-ia32.h, assembler-x64-inl.h,
    assembler-x64.cc, assembler-x64.h, assembler.cc and assembler.h.
    This code is copyrighted by Sun Microsystems Inc. and released
    under a 3-clause BSD license.

  - Valgrind client API header, located at src/third_party/valgrind/valgrind.h
    This is released under the BSD license.

  - The Wasm C/C++ API headers, located at third_party/wasm-api/wasm.{h,hh}
    This is released under the Apache license. The API's upstream prototype
    implementation also formed the basis of V8's implementation in
    src/wasm/c-api.cc.

These libraries have their own licenses; we recommend you read them,
as their terms may differ from the terms below.

Further license information can be found in LICENSE files located in 
sub-directories.

Copyright 2014, the V8 project authors. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.
    * Neither the name of Google Inc. nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/LICENSE.fdlibm                                                                  0000664 0000000 0000000 00000000372 14746647661 0016310 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        Copyright (C) 1993-2004 by Sun Microsystems, Inc. All rights reserved.

Developed at SunSoft, a Sun Microsystems, Inc. business.
Permission to use, copy, modify, and distribute this
software is freely granted, provided that this notice
is preserved.
                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/LICENSE.strongtalk                                                              0000664 0000000 0000000 00000002712 14746647661 0017243 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        Copyright (c) 1994-2006 Sun Microsystems Inc.
All Rights Reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

- Redistribution in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

- Neither the name of Sun Microsystems or the names of contributors may
be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                      node-23.7.0/deps/v8/LICENSE.v8                                                                      0000664 0000000 0000000 00000002767 14746647661 0015422 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        Copyright 2006-2011, the V8 project authors. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.
    * Neither the name of Google Inc. nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         node-23.7.0/deps/v8/LOONG_OWNERS                                                                    0000664 0000000 0000000 00000000103 14746647661 0015735 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        liuyu@loongson.cn
yuyin-hf@loongson.cn
zhaojiazhong-hf@loongson.cn
                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/MIPS_OWNERS                                                                     0000664 0000000 0000000 00000000100 14746647661 0015624 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        xwafish@gmail.com
zhaojiazhong-hf@loongson.cn
liuyu@loongson.cn
                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/OWNERS                                                                          0000664 0000000 0000000 00000002110 14746647661 0014777 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Eng reviewer. Please reach out before adding new top-level directories.
# Disagreement among owners should be escalated to eng reviewers.
file:ENG_REVIEW_OWNERS

per-file .*=file:INFRA_OWNERS
per-file .bazelrc=file:COMMON_OWNERS
per-file .mailmap=file:COMMON_OWNERS
per-file .ycm_extra_conf.py=file:COMMON_OWNERS
per-file codereview.settings=file:INFRA_OWNERS
per-file AUTHORS=file:COMMON_OWNERS
per-file BUILD.bazel=file:COMMON_OWNERS
per-file BUILD.gn=file:COMMON_OWNERS
per-file DEPS=file:COMMON_OWNERS
per-file INFRA_OWNERS=file:INFRA_OWNERS
per-file PRESUBMIT.py=file:INFRA_OWNERS
per-file WATCHLISTS=file:COMMON_OWNERS
per-file WORKSPACE=file:COMMON_OWNERS

# Needed by the auto_tag builder
per-file WATCHLISTS=v8-ci-autoroll-builder@chops-service-accounts.iam.gserviceaccount.com
per-file DEPS=v8-ci-autoroll-builder@chops-service-accounts.iam.gserviceaccount.com

per-file ...-loong64*=file:LOONG_OWNERS
per-file ...-mips*=file:MIPS_OWNERS
per-file ...-mips64*=file:MIPS_OWNERS
per-file ...-ppc*=file:PPC_OWNERS
per-file ...-riscv*=file:RISCV_OWNERS
per-file ...-s390*=file:S390_OWNERS
                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/PPC_OWNERS                                                                      0000664 0000000 0000000 00000000116 14746647661 0015505 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        junyan@redhat.com
joransiu@ca.ibm.com
midawson@redhat.com
mfarazma@redhat.com
                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/PRESUBMIT.py                                                                    0000664 0000000 0000000 00000052775 14746647661 0016011 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2012 the V8 project authors. All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#     * Neither the name of Google Inc. nor the names of its
#       contributors may be used to endorse or promote products derived
#       from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""Top-level presubmit script for V8.

See http://dev.chromium.org/developers/how-tos/depottools/presubmit-scripts
for more details about the presubmit API built into gcl.
"""

import ast
import json
import os
import re
import sys
import traceback

# This line is 'magic' in that git-cl looks for it to decide whether to
# use Python3 instead of Python2 when running the code in this file.
USE_PYTHON3 = True

_EXCLUDED_PATHS = (
    r"^test[\\\/].*",
    r"^testing[\\\/].*",
    r"^third_party[\\\/].*",
    r"^tools[\\\/].*",
)

_LICENSE_FILE = (
    r"LICENSE"
)

# Regular expression that matches code which should not be run through cpplint.
_NO_LINT_PATHS = (
    r'src[\\\/]base[\\\/]export-template\.h',
)


# Regular expression that matches code only used for test binaries
# (best effort).
_TEST_CODE_EXCLUDED_PATHS = (
    r'.+-unittest\.cc',
    # Has a method VisitForTest().
    r'src[\\\/]compiler[\\\/]ast-graph-builder\.cc',
    # Test extension.
    r'src[\\\/]extensions[\\\/]gc-extension\.cc',
    # Runtime functions used for testing.
    r'src[\\\/]runtime[\\\/]runtime-test\.cc',
    # Testing helpers.
    r'src[\\\/]heap[\\\/]cppgc[\\\/]testing\.cc',
)


_TEST_ONLY_WARNING = (
    'You might be calling functions intended only for testing from\n'
    'production code.  It is OK to ignore this warning if you know what\n'
    'you are doing, as the heuristics used to detect the situation are\n'
    'not perfect.  The commit queue will not block on this warning.')


def _V8PresubmitChecks(input_api, output_api):
  """Runs the V8 presubmit checks."""
  import sys
  sys.path.append(input_api.os_path.join(
        input_api.PresubmitLocalPath(), 'tools'))
  from v8_presubmit import CppLintProcessor
  from v8_presubmit import GCMoleProcessor
  from v8_presubmit import JSLintProcessor
  from v8_presubmit import TorqueLintProcessor
  from v8_presubmit import SourceProcessor
  from v8_presubmit import StatusFilesProcessor

  def FilterFile(affected_file):
    return input_api.FilterSourceFile(
      affected_file,
      files_to_check=None,
      files_to_skip=_NO_LINT_PATHS)

  def FilterTorqueFile(affected_file):
    return input_api.FilterSourceFile(
      affected_file,
      files_to_check=(r'.+\.tq'))

  def FilterJSFile(affected_file):
    return input_api.FilterSourceFile(
      affected_file,
      files_to_check=(r'.+\.m?js'))

  results = []
  if not CppLintProcessor().RunOnFiles(
      input_api.AffectedFiles(file_filter=FilterFile, include_deletes=False)):
    results.append(output_api.PresubmitError("C++ lint check failed"))
  if not TorqueLintProcessor().RunOnFiles(
      input_api.AffectedFiles(file_filter=FilterTorqueFile,
                              include_deletes=False)):
    results.append(output_api.PresubmitError("Torque format check failed"))
  if not JSLintProcessor().RunOnFiles(
      input_api.AffectedFiles(file_filter=FilterJSFile,
                              include_deletes=False)):
    results.append(output_api.PresubmitError("JS format check failed"))
  if not SourceProcessor().RunOnFiles(
      input_api.AffectedFiles(include_deletes=False)):
    results.append(output_api.PresubmitError(
        "Copyright header, trailing whitespaces and two empty lines " \
        "between declarations check failed"))
  if not StatusFilesProcessor().RunOnFiles(
      input_api.AffectedFiles(include_deletes=True)):
    results.append(output_api.PresubmitError("Status file check failed"))
  if not GCMoleProcessor().RunOnFiles(
      input_api.AffectedFiles(include_deletes=False)):
    results.append(output_api.PresubmitError("GCMole pattern check failed"))
  results.extend(input_api.canned_checks.CheckAuthorizedAuthor(
      input_api, output_api, bot_allowlist=[
        'v8-ci-autoroll-builder@chops-service-accounts.iam.gserviceaccount.com',
        'v8-ci-test262-import-export@chops-service-accounts.iam.gserviceaccount.com',
      ]))
  return results


def _CheckPythonLiterals(input_api, output_api):
  """Checks that all .pyl files are valid python literals."""
  affected_files = [
      af for af in input_api.AffectedFiles()
      if af.LocalPath().endswith('.pyl')
  ]

  results = []
  for af in affected_files:
    try:
      ast.literal_eval('\n'.join(af.NewContents()))
    except SyntaxError as e:
      results.append(output_api.PresubmitError(
          f'Failed to parse python literal {af.LocalPath()}:\n' +
          traceback.format_exc(0)
      ))

  return results



def _CheckUnwantedDependencies(input_api, output_api):
  """Runs checkdeps on #include statements added in this
  change. Breaking - rules is an error, breaking ! rules is a
  warning.
  """
  # We need to wait until we have an input_api object and use this
  # roundabout construct to import checkdeps because this file is
  # eval-ed and thus doesn't have __file__.
  original_sys_path = sys.path
  try:
    sys.path = sys.path + [input_api.os_path.join(
        input_api.PresubmitLocalPath(), 'buildtools', 'checkdeps')]
    import checkdeps
    from cpp_checker import CppChecker
    from rules import Rule
  finally:
    # Restore sys.path to what it was before.
    sys.path = original_sys_path

  def _FilesImpactedByDepsChange(files):
    all_files = [f.AbsoluteLocalPath() for f in files]
    deps_files = [p for p in all_files if IsDepsFile(p)]
    impacted_files = union([_CollectImpactedFiles(path) for path in deps_files])
    impacted_file_objs = [ImpactedFile(path) for path in impacted_files]
    return impacted_file_objs

  def IsDepsFile(p):
    return os.path.isfile(p) and os.path.basename(p) == 'DEPS'

  def union(list_of_lists):
    """Ensure no duplicates"""
    return set(sum(list_of_lists, []))

  def _CollectImpactedFiles(deps_file):
    # TODO(liviurau): Do not walk paths twice. Then we have no duplicates.
    # Higher level DEPS changes may dominate lower level DEPS changes.
    # TODO(liviurau): Check if DEPS changed in the right way.
    # 'include_rules' impact c++ files but 'vars' or 'deps' do not.
    # Maybe we just eval both old and new DEPS content and check
    # if the list are the same.
    result = []
    parent_dir = os.path.dirname(deps_file)
    for relative_f in input_api.change.AllFiles(parent_dir):
      abs_f = os.path.join(parent_dir, relative_f)
      if CppChecker.IsCppFile(abs_f):
        result.append(abs_f)
    return result

  class ImpactedFile(object):
    """Duck type version of AffectedFile needed to check files under directories
    where a DEPS file changed. Extend the interface along the line of
    AffectedFile if you need it for other checks."""

    def __init__(self, path):
      self._path = path

    def LocalPath(self):
      path = self._path.replace(os.sep, '/')
      return os.path.normpath(path)

    def ChangedContents(self):
      with open(self._path) as f:
        # TODO(liviurau): read only '#include' lines
        lines = f.readlines()
      return enumerate(lines, start=1)

  def _FilterDuplicates(impacted_files, affected_files):
    """"We include all impacted files but exclude affected files that are also
    impacted. Files impacted by DEPS changes take precedence before files
    affected by direct changes."""
    result = impacted_files[:]
    only_paths = set([imf.LocalPath() for imf in impacted_files])
    for af in affected_files:
      if not af.LocalPath() in only_paths:
        result.append(af)
    return result

  added_includes = []
  affected_files = input_api.AffectedFiles()
  impacted_by_deps = _FilesImpactedByDepsChange(affected_files)
  for f in _FilterDuplicates(impacted_by_deps, affected_files):
    if not CppChecker.IsCppFile(f.LocalPath()):
      continue

    changed_lines = [line for line_num, line in f.ChangedContents()]
    added_includes.append([f.LocalPath(), changed_lines])

  deps_checker = checkdeps.DepsChecker(input_api.PresubmitLocalPath())

  error_descriptions = []
  warning_descriptions = []
  for path, rule_type, rule_description in deps_checker.CheckAddedCppIncludes(
      added_includes):
    description_with_path = '{}\n    {}'.format(path, rule_description)
    if rule_type == Rule.DISALLOW:
      error_descriptions.append(description_with_path)
    else:
      warning_descriptions.append(description_with_path)

  results = []
  if error_descriptions:
    results.append(output_api.PresubmitError(
        'You added one or more #includes that violate checkdeps rules.',
        error_descriptions))
  if warning_descriptions:
    results.append(output_api.PresubmitPromptOrNotify(
        'You added one or more #includes of files that are temporarily\n'
        'allowed but being removed. Can you avoid introducing the\n'
        '#include? See relevant DEPS file(s) for details and contacts.',
        warning_descriptions))
  return results


def _CheckHeadersHaveIncludeGuards(input_api, output_api):
  """Ensures that all header files have include guards."""
  file_inclusion_pattern = r'src/.+\.h'

  def FilterFile(affected_file):
    files_to_skip = _EXCLUDED_PATHS + input_api.DEFAULT_FILES_TO_SKIP
    return input_api.FilterSourceFile(
      affected_file,
      files_to_check=(file_inclusion_pattern, ),
      files_to_skip=files_to_skip)

  leading_src_pattern = input_api.re.compile(r'^src[\\\/]')
  dash_dot_slash_pattern = input_api.re.compile(r'[-.\\\/]')

  def PathToGuardMacro(path):
    """Guards should be of the form V8_PATH_TO_FILE_WITHOUT_SRC_H_."""
    x = input_api.re.sub(leading_src_pattern, 'v8_', path)
    x = input_api.re.sub(dash_dot_slash_pattern, '_', x)
    x = x.upper() + "_"
    return x

  problems = []
  for f in input_api.AffectedSourceFiles(FilterFile):
    local_path = f.LocalPath()
    guard_macro = PathToGuardMacro(local_path)
    guard_patterns = [
            input_api.re.compile(r'^#ifndef ' + guard_macro + '$'),
            input_api.re.compile(r'^#define ' + guard_macro + '$'),
            input_api.re.compile(r'^#endif  // ' + guard_macro + '$')]
    skip_check_pattern = input_api.re.compile(
            r'^// PRESUBMIT_INTENTIONALLY_MISSING_INCLUDE_GUARD')
    found_patterns = [ False, False, False ]
    file_omitted = False

    for line in f.NewContents():
      for i in range(len(guard_patterns)):
        if guard_patterns[i].match(line):
          found_patterns[i] = True
      if skip_check_pattern.match(line):
        file_omitted = True
        break

    if not file_omitted and not all(found_patterns):
      problems.append('{}: Missing include guard \'{}\''.format(
          local_path, guard_macro))

  if problems:
    return [output_api.PresubmitError(
        'You added one or more header files without an appropriate\n'
        'include guard. Add the include guard {#ifndef,#define,#endif}\n'
        'triplet or omit the check entirely through the magic comment:\n'
        '"// PRESUBMIT_INTENTIONALLY_MISSING_INCLUDE_GUARD".', problems)]
  else:
    return []


def _CheckNoInlineHeaderIncludesInNormalHeaders(input_api, output_api):
  """Attempts to prevent inclusion of inline headers into normal header
  files. This tries to establish a layering where inline headers can be
  included by other inline headers or compilation units only."""
  file_inclusion_pattern = r'(?!.+-inl\.h).+\.h'
  include_directive_pattern = input_api.re.compile(r'#include ".+-inl.h"')
  include_error = (
    'You are including an inline header (e.g. foo-inl.h) within a normal\n'
    'header (e.g. bar.h) file.  This violates layering of dependencies.')

  def FilterFile(affected_file):
    files_to_skip = _EXCLUDED_PATHS + input_api.DEFAULT_FILES_TO_SKIP
    return input_api.FilterSourceFile(
      affected_file,
      files_to_check=(file_inclusion_pattern, ),
      files_to_skip=files_to_skip)

  problems = []
  for f in input_api.AffectedSourceFiles(FilterFile):
    local_path = f.LocalPath()
    for line_number, line in f.ChangedContents():
      if (include_directive_pattern.search(line)):
        problems.append('{}:{}\n    {}'.format(local_path, line_number,
                                               line.strip()))

  if problems:
    return [output_api.PresubmitError(include_error, problems)]
  else:
    return []


def _CheckNoProductionCodeUsingTestOnlyFunctions(input_api, output_api):
  """Attempts to prevent use of functions intended only for testing in
  non-testing code. For now this is just a best-effort implementation
  that ignores header files and may have some false positives. A
  better implementation would probably need a proper C++ parser.
  """
  # We only scan .cc files, as the declaration of for-testing functions in
  # header files are hard to distinguish from calls to such functions without a
  # proper C++ parser.
  file_inclusion_pattern = r'.+\.cc'

  base_function_pattern = r'[ :]test::[^\s]+|ForTest(ing)?|for_test(ing)?'
  inclusion_pattern = input_api.re.compile(
      r'({})\s*\('.format(base_function_pattern))
  comment_pattern = input_api.re.compile(
      r'//.*({})'.format(base_function_pattern))
  exclusion_pattern = input_api.re.compile(
      r'::[A-Za-z0-9_]+({})|({})[^;]+'.format(base_function_pattern,
                                              base_function_pattern) + '\{')

  def FilterFile(affected_file):
    files_to_skip = (_EXCLUDED_PATHS +
                     _TEST_CODE_EXCLUDED_PATHS +
                     input_api.DEFAULT_FILES_TO_SKIP)
    return input_api.FilterSourceFile(
      affected_file,
      files_to_check=(file_inclusion_pattern, ),
      files_to_skip=files_to_skip)

  problems = []
  for f in input_api.AffectedSourceFiles(FilterFile):
    local_path = f.LocalPath()
    for line_number, line in f.ChangedContents():
      if (inclusion_pattern.search(line) and
          not comment_pattern.search(line) and
          not exclusion_pattern.search(line)):
        problems.append('{}:{}\n    {}'.format(local_path, line_number,
                                               line.strip()))

  if problems:
    return [output_api.PresubmitPromptOrNotify(_TEST_ONLY_WARNING, problems)]
  else:
    return []


def _CheckGenderNeutralInLicenses(input_api, output_api):
  # License files are taken as is, even if they include gendered pronouns.
  def LicenseFilter(path):
    input_api.FilterSourceFile(path, files_to_skip=_LICENSE_FILE)

  return input_api.canned_checks.CheckGenderNeutral(
    input_api, output_api, source_file_filter=LicenseFilter)


def _RunTestsWithVPythonSpec(input_api, output_api):
  return input_api.RunTests(
    input_api.canned_checks.CheckVPythonSpec(input_api, output_api))


def _CommonChecks(input_api, output_api):
  """Checks common to both upload and commit."""
  # TODO(machenbach): Replace some of those checks, e.g. owners and copyright,
  # with the canned PanProjectChecks. Need to make sure that the checks all
  # pass on all existing files.
  checks = [
    input_api.canned_checks.CheckOwnersFormat,
    input_api.canned_checks.CheckOwners,
    _CheckCommitMessageBugEntry,
    input_api.canned_checks.CheckPatchFormatted,
    _CheckGenderNeutralInLicenses,
    _V8PresubmitChecks,
    _CheckUnwantedDependencies,
    _CheckNoProductionCodeUsingTestOnlyFunctions,
    _CheckHeadersHaveIncludeGuards,
    _CheckNoInlineHeaderIncludesInNormalHeaders,
    _CheckJSONFiles,
    _CheckNoexceptAnnotations,
    _RunTestsWithVPythonSpec,
    _CheckPythonLiterals,
  ]

  return sum([check(input_api, output_api) for check in checks], [])


def _SkipTreeCheck(input_api, output_api):
  """Check the env var whether we want to skip tree check.
     Only skip if include/v8-version.h has been updated."""
  src_version = 'include/v8-version.h'
  if not input_api.AffectedSourceFiles(
      lambda file: file.LocalPath() == src_version):
    return False
  return input_api.environ.get('PRESUBMIT_TREE_CHECK') == 'skip'


def _CheckCommitMessageBugEntry(input_api, output_api):
  """Check that bug entries are well-formed in commit message."""
  bogus_bug_msg = (
      'Bogus BUG entry: {}. Please specify prefix:number for v8 or chromium '
      '(e.g. chromium:12345) or b/number for buganizer.')
  results = []
  for bug in (input_api.change.BUG or '').split(','):
    bug = bug.strip()
    if 'none'.startswith(bug.lower()):
      continue
    if ':' not in bug and not bug.startswith('b/'):
      try:
        if int(bug) < 10000000:
          if int(bug) > 200000:
            prefix_guess = 'chromium'
          else:
            prefix_guess = 'v8'
          results.append(
              'BUG entry requires issue tracker prefix, e.g. {}:{}'.format(
                  prefix_guess, bug))
      except ValueError:
        results.append(bogus_bug_msg.format(bug))
    elif not re.match(r'\w+[:\/]\d+', bug):
      results.append(bogus_bug_msg.format(bug))
  return [output_api.PresubmitError(r) for r in results]


def _CheckJSONFiles(input_api, output_api):
  def FilterFile(affected_file):
    return input_api.FilterSourceFile(
        affected_file,
        files_to_check=(r'.+\.json',))

  results = []
  for f in input_api.AffectedFiles(
      file_filter=FilterFile, include_deletes=False):
    with open(f.LocalPath()) as j:
      try:
        json.load(j)
      except Exception as e:
        results.append('JSON validation failed for {}. Error:\n{}'.format(
            f.LocalPath(), e))

  return [output_api.PresubmitError(r) for r in results]


def _CheckNoexceptAnnotations(input_api, output_api):
  """
  Checks that all user-defined constructors and assignment operators are marked
  V8_NOEXCEPT.

  This is required for standard containers to pick the right constructors. Our
  macros (like MOVE_ONLY_WITH_DEFAULT_CONSTRUCTORS) add this automatically.
  Omitting it at some places can result in weird compiler errors if this is
  mixed with other classes that have the annotation.

  TODO(clemensb): This check should eventually be enabled for all files via
  tools/presubmit.py (https://crbug.com/v8/8616).
  """

  def FilterFile(affected_file):
    files_to_skip = _EXCLUDED_PATHS + (
        # Skip api.cc since we cannot easily add the 'noexcept' annotation to
        # public methods.
        r'src[\\\/]api[\\\/]api\.cc',
        # Skip src/bigint/ because it's meant to be V8-independent.
        r'src[\\\/]bigint[\\\/].*',
    )
    return input_api.FilterSourceFile(
        affected_file,
        files_to_check=(r'src[\\\/].*\.cc', r'src[\\\/].*\.h',
                        r'test[\\\/].*\.cc', r'test[\\\/].*\.h'),
        files_to_skip=files_to_skip)

  # matches any class name.
  class_name = r'\b([A-Z][A-Za-z0-9_:]*)(?:::\1)?'
  # initial class name is potentially followed by this to declare an assignment
  # operator.
  potential_assignment = r'(?:&\s+(?:\1::)?operator=)?\s*'
  # matches an argument list that contains only a reference to a class named
  # like the first capture group, potentially const.
  single_class_ref_arg = r'\(\s*(?:const\s+)?\1(?:::\1)?&&?[^,;)]*\)'
  # matches anything but a sequence of whitespaces followed by either
  # V8_NOEXCEPT or "= delete".
  not_followed_by_noexcept = r'(?!\s+(?:V8_NOEXCEPT|=\s+delete)\b)'
  full_pattern = r'^.*?' + class_name + potential_assignment + \
      single_class_ref_arg + not_followed_by_noexcept + '.*?$'
  regexp = input_api.re.compile(full_pattern, re.MULTILINE)

  errors = []
  for f in input_api.AffectedFiles(file_filter=FilterFile,
                                   include_deletes=False):
    with open(f.LocalPath()) as fh:
      for match in re.finditer(regexp, fh.read()):
        errors.append(f'in {f.LocalPath()}: {match.group().strip()}')

  if errors:
    return [output_api.PresubmitPromptOrNotify(
        'Copy constructors, move constructors, copy assignment operators and '
        'move assignment operators should be marked V8_NOEXCEPT.\n'
        'Please report false positives on https://crbug.com/v8/8616.',
        errors)]
  return []


def CheckChangeOnUpload(input_api, output_api):
  results = []
  results.extend(_CommonChecks(input_api, output_api))
  return results


def CheckChangeOnCommit(input_api, output_api):
  results = []
  results.extend(_CommonChecks(input_api, output_api))
  results.extend(input_api.canned_checks.CheckChangeHasDescription(
      input_api, output_api))
  if not _SkipTreeCheck(input_api, output_api):
    results.extend(input_api.canned_checks.CheckTreeIsOpen(
        input_api, output_api,
        json_url='http://v8-status.appspot.com/current?format=json'))
  return results
   node-23.7.0/deps/v8/README.md                                                                       0000664 0000000 0000000 00000001704 14746647661 0015326 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        V8 JavaScript Engine
=============

V8 is Google's open source JavaScript engine.

V8 implements ECMAScript as specified in ECMA-262.

V8 is written in C++ and is used in Google Chrome, the open source
browser from Google.

V8 can run standalone, or can be embedded into any C++ application.

V8 Project page: https://v8.dev/docs


Getting the Code
=============

Checkout [depot tools](http://www.chromium.org/developers/how-tos/install-depot-tools), and run

        fetch v8

This will checkout V8 into the directory `v8` and fetch all of its dependencies.
To stay up to date, run

        git pull origin
        gclient sync

For fetching all branches, add the following into your remote
configuration in `.git/config`:

        fetch = +refs/branch-heads/*:refs/remotes/branch-heads/*
        fetch = +refs/tags/*:refs/tags/*


Contributing
=============

Please follow the instructions mentioned at
[v8.dev/docs/contribute](https://v8.dev/docs/contribute).
                                                            node-23.7.0/deps/v8/RISCV_OWNERS                                                                    0000664 0000000 0000000 00000000121 14746647661 0015745 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        brice.dobry@futurewei.com
peng.w@rioslab.org
qiuji@iscas.ac.cn
yahan@iscas.ac.cn
                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/S390_OWNERS                                                                     0000664 0000000 0000000 00000000116 14746647661 0015521 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        junyan@redhat.com
joransiu@ca.ibm.com
midawson@redhat.com
mfarazma@redhat.com
                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/WATCHLISTS                                                                      0000664 0000000 0000000 00000012464 14746647661 0015464 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#     * Neither the name of Google Inc. nor the names of its
#       contributors may be used to endorse or promote products derived
#       from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Watchlist Rules
# Refer: http://dev.chromium.org/developers/contributing-code/watchlists

# IMPORTANT: The regular expression filepath is tested against each path using
# re.search, so it is not usually necessary to add .*.

{
  'WATCHLIST_DEFINITIONS': {
    'api': {
      'filepath': 'include/',
    },
    'snapshot': {
      'filepath': 'src/snapshot/',
    },
    'devtools': {
      'filepath': 'src/debug/' \
                  '|src/inspector/' \
                  '|src/profiler/' \
                  '|src/libsampler/' \
                  '|src/tracing/' \
                  '|include/js_protocol.pdl' \
                  '|include/v8-inspector*\.h',
    },
    'baseline': {
      'filepath': 'src/baseline/',
    },
    'feature_shipping_status': {
      'filepath': 'src/flags/flag-definitions.h',
    },
    'heap_changes': {
      'filepath': 'src/heap/',
    },
    'arm': {
      'filepath': '/arm/',
    },
    'merges': {
      'filepath': '.',
    },
    'wasm': {
      'filepath': 'src/wasm/' \
                  '|src/compiler/wasm',
    },
    'value_serializer': {
      'filepath': 'src/value-serializer',
    },
    'maglev': {
      'filepath': 'src/maglev/',
    },
    'compiler': {
      'filepath': 'src/compiler',
    },
    'parser': {
      'filepath': 'src/ast/' \
                  '|src/parsing/',
    },
    'tracing': {
      'filepath': 'src/tracing/',
    },
    'ieee754': {
      'filepath': 'src/base/ieee754\.(cc|h)' \
                  '|src/base/overflowing-math.h' \
                  '|LICENSE.fdlibm',
    },
    'regexp': {
      'filepath': 'src/.*regexp',
    },
    'bazel': {
      'filepath': 'BUILD.gn' \
                  '|BUILD.bazel' \
                  '|WORKSPACE' \
                  '|bazel/',
    },
    'cppgc': {
      'filepath': 'src/heap/cppgc/' \
                  '|src/heap/cppgc-js/' \
                  '|include/cppgc/' \
                  '|test/unittests/heap/cppgc/' \
                  '|test/unittests/heap/cppgc-js/',
    },
    'trap-handler': {
      'filepath': 'src/trap-handler/',
    },
  },

  'WATCHLISTS': {
    'maglev': [
      'leszeks+watch@chromium.org',
      'verwaest+watch@chromium.org',
      'victorgomes+watch@chromium.org',
    ],
    'compiler': [
      'dmercadier+watch@chromium.org',
    ],
    'snapshot': [
      'jgruber+watch@chromium.org',
    ],
    'devtools': [
      'devtools-reviews+v8@chromium.org',
    ],
    'baseline': [
      'leszeks+watch@chromium.org',
      'verwaest+watch@chromium.org',
    ],
    'feature_shipping_status': [
      'hablich@chromium.org',
      'saelo+watch@chromium.org',
    ],
    'heap_changes': [
      'hpayer@chromium.org',
      'mlippautz+watch@chromium.org',
    ],
    'arm': [
      'v8-mips-ports@googlegroups.com',
      'v8-ppc-ports@googlegroups.com',
      'v8-risc-v-ports@chromium.org',
    ],
    'merges': [
      # Only enabled on branches created with tools/release/create_release.py
      'v8-merges@googlegroups.com',
    ],
    'wasm': [
      'wasm-v8@google.com',
    ],
    'value_serializer': [
      'jbroman+watch@chromium.org',
    ],
    'parser': [
      'marja+watch@chromium.org',
    ],
    'tracing': [
      'alph+watch@chromium.org',
      'lpy+v8tracing@chromium.org',
      'fmeawad@chromium.org',
      'cbruni+watch@chromium.org',
    ],
    'ieee754': [
      'rtoy+watch@chromium.org',
      'hongchan+watch@chromium.org',
    ],
    'regexp': [
      'jgruber+watch@chromium.org',
      'pthier+watch@chromium.org',
    ],
    'bazel': [
      'victorgomes+watch@chromium.org',
    ],
    'api': [
      'cbruni+watch@chromium.org',
    ],
    'cppgc': [
      'oilpan-reviews+v8@chromium.org',
    ],
    'trap-handler': [
      'ahaas@chromium.org',
      'clemensb@chromium.org',
      'mark@chromium.org',
      'mseaborn@chromium.org',
    ],
  },
}
                                                                                                                                                                                                            node-23.7.0/deps/v8/WORKSPACE                                                                       0000664 0000000 0000000 00000004272 14746647661 0015333 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2021 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

workspace(name = "v8")

load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")

http_archive(
    name = "bazel_skylib",
    sha256 = "1c531376ac7e5a180e0237938a2536de0c54d93f5c278634818e0efc952dd56c",
    urls = [
        "https://github.com/bazelbuild/bazel-skylib/releases/download/1.0.3/bazel-skylib-1.0.3.tar.gz",
        "https://mirror.bazel.build/github.com/bazelbuild/bazel-skylib/releases/download/1.0.3/bazel-skylib-1.0.3.tar.gz",
    ],
)

load("@bazel_skylib//:workspace.bzl", "bazel_skylib_workspace")

bazel_skylib_workspace()

http_archive(
    name = "rules_python",
    sha256 = "a30abdfc7126d497a7698c29c46ea9901c6392d6ed315171a6df5ce433aa4502",
    strip_prefix = "rules_python-0.6.0",
    url = "https://github.com/bazelbuild/rules_python/archive/0.6.0.tar.gz",
)

load("@rules_python//python:pip.bzl", "pip_install")

pip_install(
    name = "v8_python_deps",
    extra_pip_args = ["--require-hashes"],
    requirements = "//:bazel/requirements.txt",
)

local_repository(
  name = "com_google_absl",
  path = "third_party/abseil-cpp",
)

bind(
    name = "absl_optional",
    actual = "@com_google_absl//absl/types:optional"
)

bind(
    name = "absl_btree",
    actual = "@com_google_absl//absl/container:btree"
)

bind(
    name = "absl_flat_hash_map",
    actual = "@com_google_absl//absl/container:flat_hash_map"
)

bind(
    name = "absl_flat_hash_set",
    actual = "@com_google_absl//absl/container:flat_hash_set"
)

new_local_repository(
    name = "com_googlesource_chromium_icu",
    build_file = ":bazel/BUILD.icu",
    path = "third_party/icu",
)

bind(
    name = "icu",
    actual = "@com_googlesource_chromium_icu//:icu",
)

http_archive(
    name = "intel_ittapi",
    add_prefix = "third_party/ittapi",
    build_file = "@//:bazel/BUILD.ittapi",
    sha256 = "36c42d3f2446ddfaa2d7dfa02dfaa79615933f1a68a72d7e4f1d70de7b56e2c9",
    strip_prefix = "ittapi-3.24.0",
    url = "https://github.com/intel/ittapi/archive/refs/tags/v3.24.0.tar.gz",
)

bind(
    name = "ittapi",
    actual = "@intel_ittapi//:lib_ittapi",
)
                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/bazel/                                                                          0000775 0000000 0000000 00000000000 14746647661 0015142 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/bazel/BUILD.icu                                                                 0000664 0000000 0000000 00000005576 14746647661 0016520 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2021 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

filegroup(
    name = "icudata",
    srcs = ["common/icudtl.dat"],
    visibility = ["//visibility:public"],
)

cc_library(
    name = "icuuc",
    srcs = glob([
        "source/common/**/*.h",
        "source/common/**/*.cpp",
    ]),
    copts = select({
        "@platforms//os:windows": [
            "/wd4005",  # Macro redefinition.
            "/wd4068",  # Unknown pragmas.
            "/wd4267",  # Conversion from size_t on 64-bits.
            "/utf-8",  # ICU source files are in UTF-8.
        ],
        "//conditions:default": [
            "-Wno-deprecated-declarations",
        ],
    }),
    data = [":icudata"],
    defines = [
        "HAVE_DLOPEN=0",
        "UCONFIG_ONLY_HTML_CONVERSION=1",
        "U_CHARSET_IS_UTF8=1",
        "U_USING_ICU_NAMESPACE=0",
        "U_ENABLE_DYLOAD=0",
        "USE_CHROMIUM_ICU=1",
        "U_ENABLE_TRACING=1",
        "U_ENABLE_RESOURCE_TRACING=0",
        "UNISTR_FROM_STRING_EXPLICIT=",
        "UNISTR_FROM_CHAR_EXPLICIT=",
    ] + select({
        "@platforms//os:windows": [
            "U_STATIC_IMPLEMENTATION",
            "UNICODE",
            "_UNICODE",
        ],
        "//conditions:default": [],
    }),
    includes = [
        "source/common",
        "source/i18n",
    ],
    local_defines = [
        "U_COMMON_IMPLEMENTATION",
        "U_ICUDATAENTRY_IN_COMMON",
    ],
    tags = ["requires-rtti"],
    alwayslink = 1,
)

cc_library(
    name = "icui18n",
    srcs = glob([
        "source/i18n/**/*.h",
        "source/i18n/**/*.cpp",
    ]),
    copts = select({
        "@platforms//os:windows": [
            "/wd4005",  # Macro redefinition.
            "/wd4068",  # Unknown pragmas.
            "/wd4267",  # Conversion from size_t on 64-bits.
            "/utf-8",  # ICU source files are in UTF-8.
        ],
        "//conditions:default": [
            "-Wno-deprecated-declarations",
        ],
    }),
    local_defines = [
        "U_I18N_IMPLEMENTATION",
    ],
    deps = [":icuuc"],
    alwayslink = 1,
)

cc_library(
    name = "icu",
    srcs = [
        "source/stubdata/stubdata.cpp",
        "source/stubdata/stubdata.h",
    ],
    hdrs = glob([
        "source/common/unicode/*.h",
        "source/i18n/unicode/*.h",
    ]),
    copts = select({
        "@platforms//os:windows": [
            "/wd4005",  # Macro redefinition.
            "/wd4068",  # Unknown pragmas.
            "/wd4267",  # Conversion from size_t on 64-bits.
            "/utf-8",  # ICU source files are in UTF-8.
        ],
        "//conditions:default": [],
    }),
    include_prefix = "third_party/icu",
    local_defines = [
        "U_COMMON_IMPLEMENTATION",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":icui18n",
        ":icuuc",
    ],
    alwayslink = 1,
)
                                                                                                                                  node-23.7.0/deps/v8/bazel/BUILD.ittapi                                                              0000664 0000000 0000000 00000001016 14746647661 0017213 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        cc_library(
    name = "lib_ittapi",
    srcs = [
        "third_party/ittapi/include/ittnotify.h",
        "third_party/ittapi/include/jitprofiling.h",
        "third_party/ittapi/src/ittnotify/ittnotify_config.h",
        "third_party/ittapi/src/ittnotify/jitprofiling.c",
    ],
    hdrs = [
        "third_party/ittapi/include/ittnotify.h",
        "third_party/ittapi/src/ittnotify/ittnotify_types.h",
    ],
    copts = ["-Iexternal/intel_ittapi/third_party/ittapi/include"],
    visibility = ["//visibility:public"],
)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/bazel/OWNERS                                                                    0000664 0000000 0000000 00000000124 14746647661 0016077 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Google3 V8 owners
ahaas@chromium.org
cbruni@chromium.org
victorgomes@chromium.org
                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/bazel/config/                                                                   0000775 0000000 0000000 00000000000 14746647661 0016407 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/bazel/config/BUILD.bazel                                                        0000664 0000000 0000000 00000014505 14746647661 0020272 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2021 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

load("@bazel_skylib//lib:selects.bzl", "selects")
load(
    ":v8-target-cpu.bzl",
    "v8_configure_target_cpu",
    "v8_target_cpu",
)

package(
    default_visibility = [
        "//visibility:public",
    ],
)

config_setting(
    name = "is_fastbuild",
    values = {
        "compilation_mode": "fastbuild",
    },
)

config_setting(
    name = "is_opt",
    values = {
        "compilation_mode": "opt",
    },
)

config_setting(
    name = "is_debug",
    values = {
        "compilation_mode": "dbg",
    },
)

selects.config_setting_group(
    name = "is_opt_android",
    match_all = [
        ":is_opt",
        ":is_android",
    ],
)

config_setting(
    name = "platform_cpu_x64",
    constraint_values = ["@platforms//cpu:x86_64"],
)

config_setting(
    name = "platform_cpu_ia32",
    constraint_values = ["@platforms//cpu:x86_32"],
)

config_setting(
    name = "platform_cpu_arm64",
    constraint_values = ["@platforms//cpu:aarch64"],
)

config_setting(
    name = "platform_cpu_arm",
    constraint_values = ["@platforms//cpu:arm"],
)

config_setting(
    name = "platform_cpu_s390x",
    constraint_values = ["@platforms//cpu:s390x"],
)

config_setting(
    name = "platform_cpu_riscv64",
    constraint_values = ["@platforms//cpu:riscv64"],
)

config_setting(
    name = "platform_cpu_ppc64le",
    constraint_values = ["@platforms//cpu:ppc"],
)

v8_target_cpu(
    name = "v8_target_cpu",
    build_setting_default = "none",
)

config_setting(
    name = "v8_host_target_is_none",
    flag_values = {
        ":v8_target_cpu": "none",
    },
)

v8_configure_target_cpu(
    name = "x64",
    matching_configs = [":platform_cpu_x64"],
)

v8_configure_target_cpu(
    name = "ia32",
    matching_configs = [":platform_cpu_ia32"],
)

v8_configure_target_cpu(
    name = "arm64",
    matching_configs = [":platform_cpu_arm64"],
)

v8_configure_target_cpu(
    name = "arm",
    matching_configs = [":platform_cpu_arm"],
)

v8_configure_target_cpu(
    name = "s390x",
    matching_configs = [":platform_cpu_s390x"],
)

v8_configure_target_cpu(
    name = "riscv64",
    matching_configs = [":platform_cpu_riscv64"],
)

v8_configure_target_cpu(
    name = "ppc64le",
    matching_configs = [":platform_cpu_ppc64le"],
)

selects.config_setting_group(
    name = "v8_target_is_32_bits",
    match_any = [
        ":v8_target_ia32",
        ":v8_target_arm",
    ],
)

# Running arm64 simulator on x64 host.
selects.config_setting_group(
    name = "v8_arm64_simulator",
    match_all = [
        ":v8_target_arm64",
        ":is_x64",
    ],
)

config_setting(
    name = "is_linux",
    constraint_values = ["@platforms//os:linux"],
)

config_setting(
    name = "is_android",
    constraint_values = ["@platforms//os:android"],
)

config_setting(
    name = "is_macos",
    constraint_values = ["@platforms//os:macos"],
)

config_setting(
    name = "is_windows",
    constraint_values = ["@platforms//os:windows"],
)

selects.config_setting_group(
    name = "is_64bit",
    match_any = [
        ":v8_target_arm64",
        ":is_x64",
        ":is_arm64",
        ":is_s390x",
        ":is_riscv64",
        ":is_ppc64le",
    ],
)

selects.config_setting_group(
    name = "is_windows_64bit",
    match_all = [
        ":is_64bit",
        ":is_windows",
    ],
)

selects.config_setting_group(
    name = "is_posix",
    match_any = [
        ":is_linux",
        ":is_android",
        ":is_macos",
    ],
)

selects.config_setting_group(
    name = "is_not_android",
    match_any = [
        ":is_windows",
        ":is_linux",
        ":is_macos",
    ]
)

selects.config_setting_group(
    name = "is_posix_x64",
    match_all = [
        ":is_posix",
        ":is_x64",
    ],
)

selects.config_setting_group(
    name = "is_inline_asm_x64",
    match_all = [
        ":is_posix",
        ":is_x64",
    ],
)

selects.config_setting_group(
    name = "is_inline_asm_ia32",
    match_all = [
        ":is_posix",
        ":is_ia32",
    ],
)

selects.config_setting_group(
    name = "is_inline_asm_arm64",
    match_all = [
        ":is_posix",
        ":is_arm64",
    ],
)

selects.config_setting_group(
    name = "is_inline_asm_arm",
    match_all = [
        ":is_posix",
        ":is_arm",
    ],
)

selects.config_setting_group(
    name = "is_inline_asm_s390x",
    match_all = [
        ":is_posix",
        ":is_s390x",
    ],
)

selects.config_setting_group(
    name = "is_inline_asm_riscv64",
    match_all = [
        ":is_posix",
        ":is_riscv64",
    ],
)

selects.config_setting_group(
    name = "is_inline_asm_ppc64le",
    match_all = [
        ":is_posix",
        ":is_ppc64le",
    ],
)

selects.config_setting_group(
    name = "is_msvc_asm_x64",
    match_all = [
        ":is_windows",
        ":is_x64",
    ],
)

selects.config_setting_group(
    name = "is_msvc_asm_ia32",
    match_all = [
        ":is_windows",
        ":is_ia32",
    ],
)

selects.config_setting_group(
    name = "is_msvc_asm_arm64",
    match_all = [
        ":is_windows",
        ":is_arm64",
    ],
)

config_setting(
    name = "is_compiler_default",
    flag_values = {
        "@bazel_tools//tools/cpp:compiler": "compiler",
    },
)

selects.config_setting_group(
    name = "is_compiler_default_on_linux",
    match_all = [
        ":is_compiler_default",
        ":is_linux",
    ],
)

selects.config_setting_group(
    name = "is_compiler_default_on_macos",
    match_all = [
        ":is_compiler_default",
        ":is_macos",
    ],
)

config_setting(
    name = "is_compiler_clang",
    flag_values = {
        "@bazel_tools//tools/cpp:compiler": "clang",
    },
)

selects.config_setting_group(
    name = "is_clang",
    match_any = [
        ":is_compiler_default_on_macos",
        ":is_compiler_clang",
    ],
)

selects.config_setting_group(
    name = "is_clang_s390x",
    match_all = [
        ":is_clang",
        ":is_s390x",
    ],
)

config_setting(
    name = "is_compiler_gcc",
    flag_values = {
        "@bazel_tools//tools/cpp:compiler": "gcc",
    },
)

selects.config_setting_group(
    name = "is_gcc",
    match_any = [
        ":is_compiler_default_on_linux",
        ":is_compiler_gcc",
    ],
)

selects.config_setting_group(
    name = "is_gcc_fastbuild",
    match_all = [
        ":is_gcc",
        ":is_fastbuild",
    ],
)
                                                                                                                                                                                           node-23.7.0/deps/v8/bazel/config/v8-target-cpu.bzl                                                  0000664 0000000 0000000 00000003466 14746647661 0021537 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2021 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Build rules to choose the v8 target architecture."""

load("@bazel_skylib//lib:selects.bzl", "selects")

V8CpuTypeInfo = provider(
    doc = "A singleton provider that specifies the V8 target CPU type",
    fields = {
        "value": "The V8 Target CPU selected.",
    },
)

def _host_target_cpu_impl(ctx):
    allowed_values = ["arm", "arm64", "ia32", "ppc64le", "riscv64", "s390x", "x64", "none"]
    cpu_type = ctx.build_setting_value
    if cpu_type in allowed_values:
        return V8CpuTypeInfo(value = cpu_type)
    else:
        fail("Error setting " + str(ctx.label) + ": invalid v8 target cpu '" +
             cpu_type + "'. Allowed values are " + str(allowed_values))

v8_target_cpu = rule(
    implementation = _host_target_cpu_impl,
    build_setting = config.string(flag = True),
    doc = "CPU that V8 will generate code for.",
)

def v8_configure_target_cpu(name, matching_configs):
    selects.config_setting_group(
        name = "is_" + name,
        match_any = matching_configs,
    )

    # If v8_target_cpu flag is set to 'name'
    native.config_setting(
        name = "v8_host_target_is_" + name,
        flag_values = {
            ":v8_target_cpu": name,
        },
    )

    # Default target if no v8_host_target flag is set.
    selects.config_setting_group(
        name = "v8_target_is_" + name,
        match_all = [
            ":v8_host_target_is_none",
            ":is_" + name,
        ],
    )

    # Select either the default target or the flag.
    selects.config_setting_group(
        name = "v8_target_" + name,
        match_any = [
            ":v8_host_target_is_" + name,
            ":v8_target_is_" + name,
        ],
    )
                                                                                                                                                                                                          node-23.7.0/deps/v8/bazel/defs.bzl                                                                  0000664 0000000 0000000 00000047067 14746647661 0016612 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2021 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""
This module contains helper functions to compile V8.
"""

FlagInfo = provider("The value of an option.",
fields = ["value"])

def _options_impl(ctx):
    return FlagInfo(value = ctx.build_setting_value)

_create_option_flag = rule(
    implementation = _options_impl,
    build_setting = config.bool(flag = True),
)

_create_option_string = rule(
    implementation = _options_impl,
    build_setting = config.string(flag = True),
)

_create_option_int = rule(
    implementation = _options_impl,
    build_setting = config.int(flag = True),
)

def v8_flag(name, default = False):
    _create_option_flag(name = name, build_setting_default = default)
    native.config_setting(name = "is_" + name, flag_values = {name: "True"})
    native.config_setting(name = "is_not_" + name, flag_values = {name: "False"})

def v8_string(name, default = ""):
    _create_option_string(name = name, build_setting_default = default)

def v8_int(name, default = 0):
    _create_option_int(name = name, build_setting_default = default)

def _custom_config_impl(ctx):
    defs = []
    defs.append("V8_TYPED_ARRAY_MAX_SIZE_IN_HEAP=" +
                str(ctx.attr._v8_typed_array_max_size_in_heap[FlagInfo].value))
    context = cc_common.create_compilation_context(defines = depset(defs))
    return [CcInfo(compilation_context = context)]

v8_custom_config = rule(
    implementation = _custom_config_impl,
    attrs = {
        "_v8_typed_array_max_size_in_heap": attr.label(default = ":v8_typed_array_max_size_in_heap"),
    },
)

def _config_impl(ctx):
    hdrs = []

    # Add headers
    for h in ctx.attr.hdrs:
        hdrs += h[DefaultInfo].files.to_list()
    defs = []

    # Add conditional_defines
    for f, d in ctx.attr.conditional_defines.items():
        if f[FlagInfo].value:
            defs.append(d)

    # Add defines
    for d in ctx.attr.defines:
        defs.append(d)
    context = cc_common.create_compilation_context(
        defines = depset(
            defs,
            transitive = [dep[CcInfo].compilation_context.defines for dep in ctx.attr.deps],
        ),
        headers = depset(
            hdrs,
            transitive = [dep[CcInfo].compilation_context.headers for dep in ctx.attr.deps],
        ),
    )
    return [CcInfo(compilation_context = context)]

v8_config = rule(
    implementation = _config_impl,
    attrs = {
        "conditional_defines": attr.label_keyed_string_dict(),
        "defines": attr.string_list(),
        "deps": attr.label_list(),
        "hdrs": attr.label_list(allow_files = True),
    },
)

def _default_args():
    return struct(
        deps = [":define_flags"],
        defines = select({
            "@v8//bazel/config:is_windows": [
                "UNICODE",
                "_UNICODE",
                "_CRT_RAND_S",
                "_WIN32_WINNT=0x0602",  # Override bazel default to Windows 8
            ],
            "//conditions:default": [],
        }),
        copts = select({
            "@v8//bazel/config:is_posix": [
                "-fPIC",
                "-fno-strict-aliasing",
                "-Werror",
                "-Wextra",
                "-Wno-unneeded-internal-declaration",
                "-Wno-unknown-warning-option", # b/330781959
                "-Wno-cast-function-type-mismatch",  # b/330781959
                "-Wno-bitwise-instead-of-logical",
                "-Wno-builtin-assume-aligned-alignment",
                "-Wno-unused-parameter",
                "-Wno-implicit-int-float-conversion",
                "-Wno-deprecated-copy",
                "-Wno-non-virtual-dtor",
                "-isystem .",
            ],
            "//conditions:default": [],
        }) + select({
            "@v8//bazel/config:is_clang": [
                "-Wno-invalid-offsetof",
                "-Wno-deprecated-this-capture",
                "-std=c++20",
            ],
            "@v8//bazel/config:is_gcc": [
                "-Wno-extra",
                "-Wno-array-bounds",
                "-Wno-class-memaccess",
                "-Wno-comments",
                "-Wno-deprecated-declarations",
                "-Wno-implicit-fallthrough",
                "-Wno-int-in-bool-context",
                "-Wno-maybe-uninitialized",
                "-Wno-mismatched-new-delete",
                "-Wno-redundant-move",
                "-Wno-return-type",
                "-Wno-stringop-overflow",
                "-Wno-deprecated-this-capture",
                # Use GNU dialect, because GCC doesn't allow using
                # ##__VA_ARGS__ when in standards-conforming mode.
                "-std=gnu++2a",
            ],
            "@v8//bazel/config:is_windows": [
                "/std:c++20",
            ],
            "//conditions:default": [],
        }) + select({
            "@v8//bazel/config:is_gcc_fastbuild": [
                # Non-debug builds without optimizations fail because
                # of recursive inlining of "always_inline" functions.
                "-O1",
            ],
            "//conditions:default": [],
        }) + select({
            "@v8//bazel/config:is_clang_s390x": [
                "-fno-integrated-as",
            ],
            "//conditions:default": [],
        }) +  select({
            "@v8//bazel/config:is_opt_android": [
                "-fvisibility=hidden",
                "-fvisibility-inlines-hidden",
            ],
            "//conditions:default": [
            ],
        }),
        includes = ["include"],
        linkopts = select({
            "@v8//bazel/config:is_windows": [
                "Winmm.lib",
                "DbgHelp.lib",
                "Advapi32.lib",
            ],
            "@v8//bazel/config:is_macos": ["-pthread"],
            "//conditions:default": ["-Wl,--no-as-needed -ldl -pthread"],
        }) + select({
            ":should_add_rdynamic": ["-rdynamic"],
            "//conditions:default": [],
        }),
    )

ENABLE_I18N_SUPPORT_DEFINES = [
    "-DV8_INTL_SUPPORT",
    "-DICU_UTIL_DATA_IMPL=ICU_UTIL_DATA_STATIC",
    # src/regexp/regexp-compiler-tonode.cc uses an unsafe ICU method and
    # access a character implicitly.
    "-DUNISTR_FROM_CHAR_EXPLICIT=",
]

def _should_emit_noicu_and_icu(noicu_srcs, noicu_deps, noicu_defines, icu_srcs, icu_deps, icu_defines):
     return noicu_srcs != [] or noicu_deps != [] or noicu_defines != [] or icu_srcs != [] or icu_deps != [] or icu_defines != []

# buildifier: disable=function-docstring
def v8_binary(
        name,
        srcs,
        deps = [],
        defines = [],
        includes = [],
        copts = [],
        linkopts = [],
        noicu_srcs = [],
        noicu_deps = [],
        noicu_defines = [],
        icu_srcs = [],
        icu_deps = [],
        icu_defines = [],
        **kwargs):
    default = _default_args()
    if _should_emit_noicu_and_icu(noicu_srcs, noicu_deps, noicu_defines, icu_srcs, icu_deps, icu_defines):
        native.cc_binary(
            name = "noicu/" + name,
            srcs = srcs + noicu_srcs,
            deps = deps + noicu_deps + default.deps,
            defines = defines + noicu_defines + default.defines,
            includes = includes + ["noicu/"] + default.includes,
            copts = copts + default.copts,
            linkopts = linkopts + default.linkopts,
            **kwargs
        )
        native.cc_binary(
            name = "icu/" + name,
            srcs = srcs + icu_srcs,
            deps = deps + icu_deps + default.deps,
            includes = includes + ["icu/"] + default.includes,
            defines = defines + icu_defines + default.defines,
            copts = copts + default.copts + ENABLE_I18N_SUPPORT_DEFINES,
            linkopts = linkopts + default.linkopts,
            **kwargs
        )
    else:
        native.cc_binary(
            name = name,
            srcs = srcs,
            deps = deps + default.deps,
            defines = defines + default.defines,
            includes = includes + default.includes,
            copts = copts + default.copts,
            linkopts = linkopts + default.linkopts,
            **kwargs
        )

# buildifier: disable=function-docstring
def v8_library(
        name,
        srcs,
        deps = [],
        includes = [],
        copts = [],
        linkopts = [],
        noicu_srcs = [],
        noicu_deps = [],
        noicu_defines = [],
        icu_srcs = [],
        icu_deps = [],
        icu_defines = [],
        **kwargs):
    default = _default_args()
    if _should_emit_noicu_and_icu(noicu_srcs, noicu_deps, noicu_defines, icu_srcs, icu_deps, icu_defines):
        native.cc_library(
            name = name + "_noicu",
            srcs = srcs + noicu_srcs,
            deps = deps + noicu_deps + default.deps,
            includes = includes + ["noicu/"] + default.includes,
            copts = copts + default.copts,
            linkopts = linkopts + default.linkopts,
            alwayslink = 1,
            linkstatic = 1,
            **kwargs
        )

        # Alias target used because of cc_library bug in bazel on windows
        # https://github.com/bazelbuild/bazel/issues/14237
        # TODO(victorgomes): Remove alias once bug is fixed
        native.alias(
            name = "noicu/" + name,
            actual = name + "_noicu",
        )
        native.cc_library(
            name = name + "_icu",
            srcs = srcs + icu_srcs,
            deps = deps + icu_deps + default.deps,
            includes = includes + ["icu/"] + default.includes,
            copts = copts + default.copts + ENABLE_I18N_SUPPORT_DEFINES,
            linkopts = linkopts + default.linkopts,
            alwayslink = 1,
            linkstatic = 1,
            **kwargs
        )

        # Alias target used because of cc_library bug in bazel on windows
        # https://github.com/bazelbuild/bazel/issues/14237
        # TODO(victorgomes): Remove alias once bug is fixed
        native.alias(
            name = "icu/" + name,
            actual = name + "_icu",
        )
    else:
        native.cc_library(
            name = name,
            srcs = srcs,
            deps = deps + default.deps,
            includes = includes + default.includes,
            copts = copts + default.copts,
            linkopts = linkopts + default.linkopts,
            alwayslink = 1,
            linkstatic = 1,
            **kwargs
        )

# Use a single generator target for torque definitions and initializers. We can
# split the set of outputs by using OutputGroupInfo, that way we do not need to
# run the torque generator twice.
def _torque_files_impl(ctx):
    v8root = "."

    # Arguments
    args = []
    args += ctx.attr.args
    args.append("-o")
    args.append(ctx.bin_dir.path + "/" + v8root + "/" + ctx.attr.prefix + "/torque-generated")
    args.append("-strip-v8-root")
    args.append("-v8-root")
    args.append(v8root)

    # Sources
    args += [f.path for f in ctx.files.srcs]

    # Generate/declare output files
    defs = []
    inits = []
    for src in ctx.files.srcs:
        root, _period, _ext = src.path.rpartition(".")

        # Strip v8root
        if root[:len(v8root)] == v8root:
            root = root[len(v8root):]
        file = ctx.attr.prefix + "/torque-generated/" + root
        defs.append(ctx.actions.declare_file(file + "-tq-inl.inc"))
        defs.append(ctx.actions.declare_file(file + "-tq.inc"))
        defs.append(ctx.actions.declare_file(file + "-tq.cc"))
        inits.append(ctx.actions.declare_file(file + "-tq-csa.cc"))
        inits.append(ctx.actions.declare_file(file + "-tq-csa.h"))

    defs += [ctx.actions.declare_file(ctx.attr.prefix + "/torque-generated/" + f) for f in ctx.attr.definition_extras]
    inits += [ctx.actions.declare_file(ctx.attr.prefix + "/torque-generated/" + f) for f in ctx.attr.initializer_extras]
    outs = defs + inits
    ctx.actions.run(
        outputs = outs,
        inputs = ctx.files.srcs,
        arguments = args,
        executable = ctx.executable.tool,
        mnemonic = "GenTorqueFiles",
        progress_message = "Generating Torque files",
    )
    return [
        DefaultInfo(files = depset(outs)),
        OutputGroupInfo(
            initializers = depset(inits),
            definitions = depset(defs),
        ),
    ]

_v8_torque_files = rule(
    implementation = _torque_files_impl,
    # cfg = v8_target_cpu_transition,
    attrs = {
        "prefix": attr.string(mandatory = True),
        "srcs": attr.label_list(allow_files = True, mandatory = True),
        "definition_extras": attr.string_list(),
        "initializer_extras": attr.string_list(),
        "tool": attr.label(
            allow_files = True,
            executable = True,
            cfg = "exec",
        ),
        "args": attr.string_list(),
    },
)

def v8_torque_files(name, noicu_srcs, icu_srcs, args, definition_extras, initializer_extras):
    _v8_torque_files(
        name = "noicu/" + name,
        prefix = "noicu",
        srcs = noicu_srcs,
        args = args,
        definition_extras = definition_extras,
        initializer_extras = initializer_extras,
        tool = select({
            "@v8//bazel/config:v8_target_is_32_bits": ":noicu/torque_non_pointer_compression",
            "//conditions:default": ":noicu/torque",
        }),
    )
    _v8_torque_files(
        name = "icu/" + name,
        prefix = "icu",
        srcs = icu_srcs,
        args = args,
        definition_extras = definition_extras,
        initializer_extras = initializer_extras,
        tool = select({
            "@v8//bazel/config:v8_target_is_32_bits": ":icu/torque_non_pointer_compression",
            "//conditions:default": ":icu/torque",
        }),
    )

def _v8_target_cpu_transition_impl(settings,
                                   attr, # @unused
                                  ):
    # Check for an existing v8_target_cpu flag.
    if "@v8//bazel/config:v8_target_cpu" in settings:
        if settings["@v8//bazel/config:v8_target_cpu"] != "none":
            return {}

    # Auto-detect target architecture based on the --cpu flag.
    mapping = {
        "haswell": "x64",
        "k8": "x64",
        "x86_64": "x64",
        "darwin": "x64",
        "darwin_x86_64": "x64",
        "x64_windows": "x64",
        "x86": "ia32",
        "aarch64": "arm64",
        "arm64-v8a": "arm64",
        "arm": "arm64",
        "darwin_arm64": "arm64",
        "armeabi-v7a": "arm32",
        "s390x": "s390x",
        "riscv64": "riscv64",
        "ppc": "ppc64le",
    }
    v8_target_cpu = mapping[settings["//command_line_option:cpu"]]
    return {"@v8//bazel/config:v8_target_cpu": v8_target_cpu}

# Set the v8_target_cpu to be the correct architecture given the cpu specified
# on the command line.
v8_target_cpu_transition = transition(
    implementation = _v8_target_cpu_transition_impl,
    inputs = ["@v8//bazel/config:v8_target_cpu", "//command_line_option:cpu"],
    outputs = ["@v8//bazel/config:v8_target_cpu"],
)

def _mksnapshot(ctx):
    prefix = ctx.attr.prefix
    suffix = ctx.attr.suffix
    outs = [
        ctx.actions.declare_file(prefix + "/snapshot" + suffix + ".cc"),
        ctx.actions.declare_file(prefix + "/embedded" + suffix + ".S"),
    ]
    ctx.actions.run(
        outputs = outs,
        inputs = [],
        arguments = [
            "--embedded_variant=Default",
            "--target_os",
            ctx.attr.target_os,
            "--startup_src",
            outs[0].path,
            "--embedded_src",
            outs[1].path,
        ] + ctx.attr.args,
        executable = ctx.executable.tool,
        progress_message = "Running mksnapshot",
    )
    return [DefaultInfo(files = depset(outs))]

_v8_mksnapshot = rule(
    implementation = _mksnapshot,
    attrs = {
        "args": attr.string_list(),
        "tool": attr.label(
            mandatory = True,
            allow_files = True,
            executable = True,
            cfg = "exec",
        ),
        "target_os": attr.string(mandatory = True),
        "prefix": attr.string(mandatory = True),
        "suffix": attr.string(mandatory = True),
    },
    cfg = v8_target_cpu_transition,
)

def v8_mksnapshot(name, args, suffix = ""):
    _v8_mksnapshot(
        name = "noicu/" + name,
        args = args,
        prefix = "noicu",
        tool = ":noicu/mksnapshot" + suffix,
        suffix = suffix,
        target_os = select({
            "@v8//bazel/config:is_macos": "mac",
            "//conditions:default": "",
        }),
    )
    _v8_mksnapshot(
        name = "icu/" + name,
        args = args,
        prefix = "icu",
        tool = ":icu/mksnapshot" + suffix,
        suffix = suffix,
        target_os = select({
            "@v8//bazel/config:is_macos": "mac",
            "//conditions:default": "",
        }),
    )

def _quote(val):
    if val[0] == '"' and val[-1] == '"':
        fail("String", val, "already quoted")
    return '"' + val + '"'

def _kv_bool_pair(k, v):
    return _quote(k) + ": " + v

def _json(kv_pairs):
    content = "{"
    for (k, v) in kv_pairs[:-1]:
        content += _kv_bool_pair(k, v) + ", "
    (k, v) = kv_pairs[-1]
    content += _kv_bool_pair(k, v)
    content += "}\n"
    return content

def build_config_content(cpu, icu):
    arch = cpu
    if cpu == 'x86':
        arch = 'ia32'
    return _json([
        ("arch", arch),
        ("asan", "false"),
        ("atomic_object_field_writes", "false"),
        ("cfi", "false"),
        ("clang_coverage", "false"),
        ("clang", "true"),
        ("code_comments", "false"),
        ("component_build", "false"),
        ("concurrent_marking", "false"),
        ("conservative_stack_scanning", "false"),
        ("current_cpu", cpu),
        ("dcheck_always_on", "false"),
        ("debug_code", "false"),
        ("DEBUG_defined", "false"),
        ("debugging_features", "false"),
        ("dict_property_const_tracking", "false"),
        ("direct_handle", "false"),
        ("disassembler", "false"),
        ("full_debug", "false"),
        ("gdbjit", "false"),
        ("has_jitless", "false"),
        ("has_maglev", "true"),
        ("has_turbofan", "true"),
        ("has_webassembly", "false"),
        ("has_wasm_interpreter", "false"),
        ("i18n", icu),
        ("is_android", "false"),
        ("is_ios", "false"),
        ("js_shared_memory", "false"),
        ("lite_mode", "false"),
        ("local_off_stack_check", "false"),
        ("memory_corruption_api", "false"),
        ("mips_arch_variant", '""'),
        ("mips_use_msa", "false"),
        ("msan", "false"),
        ("official_build", "false"),
        ("pointer_compression_shared_cage", "false"),
        ("pointer_compression", "true"),
        ("runtime_call_stats", "false"),
        ("sandbox", "false"),
        ("shared_ro_heap", "false"),
        ("simd_mips", "false"),
        ("simulator_run", "false"),
        ("single_generation", "false"),
        ("slow_dchecks", "false"),
        ("target_cpu", cpu),
        ("third_party_heap", "false"),
        ("tsan", "false"),
        ("ubsan", "false"),
        ("use_sanitizer", "false"),
        ("v8_cfi", "false"),
        ("v8_current_cpu", cpu),
        ("v8_target_cpu", cpu),
        ("verify_csa", "false"),
        ("verify_heap", "false"),
        ("verify_predictable", "false"),
        ("write_barriers", "false"),
    ])

# TODO(victorgomes): Create a rule (instead of a macro), that can
# dynamically populate the build config.
def v8_build_config(name, arch):
    cpu = '"' + arch + '"'
    native.genrule(
        name = "noicu/" + name,
        outs = ["noicu/" + name + ".json"],
        cmd = "echo '" + build_config_content(cpu, "false") + "' > \"$@\"",
    )
    native.genrule(
        name = "icu/" + name,
        outs = ["icu/" + name + ".json"],
        cmd = "echo '" + build_config_content(cpu, "true") + "' > \"$@\"",
    )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/bazel/requirements.in                                                           0000664 0000000 0000000 00000000007 14746647661 0020212 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        jinja2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/bazel/requirements.txt                                                          0000664 0000000 0000000 00000014150 14746647661 0020427 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #
# This file is autogenerated by pip-compile with python 3.9
# To update, run:
#
#    pip-compile --generate-hashes requirements.in
#
jinja2==3.0.3 \
    --hash=sha256:077ce6014f7b40d03b47d1f1ca4b0fc8328a692bd284016f806ed0eaca390ad8 \
    --hash=sha256:611bb273cd68f3b993fabdc4064fc858c5b47a973cb5aa7999ec1ba405c87cd7
    # via -r requirements.in
markupsafe==2.0.1 \
    --hash=sha256:01a9b8ea66f1658938f65b93a85ebe8bc016e6769611be228d797c9d998dd298 \
    --hash=sha256:023cb26ec21ece8dc3907c0e8320058b2e0cb3c55cf9564da612bc325bed5e64 \
    --hash=sha256:0446679737af14f45767963a1a9ef7620189912317d095f2d9ffa183a4d25d2b \
    --hash=sha256:04635854b943835a6ea959e948d19dcd311762c5c0c6e1f0e16ee57022669194 \
    --hash=sha256:0717a7390a68be14b8c793ba258e075c6f4ca819f15edfc2a3a027c823718567 \
    --hash=sha256:0955295dd5eec6cb6cc2fe1698f4c6d84af2e92de33fbcac4111913cd100a6ff \
    --hash=sha256:0d4b31cc67ab36e3392bbf3862cfbadac3db12bdd8b02a2731f509ed5b829724 \
    --hash=sha256:10f82115e21dc0dfec9ab5c0223652f7197feb168c940f3ef61563fc2d6beb74 \
    --hash=sha256:168cd0a3642de83558a5153c8bd34f175a9a6e7f6dc6384b9655d2697312a646 \
    --hash=sha256:1d609f577dc6e1aa17d746f8bd3c31aa4d258f4070d61b2aa5c4166c1539de35 \
    --hash=sha256:1f2ade76b9903f39aa442b4aadd2177decb66525062db244b35d71d0ee8599b6 \
    --hash=sha256:20dca64a3ef2d6e4d5d615a3fd418ad3bde77a47ec8a23d984a12b5b4c74491a \
    --hash=sha256:2a7d351cbd8cfeb19ca00de495e224dea7e7d919659c2841bbb7f420ad03e2d6 \
    --hash=sha256:2d7d807855b419fc2ed3e631034685db6079889a1f01d5d9dac950f764da3dad \
    --hash=sha256:2ef54abee730b502252bcdf31b10dacb0a416229b72c18b19e24a4509f273d26 \
    --hash=sha256:36bc903cbb393720fad60fc28c10de6acf10dc6cc883f3e24ee4012371399a38 \
    --hash=sha256:37205cac2a79194e3750b0af2a5720d95f786a55ce7df90c3af697bfa100eaac \
    --hash=sha256:3c112550557578c26af18a1ccc9e090bfe03832ae994343cfdacd287db6a6ae7 \
    --hash=sha256:3dd007d54ee88b46be476e293f48c85048603f5f516008bee124ddd891398ed6 \
    --hash=sha256:4296f2b1ce8c86a6aea78613c34bb1a672ea0e3de9c6ba08a960efe0b0a09047 \
    --hash=sha256:47ab1e7b91c098ab893b828deafa1203de86d0bc6ab587b160f78fe6c4011f75 \
    --hash=sha256:49e3ceeabbfb9d66c3aef5af3a60cc43b85c33df25ce03d0031a608b0a8b2e3f \
    --hash=sha256:4dc8f9fb58f7364b63fd9f85013b780ef83c11857ae79f2feda41e270468dd9b \
    --hash=sha256:4efca8f86c54b22348a5467704e3fec767b2db12fc39c6d963168ab1d3fc9135 \
    --hash=sha256:53edb4da6925ad13c07b6d26c2a852bd81e364f95301c66e930ab2aef5b5ddd8 \
    --hash=sha256:5855f8438a7d1d458206a2466bf82b0f104a3724bf96a1c781ab731e4201731a \
    --hash=sha256:594c67807fb16238b30c44bdf74f36c02cdf22d1c8cda91ef8a0ed8dabf5620a \
    --hash=sha256:5b6d930f030f8ed98e3e6c98ffa0652bdb82601e7a016ec2ab5d7ff23baa78d1 \
    --hash=sha256:5bb28c636d87e840583ee3adeb78172efc47c8b26127267f54a9c0ec251d41a9 \
    --hash=sha256:60bf42e36abfaf9aff1f50f52644b336d4f0a3fd6d8a60ca0d054ac9f713a864 \
    --hash=sha256:611d1ad9a4288cf3e3c16014564df047fe08410e628f89805e475368bd304914 \
    --hash=sha256:6300b8454aa6930a24b9618fbb54b5a68135092bc666f7b06901f897fa5c2fee \
    --hash=sha256:63f3268ba69ace99cab4e3e3b5840b03340efed0948ab8f78d2fd87ee5442a4f \
    --hash=sha256:6557b31b5e2c9ddf0de32a691f2312a32f77cd7681d8af66c2692efdbef84c18 \
    --hash=sha256:693ce3f9e70a6cf7d2fb9e6c9d8b204b6b39897a2c4a1aa65728d5ac97dcc1d8 \
    --hash=sha256:6a7fae0dd14cf60ad5ff42baa2e95727c3d81ded453457771d02b7d2b3f9c0c2 \
    --hash=sha256:6c4ca60fa24e85fe25b912b01e62cb969d69a23a5d5867682dd3e80b5b02581d \
    --hash=sha256:6fcf051089389abe060c9cd7caa212c707e58153afa2c649f00346ce6d260f1b \
    --hash=sha256:7d91275b0245b1da4d4cfa07e0faedd5b0812efc15b702576d103293e252af1b \
    --hash=sha256:89c687013cb1cd489a0f0ac24febe8c7a666e6e221b783e53ac50ebf68e45d86 \
    --hash=sha256:8d206346619592c6200148b01a2142798c989edcb9c896f9ac9722a99d4e77e6 \
    --hash=sha256:905fec760bd2fa1388bb5b489ee8ee5f7291d692638ea5f67982d968366bef9f \
    --hash=sha256:97383d78eb34da7e1fa37dd273c20ad4320929af65d156e35a5e2d89566d9dfb \
    --hash=sha256:984d76483eb32f1bcb536dc27e4ad56bba4baa70be32fa87152832cdd9db0833 \
    --hash=sha256:99df47edb6bda1249d3e80fdabb1dab8c08ef3975f69aed437cb69d0a5de1e28 \
    --hash=sha256:9f02365d4e99430a12647f09b6cc8bab61a6564363f313126f775eb4f6ef798e \
    --hash=sha256:a30e67a65b53ea0a5e62fe23682cfe22712e01f453b95233b25502f7c61cb415 \
    --hash=sha256:ab3ef638ace319fa26553db0624c4699e31a28bb2a835c5faca8f8acf6a5a902 \
    --hash=sha256:aca6377c0cb8a8253e493c6b451565ac77e98c2951c45f913e0b52facdcff83f \
    --hash=sha256:add36cb2dbb8b736611303cd3bfcee00afd96471b09cda130da3581cbdc56a6d \
    --hash=sha256:b2f4bf27480f5e5e8ce285a8c8fd176c0b03e93dcc6646477d4630e83440c6a9 \
    --hash=sha256:b7f2d075102dc8c794cbde1947378051c4e5180d52d276987b8d28a3bd58c17d \
    --hash=sha256:baa1a4e8f868845af802979fcdbf0bb11f94f1cb7ced4c4b8a351bb60d108145 \
    --hash=sha256:be98f628055368795d818ebf93da628541e10b75b41c559fdf36d104c5787066 \
    --hash=sha256:bf5d821ffabf0ef3533c39c518f3357b171a1651c1ff6827325e4489b0e46c3c \
    --hash=sha256:c47adbc92fc1bb2b3274c4b3a43ae0e4573d9fbff4f54cd484555edbf030baf1 \
    --hash=sha256:cdfba22ea2f0029c9261a4bd07e830a8da012291fbe44dc794e488b6c9bb353a \
    --hash=sha256:d6c7ebd4e944c85e2c3421e612a7057a2f48d478d79e61800d81468a8d842207 \
    --hash=sha256:d7f9850398e85aba693bb640262d3611788b1f29a79f0c93c565694658f4071f \
    --hash=sha256:d8446c54dc28c01e5a2dbac5a25f071f6653e6e40f3a8818e8b45d790fe6ef53 \
    --hash=sha256:deb993cacb280823246a026e3b2d81c493c53de6acfd5e6bfe31ab3402bb37dd \
    --hash=sha256:e0f138900af21926a02425cf736db95be9f4af72ba1bb21453432a07f6082134 \
    --hash=sha256:e9936f0b261d4df76ad22f8fee3ae83b60d7c3e871292cd42f40b81b70afae85 \
    --hash=sha256:f0567c4dc99f264f49fe27da5f735f414c4e7e7dd850cfd8e69f0862d7c74ea9 \
    --hash=sha256:f5653a225f31e113b152e56f154ccbe59eeb1c7487b39b9d9f9cdb58e6c79dc5 \
    --hash=sha256:f826e31d18b516f653fe296d967d700fddad5901ae07c622bb3705955e1faa94 \
    --hash=sha256:f8ba0e8349a38d3001fae7eadded3f6606f0da5d748ee53cc1dab1d6527b9509 \
    --hash=sha256:f9081981fe268bd86831e5c75f7de206ef275defcb82bc70740ae6dc507aee51 \
    --hash=sha256:fa130dd50c57d53368c9d59395cb5526eda596d3ffe36666cd81a44d56e48872
    # via jinja2
                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/bazel/v8-non-pointer-compression.bzl                                            0000664 0000000 0000000 00000003606 14746647661 0023022 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        """
Exposes the rule v8_binary_non_pointer_compression, which forces a label
to be compiled without pointer compression.
"""

def _v8_disable_pointer_compression(settings, attr):
    return {
        "//:v8_enable_pointer_compression": "False",
    }

v8_disable_pointer_compression = transition(
    implementation = _v8_disable_pointer_compression,
    inputs = [],
    outputs = ["//:v8_enable_pointer_compression"],
)

# The implementation of transition_rule: all this does is copy the
# cc_binary's output to its own output and propagate its runfiles
# and executable to use for "$ bazel run".
#
# This makes transition_rule as close to a pure wrapper of cc_binary
# as possible.
def _v8_binary_non_pointer_compression(ctx):
    binary = ctx.attr.binary[0]
    outfile = ctx.actions.declare_file(ctx.label.name)
    cc_binary_outfile = binary[DefaultInfo].files.to_list()[0]

    ctx.actions.run_shell(
        inputs = [cc_binary_outfile],
        outputs = [outfile],
        command = "cp %s %s" % (cc_binary_outfile.path, outfile.path),
    )
    return [
        DefaultInfo(
            executable = outfile,
            data_runfiles = binary[DefaultInfo].data_runfiles,
        ),
    ]

# The purpose of this rule is to transition to a config where v8_target_cpu is
# set to the appropriate architecture, which will remain in place through exec
# transitions, so mksnapshot can for instance build on x64 but for arm64.
v8_binary_non_pointer_compression = rule(
    implementation = _v8_binary_non_pointer_compression,
    attrs = {
        # This is the cc_binary whose deps will select() on that feature.
        # Note specificaly how it's configured with v8_target_cpu_transition, which
        # ensures that setting propagates down the graph.
        "binary": attr.label(cfg = v8_disable_pointer_compression),
    },
    # Making this executable means it works with "$ bazel run".
    executable = True,
)
                                                                                                                          node-23.7.0/deps/v8/build_overrides/                                                                0000775 0000000 0000000 00000000000 14746647661 0017226 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/build_overrides/OWNERS                                                          0000664 0000000 0000000 00000000025 14746647661 0020163 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        file:../INFRA_OWNERS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/build_overrides/build.gni                                                       0000664 0000000 0000000 00000004521 14746647661 0021026 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2016 The V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Variable that can be used to support multiple build scenarios, like having
# Chromium specific targets in a client project's GN file etc.
build_with_chromium = false

# Variable that can be used to support multiple build scenarios, like when
# V8 is embedded within a target.
build_with_v8_embedder = false

# Not all of V8's dependencies are available in V8's Node.js build.
build_with_node = false

# Used by perfetto to distinguish from its own standalone build and the
# chromium build.
perfetto_build_with_embedder = true

# We use Perfetto's Trace Processor to convert traces to the legacy JSON
# format.
enable_perfetto_trace_processor = true

# When building with chromium, determines whether we want to also use the
# perfetto library from chromium instead declaring our own.
use_perfetto_client_library = false

# Uncomment these to specify a different NDK location and version in
# non-Chromium builds.
# default_android_ndk_root = "//third_party/android_ndk"
# default_android_ndk_version = "r10e"

# Some non-Chromium builds don't support building java targets.
enable_java_templates = false

# Enables assertions on safety checks in libc++.
enable_safe_libcxx = true

# Enable assertions on safety checks, also in libstdc++
#
# In case the C++ standard library implementation used is libstdc++, then
# enable its own hardening checks.
enable_safe_libstdcxx = true

# Allows different projects to specify their own suppressions files.
asan_suppressions_file = "//build/sanitizers/asan_suppressions.cc"
lsan_suppressions_file = "//build/sanitizers/lsan_suppressions.cc"
tsan_suppressions_file = "//build/sanitizers/tsan_suppressions.cc"

# Skip assertions about 4GiB file size limit.
ignore_elf32_limitations = true

if (host_os == "mac") {
  _result = exec_script("//build/mac/should_use_hermetic_xcode.py",
                        [ target_os ],
                        "value")
  assert(_result != 2,
         "Do not allow building targets with the default" +
             "hermetic toolchain if the minimum OS version is not met.")
  assert(_result != 3,
         "iOS does not support building with a hermetic toolchain. " +
             "Please install Xcode.")

  use_system_xcode = _result == 0
}
                                                                                                                                                                               node-23.7.0/deps/v8/build_overrides/gtest.gni                                                       0000664 0000000 0000000 00000001071 14746647661 0021052 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2016 The V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Exclude support for registering main function in multi-process tests.
gtest_include_multiprocess = false

# Exclude support for platform-specific operations across unit tests.
gtest_include_platform_test = false

# Exclude support for testing Objective C code on OS X and iOS.
gtest_include_objc_support = false

# Exclude support for flushing coverage files on iOS.
gtest_include_ios_coverage = false
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/codereview.settings                                                             0000664 0000000 0000000 00000000362 14746647661 0017764 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        PROJECT: v8
GERRIT_HOST: True
CODE_REVIEW_SERVER: https://codereview.chromium.org
CC_LIST: v8-reviews@googlegroups.com
VIEW_VC: https://chromium.googlesource.com/v8/v8/+/
STATUS: http://v8-status.appspot.com/status
RUN_POST_UPLOAD_HOOK: True
                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/custom_deps/                                                                    0000775 0000000 0000000 00000000000 14746647661 0016372 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/custom_deps/.gitignore                                                          0000664 0000000 0000000 00000000040 14746647661 0020354 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        *
!.gitignore
!OWNERS
!README.md                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/custom_deps/OWNERS                                                              0000664 0000000 0000000 00000000025 14746647661 0017327 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        file:../INFRA_OWNERS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/custom_deps/README.md                                                           0000664 0000000 0000000 00000000176 14746647661 0017655 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        Common directory for custom dependencies pulled in via .gclient custom_deps.
All subdirectories are ignored by git by default.                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/docs/                                                                           0000775 0000000 0000000 00000000000 14746647661 0014775 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/docs/OWNERS                                                                     0000664 0000000 0000000 00000000052 14746647661 0015732 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        hablich@chromium.org
mathias@chromium.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/docs/README.md                                                                  0000664 0000000 0000000 00000000115 14746647661 0016251 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        The documentation for V8 can be found at [v8.dev/docs](https://v8.dev/docs).
                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/gni/                                                                            0000775 0000000 0000000 00000000000 14746647661 0014622 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/gni/Info.plist                                                                  0000664 0000000 0000000 00000002041 14746647661 0016567 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        <?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleDisplayName</key>
	<string>${PRODUCT_NAME}</string>
	<key>CFBundleExecutable</key>
	<string>${EXECUTABLE_NAME}</string>
	<key>CFBundleIdentifier</key>
	<string>${BUNDLE_IDENTIFIER}</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>${PRODUCT_NAME}</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>1.0</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UISupportedInterfaceOrientation</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
</dict>
</plist>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/gni/OWNERS                                                                      0000664 0000000 0000000 00000000335 14746647661 0015563 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        file:../INFRA_OWNERS

per-file v8.cml=victorgomes@chromium.org
per-file release_branch_toggle.gni=v8-ci-autoroll-builder@chops-service-accounts.iam.gserviceaccount.com
per-file release_branch_toggle.gni=vahl@chromium.org
                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/gni/release_branch_toggle.gni                                                   0000664 0000000 0000000 00000000527 14746647661 0021623 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2022 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

declare_args() {
  # TODO(liviurau): Remove old name after Chromium config update
  # https://crbug.com/1476977.
  is_on_release_branch = false
  v8_is_on_release_branch = true
}                                                                                                                                                                         node-23.7.0/deps/v8/gni/snapshot_toolchain.gni                                                      0000664 0000000 0000000 00000013124 14746647661 0021221 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2015 the V8 project authors. All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#     * Neither the name of Google Inc. nor the names of its
#       contributors may be used to endorse or promote products derived
#       from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import("//build/config/v8_target_cpu.gni")

declare_args() {
  # The v8 snapshot needs to be built by code that is compiled with a
  # toolchain that matches the bit-width of the target CPU, but runs on
  # the host.
  v8_snapshot_toolchain = ""
}

# Try to infer the appropriate snapshot toolchain for the v8_current_cpu
# where possible.
#
# Assume that v8_target_cpu (and hence v8_current_cpu) has been validated
# as supported on the current host CPU and OS in v8_target_cpu.gni. The
# logic below is complicated enough without also needing to do input
# validation.
#
# There are test cases for this code posted as an attachment to
# https://crbug.com/625353.

if (v8_snapshot_toolchain == "") {
  if (current_os == host_os && current_cpu == host_cpu) {
    # This is not a cross-compile, so build the snapshot with the current
    # toolchain.
    v8_snapshot_toolchain = current_toolchain
  } else if (current_os == host_os && current_cpu == "x86" &&
             host_cpu == "x64") {
    # This is an x64 -> x86 cross-compile, but x64 hosts can usually run x86
    # binaries built for the same OS, so build the snapshot with the current
    # toolchain here, too.
    v8_snapshot_toolchain = current_toolchain
  } else if (current_os == host_os && host_cpu == "arm64" &&
             current_cpu == "arm") {
    # Trying to compile 32-bit arm on arm64. Good luck!
    v8_snapshot_toolchain = current_toolchain
  } else if (host_cpu == "x64" && v8_current_cpu == "mips64") {
    # We don't support snapshot generation for big-endian targets,
    # therefore snapshots will need to be built using native mksnapshot
    # in combination with qemu
    v8_snapshot_toolchain = current_toolchain
  } else if (host_cpu == current_cpu) {
    # Cross-build from same ISA on one OS to another. For example:
    # * targeting win/x64 on a linux/x64 host
    # * targeting win/arm64 on a mac/arm64 host
    v8_snapshot_toolchain = host_toolchain
  } else if (host_cpu == "arm64" && current_cpu == "x64") {
    # Cross-build from arm64 to intel (likely on an Apple Silicon mac).
    v8_snapshot_toolchain =
        "//build/toolchain/${host_os}:clang_arm64_v8_$v8_current_cpu"
  } else if (host_cpu == "x64") {
    # This is a cross-compile from an x64 host to either a non-Intel target
    # cpu or to 32-bit x86 on a different target OS.

    assert(v8_current_cpu != "x64", "handled by host_cpu == current_cpu branch")
    if (v8_current_cpu == "x86") {
      _cpus = v8_current_cpu
    } else if (v8_current_cpu == "arm64" || v8_current_cpu == "mips64el" ||
               v8_current_cpu == "riscv64" || v8_current_cpu == "loong64") {
      if (is_win && v8_current_cpu == "arm64") {
        # set _cpus to blank for Windows ARM64 so host_toolchain could be
        # selected as snapshot toolchain later.
        _cpus = ""
      } else {
        _cpus = "x64_v8_${v8_current_cpu}"
      }
    } else if (v8_current_cpu == "arm" || v8_current_cpu == "riscv32") {
      _cpus = "x86_v8_${v8_current_cpu}"
    } else {
      # This branch should not be reached; leave _cpus blank so the assert
      # below will fail.
      _cpus = ""
    }

    if (_cpus != "") {
      v8_snapshot_toolchain = "//build/toolchain/${host_os}:clang_${_cpus}"
    } else if (is_win && v8_current_cpu == "arm64") {
      # cross compile Windows arm64 with host toolchain.
      v8_snapshot_toolchain = host_toolchain
    }
  } else if (host_cpu == "arm64" && current_cpu == "arm64" &&
             host_os == "mac") {
    # cross compile iOS arm64 with host_toolchain
    v8_snapshot_toolchain = host_toolchain
  }
}

assert(v8_snapshot_toolchain != "",
       "Do not know how to build a snapshot for $current_toolchain " +
           "on $host_os $host_cpu")

# We reuse the snapshot toolchain for building torque and other generators to
# avoid building v8_libbase on the host more than once. On mips with big endian,
# the snapshot toolchain is the target toolchain and, hence, can't be used.
v8_generator_toolchain = v8_snapshot_toolchain
if (host_cpu == "x64" && v8_current_cpu == "mips64") {
  v8_generator_toolchain = "//build/toolchain/linux:clang_x64"
}
                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/gni/split_static_library.gni                                                    0000664 0000000 0000000 00000005733 14746647661 0021557 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2019 the V8 project authors. All rights reserved.
# Copyright 2016 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/compiler/compiler.gni")

template("split_static_library") {
  assert(defined(invoker.split_count),
         "Must define split_count for split_static_library")

  # In many conditions the number of inputs will be 1 (because the
  # count will be conditional on platform or configuration) and for
  # some build configurations it's unnecessary to split libraries
  # since the tooling will never create files of a problematic size.
  if (invoker.split_count == 1 || use_lld) {
    static_library(target_name) {
      forward_variables_from(invoker, "*")
    }
  } else {
    group_name = target_name

    generated_static_libraries = []
    current_library_index = 0
    foreach(current_sources, split_list(invoker.sources, invoker.split_count)) {
      current_name = "${target_name}_$current_library_index"
      assert(
          current_sources != [],
          "Your values for splitting a static library generate one that has no sources.")
      generated_static_libraries += [ ":$current_name" ]

      static_library(current_name) {
        # Generated static library shard gets everything but sources (which
        # we're redefining) and visibility (which is set to be the group
        # below).
        forward_variables_from(invoker,
                               "*",
                               [
                                 "check_includes",
                                 "sources",
                                 "visibility",
                               ])
        sources = current_sources
        visibility = [ ":$group_name" ]

        # When splitting a target's sources up into a series of static
        # libraries, those targets will naturally include headers from each
        # other arbitrarily. We could theoretically generate a web of
        # dependencies and allow_circular_includes_from between all pairs of
        # targets, but that's very cumbersome. Typical usage in Chrome is that
        # only official Windows builds use split static libraries due to the
        # Visual Studio size limits, and this means we'll still get header
        # checking coverage for the other configurations.
        check_includes = false

        # Uniquify the output name if one is specified.
        if (defined(invoker.output_name)) {
          output_name = "${invoker.output_name}_$current_library_index"
        }
      }

      current_library_index = current_library_index + 1
    }

    group(group_name) {
      public_deps = generated_static_libraries
      forward_variables_from(invoker,
                             [
                               "testonly",
                               "visibility",
                             ])
    }
  }
}

set_defaults("split_static_library") {
  configs = default_compiler_configs
}
                                     node-23.7.0/deps/v8/gni/v8.cml                                                                      0000664 0000000 0000000 00000000612 14746647661 0015653 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 The V8 project authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
{
  include: [ "syslog/client.shard.cml" ],
  program: {
    runner: "elf",
    binary: "d8",
  },
  use: [
    {
      protocol: [
        "fuchsia.kernel.VmexResource",
      ],
    },
    {
      storage: "tmp",
      path: "/tmp",
    },
  ],
}
                                                                                                                      node-23.7.0/deps/v8/gni/v8.gni                                                                      0000664 0000000 0000000 00000034132 14746647661 0015661 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2016 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/chrome_build.gni")
import("//build/config/compiler/pgo/pgo.gni")
import("//build/config/gclient_args.gni")
import("//build/config/ios/config.gni")
import("//build/config/ios/ios_sdk_overrides.gni")
import("//build/config/sanitizers/sanitizers.gni")
import("//build/config/v8_target_cpu.gni")
import("//build_overrides/build.gni")
import("release_branch_toggle.gni")
import("split_static_library.gni")

declare_args() {
  # Includes files needed for correctness fuzzing.
  v8_correctness_fuzzer = false

  # Adds additional compile target for building multiple architectures at once.
  v8_multi_arch_build = false

  # Indicate if valgrind was fetched as a custom deps to make it available on
  # swarming.
  v8_has_valgrind = false

  # Indicate if gcmole was fetched as a hook to make it available on swarming.
  v8_gcmole = false

  # Turns on compiler optimizations in V8 in Debug build.
  v8_optimized_debug = true

  # Support for backtrace_symbols on linux.
  v8_enable_backtrace = ""

  # Use external files for startup data blobs:
  # the JS builtins sources and the start snapshot.
  v8_use_external_startup_data = ""

  # Includes profiles to optimize builtins.
  v8_enable_builtins_optimization = ""

  # Turns on all V8 debug features. Enables running V8 in a pseudo debug mode
  # within a release Chrome.
  v8_enable_debugging_features = is_debug

  # Enable ECMAScript Internationalization API. Enabling this feature will
  # add a dependency on the ICU library.
  v8_enable_i18n_support = true

  # Use static libraries instead of source_sets.
  v8_static_library = false

  # Enable monolithic static library for embedders.
  v8_monolithic = false

  # Expose public symbols for native modules of Node.js and Electron. Default
  # is false.
  v8_expose_public_symbols = ""

  # Deprecated for v8_expose_public_symbols.
  v8_expose_symbols = false

  # Implement tracing using Perfetto (https://perfetto.dev).
  v8_use_perfetto = false

  # Override global symbol level setting for v8.
  v8_symbol_level = symbol_level

  # Enable WebAssembly debugging via GDB-remote protocol.
  v8_enable_wasm_gdb_remote_debugging = false

  # Lite mode disables a number of performance optimizations to reduce memory
  # at the cost of performance.
  # Sets -DV8_LITE_MODE.
  v8_enable_lite_mode = false

  # iOS executable code pages is in 17.4 SDK. We
  # use target_os == "ios" here because it isn't equivalent
  # to is_ios (is_ios is based on host_os).
  if (target_os == "ios") {
    # TODO(dtapuska): Change this to an assert.
    v8_enable_lite_mode = ios_deployment_target != "17.4"
  }

  # Enable the Turbofan compiler.
  # Sets -dV8_ENABLE_TURBOFAN.
  v8_enable_turbofan = ""

  # Enable the Maglev compiler.
  # Sets -dV8_ENABLE_MAGLEV
  v8_enable_maglev = ""

  # Include support for WebAssembly. If disabled, the 'WebAssembly' global
  # will not be available, and embedder APIs to generate WebAssembly modules
  # will fail. Also, asm.js will not be translated to WebAssembly and will be
  # executed as standard JavaScript instead.
  # Sets -dV8_ENABLE_WEBASSEMBLY.
  v8_enable_webassembly = ""

  # Enable 256-bit long vector re-vectorization pass in WASM compilation pipeline.
  v8_enable_wasm_simd256_revec = false

  # Enable runtime call stats.
  # TODO(liviurau): Remove old name after Chromium config update
  # https://crbug.com/1476977.
  v8_enable_runtime_call_stats =
      !(is_on_release_branch || v8_is_on_release_branch)

  # Add fuzzilli fuzzer support.
  v8_fuzzilli = false

  # Enable FuzzTest
  v8_enable_fuzztest = !build_with_v8_embedder &&
                       !(defined(build_with_node) && build_with_node) &&
                       !(is_win && is_component_build) && is_clang

  # Scan the call stack conservatively during garbage collection.
  v8_enable_conservative_stack_scanning = false

  # Use direct pointers in handles (v8::internal::Handle and v8::Local).
  v8_enable_direct_handle = ""

  # Check for off-stack allocated local handles.
  v8_enable_local_off_stack_check = false

  v8_enable_google_benchmark = false

  cppgc_is_standalone = false

  # Enable object names in cppgc for profiling purposes.
  cppgc_enable_object_names = is_chrome_for_testing

  # Enable young generation in cppgc.
  cppgc_enable_young_generation = false

  # Enables a slim write barrier that only performs a single check in the fast
  # path and delegates all further checks to a slow path call. This is fast
  # in a setting with few slow-path checks, i.e., with disabled young generation
  # GC.
  cppgc_enable_slim_write_barrier = true

  # Enable pointer compression in cppgc.
  cppgc_enable_pointer_compression = false

  # Enable 2gb cage for fast compression/decompression. Currently disabled
  # due to an increased number of OOMs.
  cppgc_enable_2gb_cage = false

  # Enable support for larger cages, up to 16GB.
  cppgc_enable_larger_cage = true

  # Enable advanced BigInt algorithms, costing about 10-30 KB binary size
  # depending on platform. Disabled on Android to save binary size.
  v8_advanced_bigint_algorithms = !is_android

  # TODO: macros for determining endian type are clang specific.
  v8_use_libm_trig_functions = is_clang

  # Location of icu.
  v8_icu_path = "//third_party/icu"

  # Location of zlib.
  v8_zlib_path = "//third_party/zlib"

  # Enable pointer compression (sets -dV8_COMPRESS_POINTERS).
  v8_enable_pointer_compression = ""
  v8_enable_pointer_compression_shared_cage = ""
  v8_enable_31bit_smis_on_64bit_arch = false

  # Change code emission and runtime features to be CET shadow-stack compliant
  # (incomplete and experimental).
  v8_enable_cet_shadow_stack = false

  # Emit CET IBT landing pad instructions in JIT generated code (experimental).
  v8_enable_cet_ibt = false
}

if (v8_use_external_startup_data == "") {
  # If not specified as a gn arg, use external startup data by default if
  # we're not on ios.
  v8_use_external_startup_data = !is_ios
}

if (v8_enable_backtrace == "") {
  v8_enable_backtrace = is_debug && !v8_optimized_debug
}

# Chromium is configured to use the perfetto client library, v8 should also
# use perfetto for tracing.
if (build_with_chromium) {
  v8_use_perfetto = true
}

# Includes profiles to optimize builtins if
#   * it is a Chromium build, and
#   * Chromium builds with optimization.
# If no profiles are downloaded during gclient runhooks, optimization fails
# silently.
if (v8_enable_builtins_optimization == "") {
  v8_enable_builtins_optimization = build_with_chromium && chrome_pgo_phase == 2
}

# TODO(jgruber): Move v8_jitless from BUILD.gn here as these
# all depend on each other and really should be derived from
# v8_jitless.
# WebAssembly is enabled by default, except in lite mode.
if (v8_enable_webassembly == "") {
  v8_enable_webassembly = !v8_enable_lite_mode
}
assert(!(v8_enable_webassembly && v8_enable_lite_mode),
       "Webassembly is not available in lite mode.")

if (v8_enable_pointer_compression == "") {
  v8_enable_pointer_compression =
      v8_current_cpu == "arm64" || v8_current_cpu == "x64"
}

# The Wasm interpreter is currently supported only on arm64 and x64, on
# Windows, Linux and MacOS.
is_drumbrake_supported =
    v8_enable_webassembly && v8_enable_pointer_compression &&
    (v8_current_cpu == "x64" || v8_current_cpu == "arm64") &&
    (target_os == "win" || target_os == "linux" || target_os == "mac")

# Turbofan is enabled by default, except in lite mode.
if (v8_enable_turbofan == "") {
  v8_enable_turbofan = !v8_enable_lite_mode
}
assert(v8_enable_turbofan || !v8_enable_webassembly,
       "Webassembly is not available when Turbofan is disabled.")

# Direct internal handles and direct locals are enabled by default if
# conservative stack scanning is enabled.
if (v8_enable_direct_handle == "") {
  v8_enable_direct_handle = v8_enable_conservative_stack_scanning
}

# Points to // in v8 stand-alone or to //v8/ in chromium. We need absolute
# paths for all configs in templates as they are shared in different
# subdirectories.
v8_path_prefix = get_path_info("../", "abspath")

v8_inspector_js_protocol = v8_path_prefix + "/include/js_protocol.pdl"

###############################################################################
# Templates
#

# Common configs to remove or add in all v8 targets.
v8_remove_configs = []
v8_add_configs = [
  v8_path_prefix + ":features",
  v8_path_prefix + ":toolchain",
  v8_path_prefix + ":strict_warnings",
]

if (is_debug && !v8_optimized_debug) {
  v8_remove_configs += [ "//build/config/compiler:default_optimization" ]
  v8_add_configs += [ "//build/config/compiler:no_optimize" ]
} else {
  v8_remove_configs += [ "//build/config/compiler:default_optimization" ]

  # TODO(crbug.com/621335) Rework this so that we don't have the confusion
  # between "optimize_speed" and "optimize_max".
  if (((is_posix && !is_android) || is_win) && !using_sanitizer) {
    v8_add_configs += [ "//build/config/compiler:optimize_speed" ]
  } else {
    v8_add_configs += [ "//build/config/compiler:optimize_max" ]
  }
}

if (!is_debug) {
  v8_remove_configs += [
    # Too much performance impact, unclear security benefit.
    "//build/config/compiler:default_init_stack_vars",
  ]
}

if (v8_symbol_level != symbol_level) {
  v8_remove_configs += [ "//build/config/compiler:default_symbols" ]
  if (v8_symbol_level == 0) {
    v8_add_configs += [ "//build/config/compiler:no_symbols" ]
  } else if (v8_symbol_level == 1) {
    v8_add_configs += [ "//build/config/compiler:minimal_symbols" ]
  } else if (v8_symbol_level == 2) {
    v8_add_configs += [ "//build/config/compiler:symbols" ]
  } else {
    assert(false)
  }
}

if ((is_posix || is_fuchsia) && (v8_enable_backtrace || v8_monolithic)) {
  v8_remove_configs += [ "//build/config/gcc:symbol_visibility_hidden" ]
  v8_add_configs += [ "//build/config/gcc:symbol_visibility_default" ]
}

# On MIPS gcc_target_rpath and ldso_path might be needed for all builds.
if (target_cpu == "mips64el" || target_cpu == "mips64") {
  v8_add_configs += [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
}

if (!build_with_chromium && is_clang) {
  v8_remove_configs += [ "//build/config/clang:find_bad_constructs" ]
}

# All templates should be kept in sync.
template("v8_source_set") {
  if (defined(invoker.split_count) && invoker.split_count > 1 &&
      defined(v8_static_library) && v8_static_library && is_win) {
    link_target_type = "split_static_library"
  } else if (defined(v8_static_library) && v8_static_library) {
    link_target_type = "static_library"
  } else {
    link_target_type = "source_set"
  }
  target(link_target_type, target_name) {
    forward_variables_from(invoker,
                           "*",
                           [
                             "configs",
                             "remove_configs",
                           ])
    configs -= v8_remove_configs
    configs += v8_add_configs
    if (defined(invoker.remove_configs)) {
      configs -= invoker.remove_configs
    }
    configs += invoker.configs
  }
}

template("v8_header_set") {
  source_set(target_name) {
    forward_variables_from(invoker, "*", [ "configs" ])
    configs -= v8_remove_configs
    configs += v8_add_configs
    configs += invoker.configs
  }
}

template("v8_executable") {
  if (is_ios) {
    import("//build/config/ios/rules.gni")

    ios_app_bundle(target_name) {
      forward_variables_from(invoker,
                             "*",
                             [
                               "configs",
                               "remove_configs",
                             ])
      configs -= v8_remove_configs
      configs += v8_add_configs
      if (defined(invoker.remove_configs)) {
        configs -= invoker.remove_configs
      }
      configs += invoker.configs
      deps += [ v8_path_prefix + ":v8_dump_build_config" ]

      # Provide sensible defaults in case invoker did not define any of those
      # required variables.
      if (!defined(info_plist) && !defined(info_plist_target)) {
        info_plist = v8_path_prefix + "/gni/Info.plist"
      }

      bundle_identifier = "$ios_app_bundle_id_prefix.chrome.unittests.dev"
    }
  } else {
    executable(target_name) {
      forward_variables_from(invoker,
                             "*",
                             [
                               "configs",
                               "remove_configs",
                             ])
      configs -= v8_remove_configs
      configs += v8_add_configs
      if (defined(invoker.remove_configs)) {
        configs -= invoker.remove_configs
      }
      configs += invoker.configs
      if (is_linux || is_chromeos) {
        # For enabling ASLR.
        ldflags = [ "-pie" ]
      }
      deps += [ v8_path_prefix + ":v8_dump_build_config" ]

      if (is_win && !v8_enable_cet_shadow_stack) {
        configs -= [ "//build/config/compiler:cet_shadow_stack" ]
      }
    }
  }
}

template("v8_component") {
  component(target_name) {
    output_name = target_name
    forward_variables_from(invoker,
                           "*",
                           [
                             "configs",
                             "remove_configs",
                           ])
    configs -= v8_remove_configs
    configs += v8_add_configs
    if (defined(invoker.remove_configs)) {
      configs -= invoker.remove_configs
    }
    configs += invoker.configs
  }
}

template("v8_shared_library") {
  shared_library(target_name) {
    forward_variables_from(invoker,
                           "*",
                           [
                             "configs",
                             "remove_configs",
                           ])
    configs -= v8_remove_configs
    configs += v8_add_configs
    if (defined(invoker.remove_configs)) {
      configs -= invoker.remove_configs
    }
    if (defined(invoker.configs)) {
      configs += invoker.configs
    }
  }
}

template("v8_static_library") {
  static_library(target_name) {
    complete_static_lib = true
    forward_variables_from(invoker, "*", [ "configs" ])
    configs -= v8_remove_configs
    configs -= [ "//build/config/compiler:thin_archive" ]
    configs += v8_add_configs
    configs += invoker.configs
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/include/                                                                        0000775 0000000 0000000 00000000000 14746647661 0015470 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/include/APIDesign.md                                                            0000664 0000000 0000000 00000006461 14746647661 0017564 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # The V8 public C++ API

# Overview

The V8 public C++ API aims to support four use cases:

1. Enable applications that embed V8 (called the embedder) to configure and run
   one or more instances of V8.
2. Expose ECMAScript-like capabilities to the embedder.
3. Enable the embedder to interact with ECMAScript by exposing API objects.
4. Provide access to the V8 debugger (inspector).

# Configuring and running an instance of V8

V8 requires access to certain OS-level primitives such as the ability to
schedule work on threads, or allocate memory.

The embedder can define how to access those primitives via the v8::Platform
interface. While V8 bundles a basic implementation, embedders are highly
encouraged to implement v8::Platform themselves.

Currently, the v8::ArrayBuffer::Allocator is passed to the v8::Isolate factory
method, however, conceptually it should also be part of the v8::Platform since
all instances of V8 should share one allocator.

Once the v8::Platform is configured, an v8::Isolate can be created. All
further interactions with V8 should explicitly reference the v8::Isolate they
refer to. All API methods should eventually take an v8::Isolate parameter.

When a given instance of V8 is no longer needed, it can be destroyed by
disposing the respective v8::Isolate. If the embedder wishes to free all memory
associated with the v8::Isolate, it has to first clear all global handles
associated with that v8::Isolate.

# ECMAScript-like capabilities

In general, the C++ API shouldn't enable capabilities that aren't available to
scripts running in V8. Experience has shown that it's not possible to maintain
such API methods in the long term. However, capabilities also available to
scripts, i.e., ones that are defined in the ECMAScript standard are there to
stay, and we can safely expose them to embedders.

The C++ API should also be pleasant to use, and not require learning new
paradigms. Similarly to how the API exposed to scripts aims to provide good
ergonomics, we should aim to provide a reasonable developer experience for this
API surface.

ECMAScript makes heavy use of exceptions, however, V8's C++ code doesn't use
C++ exceptions. Therefore, all API methods that can throw exceptions should
indicate so by returning a v8::Maybe&lt;&gt; or v8::MaybeLocal&lt;&gt; result,
and by taking a v8::Local&lt;v8::Context&gt; parameter that indicates in which
context a possible exception should be thrown.

# API objects

V8 allows embedders to define special objects that expose additional
capabilities and APIs to scripts. The most prominent example is exposing the
HTML DOM in Blink. Other examples are e.g. node.js. It is less clear what kind
of capabilities we want to expose via this API surface. As a rule of thumb, we
want to expose operations as defined in the WebIDL and HTML spec: we
assume that those requirements are somewhat stable, and that they are a
superset of the requirements of other embedders including node.js.

Ideally, the API surfaces defined in those specs hook into the ECMAScript spec
which in turn guarantees long-term stability of the API.

# The V8 inspector

All debugging capabilities of V8 should be exposed via the inspector protocol.
The exception to this are profiling features exposed via v8-profiler.h.
Changes to the inspector protocol need to ensure backwards compatibility and
commitment to maintain.
                                                                                                                                                                                                               node-23.7.0/deps/v8/include/DEPS                                                                    0000664 0000000 0000000 00000000450 14746647661 0016145 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        include_rules = [
  # v8-inspector-protocol.h depends on generated files under include/inspector.
  "+inspector",
  "+cppgc/common.h",
  # Used by v8-cppgc.h to bridge to cppgc.
  "+cppgc/custom-space.h",
  "+cppgc/heap-statistics.h",
  "+cppgc/internal/write-barrier.h",
  "+cppgc/visitor.h",
]
                                                                                                                                                                                                                        node-23.7.0/deps/v8/include/DIR_METADATA                                                            0000664 0000000 0000000 00000000631 14746647661 0017271 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Metadata information for this directory.
#
# For more information on DIR_METADATA files, see:
#   https://source.chromium.org/chromium/infra/infra/+/master:go/src/infra/tools/dirmd/README.md
#
# For the schema of this file, see Metadata message:
#   https://source.chromium.org/chromium/infra/infra/+/master:go/src/infra/tools/dirmd/proto/dir_metadata.proto

monorail {
  component: "Blink>JavaScript>API"
}                                                                                                       node-23.7.0/deps/v8/include/OWNERS                                                                  0000664 0000000 0000000 00000001261 14746647661 0016430 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        adamk@chromium.org
cbruni@chromium.org
leszeks@chromium.org
mlippautz@chromium.org
verwaest@chromium.org
yangguo@chromium.org

per-file *DEPS=file:../COMMON_OWNERS
per-file v8-internal.h=file:../COMMON_OWNERS

per-file v8-debug.h=file:../src/debug/OWNERS

per-file js_protocol.pdl=file:../src/inspector/OWNERS
per-file v8-inspector*=file:../src/inspector/OWNERS
per-file v8-inspector*=file:../src/inspector/OWNERS

# Needed by the auto_tag builder
per-file v8-version.h=v8-ci-autoroll-builder@chops-service-accounts.iam.gserviceaccount.com

# For branch updates:
per-file v8-version.h=file:../INFRA_OWNERS
per-file v8-version.h=hablich@chromium.org
per-file v8-version.h=vahl@chromium.org
                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/include/cppgc/                                                                  0000775 0000000 0000000 00000000000 14746647661 0016564 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/include/cppgc/DEPS                                                              0000664 0000000 0000000 00000000230 14746647661 0017235 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        include_rules = [
  "-include",
  "+v8config.h",
  "+v8-platform.h",
  "+v8-source-location.h",
  "+cppgc",
  "-src",
  "+libplatform/libplatform.h",
]
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/include/cppgc/OWNERS                                                            0000664 0000000 0000000 00000000053 14746647661 0017522 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        bikineev@chromium.org
omerkatz@chromium.org                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/include/cppgc/README.md                                                         0000664 0000000 0000000 00000020122 14746647661 0020040 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Oilpan: C++ Garbage Collection

Oilpan is an open-source garbage collection library for C++ that can be used stand-alone or in collaboration with V8's JavaScript garbage collector.
Oilpan implements mark-and-sweep garbage collection (GC) with limited compaction (for a subset of objects).

**Key properties**

- Trace-based garbage collection;
- Incremental and concurrent marking;
- Incremental and concurrent sweeping;
- Precise on-heap memory layout;
- Conservative on-stack memory layout;
- Allows for collection with and without considering stack;
- Non-incremental and non-concurrent compaction for selected spaces;

See the [Hello World](https://chromium.googlesource.com/v8/v8/+/main/samples/cppgc/hello-world.cc) example on how to get started using Oilpan to manage C++ code.

Oilpan follows V8's project organization, see e.g. on how we accept [contributions](https://v8.dev/docs/contribute) and [provide a stable API](https://v8.dev/docs/api).

## Threading model

Oilpan features thread-local garbage collection and assumes heaps are not shared among threads.
In other words, objects are accessed and ultimately reclaimed by the garbage collector on the same thread that allocates them.
This allows Oilpan to run garbage collection in parallel with mutators running in other threads.

References to objects belonging to another thread's heap are modeled using cross-thread roots.
This is even true for on-heap to on-heap references.

Oilpan heaps may generally not be accessed from different threads unless otherwise noted.

## Heap partitioning

Oilpan's heaps are partitioned into spaces.
The space for an object is chosen depending on a number of criteria, e.g.:

- Objects over 64KiB are allocated in a large object space
- Objects can be assigned to a dedicated custom space.
  Custom spaces can also be marked as compactable.
- Other objects are allocated in one of the normal page spaces bucketed depending on their size.

## Precise and conservative garbage collection

Oilpan supports two kinds of GCs:

1. **Conservative GC.**
A GC is called conservative when it is executed while the regular native stack is not empty.
In this case, the native stack might contain references to objects in Oilpan's heap, which should be kept alive.
The GC scans the native stack and treats the pointers discovered via the native stack as part of the root set.
This kind of GC is considered imprecise because values on stack other than references may accidentally appear as references to on-heap object, which means these objects will be kept alive despite being in practice unreachable from the application as an actual reference.

2. **Precise GC.**
A precise GC is triggered at the end of an event loop, which is controlled by an embedder via a platform.
At this point, it is guaranteed that there are no on-stack references pointing to Oilpan's heap.
This means there is no risk of confusing other value types with references.
Oilpan has precise knowledge of on-heap object layouts, and so it knows exactly where pointers lie in memory.
Oilpan can just start marking from the regular root set and collect all garbage precisely.

## Atomic, incremental and concurrent garbage collection

Oilpan has three modes of operation:

1. **Atomic GC.**
The entire GC cycle, including all its phases (e.g. see [Marking](#Marking-phase) and [Sweeping](#Sweeping-phase)), are executed back to back in a single pause.
This mode of operation is also known as Stop-The-World (STW) garbage collection.
It results in the most jank (due to a single long pause), but is overall the most efficient (e.g. no need for write barriers).

2. **Incremental GC.**
Garbage collection work is split up into multiple steps which are interleaved with the mutator, i.e. user code chunked into tasks.
Each step is a small chunk of work that is executed either as dedicated tasks between mutator tasks or, as needed, during mutator tasks.
Using incremental GC introduces the need for write barriers that record changes to the object graph so that a consistent state is observed and no objects are accidentally considered dead and reclaimed.
The incremental steps are followed by a smaller atomic pause to finalize garbage collection.
The smaller pause times, due to smaller chunks of work, helps with reducing jank.

3. **Concurrent GC.**
This is the most common type of GC.
It builds on top of incremental GC and offloads much of the garbage collection work away from the mutator thread and on to background threads.
Using concurrent GC allows the mutator thread to spend less time on GC and more on the actual mutator.

## Marking phase

The marking phase consists of the following steps:

1. Mark all objects in the root set.

2. Mark all objects transitively reachable from the root set by calling `Trace()` methods defined on each object.

3. Clear out all weak handles to unreachable objects and run weak callbacks.

The marking phase can be executed atomically in a stop-the-world manner, in which all 3 steps are executed one after the other.

Alternatively, it can also be executed incrementally/concurrently.
With incremental/concurrent marking, step 1 is executed in a short pause after which the mutator regains control.
Step 2 is repeatedly executed in an interleaved manner with the mutator.
When the GC is ready to finalize, i.e. step 2 is (almost) finished, another short pause is triggered in which step 2 is finished and step 3 is performed.

To prevent a user-after-free (UAF) issues it is required for Oilpan to know about all edges in the object graph.
This means that all pointers except on-stack pointers must be wrapped with Oilpan's handles (i.e., Persistent<>, Member<>, WeakMember<>).
Raw pointers to on-heap objects create an edge that Oilpan cannot observe and cause UAF issues
Thus, raw pointers shall not be used to reference on-heap objects (except for raw pointers on native stacks).

## Sweeping phase

The sweeping phase consists of the following steps:

1. Invoke pre-finalizers.
At this point, no destructors have been invoked and no memory has been reclaimed.
Pre-finalizers are allowed to access any other on-heap objects, even those that may get destructed.

2. Sweeping invokes destructors of the dead (unreachable) objects and reclaims memory to be reused by future allocations.

Assumptions should not be made about the order and the timing of their execution.
There is no guarantee on the order in which the destructors are invoked.
That's why destructors must not access any other on-heap objects (which might have already been destructed).
If some destructor unavoidably needs to access other on-heap objects, it will have to be converted to a pre-finalizer.
The pre-finalizer is allowed to access other on-heap objects.

The mutator is resumed before all destructors have ran.
For example, imagine a case where X is a client of Y, and Y holds a list of clients.
If the code relies on X's destructor removing X from the list, there is a risk that Y iterates the list and calls some method of X which may touch other on-heap objects.
This causes a use-after-free.
Care must be taken to make sure that X is explicitly removed from the list before the mutator resumes its execution in a way that doesn't rely on X's destructor (e.g. a pre-finalizer).

Similar to marking, sweeping can be executed in either an atomic stop-the-world manner or incrementally/concurrently.
With incremental/concurrent sweeping, step 2 is interleaved with mutator.
Incremental/concurrent sweeping can be atomically finalized in case it is needed to trigger another GC cycle.
Even with concurrent sweeping, destructors are guaranteed to run on the thread the object has been allocated on to preserve C++ semantics.

Notes:

* Weak processing runs only when the holder object of the WeakMember outlives the pointed object.
If the holder object and the pointed object die at the same time, weak processing doesn't run.
It is wrong to write code assuming that the weak processing always runs.

* Pre-finalizers are heavy because the thread needs to scan all pre-finalizers at each sweeping phase to determine which pre-finalizers should be invoked (the thread needs to invoke pre-finalizers of dead objects).
Adding pre-finalizers to frequently created objects should be avoided.
                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/include/cppgc/allocation.h                                                      0000664 0000000 0000000 00000026576 14746647661 0021102 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_ALLOCATION_H_
#define INCLUDE_CPPGC_ALLOCATION_H_

#include <atomic>
#include <cstddef>
#include <cstdint>
#include <new>
#include <type_traits>
#include <utility>

#include "cppgc/custom-space.h"
#include "cppgc/internal/api-constants.h"
#include "cppgc/internal/gc-info.h"
#include "cppgc/type-traits.h"
#include "v8config.h"  // NOLINT(build/include_directory)

#if defined(__has_attribute)
#if __has_attribute(assume_aligned)
#define CPPGC_DEFAULT_ALIGNED \
  __attribute__((assume_aligned(api_constants::kDefaultAlignment)))
#define CPPGC_DOUBLE_WORD_ALIGNED \
  __attribute__((assume_aligned(2 * api_constants::kDefaultAlignment)))
#endif  // __has_attribute(assume_aligned)
#endif  // defined(__has_attribute)

#if !defined(CPPGC_DEFAULT_ALIGNED)
#define CPPGC_DEFAULT_ALIGNED
#endif

#if !defined(CPPGC_DOUBLE_WORD_ALIGNED)
#define CPPGC_DOUBLE_WORD_ALIGNED
#endif

namespace cppgc {

/**
 * AllocationHandle is used to allocate garbage-collected objects.
 */
class AllocationHandle;

namespace internal {

// Similar to C++17 std::align_val_t;
enum class AlignVal : size_t {};

class MakeGarbageCollectedTraitInternal {
 protected:
  static inline void MarkObjectAsFullyConstructed(const void* payload) {
    // See api_constants for an explanation of the constants.
    std::atomic<uint16_t>* atomic_mutable_bitfield =
        reinterpret_cast<std::atomic<uint16_t>*>(
            const_cast<uint16_t*>(reinterpret_cast<const uint16_t*>(
                reinterpret_cast<const uint8_t*>(payload) -
                api_constants::kFullyConstructedBitFieldOffsetFromPayload)));
    // It's safe to split use load+store here (instead of a read-modify-write
    // operation), since it's guaranteed that this 16-bit bitfield is only
    // modified by a single thread. This is cheaper in terms of code bloat (on
    // ARM) and performance.
    uint16_t value = atomic_mutable_bitfield->load(std::memory_order_relaxed);
    value |= api_constants::kFullyConstructedBitMask;
    atomic_mutable_bitfield->store(value, std::memory_order_release);
  }

  // Dispatch based on compile-time information.
  //
  // Default implementation is for a custom space with >`kDefaultAlignment` byte
  // alignment.
  template <typename GCInfoType, typename CustomSpace, size_t alignment>
  struct AllocationDispatcher final {
    static void* Invoke(AllocationHandle& handle, size_t size) {
      static_assert(std::is_base_of<CustomSpaceBase, CustomSpace>::value,
                    "Custom space must inherit from CustomSpaceBase.");
      static_assert(
          !CustomSpace::kSupportsCompaction,
          "Custom spaces that support compaction do not support allocating "
          "objects with non-default (i.e. word-sized) alignment.");
      return MakeGarbageCollectedTraitInternal::Allocate(
          handle, size, static_cast<AlignVal>(alignment),
          internal::GCInfoTrait<GCInfoType>::Index(), CustomSpace::kSpaceIndex);
    }
  };

  // Fast path for regular allocations for the default space with
  // `kDefaultAlignment` byte alignment.
  template <typename GCInfoType>
  struct AllocationDispatcher<GCInfoType, void,
                              api_constants::kDefaultAlignment>
      final {
    static void* Invoke(AllocationHandle& handle, size_t size) {
      return MakeGarbageCollectedTraitInternal::Allocate(
          handle, size, internal::GCInfoTrait<GCInfoType>::Index());
    }
  };

  // Default space with >`kDefaultAlignment` byte alignment.
  template <typename GCInfoType, size_t alignment>
  struct AllocationDispatcher<GCInfoType, void, alignment> final {
    static void* Invoke(AllocationHandle& handle, size_t size) {
      return MakeGarbageCollectedTraitInternal::Allocate(
          handle, size, static_cast<AlignVal>(alignment),
          internal::GCInfoTrait<GCInfoType>::Index());
    }
  };

  // Custom space with `kDefaultAlignment` byte alignment.
  template <typename GCInfoType, typename CustomSpace>
  struct AllocationDispatcher<GCInfoType, CustomSpace,
                              api_constants::kDefaultAlignment>
      final {
    static void* Invoke(AllocationHandle& handle, size_t size) {
      static_assert(std::is_base_of<CustomSpaceBase, CustomSpace>::value,
                    "Custom space must inherit from CustomSpaceBase.");
      return MakeGarbageCollectedTraitInternal::Allocate(
          handle, size, internal::GCInfoTrait<GCInfoType>::Index(),
          CustomSpace::kSpaceIndex);
    }
  };

 private:
  V8_EXPORT static void* CPPGC_DEFAULT_ALIGNED
  Allocate(cppgc::AllocationHandle&, size_t, GCInfoIndex);
  V8_EXPORT static void* CPPGC_DOUBLE_WORD_ALIGNED
  Allocate(cppgc::AllocationHandle&, size_t, AlignVal, GCInfoIndex);
  V8_EXPORT static void* CPPGC_DEFAULT_ALIGNED
  Allocate(cppgc::AllocationHandle&, size_t, GCInfoIndex, CustomSpaceIndex);
  V8_EXPORT static void* CPPGC_DOUBLE_WORD_ALIGNED
  Allocate(cppgc::AllocationHandle&, size_t, AlignVal, GCInfoIndex,
           CustomSpaceIndex);

  friend class HeapObjectHeader;
};

}  // namespace internal

/**
 * Base trait that provides utilities for advancers users that have custom
 * allocation needs (e.g., overriding size). It's expected that users override
 * MakeGarbageCollectedTrait (see below) and inherit from
 * MakeGarbageCollectedTraitBase and make use of the low-level primitives
 * offered to allocate and construct an object.
 */
template <typename T>
class MakeGarbageCollectedTraitBase
    : private internal::MakeGarbageCollectedTraitInternal {
 private:
  static_assert(internal::IsGarbageCollectedType<T>::value,
                "T needs to be a garbage collected object");
  static_assert(!IsGarbageCollectedWithMixinTypeV<T> ||
                    sizeof(T) <=
                        internal::api_constants::kLargeObjectSizeThreshold,
                "GarbageCollectedMixin may not be a large object");

 protected:
  /**
   * Allocates memory for an object of type T.
   *
   * \param handle AllocationHandle identifying the heap to allocate the object
   *   on.
   * \param size The size that should be reserved for the object.
   * \returns the memory to construct an object of type T on.
   */
  V8_INLINE static void* Allocate(AllocationHandle& handle, size_t size) {
    static_assert(
        std::is_base_of<typename T::ParentMostGarbageCollectedType, T>::value,
        "U of GarbageCollected<U> must be a base of T. Check "
        "GarbageCollected<T> base class inheritance.");
    static constexpr size_t kWantedAlignment =
        alignof(T) < internal::api_constants::kDefaultAlignment
            ? internal::api_constants::kDefaultAlignment
            : alignof(T);
    static_assert(
        kWantedAlignment <= internal::api_constants::kMaxSupportedAlignment,
        "Requested alignment larger than alignof(std::max_align_t) bytes. "
        "Please file a bug to possibly get this restriction lifted.");
    return AllocationDispatcher<
        typename internal::GCInfoFolding<
            T, typename T::ParentMostGarbageCollectedType>::ResultType,
        typename SpaceTrait<T>::Space, kWantedAlignment>::Invoke(handle, size);
  }

  /**
   * Marks an object as fully constructed, resulting in precise handling by the
   * garbage collector.
   *
   * \param payload The base pointer the object is allocated at.
   */
  V8_INLINE static void MarkObjectAsFullyConstructed(const void* payload) {
    internal::MakeGarbageCollectedTraitInternal::MarkObjectAsFullyConstructed(
        payload);
  }
};

/**
 * Passed to MakeGarbageCollected to specify how many bytes should be appended
 * to the allocated object.
 *
 * Example:
 * \code
 * class InlinedArray final : public GarbageCollected<InlinedArray> {
 *  public:
 *   explicit InlinedArray(size_t bytes) : size(bytes), byte_array(this + 1) {}
 *   void Trace(Visitor*) const {}

 *   size_t size;
 *   char* byte_array;
 * };
 *
 * auto* inlined_array = MakeGarbageCollected<InlinedArray(
 *    GetAllocationHandle(), AdditionalBytes(4), 4);
 * for (size_t i = 0; i < 4; i++) {
 *   Process(inlined_array->byte_array[i]);
 * }
 * \endcode
 */
struct AdditionalBytes {
  constexpr explicit AdditionalBytes(size_t bytes) : value(bytes) {}
  const size_t value;
};

/**
 * Default trait class that specifies how to construct an object of type T.
 * Advanced users may override how an object is constructed using the utilities
 * that are provided through MakeGarbageCollectedTraitBase.
 *
 * Any trait overriding construction must
 * - allocate through `MakeGarbageCollectedTraitBase<T>::Allocate`;
 * - mark the object as fully constructed using
 *   `MakeGarbageCollectedTraitBase<T>::MarkObjectAsFullyConstructed`;
 */
template <typename T>
class MakeGarbageCollectedTrait : public MakeGarbageCollectedTraitBase<T> {
 public:
  template <typename... Args>
  static T* Call(AllocationHandle& handle, Args&&... args) {
    void* memory =
        MakeGarbageCollectedTraitBase<T>::Allocate(handle, sizeof(T));
    T* object = ::new (memory) T(std::forward<Args>(args)...);
    MakeGarbageCollectedTraitBase<T>::MarkObjectAsFullyConstructed(object);
    return object;
  }

  template <typename... Args>
  static T* Call(AllocationHandle& handle, AdditionalBytes additional_bytes,
                 Args&&... args) {
    void* memory = MakeGarbageCollectedTraitBase<T>::Allocate(
        handle, sizeof(T) + additional_bytes.value);
    T* object = ::new (memory) T(std::forward<Args>(args)...);
    MakeGarbageCollectedTraitBase<T>::MarkObjectAsFullyConstructed(object);
    return object;
  }
};

/**
 * Allows users to specify a post-construction callback for specific types. The
 * callback is invoked on the instance of type T right after it has been
 * constructed. This can be useful when the callback requires a
 * fully-constructed object to be able to dispatch to virtual methods.
 */
template <typename T, typename = void>
struct PostConstructionCallbackTrait {
  static void Call(T*) {}
};

/**
 * Constructs a managed object of type T where T transitively inherits from
 * GarbageCollected.
 *
 * \param args List of arguments with which an instance of T will be
 *   constructed.
 * \returns an instance of type T.
 */
template <typename T, typename... Args>
V8_INLINE T* MakeGarbageCollected(AllocationHandle& handle, Args&&... args) {
  T* object =
      MakeGarbageCollectedTrait<T>::Call(handle, std::forward<Args>(args)...);
  PostConstructionCallbackTrait<T>::Call(object);
  return object;
}

/**
 * Constructs a managed object of type T where T transitively inherits from
 * GarbageCollected. Created objects will have additional bytes appended to
 * it. Allocated memory would suffice for `sizeof(T) + additional_bytes`.
 *
 * \param additional_bytes Denotes how many bytes to append to T.
 * \param args List of arguments with which an instance of T will be
 *   constructed.
 * \returns an instance of type T.
 */
template <typename T, typename... Args>
V8_INLINE T* MakeGarbageCollected(AllocationHandle& handle,
                                  AdditionalBytes additional_bytes,
                                  Args&&... args) {
  T* object = MakeGarbageCollectedTrait<T>::Call(handle, additional_bytes,
                                                 std::forward<Args>(args)...);
  PostConstructionCallbackTrait<T>::Call(object);
  return object;
}

}  // namespace cppgc

#undef CPPGC_DEFAULT_ALIGNED
#undef CPPGC_DOUBLE_WORD_ALIGNED

#endif  // INCLUDE_CPPGC_ALLOCATION_H_
                                                                                                                                  node-23.7.0/deps/v8/include/cppgc/common.h                                                          0000664 0000000 0000000 00000001203 14746647661 0020221 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_COMMON_H_
#define INCLUDE_CPPGC_COMMON_H_

#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {

/**
 *  Indicator for the stack state of the embedder.
 */
enum class EmbedderStackState {
  /**
   * Stack may contain interesting heap pointers.
   */
  kMayContainHeapPointers,
  /**
   * Stack does not contain any interesting heap pointers.
   */
  kNoHeapPointers,
};

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_COMMON_H_
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/include/cppgc/cross-thread-persistent.h                                         0000664 0000000 0000000 00000035502 14746647661 0023536 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_CROSS_THREAD_PERSISTENT_H_
#define INCLUDE_CPPGC_CROSS_THREAD_PERSISTENT_H_

#include <atomic>

#include "cppgc/internal/persistent-node.h"
#include "cppgc/internal/pointer-policies.h"
#include "cppgc/persistent.h"
#include "cppgc/visitor.h"

namespace cppgc {
namespace internal {

// Wrapper around PersistentBase that allows accessing poisoned memory when
// using ASAN. This is needed as the GC of the heap that owns the value
// of a CTP, may clear it (heap termination, weakness) while the object
// holding the CTP may be poisoned as itself may be deemed dead.
class CrossThreadPersistentBase : public PersistentBase {
 public:
  CrossThreadPersistentBase() = default;
  explicit CrossThreadPersistentBase(const void* raw) : PersistentBase(raw) {}

  V8_CLANG_NO_SANITIZE("address") const void* GetValueFromGC() const {
    return raw_;
  }

  V8_CLANG_NO_SANITIZE("address")
  PersistentNode* GetNodeFromGC() const { return node_; }

  V8_CLANG_NO_SANITIZE("address")
  void ClearFromGC() const {
    raw_ = nullptr;
    SetNodeSafe(nullptr);
  }

  // GetNodeSafe() can be used for a thread-safe IsValid() check in a
  // double-checked locking pattern. See ~BasicCrossThreadPersistent.
  PersistentNode* GetNodeSafe() const {
    return reinterpret_cast<std::atomic<PersistentNode*>*>(&node_)->load(
        std::memory_order_acquire);
  }

  // The GC writes using SetNodeSafe() while holding the lock.
  V8_CLANG_NO_SANITIZE("address")
  void SetNodeSafe(PersistentNode* value) const {
#if defined(__has_feature)
#if __has_feature(address_sanitizer)
#define V8_IS_ASAN 1
#endif
#endif

#ifdef V8_IS_ASAN
    __atomic_store(&node_, &value, __ATOMIC_RELEASE);
#else   // !V8_IS_ASAN
    // Non-ASAN builds can use atomics. This also covers MSVC which does not
    // have the __atomic_store intrinsic.
    reinterpret_cast<std::atomic<PersistentNode*>*>(&node_)->store(
        value, std::memory_order_release);
#endif  // !V8_IS_ASAN

#undef V8_IS_ASAN
  }
};

template <typename T, typename WeaknessPolicy, typename LocationPolicy,
          typename CheckingPolicy>
class BasicCrossThreadPersistent final : public CrossThreadPersistentBase,
                                         public LocationPolicy,
                                         private WeaknessPolicy,
                                         private CheckingPolicy {
 public:
  using typename WeaknessPolicy::IsStrongPersistent;
  using PointeeType = T;

  ~BasicCrossThreadPersistent() {
    //  This implements fast path for destroying empty/sentinel.
    //
    // Simplified version of `AssignUnsafe()` to allow calling without a
    // complete type `T`. Uses double-checked locking with a simple thread-safe
    // check for a valid handle based on a node.
    if (GetNodeSafe()) {
      PersistentRegionLock guard;
      const void* old_value = GetValue();
      // The fast path check (GetNodeSafe()) does not acquire the lock. Recheck
      // validity while holding the lock to ensure the reference has not been
      // cleared.
      if (IsValid(old_value)) {
        CrossThreadPersistentRegion& region =
            this->GetPersistentRegion(old_value);
        region.FreeNode(GetNode());
        SetNode(nullptr);
      } else {
        CPPGC_DCHECK(!GetNode());
      }
    }
    // No need to call SetValue() as the handle is not used anymore. This can
    // leave behind stale sentinel values but will always destroy the underlying
    // node.
  }

  BasicCrossThreadPersistent(
      const SourceLocation& loc = SourceLocation::Current())
      : LocationPolicy(loc) {}

  BasicCrossThreadPersistent(
      std::nullptr_t, const SourceLocation& loc = SourceLocation::Current())
      : LocationPolicy(loc) {}

  BasicCrossThreadPersistent(
      SentinelPointer s, const SourceLocation& loc = SourceLocation::Current())
      : CrossThreadPersistentBase(s), LocationPolicy(loc) {}

  BasicCrossThreadPersistent(
      T* raw, const SourceLocation& loc = SourceLocation::Current())
      : CrossThreadPersistentBase(raw), LocationPolicy(loc) {
    if (!IsValid(raw)) return;
    PersistentRegionLock guard;
    CrossThreadPersistentRegion& region = this->GetPersistentRegion(raw);
    SetNode(region.AllocateNode(this, &TraceAsRoot));
    this->CheckPointer(raw);
  }

  class UnsafeCtorTag {
   private:
    UnsafeCtorTag() = default;
    template <typename U, typename OtherWeaknessPolicy,
              typename OtherLocationPolicy, typename OtherCheckingPolicy>
    friend class BasicCrossThreadPersistent;
  };

  BasicCrossThreadPersistent(
      UnsafeCtorTag, T* raw,
      const SourceLocation& loc = SourceLocation::Current())
      : CrossThreadPersistentBase(raw), LocationPolicy(loc) {
    if (!IsValid(raw)) return;
    CrossThreadPersistentRegion& region = this->GetPersistentRegion(raw);
    SetNode(region.AllocateNode(this, &TraceAsRoot));
    this->CheckPointer(raw);
  }

  BasicCrossThreadPersistent(
      T& raw, const SourceLocation& loc = SourceLocation::Current())
      : BasicCrossThreadPersistent(&raw, loc) {}

  template <typename U, typename MemberBarrierPolicy,
            typename MemberWeaknessTag, typename MemberCheckingPolicy,
            typename MemberStorageType,
            typename = std::enable_if_t<std::is_base_of<T, U>::value>>
  BasicCrossThreadPersistent(
      internal::BasicMember<U, MemberBarrierPolicy, MemberWeaknessTag,
                            MemberCheckingPolicy, MemberStorageType>
          member,
      const SourceLocation& loc = SourceLocation::Current())
      : BasicCrossThreadPersistent(member.Get(), loc) {}

  BasicCrossThreadPersistent(
      const BasicCrossThreadPersistent& other,
      const SourceLocation& loc = SourceLocation::Current())
      : BasicCrossThreadPersistent(loc) {
    // Invoke operator=.
    *this = other;
  }

  // Heterogeneous ctor.
  template <typename U, typename OtherWeaknessPolicy,
            typename OtherLocationPolicy, typename OtherCheckingPolicy,
            typename = std::enable_if_t<std::is_base_of<T, U>::value>>
  BasicCrossThreadPersistent(
      const BasicCrossThreadPersistent<U, OtherWeaknessPolicy,
                                       OtherLocationPolicy,
                                       OtherCheckingPolicy>& other,
      const SourceLocation& loc = SourceLocation::Current())
      : BasicCrossThreadPersistent(loc) {
    *this = other;
  }

  BasicCrossThreadPersistent(
      BasicCrossThreadPersistent&& other,
      const SourceLocation& loc = SourceLocation::Current()) noexcept {
    // Invoke operator=.
    *this = std::move(other);
  }

  BasicCrossThreadPersistent& operator=(
      const BasicCrossThreadPersistent& other) {
    PersistentRegionLock guard;
    AssignSafe(guard, other.Get());
    return *this;
  }

  template <typename U, typename OtherWeaknessPolicy,
            typename OtherLocationPolicy, typename OtherCheckingPolicy,
            typename = std::enable_if_t<std::is_base_of<T, U>::value>>
  BasicCrossThreadPersistent& operator=(
      const BasicCrossThreadPersistent<U, OtherWeaknessPolicy,
                                       OtherLocationPolicy,
                                       OtherCheckingPolicy>& other) {
    PersistentRegionLock guard;
    AssignSafe(guard, other.Get());
    return *this;
  }

  BasicCrossThreadPersistent& operator=(BasicCrossThreadPersistent&& other) {
    if (this == &other) return *this;
    Clear();
    PersistentRegionLock guard;
    PersistentBase::operator=(std::move(other));
    LocationPolicy::operator=(std::move(other));
    if (!IsValid(GetValue())) return *this;
    GetNode()->UpdateOwner(this);
    other.SetValue(nullptr);
    other.SetNode(nullptr);
    this->CheckPointer(Get());
    return *this;
  }

  /**
   * Assigns a raw pointer.
   *
   * Note: **Not thread-safe.**
   */
  BasicCrossThreadPersistent& operator=(T* other) {
    AssignUnsafe(other);
    return *this;
  }

  // Assignment from member.
  template <typename U, typename MemberBarrierPolicy,
            typename MemberWeaknessTag, typename MemberCheckingPolicy,
            typename MemberStorageType,
            typename = std::enable_if_t<std::is_base_of<T, U>::value>>
  BasicCrossThreadPersistent& operator=(
      internal::BasicMember<U, MemberBarrierPolicy, MemberWeaknessTag,
                            MemberCheckingPolicy, MemberStorageType>
          member) {
    return operator=(member.Get());
  }

  /**
   * Assigns a nullptr.
   *
   * \returns the handle.
   */
  BasicCrossThreadPersistent& operator=(std::nullptr_t) {
    Clear();
    return *this;
  }

  /**
   * Assigns the sentinel pointer.
   *
   * \returns the handle.
   */
  BasicCrossThreadPersistent& operator=(SentinelPointer s) {
    PersistentRegionLock guard;
    AssignSafe(guard, s);
    return *this;
  }

  /**
   * Returns a pointer to the stored object.
   *
   * Note: **Not thread-safe.**
   *
   * \returns a pointer to the stored object.
   */
  // CFI cast exemption to allow passing SentinelPointer through T* and support
  // heterogeneous assignments between different Member and Persistent handles
  // based on their actual types.
  V8_CLANG_NO_SANITIZE("cfi-unrelated-cast") T* Get() const {
    return static_cast<T*>(const_cast<void*>(GetValue()));
  }

  /**
   * Clears the stored object.
   */
  void Clear() {
    PersistentRegionLock guard;
    AssignSafe(guard, nullptr);
  }

  /**
   * Returns a pointer to the stored object and releases it.
   *
   * Note: **Not thread-safe.**
   *
   * \returns a pointer to the stored object.
   */
  T* Release() {
    T* result = Get();
    Clear();
    return result;
  }

  /**
   * Conversio to boolean.
   *
   * Note: **Not thread-safe.**
   *
   * \returns true if an actual object has been stored and false otherwise.
   */
  explicit operator bool() const { return Get(); }

  /**
   * Conversion to object of type T.
   *
   * Note: **Not thread-safe.**
   *
   * \returns the object.
   */
  operator T*() const { return Get(); }

  /**
   * Dereferences the stored object.
   *
   * Note: **Not thread-safe.**
   */
  T* operator->() const { return Get(); }
  T& operator*() const { return *Get(); }

  template <typename U, typename OtherWeaknessPolicy = WeaknessPolicy,
            typename OtherLocationPolicy = LocationPolicy,
            typename OtherCheckingPolicy = CheckingPolicy>
  BasicCrossThreadPersistent<U, OtherWeaknessPolicy, OtherLocationPolicy,
                             OtherCheckingPolicy>
  To() const {
    using OtherBasicCrossThreadPersistent =
        BasicCrossThreadPersistent<U, OtherWeaknessPolicy, OtherLocationPolicy,
                                   OtherCheckingPolicy>;
    PersistentRegionLock guard;
    return OtherBasicCrossThreadPersistent(
        typename OtherBasicCrossThreadPersistent::UnsafeCtorTag(),
        static_cast<U*>(Get()));
  }

  template <typename U = T,
            typename = typename std::enable_if<!BasicCrossThreadPersistent<
                U, WeaknessPolicy>::IsStrongPersistent::value>::type>
  BasicCrossThreadPersistent<U, internal::StrongCrossThreadPersistentPolicy>
  Lock() const {
    return BasicCrossThreadPersistent<
        U, internal::StrongCrossThreadPersistentPolicy>(*this);
  }

 private:
  static bool IsValid(const void* ptr) {
    return ptr && ptr != kSentinelPointer;
  }

  static void TraceAsRoot(RootVisitor& root_visitor, const void* ptr) {
    root_visitor.Trace(*static_cast<const BasicCrossThreadPersistent*>(ptr));
  }

  void AssignUnsafe(T* ptr) {
    const void* old_value = GetValue();
    if (IsValid(old_value)) {
      PersistentRegionLock guard;
      old_value = GetValue();
      // The fast path check (IsValid()) does not acquire the lock. Reload
      // the value to ensure the reference has not been cleared.
      if (IsValid(old_value)) {
        CrossThreadPersistentRegion& region =
            this->GetPersistentRegion(old_value);
        if (IsValid(ptr) && (&region == &this->GetPersistentRegion(ptr))) {
          SetValue(ptr);
          this->CheckPointer(ptr);
          return;
        }
        region.FreeNode(GetNode());
        SetNode(nullptr);
      } else {
        CPPGC_DCHECK(!GetNode());
      }
    }
    SetValue(ptr);
    if (!IsValid(ptr)) return;
    PersistentRegionLock guard;
    SetNode(this->GetPersistentRegion(ptr).AllocateNode(this, &TraceAsRoot));
    this->CheckPointer(ptr);
  }

  void AssignSafe(PersistentRegionLock&, T* ptr) {
    PersistentRegionLock::AssertLocked();
    const void* old_value = GetValue();
    if (IsValid(old_value)) {
      CrossThreadPersistentRegion& region =
          this->GetPersistentRegion(old_value);
      if (IsValid(ptr) && (&region == &this->GetPersistentRegion(ptr))) {
        SetValue(ptr);
        this->CheckPointer(ptr);
        return;
      }
      region.FreeNode(GetNode());
      SetNode(nullptr);
    }
    SetValue(ptr);
    if (!IsValid(ptr)) return;
    SetNode(this->GetPersistentRegion(ptr).AllocateNode(this, &TraceAsRoot));
    this->CheckPointer(ptr);
  }

  void ClearFromGC() const {
    if (IsValid(GetValueFromGC())) {
      WeaknessPolicy::GetPersistentRegion(GetValueFromGC())
          .FreeNode(GetNodeFromGC());
      CrossThreadPersistentBase::ClearFromGC();
    }
  }

  // See Get() for details.
  V8_CLANG_NO_SANITIZE("cfi-unrelated-cast")
  T* GetFromGC() const {
    return static_cast<T*>(const_cast<void*>(GetValueFromGC()));
  }

  friend class internal::RootVisitor;
};

template <typename T, typename LocationPolicy, typename CheckingPolicy>
struct IsWeak<
    BasicCrossThreadPersistent<T, internal::WeakCrossThreadPersistentPolicy,
                               LocationPolicy, CheckingPolicy>>
    : std::true_type {};

}  // namespace internal

namespace subtle {

/**
 * **DO NOT USE: Has known caveats, see below.**
 *
 * CrossThreadPersistent allows retaining objects from threads other than the
 * thread the owning heap is operating on.
 *
 * Known caveats:
 * - Does not protect the heap owning an object from terminating.
 * - Reaching transitively through the graph is unsupported as objects may be
 *   moved concurrently on the thread owning the object.
 */
template <typename T>
using CrossThreadPersistent = internal::BasicCrossThreadPersistent<
    T, internal::StrongCrossThreadPersistentPolicy>;

/**
 * **DO NOT USE: Has known caveats, see below.**
 *
 * CrossThreadPersistent allows weakly retaining objects from threads other than
 * the thread the owning heap is operating on.
 *
 * Known caveats:
 * - Does not protect the heap owning an object from terminating.
 * - Reaching transitively through the graph is unsupported as objects may be
 *   moved concurrently on the thread owning the object.
 */
template <typename T>
using WeakCrossThreadPersistent = internal::BasicCrossThreadPersistent<
    T, internal::WeakCrossThreadPersistentPolicy>;

}  // namespace subtle
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_CROSS_THREAD_PERSISTENT_H_
                                                                                                                                                                                              node-23.7.0/deps/v8/include/cppgc/custom-space.h                                                    0000664 0000000 0000000 00000004626 14746647661 0021350 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_CUSTOM_SPACE_H_
#define INCLUDE_CPPGC_CUSTOM_SPACE_H_

#include <stddef.h>

namespace cppgc {

/**
 * Index identifying a custom space.
 */
struct CustomSpaceIndex {
  constexpr CustomSpaceIndex(size_t value) : value(value) {}  // NOLINT
  size_t value;
};

/**
 * Top-level base class for custom spaces. Users must inherit from CustomSpace
 * below.
 */
class CustomSpaceBase {
 public:
  virtual ~CustomSpaceBase() = default;
  virtual CustomSpaceIndex GetCustomSpaceIndex() const = 0;
  virtual bool IsCompactable() const = 0;
};

/**
 * Base class custom spaces should directly inherit from. The class inheriting
 * from `CustomSpace` must define `kSpaceIndex` as unique space index. These
 * indices need for form a sequence starting at 0.
 *
 * Example:
 * \code
 * class CustomSpace1 : public CustomSpace<CustomSpace1> {
 *  public:
 *   static constexpr CustomSpaceIndex kSpaceIndex = 0;
 * };
 * class CustomSpace2 : public CustomSpace<CustomSpace2> {
 *  public:
 *   static constexpr CustomSpaceIndex kSpaceIndex = 1;
 * };
 * \endcode
 */
template <typename ConcreteCustomSpace>
class CustomSpace : public CustomSpaceBase {
 public:
  /**
   * Compaction is only supported on spaces that manually manage slots
   * recording.
   */
  static constexpr bool kSupportsCompaction = false;

  CustomSpaceIndex GetCustomSpaceIndex() const final {
    return ConcreteCustomSpace::kSpaceIndex;
  }
  bool IsCompactable() const final {
    return ConcreteCustomSpace::kSupportsCompaction;
  }
};

/**
 * User-overridable trait that allows pinning types to custom spaces.
 */
template <typename T, typename = void>
struct SpaceTrait {
  using Space = void;
};

namespace internal {

template <typename CustomSpace>
struct IsAllocatedOnCompactableSpaceImpl {
  static constexpr bool value = CustomSpace::kSupportsCompaction;
};

template <>
struct IsAllocatedOnCompactableSpaceImpl<void> {
  // Non-custom spaces are by default not compactable.
  static constexpr bool value = false;
};

template <typename T>
struct IsAllocatedOnCompactableSpace {
 public:
  static constexpr bool value =
      IsAllocatedOnCompactableSpaceImpl<typename SpaceTrait<T>::Space>::value;
};

}  // namespace internal

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_CUSTOM_SPACE_H_
                                                                                                          node-23.7.0/deps/v8/include/cppgc/default-platform.h                                                0000664 0000000 0000000 00000004266 14746647661 0022213 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_DEFAULT_PLATFORM_H_
#define INCLUDE_CPPGC_DEFAULT_PLATFORM_H_

#include <memory>

#include "cppgc/platform.h"
#include "libplatform/libplatform.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {

/**
 * Platform provided by cppgc. Uses V8's DefaultPlatform provided by
 * libplatform internally. Exception: `GetForegroundTaskRunner()`, see below.
 */
class V8_EXPORT DefaultPlatform : public Platform {
 public:
  using IdleTaskSupport = v8::platform::IdleTaskSupport;
  explicit DefaultPlatform(
      int thread_pool_size = 0,
      IdleTaskSupport idle_task_support = IdleTaskSupport::kDisabled,
      std::unique_ptr<TracingController> tracing_controller = {})
      : v8_platform_(v8::platform::NewDefaultPlatform(
            thread_pool_size, idle_task_support,
            v8::platform::InProcessStackDumping::kDisabled,
            std::move(tracing_controller))) {}

  cppgc::PageAllocator* GetPageAllocator() override {
    return v8_platform_->GetPageAllocator();
  }

  double MonotonicallyIncreasingTime() override {
    return v8_platform_->MonotonicallyIncreasingTime();
  }

  std::shared_ptr<cppgc::TaskRunner> GetForegroundTaskRunner() override {
    // V8's default platform creates a new task runner when passed the
    // `v8::Isolate` pointer the first time. For non-default platforms this will
    // require getting the appropriate task runner.
    return v8_platform_->GetForegroundTaskRunner(kNoIsolate);
  }

  std::unique_ptr<cppgc::JobHandle> PostJob(
      cppgc::TaskPriority priority,
      std::unique_ptr<cppgc::JobTask> job_task) override {
    return v8_platform_->PostJob(priority, std::move(job_task));
  }

  TracingController* GetTracingController() override {
    return v8_platform_->GetTracingController();
  }

  v8::Platform* GetV8Platform() const { return v8_platform_.get(); }

 protected:
  static constexpr v8::Isolate* kNoIsolate = nullptr;

  std::unique_ptr<v8::Platform> v8_platform_;
};

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_DEFAULT_PLATFORM_H_
                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/include/cppgc/ephemeron-pair.h                                                  0000664 0000000 0000000 00000001444 14746647661 0021653 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_EPHEMERON_PAIR_H_
#define INCLUDE_CPPGC_EPHEMERON_PAIR_H_

#include "cppgc/liveness-broker.h"
#include "cppgc/member.h"

namespace cppgc {

/**
 * An ephemeron pair is used to conditionally retain an object.
 * The `value` will be kept alive only if the `key` is alive.
 */
template <typename K, typename V>
struct EphemeronPair {
  EphemeronPair(K* k, V* v) : key(k), value(v) {}
  WeakMember<K> key;
  Member<V> value;

  void ClearValueIfKeyIsDead(const LivenessBroker& broker) {
    if (!broker.IsHeapObjectAlive(key)) value = nullptr;
  }
};

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_EPHEMERON_PAIR_H_
                                                                                                                                                                                                                            node-23.7.0/deps/v8/include/cppgc/explicit-management.h                                             0000664 0000000 0000000 00000006452 14746647661 0022677 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_EXPLICIT_MANAGEMENT_H_
#define INCLUDE_CPPGC_EXPLICIT_MANAGEMENT_H_

#include <cstddef>

#include "cppgc/allocation.h"
#include "cppgc/internal/logging.h"
#include "cppgc/type-traits.h"

namespace cppgc {

class HeapHandle;

namespace subtle {

template <typename T>
void FreeUnreferencedObject(HeapHandle& heap_handle, T& object);
template <typename T>
bool Resize(T& object, AdditionalBytes additional_bytes);

}  // namespace subtle

namespace internal {

class ExplicitManagementImpl final {
 private:
  V8_EXPORT static void FreeUnreferencedObject(HeapHandle&, void*);
  V8_EXPORT static bool Resize(void*, size_t);

  template <typename T>
  friend void subtle::FreeUnreferencedObject(HeapHandle&, T&);
  template <typename T>
  friend bool subtle::Resize(T&, AdditionalBytes);
};
}  // namespace internal

namespace subtle {

/**
 * Informs the garbage collector that `object` can be immediately reclaimed. The
 * destructor may not be invoked immediately but only on next garbage
 * collection.
 *
 * It is up to the embedder to guarantee that no other object holds a reference
 * to `object` after calling `FreeUnreferencedObject()`. In case such a
 * reference exists, it's use results in a use-after-free.
 *
 * To aid in using the API, `FreeUnreferencedObject()` may be called from
 * destructors on objects that would be reclaimed in the same garbage collection
 * cycle.
 *
 * \param heap_handle The corresponding heap.
 * \param object Reference to an object that is of type `GarbageCollected` and
 *   should be immediately reclaimed.
 */
template <typename T>
void FreeUnreferencedObject(HeapHandle& heap_handle, T& object) {
  static_assert(IsGarbageCollectedTypeV<T>,
                "Object must be of type GarbageCollected.");
  internal::ExplicitManagementImpl::FreeUnreferencedObject(heap_handle,
                                                           &object);
}

/**
 * Tries to resize `object` of type `T` with additional bytes on top of
 * sizeof(T). Resizing is only useful with trailing inlined storage, see e.g.
 * `MakeGarbageCollected(AllocationHandle&, AdditionalBytes)`.
 *
 * `Resize()` performs growing or shrinking as needed and may skip the operation
 * for internal reasons, see return value.
 *
 * It is up to the embedder to guarantee that in case of shrinking a larger
 * object down, the reclaimed area is not used anymore. Any subsequent use
 * results in a use-after-free.
 *
 * The `object` must be live when calling `Resize()`.
 *
 * \param object Reference to an object that is of type `GarbageCollected` and
 *   should be resized.
 * \param additional_bytes Bytes in addition to sizeof(T) that the object should
 *   provide.
 * \returns true when the operation was successful and the result can be relied
 *   on, and false otherwise.
 */
template <typename T>
bool Resize(T& object, AdditionalBytes additional_bytes) {
  static_assert(IsGarbageCollectedTypeV<T>,
                "Object must be of type GarbageCollected.");
  return internal::ExplicitManagementImpl::Resize(
      &object, sizeof(T) + additional_bytes.value);
}

}  // namespace subtle
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_EXPLICIT_MANAGEMENT_H_
                                                                                                                                                                                                                      node-23.7.0/deps/v8/include/cppgc/garbage-collected.h                                               0000664 0000000 0000000 00000006710 14746647661 0022265 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_GARBAGE_COLLECTED_H_
#define INCLUDE_CPPGC_GARBAGE_COLLECTED_H_

#include "cppgc/internal/api-constants.h"
#include "cppgc/platform.h"
#include "cppgc/trace-trait.h"
#include "cppgc/type-traits.h"

namespace cppgc {

class Visitor;

/**
 * Base class for managed objects. Only descendent types of `GarbageCollected`
 * can be constructed using `MakeGarbageCollected()`. Must be inherited from as
 * left-most base class.
 *
 * Types inheriting from GarbageCollected must provide a method of
 * signature `void Trace(cppgc::Visitor*) const` that dispatchs all managed
 * pointers to the visitor and delegates to garbage-collected base classes.
 * The method must be virtual if the type is not directly a child of
 * GarbageCollected and marked as final.
 *
 * \code
 * // Example using final class.
 * class FinalType final : public GarbageCollected<FinalType> {
 *  public:
 *   void Trace(cppgc::Visitor* visitor) const {
 *     // Dispatch using visitor->Trace(...);
 *   }
 * };
 *
 * // Example using non-final base class.
 * class NonFinalBase : public GarbageCollected<NonFinalBase> {
 *  public:
 *   virtual void Trace(cppgc::Visitor*) const {}
 * };
 *
 * class FinalChild final : public NonFinalBase {
 *  public:
 *   void Trace(cppgc::Visitor* visitor) const final {
 *     // Dispatch using visitor->Trace(...);
 *     NonFinalBase::Trace(visitor);
 *   }
 * };
 * \endcode
 */
template <typename T>
class GarbageCollected {
 public:
  using IsGarbageCollectedTypeMarker = void;
  using ParentMostGarbageCollectedType = T;

  // Must use MakeGarbageCollected.
  void* operator new(size_t) = delete;
  void* operator new[](size_t) = delete;
  // The garbage collector is taking care of reclaiming the object. Also,
  // virtual destructor requires an unambiguous, accessible 'operator delete'.
  void operator delete(void*) {
#ifdef V8_ENABLE_CHECKS
    internal::Fatal(
        "Manually deleting a garbage collected object is not allowed");
#endif  // V8_ENABLE_CHECKS
  }
  void operator delete[](void*) = delete;

 protected:
  GarbageCollected() = default;
};

/**
 * Base class for managed mixin objects. Such objects cannot be constructed
 * directly but must be mixed into the inheritance hierarchy of a
 * GarbageCollected object.
 *
 * Types inheriting from GarbageCollectedMixin must override a virtual method
 * of signature `void Trace(cppgc::Visitor*) const` that dispatchs all managed
 * pointers to the visitor and delegates to base classes.
 *
 * \code
 * class Mixin : public GarbageCollectedMixin {
 *  public:
 *   void Trace(cppgc::Visitor* visitor) const override {
 *     // Dispatch using visitor->Trace(...);
 *   }
 * };
 * \endcode
 */
class GarbageCollectedMixin {
 public:
  using IsGarbageCollectedMixinTypeMarker = void;

  // Must use MakeGarbageCollected.
  void* operator new(size_t) = delete;
  void* operator new[](size_t) = delete;
  // The garbage collector is taking care of reclaiming the object.
  // Not override the non-array varaint of `delete` to not conflict with the
  // operator in GarbageCollected above.
  void operator delete[](void*) = delete;

  /**
   * This Trace method must be overriden by objects inheriting from
   * GarbageCollectedMixin.
   */
  virtual void Trace(cppgc::Visitor*) const {}
};

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_GARBAGE_COLLECTED_H_
                                                        node-23.7.0/deps/v8/include/cppgc/heap-consistency.h                                                0000664 0000000 0000000 00000027365 14746647661 0022226 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_HEAP_CONSISTENCY_H_
#define INCLUDE_CPPGC_HEAP_CONSISTENCY_H_

#include <cstddef>

#include "cppgc/internal/write-barrier.h"
#include "cppgc/macros.h"
#include "cppgc/member.h"
#include "cppgc/trace-trait.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {

class HeapHandle;

namespace subtle {

/**
 * **DO NOT USE: Use the appropriate managed types.**
 *
 * Consistency helpers that aid in maintaining a consistent internal state of
 * the garbage collector.
 */
class HeapConsistency final {
 public:
  using WriteBarrierParams = internal::WriteBarrier::Params;
  using WriteBarrierType = internal::WriteBarrier::Type;

  /**
   * Gets the required write barrier type for a specific write.
   *
   * \param slot Slot containing the pointer to the object. The slot itself
   *   must reside in an object that has been allocated using
   *   `MakeGarbageCollected()`.
   * \param value The pointer to the object. May be an interior pointer to an
   *   interface of the actual object.
   * \param params Parameters that may be used for actual write barrier calls.
   *   Only filled if return value indicates that a write barrier is needed. The
   *   contents of the `params` are an implementation detail.
   * \returns whether a write barrier is needed and which barrier to invoke.
   */
  static V8_INLINE WriteBarrierType GetWriteBarrierType(
      const void* slot, const void* value, WriteBarrierParams& params) {
    return internal::WriteBarrier::GetWriteBarrierType(slot, value, params);
  }

  /**
   * Gets the required write barrier type for a specific write. This override is
   * only used for all the BasicMember types.
   *
   * \param slot Slot containing the pointer to the object. The slot itself
   *   must reside in an object that has been allocated using
   *   `MakeGarbageCollected()`.
   * \param value The pointer to the object held via `BasicMember`.
   * \param params Parameters that may be used for actual write barrier calls.
   *   Only filled if return value indicates that a write barrier is needed. The
   *   contents of the `params` are an implementation detail.
   * \returns whether a write barrier is needed and which barrier to invoke.
   */
  template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
            typename CheckingPolicy, typename StorageType>
  static V8_INLINE WriteBarrierType GetWriteBarrierType(
      const internal::BasicMember<T, WeaknessTag, WriteBarrierPolicy,
                                  CheckingPolicy, StorageType>& value,
      WriteBarrierParams& params) {
    return internal::WriteBarrier::GetWriteBarrierType(
        value.GetRawSlot(), value.GetRawStorage(), params);
  }

  /**
   * Gets the required write barrier type for a specific write.
   *
   * \param slot Slot to some part of an object. The object must not necessarily
       have been allocated using `MakeGarbageCollected()` but can also live
       off-heap or on stack.
   * \param params Parameters that may be used for actual write barrier calls.
   *   Only filled if return value indicates that a write barrier is needed. The
   *   contents of the `params` are an implementation detail.
   * \param callback Callback returning the corresponding heap handle. The
   *   callback is only invoked if the heap cannot otherwise be figured out. The
   *   callback must not allocate.
   * \returns whether a write barrier is needed and which barrier to invoke.
   */
  template <typename HeapHandleCallback>
  static V8_INLINE WriteBarrierType
  GetWriteBarrierType(const void* slot, WriteBarrierParams& params,
                      HeapHandleCallback callback) {
    return internal::WriteBarrier::GetWriteBarrierType(slot, params, callback);
  }

  /**
   * Gets the required write barrier type for a specific write.
   * This version is meant to be used in conjunction with with a marking write
   * barrier barrier which doesn't consider the slot.
   *
   * \param value The pointer to the object. May be an interior pointer to an
   *   interface of the actual object.
   * \param params Parameters that may be used for actual write barrier calls.
   *   Only filled if return value indicates that a write barrier is needed. The
   *   contents of the `params` are an implementation detail.
   * \returns whether a write barrier is needed and which barrier to invoke.
   */
  static V8_INLINE WriteBarrierType
  GetWriteBarrierType(const void* value, WriteBarrierParams& params) {
    return internal::WriteBarrier::GetWriteBarrierType(value, params);
  }

  /**
   * Conservative Dijkstra-style write barrier that processes an object if it
   * has not yet been processed.
   *
   * \param params The parameters retrieved from `GetWriteBarrierType()`.
   * \param object The pointer to the object. May be an interior pointer to a
   *   an interface of the actual object.
   */
  static V8_INLINE void DijkstraWriteBarrier(const WriteBarrierParams& params,
                                             const void* object) {
    internal::WriteBarrier::DijkstraMarkingBarrier(params, object);
  }

  /**
   * Conservative Dijkstra-style write barrier that processes a range of
   * elements if they have not yet been processed.
   *
   * \param params The parameters retrieved from `GetWriteBarrierType()`.
   * \param first_element Pointer to the first element that should be processed.
   *   The slot itself must reside in an object that has been allocated using
   *   `MakeGarbageCollected()`.
   * \param element_size Size of the element in bytes.
   * \param number_of_elements Number of elements that should be processed,
   *   starting with `first_element`.
   * \param trace_callback The trace callback that should be invoked for each
   *   element if necessary.
   */
  static V8_INLINE void DijkstraWriteBarrierRange(
      const WriteBarrierParams& params, const void* first_element,
      size_t element_size, size_t number_of_elements,
      TraceCallback trace_callback) {
    internal::WriteBarrier::DijkstraMarkingBarrierRange(
        params, first_element, element_size, number_of_elements,
        trace_callback);
  }

  /**
   * Steele-style write barrier that re-processes an object if it has already
   * been processed.
   *
   * \param params The parameters retrieved from `GetWriteBarrierType()`.
   * \param object The pointer to the object which must point to an object that
   *   has been allocated using `MakeGarbageCollected()`. Interior pointers are
   *   not supported.
   */
  static V8_INLINE void SteeleWriteBarrier(const WriteBarrierParams& params,
                                           const void* object) {
    internal::WriteBarrier::SteeleMarkingBarrier(params, object);
  }

  /**
   * Generational barrier for maintaining consistency when running with multiple
   * generations.
   *
   * \param params The parameters retrieved from `GetWriteBarrierType()`.
   * \param slot Slot containing the pointer to the object. The slot itself
   *   must reside in an object that has been allocated using
   *   `MakeGarbageCollected()`.
   */
  static V8_INLINE void GenerationalBarrier(const WriteBarrierParams& params,
                                            const void* slot) {
    internal::WriteBarrier::GenerationalBarrier<
        internal::WriteBarrier::GenerationalBarrierType::kPreciseSlot>(params,
                                                                       slot);
  }

  /**
   * Generational barrier for maintaining consistency when running with multiple
   * generations. This version is used when slot contains uncompressed pointer.
   *
   * \param params The parameters retrieved from `GetWriteBarrierType()`.
   * \param slot Uncompressed slot containing the direct pointer to the object.
   * The slot itself must reside in an object that has been allocated using
   *   `MakeGarbageCollected()`.
   */
  static V8_INLINE void GenerationalBarrierForUncompressedSlot(
      const WriteBarrierParams& params, const void* uncompressed_slot) {
    internal::WriteBarrier::GenerationalBarrier<
        internal::WriteBarrier::GenerationalBarrierType::
            kPreciseUncompressedSlot>(params, uncompressed_slot);
  }

  /**
   * Generational barrier for source object that may contain outgoing pointers
   * to objects in young generation.
   *
   * \param params The parameters retrieved from `GetWriteBarrierType()`.
   * \param inner_pointer Pointer to the source object.
   */
  static V8_INLINE void GenerationalBarrierForSourceObject(
      const WriteBarrierParams& params, const void* inner_pointer) {
    internal::WriteBarrier::GenerationalBarrier<
        internal::WriteBarrier::GenerationalBarrierType::kImpreciseSlot>(
        params, inner_pointer);
  }

 private:
  HeapConsistency() = delete;
};

/**
 * Disallows garbage collection finalizations. Any garbage collection triggers
 * result in a crash when in this scope.
 *
 * Note that the garbage collector already covers paths that can lead to garbage
 * collections, so user code does not require checking
 * `IsGarbageCollectionAllowed()` before allocations.
 */
class V8_EXPORT V8_NODISCARD DisallowGarbageCollectionScope final {
  CPPGC_STACK_ALLOCATED();

 public:
  /**
   * \returns whether garbage collections are currently allowed.
   */
  static bool IsGarbageCollectionAllowed(HeapHandle& heap_handle);

  /**
   * Enters a disallow garbage collection scope. Must be paired with `Leave()`.
   * Prefer a scope instance of `DisallowGarbageCollectionScope`.
   *
   * \param heap_handle The corresponding heap.
   */
  static void Enter(HeapHandle& heap_handle);

  /**
   * Leaves a disallow garbage collection scope. Must be paired with `Enter()`.
   * Prefer a scope instance of `DisallowGarbageCollectionScope`.
   *
   * \param heap_handle The corresponding heap.
   */
  static void Leave(HeapHandle& heap_handle);

  /**
   * Constructs a scoped object that automatically enters and leaves a disallow
   * garbage collection scope based on its lifetime.
   *
   * \param heap_handle The corresponding heap.
   */
  explicit DisallowGarbageCollectionScope(HeapHandle& heap_handle);
  ~DisallowGarbageCollectionScope();

  DisallowGarbageCollectionScope(const DisallowGarbageCollectionScope&) =
      delete;
  DisallowGarbageCollectionScope& operator=(
      const DisallowGarbageCollectionScope&) = delete;

 private:
  HeapHandle& heap_handle_;
};

/**
 * Avoids invoking garbage collection finalizations. Already running garbage
 * collection phase are unaffected by this scope.
 *
 * Should only be used temporarily as the scope has an impact on memory usage
 * and follow up garbage collections.
 */
class V8_EXPORT V8_NODISCARD NoGarbageCollectionScope final {
  CPPGC_STACK_ALLOCATED();

 public:
  /**
   * Enters a no garbage collection scope. Must be paired with `Leave()`. Prefer
   * a scope instance of `NoGarbageCollectionScope`.
   *
   * \param heap_handle The corresponding heap.
   */
  static void Enter(HeapHandle& heap_handle);

  /**
   * Leaves a no garbage collection scope. Must be paired with `Enter()`. Prefer
   * a scope instance of `NoGarbageCollectionScope`.
   *
   * \param heap_handle The corresponding heap.
   */
  static void Leave(HeapHandle& heap_handle);

  /**
   * Constructs a scoped object that automatically enters and leaves a no
   * garbage collection scope based on its lifetime.
   *
   * \param heap_handle The corresponding heap.
   */
  explicit NoGarbageCollectionScope(HeapHandle& heap_handle);
  ~NoGarbageCollectionScope();

  NoGarbageCollectionScope(const NoGarbageCollectionScope&) = delete;
  NoGarbageCollectionScope& operator=(const NoGarbageCollectionScope&) = delete;

 private:
  HeapHandle& heap_handle_;
};

}  // namespace subtle
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_HEAP_CONSISTENCY_H_
                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/include/cppgc/heap-handle.h                                                     0000664 0000000 0000000 00000002411 14746647661 0021101 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_HEAP_HANDLE_H_
#define INCLUDE_CPPGC_HEAP_HANDLE_H_

#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {

namespace internal {
class HeapBase;
class WriteBarrierTypeForCagedHeapPolicy;
class WriteBarrierTypeForNonCagedHeapPolicy;
}  // namespace internal

/**
 * Opaque handle used for additional heap APIs.
 */
class HeapHandle {
 public:
  // Deleted copy ctor to avoid treating the type by value.
  HeapHandle(const HeapHandle&) = delete;
  HeapHandle& operator=(const HeapHandle&) = delete;

 private:
  HeapHandle() = default;

  V8_INLINE bool is_incremental_marking_in_progress() const {
    return is_incremental_marking_in_progress_;
  }

  V8_INLINE bool is_young_generation_enabled() const {
    return is_young_generation_enabled_;
  }

  bool is_incremental_marking_in_progress_ = false;
  bool is_young_generation_enabled_ = false;

  friend class internal::HeapBase;
  friend class internal::WriteBarrierTypeForCagedHeapPolicy;
  friend class internal::WriteBarrierTypeForNonCagedHeapPolicy;
};

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_HEAP_HANDLE_H_
                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/include/cppgc/heap-state.h                                                      0000664 0000000 0000000 00000005110 14746647661 0020765 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_HEAP_STATE_H_
#define INCLUDE_CPPGC_HEAP_STATE_H_

#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {

class HeapHandle;

namespace subtle {

/**
 * Helpers to peek into heap-internal state.
 */
class V8_EXPORT HeapState final {
 public:
  /**
   * Returns whether the garbage collector is marking. This API is experimental
   * and is expected to be removed in future.
   *
   * \param heap_handle The corresponding heap.
   * \returns true if the garbage collector is currently marking, and false
   *   otherwise.
   */
  static bool IsMarking(const HeapHandle& heap_handle);

  /*
   * Returns whether the garbage collector is sweeping. This API is experimental
   * and is expected to be removed in future.
   *
   * \param heap_handle The corresponding heap.
   * \returns true if the garbage collector is currently sweeping, and false
   *   otherwise.
   */
  static bool IsSweeping(const HeapHandle& heap_handle);

  /*
   * Returns whether the garbage collector is currently sweeping on the thread
   * owning this heap. This API allows the caller to determine whether it has
   * been called from a destructor of a managed object. This API is experimental
   * and may be removed in future.
   *
   * \param heap_handle The corresponding heap.
   * \returns true if the garbage collector is currently sweeping on this
   *   thread, and false otherwise.
   */
  static bool IsSweepingOnOwningThread(const HeapHandle& heap_handle);

  /**
   * Returns whether the garbage collector is in the atomic pause, i.e., the
   * mutator is stopped from running. This API is experimental and is expected
   * to be removed in future.
   *
   * \param heap_handle The corresponding heap.
   * \returns true if the garbage collector is currently in the atomic pause,
   *   and false otherwise.
   */
  static bool IsInAtomicPause(const HeapHandle& heap_handle);

  /**
   * Returns whether the last garbage collection was finalized conservatively
   * (i.e., with a non-empty stack). This API is experimental and is expected to
   * be removed in future.
   *
   * \param heap_handle The corresponding heap.
   * \returns true if the last garbage collection was finalized conservatively,
   * and false otherwise.
   */
  static bool PreviousGCWasConservative(const HeapHandle& heap_handle);

 private:
  HeapState() = delete;
};

}  // namespace subtle
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_HEAP_STATE_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/include/cppgc/heap-statistics.h                                                 0000664 0000000 0000000 00000007777 14746647661 0022064 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_HEAP_STATISTICS_H_
#define INCLUDE_CPPGC_HEAP_STATISTICS_H_

#include <cstddef>
#include <cstdint>
#include <string>
#include <vector>

namespace cppgc {

/**
 * `HeapStatistics` contains memory consumption and utilization statistics for a
 * cppgc heap.
 */
struct HeapStatistics final {
  /**
   * Specifies the detail level of the heap statistics. Brief statistics contain
   * only the top-level allocated and used memory statistics for the entire
   * heap. Detailed statistics also contain a break down per space and page, as
   * well as freelist statistics and object type histograms. Note that used
   * memory reported by brief statistics and detailed statistics might differ
   * slightly.
   */
  enum DetailLevel : uint8_t {
    kBrief,
    kDetailed,
  };

  /**
   * Object statistics for a single type.
   */
  struct ObjectStatsEntry {
    /**
     * Number of allocated bytes.
     */
    size_t allocated_bytes;
    /**
     * Number of allocated objects.
     */
    size_t object_count;
  };

  /**
   * Page granularity statistics. For each page the statistics record the
   * allocated memory size and overall used memory size for the page.
   */
  struct PageStatistics {
    /** Overall committed amount of memory for the page. */
    size_t committed_size_bytes = 0;
    /** Resident amount of memory held by the page. */
    size_t resident_size_bytes = 0;
    /** Amount of memory actually used on the page. */
    size_t used_size_bytes = 0;
    /** Statistics for object allocated on the page. Filled only when
     * NameProvider::SupportsCppClassNamesAsObjectNames() is true. */
    std::vector<ObjectStatsEntry> object_statistics;
  };

  /**
   * Statistics of the freelist (used only in non-large object spaces). For
   * each bucket in the freelist the statistics record the bucket size, the
   * number of freelist entries in the bucket, and the overall allocated memory
   * consumed by these freelist entries.
   */
  struct FreeListStatistics {
    /** bucket sizes in the freelist. */
    std::vector<size_t> bucket_size;
    /** number of freelist entries per bucket. */
    std::vector<size_t> free_count;
    /** memory size consumed by freelist entries per size. */
    std::vector<size_t> free_size;
  };

  /**
   * Space granularity statistics. For each space the statistics record the
   * space name, the amount of allocated memory and overall used memory for the
   * space. The statistics also contain statistics for each of the space's
   * pages, its freelist and the objects allocated on the space.
   */
  struct SpaceStatistics {
    /** The space name */
    std::string name;
    /** Overall committed amount of memory for the heap. */
    size_t committed_size_bytes = 0;
    /** Resident amount of memory held by the heap. */
    size_t resident_size_bytes = 0;
    /** Amount of memory actually used on the space. */
    size_t used_size_bytes = 0;
    /** Statistics for each of the pages in the space. */
    std::vector<PageStatistics> page_stats;
    /** Statistics for the freelist of the space. */
    FreeListStatistics free_list_stats;
  };

  /** Overall committed amount of memory for the heap. */
  size_t committed_size_bytes = 0;
  /** Resident amount of memory held by the heap. */
  size_t resident_size_bytes = 0;
  /** Amount of memory actually used on the heap. */
  size_t used_size_bytes = 0;
  /** Memory retained in the page pool, not used directly by the heap. */
  size_t pooled_memory_size_bytes = 0;
  /** Detail level of this HeapStatistics. */
  DetailLevel detail_level;

  /** Statistics for each of the spaces in the heap. Filled only when
   * `detail_level` is `DetailLevel::kDetailed`. */
  std::vector<SpaceStatistics> space_stats;

  /**
   * Vector of `cppgc::GarbageCollected` type names.
   */
  std::vector<std::string> type_names;
};

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_HEAP_STATISTICS_H_
 node-23.7.0/deps/v8/include/cppgc/heap.h                                                            0000664 0000000 0000000 00000013312 14746647661 0017652 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_HEAP_H_
#define INCLUDE_CPPGC_HEAP_H_

#include <cstddef>
#include <cstdint>
#include <memory>
#include <vector>

#include "cppgc/common.h"
#include "cppgc/custom-space.h"
#include "cppgc/platform.h"
#include "v8config.h"  // NOLINT(build/include_directory)

/**
 * cppgc - A C++ garbage collection library.
 */
namespace cppgc {

class AllocationHandle;
class HeapHandle;

/**
 * Implementation details of cppgc. Those details are considered internal and
 * may change at any point in time without notice. Users should never rely on
 * the contents of this namespace.
 */
namespace internal {
class Heap;
}  // namespace internal

class V8_EXPORT Heap {
 public:
  /**
   * Specifies the stack state the embedder is in.
   */
  using StackState = EmbedderStackState;

  /**
   * Specifies whether conservative stack scanning is supported.
   */
  enum class StackSupport : uint8_t {
    /**
     * Conservative stack scan is supported.
     */
    kSupportsConservativeStackScan,
    /**
     * Conservative stack scan is not supported. Embedders may use this option
     * when using custom infrastructure that is unsupported by the library.
     */
    kNoConservativeStackScan,
  };

  /**
   * Specifies supported marking types.
   */
  enum class MarkingType : uint8_t {
    /**
     * Atomic stop-the-world marking. This option does not require any write
     * barriers but is the most intrusive in terms of jank.
     */
    kAtomic,
    /**
     * Incremental marking interleaves marking with the rest of the application
     * workload on the same thread.
     */
    kIncremental,
    /**
     * Incremental and concurrent marking.
     */
    kIncrementalAndConcurrent
  };

  /**
   * Specifies supported sweeping types.
   */
  enum class SweepingType : uint8_t {
    /**
     * Atomic stop-the-world sweeping. All of sweeping is performed at once.
     */
    kAtomic,
    /**
     * Incremental sweeping interleaves sweeping with the rest of the
     * application workload on the same thread.
     */
    kIncremental,
    /**
     * Incremental and concurrent sweeping. Sweeping is split and interleaved
     * with the rest of the application.
     */
    kIncrementalAndConcurrent
  };

  /**
   * Constraints for a Heap setup.
   */
  struct ResourceConstraints {
    /**
     * Allows the heap to grow to some initial size in bytes before triggering
     * garbage collections. This is useful when it is known that applications
     * need a certain minimum heap to run to avoid repeatedly invoking the
     * garbage collector when growing the heap.
     */
    size_t initial_heap_size_bytes = 0;
  };

  /**
   * Options specifying Heap properties (e.g. custom spaces) when initializing a
   * heap through `Heap::Create()`.
   */
  struct HeapOptions {
    /**
     * Creates reasonable defaults for instantiating a Heap.
     *
     * \returns the HeapOptions that can be passed to `Heap::Create()`.
     */
    static HeapOptions Default() { return {}; }

    /**
     * Custom spaces added to heap are required to have indices forming a
     * numbered sequence starting at 0, i.e., their `kSpaceIndex` must
     * correspond to the index they reside in the vector.
     */
    std::vector<std::unique_ptr<CustomSpaceBase>> custom_spaces;

    /**
     * Specifies whether conservative stack scan is supported. When conservative
     * stack scan is not supported, the collector may try to invoke
     * garbage collections using non-nestable task, which are guaranteed to have
     * no interesting stack, through the provided Platform. If such tasks are
     * not supported by the Platform, the embedder must take care of invoking
     * the GC through `ForceGarbageCollectionSlow()`.
     */
    StackSupport stack_support = StackSupport::kSupportsConservativeStackScan;

    /**
     * Specifies which types of marking are supported by the heap.
     */
    MarkingType marking_support = MarkingType::kIncrementalAndConcurrent;

    /**
     * Specifies which types of sweeping are supported by the heap.
     */
    SweepingType sweeping_support = SweepingType::kIncrementalAndConcurrent;

    /**
     * Resource constraints specifying various properties that the internal
     * GC scheduler follows.
     */
    ResourceConstraints resource_constraints;
  };

  /**
   * Creates a new heap that can be used for object allocation.
   *
   * \param platform implemented and provided by the embedder.
   * \param options HeapOptions specifying various properties for the Heap.
   * \returns a new Heap instance.
   */
  static std::unique_ptr<Heap> Create(
      std::shared_ptr<Platform> platform,
      HeapOptions options = HeapOptions::Default());

  virtual ~Heap() = default;

  /**
   * Forces garbage collection.
   *
   * \param source String specifying the source (or caller) triggering a
   *   forced garbage collection.
   * \param reason String specifying the reason for the forced garbage
   *   collection.
   * \param stack_state The embedder stack state, see StackState.
   */
  void ForceGarbageCollectionSlow(
      const char* source, const char* reason,
      StackState stack_state = StackState::kMayContainHeapPointers);

  /**
   * \returns the opaque handle for allocating objects using
   * `MakeGarbageCollected()`.
   */
  AllocationHandle& GetAllocationHandle();

  /**
   * \returns the opaque heap handle which may be used to refer to this heap in
   *   other APIs. Valid as long as the underlying `Heap` is alive.
   */
  HeapHandle& GetHeapHandle();

 private:
  Heap() = default;

  friend class internal::Heap;
};

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_HEAP_H_
                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/include/cppgc/internal/                                                         0000775 0000000 0000000 00000000000 14746647661 0020400 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/include/cppgc/internal/api-constants.h                                          0000664 0000000 0000000 00000006074 14746647661 0023343 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_API_CONSTANTS_H_
#define INCLUDE_CPPGC_INTERNAL_API_CONSTANTS_H_

#include <cstddef>
#include <cstdint>

#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {
namespace internal {

// Embedders should not rely on this code!

// Internal constants to avoid exposing internal types on the API surface.
namespace api_constants {

constexpr size_t kKB = 1024;
constexpr size_t kMB = kKB * 1024;
constexpr size_t kGB = kMB * 1024;

// Offset of the uint16_t bitfield from the payload contaning the
// in-construction bit. This is subtracted from the payload pointer to get
// to the right bitfield.
static constexpr size_t kFullyConstructedBitFieldOffsetFromPayload =
    2 * sizeof(uint16_t);
// Mask for in-construction bit.
static constexpr uint16_t kFullyConstructedBitMask = uint16_t{1};

static constexpr size_t kPageSizeBits = 17;
static constexpr size_t kPageSize = size_t{1} << kPageSizeBits;

#if defined(V8_HOST_ARCH_ARM64) && defined(V8_OS_DARWIN)
constexpr size_t kGuardPageSize = 0;
#elif defined(V8_HOST_ARCH_PPC64)
constexpr size_t kGuardPageSize = 0;
#elif defined(V8_HOST_ARCH_LOONG64) || defined(V8_HOST_ARCH_MIPS64)
constexpr size_t kGuardPageSize = 0;
#else
constexpr size_t kGuardPageSize = 4096;
#endif

static constexpr size_t kLargeObjectSizeThreshold = kPageSize / 2;

#if defined(CPPGC_POINTER_COMPRESSION)
#if defined(CPPGC_ENABLE_LARGER_CAGE)
constexpr unsigned kPointerCompressionShift = 3;
#else   // !defined(CPPGC_ENABLE_LARGER_CAGE)
constexpr unsigned kPointerCompressionShift = 1;
#endif  // !defined(CPPGC_ENABLE_LARGER_CAGE)
#endif  // !defined(CPPGC_POINTER_COMPRESSION)

#if defined(CPPGC_CAGED_HEAP)
#if defined(CPPGC_2GB_CAGE)
constexpr size_t kCagedHeapDefaultReservationSize =
    static_cast<size_t>(2) * kGB;
constexpr size_t kCagedHeapMaxReservationSize =
    kCagedHeapDefaultReservationSize;
#else  // !defined(CPPGC_2GB_CAGE)
constexpr size_t kCagedHeapDefaultReservationSize =
    static_cast<size_t>(4) * kGB;
#if defined(CPPGC_POINTER_COMPRESSION)
constexpr size_t kCagedHeapMaxReservationSize =
    size_t{1} << (31 + kPointerCompressionShift);
#else   // !defined(CPPGC_POINTER_COMPRESSION)
constexpr size_t kCagedHeapMaxReservationSize =
    kCagedHeapDefaultReservationSize;
#endif  // !defined(CPPGC_POINTER_COMPRESSION)
#endif  // !defined(CPPGC_2GB_CAGE)
constexpr size_t kCagedHeapReservationAlignment = kCagedHeapMaxReservationSize;
#endif  // defined(CPPGC_CAGED_HEAP)

static constexpr size_t kDefaultAlignment = sizeof(void*);

// Maximum support alignment for a type as in `alignof(T)`.
static constexpr size_t kMaxSupportedAlignment = 2 * kDefaultAlignment;

// Granularity of heap allocations.
constexpr size_t kAllocationGranularity = sizeof(void*);

// Default cacheline size.
constexpr size_t kCachelineSize = 64;

}  // namespace api_constants

}  // namespace internal
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_INTERNAL_API_CONSTANTS_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/include/cppgc/internal/atomic-entry-flag.h                                      0000664 0000000 0000000 00000003343 14746647661 0024076 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_ATOMIC_ENTRY_FLAG_H_
#define INCLUDE_CPPGC_INTERNAL_ATOMIC_ENTRY_FLAG_H_

#include <atomic>

namespace cppgc {
namespace internal {

// A flag which provides a fast check whether a scope may be entered on the
// current thread, without needing to access thread-local storage or mutex.  Can
// have false positives (i.e., spuriously report that it might be entered), so
// it is expected that this will be used in tandem with a precise check that the
// scope is in fact entered on that thread.
//
// Example:
//   g_frobnicating_flag.MightBeEntered() &&
//   ThreadLocalFrobnicator().IsFrobnicating()
//
// Relaxed atomic operations are sufficient, since:
// - all accesses remain atomic
// - each thread must observe its own operations in order
// - no thread ever exits the flag more times than it enters (if used correctly)
// And so if a thread observes zero, it must be because it has observed an equal
// number of exits as entries.
class AtomicEntryFlag final {
 public:
  void Enter() { entries_.fetch_add(1, std::memory_order_relaxed); }
  void Exit() { entries_.fetch_sub(1, std::memory_order_relaxed); }

  // Returns false only if the current thread is not between a call to Enter
  // and a call to Exit. Returns true if this thread or another thread may
  // currently be in the scope guarded by this flag.
  bool MightBeEntered() const {
    return entries_.load(std::memory_order_relaxed) != 0;
  }

 private:
  std::atomic_int entries_{0};
};

}  // namespace internal
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_INTERNAL_ATOMIC_ENTRY_FLAG_H_
                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/include/cppgc/internal/base-page-handle.h                                       0000664 0000000 0000000 00000002700 14746647661 0023625 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_BASE_PAGE_HANDLE_H_
#define INCLUDE_CPPGC_INTERNAL_BASE_PAGE_HANDLE_H_

#include "cppgc/heap-handle.h"
#include "cppgc/internal/api-constants.h"
#include "cppgc/internal/logging.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {
namespace internal {

// The class is needed in the header to allow for fast access to HeapHandle in
// the write barrier.
class BasePageHandle {
 public:
  static V8_INLINE BasePageHandle* FromPayload(void* payload) {
    return reinterpret_cast<BasePageHandle*>(
        (reinterpret_cast<uintptr_t>(payload) &
         ~(api_constants::kPageSize - 1)) +
        api_constants::kGuardPageSize);
  }
  static V8_INLINE const BasePageHandle* FromPayload(const void* payload) {
    return FromPayload(const_cast<void*>(payload));
  }

  HeapHandle& heap_handle() { return heap_handle_; }
  const HeapHandle& heap_handle() const { return heap_handle_; }

 protected:
  explicit BasePageHandle(HeapHandle& heap_handle) : heap_handle_(heap_handle) {
    CPPGC_DCHECK(reinterpret_cast<uintptr_t>(this) % api_constants::kPageSize ==
                 api_constants::kGuardPageSize);
  }

  HeapHandle& heap_handle_;
};

}  // namespace internal
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_INTERNAL_BASE_PAGE_HANDLE_H_
                                                                node-23.7.0/deps/v8/include/cppgc/internal/caged-heap-local-data.h                                  0000664 0000000 0000000 00000007160 14746647661 0024532 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_CAGED_HEAP_LOCAL_DATA_H_
#define INCLUDE_CPPGC_INTERNAL_CAGED_HEAP_LOCAL_DATA_H_

#include <array>
#include <cstddef>
#include <cstdint>

#include "cppgc/internal/api-constants.h"
#include "cppgc/internal/caged-heap.h"
#include "cppgc/internal/logging.h"
#include "cppgc/platform.h"
#include "v8config.h"  // NOLINT(build/include_directory)

#if __cpp_lib_bitopts
#include <bit>
#endif  // __cpp_lib_bitopts

#if defined(CPPGC_CAGED_HEAP)

namespace cppgc {
namespace internal {

class HeapBase;
class HeapBaseHandle;

#if defined(CPPGC_YOUNG_GENERATION)

// AgeTable is the bytemap needed for the fast generation check in the write
// barrier. AgeTable contains entries that correspond to 4096 bytes memory
// regions (cards). Each entry in the table represents generation of the objects
// that reside on the corresponding card (young, old or mixed).
class V8_EXPORT AgeTable final {
  static constexpr size_t kRequiredSize = 1 * api_constants::kMB;
  static constexpr size_t kAllocationGranularity =
      api_constants::kAllocationGranularity;

 public:
  // Represents age of the objects living on a single card.
  enum class Age : uint8_t { kOld, kYoung, kMixed };
  // When setting age for a range, consider or ignore ages of the adjacent
  // cards.
  enum class AdjacentCardsPolicy : uint8_t { kConsider, kIgnore };

  static constexpr size_t kCardSizeInBytes =
      api_constants::kCagedHeapDefaultReservationSize / kRequiredSize;

  static constexpr size_t CalculateAgeTableSizeForHeapSize(size_t heap_size) {
    return heap_size / kCardSizeInBytes;
  }

  void SetAge(uintptr_t cage_offset, Age age) {
    table_[card(cage_offset)] = age;
  }

  V8_INLINE Age GetAge(uintptr_t cage_offset) const {
    return table_[card(cage_offset)];
  }

  void SetAgeForRange(uintptr_t cage_offset_begin, uintptr_t cage_offset_end,
                      Age age, AdjacentCardsPolicy adjacent_cards_policy);

  Age GetAgeForRange(uintptr_t cage_offset_begin,
                     uintptr_t cage_offset_end) const;

  void ResetForTesting();

 private:
  V8_INLINE size_t card(uintptr_t offset) const {
    constexpr size_t kGranularityBits =
#if __cpp_lib_bitopts
        std::countr_zero(static_cast<uint32_t>(kCardSizeInBytes));
#elif V8_HAS_BUILTIN_CTZ
        __builtin_ctz(static_cast<uint32_t>(kCardSizeInBytes));
#else   //! V8_HAS_BUILTIN_CTZ
        // Hardcode and check with assert.
#if defined(CPPGC_2GB_CAGE)
        11;
#else   // !defined(CPPGC_2GB_CAGE)
        12;
#endif  // !defined(CPPGC_2GB_CAGE)
#endif  // !V8_HAS_BUILTIN_CTZ
    static_assert((1 << kGranularityBits) == kCardSizeInBytes);
    const size_t entry = offset >> kGranularityBits;
    CPPGC_DCHECK(CagedHeapBase::GetAgeTableSize() > entry);
    return entry;
  }

#if defined(V8_CC_GNU)
  // gcc disallows flexible arrays in otherwise empty classes.
  Age table_[0];
#else   // !defined(V8_CC_GNU)
  Age table_[];
#endif  // !defined(V8_CC_GNU)
};

#endif  // CPPGC_YOUNG_GENERATION

struct CagedHeapLocalData final {
  V8_INLINE static CagedHeapLocalData& Get() {
    return *reinterpret_cast<CagedHeapLocalData*>(CagedHeapBase::GetBase());
  }

  static constexpr size_t CalculateLocalDataSizeForHeapSize(size_t heap_size) {
    return AgeTable::CalculateAgeTableSizeForHeapSize(heap_size);
  }

#if defined(CPPGC_YOUNG_GENERATION)
  AgeTable age_table;
#endif
};

}  // namespace internal
}  // namespace cppgc

#endif  // defined(CPPGC_CAGED_HEAP)

#endif  // INCLUDE_CPPGC_INTERNAL_CAGED_HEAP_LOCAL_DATA_H_
                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/include/cppgc/internal/caged-heap.h                                             0000664 0000000 0000000 00000004330 14746647661 0022527 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_CAGED_HEAP_H_
#define INCLUDE_CPPGC_INTERNAL_CAGED_HEAP_H_

#include <climits>
#include <cstddef>

#include "cppgc/internal/api-constants.h"
#include "cppgc/internal/base-page-handle.h"
#include "v8config.h"  // NOLINT(build/include_directory)

#if defined(CPPGC_CAGED_HEAP)

namespace cppgc {
namespace internal {

class V8_EXPORT CagedHeapBase {
 public:
  V8_INLINE static uintptr_t OffsetFromAddress(const void* address) {
    return reinterpret_cast<uintptr_t>(address) &
           (api_constants::kCagedHeapReservationAlignment - 1);
  }

  V8_INLINE static bool IsWithinCage(const void* address) {
    CPPGC_DCHECK(g_heap_base_);
    return (reinterpret_cast<uintptr_t>(address) &
            ~(api_constants::kCagedHeapReservationAlignment - 1)) ==
           g_heap_base_;
  }

  V8_INLINE static bool AreWithinCage(const void* addr1, const void* addr2) {
#if defined(CPPGC_2GB_CAGE)
    static constexpr size_t kHeapBaseShift = sizeof(uint32_t) * CHAR_BIT - 1;
#else   //! defined(CPPGC_2GB_CAGE)
#if defined(CPPGC_POINTER_COMPRESSION)
    static constexpr size_t kHeapBaseShift =
        31 + api_constants::kPointerCompressionShift;
#else   // !defined(CPPGC_POINTER_COMPRESSION)
    static constexpr size_t kHeapBaseShift = sizeof(uint32_t) * CHAR_BIT;
#endif  // !defined(CPPGC_POINTER_COMPRESSION)
#endif  //! defined(CPPGC_2GB_CAGE)
    static_assert((static_cast<size_t>(1) << kHeapBaseShift) ==
                  api_constants::kCagedHeapMaxReservationSize);
    CPPGC_DCHECK(g_heap_base_);
    return !(((reinterpret_cast<uintptr_t>(addr1) ^ g_heap_base_) |
              (reinterpret_cast<uintptr_t>(addr2) ^ g_heap_base_)) >>
             kHeapBaseShift);
  }

  V8_INLINE static uintptr_t GetBase() { return g_heap_base_; }
  V8_INLINE static size_t GetAgeTableSize() { return g_age_table_size_; }

 private:
  friend class CagedHeap;

  static uintptr_t g_heap_base_;
  static size_t g_age_table_size_;
};

}  // namespace internal
}  // namespace cppgc

#endif  // defined(CPPGC_CAGED_HEAP)

#endif  // INCLUDE_CPPGC_INTERNAL_CAGED_HEAP_H_
                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/include/cppgc/internal/compiler-specific.h                                      0000664 0000000 0000000 00000002774 14746647661 0024160 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_COMPILER_SPECIFIC_H_
#define INCLUDE_CPPGC_INTERNAL_COMPILER_SPECIFIC_H_

#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {

#if defined(__has_attribute)
#define CPPGC_HAS_ATTRIBUTE(FEATURE) __has_attribute(FEATURE)
#else
#define CPPGC_HAS_ATTRIBUTE(FEATURE) 0
#endif

#if defined(__has_cpp_attribute)
#define CPPGC_HAS_CPP_ATTRIBUTE(FEATURE) __has_cpp_attribute(FEATURE)
#else
#define CPPGC_HAS_CPP_ATTRIBUTE(FEATURE) 0
#endif

// [[no_unique_address]] comes in C++20 but supported in clang with -std >=
// c++11.
#if defined(V8_CC_MSVC) && CPPGC_HAS_CPP_ATTRIBUTE(msvc::no_unique_address)
// Unfortunately MSVC ignores [[no_unique_address]] (see
// https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/#msvc-extensions-and-abi),
// and clang-cl matches it for ABI compatibility reasons. We need to prefer
// [[msvc::no_unique_address]] when available if we actually want any effect.
#define CPPGC_NO_UNIQUE_ADDRESS [[msvc::no_unique_address]]
#elif CPPGC_HAS_CPP_ATTRIBUTE(no_unique_address)
#define CPPGC_NO_UNIQUE_ADDRESS [[no_unique_address]]
#else
#define CPPGC_NO_UNIQUE_ADDRESS
#endif

#if CPPGC_HAS_ATTRIBUTE(unused)
#define CPPGC_UNUSED __attribute__((unused))
#else
#define CPPGC_UNUSED
#endif

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_INTERNAL_COMPILER_SPECIFIC_H_
    node-23.7.0/deps/v8/include/cppgc/internal/finalizer-trait.h                                        0000664 0000000 0000000 00000005140 14746647661 0023655 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_FINALIZER_TRAIT_H_
#define INCLUDE_CPPGC_INTERNAL_FINALIZER_TRAIT_H_

#include <type_traits>

#include "cppgc/type-traits.h"

namespace cppgc {
namespace internal {

using FinalizationCallback = void (*)(void*);

template <typename T, typename = void>
struct HasFinalizeGarbageCollectedObject : std::false_type {};

template <typename T>
struct HasFinalizeGarbageCollectedObject<
    T,
    std::void_t<decltype(std::declval<T>().FinalizeGarbageCollectedObject())>>
    : std::true_type {};

// The FinalizerTraitImpl specifies how to finalize objects.
template <typename T, bool isFinalized>
struct FinalizerTraitImpl;

template <typename T>
struct FinalizerTraitImpl<T, true> {
 private:
  // Dispatch to custom FinalizeGarbageCollectedObject().
  struct Custom {
    static void Call(void* obj) {
      static_cast<T*>(obj)->FinalizeGarbageCollectedObject();
    }
  };

  // Dispatch to regular destructor.
  struct Destructor {
    static void Call(void* obj) { static_cast<T*>(obj)->~T(); }
  };

  using FinalizeImpl =
      std::conditional_t<HasFinalizeGarbageCollectedObject<T>::value, Custom,
                         Destructor>;

 public:
  static void Finalize(void* obj) {
    static_assert(sizeof(T), "T must be fully defined");
    FinalizeImpl::Call(obj);
  }
};

template <typename T>
struct FinalizerTraitImpl<T, false> {
  static void Finalize(void* obj) {
    static_assert(sizeof(T), "T must be fully defined");
  }
};

// The FinalizerTrait is used to determine if a type requires finalization and
// what finalization means.
template <typename T>
struct FinalizerTrait {
 private:
  // Object has a finalizer if it has
  // - a custom FinalizeGarbageCollectedObject method, or
  // - a destructor.
  static constexpr bool kNonTrivialFinalizer =
      internal::HasFinalizeGarbageCollectedObject<T>::value ||
      !std::is_trivially_destructible<typename std::remove_cv<T>::type>::value;

  static void Finalize(void* obj) {
    internal::FinalizerTraitImpl<T, kNonTrivialFinalizer>::Finalize(obj);
  }

 public:
  static constexpr bool HasFinalizer() { return kNonTrivialFinalizer; }

  // The callback used to finalize an object of type T.
  static constexpr FinalizationCallback kCallback =
      kNonTrivialFinalizer ? Finalize : nullptr;
};

template <typename T>
constexpr FinalizationCallback FinalizerTrait<T>::kCallback;

}  // namespace internal
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_INTERNAL_FINALIZER_TRAIT_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/include/cppgc/internal/gc-info.h                                                0000664 0000000 0000000 00000014372 14746647661 0022102 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_GC_INFO_H_
#define INCLUDE_CPPGC_INTERNAL_GC_INFO_H_

#include <atomic>
#include <cstdint>
#include <type_traits>

#include "cppgc/internal/finalizer-trait.h"
#include "cppgc/internal/logging.h"
#include "cppgc/internal/name-trait.h"
#include "cppgc/trace-trait.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {
namespace internal {

using GCInfoIndex = uint16_t;

struct V8_EXPORT EnsureGCInfoIndexTrait final {
  // Acquires a new GC info object and updates `registered_index` with the index
  // that identifies that new info accordingly.
  template <typename T>
  V8_INLINE static GCInfoIndex EnsureIndex(
      std::atomic<GCInfoIndex>& registered_index) {
    return EnsureGCInfoIndexTraitDispatch<T>{}(registered_index);
  }

 private:
  template <typename T, bool = FinalizerTrait<T>::HasFinalizer(),
            bool = NameTrait<T>::HasNonHiddenName()>
  struct EnsureGCInfoIndexTraitDispatch;

  static GCInfoIndex V8_PRESERVE_MOST
  EnsureGCInfoIndex(std::atomic<GCInfoIndex>&, TraceCallback,
                    FinalizationCallback, NameCallback);
  static GCInfoIndex V8_PRESERVE_MOST EnsureGCInfoIndex(
      std::atomic<GCInfoIndex>&, TraceCallback, FinalizationCallback);
  static GCInfoIndex V8_PRESERVE_MOST
  EnsureGCInfoIndex(std::atomic<GCInfoIndex>&, TraceCallback, NameCallback);
  static GCInfoIndex V8_PRESERVE_MOST
  EnsureGCInfoIndex(std::atomic<GCInfoIndex>&, TraceCallback);
};

#define DISPATCH(has_finalizer, has_non_hidden_name, function)   \
  template <typename T>                                          \
  struct EnsureGCInfoIndexTrait::EnsureGCInfoIndexTraitDispatch< \
      T, has_finalizer, has_non_hidden_name> {                   \
    V8_INLINE GCInfoIndex                                        \
    operator()(std::atomic<GCInfoIndex>& registered_index) {     \
      return function;                                           \
    }                                                            \
  };

// ------------------------------------------------------- //
// DISPATCH(has_finalizer, has_non_hidden_name, function)  //
// ------------------------------------------------------- //
DISPATCH(true, true,                                       //
         EnsureGCInfoIndex(registered_index,               //
                           TraceTrait<T>::Trace,           //
                           FinalizerTrait<T>::kCallback,   //
                           NameTrait<T>::GetName))         //
DISPATCH(true, false,                                      //
         EnsureGCInfoIndex(registered_index,               //
                           TraceTrait<T>::Trace,           //
                           FinalizerTrait<T>::kCallback))  //
DISPATCH(false, true,                                      //
         EnsureGCInfoIndex(registered_index,               //
                           TraceTrait<T>::Trace,           //
                           NameTrait<T>::GetName))         //
DISPATCH(false, false,                                     //
         EnsureGCInfoIndex(registered_index,               //
                           TraceTrait<T>::Trace))          //

#undef DISPATCH

// Trait determines how the garbage collector treats objects wrt. to traversing,
// finalization, and naming.
template <typename T>
struct GCInfoTrait final {
  V8_INLINE static GCInfoIndex Index() {
    static_assert(sizeof(T), "T must be fully defined");
    static std::atomic<GCInfoIndex>
        registered_index;  // Uses zero initialization.
    GCInfoIndex index = registered_index.load(std::memory_order_acquire);
    if (V8_UNLIKELY(!index)) {
      index = EnsureGCInfoIndexTrait::EnsureIndex<T>(registered_index);
      CPPGC_DCHECK(index != 0);
      CPPGC_DCHECK(index == registered_index.load(std::memory_order_acquire));
    }
    return index;
  }

  static constexpr void CheckCallbacksAreDefined() {
    // No USE() macro available.
    (void)static_cast<TraceCallback>(TraceTrait<T>::Trace);
    (void)static_cast<FinalizationCallback>(FinalizerTrait<T>::kCallback);
    (void)static_cast<NameCallback>(NameTrait<T>::GetName);
  }
};

// Fold types based on finalizer behavior. Note that finalizer characteristics
// align with trace behavior, i.e., destructors are virtual when trace methods
// are and vice versa.
template <typename T, typename ParentMostGarbageCollectedType>
struct GCInfoFolding final {
  static constexpr bool kHasVirtualDestructorAtBase =
      std::has_virtual_destructor<ParentMostGarbageCollectedType>::value;
  static constexpr bool kBothTypesAreTriviallyDestructible =
      std::is_trivially_destructible<ParentMostGarbageCollectedType>::value &&
      std::is_trivially_destructible<T>::value;
  static constexpr bool kHasCustomFinalizerDispatchAtBase =
      internal::HasFinalizeGarbageCollectedObject<
          ParentMostGarbageCollectedType>::value;
#ifdef CPPGC_SUPPORTS_OBJECT_NAMES
  static constexpr bool kWantsDetailedObjectNames = true;
#else   // !CPPGC_SUPPORTS_OBJECT_NAMES
  static constexpr bool kWantsDetailedObjectNames = false;
#endif  // !CPPGC_SUPPORTS_OBJECT_NAMES

  // Always true. Forces the compiler to resolve callbacks which ensures that
  // both modes don't break without requiring compiling a separate
  // configuration. Only a single GCInfo (for `ResultType` below) will actually
  // be instantiated but existence (and well-formedness) of all callbacks is
  // checked.
  static constexpr bool WantToFold() {
    if constexpr ((kHasVirtualDestructorAtBase ||
                   kBothTypesAreTriviallyDestructible ||
                   kHasCustomFinalizerDispatchAtBase) &&
                  !kWantsDetailedObjectNames) {
      GCInfoTrait<T>::CheckCallbacksAreDefined();
      GCInfoTrait<ParentMostGarbageCollectedType>::CheckCallbacksAreDefined();
      return true;
    }
    return false;
  }

  // Folding would regress name resolution when deriving names from C++
  // class names as it would just folds a name to the base class name.
  using ResultType =
      std::conditional_t<WantToFold(), ParentMostGarbageCollectedType, T>;
};

}  // namespace internal
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_INTERNAL_GC_INFO_H_
                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/include/cppgc/internal/logging.h                                                0000664 0000000 0000000 00000003246 14746647661 0022204 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_LOGGING_H_
#define INCLUDE_CPPGC_INTERNAL_LOGGING_H_

#include "cppgc/source-location.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {
namespace internal {

void V8_EXPORT DCheckImpl(const char*,
                          const SourceLocation& = SourceLocation::Current());
[[noreturn]] void V8_EXPORT
FatalImpl(const char*, const SourceLocation& = SourceLocation::Current());

// Used to ignore -Wunused-variable.
template <typename>
struct EatParams {};

#if defined(DEBUG)
#define CPPGC_DCHECK_MSG(condition, message)  \
  do {                                        \
    if (V8_UNLIKELY(!(condition))) {          \
      ::cppgc::internal::DCheckImpl(message); \
    }                                         \
  } while (false)
#else  // !defined(DEBUG)
#define CPPGC_DCHECK_MSG(condition, message)                \
  (static_cast<void>(::cppgc::internal::EatParams<decltype( \
                         static_cast<void>(condition), message)>{}))
#endif  // !defined(DEBUG)

#define CPPGC_DCHECK(condition) CPPGC_DCHECK_MSG(condition, #condition)

#define CPPGC_CHECK_MSG(condition, message)  \
  do {                                       \
    if (V8_UNLIKELY(!(condition))) {         \
      ::cppgc::internal::FatalImpl(message); \
    }                                        \
  } while (false)

#define CPPGC_CHECK(condition) CPPGC_CHECK_MSG(condition, #condition)

}  // namespace internal
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_INTERNAL_LOGGING_H_
                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/include/cppgc/internal/member-storage.h                                         0000664 0000000 0000000 00000021623 14746647661 0023466 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_MEMBER_STORAGE_H_
#define INCLUDE_CPPGC_INTERNAL_MEMBER_STORAGE_H_

#include <atomic>
#include <cstddef>
#include <type_traits>

#include "cppgc/internal/api-constants.h"
#include "cppgc/internal/logging.h"
#include "cppgc/sentinel-pointer.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {
namespace internal {

enum class WriteBarrierSlotType {
  kCompressed,
  kUncompressed,
};

#if defined(CPPGC_POINTER_COMPRESSION)

#if defined(__clang__)
// Attribute const allows the compiler to assume that CageBaseGlobal::g_base_
// doesn't change (e.g. across calls) and thereby avoid redundant loads.
#define CPPGC_CONST __attribute__((const))
#define CPPGC_REQUIRE_CONSTANT_INIT \
  __attribute__((require_constant_initialization))
#else  // defined(__clang__)
#define CPPGC_CONST
#define CPPGC_REQUIRE_CONSTANT_INIT
#endif  // defined(__clang__)

class V8_EXPORT CageBaseGlobal final {
 public:
  V8_INLINE CPPGC_CONST static uintptr_t Get() {
    CPPGC_DCHECK(IsBaseConsistent());
    return g_base_.base;
  }

  V8_INLINE CPPGC_CONST static bool IsSet() {
    CPPGC_DCHECK(IsBaseConsistent());
    return (g_base_.base & ~kLowerHalfWordMask) != 0;
  }

 private:
  // We keep the lower halfword as ones to speed up decompression.
  static constexpr uintptr_t kLowerHalfWordMask =
      (api_constants::kCagedHeapReservationAlignment - 1);

  static union alignas(api_constants::kCachelineSize) Base {
    uintptr_t base;
    char cache_line[api_constants::kCachelineSize];
  } g_base_ CPPGC_REQUIRE_CONSTANT_INIT;

  CageBaseGlobal() = delete;

  V8_INLINE static bool IsBaseConsistent() {
    return kLowerHalfWordMask == (g_base_.base & kLowerHalfWordMask);
  }

  friend class CageBaseGlobalUpdater;
};

#undef CPPGC_REQUIRE_CONSTANT_INIT
#undef CPPGC_CONST

class V8_TRIVIAL_ABI CompressedPointer final {
 public:
  using IntegralType = uint32_t;
  static constexpr auto kWriteBarrierSlotType =
      WriteBarrierSlotType::kCompressed;

  V8_INLINE CompressedPointer() : value_(0u) {}
  V8_INLINE explicit CompressedPointer(const void* ptr)
      : value_(Compress(ptr)) {}
  V8_INLINE explicit CompressedPointer(std::nullptr_t) : value_(0u) {}
  V8_INLINE explicit CompressedPointer(SentinelPointer)
      : value_(kCompressedSentinel) {}

  V8_INLINE const void* Load() const { return Decompress(value_); }
  V8_INLINE const void* LoadAtomic() const {
    return Decompress(
        reinterpret_cast<const std::atomic<IntegralType>&>(value_).load(
            std::memory_order_relaxed));
  }

  V8_INLINE void Store(const void* ptr) { value_ = Compress(ptr); }
  V8_INLINE void StoreAtomic(const void* value) {
    reinterpret_cast<std::atomic<IntegralType>&>(value_).store(
        Compress(value), std::memory_order_relaxed);
  }

  V8_INLINE void Clear() { value_ = 0u; }
  V8_INLINE bool IsCleared() const { return !value_; }

  V8_INLINE bool IsSentinel() const { return value_ == kCompressedSentinel; }

  V8_INLINE uint32_t GetAsInteger() const { return value_; }

  V8_INLINE friend bool operator==(CompressedPointer a, CompressedPointer b) {
    return a.value_ == b.value_;
  }
  V8_INLINE friend bool operator!=(CompressedPointer a, CompressedPointer b) {
    return a.value_ != b.value_;
  }
  V8_INLINE friend bool operator<(CompressedPointer a, CompressedPointer b) {
    return a.value_ < b.value_;
  }
  V8_INLINE friend bool operator<=(CompressedPointer a, CompressedPointer b) {
    return a.value_ <= b.value_;
  }
  V8_INLINE friend bool operator>(CompressedPointer a, CompressedPointer b) {
    return a.value_ > b.value_;
  }
  V8_INLINE friend bool operator>=(CompressedPointer a, CompressedPointer b) {
    return a.value_ >= b.value_;
  }

  static V8_INLINE IntegralType Compress(const void* ptr) {
    static_assert(SentinelPointer::kSentinelValue ==
                      1 << api_constants::kPointerCompressionShift,
                  "The compression scheme relies on the sentinel encoded as 1 "
                  "<< kPointerCompressionShift");
    static constexpr size_t kGigaCageMask =
        ~(api_constants::kCagedHeapReservationAlignment - 1);
    static constexpr size_t kPointerCompressionShiftMask =
        (1 << api_constants::kPointerCompressionShift) - 1;

    CPPGC_DCHECK(CageBaseGlobal::IsSet());
    const uintptr_t base = CageBaseGlobal::Get();
    CPPGC_DCHECK(!ptr || ptr == kSentinelPointer ||
                 (base & kGigaCageMask) ==
                     (reinterpret_cast<uintptr_t>(ptr) & kGigaCageMask));
    CPPGC_DCHECK(
        (reinterpret_cast<uintptr_t>(ptr) & kPointerCompressionShiftMask) == 0);

#if defined(CPPGC_2GB_CAGE)
    // Truncate the pointer.
    auto compressed =
        static_cast<IntegralType>(reinterpret_cast<uintptr_t>(ptr));
#else   // !defined(CPPGC_2GB_CAGE)
    const auto uptr = reinterpret_cast<uintptr_t>(ptr);
    // Shift the pointer and truncate.
    auto compressed = static_cast<IntegralType>(
        uptr >> api_constants::kPointerCompressionShift);
#endif  // !defined(CPPGC_2GB_CAGE)
    // Normal compressed pointers must have the MSB set.
    CPPGC_DCHECK((!compressed || compressed == kCompressedSentinel) ||
                 (compressed & (1 << 31)));
    return compressed;
  }

  static V8_INLINE void* Decompress(IntegralType ptr) {
    CPPGC_DCHECK(CageBaseGlobal::IsSet());
    const uintptr_t base = CageBaseGlobal::Get();
    return Decompress(ptr, base);
  }

  static V8_INLINE void* Decompress(IntegralType ptr, uintptr_t base) {
    CPPGC_DCHECK(CageBaseGlobal::IsSet());
    CPPGC_DCHECK(base == CageBaseGlobal::Get());
    // Treat compressed pointer as signed and cast it to uint64_t, which will
    // sign-extend it.
#if defined(CPPGC_2GB_CAGE)
    const uint64_t mask = static_cast<uint64_t>(static_cast<int32_t>(ptr));
#else   // !defined(CPPGC_2GB_CAGE)
    // Then, shift the result. It's important to shift the unsigned
    // value, as otherwise it would result in undefined behavior.
    const uint64_t mask = static_cast<uint64_t>(static_cast<int32_t>(ptr))
                          << api_constants::kPointerCompressionShift;
#endif  // !defined(CPPGC_2GB_CAGE)
    return reinterpret_cast<void*>(mask & base);
  }

 private:
#if defined(CPPGC_2GB_CAGE)
  static constexpr IntegralType kCompressedSentinel =
      SentinelPointer::kSentinelValue;
#else   // !defined(CPPGC_2GB_CAGE)
  static constexpr IntegralType kCompressedSentinel =
      SentinelPointer::kSentinelValue >>
      api_constants::kPointerCompressionShift;
#endif  // !defined(CPPGC_2GB_CAGE)
  // All constructors initialize `value_`. Do not add a default value here as it
  // results in a non-atomic write on some builds, even when the atomic version
  // of the constructor is used.
  IntegralType value_;
};

#endif  // defined(CPPGC_POINTER_COMPRESSION)

class V8_TRIVIAL_ABI RawPointer final {
 public:
  using IntegralType = uintptr_t;
  static constexpr auto kWriteBarrierSlotType =
      WriteBarrierSlotType::kUncompressed;

  V8_INLINE RawPointer() : ptr_(nullptr) {}
  V8_INLINE explicit RawPointer(const void* ptr) : ptr_(ptr) {}

  V8_INLINE const void* Load() const { return ptr_; }
  V8_INLINE const void* LoadAtomic() const {
    return reinterpret_cast<const std::atomic<const void*>&>(ptr_).load(
        std::memory_order_relaxed);
  }

  V8_INLINE void Store(const void* ptr) { ptr_ = ptr; }
  V8_INLINE void StoreAtomic(const void* ptr) {
    reinterpret_cast<std::atomic<const void*>&>(ptr_).store(
        ptr, std::memory_order_relaxed);
  }

  V8_INLINE void Clear() { ptr_ = nullptr; }
  V8_INLINE bool IsCleared() const { return !ptr_; }

  V8_INLINE bool IsSentinel() const { return ptr_ == kSentinelPointer; }

  V8_INLINE uintptr_t GetAsInteger() const {
    return reinterpret_cast<uintptr_t>(ptr_);
  }

  V8_INLINE friend bool operator==(RawPointer a, RawPointer b) {
    return a.ptr_ == b.ptr_;
  }
  V8_INLINE friend bool operator!=(RawPointer a, RawPointer b) {
    return a.ptr_ != b.ptr_;
  }
  V8_INLINE friend bool operator<(RawPointer a, RawPointer b) {
    return a.ptr_ < b.ptr_;
  }
  V8_INLINE friend bool operator<=(RawPointer a, RawPointer b) {
    return a.ptr_ <= b.ptr_;
  }
  V8_INLINE friend bool operator>(RawPointer a, RawPointer b) {
    return a.ptr_ > b.ptr_;
  }
  V8_INLINE friend bool operator>=(RawPointer a, RawPointer b) {
    return a.ptr_ >= b.ptr_;
  }

 private:
  // All constructors initialize `ptr_`. Do not add a default value here as it
  // results in a non-atomic write on some builds, even when the atomic version
  // of the constructor is used.
  const void* ptr_;
};

#if defined(CPPGC_POINTER_COMPRESSION)
using DefaultMemberStorage = CompressedPointer;
#else   // !defined(CPPGC_POINTER_COMPRESSION)
using DefaultMemberStorage = RawPointer;
#endif  // !defined(CPPGC_POINTER_COMPRESSION)

}  // namespace internal
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_INTERNAL_MEMBER_STORAGE_H_
                                                                                                             node-23.7.0/deps/v8/include/cppgc/internal/name-trait.h                                             0000664 0000000 0000000 00000010532 14746647661 0022613 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_NAME_TRAIT_H_
#define INCLUDE_CPPGC_INTERNAL_NAME_TRAIT_H_

#include <cstddef>
#include <cstdint>
#include <type_traits>

#include "cppgc/name-provider.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {
namespace internal {

#if CPPGC_SUPPORTS_OBJECT_NAMES && defined(__clang__)
#define CPPGC_SUPPORTS_COMPILE_TIME_TYPENAME 1

// Provides constexpr c-string storage for a name of fixed |Size| characters.
// Automatically appends terminating 0 byte.
template <size_t Size>
struct NameBuffer {
  char name[Size + 1]{};

  static constexpr NameBuffer FromCString(const char* str) {
    NameBuffer result;
    for (size_t i = 0; i < Size; ++i) result.name[i] = str[i];
    result.name[Size] = 0;
    return result;
  }
};

template <typename T>
const char* GetTypename() {
  static constexpr char kSelfPrefix[] =
      "const char *cppgc::internal::GetTypename() [T =";
  static_assert(__builtin_strncmp(__PRETTY_FUNCTION__, kSelfPrefix,
                                  sizeof(kSelfPrefix) - 1) == 0,
                "The prefix must match");
  static constexpr const char* kTypenameStart =
      __PRETTY_FUNCTION__ + sizeof(kSelfPrefix);
  static constexpr size_t kTypenameSize =
      __builtin_strlen(__PRETTY_FUNCTION__) - sizeof(kSelfPrefix) - 1;
  // NameBuffer is an indirection that is needed to make sure that only a
  // substring of __PRETTY_FUNCTION__ gets materialized in the binary.
  static constexpr auto buffer =
      NameBuffer<kTypenameSize>::FromCString(kTypenameStart);
  return buffer.name;
}

#else
#define CPPGC_SUPPORTS_COMPILE_TIME_TYPENAME 0
#endif

struct HeapObjectName {
  const char* value;
  bool name_was_hidden;
};

enum class HeapObjectNameForUnnamedObject : uint8_t {
  kUseClassNameIfSupported,
  kUseHiddenName,
};

class V8_EXPORT NameTraitBase {
 protected:
  static HeapObjectName GetNameFromTypeSignature(const char*);
};

// Trait that specifies how the garbage collector retrieves the name for a
// given object.
template <typename T>
class NameTrait final : public NameTraitBase {
 public:
  static constexpr bool HasNonHiddenName() {
#if CPPGC_SUPPORTS_COMPILE_TIME_TYPENAME
    return true;
#elif CPPGC_SUPPORTS_OBJECT_NAMES
    return true;
#else   // !CPPGC_SUPPORTS_OBJECT_NAMES
    return std::is_base_of<NameProvider, T>::value;
#endif  // !CPPGC_SUPPORTS_OBJECT_NAMES
  }

  static HeapObjectName GetName(
      const void* obj, HeapObjectNameForUnnamedObject name_retrieval_mode) {
    return GetNameFor(static_cast<const T*>(obj), name_retrieval_mode);
  }

 private:
  static HeapObjectName GetNameFor(const NameProvider* name_provider,
                                   HeapObjectNameForUnnamedObject) {
    // Objects inheriting from `NameProvider` are not considered unnamed as
    // users already provided a name for them.
    return {name_provider->GetHumanReadableName(), false};
  }

  static HeapObjectName GetNameFor(
      const void*, HeapObjectNameForUnnamedObject name_retrieval_mode) {
    if (name_retrieval_mode == HeapObjectNameForUnnamedObject::kUseHiddenName)
      return {NameProvider::kHiddenName, true};

#if CPPGC_SUPPORTS_COMPILE_TIME_TYPENAME
    return {GetTypename<T>(), false};
#elif CPPGC_SUPPORTS_OBJECT_NAMES

#if defined(V8_CC_GNU)
#define PRETTY_FUNCTION_VALUE __PRETTY_FUNCTION__
#elif defined(V8_CC_MSVC)
#define PRETTY_FUNCTION_VALUE __FUNCSIG__
#else
#define PRETTY_FUNCTION_VALUE nullptr
#endif

    static const HeapObjectName leaky_name =
        GetNameFromTypeSignature(PRETTY_FUNCTION_VALUE);
    return leaky_name;

#undef PRETTY_FUNCTION_VALUE

#else   // !CPPGC_SUPPORTS_OBJECT_NAMES
    // We wanted to use a class name but were unable to provide one due to
    // compiler limitations or build configuration. As such, return the hidden
    // name with name_was_hidden=false, which will cause this object to be
    // visible in the snapshot.
    return {NameProvider::kHiddenName, false};
#endif  // !CPPGC_SUPPORTS_OBJECT_NAMES
  }
};

using NameCallback = HeapObjectName (*)(const void*,
                                        HeapObjectNameForUnnamedObject);

}  // namespace internal
}  // namespace cppgc

#undef CPPGC_SUPPORTS_COMPILE_TIME_TYPENAME

#endif  // INCLUDE_CPPGC_INTERNAL_NAME_TRAIT_H_
                                                                                                                                                                      node-23.7.0/deps/v8/include/cppgc/internal/persistent-node.h                                        0000664 0000000 0000000 00000013620 14746647661 0023676 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_PERSISTENT_NODE_H_
#define INCLUDE_CPPGC_INTERNAL_PERSISTENT_NODE_H_

#include <array>
#include <memory>
#include <vector>

#include "cppgc/internal/logging.h"
#include "cppgc/trace-trait.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {
namespace internal {

class CrossThreadPersistentRegion;
class FatalOutOfMemoryHandler;
class RootVisitor;

// PersistentNode represents a variant of two states:
// 1) traceable node with a back pointer to the Persistent object;
// 2) freelist entry.
class PersistentNode final {
 public:
  PersistentNode() = default;

  PersistentNode(const PersistentNode&) = delete;
  PersistentNode& operator=(const PersistentNode&) = delete;

  void InitializeAsUsedNode(void* owner, TraceRootCallback trace) {
    CPPGC_DCHECK(trace);
    owner_ = owner;
    trace_ = trace;
  }

  void InitializeAsFreeNode(PersistentNode* next) {
    next_ = next;
    trace_ = nullptr;
  }

  void UpdateOwner(void* owner) {
    CPPGC_DCHECK(IsUsed());
    owner_ = owner;
  }

  PersistentNode* FreeListNext() const {
    CPPGC_DCHECK(!IsUsed());
    return next_;
  }

  void Trace(RootVisitor& root_visitor) const {
    CPPGC_DCHECK(IsUsed());
    trace_(root_visitor, owner_);
  }

  bool IsUsed() const { return trace_; }

  void* owner() const {
    CPPGC_DCHECK(IsUsed());
    return owner_;
  }

 private:
  // PersistentNode acts as a designated union:
  // If trace_ != nullptr, owner_ points to the corresponding Persistent handle.
  // Otherwise, next_ points to the next freed PersistentNode.
  union {
    void* owner_ = nullptr;
    PersistentNode* next_;
  };
  TraceRootCallback trace_ = nullptr;
};

class V8_EXPORT PersistentRegionBase {
  using PersistentNodeSlots = std::array<PersistentNode, 256u>;

 public:
  // Clears Persistent fields to avoid stale pointers after heap teardown.
  ~PersistentRegionBase();

  PersistentRegionBase(const PersistentRegionBase&) = delete;
  PersistentRegionBase& operator=(const PersistentRegionBase&) = delete;

  void Iterate(RootVisitor&);

  size_t NodesInUse() const;

  void ClearAllUsedNodes();

 protected:
  explicit PersistentRegionBase(const FatalOutOfMemoryHandler& oom_handler);

  PersistentNode* TryAllocateNodeFromFreeList(void* owner,
                                              TraceRootCallback trace) {
    PersistentNode* node = nullptr;
    if (V8_LIKELY(free_list_head_)) {
      node = free_list_head_;
      free_list_head_ = free_list_head_->FreeListNext();
      CPPGC_DCHECK(!node->IsUsed());
      node->InitializeAsUsedNode(owner, trace);
      nodes_in_use_++;
    }
    return node;
  }

  void FreeNode(PersistentNode* node) {
    CPPGC_DCHECK(node);
    CPPGC_DCHECK(node->IsUsed());
    node->InitializeAsFreeNode(free_list_head_);
    free_list_head_ = node;
    CPPGC_DCHECK(nodes_in_use_ > 0);
    nodes_in_use_--;
  }

  PersistentNode* RefillFreeListAndAllocateNode(void* owner,
                                                TraceRootCallback trace);

 private:
  template <typename PersistentBaseClass>
  void ClearAllUsedNodes();

  void RefillFreeList();

  std::vector<std::unique_ptr<PersistentNodeSlots>> nodes_;
  PersistentNode* free_list_head_ = nullptr;
  size_t nodes_in_use_ = 0;
  const FatalOutOfMemoryHandler& oom_handler_;

  friend class CrossThreadPersistentRegion;
};

// Variant of PersistentRegionBase that checks whether the allocation and
// freeing happens only on the thread that created the region.
class V8_EXPORT PersistentRegion final : public PersistentRegionBase {
 public:
  explicit PersistentRegion(const FatalOutOfMemoryHandler&);
  // Clears Persistent fields to avoid stale pointers after heap teardown.
  ~PersistentRegion() = default;

  PersistentRegion(const PersistentRegion&) = delete;
  PersistentRegion& operator=(const PersistentRegion&) = delete;

  V8_INLINE PersistentNode* AllocateNode(void* owner, TraceRootCallback trace) {
    CPPGC_DCHECK(IsCreationThread());
    auto* node = TryAllocateNodeFromFreeList(owner, trace);
    if (V8_LIKELY(node)) return node;

    // Slow path allocation allows for checking thread correspondence.
    CPPGC_CHECK(IsCreationThread());
    return RefillFreeListAndAllocateNode(owner, trace);
  }

  V8_INLINE void FreeNode(PersistentNode* node) {
    CPPGC_DCHECK(IsCreationThread());
    PersistentRegionBase::FreeNode(node);
  }

 private:
  bool IsCreationThread();

  int creation_thread_id_;
};

// CrossThreadPersistent uses PersistentRegionBase but protects it using this
// lock when needed.
class V8_EXPORT PersistentRegionLock final {
 public:
  PersistentRegionLock();
  ~PersistentRegionLock();

  static void AssertLocked();
};

// Variant of PersistentRegionBase that checks whether the PersistentRegionLock
// is locked.
class V8_EXPORT CrossThreadPersistentRegion final
    : protected PersistentRegionBase {
 public:
  explicit CrossThreadPersistentRegion(const FatalOutOfMemoryHandler&);
  // Clears Persistent fields to avoid stale pointers after heap teardown.
  ~CrossThreadPersistentRegion();

  CrossThreadPersistentRegion(const CrossThreadPersistentRegion&) = delete;
  CrossThreadPersistentRegion& operator=(const CrossThreadPersistentRegion&) =
      delete;

  V8_INLINE PersistentNode* AllocateNode(void* owner, TraceRootCallback trace) {
    PersistentRegionLock::AssertLocked();
    auto* node = TryAllocateNodeFromFreeList(owner, trace);
    if (V8_LIKELY(node)) return node;

    return RefillFreeListAndAllocateNode(owner, trace);
  }

  V8_INLINE void FreeNode(PersistentNode* node) {
    PersistentRegionLock::AssertLocked();
    PersistentRegionBase::FreeNode(node);
  }

  void Iterate(RootVisitor&);

  size_t NodesInUse() const;

  void ClearAllUsedNodes();
};

}  // namespace internal

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_INTERNAL_PERSISTENT_NODE_H_
                                                                                                                node-23.7.0/deps/v8/include/cppgc/internal/pointer-policies.h                                       0000664 0000000 0000000 00000020534 14746647661 0024042 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_POINTER_POLICIES_H_
#define INCLUDE_CPPGC_INTERNAL_POINTER_POLICIES_H_

#include <cstdint>
#include <type_traits>

#include "cppgc/internal/member-storage.h"
#include "cppgc/internal/write-barrier.h"
#include "cppgc/sentinel-pointer.h"
#include "cppgc/source-location.h"
#include "cppgc/type-traits.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {
namespace internal {

class HeapBase;
class PersistentRegion;
class CrossThreadPersistentRegion;

// Tags to distinguish between strong and weak member types.
class StrongMemberTag;
class WeakMemberTag;
class UntracedMemberTag;

struct DijkstraWriteBarrierPolicy {
  V8_INLINE static void InitializingBarrier(const void*, const void*) {
    // Since in initializing writes the source object is always white, having no
    // barrier doesn't break the tri-color invariant.
  }

  template <WriteBarrierSlotType SlotType>
  V8_INLINE static void AssigningBarrier(const void* slot, const void* value) {
#ifdef CPPGC_SLIM_WRITE_BARRIER
    if (V8_UNLIKELY(WriteBarrier::IsEnabled()))
      WriteBarrier::CombinedWriteBarrierSlow<SlotType>(slot);
#else   // !CPPGC_SLIM_WRITE_BARRIER
    WriteBarrier::Params params;
    const WriteBarrier::Type type =
        WriteBarrier::GetWriteBarrierType(slot, value, params);
    WriteBarrier(type, params, slot, value);
#endif  // !CPPGC_SLIM_WRITE_BARRIER
  }

  template <WriteBarrierSlotType SlotType>
  V8_INLINE static void AssigningBarrier(const void* slot, RawPointer storage) {
    static_assert(
        SlotType == WriteBarrierSlotType::kUncompressed,
        "Assigning storages of Member and UncompressedMember is not supported");
#ifdef CPPGC_SLIM_WRITE_BARRIER
    if (V8_UNLIKELY(WriteBarrier::IsEnabled()))
      WriteBarrier::CombinedWriteBarrierSlow<SlotType>(slot);
#else   // !CPPGC_SLIM_WRITE_BARRIER
    WriteBarrier::Params params;
    const WriteBarrier::Type type =
        WriteBarrier::GetWriteBarrierType(slot, storage, params);
    WriteBarrier(type, params, slot, storage.Load());
#endif  // !CPPGC_SLIM_WRITE_BARRIER
  }

#if defined(CPPGC_POINTER_COMPRESSION)
  template <WriteBarrierSlotType SlotType>
  V8_INLINE static void AssigningBarrier(const void* slot,
                                         CompressedPointer storage) {
    static_assert(
        SlotType == WriteBarrierSlotType::kCompressed,
        "Assigning storages of Member and UncompressedMember is not supported");
#ifdef CPPGC_SLIM_WRITE_BARRIER
    if (V8_UNLIKELY(WriteBarrier::IsEnabled()))
      WriteBarrier::CombinedWriteBarrierSlow<SlotType>(slot);
#else   // !CPPGC_SLIM_WRITE_BARRIER
    WriteBarrier::Params params;
    const WriteBarrier::Type type =
        WriteBarrier::GetWriteBarrierType(slot, storage, params);
    WriteBarrier(type, params, slot, storage.Load());
#endif  // !CPPGC_SLIM_WRITE_BARRIER
  }
#endif  // defined(CPPGC_POINTER_COMPRESSION)

 private:
  V8_INLINE static void WriteBarrier(WriteBarrier::Type type,
                                     const WriteBarrier::Params& params,
                                     const void* slot, const void* value) {
    switch (type) {
      case WriteBarrier::Type::kGenerational:
        WriteBarrier::GenerationalBarrier<
            WriteBarrier::GenerationalBarrierType::kPreciseSlot>(params, slot);
        break;
      case WriteBarrier::Type::kMarking:
        WriteBarrier::DijkstraMarkingBarrier(params, value);
        break;
      case WriteBarrier::Type::kNone:
        break;
    }
  }
};

struct NoWriteBarrierPolicy {
  V8_INLINE static void InitializingBarrier(const void*, const void*) {}
  template <WriteBarrierSlotType>
  V8_INLINE static void AssigningBarrier(const void*, const void*) {}
  template <WriteBarrierSlotType, typename MemberStorage>
  V8_INLINE static void AssigningBarrier(const void*, MemberStorage) {}
};

class V8_EXPORT SameThreadEnabledCheckingPolicyBase {
 protected:
  void CheckPointerImpl(const void* ptr, bool points_to_payload,
                        bool check_off_heap_assignments);

  const HeapBase* heap_ = nullptr;
};

template <bool kCheckOffHeapAssignments>
class V8_EXPORT SameThreadEnabledCheckingPolicy
    : private SameThreadEnabledCheckingPolicyBase {
 protected:
  template <typename T>
  void CheckPointer(const T* ptr) {
    if (!ptr || (kSentinelPointer == ptr)) return;

    CheckPointersImplTrampoline<T>::Call(this, ptr);
  }

 private:
  template <typename T, bool = IsCompleteV<T>>
  struct CheckPointersImplTrampoline {
    static void Call(SameThreadEnabledCheckingPolicy* policy, const T* ptr) {
      policy->CheckPointerImpl(ptr, false, kCheckOffHeapAssignments);
    }
  };

  template <typename T>
  struct CheckPointersImplTrampoline<T, true> {
    static void Call(SameThreadEnabledCheckingPolicy* policy, const T* ptr) {
      policy->CheckPointerImpl(ptr, IsGarbageCollectedTypeV<T>,
                               kCheckOffHeapAssignments);
    }
  };
};

class DisabledCheckingPolicy {
 protected:
  V8_INLINE void CheckPointer(const void*) {}
};

#ifdef DEBUG
// Off heap members are not connected to object graph and thus cannot ressurect
// dead objects.
using DefaultMemberCheckingPolicy =
    SameThreadEnabledCheckingPolicy<false /* kCheckOffHeapAssignments*/>;
using DefaultPersistentCheckingPolicy =
    SameThreadEnabledCheckingPolicy<true /* kCheckOffHeapAssignments*/>;
#else   // !DEBUG
using DefaultMemberCheckingPolicy = DisabledCheckingPolicy;
using DefaultPersistentCheckingPolicy = DisabledCheckingPolicy;
#endif  // !DEBUG
// For CT(W)P neither marking information (for value), nor objectstart bitmap
// (for slot) are guaranteed to be present because there's no synchronization
// between heaps after marking.
using DefaultCrossThreadPersistentCheckingPolicy = DisabledCheckingPolicy;

class KeepLocationPolicy {
 public:
  constexpr const SourceLocation& Location() const { return location_; }

 protected:
  constexpr KeepLocationPolicy() = default;
  constexpr explicit KeepLocationPolicy(const SourceLocation& location)
      : location_(location) {}

  // KeepLocationPolicy must not copy underlying source locations.
  KeepLocationPolicy(const KeepLocationPolicy&) = delete;
  KeepLocationPolicy& operator=(const KeepLocationPolicy&) = delete;

  // Location of the original moved from object should be preserved.
  KeepLocationPolicy(KeepLocationPolicy&&) = default;
  KeepLocationPolicy& operator=(KeepLocationPolicy&&) = default;

 private:
  SourceLocation location_;
};

class IgnoreLocationPolicy {
 public:
  constexpr SourceLocation Location() const { return {}; }

 protected:
  constexpr IgnoreLocationPolicy() = default;
  constexpr explicit IgnoreLocationPolicy(const SourceLocation&) {}
};

#if CPPGC_SUPPORTS_OBJECT_NAMES
using DefaultLocationPolicy = KeepLocationPolicy;
#else
using DefaultLocationPolicy = IgnoreLocationPolicy;
#endif

struct StrongPersistentPolicy {
  using IsStrongPersistent = std::true_type;
  static V8_EXPORT PersistentRegion& GetPersistentRegion(const void* object);
};

struct WeakPersistentPolicy {
  using IsStrongPersistent = std::false_type;
  static V8_EXPORT PersistentRegion& GetPersistentRegion(const void* object);
};

struct StrongCrossThreadPersistentPolicy {
  using IsStrongPersistent = std::true_type;
  static V8_EXPORT CrossThreadPersistentRegion& GetPersistentRegion(
      const void* object);
};

struct WeakCrossThreadPersistentPolicy {
  using IsStrongPersistent = std::false_type;
  static V8_EXPORT CrossThreadPersistentRegion& GetPersistentRegion(
      const void* object);
};

// Forward declarations setting up the default policies.
template <typename T, typename WeaknessPolicy,
          typename LocationPolicy = DefaultLocationPolicy,
          typename CheckingPolicy = DefaultCrossThreadPersistentCheckingPolicy>
class BasicCrossThreadPersistent;
template <typename T, typename WeaknessPolicy,
          typename LocationPolicy = DefaultLocationPolicy,
          typename CheckingPolicy = DefaultPersistentCheckingPolicy>
class BasicPersistent;
template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy = DefaultMemberCheckingPolicy,
          typename StorageType = DefaultMemberStorage>
class BasicMember;

}  // namespace internal

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_INTERNAL_POINTER_POLICIES_H_
                                                                                                                                                                    node-23.7.0/deps/v8/include/cppgc/internal/write-barrier.h                                          0000664 0000000 0000000 00000046134 14746647661 0023337 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_INTERNAL_WRITE_BARRIER_H_
#define INCLUDE_CPPGC_INTERNAL_WRITE_BARRIER_H_

#include <cstddef>
#include <cstdint>

#include "cppgc/heap-handle.h"
#include "cppgc/heap-state.h"
#include "cppgc/internal/api-constants.h"
#include "cppgc/internal/atomic-entry-flag.h"
#include "cppgc/internal/base-page-handle.h"
#include "cppgc/internal/member-storage.h"
#include "cppgc/platform.h"
#include "cppgc/sentinel-pointer.h"
#include "cppgc/trace-trait.h"
#include "v8config.h"  // NOLINT(build/include_directory)

#if defined(CPPGC_CAGED_HEAP)
#include "cppgc/internal/caged-heap-local-data.h"
#include "cppgc/internal/caged-heap.h"
#endif

namespace cppgc {

class HeapHandle;

namespace internal {

#if defined(CPPGC_CAGED_HEAP)
class WriteBarrierTypeForCagedHeapPolicy;
#else   // !CPPGC_CAGED_HEAP
class WriteBarrierTypeForNonCagedHeapPolicy;
#endif  // !CPPGC_CAGED_HEAP

class V8_EXPORT WriteBarrier final {
 public:
  enum class Type : uint8_t {
    kNone,
    kMarking,
    kGenerational,
  };

  enum class GenerationalBarrierType : uint8_t {
    kPreciseSlot,
    kPreciseUncompressedSlot,
    kImpreciseSlot,
  };

  struct Params {
    HeapHandle* heap = nullptr;
#if V8_ENABLE_CHECKS
    Type type = Type::kNone;
#endif  // !V8_ENABLE_CHECKS
#if defined(CPPGC_CAGED_HEAP)
    uintptr_t slot_offset = 0;
    uintptr_t value_offset = 0;
#endif  // CPPGC_CAGED_HEAP
  };

  enum class ValueMode {
    kValuePresent,
    kNoValuePresent,
  };

  // Returns the required write barrier for a given `slot` and `value`.
  static V8_INLINE Type GetWriteBarrierType(const void* slot, const void* value,
                                            Params& params);
  // Returns the required write barrier for a given `slot` and `value`.
  template <typename MemberStorage>
  static V8_INLINE Type GetWriteBarrierType(const void* slot, MemberStorage,
                                            Params& params);
  // Returns the required write barrier for a given `slot`.
  template <typename HeapHandleCallback>
  static V8_INLINE Type GetWriteBarrierType(const void* slot, Params& params,
                                            HeapHandleCallback callback);
  // Returns the required write barrier for a given  `value`.
  static V8_INLINE Type GetWriteBarrierType(const void* value, Params& params);

#ifdef CPPGC_SLIM_WRITE_BARRIER
  // A write barrier that combines `GenerationalBarrier()` and
  // `DijkstraMarkingBarrier()`. We only pass a single parameter here to clobber
  // as few registers as possible.
  template <WriteBarrierSlotType>
  static V8_NOINLINE void V8_PRESERVE_MOST
  CombinedWriteBarrierSlow(const void* slot);
#endif  // CPPGC_SLIM_WRITE_BARRIER

  static V8_INLINE void DijkstraMarkingBarrier(const Params& params,
                                               const void* object);
  static V8_INLINE void DijkstraMarkingBarrierRange(
      const Params& params, const void* first_element, size_t element_size,
      size_t number_of_elements, TraceCallback trace_callback);
  static V8_INLINE void SteeleMarkingBarrier(const Params& params,
                                             const void* object);
#if defined(CPPGC_YOUNG_GENERATION)
  template <GenerationalBarrierType>
  static V8_INLINE void GenerationalBarrier(const Params& params,
                                            const void* slot);
#else  // !CPPGC_YOUNG_GENERATION
  template <GenerationalBarrierType>
  static V8_INLINE void GenerationalBarrier(const Params& params,
                                            const void* slot){}
#endif  // CPPGC_YOUNG_GENERATION

#if V8_ENABLE_CHECKS
  static void CheckParams(Type expected_type, const Params& params);
#else   // !V8_ENABLE_CHECKS
  static void CheckParams(Type expected_type, const Params& params) {}
#endif  // !V8_ENABLE_CHECKS

  // The FlagUpdater class allows cppgc internal to update
  // |write_barrier_enabled_|.
  class FlagUpdater;
  static bool IsEnabled() { return write_barrier_enabled_.MightBeEntered(); }

 private:
  WriteBarrier() = delete;

#if defined(CPPGC_CAGED_HEAP)
  using WriteBarrierTypePolicy = WriteBarrierTypeForCagedHeapPolicy;
#else   // !CPPGC_CAGED_HEAP
  using WriteBarrierTypePolicy = WriteBarrierTypeForNonCagedHeapPolicy;
#endif  // !CPPGC_CAGED_HEAP

  static void DijkstraMarkingBarrierSlow(const void* value);
  static void DijkstraMarkingBarrierSlowWithSentinelCheck(const void* value);
  static void DijkstraMarkingBarrierRangeSlow(HeapHandle& heap_handle,
                                              const void* first_element,
                                              size_t element_size,
                                              size_t number_of_elements,
                                              TraceCallback trace_callback);
  static void SteeleMarkingBarrierSlow(const void* value);
  static void SteeleMarkingBarrierSlowWithSentinelCheck(const void* value);

#if defined(CPPGC_YOUNG_GENERATION)
  static CagedHeapLocalData& GetLocalData(HeapHandle&);
  static void GenerationalBarrierSlow(const CagedHeapLocalData& local_data,
                                      const AgeTable& age_table,
                                      const void* slot, uintptr_t value_offset,
                                      HeapHandle* heap_handle);
  static void GenerationalBarrierForUncompressedSlotSlow(
      const CagedHeapLocalData& local_data, const AgeTable& age_table,
      const void* slot, uintptr_t value_offset, HeapHandle* heap_handle);
  static void GenerationalBarrierForSourceObjectSlow(
      const CagedHeapLocalData& local_data, const void* object,
      HeapHandle* heap_handle);
#endif  // CPPGC_YOUNG_GENERATION

  static AtomicEntryFlag write_barrier_enabled_;
};

template <WriteBarrier::Type type>
V8_INLINE WriteBarrier::Type SetAndReturnType(WriteBarrier::Params& params) {
  if constexpr (type == WriteBarrier::Type::kNone)
    return WriteBarrier::Type::kNone;
#if V8_ENABLE_CHECKS
  params.type = type;
#endif  // !V8_ENABLE_CHECKS
  return type;
}

#if defined(CPPGC_CAGED_HEAP)
class V8_EXPORT WriteBarrierTypeForCagedHeapPolicy final {
 public:
  template <WriteBarrier::ValueMode value_mode, typename HeapHandleCallback>
  static V8_INLINE WriteBarrier::Type Get(const void* slot, const void* value,
                                          WriteBarrier::Params& params,
                                          HeapHandleCallback callback) {
    return ValueModeDispatch<value_mode>::Get(slot, value, params, callback);
  }

  template <WriteBarrier::ValueMode value_mode, typename HeapHandleCallback,
            typename MemberStorage>
  static V8_INLINE WriteBarrier::Type Get(const void* slot, MemberStorage value,
                                          WriteBarrier::Params& params,
                                          HeapHandleCallback callback) {
    return ValueModeDispatch<value_mode>::Get(slot, value, params, callback);
  }

  template <WriteBarrier::ValueMode value_mode, typename HeapHandleCallback>
  static V8_INLINE WriteBarrier::Type Get(const void* value,
                                          WriteBarrier::Params& params,
                                          HeapHandleCallback callback) {
    return GetNoSlot(value, params, callback);
  }

 private:
  WriteBarrierTypeForCagedHeapPolicy() = delete;

  template <typename HeapHandleCallback>
  static V8_INLINE WriteBarrier::Type GetNoSlot(const void* value,
                                                WriteBarrier::Params& params,
                                                HeapHandleCallback) {
    const bool within_cage = CagedHeapBase::IsWithinCage(value);
    if (!within_cage) return WriteBarrier::Type::kNone;

    // We know that |value| points either within the normal page or to the
    // beginning of large-page, so extract the page header by bitmasking.
    BasePageHandle* page =
        BasePageHandle::FromPayload(const_cast<void*>(value));

    HeapHandle& heap_handle = page->heap_handle();
    if (V8_UNLIKELY(heap_handle.is_incremental_marking_in_progress())) {
      return SetAndReturnType<WriteBarrier::Type::kMarking>(params);
    }

    return SetAndReturnType<WriteBarrier::Type::kNone>(params);
  }

  template <WriteBarrier::ValueMode value_mode>
  struct ValueModeDispatch;
};

template <>
struct WriteBarrierTypeForCagedHeapPolicy::ValueModeDispatch<
    WriteBarrier::ValueMode::kValuePresent> {
  template <typename HeapHandleCallback, typename MemberStorage>
  static V8_INLINE WriteBarrier::Type Get(const void* slot,
                                          MemberStorage storage,
                                          WriteBarrier::Params& params,
                                          HeapHandleCallback) {
    if (V8_LIKELY(!WriteBarrier::IsEnabled()))
      return SetAndReturnType<WriteBarrier::Type::kNone>(params);

    return BarrierEnabledGet(slot, storage.Load(), params);
  }

  template <typename HeapHandleCallback>
  static V8_INLINE WriteBarrier::Type Get(const void* slot, const void* value,
                                          WriteBarrier::Params& params,
                                          HeapHandleCallback) {
    if (V8_LIKELY(!WriteBarrier::IsEnabled()))
      return SetAndReturnType<WriteBarrier::Type::kNone>(params);

    return BarrierEnabledGet(slot, value, params);
  }

 private:
  static V8_INLINE WriteBarrier::Type BarrierEnabledGet(
      const void* slot, const void* value, WriteBarrier::Params& params) {
    const bool within_cage = CagedHeapBase::AreWithinCage(slot, value);
    if (!within_cage) return WriteBarrier::Type::kNone;

    // We know that |value| points either within the normal page or to the
    // beginning of large-page, so extract the page header by bitmasking.
    BasePageHandle* page =
        BasePageHandle::FromPayload(const_cast<void*>(value));

    HeapHandle& heap_handle = page->heap_handle();
    if (V8_LIKELY(!heap_handle.is_incremental_marking_in_progress())) {
#if defined(CPPGC_YOUNG_GENERATION)
      if (!heap_handle.is_young_generation_enabled())
        return WriteBarrier::Type::kNone;
      params.heap = &heap_handle;
      params.slot_offset = CagedHeapBase::OffsetFromAddress(slot);
      params.value_offset = CagedHeapBase::OffsetFromAddress(value);
      return SetAndReturnType<WriteBarrier::Type::kGenerational>(params);
#else   // !CPPGC_YOUNG_GENERATION
      return SetAndReturnType<WriteBarrier::Type::kNone>(params);
#endif  // !CPPGC_YOUNG_GENERATION
    }

    // Use marking barrier.
    params.heap = &heap_handle;
    return SetAndReturnType<WriteBarrier::Type::kMarking>(params);
  }
};

template <>
struct WriteBarrierTypeForCagedHeapPolicy::ValueModeDispatch<
    WriteBarrier::ValueMode::kNoValuePresent> {
  template <typename HeapHandleCallback>
  static V8_INLINE WriteBarrier::Type Get(const void* slot, const void*,
                                          WriteBarrier::Params& params,
                                          HeapHandleCallback callback) {
    if (V8_LIKELY(!WriteBarrier::IsEnabled()))
      return SetAndReturnType<WriteBarrier::Type::kNone>(params);

    HeapHandle& handle = callback();
#if defined(CPPGC_YOUNG_GENERATION)
    if (V8_LIKELY(!handle.is_incremental_marking_in_progress())) {
      if (!handle.is_young_generation_enabled()) {
        return WriteBarrier::Type::kNone;
      }
      params.heap = &handle;
      // Check if slot is on stack.
      if (V8_UNLIKELY(!CagedHeapBase::IsWithinCage(slot))) {
        return SetAndReturnType<WriteBarrier::Type::kNone>(params);
      }
      params.slot_offset = CagedHeapBase::OffsetFromAddress(slot);
      return SetAndReturnType<WriteBarrier::Type::kGenerational>(params);
    }
#else   // !defined(CPPGC_YOUNG_GENERATION)
    if (V8_UNLIKELY(!handle.is_incremental_marking_in_progress())) {
      return SetAndReturnType<WriteBarrier::Type::kNone>(params);
    }
#endif  // !defined(CPPGC_YOUNG_GENERATION)
    params.heap = &handle;
    return SetAndReturnType<WriteBarrier::Type::kMarking>(params);
  }
};

#endif  // CPPGC_CAGED_HEAP

class V8_EXPORT WriteBarrierTypeForNonCagedHeapPolicy final {
 public:
  template <WriteBarrier::ValueMode value_mode, typename HeapHandleCallback>
  static V8_INLINE WriteBarrier::Type Get(const void* slot, const void* value,
                                          WriteBarrier::Params& params,
                                          HeapHandleCallback callback) {
    return ValueModeDispatch<value_mode>::Get(slot, value, params, callback);
  }

  template <WriteBarrier::ValueMode value_mode, typename HeapHandleCallback>
  static V8_INLINE WriteBarrier::Type Get(const void* slot, RawPointer value,
                                          WriteBarrier::Params& params,
                                          HeapHandleCallback callback) {
    return ValueModeDispatch<value_mode>::Get(slot, value.Load(), params,
                                              callback);
  }

  template <WriteBarrier::ValueMode value_mode, typename HeapHandleCallback>
  static V8_INLINE WriteBarrier::Type Get(const void* value,
                                          WriteBarrier::Params& params,
                                          HeapHandleCallback callback) {
    // The slot will never be used in `Get()` below.
    return Get<WriteBarrier::ValueMode::kValuePresent>(nullptr, value, params,
                                                       callback);
  }

 private:
  template <WriteBarrier::ValueMode value_mode>
  struct ValueModeDispatch;

  WriteBarrierTypeForNonCagedHeapPolicy() = delete;
};

template <>
struct WriteBarrierTypeForNonCagedHeapPolicy::ValueModeDispatch<
    WriteBarrier::ValueMode::kValuePresent> {
  template <typename HeapHandleCallback>
  static V8_INLINE WriteBarrier::Type Get(const void*, const void* object,
                                          WriteBarrier::Params& params,
                                          HeapHandleCallback callback) {
    // The following check covers nullptr as well as sentinel pointer.
    if (object <= static_cast<void*>(kSentinelPointer)) {
      return SetAndReturnType<WriteBarrier::Type::kNone>(params);
    }
    if (V8_LIKELY(!WriteBarrier::IsEnabled())) {
      return SetAndReturnType<WriteBarrier::Type::kNone>(params);
    }
    // We know that |object| is within the normal page or in the beginning of a
    // large page, so extract the page header by bitmasking.
    BasePageHandle* page =
        BasePageHandle::FromPayload(const_cast<void*>(object));

    HeapHandle& heap_handle = page->heap_handle();
    if (V8_LIKELY(heap_handle.is_incremental_marking_in_progress())) {
      return SetAndReturnType<WriteBarrier::Type::kMarking>(params);
    }
    return SetAndReturnType<WriteBarrier::Type::kNone>(params);
  }
};

template <>
struct WriteBarrierTypeForNonCagedHeapPolicy::ValueModeDispatch<
    WriteBarrier::ValueMode::kNoValuePresent> {
  template <typename HeapHandleCallback>
  static V8_INLINE WriteBarrier::Type Get(const void*, const void*,
                                          WriteBarrier::Params& params,
                                          HeapHandleCallback callback) {
    if (V8_UNLIKELY(WriteBarrier::IsEnabled())) {
      HeapHandle& handle = callback();
      if (V8_LIKELY(handle.is_incremental_marking_in_progress())) {
        params.heap = &handle;
        return SetAndReturnType<WriteBarrier::Type::kMarking>(params);
      }
    }
    return WriteBarrier::Type::kNone;
  }
};

// static
WriteBarrier::Type WriteBarrier::GetWriteBarrierType(
    const void* slot, const void* value, WriteBarrier::Params& params) {
  return WriteBarrierTypePolicy::Get<ValueMode::kValuePresent>(slot, value,
                                                               params, []() {});
}

// static
template <typename MemberStorage>
WriteBarrier::Type WriteBarrier::GetWriteBarrierType(
    const void* slot, MemberStorage value, WriteBarrier::Params& params) {
  return WriteBarrierTypePolicy::Get<ValueMode::kValuePresent>(slot, value,
                                                               params, []() {});
}

// static
template <typename HeapHandleCallback>
WriteBarrier::Type WriteBarrier::GetWriteBarrierType(
    const void* slot, WriteBarrier::Params& params,
    HeapHandleCallback callback) {
  return WriteBarrierTypePolicy::Get<ValueMode::kNoValuePresent>(
      slot, nullptr, params, callback);
}

// static
WriteBarrier::Type WriteBarrier::GetWriteBarrierType(
    const void* value, WriteBarrier::Params& params) {
  return WriteBarrierTypePolicy::Get<ValueMode::kValuePresent>(value, params,
                                                               []() {});
}

// static
void WriteBarrier::DijkstraMarkingBarrier(const Params& params,
                                          const void* object) {
  CheckParams(Type::kMarking, params);
#if defined(CPPGC_CAGED_HEAP)
  // Caged heap already filters out sentinels.
  DijkstraMarkingBarrierSlow(object);
#else   // !CPPGC_CAGED_HEAP
  DijkstraMarkingBarrierSlowWithSentinelCheck(object);
#endif  // !CPPGC_CAGED_HEAP
}

// static
void WriteBarrier::DijkstraMarkingBarrierRange(const Params& params,
                                               const void* first_element,
                                               size_t element_size,
                                               size_t number_of_elements,
                                               TraceCallback trace_callback) {
  CheckParams(Type::kMarking, params);
  DijkstraMarkingBarrierRangeSlow(*params.heap, first_element, element_size,
                                  number_of_elements, trace_callback);
}

// static
void WriteBarrier::SteeleMarkingBarrier(const Params& params,
                                        const void* object) {
  CheckParams(Type::kMarking, params);
#if defined(CPPGC_CAGED_HEAP)
  // Caged heap already filters out sentinels.
  SteeleMarkingBarrierSlow(object);
#else   // !CPPGC_CAGED_HEAP
  SteeleMarkingBarrierSlowWithSentinelCheck(object);
#endif  // !CPPGC_CAGED_HEAP
}

#if defined(CPPGC_YOUNG_GENERATION)

// static
template <WriteBarrier::GenerationalBarrierType type>
void WriteBarrier::GenerationalBarrier(const Params& params, const void* slot) {
  CheckParams(Type::kGenerational, params);

  const CagedHeapLocalData& local_data = CagedHeapLocalData::Get();
  const AgeTable& age_table = local_data.age_table;

  // Bail out if the slot (precise or imprecise) is in young generation.
  if (V8_LIKELY(age_table.GetAge(params.slot_offset) == AgeTable::Age::kYoung))
    return;

  // Dispatch between different types of barriers.
  // TODO(chromium:1029379): Consider reload local_data in the slow path to
  // reduce register pressure.
  if constexpr (type == GenerationalBarrierType::kPreciseSlot) {
    GenerationalBarrierSlow(local_data, age_table, slot, params.value_offset,
                            params.heap);
  } else if constexpr (type ==
                       GenerationalBarrierType::kPreciseUncompressedSlot) {
    GenerationalBarrierForUncompressedSlotSlow(
        local_data, age_table, slot, params.value_offset, params.heap);
  } else {
    GenerationalBarrierForSourceObjectSlow(local_data, slot, params.heap);
  }
}

#endif  // !CPPGC_YOUNG_GENERATION

}  // namespace internal
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_INTERNAL_WRITE_BARRIER_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/include/cppgc/liveness-broker.h                                                 0000664 0000000 0000000 00000004534 14746647661 0022055 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_LIVENESS_BROKER_H_
#define INCLUDE_CPPGC_LIVENESS_BROKER_H_

#include "cppgc/heap.h"
#include "cppgc/member.h"
#include "cppgc/sentinel-pointer.h"
#include "cppgc/trace-trait.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {

namespace internal {
class LivenessBrokerFactory;
}  // namespace internal

/**
 * The broker is passed to weak callbacks to allow (temporarily) querying
 * the liveness state of an object. References to non-live objects must be
 * cleared when `IsHeapObjectAlive()` returns false.
 *
 * \code
 * class GCedWithCustomWeakCallback final
 *   : public GarbageCollected<GCedWithCustomWeakCallback> {
 *  public:
 *   UntracedMember<Bar> bar;
 *
 *   void CustomWeakCallbackMethod(const LivenessBroker& broker) {
 *     if (!broker.IsHeapObjectAlive(bar))
 *       bar = nullptr;
 *   }
 *
 *   void Trace(cppgc::Visitor* visitor) const {
 *     visitor->RegisterWeakCallbackMethod<
 *         GCedWithCustomWeakCallback,
 *         &GCedWithCustomWeakCallback::CustomWeakCallbackMethod>(this);
 *   }
 * };
 * \endcode
 */
class V8_EXPORT LivenessBroker final {
 public:
  template <typename T>
  bool IsHeapObjectAlive(const T* object) const {
    // - nullptr objects are considered alive to allow weakness to be used from
    // stack while running into a conservative GC. Treating nullptr as dead
    // would mean that e.g. custom collections could not be strongified on
    // stack.
    // - Sentinel pointers are also preserved in weakness and not cleared.
    return !object || object == kSentinelPointer ||
           IsHeapObjectAliveImpl(
               TraceTrait<T>::GetTraceDescriptor(object).base_object_payload);
  }

  template <typename T>
  bool IsHeapObjectAlive(const WeakMember<T>& weak_member) const {
    return IsHeapObjectAlive<T>(weak_member.Get());
  }

  template <typename T>
  bool IsHeapObjectAlive(const UntracedMember<T>& untraced_member) const {
    return IsHeapObjectAlive<T>(untraced_member.Get());
  }

 private:
  LivenessBroker() = default;

  bool IsHeapObjectAliveImpl(const void*) const;

  friend class internal::LivenessBrokerFactory;
};

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_LIVENESS_BROKER_H_
                                                                                                                                                                    node-23.7.0/deps/v8/include/cppgc/macros.h                                                          0000664 0000000 0000000 00000002501 14746647661 0020217 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_MACROS_H_
#define INCLUDE_CPPGC_MACROS_H_

#include <cstddef>

#include "cppgc/internal/compiler-specific.h"

namespace cppgc {

// Use CPPGC_STACK_ALLOCATED if the object is only stack allocated.
// Add the CPPGC_STACK_ALLOCATED_IGNORE annotation on a case-by-case basis when
// enforcement of CPPGC_STACK_ALLOCATED should be suppressed.
#if defined(__clang__)
#define CPPGC_STACK_ALLOCATED()                        \
 public:                                               \
  using IsStackAllocatedTypeMarker CPPGC_UNUSED = int; \
                                                       \
 private:                                              \
  void* operator new(size_t) = delete;                 \
  void* operator new(size_t, void*) = delete;          \
  static_assert(true, "Force semicolon.")
#define CPPGC_STACK_ALLOCATED_IGNORE(bug_or_reason) \
  __attribute__((annotate("stack_allocated_ignore")))
#else  // !defined(__clang__)
#define CPPGC_STACK_ALLOCATED() static_assert(true, "Force semicolon.")
#define CPPGC_STACK_ALLOCATED_IGNORE(bug_or_reason)
#endif  // !defined(__clang__)

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_MACROS_H_
                                                                                                                                                                                               node-23.7.0/deps/v8/include/cppgc/member.h                                                          0000664 0000000 0000000 00000057062 14746647661 0020216 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_MEMBER_H_
#define INCLUDE_CPPGC_MEMBER_H_

#include <atomic>
#include <cstddef>
#include <type_traits>

#include "cppgc/internal/api-constants.h"
#include "cppgc/internal/member-storage.h"
#include "cppgc/internal/pointer-policies.h"
#include "cppgc/sentinel-pointer.h"
#include "cppgc/type-traits.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {

namespace subtle {
class HeapConsistency;
}  // namespace subtle

class Visitor;

namespace internal {

// MemberBase always refers to the object as const object and defers to
// BasicMember on casting to the right type as needed.
template <typename StorageType>
class V8_TRIVIAL_ABI MemberBase {
 public:
  using RawStorage = StorageType;

 protected:
  struct AtomicInitializerTag {};

  V8_INLINE MemberBase() = default;
  V8_INLINE explicit MemberBase(const void* value) : raw_(value) {}
  V8_INLINE MemberBase(const void* value, AtomicInitializerTag) {
    SetRawAtomic(value);
  }

  V8_INLINE explicit MemberBase(RawStorage raw) : raw_(raw) {}
  V8_INLINE explicit MemberBase(std::nullptr_t) : raw_(nullptr) {}
  V8_INLINE explicit MemberBase(SentinelPointer s) : raw_(s) {}

  V8_INLINE const void** GetRawSlot() const {
    return reinterpret_cast<const void**>(const_cast<MemberBase*>(this));
  }
  V8_INLINE const void* GetRaw() const { return raw_.Load(); }
  V8_INLINE void SetRaw(void* value) { raw_.Store(value); }

  V8_INLINE const void* GetRawAtomic() const { return raw_.LoadAtomic(); }
  V8_INLINE void SetRawAtomic(const void* value) { raw_.StoreAtomic(value); }

  V8_INLINE RawStorage GetRawStorage() const { return raw_; }
  V8_INLINE void SetRawStorageAtomic(RawStorage other) {
    reinterpret_cast<std::atomic<RawStorage>&>(raw_).store(
        other, std::memory_order_relaxed);
  }

  V8_INLINE bool IsCleared() const { return raw_.IsCleared(); }

  V8_INLINE void ClearFromGC() const { raw_.Clear(); }

 private:
  friend class MemberDebugHelper;

  mutable RawStorage raw_;
};

// The basic class from which all Member classes are 'generated'.
template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy, typename StorageType>
class V8_TRIVIAL_ABI BasicMember final : private MemberBase<StorageType>,
                                         private CheckingPolicy {
  using Base = MemberBase<StorageType>;

 public:
  using PointeeType = T;
  using RawStorage = typename Base::RawStorage;

  V8_INLINE constexpr BasicMember() = default;
  V8_INLINE constexpr BasicMember(std::nullptr_t) {}     // NOLINT
  V8_INLINE BasicMember(SentinelPointer s) : Base(s) {}  // NOLINT
  V8_INLINE BasicMember(T* raw) : Base(raw) {            // NOLINT
    InitializingWriteBarrier(raw);
    this->CheckPointer(Get());
  }
  V8_INLINE BasicMember(T& raw)  // NOLINT
      : BasicMember(&raw) {}

  // Atomic ctor. Using the AtomicInitializerTag forces BasicMember to
  // initialize using atomic assignments. This is required for preventing
  // data races with concurrent marking.
  using AtomicInitializerTag = typename Base::AtomicInitializerTag;
  V8_INLINE BasicMember(std::nullptr_t, AtomicInitializerTag atomic)
      : Base(nullptr, atomic) {}
  V8_INLINE BasicMember(SentinelPointer s, AtomicInitializerTag atomic)
      : Base(s, atomic) {}
  V8_INLINE BasicMember(T* raw, AtomicInitializerTag atomic)
      : Base(raw, atomic) {
    InitializingWriteBarrier(raw);
    this->CheckPointer(Get());
  }
  V8_INLINE BasicMember(T& raw, AtomicInitializerTag atomic)
      : BasicMember(&raw, atomic) {}

  // Copy ctor.
  V8_INLINE BasicMember(const BasicMember& other)
      : BasicMember(other.GetRawStorage()) {}

  // Heterogeneous copy constructors. When the source pointer have a different
  // type, perform a compress-decompress round, because the source pointer may
  // need to be adjusted.
  template <typename U, typename OtherBarrierPolicy, typename OtherWeaknessTag,
            typename OtherCheckingPolicy,
            std::enable_if_t<internal::IsDecayedSameV<T, U>>* = nullptr>
  V8_INLINE BasicMember(  // NOLINT
      const BasicMember<U, OtherWeaknessTag, OtherBarrierPolicy,
                        OtherCheckingPolicy, StorageType>& other)
      : BasicMember(other.GetRawStorage()) {}

  template <typename U, typename OtherBarrierPolicy, typename OtherWeaknessTag,
            typename OtherCheckingPolicy,
            std::enable_if_t<internal::IsStrictlyBaseOfV<T, U>>* = nullptr>
  V8_INLINE BasicMember(  // NOLINT
      const BasicMember<U, OtherWeaknessTag, OtherBarrierPolicy,
                        OtherCheckingPolicy, StorageType>& other)
      : BasicMember(other.Get()) {}

  // Move ctor.
  V8_INLINE BasicMember(BasicMember&& other) noexcept
      : BasicMember(other.GetRawStorage()) {
    other.Clear();
  }

  // Heterogeneous move constructors. When the source pointer have a different
  // type, perform a compress-decompress round, because the source pointer may
  // need to be adjusted.
  template <typename U, typename OtherBarrierPolicy, typename OtherWeaknessTag,
            typename OtherCheckingPolicy,
            std::enable_if_t<internal::IsDecayedSameV<T, U>>* = nullptr>
  V8_INLINE BasicMember(
      BasicMember<U, OtherWeaknessTag, OtherBarrierPolicy, OtherCheckingPolicy,
                  StorageType>&& other) noexcept
      : BasicMember(other.GetRawStorage()) {
    other.Clear();
  }

  template <typename U, typename OtherBarrierPolicy, typename OtherWeaknessTag,
            typename OtherCheckingPolicy,
            std::enable_if_t<internal::IsStrictlyBaseOfV<T, U>>* = nullptr>
  V8_INLINE BasicMember(
      BasicMember<U, OtherWeaknessTag, OtherBarrierPolicy, OtherCheckingPolicy,
                  StorageType>&& other) noexcept
      : BasicMember(other.Get()) {
    other.Clear();
  }

  // Construction from Persistent.
  template <typename U, typename PersistentWeaknessPolicy,
            typename PersistentLocationPolicy,
            typename PersistentCheckingPolicy,
            typename = std::enable_if_t<std::is_base_of<T, U>::value>>
  V8_INLINE BasicMember(const BasicPersistent<U, PersistentWeaknessPolicy,
                                              PersistentLocationPolicy,
                                              PersistentCheckingPolicy>& p)
      : BasicMember(p.Get()) {}

  // Copy assignment.
  V8_INLINE BasicMember& operator=(const BasicMember& other) {
    return operator=(other.GetRawStorage());
  }

  // Heterogeneous copy assignment. When the source pointer have a different
  // type, perform a compress-decompress round, because the source pointer may
  // need to be adjusted.
  template <typename U, typename OtherWeaknessTag, typename OtherBarrierPolicy,
            typename OtherCheckingPolicy>
  V8_INLINE BasicMember& operator=(
      const BasicMember<U, OtherWeaknessTag, OtherBarrierPolicy,
                        OtherCheckingPolicy, StorageType>& other) {
    if constexpr (internal::IsDecayedSameV<T, U>) {
      return operator=(other.GetRawStorage());
    } else {
      static_assert(internal::IsStrictlyBaseOfV<T, U>);
      return operator=(other.Get());
    }
  }

  // Move assignment.
  V8_INLINE BasicMember& operator=(BasicMember&& other) noexcept {
    operator=(other.GetRawStorage());
    other.Clear();
    return *this;
  }

  // Heterogeneous move assignment. When the source pointer have a different
  // type, perform a compress-decompress round, because the source pointer may
  // need to be adjusted.
  template <typename U, typename OtherWeaknessTag, typename OtherBarrierPolicy,
            typename OtherCheckingPolicy>
  V8_INLINE BasicMember& operator=(
      BasicMember<U, OtherWeaknessTag, OtherBarrierPolicy, OtherCheckingPolicy,
                  StorageType>&& other) noexcept {
    if constexpr (internal::IsDecayedSameV<T, U>) {
      operator=(other.GetRawStorage());
    } else {
      static_assert(internal::IsStrictlyBaseOfV<T, U>);
      operator=(other.Get());
    }
    other.Clear();
    return *this;
  }

  // Assignment from Persistent.
  template <typename U, typename PersistentWeaknessPolicy,
            typename PersistentLocationPolicy,
            typename PersistentCheckingPolicy,
            typename = std::enable_if_t<std::is_base_of<T, U>::value>>
  V8_INLINE BasicMember& operator=(
      const BasicPersistent<U, PersistentWeaknessPolicy,
                            PersistentLocationPolicy, PersistentCheckingPolicy>&
          other) {
    return operator=(other.Get());
  }

  V8_INLINE BasicMember& operator=(T* other) {
    Base::SetRawAtomic(other);
    AssigningWriteBarrier(other);
    this->CheckPointer(Get());
    return *this;
  }

  V8_INLINE BasicMember& operator=(std::nullptr_t) {
    Clear();
    return *this;
  }
  V8_INLINE BasicMember& operator=(SentinelPointer s) {
    Base::SetRawAtomic(s);
    return *this;
  }

  template <typename OtherWeaknessTag, typename OtherBarrierPolicy,
            typename OtherCheckingPolicy>
  V8_INLINE void Swap(BasicMember<T, OtherWeaknessTag, OtherBarrierPolicy,
                                  OtherCheckingPolicy, StorageType>& other) {
    auto tmp = GetRawStorage();
    *this = other;
    other = tmp;
  }

  V8_INLINE explicit operator bool() const { return !Base::IsCleared(); }
  V8_INLINE operator T*() const { return Get(); }
  V8_INLINE T* operator->() const { return Get(); }
  V8_INLINE T& operator*() const { return *Get(); }

  // CFI cast exemption to allow passing SentinelPointer through T* and support
  // heterogeneous assignments between different Member and Persistent handles
  // based on their actual types.
  V8_INLINE V8_CLANG_NO_SANITIZE("cfi-unrelated-cast") T* Get() const {
    // Executed by the mutator, hence non atomic load.
    //
    // The const_cast below removes the constness from MemberBase storage. The
    // following static_cast re-adds any constness if specified through the
    // user-visible template parameter T.
    return static_cast<T*>(const_cast<void*>(Base::GetRaw()));
  }

  V8_INLINE void Clear() {
    Base::SetRawStorageAtomic(RawStorage{});
  }

  V8_INLINE T* Release() {
    T* result = Get();
    Clear();
    return result;
  }

  V8_INLINE const T** GetSlotForTesting() const {
    return reinterpret_cast<const T**>(Base::GetRawSlot());
  }

  V8_INLINE RawStorage GetRawStorage() const {
    return Base::GetRawStorage();
  }

 private:
  V8_INLINE explicit BasicMember(RawStorage raw) : Base(raw) {
    InitializingWriteBarrier(Get());
    this->CheckPointer(Get());
  }

  V8_INLINE BasicMember& operator=(RawStorage other) {
    Base::SetRawStorageAtomic(other);
    AssigningWriteBarrier();
    this->CheckPointer(Get());
    return *this;
  }

  V8_INLINE const T* GetRawAtomic() const {
    return static_cast<const T*>(Base::GetRawAtomic());
  }

  V8_INLINE void InitializingWriteBarrier(T* value) const {
    WriteBarrierPolicy::InitializingBarrier(Base::GetRawSlot(), value);
  }
  V8_INLINE void AssigningWriteBarrier(T* value) const {
    WriteBarrierPolicy::template AssigningBarrier<
        StorageType::kWriteBarrierSlotType>(Base::GetRawSlot(), value);
  }
  V8_INLINE void AssigningWriteBarrier() const {
    WriteBarrierPolicy::template AssigningBarrier<
        StorageType::kWriteBarrierSlotType>(Base::GetRawSlot(),
                                            Base::GetRawStorage());
  }

  V8_INLINE void ClearFromGC() const { Base::ClearFromGC(); }

  V8_INLINE T* GetFromGC() const { return Get(); }

  friend class cppgc::subtle::HeapConsistency;
  friend class cppgc::Visitor;
  template <typename U>
  friend struct cppgc::TraceTrait;
  template <typename T1, typename WeaknessTag1, typename WriteBarrierPolicy1,
            typename CheckingPolicy1, typename StorageType1>
  friend class BasicMember;
};

// Member equality operators.
template <typename T1, typename WeaknessTag1, typename WriteBarrierPolicy1,
          typename CheckingPolicy1, typename T2, typename WeaknessTag2,
          typename WriteBarrierPolicy2, typename CheckingPolicy2,
          typename StorageType>
V8_INLINE bool operator==(
    const BasicMember<T1, WeaknessTag1, WriteBarrierPolicy1, CheckingPolicy1,
                      StorageType>& member1,
    const BasicMember<T2, WeaknessTag2, WriteBarrierPolicy2, CheckingPolicy2,
                      StorageType>& member2) {
  if constexpr (internal::IsDecayedSameV<T1, T2>) {
    // Check compressed pointers if types are the same.
    return member1.GetRawStorage() == member2.GetRawStorage();
  } else {
    static_assert(internal::IsStrictlyBaseOfV<T1, T2> ||
                  internal::IsStrictlyBaseOfV<T2, T1>);
    // Otherwise, check decompressed pointers.
    return member1.Get() == member2.Get();
  }
}

template <typename T1, typename WeaknessTag1, typename WriteBarrierPolicy1,
          typename CheckingPolicy1, typename T2, typename WeaknessTag2,
          typename WriteBarrierPolicy2, typename CheckingPolicy2,
          typename StorageType>
V8_INLINE bool operator!=(
    const BasicMember<T1, WeaknessTag1, WriteBarrierPolicy1, CheckingPolicy1,
                      StorageType>& member1,
    const BasicMember<T2, WeaknessTag2, WriteBarrierPolicy2, CheckingPolicy2,
                      StorageType>& member2) {
  return !(member1 == member2);
}

// Equality with raw pointers.
template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy, typename StorageType, typename U>
V8_INLINE bool operator==(
    const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,
                      StorageType>& member,
    U* raw) {
  // Never allow comparison with erased pointers.
  static_assert(!internal::IsDecayedSameV<void, U>);

  if constexpr (internal::IsDecayedSameV<T, U>) {
    // Check compressed pointers if types are the same.
    return member.GetRawStorage() == StorageType(raw);
  } else if constexpr (internal::IsStrictlyBaseOfV<T, U>) {
    // Cast the raw pointer to T, which may adjust the pointer.
    return member.GetRawStorage() == StorageType(static_cast<T*>(raw));
  } else {
    // Otherwise, decompressed the member.
    return member.Get() == raw;
  }
}

template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy, typename StorageType, typename U>
V8_INLINE bool operator!=(
    const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,
                      StorageType>& member,
    U* raw) {
  return !(member == raw);
}

template <typename T, typename U, typename WeaknessTag,
          typename WriteBarrierPolicy, typename CheckingPolicy,
          typename StorageType>
V8_INLINE bool operator==(
    T* raw, const BasicMember<U, WeaknessTag, WriteBarrierPolicy,
                              CheckingPolicy, StorageType>& member) {
  return member == raw;
}

template <typename T, typename U, typename WeaknessTag,
          typename WriteBarrierPolicy, typename CheckingPolicy,
          typename StorageType>
V8_INLINE bool operator!=(
    T* raw, const BasicMember<U, WeaknessTag, WriteBarrierPolicy,
                              CheckingPolicy, StorageType>& member) {
  return !(raw == member);
}

// Equality with sentinel.
template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy, typename StorageType>
V8_INLINE bool operator==(
    const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,
                      StorageType>& member,
    SentinelPointer) {
  return member.GetRawStorage().IsSentinel();
}

template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy, typename StorageType>
V8_INLINE bool operator!=(
    const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,
                      StorageType>& member,
    SentinelPointer s) {
  return !(member == s);
}

template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy, typename StorageType>
V8_INLINE bool operator==(
    SentinelPointer s, const BasicMember<T, WeaknessTag, WriteBarrierPolicy,
                                         CheckingPolicy, StorageType>& member) {
  return member == s;
}

template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy, typename StorageType>
V8_INLINE bool operator!=(
    SentinelPointer s, const BasicMember<T, WeaknessTag, WriteBarrierPolicy,
                                         CheckingPolicy, StorageType>& member) {
  return !(s == member);
}

// Equality with nullptr.
template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy, typename StorageType>
V8_INLINE bool operator==(
    const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,
                      StorageType>& member,
    std::nullptr_t) {
  return !static_cast<bool>(member);
}

template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy, typename StorageType>
V8_INLINE bool operator!=(
    const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,
                      StorageType>& member,
    std::nullptr_t n) {
  return !(member == n);
}

template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy, typename StorageType>
V8_INLINE bool operator==(
    std::nullptr_t n, const BasicMember<T, WeaknessTag, WriteBarrierPolicy,
                                        CheckingPolicy, StorageType>& member) {
  return member == n;
}

template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy, typename StorageType>
V8_INLINE bool operator!=(
    std::nullptr_t n, const BasicMember<T, WeaknessTag, WriteBarrierPolicy,
                                        CheckingPolicy, StorageType>& member) {
  return !(n == member);
}

// Relational operators.
template <typename T1, typename WeaknessTag1, typename WriteBarrierPolicy1,
          typename CheckingPolicy1, typename T2, typename WeaknessTag2,
          typename WriteBarrierPolicy2, typename CheckingPolicy2,
          typename StorageType>
V8_INLINE bool operator<(
    const BasicMember<T1, WeaknessTag1, WriteBarrierPolicy1, CheckingPolicy1,
                      StorageType>& member1,
    const BasicMember<T2, WeaknessTag2, WriteBarrierPolicy2, CheckingPolicy2,
                      StorageType>& member2) {
  static_assert(
      internal::IsDecayedSameV<T1, T2>,
      "Comparison works only for same pointer type modulo cv-qualifiers");
  return member1.GetRawStorage() < member2.GetRawStorage();
}

template <typename T1, typename WeaknessTag1, typename WriteBarrierPolicy1,
          typename CheckingPolicy1, typename T2, typename WeaknessTag2,
          typename WriteBarrierPolicy2, typename CheckingPolicy2,
          typename StorageType>
V8_INLINE bool operator<=(
    const BasicMember<T1, WeaknessTag1, WriteBarrierPolicy1, CheckingPolicy1,
                      StorageType>& member1,
    const BasicMember<T2, WeaknessTag2, WriteBarrierPolicy2, CheckingPolicy2,
                      StorageType>& member2) {
  static_assert(
      internal::IsDecayedSameV<T1, T2>,
      "Comparison works only for same pointer type modulo cv-qualifiers");
  return member1.GetRawStorage() <= member2.GetRawStorage();
}

template <typename T1, typename WeaknessTag1, typename WriteBarrierPolicy1,
          typename CheckingPolicy1, typename T2, typename WeaknessTag2,
          typename WriteBarrierPolicy2, typename CheckingPolicy2,
          typename StorageType>
V8_INLINE bool operator>(
    const BasicMember<T1, WeaknessTag1, WriteBarrierPolicy1, CheckingPolicy1,
                      StorageType>& member1,
    const BasicMember<T2, WeaknessTag2, WriteBarrierPolicy2, CheckingPolicy2,
                      StorageType>& member2) {
  static_assert(
      internal::IsDecayedSameV<T1, T2>,
      "Comparison works only for same pointer type modulo cv-qualifiers");
  return member1.GetRawStorage() > member2.GetRawStorage();
}

template <typename T1, typename WeaknessTag1, typename WriteBarrierPolicy1,
          typename CheckingPolicy1, typename T2, typename WeaknessTag2,
          typename WriteBarrierPolicy2, typename CheckingPolicy2,
          typename StorageType>
V8_INLINE bool operator>=(
    const BasicMember<T1, WeaknessTag1, WriteBarrierPolicy1, CheckingPolicy1,
                      StorageType>& member1,
    const BasicMember<T2, WeaknessTag2, WriteBarrierPolicy2, CheckingPolicy2,
                      StorageType>& member2) {
  static_assert(
      internal::IsDecayedSameV<T1, T2>,
      "Comparison works only for same pointer type modulo cv-qualifiers");
  return member1.GetRawStorage() >= member2.GetRawStorage();
}

template <typename T, typename WriteBarrierPolicy, typename CheckingPolicy,
          typename StorageType>
struct IsWeak<internal::BasicMember<T, WeakMemberTag, WriteBarrierPolicy,
                                    CheckingPolicy, StorageType>>
    : std::true_type {};

}  // namespace internal

/**
 * Members are used in classes to contain strong pointers to other garbage
 * collected objects. All Member fields of a class must be traced in the class'
 * trace method.
 */
template <typename T>
using Member = internal::BasicMember<
    T, internal::StrongMemberTag, internal::DijkstraWriteBarrierPolicy,
    internal::DefaultMemberCheckingPolicy, internal::DefaultMemberStorage>;

/**
 * WeakMember is similar to Member in that it is used to point to other garbage
 * collected objects. However instead of creating a strong pointer to the
 * object, the WeakMember creates a weak pointer, which does not keep the
 * pointee alive. Hence if all pointers to to a heap allocated object are weak
 * the object will be garbage collected. At the time of GC the weak pointers
 * will automatically be set to null.
 */
template <typename T>
using WeakMember = internal::BasicMember<
    T, internal::WeakMemberTag, internal::DijkstraWriteBarrierPolicy,
    internal::DefaultMemberCheckingPolicy, internal::DefaultMemberStorage>;

/**
 * UntracedMember is a pointer to an on-heap object that is not traced for some
 * reason. Do not use this unless you know what you are doing. Keeping raw
 * pointers to on-heap objects is prohibited unless used from stack. Pointee
 * must be kept alive through other means.
 */
template <typename T>
using UntracedMember = internal::BasicMember<
    T, internal::UntracedMemberTag, internal::NoWriteBarrierPolicy,
    internal::DefaultMemberCheckingPolicy, internal::DefaultMemberStorage>;

namespace subtle {

/**
 * UncompressedMember. Use with care in hot paths that would otherwise cause
 * many decompression cycles.
 */
template <typename T>
using UncompressedMember = internal::BasicMember<
    T, internal::StrongMemberTag, internal::DijkstraWriteBarrierPolicy,
    internal::DefaultMemberCheckingPolicy, internal::RawPointer>;

#if defined(CPPGC_POINTER_COMPRESSION)
/**
 * CompressedMember. Default implementation of cppgc::Member on builds with
 * pointer compression.
 */
template <typename T>
using CompressedMember = internal::BasicMember<
    T, internal::StrongMemberTag, internal::DijkstraWriteBarrierPolicy,
    internal::DefaultMemberCheckingPolicy, internal::CompressedPointer>;
#endif  // defined(CPPGC_POINTER_COMPRESSION)

}  // namespace subtle

namespace internal {

struct Dummy;

static constexpr size_t kSizeOfMember = sizeof(Member<Dummy>);
static constexpr size_t kSizeOfUncompressedMember =
    sizeof(subtle::UncompressedMember<Dummy>);
#if defined(CPPGC_POINTER_COMPRESSION)
static constexpr size_t kSizeofCompressedMember =
    sizeof(subtle::CompressedMember<Dummy>);
#endif  // defined(CPPGC_POINTER_COMPRESSION)

}  // namespace internal

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_MEMBER_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/include/cppgc/name-provider.h                                                   0000664 0000000 0000000 00000004705 14746647661 0021513 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_NAME_PROVIDER_H_
#define INCLUDE_CPPGC_NAME_PROVIDER_H_

#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {

/**
 * NameProvider allows for providing a human-readable name for garbage-collected
 * objects.
 *
 * There's two cases of names to distinguish:
 * a. Explicitly specified names via using NameProvider. Such names are always
 *    preserved in the system.
 * b. Internal names that Oilpan infers from a C++ type on the class hierarchy
 *    of the object. This is not necessarily the type of the actually
 *    instantiated object.
 *
 * Depending on the build configuration, Oilpan may hide names, i.e., represent
 * them with kHiddenName, of case b. to avoid exposing internal details.
 */
class V8_EXPORT NameProvider {
 public:
  /**
   * Name that is used when hiding internals.
   */
  static constexpr const char kHiddenName[] = "InternalNode";

  /**
   * Name that is used in case compiler support is missing for composing a name
   * from C++ types.
   */
  static constexpr const char kNoNameDeducible[] = "<No name>";

  /**
   * Indicating whether the build supports extracting C++ names as object names.
   *
   * @returns true if C++ names should be hidden and represented by kHiddenName.
   */
  static constexpr bool SupportsCppClassNamesAsObjectNames() {
#if CPPGC_SUPPORTS_OBJECT_NAMES
    return true;
#else   // !CPPGC_SUPPORTS_OBJECT_NAMES
    return false;
#endif  // !CPPGC_SUPPORTS_OBJECT_NAMES
  }

  virtual ~NameProvider() = default;

  /**
   * Specifies a name for the garbage-collected object. Such names will never
   * be hidden, as they are explicitly specified by the user of this API.
   *
   * V8 may call this function while generating a heap snapshot or at other
   * times. If V8 is currently generating a heap snapshot (according to
   * HeapProfiler::IsTakingSnapshot), then the returned string must stay alive
   * until the snapshot generation has completed. Otherwise, the returned string
   * must stay alive forever. If you need a place to store a temporary string
   * during snapshot generation, use HeapProfiler::CopyNameForHeapSnapshot.
   *
   * @returns a human readable name for the object.
   */
  virtual const char* GetHumanReadableName() const = 0;
};

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_NAME_PROVIDER_H_
                                                           node-23.7.0/deps/v8/include/cppgc/object-size-trait.h                                               0000664 0000000 0000000 00000003153 14746647661 0022276 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_OBJECT_SIZE_TRAIT_H_
#define INCLUDE_CPPGC_OBJECT_SIZE_TRAIT_H_

#include <cstddef>

#include "cppgc/type-traits.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {

namespace internal {

struct V8_EXPORT BaseObjectSizeTrait {
 protected:
  static size_t GetObjectSizeForGarbageCollected(const void*);
  static size_t GetObjectSizeForGarbageCollectedMixin(const void*);
};

}  // namespace internal

namespace subtle {

/**
 * Trait specifying how to get the size of an object that was allocated using
 * `MakeGarbageCollected()`. Also supports querying the size with an inner
 * pointer to a mixin.
 */
template <typename T, bool = IsGarbageCollectedMixinTypeV<T>>
struct ObjectSizeTrait;

template <typename T>
struct ObjectSizeTrait<T, false> : cppgc::internal::BaseObjectSizeTrait {
  static_assert(sizeof(T), "T must be fully defined");
  static_assert(IsGarbageCollectedTypeV<T>,
                "T must be of type GarbageCollected or GarbageCollectedMixin");

  static size_t GetSize(const T& object) {
    return GetObjectSizeForGarbageCollected(&object);
  }
};

template <typename T>
struct ObjectSizeTrait<T, true> : cppgc::internal::BaseObjectSizeTrait {
  static_assert(sizeof(T), "T must be fully defined");

  static size_t GetSize(const T& object) {
    return GetObjectSizeForGarbageCollectedMixin(&object);
  }
};

}  // namespace subtle
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_OBJECT_SIZE_TRAIT_H_
                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/include/cppgc/persistent.h                                                      0000664 0000000 0000000 00000033161 14746647661 0021141 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_PERSISTENT_H_
#define INCLUDE_CPPGC_PERSISTENT_H_

#include <type_traits>

#include "cppgc/internal/persistent-node.h"
#include "cppgc/internal/pointer-policies.h"
#include "cppgc/sentinel-pointer.h"
#include "cppgc/source-location.h"
#include "cppgc/type-traits.h"
#include "cppgc/visitor.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {
namespace internal {

// PersistentBase always refers to the object as const object and defers to
// BasicPersistent on casting to the right type as needed.
class PersistentBase {
 protected:
  PersistentBase() = default;
  explicit PersistentBase(const void* raw) : raw_(raw) {}

  const void* GetValue() const { return raw_; }
  void SetValue(const void* value) { raw_ = value; }

  PersistentNode* GetNode() const { return node_; }
  void SetNode(PersistentNode* node) { node_ = node; }

  // Performs a shallow clear which assumes that internal persistent nodes are
  // destroyed elsewhere.
  void ClearFromGC() const {
    raw_ = nullptr;
    node_ = nullptr;
  }

 protected:
  mutable const void* raw_ = nullptr;
  mutable PersistentNode* node_ = nullptr;

  friend class PersistentRegionBase;
};

// The basic class from which all Persistent classes are generated.
template <typename T, typename WeaknessPolicy, typename LocationPolicy,
          typename CheckingPolicy>
class BasicPersistent final : public PersistentBase,
                              public LocationPolicy,
                              private WeaknessPolicy,
                              private CheckingPolicy {
 public:
  using typename WeaknessPolicy::IsStrongPersistent;
  using PointeeType = T;

  // Null-state/sentinel constructors.
  BasicPersistent(  // NOLINT
      const SourceLocation& loc = SourceLocation::Current())
      : LocationPolicy(loc) {}

  BasicPersistent(std::nullptr_t,  // NOLINT
                  const SourceLocation& loc = SourceLocation::Current())
      : LocationPolicy(loc) {}

  BasicPersistent(  // NOLINT
      SentinelPointer s, const SourceLocation& loc = SourceLocation::Current())
      : PersistentBase(s), LocationPolicy(loc) {}

  // Raw value constructors.
  BasicPersistent(T* raw,  // NOLINT
                  const SourceLocation& loc = SourceLocation::Current())
      : PersistentBase(raw), LocationPolicy(loc) {
    if (!IsValid()) return;
    SetNode(WeaknessPolicy::GetPersistentRegion(GetValue())
                .AllocateNode(this, &TraceAsRoot));
    this->CheckPointer(Get());
  }

  BasicPersistent(T& raw,  // NOLINT
                  const SourceLocation& loc = SourceLocation::Current())
      : BasicPersistent(&raw, loc) {}

  // Copy ctor.
  BasicPersistent(const BasicPersistent& other,
                  const SourceLocation& loc = SourceLocation::Current())
      : BasicPersistent(other.Get(), loc) {}

  // Heterogeneous ctor.
  template <typename U, typename OtherWeaknessPolicy,
            typename OtherLocationPolicy, typename OtherCheckingPolicy,
            typename = std::enable_if_t<std::is_base_of<T, U>::value>>
  // NOLINTNEXTLINE
  BasicPersistent(
      const BasicPersistent<U, OtherWeaknessPolicy, OtherLocationPolicy,
                            OtherCheckingPolicy>& other,
      const SourceLocation& loc = SourceLocation::Current())
      : BasicPersistent(other.Get(), loc) {}

  // Move ctor. The heterogeneous move ctor is not supported since e.g.
  // persistent can't reuse persistent node from weak persistent.
  BasicPersistent(
      BasicPersistent&& other,
      const SourceLocation& loc = SourceLocation::Current()) noexcept
      : PersistentBase(std::move(other)), LocationPolicy(std::move(other)) {
    if (!IsValid()) return;
    GetNode()->UpdateOwner(this);
    other.SetValue(nullptr);
    other.SetNode(nullptr);
    this->CheckPointer(Get());
  }

  // Constructor from member.
  template <typename U, typename MemberBarrierPolicy,
            typename MemberWeaknessTag, typename MemberCheckingPolicy,
            typename MemberStorageType,
            typename = std::enable_if_t<std::is_base_of<T, U>::value>>
  // NOLINTNEXTLINE
  BasicPersistent(const internal::BasicMember<
                      U, MemberBarrierPolicy, MemberWeaknessTag,
                      MemberCheckingPolicy, MemberStorageType>& member,
                  const SourceLocation& loc = SourceLocation::Current())
      : BasicPersistent(member.Get(), loc) {}

  ~BasicPersistent() { Clear(); }

  // Copy assignment.
  BasicPersistent& operator=(const BasicPersistent& other) {
    return operator=(other.Get());
  }

  template <typename U, typename OtherWeaknessPolicy,
            typename OtherLocationPolicy, typename OtherCheckingPolicy,
            typename = std::enable_if_t<std::is_base_of<T, U>::value>>
  BasicPersistent& operator=(
      const BasicPersistent<U, OtherWeaknessPolicy, OtherLocationPolicy,
                            OtherCheckingPolicy>& other) {
    return operator=(other.Get());
  }

  // Move assignment.
  BasicPersistent& operator=(BasicPersistent&& other) noexcept {
    if (this == &other) return *this;
    Clear();
    PersistentBase::operator=(std::move(other));
    LocationPolicy::operator=(std::move(other));
    if (!IsValid()) return *this;
    GetNode()->UpdateOwner(this);
    other.SetValue(nullptr);
    other.SetNode(nullptr);
    this->CheckPointer(Get());
    return *this;
  }

  // Assignment from member.
  template <typename U, typename MemberBarrierPolicy,
            typename MemberWeaknessTag, typename MemberCheckingPolicy,
            typename MemberStorageType,
            typename = std::enable_if_t<std::is_base_of<T, U>::value>>
  BasicPersistent& operator=(
      const internal::BasicMember<U, MemberBarrierPolicy, MemberWeaknessTag,
                                  MemberCheckingPolicy, MemberStorageType>&
          member) {
    return operator=(member.Get());
  }

  BasicPersistent& operator=(T* other) {
    Assign(other);
    return *this;
  }

  BasicPersistent& operator=(std::nullptr_t) {
    Clear();
    return *this;
  }

  BasicPersistent& operator=(SentinelPointer s) {
    Assign(s);
    return *this;
  }

  explicit operator bool() const { return Get(); }
  // Historically we allow implicit conversions to T*.
  // NOLINTNEXTLINE
  operator T*() const { return Get(); }
  T* operator->() const { return Get(); }
  T& operator*() const { return *Get(); }

  // CFI cast exemption to allow passing SentinelPointer through T* and support
  // heterogeneous assignments between different Member and Persistent handles
  // based on their actual types.
  V8_CLANG_NO_SANITIZE("cfi-unrelated-cast") T* Get() const {
    // The const_cast below removes the constness from PersistentBase storage.
    // The following static_cast re-adds any constness if specified through the
    // user-visible template parameter T.
    return static_cast<T*>(const_cast<void*>(GetValue()));
  }

  void Clear() {
    // Simplified version of `Assign()` to allow calling without a complete type
    // `T`.
    if (IsValid()) {
      WeaknessPolicy::GetPersistentRegion(GetValue()).FreeNode(GetNode());
      SetNode(nullptr);
    }
    SetValue(nullptr);
  }

  T* Release() {
    T* result = Get();
    Clear();
    return result;
  }

  template <typename U, typename OtherWeaknessPolicy = WeaknessPolicy,
            typename OtherLocationPolicy = LocationPolicy,
            typename OtherCheckingPolicy = CheckingPolicy>
  BasicPersistent<U, OtherWeaknessPolicy, OtherLocationPolicy,
                  OtherCheckingPolicy>
  To() const {
    return BasicPersistent<U, OtherWeaknessPolicy, OtherLocationPolicy,
                           OtherCheckingPolicy>(static_cast<U*>(Get()));
  }

 private:
  static void TraceAsRoot(RootVisitor& root_visitor, const void* ptr) {
    root_visitor.Trace(*static_cast<const BasicPersistent*>(ptr));
  }

  bool IsValid() const {
    // Ideally, handling kSentinelPointer would be done by the embedder. On the
    // other hand, having Persistent aware of it is beneficial since no node
    // gets wasted.
    return GetValue() != nullptr && GetValue() != kSentinelPointer;
  }

  void Assign(T* ptr) {
    if (IsValid()) {
      if (ptr && ptr != kSentinelPointer) {
        // Simply assign the pointer reusing the existing node.
        SetValue(ptr);
        this->CheckPointer(ptr);
        return;
      }
      WeaknessPolicy::GetPersistentRegion(GetValue()).FreeNode(GetNode());
      SetNode(nullptr);
    }
    SetValue(ptr);
    if (!IsValid()) return;
    SetNode(WeaknessPolicy::GetPersistentRegion(GetValue())
                .AllocateNode(this, &TraceAsRoot));
    this->CheckPointer(Get());
  }

  void ClearFromGC() const {
    if (IsValid()) {
      WeaknessPolicy::GetPersistentRegion(GetValue()).FreeNode(GetNode());
      PersistentBase::ClearFromGC();
    }
  }

  // Set Get() for details.
  V8_CLANG_NO_SANITIZE("cfi-unrelated-cast")
  T* GetFromGC() const {
    return static_cast<T*>(const_cast<void*>(GetValue()));
  }

  friend class internal::RootVisitor;
};

template <typename T1, typename WeaknessPolicy1, typename LocationPolicy1,
          typename CheckingPolicy1, typename T2, typename WeaknessPolicy2,
          typename LocationPolicy2, typename CheckingPolicy2>
bool operator==(const BasicPersistent<T1, WeaknessPolicy1, LocationPolicy1,
                                      CheckingPolicy1>& p1,
                const BasicPersistent<T2, WeaknessPolicy2, LocationPolicy2,
                                      CheckingPolicy2>& p2) {
  return p1.Get() == p2.Get();
}

template <typename T1, typename WeaknessPolicy1, typename LocationPolicy1,
          typename CheckingPolicy1, typename T2, typename WeaknessPolicy2,
          typename LocationPolicy2, typename CheckingPolicy2>
bool operator!=(const BasicPersistent<T1, WeaknessPolicy1, LocationPolicy1,
                                      CheckingPolicy1>& p1,
                const BasicPersistent<T2, WeaknessPolicy2, LocationPolicy2,
                                      CheckingPolicy2>& p2) {
  return !(p1 == p2);
}

template <typename T1, typename PersistentWeaknessPolicy,
          typename PersistentLocationPolicy, typename PersistentCheckingPolicy,
          typename T2, typename MemberWriteBarrierPolicy,
          typename MemberWeaknessTag, typename MemberCheckingPolicy,
          typename MemberStorageType>
bool operator==(
    const BasicPersistent<T1, PersistentWeaknessPolicy,
                          PersistentLocationPolicy, PersistentCheckingPolicy>&
        p,
    const BasicMember<T2, MemberWeaknessTag, MemberWriteBarrierPolicy,
                      MemberCheckingPolicy, MemberStorageType>& m) {
  return p.Get() == m.Get();
}

template <typename T1, typename PersistentWeaknessPolicy,
          typename PersistentLocationPolicy, typename PersistentCheckingPolicy,
          typename T2, typename MemberWriteBarrierPolicy,
          typename MemberWeaknessTag, typename MemberCheckingPolicy,
          typename MemberStorageType>
bool operator!=(
    const BasicPersistent<T1, PersistentWeaknessPolicy,
                          PersistentLocationPolicy, PersistentCheckingPolicy>&
        p,
    const BasicMember<T2, MemberWeaknessTag, MemberWriteBarrierPolicy,
                      MemberCheckingPolicy, MemberStorageType>& m) {
  return !(p == m);
}

template <typename T1, typename MemberWriteBarrierPolicy,
          typename MemberWeaknessTag, typename MemberCheckingPolicy,
          typename MemberStorageType, typename T2,
          typename PersistentWeaknessPolicy, typename PersistentLocationPolicy,
          typename PersistentCheckingPolicy>
bool operator==(
    const BasicMember<T2, MemberWeaknessTag, MemberWriteBarrierPolicy,
                      MemberCheckingPolicy, MemberStorageType>& m,
    const BasicPersistent<T1, PersistentWeaknessPolicy,
                          PersistentLocationPolicy, PersistentCheckingPolicy>&
        p) {
  return m.Get() == p.Get();
}

template <typename T1, typename MemberWriteBarrierPolicy,
          typename MemberWeaknessTag, typename MemberCheckingPolicy,
          typename MemberStorageType, typename T2,
          typename PersistentWeaknessPolicy, typename PersistentLocationPolicy,
          typename PersistentCheckingPolicy>
bool operator!=(
    const BasicMember<T2, MemberWeaknessTag, MemberWriteBarrierPolicy,
                      MemberCheckingPolicy, MemberStorageType>& m,
    const BasicPersistent<T1, PersistentWeaknessPolicy,
                          PersistentLocationPolicy, PersistentCheckingPolicy>&
        p) {
  return !(m == p);
}

template <typename T, typename LocationPolicy, typename CheckingPolicy>
struct IsWeak<BasicPersistent<T, internal::WeakPersistentPolicy, LocationPolicy,
                              CheckingPolicy>> : std::true_type {};
}  // namespace internal

/**
 * Persistent is a way to create a strong pointer from an off-heap object to
 * another on-heap object. As long as the Persistent handle is alive the GC will
 * keep the object pointed to alive. The Persistent handle is always a GC root
 * from the point of view of the GC. Persistent must be constructed and
 * destructed in the same thread.
 */
template <typename T>
using Persistent =
    internal::BasicPersistent<T, internal::StrongPersistentPolicy>;

/**
 * WeakPersistent is a way to create a weak pointer from an off-heap object to
 * an on-heap object. The pointer is automatically cleared when the pointee gets
 * collected. WeakPersistent must be constructed and destructed in the same
 * thread.
 */
template <typename T>
using WeakPersistent =
    internal::BasicPersistent<T, internal::WeakPersistentPolicy>;

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_PERSISTENT_H_
                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/include/cppgc/platform.h                                                        0000664 0000000 0000000 00000013632 14746647661 0020566 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_PLATFORM_H_
#define INCLUDE_CPPGC_PLATFORM_H_

#include <memory>

#include "cppgc/source-location.h"
#include "v8-platform.h"  // NOLINT(build/include_directory)
#include "v8config.h"     // NOLINT(build/include_directory)

namespace cppgc {

// TODO(v8:10346): Create separate includes for concepts that are not
// V8-specific.
using IdleTask = v8::IdleTask;
using JobHandle = v8::JobHandle;
using JobDelegate = v8::JobDelegate;
using JobTask = v8::JobTask;
using PageAllocator = v8::PageAllocator;
using Task = v8::Task;
using TaskPriority = v8::TaskPriority;
using TaskRunner = v8::TaskRunner;
using TracingController = v8::TracingController;

/**
 * Platform interface used by Heap. Contains allocators and executors.
 */
class V8_EXPORT Platform {
 public:
  virtual ~Platform() = default;

  /**
   * \returns the allocator used by cppgc to allocate its heap and various
   * support structures. Returning nullptr results in using the `PageAllocator`
   * provided by `cppgc::InitializeProcess()` instead.
   */
  virtual PageAllocator* GetPageAllocator() = 0;

  /**
   * Monotonically increasing time in seconds from an arbitrary fixed point in
   * the past. This function is expected to return at least
   * millisecond-precision values. For this reason,
   * it is recommended that the fixed point be no further in the past than
   * the epoch.
   **/
  virtual double MonotonicallyIncreasingTime() = 0;

  /**
   * Foreground task runner that should be used by a Heap.
   */
  virtual std::shared_ptr<TaskRunner> GetForegroundTaskRunner() {
    return nullptr;
  }

  /**
   * Posts `job_task` to run in parallel. Returns a `JobHandle` associated with
   * the `Job`, which can be joined or canceled.
   * This avoids degenerate cases:
   * - Calling `CallOnWorkerThread()` for each work item, causing significant
   *   overhead.
   * - Fixed number of `CallOnWorkerThread()` calls that split the work and
   *   might run for a long time. This is problematic when many components post
   *   "num cores" tasks and all expect to use all the cores. In these cases,
   *   the scheduler lacks context to be fair to multiple same-priority requests
   *   and/or ability to request lower priority work to yield when high priority
   *   work comes in.
   * A canonical implementation of `job_task` looks like:
   * \code
   * class MyJobTask : public JobTask {
   *  public:
   *   MyJobTask(...) : worker_queue_(...) {}
   *   // JobTask implementation.
   *   void Run(JobDelegate* delegate) override {
   *     while (!delegate->ShouldYield()) {
   *       // Smallest unit of work.
   *       auto work_item = worker_queue_.TakeWorkItem(); // Thread safe.
   *       if (!work_item) return;
   *       ProcessWork(work_item);
   *     }
   *   }
   *
   *   size_t GetMaxConcurrency() const override {
   *     return worker_queue_.GetSize(); // Thread safe.
   *   }
   * };
   *
   * // ...
   * auto handle = PostJob(TaskPriority::kUserVisible,
   *                       std::make_unique<MyJobTask>(...));
   * handle->Join();
   * \endcode
   *
   * `PostJob()` and methods of the returned JobHandle/JobDelegate, must never
   * be called while holding a lock that could be acquired by `JobTask::Run()`
   * or `JobTask::GetMaxConcurrency()` -- that could result in a deadlock. This
   * is because (1) `JobTask::GetMaxConcurrency()` may be invoked while holding
   * internal lock (A), hence `JobTask::GetMaxConcurrency()` can only use a lock
   * (B) if that lock is *never* held while calling back into `JobHandle` from
   * any thread (A=>B/B=>A deadlock) and (2) `JobTask::Run()` or
   * `JobTask::GetMaxConcurrency()` may be invoked synchronously from
   * `JobHandle` (B=>JobHandle::foo=>B deadlock).
   *
   * A sufficient `PostJob()` implementation that uses the default Job provided
   * in libplatform looks like:
   * \code
   * std::unique_ptr<JobHandle> PostJob(
   *     TaskPriority priority, std::unique_ptr<JobTask> job_task) override {
   *   return std::make_unique<DefaultJobHandle>(
   *       std::make_shared<DefaultJobState>(
   *           this, std::move(job_task), kNumThreads));
   * }
   * \endcode
   */
  virtual std::unique_ptr<JobHandle> PostJob(
      TaskPriority priority, std::unique_ptr<JobTask> job_task) {
    return nullptr;
  }

  /**
   * Returns an instance of a `TracingController`. This must be non-nullptr. The
   * default implementation returns an empty `TracingController` that consumes
   * trace data without effect.
   */
  virtual TracingController* GetTracingController();
};

/**
 * Process-global initialization of the garbage collector. Must be called before
 * creating a Heap.
 *
 * Can be called multiple times when paired with `ShutdownProcess()`.
 *
 * \param page_allocator The allocator used for maintaining meta data. Must stay
 *   always alive and not change between multiple calls to InitializeProcess. If
 *   no allocator is provided, a default internal version will be used.
 * \param desired_heap_size Desired amount of virtual address space to reserve
 *   for the heap, in bytes. Actual size will be clamped to minimum and maximum
 *   values based on compile-time settings and may be rounded up. If this
 *   parameter is zero, a default value will be used.
 */
V8_EXPORT void InitializeProcess(PageAllocator* page_allocator = nullptr,
                                 size_t desired_heap_size = 0);

/**
 * Must be called after destroying the last used heap. Some process-global
 * metadata may not be returned and reused upon a subsequent
 * `InitializeProcess()` call.
 */
V8_EXPORT void ShutdownProcess();

namespace internal {

V8_EXPORT void Fatal(const std::string& reason = std::string(),
                     const SourceLocation& = SourceLocation::Current());

}  // namespace internal

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_PLATFORM_H_
                                                                                                      node-23.7.0/deps/v8/include/cppgc/prefinalizer.h                                                    0000664 0000000 0000000 00000005600 14746647661 0021430 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_PREFINALIZER_H_
#define INCLUDE_CPPGC_PREFINALIZER_H_

#include "cppgc/internal/compiler-specific.h"
#include "cppgc/liveness-broker.h"

namespace cppgc {

namespace internal {

class V8_EXPORT PrefinalizerRegistration final {
 public:
  using Callback = bool (*)(const cppgc::LivenessBroker&, void*);

  PrefinalizerRegistration(void*, Callback);

  void* operator new(size_t, void* location) = delete;
  void* operator new(size_t) = delete;
};

}  // namespace internal

/**
 * Macro must be used in the private section of `Class` and registers a
 * prefinalization callback `void Class::PreFinalizer()`. The callback is
 * invoked on garbage collection after the collector has found an object to be
 * dead.
 *
 * Callback properties:
 * - The callback is invoked before a possible destructor for the corresponding
 *   object.
 * - The callback may access the whole object graph, irrespective of whether
 *   objects are considered dead or alive.
 * - The callback is invoked on the same thread as the object was created on.
 *
 * Example:
 * \code
 * class WithPrefinalizer : public GarbageCollected<WithPrefinalizer> {
 *   CPPGC_USING_PRE_FINALIZER(WithPrefinalizer, Dispose);
 *
 *  public:
 *   void Trace(Visitor*) const {}
 *   void Dispose() { prefinalizer_called = true; }
 *   ~WithPrefinalizer() {
 *     // prefinalizer_called == true
 *   }
 *  private:
 *   bool prefinalizer_called = false;
 * };
 * \endcode
 */
#define CPPGC_USING_PRE_FINALIZER(Class, PreFinalizer)                         \
 public:                                                                       \
  static bool InvokePreFinalizer(const cppgc::LivenessBroker& liveness_broker, \
                                 void* object) {                               \
    static_assert(cppgc::IsGarbageCollectedOrMixinTypeV<Class>,                \
                  "Only garbage collected objects can have prefinalizers");    \
    Class* self = static_cast<Class*>(object);                                 \
    if (liveness_broker.IsHeapObjectAlive(self)) return false;                 \
    self->PreFinalizer();                                                      \
    return true;                                                               \
  }                                                                            \
                                                                               \
 private:                                                                      \
  CPPGC_NO_UNIQUE_ADDRESS cppgc::internal::PrefinalizerRegistration            \
      prefinalizer_dummy_{this, Class::InvokePreFinalizer};                    \
  static_assert(true, "Force semicolon.")

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_PREFINALIZER_H_
                                                                                                                                node-23.7.0/deps/v8/include/cppgc/process-heap-statistics.h                                         0000664 0000000 0000000 00000001761 14746647661 0023523 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_PROCESS_HEAP_STATISTICS_H_
#define INCLUDE_CPPGC_PROCESS_HEAP_STATISTICS_H_

#include <atomic>
#include <cstddef>

#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {
namespace internal {
class ProcessHeapStatisticsUpdater;
}  // namespace internal

class V8_EXPORT ProcessHeapStatistics final {
 public:
  static size_t TotalAllocatedObjectSize() {
    return total_allocated_object_size_.load(std::memory_order_relaxed);
  }
  static size_t TotalAllocatedSpace() {
    return total_allocated_space_.load(std::memory_order_relaxed);
  }

 private:
  static std::atomic_size_t total_allocated_space_;
  static std::atomic_size_t total_allocated_object_size_;

  friend class internal::ProcessHeapStatisticsUpdater;
};

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_PROCESS_HEAP_STATISTICS_H_
               node-23.7.0/deps/v8/include/cppgc/sentinel-pointer.h                                                0000664 0000000 0000000 00000002270 14746647661 0022235 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_SENTINEL_POINTER_H_
#define INCLUDE_CPPGC_SENTINEL_POINTER_H_

#include <cstdint>

#include "cppgc/internal/api-constants.h"

namespace cppgc {
namespace internal {

// Special tag type used to denote some sentinel member. The semantics of the
// sentinel is defined by the embedder.
struct SentinelPointer {
#if defined(CPPGC_POINTER_COMPRESSION)
  static constexpr intptr_t kSentinelValue =
      1 << api_constants::kPointerCompressionShift;
#else   // !defined(CPPGC_POINTER_COMPRESSION)
  static constexpr intptr_t kSentinelValue = 0b10;
#endif  // !defined(CPPGC_POINTER_COMPRESSION)
  template <typename T>
  operator T*() const {
    return reinterpret_cast<T*>(kSentinelValue);
  }
  // Hidden friends.
  friend bool operator==(SentinelPointer, SentinelPointer) { return true; }
  friend bool operator!=(SentinelPointer, SentinelPointer) { return false; }
};

}  // namespace internal

constexpr internal::SentinelPointer kSentinelPointer;

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_SENTINEL_POINTER_H_
                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/include/cppgc/source-location.h                                                 0000664 0000000 0000000 00000000636 14746647661 0022050 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_SOURCE_LOCATION_H_
#define INCLUDE_CPPGC_SOURCE_LOCATION_H_

#include "v8-source-location.h"

namespace cppgc {

using SourceLocation = v8::SourceLocation;

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_SOURCE_LOCATION_H_
                                                                                                  node-23.7.0/deps/v8/include/cppgc/testing.h                                                         0000664 0000000 0000000 00000005731 14746647661 0020420 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_TESTING_H_
#define INCLUDE_CPPGC_TESTING_H_

#include "cppgc/common.h"
#include "cppgc/macros.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {

class HeapHandle;

/**
 * Namespace contains testing helpers.
 */
namespace testing {

/**
 * Overrides the state of the stack with the provided value. Parameters passed
 * to explicit garbage collection calls still take precedence. Must not be
 * nested.
 *
 * This scope is useful to make the garbage collector consider the stack when
 * tasks that invoke garbage collection (through the provided platform) contain
 * interesting pointers on its stack.
 */
class V8_EXPORT V8_NODISCARD OverrideEmbedderStackStateScope final {
  CPPGC_STACK_ALLOCATED();

 public:
  /**
   * Constructs a scoped object that automatically enters and leaves the scope.
   *
   * \param heap_handle The corresponding heap.
   */
  explicit OverrideEmbedderStackStateScope(HeapHandle& heap_handle,
                                           EmbedderStackState state);
  ~OverrideEmbedderStackStateScope();

  OverrideEmbedderStackStateScope(const OverrideEmbedderStackStateScope&) =
      delete;
  OverrideEmbedderStackStateScope& operator=(
      const OverrideEmbedderStackStateScope&) = delete;

 private:
  HeapHandle& heap_handle_;
};

/**
 * Testing interface for managed heaps that allows for controlling garbage
 * collection timings. Embedders should use this class when testing the
 * interaction of their code with incremental/concurrent garbage collection.
 */
class V8_EXPORT StandaloneTestingHeap final {
 public:
  explicit StandaloneTestingHeap(HeapHandle&);

  /**
   * Start an incremental garbage collection.
   */
  void StartGarbageCollection();

  /**
   * Perform an incremental step. This will also schedule concurrent steps if
   * needed.
   *
   * \param stack_state The state of the stack during the step.
   */
  bool PerformMarkingStep(EmbedderStackState stack_state);

  /**
   * Finalize the current garbage collection cycle atomically.
   * Assumes that garbage collection is in progress.
   *
   * \param stack_state The state of the stack for finalizing the garbage
   * collection cycle.
   */
  void FinalizeGarbageCollection(EmbedderStackState stack_state);

  /**
   * Toggle main thread marking on/off. Allows to stress concurrent marking
   * (e.g. to better detect data races).
   *
   * \param should_mark Denotes whether the main thread should contribute to
   * marking. Defaults to true.
   */
  void ToggleMainThreadMarking(bool should_mark);

  /**
   * Force enable compaction for the next garbage collection cycle.
   */
  void ForceCompactionForNextGarbageCollection();

 private:
  HeapHandle& heap_handle_;
};

V8_EXPORT bool IsHeapObjectOld(void*);

}  // namespace testing
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_TESTING_H_
                                       node-23.7.0/deps/v8/include/cppgc/trace-trait.h                                                     0000664 0000000 0000000 00000006627 14746647661 0021167 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_TRACE_TRAIT_H_
#define INCLUDE_CPPGC_TRACE_TRAIT_H_

#include <type_traits>

#include "cppgc/type-traits.h"
#include "v8config.h"  // NOLINT(build/include_directory)

namespace cppgc {

class Visitor;

namespace internal {

class RootVisitor;

using TraceRootCallback = void (*)(RootVisitor&, const void* object);

// Implementation of the default TraceTrait handling GarbageCollected and
// GarbageCollectedMixin.
template <typename T,
          bool =
              IsGarbageCollectedMixinTypeV<typename std::remove_const<T>::type>>
struct TraceTraitImpl;

}  // namespace internal

/**
 * Callback for invoking tracing on a given object.
 *
 * \param visitor The visitor to dispatch to.
 * \param object The object to invoke tracing on.
 */
using TraceCallback = void (*)(Visitor* visitor, const void* object);

/**
 * Describes how to trace an object, i.e., how to visit all Oilpan-relevant
 * fields of an object.
 */
struct TraceDescriptor {
  /**
   * Adjusted base pointer, i.e., the pointer to the class inheriting directly
   * from GarbageCollected, of the object that is being traced.
   */
  const void* base_object_payload;
  /**
   * Callback for tracing the object.
   */
  TraceCallback callback;
};

/**
 * Callback for getting a TraceDescriptor for a given address.
 *
 * \param address Possibly inner address of an object.
 * \returns a TraceDescriptor for the provided address.
 */
using TraceDescriptorCallback = TraceDescriptor (*)(const void* address);

namespace internal {

struct V8_EXPORT TraceTraitFromInnerAddressImpl {
  static TraceDescriptor GetTraceDescriptor(const void* address);
};

/**
 * Trait specifying how the garbage collector processes an object of type T.
 *
 * Advanced users may override handling by creating a specialization for their
 * type.
 */
template <typename T>
struct TraceTraitBase {
  static_assert(internal::IsTraceableV<T>, "T must have a Trace() method");

  /**
   * Accessor for retrieving a TraceDescriptor to process an object of type T.
   *
   * \param self The object to be processed.
   * \returns a TraceDescriptor to process the object.
   */
  static TraceDescriptor GetTraceDescriptor(const void* self) {
    return internal::TraceTraitImpl<T>::GetTraceDescriptor(
        static_cast<const T*>(self));
  }

  /**
   * Function invoking the tracing for an object of type T.
   *
   * \param visitor The visitor to dispatch to.
   * \param self The object to invoke tracing on.
   */
  static void Trace(Visitor* visitor, const void* self) {
    static_cast<const T*>(self)->Trace(visitor);
  }
};

}  // namespace internal

template <typename T>
struct TraceTrait : public internal::TraceTraitBase<T> {};

namespace internal {

template <typename T>
struct TraceTraitImpl<T, false> {
  static_assert(IsGarbageCollectedTypeV<T>,
                "T must be of type GarbageCollected or GarbageCollectedMixin");
  static TraceDescriptor GetTraceDescriptor(const void* self) {
    return {self, TraceTrait<T>::Trace};
  }
};

template <typename T>
struct TraceTraitImpl<T, true> {
  static TraceDescriptor GetTraceDescriptor(const void* self) {
    return internal::TraceTraitFromInnerAddressImpl::GetTraceDescriptor(self);
  }
};

}  // namespace internal
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_TRACE_TRAIT_H_
                                                                                                         node-23.7.0/deps/v8/include/cppgc/type-traits.h                                                     0000664 0000000 0000000 00000020720 14746647661 0021223 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_TYPE_TRAITS_H_
#define INCLUDE_CPPGC_TYPE_TRAITS_H_

// This file should stay with minimal dependencies to allow embedder to check
// against Oilpan types without including any other parts.
#include <cstddef>
#include <type_traits>

namespace cppgc {

class Visitor;

namespace internal {
template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy, typename StorageType>
class BasicMember;
struct DijkstraWriteBarrierPolicy;
struct NoWriteBarrierPolicy;
class StrongMemberTag;
class UntracedMemberTag;
class WeakMemberTag;

// Not supposed to be specialized by the user.
template <typename T>
struct IsWeak : std::false_type {};

// IsTraceMethodConst is used to verify that all Trace methods are marked as
// const. It is equivalent to IsTraceable but for a non-const object.
template <typename T, typename = void>
struct IsTraceMethodConst : std::false_type {};

template <typename T>
struct IsTraceMethodConst<T, std::void_t<decltype(std::declval<const T>().Trace(
                                 std::declval<Visitor*>()))>> : std::true_type {
};

template <typename T, typename = void>
struct IsTraceable : std::false_type {
  static_assert(sizeof(T), "T must be fully defined");
};

template <typename T>
struct IsTraceable<
    T, std::void_t<decltype(std::declval<T>().Trace(std::declval<Visitor*>()))>>
    : std::true_type {
  // All Trace methods should be marked as const. If an object of type
  // 'T' is traceable then any object of type 'const T' should also
  // be traceable.
  static_assert(IsTraceMethodConst<T>(),
                "Trace methods should be marked as const.");
};

template <typename T>
constexpr bool IsTraceableV = IsTraceable<T>::value;

template <typename T, typename = void>
struct HasGarbageCollectedMixinTypeMarker : std::false_type {
  static_assert(sizeof(T), "T must be fully defined");
};

template <typename T>
struct HasGarbageCollectedMixinTypeMarker<
    T, std::void_t<
           typename std::remove_const_t<T>::IsGarbageCollectedMixinTypeMarker>>
    : std::true_type {
  static_assert(sizeof(T), "T must be fully defined");
};

template <typename T, typename = void>
struct HasGarbageCollectedTypeMarker : std::false_type {
  static_assert(sizeof(T), "T must be fully defined");
};

template <typename T>
struct HasGarbageCollectedTypeMarker<
    T,
    std::void_t<typename std::remove_const_t<T>::IsGarbageCollectedTypeMarker>>
    : std::true_type {
  static_assert(sizeof(T), "T must be fully defined");
};

template <typename T, bool = HasGarbageCollectedTypeMarker<T>::value,
          bool = HasGarbageCollectedMixinTypeMarker<T>::value>
struct IsGarbageCollectedMixinType : std::false_type {
  static_assert(sizeof(T), "T must be fully defined");
};

template <typename T>
struct IsGarbageCollectedMixinType<T, false, true> : std::true_type {
  static_assert(sizeof(T), "T must be fully defined");
};

template <typename T, bool = HasGarbageCollectedTypeMarker<T>::value>
struct IsGarbageCollectedType : std::false_type {
  static_assert(sizeof(T), "T must be fully defined");
};

template <typename T>
struct IsGarbageCollectedType<T, true> : std::true_type {
  static_assert(sizeof(T), "T must be fully defined");
};

template <typename T>
struct IsGarbageCollectedOrMixinType
    : std::integral_constant<bool, IsGarbageCollectedType<T>::value ||
                                       IsGarbageCollectedMixinType<T>::value> {
  static_assert(sizeof(T), "T must be fully defined");
};

template <typename T, bool = (HasGarbageCollectedTypeMarker<T>::value &&
                              HasGarbageCollectedMixinTypeMarker<T>::value)>
struct IsGarbageCollectedWithMixinType : std::false_type {
  static_assert(sizeof(T), "T must be fully defined");
};

template <typename T>
struct IsGarbageCollectedWithMixinType<T, true> : std::true_type {
  static_assert(sizeof(T), "T must be fully defined");
};

template <typename BasicMemberCandidate, typename WeaknessTag,
          typename WriteBarrierPolicy>
struct IsSubclassOfBasicMemberTemplate {
 private:
  template <typename T, typename CheckingPolicy, typename StorageType>
  static std::true_type SubclassCheck(
      const BasicMember<T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy,
                        StorageType>*);
  static std::false_type SubclassCheck(...);

 public:
  static constexpr bool value = decltype(SubclassCheck(
      std::declval<std::decay_t<BasicMemberCandidate>*>()))::value;
};

template <typename T,
          bool = IsSubclassOfBasicMemberTemplate<
              T, StrongMemberTag, DijkstraWriteBarrierPolicy>::value>
struct IsMemberType : std::false_type {};

template <typename T>
struct IsMemberType<T, true> : std::true_type {};

template <typename T, bool = IsSubclassOfBasicMemberTemplate<
                          T, WeakMemberTag, DijkstraWriteBarrierPolicy>::value>
struct IsWeakMemberType : std::false_type {};

template <typename T>
struct IsWeakMemberType<T, true> : std::true_type {};

template <typename T, bool = IsSubclassOfBasicMemberTemplate<
                          T, UntracedMemberTag, NoWriteBarrierPolicy>::value>
struct IsUntracedMemberType : std::false_type {};

template <typename T>
struct IsUntracedMemberType<T, true> : std::true_type {};

template <typename T>
struct IsComplete {
 private:
  template <typename U, size_t = sizeof(U)>
  static std::true_type IsSizeOfKnown(U*);
  static std::false_type IsSizeOfKnown(...);

 public:
  static constexpr bool value =
      decltype(IsSizeOfKnown(std::declval<T*>()))::value;
};

template <typename T, typename U>
constexpr bool IsDecayedSameV =
    std::is_same_v<std::decay_t<T>, std::decay_t<U>>;

template <typename B, typename D>
constexpr bool IsStrictlyBaseOfV =
    std::is_base_of_v<std::decay_t<B>, std::decay_t<D>> &&
    !IsDecayedSameV<B, D>;

template <typename T>
constexpr bool IsAnyMemberTypeV = false;

template <typename T, typename WeaknessTag, typename WriteBarrierPolicy,
          typename CheckingPolicy, typename StorageType>
constexpr bool IsAnyMemberTypeV<internal::BasicMember<
    T, WeaknessTag, WriteBarrierPolicy, CheckingPolicy, StorageType>> = true;

}  // namespace internal

/**
 * Value is true for types that inherit from `GarbageCollectedMixin` but not
 * `GarbageCollected<T>` (i.e., they are free mixins), and false otherwise.
 */
template <typename T>
constexpr bool IsGarbageCollectedMixinTypeV =
    internal::IsGarbageCollectedMixinType<T>::value;

/**
 * Value is true for types that inherit from `GarbageCollected<T>`, and false
 * otherwise.
 */
template <typename T>
constexpr bool IsGarbageCollectedTypeV =
    internal::IsGarbageCollectedType<T>::value;

/**
 * Value is true for types that inherit from either `GarbageCollected<T>` or
 * `GarbageCollectedMixin`, and false otherwise.
 */
template <typename T>
constexpr bool IsGarbageCollectedOrMixinTypeV =
    internal::IsGarbageCollectedOrMixinType<T>::value;

/**
 * Value is true for types that inherit from `GarbageCollected<T>` and
 * `GarbageCollectedMixin`, and false otherwise.
 */
template <typename T>
constexpr bool IsGarbageCollectedWithMixinTypeV =
    internal::IsGarbageCollectedWithMixinType<T>::value;

/**
 * Value is true for types of type `Member<T>`, and false otherwise.
 */
template <typename T>
constexpr bool IsMemberTypeV = internal::IsMemberType<T>::value;

/**
 * Value is true for types of type `UntracedMember<T>`, and false otherwise.
 */
template <typename T>
constexpr bool IsUntracedMemberTypeV = internal::IsUntracedMemberType<T>::value;

/**
 * Value is true for types of type `WeakMember<T>`, and false otherwise.
 */
template <typename T>
constexpr bool IsWeakMemberTypeV = internal::IsWeakMemberType<T>::value;

/**
 * Value is true for types that are considered weak references, and false
 * otherwise.
 */
template <typename T>
constexpr bool IsWeakV = internal::IsWeak<T>::value;

/**
 * Value is true for types that are complete, and false otherwise.
 */
template <typename T>
constexpr bool IsCompleteV = internal::IsComplete<T>::value;

/**
 * Value is true for member types `Member<T>` and `WeakMember<T>`.
 */
template <typename T>
constexpr bool IsMemberOrWeakMemberTypeV =
    IsMemberTypeV<T> || IsWeakMemberTypeV<T>;

/**
 * Value is true for any member type.
 */
template <typename T>
constexpr bool IsAnyMemberTypeV = internal::IsAnyMemberTypeV<std::decay_t<T>>;

}  // namespace cppgc

#endif  // INCLUDE_CPPGC_TYPE_TRAITS_H_
                                                node-23.7.0/deps/v8/include/cppgc/visitor.h                                                         0000664 0000000 0000000 00000044124 14746647661 0020441 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_CPPGC_VISITOR_H_
#define INCLUDE_CPPGC_VISITOR_H_

#include <type_traits>

#include "cppgc/custom-space.h"
#include "cppgc/ephemeron-pair.h"
#include "cppgc/garbage-collected.h"
#include "cppgc/internal/logging.h"
#include "cppgc/internal/member-storage.h"
#include "cppgc/internal/pointer-policies.h"
#include "cppgc/liveness-broker.h"
#include "cppgc/member.h"
#include "cppgc/sentinel-pointer.h"
#include "cppgc/source-location.h"
#include "cppgc/trace-trait.h"
#include "cppgc/type-traits.h"

namespace cppgc {

namespace internal {
template <typename T, typename WeaknessPolicy, typename LocationPolicy,
          typename CheckingPolicy>
class BasicCrossThreadPersistent;
template <typename T, typename WeaknessPolicy, typename LocationPolicy,
          typename CheckingPolicy>
class BasicPersistent;
class ConservativeTracingVisitor;
class VisitorBase;
class VisitorFactory;
}  // namespace internal

using WeakCallback = void (*)(const LivenessBroker&, const void*);

/**
 * Visitor passed to trace methods. All managed pointers must have called the
 * Visitor's trace method on them.
 *
 * \code
 * class Foo final : public GarbageCollected<Foo> {
 *  public:
 *   void Trace(Visitor* visitor) const {
 *     visitor->Trace(foo_);
 *     visitor->Trace(weak_foo_);
 *   }
 *  private:
 *   Member<Foo> foo_;
 *   WeakMember<Foo> weak_foo_;
 * };
 * \endcode
 */
class V8_EXPORT Visitor {
 public:
  class Key {
   private:
    Key() = default;
    friend class internal::VisitorFactory;
  };

  explicit Visitor(Key) {}

  virtual ~Visitor() = default;

  /**
   * Trace method for Member.
   *
   * \param member Member reference retaining an object.
   */
  template <typename T>
  void Trace(const Member<T>& member) {
    const T* value = member.GetRawAtomic();
    CPPGC_DCHECK(value != kSentinelPointer);
    TraceImpl(value);
  }

  /**
   * Trace method for WeakMember.
   *
   * \param weak_member WeakMember reference weakly retaining an object.
   */
  template <typename T>
  void Trace(const WeakMember<T>& weak_member) {
    static_assert(sizeof(T), "Pointee type must be fully defined.");
    static_assert(internal::IsGarbageCollectedOrMixinType<T>::value,
                  "T must be GarbageCollected or GarbageCollectedMixin type");
    static_assert(!internal::IsAllocatedOnCompactableSpace<T>::value,
                  "Weak references to compactable objects are not allowed");

    const T* value = weak_member.GetRawAtomic();

    // Bailout assumes that WeakMember emits write barrier.
    if (!value) {
      return;
    }

    CPPGC_DCHECK(value != kSentinelPointer);
    VisitWeak(value, TraceTrait<T>::GetTraceDescriptor(value),
              &HandleWeak<WeakMember<T>>, &weak_member);
  }

#if defined(CPPGC_POINTER_COMPRESSION)
  /**
   * Trace method for UncompressedMember.
   *
   * \param member UncompressedMember reference retaining an object.
   */
  template <typename T>
  void Trace(const subtle::UncompressedMember<T>& member) {
    const T* value = member.GetRawAtomic();
    CPPGC_DCHECK(value != kSentinelPointer);
    TraceImpl(value);
  }
#endif  // defined(CPPGC_POINTER_COMPRESSION)

  template <typename T>
  void TraceMultiple(const subtle::UncompressedMember<T>* start, size_t len) {
    static_assert(sizeof(T), "Pointee type must be fully defined.");
    static_assert(internal::IsGarbageCollectedOrMixinType<T>::value,
                  "T must be GarbageCollected or GarbageCollectedMixin type");
    VisitMultipleUncompressedMember(start, len,
                                    &TraceTrait<T>::GetTraceDescriptor);
  }

  template <typename T,
            std::enable_if_t<!std::is_same_v<
                Member<T>, subtle::UncompressedMember<T>>>* = nullptr>
  void TraceMultiple(const Member<T>* start, size_t len) {
    static_assert(sizeof(T), "Pointee type must be fully defined.");
    static_assert(internal::IsGarbageCollectedOrMixinType<T>::value,
                  "T must be GarbageCollected or GarbageCollectedMixin type");
#if defined(CPPGC_POINTER_COMPRESSION)
    static_assert(std::is_same_v<Member<T>, subtle::CompressedMember<T>>,
                  "Member and CompressedMember must be the same.");
    VisitMultipleCompressedMember(start, len,
                                  &TraceTrait<T>::GetTraceDescriptor);
#endif  // defined(CPPGC_POINTER_COMPRESSION)
  }

  /**
   * Trace method for inlined objects that are not allocated themselves but
   * otherwise follow managed heap layout and have a Trace() method.
   *
   * \param object reference of the inlined object.
   */
  template <typename T>
  void Trace(const T& object) {
#if V8_ENABLE_CHECKS
    // This object is embedded in potentially multiple nested objects. The
    // outermost object must not be in construction as such objects are (a) not
    // processed immediately, and (b) only processed conservatively if not
    // otherwise possible.
    CheckObjectNotInConstruction(&object);
#endif  // V8_ENABLE_CHECKS
    TraceTrait<T>::Trace(this, &object);
  }

  template <typename T>
  void TraceMultiple(const T* start, size_t len) {
#if V8_ENABLE_CHECKS
    // This object is embedded in potentially multiple nested objects. The
    // outermost object must not be in construction as such objects are (a) not
    // processed immediately, and (b) only processed conservatively if not
    // otherwise possible.
    CheckObjectNotInConstruction(start);
#endif  // V8_ENABLE_CHECKS
    for (size_t i = 0; i < len; ++i) {
      const T* object = &start[i];
      if constexpr (std::is_polymorphic_v<T>) {
        // The object's vtable may be uninitialized in which case the object is
        // not traced.
        if (*reinterpret_cast<const uintptr_t*>(object) == 0) continue;
      }
      TraceTrait<T>::Trace(this, object);
    }
  }

  /**
   * Registers a weak callback method on the object of type T. See
   * LivenessBroker for an usage example.
   *
   * \param object of type T specifying a weak callback method.
   */
  template <typename T, void (T::*method)(const LivenessBroker&)>
  void RegisterWeakCallbackMethod(const T* object) {
    RegisterWeakCallback(&WeakCallbackMethodDelegate<T, method>, object);
  }

  /**
   * Trace method for EphemeronPair.
   *
   * \param ephemeron_pair EphemeronPair reference weakly retaining a key object
   * and strongly retaining a value object in case the key object is alive.
   */
  template <typename K, typename V>
  void Trace(const EphemeronPair<K, V>& ephemeron_pair) {
    TraceEphemeron(ephemeron_pair.key, &ephemeron_pair.value);
    RegisterWeakCallbackMethod<EphemeronPair<K, V>,
                               &EphemeronPair<K, V>::ClearValueIfKeyIsDead>(
        &ephemeron_pair);
  }

  /**
   * Trace method for a single ephemeron. Used for tracing a raw ephemeron in
   * which the `key` and `value` are kept separately.
   *
   * \param weak_member_key WeakMember reference weakly retaining a key object.
   * \param member_value Member reference with ephemeron semantics.
   */
  template <typename KeyType, typename ValueType>
  void TraceEphemeron(const WeakMember<KeyType>& weak_member_key,
                      const Member<ValueType>* member_value) {
    const KeyType* key = weak_member_key.GetRawAtomic();
    if (!key) return;

    // `value` must always be non-null.
    CPPGC_DCHECK(member_value);
    const ValueType* value = member_value->GetRawAtomic();
    if (!value) return;

    // KeyType and ValueType may refer to GarbageCollectedMixin.
    TraceDescriptor value_desc =
        TraceTrait<ValueType>::GetTraceDescriptor(value);
    CPPGC_DCHECK(value_desc.base_object_payload);
    const void* key_base_object_payload =
        TraceTrait<KeyType>::GetTraceDescriptor(key).base_object_payload;
    CPPGC_DCHECK(key_base_object_payload);

    VisitEphemeron(key_base_object_payload, value, value_desc);
  }

  /**
   * Trace method for a single ephemeron. Used for tracing a raw ephemeron in
   * which the `key` and `value` are kept separately. Note that this overload
   * is for non-GarbageCollected `value`s that can be traced though.
   *
   * \param key `WeakMember` reference weakly retaining a key object.
   * \param value Reference weakly retaining a value object. Note that
   *   `ValueType` here should not be `Member`. It is expected that
   *   `TraceTrait<ValueType>::GetTraceDescriptor(value)` returns a
   *   `TraceDescriptor` with a null base pointer but a valid trace method.
   */
  template <typename KeyType, typename ValueType>
  void TraceEphemeron(const WeakMember<KeyType>& weak_member_key,
                      const ValueType* value) {
    static_assert(!IsGarbageCollectedOrMixinTypeV<ValueType>,
                  "garbage-collected types must use WeakMember and Member");
    const KeyType* key = weak_member_key.GetRawAtomic();
    if (!key) return;

    // `value` must always be non-null.
    CPPGC_DCHECK(value);
    TraceDescriptor value_desc =
        TraceTrait<ValueType>::GetTraceDescriptor(value);
    // `value_desc.base_object_payload` must be null as this override is only
    // taken for non-garbage-collected values.
    CPPGC_DCHECK(!value_desc.base_object_payload);

    // KeyType might be a GarbageCollectedMixin.
    const void* key_base_object_payload =
        TraceTrait<KeyType>::GetTraceDescriptor(key).base_object_payload;
    CPPGC_DCHECK(key_base_object_payload);

    VisitEphemeron(key_base_object_payload, value, value_desc);
  }

  /**
   * Trace method that strongifies a WeakMember.
   *
   * \param weak_member WeakMember reference retaining an object.
   */
  template <typename T>
  void TraceStrongly(const WeakMember<T>& weak_member) {
    const T* value = weak_member.GetRawAtomic();
    CPPGC_DCHECK(value != kSentinelPointer);
    TraceImpl(value);
  }

  /**
   * Trace method for retaining containers strongly.
   *
   * \param object reference to the container.
   */
  template <typename T>
  void TraceStrongContainer(const T* object) {
    TraceImpl(object);
  }

  /**
   * Trace method for retaining containers weakly. Note that weak containers
   * should emit write barriers.
   *
   * \param object reference to the container.
   * \param callback to be invoked.
   * \param callback_data custom data that is passed to the callback.
   */
  template <typename T>
  void TraceWeakContainer(const T* object, WeakCallback callback,
                          const void* callback_data) {
    if (!object) return;
    VisitWeakContainer(object, TraceTrait<T>::GetTraceDescriptor(object),
                       TraceTrait<T>::GetWeakTraceDescriptor(object), callback,
                       callback_data);
  }

  /**
   * Registers a slot containing a reference to an object allocated on a
   * compactable space. Such references maybe be arbitrarily moved by the GC.
   *
   * \param slot location of reference to object that might be moved by the GC.
   * The slot must contain an uncompressed pointer.
   */
  template <typename T>
  void RegisterMovableReference(const T** slot) {
    static_assert(internal::IsAllocatedOnCompactableSpace<T>::value,
                  "Only references to objects allocated on compactable spaces "
                  "should be registered as movable slots.");
    static_assert(!IsGarbageCollectedMixinTypeV<T>,
                  "Mixin types do not support compaction.");
    HandleMovableReference(reinterpret_cast<const void**>(slot));
  }

  /**
   * Registers a weak callback that is invoked during garbage collection.
   *
   * \param callback to be invoked.
   * \param data custom data that is passed to the callback.
   */
  virtual void RegisterWeakCallback(WeakCallback callback, const void* data) {}

  /**
   * Defers tracing an object from a concurrent thread to the mutator thread.
   * Should be called by Trace methods of types that are not safe to trace
   * concurrently.
   *
   * \param parameter tells the trace callback which object was deferred.
   * \param callback to be invoked for tracing on the mutator thread.
   * \param deferred_size size of deferred object.
   *
   * \returns false if the object does not need to be deferred (i.e. currently
   * traced on the mutator thread) and true otherwise (i.e. currently traced on
   * a concurrent thread).
   */
  virtual V8_WARN_UNUSED_RESULT bool DeferTraceToMutatorThreadIfConcurrent(
      const void* parameter, TraceCallback callback, size_t deferred_size) {
    // By default tracing is not deferred.
    return false;
  }

 protected:
  virtual void Visit(const void* self, TraceDescriptor) {}
  virtual void VisitWeak(const void* self, TraceDescriptor, WeakCallback,
                         const void* weak_member) {}
  virtual void VisitEphemeron(const void* key, const void* value,
                              TraceDescriptor value_desc) {}
  virtual void VisitWeakContainer(const void* self, TraceDescriptor strong_desc,
                                  TraceDescriptor weak_desc,
                                  WeakCallback callback, const void* data) {}
  virtual void HandleMovableReference(const void**) {}

  virtual void VisitMultipleUncompressedMember(
      const void* start, size_t len,
      TraceDescriptorCallback get_trace_descriptor) {
    // Default implementation merely delegates to Visit().
    const char* it = static_cast<const char*>(start);
    const char* end = it + len * internal::kSizeOfUncompressedMember;
    for (; it < end; it += internal::kSizeOfUncompressedMember) {
      const auto* current = reinterpret_cast<const internal::RawPointer*>(it);
      const void* object = current->LoadAtomic();
      if (!object) continue;

      Visit(object, get_trace_descriptor(object));
    }
  }

#if defined(CPPGC_POINTER_COMPRESSION)
  virtual void VisitMultipleCompressedMember(
      const void* start, size_t len,
      TraceDescriptorCallback get_trace_descriptor) {
    // Default implementation merely delegates to Visit().
    const char* it = static_cast<const char*>(start);
    const char* end = it + len * internal::kSizeofCompressedMember;
    for (; it < end; it += internal::kSizeofCompressedMember) {
      const auto* current =
          reinterpret_cast<const internal::CompressedPointer*>(it);
      const void* object = current->LoadAtomic();
      if (!object) continue;

      Visit(object, get_trace_descriptor(object));
    }
  }
#endif  // defined(CPPGC_POINTER_COMPRESSION)

 private:
  template <typename T, void (T::*method)(const LivenessBroker&)>
  static void WeakCallbackMethodDelegate(const LivenessBroker& info,
                                         const void* self) {
    // Callback is registered through a potential const Trace method but needs
    // to be able to modify fields. See HandleWeak.
    (const_cast<T*>(static_cast<const T*>(self))->*method)(info);
  }

  template <typename PointerType>
  static void HandleWeak(const LivenessBroker& info, const void* object) {
    const PointerType* weak = static_cast<const PointerType*>(object);
    if (!info.IsHeapObjectAlive(weak->GetFromGC())) {
      weak->ClearFromGC();
    }
  }

  template <typename T>
  void TraceImpl(const T* t) {
    static_assert(sizeof(T), "Pointee type must be fully defined.");
    static_assert(internal::IsGarbageCollectedOrMixinType<T>::value,
                  "T must be GarbageCollected or GarbageCollectedMixin type");
    if (!t) {
      return;
    }
    Visit(t, TraceTrait<T>::GetTraceDescriptor(t));
  }

#if V8_ENABLE_CHECKS
  void CheckObjectNotInConstruction(const void* address);
#endif  // V8_ENABLE_CHECKS

  template <typename T, typename WeaknessPolicy, typename LocationPolicy,
            typename CheckingPolicy>
  friend class internal::BasicCrossThreadPersistent;
  template <typename T, typename WeaknessPolicy, typename LocationPolicy,
            typename CheckingPolicy>
  friend class internal::BasicPersistent;
  friend class internal::ConservativeTracingVisitor;
  friend class internal::VisitorBase;
};

namespace internal {

class V8_EXPORT RootVisitor {
 public:
  explicit RootVisitor(Visitor::Key) {}

  virtual ~RootVisitor() = default;

  template <typename AnyStrongPersistentType,
            std::enable_if_t<
                AnyStrongPersistentType::IsStrongPersistent::value>* = nullptr>
  void Trace(const AnyStrongPersistentType& p) {
    using PointeeType = typename AnyStrongPersistentType::PointeeType;
    const void* object = Extract(p);
    if (!object) {
      return;
    }
    VisitRoot(object, TraceTrait<PointeeType>::GetTraceDescriptor(object),
              p.Location());
  }

  template <typename AnyWeakPersistentType,
            std::enable_if_t<
                !AnyWeakPersistentType::IsStrongPersistent::value>* = nullptr>
  void Trace(const AnyWeakPersistentType& p) {
    using PointeeType = typename AnyWeakPersistentType::PointeeType;
    static_assert(!internal::IsAllocatedOnCompactableSpace<PointeeType>::value,
                  "Weak references to compactable objects are not allowed");
    const void* object = Extract(p);
    if (!object) {
      return;
    }
    VisitWeakRoot(object, TraceTrait<PointeeType>::GetTraceDescriptor(object),
                  &HandleWeak<AnyWeakPersistentType>, &p, p.Location());
  }

 protected:
  virtual void VisitRoot(const void*, TraceDescriptor, const SourceLocation&) {}
  virtual void VisitWeakRoot(const void* self, TraceDescriptor, WeakCallback,
                             const void* weak_root, const SourceLocation&) {}

 private:
  template <typename AnyPersistentType>
  static const void* Extract(AnyPersistentType& p) {
    using PointeeType = typename AnyPersistentType::PointeeType;
    static_assert(sizeof(PointeeType),
                  "Persistent's pointee type must be fully defined");
    static_assert(internal::IsGarbageCollectedOrMixinType<PointeeType>::value,
                  "Persistent's pointee type must be GarbageCollected or "
                  "GarbageCollectedMixin");
    return p.GetFromGC();
  }

  template <typename PointerType>
  static void HandleWeak(const LivenessBroker& info, const void* object) {
    const PointerType* weak = static_cast<const PointerType*>(object);
    if (!info.IsHeapObjectAlive(weak->GetFromGC())) {
      weak->ClearFromGC();
    }
  }
};

}  // namespace internal
}  // namespace cppgc

#endif  // INCLUDE_CPPGC_VISITOR_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/include/js_protocol-1.2.json                                                    0000664 0000000 0000000 00000202232 14746647661 0021217 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
    "version": { "major": "1", "minor": "2" },
    "domains": [
    {
        "domain": "Schema",
        "description": "Provides information about the protocol schema.",
        "types": [
            {
                "id": "Domain",
                "type": "object",
                "description": "Description of the protocol domain.",
                "exported": true,
                "properties": [
                    { "name": "name", "type": "string", "description": "Domain name." },
                    { "name": "version", "type": "string", "description": "Domain version." }
                ]
            }
        ],
        "commands": [
            {
                "name": "getDomains",
                "description": "Returns supported domains.",
                "handlers": ["browser", "renderer"],
                "returns": [
                    { "name": "domains", "type": "array", "items": { "$ref": "Domain" }, "description": "List of supported domains." }
                ]
            }
        ]
    },
    {
        "domain": "Runtime",
        "description": "Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects. Evaluation results are returned as mirror object that expose object type, string representation and unique identifier that can be used for further object reference. Original objects are maintained in memory unless they are either explicitly released or are released along with the other objects in their object group.",
        "types": [
            {
                "id": "ScriptId",
                "type": "string",
                "description": "Unique script identifier."
            },
            {
                "id": "RemoteObjectId",
                "type": "string",
                "description": "Unique object identifier."
            },
            {
                "id": "UnserializableValue",
                "type": "string",
                "enum": ["Infinity", "NaN", "-Infinity", "-0"],
                "description": "Primitive value which cannot be JSON-stringified."
            },
            {
                "id": "RemoteObject",
                "type": "object",
                "description": "Mirror object referencing original JavaScript object.",
                "exported": true,
                "properties": [
                    { "name": "type", "type": "string", "enum": ["object", "function", "undefined", "string", "number", "boolean", "symbol"], "description": "Object type." },
                    { "name": "subtype", "type": "string", "optional": true, "enum": ["array", "null", "node", "regexp", "date", "map", "set", "iterator", "generator", "error", "proxy", "promise", "typedarray"], "description": "Object subtype hint. Specified for <code>object</code> type values only." },
                    { "name": "className", "type": "string", "optional": true, "description": "Object class (constructor) name. Specified for <code>object</code> type values only." },
                    { "name": "value", "type": "any", "optional": true, "description": "Remote object value in case of primitive values or JSON values (if it was requested)." },
                    { "name": "unserializableValue", "$ref": "UnserializableValue", "optional": true, "description": "Primitive value which can not be JSON-stringified does not have <code>value</code>, but gets this property." },
                    { "name": "description", "type": "string", "optional": true, "description": "String representation of the object." },
                    { "name": "objectId", "$ref": "RemoteObjectId", "optional": true, "description": "Unique object identifier (for non-primitive values)." },
                    { "name": "preview", "$ref": "ObjectPreview", "optional": true, "description": "Preview containing abbreviated property values. Specified for <code>object</code> type values only.", "experimental": true },
                    { "name": "customPreview", "$ref": "CustomPreview", "optional": true, "experimental": true}
                ]
            },
            {
                "id": "CustomPreview",
                "type": "object",
                "experimental": true,
                "properties": [
                    { "name": "header", "type": "string"},
                    { "name": "hasBody", "type": "boolean"},
                    { "name": "formatterObjectId", "$ref": "RemoteObjectId"},
                    { "name": "bindRemoteObjectFunctionId", "$ref": "RemoteObjectId" },
                    { "name": "configObjectId", "$ref": "RemoteObjectId", "optional": true }
                ]
            },
            {
                "id": "ObjectPreview",
                "type": "object",
                "experimental": true,
                "description": "Object containing abbreviated remote object value.",
                "properties": [
                    { "name": "type", "type": "string", "enum": ["object", "function", "undefined", "string", "number", "boolean", "symbol"], "description": "Object type." },
                    { "name": "subtype", "type": "string", "optional": true, "enum": ["array", "null", "node", "regexp", "date", "map", "set", "iterator", "generator", "error"], "description": "Object subtype hint. Specified for <code>object</code> type values only." },
                    { "name": "description", "type": "string", "optional": true, "description": "String representation of the object." },
                    { "name": "overflow", "type": "boolean", "description": "True iff some of the properties or entries of the original object did not fit." },
                    { "name": "properties", "type": "array", "items": { "$ref": "PropertyPreview" }, "description": "List of the properties." },
                    { "name": "entries", "type": "array", "items": { "$ref": "EntryPreview" }, "optional": true, "description": "List of the entries. Specified for <code>map</code> and <code>set</code> subtype values only." }
                ]
            },
            {
                "id": "PropertyPreview",
                "type": "object",
                "experimental": true,
                "properties": [
                    { "name": "name", "type": "string", "description": "Property name." },
                    { "name": "type", "type": "string", "enum": ["object", "function", "undefined", "string", "number", "boolean", "symbol", "accessor"], "description": "Object type. Accessor means that the property itself is an accessor property." },
                    { "name": "value", "type": "string", "optional": true, "description": "User-friendly property value string." },
                    { "name": "valuePreview", "$ref": "ObjectPreview", "optional": true, "description": "Nested value preview." },
                    { "name": "subtype", "type": "string", "optional": true, "enum": ["array", "null", "node", "regexp", "date", "map", "set", "iterator", "generator", "error"], "description": "Object subtype hint. Specified for <code>object</code> type values only." }
                ]
            },
            {
                "id": "EntryPreview",
                "type": "object",
                "experimental": true,
                "properties": [
                    { "name": "key", "$ref": "ObjectPreview", "optional": true, "description": "Preview of the key. Specified for map-like collection entries." },
                    { "name": "value", "$ref": "ObjectPreview", "description": "Preview of the value." }
                ]
            },
            {
                "id": "PropertyDescriptor",
                "type": "object",
                "description": "Object property descriptor.",
                "properties": [
                    { "name": "name", "type": "string", "description": "Property name or symbol description." },
                    { "name": "value", "$ref": "RemoteObject", "optional": true, "description": "The value associated with the property." },
                    { "name": "writable", "type": "boolean", "optional": true, "description": "True if the value associated with the property may be changed (data descriptors only)." },
                    { "name": "get", "$ref": "RemoteObject", "optional": true, "description": "A function which serves as a getter for the property, or <code>undefined</code> if there is no getter (accessor descriptors only)." },
                    { "name": "set", "$ref": "RemoteObject", "optional": true, "description": "A function which serves as a setter for the property, or <code>undefined</code> if there is no setter (accessor descriptors only)." },
                    { "name": "configurable", "type": "boolean", "description": "True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object." },
                    { "name": "enumerable", "type": "boolean", "description": "True if this property shows up during enumeration of the properties on the corresponding object." },
                    { "name": "wasThrown", "type": "boolean", "optional": true, "description": "True if the result was thrown during the evaluation." },
                    { "name": "isOwn", "optional": true, "type": "boolean", "description": "True if the property is owned for the object." },
                    { "name": "symbol", "$ref": "RemoteObject", "optional": true, "description": "Property symbol object, if the property is of the <code>symbol</code> type." }
                ]
            },
            {
                "id": "InternalPropertyDescriptor",
                "type": "object",
                "description": "Object internal property descriptor. This property isn't normally visible in JavaScript code.",
                "properties": [
                    { "name": "name", "type": "string", "description": "Conventional property name." },
                    { "name": "value", "$ref": "RemoteObject", "optional": true, "description": "The value associated with the property." }
                ]
            },
            {
                "id": "CallArgument",
                "type": "object",
                "description": "Represents function call argument. Either remote object id <code>objectId</code>, primitive <code>value</code>, unserializable primitive value or neither of (for undefined) them should be specified.",
                "properties": [
                    { "name": "value", "type": "any", "optional": true, "description": "Primitive value." },
                    { "name": "unserializableValue", "$ref": "UnserializableValue", "optional": true, "description": "Primitive value which can not be JSON-stringified." },
                    { "name": "objectId", "$ref": "RemoteObjectId", "optional": true, "description": "Remote object handle." }
                ]
            },
            {
                "id": "ExecutionContextId",
                "type": "integer",
                "description": "Id of an execution context."
            },
            {
                "id": "ExecutionContextDescription",
                "type": "object",
                "description": "Description of an isolated world.",
                "properties": [
                    { "name": "id", "$ref": "ExecutionContextId", "description": "Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed." },
                    { "name": "origin", "type": "string", "description": "Execution context origin." },
                    { "name": "name", "type": "string", "description": "Human readable name describing given context." },
                    { "name": "auxData", "type": "object", "optional": true, "description": "Embedder-specific auxiliary data." }
                ]
            },
            {
                "id": "ExceptionDetails",
                "type": "object",
                "description": "Detailed information about exception (or error) that was thrown during script compilation or execution.",
                "properties": [
                    { "name": "exceptionId", "type": "integer", "description": "Exception id." },
                    { "name": "text", "type": "string", "description": "Exception text, which should be used together with exception object when available." },
                    { "name": "lineNumber", "type": "integer", "description": "Line number of the exception location (0-based)." },
                    { "name": "columnNumber", "type": "integer", "description": "Column number of the exception location (0-based)." },
                    { "name": "scriptId", "$ref": "ScriptId", "optional": true, "description": "Script ID of the exception location." },
                    { "name": "url", "type": "string", "optional": true, "description": "URL of the exception location, to be used when the script was not reported." },
                    { "name": "stackTrace", "$ref": "StackTrace", "optional": true, "description": "JavaScript stack trace if available." },
                    { "name": "exception", "$ref": "RemoteObject", "optional": true, "description": "Exception object if available." },
                    { "name": "executionContextId", "$ref": "ExecutionContextId", "optional": true, "description": "Identifier of the context where exception happened." }
                ]
            },
            {
                "id": "Timestamp",
                "type": "number",
                "description": "Number of milliseconds since epoch."
            },
            {
                "id": "CallFrame",
                "type": "object",
                "description": "Stack entry for runtime errors and assertions.",
                "properties": [
                    { "name": "functionName", "type": "string", "description": "JavaScript function name." },
                    { "name": "scriptId", "$ref": "ScriptId", "description": "JavaScript script id." },
                    { "name": "url", "type": "string", "description": "JavaScript script name or url." },
                    { "name": "lineNumber", "type": "integer", "description": "JavaScript script line number (0-based)." },
                    { "name": "columnNumber", "type": "integer", "description": "JavaScript script column number (0-based)." }
                ]
            },
            {
                "id": "StackTrace",
                "type": "object",
                "description": "Call frames for assertions or error messages.",
                "exported": true,
                "properties": [
                    { "name": "description", "type": "string", "optional": true, "description": "String label of this stack trace. For async traces this may be a name of the function that initiated the async call." },
                    { "name": "callFrames", "type": "array", "items": { "$ref": "CallFrame" }, "description": "JavaScript function name." },
                    { "name": "parent", "$ref": "StackTrace", "optional": true, "description": "Asynchronous JavaScript stack trace that preceded this stack, if available." }
                ]
            }
        ],
        "commands": [
            {
                "name": "evaluate",
                "async": true,
                "parameters": [
                    { "name": "expression", "type": "string", "description": "Expression to evaluate." },
                    { "name": "objectGroup", "type": "string", "optional": true, "description": "Symbolic group name that can be used to release multiple objects." },
                    { "name": "includeCommandLineAPI", "type": "boolean", "optional": true, "description": "Determines whether Command Line API should be available during the evaluation." },
                    { "name": "silent", "type": "boolean", "optional": true, "description": "In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state." },
                    { "name": "contextId", "$ref": "ExecutionContextId", "optional": true, "description": "Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page." },
                    { "name": "returnByValue", "type": "boolean", "optional": true, "description": "Whether the result is expected to be a JSON object that should be sent by value." },
                    { "name": "generatePreview", "type": "boolean", "optional": true, "experimental": true, "description": "Whether preview should be generated for the result." },
                    { "name": "userGesture", "type": "boolean", "optional": true, "experimental": true, "description": "Whether execution should be treated as initiated by user in the UI." },
                    { "name": "awaitPromise", "type": "boolean", "optional":true, "description": "Whether execution should wait for promise to be resolved. If the result of evaluation is not a Promise, it's considered to be an error." }
                ],
                "returns": [
                    { "name": "result", "$ref": "RemoteObject", "description": "Evaluation result." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails", "optional": true, "description": "Exception details."}
                ],
                "description": "Evaluates expression on global object."
            },
            {
                "name": "awaitPromise",
                "async": true,
                "parameters": [
                    { "name": "promiseObjectId", "$ref": "RemoteObjectId", "description": "Identifier of the promise." },
                    { "name": "returnByValue", "type": "boolean", "optional": true, "description": "Whether the result is expected to be a JSON object that should be sent by value." },
                    { "name": "generatePreview", "type": "boolean", "optional": true, "description": "Whether preview should be generated for the result." }
                ],
                "returns": [
                    { "name": "result", "$ref": "RemoteObject", "description": "Promise result. Will contain rejected value if promise was rejected." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails", "optional": true, "description": "Exception details if stack strace is available."}
                ],
                "description": "Add handler to promise with given promise object id."
            },
            {
                "name": "callFunctionOn",
                "async": true,
                "parameters": [
                    { "name": "objectId", "$ref": "RemoteObjectId", "description": "Identifier of the object to call function on." },
                    { "name": "functionDeclaration", "type": "string", "description": "Declaration of the function to call." },
                    { "name": "arguments", "type": "array", "items": { "$ref": "CallArgument", "description": "Call argument." }, "optional": true, "description": "Call arguments. All call arguments must belong to the same JavaScript world as the target object." },
                    { "name": "silent", "type": "boolean", "optional": true, "description": "In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state." },
                    { "name": "returnByValue", "type": "boolean", "optional": true, "description": "Whether the result is expected to be a JSON object which should be sent by value." },
                    { "name": "generatePreview", "type": "boolean", "optional": true, "experimental": true, "description": "Whether preview should be generated for the result." },
                    { "name": "userGesture", "type": "boolean", "optional": true, "experimental": true, "description": "Whether execution should be treated as initiated by user in the UI." },
                    { "name": "awaitPromise", "type": "boolean", "optional":true, "description": "Whether execution should wait for promise to be resolved. If the result of evaluation is not a Promise, it's considered to be an error." }
                ],
                "returns": [
                    { "name": "result", "$ref": "RemoteObject", "description": "Call result." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails", "optional": true, "description": "Exception details."}
                ],
                "description": "Calls function with given declaration on the given object. Object group of the result is inherited from the target object."
            },
            {
                "name": "getProperties",
                "parameters": [
                    { "name": "objectId", "$ref": "RemoteObjectId", "description": "Identifier of the object to return properties for." },
                    { "name": "ownProperties", "optional": true, "type": "boolean", "description": "If true, returns properties belonging only to the element itself, not to its prototype chain." },
                    { "name": "accessorPropertiesOnly", "optional": true, "type": "boolean", "description": "If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.", "experimental": true },
                    { "name": "generatePreview", "type": "boolean", "optional": true, "experimental": true, "description": "Whether preview should be generated for the results." }
                ],
                "returns": [
                    { "name": "result", "type": "array", "items": { "$ref": "PropertyDescriptor" }, "description": "Object properties." },
                    { "name": "internalProperties", "optional": true, "type": "array", "items": { "$ref": "InternalPropertyDescriptor" }, "description": "Internal object properties (only of the element itself)." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails", "optional": true, "description": "Exception details."}
                ],
                "description": "Returns properties of a given object. Object group of the result is inherited from the target object."
            },
            {
                "name": "releaseObject",
                "parameters": [
                    { "name": "objectId", "$ref": "RemoteObjectId", "description": "Identifier of the object to release." }
                ],
                "description": "Releases remote object with given id."
            },
            {
                "name": "releaseObjectGroup",
                "parameters": [
                    { "name": "objectGroup", "type": "string", "description": "Symbolic object group name." }
                ],
                "description": "Releases all remote objects that belong to a given group."
            },
            {
                "name": "runIfWaitingForDebugger",
                "description": "Tells inspected instance to run if it was waiting for debugger to attach."
            },
            {
                "name": "enable",
                "description": "Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context."
            },
            {
                "name": "disable",
                "description": "Disables reporting of execution contexts creation."
            },
            {
                "name": "discardConsoleEntries",
                "description": "Discards collected exceptions and console API calls."
            },
            {
                "name": "setCustomObjectFormatterEnabled",
                "parameters": [
                    {
                        "name": "enabled",
                        "type": "boolean"
                    }
                ],
                "experimental": true
            },
            {
                "name": "compileScript",
                "parameters": [
                    { "name": "expression", "type": "string", "description": "Expression to compile." },
                    { "name": "sourceURL", "type": "string", "description": "Source url to be set for the script." },
                    { "name": "persistScript", "type": "boolean", "description": "Specifies whether the compiled script should be persisted." },
                    { "name": "executionContextId", "$ref": "ExecutionContextId", "optional": true, "description": "Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page." }
                ],
                "returns": [
                    { "name": "scriptId", "$ref": "ScriptId", "optional": true, "description": "Id of the script." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails", "optional": true, "description": "Exception details."}
                ],
                "description": "Compiles expression."
            },
            {
                "name": "runScript",
                "async": true,
                "parameters": [
                    { "name": "scriptId", "$ref": "ScriptId", "description": "Id of the script to run." },
                    { "name": "executionContextId", "$ref": "ExecutionContextId", "optional": true, "description": "Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page." },
                    { "name": "objectGroup", "type": "string", "optional": true, "description": "Symbolic group name that can be used to release multiple objects." },
                    { "name": "silent", "type": "boolean", "optional": true, "description": "In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state." },
                    { "name": "includeCommandLineAPI", "type": "boolean", "optional": true, "description": "Determines whether Command Line API should be available during the evaluation." },
                    { "name": "returnByValue", "type": "boolean", "optional": true, "description": "Whether the result is expected to be a JSON object which should be sent by value." },
                    { "name": "generatePreview", "type": "boolean", "optional": true, "description": "Whether preview should be generated for the result." },
                    { "name": "awaitPromise", "type": "boolean", "optional": true, "description": "Whether execution should wait for promise to be resolved. If the result of evaluation is not a Promise, it's considered to be an error." }
                ],
                "returns": [
                    { "name": "result", "$ref": "RemoteObject", "description": "Run result." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails", "optional": true, "description": "Exception details."}
                ],
                "description": "Runs script with given id in a given context."
            }
        ],
        "events": [
            {
                "name": "executionContextCreated",
                "parameters": [
                    { "name": "context", "$ref": "ExecutionContextDescription", "description": "A newly created execution contex." }
                ],
                "description": "Issued when new execution context is created."
            },
            {
                "name": "executionContextDestroyed",
                "parameters": [
                    { "name": "executionContextId", "$ref": "ExecutionContextId", "description": "Id of the destroyed context" }
                ],
                "description": "Issued when execution context is destroyed."
            },
            {
                "name": "executionContextsCleared",
                "description": "Issued when all executionContexts were cleared in browser"
            },
            {
                "name": "exceptionThrown",
                "description": "Issued when exception was thrown and unhandled.",
                "parameters": [
                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp of the exception." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails" }
                ]
            },
            {
                "name": "exceptionRevoked",
                "description": "Issued when unhandled exception was revoked.",
                "parameters": [
                    { "name": "reason", "type": "string", "description": "Reason describing why exception was revoked." },
                    { "name": "exceptionId", "type": "integer", "description": "The id of revoked exception, as reported in <code>exceptionUnhandled</code>." }
                ]
            },
            {
                "name": "consoleAPICalled",
                "description": "Issued when console API was called.",
                "parameters": [
                    { "name": "type", "type": "string", "enum": ["log", "debug", "info", "error", "warning", "dir", "dirxml", "table", "trace", "clear", "startGroup", "startGroupCollapsed", "endGroup", "assert", "profile", "profileEnd"], "description": "Type of the call." },
                    { "name": "args", "type": "array", "items": { "$ref": "RemoteObject" }, "description": "Call arguments." },
                    { "name": "executionContextId", "$ref": "ExecutionContextId", "description": "Identifier of the context where the call was made." },
                    { "name": "timestamp", "$ref": "Timestamp", "description": "Call timestamp." },
                    { "name": "stackTrace", "$ref": "StackTrace", "optional": true, "description": "Stack trace captured when the call was made." }
                ]
            },
            {
                "name": "inspectRequested",
                "description": "Issued when object should be inspected (for example, as a result of inspect() command line API call).",
                "parameters": [
                    { "name": "object", "$ref": "RemoteObject" },
                    { "name": "hints", "type": "object" }
                ]
            }
        ]
    },
    {
        "domain": "Debugger",
        "description": "Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing breakpoints, stepping through execution, exploring stack traces, etc.",
        "dependencies": ["Runtime"],
        "types": [
            {
                "id": "BreakpointId",
                "type": "string",
                "description": "Breakpoint identifier."
            },
            {
                "id": "CallFrameId",
                "type": "string",
                "description": "Call frame identifier."
            },
            {
                "id": "Location",
                "type": "object",
                "properties": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Script identifier as reported in the <code>Debugger.scriptParsed</code>." },
                    { "name": "lineNumber", "type": "integer", "description": "Line number in the script (0-based)." },
                    { "name": "columnNumber", "type": "integer", "optional": true, "description": "Column number in the script (0-based)." }
                ],
                "description": "Location in the source code."
            },
            {
                "id": "ScriptPosition",
                "experimental": true,
                "type": "object",
                "properties": [
                    { "name": "lineNumber", "type": "integer" },
                    { "name": "columnNumber", "type": "integer" }
                ],
                "description": "Location in the source code."
            },
            {
                "id": "CallFrame",
                "type": "object",
                "properties": [
                    { "name": "callFrameId", "$ref": "CallFrameId", "description": "Call frame identifier. This identifier is only valid while the virtual machine is paused." },
                    { "name": "functionName", "type": "string", "description": "Name of the JavaScript function called on this call frame." },
                    { "name": "functionLocation", "$ref": "Location", "optional": true, "experimental": true, "description": "Location in the source code." },
                    { "name": "location", "$ref": "Location", "description": "Location in the source code." },
                    { "name": "scopeChain", "type": "array", "items": { "$ref": "Scope" }, "description": "Scope chain for this call frame." },
                    { "name": "this", "$ref": "Runtime.RemoteObject", "description": "<code>this</code> object for this call frame." },
                    { "name": "returnValue", "$ref": "Runtime.RemoteObject", "optional": true, "description": "The value being returned, if the function is at return point." }
                ],
                "description": "JavaScript call frame. Array of call frames form the call stack."
            },
            {
                "id": "Scope",
                "type": "object",
                "properties": [
                    { "name": "type", "type": "string", "enum": ["global", "local", "with", "closure", "catch", "block", "script"], "description": "Scope type." },
                    { "name": "object", "$ref": "Runtime.RemoteObject", "description": "Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties." },
                    { "name": "name", "type": "string", "optional": true },
                    { "name": "startLocation", "$ref": "Location", "optional": true, "description": "Location in the source code where scope starts" },
                    { "name": "endLocation", "$ref": "Location", "optional": true, "description": "Location in the source code where scope ends" }
                ],
                "description": "Scope description."
            },
            {
                "id": "SearchMatch",
                "type": "object",
                "description": "Search match for resource.",
                "exported": true,
                "properties": [
                    { "name": "lineNumber", "type": "number", "description": "Line number in resource content." },
                    { "name": "lineContent", "type": "string", "description": "Line with match content." }
                ],
                "experimental": true
            }
        ],
        "commands": [
            {
                "name": "enable",
                "description": "Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received."
            },
            {
                "name": "disable",
                "description": "Disables debugger for given page."
            },
            {
                "name": "setBreakpointsActive",
                "parameters": [
                    { "name": "active", "type": "boolean", "description": "New value for breakpoints active state." }
                ],
                "description": "Activates / deactivates all breakpoints on the page."
            },
            {
                "name": "setSkipAllPauses",
                "parameters": [
                    { "name": "skip", "type": "boolean", "description": "New value for skip pauses state." }
                ],
                "description": "Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc)."
            },
            {
                "name": "setBreakpointByUrl",
                "parameters": [
                    { "name": "lineNumber", "type": "integer", "description": "Line number to set breakpoint at." },
                    { "name": "url", "type": "string", "optional": true, "description": "URL of the resources to set breakpoint on." },
                    { "name": "urlRegex", "type": "string", "optional": true, "description": "Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified." },
                    { "name": "columnNumber", "type": "integer", "optional": true, "description": "Offset in the line to set breakpoint at." },
                    { "name": "condition", "type": "string", "optional": true, "description": "Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true." }
                ],
                "returns": [
                    { "name": "breakpointId", "$ref": "BreakpointId", "description": "Id of the created breakpoint for further reference." },
                    { "name": "locations", "type": "array", "items": { "$ref": "Location" }, "description": "List of the locations this breakpoint resolved into upon addition." }
                ],
                "description": "Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads."
            },
            {
                "name": "setBreakpoint",
                "parameters": [
                    { "name": "location", "$ref": "Location", "description": "Location to set breakpoint in." },
                    { "name": "condition", "type": "string", "optional": true, "description": "Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true." }
                ],
                "returns": [
                    { "name": "breakpointId", "$ref": "BreakpointId", "description": "Id of the created breakpoint for further reference." },
                    { "name": "actualLocation", "$ref": "Location", "description": "Location this breakpoint resolved into." }
                ],
                "description": "Sets JavaScript breakpoint at a given location."
            },
            {
                "name": "removeBreakpoint",
                "parameters": [
                    { "name": "breakpointId", "$ref": "BreakpointId" }
                ],
                "description": "Removes JavaScript breakpoint."
            },
            {
                "name": "continueToLocation",
                "parameters": [
                    { "name": "location", "$ref": "Location", "description": "Location to continue to." }
                ],
                "description": "Continues execution until specific location is reached."
            },
            {
                "name": "stepOver",
                "description": "Steps over the statement."
            },
            {
                "name": "stepInto",
                "description": "Steps into the function call."
            },
            {
                "name": "stepOut",
                "description": "Steps out of the function call."
            },
            {
                "name": "pause",
                "description": "Stops on the next JavaScript statement."
            },
            {
                "name": "resume",
                "description": "Resumes JavaScript execution."
            },
            {
                "name": "searchInContent",
                "parameters": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Id of the script to search in." },
                    { "name": "query", "type": "string", "description": "String to search for."  },
                    { "name": "caseSensitive", "type": "boolean", "optional": true, "description": "If true, search is case sensitive." },
                    { "name": "isRegex", "type": "boolean", "optional": true, "description": "If true, treats string parameter as regex." }
                ],
                "returns": [
                    { "name": "result", "type": "array", "items": { "$ref": "SearchMatch" }, "description": "List of search matches." }
                ],
                "experimental": true,
                "description": "Searches for given string in script content."
            },
            {
                "name": "setScriptSource",
                "parameters": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Id of the script to edit." },
                    { "name": "scriptSource", "type": "string", "description": "New content of the script." },
                    { "name": "dryRun", "type": "boolean", "optional": true, "description": " If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code." }
                ],
                "returns": [
                    { "name": "callFrames", "type": "array", "optional": true, "items": { "$ref": "CallFrame" }, "description": "New stack trace in case editing has happened while VM was stopped." },
                    { "name": "stackChanged", "type": "boolean", "optional": true, "description": "Whether current call stack  was modified after applying the changes." },
                    { "name": "asyncStackTrace", "$ref": "Runtime.StackTrace", "optional": true, "description": "Async stack trace, if any." },
                    { "name": "exceptionDetails", "optional": true, "$ref": "Runtime.ExceptionDetails", "description": "Exception details if any." }
                ],
                "description": "Edits JavaScript source live."
            },
            {
                "name": "restartFrame",
                "parameters": [
                    { "name": "callFrameId", "$ref": "CallFrameId", "description": "Call frame identifier to evaluate on." }
                ],
                "returns": [
                    { "name": "callFrames", "type": "array", "items": { "$ref": "CallFrame" }, "description": "New stack trace." },
                    { "name": "asyncStackTrace", "$ref": "Runtime.StackTrace", "optional": true, "description": "Async stack trace, if any." }
                ],
                "description": "Restarts particular call frame from the beginning."
            },
            {
                "name": "getScriptSource",
                "parameters": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Id of the script to get source for." }
                ],
                "returns": [
                    { "name": "scriptSource", "type": "string", "description": "Script source." }
                ],
                "description": "Returns source for the script with given id."
            },
            {
                "name": "setPauseOnExceptions",
                "parameters": [
                    { "name": "state", "type": "string", "enum": ["none", "uncaught", "all"], "description": "Pause on exceptions mode." }
                ],
                "description": "Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>."
            },
            {
                "name": "evaluateOnCallFrame",
                "parameters": [
                    { "name": "callFrameId", "$ref": "CallFrameId", "description": "Call frame identifier to evaluate on." },
                    { "name": "expression", "type": "string", "description": "Expression to evaluate." },
                    { "name": "objectGroup", "type": "string", "optional": true, "description": "String object group name to put result into (allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>)." },
                    { "name": "includeCommandLineAPI", "type": "boolean", "optional": true, "description": "Specifies whether command line API should be available to the evaluated expression, defaults to false." },
                    { "name": "silent", "type": "boolean", "optional": true, "description": "In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state." },
                    { "name": "returnByValue", "type": "boolean", "optional": true, "description": "Whether the result is expected to be a JSON object that should be sent by value." },
                    { "name": "generatePreview", "type": "boolean", "optional": true, "experimental": true, "description": "Whether preview should be generated for the result." }
                ],
                "returns": [
                    { "name": "result", "$ref": "Runtime.RemoteObject", "description": "Object wrapper for the evaluation result." },
                    { "name": "exceptionDetails", "$ref": "Runtime.ExceptionDetails", "optional": true, "description": "Exception details."}
                ],
                "description": "Evaluates expression on a given call frame."
            },
            {
                "name": "setVariableValue",
                "parameters": [
                    { "name": "scopeNumber", "type": "integer", "description": "0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually." },
                    { "name": "variableName", "type": "string", "description": "Variable name." },
                    { "name": "newValue", "$ref": "Runtime.CallArgument", "description": "New variable value." },
                    { "name": "callFrameId", "$ref": "CallFrameId", "description": "Id of callframe that holds variable." }
                ],
                "description": "Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually."
            },
            {
                "name": "setAsyncCallStackDepth",
                "parameters": [
                    { "name": "maxDepth", "type": "integer", "description": "Maximum depth of async call stacks. Setting to <code>0</code> will effectively disable collecting async call stacks (default)." }
                ],
                "description": "Enables or disables async call stacks tracking."
            },
            {
                "name": "setBlackboxPatterns",
                "parameters": [
                    { "name": "patterns", "type": "array", "items": { "type": "string" }, "description": "Array of regexps that will be used to check script url for blackbox state." }
                ],
                "experimental": true,
                "description": "Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful."
            },
            {
                "name": "setBlackboxedRanges",
                "parameters": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Id of the script." },
                    { "name": "positions", "type": "array", "items": { "$ref": "ScriptPosition" } }
                ],
                "experimental": true,
                "description": "Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted."
            }
        ],
        "events": [
            {
                "name": "scriptParsed",
                "parameters": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Identifier of the script parsed." },
                    { "name": "url", "type": "string", "description": "URL or name of the script parsed (if any)." },
                    { "name": "startLine", "type": "integer", "description": "Line offset of the script within the resource with given URL (for script tags)." },
                    { "name": "startColumn", "type": "integer", "description": "Column offset of the script within the resource with given URL." },
                    { "name": "endLine", "type": "integer", "description": "Last line of the script." },
                    { "name": "endColumn", "type": "integer", "description": "Length of the last line of the script." },
                    { "name": "executionContextId", "$ref": "Runtime.ExecutionContextId", "description": "Specifies script creation context." },
                    { "name": "hash", "type": "string", "description": "Content hash of the script."},
                    { "name": "executionContextAuxData", "type": "object", "optional": true, "description": "Embedder-specific auxiliary data." },
                    { "name": "isLiveEdit", "type": "boolean", "optional": true, "description": "True, if this script is generated as a result of the live edit operation.", "experimental": true },
                    { "name": "sourceMapURL", "type": "string", "optional": true, "description": "URL of source map associated with script (if any)." },
                    { "name": "hasSourceURL", "type": "boolean", "optional": true, "description": "True, if this script has sourceURL.", "experimental": true }
                ],
                "description": "Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger."
            },
            {
                "name": "scriptFailedToParse",
                "parameters": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Identifier of the script parsed." },
                    { "name": "url", "type": "string", "description": "URL or name of the script parsed (if any)." },
                    { "name": "startLine", "type": "integer", "description": "Line offset of the script within the resource with given URL (for script tags)." },
                    { "name": "startColumn", "type": "integer", "description": "Column offset of the script within the resource with given URL." },
                    { "name": "endLine", "type": "integer", "description": "Last line of the script." },
                    { "name": "endColumn", "type": "integer", "description": "Length of the last line of the script." },
                    { "name": "executionContextId", "$ref": "Runtime.ExecutionContextId", "description": "Specifies script creation context." },
                    { "name": "hash", "type": "string", "description": "Content hash of the script."},
                    { "name": "executionContextAuxData", "type": "object", "optional": true, "description": "Embedder-specific auxiliary data." },
                    { "name": "sourceMapURL", "type": "string", "optional": true, "description": "URL of source map associated with script (if any)." },
                    { "name": "hasSourceURL", "type": "boolean", "optional": true, "description": "True, if this script has sourceURL.", "experimental": true }
                ],
                "description": "Fired when virtual machine fails to parse the script."
            },
            {
                "name": "breakpointResolved",
                "parameters": [
                    { "name": "breakpointId", "$ref": "BreakpointId", "description": "Breakpoint unique identifier." },
                    { "name": "location", "$ref": "Location", "description": "Actual breakpoint location." }
                ],
                "description": "Fired when breakpoint is resolved to an actual script and location."
            },
            {
                "name": "paused",
                "parameters": [
                    { "name": "callFrames", "type": "array", "items": { "$ref": "CallFrame" }, "description": "Call stack the virtual machine stopped on." },
                    { "name": "reason", "type": "string", "enum": [ "XHR", "DOM", "EventListener", "exception", "assert", "debugCommand", "promiseRejection", "other" ], "description": "Pause reason.", "exported": true },
                    { "name": "data", "type": "object", "optional": true, "description": "Object containing break-specific auxiliary properties." },
                    { "name": "hitBreakpoints", "type": "array", "optional": true, "items": { "type": "string" }, "description": "Hit breakpoints IDs" },
                    { "name": "asyncStackTrace", "$ref": "Runtime.StackTrace", "optional": true, "description": "Async stack trace, if any." }
                ],
                "description": "Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria."
            },
            {
                "name": "resumed",
                "description": "Fired when the virtual machine resumed execution."
            }
        ]
    },
    {
        "domain": "Console",
        "description": "This domain is deprecated - use Runtime or Log instead.",
        "dependencies": ["Runtime"],
        "deprecated": true,
        "types": [
            {
                "id": "ConsoleMessage",
                "type": "object",
                "description": "Console message.",
                "properties": [
                    { "name": "source", "type": "string", "enum": ["xml", "javascript", "network", "console-api", "storage", "appcache", "rendering", "security", "other", "deprecation", "worker"], "description": "Message source." },
                    { "name": "level", "type": "string", "enum": ["log", "warning", "error", "debug", "info"], "description": "Message severity." },
                    { "name": "text", "type": "string", "description": "Message text." },
                    { "name": "url", "type": "string", "optional": true, "description": "URL of the message origin." },
                    { "name": "line", "type": "integer", "optional": true, "description": "Line number in the resource that generated this message (1-based)." },
                    { "name": "column", "type": "integer", "optional": true, "description": "Column number in the resource that generated this message (1-based)." }
                ]
            }
        ],
        "commands": [
            {
                "name": "enable",
                "description": "Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification."
            },
            {
                "name": "disable",
                "description": "Disables console domain, prevents further console messages from being reported to the client."
            },
            {
                "name": "clearMessages",
                "description": "Does nothing."
            }
        ],
        "events": [
            {
                "name": "messageAdded",
                "parameters": [
                    { "name": "message", "$ref": "ConsoleMessage", "description": "Console message that has been added." }
                ],
                "description": "Issued when new console message is added."
            }
        ]
    },
    {
        "domain": "Profiler",
        "dependencies": ["Runtime", "Debugger"],
        "types": [
            {
                "id": "ProfileNode",
                "type": "object",
                "description": "Profile node. Holds callsite information, execution statistics and child nodes.",
                "properties": [
                    { "name": "id", "type": "integer", "description": "Unique id of the node." },
                    { "name": "callFrame", "$ref": "Runtime.CallFrame", "description": "Function location." },
                    { "name": "hitCount", "type": "integer", "optional": true, "experimental": true, "description": "Number of samples where this node was on top of the call stack." },
                    { "name": "children", "type": "array", "items": { "type": "integer" }, "optional": true, "description": "Child node ids." },
                    { "name": "deoptReason", "type": "string", "optional": true, "description": "The reason of being not optimized. The function may be deoptimized or marked as don't optimize."},
                    { "name": "positionTicks", "type": "array", "items": { "$ref": "PositionTickInfo" }, "optional": true, "experimental": true, "description": "An array of source position ticks." }
                ]
            },
            {
                "id": "Profile",
                "type": "object",
                "description": "Profile.",
                "properties": [
                    { "name": "nodes", "type": "array", "items": { "$ref": "ProfileNode" }, "description": "The list of profile nodes. First item is the root node." },
                    { "name": "startTime", "type": "number", "description": "Profiling start timestamp in microseconds." },
                    { "name": "endTime", "type": "number", "description": "Profiling end timestamp in microseconds." },
                    { "name": "samples", "optional": true, "type": "array", "items": { "type": "integer" }, "description": "Ids of samples top nodes." },
                    { "name": "timeDeltas", "optional": true, "type": "array", "items": { "type": "integer" }, "description": "Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime." }
                ]
            },
            {
                "id": "PositionTickInfo",
                "type": "object",
                "experimental": true,
                "description": "Specifies a number of samples attributed to a certain source position.",
                "properties": [
                    { "name": "line", "type": "integer", "description": "Source line number (1-based)." },
                    { "name": "ticks", "type": "integer", "description": "Number of samples attributed to the source line." }
                ]
            }
        ],
        "commands": [
            {
                "name": "enable"
            },
            {
                "name": "disable"
            },
            {
                "name": "setSamplingInterval",
                "parameters": [
                    { "name": "interval", "type": "integer", "description": "New sampling interval in microseconds." }
                ],
                "description": "Changes CPU profiler sampling interval. Must be called before CPU profiles recording started."
            },
            {
                "name": "start"
            },
            {
                "name": "stop",
                "returns": [
                    { "name": "profile", "$ref": "Profile", "description": "Recorded profile." }
                ]
            }
        ],
        "events": [
            {
                "name": "consoleProfileStarted",
                "parameters": [
                    { "name": "id", "type": "string" },
                    { "name": "location", "$ref": "Debugger.Location", "description": "Location of console.profile()." },
                    { "name": "title", "type": "string", "optional": true, "description": "Profile title passed as an argument to console.profile()." }
                ],
                "description": "Sent when new profile recodring is started using console.profile() call."
            },
            {
                "name": "consoleProfileFinished",
                "parameters": [
                    { "name": "id", "type": "string" },
                    { "name": "location", "$ref": "Debugger.Location", "description": "Location of console.profileEnd()." },
                    { "name": "profile", "$ref": "Profile" },
                    { "name": "title", "type": "string", "optional": true, "description": "Profile title passed as an argument to console.profile()." }
                ]
            }
        ]
    },
    {
        "domain": "HeapProfiler",
        "dependencies": ["Runtime"],
        "experimental": true,
        "types": [
            {
                "id": "HeapSnapshotObjectId",
                "type": "string",
                "description": "Heap snapshot object id."
            },
            {
                "id": "SamplingHeapProfileNode",
                "type": "object",
                "description": "Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.",
                "properties": [
                    { "name": "callFrame", "$ref": "Runtime.CallFrame", "description": "Function location." },
                    { "name": "selfSize", "type": "number", "description": "Allocations size in bytes for the node excluding children." },
                    { "name": "children", "type": "array", "items": { "$ref": "SamplingHeapProfileNode" }, "description": "Child nodes." }
                ]
            },
            {
                "id": "SamplingHeapProfile",
                "type": "object",
                "description": "Profile.",
                "properties": [
                    { "name": "head", "$ref": "SamplingHeapProfileNode" }
                ]
            }
        ],
        "commands": [
            {
                "name": "enable"
            },
            {
                "name": "disable"
            },
            {
                "name": "startTrackingHeapObjects",
                "parameters": [
                    { "name": "trackAllocations", "type": "boolean", "optional": true }
                ]
            },
            {
                "name": "stopTrackingHeapObjects",
                "parameters": [
                    { "name": "reportProgress", "type": "boolean", "optional": true, "description": "If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped." }
                ]
            },
            {
                "name": "takeHeapSnapshot",
                "parameters": [
                    { "name": "reportProgress", "type": "boolean", "optional": true, "description": "If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken." }
                ]
            },
            {
                "name": "collectGarbage"
            },
            {
                "name": "getObjectByHeapObjectId",
                "parameters": [
                    { "name": "objectId", "$ref": "HeapSnapshotObjectId" },
                    { "name": "objectGroup", "type": "string", "optional": true, "description": "Symbolic group name that can be used to release multiple objects." }
                ],
                "returns": [
                    { "name": "result", "$ref": "Runtime.RemoteObject", "description": "Evaluation result." }
                ]
            },
            {
                "name": "addInspectedHeapObject",
                "parameters": [
                    { "name": "heapObjectId", "$ref": "HeapSnapshotObjectId", "description": "Heap snapshot object id to be accessible by means of $x command line API." }
                ],
                "description": "Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions)."
            },
            {
                "name": "getHeapObjectId",
                "parameters": [
                    { "name": "objectId", "$ref": "Runtime.RemoteObjectId", "description": "Identifier of the object to get heap object id for." }
                ],
                "returns": [
                    { "name": "heapSnapshotObjectId", "$ref": "HeapSnapshotObjectId", "description": "Id of the heap snapshot object corresponding to the passed remote object id." }
                ]
            },
            {
                "name": "startSampling",
                "parameters": [
                    { "name": "samplingInterval", "type": "number", "optional": true, "description": "Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes." }
                ]
            },
            {
                "name": "stopSampling",
                "returns": [
                    { "name": "profile", "$ref": "SamplingHeapProfile", "description": "Recorded sampling heap profile." }
                ]
            }
        ],
        "events": [
            {
                "name": "addHeapSnapshotChunk",
                "parameters": [
                    { "name": "chunk", "type": "string" }
                ]
            },
            {
                "name": "resetProfiles"
            },
            {
                "name": "reportHeapSnapshotProgress",
                "parameters": [
                    { "name": "done", "type": "integer" },
                    { "name": "total", "type": "integer" },
                    { "name": "finished", "type": "boolean", "optional": true }
                ]
            },
            {
                "name": "lastSeenObjectId",
                "description": "If heap objects tracking has been started then backend regulary sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.",
                "parameters": [
                    { "name": "lastSeenObjectId", "type": "integer" },
                    { "name": "timestamp", "type": "number" }
                ]
            },
            {
                "name": "heapStatsUpdate",
                "description": "If heap objects tracking has been started then backend may send update for one or more fragments",
                "parameters": [
                    { "name": "statsUpdate", "type": "array", "items": { "type": "integer" }, "description": "An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment."}
                ]
            }
        ]
    }]
}
                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/include/js_protocol-1.3.json                                                    0000664 0000000 0000000 00000232623 14746647661 0021227 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
    "version": { "major": "1", "minor": "3" },
    "domains": [
    {
        "domain": "Schema",
        "description": "This domain is deprecated.",
        "deprecated": true,
        "types": [
            {
                "id": "Domain",
                "type": "object",
                "description": "Description of the protocol domain.",
                "properties": [
                    { "name": "name", "type": "string", "description": "Domain name." },
                    { "name": "version", "type": "string", "description": "Domain version." }
                ]
            }
        ],
        "commands": [
            {
                "name": "getDomains",
                "description": "Returns supported domains.",
                "handlers": ["browser", "renderer"],
                "returns": [
                    { "name": "domains", "type": "array", "items": { "$ref": "Domain" }, "description": "List of supported domains." }
                ]
            }
        ]
    },
    {
        "domain": "Runtime",
        "description": "Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects. Evaluation results are returned as mirror object that expose object type, string representation and unique identifier that can be used for further object reference. Original objects are maintained in memory unless they are either explicitly released or are released along with the other objects in their object group.",
        "types": [
            {
                "id": "ScriptId",
                "type": "string",
                "description": "Unique script identifier."
            },
            {
                "id": "RemoteObjectId",
                "type": "string",
                "description": "Unique object identifier."
            },
            {
                "id": "UnserializableValue",
                "type": "string",
                "enum": ["Infinity", "NaN", "-Infinity", "-0"],
                "description": "Primitive value which cannot be JSON-stringified."
            },
            {
                "id": "RemoteObject",
                "type": "object",
                "description": "Mirror object referencing original JavaScript object.",
                "properties": [
                    { "name": "type", "type": "string", "enum": ["object", "function", "undefined", "string", "number", "boolean", "symbol"], "description": "Object type." },
                    { "name": "subtype", "type": "string", "optional": true, "enum": ["array", "null", "node", "regexp", "date", "map", "set", "weakmap", "weakset", "iterator", "generator", "error", "proxy", "promise", "typedarray"], "description": "Object subtype hint. Specified for <code>object</code> type values only." },
                    { "name": "className", "type": "string", "optional": true, "description": "Object class (constructor) name. Specified for <code>object</code> type values only." },
                    { "name": "value", "type": "any", "optional": true, "description": "Remote object value in case of primitive values or JSON values (if it was requested)." },
                    { "name": "unserializableValue", "$ref": "UnserializableValue", "optional": true, "description": "Primitive value which can not be JSON-stringified does not have <code>value</code>, but gets this property." },
                    { "name": "description", "type": "string", "optional": true, "description": "String representation of the object." },
                    { "name": "objectId", "$ref": "RemoteObjectId", "optional": true, "description": "Unique object identifier (for non-primitive values)." },
                    { "name": "preview", "$ref": "ObjectPreview", "optional": true, "description": "Preview containing abbreviated property values. Specified for <code>object</code> type values only.", "experimental": true },
                    { "name": "customPreview", "$ref": "CustomPreview", "optional": true, "experimental": true}
                ]
            },
            {
                "id": "CustomPreview",
                "type": "object",
                "experimental": true,
                "properties": [
                    { "name": "header", "type": "string"},
                    { "name": "hasBody", "type": "boolean"},
                    { "name": "formatterObjectId", "$ref": "RemoteObjectId"},
                    { "name": "bindRemoteObjectFunctionId", "$ref": "RemoteObjectId" },
                    { "name": "configObjectId", "$ref": "RemoteObjectId", "optional": true }
                ]
            },
            {
                "id": "ObjectPreview",
                "type": "object",
                "experimental": true,
                "description": "Object containing abbreviated remote object value.",
                "properties": [
                    { "name": "type", "type": "string", "enum": ["object", "function", "undefined", "string", "number", "boolean", "symbol"], "description": "Object type." },
                    { "name": "subtype", "type": "string", "optional": true, "enum": ["array", "null", "node", "regexp", "date", "map", "set", "weakmap", "weakset", "iterator", "generator", "error"], "description": "Object subtype hint. Specified for <code>object</code> type values only." },
                    { "name": "description", "type": "string", "optional": true, "description": "String representation of the object." },
                    { "name": "overflow", "type": "boolean", "description": "True iff some of the properties or entries of the original object did not fit." },
                    { "name": "properties", "type": "array", "items": { "$ref": "PropertyPreview" }, "description": "List of the properties." },
                    { "name": "entries", "type": "array", "items": { "$ref": "EntryPreview" }, "optional": true, "description": "List of the entries. Specified for <code>map</code> and <code>set</code> subtype values only." }
                ]
            },
            {
                "id": "PropertyPreview",
                "type": "object",
                "experimental": true,
                "properties": [
                    { "name": "name", "type": "string", "description": "Property name." },
                    { "name": "type", "type": "string", "enum": ["object", "function", "undefined", "string", "number", "boolean", "symbol", "accessor"], "description": "Object type. Accessor means that the property itself is an accessor property." },
                    { "name": "value", "type": "string", "optional": true, "description": "User-friendly property value string." },
                    { "name": "valuePreview", "$ref": "ObjectPreview", "optional": true, "description": "Nested value preview." },
                    { "name": "subtype", "type": "string", "optional": true, "enum": ["array", "null", "node", "regexp", "date", "map", "set", "weakmap", "weakset", "iterator", "generator", "error"], "description": "Object subtype hint. Specified for <code>object</code> type values only." }
                ]
            },
            {
                "id": "EntryPreview",
                "type": "object",
                "experimental": true,
                "properties": [
                    { "name": "key", "$ref": "ObjectPreview", "optional": true, "description": "Preview of the key. Specified for map-like collection entries." },
                    { "name": "value", "$ref": "ObjectPreview", "description": "Preview of the value." }
                ]
            },
            {
                "id": "PropertyDescriptor",
                "type": "object",
                "description": "Object property descriptor.",
                "properties": [
                    { "name": "name", "type": "string", "description": "Property name or symbol description." },
                    { "name": "value", "$ref": "RemoteObject", "optional": true, "description": "The value associated with the property." },
                    { "name": "writable", "type": "boolean", "optional": true, "description": "True if the value associated with the property may be changed (data descriptors only)." },
                    { "name": "get", "$ref": "RemoteObject", "optional": true, "description": "A function which serves as a getter for the property, or <code>undefined</code> if there is no getter (accessor descriptors only)." },
                    { "name": "set", "$ref": "RemoteObject", "optional": true, "description": "A function which serves as a setter for the property, or <code>undefined</code> if there is no setter (accessor descriptors only)." },
                    { "name": "configurable", "type": "boolean", "description": "True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object." },
                    { "name": "enumerable", "type": "boolean", "description": "True if this property shows up during enumeration of the properties on the corresponding object." },
                    { "name": "wasThrown", "type": "boolean", "optional": true, "description": "True if the result was thrown during the evaluation." },
                    { "name": "isOwn", "optional": true, "type": "boolean", "description": "True if the property is owned for the object." },
                    { "name": "symbol", "$ref": "RemoteObject", "optional": true, "description": "Property symbol object, if the property is of the <code>symbol</code> type." }
                ]
            },
            {
                "id": "InternalPropertyDescriptor",
                "type": "object",
                "description": "Object internal property descriptor. This property isn't normally visible in JavaScript code.",
                "properties": [
                    { "name": "name", "type": "string", "description": "Conventional property name." },
                    { "name": "value", "$ref": "RemoteObject", "optional": true, "description": "The value associated with the property." }
                ]
            },
            {
                "id": "CallArgument",
                "type": "object",
                "description": "Represents function call argument. Either remote object id <code>objectId</code>, primitive <code>value</code>, unserializable primitive value or neither of (for undefined) them should be specified.",
                "properties": [
                    { "name": "value", "type": "any", "optional": true, "description": "Primitive value or serializable javascript object." },
                    { "name": "unserializableValue", "$ref": "UnserializableValue", "optional": true, "description": "Primitive value which can not be JSON-stringified." },
                    { "name": "objectId", "$ref": "RemoteObjectId", "optional": true, "description": "Remote object handle." }
                ]
            },
            {
                "id": "ExecutionContextId",
                "type": "integer",
                "description": "Id of an execution context."
            },
            {
                "id": "ExecutionContextDescription",
                "type": "object",
                "description": "Description of an isolated world.",
                "properties": [
                    { "name": "id", "$ref": "ExecutionContextId", "description": "Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed." },
                    { "name": "origin", "type": "string", "description": "Execution context origin." },
                    { "name": "name", "type": "string", "description": "Human readable name describing given context." },
                    { "name": "auxData", "type": "object", "optional": true, "description": "Embedder-specific auxiliary data." }
                ]
            },
            {
                "id": "ExceptionDetails",
                "type": "object",
                "description": "Detailed information about exception (or error) that was thrown during script compilation or execution.",
                "properties": [
                    { "name": "exceptionId", "type": "integer", "description": "Exception id." },
                    { "name": "text", "type": "string", "description": "Exception text, which should be used together with exception object when available." },
                    { "name": "lineNumber", "type": "integer", "description": "Line number of the exception location (0-based)." },
                    { "name": "columnNumber", "type": "integer", "description": "Column number of the exception location (0-based)." },
                    { "name": "scriptId", "$ref": "ScriptId", "optional": true, "description": "Script ID of the exception location." },
                    { "name": "url", "type": "string", "optional": true, "description": "URL of the exception location, to be used when the script was not reported." },
                    { "name": "stackTrace", "$ref": "StackTrace", "optional": true, "description": "JavaScript stack trace if available." },
                    { "name": "exception", "$ref": "RemoteObject", "optional": true, "description": "Exception object if available." },
                    { "name": "executionContextId", "$ref": "ExecutionContextId", "optional": true, "description": "Identifier of the context where exception happened." }
                ]
            },
            {
                "id": "Timestamp",
                "type": "number",
                "description": "Number of milliseconds since epoch."
            },
            {
                "id": "CallFrame",
                "type": "object",
                "description": "Stack entry for runtime errors and assertions.",
                "properties": [
                    { "name": "functionName", "type": "string", "description": "JavaScript function name." },
                    { "name": "scriptId", "$ref": "ScriptId", "description": "JavaScript script id." },
                    { "name": "url", "type": "string", "description": "JavaScript script name or url." },
                    { "name": "lineNumber", "type": "integer", "description": "JavaScript script line number (0-based)." },
                    { "name": "columnNumber", "type": "integer", "description": "JavaScript script column number (0-based)." }
                ]
            },
            {
                "id": "StackTrace",
                "type": "object",
                "description": "Call frames for assertions or error messages.",
                "properties": [
                    { "name": "description", "type": "string", "optional": true, "description": "String label of this stack trace. For async traces this may be a name of the function that initiated the async call." },
                    { "name": "callFrames", "type": "array", "items": { "$ref": "CallFrame" }, "description": "JavaScript function name." },
                    { "name": "parent", "$ref": "StackTrace", "optional": true, "description": "Asynchronous JavaScript stack trace that preceded this stack, if available." },
                    { "name": "parentId", "$ref": "StackTraceId", "optional": true, "experimental": true, "description": "Asynchronous JavaScript stack trace that preceded this stack, if available." }
                ]
            },
            {
                "id": "UniqueDebuggerId",
                "type": "string",
                "description": "Unique identifier of current debugger.",
                "experimental": true
            },
            {
                "id": "StackTraceId",
                "type": "object",
                "description": "If <code>debuggerId</code> is set stack trace comes from another debugger and can be resolved there. This allows to track cross-debugger calls. See <code>Runtime.StackTrace</code> and <code>Debugger.paused</code> for usages.",
                "properties": [
                    { "name": "id", "type": "string" },
                    { "name": "debuggerId", "$ref": "UniqueDebuggerId", "optional": true }
                ],
                "experimental": true
            }
        ],
        "commands": [
            {
                "name": "evaluate",
                "parameters": [
                    { "name": "expression", "type": "string", "description": "Expression to evaluate." },
                    { "name": "objectGroup", "type": "string", "optional": true, "description": "Symbolic group name that can be used to release multiple objects." },
                    { "name": "includeCommandLineAPI", "type": "boolean", "optional": true, "description": "Determines whether Command Line API should be available during the evaluation." },
                    { "name": "silent", "type": "boolean", "optional": true, "description": "In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state." },
                    { "name": "contextId", "$ref": "ExecutionContextId", "optional": true, "description": "Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page." },
                    { "name": "returnByValue", "type": "boolean", "optional": true, "description": "Whether the result is expected to be a JSON object that should be sent by value." },
                    { "name": "generatePreview", "type": "boolean", "optional": true, "experimental": true, "description": "Whether preview should be generated for the result." },
                    { "name": "userGesture", "type": "boolean", "optional": true, "description": "Whether execution should be treated as initiated by user in the UI." },
                    { "name": "awaitPromise", "type": "boolean", "optional":true, "description": "Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved." }
                ],
                "returns": [
                    { "name": "result", "$ref": "RemoteObject", "description": "Evaluation result." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails", "optional": true, "description": "Exception details."}
                ],
                "description": "Evaluates expression on global object."
            },
            {
                "name": "awaitPromise",
                "parameters": [
                    { "name": "promiseObjectId", "$ref": "RemoteObjectId", "description": "Identifier of the promise." },
                    { "name": "returnByValue", "type": "boolean", "optional": true, "description": "Whether the result is expected to be a JSON object that should be sent by value." },
                    { "name": "generatePreview", "type": "boolean", "optional": true, "description": "Whether preview should be generated for the result." }
                ],
                "returns": [
                    { "name": "result", "$ref": "RemoteObject", "description": "Promise result. Will contain rejected value if promise was rejected." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails", "optional": true, "description": "Exception details if stack strace is available."}
                ],
                "description": "Add handler to promise with given promise object id."
            },
            {
                "name": "callFunctionOn",
                "parameters": [
                    { "name": "functionDeclaration", "type": "string", "description": "Declaration of the function to call." },
                    { "name": "objectId", "$ref": "RemoteObjectId", "optional": true, "description": "Identifier of the object to call function on. Either objectId or executionContextId should be specified." },
                    { "name": "arguments", "type": "array", "items": { "$ref": "CallArgument", "description": "Call argument." }, "optional": true, "description": "Call arguments. All call arguments must belong to the same JavaScript world as the target object." },
                    { "name": "silent", "type": "boolean", "optional": true, "description": "In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state." },
                    { "name": "returnByValue", "type": "boolean", "optional": true, "description": "Whether the result is expected to be a JSON object which should be sent by value." },
                    { "name": "generatePreview", "type": "boolean", "optional": true, "experimental": true, "description": "Whether preview should be generated for the result." },
                    { "name": "userGesture", "type": "boolean", "optional": true, "description": "Whether execution should be treated as initiated by user in the UI." },
                    { "name": "awaitPromise", "type": "boolean", "optional":true, "description": "Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved." },
                    { "name": "executionContextId", "$ref": "ExecutionContextId", "optional": true, "description": "Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified." },
                    { "name": "objectGroup", "type": "string", "optional": true, "description": "Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object." }
                ],
                "returns": [
                    { "name": "result", "$ref": "RemoteObject", "description": "Call result." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails", "optional": true, "description": "Exception details."}
                ],
                "description": "Calls function with given declaration on the given object. Object group of the result is inherited from the target object."
            },
            {
                "name": "getProperties",
                "parameters": [
                    { "name": "objectId", "$ref": "RemoteObjectId", "description": "Identifier of the object to return properties for." },
                    { "name": "ownProperties", "optional": true, "type": "boolean", "description": "If true, returns properties belonging only to the element itself, not to its prototype chain." },
                    { "name": "accessorPropertiesOnly", "optional": true, "type": "boolean", "description": "If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.", "experimental": true },
                    { "name": "generatePreview", "type": "boolean", "optional": true, "experimental": true, "description": "Whether preview should be generated for the results." }
                ],
                "returns": [
                    { "name": "result", "type": "array", "items": { "$ref": "PropertyDescriptor" }, "description": "Object properties." },
                    { "name": "internalProperties", "optional": true, "type": "array", "items": { "$ref": "InternalPropertyDescriptor" }, "description": "Internal object properties (only of the element itself)." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails", "optional": true, "description": "Exception details."}
                ],
                "description": "Returns properties of a given object. Object group of the result is inherited from the target object."
            },
            {
                "name": "releaseObject",
                "parameters": [
                    { "name": "objectId", "$ref": "RemoteObjectId", "description": "Identifier of the object to release." }
                ],
                "description": "Releases remote object with given id."
            },
            {
                "name": "releaseObjectGroup",
                "parameters": [
                    { "name": "objectGroup", "type": "string", "description": "Symbolic object group name." }
                ],
                "description": "Releases all remote objects that belong to a given group."
            },
            {
                "name": "runIfWaitingForDebugger",
                "description": "Tells inspected instance to run if it was waiting for debugger to attach."
            },
            {
                "name": "enable",
                "description": "Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context."
            },
            {
                "name": "disable",
                "description": "Disables reporting of execution contexts creation."
            },
            {
                "name": "discardConsoleEntries",
                "description": "Discards collected exceptions and console API calls."
            },
            {
                "name": "setCustomObjectFormatterEnabled",
                "parameters": [
                    {
                        "name": "enabled",
                        "type": "boolean"
                    }
                ],
                "experimental": true
            },
            {
                "name": "compileScript",
                "parameters": [
                    { "name": "expression", "type": "string", "description": "Expression to compile." },
                    { "name": "sourceURL", "type": "string", "description": "Source url to be set for the script." },
                    { "name": "persistScript", "type": "boolean", "description": "Specifies whether the compiled script should be persisted." },
                    { "name": "executionContextId", "$ref": "ExecutionContextId", "optional": true, "description": "Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page." }
                ],
                "returns": [
                    { "name": "scriptId", "$ref": "ScriptId", "optional": true, "description": "Id of the script." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails", "optional": true, "description": "Exception details."}
                ],
                "description": "Compiles expression."
            },
            {
                "name": "runScript",
                "parameters": [
                    { "name": "scriptId", "$ref": "ScriptId", "description": "Id of the script to run." },
                    { "name": "executionContextId", "$ref": "ExecutionContextId", "optional": true, "description": "Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page." },
                    { "name": "objectGroup", "type": "string", "optional": true, "description": "Symbolic group name that can be used to release multiple objects." },
                    { "name": "silent", "type": "boolean", "optional": true, "description": "In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state." },
                    { "name": "includeCommandLineAPI", "type": "boolean", "optional": true, "description": "Determines whether Command Line API should be available during the evaluation." },
                    { "name": "returnByValue", "type": "boolean", "optional": true, "description": "Whether the result is expected to be a JSON object which should be sent by value." },
                    { "name": "generatePreview", "type": "boolean", "optional": true, "description": "Whether preview should be generated for the result." },
                    { "name": "awaitPromise", "type": "boolean", "optional": true, "description": "Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved." }
                ],
                "returns": [
                    { "name": "result", "$ref": "RemoteObject", "description": "Run result." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails", "optional": true, "description": "Exception details."}
                ],
                "description": "Runs script with given id in a given context."
            },
            {
                "name": "queryObjects",
                "parameters": [
                    { "name": "prototypeObjectId", "$ref": "RemoteObjectId", "description": "Identifier of the prototype to return objects for." }
                ],
                "returns": [
                    { "name": "objects", "$ref": "RemoteObject", "description": "Array with objects." }
                ]
            },
            {
                "name": "globalLexicalScopeNames",
                "parameters": [
                    { "name": "executionContextId", "$ref": "ExecutionContextId", "optional": true, "description": "Specifies in which execution context to lookup global scope variables." }
                ],
                "returns": [
                    { "name": "names", "type": "array", "items": { "type": "string" } }
                ],
                "description": "Returns all let, const and class variables from global scope."
            }
        ],
        "events": [
            {
                "name": "executionContextCreated",
                "parameters": [
                    { "name": "context", "$ref": "ExecutionContextDescription", "description": "A newly created execution context." }
                ],
                "description": "Issued when new execution context is created."
            },
            {
                "name": "executionContextDestroyed",
                "parameters": [
                    { "name": "executionContextId", "$ref": "ExecutionContextId", "description": "Id of the destroyed context" }
                ],
                "description": "Issued when execution context is destroyed."
            },
            {
                "name": "executionContextsCleared",
                "description": "Issued when all executionContexts were cleared in browser"
            },
            {
                "name": "exceptionThrown",
                "description": "Issued when exception was thrown and unhandled.",
                "parameters": [
                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp of the exception." },
                    { "name": "exceptionDetails", "$ref": "ExceptionDetails" }
                ]
            },
            {
                "name": "exceptionRevoked",
                "description": "Issued when unhandled exception was revoked.",
                "parameters": [
                    { "name": "reason", "type": "string", "description": "Reason describing why exception was revoked." },
                    { "name": "exceptionId", "type": "integer", "description": "The id of revoked exception, as reported in <code>exceptionThrown</code>." }
                ]
            },
            {
                "name": "consoleAPICalled",
                "description": "Issued when console API was called.",
                "parameters": [
                    { "name": "type", "type": "string", "enum": ["log", "debug", "info", "error", "warning", "dir", "dirxml", "table", "trace", "clear", "startGroup", "startGroupCollapsed", "endGroup", "assert", "profile", "profileEnd", "count", "timeEnd"], "description": "Type of the call." },
                    { "name": "args", "type": "array", "items": { "$ref": "RemoteObject" }, "description": "Call arguments." },
                    { "name": "executionContextId", "$ref": "ExecutionContextId", "description": "Identifier of the context where the call was made." },
                    { "name": "timestamp", "$ref": "Timestamp", "description": "Call timestamp." },
                    { "name": "stackTrace", "$ref": "StackTrace", "optional": true, "description": "Stack trace captured when the call was made." },
                    { "name": "context", "type": "string", "optional": true, "experimental": true, "description": "Console context descriptor for calls on non-default console context (not console.*): 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call on named context." }
                ]
            },
            {
                "name": "inspectRequested",
                "description": "Issued when object should be inspected (for example, as a result of inspect() command line API call).",
                "parameters": [
                    { "name": "object", "$ref": "RemoteObject" },
                    { "name": "hints", "type": "object" }
                ]
            }
        ]
    },
    {
        "domain": "Debugger",
        "description": "Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing breakpoints, stepping through execution, exploring stack traces, etc.",
        "dependencies": ["Runtime"],
        "types": [
            {
                "id": "BreakpointId",
                "type": "string",
                "description": "Breakpoint identifier."
            },
            {
                "id": "CallFrameId",
                "type": "string",
                "description": "Call frame identifier."
            },
            {
                "id": "Location",
                "type": "object",
                "properties": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Script identifier as reported in the <code>Debugger.scriptParsed</code>." },
                    { "name": "lineNumber", "type": "integer", "description": "Line number in the script (0-based)." },
                    { "name": "columnNumber", "type": "integer", "optional": true, "description": "Column number in the script (0-based)." }
                ],
                "description": "Location in the source code."
            },
            {
                "id": "ScriptPosition",
                "experimental": true,
                "type": "object",
                "properties": [
                    { "name": "lineNumber", "type": "integer" },
                    { "name": "columnNumber", "type": "integer" }
                ],
                "description": "Location in the source code."
            },
            {
                "id": "CallFrame",
                "type": "object",
                "properties": [
                    { "name": "callFrameId", "$ref": "CallFrameId", "description": "Call frame identifier. This identifier is only valid while the virtual machine is paused." },
                    { "name": "functionName", "type": "string", "description": "Name of the JavaScript function called on this call frame." },
                    { "name": "functionLocation", "$ref": "Location", "optional": true, "description": "Location in the source code." },
                    { "name": "location", "$ref": "Location", "description": "Location in the source code." },
                    { "name": "url", "type": "string", "description": "JavaScript script name or url." },
                    { "name": "scopeChain", "type": "array", "items": { "$ref": "Scope" }, "description": "Scope chain for this call frame." },
                    { "name": "this", "$ref": "Runtime.RemoteObject", "description": "<code>this</code> object for this call frame." },
                    { "name": "returnValue", "$ref": "Runtime.RemoteObject", "optional": true, "description": "The value being returned, if the function is at return point." }
                ],
                "description": "JavaScript call frame. Array of call frames form the call stack."
            },
            {
                "id": "Scope",
                "type": "object",
                "properties": [
                    { "name": "type", "type": "string", "enum": ["global", "local", "with", "closure", "catch", "block", "script", "eval", "module"], "description": "Scope type." },
                    { "name": "object", "$ref": "Runtime.RemoteObject", "description": "Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties." },
                    { "name": "name", "type": "string", "optional": true },
                    { "name": "startLocation", "$ref": "Location", "optional": true, "description": "Location in the source code where scope starts" },
                    { "name": "endLocation", "$ref": "Location", "optional": true, "description": "Location in the source code where scope ends" }
                ],
                "description": "Scope description."
            },
            {
                "id": "SearchMatch",
                "type": "object",
                "description": "Search match for resource.",
                "properties": [
                    { "name": "lineNumber", "type": "number", "description": "Line number in resource content." },
                    { "name": "lineContent", "type": "string", "description": "Line with match content." }
                ]
            },
            {
                "id": "BreakLocation",
                "type": "object",
                "properties": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Script identifier as reported in the <code>Debugger.scriptParsed</code>." },
                    { "name": "lineNumber", "type": "integer", "description": "Line number in the script (0-based)." },
                    { "name": "columnNumber", "type": "integer", "optional": true, "description": "Column number in the script (0-based)." },
                    { "name": "type", "type": "string", "enum": [ "debuggerStatement", "call", "return" ], "optional": true }
                ]
            }
        ],
        "commands": [
            {
                "name": "enable",
                "returns": [
                    { "name": "debuggerId", "$ref": "Runtime.UniqueDebuggerId", "experimental": true, "description": "Unique identifier of the debugger." }
                ],
                "description": "Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received."
            },
            {
                "name": "disable",
                "description": "Disables debugger for given page."
            },
            {
                "name": "setBreakpointsActive",
                "parameters": [
                    { "name": "active", "type": "boolean", "description": "New value for breakpoints active state." }
                ],
                "description": "Activates / deactivates all breakpoints on the page."
            },
            {
                "name": "setSkipAllPauses",
                "parameters": [
                    { "name": "skip", "type": "boolean", "description": "New value for skip pauses state." }
                ],
                "description": "Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc)."
            },
            {
                "name": "setBreakpointByUrl",
                "parameters": [
                    { "name": "lineNumber", "type": "integer", "description": "Line number to set breakpoint at." },
                    { "name": "url", "type": "string", "optional": true, "description": "URL of the resources to set breakpoint on." },
                    { "name": "urlRegex", "type": "string", "optional": true, "description": "Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified." },
                    { "name": "scriptHash", "type": "string", "optional": true, "description": "Script hash of the resources to set breakpoint on." },
                    { "name": "columnNumber", "type": "integer", "optional": true, "description": "Offset in the line to set breakpoint at." },
                    { "name": "condition", "type": "string", "optional": true, "description": "Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true." }
                ],
                "returns": [
                    { "name": "breakpointId", "$ref": "BreakpointId", "description": "Id of the created breakpoint for further reference." },
                    { "name": "locations", "type": "array", "items": { "$ref": "Location" }, "description": "List of the locations this breakpoint resolved into upon addition." }
                ],
                "description": "Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads."
            },
            {
                "name": "setBreakpoint",
                "parameters": [
                    { "name": "location", "$ref": "Location", "description": "Location to set breakpoint in." },
                    { "name": "condition", "type": "string", "optional": true, "description": "Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true." }
                ],
                "returns": [
                    { "name": "breakpointId", "$ref": "BreakpointId", "description": "Id of the created breakpoint for further reference." },
                    { "name": "actualLocation", "$ref": "Location", "description": "Location this breakpoint resolved into." }
                ],
                "description": "Sets JavaScript breakpoint at a given location."
            },
            {
                "name": "removeBreakpoint",
                "parameters": [
                    { "name": "breakpointId", "$ref": "BreakpointId" }
                ],
                "description": "Removes JavaScript breakpoint."
            },
            {
                "name": "getPossibleBreakpoints",
                "parameters": [
                    { "name": "start", "$ref": "Location", "description": "Start of range to search possible breakpoint locations in." },
                    { "name": "end", "$ref": "Location", "optional": true, "description": "End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range." },
                    { "name": "restrictToFunction", "type": "boolean", "optional": true, "description": "Only consider locations which are in the same (non-nested) function as start." }
                ],
                "returns": [
                    { "name": "locations", "type": "array", "items": { "$ref": "BreakLocation" }, "description": "List of the possible breakpoint locations." }
                ],
                "description": "Returns possible locations for breakpoint. scriptId in start and end range locations should be the same."
            },
            {
                "name": "continueToLocation",
                "parameters": [
                    { "name": "location", "$ref": "Location", "description": "Location to continue to." },
                    { "name": "targetCallFrames", "type": "string", "enum": ["any", "current"], "optional": true }
                ],
                "description": "Continues execution until specific location is reached."
            },
            {
                "name": "pauseOnAsyncCall",
                "parameters": [
                    { "name": "parentStackTraceId", "$ref": "Runtime.StackTraceId", "description": "Debugger will pause when async call with given stack trace is started." }
                ],
                "experimental": true
            },
            {
                "name": "stepOver",
                "description": "Steps over the statement."
            },
            {
                "name": "stepInto",
                "parameters": [
                    { "name": "breakOnAsyncCall", "type": "boolean", "optional": true, "experimental": true, "description": "Debugger will issue additional Debugger.paused notification if any async task is scheduled before next pause." }
                ],
                "description": "Steps into the function call."
            },
            {
                "name": "stepOut",
                "description": "Steps out of the function call."
            },
            {
                "name": "pause",
                "description": "Stops on the next JavaScript statement."
            },
            {
                "name": "scheduleStepIntoAsync",
                "description": "This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.",
                "experimental": true
            },
            {
                "name": "resume",
                "description": "Resumes JavaScript execution."
            },
            {
                "name": "getStackTrace",
                "parameters": [
                    { "name": "stackTraceId", "$ref": "Runtime.StackTraceId" }
                ],
                "returns": [
                    { "name": "stackTrace", "$ref": "Runtime.StackTrace" }
                ],
                "description": "Returns stack trace with given <code>stackTraceId</code>.",
                "experimental": true
            },
            {
                "name": "searchInContent",
                "parameters": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Id of the script to search in." },
                    { "name": "query", "type": "string", "description": "String to search for."  },
                    { "name": "caseSensitive", "type": "boolean", "optional": true, "description": "If true, search is case sensitive." },
                    { "name": "isRegex", "type": "boolean", "optional": true, "description": "If true, treats string parameter as regex." }
                ],
                "returns": [
                    { "name": "result", "type": "array", "items": { "$ref": "SearchMatch" }, "description": "List of search matches." }
                ],
                "description": "Searches for given string in script content."
            },
            {
                "name": "setScriptSource",
                "parameters": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Id of the script to edit." },
                    { "name": "scriptSource", "type": "string", "description": "New content of the script." },
                    { "name": "dryRun", "type": "boolean", "optional": true, "description": " If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code." }
                ],
                "returns": [
                    { "name": "callFrames", "type": "array", "optional": true, "items": { "$ref": "CallFrame" }, "description": "New stack trace in case editing has happened while VM was stopped." },
                    { "name": "stackChanged", "type": "boolean", "optional": true, "description": "Whether current call stack  was modified after applying the changes." },
                    { "name": "asyncStackTrace", "$ref": "Runtime.StackTrace", "optional": true, "description": "Async stack trace, if any." },
                    { "name": "asyncStackTraceId", "$ref": "Runtime.StackTraceId", "optional": true, "experimental": true, "description": "Async stack trace, if any." },
                    { "name": "exceptionDetails", "optional": true, "$ref": "Runtime.ExceptionDetails", "description": "Exception details if any." }
                ],
                "description": "Edits JavaScript source live."
            },
            {
                "name": "restartFrame",
                "parameters": [
                    { "name": "callFrameId", "$ref": "CallFrameId", "description": "Call frame identifier to evaluate on." }
                ],
                "returns": [
                    { "name": "callFrames", "type": "array", "items": { "$ref": "CallFrame" }, "description": "New stack trace." },
                    { "name": "asyncStackTrace", "$ref": "Runtime.StackTrace", "optional": true, "description": "Async stack trace, if any." },
                    { "name": "asyncStackTraceId", "$ref": "Runtime.StackTraceId", "optional": true, "experimental": true, "description": "Async stack trace, if any." }
                ],
                "description": "Restarts particular call frame from the beginning."
            },
            {
                "name": "getScriptSource",
                "parameters": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Id of the script to get source for." }
                ],
                "returns": [
                    { "name": "scriptSource", "type": "string", "description": "Script source." }
                ],
                "description": "Returns source for the script with given id."
            },
            {
                "name": "setPauseOnExceptions",
                "parameters": [
                    { "name": "state", "type": "string", "enum": ["none", "uncaught", "all"], "description": "Pause on exceptions mode." }
                ],
                "description": "Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>."
            },
            {
                "name": "evaluateOnCallFrame",
                "parameters": [
                    { "name": "callFrameId", "$ref": "CallFrameId", "description": "Call frame identifier to evaluate on." },
                    { "name": "expression", "type": "string", "description": "Expression to evaluate." },
                    { "name": "objectGroup", "type": "string", "optional": true, "description": "String object group name to put result into (allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>)." },
                    { "name": "includeCommandLineAPI", "type": "boolean", "optional": true, "description": "Specifies whether command line API should be available to the evaluated expression, defaults to false." },
                    { "name": "silent", "type": "boolean", "optional": true, "description": "In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state." },
                    { "name": "returnByValue", "type": "boolean", "optional": true, "description": "Whether the result is expected to be a JSON object that should be sent by value." },
                    { "name": "generatePreview", "type": "boolean", "optional": true, "experimental": true, "description": "Whether preview should be generated for the result." },
                    { "name": "throwOnSideEffect", "type": "boolean", "optional": true, "description": "Whether to throw an exception if side effect cannot be ruled out during evaluation." }
                ],
                "returns": [
                    { "name": "result", "$ref": "Runtime.RemoteObject", "description": "Object wrapper for the evaluation result." },
                    { "name": "exceptionDetails", "$ref": "Runtime.ExceptionDetails", "optional": true, "description": "Exception details."}
                ],
                "description": "Evaluates expression on a given call frame."
            },
            {
                "name": "setVariableValue",
                "parameters": [
                    { "name": "scopeNumber", "type": "integer", "description": "0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually." },
                    { "name": "variableName", "type": "string", "description": "Variable name." },
                    { "name": "newValue", "$ref": "Runtime.CallArgument", "description": "New variable value." },
                    { "name": "callFrameId", "$ref": "CallFrameId", "description": "Id of callframe that holds variable." }
                ],
                "description": "Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually."
            },
            {
                "name": "setReturnValue",
                "parameters": [
                    { "name": "newValue", "$ref": "Runtime.CallArgument", "description": "New return value." }
                ],
                "experimental": true,
                "description": "Changes return value in top frame. Available only at return break position."
            },
            {
                "name": "setAsyncCallStackDepth",
                "parameters": [
                    { "name": "maxDepth", "type": "integer", "description": "Maximum depth of async call stacks. Setting to <code>0</code> will effectively disable collecting async call stacks (default)." }
                ],
                "description": "Enables or disables async call stacks tracking."
            },
            {
                "name": "setBlackboxPatterns",
                "parameters": [
                    { "name": "patterns", "type": "array", "items": { "type": "string" }, "description": "Array of regexps that will be used to check script url for blackbox state." }
                ],
                "experimental": true,
                "description": "Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful."
            },
            {
                "name": "setBlackboxedRanges",
                "parameters": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Id of the script." },
                    { "name": "positions", "type": "array", "items": { "$ref": "ScriptPosition" } }
                ],
                "experimental": true,
                "description": "Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted."
            }
        ],
        "events": [
            {
                "name": "scriptParsed",
                "parameters": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Identifier of the script parsed." },
                    { "name": "url", "type": "string", "description": "URL or name of the script parsed (if any)." },
                    { "name": "startLine", "type": "integer", "description": "Line offset of the script within the resource with given URL (for script tags)." },
                    { "name": "startColumn", "type": "integer", "description": "Column offset of the script within the resource with given URL." },
                    { "name": "endLine", "type": "integer", "description": "Last line of the script." },
                    { "name": "endColumn", "type": "integer", "description": "Length of the last line of the script." },
                    { "name": "executionContextId", "$ref": "Runtime.ExecutionContextId", "description": "Specifies script creation context." },
                    { "name": "hash", "type": "string", "description": "Content hash of the script."},
                    { "name": "executionContextAuxData", "type": "object", "optional": true, "description": "Embedder-specific auxiliary data." },
                    { "name": "isLiveEdit", "type": "boolean", "optional": true, "description": "True, if this script is generated as a result of the live edit operation.", "experimental": true },
                    { "name": "sourceMapURL", "type": "string", "optional": true, "description": "URL of source map associated with script (if any)." },
                    { "name": "hasSourceURL", "type": "boolean", "optional": true, "description": "True, if this script has sourceURL." },
                    { "name": "isModule", "type": "boolean", "optional": true, "description": "True, if this script is ES6 module." },
                    { "name": "length", "type": "integer", "optional": true, "description": "This script length." },
                    { "name": "stackTrace", "$ref": "Runtime.StackTrace", "optional": true, "description": "JavaScript top stack frame of where the script parsed event was triggered if available.", "experimental": true }
                ],
                "description": "Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger."
            },
            {
                "name": "scriptFailedToParse",
                "parameters": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "Identifier of the script parsed." },
                    { "name": "url", "type": "string", "description": "URL or name of the script parsed (if any)." },
                    { "name": "startLine", "type": "integer", "description": "Line offset of the script within the resource with given URL (for script tags)." },
                    { "name": "startColumn", "type": "integer", "description": "Column offset of the script within the resource with given URL." },
                    { "name": "endLine", "type": "integer", "description": "Last line of the script." },
                    { "name": "endColumn", "type": "integer", "description": "Length of the last line of the script." },
                    { "name": "executionContextId", "$ref": "Runtime.ExecutionContextId", "description": "Specifies script creation context." },
                    { "name": "hash", "type": "string", "description": "Content hash of the script."},
                    { "name": "executionContextAuxData", "type": "object", "optional": true, "description": "Embedder-specific auxiliary data." },
                    { "name": "sourceMapURL", "type": "string", "optional": true, "description": "URL of source map associated with script (if any)." },
                    { "name": "hasSourceURL", "type": "boolean", "optional": true, "description": "True, if this script has sourceURL." },
                    { "name": "isModule", "type": "boolean", "optional": true, "description": "True, if this script is ES6 module." },
                    { "name": "length", "type": "integer", "optional": true, "description": "This script length." },
                    { "name": "stackTrace", "$ref": "Runtime.StackTrace", "optional": true, "description": "JavaScript top stack frame of where the script parsed event was triggered if available.", "experimental": true }
                ],
                "description": "Fired when virtual machine fails to parse the script."
            },
            {
                "name": "breakpointResolved",
                "parameters": [
                    { "name": "breakpointId", "$ref": "BreakpointId", "description": "Breakpoint unique identifier." },
                    { "name": "location", "$ref": "Location", "description": "Actual breakpoint location." }
                ],
                "description": "Fired when breakpoint is resolved to an actual script and location."
            },
            {
                "name": "paused",
                "parameters": [
                    { "name": "callFrames", "type": "array", "items": { "$ref": "CallFrame" }, "description": "Call stack the virtual machine stopped on." },
                    { "name": "reason", "type": "string", "enum": [ "XHR", "DOM", "EventListener", "exception", "assert", "debugCommand", "promiseRejection", "OOM", "other", "ambiguous" ], "description": "Pause reason." },
                    { "name": "data", "type": "object", "optional": true, "description": "Object containing break-specific auxiliary properties." },
                    { "name": "hitBreakpoints", "type": "array", "optional": true, "items": { "type": "string" }, "description": "Hit breakpoints IDs" },
                    { "name": "asyncStackTrace", "$ref": "Runtime.StackTrace", "optional": true, "description": "Async stack trace, if any." },
                    { "name": "asyncStackTraceId", "$ref": "Runtime.StackTraceId", "optional": true, "experimental": true, "description": "Async stack trace, if any." },
                    { "name": "asyncCallStackTraceId", "$ref": "Runtime.StackTraceId", "optional": true, "experimental": true, "description": "Just scheduled async call will have this stack trace as parent stack during async execution. This field is available only after <code>Debugger.stepInto</code> call with <code>breakOnAsynCall</code> flag." }
                ],
                "description": "Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria."
            },
            {
                "name": "resumed",
                "description": "Fired when the virtual machine resumed execution."
            }
        ]
    },
    {
        "domain": "Console",
        "description": "This domain is deprecated - use Runtime or Log instead.",
        "dependencies": ["Runtime"],
        "deprecated": true,
        "types": [
            {
                "id": "ConsoleMessage",
                "type": "object",
                "description": "Console message.",
                "properties": [
                    { "name": "source", "type": "string", "enum": ["xml", "javascript", "network", "console-api", "storage", "appcache", "rendering", "security", "other", "deprecation", "worker"], "description": "Message source." },
                    { "name": "level", "type": "string", "enum": ["log", "warning", "error", "debug", "info"], "description": "Message severity." },
                    { "name": "text", "type": "string", "description": "Message text." },
                    { "name": "url", "type": "string", "optional": true, "description": "URL of the message origin." },
                    { "name": "line", "type": "integer", "optional": true, "description": "Line number in the resource that generated this message (1-based)." },
                    { "name": "column", "type": "integer", "optional": true, "description": "Column number in the resource that generated this message (1-based)." }
                ]
            }
        ],
        "commands": [
            {
                "name": "enable",
                "description": "Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification."
            },
            {
                "name": "disable",
                "description": "Disables console domain, prevents further console messages from being reported to the client."
            },
            {
                "name": "clearMessages",
                "description": "Does nothing."
            }
        ],
        "events": [
            {
                "name": "messageAdded",
                "parameters": [
                    { "name": "message", "$ref": "ConsoleMessage", "description": "Console message that has been added." }
                ],
                "description": "Issued when new console message is added."
            }
        ]
    },
    {
        "domain": "Profiler",
        "dependencies": ["Runtime", "Debugger"],
        "types": [
            {
                "id": "ProfileNode",
                "type": "object",
                "description": "Profile node. Holds callsite information, execution statistics and child nodes.",
                "properties": [
                    { "name": "id", "type": "integer", "description": "Unique id of the node." },
                    { "name": "callFrame", "$ref": "Runtime.CallFrame", "description": "Function location." },
                    { "name": "hitCount", "type": "integer", "optional": true, "description": "Number of samples where this node was on top of the call stack." },
                    { "name": "children", "type": "array", "items": { "type": "integer" }, "optional": true, "description": "Child node ids." },
                    { "name": "deoptReason", "type": "string", "optional": true, "description": "The reason of being not optimized. The function may be deoptimized or marked as don't optimize."},
                    { "name": "positionTicks", "type": "array", "items": { "$ref": "PositionTickInfo" }, "optional": true, "description": "An array of source position ticks." }
                ]
            },
            {
                "id": "Profile",
                "type": "object",
                "description": "Profile.",
                "properties": [
                    { "name": "nodes", "type": "array", "items": { "$ref": "ProfileNode" }, "description": "The list of profile nodes. First item is the root node." },
                    { "name": "startTime", "type": "number", "description": "Profiling start timestamp in microseconds." },
                    { "name": "endTime", "type": "number", "description": "Profiling end timestamp in microseconds." },
                    { "name": "samples", "optional": true, "type": "array", "items": { "type": "integer" }, "description": "Ids of samples top nodes." },
                    { "name": "timeDeltas", "optional": true, "type": "array", "items": { "type": "integer" }, "description": "Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime." }
                ]
            },
            {
                "id": "PositionTickInfo",
                "type": "object",
                "description": "Specifies a number of samples attributed to a certain source position.",
                "properties": [
                    { "name": "line", "type": "integer", "description": "Source line number (1-based)." },
                    { "name": "ticks", "type": "integer", "description": "Number of samples attributed to the source line." }
                ]
            },
            {   "id": "CoverageRange",
                "type": "object",
                "description": "Coverage data for a source range.",
                "properties": [
                    { "name": "startOffset", "type": "integer", "description": "JavaScript script source offset for the range start." },
                    { "name": "endOffset", "type": "integer", "description": "JavaScript script source offset for the range end." },
                    { "name": "count", "type": "integer", "description": "Collected execution count of the source range." }
                ]
            },
            {   "id": "FunctionCoverage",
                "type": "object",
                "description": "Coverage data for a JavaScript function.",
                "properties": [
                    { "name": "functionName", "type": "string", "description": "JavaScript function name." },
                    { "name": "ranges", "type": "array", "items": { "$ref": "CoverageRange" }, "description": "Source ranges inside the function with coverage data." },
                    { "name": "isBlockCoverage", "type": "boolean", "description": "Whether coverage data for this function has block granularity." }
                ]
            },
            {
                "id": "ScriptCoverage",
                "type": "object",
                "description": "Coverage data for a JavaScript script.",
                "properties": [
                    { "name": "scriptId", "$ref": "Runtime.ScriptId", "description": "JavaScript script id." },
                    { "name": "url", "type": "string", "description": "JavaScript script name or url." },
                    { "name": "functions", "type": "array", "items": { "$ref": "FunctionCoverage" }, "description": "Functions contained in the script that has coverage data." }
                ]
            }
        ],
        "commands": [
            {
                "name": "enable"
            },
            {
                "name": "disable"
            },
            {
                "name": "setSamplingInterval",
                "parameters": [
                    { "name": "interval", "type": "integer", "description": "New sampling interval in microseconds." }
                ],
                "description": "Changes CPU profiler sampling interval. Must be called before CPU profiles recording started."
            },
            {
                "name": "start"
            },
            {
                "name": "stop",
                "returns": [
                    { "name": "profile", "$ref": "Profile", "description": "Recorded profile." }
                ]
            },
            {
                "name": "startPreciseCoverage",
                "parameters": [
                    { "name": "callCount", "type": "boolean", "optional": true, "description": "Collect accurate call counts beyond simple 'covered' or 'not covered'." },
                    { "name": "detailed", "type": "boolean", "optional": true, "description": "Collect block-based coverage." }
                ],
                "description": "Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters."
            },
            {
                "name": "stopPreciseCoverage",
                "description": "Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code."
            },
            {
                "name": "takePreciseCoverage",
                "returns": [
                    { "name": "result", "type": "array", "items": { "$ref": "ScriptCoverage" }, "description": "Coverage data for the current isolate." }
                ],
                "description": "Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started."
            },
            {
                "name": "getBestEffortCoverage",
                "returns": [
                    { "name": "result", "type": "array", "items": { "$ref": "ScriptCoverage" }, "description": "Coverage data for the current isolate." }
                ],
                "description": "Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection."
            }
        ],
        "events": [
            {
                "name": "consoleProfileStarted",
                "parameters": [
                    { "name": "id", "type": "string" },
                    { "name": "location", "$ref": "Debugger.Location", "description": "Location of console.profile()." },
                    { "name": "title", "type": "string", "optional": true, "description": "Profile title passed as an argument to console.profile()." }
                ],
                "description": "Sent when new profile recording is started using console.profile() call."
            },
            {
                "name": "consoleProfileFinished",
                "parameters": [
                    { "name": "id", "type": "string" },
                    { "name": "location", "$ref": "Debugger.Location", "description": "Location of console.profileEnd()." },
                    { "name": "profile", "$ref": "Profile" },
                    { "name": "title", "type": "string", "optional": true, "description": "Profile title passed as an argument to console.profile()." }
                ]
            }
        ]
    },
    {
        "domain": "HeapProfiler",
        "dependencies": ["Runtime"],
        "experimental": true,
        "types": [
            {
                "id": "HeapSnapshotObjectId",
                "type": "string",
                "description": "Heap snapshot object id."
            },
            {
                "id": "SamplingHeapProfileNode",
                "type": "object",
                "description": "Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.",
                "properties": [
                    { "name": "callFrame", "$ref": "Runtime.CallFrame", "description": "Function location." },
                    { "name": "selfSize", "type": "number", "description": "Allocations size in bytes for the node excluding children." },
                    { "name": "children", "type": "array", "items": { "$ref": "SamplingHeapProfileNode" }, "description": "Child nodes." }
                ]
            },
            {
                "id": "SamplingHeapProfile",
                "type": "object",
                "description": "Profile.",
                "properties": [
                    { "name": "head", "$ref": "SamplingHeapProfileNode" }
                ]
            }
        ],
        "commands": [
            {
                "name": "enable"
            },
            {
                "name": "disable"
            },
            {
                "name": "startTrackingHeapObjects",
                "parameters": [
                    { "name": "trackAllocations", "type": "boolean", "optional": true }
                ]
            },
            {
                "name": "stopTrackingHeapObjects",
                "parameters": [
                    { "name": "reportProgress", "type": "boolean", "optional": true, "description": "If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped." }
                ]
            },
            {
                "name": "takeHeapSnapshot",
                "parameters": [
                    { "name": "reportProgress", "type": "boolean", "optional": true, "description": "If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken." }
                ]
            },
            {
                "name": "collectGarbage"
            },
            {
                "name": "getObjectByHeapObjectId",
                "parameters": [
                    { "name": "objectId", "$ref": "HeapSnapshotObjectId" },
                    { "name": "objectGroup", "type": "string", "optional": true, "description": "Symbolic group name that can be used to release multiple objects." }
                ],
                "returns": [
                    { "name": "result", "$ref": "Runtime.RemoteObject", "description": "Evaluation result." }
                ]
            },
            {
                "name": "addInspectedHeapObject",
                "parameters": [
                    { "name": "heapObjectId", "$ref": "HeapSnapshotObjectId", "description": "Heap snapshot object id to be accessible by means of $x command line API." }
                ],
                "description": "Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions)."
            },
            {
                "name": "getHeapObjectId",
                "parameters": [
                    { "name": "objectId", "$ref": "Runtime.RemoteObjectId", "description": "Identifier of the object to get heap object id for." }
                ],
                "returns": [
                    { "name": "heapSnapshotObjectId", "$ref": "HeapSnapshotObjectId", "description": "Id of the heap snapshot object corresponding to the passed remote object id." }
                ]
            },
            {
                "name": "startSampling",
                "parameters": [
                    { "name": "samplingInterval", "type": "number", "optional": true, "description": "Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes." }
                ]
            },
            {
                "name": "stopSampling",
                "returns": [
                    { "name": "profile", "$ref": "SamplingHeapProfile", "description": "Recorded sampling heap profile." }
                ]
            },
            {
                "name": "getSamplingProfile",
                "returns": [
                    { "name": "profile", "$ref": "SamplingHeapProfile", "description": "Return the sampling profile being collected." }
                ]
            }
        ],
        "events": [
            {
                "name": "addHeapSnapshotChunk",
                "parameters": [
                    { "name": "chunk", "type": "string" }
                ]
            },
            {
                "name": "resetProfiles"
            },
            {
                "name": "reportHeapSnapshotProgress",
                "parameters": [
                    { "name": "done", "type": "integer" },
                    { "name": "total", "type": "integer" },
                    { "name": "finished", "type": "boolean", "optional": true }
                ]
            },
            {
                "name": "lastSeenObjectId",
                "description": "If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.",
                "parameters": [
                    { "name": "lastSeenObjectId", "type": "integer" },
                    { "name": "timestamp", "type": "number" }
                ]
            },
            {
                "name": "heapStatsUpdate",
                "description": "If heap objects tracking has been started then backend may send update for one or more fragments",
                "parameters": [
                    { "name": "statsUpdate", "type": "array", "items": { "type": "integer" }, "description": "An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment."}
                ]
            }
        ]
    }]
}
                                                                                                             node-23.7.0/deps/v8/include/js_protocol.pdl                                                         0000664 0000000 0000000 00000205766 14746647661 0020546 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2017 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

version
  major 1
  minor 3

# This domain is deprecated - use Runtime or Log instead.
deprecated domain Console
  depends on Runtime

  # Console message.
  type ConsoleMessage extends object
    properties
      # Message source.
      enum source
        xml
        javascript
        network
        console-api
        storage
        appcache
        rendering
        security
        other
        deprecation
        worker
      # Message severity.
      enum level
        log
        warning
        error
        debug
        info
      # Message text.
      string text
      # URL of the message origin.
      optional string url
      # Line number in the resource that generated this message (1-based).
      optional integer line
      # Column number in the resource that generated this message (1-based).
      optional integer column

  # Does nothing.
  command clearMessages

  # Disables console domain, prevents further console messages from being reported to the client.
  command disable

  # Enables console domain, sends the messages collected so far to the client by means of the
  # `messageAdded` notification.
  command enable

  # Issued when new console message is added.
  event messageAdded
    parameters
      # Console message that has been added.
      ConsoleMessage message

# Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
# breakpoints, stepping through execution, exploring stack traces, etc.
domain Debugger
  depends on Runtime

  # Breakpoint identifier.
  type BreakpointId extends string

  # Call frame identifier.
  type CallFrameId extends string

  # Location in the source code.
  type Location extends object
    properties
      # Script identifier as reported in the `Debugger.scriptParsed`.
      Runtime.ScriptId scriptId
      # Line number in the script (0-based).
      integer lineNumber
      # Column number in the script (0-based).
      optional integer columnNumber

  # Location in the source code.
  experimental type ScriptPosition extends object
    properties
      integer lineNumber
      integer columnNumber

  # Location range within one script.
  experimental type LocationRange extends object
    properties
      Runtime.ScriptId scriptId
      ScriptPosition start
      ScriptPosition end

  # JavaScript call frame. Array of call frames form the call stack.
  type CallFrame extends object
    properties
      # Call frame identifier. This identifier is only valid while the virtual machine is paused.
      CallFrameId callFrameId
      # Name of the JavaScript function called on this call frame.
      string functionName
      # Location in the source code.
      optional Location functionLocation
      # Location in the source code.
      Location location
      # JavaScript script name or url.
      # Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously
      # sent `Debugger.scriptParsed` event.
      deprecated string url
      # Scope chain for this call frame.
      array of Scope scopeChain
      # `this` object for this call frame.
      Runtime.RemoteObject this
      # The value being returned, if the function is at return point.
      optional Runtime.RemoteObject returnValue
      # Valid only while the VM is paused and indicates whether this frame
      # can be restarted or not. Note that a `true` value here does not
      # guarantee that Debugger#restartFrame with this CallFrameId will be
      # successful, but it is very likely.
      experimental optional boolean canBeRestarted

  # Scope description.
  type Scope extends object
    properties
      # Scope type.
      enum type
        global
        local
        with
        closure
        catch
        block
        script
        eval
        module
        wasm-expression-stack
      # Object representing the scope. For `global` and `with` scopes it represents the actual
      # object; for the rest of the scopes, it is artificial transient object enumerating scope
      # variables as its properties.
      Runtime.RemoteObject object
      optional string name
      # Location in the source code where scope starts
      optional Location startLocation
      # Location in the source code where scope ends
      optional Location endLocation

  # Search match for resource.
  type SearchMatch extends object
    properties
      # Line number in resource content.
      number lineNumber
      # Line with match content.
      string lineContent

  type BreakLocation extends object
    properties
      # Script identifier as reported in the `Debugger.scriptParsed`.
      Runtime.ScriptId scriptId
      # Line number in the script (0-based).
      integer lineNumber
      # Column number in the script (0-based).
      optional integer columnNumber
      optional enum type
        debuggerStatement
        call
        return

  # Continues execution until specific location is reached.
  command continueToLocation
    parameters
      # Location to continue to.
      Location location
      optional enum targetCallFrames
        any
        current

  # Disables debugger for given page.
  command disable

  # Enables debugger for the given page. Clients should not assume that the debugging has been
  # enabled until the result for this command is received.
  command enable
    parameters
      # The maximum size in bytes of collected scripts (not referenced by other heap objects)
      # the debugger can hold. Puts no limit if parameter is omitted.
      experimental optional number maxScriptsCacheSize
    returns
      # Unique identifier of the debugger.
      experimental Runtime.UniqueDebuggerId debuggerId

  # Evaluates expression on a given call frame.
  command evaluateOnCallFrame
    parameters
      # Call frame identifier to evaluate on.
      CallFrameId callFrameId
      # Expression to evaluate.
      string expression
      # String object group name to put result into (allows rapid releasing resulting object handles
      # using `releaseObjectGroup`).
      optional string objectGroup
      # Specifies whether command line API should be available to the evaluated expression, defaults
      # to false.
      optional boolean includeCommandLineAPI
      # In silent mode exceptions thrown during evaluation are not reported and do not pause
      # execution. Overrides `setPauseOnException` state.
      optional boolean silent
      # Whether the result is expected to be a JSON object that should be sent by value.
      optional boolean returnByValue
      # Whether preview should be generated for the result.
      experimental optional boolean generatePreview
      # Whether to throw an exception if side effect cannot be ruled out during evaluation.
      optional boolean throwOnSideEffect
      # Terminate execution after timing out (number of milliseconds).
      experimental optional Runtime.TimeDelta timeout
    returns
      # Object wrapper for the evaluation result.
      Runtime.RemoteObject result
      # Exception details.
      optional Runtime.ExceptionDetails exceptionDetails

  # Returns possible locations for breakpoint. scriptId in start and end range locations should be
  # the same.
  command getPossibleBreakpoints
    parameters
      # Start of range to search possible breakpoint locations in.
      Location start
      # End of range to search possible breakpoint locations in (excluding). When not specified, end
      # of scripts is used as end of range.
      optional Location end
      # Only consider locations which are in the same (non-nested) function as start.
      optional boolean restrictToFunction
    returns
      # List of the possible breakpoint locations.
      array of BreakLocation locations

  # Returns source for the script with given id.
  command getScriptSource
    parameters
      # Id of the script to get source for.
      Runtime.ScriptId scriptId
    returns
      # Script source (empty in case of Wasm bytecode).
      string scriptSource
      # Wasm bytecode.
      optional binary bytecode

  experimental type WasmDisassemblyChunk extends object
    properties
      # The next chunk of disassembled lines.
      array of string lines
      # The bytecode offsets describing the start of each line.
      array of integer bytecodeOffsets

  experimental command disassembleWasmModule
    parameters
      # Id of the script to disassemble
      Runtime.ScriptId scriptId
    returns
      # For large modules, return a stream from which additional chunks of
      # disassembly can be read successively.
      optional string streamId
      # The total number of lines in the disassembly text.
      integer totalNumberOfLines
      # The offsets of all function bodies, in the format [start1, end1,
      # start2, end2, ...] where all ends are exclusive.
      array of integer functionBodyOffsets
      # The first chunk of disassembly.
      WasmDisassemblyChunk chunk

  # Disassemble the next chunk of lines for the module corresponding to the
  # stream. If disassembly is complete, this API will invalidate the streamId
  # and return an empty chunk. Any subsequent calls for the now invalid stream
  # will return errors.
  experimental command nextWasmDisassemblyChunk
    parameters
      string streamId
    returns
      # The next chunk of disassembly.
      WasmDisassemblyChunk chunk

  # This command is deprecated. Use getScriptSource instead.
  deprecated command getWasmBytecode
    parameters
      # Id of the Wasm script to get source for.
      Runtime.ScriptId scriptId
    returns
      # Script source.
      binary bytecode

  # Returns stack trace with given `stackTraceId`.
  experimental command getStackTrace
    parameters
      Runtime.StackTraceId stackTraceId
    returns
      Runtime.StackTrace stackTrace

  # Stops on the next JavaScript statement.
  command pause

  experimental deprecated command pauseOnAsyncCall
    parameters
      # Debugger will pause when async call with given stack trace is started.
      Runtime.StackTraceId parentStackTraceId

  # Removes JavaScript breakpoint.
  command removeBreakpoint
    parameters
      BreakpointId breakpointId

  # Restarts particular call frame from the beginning. The old, deprecated
  # behavior of `restartFrame` is to stay paused and allow further CDP commands
  # after a restart was scheduled. This can cause problems with restarting, so
  # we now continue execution immediatly after it has been scheduled until we
  # reach the beginning of the restarted frame.
  #
  # To stay back-wards compatible, `restartFrame` now expects a `mode`
  # parameter to be present. If the `mode` parameter is missing, `restartFrame`
  # errors out.
  #
  # The various return values are deprecated and `callFrames` is always empty.
  # Use the call frames from the `Debugger#paused` events instead, that fires
  # once V8 pauses at the beginning of the restarted function.
  command restartFrame
    parameters
      # Call frame identifier to evaluate on.
      CallFrameId callFrameId
      # The `mode` parameter must be present and set to 'StepInto', otherwise
      # `restartFrame` will error out.
      experimental optional enum mode
        # Pause at the beginning of the restarted function
        StepInto
    returns
      # New stack trace.
      deprecated array of CallFrame callFrames
      # Async stack trace, if any.
      deprecated optional Runtime.StackTrace asyncStackTrace
      # Async stack trace, if any.
      deprecated optional Runtime.StackTraceId asyncStackTraceId

  # Resumes JavaScript execution.
  command resume
    parameters
      # Set to true to terminate execution upon resuming execution. In contrast
      # to Runtime.terminateExecution, this will allows to execute further
      # JavaScript (i.e. via evaluation) until execution of the paused code
      # is actually resumed, at which point termination is triggered.
      # If execution is currently not paused, this parameter has no effect.
      optional boolean terminateOnResume

  # Searches for given string in script content.
  command searchInContent
    parameters
      # Id of the script to search in.
      Runtime.ScriptId scriptId
      # String to search for.
      string query
      # If true, search is case sensitive.
      optional boolean caseSensitive
      # If true, treats string parameter as regex.
      optional boolean isRegex
    returns
      # List of search matches.
      array of SearchMatch result

  # Enables or disables async call stacks tracking.
  command setAsyncCallStackDepth
    parameters
      # Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
      # call stacks (default).
      integer maxDepth

  # Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
  # scripts with url matching one of the patterns. VM will try to leave blackboxed script by
  # performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
  experimental command setBlackboxPatterns
    parameters
      # Array of regexps that will be used to check script url for blackbox state.
      array of string patterns

  # Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
  # scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
  # Positions array contains positions where blackbox state is changed. First interval isn't
  # blackboxed. Array should be sorted.
  experimental command setBlackboxedRanges
    parameters
      # Id of the script.
      Runtime.ScriptId scriptId
      array of ScriptPosition positions

  # Sets JavaScript breakpoint at a given location.
  command setBreakpoint
    parameters
      # Location to set breakpoint in.
      Location location
      # Expression to use as a breakpoint condition. When specified, debugger will only stop on the
      # breakpoint if this expression evaluates to true.
      optional string condition
    returns
      # Id of the created breakpoint for further reference.
      BreakpointId breakpointId
      # Location this breakpoint resolved into.
      Location actualLocation

  # Sets instrumentation breakpoint.
  command setInstrumentationBreakpoint
    parameters
      # Instrumentation name.
      enum instrumentation
        beforeScriptExecution
        beforeScriptWithSourceMapExecution
    returns
      # Id of the created breakpoint for further reference.
      BreakpointId breakpointId

  # Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
  # command is issued, all existing parsed scripts will have breakpoints resolved and returned in
  # `locations` property. Further matching script parsing will result in subsequent
  # `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
  command setBreakpointByUrl
    parameters
      # Line number to set breakpoint at.
      integer lineNumber
      # URL of the resources to set breakpoint on.
      optional string url
      # Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or
      # `urlRegex` must be specified.
      optional string urlRegex
      # Script hash of the resources to set breakpoint on.
      optional string scriptHash
      # Offset in the line to set breakpoint at.
      optional integer columnNumber
      # Expression to use as a breakpoint condition. When specified, debugger will only stop on the
      # breakpoint if this expression evaluates to true.
      optional string condition
    returns
      # Id of the created breakpoint for further reference.
      BreakpointId breakpointId
      # List of the locations this breakpoint resolved into upon addition.
      array of Location locations

  # Sets JavaScript breakpoint before each call to the given function.
  # If another function was created from the same source as a given one,
  # calling it will also trigger the breakpoint.
  experimental command setBreakpointOnFunctionCall
    parameters
      # Function object id.
      Runtime.RemoteObjectId objectId
      # Expression to use as a breakpoint condition. When specified, debugger will
      # stop on the breakpoint if this expression evaluates to true.
      optional string condition
    returns
      # Id of the created breakpoint for further reference.
      BreakpointId breakpointId

  # Activates / deactivates all breakpoints on the page.
  command setBreakpointsActive
    parameters
      # New value for breakpoints active state.
      boolean active

  # Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
  # or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.
  command setPauseOnExceptions
    parameters
      # Pause on exceptions mode.
      enum state
        none
        caught
        uncaught
        all

  # Changes return value in top frame. Available only at return break position.
  experimental command setReturnValue
    parameters
      # New return value.
      Runtime.CallArgument newValue

  # Edits JavaScript source live.
  #
  # In general, functions that are currently on the stack can not be edited with
  # a single exception: If the edited function is the top-most stack frame and
  # that is the only activation of that function on the stack. In this case
  # the live edit will be successful and a `Debugger.restartFrame` for the
  # top-most function is automatically triggered.
  command setScriptSource
    parameters
      # Id of the script to edit.
      Runtime.ScriptId scriptId
      # New content of the script.
      string scriptSource
      #  If true the change will not actually be applied. Dry run may be used to get result
      # description without actually modifying the code.
      optional boolean dryRun
      # If true, then `scriptSource` is allowed to change the function on top of the stack
      # as long as the top-most stack frame is the only activation of that function.
      experimental optional boolean allowTopFrameEditing
    returns
      # New stack trace in case editing has happened while VM was stopped.
      deprecated optional array of CallFrame callFrames
      # Whether current call stack  was modified after applying the changes.
      deprecated optional boolean stackChanged
      # Async stack trace, if any.
      deprecated optional Runtime.StackTrace asyncStackTrace
      # Async stack trace, if any.
      deprecated optional Runtime.StackTraceId asyncStackTraceId
      # Whether the operation was successful or not. Only `Ok` denotes a
      # successful live edit while the other enum variants denote why
      # the live edit failed.
      experimental enum status
        Ok
        CompileError
        BlockedByActiveGenerator
        BlockedByActiveFunction
        BlockedByTopLevelEsModuleChange
      # Exception details if any. Only present when `status` is `CompileError`.
      optional Runtime.ExceptionDetails exceptionDetails

  # Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
  command setSkipAllPauses
    parameters
      # New value for skip pauses state.
      boolean skip

  # Changes value of variable in a callframe. Object-based scopes are not supported and must be
  # mutated manually.
  command setVariableValue
    parameters
      # 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'
      # scope types are allowed. Other scopes could be manipulated manually.
      integer scopeNumber
      # Variable name.
      string variableName
      # New variable value.
      Runtime.CallArgument newValue
      # Id of callframe that holds variable.
      CallFrameId callFrameId

  # Steps into the function call.
  command stepInto
    parameters
      # Debugger will pause on the execution of the first async task which was scheduled
      # before next pause.
      experimental optional boolean breakOnAsyncCall
      # The skipList specifies location ranges that should be skipped on step into.
      experimental optional array of LocationRange skipList

  # Steps out of the function call.
  command stepOut

  # Steps over the statement.
  command stepOver
    parameters
      # The skipList specifies location ranges that should be skipped on step over.
      experimental optional array of LocationRange skipList

  # Fired when breakpoint is resolved to an actual script and location.
  event breakpointResolved
    parameters
      # Breakpoint unique identifier.
      BreakpointId breakpointId
      # Actual breakpoint location.
      Location location

  # Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
  event paused
    parameters
      # Call stack the virtual machine stopped on.
      array of CallFrame callFrames
      # Pause reason.
      enum reason
        ambiguous
        assert
        CSPViolation
        debugCommand
        DOM
        EventListener
        exception
        instrumentation
        OOM
        other
        promiseRejection
        XHR
        step
      # Object containing break-specific auxiliary properties.
      optional object data
      # Hit breakpoints IDs
      optional array of string hitBreakpoints
      # Async stack trace, if any.
      optional Runtime.StackTrace asyncStackTrace
      # Async stack trace, if any.
      experimental optional Runtime.StackTraceId asyncStackTraceId
      # Never present, will be removed.
      experimental deprecated optional Runtime.StackTraceId asyncCallStackTraceId

  # Fired when the virtual machine resumed execution.
  event resumed

  # Enum of possible script languages.
  type ScriptLanguage extends string
    enum
      JavaScript
      WebAssembly

  # Debug symbols available for a wasm script.
  type DebugSymbols extends object
    properties
      # Type of the debug symbols.
      enum type
        None
        SourceMap
        EmbeddedDWARF
        ExternalDWARF
      # URL of the external symbol source.
      optional string externalURL

  # Fired when virtual machine fails to parse the script.
  event scriptFailedToParse
    parameters
      # Identifier of the script parsed.
      Runtime.ScriptId scriptId
      # URL or name of the script parsed (if any).
      string url
      # Line offset of the script within the resource with given URL (for script tags).
      integer startLine
      # Column offset of the script within the resource with given URL.
      integer startColumn
      # Last line of the script.
      integer endLine
      # Length of the last line of the script.
      integer endColumn
      # Specifies script creation context.
      Runtime.ExecutionContextId executionContextId
      # Content hash of the script, SHA-256.
      string hash
      # Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
      optional object executionContextAuxData
      # URL of source map associated with script (if any).
      optional string sourceMapURL
      # True, if this script has sourceURL.
      optional boolean hasSourceURL
      # True, if this script is ES6 module.
      optional boolean isModule
      # This script length.
      optional integer length
      # JavaScript top stack frame of where the script parsed event was triggered if available.
      experimental optional Runtime.StackTrace stackTrace
      # If the scriptLanguage is WebAssembly, the code section offset in the module.
      experimental optional integer codeOffset
      # The language of the script.
      experimental optional Debugger.ScriptLanguage scriptLanguage
      # The name the embedder supplied for this script.
      experimental optional string embedderName

  # Fired when virtual machine parses script. This event is also fired for all known and uncollected
  # scripts upon enabling debugger.
  event scriptParsed
    parameters
      # Identifier of the script parsed.
      Runtime.ScriptId scriptId
      # URL or name of the script parsed (if any).
      string url
      # Line offset of the script within the resource with given URL (for script tags).
      integer startLine
      # Column offset of the script within the resource with given URL.
      integer startColumn
      # Last line of the script.
      integer endLine
      # Length of the last line of the script.
      integer endColumn
      # Specifies script creation context.
      Runtime.ExecutionContextId executionContextId
      # Content hash of the script, SHA-256.
      string hash
      # Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
      optional object executionContextAuxData
      # True, if this script is generated as a result of the live edit operation.
      experimental optional boolean isLiveEdit
      # URL of source map associated with script (if any).
      optional string sourceMapURL
      # True, if this script has sourceURL.
      optional boolean hasSourceURL
      # True, if this script is ES6 module.
      optional boolean isModule
      # This script length.
      optional integer length
      # JavaScript top stack frame of where the script parsed event was triggered if available.
      experimental optional Runtime.StackTrace stackTrace
      # If the scriptLanguage is WebAssembly, the code section offset in the module.
      experimental optional integer codeOffset
      # The language of the script.
      experimental optional Debugger.ScriptLanguage scriptLanguage
      # If the scriptLanguage is WebASsembly, the source of debug symbols for the module.
      experimental optional Debugger.DebugSymbols debugSymbols
      # The name the embedder supplied for this script.
      experimental optional string embedderName

experimental domain HeapProfiler
  depends on Runtime

  # Heap snapshot object id.
  type HeapSnapshotObjectId extends string

  # Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
  type SamplingHeapProfileNode extends object
    properties
      # Function location.
      Runtime.CallFrame callFrame
      # Allocations size in bytes for the node excluding children.
      number selfSize
      # Node id. Ids are unique across all profiles collected between startSampling and stopSampling.
      integer id
      # Child nodes.
      array of SamplingHeapProfileNode children

  # A single sample from a sampling profile.
  type SamplingHeapProfileSample extends object
    properties
      # Allocation size in bytes attributed to the sample.
      number size
      # Id of the corresponding profile tree node.
      integer nodeId
      # Time-ordered sample ordinal number. It is unique across all profiles retrieved
      # between startSampling and stopSampling.
      number ordinal

  # Sampling profile.
  type SamplingHeapProfile extends object
    properties
      SamplingHeapProfileNode head
      array of SamplingHeapProfileSample samples

  # Enables console to refer to the node with given id via $x (see Command Line API for more details
  # $x functions).
  command addInspectedHeapObject
    parameters
      # Heap snapshot object id to be accessible by means of $x command line API.
      HeapSnapshotObjectId heapObjectId

  command collectGarbage

  command disable

  command enable

  command getHeapObjectId
    parameters
      # Identifier of the object to get heap object id for.
      Runtime.RemoteObjectId objectId
    returns
      # Id of the heap snapshot object corresponding to the passed remote object id.
      HeapSnapshotObjectId heapSnapshotObjectId

  command getObjectByHeapObjectId
    parameters
      HeapSnapshotObjectId objectId
      # Symbolic group name that can be used to release multiple objects.
      optional string objectGroup
    returns
      # Evaluation result.
      Runtime.RemoteObject result

  command getSamplingProfile
    returns
      # Return the sampling profile being collected.
      SamplingHeapProfile profile

  command startSampling
    parameters
      # Average sample interval in bytes. Poisson distribution is used for the intervals. The
      # default value is 32768 bytes.
      optional number samplingInterval
      # By default, the sampling heap profiler reports only objects which are
      # still alive when the profile is returned via getSamplingProfile or
      # stopSampling, which is useful for determining what functions contribute
      # the most to steady-state memory usage. This flag instructs the sampling
      # heap profiler to also include information about objects discarded by
      # major GC, which will show which functions cause large temporary memory
      # usage or long GC pauses.
      optional boolean includeObjectsCollectedByMajorGC
      # By default, the sampling heap profiler reports only objects which are
      # still alive when the profile is returned via getSamplingProfile or
      # stopSampling, which is useful for determining what functions contribute
      # the most to steady-state memory usage. This flag instructs the sampling
      # heap profiler to also include information about objects discarded by
      # minor GC, which is useful when tuning a latency-sensitive application
      # for minimal GC activity.
      optional boolean includeObjectsCollectedByMinorGC

  command startTrackingHeapObjects
    parameters
      optional boolean trackAllocations

  command stopSampling
    returns
      # Recorded sampling heap profile.
      SamplingHeapProfile profile

  command stopTrackingHeapObjects
    parameters
      # If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken
      # when the tracking is stopped.
      optional boolean reportProgress
      # Deprecated in favor of `exposeInternals`.
      deprecated optional boolean treatGlobalObjectsAsRoots
      # If true, numerical values are included in the snapshot
      optional boolean captureNumericValue
      # If true, exposes internals of the snapshot.
      experimental optional boolean exposeInternals

  command takeHeapSnapshot
    parameters
      # If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
      optional boolean reportProgress
      # If true, a raw snapshot without artificial roots will be generated.
      # Deprecated in favor of `exposeInternals`.
      deprecated optional boolean treatGlobalObjectsAsRoots
      # If true, numerical values are included in the snapshot
      optional boolean captureNumericValue
      # If true, exposes internals of the snapshot.
      experimental optional boolean exposeInternals

  event addHeapSnapshotChunk
    parameters
      string chunk

  # If heap objects tracking has been started then backend may send update for one or more fragments
  event heapStatsUpdate
    parameters
      # An array of triplets. Each triplet describes a fragment. The first integer is the fragment
      # index, the second integer is a total count of objects for the fragment, the third integer is
      # a total size of the objects for the fragment.
      array of integer statsUpdate

  # If heap objects tracking has been started then backend regularly sends a current value for last
  # seen object id and corresponding timestamp. If the were changes in the heap since last event
  # then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
  event lastSeenObjectId
    parameters
      integer lastSeenObjectId
      number timestamp

  event reportHeapSnapshotProgress
    parameters
      integer done
      integer total
      optional boolean finished

  event resetProfiles

domain Profiler
  depends on Runtime
  depends on Debugger

  # Profile node. Holds callsite information, execution statistics and child nodes.
  type ProfileNode extends object
    properties
      # Unique id of the node.
      integer id
      # Function location.
      Runtime.CallFrame callFrame
      # Number of samples where this node was on top of the call stack.
      optional integer hitCount
      # Child node ids.
      optional array of integer children
      # The reason of being not optimized. The function may be deoptimized or marked as don't
      # optimize.
      optional string deoptReason
      # An array of source position ticks.
      optional array of PositionTickInfo positionTicks

  # Profile.
  type Profile extends object
    properties
      # The list of profile nodes. First item is the root node.
      array of ProfileNode nodes
      # Profiling start timestamp in microseconds.
      number startTime
      # Profiling end timestamp in microseconds.
      number endTime
      # Ids of samples top nodes.
      optional array of integer samples
      # Time intervals between adjacent samples in microseconds. The first delta is relative to the
      # profile startTime.
      optional array of integer timeDeltas

  # Specifies a number of samples attributed to a certain source position.
  type PositionTickInfo extends object
    properties
      # Source line number (1-based).
      integer line
      # Number of samples attributed to the source line.
      integer ticks

  # Coverage data for a source range.
  type CoverageRange extends object
    properties
      # JavaScript script source offset for the range start.
      integer startOffset
      # JavaScript script source offset for the range end.
      integer endOffset
      # Collected execution count of the source range.
      integer count

  # Coverage data for a JavaScript function.
  type FunctionCoverage extends object
    properties
      # JavaScript function name.
      string functionName
      # Source ranges inside the function with coverage data.
      array of CoverageRange ranges
      # Whether coverage data for this function has block granularity.
      boolean isBlockCoverage

  # Coverage data for a JavaScript script.
  type ScriptCoverage extends object
    properties
      # JavaScript script id.
      Runtime.ScriptId scriptId
      # JavaScript script name or url.
      string url
      # Functions contained in the script that has coverage data.
      array of FunctionCoverage functions

  command disable

  command enable

  # Collect coverage data for the current isolate. The coverage data may be incomplete due to
  # garbage collection.
  command getBestEffortCoverage
    returns
      # Coverage data for the current isolate.
      array of ScriptCoverage result

  # Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
  command setSamplingInterval
    parameters
      # New sampling interval in microseconds.
      integer interval

  command start

  # Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
  # coverage may be incomplete. Enabling prevents running optimized code and resets execution
  # counters.
  command startPreciseCoverage
    parameters
      # Collect accurate call counts beyond simple 'covered' or 'not covered'.
      optional boolean callCount
      # Collect block-based coverage.
      optional boolean detailed
      # Allow the backend to send updates on its own initiative
      optional boolean allowTriggeredUpdates
    returns
      # Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
      number timestamp

  command stop
    returns
      # Recorded profile.
      Profile profile

  # Disable precise code coverage. Disabling releases unnecessary execution count records and allows
  # executing optimized code.
  command stopPreciseCoverage

  # Collect coverage data for the current isolate, and resets execution counters. Precise code
  # coverage needs to have started.
  command takePreciseCoverage
    returns
      # Coverage data for the current isolate.
      array of ScriptCoverage result
      # Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
      number timestamp

  event consoleProfileFinished
    parameters
      string id
      # Location of console.profileEnd().
      Debugger.Location location
      Profile profile
      # Profile title passed as an argument to console.profile().
      optional string title

  # Sent when new profile recording is started using console.profile() call.
  event consoleProfileStarted
    parameters
      string id
      # Location of console.profile().
      Debugger.Location location
      # Profile title passed as an argument to console.profile().
      optional string title

  # Reports coverage delta since the last poll (either from an event like this, or from
  # `takePreciseCoverage` for the current isolate. May only be sent if precise code
  # coverage has been started. This event can be trigged by the embedder to, for example,
  # trigger collection of coverage data immediately at a certain point in time.
  experimental event preciseCoverageDeltaUpdate
    parameters
      # Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
      number timestamp
      # Identifier for distinguishing coverage events.
      string occasion
      # Coverage data for the current isolate.
      array of ScriptCoverage result

# Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
# Evaluation results are returned as mirror object that expose object type, string representation
# and unique identifier that can be used for further object reference. Original objects are
# maintained in memory unless they are either explicitly released or are released along with the
# other objects in their object group.
domain Runtime

  # Unique script identifier.
  type ScriptId extends string

  # Represents options for serialization. Overrides `generatePreview` and `returnByValue`.
  type SerializationOptions extends object
    properties
      enum serialization
        # Whether the result should be deep-serialized. The result is put into
        # `deepSerializedValue` and `ObjectId` is provided.
        deep
        # Whether the result is expected to be a JSON object which should be sent by value.
        # The result is put either into `value` or into `unserializableValue`. Synonym of
        # `returnByValue: true`. Overrides `returnByValue`.
        json
        # Only remote object id is put in the result. Same bahaviour as if no
        # `serializationOptions`, `generatePreview` nor `returnByValue` are provided.
        idOnly

      # Deep serialization depth. Default is full depth. Respected only in `deep` serialization mode.
      optional integer maxDepth

      # Embedder-specific parameters. For example if connected to V8 in Chrome these control DOM
      # serialization via `maxNodeDepth: integer` and `includeShadowTree: "none" | "open" | "all"`.
      # Values can be only of type string or integer.
      optional object additionalParameters

  # Represents deep serialized value.
  type DeepSerializedValue extends object
    properties
      enum type
        undefined
        null
        string
        number
        boolean
        bigint
        regexp
        date
        symbol
        array
        object
        function
        map
        set
        weakmap
        weakset
        error
        proxy
        promise
        typedarray
        arraybuffer
        node
        window
        generator
      optional any value
      optional string objectId
      # Set if value reference met more then once during serialization. In such
      # case, value is provided only to one of the serialized values. Unique
      # per value in the scope of one CDP call.
      optional integer weakLocalObjectReference

  # Unique object identifier.
  type RemoteObjectId extends string

  # Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,
  # `-Infinity`, and bigint literals.
  type UnserializableValue extends string

  # Mirror object referencing original JavaScript object.
  type RemoteObject extends object
    properties
      # Object type.
      enum type
        object
        function
        undefined
        string
        number
        boolean
        symbol
        bigint
      # Object subtype hint. Specified for `object` type values only.
      # NOTE: If you change anything here, make sure to also update
      # `subtype` in `ObjectPreview` and `PropertyPreview` below.
      optional enum subtype
        array
        null
        node
        regexp
        date
        map
        set
        weakmap
        weakset
        iterator
        generator
        error
        proxy
        promise
        typedarray
        arraybuffer
        dataview
        webassemblymemory
        wasmvalue
      # Object class (constructor) name. Specified for `object` type values only.
      optional string className
      # Remote object value in case of primitive values or JSON values (if it was requested).
      optional any value
      # Primitive value which can not be JSON-stringified does not have `value`, but gets this
      # property.
      optional UnserializableValue unserializableValue
      # String representation of the object.
      optional string description
      # Deep serialized value.
      experimental optional DeepSerializedValue deepSerializedValue
      # Unique object identifier (for non-primitive values).
      optional RemoteObjectId objectId
      # Preview containing abbreviated property values. Specified for `object` type values only.
      experimental optional ObjectPreview preview
      experimental optional CustomPreview customPreview

  experimental type CustomPreview extends object
    properties
      # The JSON-stringified result of formatter.header(object, config) call.
      # It contains json ML array that represents RemoteObject.
      string header
      # If formatter returns true as a result of formatter.hasBody call then bodyGetterId will
      # contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.
      # The result value is json ML array.
      optional RemoteObjectId bodyGetterId

  # Object containing abbreviated remote object value.
  experimental type ObjectPreview extends object
    properties
      # Object type.
      enum type
        object
        function
        undefined
        string
        number
        boolean
        symbol
        bigint
      # Object subtype hint. Specified for `object` type values only.
      optional enum subtype
        array
        null
        node
        regexp
        date
        map
        set
        weakmap
        weakset
        iterator
        generator
        error
        proxy
        promise
        typedarray
        arraybuffer
        dataview
        webassemblymemory
        wasmvalue
      # String representation of the object.
      optional string description
      # True iff some of the properties or entries of the original object did not fit.
      boolean overflow
      # List of the properties.
      array of PropertyPreview properties
      # List of the entries. Specified for `map` and `set` subtype values only.
      optional array of EntryPreview entries

  experimental type PropertyPreview extends object
    properties
      # Property name.
      string name
      # Object type. Accessor means that the property itself is an accessor property.
      enum type
        object
        function
        undefined
        string
        number
        boolean
        symbol
        accessor
        bigint
      # User-friendly property value string.
      optional string value
      # Nested value preview.
      optional ObjectPreview valuePreview
      # Object subtype hint. Specified for `object` type values only.
      optional enum subtype
        array
        null
        node
        regexp
        date
        map
        set
        weakmap
        weakset
        iterator
        generator
        error
        proxy
        promise
        typedarray
        arraybuffer
        dataview
        webassemblymemory
        wasmvalue

  experimental type EntryPreview extends object
    properties
      # Preview of the key. Specified for map-like collection entries.
      optional ObjectPreview key
      # Preview of the value.
      ObjectPreview value

  # Object property descriptor.
  type PropertyDescriptor extends object
    properties
      # Property name or symbol description.
      string name
      # The value associated with the property.
      optional RemoteObject value
      # True if the value associated with the property may be changed (data descriptors only).
      optional boolean writable
      # A function which serves as a getter for the property, or `undefined` if there is no getter
      # (accessor descriptors only).
      optional RemoteObject get
      # A function which serves as a setter for the property, or `undefined` if there is no setter
      # (accessor descriptors only).
      optional RemoteObject set
      # True if the type of this property descriptor may be changed and if the property may be
      # deleted from the corresponding object.
      boolean configurable
      # True if this property shows up during enumeration of the properties on the corresponding
      # object.
      boolean enumerable
      # True if the result was thrown during the evaluation.
      optional boolean wasThrown
      # True if the property is owned for the object.
      optional boolean isOwn
      # Property symbol object, if the property is of the `symbol` type.
      optional RemoteObject symbol

  # Object internal property descriptor. This property isn't normally visible in JavaScript code.
  type InternalPropertyDescriptor extends object
    properties
      # Conventional property name.
      string name
      # The value associated with the property.
      optional RemoteObject value

  # Object private field descriptor.
  experimental type PrivatePropertyDescriptor extends object
    properties
      # Private property name.
      string name
      # The value associated with the private property.
      optional RemoteObject value
      # A function which serves as a getter for the private property,
      # or `undefined` if there is no getter (accessor descriptors only).
      optional RemoteObject get
      # A function which serves as a setter for the private property,
      # or `undefined` if there is no setter (accessor descriptors only).
      optional RemoteObject set

  # Represents function call argument. Either remote object id `objectId`, primitive `value`,
  # unserializable primitive value or neither of (for undefined) them should be specified.
  type CallArgument extends object
    properties
      # Primitive value or serializable javascript object.
      optional any value
      # Primitive value which can not be JSON-stringified.
      optional UnserializableValue unserializableValue
      # Remote object handle.
      optional RemoteObjectId objectId

  # Id of an execution context.
  type ExecutionContextId extends integer

  # Description of an isolated world.
  type ExecutionContextDescription extends object
    properties
      # Unique id of the execution context. It can be used to specify in which execution context
      # script evaluation should be performed.
      ExecutionContextId id
      # Execution context origin.
      string origin
      # Human readable name describing given context.
      string name
      # A system-unique execution context identifier. Unlike the id, this is unique across
      # multiple processes, so can be reliably used to identify specific context while backend
      # performs a cross-process navigation.
      experimental string uniqueId
      # Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
      optional object auxData

  # Detailed information about exception (or error) that was thrown during script compilation or
  # execution.
  type ExceptionDetails extends object
    properties
      # Exception id.
      integer exceptionId
      # Exception text, which should be used together with exception object when available.
      string text
      # Line number of the exception location (0-based).
      integer lineNumber
      # Column number of the exception location (0-based).
      integer columnNumber
      # Script ID of the exception location.
      optional ScriptId scriptId
      # URL of the exception location, to be used when the script was not reported.
      optional string url
      # JavaScript stack trace if available.
      optional StackTrace stackTrace
      # Exception object if available.
      optional RemoteObject exception
      # Identifier of the context where exception happened.
      optional ExecutionContextId executionContextId
      # Dictionary with entries of meta data that the client associated
      # with this exception, such as information about associated network
      # requests, etc.
      experimental optional object exceptionMetaData

  # Number of milliseconds since epoch.
  type Timestamp extends number

  # Number of milliseconds.
  type TimeDelta extends number

  # Stack entry for runtime errors and assertions.
  type CallFrame extends object
    properties
      # JavaScript function name.
      string functionName
      # JavaScript script id.
      ScriptId scriptId
      # JavaScript script name or url.
      string url
      # JavaScript script line number (0-based).
      integer lineNumber
      # JavaScript script column number (0-based).
      integer columnNumber

  # Call frames for assertions or error messages.
  type StackTrace extends object
    properties
      # String label of this stack trace. For async traces this may be a name of the function that
      # initiated the async call.
      optional string description
      # JavaScript function name.
      array of CallFrame callFrames
      # Asynchronous JavaScript stack trace that preceded this stack, if available.
      optional StackTrace parent
      # Asynchronous JavaScript stack trace that preceded this stack, if available.
      experimental optional StackTraceId parentId

  # Unique identifier of current debugger.
  experimental type UniqueDebuggerId extends string

  # If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This
  # allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.
  experimental type StackTraceId extends object
    properties
      string id
      optional UniqueDebuggerId debuggerId

  # Add handler to promise with given promise object id.
  command awaitPromise
    parameters
      # Identifier of the promise.
      RemoteObjectId promiseObjectId
      # Whether the result is expected to be a JSON object that should be sent by value.
      optional boolean returnByValue
      # Whether preview should be generated for the result.
      optional boolean generatePreview
    returns
      # Promise result. Will contain rejected value if promise was rejected.
      RemoteObject result
      # Exception details if stack strace is available.
      optional ExceptionDetails exceptionDetails

  # Calls function with given declaration on the given object. Object group of the result is
  # inherited from the target object.
  command callFunctionOn
    parameters
      # Declaration of the function to call.
      string functionDeclaration
      # Identifier of the object to call function on. Either objectId or executionContextId should
      # be specified.
      optional RemoteObjectId objectId
      # Call arguments. All call arguments must belong to the same JavaScript world as the target
      # object.
      optional array of CallArgument arguments
      # In silent mode exceptions thrown during evaluation are not reported and do not pause
      # execution. Overrides `setPauseOnException` state.
      optional boolean silent
      # Whether the result is expected to be a JSON object which should be sent by value.
      # Can be overriden by `serializationOptions`.
      optional boolean returnByValue
      # Whether preview should be generated for the result.
      experimental optional boolean generatePreview
      # Whether execution should be treated as initiated by user in the UI.
      optional boolean userGesture
      # Whether execution should `await` for resulting value and return once awaited promise is
      # resolved.
      optional boolean awaitPromise
      # Specifies execution context which global object will be used to call function on. Either
      # executionContextId or objectId should be specified.
      optional ExecutionContextId executionContextId
      # Symbolic group name that can be used to release multiple objects. If objectGroup is not
      # specified and objectId is, objectGroup will be inherited from object.
      optional string objectGroup
      # Whether to throw an exception if side effect cannot be ruled out during evaluation.
      experimental optional boolean throwOnSideEffect
      # An alternative way to specify the execution context to call function on.
      # Compared to contextId that may be reused across processes, this is guaranteed to be
      # system-unique, so it can be used to prevent accidental function call
      # in context different than intended (e.g. as a result of navigation across process
      # boundaries).
      # This is mutually exclusive with `executionContextId`.
      experimental optional string uniqueContextId
      # Specifies the result serialization. If provided, overrides
      # `generatePreview` and `returnByValue`.
      experimental optional SerializationOptions serializationOptions

    returns
      # Call result.
      RemoteObject result
      # Exception details.
      optional ExceptionDetails exceptionDetails

  # Compiles expression.
  command compileScript
    parameters
      # Expression to compile.
      string expression
      # Source url to be set for the script.
      string sourceURL
      # Specifies whether the compiled script should be persisted.
      boolean persistScript
      # Specifies in which execution context to perform script run. If the parameter is omitted the
      # evaluation will be performed in the context of the inspected page.
      optional ExecutionContextId executionContextId
    returns
      # Id of the script.
      optional ScriptId scriptId
      # Exception details.
      optional ExceptionDetails exceptionDetails

  # Disables reporting of execution contexts creation.
  command disable

  # Discards collected exceptions and console API calls.
  command discardConsoleEntries

  # Enables reporting of execution contexts creation by means of `executionContextCreated` event.
  # When the reporting gets enabled the event will be sent immediately for each existing execution
  # context.
  command enable

  # Evaluates expression on global object.
  command evaluate
    parameters
      # Expression to evaluate.
      string expression
      # Symbolic group name that can be used to release multiple objects.
      optional string objectGroup
      # Determines whether Command Line API should be available during the evaluation.
      optional boolean includeCommandLineAPI
      # In silent mode exceptions thrown during evaluation are not reported and do not pause
      # execution. Overrides `setPauseOnException` state.
      optional boolean silent
      # Specifies in which execution context to perform evaluation. If the parameter is omitted the
      # evaluation will be performed in the context of the inspected page.
      # This is mutually exclusive with `uniqueContextId`, which offers an
      # alternative way to identify the execution context that is more reliable
      # in a multi-process environment.
      optional ExecutionContextId contextId
      # Whether the result is expected to be a JSON object that should be sent by value.
      optional boolean returnByValue
      # Whether preview should be generated for the result.
      experimental optional boolean generatePreview
      # Whether execution should be treated as initiated by user in the UI.
      optional boolean userGesture
      # Whether execution should `await` for resulting value and return once awaited promise is
      # resolved.
      optional boolean awaitPromise
      # Whether to throw an exception if side effect cannot be ruled out during evaluation.
      # This implies `disableBreaks` below.
      experimental optional boolean throwOnSideEffect
      # Terminate execution after timing out (number of milliseconds).
      experimental optional TimeDelta timeout
      # Disable breakpoints during execution.
      experimental optional boolean disableBreaks
      # Setting this flag to true enables `let` re-declaration and top-level `await`.
      # Note that `let` variables can only be re-declared if they originate from
      # `replMode` themselves.
      experimental optional boolean replMode
      # The Content Security Policy (CSP) for the target might block 'unsafe-eval'
      # which includes eval(), Function(), setTimeout() and setInterval()
      # when called with non-callable arguments. This flag bypasses CSP for this
      # evaluation and allows unsafe-eval. Defaults to true.
      experimental optional boolean allowUnsafeEvalBlockedByCSP
      # An alternative way to specify the execution context to evaluate in.
      # Compared to contextId that may be reused across processes, this is guaranteed to be
      # system-unique, so it can be used to prevent accidental evaluation of the expression
      # in context different than intended (e.g. as a result of navigation across process
      # boundaries).
      # This is mutually exclusive with `contextId`.
      experimental optional string uniqueContextId
      # Specifies the result serialization. If provided, overrides
      # `generatePreview` and `returnByValue`.
      experimental optional SerializationOptions serializationOptions
    returns
      # Evaluation result.
      RemoteObject result
      # Exception details.
      optional ExceptionDetails exceptionDetails

  # Returns the isolate id.
  experimental command getIsolateId
    returns
      # The isolate id.
      string id

  # Returns the JavaScript heap usage.
  # It is the total usage of the corresponding isolate not scoped to a particular Runtime.
  experimental command getHeapUsage
    returns
      # Used heap size in bytes.
      number usedSize
      # Allocated heap size in bytes.
      number totalSize

  # Returns properties of a given object. Object group of the result is inherited from the target
  # object.
  command getProperties
    parameters
      # Identifier of the object to return properties for.
      RemoteObjectId objectId
      # If true, returns properties belonging only to the element itself, not to its prototype
      # chain.
      optional boolean ownProperties
      # If true, returns accessor properties (with getter/setter) only; internal properties are not
      # returned either.
      experimental optional boolean accessorPropertiesOnly
      # Whether preview should be generated for the results.
      experimental optional boolean generatePreview
      # If true, returns non-indexed properties only.
      experimental optional boolean nonIndexedPropertiesOnly
    returns
      # Object properties.
      array of PropertyDescriptor result
      # Internal object properties (only of the element itself).
      optional array of InternalPropertyDescriptor internalProperties
      # Object private properties.
      experimental optional array of PrivatePropertyDescriptor privateProperties
      # Exception details.
      optional ExceptionDetails exceptionDetails

  # Returns all let, const and class variables from global scope.
  command globalLexicalScopeNames
    parameters
      # Specifies in which execution context to lookup global scope variables.
      optional ExecutionContextId executionContextId
    returns
      array of string names

  command queryObjects
    parameters
      # Identifier of the prototype to return objects for.
      RemoteObjectId prototypeObjectId
      # Symbolic group name that can be used to release the results.
      optional string objectGroup
    returns
      # Array with objects.
      RemoteObject objects

  # Releases remote object with given id.
  command releaseObject
    parameters
      # Identifier of the object to release.
      RemoteObjectId objectId

  # Releases all remote objects that belong to a given group.
  command releaseObjectGroup
    parameters
      # Symbolic object group name.
      string objectGroup

  # Tells inspected instance to run if it was waiting for debugger to attach.
  command runIfWaitingForDebugger

  # Runs script with given id in a given context.
  command runScript
    parameters
      # Id of the script to run.
      ScriptId scriptId
      # Specifies in which execution context to perform script run. If the parameter is omitted the
      # evaluation will be performed in the context of the inspected page.
      optional ExecutionContextId executionContextId
      # Symbolic group name that can be used to release multiple objects.
      optional string objectGroup
      # In silent mode exceptions thrown during evaluation are not reported and do not pause
      # execution. Overrides `setPauseOnException` state.
      optional boolean silent
      # Determines whether Command Line API should be available during the evaluation.
      optional boolean includeCommandLineAPI
      # Whether the result is expected to be a JSON object which should be sent by value.
      optional boolean returnByValue
      # Whether preview should be generated for the result.
      optional boolean generatePreview
      # Whether execution should `await` for resulting value and return once awaited promise is
      # resolved.
      optional boolean awaitPromise
    returns
      # Run result.
      RemoteObject result
      # Exception details.
      optional ExceptionDetails exceptionDetails

  # Enables or disables async call stacks tracking.
  command setAsyncCallStackDepth
    redirect Debugger
    parameters
      # Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
      # call stacks (default).
      integer maxDepth

  experimental command setCustomObjectFormatterEnabled
    parameters
      boolean enabled

  experimental command setMaxCallStackSizeToCapture
    parameters
      integer size

  # Terminate current or next JavaScript execution.
  # Will cancel the termination when the outer-most script execution ends.
  experimental command terminateExecution

  # If executionContextId is empty, adds binding with the given name on the
  # global objects of all inspected contexts, including those created later,
  # bindings survive reloads.
  # Binding function takes exactly one argument, this argument should be string,
  # in case of any other input, function throws an exception.
  # Each binding function call produces Runtime.bindingCalled notification.
  command addBinding
    parameters
      string name
      # If specified, the binding would only be exposed to the specified
      # execution context. If omitted and `executionContextName` is not set,
      # the binding is exposed to all execution contexts of the target.
      # This parameter is mutually exclusive with `executionContextName`.
      # Deprecated in favor of `executionContextName` due to an unclear use case
      # and bugs in implementation (crbug.com/1169639). `executionContextId` will be
      # removed in the future.
      experimental deprecated optional ExecutionContextId executionContextId
      # If specified, the binding is exposed to the executionContext with
      # matching name, even for contexts created after the binding is added.
      # See also `ExecutionContext.name` and `worldName` parameter to
      # `Page.addScriptToEvaluateOnNewDocument`.
      # This parameter is mutually exclusive with `executionContextId`.
      optional string executionContextName

  # This method does not remove binding function from global object but
  # unsubscribes current runtime agent from Runtime.bindingCalled notifications.
  command removeBinding
    parameters
      string name

  # This method tries to lookup and populate exception details for a
  # JavaScript Error object.
  # Note that the stackTrace portion of the resulting exceptionDetails will
  # only be populated if the Runtime domain was enabled at the time when the
  # Error was thrown.
  experimental command getExceptionDetails
    parameters
      # The error object for which to resolve the exception details.
      RemoteObjectId errorObjectId
    returns
      optional ExceptionDetails exceptionDetails

  # Notification is issued every time when binding is called.
  experimental event bindingCalled
    parameters
      string name
      string payload
      # Identifier of the context where the call was made.
      ExecutionContextId executionContextId

  # Issued when console API was called.
  event consoleAPICalled
    parameters
      # Type of the call.
      enum type
        log
        debug
        info
        error
        warning
        dir
        dirxml
        table
        trace
        clear
        startGroup
        startGroupCollapsed
        endGroup
        assert
        profile
        profileEnd
        count
        timeEnd
      # Call arguments.
      array of RemoteObject args
      # Identifier of the context where the call was made.
      ExecutionContextId executionContextId
      # Call timestamp.
      Timestamp timestamp
      # Stack trace captured when the call was made. The async stack chain is automatically reported for
      # the following call types: `assert`, `error`, `trace`, `warning`. For other types the async call
      # chain can be retrieved using `Debugger.getStackTrace` and `stackTrace.parentId` field.
      optional StackTrace stackTrace
      # Console context descriptor for calls on non-default console context (not console.*):
      # 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call
      # on named context.
      experimental optional string context

  # Issued when unhandled exception was revoked.
  event exceptionRevoked
    parameters
      # Reason describing why exception was revoked.
      string reason
      # The id of revoked exception, as reported in `exceptionThrown`.
      integer exceptionId

  # Issued when exception was thrown and unhandled.
  event exceptionThrown
    parameters
      # Timestamp of the exception.
      Timestamp timestamp
      ExceptionDetails exceptionDetails

  # Issued when new execution context is created.
  event executionContextCreated
    parameters
      # A newly created execution context.
      ExecutionContextDescription context

  # Issued when execution context is destroyed.
  event executionContextDestroyed
    parameters
      # Id of the destroyed context
      deprecated ExecutionContextId executionContextId
      # Unique Id of the destroyed context
      experimental string executionContextUniqueId

  # Issued when all executionContexts were cleared in browser
  event executionContextsCleared

  # Issued when object should be inspected (for example, as a result of inspect() command line API
  # call).
  event inspectRequested
    parameters
      RemoteObject object
      object hints
      # Identifier of the context where the call was made.
      experimental optional ExecutionContextId executionContextId

# This domain is deprecated.
deprecated domain Schema

  # Description of the protocol domain.
  type Domain extends object
    properties
      # Domain name.
      string name
      # Domain version.
      string version

  # Returns supported domains.
  command getDomains
    returns
      # List of supported domains.
      array of Domain domains
          node-23.7.0/deps/v8/include/libplatform/                                                            0000775 0000000 0000000 00000000000 14746647661 0020003 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/include/libplatform/DEPS                                                        0000664 0000000 0000000 00000000225 14746647661 0020460 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        include_rules = [
  "+libplatform/libplatform-export.h",
]

specific_include_rules = {
  "libplatform\.h": [
    "+libplatform/v8-tracing.h",
  ],
}
                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/include/libplatform/libplatform-export.h                                        0000664 0000000 0000000 00000001444 14746647661 0024011 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_LIBPLATFORM_LIBPLATFORM_EXPORT_H_
#define V8_LIBPLATFORM_LIBPLATFORM_EXPORT_H_

#if defined(_WIN32)

#ifdef BUILDING_V8_PLATFORM_SHARED
#define V8_PLATFORM_EXPORT __declspec(dllexport)
#elif USING_V8_PLATFORM_SHARED
#define V8_PLATFORM_EXPORT __declspec(dllimport)
#else
#define V8_PLATFORM_EXPORT
#endif  // BUILDING_V8_PLATFORM_SHARED

#else  // defined(_WIN32)

// Setup for Linux shared library export.
#ifdef BUILDING_V8_PLATFORM_SHARED
#define V8_PLATFORM_EXPORT __attribute__((visibility("default")))
#else
#define V8_PLATFORM_EXPORT
#endif

#endif  // defined(_WIN32)

#endif  // V8_LIBPLATFORM_LIBPLATFORM_EXPORT_H_
                                                                                                                                                                                                                            node-23.7.0/deps/v8/include/libplatform/libplatform.h                                               0000664 0000000 0000000 00000010632 14746647661 0022471 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_LIBPLATFORM_LIBPLATFORM_H_
#define V8_LIBPLATFORM_LIBPLATFORM_H_

#include <memory>

#include "libplatform/libplatform-export.h"
#include "libplatform/v8-tracing.h"
#include "v8-platform.h"  // NOLINT(build/include_directory)
#include "v8config.h"     // NOLINT(build/include_directory)

namespace v8 {
namespace platform {

enum class IdleTaskSupport { kDisabled, kEnabled };
enum class InProcessStackDumping { kDisabled, kEnabled };

enum class MessageLoopBehavior : bool {
  kDoNotWait = false,
  kWaitForWork = true
};

enum class PriorityMode : bool { kDontApply, kApply };

/**
 * Returns a new instance of the default v8::Platform implementation.
 *
 * The caller will take ownership of the returned pointer. |thread_pool_size|
 * is the number of worker threads to allocate for background jobs. If a value
 * of zero is passed, a suitable default based on the current number of
 * processors online will be chosen.
 * If |idle_task_support| is enabled then the platform will accept idle
 * tasks (IdleTasksEnabled will return true) and will rely on the embedder
 * calling v8::platform::RunIdleTasks to process the idle tasks.
 * If |tracing_controller| is nullptr, the default platform will create a
 * v8::platform::TracingController instance and use it.
 * If |priority_mode| is PriorityMode::kApply, the default platform will use
 * multiple task queues executed by threads different system-level priorities
 * (where available) to schedule tasks.
 */
V8_PLATFORM_EXPORT std::unique_ptr<v8::Platform> NewDefaultPlatform(
    int thread_pool_size = 0,
    IdleTaskSupport idle_task_support = IdleTaskSupport::kDisabled,
    InProcessStackDumping in_process_stack_dumping =
        InProcessStackDumping::kDisabled,
    std::unique_ptr<v8::TracingController> tracing_controller = {},
    PriorityMode priority_mode = PriorityMode::kDontApply);

/**
 * The same as NewDefaultPlatform but disables the worker thread pool.
 * It must be used with the --single-threaded V8 flag.
 */
V8_PLATFORM_EXPORT std::unique_ptr<v8::Platform>
NewSingleThreadedDefaultPlatform(
    IdleTaskSupport idle_task_support = IdleTaskSupport::kDisabled,
    InProcessStackDumping in_process_stack_dumping =
        InProcessStackDumping::kDisabled,
    std::unique_ptr<v8::TracingController> tracing_controller = {});

/**
 * Returns a new instance of the default v8::JobHandle implementation.
 *
 * The job will be executed by spawning up to |num_worker_threads| many worker
 * threads on the provided |platform| with the given |priority|.
 */
V8_PLATFORM_EXPORT std::unique_ptr<v8::JobHandle> NewDefaultJobHandle(
    v8::Platform* platform, v8::TaskPriority priority,
    std::unique_ptr<v8::JobTask> job_task, size_t num_worker_threads);

/**
 * Pumps the message loop for the given isolate.
 *
 * The caller has to make sure that this is called from the right thread.
 * Returns true if a task was executed, and false otherwise. If the call to
 * PumpMessageLoop is nested within another call to PumpMessageLoop, only
 * nestable tasks may run. Otherwise, any task may run. Unless requested through
 * the |behavior| parameter, this call does not block if no task is pending. The
 * |platform| has to be created using |NewDefaultPlatform|.
 */
V8_PLATFORM_EXPORT bool PumpMessageLoop(
    v8::Platform* platform, v8::Isolate* isolate,
    MessageLoopBehavior behavior = MessageLoopBehavior::kDoNotWait);

/**
 * Runs pending idle tasks for at most |idle_time_in_seconds| seconds.
 *
 * The caller has to make sure that this is called from the right thread.
 * This call does not block if no task is pending. The |platform| has to be
 * created using |NewDefaultPlatform|.
 */
V8_PLATFORM_EXPORT void RunIdleTasks(v8::Platform* platform,
                                     v8::Isolate* isolate,
                                     double idle_time_in_seconds);

/**
 * Notifies the given platform about the Isolate getting deleted soon. Has to be
 * called for all Isolates which are deleted - unless we're shutting down the
 * platform.
 *
 * The |platform| has to be created using |NewDefaultPlatform|.
 *
 */
V8_PLATFORM_EXPORT void NotifyIsolateShutdown(v8::Platform* platform,
                                              Isolate* isolate);

}  // namespace platform
}  // namespace v8

#endif  // V8_LIBPLATFORM_LIBPLATFORM_H_
                                                                                                      node-23.7.0/deps/v8/include/libplatform/v8-tracing.h                                                0000664 0000000 0000000 00000025501 14746647661 0022141 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_LIBPLATFORM_V8_TRACING_H_
#define V8_LIBPLATFORM_V8_TRACING_H_

#include <atomic>
#include <fstream>
#include <memory>
#include <unordered_set>
#include <vector>

#include "libplatform/libplatform-export.h"
#include "v8-platform.h"  // NOLINT(build/include_directory)

namespace perfetto {
namespace trace_processor {
class TraceProcessorStorage;
}
class TracingSession;
}

namespace v8 {

namespace base {
class Mutex;
}  // namespace base

namespace platform {
namespace tracing {

class TraceEventListener;

const int kTraceMaxNumArgs = 2;

class V8_PLATFORM_EXPORT TraceObject {
 public:
  union ArgValue {
    uint64_t as_uint;
    int64_t as_int;
    double as_double;
    const void* as_pointer;
    const char* as_string;
  };

  TraceObject() = default;
  ~TraceObject();
  void Initialize(
      char phase, const uint8_t* category_enabled_flag, const char* name,
      const char* scope, uint64_t id, uint64_t bind_id, int num_args,
      const char** arg_names, const uint8_t* arg_types,
      const uint64_t* arg_values,
      std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables,
      unsigned int flags, int64_t timestamp, int64_t cpu_timestamp);
  void UpdateDuration(int64_t timestamp, int64_t cpu_timestamp);
  void InitializeForTesting(
      char phase, const uint8_t* category_enabled_flag, const char* name,
      const char* scope, uint64_t id, uint64_t bind_id, int num_args,
      const char** arg_names, const uint8_t* arg_types,
      const uint64_t* arg_values,
      std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables,
      unsigned int flags, int pid, int tid, int64_t ts, int64_t tts,
      uint64_t duration, uint64_t cpu_duration);

  int pid() const { return pid_; }
  int tid() const { return tid_; }
  char phase() const { return phase_; }
  const uint8_t* category_enabled_flag() const {
    return category_enabled_flag_;
  }
  const char* name() const { return name_; }
  const char* scope() const { return scope_; }
  uint64_t id() const { return id_; }
  uint64_t bind_id() const { return bind_id_; }
  int num_args() const { return num_args_; }
  const char** arg_names() { return arg_names_; }
  uint8_t* arg_types() { return arg_types_; }
  ArgValue* arg_values() { return arg_values_; }
  std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables() {
    return arg_convertables_;
  }
  unsigned int flags() const { return flags_; }
  int64_t ts() { return ts_; }
  int64_t tts() { return tts_; }
  uint64_t duration() { return duration_; }
  uint64_t cpu_duration() { return cpu_duration_; }

 private:
  int pid_;
  int tid_;
  char phase_;
  const char* name_;
  const char* scope_;
  const uint8_t* category_enabled_flag_;
  uint64_t id_;
  uint64_t bind_id_;
  int num_args_ = 0;
  const char* arg_names_[kTraceMaxNumArgs];
  uint8_t arg_types_[kTraceMaxNumArgs];
  ArgValue arg_values_[kTraceMaxNumArgs];
  std::unique_ptr<v8::ConvertableToTraceFormat>
      arg_convertables_[kTraceMaxNumArgs];
  char* parameter_copy_storage_ = nullptr;
  unsigned int flags_;
  int64_t ts_;
  int64_t tts_;
  uint64_t duration_;
  uint64_t cpu_duration_;

  // Disallow copy and assign
  TraceObject(const TraceObject&) = delete;
  void operator=(const TraceObject&) = delete;
};

class V8_PLATFORM_EXPORT TraceWriter {
 public:
  TraceWriter() = default;
  virtual ~TraceWriter() = default;
  virtual void AppendTraceEvent(TraceObject* trace_event) = 0;
  virtual void Flush() = 0;

  static TraceWriter* CreateJSONTraceWriter(std::ostream& stream);
  static TraceWriter* CreateJSONTraceWriter(std::ostream& stream,
                                            const std::string& tag);

  static TraceWriter* CreateSystemInstrumentationTraceWriter();

 private:
  // Disallow copy and assign
  TraceWriter(const TraceWriter&) = delete;
  void operator=(const TraceWriter&) = delete;
};

class V8_PLATFORM_EXPORT TraceBufferChunk {
 public:
  explicit TraceBufferChunk(uint32_t seq);

  void Reset(uint32_t new_seq);
  bool IsFull() const { return next_free_ == kChunkSize; }
  TraceObject* AddTraceEvent(size_t* event_index);
  TraceObject* GetEventAt(size_t index) { return &chunk_[index]; }

  uint32_t seq() const { return seq_; }
  size_t size() const { return next_free_; }

  static const size_t kChunkSize = 64;

 private:
  size_t next_free_ = 0;
  TraceObject chunk_[kChunkSize];
  uint32_t seq_;

  // Disallow copy and assign
  TraceBufferChunk(const TraceBufferChunk&) = delete;
  void operator=(const TraceBufferChunk&) = delete;
};

class V8_PLATFORM_EXPORT TraceBuffer {
 public:
  TraceBuffer() = default;
  virtual ~TraceBuffer() = default;

  virtual TraceObject* AddTraceEvent(uint64_t* handle) = 0;
  virtual TraceObject* GetEventByHandle(uint64_t handle) = 0;
  virtual bool Flush() = 0;

  static const size_t kRingBufferChunks = 1024;

  static TraceBuffer* CreateTraceBufferRingBuffer(size_t max_chunks,
                                                  TraceWriter* trace_writer);

 private:
  // Disallow copy and assign
  TraceBuffer(const TraceBuffer&) = delete;
  void operator=(const TraceBuffer&) = delete;
};

// Options determines how the trace buffer stores data.
enum TraceRecordMode {
  // Record until the trace buffer is full.
  RECORD_UNTIL_FULL,

  // Record until the user ends the trace. The trace buffer is a fixed size
  // and we use it as a ring buffer during recording.
  RECORD_CONTINUOUSLY,

  // Record until the trace buffer is full, but with a huge buffer size.
  RECORD_AS_MUCH_AS_POSSIBLE,

  // Echo to console. Events are discarded.
  ECHO_TO_CONSOLE,
};

class V8_PLATFORM_EXPORT TraceConfig {
 public:
  typedef std::vector<std::string> StringList;

  static TraceConfig* CreateDefaultTraceConfig();

  TraceConfig() : enable_systrace_(false), enable_argument_filter_(false) {}
  TraceRecordMode GetTraceRecordMode() const { return record_mode_; }
  const StringList& GetEnabledCategories() const {
    return included_categories_;
  }
  bool IsSystraceEnabled() const { return enable_systrace_; }
  bool IsArgumentFilterEnabled() const { return enable_argument_filter_; }

  void SetTraceRecordMode(TraceRecordMode mode) { record_mode_ = mode; }
  void EnableSystrace() { enable_systrace_ = true; }
  void EnableArgumentFilter() { enable_argument_filter_ = true; }

  void AddIncludedCategory(const char* included_category);

  bool IsCategoryGroupEnabled(const char* category_group) const;

 private:
  TraceRecordMode record_mode_;
  bool enable_systrace_ : 1;
  bool enable_argument_filter_ : 1;
  StringList included_categories_;

  // Disallow copy and assign
  TraceConfig(const TraceConfig&) = delete;
  void operator=(const TraceConfig&) = delete;
};

#if defined(_MSC_VER)
#define V8_PLATFORM_NON_EXPORTED_BASE(code) \
  __pragma(warning(suppress : 4275)) code
#else
#define V8_PLATFORM_NON_EXPORTED_BASE(code) code
#endif  // defined(_MSC_VER)

class V8_PLATFORM_EXPORT TracingController
    : public V8_PLATFORM_NON_EXPORTED_BASE(v8::TracingController) {
 public:
  TracingController();
  ~TracingController() override;

#if defined(V8_USE_PERFETTO)
  // Must be called before StartTracing() if V8_USE_PERFETTO is true. Provides
  // the output stream for the JSON trace data.
  void InitializeForPerfetto(std::ostream* output_stream);
  // Provide an optional listener for testing that will receive trace events.
  // Must be called before StartTracing().
  void SetTraceEventListenerForTesting(TraceEventListener* listener);
#else   // defined(V8_USE_PERFETTO)
  // The pointer returned from GetCategoryGroupEnabled() points to a value with
  // zero or more of the following bits. Used in this class only. The
  // TRACE_EVENT macros should only use the value as a bool. These values must
  // be in sync with macro values in TraceEvent.h in Blink.
  enum CategoryGroupEnabledFlags {
    // Category group enabled for the recording mode.
    ENABLED_FOR_RECORDING = 1 << 0,
    // Category group enabled by SetEventCallbackEnabled().
    ENABLED_FOR_EVENT_CALLBACK = 1 << 2,
    // Category group enabled to export events to ETW.
    ENABLED_FOR_ETW_EXPORT = 1 << 3
  };

  // Takes ownership of |trace_buffer|.
  void Initialize(TraceBuffer* trace_buffer);

  // v8::TracingController implementation.
  const uint8_t* GetCategoryGroupEnabled(const char* category_group) override;
  uint64_t AddTraceEvent(
      char phase, const uint8_t* category_enabled_flag, const char* name,
      const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,
      const char** arg_names, const uint8_t* arg_types,
      const uint64_t* arg_values,
      std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables,
      unsigned int flags) override;
  uint64_t AddTraceEventWithTimestamp(
      char phase, const uint8_t* category_enabled_flag, const char* name,
      const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,
      const char** arg_names, const uint8_t* arg_types,
      const uint64_t* arg_values,
      std::unique_ptr<v8::ConvertableToTraceFormat>* arg_convertables,
      unsigned int flags, int64_t timestamp) override;
  void UpdateTraceEventDuration(const uint8_t* category_enabled_flag,
                                const char* name, uint64_t handle) override;

  static const char* GetCategoryGroupName(const uint8_t* category_enabled_flag);

  void AddTraceStateObserver(
      v8::TracingController::TraceStateObserver* observer) override;
  void RemoveTraceStateObserver(
      v8::TracingController::TraceStateObserver* observer) override;
#endif  // !defined(V8_USE_PERFETTO)

  void StartTracing(TraceConfig* trace_config);
  void StopTracing();

 protected:
#if !defined(V8_USE_PERFETTO)
  virtual int64_t CurrentTimestampMicroseconds();
  virtual int64_t CurrentCpuTimestampMicroseconds();
#endif  // !defined(V8_USE_PERFETTO)

 private:
#if !defined(V8_USE_PERFETTO)
  void UpdateCategoryGroupEnabledFlag(size_t category_index);
  void UpdateCategoryGroupEnabledFlags();
#endif  // !defined(V8_USE_PERFETTO)

  std::unique_ptr<base::Mutex> mutex_;
  std::unique_ptr<TraceConfig> trace_config_;
  std::atomic_bool recording_{false};

#if defined(V8_USE_PERFETTO)
  std::ostream* output_stream_ = nullptr;
  std::unique_ptr<perfetto::trace_processor::TraceProcessorStorage>
      trace_processor_;
  TraceEventListener* listener_for_testing_ = nullptr;
  std::unique_ptr<perfetto::TracingSession> tracing_session_;
#else   // !defined(V8_USE_PERFETTO)
  std::unordered_set<v8::TracingController::TraceStateObserver*> observers_;
  std::unique_ptr<TraceBuffer> trace_buffer_;
#endif  // !defined(V8_USE_PERFETTO)

  // Disallow copy and assign
  TracingController(const TracingController&) = delete;
  void operator=(const TracingController&) = delete;
};

#undef V8_PLATFORM_NON_EXPORTED_BASE

}  // namespace tracing
}  // namespace platform
}  // namespace v8

#endif  // V8_LIBPLATFORM_V8_TRACING_H_
                                                                                                                                                                                               node-23.7.0/deps/v8/include/v8-array-buffer.h                                                       0000664 0000000 0000000 00000045022 14746647661 0020564 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_V8_ARRAY_BUFFER_H_
#define INCLUDE_V8_ARRAY_BUFFER_H_

#include <stddef.h>

#include <memory>

#include "v8-local-handle.h"  // NOLINT(build/include_directory)
#include "v8-object.h"        // NOLINT(build/include_directory)
#include "v8config.h"         // NOLINT(build/include_directory)

namespace v8 {

class SharedArrayBuffer;

#ifndef V8_ARRAY_BUFFER_INTERNAL_FIELD_COUNT
// Defined using gn arg `v8_array_buffer_internal_field_count`.
#define V8_ARRAY_BUFFER_INTERNAL_FIELD_COUNT 2
#endif

enum class ArrayBufferCreationMode { kInternalized, kExternalized };
enum class BackingStoreInitializationMode { kZeroInitialized, kUninitialized };

/**
 * A wrapper around the backing store (i.e. the raw memory) of an array buffer.
 * See a document linked in http://crbug.com/v8/9908 for more information.
 *
 * The allocation and destruction of backing stores is generally managed by
 * V8. Clients should always use standard C++ memory ownership types (i.e.
 * std::unique_ptr and std::shared_ptr) to manage lifetimes of backing stores
 * properly, since V8 internal objects may alias backing stores.
 *
 * This object does not keep the underlying |ArrayBuffer::Allocator| alive by
 * default. Use Isolate::CreateParams::array_buffer_allocator_shared when
 * creating the Isolate to make it hold a reference to the allocator itself.
 */
class V8_EXPORT BackingStore : public v8::internal::BackingStoreBase {
 public:
  ~BackingStore();

  /**
   * Return a pointer to the beginning of the memory block for this backing
   * store. The pointer is only valid as long as this backing store object
   * lives.
   */
  void* Data() const;

  /**
   * The length (in bytes) of this backing store.
   */
  size_t ByteLength() const;

  /**
   * The maximum length (in bytes) that this backing store may grow to.
   *
   * If this backing store was created for a resizable ArrayBuffer or a growable
   * SharedArrayBuffer, it is >= ByteLength(). Otherwise it is ==
   * ByteLength().
   */
  size_t MaxByteLength() const;

  /**
   * Indicates whether the backing store was created for an ArrayBuffer or
   * a SharedArrayBuffer.
   */
  bool IsShared() const;

  /**
   * Indicates whether the backing store was created for a resizable ArrayBuffer
   * or a growable SharedArrayBuffer, and thus may be resized by user JavaScript
   * code.
   */
  bool IsResizableByUserJavaScript() const;

  /**
   * Prevent implicit instantiation of operator delete with size_t argument.
   * The size_t argument would be incorrect because ptr points to the
   * internal BackingStore object.
   */
  void operator delete(void* ptr) { ::operator delete(ptr); }

  /**
   * Wrapper around ArrayBuffer::Allocator::Reallocate that preserves IsShared.
   * Assumes that the backing_store was allocated by the ArrayBuffer allocator
   * of the given isolate.
   */
  V8_DEPRECATED(
      "Reallocate is unsafe, please do not use. Please allocate a new "
      "BackingStore and copy instead.")
  static std::unique_ptr<BackingStore> Reallocate(
      v8::Isolate* isolate, std::unique_ptr<BackingStore> backing_store,
      size_t byte_length);

  /**
   * This callback is used only if the memory block for a BackingStore cannot be
   * allocated with an ArrayBuffer::Allocator. In such cases the destructor of
   * the BackingStore invokes the callback to free the memory block.
   */
  using DeleterCallback = void (*)(void* data, size_t length,
                                   void* deleter_data);

  /**
   * If the memory block of a BackingStore is static or is managed manually,
   * then this empty deleter along with nullptr deleter_data can be passed to
   * ArrayBuffer::NewBackingStore to indicate that.
   *
   * The manually managed case should be used with caution and only when it
   * is guaranteed that the memory block freeing happens after detaching its
   * ArrayBuffer.
   */
  static void EmptyDeleter(void* data, size_t length, void* deleter_data);

 private:
  /**
   * See [Shared]ArrayBuffer::GetBackingStore and
   * [Shared]ArrayBuffer::NewBackingStore.
   */
  BackingStore();
};

#if !defined(V8_IMMINENT_DEPRECATION_WARNINGS)
// Use v8::BackingStore::DeleterCallback instead.
using BackingStoreDeleterCallback = void (*)(void* data, size_t length,
                                             void* deleter_data);

#endif

/**
 * An instance of the built-in ArrayBuffer constructor (ES6 draft 15.13.5).
 */
class V8_EXPORT ArrayBuffer : public Object {
 public:
  /**
   * A thread-safe allocator that V8 uses to allocate |ArrayBuffer|'s memory.
   * The allocator is a global V8 setting. It has to be set via
   * Isolate::CreateParams.
   *
   * Memory allocated through this allocator by V8 is accounted for as external
   * memory by V8. Note that V8 keeps track of the memory for all internalized
   * |ArrayBuffer|s. Responsibility for tracking external memory (using
   * Isolate::AdjustAmountOfExternalAllocatedMemory) is handed over to the
   * embedder upon externalization and taken over upon internalization (creating
   * an internalized buffer from an existing buffer).
   *
   * Note that it is unsafe to call back into V8 from any of the allocator
   * functions.
   */
  class V8_EXPORT Allocator {
   public:
    virtual ~Allocator() = default;

    /**
     * Allocate |length| bytes. Return nullptr if allocation is not successful.
     * Memory should be initialized to zeroes.
     */
    virtual void* Allocate(size_t length) = 0;

    /**
     * Allocate |length| bytes. Return nullptr if allocation is not successful.
     * Memory does not have to be initialized.
     */
    virtual void* AllocateUninitialized(size_t length) = 0;

    /**
     * Free the memory block of size |length|, pointed to by |data|.
     * That memory is guaranteed to be previously allocated by |Allocate|.
     */
    virtual void Free(void* data, size_t length) = 0;

    /**
     * Reallocate the memory block of size |old_length| to a memory block of
     * size |new_length| by expanding, contracting, or copying the existing
     * memory block. If |new_length| > |old_length|, then the new part of
     * the memory must be initialized to zeros. Return nullptr if reallocation
     * is not successful.
     *
     * The caller guarantees that the memory block was previously allocated
     * using Allocate or AllocateUninitialized.
     *
     * The default implementation allocates a new block and copies data.
     */
    V8_DEPRECATED(
        "Reallocate is unsafe, please do not use. Please allocate new memory "
        "and copy instead.")
    virtual void* Reallocate(void* data, size_t old_length, size_t new_length);

    /**
     * ArrayBuffer allocation mode. kNormal is a malloc/free style allocation,
     * while kReservation is for larger allocations with the ability to set
     * access permissions.
     */
    enum class AllocationMode { kNormal, kReservation };

    /**
     * Convenience allocator.
     *
     * When the sandbox is enabled, this allocator will allocate its backing
     * memory inside the sandbox. Otherwise, it will rely on malloc/free.
     *
     * Caller takes ownership, i.e. the returned object needs to be freed using
     * |delete allocator| once it is no longer in use.
     */
    static Allocator* NewDefaultAllocator();
  };

  /**
   * Data length in bytes.
   */
  size_t ByteLength() const;

  /**
   * Maximum length in bytes.
   */
  size_t MaxByteLength() const;

  /**
   * Create a new ArrayBuffer. Allocate |byte_length| bytes, which are either
   * zero-initialized or uninitialized. Allocated memory will be owned by a
   * created ArrayBuffer and will be deallocated when it is garbage-collected,
   * unless the object is externalized.
   */
  static Local<ArrayBuffer> New(
      Isolate* isolate, size_t byte_length,
      BackingStoreInitializationMode initialization_mode =
          BackingStoreInitializationMode::kZeroInitialized);

  /**
   * Create a new ArrayBuffer with an existing backing store.
   * The created array keeps a reference to the backing store until the array
   * is garbage collected. Note that the IsExternal bit does not affect this
   * reference from the array to the backing store.
   *
   * In future IsExternal bit will be removed. Until then the bit is set as
   * follows. If the backing store does not own the underlying buffer, then
   * the array is created in externalized state. Otherwise, the array is created
   * in internalized state. In the latter case the array can be transitioned
   * to the externalized state using Externalize(backing_store).
   */
  static Local<ArrayBuffer> New(Isolate* isolate,
                                std::shared_ptr<BackingStore> backing_store);

  /**
   * Returns a new standalone BackingStore that is allocated using the array
   * buffer allocator of the isolate. The allocation can either be zero
   * intialized, or uninitialized. The result can be later passed to
   * ArrayBuffer::New.
   *
   * If the allocator returns nullptr, then the function may cause GCs in the
   * given isolate and re-try the allocation. If GCs do not help, then the
   * function will crash with an out-of-memory error.
   */
  static std::unique_ptr<BackingStore> NewBackingStore(
      Isolate* isolate, size_t byte_length,
      BackingStoreInitializationMode initialization_mode =
          BackingStoreInitializationMode::kZeroInitialized);
  /**
   * Returns a new standalone BackingStore that takes over the ownership of
   * the given buffer. The destructor of the BackingStore invokes the given
   * deleter callback.
   *
   * The result can be later passed to ArrayBuffer::New. The raw pointer
   * to the buffer must not be passed again to any V8 API function.
   */
  static std::unique_ptr<BackingStore> NewBackingStore(
      void* data, size_t byte_length, v8::BackingStore::DeleterCallback deleter,
      void* deleter_data);

  /**
   * Returns a new resizable standalone BackingStore that is allocated using the
   * array buffer allocator of the isolate. The result can be later passed to
   * ArrayBuffer::New.
   *
   * |byte_length| must be <= |max_byte_length|.
   *
   * This function is usable without an isolate. Unlike |NewBackingStore| calls
   * with an isolate, GCs cannot be triggered, and there are no
   * retries. Allocation failure will cause the function to crash with an
   * out-of-memory error.
   */
  static std::unique_ptr<BackingStore> NewResizableBackingStore(
      size_t byte_length, size_t max_byte_length);

  /**
   * Returns true if this ArrayBuffer may be detached.
   */
  bool IsDetachable() const;

  /**
   * Returns true if this ArrayBuffer has been detached.
   */
  bool WasDetached() const;

  /**
   * Detaches this ArrayBuffer and all its views (typed arrays).
   * Detaching sets the byte length of the buffer and all typed arrays to zero,
   * preventing JavaScript from ever accessing underlying backing store.
   * ArrayBuffer should have been externalized and must be detachable.
   */
  V8_DEPRECATED(
      "Use the version which takes a key parameter (passing a null handle is "
      "ok).")
  void Detach();

  /**
   * Detaches this ArrayBuffer and all its views (typed arrays).
   * Detaching sets the byte length of the buffer and all typed arrays to zero,
   * preventing JavaScript from ever accessing underlying backing store.
   * ArrayBuffer should have been externalized and must be detachable. Returns
   * Nothing if the key didn't pass the [[ArrayBufferDetachKey]] check,
   * Just(true) otherwise.
   */
  V8_WARN_UNUSED_RESULT Maybe<bool> Detach(v8::Local<v8::Value> key);

  /**
   * Sets the ArrayBufferDetachKey.
   */
  void SetDetachKey(v8::Local<v8::Value> key);

  /**
   * Get a shared pointer to the backing store of this array buffer. This
   * pointer coordinates the lifetime management of the internal storage
   * with any live ArrayBuffers on the heap, even across isolates. The embedder
   * should not attempt to manage lifetime of the storage through other means.
   *
   * The returned shared pointer will not be empty, even if the ArrayBuffer has
   * been detached. Use |WasDetached| to tell if it has been detached instead.
   */
  std::shared_ptr<BackingStore> GetBackingStore();

  /**
   * More efficient shortcut for
   * GetBackingStore()->IsResizableByUserJavaScript().
   */
  bool IsResizableByUserJavaScript() const;

  /**
   * More efficient shortcut for GetBackingStore()->Data(). The returned pointer
   * is valid as long as the ArrayBuffer is alive.
   */
  void* Data() const;

  V8_INLINE static ArrayBuffer* Cast(Value* value) {
#ifdef V8_ENABLE_CHECKS
    CheckCast(value);
#endif
    return static_cast<ArrayBuffer*>(value);
  }

  static constexpr int kInternalFieldCount =
      V8_ARRAY_BUFFER_INTERNAL_FIELD_COUNT;
  static constexpr int kEmbedderFieldCount = kInternalFieldCount;

 private:
  ArrayBuffer();
  static void CheckCast(Value* obj);
};

#ifndef V8_ARRAY_BUFFER_VIEW_INTERNAL_FIELD_COUNT
// Defined using gn arg `v8_array_buffer_view_internal_field_count`.
#define V8_ARRAY_BUFFER_VIEW_INTERNAL_FIELD_COUNT 2
#endif

/**
 * A base class for an instance of one of "views" over ArrayBuffer,
 * including TypedArrays and DataView (ES6 draft 15.13).
 */
class V8_EXPORT ArrayBufferView : public Object {
 public:
  /**
   * Returns underlying ArrayBuffer.
   */
  Local<ArrayBuffer> Buffer();
  /**
   * Byte offset in |Buffer|.
   */
  size_t ByteOffset();
  /**
   * Size of a view in bytes.
   */
  size_t ByteLength();

  /**
   * Copy the contents of the ArrayBufferView's buffer to an embedder defined
   * memory without additional overhead that calling ArrayBufferView::Buffer
   * might incur.
   *
   * Will write at most min(|byte_length|, ByteLength) bytes starting at
   * ByteOffset of the underlying buffer to the memory starting at |dest|.
   * Returns the number of bytes actually written.
   */
  size_t CopyContents(void* dest, size_t byte_length);

  /**
   * Returns true if ArrayBufferView's backing ArrayBuffer has already been
   * allocated.
   */
  bool HasBuffer() const;

  V8_INLINE static ArrayBufferView* Cast(Value* value) {
#ifdef V8_ENABLE_CHECKS
    CheckCast(value);
#endif
    return static_cast<ArrayBufferView*>(value);
  }

  static constexpr int kInternalFieldCount =
      V8_ARRAY_BUFFER_VIEW_INTERNAL_FIELD_COUNT;
  static const int kEmbedderFieldCount = kInternalFieldCount;

 private:
  ArrayBufferView();
  static void CheckCast(Value* obj);
};

/**
 * An instance of DataView constructor (ES6 draft 15.13.7).
 */
class V8_EXPORT DataView : public ArrayBufferView {
 public:
  static Local<DataView> New(Local<ArrayBuffer> array_buffer,
                             size_t byte_offset, size_t length);
  static Local<DataView> New(Local<SharedArrayBuffer> shared_array_buffer,
                             size_t byte_offset, size_t length);
  V8_INLINE static DataView* Cast(Value* value) {
#ifdef V8_ENABLE_CHECKS
    CheckCast(value);
#endif
    return static_cast<DataView*>(value);
  }

 private:
  DataView();
  static void CheckCast(Value* obj);
};

/**
 * An instance of the built-in SharedArrayBuffer constructor.
 */
class V8_EXPORT SharedArrayBuffer : public Object {
 public:
  /**
   * Data length in bytes.
   */
  size_t ByteLength() const;

  /**
   * Maximum length in bytes.
   */
  size_t MaxByteLength() const;

  /**
   * Create a new SharedArrayBuffer. Allocate |byte_length| bytes, which are
   * either zero-initialized or uninitialized. Allocated memory will be owned by
   * a created SharedArrayBuffer and will be deallocated when it is
   * garbage-collected, unless the object is externalized.
   */
  static Local<SharedArrayBuffer> New(
      Isolate* isolate, size_t byte_length,
      BackingStoreInitializationMode initialization_mode =
          BackingStoreInitializationMode::kZeroInitialized);

  /**
   * Create a new SharedArrayBuffer with an existing backing store.
   * The created array keeps a reference to the backing store until the array
   * is garbage collected. Note that the IsExternal bit does not affect this
   * reference from the array to the backing store.
   *
   * In future IsExternal bit will be removed. Until then the bit is set as
   * follows. If the backing store does not own the underlying buffer, then
   * the array is created in externalized state. Otherwise, the array is created
   * in internalized state. In the latter case the array can be transitioned
   * to the externalized state using Externalize(backing_store).
   */
  static Local<SharedArrayBuffer> New(
      Isolate* isolate, std::shared_ptr<BackingStore> backing_store);

  /**
   * Returns a new standalone BackingStore that is allocated using the array
   * buffer allocator of the isolate. The allocation can either be zero
   * intialized, or uninitialized. The result can be later passed to
   * SharedArrayBuffer::New.
   *
   * If the allocator returns nullptr, then the function may cause GCs in the
   * given isolate and re-try the allocation. If GCs do not help, then the
   * function will crash with an out-of-memory error.
   */
  static std::unique_ptr<BackingStore> NewBackingStore(
      Isolate* isolate, size_t byte_length,
      BackingStoreInitializationMode initialization_mode =
          BackingStoreInitializationMode::kZeroInitialized);
  /**
   * Returns a new standalone BackingStore that takes over the ownership of
   * the given buffer. The destructor of the BackingStore invokes the given
   * deleter callback.
   *
   * The result can be later passed to SharedArrayBuffer::New. The raw pointer
   * to the buffer must not be passed again to any V8 functions.
   */
  static std::unique_ptr<BackingStore> NewBackingStore(
      void* data, size_t byte_length, v8::BackingStore::DeleterCallback deleter,
      void* deleter_data);

  /**
   * Get a shared pointer to the backing store of this array buffer. This
   * pointer coordinates the lifetime management of the internal storage
   * with any live ArrayBuffers on the heap, even across isolates. The embedder
   * should not attempt to manage lifetime of the storage through other means.
   */
  std::shared_ptr<BackingStore> GetBackingStore();

  /**
   * More efficient shortcut for GetBackingStore()->Data(). The returned pointer
   * is valid as long as the ArrayBuffer is alive.
   */
  void* Data() const;

  V8_INLINE static SharedArrayBuffer* Cast(Value* value) {
#ifdef V8_ENABLE_CHECKS
    CheckCast(value);
#endif
    return static_cast<SharedArrayBuffer*>(value);
  }

  static constexpr int kInternalFieldCount =
      V8_ARRAY_BUFFER_INTERNAL_FIELD_COUNT;

 private:
  SharedArrayBuffer();
  static void CheckCast(Value* obj);
};

}  // namespace v8

#endif  // INCLUDE_V8_ARRAY_BUFFER_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/include/v8-callbacks.h                                                          0000664 0000000 0000000 00000041066 14746647661 0020122 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_V8_ISOLATE_CALLBACKS_H_
#define INCLUDE_V8_ISOLATE_CALLBACKS_H_

#include <stddef.h>

#include <functional>
#include <string>

#include "cppgc/common.h"
#include "v8-data.h"          // NOLINT(build/include_directory)
#include "v8-local-handle.h"  // NOLINT(build/include_directory)
#include "v8-promise.h"       // NOLINT(build/include_directory)
#include "v8config.h"         // NOLINT(build/include_directory)

#if defined(V8_OS_WIN)
struct _EXCEPTION_POINTERS;
#endif

namespace v8 {

template <typename T>
class FunctionCallbackInfo;
class Isolate;
class Message;
class Module;
class Object;
class Promise;
class ScriptOrModule;
class String;
class UnboundScript;
class Value;

/**
 * A JIT code event is issued each time code is added, moved or removed.
 *
 * \note removal events are not currently issued.
 */
struct JitCodeEvent {
  enum EventType {
    CODE_ADDED,
    CODE_MOVED,
    CODE_REMOVED,
    CODE_ADD_LINE_POS_INFO,
    CODE_START_LINE_INFO_RECORDING,
    CODE_END_LINE_INFO_RECORDING
  };
  // Definition of the code position type. The "POSITION" type means the place
  // in the source code which are of interest when making stack traces to
  // pin-point the source location of a stack frame as close as possible.
  // The "STATEMENT_POSITION" means the place at the beginning of each
  // statement, and is used to indicate possible break locations.
  enum PositionType { POSITION, STATEMENT_POSITION };

  // There are three different kinds of CodeType, one for JIT code generated
  // by the optimizing compiler, one for byte code generated for the
  // interpreter, and one for code generated from Wasm. For JIT_CODE and
  // WASM_CODE, |code_start| points to the beginning of jitted assembly code,
  // while for BYTE_CODE events, |code_start| points to the first bytecode of
  // the interpreted function.
  enum CodeType { BYTE_CODE, JIT_CODE, WASM_CODE };

  // Type of event.
  EventType type;
  CodeType code_type;
  // Start of the instructions.
  void* code_start;
  // Size of the instructions.
  size_t code_len;
  // Script info for CODE_ADDED event.
  Local<UnboundScript> script;
  // User-defined data for *_LINE_INFO_* event. It's used to hold the source
  // code line information which is returned from the
  // CODE_START_LINE_INFO_RECORDING event. And it's passed to subsequent
  // CODE_ADD_LINE_POS_INFO and CODE_END_LINE_INFO_RECORDING events.
  void* user_data;

  struct name_t {
    // Name of the object associated with the code, note that the string is not
    // zero-terminated.
    const char* str;
    // Number of chars in str.
    size_t len;
  };

  struct line_info_t {
    // PC offset
    size_t offset;
    // Code position
    size_t pos;
    // The position type.
    PositionType position_type;
  };

  struct wasm_source_info_t {
    // Source file name.
    const char* filename;
    // Length of filename.
    size_t filename_size;
    // Line number table, which maps offsets of JITted code to line numbers of
    // source file.
    const line_info_t* line_number_table;
    // Number of entries in the line number table.
    size_t line_number_table_size;
  };

  wasm_source_info_t* wasm_source_info = nullptr;

  union {
    // Only valid for CODE_ADDED.
    struct name_t name;

    // Only valid for CODE_ADD_LINE_POS_INFO
    struct line_info_t line_info;

    // New location of instructions. Only valid for CODE_MOVED.
    void* new_code_start;
  };

  Isolate* isolate;
};

/**
 * Option flags passed to the SetJitCodeEventHandler function.
 */
enum JitCodeEventOptions {
  kJitCodeEventDefault = 0,
  // Generate callbacks for already existent code.
  kJitCodeEventEnumExisting = 1
};

/**
 * Callback function passed to SetJitCodeEventHandler.
 *
 * \param event code add, move or removal event.
 */
using JitCodeEventHandler = void (*)(const JitCodeEvent* event);

// --- Garbage Collection Callbacks ---

/**
 * Applications can register callback functions which will be called before and
 * after certain garbage collection operations.  Allocations are not allowed in
 * the callback functions, you therefore cannot manipulate objects (set or
 * delete properties for example) since it is possible such operations will
 * result in the allocation of objects.
 * TODO(v8:12612): Deprecate kGCTypeMinorMarkSweep after updating blink.
 */
enum GCType {
  kGCTypeScavenge = 1 << 0,
  kGCTypeMinorMarkSweep = 1 << 1,
  kGCTypeMarkSweepCompact = 1 << 2,
  kGCTypeIncrementalMarking = 1 << 3,
  kGCTypeProcessWeakCallbacks = 1 << 4,
  kGCTypeAll = kGCTypeScavenge | kGCTypeMinorMarkSweep |
               kGCTypeMarkSweepCompact | kGCTypeIncrementalMarking |
               kGCTypeProcessWeakCallbacks
};

/**
 * GCCallbackFlags is used to notify additional information about the GC
 * callback.
 *   - kGCCallbackFlagConstructRetainedObjectInfos: The GC callback is for
 *     constructing retained object infos.
 *   - kGCCallbackFlagForced: The GC callback is for a forced GC for testing.
 *   - kGCCallbackFlagSynchronousPhantomCallbackProcessing: The GC callback
 *     is called synchronously without getting posted to an idle task.
 *   - kGCCallbackFlagCollectAllAvailableGarbage: The GC callback is called
 *     in a phase where V8 is trying to collect all available garbage
 *     (e.g., handling a low memory notification).
 *   - kGCCallbackScheduleIdleGarbageCollection: The GC callback is called to
 *     trigger an idle garbage collection.
 */
enum GCCallbackFlags {
  kNoGCCallbackFlags = 0,
  kGCCallbackFlagConstructRetainedObjectInfos = 1 << 1,
  kGCCallbackFlagForced = 1 << 2,
  kGCCallbackFlagSynchronousPhantomCallbackProcessing = 1 << 3,
  kGCCallbackFlagCollectAllAvailableGarbage = 1 << 4,
  kGCCallbackFlagCollectAllExternalMemory = 1 << 5,
  kGCCallbackScheduleIdleGarbageCollection = 1 << 6,
};

using GCCallback = void (*)(GCType type, GCCallbackFlags flags);

using InterruptCallback = void (*)(Isolate* isolate, void* data);

/**
 * This callback is invoked when the heap size is close to the heap limit and
 * V8 is likely to abort with out-of-memory error.
 * The callback can extend the heap limit by returning a value that is greater
 * than the current_heap_limit. The initial heap limit is the limit that was
 * set after heap setup.
 */
using NearHeapLimitCallback = size_t (*)(void* data, size_t current_heap_limit,
                                         size_t initial_heap_limit);

/**
 * Callback function passed to SetUnhandledExceptionCallback.
 */
#if defined(V8_OS_WIN)
using UnhandledExceptionCallback =
    int (*)(_EXCEPTION_POINTERS* exception_pointers);
#endif

// --- Counters Callbacks ---

using CounterLookupCallback = int* (*)(const char* name);

using CreateHistogramCallback = void* (*)(const char* name, int min, int max,
                                          size_t buckets);

using AddHistogramSampleCallback = void (*)(void* histogram, int sample);

// --- Exceptions ---

using FatalErrorCallback = void (*)(const char* location, const char* message);

struct OOMDetails {
  bool is_heap_oom = false;
  const char* detail = nullptr;
};

using OOMErrorCallback = void (*)(const char* location,
                                  const OOMDetails& details);

using MessageCallback = void (*)(Local<Message> message, Local<Value> data);

// --- Tracing ---

enum LogEventStatus : int { kStart = 0, kEnd = 1, kLog = 2 };
using LogEventCallback = void (*)(const char* name,
                                  int /* LogEventStatus */ status);

// --- Crashkeys Callback ---
enum class CrashKeyId {
  kIsolateAddress,
  kReadonlySpaceFirstPageAddress,
  kMapSpaceFirstPageAddress V8_ENUM_DEPRECATE_SOON("Map space got removed"),
  kOldSpaceFirstPageAddress,
  kCodeRangeBaseAddress,
  kCodeSpaceFirstPageAddress,
  kDumpType,
  kSnapshotChecksumCalculated,
  kSnapshotChecksumExpected,
};

using AddCrashKeyCallback = void (*)(CrashKeyId id, const std::string& value);

// --- Enter/Leave Script Callback ---
using BeforeCallEnteredCallback = void (*)(Isolate*);
using CallCompletedCallback = void (*)(Isolate*);

// --- AllowCodeGenerationFromStrings callbacks ---

/**
 * Callback to check if code generation from strings is allowed. See
 * Context::AllowCodeGenerationFromStrings.
 */
using AllowCodeGenerationFromStringsCallback = bool (*)(Local<Context> context,
                                                        Local<String> source);

struct ModifyCodeGenerationFromStringsResult {
  // If true, proceed with the codegen algorithm. Otherwise, block it.
  bool codegen_allowed = false;
  // Overwrite the original source with this string, if present.
  // Use the original source if empty.
  // This field is considered only if codegen_allowed is true.
  MaybeLocal<String> modified_source;
};

/**
 * Access type specification.
 */
enum AccessType {
  ACCESS_GET,
  ACCESS_SET,
  ACCESS_HAS,
  ACCESS_DELETE,
  ACCESS_KEYS
};

// --- Failed Access Check Callback ---

using FailedAccessCheckCallback = void (*)(Local<Object> target,
                                           AccessType type, Local<Value> data);

/**
 * Callback to check if codegen is allowed from a source object, and convert
 * the source to string if necessary. See: ModifyCodeGenerationFromStrings.
 */
using ModifyCodeGenerationFromStringsCallback =
    ModifyCodeGenerationFromStringsResult (*)(Local<Context> context,
                                              Local<Value> source);
using ModifyCodeGenerationFromStringsCallback2 =
    ModifyCodeGenerationFromStringsResult (*)(Local<Context> context,
                                              Local<Value> source,
                                              bool is_code_like);

// --- WebAssembly compilation callbacks ---
using ExtensionCallback = bool (*)(const FunctionCallbackInfo<Value>&);

using AllowWasmCodeGenerationCallback = bool (*)(Local<Context> context,
                                                 Local<String> source);

// --- Callback for APIs defined on v8-supported objects, but implemented
// by the embedder. Example: WebAssembly.{compile|instantiate}Streaming ---
using ApiImplementationCallback = void (*)(const FunctionCallbackInfo<Value>&);

// --- Callback for WebAssembly.compileStreaming ---
using WasmStreamingCallback = void (*)(const FunctionCallbackInfo<Value>&);

enum class WasmAsyncSuccess { kSuccess, kFail };

// --- Callback called when async WebAssembly operations finish ---
using WasmAsyncResolvePromiseCallback = void (*)(
    Isolate* isolate, Local<Context> context, Local<Promise::Resolver> resolver,
    Local<Value> result, WasmAsyncSuccess success);

// --- Callback for loading source map file for Wasm profiling support
using WasmLoadSourceMapCallback = Local<String> (*)(Isolate* isolate,
                                                    const char* name);

// --- Callback for checking if WebAssembly imported strings are enabled ---
using WasmImportedStringsEnabledCallback = bool (*)(Local<Context> context);

// --- Callback for checking if the SharedArrayBuffer constructor is enabled ---
using SharedArrayBufferConstructorEnabledCallback =
    bool (*)(Local<Context> context);

// --- Callback for checking if the compile hints magic comments are enabled ---
using JavaScriptCompileHintsMagicEnabledCallback =
    bool (*)(Local<Context> context);

// --- Callback for checking if WebAssembly JSPI is enabled ---
using WasmJSPIEnabledCallback = bool (*)(Local<Context> context);

/**
 * Import phases in import requests.
 */
enum class ModuleImportPhase {
  kSource,
  kEvaluation,
};

/**
 * HostImportModuleDynamicallyCallback is called when we
 * require the embedder to load a module. This is used as part of the dynamic
 * import syntax.
 *
 * The referrer contains metadata about the script/module that calls
 * import.
 *
 * The specifier is the name of the module that should be imported.
 *
 * The import_attributes are import attributes for this request in the form:
 * [key1, value1, key2, value2, ...] where the keys and values are of type
 * v8::String. Note, unlike the FixedArray passed to ResolveModuleCallback and
 * returned from ModuleRequest::GetImportAttributes(), this array does not
 * contain the source Locations of the attributes.
 *
 * The embedder must compile, instantiate, evaluate the Module, and
 * obtain its namespace object.
 *
 * The Promise returned from this function is forwarded to userland
 * JavaScript. The embedder must resolve this promise with the module
 * namespace object. In case of an exception, the embedder must reject
 * this promise with the exception. If the promise creation itself
 * fails (e.g. due to stack overflow), the embedder must propagate
 * that exception by returning an empty MaybeLocal.
 */
using HostImportModuleDynamicallyCallback = MaybeLocal<Promise> (*)(
    Local<Context> context, Local<Data> host_defined_options,
    Local<Value> resource_name, Local<String> specifier,
    Local<FixedArray> import_attributes);

/**
 * Callback for requesting a compile hint for a function from the embedder. The
 * first parameter is the position of the function in source code and the second
 * parameter is embedder data to be passed back.
 */
using CompileHintCallback = bool (*)(int, void*);

/**
 * HostInitializeImportMetaObjectCallback is called the first time import.meta
 * is accessed for a module. Subsequent access will reuse the same value.
 *
 * The method combines two implementation-defined abstract operations into one:
 * HostGetImportMetaProperties and HostFinalizeImportMeta.
 *
 * The embedder should use v8::Object::CreateDataProperty to add properties on
 * the meta object.
 */
using HostInitializeImportMetaObjectCallback = void (*)(Local<Context> context,
                                                        Local<Module> module,
                                                        Local<Object> meta);

/**
 * HostCreateShadowRealmContextCallback is called each time a ShadowRealm is
 * being constructed in the initiator_context.
 *
 * The method combines Context creation and implementation defined abstract
 * operation HostInitializeShadowRealm into one.
 *
 * The embedder should use v8::Context::New or v8::Context:NewFromSnapshot to
 * create a new context. If the creation fails, the embedder must propagate
 * that exception by returning an empty MaybeLocal.
 */
using HostCreateShadowRealmContextCallback =
    MaybeLocal<Context> (*)(Local<Context> initiator_context);

/**
 * PrepareStackTraceCallback is called when the stack property of an error is
 * first accessed. The return value will be used as the stack value. If this
 * callback is registed, the |Error.prepareStackTrace| API will be disabled.
 * |sites| is an array of call sites, specified in
 * https://v8.dev/docs/stack-trace-api
 */
using PrepareStackTraceCallback = MaybeLocal<Value> (*)(Local<Context> context,
                                                        Local<Value> error,
                                                        Local<Array> sites);

#if defined(V8_OS_WIN)
/**
 * Callback to selectively enable ETW tracing based on the document URL.
 * Implemented by the embedder, it should never call back into V8.
 *
 * Windows allows passing additional data to the ETW EnableCallback:
 * https://learn.microsoft.com/en-us/windows/win32/api/evntprov/nc-evntprov-penablecallback
 *
 * This data can be configured in a WPR (Windows Performance Recorder)
 * profile, adding a CustomFilter to an EventProvider like the following:
 *
 * <EventProvider Id=".." Name="57277741-3638-4A4B-BDBA-0AC6E45DA56C" Level="5">
 *   <CustomFilter Type="0x80000000" Value="AQABAAAAAAA..." />
 * </EventProvider>
 *
 * Where:
 * - Name="57277741-3638-4A4B-BDBA-0AC6E45DA56C" is the GUID of the V8
 *     ETW provider, (see src/libplatform/etw/etw-provider-win.h),
 * - Type="0x80000000" is EVENT_FILTER_TYPE_SCHEMATIZED,
 * - Value="AQABAAAAAA..." is a base64-encoded byte array that is
 *     base64-decoded by Windows and passed to the ETW enable callback in
 *     the 'PEVENT_FILTER_DESCRIPTOR FilterData' argument; see:
 * https://learn.microsoft.com/en-us/windows/win32/api/evntprov/ns-evntprov-event_filter_descriptor.
 *
 * This array contains a struct EVENT_FILTER_HEADER followed by a
 * variable length payload, and as payload we pass a string in JSON format,
 * with a list of regular expressions that should match the document URL
 * in order to enable ETW tracing:
 *   {
 *     "version": "1.0",
 *     "filtered_urls": [
 *         "https:\/\/.*\.chromium\.org\/.*", "https://v8.dev/";, "..."
 *     ]
 *  }
 */
using FilterETWSessionByURLCallback =
    bool (*)(Local<Context> context, const std::string& etw_filter_payload);
#endif  // V8_OS_WIN

}  // namespace v8

#endif  // INCLUDE_V8_ISOLATE_CALLBACKS_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/include/v8-container.h                                                          0000664 0000000 0000000 00000013507 14746647661 0020164 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_V8_CONTAINER_H_
#define INCLUDE_V8_CONTAINER_H_

#include <stddef.h>
#include <stdint.h>

#include <functional>

#include "v8-local-handle.h"  // NOLINT(build/include_directory)
#include "v8-object.h"        // NOLINT(build/include_directory)
#include "v8config.h"         // NOLINT(build/include_directory)

namespace v8 {

class Context;
class Isolate;

/**
 * An instance of the built-in array constructor (ECMA-262, 15.4.2).
 */
class V8_EXPORT Array : public Object {
 public:
  uint32_t Length() const;

  /**
   * Creates a JavaScript array with the given length. If the length
   * is negative the returned array will have length 0.
   */
  static Local<Array> New(Isolate* isolate, int length = 0);

  /**
   * Creates a JavaScript array out of a Local<Value> array in C++
   * with a known length.
   */
  static Local<Array> New(Isolate* isolate, Local<Value>* elements,
                          size_t length);
  V8_INLINE static Array* Cast(Value* value) {
#ifdef V8_ENABLE_CHECKS
    CheckCast(value);
#endif
    return static_cast<Array*>(value);
  }

  /**
   * Creates a JavaScript array from a provided callback.
   *
   * \param context The v8::Context to create the array in.
   * \param length The length of the array to be created.
   * \param next_value_callback The callback that is invoked to retrieve
   *     elements for the array. The embedder can signal that the array
   *     initialization should be aborted by throwing an exception and returning
   *     an empty MaybeLocal.
   * \returns The v8::Array if all elements were constructed successfully and an
   *     empty MaybeLocal otherwise.
   */
  static MaybeLocal<Array> New(
      Local<Context> context, size_t length,
      std::function<MaybeLocal<v8::Value>()> next_value_callback);

  enum class CallbackResult {
    kException,
    kBreak,
    kContinue,
  };
  using IterationCallback = CallbackResult (*)(uint32_t index,
                                               Local<Value> element,
                                               void* data);

  /**
   * Calls {callback} for every element of this array, passing {callback_data}
   * as its {data} parameter.
   * This function will typically be faster than calling {Get()} repeatedly.
   * As a consequence of being optimized for low overhead, the provided
   * callback must adhere to the following restrictions:
   *  - It must not allocate any V8 objects and continue iterating; it may
   *    allocate (e.g. an error message/object) and then immediately terminate
   *    the iteration.
   *  - It must not modify the array being iterated.
   *  - It must not call back into V8 (unless it can guarantee that such a
   *    call does not violate the above restrictions, which is difficult).
   *  - The {Local<Value> element} must not "escape", i.e. must not be assigned
   *    to any other {Local}. Creating a {Global} from it, or updating a
   *    v8::TypecheckWitness with it, is safe.
   * These restrictions may be lifted in the future if use cases arise that
   * justify a slower but more robust implementation.
   *
   * Returns {Nothing} on exception; use a {TryCatch} to catch and handle this
   * exception.
   * When the {callback} returns {kException}, iteration is terminated
   * immediately, returning {Nothing}. By returning {kBreak}, the callback
   * can request non-exceptional early termination of the iteration.
   */
  Maybe<void> Iterate(Local<Context> context, IterationCallback callback,
                      void* callback_data);

 private:
  Array();
  static void CheckCast(Value* obj);
};

/**
 * An instance of the built-in Map constructor (ECMA-262, 6th Edition, 23.1.1).
 */
class V8_EXPORT Map : public Object {
 public:
  size_t Size() const;
  void Clear();
  V8_WARN_UNUSED_RESULT MaybeLocal<Value> Get(Local<Context> context,
                                              Local<Value> key);
  V8_WARN_UNUSED_RESULT MaybeLocal<Map> Set(Local<Context> context,
                                            Local<Value> key,
                                            Local<Value> value);
  V8_WARN_UNUSED_RESULT Maybe<bool> Has(Local<Context> context,
                                        Local<Value> key);
  V8_WARN_UNUSED_RESULT Maybe<bool> Delete(Local<Context> context,
                                           Local<Value> key);

  /**
   * Returns an array of length Size() * 2, where index N is the Nth key and
   * index N + 1 is the Nth value.
   */
  Local<Array> AsArray() const;

  /**
   * Creates a new empty Map.
   */
  static Local<Map> New(Isolate* isolate);

  V8_INLINE static Map* Cast(Value* value) {
#ifdef V8_ENABLE_CHECKS
    CheckCast(value);
#endif
    return static_cast<Map*>(value);
  }

 private:
  Map();
  static void CheckCast(Value* obj);
};

/**
 * An instance of the built-in Set constructor (ECMA-262, 6th Edition, 23.2.1).
 */
class V8_EXPORT Set : public Object {
 public:
  size_t Size() const;
  void Clear();
  V8_WARN_UNUSED_RESULT MaybeLocal<Set> Add(Local<Context> context,
                                            Local<Value> key);
  V8_WARN_UNUSED_RESULT Maybe<bool> Has(Local<Context> context,
                                        Local<Value> key);
  V8_WARN_UNUSED_RESULT Maybe<bool> Delete(Local<Context> context,
                                           Local<Value> key);

  /**
   * Returns an array of the keys in this Set.
   */
  Local<Array> AsArray() const;

  /**
   * Creates a new empty Set.
   */
  static Local<Set> New(Isolate* isolate);

  V8_INLINE static Set* Cast(Value* value) {
#ifdef V8_ENABLE_CHECKS
    CheckCast(value);
#endif
    return static_cast<Set*>(value);
  }

 private:
  Set();
  static void CheckCast(Value* obj);
};

}  // namespace v8

#endif  // INCLUDE_V8_CONTAINER_H_
                                                                                                                                                                                         node-23.7.0/deps/v8/include/v8-context.h                                                            0000664 0000000 0000000 00000046323 14746647661 0017670 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_V8_CONTEXT_H_
#define INCLUDE_V8_CONTEXT_H_

#include <stdint.h>

#include <vector>

#include "v8-data.h"          // NOLINT(build/include_directory)
#include "v8-local-handle.h"  // NOLINT(build/include_directory)
#include "v8-maybe.h"         // NOLINT(build/include_directory)
#include "v8-snapshot.h"      // NOLINT(build/include_directory)
#include "v8config.h"         // NOLINT(build/include_directory)

namespace v8 {

class Function;
class MicrotaskQueue;
class Object;
class ObjectTemplate;
class Value;
class String;

/**
 * A container for extension names.
 */
class V8_EXPORT ExtensionConfiguration {
 public:
  ExtensionConfiguration() : name_count_(0), names_(nullptr) {}
  ExtensionConfiguration(int name_count, const char* names[])
      : name_count_(name_count), names_(names) {}

  const char** begin() const { return &names_[0]; }
  const char** end() const { return &names_[name_count_]; }

 private:
  const int name_count_;
  const char** names_;
};

/**
 * A sandboxed execution context with its own set of built-in objects
 * and functions.
 */
class V8_EXPORT Context : public Data {
 public:
  /**
   * Returns the global proxy object.
   *
   * Global proxy object is a thin wrapper whose prototype points to actual
   * context's global object with the properties like Object, etc. This is done
   * that way for security reasons (for more details see
   * https://wiki.mozilla.org/Gecko:SplitWindow).
   *
   * Please note that changes to global proxy object prototype most probably
   * would break VM---v8 expects only global object as a prototype of global
   * proxy object.
   */
  Local<Object> Global();

  /**
   * Detaches the global object from its context before
   * the global object can be reused to create a new context.
   */
  void DetachGlobal();

  /**
   * Creates a new context and returns a handle to the newly allocated
   * context.
   *
   * \param isolate The isolate in which to create the context.
   *
   * \param extensions An optional extension configuration containing
   * the extensions to be installed in the newly created context.
   *
   * \param global_template An optional object template from which the
   * global object for the newly created context will be created.
   *
   * \param global_object An optional global object to be reused for
   * the newly created context. This global object must have been
   * created by a previous call to Context::New with the same global
   * template. The state of the global object will be completely reset
   * and only object identify will remain.
   *
   * \param internal_fields_deserializer An optional callback used
   * to deserialize fields set by
   * v8::Object::SetAlignedPointerInInternalField() in wrapper objects
   * from the default context snapshot. It should match the
   * SerializeInternalFieldsCallback() used by
   * v8::SnapshotCreator::SetDefaultContext() when the default context
   * snapshot is created. It does not need to be configured if the default
   * context snapshot contains no wrapper objects with pointer internal
   * fields, or if no custom startup snapshot is configured
   * in the v8::CreateParams used to create the isolate.
   *
   * \param microtask_queue An optional microtask queue used to manage
   * the microtasks created in this context. If not set the per-isolate
   * default microtask queue would be used.
   *
   * \param context_data_deserializer An optional callback used
   * to deserialize embedder data set by
   * v8::Context::SetAlignedPointerInEmbedderData() in the default
   * context from the default context snapshot. It does not need to be
   * configured if the default context snapshot contains no pointer embedder
   * data, or if no custom startup snapshot is configured in the
   * v8::CreateParams used to create the isolate.
   *
   * \param api_wrapper_deserializer An optional callback used to deserialize
   * API wrapper objects that was initially set with v8::Object::Wrap() and then
   * serialized using SerializeAPIWrapperCallback.
   */
  static Local<Context> New(
      Isolate* isolate, ExtensionConfiguration* extensions = nullptr,
      MaybeLocal<ObjectTemplate> global_template = MaybeLocal<ObjectTemplate>(),
      MaybeLocal<Value> global_object = MaybeLocal<Value>(),
      DeserializeInternalFieldsCallback internal_fields_deserializer =
          DeserializeInternalFieldsCallback(),
      MicrotaskQueue* microtask_queue = nullptr,
      DeserializeContextDataCallback context_data_deserializer =
          DeserializeContextDataCallback(),
      DeserializeAPIWrapperCallback api_wrapper_deserializer =
          DeserializeAPIWrapperCallback());

  /**
   * Create a new context from a (non-default) context snapshot. There
   * is no way to provide a global object template since we do not create
   * a new global object from template, but we can reuse a global object.
   *
   * \param isolate See v8::Context::New().
   *
   * \param context_snapshot_index The index of the context snapshot to
   * deserialize from. Use v8::Context::New() for the default snapshot.
   *
   * \param internal_fields_deserializer An optional callback used
   * to deserialize fields set by
   * v8::Object::SetAlignedPointerInInternalField() in wrapper objects
   * from the default context snapshot. It does not need to be
   * configured if there are no wrapper objects with no internal
   * pointer fields in the default context snapshot or if no startup
   * snapshot is configured when the isolate is created.
   *
   * \param extensions See v8::Context::New().
   *
   * \param global_object See v8::Context::New().
   *
   * \param internal_fields_deserializer Similar to
   * internal_fields_deserializer in v8::Context::New() but applies to
   * the context specified by the context_snapshot_index.
   *
   * \param microtask_queue  See v8::Context::New().
   *
   * \param context_data_deserializer  Similar to
   * context_data_deserializer in v8::Context::New() but applies to
   * the context specified by the context_snapshot_index.
   *
   *\param api_wrapper_deserializer Similar to api_wrapper_deserializer in
   * v8::Context::New() but applies to the context specified by the
   * context_snapshot_index.
   */
  static MaybeLocal<Context> FromSnapshot(
      Isolate* isolate, size_t context_snapshot_index,
      DeserializeInternalFieldsCallback internal_fields_deserializer =
          DeserializeInternalFieldsCallback(),
      ExtensionConfiguration* extensions = nullptr,
      MaybeLocal<Value> global_object = MaybeLocal<Value>(),
      MicrotaskQueue* microtask_queue = nullptr,
      DeserializeContextDataCallback context_data_deserializer =
          DeserializeContextDataCallback(),
      DeserializeAPIWrapperCallback api_wrapper_deserializer =
          DeserializeAPIWrapperCallback());

  /**
   * Returns an global object that isn't backed by an actual context.
   *
   * The global template needs to have access checks with handlers installed.
   * If an existing global object is passed in, the global object is detached
   * from its context.
   *
   * Note that this is different from a detached context where all accesses to
   * the global proxy will fail. Instead, the access check handlers are invoked.
   *
   * It is also not possible to detach an object returned by this method.
   * Instead, the access check handlers need to return nothing to achieve the
   * same effect.
   *
   * It is possible, however, to create a new context from the global object
   * returned by this method.
   */
  static MaybeLocal<Object> NewRemoteContext(
      Isolate* isolate, Local<ObjectTemplate> global_template,
      MaybeLocal<Value> global_object = MaybeLocal<Value>());

  /**
   * Sets the security token for the context.  To access an object in
   * another context, the security tokens must match.
   */
  void SetSecurityToken(Local<Value> token);

  /** Restores the security token to the default value. */
  void UseDefaultSecurityToken();

  /** Returns the security token of this context.*/
  Local<Value> GetSecurityToken();

  /**
   * Enter this context.  After entering a context, all code compiled
   * and run is compiled and run in this context.  If another context
   * is already entered, this old context is saved so it can be
   * restored when the new context is exited.
   */
  void Enter();

  /**
   * Exit this context.  Exiting the current context restores the
   * context that was in place when entering the current context.
   */
  void Exit();

  /**
   * Delegate to help with Deep freezing embedder-specific objects (such as
   * JSApiObjects) that can not be frozen natively.
   */
  class DeepFreezeDelegate {
   public:
    /**
     * Performs embedder-specific operations to freeze the provided embedder
     * object. The provided object *will* be frozen by DeepFreeze after this
     * function returns, so only embedder-specific objects need to be frozen.
     * This function *may not* create new JS objects or perform JS allocations.
     * Any v8 objects reachable from the provided embedder object that should
     * also be considered for freezing should be added to the children_out
     * parameter. Returns true if the operation completed successfully.
     */
    virtual bool FreezeEmbedderObjectAndGetChildren(
        Local<Object> obj, LocalVector<Object>& children_out) = 0;
  };

  /**
   * Attempts to recursively freeze all objects reachable from this context.
   * Some objects (generators, iterators, non-const closures) can not be frozen
   * and will cause this method to throw an error. An optional delegate can be
   * provided to help freeze embedder-specific objects.
   *
   * Freezing occurs in two steps:
   * 1. "Marking" where we iterate through all objects reachable by this
   *    context, accumulating a list of objects that need to be frozen and
   *    looking for objects that can't be frozen. This step is separated because
   *    it is more efficient when we can assume there is no garbage collection.
   * 2. "Freezing" where we go through the list of objects and freezing them.
   *    This effectively requires copying them so it may trigger garbage
   *    collection.
   */
  Maybe<void> DeepFreeze(DeepFreezeDelegate* delegate = nullptr);

  /** Returns the isolate associated with a current context. */
  Isolate* GetIsolate();

  /** Returns the microtask queue associated with a current context. */
  MicrotaskQueue* GetMicrotaskQueue();

  /** Sets the microtask queue associated with the current context. */
  void SetMicrotaskQueue(MicrotaskQueue* queue);

  /**
   * The field at kDebugIdIndex used to be reserved for the inspector.
   * It now serves no purpose.
   */
  enum EmbedderDataFields { kDebugIdIndex = 0 };

  /**
   * Return the number of fields allocated for embedder data.
   */
  uint32_t GetNumberOfEmbedderDataFields();

  /**
   * Gets the embedder data with the given index, which must have been set by a
   * previous call to SetEmbedderData with the same index.
   */
  V8_INLINE Local<Value> GetEmbedderData(int index);

  /**
   * Gets the binding object used by V8 extras. Extra natives get a reference
   * to this object and can use it to "export" functionality by adding
   * properties. Extra natives can also "import" functionality by accessing
   * properties added by the embedder using the V8 API.
   */
  Local<Object> GetExtrasBindingObject();

  /**
   * Sets the embedder data with the given index, growing the data as
   * needed. Note that index 0 currently has a special meaning for Chrome's
   * debugger.
   */
  void SetEmbedderData(int index, Local<Value> value);

  /**
   * Gets a 2-byte-aligned native pointer from the embedder data with the given
   * index, which must have been set by a previous call to
   * SetAlignedPointerInEmbedderData with the same index. Note that index 0
   * currently has a special meaning for Chrome's debugger.
   */
  V8_INLINE void* GetAlignedPointerFromEmbedderData(Isolate* isolate,
                                                    int index);
  V8_INLINE void* GetAlignedPointerFromEmbedderData(int index);

  /**
   * Sets a 2-byte-aligned native pointer in the embedder data with the given
   * index, growing the data as needed. Note that index 0 currently has a
   * special meaning for Chrome's debugger.
   */
  void SetAlignedPointerInEmbedderData(int index, void* value);

  /**
   * Control whether code generation from strings is allowed. Calling
   * this method with false will disable 'eval' and the 'Function'
   * constructor for code running in this context. If 'eval' or the
   * 'Function' constructor are used an exception will be thrown.
   *
   * If code generation from strings is not allowed the
   * V8::AllowCodeGenerationFromStrings callback will be invoked if
   * set before blocking the call to 'eval' or the 'Function'
   * constructor. If that callback returns true, the call will be
   * allowed, otherwise an exception will be thrown. If no callback is
   * set an exception will be thrown.
   */
  void AllowCodeGenerationFromStrings(bool allow);

  /**
   * Returns true if code generation from strings is allowed for the context.
   * For more details see AllowCodeGenerationFromStrings(bool) documentation.
   */
  bool IsCodeGenerationFromStringsAllowed() const;

  /**
   * Sets the error description for the exception that is thrown when
   * code generation from strings is not allowed and 'eval' or the 'Function'
   * constructor are called.
   */
  void SetErrorMessageForCodeGenerationFromStrings(Local<String> message);

  /**
   * Sets the error description for the exception that is thrown when
   * wasm code generation is not allowed.
   */
  void SetErrorMessageForWasmCodeGeneration(Local<String> message);

  /**
   * Return data that was previously attached to the context snapshot via
   * SnapshotCreator, and removes the reference to it.
   * Repeated call with the same index returns an empty MaybeLocal.
   */
  template <class T>
  V8_INLINE MaybeLocal<T> GetDataFromSnapshotOnce(size_t index);

  /**
   * If callback is set, abort any attempt to execute JavaScript in this
   * context, call the specified callback, and throw an exception.
   * To unset abort, pass nullptr as callback.
   */
  using AbortScriptExecutionCallback = void (*)(Isolate* isolate,
                                                Local<Context> context);
  void SetAbortScriptExecution(AbortScriptExecutionCallback callback);

  /**
   * Set or clear hooks to be invoked for promise lifecycle operations.
   * To clear a hook, set it to an empty v8::Function. Each function will
   * receive the observed promise as the first argument. If a chaining
   * operation is used on a promise, the init will additionally receive
   * the parent promise as the second argument.
   */
  void SetPromiseHooks(Local<Function> init_hook, Local<Function> before_hook,
                       Local<Function> after_hook,
                       Local<Function> resolve_hook);

  bool HasTemplateLiteralObject(Local<Value> object);
  /**
   * Stack-allocated class which sets the execution context for all
   * operations executed within a local scope.
   */
  class V8_NODISCARD Scope {
   public:
    explicit V8_INLINE Scope(Local<Context> context) : context_(context) {
      context_->Enter();
    }
    V8_INLINE ~Scope() { context_->Exit(); }

   private:
    Local<Context> context_;
  };

  /**
   * Stack-allocated class to support the backup incumbent settings object
   * stack.
   * https://html.spec.whatwg.org/multipage/webappapis.html#backup-incumbent-settings-object-stack
   */
  class V8_EXPORT V8_NODISCARD BackupIncumbentScope final {
   public:
    /**
     * |backup_incumbent_context| is pushed onto the backup incumbent settings
     * object stack.
     */
    explicit BackupIncumbentScope(Local<Context> backup_incumbent_context);
    ~BackupIncumbentScope();

   private:
    friend class internal::Isolate;

    uintptr_t JSStackComparableAddressPrivate() const {
      return js_stack_comparable_address_;
    }

    Local<Context> backup_incumbent_context_;
    uintptr_t js_stack_comparable_address_ = 0;
    const BackupIncumbentScope* prev_ = nullptr;
  };

  V8_INLINE static Context* Cast(Data* data);

 private:
  friend class Value;
  friend class Script;
  friend class Object;
  friend class Function;

  static void CheckCast(Data* obj);

  internal::Address* GetDataFromSnapshotOnce(size_t index);
  Local<Value> SlowGetEmbedderData(int index);
  void* SlowGetAlignedPointerFromEmbedderData(int index);
};

// --- Implementation ---

Local<Value> Context::GetEmbedderData(int index) {
#ifndef V8_ENABLE_CHECKS
  using A = internal::Address;
  using I = internal::Internals;
  A ctx = internal::ValueHelper::ValueAsAddress(this);
  A embedder_data =
      I::ReadTaggedPointerField(ctx, I::kNativeContextEmbedderDataOffset);
  int value_offset =
      I::kEmbedderDataArrayHeaderSize + (I::kEmbedderDataSlotSize * index);
  A value = I::ReadRawField<A>(embedder_data, value_offset);
#ifdef V8_COMPRESS_POINTERS
  // We read the full pointer value and then decompress it in order to avoid
  // dealing with potential endiannes issues.
  value = I::DecompressTaggedField(embedder_data, static_cast<uint32_t>(value));
#endif

  auto isolate = reinterpret_cast<v8::Isolate*>(
      internal::IsolateFromNeverReadOnlySpaceObject(ctx));
  return Local<Value>::New(isolate, value);
#else
  return SlowGetEmbedderData(index);
#endif
}

void* Context::GetAlignedPointerFromEmbedderData(Isolate* isolate, int index) {
#if !defined(V8_ENABLE_CHECKS)
  using A = internal::Address;
  using I = internal::Internals;
  A ctx = internal::ValueHelper::ValueAsAddress(this);
  A embedder_data =
      I::ReadTaggedPointerField(ctx, I::kNativeContextEmbedderDataOffset);
  int value_offset = I::kEmbedderDataArrayHeaderSize +
                     (I::kEmbedderDataSlotSize * index) +
                     I::kEmbedderDataSlotExternalPointerOffset;
  return reinterpret_cast<void*>(
      I::ReadExternalPointerField<internal::kEmbedderDataSlotPayloadTag>(
          isolate, embedder_data, value_offset));
#else
  return SlowGetAlignedPointerFromEmbedderData(index);
#endif
}

void* Context::GetAlignedPointerFromEmbedderData(int index) {
#if !defined(V8_ENABLE_CHECKS)
  using A = internal::Address;
  using I = internal::Internals;
  A ctx = internal::ValueHelper::ValueAsAddress(this);
  A embedder_data =
      I::ReadTaggedPointerField(ctx, I::kNativeContextEmbedderDataOffset);
  int value_offset = I::kEmbedderDataArrayHeaderSize +
                     (I::kEmbedderDataSlotSize * index) +
                     I::kEmbedderDataSlotExternalPointerOffset;
  Isolate* isolate = I::GetIsolateForSandbox(ctx);
  return reinterpret_cast<void*>(
      I::ReadExternalPointerField<internal::kEmbedderDataSlotPayloadTag>(
          isolate, embedder_data, value_offset));
#else
  return SlowGetAlignedPointerFromEmbedderData(index);
#endif
}

template <class T>
MaybeLocal<T> Context::GetDataFromSnapshotOnce(size_t index) {
  if (auto slot = GetDataFromSnapshotOnce(index); slot) {
    internal::PerformCastCheck(
        internal::ValueHelper::SlotAsValue<T, false>(slot));
    return Local<T>::FromSlot(slot);
  }
  return {};
}

Context* Context::Cast(v8::Data* data) {
#ifdef V8_ENABLE_CHECKS
  CheckCast(data);
#endif
  return static_cast<Context*>(data);
}

}  // namespace v8

#endif  // INCLUDE_V8_CONTEXT_H_
                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/include/v8-cppgc.h                                                              0000664 0000000 0000000 00000013376 14746647661 0017302 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_V8_CPPGC_H_
#define INCLUDE_V8_CPPGC_H_

#include <cstdint>
#include <memory>
#include <vector>

#include "cppgc/common.h"
#include "cppgc/custom-space.h"
#include "cppgc/heap-statistics.h"
#include "cppgc/visitor.h"
#include "v8-internal.h"       // NOLINT(build/include_directory)
#include "v8-platform.h"       // NOLINT(build/include_directory)
#include "v8-traced-handle.h"  // NOLINT(build/include_directory)

namespace cppgc {
class AllocationHandle;
class HeapHandle;
}  // namespace cppgc

namespace v8 {

class Object;

namespace internal {
class CppHeap;
}  // namespace internal

class CustomSpaceStatisticsReceiver;

struct V8_EXPORT CppHeapCreateParams {
  explicit CppHeapCreateParams(
      std::vector<std::unique_ptr<cppgc::CustomSpaceBase>> custom_spaces)
      : custom_spaces(std::move(custom_spaces)) {}

  CppHeapCreateParams(const CppHeapCreateParams&) = delete;
  CppHeapCreateParams& operator=(const CppHeapCreateParams&) = delete;

  std::vector<std::unique_ptr<cppgc::CustomSpaceBase>> custom_spaces;
  /**
   * Specifies which kind of marking are supported by the heap. The type may be
   * further reduced via runtime flags when attaching the heap to an Isolate.
   */
  cppgc::Heap::MarkingType marking_support =
      cppgc::Heap::MarkingType::kIncrementalAndConcurrent;
  /**
   * Specifies which kind of sweeping is supported by the heap. The type may be
   * further reduced via runtime flags when attaching the heap to an Isolate.
   */
  cppgc::Heap::SweepingType sweeping_support =
      cppgc::Heap::SweepingType::kIncrementalAndConcurrent;
};

/**
 * A heap for allocating managed C++ objects.
 *
 * Similar to v8::Isolate, the heap may only be accessed from one thread at a
 * time. The heap may be used from different threads using the
 * v8::Locker/v8::Unlocker APIs which is different from generic Oilpan.
 */
class V8_EXPORT CppHeap {
 public:
  static std::unique_ptr<CppHeap> Create(v8::Platform* platform,
                                         const CppHeapCreateParams& params);

  virtual ~CppHeap() = default;

  /**
   * \returns the opaque handle for allocating objects using
   * `MakeGarbageCollected()`.
   */
  cppgc::AllocationHandle& GetAllocationHandle();

  /**
   * \returns the opaque heap handle which may be used to refer to this heap in
   *   other APIs. Valid as long as the underlying `CppHeap` is alive.
   */
  cppgc::HeapHandle& GetHeapHandle();

  /**
   * Terminate clears all roots and performs multiple garbage collections to
   * reclaim potentially newly created objects in destructors.
   *
   * After this call, object allocation is prohibited.
   */
  void Terminate();

  /**
   * \param detail_level specifies whether should return detailed
   *   statistics or only brief summary statistics.
   * \returns current CppHeap statistics regarding memory consumption
   *   and utilization.
   */
  cppgc::HeapStatistics CollectStatistics(
      cppgc::HeapStatistics::DetailLevel detail_level);

  /**
   * Collects statistics for the given spaces and reports them to the receiver.
   *
   * \param custom_spaces a collection of custom space indicies.
   * \param receiver an object that gets the results.
   */
  void CollectCustomSpaceStatisticsAtLastGC(
      std::vector<cppgc::CustomSpaceIndex> custom_spaces,
      std::unique_ptr<CustomSpaceStatisticsReceiver> receiver);

  /**
   * Enables a detached mode that allows testing garbage collection using
   * `cppgc::testing` APIs. Once used, the heap cannot be attached to an
   * `Isolate` anymore.
   */
  void EnableDetachedGarbageCollectionsForTesting();

  /**
   * Performs a stop-the-world garbage collection for testing purposes.
   *
   * \param stack_state The stack state to assume for the garbage collection.
   */
  void CollectGarbageForTesting(cppgc::EmbedderStackState stack_state);

  /**
   * Performs a stop-the-world minor garbage collection for testing purposes.
   *
   * \param stack_state The stack state to assume for the garbage collection.
   */
  void CollectGarbageInYoungGenerationForTesting(
      cppgc::EmbedderStackState stack_state);

 private:
  CppHeap() = default;

  friend class internal::CppHeap;
};

class JSVisitor : public cppgc::Visitor {
 public:
  explicit JSVisitor(cppgc::Visitor::Key key) : cppgc::Visitor(key) {}
  ~JSVisitor() override = default;

  void Trace(const TracedReferenceBase& ref) {
    if (ref.IsEmptyThreadSafe()) return;
    Visit(ref);
  }

 protected:
  using cppgc::Visitor::Visit;

  virtual void Visit(const TracedReferenceBase& ref) {}
};

/**
 * Provided as input to `CppHeap::CollectCustomSpaceStatisticsAtLastGC()`.
 *
 * Its method is invoked with the results of the statistic collection.
 */
class CustomSpaceStatisticsReceiver {
 public:
  virtual ~CustomSpaceStatisticsReceiver() = default;
  /**
   * Reports the size of a space at the last GC. It is called for each space
   * that was requested in `CollectCustomSpaceStatisticsAtLastGC()`.
   *
   * \param space_index The index of the space.
   * \param bytes The total size of live objects in the space at the last GC.
   *    It is zero if there was no GC yet.
   */
  virtual void AllocatedBytes(cppgc::CustomSpaceIndex space_index,
                              size_t bytes) = 0;
};

}  // namespace v8

namespace cppgc {

template <typename T>
struct TraceTrait<v8::TracedReference<T>> {
  static cppgc::TraceDescriptor GetTraceDescriptor(const void* self) {
    return {nullptr, Trace};
  }

  static void Trace(Visitor* visitor, const void* self) {
    static_cast<v8::JSVisitor*>(visitor)->Trace(
        *static_cast<const v8::TracedReference<T>*>(self));
  }
};

}  // namespace cppgc

#endif  // INCLUDE_V8_CPPGC_H_
                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/include/v8-data.h                                                               0000664 0000000 0000000 00000003127 14746647661 0017110 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_V8_DATA_H_
#define INCLUDE_V8_DATA_H_

#include "v8-local-handle.h"  // NOLINT(build/include_directory)
#include "v8config.h"         // NOLINT(build/include_directory)

namespace v8 {

class Context;

/**
 * The superclass of objects that can reside on V8's heap.
 */
class V8_EXPORT Data {
 public:
  /**
   * Returns true if this data is a |v8::Value|.
   */
  bool IsValue() const;

  /**
   * Returns true if this data is a |v8::Module|.
   */
  bool IsModule() const;

  /**
   * Returns tru if this data is a |v8::FixedArray|
   */
  bool IsFixedArray() const;

  /**
   * Returns true if this data is a |v8::Private|.
   */
  bool IsPrivate() const;

  /**
   * Returns true if this data is a |v8::ObjectTemplate|.
   */
  bool IsObjectTemplate() const;

  /**
   * Returns true if this data is a |v8::FunctionTemplate|.
   */
  bool IsFunctionTemplate() const;

  /**
   * Returns true if this data is a |v8::Context|.
   */
  bool IsContext() const;

 private:
  Data() = delete;
};

/**
 * A fixed-sized array with elements of type Data.
 */
class V8_EXPORT FixedArray : public Data {
 public:
  int Length() const;
  Local<Data> Get(Local<Context> context, int i) const;

  V8_INLINE static FixedArray* Cast(Data* data) {
#ifdef V8_ENABLE_CHECKS
    CheckCast(data);
#endif
    return reinterpret_cast<FixedArray*>(data);
  }

 private:
  static void CheckCast(Data* obj);
};

}  // namespace v8

#endif  // INCLUDE_V8_DATA_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/include/v8-date.h                                                               0000664 0000000 0000000 00000002637 14746647661 0017121 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_V8_DATE_H_
#define INCLUDE_V8_DATE_H_

#include "v8-local-handle.h"  // NOLINT(build/include_directory)
#include "v8-object.h"        // NOLINT(build/include_directory)
#include "v8config.h"         // NOLINT(build/include_directory)

namespace v8 {

class Context;

/**
 * An instance of the built-in Date constructor (ECMA-262, 15.9).
 */
class V8_EXPORT Date : public Object {
 public:
  static V8_WARN_UNUSED_RESULT MaybeLocal<Value> New(Local<Context> context,
                                                     double time);

  static V8_WARN_UNUSED_RESULT MaybeLocal<Value> Parse(
      Local<Context> context,
      Local<String> date_string);

  /**
   * A specialization of Value::NumberValue that is more efficient
   * because we know the structure of this object.
   */
  double ValueOf() const;

  /**
   * Generates ISO string representation.
   */
  v8::Local<v8::String> ToISOString() const;

  /**
   * Generates UTC string representation.
   */
  v8::Local<v8::String> ToUTCString() const;

  V8_INLINE static Date* Cast(Value* value) {
#ifdef V8_ENABLE_CHECKS
    CheckCast(value);
#endif
    return static_cast<Date*>(value);
  }

 private:
  static void CheckCast(Value* obj);
};

}  // namespace v8

#endif  // INCLUDE_V8_DATE_H_
                                                                                                 node-23.7.0/deps/v8/include/v8-debug.h                                                              0000664 0000000 0000000 00000012051 14746647661 0017261 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef INCLUDE_V8_DEBUG_H_
#define INCLUDE_V8_DEBUG_H_

#include <stdint.h>

#include "v8-script.h"  // NOLINT(build/include_directory)
#include "v8config.h"   // NOLINT(build/include_directory)

namespace v8 {

class Isolate;
class String;

/**
 * A single JavaScript stack frame.
 */
class V8_EXPORT StackFrame {
 public:
  /**
   * Returns the source location, 0-based, for the associated function call.
   */
  Location GetLocation() const;

  /**
   * Returns the number, 1-based, of the line for the associate function call.
   * This method will return Message::kNoLineNumberInfo if it is unable to
   * retrieve the line number, or if kLineNumber was not passed as an option
   * when capturing the StackTrace.
   */
  int GetLineNumber() const { return GetLocation().GetLineNumber() + 1; }

  /**
   * Returns the 1-based column offset on the line for the associated function
   * call.
   * This method will return Message::kNoColumnInfo if it is unable to retrieve
   * the column number, or if kColumnOffset was not passed as an option when
   * capturing the StackTrace.
   */
  int GetColumn() const { return GetLocation().GetColumnNumber() + 1; }

  /**
   * Returns the id of the script for the function for this StackFrame.
   * This method will return Message::kNoScriptIdInfo if it is unable to
   * retrieve the script id, or if kScriptId was not passed as an option when
   * capturing the StackTrace.
   */
  int GetScriptId() const;

  /**
   * Returns the name of the resource that contains the script for the
   * function for this StackFrame.
   */
  Local<String> GetScriptName() const;

  /**
   * Returns the name of the resource that contains the script for the
   * function for this StackFrame or sourceURL value if the script name
   * is undefined and its source ends with //# sourceURL=... string or
   * deprecated //@ sourceURL=... string.
   */
  Local<String> GetScriptNameOrSourceURL() const;

  /**
   * Returns the source of the script for the function for this StackFrame.
   */
  Local<String> GetScriptSource() const;

  /**
   * Returns the source mapping URL (if one is present) of the script for
   * the function for this StackFrame.
   */
  Local<String> GetScriptSourceMappingURL() const;

  /**
   * Returns the name of the function associated with this stack frame.
   */
  Local<String> GetFunctionName() const;

  /**
   * Returns whether or not the associated function is compiled via a call to
   * eval().
   */
  bool IsEval() const;

  /**
   * Returns whether or not the associated function is called as a
   * constructor via "new".
   */
  bool IsConstructor() const;

  /**
   * Returns whether or not the associated functions is defined in wasm.
   */
  bool IsWasm() const;

  /**
   * Returns whether or not the associated function is defined by the user.
   */
  bool IsUserJavaScript() const;
};

/**
 * Representation of a JavaScript stack trace. The information collected is a
 * snapshot of the execution stack and the information remains valid after
 * execution continues.
 */
class V8_EXPORT StackTrace {
 public:
  /**
   * Flags that determine what information is placed captured for each
   * StackFrame when grabbing the current stack trace.
   * Note: these options are deprecated and we always collect all available
   * information (kDetailed).
   */
  enum StackTraceOptions {
    kLineNumber = 1,
    kColumnOffset = 1 << 1 | kLineNumber,
    kScriptName = 1 << 2,
    kFunctionName = 1 << 3,
    kIsEval = 1 << 4,
    kIsConstructor = 1 << 5,
    kScriptNameOrSourceURL = 1 << 6,
    kScriptId = 1 << 7,
    kExposeFramesAcrossSecurityOrigins = 1 << 8,
    kOverview = kLineNumber | kColumnOffset | kScriptName | kFunctionName,
    kDetailed = kOverview | kIsEval | kIsConstructor | kScriptNameOrSourceURL
  };

  /**
   * Returns a StackFrame at a particular index.
   */
  Local<StackFrame> GetFrame(Isolate* isolate, uint32_t index) const;

  /**
   * Returns the number of StackFrames.
   */
  int GetFrameCount() const;

  /**
   * Grab a snapshot of the current JavaScript execution stack.
   *
   * \param frame_limit The maximum number of stack frames we want to capture.
   * \param options Enumerates the set of things we will capture for each
   *   StackFrame.
   */
  static Local<StackTrace> CurrentStackTrace(
      Isolate* isolate, int frame_limit, StackTraceOptions options = kDetailed);

  /**
   * Returns the first valid script name or source URL starting at the top of
   * the JS stack. The returned string is either an empty handle if no script
   * name/url was found or a non-zero-length string.
   *
   * This method is equivalent to calling StackTrace::CurrentStackTrace and
   * walking the resulting frames from the beginning until a non-empty script
   * name/url is found. The difference is that this method won't allocate
   * a stack trace.
   */
  static Local<String> CurrentScriptNameOrSourceURL(Isolate* isolate);
};

}  // namespace v8

#endif  // INCLUDE_V8_DEBUG_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/include/v8-embedder-heap.h                                                      0000664 0000000 0000000 00000005516 14746647661 0020665 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        