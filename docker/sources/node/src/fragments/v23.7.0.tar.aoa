sequential string.
  bool internalized = IsInternalizedString(*object_, cage_base);
  if (IsExternalOneByteString(*object_, cage_base)) {
    map = internalized ? roots.internalized_one_byte_string_map()
                       : roots.seq_one_byte_string_map();
    allocation_size = SeqOneByteString::SizeFor(length);
    content_size = length * kCharSize;
    resource = reinterpret_cast<const uint8_t*>(
        Cast<ExternalOneByteString>(string)->resource()->data());
  } else {
    map = internalized ? roots.internalized_two_byte_string_map()
                       : roots.seq_two_byte_string_map();
    allocation_size = SeqTwoByteString::SizeFor(length);
    content_size = length * kShortSize;
    resource = reinterpret_cast<const uint8_t*>(
        Cast<ExternalTwoByteString>(string)->resource()->data());
  }

  SnapshotSpace space = SnapshotSpace::kOld;
  SerializePrologue(space, allocation_size, map);

  // Output the rest of the imaginary string.
  int bytes_to_output = allocation_size - HeapObject::kHeaderSize;
  DCHECK(IsAligned(bytes_to_output, kTaggedSize));
  int slots_to_output = bytes_to_output >> kTaggedSizeLog2;

  // Output raw data header. Do not bother with common raw length cases here.
  sink_->Put(kVariableRawData, "RawDataForString");
  sink_->PutUint30(slots_to_output, "length");

  // Serialize string header (except for map).
  uint8_t* string_start = reinterpret_cast<uint8_t*>(string->address());
  for (size_t i = sizeof(HeapObjectLayout); i < sizeof(SeqString); i++) {
    sink_->Put(string_start[i], "StringHeader");
  }

  // Serialize string content.
  sink_->PutRaw(resource, content_size, "StringContent");

  // Since the allocation size is rounded up to object alignment, there
  // maybe left-over bytes that need to be padded.
  size_t padding_size = allocation_size - sizeof(SeqString) - content_size;
  DCHECK(0 <= padding_size && padding_size < kObjectAlignment);
  for (size_t i = 0; i < padding_size; i++) {
    sink_->Put(static_cast<uint8_t>(0), "StringPadding");
  }
}

// Clear and later restore the next link in the weak cell or allocation site.
// TODO(all): replace this with proper iteration of weak slots in serializer.
class V8_NODISCARD UnlinkWeakNextScope {
 public:
  explicit UnlinkWeakNextScope(Heap* heap, Tagged<HeapObject> object) {
    Isolate* isolate = heap->isolate();
    if (IsAllocationSite(object, isolate) &&
        Cast<AllocationSite>(object)->HasWeakNext()) {
      object_ = object;
      next_ = Cast<AllocationSite>(object)->weak_next();
      Cast<AllocationSite>(object)->set_weak_next(
          ReadOnlyRoots(isolate).undefined_value());
    }
  }

  ~UnlinkWeakNextScope() {
    if (next_ == Smi::zero()) return;
    Cast<AllocationSite>(object_)->set_weak_next(next_, UPDATE_WRITE_BARRIER);
  }

 private:
  Tagged<HeapObject> object_;
  Tagged<Object> next_ = Smi::zero();
  DISALLOW_GARBAGE_COLLECTION(no_gc_)
};

void Serializer::ObjectSerializer::Serialize(SlotType slot_type) {
  RecursionScope recursion(serializer_);

  {
    DisallowGarbageCollection no_gc;
    Tagged<HeapObject> raw = *object_;
    // Defer objects as "pending" if they cannot be serialized now, or if we
    // exceed a certain recursion depth. Some objects cannot be deferred.
    bool should_defer =
        recursion.ExceedsMaximum() || serializer_->MustBeDeferred(raw);
    if (should_defer && CanBeDeferred(raw, slot_type)) {
      if (v8_flags.trace_serializer) {
        PrintF(" Deferring heap object: ");
        ShortPrint(*object_);
        PrintF("\n");
      }
      // Deferred objects are considered "pending".
      serializer_->RegisterObjectIsPending(raw);
      serializer_->PutPendingForwardReference(
          *serializer_->forward_refs_per_pending_object_.Find(raw));
      serializer_->QueueDeferredObject(raw);
      return;
    } else {
      if (v8_flags.trace_serializer && recursion.ExceedsMaximum()) {
        PrintF(" Exceeding max recursion depth by %d for: ",
               recursion.ExceedsMaximumBy());
        ShortPrint(*object_);
        PrintF("\n");
      }
    }

    if (v8_flags.trace_serializer) {
      PrintF(" Encoding heap object: ");
      ShortPrint(*object_);
      PrintF("\n");
    }
  }

  PtrComprCageBase cage_base(isolate());
  InstanceType instance_type = object_->map(cage_base)->instance_type();
  if (InstanceTypeChecker::IsExternalString(instance_type)) {
    SerializeExternalString();
    return;
  }
  if (InstanceTypeChecker::IsJSTypedArray(instance_type)) {
    SerializeJSTypedArray();
    return;
  }
  if (InstanceTypeChecker::IsJSArrayBuffer(instance_type)) {
    SerializeJSArrayBuffer();
    return;
  }
  if (InstanceTypeChecker::IsScript(instance_type)) {
    // Clear cached line ends & compiled lazy function positions.
    Cast<Script>(object_)->set_line_ends(Smi::zero());
    Cast<Script>(object_)->set_compiled_lazy_function_positions(
        ReadOnlyRoots(isolate()).undefined_value());
  }

#if V8_ENABLE_WEBASSEMBLY
  // The padding for wasm null is a free space filler. We put it into the roots
  // table to be able to skip its payload when serializing the read only heap
  // in the ReadOnlyHeapImageSerializer.
  DCHECK_IMPLIES(
      !object_->SafeEquals(ReadOnlyRoots(isolate()).wasm_null_padding()),
      !IsFreeSpaceOrFiller(*object_, cage_base));
#else
  DCHECK(!IsFreeSpaceOrFiller(*object_, cage_base));
#endif

  SerializeObject();
}

namespace {
SnapshotSpace GetSnapshotSpace(Tagged<HeapObject> object) {
  if (V8_ENABLE_THIRD_PARTY_HEAP_BOOL) {
    if (IsInstructionStream(object)) {
      return SnapshotSpace::kCode;
    } else if (ReadOnlyHeap::Contains(object)) {
      return SnapshotSpace::kReadOnlyHeap;
    } else {
      return SnapshotSpace::kOld;
    }
  } else if (ReadOnlyHeap::Contains(object)) {
    return SnapshotSpace::kReadOnlyHeap;
  } else {
    AllocationSpace heap_space =
        MutablePageMetadata::FromHeapObject(object)->owner_identity();
    // Large code objects are not supported and cannot be expressed by
    // SnapshotSpace.
    DCHECK_NE(heap_space, CODE_LO_SPACE);
    switch (heap_space) {
      case OLD_SPACE:
      // Young generation objects are tenured, as objects that have survived
      // until snapshot building probably deserve to be considered 'old'.
      case NEW_SPACE:
      // Large objects (young and old) are encoded as simply 'old' snapshot
      // obects, as "normal" objects vs large objects is a heap implementation
      // detail and isn't relevant to the snapshot.
      case NEW_LO_SPACE:
      case LO_SPACE:
      // Shared objects are currently encoded as 'old' snapshot objects. This
      // basically duplicates shared heap objects for each isolate again.
      case SHARED_SPACE:
      case SHARED_LO_SPACE:
        return SnapshotSpace::kOld;
      case CODE_SPACE:
        return SnapshotSpace::kCode;
      case TRUSTED_SPACE:
      case TRUSTED_LO_SPACE:
        return SnapshotSpace::kTrusted;
      // Shared objects are currently encoded as 'trusteds' snapshot objects.
      // This basically duplicates shared trusted heap objects for each isolate
      // again.
      case SHARED_TRUSTED_SPACE:
      case SHARED_TRUSTED_LO_SPACE:
        return SnapshotSpace::kTrusted;
      case CODE_LO_SPACE:
      case RO_SPACE:
        UNREACHABLE();
    }
  }
}
}  // namespace

void Serializer::ObjectSerializer::SerializeObject() {
  Tagged<Map> map = object_->map(serializer_->cage_base());
  int size = object_->SizeFromMap(map);

  // Descriptor arrays have complex element weakness, that is dependent on the
  // maps pointing to them. During deserialization, this can cause them to get
  // prematurely trimmed one of their owners isn't deserialized yet. We work
  // around this by forcing all descriptor arrays to be serialized as "strong",
  // i.e. no custom weakness, and "re-weaken" them in the deserializer once
  // deserialization completes.
  //
  // See also `Deserializer::WeakenDescriptorArrays`.
  if (map == ReadOnlyRoots(isolate()).descriptor_array_map()) {
    map = ReadOnlyRoots(isolate()).strong_descriptor_array_map();
  }
  SnapshotSpace space = GetSnapshotSpace(*object_);
  SerializePrologue(space, size, map);

  // Serialize the rest of the object.
  CHECK_EQ(0, bytes_processed_so_far_);
  bytes_processed_so_far_ = kTaggedSize;

  SerializeContent(map, size);
}

void Serializer::ObjectSerializer::SerializeDeferred() {
  const SerializerReference* back_reference =
      serializer_->reference_map()->LookupReference(object_);

  if (back_reference != nullptr) {
    if (v8_flags.trace_serializer) {
      PrintF(" Deferred heap object ");
      ShortPrint(*object_);
      PrintF(" was already serialized\n");
    }
    return;
  }

  if (v8_flags.trace_serializer) {
    PrintF(" Encoding deferred heap object\n");
  }
  Serialize(SlotType::kAnySlot);
}

void Serializer::ObjectSerializer::SerializeContent(Tagged<Map> map, int size) {
  Tagged<HeapObject> raw = *object_;
  UnlinkWeakNextScope unlink_weak_next(isolate()->heap(), raw);
  // Iterate references first.
  raw->IterateBody(map, size, this);
  // Then output data payload, if any.
  OutputRawData(raw.address() + size);
}

void Serializer::ObjectSerializer::VisitPointers(Tagged<HeapObject> host,
                                                 ObjectSlot start,
                                                 ObjectSlot end) {
  VisitPointers(host, MaybeObjectSlot(start), MaybeObjectSlot(end));
}

void Serializer::ObjectSerializer::VisitPointers(Tagged<HeapObject> host,
                                                 MaybeObjectSlot start,
                                                 MaybeObjectSlot end) {
  HandleScope scope(isolate());
  PtrComprCageBase cage_base(isolate());
  DisallowGarbageCollection no_gc;

  MaybeObjectSlot current = start;
  while (current < end) {
    while (current < end && current.load(cage_base).IsSmi()) {
      ++current;
    }
    if (current < end) {
      OutputRawData(current.address());
    }
    // TODO(ishell): Revisit this change once we stick to 32-bit compressed
    // tagged values.
    while (current < end && current.load(cage_base).IsCleared()) {
      sink_->Put(kClearedWeakReference, "ClearedWeakReference");
      bytes_processed_so_far_ += kTaggedSize;
      ++current;
    }
    Tagged<HeapObject> current_contents;
    HeapObjectReferenceType reference_type;
    while (current < end && current.load(cage_base).GetHeapObject(
                                &current_contents, &reference_type)) {
      // Write a weak prefix if we need it. This has to be done before the
      // potential pending object serialization.
      if (reference_type == HeapObjectReferenceType::WEAK) {
        sink_->Put(kWeakPrefix, "WeakReference");
      }

      Handle<HeapObject> obj = handle(current_contents, isolate());
      if (serializer_->SerializePendingObject(*obj)) {
        bytes_processed_so_far_ += kTaggedSize;
        ++current;
        continue;
      }

      RootIndex root_index;
      // Compute repeat count and write repeat prefix if applicable.
      // Repeats are not subject to the write barrier so we can only use
      // immortal immovable root members.
      MaybeObjectSlot repeat_end = current + 1;
      if (repeat_end < end &&
          serializer_->root_index_map()->Lookup(*obj, &root_index) &&
          RootsTable::IsImmortalImmovable(root_index) &&
          current.load(cage_base) == repeat_end.load(cage_base) &&
          reference_type == HeapObjectReferenceType::STRONG) {
        DCHECK(!Heap::InYoungGeneration(*obj));
        while (repeat_end < end &&
               repeat_end.load(cage_base) == current.load(cage_base)) {
          repeat_end++;
        }
        int repeat_count = static_cast<int>(repeat_end - current);
        current = repeat_end;
        bytes_processed_so_far_ += repeat_count * kTaggedSize;
        serializer_->PutRepeat(repeat_count);
      } else {
        bytes_processed_so_far_ += kTaggedSize;
        ++current;
      }
      // Now write the object itself.
      serializer_->SerializeObject(obj, SlotType::kAnySlot);
    }
  }
}

void Serializer::ObjectSerializer::VisitInstructionStreamPointer(
    Tagged<Code> host, InstructionStreamSlot slot) {
  DCHECK(!host->has_instruction_stream());
}

// All of these visitor functions are unreachable since we don't serialize
// InstructionStream objects anymore.
void Serializer::ObjectSerializer::VisitEmbeddedPointer(
    Tagged<InstructionStream> host, RelocInfo* rinfo) {
  UNREACHABLE();
}

void Serializer::ObjectSerializer::VisitExternalReference(
    Tagged<InstructionStream> host, RelocInfo* rinfo) {
  UNREACHABLE();
}

void Serializer::ObjectSerializer::VisitInternalReference(
    Tagged<InstructionStream> host, RelocInfo* rinfo) {
  UNREACHABLE();
}

void Serializer::ObjectSerializer::VisitOffHeapTarget(
    Tagged<InstructionStream> host, RelocInfo* rinfo) {
  UNREACHABLE();
}

void Serializer::ObjectSerializer::VisitCodeTarget(
    Tagged<InstructionStream> host, RelocInfo* rinfo) {
  UNREACHABLE();
}

void Serializer::ObjectSerializer::OutputExternalReference(
    Address target, int target_size, bool sandboxify, ExternalPointerTag tag) {
  DCHECK_LE(target_size, sizeof(target));  // Must fit in Address.
  DCHECK_IMPLIES(sandboxify, V8_ENABLE_SANDBOX_BOOL);
  DCHECK_IMPLIES(sandboxify, tag != kExternalPointerNullTag);
  DCHECK_NE(tag, kAnyExternalPointerTag);
  ExternalReferenceEncoder::Value encoded_reference;
  bool encoded_successfully;

  if (serializer_->allow_unknown_external_references_for_testing()) {
    encoded_successfully =
        serializer_->TryEncodeExternalReference(target).To(&encoded_reference);
  } else {
    encoded_reference = serializer_->EncodeExternalReference(target);
    encoded_successfully = true;
  }

  if (!encoded_successfully) {
    // In this case the serialized snapshot will not be used in a different
    // Isolate and thus the target address will not change between
    // serialization and deserialization. We can serialize seen external
    // references verbatim.
    CHECK(serializer_->allow_unknown_external_references_for_testing());
    CHECK(IsAligned(target_size, kTaggedSize));
    CHECK_LE(target_size, kFixedRawDataCount * kTaggedSize);
    if (sandboxify) {
      CHECK_EQ(target_size, kSystemPointerSize);
      sink_->Put(kSandboxedRawExternalReference, "SandboxedRawReference");
      sink_->PutRaw(reinterpret_cast<uint8_t*>(&target), target_size,
                    "raw pointer");
    } else {
      // Encode as FixedRawData instead of RawExternalReference as the target
      // may be less than kSystemPointerSize large.
      int size_in_tagged = target_size >> kTaggedSizeLog2;
      sink_->Put(FixedRawDataWithSize::Encode(size_in_tagged), "FixedRawData");
      sink_->PutRaw(reinterpret_cast<uint8_t*>(&target), target_size,
                    "raw pointer");
    }
  } else if (encoded_reference.is_from_api()) {
    if (sandboxify) {
      sink_->Put(kSandboxedApiReference, "SandboxedApiRef");
    } else {
      sink_->Put(kApiReference, "ApiRef");
    }
    sink_->PutUint30(encoded_reference.index(), "reference index");
  } else {
    if (sandboxify) {
      sink_->Put(kSandboxedExternalReference, "SandboxedExternalRef");
    } else {
      sink_->Put(kExternalReference, "ExternalRef");
    }
    sink_->PutUint30(encoded_reference.index(), "reference index");
  }
  if (sandboxify) {
    sink_->PutUint30(static_cast<uint32_t>(tag >> kExternalPointerTagShift),
                     "external pointer tag");
  }
}

void Serializer::ObjectSerializer::VisitCppHeapPointer(
    Tagged<HeapObject> host, CppHeapPointerSlot slot) {
  PtrComprCageBase cage_base(isolate());
  // Currently there's only very limited support for CppHeapPointerSlot
  // serialization as it's only used for API wrappers.
  //
  // We serialize the slot as initialized-but-unused slot.  The actual API
  // wrapper serialization is implemented in
  // `ContextSerializer::SerializeApiWrapperFields()`.
  DCHECK(IsJSApiWrapperObject(object_->map(cage_base)));
  static_assert(kCppHeapPointerSlotSize % kTaggedSize == 0);
  sink_->Put(
      FixedRawDataWithSize::Encode(kCppHeapPointerSlotSize >> kTaggedSizeLog2),
      "FixedRawData");
  sink_->PutRaw(reinterpret_cast<const uint8_t*>(&kNullCppHeapPointer),
                kCppHeapPointerSlotSize, "empty cpp heap pointer handle");
  bytes_processed_so_far_ += kCppHeapPointerSlotSize;
}

void Serializer::ObjectSerializer::VisitExternalPointer(
    Tagged<HeapObject> host, ExternalPointerSlot slot) {
  PtrComprCageBase cage_base(isolate());
  InstanceType instance_type = object_->map(cage_base)->instance_type();
  if (InstanceTypeChecker::IsForeign(instance_type) ||
      InstanceTypeChecker::IsJSExternalObject(instance_type) ||
      InstanceTypeChecker::IsAccessorInfo(instance_type) ||
      InstanceTypeChecker::IsFunctionTemplateInfo(instance_type)) {
    // Output raw data payload, if any.
    OutputRawData(slot.address());
    Address value = slot.load(isolate());
#ifdef V8_ENABLE_SANDBOX
    // We need to load the actual tag from the table here since the slot may
    // use a generic tag (e.g. kAnyExternalPointerTag) if the concrete tag is
    // unknown by the visitor (for example the case for Foreigns).
    ExternalPointerHandle handle = slot.Relaxed_LoadHandle();
    ExternalPointerTag tag = isolate()->external_pointer_table().GetTag(handle);
#else
    ExternalPointerTag tag = kExternalPointerNullTag;
#endif  // V8_ENABLE_SANDBOX
    const bool sandboxify = V8_ENABLE_SANDBOX_BOOL;
    OutputExternalReference(value, kSystemPointerSize, sandboxify, tag);
    bytes_processed_so_far_ += kExternalPointerSlotSize;
  } else {
    // Serialization of external references in other objects is handled
    // elsewhere or not supported.
    DCHECK(
        // Serialization of external pointers stored in EmbedderDataArray
        // is not supported yet, mostly because it's not used.
        InstanceTypeChecker::IsEmbedderDataArray(instance_type) ||
        // See ObjectSerializer::SerializeJSTypedArray().
        InstanceTypeChecker::IsJSTypedArray(instance_type) ||
        // See ObjectSerializer::SerializeJSArrayBuffer().
        InstanceTypeChecker::IsJSArrayBuffer(instance_type) ||
        // See ObjectSerializer::SerializeExternalString().
        InstanceTypeChecker::IsExternalString(instance_type) ||
        // See ObjectSerializer::SanitizeNativeContextScope.
        InstanceTypeChecker::IsNativeContext(instance_type) ||
        // Serialization of external pointers stored in
        // JSSynchronizationPrimitive is not supported.
        // TODO(v8:12547): JSSynchronizationPrimitives should also be sanitized
        // to always be serialized in an unlocked state.
        InstanceTypeChecker::IsJSSynchronizationPrimitive(instance_type) ||
        // See ContextSerializer::SerializeObjectWithEmbedderFields().
        (InstanceTypeChecker::IsJSObject(instance_type) &&
         Cast<JSObject>(host)->GetEmbedderFieldCount() > 0));
  }
}

void Serializer::ObjectSerializer::VisitIndirectPointer(
    Tagged<HeapObject> host, IndirectPointerSlot slot,
    IndirectPointerMode mode) {
#ifdef V8_ENABLE_SANDBOX
  // If the slot is empty (i.e. contains a null handle), then we can just skip
  // it since in that case the correct action is to encode the null handle as
  // raw data, which will automatically happen if the slot is skipped here.
  if (slot.IsEmpty()) return;

  // If necessary, output any raw data preceeding this slot.
  OutputRawData(slot.address());

  // The slot must be properly initialized at this point, so will always contain
  // a reference to a HeapObject.
  Handle<HeapObject> slot_value(Cast<HeapObject>(slot.load(isolate())),
                                isolate());
  CHECK(IsHeapObject(*slot_value));
  bytes_processed_so_far_ += kIndirectPointerSize;

  // Currently we cannot see pending objects here, but we may need to support
  // them in the future. They should already be supported by the deserializer.
  CHECK(!serializer_->SerializePendingObject(*slot_value));
  sink_->Put(kIndirectPointerPrefix, "IndirectPointer");
  serializer_->SerializeObject(slot_value, SlotType::kAnySlot);
#else
  UNREACHABLE();
#endif
}

void Serializer::ObjectSerializer::VisitTrustedPointerTableEntry(
    Tagged<HeapObject> host, IndirectPointerSlot slot) {
#ifdef V8_ENABLE_SANDBOX
  // These fields only exist on the ExposedTrustedObject class, and they are
  // located directly after the Map word.
  DCHECK_EQ(bytes_processed_so_far_,
            ExposedTrustedObject::kSelfIndirectPointerOffset);

  // Nothing to do here. We already emitted the kInitializeSelfIndirectPointer
  // after processing the Map word in SerializePrologue.
  bytes_processed_so_far_ += kIndirectPointerSize;
#else
  UNREACHABLE();
#endif
}

void Serializer::ObjectSerializer::VisitProtectedPointer(
    Tagged<TrustedObject> host, ProtectedPointerSlot slot) {
  Tagged<Object> content = slot.load(isolate());

  // Similar to the indirect pointer case, if the slot is empty (i.e. contains
  // Smi::zero()), then we skip it here.
  if (content == Smi::zero()) return;
  DCHECK(!IsSmi(content));

  // If necessary, output any raw data preceeding this slot.
  OutputRawData(slot.address());

  Handle<HeapObject> object(Cast<HeapObject>(content), isolate());
  bytes_processed_so_far_ += kTaggedSize;

  // Currently we cannot see pending objects here, but we may need to support
  // them in the future. They should already be supported by the deserializer.
  CHECK(!serializer_->SerializePendingObject(*object));
  sink_->Put(kProtectedPointerPrefix, "ProtectedPointer");
  serializer_->SerializeObject(object, SlotType::kAnySlot);
}

void Serializer::ObjectSerializer::VisitJSDispatchTableEntry(
    Tagged<HeapObject> host, JSDispatchHandle handle) {
#ifdef V8_ENABLE_LEAPTIERING
  // New dispatch table entries will be allocated during deserialization if
  // necessary. Here we just serialize an empty handle.
  // TODO(saelo): we could also emit a kInitializeJSDispatchHandle opcode here
  // and then allocate a dispatch entry during deserialization when we
  // encounter that. That way we don't need to hook into object post
  // processing. If the dispatch handle is empty, we would just skip it here
  // (and would then serialize the raw null handle, which is correct).
  // TODO(saelo): we might want to call OutputRawData here, but for that we
  // first need to pass the slot address to this method (e.g. as part of a
  // JSDispatchHandleSlot struct).
  static_assert(kJSDispatchHandleSize % kTaggedSize == 0);
  sink_->Put(
      FixedRawDataWithSize::Encode(kJSDispatchHandleSize >> kTaggedSizeLog2),
      "FixedRawData");
  sink_->PutRaw(reinterpret_cast<const uint8_t*>(&kNullJSDispatchHandle),
                kJSDispatchHandleSize, "empty js dispatch handle");
  bytes_processed_so_far_ += kJSDispatchHandleSize;
#else
  UNREACHABLE();
#endif  // V8_ENABLE_LEAPTIERING
}
namespace {

// Similar to OutputRawData, but substitutes the given field with the given
// value instead of reading it from the object.
void OutputRawWithCustomField(SnapshotByteSink* sink, Address object_start,
                              int written_so_far, int bytes_to_write,
                              int field_offset, int field_size,
                              const uint8_t* field_value) {
  int offset = field_offset - written_so_far;
  if (0 <= offset && offset < bytes_to_write) {
    DCHECK_GE(bytes_to_write, offset + field_size);
    sink->PutRaw(reinterpret_cast<uint8_t*>(object_start + written_so_far),
                 offset, "Bytes");
    sink->PutRaw(field_value, field_size, "Bytes");
    written_so_far += offset + field_size;
    bytes_to_write -= offset + field_size;
    sink->PutRaw(reinterpret_cast<uint8_t*>(object_start + written_so_far),
                 bytes_to_write, "Bytes");
  } else {
    sink->PutRaw(reinterpret_cast<uint8_t*>(object_start + written_so_far),
                 bytes_to_write, "Bytes");
  }
}
}  // anonymous namespace

void Serializer::ObjectSerializer::OutputRawData(Address up_to) {
  Address object_start = object_->address();
  int base = bytes_processed_so_far_;
  int up_to_offset = static_cast<int>(up_to - object_start);
  int to_skip = up_to_offset - bytes_processed_so_far_;
  int bytes_to_output = to_skip;
  DCHECK(IsAligned(bytes_to_output, kTaggedSize));
  int tagged_to_output = bytes_to_output / kTaggedSize;
  bytes_processed_so_far_ += to_skip;
  DCHECK_GE(to_skip, 0);
  if (bytes_to_output != 0) {
    DCHECK(to_skip == bytes_to_output);
    if (tagged_to_output <= kFixedRawDataCount) {
      sink_->Put(FixedRawDataWithSize::Encode(tagged_to_output),
                 "FixedRawData");
    } else {
      sink_->Put(kVariableRawData, "VariableRawData");
      sink_->PutUint30(tagged_to_output, "length");
    }
#ifdef MEMORY_SANITIZER
    // Check that we do not serialize uninitialized memory.
    __msan_check_mem_is_initialized(
        reinterpret_cast<void*>(object_start + base), bytes_to_output);
#endif  // MEMORY_SANITIZER
    PtrComprCageBase cage_base(isolate_);
    if (IsSharedFunctionInfo(*object_, cage_base)) {
      // The bytecode age field can be changed by GC concurrently.
      static_assert(SharedFunctionInfo::kAgeSize == kUInt16Size);
      uint16_t field_value = 0;
      OutputRawWithCustomField(sink_, object_start, base, bytes_to_output,
                               SharedFunctionInfo::kAgeOffset,
                               sizeof(field_value),
                               reinterpret_cast<uint8_t*>(&field_value));
    } else if (IsDescriptorArray(*object_, cage_base)) {
      // The number of marked descriptors field can be changed by GC
      // concurrently.
      const auto field_value = DescriptorArrayMarkingState::kInitialGCState;
      static_assert(sizeof(field_value) == DescriptorArray::kSizeOfRawGcState);
      OutputRawWithCustomField(sink_, object_start, base, bytes_to_output,
                               DescriptorArray::kRawGcStateOffset,
                               sizeof(field_value),
                               reinterpret_cast<const uint8_t*>(&field_value));
    } else if (IsCode(*object_, cage_base)) {
#ifdef V8_ENABLE_SANDBOX
      // When the sandbox is enabled, this field contains the handle to this
      // Code object's code pointer table entry. This will be recomputed after
      // deserialization.
      static uint8_t field_value[kIndirectPointerSize] = {0};
      OutputRawWithCustomField(sink_, object_start, base, bytes_to_output,
                               Code::kSelfIndirectPointerOffset,
                               sizeof(field_value), field_value);
#else
      // In this case, instruction_start field contains a raw value that will
      // similarly be recomputed after deserialization, so write zeros to keep
      // the snapshot deterministic.
      static uint8_t field_value[kSystemPointerSize] = {0};
      OutputRawWithCustomField(sink_, object_start, base, bytes_to_output,
                               Code::kInstructionStartOffset,
                               sizeof(field_value), field_value);
#endif  // V8_ENABLE_SANDBOX
    } else if (IsSeqString(*object_)) {
      // SeqStrings may contain padding. Serialize the padding bytes as 0s to
      // make the snapshot content deterministic.
      SeqString::DataAndPaddingSizes sizes =
          Cast<SeqString>(*object_)->GetDataAndPaddingSizes();
      DCHECK_EQ(bytes_to_output, sizes.data_size - base + sizes.padding_size);
      int data_bytes_to_output = sizes.data_size - base;
      sink_->PutRaw(reinterpret_cast<uint8_t*>(object_start + base),
                    data_bytes_to_output, "SeqStringData");
      sink_->PutN(sizes.padding_size, 0, "SeqStringPadding");
    } else {
      sink_->PutRaw(reinterpret_cast<uint8_t*>(object_start + base),
                    bytes_to_output, "Bytes");
    }
  }
}

Serializer::HotObjectsList::HotObjectsList(Heap* heap) : heap_(heap) {
  strong_roots_entry_ = heap->RegisterStrongRoots(
      "Serializer::HotObjectsList", FullObjectSlot(&circular_queue_[0]),
      FullObjectSlot(&circular_queue_[kSize]));
}
Serializer::HotObjectsList::~HotObjectsList() {
  heap_->UnregisterStrongRoots(strong_roots_entry_);
}

Handle<FixedArray> ObjectCacheIndexMap::Values(Isolate* isolate) {
  if (size() == 0) {
    return isolate->factory()->empty_fixed_array();
  }
  Handle<FixedArray> externals = isolate->factory()->NewFixedArray(size());
  DisallowGarbageCollection no_gc;
  Tagged<FixedArray> raw = *externals;
  IdentityMap<int, base::DefaultAllocationPolicy>::IteratableScope it_scope(
      &map_);
  for (auto it = it_scope.begin(); it != it_scope.end(); ++it) {
    raw->set(*it.entry(), it.key());
  }

  return externals;
}

bool Serializer::SerializeReadOnlyObjectReference(Tagged<HeapObject> obj,
                                                  SnapshotByteSink* sink) {
  if (!ReadOnlyHeap::Contains(obj)) return false;

  // For objects on the read-only heap, never serialize the object, but instead
  // create a back reference that encodes the page number as the chunk_index and
  // the offset within the page as the chunk_offset.
  Address address = obj.address();
  MemoryChunkMetadata* chunk = MemoryChunkMetadata::FromAddress(address);
  uint32_t chunk_index = 0;
  ReadOnlySpace* const read_only_space = isolate()->heap()->read_only_space();
  DCHECK(!read_only_space->writable());
  for (ReadOnlyPageMetadata* page : read_only_space->pages()) {
    if (chunk == page) break;
    ++chunk_index;
  }
  uint32_t chunk_offset = static_cast<uint32_t>(chunk->Offset(address));
  sink->Put(kReadOnlyHeapRef, "ReadOnlyHeapRef");
  sink->PutUint30(chunk_index, "ReadOnlyHeapRefChunkIndex");
  sink->PutUint30(chunk_offset, "ReadOnlyHeapRefChunkOffset");
  return true;
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                   node-23.7.0/deps/v8/src/snapshot/serializer.h                                                       0000664 0000000 0000000 00000045105 14746647661 0021022 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_SNAPSHOT_SERIALIZER_H_
#define V8_SNAPSHOT_SERIALIZER_H_

#include "src/codegen/external-reference-encoder.h"
#include "src/common/assert-scope.h"
#include "src/execution/isolate.h"
#include "src/handles/global-handles.h"
#include "src/logging/log.h"
#include "src/objects/abstract-code.h"
#include "src/objects/bytecode-array.h"
#include "src/objects/instruction-stream.h"
#include "src/objects/objects.h"
#include "src/snapshot/serializer-deserializer.h"
#include "src/snapshot/snapshot-source-sink.h"
#include "src/snapshot/snapshot.h"
#include "src/utils/identity-map.h"

namespace v8 {
namespace internal {

class CodeAddressMap : public CodeEventLogger {
 public:
  explicit CodeAddressMap(Isolate* isolate) : CodeEventLogger(isolate) {
    CHECK(isolate->logger()->AddListener(this));
  }

  ~CodeAddressMap() override {
    CHECK(isolate_->logger()->RemoveListener(this));
  }

  void CodeMoveEvent(Tagged<InstructionStream> from,
                     Tagged<InstructionStream> to) override {
    address_to_name_map_.Move(from.address(), to.address());
  }
  void BytecodeMoveEvent(Tagged<BytecodeArray> from,
                         Tagged<BytecodeArray> to) override {
    address_to_name_map_.Move(from.address(), to.address());
  }

  void CodeDisableOptEvent(Handle<AbstractCode> code,
                           Handle<SharedFunctionInfo> shared) override {}

  const char* Lookup(Address address) {
    return address_to_name_map_.Lookup(address);
  }

 private:
  class NameMap {
   public:
    NameMap() : impl_() {}
    NameMap(const NameMap&) = delete;
    NameMap& operator=(const NameMap&) = delete;

    ~NameMap() {
      for (base::HashMap::Entry* p = impl_.Start(); p != nullptr;
           p = impl_.Next(p)) {
        DeleteArray(static_cast<const char*>(p->value));
      }
    }

    void Insert(Address code_address, const char* name, int name_size) {
      base::HashMap::Entry* entry = FindOrCreateEntry(code_address);
      if (entry->value == nullptr) {
        entry->value = CopyName(name, name_size);
      }
    }

    const char* Lookup(Address code_address) {
      base::HashMap::Entry* entry = FindEntry(code_address);
      return (entry != nullptr) ? static_cast<const char*>(entry->value)
                                : nullptr;
    }

    void Remove(Address code_address) {
      base::HashMap::Entry* entry = FindEntry(code_address);
      if (entry != nullptr) {
        DeleteArray(static_cast<char*>(entry->value));
        RemoveEntry(entry);
      }
    }

    void Move(Address from, Address to) {
      if (from == to) return;
      base::HashMap::Entry* from_entry = FindEntry(from);
      DCHECK_NOT_NULL(from_entry);
      void* value = from_entry->value;
      RemoveEntry(from_entry);
      base::HashMap::Entry* to_entry = FindOrCreateEntry(to);
      DCHECK_NULL(to_entry->value);
      to_entry->value = value;
    }

   private:
    static char* CopyName(const char* name, int name_size) {
      char* result = NewArray<char>(name_size + 1);
      for (int i = 0; i < name_size; ++i) {
        char c = name[i];
        if (c == '\0') c = ' ';
        result[i] = c;
      }
      result[name_size] = '\0';
      return result;
    }

    base::HashMap::Entry* FindOrCreateEntry(Address code_address) {
      return impl_.LookupOrInsert(reinterpret_cast<void*>(code_address),
                                  ComputeAddressHash(code_address));
    }

    base::HashMap::Entry* FindEntry(Address code_address) {
      return impl_.Lookup(reinterpret_cast<void*>(code_address),
                          ComputeAddressHash(code_address));
    }

    void RemoveEntry(base::HashMap::Entry* entry) {
      impl_.Remove(entry->key, entry->hash);
    }

    base::HashMap impl_;
  };

  void LogRecordedBuffer(Tagged<AbstractCode> code,
                         MaybeHandle<SharedFunctionInfo>, const char* name,
                         int length) override {
    DisallowGarbageCollection no_gc;
    address_to_name_map_.Insert(code.address(), name, length);
  }

#if V8_ENABLE_WEBASSEMBLY
  void LogRecordedBuffer(const wasm::WasmCode* code, const char* name,
                         int length) override {
    UNREACHABLE();
  }
#endif  // V8_ENABLE_WEBASSEMBLY

  NameMap address_to_name_map_;
};

class ObjectCacheIndexMap {
 public:
  explicit ObjectCacheIndexMap(Heap* heap) : map_(heap), next_index_(0) {}
  ObjectCacheIndexMap(const ObjectCacheIndexMap&) = delete;
  ObjectCacheIndexMap& operator=(const ObjectCacheIndexMap&) = delete;

  // If |obj| is in the map, immediately return true.  Otherwise add it to the
  // map and return false. In either case set |*index_out| to the index
  // associated with the map.
  bool LookupOrInsert(Tagged<HeapObject> obj, int* index_out) {
    auto find_result = map_.FindOrInsert(obj);
    if (!find_result.already_exists) {
      *find_result.entry = next_index_++;
    }
    *index_out = *find_result.entry;
    return find_result.already_exists;
  }
  bool LookupOrInsert(DirectHandle<HeapObject> obj, int* index_out) {
    return LookupOrInsert(*obj, index_out);
  }

  bool Lookup(Tagged<HeapObject> obj, int* index_out) const {
    int* index = map_.Find(obj);
    if (index == nullptr) {
      return false;
    }
    *index_out = *index;
    return true;
  }

  Handle<FixedArray> Values(Isolate* isolate);

  int size() const { return next_index_; }

 private:
  IdentityMap<int, base::DefaultAllocationPolicy> map_;
  int next_index_;
};

class Serializer : public SerializerDeserializer {
 public:
  Serializer(Isolate* isolate, Snapshot::SerializerFlags flags);
  ~Serializer() override { DCHECK_EQ(unresolved_forward_refs_, 0); }
  Serializer(const Serializer&) = delete;
  Serializer& operator=(const Serializer&) = delete;

  const std::vector<uint8_t>* Payload() const { return sink_.data(); }

  bool ReferenceMapContains(DirectHandle<HeapObject> o) {
    return reference_map()->LookupReference(o) != nullptr;
  }

  Isolate* isolate() const { return isolate_; }

  // The pointer compression cage base value used for decompression of all
  // tagged values except references to InstructionStream objects.
  PtrComprCageBase cage_base() const {
#if V8_COMPRESS_POINTERS
    return cage_base_;
#else
    return PtrComprCageBase{};
#endif  // V8_COMPRESS_POINTERS
  }

  int TotalAllocationSize() const;

 protected:
  using PendingObjectReferences = std::vector<int>*;

  class ObjectSerializer;
  class V8_NODISCARD RecursionScope {
   public:
    explicit RecursionScope(Serializer* serializer) : serializer_(serializer) {
      serializer_->recursion_depth_++;
    }
    ~RecursionScope() { serializer_->recursion_depth_--; }
    bool ExceedsMaximum() const {
      return serializer_->recursion_depth_ > kMaxRecursionDepth;
    }
    int ExceedsMaximumBy() const {
      return serializer_->recursion_depth_ - kMaxRecursionDepth;
    }

   private:
    static const int kMaxRecursionDepth = 32;
    Serializer* serializer_;
  };

  // Compares obj with not_mapped_symbol root. When V8_EXTERNAL_CODE_SPACE is
  // enabled it compares full pointers.
  V8_INLINE bool IsNotMappedSymbol(Tagged<HeapObject> obj) const;

  void SerializeDeferredObjects();
  void SerializeObject(Handle<HeapObject> o, SlotType slot_type);
  virtual void SerializeObjectImpl(Handle<HeapObject> o,
                                   SlotType slot_type) = 0;

  virtual bool MustBeDeferred(Tagged<HeapObject> object);

  void VisitRootPointers(Root root, const char* description,
                         FullObjectSlot start, FullObjectSlot end) override;
  void SerializeRootObject(FullObjectSlot slot);

  void PutRoot(RootIndex root_index);
  void PutSmiRoot(FullObjectSlot slot);
  void PutBackReference(Tagged<HeapObject> object,
                        SerializerReference reference);
  void PutAttachedReference(SerializerReference reference);
  void PutNextChunk(SnapshotSpace space);
  void PutRepeat(int repeat_count);

  // Emit a marker noting that this slot is a forward reference to the an
  // object which has not yet been serialized.
  void PutPendingForwardReference(PendingObjectReferences& ref);
  // Resolve the given previously registered forward reference to the current
  // object.
  void ResolvePendingForwardReference(int obj);

  // Returns true if the object was successfully serialized as a root.
  bool SerializeRoot(Tagged<HeapObject> obj);

  // Returns true if the object was successfully serialized as hot object.
  bool SerializeHotObject(Tagged<HeapObject> obj);

  // Returns true if the object was successfully serialized as back reference.
  bool SerializeBackReference(Tagged<HeapObject> obj);

  // Returns true if the object was successfully serialized as pending object.
  bool SerializePendingObject(Tagged<HeapObject> obj);

  // Returns true if the given heap object is a bytecode handler code object.
  bool ObjectIsBytecodeHandler(Tagged<HeapObject> obj) const;

  ExternalReferenceEncoder::Value EncodeExternalReference(Address addr);

  Maybe<ExternalReferenceEncoder::Value> TryEncodeExternalReference(
      Address addr) {
    return external_reference_encoder_.TryEncode(addr);
  }

  bool SerializeReadOnlyObjectReference(Tagged<HeapObject> obj,
                                        SnapshotByteSink* sink);

  // GetInt reads 4 bytes at once, requiring padding at the end.
  // Use padding_offset to specify the space you want to use after padding.
  void Pad(int padding_offset = 0);

  // We may not need the code address map for logging for every instance
  // of the serializer.  Initialize it on demand.
  void InitializeCodeAddressMap();

  Tagged<InstructionStream> CopyCode(Tagged<InstructionStream> istream);

  void QueueDeferredObject(Tagged<HeapObject> obj) {
    DCHECK_NULL(reference_map_.LookupReference(obj));
    deferred_objects_.Push(obj);
  }

  // Register that the the given object shouldn't be immediately serialized, but
  // will be serialized later and any references to it should be pending forward
  // references.
  void RegisterObjectIsPending(Tagged<HeapObject> obj);

  // Resolve the given pending object reference with the current object.
  void ResolvePendingObject(Tagged<HeapObject> obj);

  void OutputStatistics(const char* name);

  void CountAllocation(Tagged<Map> map, int size, SnapshotSpace space);

#ifdef DEBUG
  void PushStack(DirectHandle<HeapObject> o) { stack_.Push(*o); }
  void PopStack();
  void PrintStack();
  void PrintStack(std::ostream&);
#endif  // DEBUG

  SerializerReferenceMap* reference_map() { return &reference_map_; }
  const RootIndexMap* root_index_map() const { return &root_index_map_; }

  SnapshotByteSink sink_;  // Used directly by subclasses.

  bool allow_unknown_external_references_for_testing() const {
    return (flags_ & Snapshot::kAllowUnknownExternalReferencesForTesting) != 0;
  }
  bool allow_active_isolate_for_testing() const {
    return (flags_ & Snapshot::kAllowActiveIsolateForTesting) != 0;
  }

  bool reconstruct_read_only_and_shared_object_caches_for_testing() const {
    return (flags_ &
            Snapshot::kReconstructReadOnlyAndSharedObjectCachesForTesting) != 0;
  }

  bool deferred_objects_empty() { return deferred_objects_.size() == 0; }

 protected:
  bool serializer_tracks_serialization_statistics() const {
    return serializer_tracks_serialization_statistics_;
  }
  void set_serializer_tracks_serialization_statistics(bool v) {
    serializer_tracks_serialization_statistics_ = v;
  }

 private:
  // A circular queue of hot objects. This is added to in the same order as in
  // Deserializer::HotObjectsList, but this stores the objects as an array of
  // raw addresses that are considered strong roots. This allows objects to be
  // added to the list without having to extend their handle's lifetime.
  //
  // We should never allow this class to return Handles to objects in the queue,
  // as the object in the queue may change if kSize other objects are added to
  // the queue during that Handle's lifetime.
  class HotObjectsList {
   public:
    explicit HotObjectsList(Heap* heap);
    ~HotObjectsList();
    HotObjectsList(const HotObjectsList&) = delete;
    HotObjectsList& operator=(const HotObjectsList&) = delete;

    void Add(Tagged<HeapObject> object) {
      circular_queue_[index_] = object.ptr();
      index_ = (index_ + 1) & kSizeMask;
    }

    static const int kNotFound = -1;

    int Find(Tagged<HeapObject> object) {
      DCHECK(!AllowGarbageCollection::IsAllowed());
      for (int i = 0; i < kSize; i++) {
        if (circular_queue_[i] == object.ptr()) {
          return i;
        }
      }
      return kNotFound;
    }

   private:
    static const int kSize = kHotObjectCount;
    static const int kSizeMask = kSize - 1;
    static_assert(base::bits::IsPowerOfTwo(kSize));
    Heap* heap_;
    StrongRootsEntry* strong_roots_entry_;
    Address circular_queue_[kSize] = {kNullAddress};
    int index_ = 0;
  };

  // Disallow GC during serialization.
  // TODO(leszeks, v8:10815): Remove this constraint.
  DISALLOW_GARBAGE_COLLECTION(no_gc_)

  Isolate* isolate_;
#if V8_COMPRESS_POINTERS
  const PtrComprCageBase cage_base_;
#endif  // V8_COMPRESS_POINTERS
  HotObjectsList hot_objects_;
  SerializerReferenceMap reference_map_;
  ExternalReferenceEncoder external_reference_encoder_;
  RootIndexMap root_index_map_;
  std::unique_ptr<CodeAddressMap> code_address_map_;
  std::vector<uint8_t> code_buffer_;
  GlobalHandleVector<HeapObject>
      deferred_objects_;  // To handle stack overflow.
  int num_back_refs_ = 0;

  // Objects which have started being serialized, but haven't yet been allocated
  // with the allocator, are considered "pending". References to them don't have
  // an allocation to backref to, so instead they are registered as pending
  // forward references, which are resolved once the object is allocated.
  //
  // Forward references are registered in a deterministic order, and can
  // therefore be identified by an incrementing integer index, which is
  // effectively an index into a vector of the currently registered forward
  // refs. The references in this vector might not be resolved in order, so we
  // can only clear it (and reset the indices) when there are no unresolved
  // forward refs remaining.
  int next_forward_ref_id_ = 0;
  int unresolved_forward_refs_ = 0;
  IdentityMap<PendingObjectReferences, base::DefaultAllocationPolicy>
      forward_refs_per_pending_object_;

  // Used to keep track of the off-heap backing stores used by TypedArrays/
  // ArrayBuffers. Note that the index begins at 1 and not 0, because when a
  // TypedArray has an on-heap backing store, the backing_store pointer in the
  // corresponding ArrayBuffer will be null, which makes it indistinguishable
  // from index 0.
  uint32_t seen_backing_stores_index_ = 1;

  int recursion_depth_ = 0;
  const Snapshot::SerializerFlags flags_;

  bool serializer_tracks_serialization_statistics_ = true;
  size_t allocation_size_[kNumberOfSnapshotSpaces] = {0};
#ifdef OBJECT_PRINT
// Verbose serialization_statistics output is only enabled conditionally.
#define VERBOSE_SERIALIZATION_STATISTICS
#endif
#ifdef VERBOSE_SERIALIZATION_STATISTICS
  static constexpr int kInstanceTypes = LAST_TYPE + 1;
  std::unique_ptr<int[]> instance_type_count_[kNumberOfSnapshotSpaces];
  std::unique_ptr<size_t[]> instance_type_size_[kNumberOfSnapshotSpaces];
#endif  // VERBOSE_SERIALIZATION_STATISTICS

#ifdef DEBUG
  GlobalHandleVector<HeapObject> back_refs_;
  GlobalHandleVector<HeapObject> stack_;
#endif  // DEBUG
};

class Serializer::ObjectSerializer : public ObjectVisitor {
 public:
  ObjectSerializer(Serializer* serializer, Handle<HeapObject> obj,
                   SnapshotByteSink* sink)
      : isolate_(serializer->isolate()),
        serializer_(serializer),
        object_(obj),
        sink_(sink),
        bytes_processed_so_far_(0) {
#ifdef DEBUG
    serializer_->PushStack(obj);
#endif  // DEBUG
  }
  ~ObjectSerializer() override {
#ifdef DEBUG
    serializer_->PopStack();
#endif  // DEBUG
  }
  void Serialize(SlotType slot_type);
  void SerializeObject();
  void SerializeDeferred();
  void VisitPointers(Tagged<HeapObject> host, ObjectSlot start,
                     ObjectSlot end) override;
  void VisitPointers(Tagged<HeapObject> host, MaybeObjectSlot start,
                     MaybeObjectSlot end) override;
  void VisitInstructionStreamPointer(Tagged<Code> host,
                                     InstructionStreamSlot slot) override;
  void VisitEmbeddedPointer(Tagged<InstructionStream> host,
                            RelocInfo* target) override;
  void VisitExternalReference(Tagged<InstructionStream> host,
                              RelocInfo* rinfo) override;
  void VisitInternalReference(Tagged<InstructionStream> host,
                              RelocInfo* rinfo) override;
  void VisitCodeTarget(Tagged<InstructionStream> host,
                       RelocInfo* target) override;
  void VisitOffHeapTarget(Tagged<InstructionStream> host,
                          RelocInfo* target) override;

  void VisitExternalPointer(Tagged<HeapObject> host,
                            ExternalPointerSlot slot) override;
  void VisitIndirectPointer(Tagged<HeapObject> host, IndirectPointerSlot slot,
                            IndirectPointerMode mode) override;
  void VisitTrustedPointerTableEntry(Tagged<HeapObject> host,
                                     IndirectPointerSlot slot) override;
  void VisitProtectedPointer(Tagged<TrustedObject> host,
                             ProtectedPointerSlot slot) override;
  void VisitCppHeapPointer(Tagged<HeapObject> host,
                           CppHeapPointerSlot slot) override;
  void VisitJSDispatchTableEntry(Tagged<HeapObject> host,
                                 JSDispatchHandle handle) override;

  Isolate* isolate() { return isolate_; }

 private:
  void SerializePrologue(SnapshotSpace space, int size, Tagged<Map> map);

  // This function outputs or skips the raw data between the last pointer and
  // up to the current position.
  void SerializeContent(Tagged<Map> map, int size);
  void OutputExternalReference(Address target, int target_size, bool sandboxify,
                               ExternalPointerTag tag);
  void OutputRawData(Address up_to);
  uint32_t SerializeBackingStore(void* backing_store, uint32_t byte_length,
                                 Maybe<uint32_t> max_byte_length);
  void SerializeJSTypedArray();
  void SerializeJSArrayBuffer();
  void SerializeExternalString();
  void SerializeExternalStringAsSequentialString();

  Isolate* isolate_;
  Serializer* serializer_;
  Handle<HeapObject> object_;
  SnapshotByteSink* sink_;
  int bytes_processed_so_far_;
};

}  // namespace internal
}  // namespace v8

#endif  // V8_SNAPSHOT_SERIALIZER_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/src/snapshot/shared-heap-deserializer.cc                                        0000664 0000000 0000000 00000003327 14746647661 0023650 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/snapshot/shared-heap-deserializer.h"

#include "src/heap/heap-inl.h"

namespace v8 {
namespace internal {

void SharedHeapDeserializer::DeserializeIntoIsolate() {
  // Don't deserialize into client Isolates. If there are client Isolates, the
  // shared heap object cache should already be populated.
  if (isolate()->has_shared_space() && !isolate()->is_shared_space_isolate()) {
    DCHECK(!isolate()->shared_heap_object_cache()->empty());
    return;
  }

  DCHECK(isolate()->shared_heap_object_cache()->empty());
  HandleScope scope(isolate());

  IterateSharedHeapObjectCache(isolate(), this);
  DeserializeStringTable();
  DeserializeDeferredObjects();

  if (should_rehash()) {
    // The hash seed has already been initialized in ReadOnlyDeserializer, thus
    // there is no need to call `isolate()->heap()->InitializeHashSeed();`.
    Rehash();
  }
}

void SharedHeapDeserializer::DeserializeStringTable() {
  // See SharedHeapSerializer::SerializeStringTable.

  DCHECK(isolate()->OwnsStringTables());

  // Get the string table size.
  const int length = source()->GetUint30();

  // .. and the contents.
  DirectHandleVector<String> strings(isolate());
  strings.reserve(length);
  for (int i = 0; i < length; ++i) {
    strings.emplace_back(Cast<String>(ReadObject()));
  }

  StringTable* t = isolate()->string_table();
  DCHECK_EQ(t->NumberOfElements(), 0);
  t->InsertForIsolateDeserialization(
      isolate(), base::VectorOf(strings.data(), strings.size()));
  DCHECK_EQ(t->NumberOfElements(), length);
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/src/snapshot/shared-heap-deserializer.h                                         0000664 0000000 0000000 00000002165 14746647661 0023511 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_SNAPSHOT_SHARED_HEAP_DESERIALIZER_H_
#define V8_SNAPSHOT_SHARED_HEAP_DESERIALIZER_H_

#include "src/snapshot/deserializer.h"
#include "src/snapshot/snapshot-data.h"

namespace v8 {
namespace internal {

// Initializes objects in the shared isolate that are not already included in
// the startup snapshot.
class SharedHeapDeserializer final : public Deserializer<Isolate> {
 public:
  explicit SharedHeapDeserializer(Isolate* isolate,
                                  const SnapshotData* shared_heap_data,
                                  bool can_rehash)
      : Deserializer(isolate, shared_heap_data->Payload(),
                     shared_heap_data->GetMagicNumber(), false, can_rehash) {}

  // Depending on runtime flags, deserialize shared heap objects into the
  // Isolate.
  void DeserializeIntoIsolate();

 private:
  void DeserializeStringTable();
};

}  // namespace internal
}  // namespace v8

#endif  // V8_SNAPSHOT_SHARED_HEAP_DESERIALIZER_H_
                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/src/snapshot/shared-heap-serializer.cc                                          0000664 0000000 0000000 00000020041 14746647661 0023327 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/snapshot/shared-heap-serializer.h"

#include "src/heap/read-only-heap.h"
#include "src/objects/objects-inl.h"
#include "src/snapshot/read-only-serializer.h"

namespace v8 {
namespace internal {

// static
bool SharedHeapSerializer::CanBeInSharedOldSpace(Tagged<HeapObject> obj) {
  if (ReadOnlyHeap::Contains(obj)) return false;
  if (IsString(obj)) {
    return IsInternalizedString(obj) ||
           String::IsInPlaceInternalizable(Cast<String>(obj));
  }
  return false;
}

// static
bool SharedHeapSerializer::ShouldBeInSharedHeapObjectCache(
    Tagged<HeapObject> obj) {
  // To keep the shared heap object cache lean, only include objects that should
  // not be duplicated. Currently, that is only internalized strings. In-place
  // internalizable strings will still be allocated in the shared heap by the
  // deserializer, but do not need to be kept alive forever in the cache.
  if (CanBeInSharedOldSpace(obj)) {
    if (IsInternalizedString(obj)) return true;
  }
  return false;
}

SharedHeapSerializer::SharedHeapSerializer(Isolate* isolate,
                                           Snapshot::SerializerFlags flags)
    : RootsSerializer(isolate, flags, RootIndex::kFirstStrongRoot)
#ifdef DEBUG
      ,
      serialized_objects_(isolate->heap())
#endif
{
  if (ShouldReconstructSharedHeapObjectCacheForTesting()) {
    ReconstructSharedHeapObjectCacheForTesting();
  }
}

SharedHeapSerializer::~SharedHeapSerializer() {
  OutputStatistics("SharedHeapSerializer");
}

void SharedHeapSerializer::FinalizeSerialization() {
  // This is called after serialization of the startup and context snapshots
  // which entries are added to the shared heap object cache. Terminate the
  // cache with an undefined.
  Tagged<Object> undefined = ReadOnlyRoots(isolate()).undefined_value();
  VisitRootPointer(Root::kSharedHeapObjectCache, nullptr,
                   FullObjectSlot(&undefined));

  // When v8_flags.shared_string_table is true, all internalized and
  // internalizable-in-place strings are in the shared heap.
  SerializeStringTable(isolate()->string_table());
  SerializeDeferredObjects();
  Pad();

#ifdef DEBUG
  // Check that all serialized object are in shared heap and not RO. RO objects
  // should be in the RO snapshot.
  IdentityMap<int, base::DefaultAllocationPolicy>::IteratableScope it_scope(
      &serialized_objects_);
  for (auto it = it_scope.begin(); it != it_scope.end(); ++it) {
    Tagged<HeapObject> obj = Cast<HeapObject>(it.key());
    CHECK(CanBeInSharedOldSpace(obj));
    CHECK(!ReadOnlyHeap::Contains(obj));
  }
#endif
}

bool SharedHeapSerializer::SerializeUsingSharedHeapObjectCache(
    SnapshotByteSink* sink, Handle<HeapObject> obj) {
  if (!ShouldBeInSharedHeapObjectCache(*obj)) return false;
  int cache_index = SerializeInObjectCache(obj);

  // When testing deserialization of a snapshot from a live Isolate where there
  // is also a shared Isolate, the shared object cache needs to be extended
  // because the live isolate may have had new internalized strings that were
  // not present in the startup snapshot to be serialized.
  if (ShouldReconstructSharedHeapObjectCacheForTesting()) {
    std::vector<Tagged<Object>>* existing_cache =
        isolate()->shared_space_isolate()->shared_heap_object_cache();
    const size_t existing_cache_size = existing_cache->size();
    // This is strictly < because the existing cache contains the terminating
    // undefined value, which the reconstructed cache does not.
    DCHECK_LT(base::checked_cast<size_t>(cache_index), existing_cache_size);
    if (base::checked_cast<size_t>(cache_index) == existing_cache_size - 1) {
      ReadOnlyRoots roots(isolate());
      DCHECK(IsUndefined(existing_cache->back(), roots));
      existing_cache->back() = *obj;
      existing_cache->push_back(roots.undefined_value());
    }
  }

  sink->Put(kSharedHeapObjectCache, "SharedHeapObjectCache");
  sink->PutUint30(cache_index, "shared_heap_object_cache_index");
  return true;
}

void SharedHeapSerializer::SerializeStringTable(StringTable* string_table) {
  // A StringTable is serialized as:
  //
  //   N : int
  //   string 1
  //   string 2
  //   ...
  //   string N
  //
  // Notably, the hashmap structure, including empty and deleted elements, is
  // not serialized.

  sink_.PutUint30(string_table->NumberOfElements(),
                  "String table number of elements");

  // Custom RootVisitor which walks the string table, but only serializes the
  // string entries. This is an inline class to be able to access the non-public
  // SerializeObject method.
  class SharedHeapSerializerStringTableVisitor : public RootVisitor {
   public:
    explicit SharedHeapSerializerStringTableVisitor(
        SharedHeapSerializer* serializer)
        : serializer_(serializer) {}

    void VisitRootPointers(Root root, const char* description,
                           FullObjectSlot start, FullObjectSlot end) override {
      UNREACHABLE();
    }

    void VisitRootPointers(Root root, const char* description,
                           OffHeapObjectSlot start,
                           OffHeapObjectSlot end) override {
      DCHECK_EQ(root, Root::kStringTable);
      Isolate* isolate = serializer_->isolate();
      for (OffHeapObjectSlot current = start; current < end; ++current) {
        Tagged<Object> obj = current.load(isolate);
        if (IsHeapObject(obj)) {
          DCHECK(IsInternalizedString(obj));
          serializer_->SerializeObject(handle(Cast<HeapObject>(obj), isolate),
                                       SlotType::kAnySlot);
        }
      }
    }

   private:
    SharedHeapSerializer* serializer_;
  };

  SharedHeapSerializerStringTableVisitor string_table_visitor(this);
  isolate()->string_table()->IterateElements(&string_table_visitor);
}

void SharedHeapSerializer::SerializeObjectImpl(Handle<HeapObject> obj,
                                               SlotType slot_type) {
  // Objects in the shared heap cannot depend on per-Isolate roots but can
  // depend on RO roots since sharing objects requires sharing the RO space.
  DCHECK(CanBeInSharedOldSpace(*obj) || ReadOnlyHeap::Contains(*obj));
  {
    DisallowGarbageCollection no_gc;
    Tagged<HeapObject> raw = *obj;
    if (SerializeHotObject(raw)) return;
    if (IsRootAndHasBeenSerialized(raw) && SerializeRoot(raw)) return;
  }
  if (SerializeReadOnlyObjectReference(*obj, &sink_)) return;
  {
    DisallowGarbageCollection no_gc;
    Tagged<HeapObject> raw = *obj;
    if (SerializeBackReference(raw)) return;
    CheckRehashability(raw);

    DCHECK(!ReadOnlyHeap::Contains(raw));
  }

  ObjectSerializer object_serializer(this, obj, &sink_);
  object_serializer.Serialize(slot_type);

#ifdef DEBUG
  CHECK_NULL(serialized_objects_.Find(obj));
  // There's no "IdentitySet", so use an IdentityMap with a value that is
  // later ignored.
  serialized_objects_.Insert(obj, 0);
#endif
}

bool SharedHeapSerializer::ShouldReconstructSharedHeapObjectCacheForTesting()
    const {
  // When the live Isolate being serialized is not a client Isolate, there's no
  // need to reconstruct the shared heap object cache because it is not actually
  // shared.
  return reconstruct_read_only_and_shared_object_caches_for_testing() &&
         isolate()->has_shared_space();
}

void SharedHeapSerializer::ReconstructSharedHeapObjectCacheForTesting() {
  std::vector<Tagged<Object>>* cache =
      isolate()->shared_space_isolate()->shared_heap_object_cache();
  // Don't reconstruct the final element, which is always undefined and marks
  // the end of the cache, since serializing the live Isolate may extend the
  // shared object cache.
  for (size_t i = 0, size = cache->size(); i < size - 1; i++) {
    Handle<HeapObject> obj(Cast<HeapObject>(cache->at(i)), isolate());
    DCHECK(ShouldBeInSharedHeapObjectCache(*obj));
    int cache_index = SerializeInObjectCache(obj);
    USE(cache_index);
    DCHECK_EQ(cache_index, i);
  }
  DCHECK(IsUndefined(cache->back(), isolate()));
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/src/snapshot/shared-heap-serializer.h                                           0000664 0000000 0000000 00000004026 14746647661 0023176 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_SNAPSHOT_SHARED_HEAP_SERIALIZER_H_
#define V8_SNAPSHOT_SHARED_HEAP_SERIALIZER_H_

#include "src/snapshot/roots-serializer.h"

namespace v8 {
namespace internal {

class HeapObject;

// SharedHeapSerializer serializes objects that should be in the shared heap in
// the shared Isolate during startup. Currently the shared heap is only in use
// behind flags (e.g. --shared-string-table). When it is not in use, its
// contents are deserialized into each Isolate.
class V8_EXPORT_PRIVATE SharedHeapSerializer : public RootsSerializer {
 public:
  SharedHeapSerializer(Isolate* isolate, Snapshot::SerializerFlags flags);
  ~SharedHeapSerializer() override;
  SharedHeapSerializer(const SharedHeapSerializer&) = delete;
  SharedHeapSerializer& operator=(const SharedHeapSerializer&) = delete;

  // Terminate the shared heap object cache with an undefined value and
  // serialize the string table..
  void FinalizeSerialization();

  // If |obj| can be serialized in the shared heap snapshot then add it to the
  // shared heap object cache if not already present and emit a
  // SharedHeapObjectCache bytecode into |sink|. Returns whether this was
  // successful.
  bool SerializeUsingSharedHeapObjectCache(SnapshotByteSink* sink,
                                           Handle<HeapObject> obj);

  static bool CanBeInSharedOldSpace(Tagged<HeapObject> obj);

  static bool ShouldBeInSharedHeapObjectCache(Tagged<HeapObject> obj);

 private:
  bool ShouldReconstructSharedHeapObjectCacheForTesting() const;

  void ReconstructSharedHeapObjectCacheForTesting();

  void SerializeStringTable(StringTable* string_table);

  void SerializeObjectImpl(Handle<HeapObject> obj, SlotType slot_type) override;

#ifdef DEBUG
  IdentityMap<int, base::DefaultAllocationPolicy> serialized_objects_;
#endif
};

}  // namespace internal
}  // namespace v8

#endif  // V8_SNAPSHOT_SHARED_HEAP_SERIALIZER_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/src/snapshot/snapshot-compression.cc                                            0000664 0000000 0000000 00000006750 14746647661 0023210 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/snapshot/snapshot-compression.h"

#include "src/base/platform/elapsed-timer.h"
#include "src/utils/memcopy.h"
#include "src/utils/utils.h"
#include "third_party/zlib/google/compression_utils_portable.h"

namespace v8 {
namespace internal {

uint32_t GetUncompressedSize(const Bytef* compressed_data) {
  uint32_t size;
  MemCopy(&size, compressed_data, sizeof(size));
  return size;
}

SnapshotData SnapshotCompression::Compress(
    const SnapshotData* uncompressed_data) {
  SnapshotData snapshot_data;
  base::ElapsedTimer timer;
  if (v8_flags.profile_deserialization) timer.Start();

  static_assert(sizeof(Bytef) == 1, "");
  const uLongf input_size =
      static_cast<uLongf>(uncompressed_data->RawData().size());
  uint32_t payload_length =
      static_cast<uint32_t>(uncompressed_data->RawData().size());

  uLongf compressed_data_size = compressBound(input_size);

  // Allocating >= the final amount we will need.
  snapshot_data.AllocateData(
      static_cast<uint32_t>(sizeof(payload_length) + compressed_data_size));

  uint8_t* compressed_data =
      const_cast<uint8_t*>(snapshot_data.RawData().begin());
  // Since we are doing raw compression (no zlib or gzip headers), we need to
  // manually store the uncompressed size.
  MemCopy(compressed_data, &payload_length, sizeof(payload_length));

  CHECK_EQ(
      zlib_internal::CompressHelper(
          zlib_internal::ZRAW, compressed_data + sizeof(payload_length),
          &compressed_data_size,
          reinterpret_cast<const Bytef*>(uncompressed_data->RawData().begin()),
          input_size, Z_DEFAULT_COMPRESSION, nullptr, nullptr),
      Z_OK);

  // Reallocating to exactly the size we need.
  snapshot_data.Resize(static_cast<uint32_t>(compressed_data_size) +
                       sizeof(payload_length));
  DCHECK_EQ(payload_length,
            GetUncompressedSize(snapshot_data.RawData().begin()));

  if (v8_flags.profile_deserialization) {
    double ms = timer.Elapsed().InMillisecondsF();
    PrintF("[Compressing %d bytes took %0.3f ms]\n", payload_length, ms);
  }
  return snapshot_data;
}

SnapshotData SnapshotCompression::Decompress(
    base::Vector<const uint8_t> compressed_data) {
  SnapshotData snapshot_data;
  base::ElapsedTimer timer;
  if (v8_flags.profile_deserialization) timer.Start();

  const Bytef* input_bytef =
      reinterpret_cast<const Bytef*>(compressed_data.begin());

  // Since we are doing raw compression (no zlib or gzip headers), we need to
  // manually retrieve the uncompressed size.
  uint32_t uncompressed_payload_length = GetUncompressedSize(input_bytef);
  input_bytef += sizeof(uncompressed_payload_length);

  snapshot_data.AllocateData(uncompressed_payload_length);

  uLongf uncompressed_size = uncompressed_payload_length;
  CHECK_EQ(zlib_internal::UncompressHelper(
               zlib_internal::ZRAW,
               const_cast<Bytef*>(snapshot_data.RawData().begin()),
               &uncompressed_size, input_bytef,
               static_cast<uLong>(compressed_data.size() -
                                  sizeof(uncompressed_payload_length))),
           Z_OK);

  if (v8_flags.profile_deserialization) {
    double ms = timer.Elapsed().InMillisecondsF();
    PrintF("[Decompressing %d bytes took %0.3f ms]\n",
           uncompressed_payload_length, ms);
  }
  return snapshot_data;
}

}  // namespace internal
}  // namespace v8
                        node-23.7.0/deps/v8/src/snapshot/snapshot-compression.h                                             0000664 0000000 0000000 00000001314 14746647661 0023041 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_SNAPSHOT_SNAPSHOT_COMPRESSION_H_
#define V8_SNAPSHOT_SNAPSHOT_COMPRESSION_H_

#include "src/base/vector.h"
#include "src/snapshot/snapshot-data.h"

namespace v8 {
namespace internal {

class SnapshotCompression : public AllStatic {
 public:
  V8_EXPORT_PRIVATE static SnapshotData Compress(
      const SnapshotData* uncompressed_data);
  V8_EXPORT_PRIVATE static SnapshotData Decompress(
      base::Vector<const uint8_t> compressed_data);
};

}  // namespace internal
}  // namespace v8

#endif  // V8_SNAPSHOT_SNAPSHOT_COMPRESSION_H_
                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/src/snapshot/snapshot-data.cc                                                   0000664 0000000 0000000 00000002770 14746647661 0021556 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/snapshot/snapshot-data.h"

#include "src/common/assert-scope.h"
#include "src/snapshot/serializer.h"

namespace v8 {
namespace internal {

void SerializedData::AllocateData(uint32_t size) {
  DCHECK(!owns_data_);
  data_ = NewArray<uint8_t>(size);
  size_ = size;
  owns_data_ = true;
}

// static
constexpr uint32_t SerializedData::kMagicNumber;

SnapshotData::SnapshotData(const Serializer* serializer) {
  DisallowGarbageCollection no_gc;
  const std::vector<uint8_t>* payload = serializer->Payload();

  // Calculate sizes.
  uint32_t size = kHeaderSize + static_cast<uint32_t>(payload->size());

  // Allocate backing store and create result data.
  AllocateData(size);

  // Zero out pre-payload data. Part of that is only used for padding.
  memset(data_, 0, kHeaderSize);

  // Set header values.
  SetMagicNumber();
  SetHeaderValue(kPayloadLengthOffset, static_cast<int>(payload->size()));

  // Copy serialized data.
  CopyBytes(data_ + kHeaderSize, payload->data(),
            static_cast<size_t>(payload->size()));
}

base::Vector<const uint8_t> SnapshotData::Payload() const {
  const uint8_t* payload = data_ + kHeaderSize;
  uint32_t length = GetHeaderValue(kPayloadLengthOffset);
  DCHECK_EQ(data_ + size_, payload + length);
  return base::Vector<const uint8_t>(payload, length);
}

}  // namespace internal
}  // namespace v8
        node-23.7.0/deps/v8/src/snapshot/snapshot-data.h                                                    0000664 0000000 0000000 00000006422 14746647661 0021416 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_SNAPSHOT_SNAPSHOT_DATA_H_
#define V8_SNAPSHOT_SNAPSHOT_DATA_H_

#include "src/base/bit-field.h"
#include "src/base/memory.h"
#include "src/base/vector.h"
#include "src/codegen/external-reference-table.h"
#include "src/utils/memcopy.h"

namespace v8 {
namespace internal {

// Forward declarations.
class Isolate;
class Serializer;

class SerializedData {
 public:
  SerializedData(uint8_t* data, int size)
      : data_(data), size_(size), owns_data_(false) {}
  SerializedData() : data_(nullptr), size_(0), owns_data_(false) {}
  SerializedData(SerializedData&& other) V8_NOEXCEPT
      : data_(other.data_),
        size_(other.size_),
        owns_data_(other.owns_data_) {
    // Ensure |other| will not attempt to destroy our data in destructor.
    other.owns_data_ = false;
  }
  SerializedData(const SerializedData&) = delete;
  SerializedData& operator=(const SerializedData&) = delete;

  virtual ~SerializedData() {
    if (owns_data_) DeleteArray<uint8_t>(data_);
  }

  uint32_t GetMagicNumber() const { return GetHeaderValue(kMagicNumberOffset); }

  using ChunkSizeBits = base::BitField<uint32_t, 0, 31>;
  using IsLastChunkBits = base::BitField<bool, 31, 1>;

  static constexpr uint32_t kMagicNumberOffset = 0;
  static constexpr uint32_t kMagicNumber =
      0xC0DE0000 ^ ExternalReferenceTable::kSize;

 protected:
  void SetHeaderValue(uint32_t offset, uint32_t value) {
    base::WriteLittleEndianValue(reinterpret_cast<Address>(data_) + offset,
                                 value);
  }

  uint32_t GetHeaderValue(uint32_t offset) const {
    return base::ReadLittleEndianValue<uint32_t>(
        reinterpret_cast<Address>(data_) + offset);
  }

  void AllocateData(uint32_t size);

  void SetMagicNumber() { SetHeaderValue(kMagicNumberOffset, kMagicNumber); }

  uint8_t* data_;
  uint32_t size_;
  bool owns_data_;
};

// Wrapper around reservation sizes and the serialization payload.
class V8_EXPORT_PRIVATE SnapshotData : public SerializedData {
 public:
  // Used when producing.
  explicit SnapshotData(const Serializer* serializer);

  // Used when consuming.
  explicit SnapshotData(const base::Vector<const uint8_t> snapshot)
      : SerializedData(const_cast<uint8_t*>(snapshot.begin()),
                       snapshot.length()) {}

  virtual base::Vector<const uint8_t> Payload() const;

  base::Vector<const uint8_t> RawData() const {
    return base::Vector<const uint8_t>(data_, size_);
  }

 protected:
  // Empty constructor used by SnapshotCompression so it can manually allocate
  // memory.
  SnapshotData() : SerializedData() {}
  friend class SnapshotCompression;

  // Resize used by SnapshotCompression so it can shrink the compressed
  // SnapshotData.
  void Resize(uint32_t size) { size_ = size; }

  // The data header consists of uint32_t-sized entries:
  // [0] magic number and (internal) external reference count
  // [1] payload length
  // ... serialized payload
  static const uint32_t kPayloadLengthOffset = kMagicNumberOffset + kUInt32Size;
  static const uint32_t kHeaderSize = kPayloadLengthOffset + kUInt32Size;
};

}  // namespace internal
}  // namespace v8

#endif  // V8_SNAPSHOT_SNAPSHOT_DATA_H_
                                                                                                                                                                                                                                              node-23.7.0/deps/v8/src/snapshot/snapshot-empty.cc                                                  0000664 0000000 0000000 00000001755 14746647661 0022005 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2006-2008 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Used for building without snapshots.

#include "src/snapshot/snapshot.h"

namespace v8 {
namespace internal {

#ifdef V8_USE_EXTERNAL_STARTUP_DATA
// Dummy implementations of Set*FromFile(..) APIs.
//
// These are meant for use with snapshot-external.cc. Should this file
// be compiled with those options we just supply these dummy implementations
// below. This happens when compiling the mksnapshot utility.
void SetNativesFromFile(StartupData* data) { UNREACHABLE(); }
void SetSnapshotFromFile(StartupData* data) { UNREACHABLE(); }
void ReadNatives() {}
void DisposeNatives() {}
#endif  // V8_USE_EXTERNAL_STARTUP_DATA

const v8::StartupData* Snapshot::DefaultSnapshotBlob() { return nullptr; }
bool Snapshot::ShouldVerifyChecksum(const v8::StartupData* data) {
  return false;
}

}  // namespace internal
}  // namespace v8
                   node-23.7.0/deps/v8/src/snapshot/snapshot-external.cc                                               0000664 0000000 0000000 00000003733 14746647661 0022467 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2006-2008 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Used for building with external snapshots.

#include "src/base/platform/mutex.h"
#include "src/flags/flags.h"
#include "src/init/v8.h"  // for V8::Initialize
#include "src/snapshot/snapshot-source-sink.h"
#include "src/snapshot/snapshot.h"

#ifndef V8_USE_EXTERNAL_STARTUP_DATA
#error snapshot-external.cc is used only for the external snapshot build.
#endif  // V8_USE_EXTERNAL_STARTUP_DATA


namespace v8 {
namespace internal {

static base::LazyMutex external_startup_data_mutex = LAZY_MUTEX_INITIALIZER;
static v8::StartupData external_startup_blob = {nullptr, 0};
#ifdef V8_TARGET_OS_ANDROID
static bool external_startup_checksum_verified = false;
#endif

void SetSnapshotFromFile(StartupData* snapshot_blob) {
  base::MutexGuard lock_guard(external_startup_data_mutex.Pointer());
  DCHECK(snapshot_blob);
  DCHECK(snapshot_blob->data);
  DCHECK_GT(snapshot_blob->raw_size, 0);
  DCHECK(!external_startup_blob.data);
  DCHECK(Snapshot::SnapshotIsValid(snapshot_blob));
  external_startup_blob = *snapshot_blob;
#ifdef V8_TARGET_OS_ANDROID
  external_startup_checksum_verified = false;
#endif
}

bool Snapshot::ShouldVerifyChecksum(const v8::StartupData* data) {
#ifdef V8_TARGET_OS_ANDROID
  base::MutexGuard lock_guard(external_startup_data_mutex.Pointer());
  if (data != &external_startup_blob) {
    return v8_flags.verify_snapshot_checksum;
  }
  // Verify the external snapshot maximally once per process due to the
  // additional overhead.
  if (external_startup_checksum_verified) return false;
  external_startup_checksum_verified = true;
  return true;
#else
  return v8_flags.verify_snapshot_checksum;
#endif
}

const v8::StartupData* Snapshot::DefaultSnapshotBlob() {
  base::MutexGuard lock_guard(external_startup_data_mutex.Pointer());
  return &external_startup_blob;
}
}  // namespace internal
}  // namespace v8
                                     node-23.7.0/deps/v8/src/snapshot/snapshot-source-sink.cc                                            0000664 0000000 0000000 00000003347 14746647661 0023110 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/snapshot/snapshot-source-sink.h"

#include <vector>

#include "src/base/logging.h"
#include "src/handles/handles-inl.h"
#include "src/objects/objects-inl.h"

namespace v8 {
namespace internal {

void SnapshotByteSink::PutN(int number_of_bytes, const uint8_t v,
                            const char* description) {
  data_.insert(data_.end(), number_of_bytes, v);
}

void SnapshotByteSink::PutUint30(uint32_t integer, const char* description) {
  CHECK_LT(integer, 1UL << 30);
  integer <<= 2;
  int bytes = 1;
  if (integer > 0xFF) bytes = 2;
  if (integer > 0xFFFF) bytes = 3;
  if (integer > 0xFFFFFF) bytes = 4;
  integer |= (bytes - 1);
  Put(static_cast<uint8_t>(integer & 0xFF), "IntPart1");
  if (bytes > 1) Put(static_cast<uint8_t>((integer >> 8) & 0xFF), "IntPart2");
  if (bytes > 2) Put(static_cast<uint8_t>((integer >> 16) & 0xFF), "IntPart3");
  if (bytes > 3) Put(static_cast<uint8_t>((integer >> 24) & 0xFF), "IntPart4");
}

void SnapshotByteSink::PutRaw(const uint8_t* data, int number_of_bytes,
                              const char* description) {
#ifdef MEMORY_SANITIZER
  __msan_check_mem_is_initialized(data, number_of_bytes);
#endif
  data_.insert(data_.end(), data, data + number_of_bytes);
}

void SnapshotByteSink::Append(const SnapshotByteSink& other) {
  data_.insert(data_.end(), other.data_.begin(), other.data_.end());
}

int SnapshotByteSource::GetBlob(const uint8_t** data) {
  int size = GetUint30();
  CHECK_LE(position_ + size, length_);
  *data = &data_[position_];
  Advance(size);
  return size;
}
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/src/snapshot/snapshot-source-sink.h                                             0000664 0000000 0000000 00000010765 14746647661 0022754 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_SNAPSHOT_SNAPSHOT_SOURCE_SINK_H_
#define V8_SNAPSHOT_SNAPSHOT_SOURCE_SINK_H_

#include <utility>
#include <vector>

#include "src/base/atomicops.h"
#include "src/base/logging.h"
#include "src/common/globals.h"
#include "src/utils/utils.h"

namespace v8 {
namespace internal {


/**
 * Source to read snapshot and builtins files from.
 *
 * Note: Memory ownership remains with callee.
 */
class SnapshotByteSource final {
 public:
  SnapshotByteSource(const char* data, int length)
      : data_(reinterpret_cast<const uint8_t*>(data)),
        length_(length),
        position_(0) {}

  explicit SnapshotByteSource(base::Vector<const uint8_t> payload)
      : data_(payload.begin()), length_(payload.length()), position_(0) {}

  ~SnapshotByteSource() = default;
  SnapshotByteSource(const SnapshotByteSource&) = delete;
  SnapshotByteSource& operator=(const SnapshotByteSource&) = delete;

  bool HasMore() { return position_ < length_; }

  uint8_t Get() {
    DCHECK(position_ < length_);
    return data_[position_++];
  }

  uint8_t Peek() const {
    DCHECK(position_ < length_);
    return data_[position_];
  }

  void Advance(int by) { position_ += by; }

  void CopyRaw(void* to, int number_of_bytes) {
    DCHECK_LE(position_ + number_of_bytes, length_);
    memcpy(to, data_ + position_, number_of_bytes);
    position_ += number_of_bytes;
  }

  void CopySlots(Address* dest, int number_of_slots) {
    base::AtomicWord* start = reinterpret_cast<base::AtomicWord*>(dest);
    base::AtomicWord* end = start + number_of_slots;
    for (base::AtomicWord* p = start; p < end;
         ++p, position_ += sizeof(base::AtomicWord)) {
      base::AtomicWord val;
      memcpy(&val, data_ + position_, sizeof(base::AtomicWord));
      base::Relaxed_Store(p, val);
    }
  }

#ifdef V8_COMPRESS_POINTERS
  void CopySlots(Tagged_t* dest, int number_of_slots) {
    AtomicTagged_t* start = reinterpret_cast<AtomicTagged_t*>(dest);
    AtomicTagged_t* end = start + number_of_slots;
    for (AtomicTagged_t* p = start; p < end;
         ++p, position_ += sizeof(AtomicTagged_t)) {
      AtomicTagged_t val;
      memcpy(&val, data_ + position_, sizeof(AtomicTagged_t));
      base::Relaxed_Store(p, val);
    }
  }
#endif

  // Decode a uint30 with run-length encoding. Must have been encoded with
  // PutUint30.
  inline uint32_t GetUint30() {
    // This way of decoding variable-length encoded integers does not
    // suffer from branch mispredictions.
    DCHECK_LT(position_ + 3, length_);
    uint32_t answer = data_[position_];
    answer |= data_[position_ + 1] << 8;
    answer |= data_[position_ + 2] << 16;
    answer |= data_[position_ + 3] << 24;
    int bytes = (answer & 3) + 1;
    Advance(bytes);
    uint32_t mask = 0xffffffffu;
    mask >>= 32 - (bytes << 3);
    answer &= mask;
    answer >>= 2;
    return answer;
  }

  uint32_t GetUint32() {
    uint32_t integer;
    CopyRaw(reinterpret_cast<uint8_t*>(&integer), sizeof(integer));
    return integer;
  }

  // Returns length.
  int GetBlob(const uint8_t** data);

  int position() const { return position_; }
  void set_position(int position) { position_ = position; }

  const uint8_t* data() const { return data_; }
  int length() const { return length_; }

 private:
  const uint8_t* data_;
  int length_;
  int position_;
};

/**
 * Sink to write snapshot files to.
 *
 * Users must implement actual storage or i/o.
 */
class SnapshotByteSink {
 public:
  SnapshotByteSink() = default;
  explicit SnapshotByteSink(int initial_size) : data_(initial_size) {}

  ~SnapshotByteSink() = default;

  void Put(uint8_t b, const char* description) { data_.push_back(b); }

  void PutN(int number_of_bytes, const uint8_t v, const char* description);
  // Append a uint30 with run-length encoding. Must be decoded with GetUint30.
  void PutUint30(uint32_t integer, const char* description);
  void PutUint32(uint32_t integer, const char* description) {
    PutRaw(reinterpret_cast<uint8_t*>(&integer), sizeof(integer), description);
  }
  void PutRaw(const uint8_t* data, int number_of_bytes,
              const char* description);

  void Append(const SnapshotByteSink& other);
  int Position() const { return static_cast<int>(data_.size()); }

  const std::vector<uint8_t>* data() const { return &data_; }

 private:
  std::vector<uint8_t> data_;
};

}  // namespace internal
}  // namespace v8

#endif  // V8_SNAPSHOT_SNAPSHOT_SOURCE_SINK_H_
           node-23.7.0/deps/v8/src/snapshot/snapshot-utils.cc                                                  0000664 0000000 0000000 00000002126 14746647661 0022000 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/snapshot/snapshot-utils.h"

#include "src/base/sanitizer/msan.h"

#ifdef V8_USE_ZLIB
#include "third_party/zlib/zlib.h"
#endif

namespace v8 {
namespace internal {

uint32_t Checksum(base::Vector<const uint8_t> payload) {
#ifdef MEMORY_SANITIZER
  // Computing the checksum includes padding bytes for objects like strings.
  // Mark every object as initialized in the code serializer.
  MSAN_MEMORY_IS_INITIALIZED(payload.begin(), payload.length());
#endif  // MEMORY_SANITIZER

#ifdef V8_USE_ZLIB
  // Priming the adler32 call so it can see what CPU features are available.
  adler32(0, nullptr, 0);
  return static_cast<uint32_t>(adler32(0, payload.begin(), payload.length()));
#else
  // Simple Fletcher-32.
  uint32_t sum1 = 0, sum2 = 0;
  for (auto data : payload) {
    sum1 = (sum1 + data) % 65535;
    sum2 = (sum2 + sum1) % 65535;
  }
  return (sum2 << 16 | sum1);
#endif
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/src/snapshot/snapshot-utils.h                                                   0000664 0000000 0000000 00000000771 14746647661 0021646 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_SNAPSHOT_SNAPSHOT_UTILS_H_
#define V8_SNAPSHOT_SNAPSHOT_UTILS_H_

#include "src/base/vector.h"
#include "src/common/globals.h"

namespace v8 {
namespace internal {

V8_EXPORT_PRIVATE uint32_t Checksum(base::Vector<const uint8_t> payload);

}  // namespace internal
}  // namespace v8

#endif  // V8_SNAPSHOT_SNAPSHOT_UTILS_H_
       node-23.7.0/deps/v8/src/snapshot/snapshot.cc                                                        0000664 0000000 0000000 00000134344 14746647661 0020652 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2006-2008 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The common functionality when building with or without snapshots.

#include "src/snapshot/snapshot.h"

#include "src/api/api-inl.h"  // For OpenHandle.
#include "src/baseline/baseline-batch-compiler.h"
#include "src/common/assert-scope.h"
#include "src/execution/local-isolate-inl.h"
#include "src/handles/global-handles-inl.h"
#include "src/heap/local-heap-inl.h"
#include "src/heap/read-only-promotion.h"
#include "src/heap/safepoint.h"
#include "src/init/bootstrapper.h"
#include "src/logging/counters-scopes.h"
#include "src/logging/runtime-call-stats-scope.h"
#include "src/objects/js-regexp-inl.h"
#include "src/snapshot/context-deserializer.h"
#include "src/snapshot/context-serializer.h"
#include "src/snapshot/read-only-serializer.h"
#include "src/snapshot/shared-heap-serializer.h"
#include "src/snapshot/snapshot-utils.h"
#include "src/snapshot/startup-serializer.h"
#include "src/utils/memcopy.h"
#include "src/utils/version.h"

#ifdef V8_SNAPSHOT_COMPRESSION
#include "src/snapshot/snapshot-compression.h"
#endif

namespace v8 {
namespace internal {

namespace {

class SnapshotImpl : public AllStatic {
 public:
  static v8::StartupData CreateSnapshotBlob(
      const SnapshotData* startup_snapshot_in,
      const SnapshotData* read_only_snapshot_in,
      const SnapshotData* shared_heap_snapshot_in,
      const std::vector<SnapshotData*>& context_snapshots_in,
      bool can_be_rehashed);

  static uint32_t ExtractNumContexts(const v8::StartupData* data);
  static uint32_t ExtractContextOffset(const v8::StartupData* data,
                                       uint32_t index);
  static base::Vector<const uint8_t> ExtractStartupData(
      const v8::StartupData* data);
  static base::Vector<const uint8_t> ExtractReadOnlyData(
      const v8::StartupData* data);
  static base::Vector<const uint8_t> ExtractSharedHeapData(
      const v8::StartupData* data);
  static base::Vector<const uint8_t> ExtractContextData(
      const v8::StartupData* data, uint32_t index);

  static uint32_t GetHeaderValue(const v8::StartupData* data, uint32_t offset) {
    DCHECK_NOT_NULL(data);
    DCHECK_LT(offset, static_cast<uint32_t>(data->raw_size));
    return base::ReadLittleEndianValue<uint32_t>(
        reinterpret_cast<Address>(data->data) + offset);
  }
  static void SetHeaderValue(char* data, uint32_t offset, uint32_t value) {
    base::WriteLittleEndianValue(reinterpret_cast<Address>(data) + offset,
                                 value);
  }

  static void CheckVersion(const v8::StartupData* data);

  // Snapshot blob layout:
  // [0] number of contexts N
  // [1] rehashability
  // [2] checksum
  // [3] read-only snapshot checksum
  // [4] (64 bytes) version string
  // [5] offset to readonly
  // [6] offset to shared heap
  // [7] offset to context 0
  // [8] offset to context 1
  // ...
  // ... offset to context N - 1
  // ... startup snapshot data
  // ... read-only snapshot data
  // ... shared heap snapshot data
  // ... context 0 snapshot data
  // ... context 1 snapshot data

  static const uint32_t kNumberOfContextsOffset = 0;
  // TODO(yangguo): generalize rehashing, and remove this flag.
  static const uint32_t kRehashabilityOffset =
      kNumberOfContextsOffset + kUInt32Size;
  static const uint32_t kChecksumOffset = kRehashabilityOffset + kUInt32Size;
  static const uint32_t kReadOnlySnapshotChecksumOffset =
      kChecksumOffset + kUInt32Size;
  static const uint32_t kVersionStringOffset =
      kReadOnlySnapshotChecksumOffset + kUInt32Size;
  static const uint32_t kVersionStringLength = 64;
  static const uint32_t kReadOnlyOffsetOffset =
      kVersionStringOffset + kVersionStringLength;
  static const uint32_t kSharedHeapOffsetOffset =
      kReadOnlyOffsetOffset + kUInt32Size;
  static const uint32_t kFirstContextOffsetOffset =
      kSharedHeapOffsetOffset + kUInt32Size;

  static base::Vector<const uint8_t> ChecksummedContent(
      const v8::StartupData* data) {
    // The hashed region is everything but the header slots up-to-and-including
    // the checksum slot itself.
    // TODO(jgruber): We currently exclude #contexts and rehashability. This
    // seems arbitrary and I think we could shuffle header slot order around to
    // include them, just for consistency.
    static_assert(kReadOnlySnapshotChecksumOffset ==
                  kChecksumOffset + kUInt32Size);
    const uint32_t kChecksumStart = kReadOnlySnapshotChecksumOffset;
    return base::Vector<const uint8_t>(
        reinterpret_cast<const uint8_t*>(data->data + kChecksumStart),
        data->raw_size - kChecksumStart);
  }

  static uint32_t StartupSnapshotOffset(int num_contexts) {
    return POINTER_SIZE_ALIGN(kFirstContextOffsetOffset +
                              num_contexts * kInt32Size);
  }

  static uint32_t ContextSnapshotOffsetOffset(int index) {
    return kFirstContextOffsetOffset + index * kInt32Size;
  }
};

}  // namespace

SnapshotData MaybeDecompress(Isolate* isolate,
                             base::Vector<const uint8_t> snapshot_data) {
#ifdef V8_SNAPSHOT_COMPRESSION
  TRACE_EVENT0("v8", "V8.SnapshotDecompress");
  RCS_SCOPE(isolate, RuntimeCallCounterId::kSnapshotDecompress);
  NestedTimedHistogramScope histogram_timer(
      isolate->counters()->snapshot_decompress());
  return SnapshotCompression::Decompress(snapshot_data);
#else
  return SnapshotData(snapshot_data);
#endif
}

#ifdef DEBUG
bool Snapshot::SnapshotIsValid(const v8::StartupData* snapshot_blob) {
  return SnapshotImpl::ExtractNumContexts(snapshot_blob) > 0;
}
#endif  // DEBUG

bool Snapshot::HasContextSnapshot(Isolate* isolate, size_t index) {
  // Do not use snapshots if the isolate is used to create snapshots.
  const v8::StartupData* blob = isolate->snapshot_blob();
  if (blob == nullptr) return false;
  if (blob->data == nullptr) return false;
  size_t num_contexts =
      static_cast<size_t>(SnapshotImpl::ExtractNumContexts(blob));
  return index < num_contexts;
}

bool Snapshot::VersionIsValid(const v8::StartupData* data) {
  char version[SnapshotImpl::kVersionStringLength];
  memset(version, 0, SnapshotImpl::kVersionStringLength);
  CHECK_LT(
      SnapshotImpl::kVersionStringOffset + SnapshotImpl::kVersionStringLength,
      static_cast<uint32_t>(data->raw_size));
  Version::GetString(
      base::Vector<char>(version, SnapshotImpl::kVersionStringLength));
  return strncmp(version, data->data + SnapshotImpl::kVersionStringOffset,
                 SnapshotImpl::kVersionStringLength) == 0;
}

bool Snapshot::Initialize(Isolate* isolate) {
  if (!isolate->snapshot_available()) return false;

  const v8::StartupData* blob = isolate->snapshot_blob();
  SnapshotImpl::CheckVersion(blob);
  if (Snapshot::ShouldVerifyChecksum(blob)) {
    CHECK(VerifyChecksum(blob));
  }

  base::Vector<const uint8_t> startup_data =
      SnapshotImpl::ExtractStartupData(blob);
  base::Vector<const uint8_t> read_only_data =
      SnapshotImpl::ExtractReadOnlyData(blob);
  base::Vector<const uint8_t> shared_heap_data =
      SnapshotImpl::ExtractSharedHeapData(blob);

  SnapshotData startup_snapshot_data(MaybeDecompress(isolate, startup_data));
  SnapshotData read_only_snapshot_data(
      MaybeDecompress(isolate, read_only_data));
  SnapshotData shared_heap_snapshot_data(
      MaybeDecompress(isolate, shared_heap_data));

  return isolate->InitWithSnapshot(
      &startup_snapshot_data, &read_only_snapshot_data,
      &shared_heap_snapshot_data, ExtractRehashability(blob));
}

MaybeHandle<Context> Snapshot::NewContextFromSnapshot(
    Isolate* isolate, Handle<JSGlobalProxy> global_proxy, size_t context_index,
    DeserializeEmbedderFieldsCallback embedder_fields_deserializer) {
  if (!isolate->snapshot_available()) return Handle<Context>();

  const v8::StartupData* blob = isolate->snapshot_blob();
  bool can_rehash = ExtractRehashability(blob);
  base::Vector<const uint8_t> context_data = SnapshotImpl::ExtractContextData(
      blob, static_cast<uint32_t>(context_index));
  SnapshotData snapshot_data(MaybeDecompress(isolate, context_data));

  return ContextDeserializer::DeserializeContext(
      isolate, &snapshot_data, context_index, can_rehash, global_proxy,
      embedder_fields_deserializer);
}

// static
void Snapshot::ClearReconstructableDataForSerialization(
    Isolate* isolate, bool clear_recompilable_data) {
  // Clear SFIs and JSRegExps.
  PtrComprCageBase cage_base(isolate);

  {
    HandleScope scope(isolate);
    std::vector<i::Handle<i::SharedFunctionInfo>> sfis_to_clear;
    {
      i::HeapObjectIterator it(isolate->heap());
      for (i::Tagged<i::HeapObject> o = it.Next(); !o.is_null();
           o = it.Next()) {
        if (clear_recompilable_data && IsSharedFunctionInfo(o, cage_base)) {
          i::Tagged<i::SharedFunctionInfo> shared =
              i::Cast<i::SharedFunctionInfo>(o);
          if (IsScript(shared->script(cage_base), cage_base) &&
              Cast<Script>(shared->script(cage_base))->type() ==
                  Script::Type::kExtension) {
            continue;  // Don't clear extensions, they cannot be recompiled.
          }
          if (shared->CanDiscardCompiled()) {
            sfis_to_clear.emplace_back(shared, isolate);
          }
        } else if (IsJSRegExp(o, cage_base)) {
          i::Tagged<i::JSRegExp> regexp = i::Cast<i::JSRegExp>(o);
          if (regexp->has_data()) {
            i::Tagged<i::RegExpData> data = regexp->data(isolate);
            if (data->HasCompiledCode()) {
              DCHECK(Is<IrRegExpData>(regexp->data(isolate)));
              Cast<IrRegExpData>(data)->DiscardCompiledCodeForSerialization();
            }
          }
        }
      }
    }

#if V8_ENABLE_WEBASSEMBLY
    // Clear the cached js-to-wasm wrappers.
    DirectHandle<WeakArrayList> wrappers(isolate->heap()->js_to_wasm_wrappers(),
                                         isolate);
    for (int i = 0; i < wrappers->length(); ++i) {
      wrappers->Set(i, Tagged<MaybeObject>{});
    }
#endif  // V8_ENABLE_WEBASSEMBLY

    // Must happen after heap iteration since SFI::DiscardCompiled may allocate.
    for (i::DirectHandle<i::SharedFunctionInfo> shared : sfis_to_clear) {
      if (shared->CanDiscardCompiled()) {
        i::SharedFunctionInfo::DiscardCompiled(isolate, shared);
      }
    }
  }

  // Clear JSFunctions.
  {
    i::HeapObjectIterator it(isolate->heap());
    for (i::Tagged<i::HeapObject> o = it.Next(); !o.is_null(); o = it.Next()) {
      if (!IsJSFunction(o, cage_base)) continue;

      i::Tagged<i::JSFunction> fun = i::Cast<i::JSFunction>(o);
      fun->CompleteInobjectSlackTrackingIfActive();

      i::Tagged<i::SharedFunctionInfo> shared = fun->shared();
      if (IsScript(shared->script(cage_base), cage_base) &&
          Cast<Script>(shared->script(cage_base))->type() ==
              Script::Type::kExtension) {
        continue;  // Don't clear extensions, they cannot be recompiled.
      }

      // Also, clear out feedback vectors and recompilable code.
      if (fun->CanDiscardCompiled(isolate)) {
        fun->set_code(*BUILTIN_CODE(isolate, CompileLazy));
      }
      if (!IsUndefined(fun->raw_feedback_cell(cage_base)->value(cage_base))) {
        fun->raw_feedback_cell(cage_base)->set_value(
            i::ReadOnlyRoots(isolate).undefined_value());
      }
#ifdef DEBUG
      if (clear_recompilable_data) {
#if V8_ENABLE_WEBASSEMBLY
        DCHECK(fun->shared()->HasWasmExportedFunctionData() ||
               fun->shared()->HasBuiltinId() ||
               fun->shared()->IsApiFunction() ||
               fun->shared()->HasUncompiledDataWithoutPreparseData());
#else
        DCHECK(fun->shared()->HasBuiltinId() ||
               fun->shared()->IsApiFunction() ||
               fun->shared()->HasUncompiledDataWithoutPreparseData());
#endif  // V8_ENABLE_WEBASSEMBLY
      }
#endif  // DEBUG
    }
  }

  // PendingOptimizeTable also contains BytecodeArray, we need to clear the
  // recompilable code same as above.
  ReadOnlyRoots roots(isolate);
  isolate->heap()->SetFunctionsMarkedForManualOptimization(
      roots.undefined_value());

#if V8_ENABLE_WEBASSEMBLY
  {
    // Check if there are any asm.js / wasm functions on the heap.
    // These cannot be serialized due to restrictions with the js-to-wasm
    // wrapper. A tiered-up wrapper would have to be replaced with a generic
    // wrapper which isn't supported. For asm.js there also isn't any support
    // for the generic wrapper at all.
    i::HeapObjectIterator it(isolate->heap(),
                             HeapObjectIterator::kFilterUnreachable);
    for (i::Tagged<i::HeapObject> o = it.Next(); !o.is_null(); o = it.Next()) {
      if (IsJSFunction(o)) {
        i::Tagged<i::JSFunction> fun = i::Cast<i::JSFunction>(o);
        if (fun->shared()->HasAsmWasmData()) {
          FATAL("asm.js functions are not supported in snapshots");
        }
        if (fun->shared()->HasWasmExportedFunctionData()) {
          FATAL(
              "Exported WebAssembly functions are not supported in snapshots");
        }
      }
    }
  }
#endif  // V8_ENABLE_WEBASSEMBLY
}

// static
void Snapshot::SerializeDeserializeAndVerifyForTesting(
    Isolate* isolate, DirectHandle<Context> default_context) {
  StartupData serialized_data;
  std::unique_ptr<const char[]> auto_delete_serialized_data;

  isolate->heap()->CollectAllAvailableGarbage(
      i::GarbageCollectionReason::kSnapshotCreator);

  // Test serialization.
  {
    SafepointKind safepoint_kind = isolate->has_shared_space()
                                       ? SafepointKind::kGlobal
                                       : SafepointKind::kIsolate;
    SafepointScope safepoint_scope(isolate, safepoint_kind);
    DisallowGarbageCollection no_gc;

    Snapshot::SerializerFlags flags(
        Snapshot::kAllowUnknownExternalReferencesForTesting |
        Snapshot::kAllowActiveIsolateForTesting |
        ((isolate->has_shared_space() || ReadOnlyHeap::IsReadOnlySpaceShared())
             ? Snapshot::kReconstructReadOnlyAndSharedObjectCachesForTesting
             : 0));
    std::vector<Tagged<Context>> contexts{*default_context};
    std::vector<SerializeEmbedderFieldsCallback> callbacks{
        SerializeEmbedderFieldsCallback()};
    serialized_data = Snapshot::Create(isolate, &contexts, callbacks,
                                       safepoint_scope, no_gc, flags);
    auto_delete_serialized_data.reset(serialized_data.data);
  }

  // The shared heap is verified on Heap teardown, which performs a global
  // safepoint. Both isolate and new_isolate are running in the same thread, so
  // park isolate before running new_isolate to avoid deadlock.
  isolate->main_thread_local_isolate()->ExecuteMainThreadWhileParked(
      [&serialized_data]() {
        // Test deserialization.
        Isolate* new_isolate = Isolate::New();
        std::unique_ptr<v8::ArrayBuffer::Allocator> array_buffer_allocator(
            v8::ArrayBuffer::Allocator::NewDefaultAllocator());
        {
          // Set serializer_enabled() to not install extensions and experimental
          // natives on the new isolate.
          // TODO(v8:10416): This should be a separate setting on the isolate.
          new_isolate->enable_serializer();
          new_isolate->Enter();
          new_isolate->set_snapshot_blob(&serialized_data);
          new_isolate->set_array_buffer_allocator(array_buffer_allocator.get());
          CHECK(Snapshot::Initialize(new_isolate));

          HandleScope scope(new_isolate);
          DirectHandle<Context> new_native_context =
              new_isolate->bootstrapper()->CreateEnvironmentForTesting();
          CHECK(IsNativeContext(*new_native_context));

#ifdef VERIFY_HEAP
          if (v8_flags.verify_heap)
            HeapVerifier::VerifyHeap(new_isolate->heap());
#endif  // VERIFY_HEAP
        }
        new_isolate->Exit();
        Isolate::Delete(new_isolate);
      });
}

// static
v8::StartupData Snapshot::Create(
    Isolate* isolate, std::vector<Tagged<Context>>* contexts,
    const std::vector<SerializeEmbedderFieldsCallback>&
        embedder_fields_serializers,
    const SafepointScope& safepoint_scope,
    const DisallowGarbageCollection& no_gc, SerializerFlags flags) {
  TRACE_EVENT0("v8", "V8.SnapshotCreate");
  DCHECK_EQ(contexts->size(), embedder_fields_serializers.size());
  DCHECK_GT(contexts->size(), 0);
  HandleScope scope(isolate);

  ReadOnlySerializer read_only_serializer(isolate, flags);
  read_only_serializer.Serialize();

  // TODO(v8:6593): generalize rehashing, and remove this flag.
  bool can_be_rehashed = read_only_serializer.can_be_rehashed();

  SharedHeapSerializer shared_heap_serializer(isolate, flags);
  StartupSerializer startup_serializer(isolate, flags, &shared_heap_serializer);
  startup_serializer.SerializeStrongReferences(no_gc);

  // Serialize each context with a new serializer.
  const int num_contexts = static_cast<int>(contexts->size());
  std::vector<SnapshotData*> context_snapshots;
  context_snapshots.reserve(num_contexts);

  std::vector<int> context_allocation_sizes;
  for (int i = 0; i < num_contexts; i++) {
    ContextSerializer context_serializer(isolate, flags, &startup_serializer,
                                         embedder_fields_serializers[i]);
    context_serializer.Serialize(&contexts->at(i), no_gc);
    can_be_rehashed = can_be_rehashed && context_serializer.can_be_rehashed();
    context_snapshots.push_back(new SnapshotData(&context_serializer));
    if (v8_flags.serialization_statistics) {
      context_allocation_sizes.push_back(
          context_serializer.TotalAllocationSize());
    }
  }

  startup_serializer.SerializeWeakReferencesAndDeferred();
  can_be_rehashed = can_be_rehashed && startup_serializer.can_be_rehashed();

  startup_serializer.CheckNoDirtyFinalizationRegistries();

  shared_heap_serializer.FinalizeSerialization();
  can_be_rehashed = can_be_rehashed && shared_heap_serializer.can_be_rehashed();

  if (v8_flags.serialization_statistics) {
    DCHECK_NE(read_only_serializer.TotalAllocationSize(), 0);
    DCHECK_NE(startup_serializer.TotalAllocationSize(), 0);
    // The shared heap snapshot can be empty, no problem.
    // DCHECK_NE(shared_heap_serializer.TotalAllocationSize(), 0);
    int per_isolate_allocation_size = startup_serializer.TotalAllocationSize();
    int per_process_allocation_size = 0;
    if (ReadOnlyHeap::IsReadOnlySpaceShared()) {
      per_process_allocation_size += read_only_serializer.TotalAllocationSize();
    } else {
      per_isolate_allocation_size += read_only_serializer.TotalAllocationSize();
    }
    // TODO(jgruber): At snapshot-generation time we don't know whether the
    // shared heap snapshot will actually be shared at runtime, or if it will
    // be deserialized into each isolate. Conservatively account to per-isolate
    // memory here.
    per_isolate_allocation_size += shared_heap_serializer.TotalAllocationSize();
    // These prints must match the regexp in test/memory/Memory.json
    PrintF("Deserialization will allocate:\n");
    PrintF("%10d bytes per process\n", per_process_allocation_size);
    PrintF("%10d bytes per isolate\n", per_isolate_allocation_size);
    for (int i = 0; i < num_contexts; i++) {
      DCHECK_NE(context_allocation_sizes[i], 0);
      PrintF("%10d bytes per context #%d\n", context_allocation_sizes[i], i);
    }
    PrintF("\n");
  }

  SnapshotData read_only_snapshot(&read_only_serializer);
  SnapshotData shared_heap_snapshot(&shared_heap_serializer);
  SnapshotData startup_snapshot(&startup_serializer);
  v8::StartupData result = SnapshotImpl::CreateSnapshotBlob(
      &startup_snapshot, &read_only_snapshot, &shared_heap_snapshot,
      context_snapshots, can_be_rehashed);

  for (const SnapshotData* ptr : context_snapshots) delete ptr;

  CHECK(Snapshot::VerifyChecksum(&result));
  return result;
}

v8::StartupData SnapshotImpl::CreateSnapshotBlob(
    const SnapshotData* startup_snapshot_in,
    const SnapshotData* read_only_snapshot_in,
    const SnapshotData* shared_heap_snapshot_in,
    const std::vector<SnapshotData*>& context_snapshots_in,
    bool can_be_rehashed) {
  TRACE_EVENT0("v8", "V8.SnapshotCompress");
  // Have these separate from snapshot_in for compression, since we need to
  // access the compressed data as well as the uncompressed reservations.
  const SnapshotData* startup_snapshot;
  const SnapshotData* read_only_snapshot;
  const SnapshotData* shared_heap_snapshot;
  const std::vector<SnapshotData*>* context_snapshots;
#ifdef V8_SNAPSHOT_COMPRESSION
  SnapshotData startup_compressed(
      SnapshotCompression::Compress(startup_snapshot_in));
  SnapshotData read_only_compressed(
      SnapshotCompression::Compress(read_only_snapshot_in));
  SnapshotData shared_heap_compressed(
      SnapshotCompression::Compress(shared_heap_snapshot_in));
  startup_snapshot = &startup_compressed;
  read_only_snapshot = &read_only_compressed;
  shared_heap_snapshot = &shared_heap_compressed;
  std::vector<SnapshotData> context_snapshots_compressed;
  context_snapshots_compressed.reserve(context_snapshots_in.size());
  std::vector<SnapshotData*> context_snapshots_compressed_ptrs;
  for (unsigned int i = 0; i < context_snapshots_in.size(); ++i) {
    context_snapshots_compressed.push_back(
        SnapshotCompression::Compress(context_snapshots_in[i]));
    context_snapshots_compressed_ptrs.push_back(
        &context_snapshots_compressed[i]);
  }
  context_snapshots = &context_snapshots_compressed_ptrs;
#else
  startup_snapshot = startup_snapshot_in;
  read_only_snapshot = read_only_snapshot_in;
  shared_heap_snapshot = shared_heap_snapshot_in;
  context_snapshots = &context_snapshots_in;
#endif

  uint32_t num_contexts = static_cast<uint32_t>(context_snapshots->size());
  uint32_t startup_snapshot_offset =
      SnapshotImpl::StartupSnapshotOffset(num_contexts);
  uint32_t total_length = startup_snapshot_offset;
  total_length += static_cast<uint32_t>(startup_snapshot->RawData().length());
  total_length += static_cast<uint32_t>(read_only_snapshot->RawData().length());
  total_length +=
      static_cast<uint32_t>(shared_heap_snapshot->RawData().length());
  for (const auto context_snapshot : *context_snapshots) {
    total_length += static_cast<uint32_t>(context_snapshot->RawData().length());
  }

  char* data = new char[total_length];
  // Zero out pre-payload data. Part of that is only used for padding.
  memset(data, 0, SnapshotImpl::StartupSnapshotOffset(num_contexts));

  SnapshotImpl::SetHeaderValue(data, SnapshotImpl::kNumberOfContextsOffset,
                               num_contexts);
  SnapshotImpl::SetHeaderValue(data, SnapshotImpl::kRehashabilityOffset,
                               can_be_rehashed ? 1 : 0);

  // Write version string into snapshot data.
  memset(data + SnapshotImpl::kVersionStringOffset, 0,
         SnapshotImpl::kVersionStringLength);
  Version::GetString(
      base::Vector<char>(data + SnapshotImpl::kVersionStringOffset,
                         SnapshotImpl::kVersionStringLength));

  // Startup snapshot (isolate-specific data).
  uint32_t payload_offset = startup_snapshot_offset;
  uint32_t payload_length =
      static_cast<uint32_t>(startup_snapshot->RawData().length());
  CopyBytes(data + payload_offset,
            reinterpret_cast<const char*>(startup_snapshot->RawData().begin()),
            payload_length);
  if (v8_flags.serialization_statistics) {
    // These prints must match the regexp in test/memory/Memory.json
    PrintF("Snapshot blob consists of:\n");
    PrintF("%10d bytes for startup\n", payload_length);
  }
  payload_offset += payload_length;

  // Read-only.
  SnapshotImpl::SetHeaderValue(data, SnapshotImpl::kReadOnlyOffsetOffset,
                               payload_offset);
  payload_length = read_only_snapshot->RawData().length();
  CopyBytes(
      data + payload_offset,
      reinterpret_cast<const char*>(read_only_snapshot->RawData().begin()),
      payload_length);
  SnapshotImpl::SetHeaderValue(
      data, SnapshotImpl::kReadOnlySnapshotChecksumOffset,
      Checksum(base::VectorOf(
          reinterpret_cast<const uint8_t*>(data + payload_offset),
          payload_length)));
  if (v8_flags.serialization_statistics) {
    // These prints must match the regexp in test/memory/Memory.json
    PrintF("%10d bytes for read-only\n", payload_length);
  }
  payload_offset += payload_length;

  // Shared heap.
  SnapshotImpl::SetHeaderValue(data, SnapshotImpl::kSharedHeapOffsetOffset,
                               payload_offset);
  payload_length = shared_heap_snapshot->RawData().length();
  CopyBytes(
      data + payload_offset,
      reinterpret_cast<const char*>(shared_heap_snapshot->RawData().begin()),
      payload_length);
  if (v8_flags.serialization_statistics) {
    // These prints must match the regexp in test/memory/Memory.json
    PrintF("%10d bytes for shared heap\n", payload_length);
  }
  payload_offset += payload_length;

  // Context snapshots (context-specific data).
  for (uint32_t i = 0; i < num_contexts; i++) {
    SnapshotImpl::SetHeaderValue(
        data, SnapshotImpl::ContextSnapshotOffsetOffset(i), payload_offset);
    SnapshotData* context_snapshot = (*context_snapshots)[i];
    payload_length = context_snapshot->RawData().length();
    CopyBytes(
        data + payload_offset,
        reinterpret_cast<const char*>(context_snapshot->RawData().begin()),
        payload_length);
    if (v8_flags.serialization_statistics) {
      // These prints must match the regexp in test/memory/Memory.json
      PrintF("%10d bytes for context #%d\n", payload_length, i);
    }
    payload_offset += payload_length;
  }
  if (v8_flags.serialization_statistics) PrintF("\n");

  DCHECK_EQ(total_length, payload_offset);
  v8::StartupData result = {data, static_cast<int>(total_length)};

  SnapshotImpl::SetHeaderValue(
      data, SnapshotImpl::kChecksumOffset,
      Checksum(SnapshotImpl::ChecksummedContent(&result)));

  return result;
}

uint32_t SnapshotImpl::ExtractNumContexts(const v8::StartupData* data) {
  return GetHeaderValue(data, kNumberOfContextsOffset);
}

uint32_t Snapshot::GetExpectedChecksum(const v8::StartupData* data) {
  return SnapshotImpl::GetHeaderValue(data, SnapshotImpl::kChecksumOffset);
}
uint32_t Snapshot::CalculateChecksum(const v8::StartupData* data) {
  return Checksum(SnapshotImpl::ChecksummedContent(data));
}

bool Snapshot::VerifyChecksum(const v8::StartupData* data) {
  base::ElapsedTimer timer;
  if (v8_flags.profile_deserialization) timer.Start();
  uint32_t expected = GetExpectedChecksum(data);
  uint32_t result = CalculateChecksum(data);
  if (v8_flags.profile_deserialization) {
    double ms = timer.Elapsed().InMillisecondsF();
    PrintF("[Verifying snapshot checksum took %0.3f ms]\n", ms);
  }
  return result == expected;
}

uint32_t SnapshotImpl::ExtractContextOffset(const v8::StartupData* data,
                                            uint32_t index) {
  // Extract the offset of the context at a given index from the StartupData,
  // and check that it is within bounds.
  uint32_t context_offset =
      GetHeaderValue(data, ContextSnapshotOffsetOffset(index));
  CHECK_LT(context_offset, static_cast<uint32_t>(data->raw_size));
  return context_offset;
}

bool Snapshot::ExtractRehashability(const v8::StartupData* data) {
  uint32_t rehashability =
      SnapshotImpl::GetHeaderValue(data, SnapshotImpl::kRehashabilityOffset);
  CHECK_IMPLIES(rehashability != 0, rehashability == 1);
  return rehashability != 0;
}

// static
uint32_t Snapshot::ExtractReadOnlySnapshotChecksum(
    const v8::StartupData* data) {
  return SnapshotImpl::GetHeaderValue(
      data, SnapshotImpl::kReadOnlySnapshotChecksumOffset);
}

namespace {
base::Vector<const uint8_t> ExtractData(const v8::StartupData* snapshot,
                                        uint32_t start_offset,
                                        uint32_t end_offset) {
  CHECK_LT(start_offset, end_offset);
  CHECK_LT(end_offset, snapshot->raw_size);
  uint32_t length = end_offset - start_offset;
  const uint8_t* data =
      reinterpret_cast<const uint8_t*>(snapshot->data + start_offset);
  return base::Vector<const uint8_t>(data, length);
}
}  // namespace

base::Vector<const uint8_t> SnapshotImpl::ExtractStartupData(
    const v8::StartupData* data) {
  DCHECK(Snapshot::SnapshotIsValid(data));

  uint32_t num_contexts = ExtractNumContexts(data);
  return ExtractData(data, StartupSnapshotOffset(num_contexts),
                     GetHeaderValue(data, kReadOnlyOffsetOffset));
}

base::Vector<const uint8_t> SnapshotImpl::ExtractReadOnlyData(
    const v8::StartupData* data) {
  DCHECK(Snapshot::SnapshotIsValid(data));

  return ExtractData(data, GetHeaderValue(data, kReadOnlyOffsetOffset),
                     GetHeaderValue(data, kSharedHeapOffsetOffset));
}

base::Vector<const uint8_t> SnapshotImpl::ExtractSharedHeapData(
    const v8::StartupData* data) {
  DCHECK(Snapshot::SnapshotIsValid(data));

  return ExtractData(data, GetHeaderValue(data, kSharedHeapOffsetOffset),
                     GetHeaderValue(data, ContextSnapshotOffsetOffset(0)));
}

base::Vector<const uint8_t> SnapshotImpl::ExtractContextData(
    const v8::StartupData* data, uint32_t index) {
  uint32_t num_contexts = ExtractNumContexts(data);
  CHECK_LT(index, num_contexts);

  uint32_t context_offset = ExtractContextOffset(data, index);
  uint32_t next_context_offset;
  if (index == num_contexts - 1) {
    next_context_offset = data->raw_size;
  } else {
    next_context_offset = ExtractContextOffset(data, index + 1);
    CHECK_LT(next_context_offset, data->raw_size);
  }

  const uint8_t* context_data =
      reinterpret_cast<const uint8_t*>(data->data + context_offset);
  uint32_t context_length = next_context_offset - context_offset;
  return base::Vector<const uint8_t>(context_data, context_length);
}

void SnapshotImpl::CheckVersion(const v8::StartupData* data) {
  if (!Snapshot::VersionIsValid(data)) {
    char version[kVersionStringLength];
    memset(version, 0, kVersionStringLength);
    CHECK_LT(kVersionStringOffset + kVersionStringLength,
             static_cast<uint32_t>(data->raw_size));
    Version::GetString(base::Vector<char>(version, kVersionStringLength));
    FATAL(
        "Version mismatch between V8 binary and snapshot.\n"
        "#   V8 binary version: %.*s\n"
        "#    Snapshot version: %.*s\n"
        "# The snapshot consists of %d bytes and contains %d context(s).",
        kVersionStringLength, version, kVersionStringLength,
        data->data + kVersionStringOffset, data->raw_size,
        ExtractNumContexts(data));
  }
}

namespace {

bool RunExtraCode(v8::Isolate* isolate, v8::Local<v8::Context> context,
                  const char* utf8_source, const char* name) {
  v8::Context::Scope context_scope(context);
  v8::TryCatch try_catch(isolate);
  v8::Local<v8::String> source_string;
  if (!v8::String::NewFromUtf8(isolate, utf8_source).ToLocal(&source_string)) {
    return false;
  }
  v8::Local<v8::String> resource_name =
      v8::String::NewFromUtf8(isolate, name).ToLocalChecked();
  v8::ScriptOrigin origin(resource_name);
  v8::ScriptCompiler::Source source(source_string, origin);
  v8::Local<v8::Script> script;
  if (!v8::ScriptCompiler::Compile(context, &source).ToLocal(&script)) {
    return false;
  }
  if (script->Run(context).IsEmpty()) return false;
  CHECK(!try_catch.HasCaught());
  return true;
}

}  // namespace

v8::StartupData CreateSnapshotDataBlobInternal(
    v8::SnapshotCreator::FunctionCodeHandling function_code_handling,
    const char* embedded_source, SnapshotCreator& snapshot_creator,
    Snapshot::SerializerFlags serializer_flags) {
  SnapshotCreatorImpl* creator =
      SnapshotCreatorImpl::FromSnapshotCreator(&snapshot_creator);
  {
    auto v8_isolate = reinterpret_cast<v8::Isolate*>(creator->isolate());
    v8::HandleScope scope(v8_isolate);
    v8::Local<v8::Context> context = v8::Context::New(v8_isolate);
    if (embedded_source != nullptr &&
        !RunExtraCode(v8_isolate, context, embedded_source, "<embedded>")) {
      return {};
    }
    creator->SetDefaultContext(Utils::OpenHandle(*context),
                               SerializeEmbedderFieldsCallback());
  }
  return creator->CreateBlob(function_code_handling, serializer_flags);
}

v8::StartupData CreateSnapshotDataBlobInternal(
    v8::SnapshotCreator::FunctionCodeHandling function_code_handling,
    const char* embedded_source, Snapshot::SerializerFlags serializer_flags) {
  std::unique_ptr<v8::ArrayBuffer::Allocator> array_buffer_allocator(
      v8::ArrayBuffer::Allocator::NewDefaultAllocator());
  v8::Isolate::CreateParams create_params;
  create_params.array_buffer_allocator = array_buffer_allocator.get();
  v8::SnapshotCreator creator(create_params);
  return CreateSnapshotDataBlobInternal(function_code_handling, embedded_source,
                                        creator, serializer_flags);
}

v8::StartupData CreateSnapshotDataBlobInternalForInspectorTest(
    v8::SnapshotCreator::FunctionCodeHandling function_code_handling,
    const char* embedded_source) {
  return CreateSnapshotDataBlobInternal(function_code_handling,
                                        embedded_source);
}

v8::StartupData WarmUpSnapshotDataBlobInternal(
    v8::StartupData cold_snapshot_blob, const char* warmup_source) {
  CHECK(cold_snapshot_blob.raw_size > 0 && cold_snapshot_blob.data != nullptr);
  CHECK_NOT_NULL(warmup_source);

  // Use following steps to create a warmed up snapshot blob from a cold one:
  //  - Create a new isolate from the cold snapshot.
  //  - Create a new context to run the warmup script. This will trigger
  //    compilation of executed functions.
  //  - Create a new context. This context will be unpolluted.
  //  - Serialize the isolate and the second context into a new snapshot blob.

  std::unique_ptr<v8::ArrayBuffer::Allocator> allocator(
      ArrayBuffer::Allocator::NewDefaultAllocator());
  v8::Isolate::CreateParams params;
  params.snapshot_blob = &cold_snapshot_blob;
  params.array_buffer_allocator = allocator.get();
  v8::SnapshotCreator snapshot_creator(params);
  v8::Isolate* isolate = snapshot_creator.GetIsolate();
  {
    v8::HandleScope scope(isolate);
    v8::Local<v8::Context> context = v8::Context::New(isolate);
    if (!RunExtraCode(isolate, context, warmup_source, "<warm-up>")) {
      return {};
    }
  }
  {
    v8::HandleScope handle_scope(isolate);
    isolate->ContextDisposedNotification(false);
    v8::Local<v8::Context> context = v8::Context::New(isolate);
    snapshot_creator.SetDefaultContext(context);
  }

  return snapshot_creator.CreateBlob(
      v8::SnapshotCreator::FunctionCodeHandling::kKeep);
}

void SnapshotCreatorImpl::InitInternal(const StartupData* blob) {
  isolate_->enable_serializer();
  isolate_->Enter();

  if (blob != nullptr && blob->raw_size > 0) {
    isolate_->set_snapshot_blob(blob);
    Snapshot::Initialize(isolate_);
  } else {
    isolate_->InitWithoutSnapshot();
  }

#ifdef V8_ENABLE_SPARKPLUG
  isolate_->baseline_batch_compiler()->set_enabled(false);
#endif  // V8_ENABLE_SPARKPLUG

  // Reserve a spot for the default context s.t. the call sequence of
  // SetDefaultContext / AddContext remains independent.
  contexts_.push_back(SerializableContext{});
  DCHECK_EQ(contexts_.size(), kDefaultContextIndex + 1);
}

SnapshotCreatorImpl::SnapshotCreatorImpl(
    Isolate* isolate, const intptr_t* api_external_references,
    const StartupData* existing_blob, bool owns_isolate)
    : owns_isolate_(owns_isolate),
      isolate_(isolate == nullptr ? Isolate::New() : isolate),
      array_buffer_allocator_(ArrayBuffer::Allocator::NewDefaultAllocator()) {
  DCHECK_NOT_NULL(isolate_);

  isolate_->set_array_buffer_allocator(array_buffer_allocator_.get());
  isolate_->set_api_external_references(api_external_references);

  InitInternal(existing_blob ? existing_blob : Snapshot::DefaultSnapshotBlob());
}

SnapshotCreatorImpl::SnapshotCreatorImpl(
    const v8::Isolate::CreateParams& params)
    : owns_isolate_(true), isolate_(Isolate::New()) {
  if (auto allocator = params.array_buffer_allocator_shared) {
    CHECK(params.array_buffer_allocator == nullptr ||
          params.array_buffer_allocator == allocator.get());
    isolate_->set_array_buffer_allocator(allocator.get());
    isolate_->set_array_buffer_allocator_shared(std::move(allocator));
  } else {
    CHECK_NOT_NULL(params.array_buffer_allocator);
    isolate_->set_array_buffer_allocator(params.array_buffer_allocator);
  }
  isolate_->set_api_external_references(params.external_references);
  isolate_->heap()->ConfigureHeap(params.constraints, params.cpp_heap);

  InitInternal(params.snapshot_blob ? params.snapshot_blob
                                    : Snapshot::DefaultSnapshotBlob());
}

SnapshotCreatorImpl::SnapshotCreatorImpl(
    Isolate* isolate, const v8::Isolate::CreateParams& params)
    : owns_isolate_(false), isolate_(isolate) {
  if (auto allocator = params.array_buffer_allocator_shared) {
    CHECK(params.array_buffer_allocator == nullptr ||
          params.array_buffer_allocator == allocator.get());
    isolate_->set_array_buffer_allocator(allocator.get());
    isolate_->set_array_buffer_allocator_shared(std::move(allocator));
  } else {
    CHECK_NOT_NULL(params.array_buffer_allocator);
    isolate_->set_array_buffer_allocator(params.array_buffer_allocator);
  }
  isolate_->set_api_external_references(params.external_references);
  isolate_->heap()->ConfigureHeap(params.constraints, params.cpp_heap);

  InitInternal(params.snapshot_blob ? params.snapshot_blob
                                    : Snapshot::DefaultSnapshotBlob());
}

SnapshotCreatorImpl::~SnapshotCreatorImpl() {
  if (isolate_->heap()->read_only_space()->writable()) {
    // Finalize the RO heap in order to leave the Isolate in a consistent state.
    isolate_->read_only_heap()->OnCreateHeapObjectsComplete(isolate_);
  }
  // Destroy leftover global handles (i.e. if CreateBlob was never called).
  for (size_t i = 0; i < contexts_.size(); i++) {
    DCHECK(!created());
    GlobalHandles::Destroy(contexts_[i].handle_location);
    contexts_[i].handle_location = nullptr;
  }
  isolate_->Exit();
  if (owns_isolate_) Isolate::Delete(isolate_);
}

void SnapshotCreatorImpl::SetDefaultContext(
    Handle<NativeContext> context, SerializeEmbedderFieldsCallback callback) {
  DCHECK(contexts_[kDefaultContextIndex].handle_location == nullptr);
  DCHECK(!context.is_null());
  DCHECK(!created());
  CHECK_EQ(isolate_, context->GetIsolate());
  contexts_[kDefaultContextIndex].handle_location =
      isolate_->global_handles()->Create(*context).location();
  contexts_[kDefaultContextIndex].callback = callback;
}

size_t SnapshotCreatorImpl::AddContext(
    Handle<NativeContext> context, SerializeEmbedderFieldsCallback callback) {
  DCHECK(!context.is_null());
  DCHECK(!created());
  CHECK_EQ(isolate_, context->GetIsolate());
  size_t index = contexts_.size() - kFirstAddtlContextIndex;
  contexts_.emplace_back(
      isolate_->global_handles()->Create(*context).location(), callback);
  return index;
}

size_t SnapshotCreatorImpl::AddData(DirectHandle<NativeContext> context,
                                    Address object) {
  CHECK_EQ(isolate_, context->GetIsolate());
  DCHECK_NE(object, kNullAddress);
  DCHECK(!created());
  HandleScope scope(isolate_);
  DirectHandle<Object> obj(Tagged<Object>(object), isolate_);
  Handle<ArrayList> list;
  if (!IsArrayList(context->serialized_objects())) {
    list = ArrayList::New(isolate_, 1);
  } else {
    list = Handle<ArrayList>(Cast<ArrayList>(context->serialized_objects()),
                             isolate_);
  }
  size_t index = static_cast<size_t>(list->length());
  list = ArrayList::Add(isolate_, list, obj);
  context->set_serialized_objects(*list);
  return index;
}

size_t SnapshotCreatorImpl::AddData(Address object) {
  DCHECK_NE(object, kNullAddress);
  DCHECK(!created());
  HandleScope scope(isolate_);
  DirectHandle<Object> obj(Tagged<Object>(object), isolate_);
  Handle<ArrayList> list;
  if (!IsArrayList(isolate_->heap()->serialized_objects())) {
    list = ArrayList::New(isolate_, 1);
  } else {
    list = Handle<ArrayList>(
        Cast<ArrayList>(isolate_->heap()->serialized_objects()), isolate_);
  }
  size_t index = static_cast<size_t>(list->length());
  list = ArrayList::Add(isolate_, list, obj);
  isolate_->heap()->SetSerializedObjects(*list);
  return index;
}

Handle<NativeContext> SnapshotCreatorImpl::context_at(size_t i) const {
  return Handle<NativeContext>(contexts_[i].handle_location);
}

namespace {

void ConvertSerializedObjectsToFixedArray(Isolate* isolate) {
  if (!IsArrayList(isolate->heap()->serialized_objects())) {
    isolate->heap()->SetSerializedObjects(
        ReadOnlyRoots(isolate).empty_fixed_array());
  } else {
    DirectHandle<ArrayList> list(
        Cast<ArrayList>(isolate->heap()->serialized_objects()), isolate);
    DirectHandle<FixedArray> elements = ArrayList::ToFixedArray(isolate, list);
    isolate->heap()->SetSerializedObjects(*elements);
  }
}

void ConvertSerializedObjectsToFixedArray(Isolate* isolate,
                                          DirectHandle<NativeContext> context) {
  if (!IsArrayList(context->serialized_objects())) {
    context->set_serialized_objects(ReadOnlyRoots(isolate).empty_fixed_array());
  } else {
    DirectHandle<ArrayList> list(Cast<ArrayList>(context->serialized_objects()),
                                 isolate);
    DirectHandle<FixedArray> elements = ArrayList::ToFixedArray(isolate, list);
    context->set_serialized_objects(*elements);
  }
}

}  // anonymous namespace

// static
StartupData SnapshotCreatorImpl::CreateBlob(
    SnapshotCreator::FunctionCodeHandling function_code_handling,
    Snapshot::SerializerFlags serializer_flags) {
  CHECK(!created());
  CHECK(contexts_[kDefaultContextIndex].handle_location != nullptr);

  const size_t num_contexts = contexts_.size();
  const size_t num_additional_contexts = num_contexts - 1;

  // Create and store lists of embedder-provided data needed during
  // serialization.
  {
    HandleScope scope(isolate_);

    // Convert list of context-independent data to FixedArray.
    ConvertSerializedObjectsToFixedArray(isolate_);

    // Convert lists of context-dependent data to FixedArray.
    for (size_t i = 0; i < num_contexts; i++) {
      ConvertSerializedObjectsToFixedArray(isolate_, context_at(i));
    }

    // We need to store the global proxy size upfront in case we need the
    // bootstrapper to create a global proxy before we deserialize the context.
    DirectHandle<FixedArray> global_proxy_sizes =
        isolate_->factory()->NewFixedArray(
            static_cast<int>(num_additional_contexts), AllocationType::kOld);
    for (size_t i = kFirstAddtlContextIndex; i < num_contexts; i++) {
      global_proxy_sizes->set(
          static_cast<int>(i - kFirstAddtlContextIndex),
          Smi::FromInt(context_at(i)->global_proxy()->Size()));
    }
    isolate_->heap()->SetSerializedGlobalProxySizes(*global_proxy_sizes);
  }

  // We might rehash strings and re-sort descriptors. Clear the lookup cache.
  isolate_->descriptor_lookup_cache()->Clear();

  // If we don't do this then we end up with a stray root pointing at the
  // context even after we have disposed of the context.
  {
    // Note that we need to run a garbage collection without stack at this
    // point, so that all dead objects are reclaimed. This is required to avoid
    // conservative stack scanning and guarantee deterministic behaviour.
    EmbedderStackStateScope stack_scope(
        isolate_->heap(), EmbedderStackStateOrigin::kExplicitInvocation,
        StackState::kNoHeapPointers);
    isolate_->heap()->CollectAllAvailableGarbage(
        GarbageCollectionReason::kSnapshotCreator);
  }
  {
    HandleScope scope(isolate_);
    isolate_->heap()->CompactWeakArrayLists();
  }

  Snapshot::ClearReconstructableDataForSerialization(
      isolate_,
      function_code_handling == SnapshotCreator::FunctionCodeHandling::kClear);

  SafepointKind safepoint_kind = isolate_->has_shared_space()
                                     ? SafepointKind::kGlobal
                                     : SafepointKind::kIsolate;
  SafepointScope safepoint_scope(isolate_, safepoint_kind);
  DisallowGarbageCollection no_gc_from_here_on;

  // RO space is usually writable when serializing a snapshot s.t. preceding
  // heap initialization can also extend RO space. There are notable exceptions
  // though, including --stress-snapshot and serializer cctests.
  if (isolate_->heap()->read_only_space()->writable()) {
    // Promote objects from mutable heap spaces to read-only space prior to
    // serialization. Objects can be promoted if a) they are themselves
    // immutable-after-deserialization and b) all objects in the transitive
    // object graph also satisfy condition a).
    ReadOnlyPromotion::Promote(isolate_, safepoint_scope, no_gc_from_here_on);
    // When creating the snapshot from scratch, we are responsible for sealing
    // the RO heap here. Note we cannot delegate the responsibility e.g. to
    // Isolate::Init since it should still be possible to allocate into RO
    // space after the Isolate has been initialized, for example as part of
    // Context creation.
    isolate_->read_only_heap()->OnCreateHeapObjectsComplete(isolate_);
  }

  // Create a vector with all contexts and destroy associated global handles.
  // This is important because serialization visits active global handles as
  // roots, which we don't want for our internal SnapshotCreatorImpl-related
  // data.
  // Note these contexts may be dead after calling Clear(), but will not be
  // collected until serialization completes and the DisallowGarbageCollection
  // scope above goes out of scope.
  std::vector<Tagged<Context>> raw_contexts;
  raw_contexts.reserve(num_contexts);
  {
    HandleScope scope(isolate_);
    for (size_t i = 0; i < num_contexts; i++) {
      raw_contexts.push_back(*context_at(i));
      GlobalHandles::Destroy(contexts_[i].handle_location);
      contexts_[i].handle_location = nullptr;
    }
  }

  // Check that values referenced by global/eternal handles are accounted for.
  SerializedHandleChecker handle_checker(isolate_, &raw_contexts);
  if (!handle_checker.CheckGlobalAndEternalHandles()) {
    GRACEFUL_FATAL("CheckGlobalAndEternalHandles failed");
  }

  // Create a vector with all embedder fields serializers.
  std::vector<SerializeEmbedderFieldsCallback> raw_callbacks;
  raw_callbacks.reserve(num_contexts);
  for (size_t i = 0; i < num_contexts; i++) {
    raw_callbacks.push_back(contexts_[i].callback);
  }

  contexts_.clear();
  return Snapshot::Create(isolate_, &raw_contexts, raw_callbacks,
                          safepoint_scope, no_gc_from_here_on,
                          serializer_flags);
}

SnapshotCreatorImpl* SnapshotCreatorImpl::FromSnapshotCreator(
    v8::SnapshotCreator* snapshot_creator) {
  return snapshot_creator->impl_;
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/src/snapshot/snapshot.h                                                         0000664 0000000 0000000 00000022061 14746647661 0020504 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_SNAPSHOT_SNAPSHOT_H_
#define V8_SNAPSHOT_SNAPSHOT_H_

#include <vector>

#include "include/v8-array-buffer.h"  // For ArrayBuffer::Allocator.
#include "include/v8-snapshot.h"  // For StartupData.
#include "src/common/assert-scope.h"
#include "src/common/globals.h"
#include "src/snapshot/serializer-deserializer.h"

namespace v8 {
namespace internal {

class Context;
class Isolate;
class JSGlobalProxy;
class SafepointScope;
class SnapshotData;

class Snapshot : public AllStatic {
 public:
  // ---------------- Serialization -------------------------------------------

  enum SerializerFlag {
    // If set, serializes unknown external references as verbatim data. This
    // usually leads to invalid state if the snapshot is deserialized in a
    // different isolate or a different process.
    // If unset, all external references must be known to the encoder.
    kAllowUnknownExternalReferencesForTesting = 1 << 0,
    // If set, the serializer enters a more permissive mode which allows
    // serialization of a currently active, running isolate. This has multiple
    // effects; for example, open handles are allowed, microtasks may exist,
    // etc. Note that in this mode, the serializer is allowed to skip
    // visitation of certain problematic areas even if they are non-empty. The
    // resulting snapshot is not guaranteed to result in a runnable context
    // after deserialization.
    // If unset, we assert that these previously mentioned areas are empty.
    kAllowActiveIsolateForTesting = 1 << 1,
    // If set, the ReadOnlySerializer and the SharedHeapSerializer reconstructs
    // their respective object caches from the existing ReadOnlyHeap's read-only
    // object cache or the existing shared heap's object cache so the same
    // mapping is used.  This mode is used for testing deserialization of a
    // snapshot from a live isolate that's using a shared ReadOnlyHeap or is
    // attached to a shared isolate. Otherwise during deserialization the
    // indices will mismatch, causing deserialization crashes when e.g. types
    // mismatch.  If unset, the read-only object cache is populated as read-only
    // objects are serialized, and the shared heap object cache is populated as
    // shared heap objects are serialized.
    kReconstructReadOnlyAndSharedObjectCachesForTesting = 1 << 2,
  };
  using SerializerFlags = base::Flags<SerializerFlag>;
  V8_EXPORT_PRIVATE static constexpr SerializerFlags kDefaultSerializerFlags =
      {};

  // In preparation for serialization, clear data from the given isolate's heap
  // that 1. can be reconstructed and 2. is not suitable for serialization. The
  // `clear_recompilable_data` flag controls whether compiled objects are
  // cleared from shared function infos and regexp objects.
  V8_EXPORT_PRIVATE static void ClearReconstructableDataForSerialization(
      Isolate* isolate, bool clear_recompilable_data);

  // Serializes the given isolate and contexts. Each context may have an
  // associated callback to serialize internal fields. The default context must
  // be passed at index 0.
  static v8::StartupData Create(
      Isolate* isolate, std::vector<Tagged<Context>>* contexts,
      const std::vector<SerializeEmbedderFieldsCallback>&
          embedder_fields_serializers,
      const SafepointScope& safepoint_scope,
      const DisallowGarbageCollection& no_gc,
      SerializerFlags flags = kDefaultSerializerFlags);

  // ---------------- Deserialization -----------------------------------------

  // Initialize the Isolate from the internal snapshot. Returns false if no
  // snapshot could be found.
  static bool Initialize(Isolate* isolate);

  // Create a new context using the internal context snapshot.
  static MaybeHandle<Context> NewContextFromSnapshot(
      Isolate* isolate, Handle<JSGlobalProxy> global_proxy,
      size_t context_index,
      DeserializeEmbedderFieldsCallback embedder_fields_deserializer);

  // ---------------- Testing -------------------------------------------------

  // This function is used to stress the snapshot component. It serializes the
  // current isolate and context into a snapshot, deserializes the snapshot into
  // a new isolate and context, and finally runs VerifyHeap on the fresh
  // isolate.
  V8_EXPORT_PRIVATE static void SerializeDeserializeAndVerifyForTesting(
      Isolate* isolate, DirectHandle<Context> default_context);

  // ---------------- Helper methods ------------------------------------------

  static bool HasContextSnapshot(Isolate* isolate, size_t index);
  static bool EmbedsScript(Isolate* isolate);
  V8_EXPORT_PRIVATE static uint32_t GetExpectedChecksum(
      const v8::StartupData* data);
  V8_EXPORT_PRIVATE static uint32_t CalculateChecksum(
      const v8::StartupData* data);
  V8_EXPORT_PRIVATE static bool VerifyChecksum(const v8::StartupData* data);
  static bool ExtractRehashability(const v8::StartupData* data);
  V8_EXPORT_PRIVATE static uint32_t ExtractReadOnlySnapshotChecksum(
      const v8::StartupData* data);
  static bool VersionIsValid(const v8::StartupData* data);

  // To be implemented by the snapshot source.
  static const v8::StartupData* DefaultSnapshotBlob();
  static bool ShouldVerifyChecksum(const v8::StartupData* data);

#ifdef DEBUG
  static bool SnapshotIsValid(const v8::StartupData* snapshot_blob);
#endif  // DEBUG
};

// Convenience wrapper around snapshot data blob creation used e.g. by tests.
V8_EXPORT_PRIVATE v8::StartupData CreateSnapshotDataBlobInternal(
    v8::SnapshotCreator::FunctionCodeHandling function_code_handling,
    const char* embedded_source = nullptr,
    Snapshot::SerializerFlags serializer_flags =
        Snapshot::kDefaultSerializerFlags);
// Convenience wrapper around snapshot data blob creation used e.g. by
// mksnapshot.
V8_EXPORT_PRIVATE v8::StartupData CreateSnapshotDataBlobInternal(
    v8::SnapshotCreator::FunctionCodeHandling function_code_handling,
    const char* embedded_source, v8::SnapshotCreator& snapshot_creator,
    Snapshot::SerializerFlags serializer_flags =
        Snapshot::kDefaultSerializerFlags);
// .. and for inspector-test.cc which needs an extern declaration due to
// restrictive include rules:
V8_EXPORT_PRIVATE v8::StartupData
CreateSnapshotDataBlobInternalForInspectorTest(
    v8::SnapshotCreator::FunctionCodeHandling function_code_handling,
    const char* embedded_source);

// Convenience wrapper around snapshot data blob warmup used e.g. by tests and
// mksnapshot.
V8_EXPORT_PRIVATE v8::StartupData WarmUpSnapshotDataBlobInternal(
    v8::StartupData cold_snapshot_blob, const char* warmup_source);

#ifdef V8_USE_EXTERNAL_STARTUP_DATA
void SetSnapshotFromFile(StartupData* snapshot_blob);
#endif

// The implementation of the API-exposed class SnapshotCreator.
class SnapshotCreatorImpl final {
 public:
  // This ctor is used for internal usages:
  // 1. %ProfileCreateSnapshotDataBlob(): Needs to hook into an existing
  //    Isolate.
  //
  // TODO(v8:14490): Refactor 1. to go through the public API and simplify this
  // part of the internal snapshot creator.
  SnapshotCreatorImpl(Isolate* isolate, const intptr_t* api_external_references,
                      const StartupData* existing_blob, bool owns_isolate);
  explicit SnapshotCreatorImpl(const v8::Isolate::CreateParams& params);

  SnapshotCreatorImpl(Isolate* isolate,
                      const v8::Isolate::CreateParams& params);

  ~SnapshotCreatorImpl();

  Isolate* isolate() const { return isolate_; }

  void SetDefaultContext(Handle<NativeContext> context,
                         SerializeEmbedderFieldsCallback callback);
  size_t AddContext(Handle<NativeContext> context,
                    SerializeEmbedderFieldsCallback callback);

  size_t AddData(DirectHandle<NativeContext> context, Address object);
  size_t AddData(Address object);

  StartupData CreateBlob(
      SnapshotCreator::FunctionCodeHandling function_code_handling,
      Snapshot::SerializerFlags serializer_flags =
          Snapshot::kDefaultSerializerFlags);

  static SnapshotCreatorImpl* FromSnapshotCreator(
      v8::SnapshotCreator* snapshot_creator);

  static constexpr size_t kDefaultContextIndex = 0;
  static constexpr size_t kFirstAddtlContextIndex = kDefaultContextIndex + 1;

 private:
  struct SerializableContext {
    SerializableContext() : handle_location(nullptr), callback(nullptr) {}
    SerializableContext(Address* handle_location,
                        SerializeEmbedderFieldsCallback callback)
        : handle_location(handle_location), callback(callback) {}
    Address* handle_location = nullptr;  // A GlobalHandle.
    SerializeEmbedderFieldsCallback callback;
  };

  void InitInternal(const StartupData*);

  Handle<NativeContext> context_at(size_t i) const;
  bool created() const { return contexts_.size() == 0; }

  const bool owns_isolate_;
  Isolate* const isolate_;
  std::unique_ptr<v8::ArrayBuffer::Allocator> array_buffer_allocator_;
  std::vector<SerializableContext> contexts_;
};

}  // namespace internal
}  // namespace v8

#endif  // V8_SNAPSHOT_SNAPSHOT_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/src/snapshot/sort-builtins.cc                                                   0000664 0000000 0000000 00000027061 14746647661 0021626 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "sort-builtins.h"

#include <algorithm>
#include <fstream>

#include "src/snapshot/embedded/embedded-data-inl.h"
#include "src/snapshot/embedded/embedded-data.h"

namespace v8 {
namespace internal {

Cluster::Cluster(uint32_t density, uint32_t size, Builtin target,
                 BuiltinsSorter* sorter)
    : density_(density), size_(size), sorter_(sorter) {
  CHECK(size_);
  targets_.push_back(target);
  sorter_->builtin_cluster_map_[target] = this;
}

BuiltinsSorter::BuiltinsSorter() {}

BuiltinsSorter::~BuiltinsSorter() {
  for (Cluster* cls : clusters_) {
    delete cls;
  }
}

void Cluster::Merge(Cluster* other) {
  for (Builtin builtin : other->targets_) {
    targets_.push_back(builtin);
    sorter_->builtin_cluster_map_.emplace(builtin, this);
  }
  density_ = static_cast<uint32_t>(
      (time_approximation() + other->time_approximation()) /
      (size_ + other->size_));
  size_ += other->size_;
  other->density_ = 0;
  other->size_ = 0;
  other->targets_.clear();
}

uint64_t Cluster::time_approximation() {
  return static_cast<uint64_t>(size_) * density_;
}

void BuiltinsSorter::InitializeClusters() {
  for (uint32_t i = 0; i < static_cast<uint32_t>(builtin_size_.size()); i++) {
    Builtin id = Builtins::FromInt(i);
    Builtins::Kind kind = Builtins::KindOf(id);
    if (kind == Builtins::Kind::ASM || kind == Builtins::Kind::CPP) {
      // CHECK there is no data for execution count for non TurboFan compiled
      // builtin.
      CHECK_EQ(builtin_density_map_[id], 0);
      continue;
    }
    Cluster* cls =
        new Cluster(builtin_density_map_[id], builtin_size_[i], id, this);
    clusters_.push_back(cls);
    builtin_density_order_.push_back(
        BuiltinDensitySlot{builtin_density_map_[id], id});
  }

  std::sort(builtin_density_order_.begin(), builtin_density_order_.end(),
            [](const BuiltinDensitySlot& x, const BuiltinDensitySlot& y) {
              return x.density_ > y.density_;
            });
}

Builtin BuiltinsSorter::FindBestPredecessorOf(Builtin callee) {
  Builtin bestPred = Builtin::kNoBuiltinId;
  int32_t bestProb = 0;

  for (auto caller_it = call_graph_.begin(); caller_it != call_graph_.end();
       caller_it++) {
    Builtin caller = caller_it->first;
    const CallProbabilities& callees_prob = caller_it->second;
    if (callees_prob.count(callee) > 0) {
      int32_t incoming_prob = callees_prob.at(callee).incoming_;
      if (incoming_prob == -1) {
        // We dont want to merge any cluster with -1 prob, because it means it's
        // either a non TurboFan compiled builtin or its execution count too
        // small.
        continue;
      }
      if (bestPred == Builtin::kNoBuiltinId || incoming_prob > bestProb) {
        bestPred = caller;
        bestProb = incoming_prob;
      }
    }

    if (bestProb < kMinEdgeProbabilityThreshold ||
        bestPred == Builtin::kNoBuiltinId)
      continue;

    Cluster* predCls = builtin_cluster_map_[bestPred];
    Cluster* succCls = builtin_cluster_map_[callee];

    // Don't merge if the caller and callee are already in same cluster.
    if (predCls == succCls) continue;
    // Don't merge clusters if the combined size is too big.
    if (predCls->size_ + succCls->size_ > kMaxClusterSize) continue;
    if (predCls->density_ == 0) {
      // Some density of cluster after normalized may be 0, in that case we dont
      // merge them.
      continue;
    }
    CHECK(predCls->size_);

    uint32_t new_density = static_cast<uint32_t>(
        (predCls->time_approximation() + succCls->time_approximation()) /
        (predCls->size_ + succCls->size_));

    // Don't merge clusters if the new merged density is lower too many times
    // than current cluster, to avoid a huge dropping in cluster density, it
    // will harm locality of builtins.
    if (predCls->density_ / kMaxDensityDecreaseThreshold > new_density)
      continue;
  }

  return bestPred;
}

void BuiltinsSorter::MergeBestPredecessors() {
  for (size_t i = 0; i < builtin_density_order_.size(); i++) {
    Builtin id = builtin_density_order_[i].builtin_;
    Cluster* succ_cluster = builtin_cluster_map_[id];

    Builtin bestPred = FindBestPredecessorOf(id);
    if (bestPred != Builtin::kNoBuiltinId) {
      Cluster* pred_cluster = builtin_cluster_map_[bestPred];
      pred_cluster->Merge(succ_cluster);
    }
  }
}

void BuiltinsSorter::SortClusters() {
  std::sort(clusters_.begin(), clusters_.end(),
            [](const Cluster* x, const Cluster* y) {
              return x->density_ > y->density_;
            });

  clusters_.erase(
      std::remove_if(clusters_.begin(), clusters_.end(),
                     [](const Cluster* x) { return x->targets_.empty(); }),
      clusters_.end());
}

bool AddBuiltinIfNotProcessed(Builtin builtin, std::vector<Builtin>& order,
                              std::unordered_set<Builtin>& processed_builtins) {
  if (processed_builtins.count(builtin) == 0) {
    order.push_back(builtin);
    processed_builtins.emplace(builtin);
    return true;
  }
  return false;
}

void BuiltinsSorter::ProcessBlockCountLineInfo(
    std::istringstream& line_stream,
    std::unordered_map<std::string, Builtin>& name2id) {
  // Any line starting with kBuiltinCallBlockDensityMarker is a normalized
  // execution count of block with call. The format is:
  //   literal kBuiltinCallBlockDensityMarker , caller , block ,
  //   normalized_count
  std::string token;
  std::string caller_name;
  CHECK(std::getline(line_stream, caller_name, ','));
  Builtin caller_id = name2id[caller_name];

  BuiltinsCallGraph* profiler = BuiltinsCallGraph::Get();

  char* end = nullptr;
  errno = 0;
  CHECK(std::getline(line_stream, token, ','));
  int32_t block_id = static_cast<int32_t>(strtoul(token.c_str(), &end, 0));
  CHECK(errno == 0 && end != token.c_str());

  CHECK(std::getline(line_stream, token, ','));
  int32_t normalized_count =
      static_cast<int32_t>(strtoul(token.c_str(), &end, 0));
  CHECK(errno == 0 && end != token.c_str());
  CHECK(line_stream.eof());

  const BuiltinCallees* block_callees = profiler->GetBuiltinCallees(caller_id);
  if (block_callees) {
    int32_t outgoing_prob = 0;
    int32_t incoming_prob = 0;
    int caller_density = 0;
    int callee_density = 0;

    CHECK(builtin_density_map_.count(caller_id));
    caller_density = builtin_density_map_.at(caller_id);

    // TODO(v8:13938): Remove the below if check when we just store
    // interesting blocks (contain call other builtins) execution count into
    // profiling file.
    if (block_callees->count(block_id)) {
      // If the line of block density make sense (means it contain call to
      // other builtins in this block).
      for (const auto& callee_id : block_callees->at(block_id)) {
        if (caller_density != 0) {
          outgoing_prob = normalized_count * 100 / caller_density;
        } else {
          // If the caller density was normalized as 0 but the block density
          // was not, we set caller prob as 100, otherwise it's 0. Because in
          // the normalization, we may loss fidelity.
          // For example, a caller was executed 8 times, but after
          // normalization, it may be 0 time. At that time, if the
          // normalized_count of this block (it may be a loop body) is a
          // positive number, we could think normalized_count is bigger than the
          // execution count of caller, hence we set it as 100, otherwise it's
          // smaller than execution count of caller, we could set it as 0.
          outgoing_prob = normalized_count ? 100 : 0;
        }

        if (builtin_density_map_.count(callee_id)) {
          callee_density = builtin_density_map_.at(callee_id);
          if (callee_density != 0) {
            incoming_prob = normalized_count * 100 / callee_density;
          } else {
            // Same as caller prob when callee density exists but is 0.
            incoming_prob = normalized_count ? 100 : 0;
          }

        } else {
          // If callee_density does not exist, it means the callee was not
          // compiled by TurboFan or execution count is too small (0 after
          // normalization), we couldn't get the callee count, so we set it as
          // -1. In that case we could avoid merging this callee builtin into
          // any other cluster.
          incoming_prob = -1;
        }

        CallProbability probs = CallProbability(incoming_prob, outgoing_prob);
        if (call_graph_.count(caller_id) == 0) {
          call_graph_.emplace(caller_id, CallProbabilities());
        }
        CallProbabilities& call_probs = call_graph_.at(caller_id);
        call_probs.emplace(callee_id, probs);
      }
    }
  }
  CHECK(line_stream.eof());
}

void BuiltinsSorter::ProcessBuiltinDensityLineInfo(
    std::istringstream& line_stream,
    std::unordered_map<std::string, Builtin>& name2id) {
  // Any line starting with kBuiltinDensityMarker is normalized execution count
  // for block 0 of a builtin, we take it as density of this builtin. The format
  // is:
  //   literal kBuiltinDensityMarker , builtin_name , density
  std::string token;
  std::string builtin_name;
  CHECK(std::getline(line_stream, builtin_name, ','));
  std::getline(line_stream, token, ',');
  CHECK(line_stream.eof());
  char* end = nullptr;
  errno = 0;
  int density = static_cast<int>(strtol(token.c_str(), &end, 0));
  CHECK(errno == 0 && end != token.c_str());

  Builtin builtin_id = name2id[builtin_name];
  builtin_density_map_.emplace(builtin_id, density);
}

void BuiltinsSorter::InitializeCallGraph(const char* profiling_file,
                                         const std::vector<uint32_t>& size) {
  std::ifstream file(profiling_file);
  CHECK_WITH_MSG(file.good(), "Can't read log file");

  std::unordered_map<std::string, Builtin> name2id;
  for (Builtin i = Builtins::kFirst; i <= Builtins::kLast; ++i) {
    std::string name = Builtins::name(i);
    name2id.emplace(name, i);
    builtin_size_.push_back(size.at(static_cast<uint32_t>(i)));
  }

  for (std::string line; std::getline(file, line);) {
    std::string token;
    std::istringstream line_stream(line);
    // We must put lines start with kBuiltinDensityMarker before lines start
    // with kBuiltinCallBlockDensityMarker, because we have to density to
    // calculate call prob.
    if (!std::getline(line_stream, token, ',')) continue;
    if (token == kBuiltinCallBlockDensityMarker) {
      ProcessBlockCountLineInfo(line_stream, name2id);
    } else if (token == kBuiltinDensityMarker) {
      ProcessBuiltinDensityLineInfo(line_stream, name2id);
    }
  }
}

std::vector<Builtin> BuiltinsSorter::SortBuiltins(
    const char* profiling_file, const std::vector<uint32_t>& builtin_size) {
  InitializeCallGraph(profiling_file, builtin_size);

  // Step 1: initialization.
  InitializeClusters();

  // Step 2: Merge best predecessors.
  MergeBestPredecessors();

  // Step 3: Sort clusters again.
  SortClusters();

  std::unordered_set<Builtin> processed_builtins;
  std::vector<Builtin> builtin_order;

  // For functions in the sorted cluster from step 3.
  for (size_t i = 0; i < clusters_.size(); i++) {
    Cluster* cls = clusters_.at(i);
    for (size_t j = 0; j < cls->targets_.size(); j++) {
      Builtin builtin = cls->targets_[j];
      CHECK(
          AddBuiltinIfNotProcessed(builtin, builtin_order, processed_builtins));
    }
  }

  // For the remaining builtins.
  for (Builtin i = Builtins::kFirst; i <= Builtins::kLast; ++i) {
    AddBuiltinIfNotProcessed(i, builtin_order, processed_builtins);
  }

  return builtin_order;
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/src/snapshot/sort-builtins.h                                                    0000664 0000000 0000000 00000012344 14746647661 0021466 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_SNAPSHOT_SORT_BUILTINS_H_
#define V8_SNAPSHOT_SORT_BUILTINS_H_

#include <unordered_map>
#include <vector>

#include "src/builtins/builtins.h"
#include "src/diagnostics/basic-block-profiler.h"

// The inputs were the builtin size, call graph and basic block execution count.
// There are 3 steps in this sorting algorithm:
// 1. Initializing cluster and sorting:
//  A cluster represents a group of functions. At the beginning, each
//  function was in an individual cluster, and we sort these clusters
//  by their density (which means how much probabilities this function was
//  invoked).
//
// 2. Merge the best predecessor:
//  After step 1, we will get lots of clusters which may contain only
//  one function. According to this order, we iterate each function
//  and merge cluster with some conditions, like:
//   1) The most incoming probability.
//   2) Incoming probability must be bigger than a threshold, like 0.1
//   3) Merged cluster size couldn't be bigger than a threshold, like 1 mb.
//   4) Predecessor cluster density couldn't be bigger N times than the new
//   merged cluster, N is 8 now.
//
// 3. Sorting clusters:
//  After step 2, we obtain lots of clusters which comprise several functions.
//  We will finally sort these clusters by their density.

namespace v8 {
namespace internal {

class Cluster;
struct CallProbability {
  CallProbability(int32_t incoming = 0, int32_t outgoing = 0)
      : incoming_(incoming), outgoing_(outgoing) {}

  // There are a caller and a callee, we assume caller was invoked
  // "caller-count" times, it calls callee "call-count" times, the callee was
  // invoked "callee-count" times. imcoming_ means the possibity the callee
  // calls from caller, it was calculted by call-count / callee-count. If
  // callee-count is 0 (may not be compiled by TurboFan or normalized as 0 due
  // to too small), we set imcoming_ as -1.
  int32_t incoming_;
  // outgoing_ means the possibity the caller
  // calls to callee, it was calculted by call-count / caller-count. If
  // caller-count is 0 (may not be compiled by TurboFan or normalized as 0 due
  // to too small), we set outgoing_ as -1. We didn't use outgoing_ as condition
  // for reordering builtins yet, but we could try to do some experiments with
  // it later for obtaining a better order of builtins.
  int32_t outgoing_;
};
// The key is the callee builtin, the value is call probabilities in percent
// (mostly range in 0 ~ 100, except one call happend in a loop block which was
// executed more times than block 0 of this builtin).
using CallProbabilities = std::unordered_map<Builtin, CallProbability>;
// The key is the caller builtin.
using CallGraph = std::unordered_map<Builtin, CallProbabilities>;
// The key is the builtin id, the value is density of builtin (range in 0 ~
// 10000).
using BuiltinDensityMap = std::unordered_map<Builtin, uint32_t>;
// The index is the builtin id, the value is size of builtin (in bytes).
using BuiltinSize = std::vector<uint32_t>;
// The key is the builtin id, the value is the cluster which it was comprised.
using BuiltinClusterMap = std::unordered_map<Builtin, Cluster*>;

class BuiltinsSorter {
  const int32_t kMinEdgeProbabilityThreshold = 10;
  const uint32_t kMaxClusterSize = 1 * MB;
  const uint32_t kMaxDensityDecreaseThreshold = 8;

  const std::string kBuiltinCallBlockDensityMarker = "block_count";
  const std::string kBuiltinDensityMarker = "builtin_count";

  // Pair of denstity of builtin and builtin id.
  struct BuiltinDensitySlot {
    BuiltinDensitySlot(uint32_t density, Builtin builtin)
        : density_(density), builtin_(builtin) {}

    uint32_t density_;
    Builtin builtin_;
  };

 public:
  BuiltinsSorter();
  ~BuiltinsSorter();
  std::vector<Builtin> SortBuiltins(const char* profiling_file,
                                    const std::vector<uint32_t>& builtin_size);

 private:
  void InitializeCallGraph(const char* profiling_file,
                           const std::vector<uint32_t>& size);
  void InitializeClusters();
  void MergeBestPredecessors();
  void SortClusters();
  Builtin FindBestPredecessorOf(Builtin callee);
  void ProcessBlockCountLineInfo(
      std::istringstream& line_stream,
      std::unordered_map<std::string, Builtin>& name2id);
  void ProcessBuiltinDensityLineInfo(
      std::istringstream& line_stream,
      std::unordered_map<std::string, Builtin>& name2id);

  std::vector<Cluster*> clusters_;

  std::vector<BuiltinDensitySlot> builtin_density_order_;

  CallGraph call_graph_;

  BuiltinDensityMap builtin_density_map_;

  BuiltinSize builtin_size_;

  BuiltinClusterMap builtin_cluster_map_;

  friend class Cluster;
};

class Cluster {
 public:
  Cluster(uint32_t density, uint32_t size, Builtin target,
          BuiltinsSorter* sorter);
  void Merge(Cluster* other);
  uint64_t time_approximation();

 private:
  // Max initialized density was normalized as 10000.
  uint32_t density_;
  // Size of the cluster in bytes.
  uint32_t size_;
  std::vector<Builtin> targets_;
  BuiltinsSorter* sorter_;

  friend class BuiltinsSorter;
};

}  // namespace internal

}  // namespace v8

#endif  // V8_SNAPSHOT_SORT_BUILTINS_H_
                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/src/snapshot/startup-deserializer.cc                                            0000664 0000000 0000000 00000010547 14746647661 0023173 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/snapshot/startup-deserializer.h"

#include "src/api/api.h"
#include "src/codegen/flush-instruction-cache.h"
#include "src/execution/v8threads.h"
#include "src/handles/handles-inl.h"
#include "src/heap/paged-spaces-inl.h"
#include "src/logging/counters-scopes.h"
#include "src/logging/log.h"
#include "src/objects/oddball.h"
#include "src/roots/roots-inl.h"

namespace v8 {
namespace internal {

void StartupDeserializer::DeserializeIntoIsolate() {
  TRACE_EVENT0("v8", "V8.DeserializeIsolate");
  RCS_SCOPE(isolate(), RuntimeCallCounterId::kDeserializeIsolate);
  base::ElapsedTimer timer;
  if (V8_UNLIKELY(v8_flags.profile_deserialization)) timer.Start();
  NestedTimedHistogramScope histogram_timer(
      isolate()->counters()->snapshot_deserialize_isolate());
  HandleScope scope(isolate());

  // No active threads.
  DCHECK_NULL(isolate()->thread_manager()->FirstThreadStateInUse());
  // No active handles.
  DCHECK(isolate()->handle_scope_implementer()->blocks()->empty());
  // Startup object cache is not yet populated.
  DCHECK(isolate()->startup_object_cache()->empty());
  // Builtins are not yet created.
  DCHECK(!isolate()->builtins()->is_initialized());

  {
    DeserializeAndCheckExternalReferenceTable();

    isolate()->heap()->IterateSmiRoots(this);
    isolate()->heap()->IterateRoots(
        this,
        base::EnumSet<SkipRoot>{SkipRoot::kUnserializable, SkipRoot::kWeak,
                                SkipRoot::kTracedHandles});
    IterateStartupObjectCache(isolate(), this);

    isolate()->heap()->IterateWeakRoots(
        this, base::EnumSet<SkipRoot>{SkipRoot::kUnserializable});
    DeserializeDeferredObjects();
    for (DirectHandle<AccessorInfo> info : accessor_infos()) {
      RestoreExternalReferenceRedirector(isolate(), *info);
    }
    for (DirectHandle<FunctionTemplateInfo> info : function_template_infos()) {
      RestoreExternalReferenceRedirector(isolate(), *info);
    }

    // Flush the instruction cache for the entire code-space. Must happen after
    // builtins deserialization.
    FlushICache();
  }

  isolate()->heap()->set_native_contexts_list(
      ReadOnlyRoots(isolate()).undefined_value());
  // The allocation site list is build during root iteration, but if no sites
  // were encountered then it needs to be initialized to undefined.
  if (isolate()->heap()->allocation_sites_list() == Smi::zero()) {
    isolate()->heap()->set_allocation_sites_list(
        ReadOnlyRoots(isolate()).undefined_value());
  }
  isolate()->heap()->set_dirty_js_finalization_registries_list(
      ReadOnlyRoots(isolate()).undefined_value());
  isolate()->heap()->set_dirty_js_finalization_registries_list_tail(
      ReadOnlyRoots(isolate()).undefined_value());

  isolate()->builtins()->MarkInitialized();

  LogNewMapEvents();
  WeakenDescriptorArrays();

  if (should_rehash()) {
    // Hash seed was initialized in ReadOnlyDeserializer.
    Rehash();
  }

  if (V8_UNLIKELY(v8_flags.profile_deserialization)) {
    // ATTENTION: The Memory.json benchmark greps for this exact output. Do not
    // change it without also updating Memory.json.
    const int bytes = source()->length();
    const double ms = timer.Elapsed().InMillisecondsF();
    PrintF("[Deserializing isolate (%d bytes) took %0.3f ms]\n", bytes, ms);
  }
}

void StartupDeserializer::DeserializeAndCheckExternalReferenceTable() {
  // Verify that any external reference entries that were deduplicated in the
  // serializer are also deduplicated in this isolate.
  ExternalReferenceTable* table = isolate()->external_reference_table();
  while (true) {
    uint32_t index = source()->GetUint30();
    if (index == ExternalReferenceTable::kSizeIsolateIndependent) break;
    uint32_t encoded_index = source()->GetUint30();
    CHECK_EQ(table->address(index), table->address(encoded_index));
  }
}

void StartupDeserializer::LogNewMapEvents() {
  if (v8_flags.log_maps) LOG(isolate(), LogAllMaps());
}

void StartupDeserializer::FlushICache() {
  DCHECK(!deserializing_user_code());
  // The entire isolate is newly deserialized. Simply flush all code pages.
  for (PageMetadata* p : *isolate()->heap()->code_space()) {
    FlushInstructionCache(p->area_start(), p->area_end() - p->area_start());
  }
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                         node-23.7.0/deps/v8/src/snapshot/startup-deserializer.h                                             0000664 0000000 0000000 00000002126 14746647661 0023027 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_SNAPSHOT_STARTUP_DESERIALIZER_H_
#define V8_SNAPSHOT_STARTUP_DESERIALIZER_H_

#include "src/snapshot/deserializer.h"
#include "src/snapshot/snapshot-data.h"

namespace v8 {
namespace internal {

// Initializes an isolate with context-independent data from a given snapshot.
class StartupDeserializer final : public Deserializer<Isolate> {
 public:
  explicit StartupDeserializer(Isolate* isolate,
                               const SnapshotData* startup_data,
                               bool can_rehash)
      : Deserializer(isolate, startup_data->Payload(),
                     startup_data->GetMagicNumber(), false, can_rehash) {}

  // Deserialize the snapshot into an empty heap.
  void DeserializeIntoIsolate();

 private:
  void FlushICache();
  void LogNewMapEvents();
  void DeserializeAndCheckExternalReferenceTable();
};

}  // namespace internal
}  // namespace v8

#endif  // V8_SNAPSHOT_STARTUP_DESERIALIZER_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/src/snapshot/startup-serializer.cc                                              0000664 0000000 0000000 00000021764 14746647661 0022665 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/snapshot/startup-serializer.h"

#include "src/execution/v8threads.h"
#include "src/handles/global-handles-inl.h"
#include "src/heap/heap-inl.h"
#include "src/heap/read-only-heap.h"
#include "src/objects/contexts.h"
#include "src/objects/objects-inl.h"
#include "src/objects/slots.h"
#include "src/snapshot/read-only-serializer.h"
#include "src/snapshot/shared-heap-serializer.h"

namespace v8 {
namespace internal {

namespace {

// The isolate roots may not point at context-specific objects during
// serialization.
class V8_NODISCARD SanitizeIsolateScope final {
 public:
  SanitizeIsolateScope(Isolate* isolate, bool allow_active_isolate_for_testing,
                       const DisallowGarbageCollection& no_gc)
      : isolate_(isolate),
        feedback_vectors_for_profiling_tools_(
            isolate->heap()->feedback_vectors_for_profiling_tools()),
        detached_contexts_(isolate->heap()->detached_contexts()) {
#ifdef DEBUG
    if (!allow_active_isolate_for_testing) {
      // These should already be empty when creating a real snapshot.
      DCHECK_EQ(feedback_vectors_for_profiling_tools_,
                ReadOnlyRoots(isolate).undefined_value());
      DCHECK_EQ(detached_contexts_,
                ReadOnlyRoots(isolate).empty_weak_array_list());
    }
#endif

    isolate->SetFeedbackVectorsForProfilingTools(
        ReadOnlyRoots(isolate).undefined_value());
    isolate->heap()->SetDetachedContexts(
        ReadOnlyRoots(isolate).empty_weak_array_list());
  }

  ~SanitizeIsolateScope() {
    // Restore saved fields.
    isolate_->SetFeedbackVectorsForProfilingTools(
        feedback_vectors_for_profiling_tools_);
    isolate_->heap()->SetDetachedContexts(detached_contexts_);
  }

 private:
  Isolate* isolate_;
  const Tagged<Object> feedback_vectors_for_profiling_tools_;
  const Tagged<WeakArrayList> detached_contexts_;
};

}  // namespace

StartupSerializer::StartupSerializer(
    Isolate* isolate, Snapshot::SerializerFlags flags,
    SharedHeapSerializer* shared_heap_serializer)
    : RootsSerializer(isolate, flags, RootIndex::kFirstStrongRoot),
      shared_heap_serializer_(shared_heap_serializer),
      accessor_infos_(isolate->heap()),
      function_template_infos_(isolate->heap()) {
  InitializeCodeAddressMap();

  // This serializes any external reference which don't encode to their own
  // index. This is so that the deserializer can verify that any entries that
  // were deduplicated during serialization are also deduplicated in the
  // deserializing binary.
  ExternalReferenceTable* table = isolate->external_reference_table();
  for (uint32_t i = 0; i < ExternalReferenceTable::kSizeIsolateIndependent;
       ++i) {
    ExternalReferenceEncoder::Value encoded_reference =
        EncodeExternalReference(table->address(i));
    if (encoded_reference.index() != i) {
      sink_.PutUint30(i, "expected reference index");
      sink_.PutUint30(encoded_reference.index(), "actual reference index");
    }
  }
  sink_.PutUint30(ExternalReferenceTable::kSizeIsolateIndependent,
                  "end of deduplicated reference indices");
}

StartupSerializer::~StartupSerializer() {
  for (DirectHandle<AccessorInfo> info : accessor_infos_) {
    RestoreExternalReferenceRedirector(isolate(), *info);
  }
  for (DirectHandle<FunctionTemplateInfo> info : function_template_infos_) {
    RestoreExternalReferenceRedirector(isolate(), *info);
  }
  OutputStatistics("StartupSerializer");
}

void StartupSerializer::SerializeObjectImpl(Handle<HeapObject> obj,
                                            SlotType slot_type) {
  PtrComprCageBase cage_base(isolate());
#ifdef DEBUG
  if (IsJSFunction(*obj, cage_base)) {
    v8::base::OS::PrintError("Reference stack:\n");
    PrintStack(std::cerr);
    Print(*obj, std::cerr);
    FATAL(
        "JSFunction should be added through the context snapshot instead of "
        "the isolate snapshot");
  }
#endif  // DEBUG
  {
    DisallowGarbageCollection no_gc;
    Tagged<HeapObject> raw = *obj;
    DCHECK(!IsInstructionStream(raw));
    if (SerializeHotObject(raw)) return;
    if (IsRootAndHasBeenSerialized(raw) && SerializeRoot(raw)) return;
  }

  if (SerializeReadOnlyObjectReference(*obj, &sink_)) return;
  if (SerializeUsingSharedHeapObjectCache(&sink_, obj)) return;
  if (SerializeBackReference(*obj)) return;

  if (USE_SIMULATOR_BOOL && IsAccessorInfo(*obj, cage_base)) {
    // Wipe external reference redirects in the accessor info.
    auto info = Cast<AccessorInfo>(obj);
    info->remove_getter_redirection(isolate());
    accessor_infos_.Push(*info);
  } else if (USE_SIMULATOR_BOOL && IsFunctionTemplateInfo(*obj, cage_base)) {
    auto info = Cast<FunctionTemplateInfo>(obj);
    info->remove_callback_redirection(isolate());
    function_template_infos_.Push(*info);
  } else if (IsScript(*obj, cage_base) &&
             Cast<Script>(obj)->IsUserJavaScript()) {
    Cast<Script>(obj)->set_context_data(
        ReadOnlyRoots(isolate()).uninitialized_symbol());
  } else if (IsSharedFunctionInfo(*obj, cage_base)) {
    // Clear inferred name for native functions.
    auto shared = Cast<SharedFunctionInfo>(obj);
    if (!shared->IsSubjectToDebugging() && shared->HasUncompiledData()) {
      shared->uncompiled_data(isolate())->set_inferred_name(
          ReadOnlyRoots(isolate()).empty_string());
    }
  }

  CheckRehashability(*obj);

  // Object has not yet been serialized.  Serialize it here.
  DCHECK(!ReadOnlyHeap::Contains(*obj));
  ObjectSerializer object_serializer(this, obj, &sink_);
  object_serializer.Serialize(slot_type);
}

void StartupSerializer::SerializeWeakReferencesAndDeferred() {
  // This comes right after serialization of the context snapshot, where we
  // add entries to the startup object cache of the startup snapshot. Add
  // one entry with 'undefined' to terminate the startup object cache.
  Tagged<Object> undefined = ReadOnlyRoots(isolate()).undefined_value();
  VisitRootPointer(Root::kStartupObjectCache, nullptr,
                   FullObjectSlot(&undefined));

  isolate()->heap()->IterateWeakRoots(
      this, base::EnumSet<SkipRoot>{SkipRoot::kUnserializable});
  SerializeDeferredObjects();
  Pad();
}

void StartupSerializer::SerializeStrongReferences(
    const DisallowGarbageCollection& no_gc) {
  Isolate* isolate = this->isolate();
  // No active threads.
  CHECK_NULL(isolate->thread_manager()->FirstThreadStateInUse());

  SanitizeIsolateScope sanitize_isolate(
      isolate, allow_active_isolate_for_testing(), no_gc);

  // Visit smi roots and immortal immovables first to make sure they end up in
  // the first page.
  isolate->heap()->IterateSmiRoots(this);
  isolate->heap()->IterateRoots(
      this, base::EnumSet<SkipRoot>{SkipRoot::kUnserializable, SkipRoot::kWeak,
                                    SkipRoot::kTracedHandles});
}

SerializedHandleChecker::SerializedHandleChecker(
    Isolate* isolate, std::vector<Tagged<Context>>* contexts)
    : isolate_(isolate) {
  AddToSet(Cast<FixedArray>(isolate->heap()->serialized_objects()));
  for (auto const& context : *contexts) {
    AddToSet(Cast<FixedArray>(context->serialized_objects()));
  }
}

bool StartupSerializer::SerializeUsingSharedHeapObjectCache(
    SnapshotByteSink* sink, Handle<HeapObject> obj) {
  return shared_heap_serializer_->SerializeUsingSharedHeapObjectCache(sink,
                                                                      obj);
}

void StartupSerializer::SerializeUsingStartupObjectCache(
    SnapshotByteSink* sink, Handle<HeapObject> obj) {
  int cache_index = SerializeInObjectCache(obj);
  sink->Put(kStartupObjectCache, "StartupObjectCache");
  sink->PutUint30(cache_index, "startup_object_cache_index");
}

void StartupSerializer::CheckNoDirtyFinalizationRegistries() {
  Isolate* isolate = this->isolate();
  CHECK(IsUndefined(isolate->heap()->dirty_js_finalization_registries_list(),
                    isolate));
  CHECK(IsUndefined(
      isolate->heap()->dirty_js_finalization_registries_list_tail(), isolate));
}

void SerializedHandleChecker::AddToSet(Tagged<FixedArray> serialized) {
  int length = serialized->length();
  for (int i = 0; i < length; i++) serialized_.insert(serialized->get(i));
}

void SerializedHandleChecker::VisitRootPointers(Root root,
                                                const char* description,
                                                FullObjectSlot start,
                                                FullObjectSlot end) {
  for (FullObjectSlot p = start; p < end; ++p) {
    if (serialized_.find(*p) != serialized_.end()) continue;
    PrintF("%s handle not serialized: ",
           root == Root::kGlobalHandles ? "global" : "eternal");
    Print(*p);
    PrintF("\n");
    ok_ = false;
  }
}

bool SerializedHandleChecker::CheckGlobalAndEternalHandles() {
  isolate_->global_handles()->IterateAllRoots(this);
  isolate_->traced_handles()->Iterate(this);
  isolate_->eternal_handles()->IterateAllRoots(this);
  return ok_;
}

}  // namespace internal
}  // namespace v8
            node-23.7.0/deps/v8/src/snapshot/startup-serializer.h                                               0000664 0000000 0000000 00000005455 14746647661 0022526 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_SNAPSHOT_STARTUP_SERIALIZER_H_
#define V8_SNAPSHOT_STARTUP_SERIALIZER_H_

#include <unordered_set>

#include "src/handles/global-handles.h"
#include "src/snapshot/roots-serializer.h"

namespace v8 {
namespace internal {

class HeapObject;
class SnapshotByteSink;
class SharedHeapSerializer;

class V8_EXPORT_PRIVATE StartupSerializer : public RootsSerializer {
 public:
  StartupSerializer(Isolate* isolate, Snapshot::SerializerFlags flags,
                    SharedHeapSerializer* shared_heap_serializer);
  ~StartupSerializer() override;
  StartupSerializer(const StartupSerializer&) = delete;
  StartupSerializer& operator=(const StartupSerializer&) = delete;

  // Serialize the current state of the heap.  The order is:
  // 1) Strong roots
  // 2) Builtins and bytecode handlers
  // 3) Startup object cache
  // 4) Weak references (e.g. the string table)
  void SerializeStrongReferences(const DisallowGarbageCollection& no_gc);
  void SerializeWeakReferencesAndDeferred();

  // If |obj| can be serialized in the shared heap snapshot then add it to the
  // shareable object cache if not already present and emits a
  // SharedHeapObjectCache bytecode into |sink|. Returns whether this was
  // successful.
  bool SerializeUsingSharedHeapObjectCache(SnapshotByteSink* sink,
                                           Handle<HeapObject> obj);

  // Adds |obj| to the startup object object cache if not already present and
  // emits a StartupObjectCache bytecode into |sink|.
  void SerializeUsingStartupObjectCache(SnapshotByteSink* sink,
                                        Handle<HeapObject> obj);

  // The per-heap dirty FinalizationRegistry list is weak and not serialized. No
  // JSFinalizationRegistries should be used during startup.
  void CheckNoDirtyFinalizationRegistries();

 private:
  void SerializeObjectImpl(Handle<HeapObject> o, SlotType slot_type) override;

  SharedHeapSerializer* const shared_heap_serializer_;
  GlobalHandleVector<AccessorInfo> accessor_infos_;
  GlobalHandleVector<FunctionTemplateInfo> function_template_infos_;
};

class SerializedHandleChecker : public RootVisitor {
 public:
  SerializedHandleChecker(Isolate* isolate,
                          std::vector<Tagged<Context>>* contexts);
  void VisitRootPointers(Root root, const char* description,
                         FullObjectSlot start, FullObjectSlot end) override;
  bool CheckGlobalAndEternalHandles();

 private:
  void AddToSet(Tagged<FixedArray> serialized);

  Isolate* isolate_;
  std::unordered_set<Tagged<Object>, Object::Hasher> serialized_;
  bool ok_ = true;
};

}  // namespace internal
}  // namespace v8

#endif  // V8_SNAPSHOT_STARTUP_SERIALIZER_H_
                                                                                                                                                                                                                   node-23.7.0/deps/v8/src/snapshot/static-roots-gen.cc                                                0000664 0000000 0000000 00000011551 14746647661 0022207 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/snapshot/static-roots-gen.h"

#include <fstream>

#include "src/common/globals.h"
#include "src/common/ptr-compr-inl.h"
#include "src/execution/isolate.h"
#include "src/objects/instance-type-inl.h"
#include "src/objects/instance-type.h"
#include "src/objects/objects-definitions.h"
#include "src/objects/visitors.h"
#include "src/roots/roots-inl.h"
#include "src/roots/roots.h"

namespace v8 {
namespace internal {

class StaticRootsTableGenImpl {
 public:
  explicit StaticRootsTableGenImpl(Isolate* isolate) {
    // Collect all roots
    ReadOnlyRoots ro_roots(isolate);
    {
      RootIndex pos = RootIndex::kFirstReadOnlyRoot;
#define ADD_ROOT(_, value, CamelName)                       \
  {                                                         \
    Tagged_t ptr = V8HeapCompressionScheme::CompressObject( \
        ro_roots.unchecked_##value().ptr());                \
    sorted_roots_[ptr].push_back(pos);                      \
    camel_names_[RootIndex::k##CamelName] = #CamelName;     \
    ++pos;                                                  \
  }
      READ_ONLY_ROOT_LIST(ADD_ROOT)
#undef ADD_ROOT
    }
  }

  const std::map<Tagged_t, std::list<RootIndex>>& sorted_roots() {
    return sorted_roots_;
  }

  const std::string& camel_name(RootIndex idx) { return camel_names_.at(idx); }

 private:
  std::map<Tagged_t, std::list<RootIndex>> sorted_roots_;
  std::unordered_map<RootIndex, std::string> camel_names_;
};

void StaticRootsTableGen::write(Isolate* isolate, const char* file) {
  CHECK_WITH_MSG(!V8_STATIC_ROOTS_BOOL,
                 "Re-generating the table of roots is only supported in builds "
                 "with v8_enable_static_roots disabled");
  CHECK(V8_STATIC_ROOTS_GENERATION_BOOL);
  CHECK(file);
  static_assert(static_cast<int>(RootIndex::kFirstReadOnlyRoot) == 0);

  std::ofstream out(file, std::ios::binary);

  out << "// Copyright 2022 the V8 project authors. All rights reserved.\n"
      << "// Use of this source code is governed by a BSD-style license "
         "that can be\n"
      << "// found in the LICENSE file.\n"
      << "\n"
      << "// This file is automatically generated by "
         "`tools/dev/gen-static-roots.py`. Do\n// not edit manually.\n"
      << "\n"
      << "#ifndef V8_ROOTS_STATIC_ROOTS_H_\n"
      << "#define V8_ROOTS_STATIC_ROOTS_H_\n"
      << "\n"
      << "#include \"src/common/globals.h\"\n"
      << "\n"
      << "#if V8_STATIC_ROOTS_BOOL\n"
      << "\n"
      << "#include \"src/roots/roots.h\"\n"
      << "\n"
      << "// Disabling Wasm or Intl invalidates the contents of "
         "static-roots.h.\n"
      << "// TODO(olivf): To support static roots for multiple build "
         "configurations we\n"
      << "//              will need to generate target specific versions of "
         "this file.\n"
      << "static_assert(V8_ENABLE_WEBASSEMBLY);\n"
      << "static_assert(V8_INTL_SUPPORT);\n"
      << "\n"
      << "namespace v8 {\n"
      << "namespace internal {\n"
      << "\n"
      << "struct StaticReadOnlyRoot {\n";

  // Output a symbol for every root. Ordered by ptr to make it easier to see the
  // memory layout of the read only page.
  const auto size = static_cast<int>(RootIndex::kReadOnlyRootsCount);
  StaticRootsTableGenImpl gen(isolate);

  for (auto& entry : gen.sorted_roots()) {
    Tagged_t ptr = entry.first;
    CHECK_LT(ptr, kRegularPageSize);
    const std::list<RootIndex>& roots = entry.second;

    for (RootIndex root : roots) {
      static const char* kPreString = "  static constexpr Tagged_t k";
      const std::string& name = gen.camel_name(root);
      size_t ptr_len = ceil(log2(ptr) / 4.0);
      // Full line is: "kPreString|name = 0x.....;"
      size_t len = strlen(kPreString) + name.length() + 5 + ptr_len + 1;
      out << kPreString << name << " =";
      if (len > 80) out << "\n     ";
      out << " 0x" << std::hex << ptr << std::dec << ";\n";
    }
  }

  out << "\n";
  out << "  static constexpr Tagged_t kFirstAllocatedRoot = 0x" << std::hex
      << gen.sorted_roots().cbegin()->first << std::dec << ";\n";
  out << "  static constexpr Tagged_t kLastAllocatedRoot = 0x" << std::hex
      << gen.sorted_roots().crbegin()->first << std::dec << ";\n";
  out << "};\n";

  // Output in order of roots table
  out << "\nstatic constexpr std::array<Tagged_t, " << size
      << "> StaticReadOnlyRootsPointerTable = {\n";

  {
#define ENTRY(_1, _2, CamelName) \
  out << "    StaticReadOnlyRoot::k" << #CamelName << ",\n";
    READ_ONLY_ROOT_LIST(ENTRY)
#undef ENTRY
    out << "};\n";
  }
  out << "\n"
      << "}  // namespace internal\n"
      << "}  // namespace v8\n"
      << "#endif  // V8_STATIC_ROOTS_BOOL\n"
      << "#endif  // V8_ROOTS_STATIC_ROOTS_H_\n";
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                       node-23.7.0/deps/v8/src/snapshot/static-roots-gen.h                                                 0000664 0000000 0000000 00000000750 14746647661 0022050 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_SNAPSHOT_STATIC_ROOTS_GEN_H_
#define V8_SNAPSHOT_STATIC_ROOTS_GEN_H_

namespace v8 {
namespace internal {

class Isolate;

class StaticRootsTableGen {
 public:
  static void write(Isolate* isolate, const char* file);
};

}  // namespace internal
}  // namespace v8

#endif  // V8_SNAPSHOT_STATIC_ROOTS_GEN_H_
                        node-23.7.0/deps/v8/src/strings/                                                                    0000775 0000000 0000000 00000000000 14746647661 0016325 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/src/strings/DIR_METADATA                                                        0000664 0000000 0000000 00000000635 14746647661 0020132 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Metadata information for this directory.
#
# For more information on DIR_METADATA files, see:
#   https://source.chromium.org/chromium/infra/infra/+/master:go/src/infra/tools/dirmd/README.md
#
# For the schema of this file, see Metadata message:
#   https://source.chromium.org/chromium/infra/infra/+/master:go/src/infra/tools/dirmd/proto/dir_metadata.proto

monorail {
  component: "Blink>JavaScript>Runtime"
}                                                                                                   node-23.7.0/deps/v8/src/strings/OWNERS                                                              0000664 0000000 0000000 00000000102 14746647661 0017256 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        jkummerow@chromium.org
leszeks@chromium.org
verwaest@chromium.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/src/strings/char-predicates-inl.h                                               0000664 0000000 0000000 00000013303 14746647661 0022314 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2011 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_STRINGS_CHAR_PREDICATES_INL_H_
#define V8_STRINGS_CHAR_PREDICATES_INL_H_

#include "src/base/bounds.h"
#include "src/strings/char-predicates.h"
#include "src/utils/utils.h"

namespace v8 {
namespace internal {

// If c is in 'A'-'Z' or 'a'-'z', return its lower-case.
// Else, return something outside of 'A'-'Z' and 'a'-'z'.
// Note: it ignores LOCALE.
inline constexpr int AsciiAlphaToLower(base::uc32 c) { return c | 0x20; }

inline constexpr bool IsCarriageReturn(base::uc32 c) { return c == 0x000D; }

inline constexpr bool IsLineFeed(base::uc32 c) { return c == 0x000A; }

inline constexpr bool IsAsciiIdentifier(base::uc32 c) {
  return IsAlphaNumeric(c) || c == '$' || c == '_';
}

inline constexpr bool IsAlphaNumeric(base::uc32 c) {
  return base::IsInRange(AsciiAlphaToLower(c), 'a', 'z') || IsDecimalDigit(c);
}

inline constexpr bool IsDecimalDigit(base::uc32 c) {
  // ECMA-262, 3rd, 7.8.3 (p 16)
  return base::IsInRange(c, '0', '9');
}

inline constexpr bool IsHexDigit(base::uc32 c) {
  // ECMA-262, 3rd, 7.6 (p 15)
  return IsDecimalDigit(c) || base::IsInRange(AsciiAlphaToLower(c), 'a', 'f');
}

inline constexpr bool IsOctalDigit(base::uc32 c) {
  // ECMA-262, 6th, 7.8.3
  return base::IsInRange(c, '0', '7');
}

inline constexpr bool IsNonOctalDecimalDigit(base::uc32 c) {
  return base::IsInRange(c, '8', '9');
}

inline constexpr bool IsBinaryDigit(base::uc32 c) {
  // ECMA-262, 6th, 7.8.3
  return c == '0' || c == '1';
}

inline constexpr bool IsAsciiLower(base::uc32 c) {
  return base::IsInRange(c, 'a', 'z');
}

inline constexpr bool IsAsciiUpper(base::uc32 c) {
  return base::IsInRange(c, 'A', 'Z');
}

inline constexpr base::uc32 ToAsciiUpper(base::uc32 c) {
  return c & ~(IsAsciiLower(c) << 5);
}

inline constexpr base::uc32 ToAsciiLower(base::uc32 c) {
  return c | (IsAsciiUpper(c) << 5);
}

inline constexpr bool IsRegExpWord(base::uc32 c) {
  return IsAlphaNumeric(c) || c == '_';
}

// Constexpr cache table for character flags.
enum OneByteCharFlags {
  kIsIdentifierStart = 1 << 0,
  kIsIdentifierPart = 1 << 1,
  kIsWhiteSpace = 1 << 2,
  kIsWhiteSpaceOrLineTerminator = 1 << 3,
  kMaybeLineEnd = 1 << 4
};

// See http://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt
// ID_Start. Additionally includes '_' and '$'.
constexpr bool IsOneByteIDStart(base::uc32 c) {
  return c == 0x0024 || (c >= 0x0041 && c <= 0x005A) || c == 0x005F ||
         (c >= 0x0061 && c <= 0x007A) || c == 0x00AA || c == 0x00B5 ||
         c == 0x00BA || (c >= 0x00C0 && c <= 0x00D6) ||
         (c >= 0x00D8 && c <= 0x00F6) || (c >= 0x00F8 && c <= 0x00FF);
}

// See http://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt
// ID_Continue. Additionally includes '_' and '$'.
constexpr bool IsOneByteIDContinue(base::uc32 c) {
  return c == 0x0024 || (c >= 0x0030 && c <= 0x0039) || c == 0x005F ||
         (c >= 0x0041 && c <= 0x005A) || (c >= 0x0061 && c <= 0x007A) ||
         c == 0x00AA || c == 0x00B5 || c == 0x00B7 || c == 0x00BA ||
         (c >= 0x00C0 && c <= 0x00D6) || (c >= 0x00D8 && c <= 0x00F6) ||
         (c >= 0x00F8 && c <= 0x00FF);
}

constexpr bool IsOneByteWhitespace(base::uc32 c) {
  return c == '\t' || c == '\v' || c == '\f' || c == ' ' || c == u'\xa0';
}

constexpr uint8_t BuildOneByteCharFlags(base::uc32 c) {
  uint8_t result = 0;
  if (IsOneByteIDStart(c) || c == '\\') result |= kIsIdentifierStart;
  if (IsOneByteIDContinue(c) || c == '\\') result |= kIsIdentifierPart;
  if (IsOneByteWhitespace(c)) {
    result |= kIsWhiteSpace | kIsWhiteSpaceOrLineTerminator;
  }
  if (c == '\r' || c == '\n') {
    result |= kIsWhiteSpaceOrLineTerminator | kMaybeLineEnd;
  }
  // Add markers to identify 0x2028 and 0x2029.
  if (c == static_cast<uint8_t>(0x2028) || c == static_cast<uint8_t>(0x2029)) {
    result |= kMaybeLineEnd;
  }
  return result;
}
const constexpr uint8_t kOneByteCharFlags[256] = {
#define BUILD_CHAR_FLAGS(N) BuildOneByteCharFlags(N),
    INT_0_TO_127_LIST(BUILD_CHAR_FLAGS)
#undef BUILD_CHAR_FLAGS
#define BUILD_CHAR_FLAGS(N) BuildOneByteCharFlags(N + 128),
        INT_0_TO_127_LIST(BUILD_CHAR_FLAGS)
#undef BUILD_CHAR_FLAGS
};

bool IsIdentifierStart(base::uc32 c) {
  if (!base::IsInRange(c, 0, 255)) return IsIdentifierStartSlow(c);
  DCHECK_EQ(IsIdentifierStartSlow(c),
            static_cast<bool>(kOneByteCharFlags[c] & kIsIdentifierStart));
  return kOneByteCharFlags[c] & kIsIdentifierStart;
}

bool IsIdentifierPart(base::uc32 c) {
  if (!base::IsInRange(c, 0, 255)) return IsIdentifierPartSlow(c);
  DCHECK_EQ(IsIdentifierPartSlow(c),
            static_cast<bool>(kOneByteCharFlags[c] & kIsIdentifierPart));
  return kOneByteCharFlags[c] & kIsIdentifierPart;
}

bool IsWhiteSpace(base::uc32 c) {
  if (!base::IsInRange(c, 0, 255)) return IsWhiteSpaceSlow(c);
  DCHECK_EQ(IsWhiteSpaceSlow(c),
            static_cast<bool>(kOneByteCharFlags[c] & kIsWhiteSpace));
  return kOneByteCharFlags[c] & kIsWhiteSpace;
}

bool IsWhiteSpaceOrLineTerminator(base::uc32 c) {
  if (!base::IsInRange(c, 0, 255)) return IsWhiteSpaceOrLineTerminatorSlow(c);
  DCHECK_EQ(
      IsWhiteSpaceOrLineTerminatorSlow(c),
      static_cast<bool>(kOneByteCharFlags[c] & kIsWhiteSpaceOrLineTerminator));
  return kOneByteCharFlags[c] & kIsWhiteSpaceOrLineTerminator;
}

bool IsLineTerminatorSequence(base::uc32 c, base::uc32 next) {
  if (kOneByteCharFlags[static_cast<uint8_t>(c)] & kMaybeLineEnd) {
    if (c == '\n') return true;
    if (c == '\r') return next != '\n';
    return base::IsInRange(static_cast<unsigned int>(c), 0x2028u, 0x2029u);
  }
  return false;
}

}  // namespace internal

}  // namespace v8

#endif  // V8_STRINGS_CHAR_PREDICATES_INL_H_
                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/src/strings/char-predicates.cc                                                  0000664 0000000 0000000 00000002606 14746647661 0021676 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2011 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_INTL_SUPPORT
#error Internationalization is expected to be enabled.
#endif  // V8_INTL_SUPPORT

#include "src/strings/char-predicates.h"

#include "unicode/uchar.h"
#include "unicode/urename.h"

namespace v8 {
namespace internal {

// ES#sec-names-and-keywords Names and Keywords
// UnicodeIDStart, '$', '_' and '\'
bool IsIdentifierStartSlow(base::uc32 c) {
  // cannot use u_isIDStart because it does not work for
  // Other_ID_Start characters.
  return u_hasBinaryProperty(c, UCHAR_ID_START) ||
         (c < 0x60 && (c == '$' || c == '\\' || c == '_'));
}

// ES#sec-names-and-keywords Names and Keywords
// UnicodeIDContinue, '$', '_', '\', ZWJ, and ZWNJ
bool IsIdentifierPartSlow(base::uc32 c) {
  // Can't use u_isIDPart because it does not work for
  // Other_ID_Continue characters.
  return u_hasBinaryProperty(c, UCHAR_ID_CONTINUE) ||
         (c < 0x60 && (c == '$' || c == '\\' || c == '_')) || c == 0x200C ||
         c == 0x200D;
}

// ES#sec-white-space White Space
// gC=Zs, U+0009, U+000B, U+000C, U+FEFF
bool IsWhiteSpaceSlow(base::uc32 c) {
  return (u_charType(c) == U_SPACE_SEPARATOR) ||
         (c < 0x0D && (c == 0x09 || c == 0x0B || c == 0x0C)) || c == 0xFEFF;
}

}  // namespace internal
}  // namespace v8
                                                                                                                          node-23.7.0/deps/v8/src/strings/char-predicates.h                                                   0000664 0000000 0000000 00000006315 14746647661 0021541 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2011 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_STRINGS_CHAR_PREDICATES_H_
#define V8_STRINGS_CHAR_PREDICATES_H_

#include "src/base/strings.h"
#include "src/strings/unicode.h"

namespace v8 {
namespace internal {

// Unicode character predicates as defined by ECMA-262, 3rd,
// used for lexical analysis.

inline constexpr int AsciiAlphaToLower(base::uc32 c);
inline constexpr bool IsCarriageReturn(base::uc32 c);
inline constexpr bool IsLineFeed(base::uc32 c);
inline constexpr bool IsAsciiIdentifier(base::uc32 c);
inline constexpr bool IsAlphaNumeric(base::uc32 c);
inline constexpr bool IsDecimalDigit(base::uc32 c);
inline constexpr bool IsHexDigit(base::uc32 c);
inline constexpr bool IsOctalDigit(base::uc32 c);
inline constexpr bool IsBinaryDigit(base::uc32 c);
inline constexpr bool IsRegExpWord(base::uc32 c);

inline constexpr bool IsAsciiLower(base::uc32 ch);
inline constexpr bool IsAsciiUpper(base::uc32 ch);

inline constexpr base::uc32 ToAsciiUpper(base::uc32 ch);
inline constexpr base::uc32 ToAsciiLower(base::uc32 ch);

// ES#sec-names-and-keywords
// This includes '_', '$' and '\', and ID_Start according to
// http://www.unicode.org/reports/tr31/, which consists of categories
// 'Lu', 'Ll', 'Lt', 'Lm', 'Lo', 'Nl', but excluding properties
// 'Pattern_Syntax' or 'Pattern_White_Space'.
inline bool IsIdentifierStart(base::uc32 c);
#ifdef V8_INTL_SUPPORT
V8_EXPORT_PRIVATE bool IsIdentifierStartSlow(base::uc32 c);
#else
inline bool IsIdentifierStartSlow(base::uc32 c) {
  // Non-BMP characters are not supported without I18N.
  return (c <= 0xFFFF) ? unibrow::ID_Start::Is(c) : false;
}
#endif

// ES#sec-names-and-keywords
// This includes \u200c and \u200d, and ID_Continue according to
// http://www.unicode.org/reports/tr31/, which consists of ID_Start,
// the categories 'Mn', 'Mc', 'Nd', 'Pc', but excluding properties
// 'Pattern_Syntax' or 'Pattern_White_Space'.
inline bool IsIdentifierPart(base::uc32 c);
#ifdef V8_INTL_SUPPORT
V8_EXPORT_PRIVATE bool IsIdentifierPartSlow(base::uc32 c);
#else
inline bool IsIdentifierPartSlow(base::uc32 c) {
  // Non-BMP charaacters are not supported without I18N.
  if (c <= 0xFFFF) {
    return unibrow::ID_Start::Is(c) || unibrow::ID_Continue::Is(c);
  }
  return false;
}
#endif

// ES6 draft section 11.2
// This includes all code points of Unicode category 'Zs'.
// Further included are \u0009, \u000b, \u000c, and \ufeff.
inline bool IsWhiteSpace(base::uc32 c);
#ifdef V8_INTL_SUPPORT
V8_EXPORT_PRIVATE bool IsWhiteSpaceSlow(base::uc32 c);
#else
inline bool IsWhiteSpaceSlow(base::uc32 c) {
  return unibrow::WhiteSpace::Is(c);
}
#endif

// WhiteSpace and LineTerminator according to ES6 draft section 11.2 and 11.3
// This includes all the characters with Unicode category 'Z' (= Zs+Zl+Zp)
// as well as \u0009 - \u000d and \ufeff.
inline bool IsWhiteSpaceOrLineTerminator(base::uc32 c);
inline bool IsWhiteSpaceOrLineTerminatorSlow(base::uc32 c) {
  return IsWhiteSpaceSlow(c) || unibrow::IsLineTerminator(c);
}

inline bool IsLineTerminatorSequence(base::uc32 c, base::uc32 next);

}  // namespace internal
}  // namespace v8

#endif  // V8_STRINGS_CHAR_PREDICATES_H_
                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/src/strings/string-builder-inl.h                                                0000664 0000000 0000000 00000015455 14746647661 0022222 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_STRINGS_STRING_BUILDER_INL_H_
#define V8_STRINGS_STRING_BUILDER_INL_H_

#include "src/execution/isolate.h"
#include "src/handles/handles-inl.h"
#include "src/objects/string-inl.h"
#include "src/strings/string-builder.h"

namespace v8 {
namespace internal {

const int kStringBuilderConcatHelperLengthBits = 11;
const int kStringBuilderConcatHelperPositionBits = 19;

using StringBuilderSubstringLength =
    base::BitField<int, 0, kStringBuilderConcatHelperLengthBits>;
using StringBuilderSubstringPosition =
    base::BitField<int, kStringBuilderConcatHelperLengthBits,
                   kStringBuilderConcatHelperPositionBits>;

template <typename sinkchar>
void StringBuilderConcatHelper(Tagged<String> special, sinkchar* sink,
                               Tagged<FixedArray> fixed_array,
                               int array_length);

// Returns the result length of the concatenation.
// On illegal argument, -1 is returned.
int StringBuilderConcatLength(int special_length,
                              Tagged<FixedArray> fixed_array, int array_length,
                              bool* one_byte);

// static
inline void ReplacementStringBuilder::AddSubjectSlice(
    FixedArrayBuilder* builder, int from, int to) {
  DCHECK_GE(from, 0);
  int length = to - from;
  DCHECK_GT(length, 0);
  if (StringBuilderSubstringLength::is_valid(length) &&
      StringBuilderSubstringPosition::is_valid(from)) {
    int encoded_slice = StringBuilderSubstringLength::encode(length) |
                        StringBuilderSubstringPosition::encode(from);
    builder->Add(Smi::FromInt(encoded_slice));
  } else {
    // Otherwise encode as two smis.
    builder->Add(Smi::FromInt(-length));
    builder->Add(Smi::FromInt(from));
  }
}

inline void ReplacementStringBuilder::AddSubjectSlice(int from, int to) {
  EnsureCapacity(2);  // Subject slices are encoded with up to two smis.
  AddSubjectSlice(&array_builder_, from, to);
  IncrementCharacterCount(to - from);
}

template <typename SrcChar, typename DestChar>
void IncrementalStringBuilder::Append(SrcChar c) {
  DCHECK_EQ(encoding_ == String::ONE_BYTE_ENCODING, sizeof(DestChar) == 1);
  if (sizeof(DestChar) == 1) {
    DCHECK_EQ(String::ONE_BYTE_ENCODING, encoding_);
    Cast<SeqOneByteString>(*current_part_)
        ->SeqOneByteStringSet(current_index_++, c);
  } else {
    DCHECK_EQ(String::TWO_BYTE_ENCODING, encoding_);
    Cast<SeqTwoByteString>(*current_part_)
        ->SeqTwoByteStringSet(current_index_++, c);
  }
  if (current_index_ == part_length_) Extend();
  DCHECK(HasValidCurrentIndex());
}

V8_INLINE void IncrementalStringBuilder::AppendCharacter(uint8_t c) {
  if (encoding_ == String::ONE_BYTE_ENCODING) {
    Append<uint8_t, uint8_t>(c);
  } else {
    Append<uint8_t, base::uc16>(c);
  }
}

template <int N>
V8_INLINE void IncrementalStringBuilder::AppendCStringLiteral(
    const char (&literal)[N]) {
  // Note that the literal contains the zero char.
  const int length = N - 1;
  static_assert(length > 0);
  if (length == 1) return AppendCharacter(literal[0]);
  if (encoding_ == String::ONE_BYTE_ENCODING && CurrentPartCanFit(N)) {
    const uint8_t* chars = reinterpret_cast<const uint8_t*>(literal);
    Cast<SeqOneByteString>(*current_part_)
        ->SeqOneByteStringSetChars(current_index_, chars, length);
    current_index_ += length;
    if (current_index_ == part_length_) Extend();
    DCHECK(HasValidCurrentIndex());
    return;
  }
  return AppendCString(literal);
}

template <typename SrcChar>
V8_INLINE void IncrementalStringBuilder::AppendCString(const SrcChar* s) {
  if (encoding_ == String::ONE_BYTE_ENCODING) {
    while (*s != '\0') Append<SrcChar, uint8_t>(*s++);
  } else {
    while (*s != '\0') Append<SrcChar, base::uc16>(*s++);
  }
}

V8_INLINE void IncrementalStringBuilder::AppendInt(int i) {
  char buffer[kIntToCStringBufferSize];
  const char* str =
      IntToCString(i, base::Vector<char>(buffer, kIntToCStringBufferSize));
  AppendCString(str);
}

V8_INLINE int IncrementalStringBuilder::EscapedLengthIfCurrentPartFits(
    int length) {
  if (length > kMaxPartLength) return 0;
  // The worst case length of an escaped character is 6. Shifting the remaining
  // string length right by 3 is a more pessimistic estimate, but faster to
  // calculate.
  static_assert((kMaxPartLength << 3) <= String::kMaxLength);
  // This shift will not overflow because length is already less than the
  // maximum part length.
  int worst_case_length = length << 3;
  return CurrentPartCanFit(worst_case_length) ? worst_case_length : 0;
}

// Change encoding to two-byte.
void IncrementalStringBuilder::ChangeEncoding() {
  DCHECK_EQ(String::ONE_BYTE_ENCODING, encoding_);
  ShrinkCurrentPart();
  encoding_ = String::TWO_BYTE_ENCODING;
  Extend();
}

template <typename DestChar>
inline IncrementalStringBuilder::NoExtend<DestChar>::NoExtend(
    Tagged<String> string, int offset, const DisallowGarbageCollection& no_gc) {
  DCHECK(IsSeqOneByteString(string) || IsSeqTwoByteString(string));
  if (sizeof(DestChar) == 1) {
    start_ = reinterpret_cast<DestChar*>(
        Cast<SeqOneByteString>(string)->GetChars(no_gc) + offset);
  } else {
    start_ = reinterpret_cast<DestChar*>(
        Cast<SeqTwoByteString>(string)->GetChars(no_gc) + offset);
  }
  cursor_ = start_;
#ifdef DEBUG
  string_ = string;
#endif
}

#ifdef DEBUG
template <typename DestChar>
inline IncrementalStringBuilder::NoExtend<DestChar>::~NoExtend() {
  DestChar* end;
  if (sizeof(DestChar) == 1) {
    auto one_byte_string = Cast<SeqOneByteString>(string_);
    end = reinterpret_cast<DestChar*>(one_byte_string->GetChars(no_gc_) +
                                      one_byte_string->length());
  } else {
    auto two_byte_string = Cast<SeqTwoByteString>(string_);
    end = reinterpret_cast<DestChar*>(two_byte_string->GetChars(no_gc_) +
                                      two_byte_string->length());
  }
  DCHECK_LE(cursor_, end + 1);
}
#endif

template <typename DestChar>
inline IncrementalStringBuilder::NoExtendBuilder<DestChar>::NoExtendBuilder(
    IncrementalStringBuilder* builder, int required_length,
    const DisallowGarbageCollection& no_gc)
    : NoExtend<DestChar>(*(builder->current_part()), builder->current_index_,
                         no_gc),
      builder_(builder) {
  DCHECK(builder->CurrentPartCanFit(required_length));
}

V8_INLINE Factory* IncrementalStringBuilder::factory() {
  return isolate_->factory();
}

V8_INLINE void IncrementalStringBuilder::ShrinkCurrentPart() {
  DCHECK(current_index_ < part_length_);
  set_current_part(SeqString::Truncate(
      isolate_, indirect_handle(Cast<SeqString>(current_part()), isolate_),
      current_index_));
}

}  // namespace internal
}  // namespace v8

#endif  // V8_STRINGS_STRING_BUILDER_INL_H_
                                                                                                                                                                                                                   node-23.7.0/deps/v8/src/strings/string-builder.cc                                                   0000664 0000000 0000000 00000027714 14746647661 0021601 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/base/strings.h"
#include "src/execution/isolate-inl.h"
#include "src/objects/fixed-array-inl.h"
#include "src/objects/js-array-inl.h"
#include "src/strings/string-builder-inl.h"

namespace v8 {
namespace internal {

template <typename sinkchar>
void StringBuilderConcatHelper(Tagged<String> special, sinkchar* sink,
                               Tagged<FixedArray> fixed_array,
                               int array_length) {
  DisallowGarbageCollection no_gc;
  int position = 0;
  for (int i = 0; i < array_length; i++) {
    Tagged<Object> element = fixed_array->get(i);
    if (IsSmi(element)) {
      // Smi encoding of position and length.
      int encoded_slice = Smi::ToInt(element);
      int pos;
      int len;
      if (encoded_slice > 0) {
        // Position and length encoded in one smi.
        pos = StringBuilderSubstringPosition::decode(encoded_slice);
        len = StringBuilderSubstringLength::decode(encoded_slice);
      } else {
        // Position and length encoded in two smis.
        Tagged<Object> obj = fixed_array->get(++i);
        DCHECK(IsSmi(obj));
        pos = Smi::ToInt(obj);
        len = -encoded_slice;
      }
      String::WriteToFlat(special, sink + position, pos, len);
      position += len;
    } else {
      Tagged<String> string = Cast<String>(element);
      int element_length = string->length();
      String::WriteToFlat(string, sink + position, 0, element_length);
      position += element_length;
    }
  }
}

template void StringBuilderConcatHelper<uint8_t>(Tagged<String> special,
                                                 uint8_t* sink,
                                                 Tagged<FixedArray> fixed_array,
                                                 int array_length);

template void StringBuilderConcatHelper<base::uc16>(
    Tagged<String> special, base::uc16* sink, Tagged<FixedArray> fixed_array,
    int array_length);

int StringBuilderConcatLength(int special_length,
                              Tagged<FixedArray> fixed_array, int array_length,
                              bool* one_byte) {
  DisallowGarbageCollection no_gc;
  int position = 0;
  for (int i = 0; i < array_length; i++) {
    int increment = 0;
    Tagged<Object> elt = fixed_array->get(i);
    if (IsSmi(elt)) {
      // Smi encoding of position and length.
      int smi_value = Smi::ToInt(elt);
      int pos;
      int len;
      if (smi_value > 0) {
        // Position and length encoded in one smi.
        pos = StringBuilderSubstringPosition::decode(smi_value);
        len = StringBuilderSubstringLength::decode(smi_value);
      } else {
        // Position and length encoded in two smis.
        len = -smi_value;
        // Get the position and check that it is a positive smi.
        i++;
        if (i >= array_length) return -1;
        Tagged<Object> next_smi = fixed_array->get(i);
        if (!IsSmi(next_smi)) return -1;
        pos = Smi::ToInt(next_smi);
        if (pos < 0) return -1;
      }
      DCHECK_GE(pos, 0);
      DCHECK_GE(len, 0);
      if (pos > special_length || len > special_length - pos) return -1;
      increment = len;
    } else if (IsString(elt)) {
      Tagged<String> element = Cast<String>(elt);
      int element_length = element->length();
      increment = element_length;
      if (*one_byte && !element->IsOneByteRepresentation()) {
        *one_byte = false;
      }
    } else {
      return -1;
    }
    if (increment > String::kMaxLength - position) {
      return kMaxInt;  // Provoke throw on allocation.
    }
    position += increment;
  }
  return position;
}

FixedArrayBuilder::FixedArrayBuilder(Isolate* isolate, int initial_capacity)
    : array_(isolate->factory()->NewFixedArrayWithHoles(initial_capacity)),
      length_(0),
      has_non_smi_elements_(false) {
  // Require a non-zero initial size. Ensures that doubling the size to
  // extend the array will work.
  DCHECK_GT(initial_capacity, 0);
}

FixedArrayBuilder::FixedArrayBuilder(DirectHandle<FixedArray> backing_store)
    : array_(backing_store), length_(0), has_non_smi_elements_(false) {
  // Require a non-zero initial size. Ensures that doubling the size to
  // extend the array will work.
  DCHECK_GT(backing_store->length(), 0);
}

FixedArrayBuilder::FixedArrayBuilder(Isolate* isolate)
    : array_(isolate->factory()->empty_fixed_array()),
      length_(0),
      has_non_smi_elements_(false) {}

// static
FixedArrayBuilder FixedArrayBuilder::Lazy(Isolate* isolate) {
  return FixedArrayBuilder(isolate);
}

bool FixedArrayBuilder::HasCapacity(int elements) {
  int length = array_->length();
  int required_length = length_ + elements;
  return (length >= required_length);
}

void FixedArrayBuilder::EnsureCapacity(Isolate* isolate, int elements) {
  int length = array_->length();
  int required_length = length_ + elements;
  if (length < required_length) {
    if (length == 0) {
      constexpr int kInitialCapacityForLazy = 16;
      array_ = isolate->factory()->NewFixedArrayWithHoles(
          std::max(kInitialCapacityForLazy, elements));
      return;
    }

    int new_length = length;
    do {
      new_length *= 2;
    } while (new_length < required_length);
    DirectHandle<FixedArray> extended_array =
        isolate->factory()->NewFixedArrayWithHoles(new_length);
    FixedArray::CopyElements(isolate, *extended_array, 0, *array_, 0, length_);
    array_ = extended_array;
  }
}

void FixedArrayBuilder::Add(Tagged<Object> value) {
  DCHECK(!IsSmi(value));
  array_->set(length_, value);
  length_++;
  has_non_smi_elements_ = true;
}

void FixedArrayBuilder::Add(Tagged<Smi> value) {
  DCHECK(IsSmi(value));
  array_->set(length_, value);
  length_++;
}

int FixedArrayBuilder::capacity() { return array_->length(); }

ReplacementStringBuilder::ReplacementStringBuilder(Heap* heap,
                                                   DirectHandle<String> subject,
                                                   int estimated_part_count)
    : heap_(heap),
      array_builder_(Isolate::FromHeap(heap), estimated_part_count),
      subject_(subject),
      character_count_(0),
      is_one_byte_(subject->IsOneByteRepresentation()) {
  // Require a non-zero initial size. Ensures that doubling the size to
  // extend the array will work.
  DCHECK_GT(estimated_part_count, 0);
}

void ReplacementStringBuilder::EnsureCapacity(int elements) {
  array_builder_.EnsureCapacity(Isolate::FromHeap(heap_), elements);
}

void ReplacementStringBuilder::AddString(DirectHandle<String> string) {
  int length = string->length();
  DCHECK_GT(length, 0);
  AddElement(string);
  if (!string->IsOneByteRepresentation()) {
    is_one_byte_ = false;
  }
  IncrementCharacterCount(length);
}

MaybeDirectHandle<String> ReplacementStringBuilder::ToString() {
  Isolate* isolate = Isolate::FromHeap(heap_);
  if (array_builder_.length() == 0) {
    return isolate->factory()->empty_string();
  }

  DirectHandle<String> joined_string;
  if (is_one_byte_) {
    DirectHandle<SeqOneByteString> seq;
    ASSIGN_RETURN_ON_EXCEPTION(
        isolate, seq,
        isolate->factory()->NewRawOneByteString(character_count_));

    DisallowGarbageCollection no_gc;
    uint8_t* char_buffer = seq->GetChars(no_gc);
    StringBuilderConcatHelper(*subject_, char_buffer, *array_builder_.array(),
                              array_builder_.length());
    joined_string = Cast<String>(seq);
  } else {
    // Two-byte.
    DirectHandle<SeqTwoByteString> seq;
    ASSIGN_RETURN_ON_EXCEPTION(
        isolate, seq,
        isolate->factory()->NewRawTwoByteString(character_count_));

    DisallowGarbageCollection no_gc;
    base::uc16* char_buffer = seq->GetChars(no_gc);
    StringBuilderConcatHelper(*subject_, char_buffer, *array_builder_.array(),
                              array_builder_.length());
    joined_string = Cast<String>(seq);
  }
  return joined_string;
}

void ReplacementStringBuilder::AddElement(DirectHandle<Object> element) {
  DCHECK(IsSmi(*element) || IsString(*element));
  EnsureCapacity(1);
  DisallowGarbageCollection no_gc;
  array_builder_.Add(*element);
}

IncrementalStringBuilder::IncrementalStringBuilder(Isolate* isolate)
    : isolate_(isolate),
      encoding_(String::ONE_BYTE_ENCODING),
      overflowed_(false),
      part_length_(kInitialPartLength),
      current_index_(0) {
  // Create an accumulator handle starting with the empty string.
  accumulator_ =
      DirectHandle<String>::New(ReadOnlyRoots(isolate).empty_string(), isolate);
  current_part_ =
      factory()->NewRawOneByteString(part_length_).ToHandleChecked();
}

int IncrementalStringBuilder::Length() const {
  return accumulator_->length() + current_index_;
}

bool IncrementalStringBuilder::HasValidCurrentIndex() const {
  return current_index_ < part_length_;
}

void IncrementalStringBuilder::Accumulate(DirectHandle<String> new_part) {
  DirectHandle<String> new_accumulator;
  if (accumulator()->length() + new_part->length() > String::kMaxLength) {
    // Set the flag and carry on. Delay throwing the exception till the end.
    new_accumulator = factory()->empty_string();
    overflowed_ = true;
  } else {
    new_accumulator =
        factory()
            ->NewConsString(indirect_handle(accumulator(), isolate_),
                            indirect_handle(new_part, isolate_))
            .ToHandleChecked();
  }
  set_accumulator(new_accumulator);
}

void IncrementalStringBuilder::Extend() {
  DCHECK_EQ(current_index_, current_part()->length());
  Accumulate(current_part());
  if (part_length_ <= kMaxPartLength / kPartLengthGrowthFactor) {
    part_length_ *= kPartLengthGrowthFactor;
  }
  DirectHandle<String> new_part;
  if (encoding_ == String::ONE_BYTE_ENCODING) {
    new_part = factory()->NewRawOneByteString(part_length_).ToHandleChecked();
  } else {
    new_part = factory()->NewRawTwoByteString(part_length_).ToHandleChecked();
  }
  // Reuse the same handle to avoid being invalidated when exiting handle scope.
  set_current_part(new_part);
  current_index_ = 0;
}

MaybeDirectHandle<String> IncrementalStringBuilder::Finish() {
  ShrinkCurrentPart();
  Accumulate(current_part());
  if (overflowed_) {
    THROW_NEW_ERROR(isolate_, NewInvalidStringLengthError());
  }
  if (isolate()->serializer_enabled()) {
    return factory()->InternalizeString(
        indirect_handle(accumulator(), isolate_));
  }
  return accumulator();
}

// Short strings can be copied directly to {current_part_}.
// Requires the IncrementalStringBuilder to either have two byte encoding or
// the incoming string to have one byte representation "underneath" (The
// one byte check requires the string to be flat).
bool IncrementalStringBuilder::CanAppendByCopy(DirectHandle<String> string) {
  const bool representation_ok =
      encoding_ == String::TWO_BYTE_ENCODING ||
      (string->IsFlat() && String::IsOneByteRepresentationUnderneath(*string));

  return representation_ok && CurrentPartCanFit(string->length());
}

void IncrementalStringBuilder::AppendStringByCopy(DirectHandle<String> string) {
  DCHECK(CanAppendByCopy(string));

  {
    DisallowGarbageCollection no_gc;
    if (encoding_ == String::ONE_BYTE_ENCODING) {
      String::WriteToFlat(
          *string,
          Cast<SeqOneByteString>(current_part())->GetChars(no_gc) +
              current_index_,
          0, string->length());
    } else {
      String::WriteToFlat(
          *string,
          Cast<SeqTwoByteString>(current_part())->GetChars(no_gc) +
              current_index_,
          0, string->length());
    }
  }
  current_index_ += string->length();
  DCHECK(current_index_ <= part_length_);
  if (current_index_ == part_length_) Extend();
}

void IncrementalStringBuilder::AppendString(DirectHandle<String> string) {
  if (CanAppendByCopy(string)) {
    AppendStringByCopy(string);
    return;
  }

  ShrinkCurrentPart();
  part_length_ = kInitialPartLength;  // Allocate conservatively.
  Extend();  // Attach current part and allocate new part.
  Accumulate(string);
}

}  // namespace internal
}  // namespace v8
                                                    node-23.7.0/deps/v8/src/strings/string-builder.h                                                    0000664 0000000 0000000 00000012717 14746647661 0021440 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_STRINGS_STRING_BUILDER_H_
#define V8_STRINGS_STRING_BUILDER_H_

#include "src/common/assert-scope.h"
#include "src/handles/handles.h"
#include "src/objects/string.h"

namespace v8 {
namespace internal {

class FixedArrayBuilder {
 public:
  explicit FixedArrayBuilder(Isolate* isolate, int initial_capacity);
  explicit FixedArrayBuilder(DirectHandle<FixedArray> backing_store);

  // Creates a FixedArrayBuilder which allocates its backing store lazily when
  // EnsureCapacity is called.
  static FixedArrayBuilder Lazy(Isolate* isolate);

  bool HasCapacity(int elements);
  void EnsureCapacity(Isolate* isolate, int elements);

  void Add(Tagged<Object> value);
  void Add(Tagged<Smi> value);

  DirectHandle<FixedArray> array() { return array_; }

  int length() { return length_; }

  int capacity();

 private:
  explicit FixedArrayBuilder(Isolate* isolate);

  DirectHandle<FixedArray> array_;
  int length_;
  bool has_non_smi_elements_;
};

class ReplacementStringBuilder {
 public:
  ReplacementStringBuilder(Heap* heap, DirectHandle<String> subject,
                           int estimated_part_count);

  // Caution: Callers must ensure the builder has enough capacity.
  static inline void AddSubjectSlice(FixedArrayBuilder* builder, int from,
                                     int to);

  inline void AddSubjectSlice(int from, int to);

  void AddString(DirectHandle<String> string);

  MaybeDirectHandle<String> ToString();

  void IncrementCharacterCount(int by) {
    if (character_count_ > String::kMaxLength - by) {
      static_assert(String::kMaxLength < kMaxInt);
      character_count_ = kMaxInt;
    } else {
      character_count_ += by;
    }
  }

 private:
  void AddElement(DirectHandle<Object> element);
  void EnsureCapacity(int elements);

  Heap* heap_;
  FixedArrayBuilder array_builder_;
  DirectHandle<String> subject_;
  int character_count_;
  bool is_one_byte_;
};

class IncrementalStringBuilder {
 public:
  explicit IncrementalStringBuilder(Isolate* isolate);

  V8_INLINE String::Encoding CurrentEncoding() { return encoding_; }

  template <typename SrcChar, typename DestChar>
  V8_INLINE void Append(SrcChar c);

  V8_INLINE void AppendCharacter(uint8_t c);

  template <int N>
  V8_INLINE void AppendCStringLiteral(const char (&literal)[N]);

  template <typename SrcChar>
  V8_INLINE void AppendCString(const SrcChar* s);

  V8_INLINE void AppendInt(int i);

  V8_INLINE bool CurrentPartCanFit(int length) {
    return part_length_ - current_index_ > length;
  }

  // We make a rough estimate to find out if the current string can be
  // serialized without allocating a new string part.
  V8_INLINE int EscapedLengthIfCurrentPartFits(int length);

  void AppendString(DirectHandle<String> string);

  MaybeDirectHandle<String> Finish();

  V8_INLINE bool HasOverflowed() const { return overflowed_; }

  int Length() const;

  // Change encoding to two-byte.
  V8_INLINE void ChangeEncoding();

  template <typename DestChar>
  class NoExtend {
   public:
    inline NoExtend(Tagged<String> string, int offset,
                    const DisallowGarbageCollection& no_gc);

#ifdef DEBUG
    inline ~NoExtend();
#endif

    V8_INLINE void Append(DestChar c) { *(cursor_++) = c; }
    V8_INLINE void AppendCString(const char* s) {
      const uint8_t* u = reinterpret_cast<const uint8_t*>(s);
      while (*u != '\0') Append(*(u++));
    }

    int written() { return static_cast<int>(cursor_ - start_); }

   private:
    DestChar* start_;
    DestChar* cursor_;
#ifdef DEBUG
    Tagged<String> string_;
#endif
    DISALLOW_GARBAGE_COLLECTION(no_gc_)
  };

  template <typename DestChar>
  class NoExtendBuilder : public NoExtend<DestChar> {
   public:
    inline NoExtendBuilder(IncrementalStringBuilder* builder,
                           int required_length,
                           const DisallowGarbageCollection& no_gc);

    ~NoExtendBuilder() {
      builder_->current_index_ += NoExtend<DestChar>::written();
      DCHECK(builder_->HasValidCurrentIndex());
    }

   private:
    IncrementalStringBuilder* builder_;
  };

  Isolate* isolate() { return isolate_; }

 private:
  V8_INLINE Factory* factory();

  V8_INLINE DirectHandle<String> accumulator() { return accumulator_; }

  V8_INLINE void set_accumulator(DirectHandle<String> string) {
    accumulator_.PatchValue(*string);
  }

  V8_INLINE DirectHandle<String> current_part() { return current_part_; }

  V8_INLINE void set_current_part(DirectHandle<String> string) {
    current_part_.PatchValue(*string);
  }

  // Add the current part to the accumulator.
  void Accumulate(DirectHandle<String> new_part);

  // Finish the current part and allocate a new part.
  void Extend();

  bool HasValidCurrentIndex() const;

  // Shrink current part to the right size.
  V8_INLINE void ShrinkCurrentPart();

  void AppendStringByCopy(DirectHandle<String> string);
  bool CanAppendByCopy(DirectHandle<String> string);

  static const int kInitialPartLength = 32;
  static const int kMaxPartLength = 16 * 1024;
  static const int kPartLengthGrowthFactor = 2;
  static const int kIntToCStringBufferSize = 100;

  Isolate* isolate_;
  String::Encoding encoding_;
  bool overflowed_;
  int part_length_;
  int current_index_;
  DirectHandle<String> accumulator_;
  DirectHandle<String> current_part_;
};

}  // namespace internal
}  // namespace v8

#endif  // V8_STRINGS_STRING_BUILDER_H_
                                                 node-23.7.0/deps/v8/src/strings/string-case.cc                                                      0000664 0000000 0000000 00000011565 14746647661 0021063 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/strings/string-case.h"

#include "src/base/logging.h"
#include "src/common/assert-scope.h"
#include "src/common/globals.h"
#include "src/utils/utils.h"

namespace v8 {
namespace internal {

// FastAsciiConvert tries to do character processing on a word_t basis if
// source and destination strings are properly aligned. Natural alignment of
// string data depends on kTaggedSize so we define word_t via Tagged_t.
using word_t = std::make_unsigned<Tagged_t>::type;

const word_t kWordTAllBitsSet = std::numeric_limits<word_t>::max();
const word_t kOneInEveryByte = kWordTAllBitsSet / 0xFF;
const word_t kAsciiMask = kOneInEveryByte << 7;

#ifdef DEBUG
bool CheckFastAsciiConvert(char* dst, const char* src, int length, bool changed,
                           bool is_to_lower) {
  bool expected_changed = false;
  for (int i = 0; i < length; i++) {
    if (dst[i] == src[i]) continue;
    expected_changed = true;
    if (is_to_lower) {
      DCHECK('A' <= src[i] && src[i] <= 'Z');
      DCHECK(dst[i] == src[i] + ('a' - 'A'));
    } else {
      DCHECK('a' <= src[i] && src[i] <= 'z');
      DCHECK(dst[i] == src[i] - ('a' - 'A'));
    }
  }
  return (expected_changed == changed);
}
#endif

// Given a word and two range boundaries returns a word with high bit
// set in every byte iff the corresponding input byte was strictly in
// the range (m, n). All the other bits in the result are cleared.
// This function is only useful when it can be inlined and the
// boundaries are statically known.
// Requires: all bytes in the input word and the boundaries must be
// ASCII (less than 0x7F).
static inline word_t AsciiRangeMask(word_t w, char m, char n) {
  // Use strict inequalities since in edge cases the function could be
  // further simplified.
  DCHECK(0 < m && m < n);
  // Has high bit set in every w byte less than n.
  word_t tmp1 = kOneInEveryByte * (0x7F + n) - w;
  // Has high bit set in every w byte greater than m.
  word_t tmp2 = w + kOneInEveryByte * (0x7F - m);
  return (tmp1 & tmp2 & (kOneInEveryByte * 0x80));
}

template <bool is_lower>
int FastAsciiConvert(char* dst, const char* src, int length,
                     bool* changed_out) {
#ifdef DEBUG
  char* saved_dst = dst;
#endif
  const char* saved_src = src;
  DisallowGarbageCollection no_gc;
  // We rely on the distance between upper and lower case letters
  // being a known power of 2.
  DCHECK_EQ('a' - 'A', 1 << 5);
  // Boundaries for the range of input characters than require conversion.
  static const char lo = is_lower ? 'A' - 1 : 'a' - 1;
  static const char hi = is_lower ? 'Z' + 1 : 'z' + 1;
  bool changed = false;
  const char* const limit = src + length;

  // dst is newly allocated and always aligned.
  DCHECK(IsAligned(reinterpret_cast<Address>(dst), sizeof(word_t)));
  // Only attempt processing one word at a time if src is also aligned.
  if (IsAligned(reinterpret_cast<Address>(src), sizeof(word_t))) {
    // Process the prefix of the input that requires no conversion one aligned
    // (machine) word at a time.
    while (src <= limit - sizeof(word_t)) {
      const word_t w = *reinterpret_cast<const word_t*>(src);
      if ((w & kAsciiMask) != 0) return static_cast<int>(src - saved_src);
      if (AsciiRangeMask(w, lo, hi) != 0) {
        changed = true;
        break;
      }
      *reinterpret_cast<word_t*>(dst) = w;
      src += sizeof(word_t);
      dst += sizeof(word_t);
    }
    // Process the remainder of the input performing conversion when
    // required one word at a time.
    while (src <= limit - sizeof(word_t)) {
      const word_t w = *reinterpret_cast<const word_t*>(src);
      if ((w & kAsciiMask) != 0) return static_cast<int>(src - saved_src);
      word_t m = AsciiRangeMask(w, lo, hi);
      // The mask has high (7th) bit set in every byte that needs
      // conversion and we know that the distance between cases is
      // 1 << 5.
      *reinterpret_cast<word_t*>(dst) = w ^ (m >> 2);
      src += sizeof(word_t);
      dst += sizeof(word_t);
    }
  }
  // Process the last few bytes of the input (or the whole input if
  // unaligned access is not supported).
  while (src < limit) {
    char c = *src;
    if ((c & kAsciiMask) != 0) return static_cast<int>(src - saved_src);
    if (lo < c && c < hi) {
      c ^= (1 << 5);
      changed = true;
    }
    *dst = c;
    ++src;
    ++dst;
  }

  DCHECK(
      CheckFastAsciiConvert(saved_dst, saved_src, length, changed, is_lower));

  *changed_out = changed;
  return length;
}

template int FastAsciiConvert<false>(char* dst, const char* src, int length,
                                     bool* changed_out);
template int FastAsciiConvert<true>(char* dst, const char* src, int length,
                                    bool* changed_out);

}  // namespace internal
}  // namespace v8
                                                                                                                                           node-23.7.0/deps/v8/src/strings/string-case.h                                                       0000664 0000000 0000000 00000000717 14746647661 0020722 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_STRINGS_STRING_CASE_H_
#define V8_STRINGS_STRING_CASE_H_

namespace v8 {
namespace internal {

template <bool is_lower>
int FastAsciiConvert(char* dst, const char* src, int length, bool* changed_out);

}  // namespace internal
}  // namespace v8

#endif  // V8_STRINGS_STRING_CASE_H_
                                                 node-23.7.0/deps/v8/src/strings/string-hasher-inl.h                                                 0000664 0000000 0000000 00000012004 14746647661 0022031 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_STRINGS_STRING_HASHER_INL_H_
#define V8_STRINGS_STRING_HASHER_INL_H_

#include "src/strings/string-hasher.h"

// Comment inserted to prevent header reordering.
#include <type_traits>

#include "src/objects/name-inl.h"
#include "src/objects/string-inl.h"
#include "src/strings/char-predicates-inl.h"
#include "src/utils/utils-inl.h"

namespace v8 {
namespace internal {

uint32_t StringHasher::AddCharacterCore(uint32_t running_hash, uint16_t c) {
  running_hash += c;
  running_hash += (running_hash << 10);
  running_hash ^= (running_hash >> 6);
  return running_hash;
}

uint32_t StringHasher::GetHashCore(uint32_t running_hash) {
  running_hash += (running_hash << 3);
  running_hash ^= (running_hash >> 11);
  running_hash += (running_hash << 15);
  int32_t hash = static_cast<int32_t>(running_hash & String::HashBits::kMax);
  // Ensure that the hash is kZeroHash, if the computed value is 0.
  int32_t mask = (hash - 1) >> 31;
  running_hash |= (kZeroHash & mask);
  return running_hash;
}

uint32_t StringHasher::GetTrivialHash(int length) {
  DCHECK_GT(length, String::kMaxHashCalcLength);
  // The hash of a large string is simply computed from the length.
  // Ensure that the max length is small enough to be encoded without losing
  // information.
  static_assert(String::kMaxLength <= String::HashBits::kMax);
  uint32_t hash = static_cast<uint32_t>(length);
  return String::CreateHashFieldValue(hash, String::HashFieldType::kHash);
}

template <typename char_t>
uint32_t StringHasher::HashSequentialString(const char_t* chars_raw, int length,
                                            uint64_t seed) {
  static_assert(std::is_integral<char_t>::value);
  static_assert(sizeof(char_t) <= 2);
  using uchar = typename std::make_unsigned<char_t>::type;
  const uchar* chars = reinterpret_cast<const uchar*>(chars_raw);
  DCHECK_LE(0, length);
  DCHECK_IMPLIES(0 < length, chars != nullptr);
  if (length >= 1) {
    if (IsDecimalDigit(chars[0]) && (length == 1 || chars[0] != '0')) {
      if (length <= String::kMaxArrayIndexSize) {
        // Possible array index; try to compute the array index hash.
        uint32_t index = chars[0] - '0';
        int i = 1;
        do {
          if (i == length) {
            return MakeArrayIndexHash(index, length);
          }
        } while (TryAddArrayIndexChar(&index, chars[i++]));
      }
      // The following block wouldn't do anything on 32-bit platforms,
      // because kMaxArrayIndexSize == kMaxIntegerIndexSize there, and
      // if we wanted to compile it everywhere, then {index_big} would
      // have to be a {size_t}, which the Mac compiler doesn't like to
      // implicitly cast to uint64_t for the {TryAddIndexChar} call.
#if V8_HOST_ARCH_64_BIT
      // No "else" here: if the block above was entered and fell through,
      // we'll have to take this branch.
      if (length <= String::kMaxIntegerIndexSize) {
        // Not an array index, but it could still be an integer index.
        // Perform a regular hash computation, and additionally check
        // if there are non-digit characters.
        String::HashFieldType type = String::HashFieldType::kIntegerIndex;
        uint32_t running_hash = static_cast<uint32_t>(seed);
        uint64_t index_big = 0;
        const uchar* end = &chars[length];
        while (chars != end) {
          if (type == String::HashFieldType::kIntegerIndex &&
              !TryAddIntegerIndexChar(&index_big, *chars)) {
            type = String::HashFieldType::kHash;
          }
          running_hash = AddCharacterCore(running_hash, *chars++);
        }
        uint32_t hash =
            String::CreateHashFieldValue(GetHashCore(running_hash), type);
        if (Name::ContainsCachedArrayIndex(hash)) {
          // The hash accidentally looks like a cached index. Fix that by
          // setting a bit that looks like a longer-than-cacheable string
          // length.
          hash |= (String::kMaxCachedArrayIndexLength + 1)
                  << String::ArrayIndexLengthBits::kShift;
        }
        DCHECK(!Name::ContainsCachedArrayIndex(hash));
        return hash;
      }
#endif
    }
    // No "else" here: if the first character was a decimal digit, we might
    // still have to take this branch.
    if (length > String::kMaxHashCalcLength) {
      return GetTrivialHash(length);
    }
  }

  // Non-index hash.
  uint32_t running_hash = static_cast<uint32_t>(seed);
  const uchar* end = &chars[length];
  while (chars != end) {
    running_hash = AddCharacterCore(running_hash, *chars++);
  }

  return String::CreateHashFieldValue(GetHashCore(running_hash),
                                      String::HashFieldType::kHash);
}

std::size_t SeededStringHasher::operator()(const char* name) const {
  return StringHasher::HashSequentialString(
      name, static_cast<int>(strlen(name)), hashseed_);
}

}  // namespace internal
}  // namespace v8

#endif  // V8_STRINGS_STRING_HASHER_INL_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/src/strings/string-hasher.h                                                     0000664 0000000 0000000 00000003675 14746647661 0021267 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_STRINGS_STRING_HASHER_H_
#define V8_STRINGS_STRING_HASHER_H_

#include "src/common/globals.h"

namespace v8 {

namespace base {
template <typename T>
class Vector;
}  // namespace base

namespace internal {

// Helper class for incrementally calculating string hashes in a form suitable
// for storing into Name::raw_hash_field.
class V8_EXPORT_PRIVATE StringHasher final {
 public:
  StringHasher() = delete;
  template <typename char_t>
  static inline uint32_t HashSequentialString(const char_t* chars, int length,
                                              uint64_t seed);

  // Calculated hash value for a string consisting of 1 to
  // String::kMaxArrayIndexSize digits with no leading zeros (except "0").
  // value is represented decimal value.
  static uint32_t MakeArrayIndexHash(uint32_t value, int length);

  // No string is allowed to have a hash of zero.  That value is reserved
  // for internal properties.  If the hash calculation yields zero then we
  // use 27 instead.
  static const int kZeroHash = 27;

  // Reusable parts of the hashing algorithm.
  V8_INLINE static uint32_t AddCharacterCore(uint32_t running_hash, uint16_t c);
  V8_INLINE static uint32_t GetHashCore(uint32_t running_hash);

  static inline uint32_t GetTrivialHash(int length);
};

// Useful for std containers that require something ()'able.
struct SeededStringHasher {
  explicit SeededStringHasher(uint64_t hashseed) : hashseed_(hashseed) {}
  inline std::size_t operator()(const char* name) const;

  uint64_t hashseed_;
};

// Useful for std containers that require something ()'able.
struct StringEquals {
  bool operator()(const char* name1, const char* name2) const {
    return strcmp(name1, name2) == 0;
  }
};

}  // namespace internal
}  // namespace v8

#endif  // V8_STRINGS_STRING_HASHER_H_
                                                                   node-23.7.0/deps/v8/src/strings/string-search.h                                                     0000664 0000000 0000000 00000047566 14746647661 0021271 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2011 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_STRINGS_STRING_SEARCH_H_
#define V8_STRINGS_STRING_SEARCH_H_

#include "src/base/strings.h"
#include "src/base/vector.h"
#include "src/execution/isolate.h"
#include "src/objects/string.h"

namespace v8 {
namespace internal {

//---------------------------------------------------------------------
// String Search object.
//---------------------------------------------------------------------

// Class holding constants and methods that apply to all string search variants,
// independently of subject and pattern char size.
class StringSearchBase {
 protected:
  // Cap on the maximal shift in the Boyer-Moore implementation. By setting a
  // limit, we can fix the size of tables. For a needle longer than this limit,
  // search will not be optimal, since we only build tables for a suffix
  // of the string, but it is a safe approximation.
  static const int kBMMaxShift = Isolate::kBMMaxShift;

  // Reduce alphabet to this size.
  // One of the tables used by Boyer-Moore and Boyer-Moore-Horspool has size
  // proportional to the input alphabet. We reduce the alphabet size by
  // equating input characters modulo a smaller alphabet size. This gives
  // a potentially less efficient searching, but is a safe approximation.
  // For needles using only characters in the same Unicode 256-code point page,
  // there is no search speed degradation.
  static const int kLatin1AlphabetSize = 256;
  static const int kUC16AlphabetSize = Isolate::kUC16AlphabetSize;

  // Bad-char shift table stored in the state. It's length is the alphabet size.
  // For patterns below this length, the skip length of Boyer-Moore is too short
  // to compensate for the algorithmic overhead compared to simple brute force.
  static const int kBMMinPatternLength = 7;

  static inline bool IsOneByteString(base::Vector<const uint8_t> string) {
    return true;
  }

  static inline bool IsOneByteString(base::Vector<const base::uc16> string) {
    return String::IsOneByte(string.begin(), string.length());
  }

  friend class Isolate;
};

template <typename PatternChar, typename SubjectChar>
class StringSearch : private StringSearchBase {
 public:
  StringSearch(Isolate* isolate, base::Vector<const PatternChar> pattern)
      : isolate_(isolate),
        pattern_(pattern),
        start_(std::max(0, pattern.length() - kBMMaxShift)) {
    if (sizeof(PatternChar) > sizeof(SubjectChar)) {
      if (!IsOneByteString(pattern_)) {
        strategy_ = &FailSearch;
        return;
      }
    }
    int pattern_length = pattern_.length();
    if (pattern_length < kBMMinPatternLength) {
      if (pattern_length == 1) {
        strategy_ = &SingleCharSearch;
        return;
      }
      strategy_ = &LinearSearch;
      return;
    }
    strategy_ = &InitialSearch;
  }

  int Search(base::Vector<const SubjectChar> subject, int index) {
    return strategy_(this, subject, index);
  }

  static inline int AlphabetSize() {
    if (sizeof(PatternChar) == 1) {
      // Latin1 needle.
      return kLatin1AlphabetSize;
    } else {
      DCHECK_EQ(sizeof(PatternChar), 2);
      // UC16 needle.
      return kUC16AlphabetSize;
    }
  }

 private:
  using SearchFunction = int (*)(StringSearch<PatternChar, SubjectChar>*,
                                 base::Vector<const SubjectChar>, int);

  static int FailSearch(StringSearch<PatternChar, SubjectChar>*,
                        base::Vector<const SubjectChar>, int) {
    return -1;
  }

  static int SingleCharSearch(StringSearch<PatternChar, SubjectChar>* search,
                              base::Vector<const SubjectChar> subject,
                              int start_index);

  static int LinearSearch(StringSearch<PatternChar, SubjectChar>* search,
                          base::Vector<const SubjectChar> subject,
                          int start_index);

  static int InitialSearch(StringSearch<PatternChar, SubjectChar>* search,
                           base::Vector<const SubjectChar> subject,
                           int start_index);

  static int BoyerMooreHorspoolSearch(
      StringSearch<PatternChar, SubjectChar>* search,
      base::Vector<const SubjectChar> subject, int start_index);

  static int BoyerMooreSearch(StringSearch<PatternChar, SubjectChar>* search,
                              base::Vector<const SubjectChar> subject,
                              int start_index);

  void PopulateBoyerMooreHorspoolTable();

  void PopulateBoyerMooreTable();

  static inline bool exceedsOneByte(uint8_t c) { return false; }

  static inline bool exceedsOneByte(uint16_t c) {
    return c > String::kMaxOneByteCharCodeU;
  }

  static inline int CharOccurrence(int* bad_char_occurrence,
                                   SubjectChar char_code) {
    if (sizeof(SubjectChar) == 1) {
      return bad_char_occurrence[static_cast<int>(char_code)];
    }
    if (sizeof(PatternChar) == 1) {
      if (exceedsOneByte(char_code)) {
        return -1;
      }
      return bad_char_occurrence[static_cast<unsigned int>(char_code)];
    }
    // Both pattern and subject are UC16. Reduce character to equivalence
    // class.
    int equiv_class = char_code % kUC16AlphabetSize;
    return bad_char_occurrence[equiv_class];
  }

  // The following tables are shared by all searches.
  // TODO(lrn): Introduce a way for a pattern to keep its tables
  // between searches (e.g., for an Atom RegExp).

  // Store for the BoyerMoore(Horspool) bad char shift table.
  // Return a table covering the last kBMMaxShift+1 positions of
  // pattern.
  int* bad_char_table() { return isolate_->bad_char_shift_table(); }

  // Store for the BoyerMoore good suffix shift table.
  int* good_suffix_shift_table() {
    // Return biased pointer that maps the range  [start_..pattern_.length()
    // to the kGoodSuffixShiftTable array.
    return isolate_->good_suffix_shift_table() - start_;
  }

  // Table used temporarily while building the BoyerMoore good suffix
  // shift table.
  int* suffix_table() {
    // Return biased pointer that maps the range  [start_..pattern_.length()
    // to the kSuffixTable array.
    return isolate_->suffix_table() - start_;
  }

  Isolate* isolate_;
  // The pattern to search for.
  base::Vector<const PatternChar> pattern_;
  // Pointer to implementation of the search.
  SearchFunction strategy_;
  // Cache value of max(0, pattern_length() - kBMMaxShift)
  int start_;
};

template <typename T, typename U>
inline T AlignDown(T value, U alignment) {
  return reinterpret_cast<T>(
      (reinterpret_cast<uintptr_t>(value) & ~(alignment - 1)));
}

inline uint8_t GetHighestValueByte(base::uc16 character) {
  return std::max(static_cast<uint8_t>(character & 0xFF),
                  static_cast<uint8_t>(character >> 8));
}

inline uint8_t GetHighestValueByte(uint8_t character) { return character; }

template <typename PatternChar, typename SubjectChar>
inline int FindFirstCharacter(base::Vector<const PatternChar> pattern,
                              base::Vector<const SubjectChar> subject,
                              int index) {
  const PatternChar pattern_first_char = pattern[0];
  const int max_n = (subject.length() - pattern.length() + 1);

  if (sizeof(SubjectChar) == 2 && pattern_first_char == 0) {
    // Special-case looking for the 0 char in other than one-byte strings.
    // memchr mostly fails in this case due to every other byte being 0 in text
    // that is mostly ascii characters.
    for (int i = index; i < max_n; ++i) {
      if (subject[i] == 0) return i;
    }
    return -1;
  }
  const uint8_t search_byte = GetHighestValueByte(pattern_first_char);
  const SubjectChar search_char = static_cast<SubjectChar>(pattern_first_char);
  int pos = index;
  do {
    DCHECK_GE(max_n - pos, 0);
    const SubjectChar* char_pos = reinterpret_cast<const SubjectChar*>(
        memchr(subject.begin() + pos, search_byte,
               (max_n - pos) * sizeof(SubjectChar)));
    if (char_pos == nullptr) return -1;
    char_pos = AlignDown(char_pos, sizeof(SubjectChar));
    pos = static_cast<int>(char_pos - subject.begin());
    if (subject[pos] == search_char) return pos;
  } while (++pos < max_n);

  return -1;
}

//---------------------------------------------------------------------
// Single Character Pattern Search Strategy
//---------------------------------------------------------------------

template <typename PatternChar, typename SubjectChar>
int StringSearch<PatternChar, SubjectChar>::SingleCharSearch(
    StringSearch<PatternChar, SubjectChar>* search,
    base::Vector<const SubjectChar> subject, int index) {
  DCHECK_EQ(1, search->pattern_.length());
  PatternChar pattern_first_char = search->pattern_[0];
  if (sizeof(PatternChar) > sizeof(SubjectChar)) {
    if (exceedsOneByte(pattern_first_char)) {
      return -1;
    }
  }
  return FindFirstCharacter(search->pattern_, subject, index);
}

//---------------------------------------------------------------------
// Linear Search Strategy
//---------------------------------------------------------------------

template <typename PatternChar, typename SubjectChar>
inline bool CharCompare(const PatternChar* pattern, const SubjectChar* subject,
                        int length) {
  DCHECK_GT(length, 0);
  int pos = 0;
  do {
    if (pattern[pos] != subject[pos]) {
      return false;
    }
    pos++;
  } while (pos < length);
  return true;
}

// Simple linear search for short patterns. Never bails out.
template <typename PatternChar, typename SubjectChar>
int StringSearch<PatternChar, SubjectChar>::LinearSearch(
    StringSearch<PatternChar, SubjectChar>* search,
    base::Vector<const SubjectChar> subject, int index) {
  base::Vector<const PatternChar> pattern = search->pattern_;
  DCHECK_GT(pattern.length(), 1);
  int pattern_length = pattern.length();
  int i = index;
  int n = subject.length() - pattern_length;
  while (i <= n) {
    i = FindFirstCharacter(pattern, subject, i);
    if (i == -1) return -1;
    DCHECK_LE(i, n);
    i++;
    // Loop extracted to separate function to allow using return to do
    // a deeper break.
    if (CharCompare(pattern.begin() + 1, subject.begin() + i,
                    pattern_length - 1)) {
      return i - 1;
    }
  }
  return -1;
}

//---------------------------------------------------------------------
// Boyer-Moore string search
//---------------------------------------------------------------------

template <typename PatternChar, typename SubjectChar>
int StringSearch<PatternChar, SubjectChar>::BoyerMooreSearch(
    StringSearch<PatternChar, SubjectChar>* search,
    base::Vector<const SubjectChar> subject, int start_index) {
  base::Vector<const PatternChar> pattern = search->pattern_;
  int subject_length = subject.length();
  int pattern_length = pattern.length();
  // Only preprocess at most kBMMaxShift last characters of pattern.
  int start = search->start_;

  int* bad_char_occurence = search->bad_char_table();
  int* good_suffix_shift = search->good_suffix_shift_table();

  PatternChar last_char = pattern[pattern_length - 1];
  int index = start_index;
  // Continue search from i.
  while (index <= subject_length - pattern_length) {
    int j = pattern_length - 1;
    int c;
    while (last_char != (c = subject[index + j])) {
      int shift = j - CharOccurrence(bad_char_occurence, c);
      index += shift;
      if (index > subject_length - pattern_length) {
        return -1;
      }
    }
    while (j >= 0 && pattern[j] == (c = subject[index + j])) j--;
    if (j < 0) {
      return index;
    } else if (j < start) {
      // we have matched more than our tables allow us to be smart about.
      // Fall back on BMH shift.
      index += pattern_length - 1 -
               CharOccurrence(bad_char_occurence,
                              static_cast<SubjectChar>(last_char));
    } else {
      int gs_shift = good_suffix_shift[j + 1];
      int bc_occ = CharOccurrence(bad_char_occurence, c);
      int shift = j - bc_occ;
      if (gs_shift > shift) {
        shift = gs_shift;
      }
      index += shift;
    }
  }

  return -1;
}

template <typename PatternChar, typename SubjectChar>
void StringSearch<PatternChar, SubjectChar>::PopulateBoyerMooreTable() {
  int pattern_length = pattern_.length();
  const PatternChar* pattern = pattern_.begin();
  // Only look at the last kBMMaxShift characters of pattern (from start_
  // to pattern_length).
  int start = start_;
  int length = pattern_length - start;

  // Biased tables so that we can use pattern indices as table indices,
  // even if we only cover the part of the pattern from offset start.
  int* shift_table = good_suffix_shift_table();
  int* suffix_table = this->suffix_table();

  // Initialize table.
  for (int i = start; i < pattern_length; i++) {
    shift_table[i] = length;
  }
  shift_table[pattern_length] = 1;
  suffix_table[pattern_length] = pattern_length + 1;

  if (pattern_length <= start) {
    return;
  }

  // Find suffixes.
  PatternChar last_char = pattern[pattern_length - 1];
  int suffix = pattern_length + 1;
  {
    int i = pattern_length;
    while (i > start) {
      PatternChar c = pattern[i - 1];
      while (suffix <= pattern_length && c != pattern[suffix - 1]) {
        if (shift_table[suffix] == length) {
          shift_table[suffix] = suffix - i;
        }
        suffix = suffix_table[suffix];
      }
      suffix_table[--i] = --suffix;
      if (suffix == pattern_length) {
        // No suffix to extend, so we check against last_char only.
        while ((i > start) && (pattern[i - 1] != last_char)) {
          if (shift_table[pattern_length] == length) {
            shift_table[pattern_length] = pattern_length - i;
          }
          suffix_table[--i] = pattern_length;
        }
        if (i > start) {
          suffix_table[--i] = --suffix;
        }
      }
    }
  }
  // Build shift table using suffixes.
  if (suffix < pattern_length) {
    for (int i = start; i <= pattern_length; i++) {
      if (shift_table[i] == length) {
        shift_table[i] = suffix - start;
      }
      if (i == suffix) {
        suffix = suffix_table[suffix];
      }
    }
  }
}

//---------------------------------------------------------------------
// Boyer-Moore-Horspool string search.
//---------------------------------------------------------------------

template <typename PatternChar, typename SubjectChar>
int StringSearch<PatternChar, SubjectChar>::BoyerMooreHorspoolSearch(
    StringSearch<PatternChar, SubjectChar>* search,
    base::Vector<const SubjectChar> subject, int start_index) {
  base::Vector<const PatternChar> pattern = search->pattern_;
  int subject_length = subject.length();
  int pattern_length = pattern.length();
  int* char_occurrences = search->bad_char_table();
  int badness = -pattern_length;

  // How bad we are doing without a good-suffix table.
  PatternChar last_char = pattern[pattern_length - 1];
  int last_char_shift =
      pattern_length - 1 -
      CharOccurrence(char_occurrences, static_cast<SubjectChar>(last_char));
  // Perform search
  int index = start_index;  // No matches found prior to this index.
  while (index <= subject_length - pattern_length) {
    int j = pattern_length - 1;
    int subject_char;
    while (last_char != (subject_char = subject[index + j])) {
      int bc_occ = CharOccurrence(char_occurrences, subject_char);
      int shift = j - bc_occ;
      index += shift;
      badness += 1 - shift;  // at most zero, so badness cannot increase.
      if (index > subject_length - pattern_length) {
        return -1;
      }
    }
    j--;
    while (j >= 0 && pattern[j] == (subject[index + j])) j--;
    if (j < 0) {
      return index;
    } else {
      index += last_char_shift;
      // Badness increases by the number of characters we have
      // checked, and decreases by the number of characters we
      // can skip by shifting. It's a measure of how we are doing
      // compared to reading each character exactly once.
      badness += (pattern_length - j) - last_char_shift;
      if (badness > 0) {
        search->PopulateBoyerMooreTable();
        search->strategy_ = &BoyerMooreSearch;
        return BoyerMooreSearch(search, subject, index);
      }
    }
  }
  return -1;
}

template <typename PatternChar, typename SubjectChar>
void StringSearch<PatternChar, SubjectChar>::PopulateBoyerMooreHorspoolTable() {
  int pattern_length = pattern_.length();

  int* bad_char_occurrence = bad_char_table();

  // Only preprocess at most kBMMaxShift last characters of pattern.
  int start = start_;
  // Run forwards to populate bad_char_table, so that *last* instance
  // of character equivalence class is the one registered.
  // Notice: Doesn't include the last character.
  int table_size = AlphabetSize();
  if (start == 0) {  // All patterns less than kBMMaxShift in length.
    memset(bad_char_occurrence, -1, table_size * sizeof(*bad_char_occurrence));
  } else {
    for (int i = 0; i < table_size; i++) {
      bad_char_occurrence[i] = start - 1;
    }
  }
  for (int i = start; i < pattern_length - 1; i++) {
    PatternChar c = pattern_[i];
    int bucket = (sizeof(PatternChar) == 1) ? c : c % AlphabetSize();
    bad_char_occurrence[bucket] = i;
  }
}

//---------------------------------------------------------------------
// Linear string search with bailout to BMH.
//---------------------------------------------------------------------

// Simple linear search for short patterns, which bails out if the string
// isn't found very early in the subject. Upgrades to BoyerMooreHorspool.
template <typename PatternChar, typename SubjectChar>
int StringSearch<PatternChar, SubjectChar>::InitialSearch(
    StringSearch<PatternChar, SubjectChar>* search,
    base::Vector<const SubjectChar> subject, int index) {
  base::Vector<const PatternChar> pattern = search->pattern_;
  int pattern_length = pattern.length();
  // Badness is a count of how much work we have done.  When we have
  // done enough work we decide it's probably worth switching to a better
  // algorithm.
  int badness = -10 - (pattern_length << 2);

  // We know our pattern is at least 2 characters, we cache the first so
  // the common case of the first character not matching is faster.
  for (int i = index, n = subject.length() - pattern_length; i <= n; i++) {
    badness++;
    if (badness <= 0) {
      i = FindFirstCharacter(pattern, subject, i);
      if (i == -1) return -1;
      DCHECK_LE(i, n);
      int j = 1;
      do {
        if (pattern[j] != subject[i + j]) {
          break;
        }
        j++;
      } while (j < pattern_length);
      if (j == pattern_length) {
        return i;
      }
      badness += j;
    } else {
      search->PopulateBoyerMooreHorspoolTable();
      search->strategy_ = &BoyerMooreHorspoolSearch;
      return BoyerMooreHorspoolSearch(search, subject, i);
    }
  }
  return -1;
}

// Perform a a single stand-alone search.
// If searching multiple times for the same pattern, a search
// object should be constructed once and the Search function then called
// for each search.
template <typename SubjectChar, typename PatternChar>
int SearchString(Isolate* isolate, base::Vector<const SubjectChar> subject,
                 base::Vector<const PatternChar> pattern, int start_index) {
  StringSearch<PatternChar, SubjectChar> search(isolate, pattern);
  return search.Search(subject, start_index);
}

// A wrapper function around SearchString that wraps raw pointers to the subject
// and pattern as vectors before calling SearchString. Used from the
// StringIndexOf builtin.
template <typename SubjectChar, typename PatternChar>
intptr_t SearchStringRaw(Isolate* isolate, const SubjectChar* subject_ptr,
                         int subject_length, const PatternChar* pattern_ptr,
                         int pattern_length, int start_index) {
  DisallowGarbageCollection no_gc;
  base::Vector<const SubjectChar> subject(subject_ptr, subject_length);
  base::Vector<const PatternChar> pattern(pattern_ptr, pattern_length);
  return SearchString(isolate, subject, pattern, start_index);
}

}  // namespace internal
}  // namespace v8

#endif  // V8_STRINGS_STRING_SEARCH_H_
                                                                                                                                          node-23.7.0/deps/v8/src/strings/string-stream.cc                                                    0000664 0000000 0000000 00000034311 14746647661 0021435 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/strings/string-stream.h"

#include <memory>

#include "src/base/vector.h"
#include "src/handles/handles-inl.h"
#include "src/logging/log.h"
#include "src/objects/js-array-inl.h"
#include "src/objects/objects-inl.h"
#include "src/objects/prototype.h"

namespace v8 {
namespace internal {

static const int kMentionedObjectCacheMaxSize = 256;

char* HeapStringAllocator::allocate(unsigned bytes) {
  space_ = NewArray<char>(bytes);
  return space_;
}

char* FixedStringAllocator::allocate(unsigned bytes) {
  CHECK_LE(bytes, length_);
  return buffer_;
}

char* FixedStringAllocator::grow(unsigned* old) {
  *old = length_;
  return buffer_;
}

bool StringStream::Put(char c) {
  if (full()) return false;
  DCHECK(length_ < capacity_);
  // Since the trailing '\0' is not accounted for in length_ fullness is
  // indicated by a difference of 1 between length_ and capacity_. Thus when
  // reaching a difference of 2 we need to grow the buffer.
  if (length_ == capacity_ - 2) {
    unsigned new_capacity = capacity_;
    char* new_buffer = allocator_->grow(&new_capacity);
    if (new_capacity > capacity_) {
      capacity_ = new_capacity;
      buffer_ = new_buffer;
    } else {
      // Reached the end of the available buffer.
      DCHECK_GE(capacity_, 5);
      length_ = capacity_ - 1;  // Indicate fullness of the stream.
      buffer_[length_ - 4] = '.';
      buffer_[length_ - 3] = '.';
      buffer_[length_ - 2] = '.';
      buffer_[length_ - 1] = '\n';
      buffer_[length_] = '\0';
      return false;
    }
  }
  buffer_[length_] = c;
  buffer_[length_ + 1] = '\0';
  length_++;
  return true;
}

// A control character is one that configures a format element.  For
// instance, in %.5s, .5 are control characters.
static bool IsControlChar(char c) {
  switch (c) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case '.':
    case '-':
      return true;
    default:
      return false;
  }
}

void StringStream::Add(base::Vector<const char> format,
                       base::Vector<FmtElm> elms) {
  // If we already ran out of space then return immediately.
  if (full()) return;
  int offset = 0;
  int elm = 0;
  while (offset < format.length()) {
    if (format[offset] != '%' || elm == elms.length()) {
      Put(format[offset]);
      offset++;
      continue;
    }
    // Read this formatting directive into a temporary buffer
    base::EmbeddedVector<char, 24> temp;
    int format_length = 0;
    // Skip over the whole control character sequence until the
    // format element type
    temp[format_length++] = format[offset++];
    while (offset < format.length() && IsControlChar(format[offset]))
      temp[format_length++] = format[offset++];
    if (offset >= format.length()) return;
    char type = format[offset];
    temp[format_length++] = type;
    temp[format_length] = '\0';
    offset++;
    FmtElm current = elms[elm++];
    switch (type) {
      case 's': {
        DCHECK_EQ(FmtElm::C_STR, current.type_);
        const char* value = current.data_.u_c_str_;
        Add(value);
        break;
      }
      case 'w': {
        DCHECK_EQ(FmtElm::LC_STR, current.type_);
        base::Vector<const base::uc16> value = *current.data_.u_lc_str_;
        for (int i = 0; i < value.length(); i++)
          Put(static_cast<char>(value[i]));
        break;
      }
      case 'o': {
        DCHECK_EQ(FmtElm::OBJ, current.type_);
        Tagged<Object> obj(current.data_.u_obj_);
        PrintObject(obj);
        break;
      }
      case 'k': {
        DCHECK_EQ(FmtElm::INT, current.type_);
        int value = current.data_.u_int_;
        if (0x20 <= value && value <= 0x7F) {
          Put(value);
        } else if (value <= 0xFF) {
          Add("\\x%02x", value);
        } else {
          Add("\\u%04x", value);
        }
        break;
      }
      case 'i':
      case 'd':
      case 'u':
      case 'x':
      case 'c':
      case 'X': {
        int value = current.data_.u_int_;
        base::EmbeddedVector<char, 24> formatted;
        int length = SNPrintF(formatted, temp.begin(), value);
        Add(base::Vector<const char>(formatted.begin(), length));
        break;
      }
      case 'f':
      case 'g':
      case 'G':
      case 'e':
      case 'E': {
        double value = current.data_.u_double_;
        int inf = std::isinf(value);
        if (inf == -1) {
          Add("-inf");
        } else if (inf == 1) {
          Add("inf");
        } else if (std::isnan(value)) {
          Add("nan");
        } else {
          base::EmbeddedVector<char, 28> formatted;
          SNPrintF(formatted, temp.begin(), value);
          Add(formatted.begin());
        }
        break;
      }
      case 'p': {
        void* value = current.data_.u_pointer_;
        base::EmbeddedVector<char, 20> formatted;
        SNPrintF(formatted, temp.begin(), value);
        Add(formatted.begin());
        break;
      }
      default:
        UNREACHABLE();
    }
  }

  // Verify that the buffer is 0-terminated
  DCHECK_EQ(buffer_[length_], '\0');
}

void StringStream::PrintObject(Tagged<Object> o) {
  ShortPrint(o, this);
  if (IsString(o)) {
    if (Cast<String>(o)->length() <= String::kMaxShortPrintLength) {
      return;
    }
  } else if (IsNumber(o) || IsOddball(o)) {
    return;
  }
  if (IsHeapObject(o) && object_print_mode_ == kPrintObjectVerbose) {
    // TODO(delphick): Consider whether we can get the isolate without using
    // TLS.
    Isolate* isolate = Isolate::Current();
    DebugObjectCache* debug_object_cache =
        isolate->string_stream_debug_object_cache();
    for (size_t i = 0; i < debug_object_cache->size(); i++) {
      if (*(*debug_object_cache)[i] == o) {
        Add("#%d#", static_cast<int>(i));
        return;
      }
    }
    if (debug_object_cache->size() < kMentionedObjectCacheMaxSize) {
      Add("#%d#", static_cast<int>(debug_object_cache->size()));
      debug_object_cache->push_back(handle(Cast<HeapObject>(o), isolate));
    } else {
      Add("@%p", o);
    }
  }
}

std::unique_ptr<char[]> StringStream::ToCString() const {
  char* str = NewArray<char>(length_ + 1);
  MemCopy(str, buffer_, length_);
  str[length_] = '\0';
  return std::unique_ptr<char[]>(str);
}

void StringStream::Log(Isolate* isolate) {
  LOG(isolate, StringEvent("StackDump", buffer_));
}

void StringStream::OutputToFile(FILE* out) {
  // Dump the output to stdout, but make sure to break it up into
  // manageable chunks to avoid losing parts of the output in the OS
  // printing code. This is a problem on Windows in particular; see
  // the VPrint() function implementations in platform-win32.cc.
  unsigned position = 0;
  for (unsigned next; (next = position + 2048) < length_; position = next) {
    char save = buffer_[next];
    buffer_[next] = '\0';
    internal::PrintF(out, "%s", &buffer_[position]);
    buffer_[next] = save;
  }
  internal::PrintF(out, "%s", &buffer_[position]);
}

Handle<String> StringStream::ToString(Isolate* isolate) {
  return isolate->factory()
      ->NewStringFromUtf8(base::Vector<const char>(buffer_, length_))
      .ToHandleChecked();
}

void StringStream::ClearMentionedObjectCache(Isolate* isolate) {
  isolate->set_string_stream_current_security_token(Tagged<Object>());
  if (isolate->string_stream_debug_object_cache() == nullptr) {
    isolate->set_string_stream_debug_object_cache(new DebugObjectCache());
  }
  isolate->string_stream_debug_object_cache()->clear();
}

#ifdef DEBUG
bool StringStream::IsMentionedObjectCacheClear(Isolate* isolate) {
  return object_print_mode_ == kPrintObjectConcise ||
         isolate->string_stream_debug_object_cache()->size() == 0;
}
#endif

bool StringStream::Put(Tagged<String> str) {
  return Put(str, 0, str->length());
}

bool StringStream::Put(Tagged<String> str, int start, int end) {
  StringCharacterStream stream(str, start);
  for (int i = start; i < end && stream.HasMore(); i++) {
    uint16_t c = stream.GetNext();
    if (c >= 127 || c < 32) {
      c = '?';
    }
    if (!Put(static_cast<char>(c))) {
      return false;  // Output was truncated.
    }
  }
  return true;
}

void StringStream::PrintName(Tagged<Object> name) {
  if (IsString(name)) {
    Tagged<String> str = Cast<String>(name);
    if (str->length() > 0) {
      Put(str);
    } else {
      Add("/* anonymous */");
    }
  } else {
    Add("%o", name);
  }
}

void StringStream::PrintUsingMap(Tagged<JSObject> js_object) {
  Tagged<Map> map = js_object->map();
  Tagged<DescriptorArray> descs =
      map->instance_descriptors(js_object->GetIsolate());
  for (InternalIndex i : map->IterateOwnDescriptors()) {
    PropertyDetails details = descs->GetDetails(i);
    if (details.location() == PropertyLocation::kField) {
      DCHECK_EQ(PropertyKind::kData, details.kind());
      Tagged<Object> key = descs->GetKey(i);
      if (IsString(key) || IsNumber(key)) {
        int len = 3;
        if (IsString(key)) {
          len = Cast<String>(key)->length();
        }
        for (; len < 18; len++) Put(' ');
        if (IsString(key)) {
          Put(Cast<String>(key));
        } else {
          ShortPrint(key);
        }
        Add(": ");
        FieldIndex index = FieldIndex::ForDescriptor(map, i);
        Tagged<Object> value = js_object->RawFastPropertyAt(index);
        Add("%o\n", value);
      }
    }
  }
}

void StringStream::PrintFixedArray(Tagged<FixedArray> array,
                                   unsigned int limit) {
  ReadOnlyRoots roots = array->GetReadOnlyRoots();
  for (unsigned int i = 0; i < 10 && i < limit; i++) {
    Tagged<Object> element = array->get(i);
    if (IsTheHole(element, roots)) continue;
    for (int len = 1; len < 18; len++) {
      Put(' ');
    }
    Add("%d: %o\n", i, array->get(i));
  }
  if (limit >= 10) {
    Add("                  ...\n");
  }
}

void StringStream::PrintByteArray(Tagged<ByteArray> byte_array) {
  unsigned int limit = byte_array->length();
  for (unsigned int i = 0; i < 10 && i < limit; i++) {
    uint8_t b = byte_array->get(i);
    Add("             %d: %3d 0x%02x", i, b, b);
    if (b >= ' ' && b <= '~') {
      Add(" '%c'", b);
    } else if (b == '\n') {
      Add(" '\n'");
    } else if (b == '\r') {
      Add(" '\r'");
    } else if (b >= 1 && b <= 26) {
      Add(" ^%c", b + 'A' - 1);
    }
    Add("\n");
  }
  if (limit >= 10) {
    Add("                  ...\n");
  }
}

void StringStream::PrintMentionedObjectCache(Isolate* isolate) {
  if (object_print_mode_ == kPrintObjectConcise) return;
  DebugObjectCache* debug_object_cache =
      isolate->string_stream_debug_object_cache();
  Add("-- ObjectCacheKey --\n\n");
  for (size_t i = 0; i < debug_object_cache->size(); i++) {
    Tagged<HeapObject> printee = *(*debug_object_cache)[i];
    Add(" #%d# %p: ", static_cast<int>(i),
        reinterpret_cast<void*>(printee.ptr()));
    ShortPrint(printee, this);
    Add("\n");
    if (IsJSObject(printee)) {
      if (IsJSPrimitiveWrapper(printee)) {
        Add("           value(): %o\n",
            Cast<JSPrimitiveWrapper>(printee)->value());
      }
      PrintUsingMap(Cast<JSObject>(printee));
      if (IsJSArray(printee)) {
        Tagged<JSArray> array = Cast<JSArray>(printee);
        if (array->HasObjectElements()) {
          unsigned int limit = Cast<FixedArray>(array->elements())->length();
          unsigned int length = static_cast<uint32_t>(
              Object::NumberValue(Cast<JSArray>(array)->length()));
          if (length < limit) limit = length;
          PrintFixedArray(Cast<FixedArray>(array->elements()), limit);
        }
      }
    } else if (IsByteArray(printee)) {
      PrintByteArray(Cast<ByteArray>(printee));
    } else if (IsFixedArray(printee)) {
      unsigned int limit = Cast<FixedArray>(printee)->length();
      PrintFixedArray(Cast<FixedArray>(printee), limit);
    }
  }
}

void StringStream::PrintSecurityTokenIfChanged(Tagged<JSFunction> fun) {
  Tagged<Object> token = fun->native_context()->security_token();
  Isolate* isolate = fun->GetIsolate();
  // Use SafeEquals because the cached token might be a stale pointer.
  if (token.SafeEquals(isolate->string_stream_current_security_token())) {
    Add("Security context: %o\n", token);
    isolate->set_string_stream_current_security_token(token);
  }
}

void StringStream::PrintFunction(Tagged<JSFunction> fun,
                                 Tagged<Object> receiver) {
  PrintPrototype(fun, receiver);
}

void StringStream::PrintPrototype(Tagged<JSFunction> fun,
                                  Tagged<Object> receiver) {
  Tagged<Object> name = fun->shared()->Name();
  bool print_name = false;
  Isolate* isolate = fun->GetIsolate();
  if (IsNullOrUndefined(receiver, isolate) || IsTheHole(receiver, isolate) ||
      IsJSProxy(receiver) || IsWasmObject(receiver)) {
    print_name = true;
  } else if (!isolate->context().is_null()) {
    if (!IsJSObject(receiver)) {
      receiver =
          Object::GetPrototypeChainRootMap(receiver, isolate)->prototype();
    }

    for (PrototypeIterator iter(isolate, Cast<JSObject>(receiver),
                                kStartAtReceiver);
         !iter.IsAtEnd(); iter.Advance()) {
      if (!IsJSObject(iter.GetCurrent())) break;
      Tagged<Object> key = iter.GetCurrent<JSObject>()->SlowReverseLookup(fun);
      if (!IsUndefined(key, isolate)) {
        if (!IsString(name) || !IsString(key) ||
            !Cast<String>(name)->Equals(Cast<String>(key))) {
          print_name = true;
        }
        if (IsString(name) && Cast<String>(name)->length() == 0) {
          print_name = false;
        }
        name = key;
        break;
      }
    }
  }
  PrintName(name);
  // Also known as - if the name in the function doesn't match the name under
  // which it was looked up.
  if (print_name) {
    Add("(aka ");
    PrintName(fun->shared()->Name());
    Put(')');
  }
}

char* HeapStringAllocator::grow(unsigned* bytes) {
  unsigned new_bytes = *bytes * 2;
  // Check for overflow.
  if (new_bytes <= *bytes) {
    return space_;
  }
  char* new_space = NewArray<char>(new_bytes);
  if (new_space == nullptr) {
    return space_;
  }
  MemCopy(new_space, space_, *bytes);
  *bytes = new_bytes;
  DeleteArray(space_);
  space_ = new_space;
  return new_space;
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/src/strings/string-stream.h                                                     0000664 0000000 0000000 00000014402 14746647661 0021276 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_STRINGS_STRING_STREAM_H_
#define V8_STRINGS_STRING_STREAM_H_

#include <memory>

#include "src/base/small-vector.h"
#include "src/base/strings.h"
#include "src/base/vector.h"
#include "src/handles/handles.h"
#include "src/objects/objects.h"
#include "src/objects/tagged.h"
#include "src/utils/allocation.h"

namespace v8 {
namespace internal {

// Forward declarations.
class ByteArray;

class StringAllocator {
 public:
  virtual ~StringAllocator() = default;
  // Allocate a number of bytes.
  virtual char* allocate(unsigned bytes) = 0;
  // Allocate a larger number of bytes and copy the old buffer to the new one.
  // bytes is an input and output parameter passing the old size of the buffer
  // and returning the new size.  If allocation fails then we return the old
  // buffer and do not increase the size.
  virtual char* grow(unsigned* bytes) = 0;
};

// Normal allocator uses new[] and delete[].
class HeapStringAllocator final : public StringAllocator {
 public:
  ~HeapStringAllocator() override { DeleteArray(space_); }
  char* allocate(unsigned bytes) override;
  char* grow(unsigned* bytes) override;

 private:
  char* space_;
};

class FixedStringAllocator final : public StringAllocator {
 public:
  FixedStringAllocator(char* buffer, unsigned length)
      : buffer_(buffer), length_(length) {}
  ~FixedStringAllocator() override = default;
  FixedStringAllocator(const FixedStringAllocator&) = delete;
  FixedStringAllocator& operator=(const FixedStringAllocator&) = delete;

  char* allocate(unsigned bytes) override;
  char* grow(unsigned* bytes) override;

 private:
  char* buffer_;
  unsigned length_;
};

template <std::size_t kInlineSize>
class SmallStringOptimizedAllocator final : public StringAllocator {
 public:
  using SmallVector = base::SmallVector<char, kInlineSize>;

  explicit SmallStringOptimizedAllocator(SmallVector* vector) V8_NOEXCEPT
      : vector_(vector) {}

  char* allocate(unsigned bytes) override {
    vector_->resize_no_init(bytes);
    return vector_->data();
  }

  char* grow(unsigned* bytes) override {
    unsigned new_bytes = *bytes * 2;
    // Check for overflow.
    if (new_bytes <= *bytes) {
      return vector_->data();
    }
    vector_->resize_no_init(new_bytes);
    *bytes = new_bytes;
    return vector_->data();
  }

 private:
  SmallVector* vector_;
};

class StringStream final {
  class FmtElm final {
   public:
    FmtElm(int value) : FmtElm(INT) {  // NOLINT
      data_.u_int_ = value;
    }
    explicit FmtElm(double value) : FmtElm(DOUBLE) {  // NOLINT
      data_.u_double_ = value;
    }
    FmtElm(const char* value) : FmtElm(C_STR) {  // NOLINT
      data_.u_c_str_ = value;
    }
    FmtElm(const base::Vector<const base::uc16>& value)  // NOLINT
        : FmtElm(LC_STR) {
      data_.u_lc_str_ = &value;
    }
    template <typename T>
    FmtElm(Tagged<T> value) : FmtElm(OBJ) {  // NOLINT
      data_.u_obj_ = value.ptr();
    }
    template <typename T>
    FmtElm(Handle<T> value) : FmtElm(HANDLE) {  // NOLINT
      data_.u_handle_ = value.location();
    }
    FmtElm(void* value) : FmtElm(POINTER) {  // NOLINT
      data_.u_pointer_ = value;
    }

   private:
    friend class StringStream;
    enum Type { INT, DOUBLE, C_STR, LC_STR, OBJ, HANDLE, POINTER };

#ifdef DEBUG
    Type type_;
    explicit FmtElm(Type type) : type_(type) {}
#else
    explicit FmtElm(Type) {}
#endif

    union {
      int u_int_;
      double u_double_;
      const char* u_c_str_;
      const base::Vector<const base::uc16>* u_lc_str_;
      Address u_obj_;
      Address* u_handle_;
      void* u_pointer_;
    } data_;
  };

 public:
  enum ObjectPrintMode { kPrintObjectConcise, kPrintObjectVerbose };
  explicit StringStream(StringAllocator* allocator,
                        ObjectPrintMode object_print_mode = kPrintObjectVerbose)
      : allocator_(allocator),
        object_print_mode_(object_print_mode),
        capacity_(kInitialCapacity),
        length_(0),
        buffer_(allocator_->allocate(kInitialCapacity)) {
    buffer_[0] = 0;
  }

  bool Put(char c);
  bool Put(Tagged<String> str);
  bool Put(Tagged<String> str, int start, int end);
  void Add(const char* format) { Add(base::CStrVector(format)); }
  void Add(base::Vector<const char> format) {
    Add(format, base::Vector<FmtElm>());
  }

  template <typename... Args>
  void Add(const char* format, Args... args) {
    Add(base::CStrVector(format), args...);
  }

  template <typename... Args>
  void Add(base::Vector<const char> format, Args... args) {
    FmtElm elems[]{args...};
    Add(format, base::ArrayVector(elems));
  }

  // Getting the message out.
  void OutputToFile(FILE* out);
  void OutputToStdOut() { OutputToFile(stdout); }
  void Log(Isolate* isolate);
  Handle<String> ToString(Isolate* isolate);
  std::unique_ptr<char[]> ToCString() const;
  int length() const { return length_; }

  // Object printing support.
  void PrintName(Tagged<Object> o);
  void PrintFixedArray(Tagged<FixedArray> array, unsigned int limit);
  void PrintByteArray(Tagged<ByteArray> ba);
  void PrintUsingMap(Tagged<JSObject> js_object);
  void PrintPrototype(Tagged<JSFunction> fun, Tagged<Object> receiver);
  void PrintSecurityTokenIfChanged(Tagged<JSFunction> function);
  void PrintFunction(Tagged<JSFunction> function, Tagged<Object> receiver);

  // Reset the stream.
  void Reset() {
    length_ = 0;
    buffer_[0] = 0;
  }

  // Mentioned object cache support.
  void PrintMentionedObjectCache(Isolate* isolate);
  V8_EXPORT_PRIVATE static void ClearMentionedObjectCache(Isolate* isolate);
#ifdef DEBUG
  bool IsMentionedObjectCacheClear(Isolate* isolate);
#endif

  static const int kInitialCapacity = 16;

 private:
  void Add(base::Vector<const char> format, base::Vector<FmtElm> elms);
  void PrintObject(Tagged<Object> obj);

  StringAllocator* allocator_;
  ObjectPrintMode object_print_mode_;
  unsigned capacity_;
  unsigned length_;  // does not include terminating 0-character
  char* buffer_;

  bool full() const { return (capacity_ - length_) == 1; }
  int space() const { return capacity_ - length_; }

  DISALLOW_IMPLICIT_CONSTRUCTORS(StringStream);
};

}  // namespace internal
}  // namespace v8

#endif  // V8_STRINGS_STRING_STREAM_H_
                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/src/strings/unicode-decoder.cc                                                  0000664 0000000 0000000 00000015077 14746647661 0021677 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/strings/unicode-decoder.h"

#include "src/strings/unicode-inl.h"
#include "src/utils/memcopy.h"

#if V8_ENABLE_WEBASSEMBLY
#include "src/third_party/utf8-decoder/generalized-utf8-decoder.h"
#endif

namespace v8 {
namespace internal {

namespace {
template <class Decoder>
struct DecoderTraits;

template <>
struct DecoderTraits<Utf8Decoder> {
  static bool IsInvalidSurrogatePair(uint32_t lead, uint32_t trail) {
    // The DfaDecoder will only ever decode Unicode scalar values, and all
    // sequences of USVs are valid.
    DCHECK(!unibrow::Utf16::IsLeadSurrogate(trail));
    DCHECK(!unibrow::Utf16::IsTrailSurrogate(trail));
    return false;
  }
  static const bool kAllowIncompleteSequences = true;
  using DfaDecoder = Utf8DfaDecoder;
};

#if V8_ENABLE_WEBASSEMBLY
template <>
struct DecoderTraits<Wtf8Decoder> {
  static bool IsInvalidSurrogatePair(uint32_t lead, uint32_t trail) {
    return unibrow::Utf16::IsSurrogatePair(lead, trail);
  }
  static const bool kAllowIncompleteSequences = false;
  using DfaDecoder = GeneralizedUtf8DfaDecoder;
};

template <>
struct DecoderTraits<StrictUtf8Decoder> {
  static bool IsInvalidSurrogatePair(uint32_t lead, uint32_t trail) {
    // The DfaDecoder will only ever decode Unicode scalar values, and all
    // sequences of USVs are valid.
    DCHECK(!unibrow::Utf16::IsLeadSurrogate(trail));
    DCHECK(!unibrow::Utf16::IsTrailSurrogate(trail));
    return false;
  }
  static const bool kAllowIncompleteSequences = false;
  using DfaDecoder = Utf8DfaDecoder;
};
#endif  // V8_ENABLE_WEBASSEMBLY
}  // namespace

template <class Decoder>
Utf8DecoderBase<Decoder>::Utf8DecoderBase(base::Vector<const uint8_t> data)
    : encoding_(Encoding::kAscii),
      non_ascii_start_(NonAsciiStart(data.begin(), data.length())),
      utf16_length_(non_ascii_start_) {
  using Traits = DecoderTraits<Decoder>;
  if (non_ascii_start_ == data.length()) return;

  bool is_one_byte = true;
  auto state = Traits::DfaDecoder::kAccept;
  uint32_t current = 0;
  uint32_t previous = 0;
  const uint8_t* cursor = data.begin() + non_ascii_start_;
  const uint8_t* end = data.begin() + data.length();

  while (cursor < end) {
    if (V8_LIKELY(*cursor <= unibrow::Utf8::kMaxOneByteChar &&
                  state == Traits::DfaDecoder::kAccept)) {
      DCHECK_EQ(0u, current);
      DCHECK(!Traits::IsInvalidSurrogatePair(previous, *cursor));
      previous = *cursor;
      utf16_length_++;
      cursor++;
      continue;
    }

    auto previous_state = state;
    Traits::DfaDecoder::Decode(*cursor, &state, &current);
    if (state < Traits::DfaDecoder::kAccept) {
      DCHECK_EQ(state, Traits::DfaDecoder::kReject);
      if (Traits::kAllowIncompleteSequences) {
        state = Traits::DfaDecoder::kAccept;
        static_assert(unibrow::Utf8::kBadChar > unibrow::Latin1::kMaxChar);
        is_one_byte = false;
        utf16_length_++;
        previous = unibrow::Utf8::kBadChar;
        current = 0;
        // If we were trying to continue a multibyte sequence, try this byte
        // again.
        if (previous_state != Traits::DfaDecoder::kAccept) continue;
      } else {
        encoding_ = Encoding::kInvalid;
        return;
      }
    } else if (state == Traits::DfaDecoder::kAccept) {
      if (Traits::IsInvalidSurrogatePair(previous, current)) {
        encoding_ = Encoding::kInvalid;
        return;
      }
      is_one_byte = is_one_byte && current <= unibrow::Latin1::kMaxChar;
      utf16_length_++;
      if (current > unibrow::Utf16::kMaxNonSurrogateCharCode) utf16_length_++;
      previous = current;
      current = 0;
    }
    cursor++;
  }

  if (state == Traits::DfaDecoder::kAccept) {
    encoding_ = is_one_byte ? Encoding::kLatin1 : Encoding::kUtf16;
  } else if (Traits::kAllowIncompleteSequences) {
    static_assert(unibrow::Utf8::kBadChar > unibrow::Latin1::kMaxChar);
    encoding_ = Encoding::kUtf16;
    utf16_length_++;
  } else {
    encoding_ = Encoding::kInvalid;
  }
}

template <class Decoder>
template <typename Char>
void Utf8DecoderBase<Decoder>::Decode(Char* out,
                                      base::Vector<const uint8_t> data) {
  using Traits = DecoderTraits<Decoder>;
  DCHECK(!is_invalid());
  CopyChars(out, data.begin(), non_ascii_start_);

  out += non_ascii_start_;

  auto state = Traits::DfaDecoder::kAccept;
  uint32_t current = 0;
  const uint8_t* cursor = data.begin() + non_ascii_start_;
  const uint8_t* end = data.begin() + data.length();

  while (cursor < end) {
    if (V8_LIKELY(*cursor <= unibrow::Utf8::kMaxOneByteChar &&
                  state == Traits::DfaDecoder::kAccept)) {
      DCHECK_EQ(0u, current);
      *(out++) = static_cast<Char>(*cursor);
      cursor++;
      continue;
    }

    auto previous_state = state;
    Traits::DfaDecoder::Decode(*cursor, &state, &current);
    if (Traits::kAllowIncompleteSequences &&
        state < Traits::DfaDecoder::kAccept) {
      state = Traits::DfaDecoder::kAccept;
      *(out++) = static_cast<Char>(unibrow::Utf8::kBadChar);
      current = 0;
      // If we were trying to continue a multibyte sequence, try this byte
      // again.
      if (previous_state != Traits::DfaDecoder::kAccept) continue;
    } else if (state == Traits::DfaDecoder::kAccept) {
      if (sizeof(Char) == 1 ||
          current <= unibrow::Utf16::kMaxNonSurrogateCharCode) {
        *(out++) = static_cast<Char>(current);
      } else {
        *(out++) = unibrow::Utf16::LeadSurrogate(current);
        *(out++) = unibrow::Utf16::TrailSurrogate(current);
      }
      current = 0;
    }
    cursor++;
  }

  if (Traits::kAllowIncompleteSequences &&
      state != Traits::DfaDecoder::kAccept) {
    *out = static_cast<Char>(unibrow::Utf8::kBadChar);
  } else {
    DCHECK_EQ(state, Traits::DfaDecoder::kAccept);
  }
}

#define DEFINE_UNICODE_DECODER(Decoder)                                 \
  template V8_EXPORT_PRIVATE Utf8DecoderBase<Decoder>::Utf8DecoderBase( \
      base::Vector<const uint8_t> data);                                \
  template V8_EXPORT_PRIVATE void Utf8DecoderBase<Decoder>::Decode(     \
      uint8_t* out, base::Vector<const uint8_t> data);                  \
  template V8_EXPORT_PRIVATE void Utf8DecoderBase<Decoder>::Decode(     \
      uint16_t* out, base::Vector<const uint8_t> data)

DEFINE_UNICODE_DECODER(Utf8Decoder);

#if V8_ENABLE_WEBASSEMBLY
DEFINE_UNICODE_DECODER(Wtf8Decoder);
DEFINE_UNICODE_DECODER(StrictUtf8Decoder);
#endif  // V8_ENABLE_WEBASSEMBLY

#undef DEFINE_UNICODE_DECODER

}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/src/strings/unicode-decoder.h                                                   0000664 0000000 0000000 00000007220 14746647661 0021530 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_STRINGS_UNICODE_DECODER_H_
#define V8_STRINGS_UNICODE_DECODER_H_

#include "src/base/vector.h"
#include "src/strings/unicode.h"

namespace v8 {
namespace internal {

// The return value may point to the first aligned word containing the first
// non-one-byte character, rather than directly to the non-one-byte character.
// If the return value is >= the passed length, the entire string was
// one-byte.
inline int NonAsciiStart(const uint8_t* chars, int length) {
  const uint8_t* start = chars;
  const uint8_t* limit = chars + length;

  if (static_cast<size_t>(length) >= kIntptrSize) {
    // Check unaligned bytes.
    while (!IsAligned(reinterpret_cast<intptr_t>(chars), kIntptrSize)) {
      if (*chars > unibrow::Utf8::kMaxOneByteChar) {
        return static_cast<int>(chars - start);
      }
      ++chars;
    }
    // Check aligned words.
    DCHECK_EQ(unibrow::Utf8::kMaxOneByteChar, 0x7F);
    const uintptr_t non_one_byte_mask = kUintptrAllBitsSet / 0xFF * 0x80;
    while (chars + sizeof(uintptr_t) <= limit) {
      if (*reinterpret_cast<const uintptr_t*>(chars) & non_one_byte_mask) {
        return static_cast<int>(chars - start);
      }
      chars += sizeof(uintptr_t);
    }
  }
  // Check remaining unaligned bytes.
  while (chars < limit) {
    if (*chars > unibrow::Utf8::kMaxOneByteChar) {
      return static_cast<int>(chars - start);
    }
    ++chars;
  }

  return static_cast<int>(chars - start);
}

template <class Decoder>
class Utf8DecoderBase {
 public:
  enum class Encoding : uint8_t { kAscii, kLatin1, kUtf16, kInvalid };

  bool is_invalid() const {
    return static_cast<const Decoder&>(*this).is_invalid();
  }
  bool is_ascii() const { return encoding_ == Encoding::kAscii; }
  bool is_one_byte() const { return encoding_ <= Encoding::kLatin1; }
  int utf16_length() const {
    DCHECK(!is_invalid());
    return utf16_length_;
  }
  int non_ascii_start() const {
    DCHECK(!is_invalid());
    return non_ascii_start_;
  }

  template <typename Char>
  void Decode(Char* out, base::Vector<const uint8_t> data);

 protected:
  explicit Utf8DecoderBase(base::Vector<const uint8_t> data);
  Encoding encoding_;
  int non_ascii_start_;
  int utf16_length_;
};

class V8_EXPORT_PRIVATE Utf8Decoder final
    : public Utf8DecoderBase<Utf8Decoder> {
 public:
  explicit Utf8Decoder(base::Vector<const uint8_t> data)
      : Utf8DecoderBase(data) {}

  // This decoder never fails; an invalid byte sequence decodes to U+FFFD and
  // then the decode continues.
  bool is_invalid() const {
    DCHECK_NE(encoding_, Encoding::kInvalid);
    return false;
  }
};

#if V8_ENABLE_WEBASSEMBLY
// Like Utf8Decoder above, except that instead of replacing invalid sequences
// with U+FFFD, we have a separate Encoding::kInvalid state, and we also accept
// isolated surrogates.
class Wtf8Decoder : public Utf8DecoderBase<Wtf8Decoder> {
 public:
  explicit Wtf8Decoder(base::Vector<const uint8_t> data)
      : Utf8DecoderBase(data) {}

  bool is_invalid() const { return encoding_ == Encoding::kInvalid; }
};

// Like Utf8Decoder above, except that instead of replacing invalid sequences
// with U+FFFD, we have a separate Encoding::kInvalid state.
class StrictUtf8Decoder : public Utf8DecoderBase<StrictUtf8Decoder> {
 public:
  explicit StrictUtf8Decoder(base::Vector<const uint8_t> data)
      : Utf8DecoderBase(data) {}

  bool is_invalid() const { return encoding_ == Encoding::kInvalid; }
};
#endif  // V8_ENABLE_WEBASSEMBLY

}  // namespace internal
}  // namespace v8

#endif  // V8_STRINGS_UNICODE_DECODER_H_
                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/src/strings/unicode-inl.h                                                       0000664 0000000 0000000 00000014555 14746647661 0020716 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2007-2010 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_STRINGS_UNICODE_INL_H_
#define V8_STRINGS_UNICODE_INL_H_

#include "src/base/logging.h"
#include "src/strings/unicode.h"
#include "src/utils/utils.h"

namespace unibrow {

#ifndef V8_INTL_SUPPORT
template <class T, int s>
bool Predicate<T, s>::get(uchar code_point) {
  CacheEntry entry = entries_[code_point & kMask];
  if (entry.code_point() == code_point) return entry.value();
  return CalculateValue(code_point);
}

template <class T, int s>
bool Predicate<T, s>::CalculateValue(uchar code_point) {
  bool result = T::Is(code_point);
  entries_[code_point & kMask] = CacheEntry(code_point, result);
  return result;
}

template <class T, int s>
int Mapping<T, s>::get(uchar c, uchar n, uchar* result) {
  CacheEntry entry = entries_[c & kMask];
  if (entry.code_point_ == c) {
    if (entry.offset_ == 0) {
      return 0;
    } else {
      result[0] = c + entry.offset_;
      return 1;
    }
  } else {
    return CalculateValue(c, n, result);
  }
}

template <class T, int s>
int Mapping<T, s>::CalculateValue(uchar c, uchar n, uchar* result) {
  bool allow_caching = true;
  int length = T::Convert(c, n, result, &allow_caching);
  if (allow_caching) {
    if (length == 1) {
      entries_[c & kMask] = CacheEntry(c, result[0] - c);
      return 1;
    } else {
      entries_[c & kMask] = CacheEntry(c, 0);
      return 0;
    }
  } else {
    return length;
  }
}
#endif  // !V8_INTL_SUPPORT

bool Utf16::HasUnpairedSurrogate(const uint16_t* code_units, size_t length) {
  for (size_t i = 0; i < length; ++i) {
    const int code_unit = code_units[i];
    if (IsLeadSurrogate(code_unit)) {
      // The current code unit is a leading surrogate. Check if it is followed
      // by a trailing surrogate.
      if (i == length - 1) return true;
      if (!IsTrailSurrogate(code_units[i + 1])) return true;
      // Skip the paired trailing surrogate.
      ++i;
    } else if (IsTrailSurrogate(code_unit)) {
      // All paired trailing surrogates are skipped above, so this branch is
      // only for those that are unpaired.
      return true;
    }
  }
  return false;
}

// Decodes UTF-8 bytes incrementally, allowing the decoding of bytes as they
// stream in. This **must** be followed by a call to ValueOfIncrementalFinish
// when the stream is complete, to ensure incomplete sequences are handled.
uchar Utf8::ValueOfIncremental(const uint8_t** cursor, State* state,
                               Utf8IncrementalBuffer* buffer) {
  DCHECK_NOT_NULL(buffer);
  State old_state = *state;
  uint8_t next = **cursor;
  *cursor += 1;

  if (V8_LIKELY(next <= kMaxOneByteChar && old_state == State::kAccept)) {
    DCHECK_EQ(0u, *buffer);
    return static_cast<uchar>(next);
  }

  // So we're at the lead byte of a 2/3/4 sequence, or we're at a continuation
  // char in that sequence.
  Utf8DfaDecoder::Decode(next, state, buffer);

  switch (*state) {
    case State::kAccept: {
      uchar t = *buffer;
      *buffer = 0;
      return t;
    }

    case State::kReject:
      *state = State::kAccept;
      *buffer = 0;

      // If we hit a bad byte, we need to determine if we were trying to start
      // a sequence or continue one. If we were trying to start a sequence,
      // that means it's just an invalid lead byte and we need to continue to
      // the next (which we already did above). If we were already in a
      // sequence, we need to reprocess this same byte after resetting to the
      // initial state.
      if (old_state != State::kAccept) {
        // We were trying to continue a sequence, so let's reprocess this byte
        // next time.
        *cursor -= 1;
      }
      return kBadChar;

    default:
      return kIncomplete;
  }
}

unsigned Utf8::EncodeOneByte(char* str, uint8_t c) {
  static const int kMask = ~(1 << 6);
  if (c <= kMaxOneByteChar) {
    str[0] = c;
    return 1;
  }
  str[0] = 0xC0 | (c >> 6);
  str[1] = 0x80 | (c & kMask);
  return 2;
}

// Encode encodes the UTF-16 code units c and previous into the given str
// buffer, and combines surrogate code units into single code points. If
// replace_invalid is set to true, orphan surrogate code units will be replaced
// with kBadChar.
unsigned Utf8::Encode(char* str, uchar c, int previous, bool replace_invalid) {
  static const int kMask = ~(1 << 6);
  if (c <= kMaxOneByteChar) {
    str[0] = c;
    return 1;
  } else if (c <= kMaxTwoByteChar) {
    str[0] = 0xC0 | (c >> 6);
    str[1] = 0x80 | (c & kMask);
    return 2;
  } else if (c <= kMaxThreeByteChar) {
    DCHECK(!Utf16::IsLeadSurrogate(Utf16::kNoPreviousCharacter));
    if (Utf16::IsSurrogatePair(previous, c)) {
      const int kUnmatchedSize = kSizeOfUnmatchedSurrogate;
      return Encode(str - kUnmatchedSize,
                    Utf16::CombineSurrogatePair(previous, c),
                    Utf16::kNoPreviousCharacter, replace_invalid) -
             kUnmatchedSize;
    } else if (replace_invalid &&
               (Utf16::IsLeadSurrogate(c) || Utf16::IsTrailSurrogate(c))) {
      c = kBadChar;
    }
    str[0] = 0xE0 | (c >> 12);
    str[1] = 0x80 | ((c >> 6) & kMask);
    str[2] = 0x80 | (c & kMask);
    return 3;
  } else {
    str[0] = 0xF0 | (c >> 18);
    str[1] = 0x80 | ((c >> 12) & kMask);
    str[2] = 0x80 | ((c >> 6) & kMask);
    str[3] = 0x80 | (c & kMask);
    return 4;
  }
}

uchar Utf8::ValueOf(const uint8_t* bytes, size_t length, size_t* cursor) {
  if (length <= 0) return kBadChar;
  uint8_t first = bytes[0];
  // Characters between 0000 and 007F are encoded as a single character
  if (V8_LIKELY(first <= kMaxOneByteChar)) {
    *cursor += 1;
    return first;
  }
  return CalculateValue(bytes, length, cursor);
}

unsigned Utf8::Length(uchar c, int previous) {
  if (c <= kMaxOneByteChar) {
    return 1;
  } else if (c <= kMaxTwoByteChar) {
    return 2;
  } else if (c <= kMaxThreeByteChar) {
    DCHECK(!Utf16::IsLeadSurrogate(Utf16::kNoPreviousCharacter));
    if (Utf16::IsSurrogatePair(previous, c)) {
      return kSizeOfUnmatchedSurrogate - kBytesSavedByCombiningSurrogates;
    }
    return 3;
  } else {
    return 4;
  }
}

bool Utf8::IsValidCharacter(uchar c) {
  return c < 0xD800u || (c >= 0xE000u && c < 0xFDD0u) ||
         (c > 0xFDEFu && c <= 0x10FFFFu && (c & 0xFFFEu) != 0xFFFEu &&
          c != kBadChar);
}

}  // namespace unibrow

#endif  // V8_STRINGS_UNICODE_INL_H_
                                                                                                                                                   node-23.7.0/deps/v8/src/strings/unicode.cc                                                          0000664 0000000 0000000 00000504651 14746647661 0020275 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// This file was generated at 2014-10-08 15:25:47.940335

#include "src/strings/unicode.h"

#include <stdio.h>
#include <stdlib.h>

#include <vector>

#include "src/strings/unicode-inl.h"

#if V8_ENABLE_WEBASSEMBLY
#include "src/third_party/utf8-decoder/generalized-utf8-decoder.h"
#endif

#ifdef V8_INTL_SUPPORT
#include "unicode/uchar.h"
#endif

namespace unibrow {

#ifndef V8_INTL_SUPPORT
static const int kStartBit = (1 << 30);
static const int kChunkBits = (1 << 13);
#endif  // !V8_INTL_SUPPORT

static const uchar kSentinel = static_cast<uchar>(-1);

/**
 * \file
 * Implementations of functions for working with Unicode.
 */

using int16_t = signed short;     // NOLINT
using uint16_t = unsigned short;  // NOLINT
using int32_t = int;              // NOLINT

#ifndef V8_INTL_SUPPORT
// All access to the character table should go through this function.
template <int D>
static inline uchar TableGet(const int32_t* table, int index) {
  return table[D * index];
}

static inline uchar GetEntry(int32_t entry) { return entry & (kStartBit - 1); }

static inline bool IsStart(int32_t entry) { return (entry & kStartBit) != 0; }

/**
 * Look up a character in the Unicode table using a mix of binary and
 * interpolation search.  For a uniformly distributed array
 * interpolation search beats binary search by a wide margin.  However,
 * in this case interpolation search degenerates because of some very
 * high values in the lower end of the table so this function uses a
 * combination.  The average number of steps to look up the information
 * about a character is around 10, slightly higher if there is no
 * information available about the character.
 */
static bool LookupPredicate(const int32_t* table, uint16_t size, uchar chr) {
  static const int kEntryDist = 1;
  uint16_t value = chr & (kChunkBits - 1);
  unsigned int low = 0;
  unsigned int high = size - 1;
  while (high != low) {
    unsigned int mid = low + ((high - low) >> 1);
    uchar current_value = GetEntry(TableGet<kEntryDist>(table, mid));
    // If we've found an entry less than or equal to this one, and the
    // next one is not also less than this one, we've arrived.
    if ((current_value <= value) &&
        (mid + 1 == size ||
         GetEntry(TableGet<kEntryDist>(table, mid + 1)) > value)) {
      low = mid;
      break;
    } else if (current_value < value) {
      low = mid + 1;
    } else if (current_value > value) {
      // If we've just checked the bottom-most value and it's not
      // the one we're looking for, we're done.
      if (mid == 0) break;
      high = mid - 1;
    }
  }
  int32_t field = TableGet<kEntryDist>(table, low);
  uchar entry = GetEntry(field);
  bool is_start = IsStart(field);
  return (entry == value) || (entry < value && is_start);
}
#endif  // !V8_INTL_SUPPORT

template <int kW>
struct MultiCharacterSpecialCase {
  static const uchar kEndOfEncoding = kSentinel;
  uchar chars[kW];
};

#ifndef V8_INTL_SUPPORT
// Look up the mapping for the given character in the specified table,
// which is of the specified length and uses the specified special case
// mapping for multi-char mappings.  The next parameter is the character
// following the one to map.  The result will be written in to the result
// buffer and the number of characters written will be returned.  Finally,
// if the allow_caching_ptr is non-null then false will be stored in
// it if the result contains multiple characters or depends on the
// context.
// If ranges are linear, a match between a start and end point is
// offset by the distance between the match and the start. Otherwise
// the result is the same as for the start point on the entire range.
template <bool ranges_are_linear, int kW>
static int LookupMapping(const int32_t* table, uint16_t size,
                         const MultiCharacterSpecialCase<kW>* multi_chars,
                         uchar chr, uchar next, uchar* result,
                         bool* allow_caching_ptr) {
  static const int kEntryDist = 2;
  uint16_t key = chr & (kChunkBits - 1);
  uint16_t chunk_start = chr - key;
  unsigned int low = 0;
  unsigned int high = size - 1;
  while (high != low) {
    unsigned int mid = low + ((high - low) >> 1);
    uchar current_value = GetEntry(TableGet<kEntryDist>(table, mid));
    // If we've found an entry less than or equal to this one, and the next one
    // is not also less than this one, we've arrived.
    if ((current_value <= key) &&
        (mid + 1 == size ||
         GetEntry(TableGet<kEntryDist>(table, mid + 1)) > key)) {
      low = mid;
      break;
    } else if (current_value < key) {
      low = mid + 1;
    } else if (current_value > key) {
      // If we've just checked the bottom-most value and it's not
      // the one we're looking for, we're done.
      if (mid == 0) break;
      high = mid - 1;
    }
  }
  int32_t field = TableGet<kEntryDist>(table, low);
  uchar entry = GetEntry(field);
  bool is_start = IsStart(field);
  bool found = (entry == key) || (entry < key && is_start);
  if (found) {
    int32_t value = table[2 * low + 1];
    if (value == 0) {
      // 0 means not present
      return 0;
    } else if ((value & 3) == 0) {
      // Low bits 0 means a constant offset from the given character.
      if (ranges_are_linear) {
        result[0] = chr + (value >> 2);
      } else {
        result[0] = entry + chunk_start + (value >> 2);
      }
      return 1;
    } else if ((value & 3) == 1) {
      // Low bits 1 means a special case mapping
      if (allow_caching_ptr) *allow_caching_ptr = false;
      const MultiCharacterSpecialCase<kW>& mapping = multi_chars[value >> 2];
      int length = 0;
      for (length = 0; length < kW; length++) {
        uchar mapped = mapping.chars[length];
        if (mapped == MultiCharacterSpecialCase<kW>::kEndOfEncoding) break;
        if (ranges_are_linear) {
          result[length] = mapped + (key - entry);
        } else {
          result[length] = mapped;
        }
      }
      return length;
    } else {
      // Low bits 2 means a really really special case
      if (allow_caching_ptr) *allow_caching_ptr = false;
      // The cases of this switch are defined in unicode.py in the
      // really_special_cases mapping.
      switch (value >> 2) {
        case 1:
          // Really special case 1: upper case sigma.  This letter
          // converts to two different lower case sigmas depending on
          // whether or not it occurs at the end of a word.
          if (next != 0 && Letter::Is(next)) {
            result[0] = 0x03C3;
          } else {
            result[0] = 0x03C2;
          }
          return 1;
        default:
          return 0;
      }
      return -1;
    }
  } else {
    return 0;
  }
}
#endif  // !V8_INTL_SUPPORT

// This method decodes an UTF-8 value according to RFC 3629 and
// https://encoding.spec.whatwg.org/#utf-8-decoder .
uchar Utf8::CalculateValue(const uint8_t* str, size_t max_length,
                           size_t* cursor) {
  DCHECK_GT(max_length, 0);
  DCHECK_GT(str[0], kMaxOneByteChar);

  State state = State::kAccept;
  Utf8IncrementalBuffer buffer = 0;
  uchar t;

  const uint8_t* start = str;
  const uint8_t* end = str + max_length;

  do {
    t = ValueOfIncremental(&str, &state, &buffer);
  } while (str < end && t == kIncomplete);

  *cursor += str - start;
  return (state == State::kAccept) ? t : kBadChar;
}

// Finishes the incremental decoding, ensuring that if an unfinished sequence
// is left that it is replaced by a replacement char.
uchar Utf8::ValueOfIncrementalFinish(State* state) {
  if (*state == State::kAccept) {
    return kBufferEmpty;
  } else {
    DCHECK_GT(*state, State::kAccept);
    *state = State::kAccept;
    return kBadChar;
  }
}

bool Utf8::ValidateEncoding(const uint8_t* bytes, size_t length) {
  State state = State::kAccept;
  Utf8IncrementalBuffer throw_away = 0;
  for (size_t i = 0; i < length && state != State::kReject; i++) {
    Utf8DfaDecoder::Decode(bytes[i], &state, &throw_away);
  }
  return state == State::kAccept;
}

// static
void Utf16::ReplaceUnpairedSurrogates(const uint16_t* source_code_units,
                                      uint16_t* dest_code_units,
                                      size_t length) {
  // U+FFFD (REPLACEMENT CHARACTER)
  constexpr uint16_t kReplacement = 0xFFFD;

  for (size_t i = 0; i < length; i++) {
    const uint16_t source_code_unit = source_code_units[i];
    const size_t copy_index = i;
    uint16_t dest_code_unit = source_code_unit;
    if (IsLeadSurrogate(source_code_unit)) {
      // The current code unit is a leading surrogate. If it's not followed by a
      // trailing surrogate, replace it with the replacement character.
      if (i == length - 1 || !IsTrailSurrogate(source_code_units[i + 1])) {
        dest_code_unit = kReplacement;
      } else {
        // Copy the paired trailing surrogate. The paired leading surrogate will
        // be copied below.
        ++i;
        dest_code_units[i] = source_code_units[i];
      }
    } else if (IsTrailSurrogate(source_code_unit)) {
      // All paired trailing surrogates are skipped above, so this branch is
      // only for those that are unpaired.
      dest_code_unit = kReplacement;
    }
    dest_code_units[copy_index] = dest_code_unit;
  }
}

#if V8_ENABLE_WEBASSEMBLY
bool Wtf8::ValidateEncoding(const uint8_t* bytes, size_t length) {
  using State = GeneralizedUtf8DfaDecoder::State;
  auto state = State::kAccept;
  uint32_t current = 0;
  uint32_t previous = 0;
  for (size_t i = 0; i < length; i++) {
    GeneralizedUtf8DfaDecoder::Decode(bytes[i], &state, &current);
    if (state == State::kReject) return false;
    if (state == State::kAccept) {
      if (Utf16::IsTrailSurrogate(current) &&
          Utf16::IsLeadSurrogate(previous)) {
        return false;
      }
      previous = current;
      current = 0;
    }
  }
  return state == State::kAccept;
}

// Precondition: valid WTF-8.
void Wtf8::ScanForSurrogates(v8::base::Vector<const uint8_t> wtf8,
                             std::vector<size_t>* surrogate_offsets) {
  // A surrogate codepoint is encoded in a three-byte sequence:
  //
  //   0xED [0xA0,0xBF] [0x80,0xBF]
  //
  // If the first byte is 0xED, you already have a 50% chance of the value being
  // a surrogate; you just have to check the second byte.  (There are
  // three-byte non-surrogates starting with 0xED whose second byte is in
  // [0x80,0x9F].)  Could speed this up with SWAR; most likely case is that no
  // byte in the array is 0xED.
  const uint8_t kWtf8SurrogateFirstByte = 0xED;
  const uint8_t kWtf8SurrogateSecondByteHighBit = 0x20;

  for (size_t i = 0; i < wtf8.size(); i++) {
    if (wtf8[i] == kWtf8SurrogateFirstByte &&
        (wtf8[i + 1] & kWtf8SurrogateSecondByteHighBit)) {
      // Record the byte offset of the encoded surrogate.
      surrogate_offsets->push_back(i);
    }
  }
}
#endif  // V8_ENABLE_WEBASSEMBLY

// Uppercase:            point.category == 'Lu'
// TODO(jshin): Check if it's ok to exclude Other_Uppercase characters.
#ifdef V8_INTL_SUPPORT
bool Uppercase::Is(uchar c) { return static_cast<bool>(u_isupper(c)); }
#else
static const uint16_t kUppercaseTable0Size = 455;
static const int32_t kUppercaseTable0[455] = {
    1073741889, 90,         1073742016, 214,        1073742040, 222,
    256,        258,        260,        262,        264,        266,
    268,        270,        272,        274,        276,        278,
    280,        282,        284,        286,        288,        290,
    292,        294,        296,        298,        300,        302,
    304,        306,        308,        310,        313,        315,
    317,        319,        321,        323,        325,        327,
    330,        332,        334,        336,        338,        340,
    342,        344,        346,        348,        350,        352,
    354,        356,        358,        360,        362,        364,
    366,        368,        370,        372,        374,        1073742200,
    377,        379,        381,        1073742209, 386,        388,
    1073742214, 391,        1073742217, 395,        1073742222, 401,
    1073742227, 404,        1073742230, 408,        1073742236, 413,
    1073742239, 416,        418,        420,        1073742246, 423,
    425,        428,        1073742254, 431,        1073742257, 435,
    437,        1073742263, 440,        444,        452,        455,
    458,        461,        463,        465,        467,        469,
    471,        473,        475,        478,        480,        482,
    484,        486,        488,        490,        492,        494,
    497,        500,        1073742326, 504,        506,        508,
    510,        512,        514,        516,        518,        520,
    522,        524,        526,        528,        530,        532,
    534,        536,        538,        540,        542,        544,
    546,        548,        550,        552,        554,        556,
    558,        560,        562,        1073742394, 571,        1073742397,
    574,        577,        1073742403, 582,        584,        586,
    588,        590,        880,        882,        886,        895,
    902,        1073742728, 906,        908,        1073742734, 911,
    1073742737, 929,        1073742755, 939,        975,        1073742802,
    980,        984,        986,        988,        990,        992,
    994,        996,        998,        1000,       1002,       1004,
    1006,       1012,       1015,       1073742841, 1018,       1073742845,
    1071,       1120,       1122,       1124,       1126,       1128,
    1130,       1132,       1134,       1136,       1138,       1140,
    1142,       1144,       1146,       1148,       1150,       1152,
    1162,       1164,       1166,       1168,       1170,       1172,
    1174,       1176,       1178,       1180,       1182,       1184,
    1186,       1188,       1190,       1192,       1194,       1196,
    1198,       1200,       1202,       1204,       1206,       1208,
    1210,       1212,       1214,       1073743040, 1217,       1219,
    1221,       1223,       1225,       1227,       1229,       1232,
    1234,       1236,       1238,       1240,       1242,       1244,
    1246,       1248,       1250,       1252,       1254,       1256,
    1258,       1260,       1262,       1264,       1266,       1268,
    1270,       1272,       1274,       1276,       1278,       1280,
    1282,       1284,       1286,       1288,       1290,       1292,
    1294,       1296,       1298,       1300,       1302,       1304,
    1306,       1308,       1310,       1312,       1314,       1316,
    1318,       1320,       1322,       1324,       1326,       1073743153,
    1366,       1073746080, 4293,       4295,       4301,       7680,
    7682,       7684,       7686,       7688,       7690,       7692,
    7694,       7696,       7698,       7700,       7702,       7704,
    7706,       7708,       7710,       7712,       7714,       7716,
    7718,       7720,       7722,       7724,       7726,       7728,
    7730,       7732,       7734,       7736,       7738,       7740,
    7742,       7744,       7746,       7748,       7750,       7752,
    7754,       7756,       7758,       7760,       7762,       7764,
    7766,       7768,       7770,       7772,       7774,       7776,
    7778,       7780,       7782,       7784,       7786,       7788,
    7790,       7792,       7794,       7796,       7798,       7800,
    7802,       7804,       7806,       7808,       7810,       7812,
    7814,       7816,       7818,       7820,       7822,       7824,
    7826,       7828,       7838,       7840,       7842,       7844,
    7846,       7848,       7850,       7852,       7854,       7856,
    7858,       7860,       7862,       7864,       7866,       7868,
    7870,       7872,       7874,       7876,       7878,       7880,
    7882,       7884,       7886,       7888,       7890,       7892,
    7894,       7896,       7898,       7900,       7902,       7904,
    7906,       7908,       7910,       7912,       7914,       7916,
    7918,       7920,       7922,       7924,       7926,       7928,
    7930,       7932,       7934,       1073749768, 7951,       1073749784,
    7965,       1073749800, 7983,       1073749816, 7999,       1073749832,
    8013,       8025,       8027,       8029,       8031,       1073749864,
    8047,       1073749944, 8123,       1073749960, 8139,       1073749976,
    8155,       1073749992, 8172,       1073750008, 8187};
static const uint16_t kUppercaseTable1Size = 86;
static const int32_t kUppercaseTable1[86] = {
    258,        263,  1073742091, 269,  1073742096, 274,        277,
    1073742105, 285,  292,        294,  296,        1073742122, 301,
    1073742128, 307,  1073742142, 319,  325,        387,        1073744896,
    3118,       3168, 1073744994, 3172, 3175,       3177,       3179,
    1073745005, 3184, 3186,       3189, 1073745022, 3200,       3202,
    3204,       3206, 3208,       3210, 3212,       3214,       3216,
    3218,       3220, 3222,       3224, 3226,       3228,       3230,
    3232,       3234, 3236,       3238, 3240,       3242,       3244,
    3246,       3248, 3250,       3252, 3254,       3256,       3258,
    3260,       3262, 3264,       3266, 3268,       3270,       3272,
    3274,       3276, 3278,       3280, 3282,       3284,       3286,
    3288,       3290, 3292,       3294, 3296,       3298,       3307,
    3309,       3314};
static const uint16_t kUppercaseTable5Size = 101;
static const int32_t kUppercaseTable5[101] = {
    1600, 1602, 1604, 1606, 1608, 1610, 1612, 1614,       1616, 1618,
    1620, 1622, 1624, 1626, 1628, 1630, 1632, 1634,       1636, 1638,
    1640, 1642, 1644, 1664, 1666, 1668, 1670, 1672,       1674, 1676,
    1678, 1680, 1682, 1684, 1686, 1688, 1690, 1826,       1828, 1830,
    1832, 1834, 1836, 1838, 1842, 1844, 1846, 1848,       1850, 1852,
    1854, 1856, 1858, 1860, 1862, 1864, 1866, 1868,       1870, 1872,
    1874, 1876, 1878, 1880, 1882, 1884, 1886, 1888,       1890, 1892,
    1894, 1896, 1898, 1900, 1902, 1913, 1915, 1073743741, 1918, 1920,
    1922, 1924, 1926, 1931, 1933, 1936, 1938, 1942,       1944, 1946,
    1948, 1950, 1952, 1954, 1956, 1958, 1960, 1073743786, 1965, 1073743792,
    1969};
static const uint16_t kUppercaseTable7Size = 2;
static const int32_t kUppercaseTable7[2] = {1073749793, 7994};
bool Uppercase::Is(uchar c) {
  int chunk_index = c >> 13;
  switch (chunk_index) {
    case 0:
      return LookupPredicate(kUppercaseTable0, kUppercaseTable0Size, c);
    case 1:
      return LookupPredicate(kUppercaseTable1, kUppercaseTable1Size, c);
    case 5:
      return LookupPredicate(kUppercaseTable5, kUppercaseTable5Size, c);
    case 7:
      return LookupPredicate(kUppercaseTable7, kUppercaseTable7Size, c);
    default:
      return false;
  }
}
#endif  // V8_INTL_SUPPORT

// Letter:               point.category in ['Lu', 'Ll', 'Lt', 'Lm', 'Lo', 'Nl']
#ifdef V8_INTL_SUPPORT
bool Letter::Is(uchar c) { return static_cast<bool>(u_isalpha(c)); }
#else
static const uint16_t kLetterTable0Size = 431;
static const int32_t kLetterTable0[431] = {
    1073741889, 90,         1073741921, 122,        170,        181,
    186,        1073742016, 214,        1073742040, 246,        1073742072,
    705,        1073742534, 721,        1073742560, 740,        748,
    750,        1073742704, 884,        1073742710, 887,        1073742714,
    893,        895,        902,        1073742728, 906,        908,
    1073742734, 929,        1073742755, 1013,       1073742839, 1153,
    1073742986, 1327,       1073743153, 1366,       1369,       1073743201,
    1415,       1073743312, 1514,       1073743344, 1522,       1073743392,
    1610,       1073743470, 1647,       1073743473, 1747,       1749,
    1073743589, 1766,       1073743598, 1775,       1073743610, 1788,
    1791,       1808,       1073743634, 1839,       1073743693, 1957,
    1969,       1073743818, 2026,       1073743860, 2037,       2042,
    1073743872, 2069,       2074,       2084,       2088,       1073743936,
    2136,       1073744032, 2226,       1073744132, 2361,       2365,
    2384,       1073744216, 2401,       1073744241, 2432,       1073744261,
    2444,       1073744271, 2448,       1073744275, 2472,       1073744298,
    2480,       2482,       1073744310, 2489,       2493,       2510,
    1073744348, 2525,       1073744351, 2529,       1073744368, 2545,
    1073744389, 2570,       1073744399, 2576,       1073744403, 2600,
    1073744426, 2608,       1073744434, 2611,       1073744437, 2614,
    1073744440, 2617,       1073744473, 2652,       2654,       1073744498,
    2676,       1073744517, 2701,       1073744527, 2705,       1073744531,
    2728,       1073744554, 2736,       1073744562, 2739,       1073744565,
    2745,       2749,       2768,       1073744608, 2785,       1073744645,
    2828,       1073744655, 2832,       1073744659, 2856,       1073744682,
    2864,       1073744690, 2867,       1073744693, 2873,       2877,
    1073744732, 2909,       1073744735, 2913,       2929,       2947,
    1073744773, 2954,       1073744782, 2960,       1073744786, 2965,
    1073744793, 2970,       2972,       1073744798, 2975,       1073744803,
    2980,       1073744808, 2986,       1073744814, 3001,       3024,
    1073744901, 3084,       1073744910, 3088,       1073744914, 3112,
    1073744938, 3129,       3133,       1073744984, 3161,       1073744992,
    3169,       1073745029, 3212,       1073745038, 3216,       1073745042,
    3240,       1073745066, 3251,       1073745077, 3257,       3261,
    3294,       1073745120, 3297,       1073745137, 3314,       1073745157,
    3340,       1073745166, 3344,       1073745170, 3386,       3389,
    3406,       1073745248, 3425,       1073745274, 3455,       1073745285,
    3478,       1073745306, 3505,       1073745331, 3515,       3517,
    1073745344, 3526,       1073745409, 3632,       1073745458, 3635,
    1073745472, 3654,       1073745537, 3714,       3716,       1073745543,
    3720,       3722,       3725,       1073745556, 3735,       1073745561,
    3743,       1073745569, 3747,       3749,       3751,       1073745578,
    3755,       1073745581, 3760,       1073745586, 3763,       3773,
    1073745600, 3780,       3782,       1073745628, 3807,       3840,
    1073745728, 3911,       1073745737, 3948,       1073745800, 3980,
    1073745920, 4138,       4159,       1073746000, 4181,       1073746010,
    4189,       4193,       1073746021, 4198,       1073746030, 4208,
    1073746037, 4225,       4238,       1073746080, 4293,       4295,
    4301,       1073746128, 4346,       1073746172, 4680,       1073746506,
    4685,       1073746512, 4694,       4696,       1073746522, 4701,
    1073746528, 4744,       1073746570, 4749,       1073746576, 4784,
    1073746610, 4789,       1073746616, 4798,       4800,       1073746626,
    4805,       1073746632, 4822,       1073746648, 4880,       1073746706,
    4885,       1073746712, 4954,       1073746816, 5007,       1073746848,
    5108,       1073746945, 5740,       1073747567, 5759,       1073747585,
    5786,       1073747616, 5866,       1073747694, 5880,       1073747712,
    5900,       1073747726, 5905,       1073747744, 5937,       1073747776,
    5969,       1073747808, 5996,       1073747822, 6000,       1073747840,
    6067,       6103,       6108,       1073748000, 6263,       1073748096,
    6312,       6314,       1073748144, 6389,       1073748224, 6430,
    1073748304, 6509,       1073748336, 6516,       1073748352, 6571,
    1073748417, 6599,       1073748480, 6678,       1073748512, 6740,
    6823,       1073748741, 6963,       1073748805, 6987,       1073748867,
    7072,       1073748910, 7087,       1073748922, 7141,       1073748992,
    7203,       1073749069, 7247,       1073749082, 7293,       1073749225,
    7404,       1073749230, 7409,       1073749237, 7414,       1073749248,
    7615,       1073749504, 7957,       1073749784, 7965,       1073749792,
    8005,       1073749832, 8013,       1073749840, 8023,       8025,
    8027,       8029,       1073749855, 8061,       1073749888, 8116,
    1073749942, 8124,       8126,       1073749954, 8132,       1073749958,
    8140,       1073749968, 8147,       1073749974, 8155,       1073749984,
    8172,       1073750002, 8180,       1073750006, 8188};
static const uint16_t kLetterTable1Size = 87;
static const int32_t kLetterTable1[87] = {
    113,        127,        1073741968, 156,        258,        263,
    1073742090, 275,        277,        1073742105, 285,        292,
    294,        296,        1073742122, 301,        1073742127, 313,
    1073742140, 319,        1073742149, 329,        334,        1073742176,
    392,        1073744896, 3118,       1073744944, 3166,       1073744992,
    3300,       1073745131, 3310,       1073745138, 3315,       1073745152,
    3365,       3367,       3373,       1073745200, 3431,       3439,
    1073745280, 3478,       1073745312, 3494,       1073745320, 3502,
    1073745328, 3510,       1073745336, 3518,       1073745344, 3526,
    1073745352, 3534,       1073745360, 3542,       1073745368, 3550,
    3631,       1073745925, 4103,       1073745953, 4137,       1073745969,
    4149,       1073745976, 4156,       1073745985, 4246,       1073746077,
    4255,       1073746081, 4346,       1073746172, 4351,       1073746181,
    4397,       1073746225, 4494,       1073746336, 4538,       1073746416,
    4607,       1073746944, 8191};
static const uint16_t kLetterTable2Size = 4;
static const int32_t kLetterTable2[4] = {1073741824, 3509, 1073745408, 8191};
static const uint16_t kLetterTable3Size = 2;
static const int32_t kLetterTable3[2] = {1073741824, 8191};
static const uint16_t kLetterTable4Size = 2;
static const int32_t kLetterTable4[2] = {1073741824, 8140};
static const uint16_t kLetterTable5Size = 100;
static const int32_t kLetterTable5[100] = {
    1073741824, 1164,       1073743056, 1277,       1073743104, 1548,
    1073743376, 1567,       1073743402, 1579,       1073743424, 1646,
    1073743487, 1693,       1073743520, 1775,       1073743639, 1823,
    1073743650, 1928,       1073743755, 1934,       1073743760, 1965,
    1073743792, 1969,       1073743863, 2049,       1073743875, 2053,
    1073743879, 2058,       1073743884, 2082,       1073743936, 2163,
    1073744002, 2227,       1073744114, 2295,       2299,       1073744138,
    2341,       1073744176, 2374,       1073744224, 2428,       1073744260,
    2482,       2511,       1073744352, 2532,       1073744358, 2543,
    1073744378, 2558,       1073744384, 2600,       1073744448, 2626,
    1073744452, 2635,       1073744480, 2678,       2682,       1073744510,
    2735,       2737,       1073744565, 2742,       1073744569, 2749,
    2752,       2754,       1073744603, 2781,       1073744608, 2794,
    1073744626, 2804,       1073744641, 2822,       1073744649, 2830,
    1073744657, 2838,       1073744672, 2854,       1073744680, 2862,
    1073744688, 2906,       1073744732, 2911,       1073744740, 2917,
    1073744832, 3042,       1073744896, 8191};
static const uint16_t kLetterTable6Size = 6;
static const int32_t kLetterTable6[6] = {1073741824, 6051,       1073747888,
                                         6086,       1073747915, 6139};
static const uint16_t kLetterTable7Size = 48;
static const int32_t kLetterTable7[48] = {
    1073748224, 6765,       1073748592, 6873,       1073748736, 6918,
    1073748755, 6935,       6941,       1073748767, 6952,       1073748778,
    6966,       1073748792, 6972,       6974,       1073748800, 6977,
    1073748803, 6980,       1073748806, 7089,       1073748947, 7485,
    1073749328, 7567,       1073749394, 7623,       1073749488, 7675,
    1073749616, 7796,       1073749622, 7932,       1073749793, 7994,
    1073749825, 8026,       1073749862, 8126,       1073749954, 8135,
    1073749962, 8143,       1073749970, 8151,       1073749978, 8156};
bool Letter::Is(uchar c) {
  int chunk_index = c >> 13;
  switch (chunk_index) {
    case 0:
      return LookupPredicate(kLetterTable0, kLetterTable0Size, c);
    case 1:
      return LookupPredicate(kLetterTable1, kLetterTable1Size, c);
    case 2:
      return LookupPredicate(kLetterTable2, kLetterTable2Size, c);
    case 3:
      return LookupPredicate(kLetterTable3, kLetterTable3Size, c);
    case 4:
      return LookupPredicate(kLetterTable4, kLetterTable4Size, c);
    case 5:
      return LookupPredicate(kLetterTable5, kLetterTable5Size, c);
    case 6:
      return LookupPredicate(kLetterTable6, kLetterTable6Size, c);
    case 7:
      return LookupPredicate(kLetterTable7, kLetterTable7Size, c);
    default:
      return false;
  }
}
#endif

#ifndef V8_INTL_SUPPORT
// ID_Start:             ((point.category in ['Lu', 'Ll', 'Lt', 'Lm', 'Lo',
// 'Nl'] or 'Other_ID_Start' in point.properties) and ('Pattern_Syntax' not in
// point.properties) and ('Pattern_White_Space' not in point.properties)) or
// ('JS_ID_Start' in point.properties)

static const uint16_t kID_StartTable0Size = 434;
static const int32_t kID_StartTable0[434] = {
    36,         1073741889, 90,         92,         95,         1073741921,
    122,        170,        181,        186,        1073742016, 214,
    1073742040, 246,        1073742072, 705,        1073742534, 721,
    1073742560, 740,        748,        750,        1073742704, 884,
    1073742710, 887,        1073742714, 893,        895,        902,
    1073742728, 906,        908,        1073742734, 929,        1073742755,
    1013,       1073742839, 1153,       1073742986, 1327,       1073743153,
    1366,       1369,       1073743201, 1415,       1073743312, 1514,
    1073743344, 1522,       1073743392, 1610,       1073743470, 1647,
    1073743473, 1747,       1749,       1073743589, 1766,       1073743598,
    1775,       1073743610, 1788,       1791,       1808,       1073743634,
    1839,       1073743693, 1957,       1969,       1073743818, 2026,
    1073743860, 2037,       2042,       1073743872, 2069,       2074,
    2084,       2088,       1073743936, 2136,       1073744032, 2226,
    1073744132, 2361,       2365,       2384,       1073744216, 2401,
    1073744241, 2432,       1073744261, 2444,       1073744271, 2448,
    1073744275, 2472,       1073744298, 2480,       2482,       1073744310,
    2489,       2493,       2510,       1073744348, 2525,       1073744351,
    2529,       1073744368, 2545,       1073744389, 2570,       1073744399,
    2576,       1073744403, 2600,       1073744426, 2608,       1073744434,
    2611,       1073744437, 2614,       1073744440, 2617,       1073744473,
    2652,       2654,       1073744498, 2676,       1073744517, 2701,
    1073744527, 2705,       1073744531, 2728,       1073744554, 2736,
    1073744562, 2739,       1073744565, 2745,       2749,       2768,
    1073744608, 2785,       1073744645, 2828,       1073744655, 2832,
    1073744659, 2856,       1073744682, 2864,       1073744690, 2867,
    1073744693, 2873,       2877,       1073744732, 2909,       1073744735,
    2913,       2929,       2947,       1073744773, 2954,       1073744782,
    2960,       1073744786, 2965,       1073744793, 2970,       2972,
    1073744798, 2975,       1073744803, 2980,       1073744808, 2986,
    1073744814, 3001,       3024,       1073744901, 3084,       1073744910,
    3088,       1073744914, 3112,       1073744938, 3129,       3133,
    1073744984, 3161,       1073744992, 3169,       1073745029, 3212,
    1073745038, 3216,       1073745042, 3240,       1073745066, 3251,
    1073745077, 3257,       3261,       3294,       1073745120, 3297,
    1073745137, 3314,       1073745157, 3340,       1073745166, 3344,
    1073745170, 3386,       3389,       3406,       1073745248, 3425,
    1073745274, 3455,       1073745285, 3478,       1073745306, 3505,
    1073745331, 3515,       3517,       1073745344, 3526,       1073745409,
    3632,       1073745458, 3635,       1073745472, 3654,       1073745537,
    3714,       3716,       1073745543, 3720,       3722,       3725,
    1073745556, 3735,       1073745561, 3743,       1073745569, 3747,
    3749,       3751,       1073745578, 3755,       1073745581, 3760,
    1073745586, 3763,       3773,       1073745600, 3780,       3782,
    1073745628, 3807,       3840,       1073745728, 3911,       1073745737,
    3948,       1073745800, 3980,       1073745920, 4138,       4159,
    1073746000, 4181,       1073746010, 4189,       4193,       1073746021,
    4198,       1073746030, 4208,       1073746037, 4225,       4238,
    1073746080, 4293,       4295,       4301,       1073746128, 4346,
    1073746172, 4680,       1073746506, 4685,       1073746512, 4694,
    4696,       1073746522, 4701,       1073746528, 4744,       1073746570,
    4749,       1073746576, 4784,       1073746610, 4789,       1073746616,
    4798,       4800,       1073746626, 4805,       1073746632, 4822,
    1073746648, 4880,       1073746706, 4885,       1073746712, 4954,
    1073746816, 5007,       1073746848, 5108,       1073746945, 5740,
    1073747567, 5759,       1073747585, 5786,       1073747616, 5866,
    1073747694, 5880,       1073747712, 5900,       1073747726, 5905,
    1073747744, 5937,       1073747776, 5969,       1073747808, 5996,
    1073747822, 6000,       1073747840, 6067,       6103,       6108,
    1073748000, 6263,       1073748096, 6312,       6314,       1073748144,
    6389,       1073748224, 6430,       1073748304, 6509,       1073748336,
    6516,       1073748352, 6571,       1073748417, 6599,       1073748480,
    6678,       1073748512, 6740,       6823,       1073748741, 6963,
    1073748805, 6987,       1073748867, 7072,       1073748910, 7087,
    1073748922, 7141,       1073748992, 7203,       1073749069, 7247,
    1073749082, 7293,       1073749225, 7404,       1073749230, 7409,
    1073749237, 7414,       1073749248, 7615,       1073749504, 7957,
    1073749784, 7965,       1073749792, 8005,       1073749832, 8013,
    1073749840, 8023,       8025,       8027,       8029,       1073749855,
    8061,       1073749888, 8116,       1073749942, 8124,       8126,
    1073749954, 8132,       1073749958, 8140,       1073749968, 8147,
    1073749974, 8155,       1073749984, 8172,       1073750002, 8180,
    1073750006, 8188};
static const uint16_t kID_StartTable1Size = 84;
static const int32_t kID_StartTable1[84] = {
    113,        127,        1073741968, 156,        258,        263,
    1073742090, 275,        277,        1073742104, 285,        292,
    294,        296,        1073742122, 313,        1073742140, 319,
    1073742149, 329,        334,        1073742176, 392,        1073744896,
    3118,       1073744944, 3166,       1073744992, 3300,       1073745131,
    3310,       1073745138, 3315,       1073745152, 3365,       3367,
    3373,       1073745200, 3431,       3439,       1073745280, 3478,
    1073745312, 3494,       1073745320, 3502,       1073745328, 3510,
    1073745336, 3518,       1073745344, 3526,       1073745352, 3534,
    1073745360, 3542,       1073745368, 3550,       1073745925, 4103,
    1073745953, 4137,       1073745969, 4149,       1073745976, 4156,
    1073745985, 4246,       1073746075, 4255,       1073746081, 4346,
    1073746172, 4351,       1073746181, 4397,       1073746225, 4494,
    1073746336, 4538,       1073746416, 4607,       1073746944, 8191};
static const uint16_t kID_StartTable2Size = 4;
static const int32_t kID_StartTable2[4] = {1073741824, 3509, 1073745408, 8191};
static const uint16_t kID_StartTable3Size = 2;
static const int32_t kID_StartTable3[2] = {1073741824, 8191};
static const uint16_t kID_StartTable4Size = 2;
static const int32_t kID_StartTable4[2] = {1073741824, 8140};
static const uint16_t kID_StartTable5Size = 100;
static const int32_t kID_StartTable5[100] = {
    1073741824, 1164,       1073743056, 1277,       1073743104, 1548,
    1073743376, 1567,       1073743402, 1579,       1073743424, 1646,
    1073743487, 1693,       1073743520, 1775,       1073743639, 1823,
    1073743650, 1928,       1073743755, 1934,       1073743760, 1965,
    1073743792, 1969,       1073743863, 2049,       1073743875, 2053,
    1073743879, 2058,       1073743884, 2082,       1073743936, 2163,
    1073744002, 2227,       1073744114, 2295,       2299,       1073744138,
    2341,       1073744176, 2374,       1073744224, 2428,       1073744260,
    2482,       2511,       1073744352, 2532,       1073744358, 2543,
    1073744378, 2558,       1073744384, 2600,       1073744448, 2626,
    1073744452, 2635,       1073744480, 2678,       2682,       1073744510,
    2735,       2737,       1073744565, 2742,       1073744569, 2749,
    2752,       2754,       1073744603, 2781,       1073744608, 2794,
    1073744626, 2804,       1073744641, 2822,       1073744649, 2830,
    1073744657, 2838,       1073744672, 2854,       1073744680, 2862,
    1073744688, 2906,       1073744732, 2911,       1073744740, 2917,
    1073744832, 3042,       1073744896, 8191};
static const uint16_t kID_StartTable6Size = 6;
static const int32_t kID_StartTable6[6] = {1073741824, 6051,       1073747888,
                                           6086,       1073747915, 6139};
static const uint16_t kID_StartTable7Size = 48;
static const int32_t kID_StartTable7[48] = {
    1073748224, 6765,       1073748592, 6873,       1073748736, 6918,
    1073748755, 6935,       6941,       1073748767, 6952,       1073748778,
    6966,       1073748792, 6972,       6974,       1073748800, 6977,
    1073748803, 6980,       1073748806, 7089,       1073748947, 7485,
    1073749328, 7567,       1073749394, 7623,       1073749488, 7675,
    1073749616, 7796,       1073749622, 7932,       1073749793, 7994,
    1073749825, 8026,       1073749862, 8126,       1073749954, 8135,
    1073749962, 8143,       1073749970, 8151,       1073749978, 8156};
bool ID_Start::Is(uchar c) {
  int chunk_index = c >> 13;
  switch (chunk_index) {
    case 0:
      return LookupPredicate(kID_StartTable0, kID_StartTable0Size, c);
    case 1:
      return LookupPredicate(kID_StartTable1, kID_StartTable1Size, c);
    case 2:
      return LookupPredicate(kID_StartTable2, kID_StartTable2Size, c);
    case 3:
      return LookupPredicate(kID_StartTable3, kID_StartTable3Size, c);
    case 4:
      return LookupPredicate(kID_StartTable4, kID_StartTable4Size, c);
    case 5:
      return LookupPredicate(kID_StartTable5, kID_StartTable5Size, c);
    case 6:
      return LookupPredicate(kID_StartTable6, kID_StartTable6Size, c);
    case 7:
      return LookupPredicate(kID_StartTable7, kID_StartTable7Size, c);
    default:
      return false;
  }
}

// ID_Continue:          point.category in ['Nd', 'Mn', 'Mc', 'Pc'] or
// 'Other_ID_Continue' in point.properties or 'JS_ID_Continue' in
// point.properties

static const uint16_t kID_ContinueTable0Size = 315;
static const int32_t kID_ContinueTable0[315] = {
    1073741872, 57,         95,         183,        1073742592, 879,
    903,        1073742979, 1159,       1073743249, 1469,       1471,
    1073743297, 1474,       1073743300, 1477,       1479,       1073743376,
    1562,       1073743435, 1641,       1648,       1073743574, 1756,
    1073743583, 1764,       1073743591, 1768,       1073743594, 1773,
    1073743600, 1785,       1809,       1073743664, 1866,       1073743782,
    1968,       1073743808, 1993,       1073743851, 2035,       1073743894,
    2073,       1073743899, 2083,       1073743909, 2087,       1073743913,
    2093,       1073743961, 2139,       1073744100, 2307,       1073744186,
    2364,       1073744190, 2383,       1073744209, 2391,       1073744226,
    2403,       1073744230, 2415,       1073744257, 2435,       2492,
    1073744318, 2500,       1073744327, 2504,       1073744331, 2509,
    2519,       1073744354, 2531,       1073744358, 2543,       1073744385,
    2563,       2620,       1073744446, 2626,       1073744455, 2632,
    1073744459, 2637,       2641,       1073744486, 2673,       2677,
    1073744513, 2691,       2748,       1073744574, 2757,       1073744583,
    2761,       1073744587, 2765,       1073744610, 2787,       1073744614,
    2799,       1073744641, 2819,       2876,       1073744702, 2884,
    1073744711, 2888,       1073744715, 2893,       1073744726, 2903,
    1073744738, 2915,       1073744742, 2927,       2946,       1073744830,
    3010,       1073744838, 3016,       1073744842, 3021,       3031,
    1073744870, 3055,       1073744896, 3075,       1073744958, 3140,
    1073744966, 3144,       1073744970, 3149,       1073744981, 3158,
    1073744994, 3171,       1073744998, 3183,       1073745025, 3203,
    3260,       1073745086, 3268,       1073745094, 3272,       1073745098,
    3277,       1073745109, 3286,       1073745122, 3299,       1073745126,
    3311,       1073745153, 3331,       1073745214, 3396,       1073745222,
    3400,       1073745226, 3405,       3415,       1073745250, 3427,
    1073745254, 3439,       1073745282, 3459,       3530,       1073745359,
    3540,       3542,       1073745368, 3551,       1073745382, 3567,
    1073745394, 3571,       3633,       1073745460, 3642,       1073745479,
    3662,       1073745488, 3673,       3761,       1073745588, 3769,
    1073745595, 3772,       1073745608, 3789,       1073745616, 3801,
    1073745688, 3865,       1073745696, 3881,       3893,       3895,
    3897,       1073745726, 3903,       1073745777, 3972,       1073745798,
    3975,       1073745805, 3991,       1073745817, 4028,       4038,
    1073745963, 4158,       1073745984, 4169,       1073746006, 4185,
    1073746014, 4192,       1073746018, 4196,       1073746023, 4205,
    1073746033, 4212,       1073746050, 4237,       1073746063, 4253,
    1073746781, 4959,       1073746793, 4977,       1073747730, 5908,
    1073747762, 5940,       1073747794, 5971,       1073747826, 6003,
    1073747892, 6099,       6109,       1073747936, 6121,       1073747979,
    6157,       1073747984, 6169,       6313,       1073748256, 6443,
    1073748272, 6459,       1073748294, 6479,       1073748400, 6592,
    1073748424, 6601,       1073748432, 6618,       1073748503, 6683,
    1073748565, 6750,       1073748576, 6780,       1073748607, 6793,
    1073748624, 6809,       1073748656, 6845,       1073748736, 6916,
    1073748788, 6980,       1073748816, 7001,       1073748843, 7027,
    1073748864, 7042,       1073748897, 7085,       1073748912, 7097,
    1073748966, 7155,       1073749028, 7223,       1073749056, 7241,
    1073749072, 7257,       1073749200, 7378,       1073749204, 7400,
    7405,       1073749234, 7412,       1073749240, 7417,       1073749440,
    7669,       1073749500, 7679};
static const uint16_t kID_ContinueTable1Size = 19;
static const int32_t kID_ContinueTable1[19] = {
    1073741836, 13,   1073741887, 64,         84,
    1073742032, 220,  225,        1073742053, 240,
    1073745135, 3313, 3455,       1073745376, 3583,
    1073745962, 4143, 1073746073, 4250};
static const uint16_t kID_ContinueTable5Size = 63;
static const int32_t kID_ContinueTable5[63] = {
    1073743392, 1577,       1647,       1073743476, 1661,       1695,
    1073743600, 1777,       2050,       2054,       2059,       1073743907,
    2087,       1073744000, 2177,       1073744052, 2244,       1073744080,
    2265,       1073744096, 2289,       1073744128, 2313,       1073744166,
    2349,       1073744199, 2387,       1073744256, 2435,       1073744307,
    2496,       1073744336, 2521,       2533,       1073744368, 2553,
    1073744425, 2614,       2627,       1073744460, 2637,       1073744464,
    2649,       1073744507, 2685,       2736,       1073744562, 2740,
    1073744567, 2744,       1073744574, 2751,       2753,       1073744619,
    2799,       1073744629, 2806,       1073744867, 3050,       1073744876,
    3053,       1073744880, 3065};
static const uint16_t kID_ContinueTable7Size = 12;
static const int32_t kID_ContinueTable7[12] = {
    6942, 1073749504, 7695, 1073749536, 7725, 1073749555,
    7732, 1073749581, 7759, 1073749776, 7961, 7999};
bool ID_Continue::Is(uchar c) {
  int chunk_index = c >> 13;
  switch (chunk_index) {
    case 0:
      return LookupPredicate(kID_ContinueTable0, kID_ContinueTable0Size, c);
    case 1:
      return LookupPredicate(kID_ContinueTable1, kID_ContinueTable1Size, c);
    case 5:
      return LookupPredicate(kID_ContinueTable5, kID_ContinueTable5Size, c);
    case 7:
      return LookupPredicate(kID_ContinueTable7, kID_ContinueTable7Size, c);
    default:
      return false;
  }
}

// WhiteSpace:           (point.category == 'Zs') or ('JS_White_Space' in
// point.properties)

static const uint16_t kWhiteSpaceTable0Size = 6;
static const int32_t kWhiteSpaceTable0[6] = {9, 1073741835, 12, 32, 160, 5760};
static const uint16_t kWhiteSpaceTable1Size = 5;
static const int32_t kWhiteSpaceTable1[5] = {1073741824, 10, 47, 95, 4096};
static const uint16_t kWhiteSpaceTable7Size = 1;
static const int32_t kWhiteSpaceTable7[1] = {7935};
bool WhiteSpace::Is(uchar c) {
  int chunk_index = c >> 13;
  switch (chunk_index) {
    case 0:
      return LookupPredicate(kWhiteSpaceTable0, kWhiteSpaceTable0Size, c);
    case 1:
      return LookupPredicate(kWhiteSpaceTable1, kWhiteSpaceTable1Size, c);
    case 7:
      return LookupPredicate(kWhiteSpaceTable7, kWhiteSpaceTable7Size, c);
    default:
      return false;
  }
}
#endif  // !V8_INTL_SUPPORT

#ifndef V8_INTL_SUPPORT
static const MultiCharacterSpecialCase<2> kToLowercaseMultiStrings0[2] = {
    {{105, 775}}, {{kSentinel}}};
static const uint16_t kToLowercaseTable0Size = 488;
static const int32_t kToLowercaseTable0[976] = {
    1073741889, 128,   90,         128,   1073742016, 128,   214,        128,
    1073742040, 128,   222,        128,   256,        4,     258,        4,
    260,        4,     262,        4,     264,        4,     266,        4,
    268,        4,     270,        4,     272,        4,     274,        4,
    276,        4,     278,        4,     280,        4,     282,        4,
    284,        4,     286,        4,     288,        4,     290,        4,
    292,        4,     294,        4,     296,        4,     298,        4,
    300,        4,     302,        4,     304,        1,     306,        4,
    308,        4,     310,        4,     313,        4,     315,        4,
    317,        4,     319,        4,     321,        4,     323,        4,
    325,        4,     327,        4,     330,        4,     332,        4,
    334,        4,     336,        4,     338,        4,     340,        4,
    342,        4,     344,        4,     346,        4,     348,        4,
    350,        4,     352,        4,     354,        4,     356,        4,
    358,        4,     360,        4,     362,        4,     364,        4,
    366,        4,     368,        4,     370,        4,     372,        4,
    374,        4,     376,        -484,  377,        4,     379,        4,
    381,        4,     385,        840,   386,        4,     388,        4,
    390,        824,   391,        4,     1073742217, 820,   394,        820,
    395,        4,     398,        316,   399,        808,   400,        812,
    401,        4,     403,        820,   404,        828,   406,        844,
    407,        836,   408,        4,     412,        844,   413,        852,
    415,        856,   416,        4,     418,        4,     420,        4,
    422,        872,   423,        4,     425,        872,   428,        4,
    430,        872,   431,        4,     1073742257, 868,   434,        868,
    435,        4,     437,        4,     439,        876,   440,        4,
    444,        4,     452,        8,     453,        4,     455,        8,
    456,        4,     458,        8,     459,        4,     461,        4,
    463,        4,     465,        4,     467,        4,     469,        4,
    471,        4,     473,        4,     475,        4,     478,        4,
    480,        4,     482,        4,     484,        4,     486,        4,
    488,        4,     490,        4,     492,        4,     494,        4,
    497,        8,     498,        4,     500,        4,     502,        -388,
    503,        -224,  504,        4,     506,        4,     508,        4,
    510,        4,     512,        4,     514,        4,     516,        4,
    518,        4,     520,        4,     522,        4,     524,        4,
    526,        4,     528,        4,     530,        4,     532,        4,
    534,        4,     536,        4,     538,        4,     540,        4,
    542,        4,     544,        -520,  546,        4,     548,        4,
    550,        4,     552,        4,     554,        4,     556,        4,
    558,        4,     560,        4,     562,        4,     570,        43180,
    571,        4,     573,        -652,  574,        43168, 577,        4,
    579,        -780,  580,        276,   581,        284,   582,        4,
    584,        4,     586,        4,     588,        4,     590,        4,
    880,        4,     882,        4,     886,        4,     895,        464,
    902,        152,   1073742728, 148,   906,        148,   908,        256,
    1073742734, 252,   911,        252,   1073742737, 128,   929,        128,
    931,        6,     1073742756, 128,   939,        128,   975,        32,
    984,        4,     986,        4,     988,        4,     990,        4,
    992,        4,     994,        4,     996,        4,     998,        4,
    1000,       4,     1002,       4,     1004,       4,     1006,       4,
    1012,       -240,  1015,       4,     1017,       -28,   1018,       4,
    1073742845, -520,  1023,       -520,  1073742848, 320,   1039,       320,
    1073742864, 128,   1071,       128,   1120,       4,     1122,       4,
    1124,       4,     1126,       4,     1128,       4,     1130,       4,
    1132,       4,     1134,       4,     1136,       4,     1138,       4,
    1140,       4,     1142,       4,     1144,       4,     1146,       4,
    1148,       4,     1150,       4,     1152,       4,     1162,       4,
    1164,       4,     1166,       4,     1168,       4,     1170,       4,
    1172,       4,     1174,       4,     1176,       4,     1178,       4,
    1180,       4,     1182,       4,     1184,       4,     1186,       4,
    1188,       4,     1190,       4,     1192,       4,     1194,       4,
    1196,       4,     1198,       4,     1200,       4,     1202,       4,
    1204,       4,     1206,       4,     1208,       4,     1210,       4,
    1212,       4,     1214,       4,     1216,       60,    1217,       4,
    1219,       4,     1221,       4,     1223,       4,     1225,       4,
    1227,       4,     1229,       4,     1232,       4,     1234,       4,
    1236,       4,     1238,       4,     1240,       4,     1242,       4,
    1244,       4,     1246,       4,     1248,       4,     1250,       4,
    1252,       4,     1254,       4,     1256,       4,     1258,       4,
    1260,       4,     1262,       4,     1264,       4,     1266,       4,
    1268,       4,     1270,       4,     1272,       4,     1274,       4,
    1276,       4,     1278,       4,     1280,       4,     1282,       4,
    1284,       4,     1286,       4,     1288,       4,     1290,       4,
    1292,       4,     1294,       4,     1296,       4,     1298,       4,
    1300,       4,     1302,       4,     1304,       4,     1306,       4,
    1308,       4,     1310,       4,     1312,       4,     1314,       4,
    1316,       4,     1318,       4,     1320,       4,     1322,       4,
    1324,       4,     1326,       4,     1073743153, 192,   1366,       192,
    1073746080, 29056, 4293,       29056, 4295,       29056, 4301,       29056,
    7680,       4,     7682,       4,     7684,       4,     7686,       4,
    7688,       4,     7690,       4,     7692,       4,     7694,       4,
    7696,       4,     7698,       4,     7700,       4,     7702,       4,
    7704,       4,     7706,       4,     7708,       4,     7710,       4,
    7712,       4,     7714,       4,     7716,       4,     7718,       4,
    7720,       4,     7722,       4,     7724,       4,     7726,       4,
    7728,       4,     7730,       4,     7732,       4,     7734,       4,
    7736,       4,     7738,       4,     7740,       4,     7742,       4,
    7744,       4,     7746,       4,     7748,       4,     7750,       4,
    7752,       4,     7754,       4,     7756,       4,     7758,       4,
    7760,       4,     7762,       4,     7764,       4,     7766,       4,
    7768,       4,     7770,       4,     7772,       4,     7774,       4,
    7776,       4,     7778,       4,     7780,       4,     7782,       4,
    7784,       4,     7786,       4,     7788,       4,     7790,       4,
    7792,       4,     7794,       4,     7796,       4,     7798,       4,
    7800,       4,     7802,       4,     7804,       4,     7806,       4,
    7808,       4,     7810,       4,     7812,       4,     7814,       4,
    7816,       4,     7818,       4,     7820,       4,     7822,       4,
    7824,       4,     7826,       4,     7828,       4,     7838,       -30460,
    7840,       4,     7842,       4,     7844,       4,     7846,       4,
    7848,       4,     7850,       4,     7852,       4,     7854,       4,
    7856,       4,     7858,       4,     7860,       4,     7862,       4,
    7864,       4,     7866,       4,     7868,       4,     7870,       4,
    7872,       4,     7874,       4,     7876,       4,     7878,       4,
    7880,       4,     7882,       4,     7884,       4,     7886,       4,
    7888,       4,     7890,       4,     7892,       4,     7894,       4,
    7896,       4,     7898,       4,     7900,       4,     7902,       4,
    7904,       4,     7906,       4,     7908,       4,     7910,       4,
    7912,       4,     7914,       4,     7916,       4,     7918,       4,
    7920,       4,     7922,       4,     7924,       4,     7926,       4,
    7928,       4,     7930,       4,     7932,       4,     7934,       4,
    1073749768, -32,   7951,       -32,   1073749784, -32,   7965,       -32,
    1073749800, -32,   7983,       -32,   1073749816, -32,   7999,       -32,
    1073749832, -32,   8013,       -32,   8025,       -32,   8027,       -32,
    8029,       -32,   8031,       -32,   1073749864, -32,   8047,       -32,
    1073749896, -32,   8079,       -32,   1073749912, -32,   8095,       -32,
    1073749928, -32,   8111,       -32,   1073749944, -32,   8121,       -32,
    1073749946, -296,  8123,       -296,  8124,       -36,   1073749960, -344,
    8139,       -344,  8140,       -36,   1073749976, -32,   8153,       -32,
    1073749978, -400,  8155,       -400,  1073749992, -32,   8169,       -32,
    1073749994, -448,  8171,       -448,  8172,       -28,   1073750008, -512,
    8185,       -512,  1073750010, -504,  8187,       -504,  8188,       -36};
static const uint16_t kToLowercaseMultiStrings0Size = 2;
static const MultiCharacterSpecialCase<1> kToLowercaseMultiStrings1[1] = {
    {{kSentinel}}};
static const uint16_t kToLowercaseTable1Size = 79;
static const int32_t kToLowercaseTable1[158] = {
    294,        -30068, 298,        -33532, 299,  -33048, 306,        112,
    1073742176, 64,     367,        64,     387,  4,      1073743030, 104,
    1231,       104,    1073744896, 192,    3118, 192,    3168,       4,
    3170,       -42972, 3171,       -15256, 3172, -42908, 3175,       4,
    3177,       4,      3179,       4,      3181, -43120, 3182,       -42996,
    3183,       -43132, 3184,       -43128, 3186, 4,      3189,       4,
    1073745022, -43260, 3199,       -43260, 3200, 4,      3202,       4,
    3204,       4,      3206,       4,      3208, 4,      3210,       4,
    3212,       4,      3214,       4,      3216, 4,      3218,       4,
    3220,       4,      3222,       4,      3224, 4,      3226,       4,
    3228,       4,      3230,       4,      3232, 4,      3234,       4,
    3236,       4,      3238,       4,      3240, 4,      3242,       4,
    3244,       4,      3246,       4,      3248, 4,      3250,       4,
    3252,       4,      3254,       4,      3256, 4,      3258,       4,
    3260,       4,      3262,       4,      3264, 4,      3266,       4,
    3268,       4,      3270,       4,      3272, 4,      3274,       4,
    3276,       4,      3278,       4,      3280, 4,      3282,       4,
    3284,       4,      3286,       4,      3288, 4,      3290,       4,
    3292,       4,      3294,       4,      3296, 4,      3298,       4,
    3307,       4,      3309,       4,      3314, 4};
static const uint16_t kToLowercaseMultiStrings1Size = 1;
static const MultiCharacterSpecialCase<1> kToLowercaseMultiStrings5[1] = {
    {{kSentinel}}};
static const uint16_t kToLowercaseTable5Size = 103;
static const int32_t kToLowercaseTable5[206] = {
    1600, 4,       1602, 4,       1604, 4,       1606, 4,       1608, 4,
    1610, 4,       1612, 4,       1614, 4,       1616, 4,       1618, 4,
    1620, 4,       1622, 4,       1624, 4,       1626, 4,       1628, 4,
    1630, 4,       1632, 4,       1634, 4,       1636, 4,       1638, 4,
    1640, 4,       1642, 4,       1644, 4,       1664, 4,       1666, 4,
    1668, 4,       1670, 4,       1672, 4,       1674, 4,       1676, 4,
    1678, 4,       1680, 4,       1682, 4,       1684, 4,       1686, 4,
    1688, 4,       1690, 4,       1826, 4,       1828, 4,       1830, 4,
    1832, 4,       1834, 4,       1836, 4,       1838, 4,       1842, 4,
    1844, 4,       1846, 4,       1848, 4,       1850, 4,       1852, 4,
    1854, 4,       1856, 4,       1858, 4,       1860, 4,       1862, 4,
    1864, 4,       1866, 4,       1868, 4,       1870, 4,       1872, 4,
    1874, 4,       1876, 4,       1878, 4,       1880, 4,       1882, 4,
    1884, 4,       1886, 4,       1888, 4,       1890, 4,       1892, 4,
    1894, 4,       1896, 4,       1898, 4,       1900, 4,       1902, 4,
    1913, 4,       1915, 4,       1917, -141328, 1918, 4,       1920, 4,
    1922, 4,       1924, 4,       1926, 4,       1931, 4,       1933, -169120,
    1936, 4,       1938, 4,       1942, 4,       1944, 4,       1946, 4,
    1948, 4,       1950, 4,       1952, 4,       1954, 4,       1956, 4,
    1958, 4,       1960, 4,       1962, -169232, 1963, -169276, 1964, -169260,
    1965, -169220, 1968, -169032, 1969, -169128};
static const uint16_t kToLowercaseMultiStrings5Size = 1;
static const MultiCharacterSpecialCase<1> kToLowercaseMultiStrings7[1] = {
    {{kSentinel}}};
static const uint16_t kToLowercaseTable7Size = 2;
static const int32_t kToLowercaseTable7[4] = {1073749793, 128, 7994, 128};
static const uint16_t kToLowercaseMultiStrings7Size = 1;
int ToLowercase::Convert(uchar c, uchar n, uchar* result,
                         bool* allow_caching_ptr) {
  int chunk_index = c >> 13;
  switch (chunk_index) {
    case 0:
      return LookupMapping<true>(kToLowercaseTable0, kToLowercaseTable0Size,
                                 kToLowercaseMultiStrings0, c, n, result,
                                 allow_caching_ptr);
    case 1:
      return LookupMapping<true>(kToLowercaseTable1, kToLowercaseTable1Size,
                                 kToLowercaseMultiStrings1, c, n, result,
                                 allow_caching_ptr);
    case 5:
      return LookupMapping<true>(kToLowercaseTable5, kToLowercaseTable5Size,
                                 kToLowercaseMultiStrings5, c, n, result,
                                 allow_caching_ptr);
    case 7:
      return LookupMapping<true>(kToLowercaseTable7, kToLowercaseTable7Size,
                                 kToLowercaseMultiStrings7, c, n, result,
                                 allow_caching_ptr);
    default:
      return 0;
  }
}

static const MultiCharacterSpecialCase<3> kToUppercaseMultiStrings0[62] = {
    {{83, 83, kSentinel}},    {{700, 78, kSentinel}},
    {{74, 780, kSentinel}},   {{921, 776, 769}},
    {{933, 776, 769}},        {{1333, 1362, kSentinel}},
    {{72, 817, kSentinel}},   {{84, 776, kSentinel}},
    {{87, 778, kSentinel}},   {{89, 778, kSentinel}},
    {{65, 702, kSentinel}},   {{933, 787, kSentinel}},
    {{933, 787, 768}},        {{933, 787, 769}},
    {{933, 787, 834}},        {{7944, 921, kSentinel}},
    {{7945, 921, kSentinel}}, {{7946, 921, kSentinel}},
    {{7947, 921, kSentinel}}, {{7948, 921, kSentinel}},
    {{7949, 921, kSentinel}}, {{7950, 921, kSentinel}},
    {{7951, 921, kSentinel}}, {{7976, 921, kSentinel}},
    {{7977, 921, kSentinel}}, {{7978, 921, kSentinel}},
    {{7979, 921, kSentinel}}, {{7980, 921, kSentinel}},
    {{7981, 921, kSentinel}}, {{7982, 921, kSentinel}},
    {{7983, 921, kSentinel}}, {{8040, 921, kSentinel}},
    {{8041, 921, kSentinel}}, {{8042, 921, kSentinel}},
    {{8043, 921, kSentinel}}, {{8044, 921, kSentinel}},
    {{8045, 921, kSentinel}}, {{8046, 921, kSentinel}},
    {{8047, 921, kSentinel}}, {{8122, 921, kSentinel}},
    {{913, 921, kSentinel}},  {{902, 921, kSentinel}},
    {{913, 834, kSentinel}},  {{913, 834, 921}},
    {{8138, 921, kSentinel}}, {{919, 921, kSentinel}},
    {{905, 921, kSentinel}},  {{919, 834, kSentinel}},
    {{919, 834, 921}},        {{921, 776, 768}},
    {{921, 834, kSentinel}},  {{921, 776, 834}},
    {{933, 776, 768}},        {{929, 787, kSentinel}},
    {{933, 834, kSentinel}},  {{933, 776, 834}},
    {{8186, 921, kSentinel}}, {{937, 921, kSentinel}},
    {{911, 921, kSentinel}},  {{937, 834, kSentinel}},
    {{937, 834, 921}},        {{kSentinel}}};
static const uint16_t kToUppercaseTable0Size = 590;
static const int32_t kToUppercaseTable0[1180] = {
    1073741921, -128,   122,        -128,   181,        2972,
    223,        1,      1073742048, -128,   246,        -128,
    1073742072, -128,   254,        -128,   255,        484,
    257,        -4,     259,        -4,     261,        -4,
    263,        -4,     265,        -4,     267,        -4,
    269,        -4,     271,        -4,     273,        -4,
    275,        -4,     277,        -4,     279,        -4,
    281,        -4,     283,        -4,     285,        -4,
    287,        -4,     289,        -4,     291,        -4,
    293,        -4,     295,        -4,     297,        -4,
    299,        -4,     301,        -4,     303,        -4,
    305,        -928,   307,        -4,     309,        -4,
    311,        -4,     314,        -4,     316,        -4,
    318,        -4,     320,        -4,     322,        -4,
    324,        -4,     326,        -4,     328,        -4,
    329,        5,      331,        -4,     333,        -4,
    335,        -4,     337,        -4,     339,        -4,
    341,        -4,     343,        -4,     345,        -4,
    347,        -4,     349,        -4,     351,        -4,
    353,        -4,     355,        -4,     357,        -4,
    359,        -4,     361,        -4,     363,        -4,
    365,        -4,     367,        -4,     369,        -4,
    371,        -4,     373,        -4,     375,        -4,
    378,        -4,     380,        -4,     382,        -4,
    383,        -1200,  384,        780,    387,        -4,
    389,        -4,     392,        -4,     396,        -4,
    402,        -4,     405,        388,    409,        -4,
    410,        652,    414,        520,    417,        -4,
    419,        -4,     421,        -4,     424,        -4,
    429,        -4,     432,        -4,     436,        -4,
    438,        -4,     441,        -4,     445,        -4,
    447,        224,    453,        -4,     454,        -8,
    456,        -4,     457,        -8,     459,        -4,
    460,        -8,     462,        -4,     464,        -4,
    466,        -4,     468,        -4,     470,        -4,
    472,        -4,     474,        -4,     476,        -4,
    477,        -316,   479,        -4,     481,        -4,
    483,        -4,     485,        -4,     487,        -4,
    489,        -4,     491,        -4,     493,        -4,
    495,        -4,     496,        9,      498,        -4,
    499,        -8,     501,        -4,     505,        -4,
    507,        -4,     509,        -4,     511,        -4,
    513,        -4,     515,        -4,     517,        -4,
    519,        -4,     521,        -4,     523,        -4,
    525,        -4,     527,        -4,     529,        -4,
    531,        -4,     533,        -4,     535,        -4,
    537,        -4,     539,        -4,     541,        -4,
    543,        -4,     547,        -4,     549,        -4,
    551,        -4,     553,        -4,     555,        -4,
    557,        -4,     559,        -4,     561,        -4,
    563,        -4,     572,        -4,     1073742399, 43260,
    576,        43260,  578,        -4,     583,        -4,
    585,        -4,     587,        -4,     589,        -4,
    591,        -4,     592,        43132,  593,        43120,
    594,        43128,  595,        -840,   596,        -824,
    1073742422, -820,   599,        -820,   601,        -808,
    603,        -812,   604,        169276, 608,        -820,
    609,        169260, 611,        -828,   613,        169120,
    614,        169232, 616,        -836,   617,        -844,
    619,        42972,  620,        169220, 623,        -844,
    625,        42996,  626,        -852,   629,        -856,
    637,        42908,  640,        -872,   643,        -872,
    647,        169128, 648,        -872,   649,        -276,
    1073742474, -868,   651,        -868,   652,        -284,
    658,        -876,   670,        169032, 837,        336,
    881,        -4,     883,        -4,     887,        -4,
    1073742715, 520,    893,        520,    912,        13,
    940,        -152,   1073742765, -148,   943,        -148,
    944,        17,     1073742769, -128,   961,        -128,
    962,        -124,   1073742787, -128,   971,        -128,
    972,        -256,   1073742797, -252,   974,        -252,
    976,        -248,   977,        -228,   981,        -188,
    982,        -216,   983,        -32,    985,        -4,
    987,        -4,     989,        -4,     991,        -4,
    993,        -4,     995,        -4,     997,        -4,
    999,        -4,     1001,       -4,     1003,       -4,
    1005,       -4,     1007,       -4,     1008,       -344,
    1009,       -320,   1010,       28,     1011,       -464,
    1013,       -384,   1016,       -4,     1019,       -4,
    1073742896, -128,   1103,       -128,   1073742928, -320,
    1119,       -320,   1121,       -4,     1123,       -4,
    1125,       -4,     1127,       -4,     1129,       -4,
    1131,       -4,     1133,       -4,     1135,       -4,
    1137,       -4,     1139,       -4,     1141,       -4,
    1143,       -4,     1145,       -4,     1147,       -4,
    1149,       -4,     1151,       -4,     1153,       -4,
    1163,       -4,     1165,       -4,     1167,       -4,
    1169,       -4,     1171,       -4,     1173,       -4,
    1175,       -4,     1177,       -4,     1179,       -4,
    1181,       -4,     1183,       -4,     1185,       -4,
    1187,       -4,     1189,       -4,     1191,       -4,
    1193,       -4,     1195,       -4,     1197,       -4,
    1199,       -4,     1201,       -4,     1203,       -4,
    1205,       -4,     1207,       -4,     1209,       -4,
    1211,       -4,     1213,       -4,     1215,       -4,
    1218,       -4,     1220,       -4,     1222,       -4,
    1224,       -4,     1226,       -4,     1228,       -4,
    1230,       -4,     1231,       -60,    1233,       -4,
    1235,       -4,     1237,       -4,     1239,       -4,
    1241,       -4,     1243,       -4,     1245,       -4,
    1247,       -4,     1249,       -4,     1251,       -4,
    1253,       -4,     1255,       -4,     1257,       -4,
    1259,       -4,     1261,       -4,     1263,       -4,
    1265,       -4,     1267,       -4,     1269,       -4,
    1271,       -4,     1273,       -4,     1275,       -4,
    1277,       -4,     1279,       -4,     1281,       -4,
    1283,       -4,     1285,       -4,     1287,       -4,
    1289,       -4,     1291,       -4,     1293,       -4,
    1295,       -4,     1297,       -4,     1299,       -4,
    1301,       -4,     1303,       -4,     1305,       -4,
    1307,       -4,     1309,       -4,     1311,       -4,
    1313,       -4,     1315,       -4,     1317,       -4,
    1319,       -4,     1321,       -4,     1323,       -4,
    1325,       -4,     1327,       -4,     1073743201, -192,
    1414,       -192,   1415,       21,     7545,       141328,
    7549,       15256,  7681,       -4,     7683,       -4,
    7685,       -4,     7687,       -4,     7689,       -4,
    7691,       -4,     7693,       -4,     7695,       -4,
    7697,       -4,     7699,       -4,     7701,       -4,
    7703,       -4,     7705,       -4,     7707,       -4,
    7709,       -4,     7711,       -4,     7713,       -4,
    7715,       -4,     7717,       -4,     7719,       -4,
    7721,       -4,     7723,       -4,     7725,       -4,
    7727,       -4,     7729,       -4,     7731,       -4,
    7733,       -4,     7735,       -4,     7737,       -4,
    7739,       -4,     7741,       -4,     7743,       -4,
    7745,       -4,     7747,       -4,     7749,       -4,
    7751,       -4,     7753,       -4,     7755,       -4,
    7757,       -4,     7759,       -4,     7761,       -4,
    7763,       -4,     7765,       -4,     7767,       -4,
    7769,       -4,     7771,       -4,     7773,       -4,
    7775,       -4,     7777,       -4,     7779,       -4,
    7781,       -4,     7783,       -4,     7785,       -4,
    7787,       -4,     7789,       -4,     7791,       -4,
    7793,       -4,     7795,       -4,     7797,       -4,
    7799,       -4,     7801,       -4,     7803,       -4,
    7805,       -4,     7807,       -4,     7809,       -4,
    7811,       -4,     7813,       -4,     7815,       -4,
    7817,       -4,     7819,       -4,     7821,       -4,
    7823,       -4,     7825,       -4,     7827,       -4,
    7829,       -4,     7830,       25,     7831,       29,
    7832,       33,     7833,       37,     7834,       41,
    7835,       -236,   7841,       -4,     7843,       -4,
    7845,       -4,     7847,       -4,     7849,       -4,
    7851,       -4,     7853,       -4,     7855,       -4,
    7857,       -4,     7859,       -4,     7861,       -4,
    7863,       -4,     7865,       -4,     7867,       -4,
    7869,       -4,     7871,       -4,     7873,       -4,
    7875,       -4,     7877,       -4,     7879,       -4,
    7881,       -4,     7883,       -4,     7885,       -4,
    7887,       -4,     7889,       -4,     7891,       -4,
    7893,       -4,     7895,       -4,     7897,       -4,
    7899,       -4,     7901,       -4,     7903,       -4,
    7905,       -4,     7907,       -4,     7909,       -4,
    7911,       -4,     7913,       -4,     7915,       -4,
    7917,       -4,     7919,       -4,     7921,       -4,
    7923,       -4,     7925,       -4,     7927,       -4,
    7929,       -4,     7931,       -4,     7933,       -4,
    7935,       -4,     1073749760, 32,     7943,       32,
    1073749776, 32,     7957,       32,     1073749792, 32,
    7975,       32,     1073749808, 32,     7991,       32,
    1073749824, 32,     8005,       32,     8016,       45,
    8017,       32,     8018,       49,     8019,       32,
    8020,       53,     8021,       32,     8022,       57,
    8023,       32,     1073749856, 32,     8039,       32,
    1073749872, 296,    8049,       296,    1073749874, 344,
    8053,       344,    1073749878, 400,    8055,       400,
    1073749880, 512,    8057,       512,    1073749882, 448,
    8059,       448,    1073749884, 504,    8061,       504,
    8064,       61,     8065,       65,     8066,       69,
    8067,       73,     8068,       77,     8069,       81,
    8070,       85,     8071,       89,     8072,       61,
    8073,       65,     8074,       69,     8075,       73,
    8076,       77,     8077,       81,     8078,       85,
    8079,       89,     8080,       93,     8081,       97,
    8082,       101,    8083,       105,    8084,       109,
    8085,       113,    8086,       117,    8087,       121,
    8088,       93,     8089,       97,     8090,       101,
    8091,       105,    8092,       109,    8093,       113,
    8094,       117,    8095,       121,    8096,       125,
    8097,       129,    8098,       133,    8099,       137,
    8100,       141,    8101,       145,    8102,       149,
    8103,       153,    8104,       125,    8105,       129,
    8106,       133,    8107,       137,    8108,       141,
    8109,       145,    8110,       149,    8111,       153,
    1073749936, 32,     8113,       32,     8114,       157,
    8115,       161,    8116,       165,    8118,       169,
    8119,       173,    8124,       161,    8126,       -28820,
    8130,       177,    8131,       181,    8132,       185,
    8134,       189,    8135,       193,    8140,       181,
    1073749968, 32,     8145,       32,     8146,       197,
    8147,       13,     8150,       201,    8151,       205,
    1073749984, 32,     8161,       32,     8162,       209,
    8163,       17,     8164,       213,    8165,       28,
    8166,       217,    8167,       221,    8178,       225,
    8179,       229,    8180,       233,    8182,       237,
    8183,       241,    8188,       229};
static const uint16_t kToUppercaseMultiStrings0Size = 62;
static const MultiCharacterSpecialCase<1> kToUppercaseMultiStrings1[1] = {
    {{kSentinel}}};
static const uint16_t kToUppercaseTable1Size = 73;
static const int32_t kToUppercaseTable1[146] = {
    334,  -112,   1073742192, -64,    383,  -64,   388,  -4, 1073743056, -104,
    1257, -104,   1073744944, -192,   3166, -192,  3169, -4, 3173,       -43180,
    3174, -43168, 3176,       -4,     3178, -4,    3180, -4, 3187,       -4,
    3190, -4,     3201,       -4,     3203, -4,    3205, -4, 3207,       -4,
    3209, -4,     3211,       -4,     3213, -4,    3215, -4, 3217,       -4,
    3219, -4,     3221,       -4,     3223, -4,    3225, -4, 3227,       -4,
    3229, -4,     3231,       -4,     3233, -4,    3235, -4, 3237,       -4,
    3239, -4,     3241,       -4,     3243, -4,    3245, -4, 3247,       -4,
    3249, -4,     3251,       -4,     3253, -4,    3255, -4, 3257,       -4,
    3259, -4,     3261,       -4,     3263, -4,    3265, -4, 3267,       -4,
    3269, -4,     3271,       -4,     3273, -4,    3275, -4, 3277,       -4,
    3279, -4,     3281,       -4,     3283, -4,    3285, -4, 3287,       -4,
    3289, -4,     3291,       -4,     3293, -4,    3295, -4, 3297,       -4,
    3299, -4,     3308,       -4,     3310, -4,    3315, -4, 1073745152, -29056,
    3365, -29056, 3367,       -29056, 3373, -29056};
static const uint16_t kToUppercaseMultiStrings1Size = 1;
static const MultiCharacterSpecialCase<1> kToUppercaseMultiStrings5[1] = {
    {{kSentinel}}};
static const uint16_t kToUppercaseTable5Size = 95;
static const int32_t kToUppercaseTable5[190] = {
    1601, -4, 1603, -4, 1605, -4, 1607, -4, 1609, -4, 1611, -4, 1613, -4,
    1615, -4, 1617, -4, 1619, -4, 1621, -4, 1623, -4, 1625, -4, 1627, -4,
    1629, -4, 1631, -4, 1633, -4, 1635, -4, 1637, -4, 1639, -4, 1641, -4,
    1643, -4, 1645, -4, 1665, -4, 1667, -4, 1669, -4, 1671, -4, 1673, -4,
    1675, -4, 1677, -4, 1679, -4, 1681, -4, 1683, -4, 1685, -4, 1687, -4,
    1689, -4, 1691, -4, 1827, -4, 1829, -4, 1831, -4, 1833, -4, 1835, -4,
    1837, -4, 1839, -4, 1843, -4, 1845, -4, 1847, -4, 1849, -4, 1851, -4,
    1853, -4, 1855, -4, 1857, -4, 1859, -4, 1861, -4, 1863, -4, 1865, -4,
    1867, -4, 1869, -4, 1871, -4, 1873, -4, 1875, -4, 1877, -4, 1879, -4,
    1881, -4, 1883, -4, 1885, -4, 1887, -4, 1889, -4, 1891, -4, 1893, -4,
    1895, -4, 1897, -4, 1899, -4, 1901, -4, 1903, -4, 1914, -4, 1916, -4,
    1919, -4, 1921, -4, 1923, -4, 1925, -4, 1927, -4, 1932, -4, 1937, -4,
    1939, -4, 1943, -4, 1945, -4, 1947, -4, 1949, -4, 1951, -4, 1953, -4,
    1955, -4, 1957, -4, 1959, -4, 1961, -4};
static const uint16_t kToUppercaseMultiStrings5Size = 1;
static const MultiCharacterSpecialCase<3> kToUppercaseMultiStrings7[12] = {
    {{70, 70, kSentinel}},
    {{70, 73, kSentinel}},
    {{70, 76, kSentinel}},
    {{70, 70, 73}},
    {{70, 70, 76}},
    {{83, 84, kSentinel}},
    {{1348, 1350, kSentinel}},
    {{1348, 1333, kSentinel}},
    {{1348, 1339, kSentinel}},
    {{1358, 1350, kSentinel}},
    {{1348, 1341, kSentinel}},
    {{kSentinel}}};
static const uint16_t kToUppercaseTable7Size = 14;
static const int32_t kToUppercaseTable7[28] = {
    6912, 1,  6913, 5,  6914,       9,    6915, 13,  6916, 17,
    6917, 21, 6918, 21, 6931,       25,   6932, 29,  6933, 33,
    6934, 37, 6935, 41, 1073749825, -128, 8026, -128};
static const uint16_t kToUppercaseMultiStrings7Size = 12;
int ToUppercase::Convert(uchar c, uchar n, uchar* result,
                         bool* allow_caching_ptr) {
  int chunk_index = c >> 13;
  switch (chunk_index) {
    case 0:
      return LookupMapping<true>(kToUppercaseTable0, kToUppercaseTable0Size,
                                 kToUppercaseMultiStrings0, c, n, result,
                                 allow_caching_ptr);
    case 1:
      return LookupMapping<true>(kToUppercaseTable1, kToUppercaseTable1Size,
                                 kToUppercaseMultiStrings1, c, n, result,
                                 allow_caching_ptr);
    case 5:
      return LookupMapping<true>(kToUppercaseTable5, kToUppercaseTable5Size,
                                 kToUppercaseMultiStrings5, c, n, result,
                                 allow_caching_ptr);
    case 7:
      return LookupMapping<true>(kToUppercaseTable7, kToUppercaseTable7Size,
                                 kToUppercaseMultiStrings7, c, n, result,
                                 allow_caching_ptr);
    default:
      return 0;
  }
}

static const MultiCharacterSpecialCase<1> kEcma262CanonicalizeMultiStrings0[1] =
    {{{kSentinel}}};
static const uint16_t kEcma262CanonicalizeTable0Size = 498;
static const int32_t kEcma262CanonicalizeTable0[996] = {
    1073741921, -128,   122,        -128,   181,        2972,
    1073742048, -128,   246,        -128,   1073742072, -128,
    254,        -128,   255,        484,    257,        -4,
    259,        -4,     261,        -4,     263,        -4,
    265,        -4,     267,        -4,     269,        -4,
    271,        -4,     273,        -4,     275,        -4,
    277,        -4,     279,        -4,     281,        -4,
    283,        -4,     285,        -4,     287,        -4,
    289,        -4,     291,        -4,     293,        -4,
    295,        -4,     297,        -4,     299,        -4,
    301,        -4,     303,        -4,     307,        -4,
    309,        -4,     311,        -4,     314,        -4,
    316,        -4,     318,        -4,     320,        -4,
    322,        -4,     324,        -4,     326,        -4,
    328,        -4,     331,        -4,     333,        -4,
    335,        -4,     337,        -4,     339,        -4,
    341,        -4,     343,        -4,     345,        -4,
    347,        -4,     349,        -4,     351,        -4,
    353,        -4,     355,        -4,     357,        -4,
    359,        -4,     361,        -4,     363,        -4,
    365,        -4,     367,        -4,     369,        -4,
    371,        -4,     373,        -4,     375,        -4,
    378,        -4,     380,        -4,     382,        -4,
    384,        780,    387,        -4,     389,        -4,
    392,        -4,     396,        -4,     402,        -4,
    405,        388,    409,        -4,     410,        652,
    414,        520,    417,        -4,     419,        -4,
    421,        -4,     424,        -4,     429,        -4,
    432,        -4,     436,        -4,     438,        -4,
    441,        -4,     445,        -4,     447,        224,
    453,        -4,     454,        -8,     456,        -4,
    457,        -8,     459,        -4,     460,        -8,
    462,        -4,     464,        -4,     466,        -4,
    468,        -4,     470,        -4,     472,        -4,
    474,        -4,     476,        -4,     477,        -316,
    479,        -4,     481,        -4,     483,        -4,
    485,        -4,     487,        -4,     489,        -4,
    491,        -4,     493,        -4,     495,        -4,
    498,        -4,     499,        -8,     501,        -4,
    505,        -4,     507,        -4,     509,        -4,
    511,        -4,     513,        -4,     515,        -4,
    517,        -4,     519,        -4,     521,        -4,
    523,        -4,     525,        -4,     527,        -4,
    529,        -4,     531,        -4,     533,        -4,
    535,        -4,     537,        -4,     539,        -4,
    541,        -4,     543,        -4,     547,        -4,
    549,        -4,     551,        -4,     553,        -4,
    555,        -4,     557,        -4,     559,        -4,
    561,        -4,     563,        -4,     572,        -4,
    1073742399, 43260,  576,        43260,  578,        -4,
    583,        -4,     585,        -4,     587,        -4,
    589,        -4,     591,        -4,     592,        43132,
    593,        43120,  594,        43128,  595,        -840,
    596,        -824,   1073742422, -820,   599,        -820,
    601,        -808,   603,        -812,   604,        169276,
    608,        -820,   609,        169260, 611,        -828,
    613,        169120, 614,        169232, 616,        -836,
    617,        -844,   619,        42972,  620,        169220,
    623,        -844,   625,        42996,  626,        -852,
    629,        -856,   637,        42908,  640,        -872,
    643,        -872,   647,        169128, 648,        -872,
    649,        -276,   1073742474, -868,   651,        -868,
    652,        -284,   658,        -876,   670,        169032,
    837,        336,    881,        -4,     883,        -4,
    887,        -4,     1073742715, 520,    893,        520,
    940,        -152,   1073742765, -148,   943,        -148,
    1073742769, -128,   961,        -128,   962,        -124,
    1073742787, -128,   971,        -128,   972,        -256,
    1073742797, -252,   974,        -252,   976,        -248,
    977,        -228,   981,        -188,   982,        -216,
    983,        -32,    985,        -4,     987,        -4,
    989,        -4,     991,        -4,     993,        -4,
    995,        -4,     997,        -4,     999,        -4,
    1001,       -4,     1003,       -4,     1005,       -4,
    1007,       -4,     1008,       -344,   1009,       -320,
    1010,       28,     1011,       -464,   1013,       -384,
    1016,       -4,     1019,       -4,     1073742896, -128,
    1103,       -128,   1073742928, -320,   1119,       -320,
    1121,       -4,     1123,       -4,     1125,       -4,
    1127,       -4,     1129,       -4,     1131,       -4,
    1133,       -4,     1135,       -4,     1137,       -4,
    1139,       -4,     1141,       -4,     1143,       -4,
    1145,       -4,     1147,       -4,     1149,       -4,
    1151,       -4,     1153,       -4,     1163,       -4,
    1165,       -4,     1167,       -4,     1169,       -4,
    1171,       -4,     1173,       -4,     1175,       -4,
    1177,       -4,     1179,       -4,     1181,       -4,
    1183,       -4,     1185,       -4,     1187,       -4,
    1189,       -4,     1191,       -4,     1193,       -4,
    1195,       -4,     1197,       -4,     1199,       -4,
    1201,       -4,     1203,       -4,     1205,       -4,
    1207,       -4,     1209,       -4,     1211,       -4,
    1213,       -4,     1215,       -4,     1218,       -4,
    1220,       -4,     1222,       -4,     1224,       -4,
    1226,       -4,     1228,       -4,     1230,       -4,
    1231,       -60,    1233,       -4,     1235,       -4,
    1237,       -4,     1239,       -4,     1241,       -4,
    1243,       -4,     1245,       -4,     1247,       -4,
    1249,       -4,     1251,       -4,     1253,       -4,
    1255,       -4,     1257,       -4,     1259,       -4,
    1261,       -4,     1263,       -4,     1265,       -4,
    1267,       -4,     1269,       -4,     1271,       -4,
    1273,       -4,     1275,       -4,     1277,       -4,
    1279,       -4,     1281,       -4,     1283,       -4,
    1285,       -4,     1287,       -4,     1289,       -4,
    1291,       -4,     1293,       -4,     1295,       -4,
    1297,       -4,     1299,       -4,     1301,       -4,
    1303,       -4,     1305,       -4,     1307,       -4,
    1309,       -4,     1311,       -4,     1313,       -4,
    1315,       -4,     1317,       -4,     1319,       -4,
    1321,       -4,     1323,       -4,     1325,       -4,
    1327,       -4,     1073743201, -192,   1414,       -192,
    7545,       141328, 7549,       15256,  7681,       -4,
    7683,       -4,     7685,       -4,     7687,       -4,
    7689,       -4,     7691,       -4,     7693,       -4,
    7695,       -4,     7697,       -4,     7699,       -4,
    7701,       -4,     7703,       -4,     7705,       -4,
    7707,       -4,     7709,       -4,     7711,       -4,
    7713,       -4,     7715,       -4,     7717,       -4,
    7719,       -4,     7721,       -4,     7723,       -4,
    7725,       -4,     7727,       -4,     7729,       -4,
    7731,       -4,     7733,       -4,     7735,       -4,
    7737,       -4,     7739,       -4,     7741,       -4,
    7743,       -4,     7745,       -4,     7747,       -4,
    7749,       -4,     7751,       -4,     7753,       -4,
    7755,       -4,     7757,       -4,     7759,       -4,
    7761,       -4,     7763,       -4,     7765,       -4,
    7767,       -4,     7769,       -4,     7771,       -4,
    7773,       -4,     7775,       -4,     7777,       -4,
    7779,       -4,     7781,       -4,     7783,       -4,
    7785,       -4,     7787,       -4,     7789,       -4,
    7791,       -4,     7793,       -4,     7795,       -4,
    7797,       -4,     7799,       -4,     7801,       -4,
    7803,       -4,     7805,       -4,     7807,       -4,
    7809,       -4,     7811,       -4,     7813,       -4,
    7815,       -4,     7817,       -4,     7819,       -4,
    7821,       -4,     7823,       -4,     7825,       -4,
    7827,       -4,     7829,       -4,     7835,       -236,
    7841,       -4,     7843,       -4,     7845,       -4,
    7847,       -4,     7849,       -4,     7851,       -4,
    7853,       -4,     7855,       -4,     7857,       -4,
    7859,       -4,     7861,       -4,     7863,       -4,
    7865,       -4,     7867,       -4,     7869,       -4,
    7871,       -4,     7873,       -4,     7875,       -4,
    7877,       -4,     7879,       -4,     7881,       -4,
    7883,       -4,     7885,       -4,     7887,       -4,
    7889,       -4,     7891,       -4,     7893,       -4,
    7895,       -4,     7897,       -4,     7899,       -4,
    7901,       -4,     7903,       -4,     7905,       -4,
    7907,       -4,     7909,       -4,     7911,       -4,
    7913,       -4,     7915,       -4,     7917,       -4,
    7919,       -4,     7921,       -4,     7923,       -4,
    7925,       -4,     7927,       -4,     7929,       -4,
    7931,       -4,     7933,       -4,     7935,       -4,
    1073749760, 32,     7943,       32,     1073749776, 32,
    7957,       32,     1073749792, 32,     7975,       32,
    1073749808, 32,     7991,       32,     1073749824, 32,
    8005,       32,     8017,       32,     8019,       32,
    8021,       32,     8023,       32,     1073749856, 32,
    8039,       32,     1073749872, 296,    8049,       296,
    1073749874, 344,    8053,       344,    1073749878, 400,
    8055,       400,    1073749880, 512,    8057,       512,
    1073749882, 448,    8059,       448,    1073749884, 504,
    8061,       504,    1073749936, 32,     8113,       32,
    8126,       -28820, 1073749968, 32,     8145,       32,
    1073749984, 32,     8161,       32,     8165,       28};
static const uint16_t kEcma262CanonicalizeMultiStrings0Size = 1;
static const MultiCharacterSpecialCase<1> kEcma262CanonicalizeMultiStrings1[1] =
    {{{kSentinel}}};
static const uint16_t kEcma262CanonicalizeTable1Size = 73;
static const int32_t kEcma262CanonicalizeTable1[146] = {
    334,  -112,   1073742192, -64,    383,  -64,   388,  -4, 1073743056, -104,
    1257, -104,   1073744944, -192,   3166, -192,  3169, -4, 3173,       -43180,
    3174, -43168, 3176,       -4,     3178, -4,    3180, -4, 3187,       -4,
    3190, -4,     3201,       -4,     3203, -4,    3205, -4, 3207,       -4,
    3209, -4,     3211,       -4,     3213, -4,    3215, -4, 3217,       -4,
    3219, -4,     3221,       -4,     3223, -4,    3225, -4, 3227,       -4,
    3229, -4,     3231,       -4,     3233, -4,    3235, -4, 3237,       -4,
    3239, -4,     3241,       -4,     3243, -4,    3245, -4, 3247,       -4,
    3249, -4,     3251,       -4,     3253, -4,    3255, -4, 3257,       -4,
    3259, -4,     3261,       -4,     3263, -4,    3265, -4, 3267,       -4,
    3269, -4,     3271,       -4,     3273, -4,    3275, -4, 3277,       -4,
    3279, -4,     3281,       -4,     3283, -4,    3285, -4, 3287,       -4,
    3289, -4,     3291,       -4,     3293, -4,    3295, -4, 3297,       -4,
    3299, -4,     3308,       -4,     3310, -4,    3315, -4, 1073745152, -29056,
    3365, -29056, 3367,       -29056, 3373, -29056};
static const uint16_t kEcma262CanonicalizeMultiStrings1Size = 1;
static const MultiCharacterSpecialCase<1> kEcma262CanonicalizeMultiStrings5[1] =
    {{{kSentinel}}};
static const uint16_t kEcma262CanonicalizeTable5Size = 95;
static const int32_t kEcma262CanonicalizeTable5[190] = {
    1601, -4, 1603, -4, 1605, -4, 1607, -4, 1609, -4, 1611, -4, 1613, -4,
    1615, -4, 1617, -4, 1619, -4, 1621, -4, 1623, -4, 1625, -4, 1627, -4,
    1629, -4, 1631, -4, 1633, -4, 1635, -4, 1637, -4, 1639, -4, 1641, -4,
    1643, -4, 1645, -4, 1665, -4, 1667, -4, 1669, -4, 1671, -4, 1673, -4,
    1675, -4, 1677, -4, 1679, -4, 1681, -4, 1683, -4, 1685, -4, 1687, -4,
    1689, -4, 1691, -4, 1827, -4, 1829, -4, 1831, -4, 1833, -4, 1835, -4,
    1837, -4, 1839, -4, 1843, -4, 1845, -4, 1847, -4, 1849, -4, 1851, -4,
    1853, -4, 1855, -4, 1857, -4, 1859, -4, 1861, -4, 1863, -4, 1865, -4,
    1867, -4, 1869, -4, 1871, -4, 1873, -4, 1875, -4, 1877, -4, 1879, -4,
    1881, -4, 1883, -4, 1885, -4, 1887, -4, 1889, -4, 1891, -4, 1893, -4,
    1895, -4, 1897, -4, 1899, -4, 1901, -4, 1903, -4, 1914, -4, 1916, -4,
    1919, -4, 1921, -4, 1923, -4, 1925, -4, 1927, -4, 1932, -4, 1937, -4,
    1939, -4, 1943, -4, 1945, -4, 1947, -4, 1949, -4, 1951, -4, 1953, -4,
    1955, -4, 1957, -4, 1959, -4, 1961, -4};
static const uint16_t kEcma262CanonicalizeMultiStrings5Size = 1;
static const MultiCharacterSpecialCase<1> kEcma262CanonicalizeMultiStrings7[1] =
    {{{kSentinel}}};
static const uint16_t kEcma262CanonicalizeTable7Size = 2;
static const int32_t kEcma262CanonicalizeTable7[4] = {1073749825, -128, 8026,
                                                      -128};
static const uint16_t kEcma262CanonicalizeMultiStrings7Size = 1;
int Ecma262Canonicalize::Convert(uchar c, uchar n, uchar* result,
                                 bool* allow_caching_ptr) {
  int chunk_index = c >> 13;
  switch (chunk_index) {
    case 0:
      return LookupMapping<true>(
          kEcma262CanonicalizeTable0, kEcma262CanonicalizeTable0Size,
          kEcma262CanonicalizeMultiStrings0, c, n, result, allow_caching_ptr);
    case 1:
      return LookupMapping<true>(
          kEcma262CanonicalizeTable1, kEcma262CanonicalizeTable1Size,
          kEcma262CanonicalizeMultiStrings1, c, n, result, allow_caching_ptr);
    case 5:
      return LookupMapping<true>(
          kEcma262CanonicalizeTable5, kEcma262CanonicalizeTable5Size,
          kEcma262CanonicalizeMultiStrings5, c, n, result, allow_caching_ptr);
    case 7:
      return LookupMapping<true>(
          kEcma262CanonicalizeTable7, kEcma262CanonicalizeTable7Size,
          kEcma262CanonicalizeMultiStrings7, c, n, result, allow_caching_ptr);
    default:
      return 0;
  }
}

static const MultiCharacterSpecialCase<4>
    kEcma262UnCanonicalizeMultiStrings0[507] = {{{65, 97, kSentinel}},
                                                {{90, 122, kSentinel}},
                                                {{181, 924, 956, kSentinel}},
                                                {{192, 224, kSentinel}},
                                                {{214, 246, kSentinel}},
                                                {{216, 248, kSentinel}},
                                                {{222, 254, kSentinel}},
                                                {{255, 376, kSentinel}},
                                                {{256, 257, kSentinel}},
                                                {{258, 259, kSentinel}},
                                                {{260, 261, kSentinel}},
                                                {{262, 263, kSentinel}},
                                                {{264, 265, kSentinel}},
                                                {{266, 267, kSentinel}},
                                                {{268, 269, kSentinel}},
                                                {{270, 271, kSentinel}},
                                                {{272, 273, kSentinel}},
                                                {{274, 275, kSentinel}},
                                                {{276, 277, kSentinel}},
                                                {{278, 279, kSentinel}},
                                                {{280, 281, kSentinel}},
                                                {{282, 283, kSentinel}},
                                                {{284, 285, kSentinel}},
                                                {{286, 287, kSentinel}},
                                                {{288, 289, kSentinel}},
                                                {{290, 291, kSentinel}},
                                                {{292, 293, kSentinel}},
                                                {{294, 295, kSentinel}},
                                                {{296, 297, kSentinel}},
                                                {{298, 299, kSentinel}},
                                                {{300, 301, kSentinel}},
                                                {{302, 303, kSentinel}},
                                                {{306, 307, kSentinel}},
                                                {{308, 309, kSentinel}},
                                                {{310, 311, kSentinel}},
                                                {{313, 314, kSentinel}},
                                                {{315, 316, kSentinel}},
                                                {{317, 318, kSentinel}},
                                                {{319, 320, kSentinel}},
                                                {{321, 322, kSentinel}},
                                                {{323, 324, kSentinel}},
                                                {{325, 326, kSentinel}},
                                                {{327, 328, kSentinel}},
                                                {{330, 331, kSentinel}},
                                                {{332, 333, kSentinel}},
                                                {{334, 335, kSentinel}},
                                                {{336, 337, kSentinel}},
                                                {{338, 339, kSentinel}},
                                                {{340, 341, kSentinel}},
                                                {{342, 343, kSentinel}},
                                                {{344, 345, kSentinel}},
                                                {{346, 347, kSentinel}},
                                                {{348, 349, kSentinel}},
                                                {{350, 351, kSentinel}},
                                                {{352, 353, kSentinel}},
                                                {{354, 355, kSentinel}},
                                                {{356, 357, kSentinel}},
                                                {{358, 359, kSentinel}},
                                                {{360, 361, kSentinel}},
                                                {{362, 363, kSentinel}},
                                                {{364, 365, kSentinel}},
                                                {{366, 367, kSentinel}},
                                                {{368, 369, kSentinel}},
                                                {{370, 371, kSentinel}},
                                                {{372, 373, kSentinel}},
                                                {{374, 375, kSentinel}},
                                                {{377, 378, kSentinel}},
                                                {{379, 380, kSentinel}},
                                                {{381, 382, kSentinel}},
                                                {{384, 579, kSentinel}},
                                                {{385, 595, kSentinel}},
                                                {{386, 387, kSentinel}},
                                                {{388, 389, kSentinel}},
                                                {{390, 596, kSentinel}},
                                                {{391, 392, kSentinel}},
                                                {{393, 598, kSentinel}},
                                                {{394, 599, kSentinel}},
                                                {{395, 396, kSentinel}},
                                                {{398, 477, kSentinel}},
                                                {{399, 601, kSentinel}},
                                                {{400, 603, kSentinel}},
                                                {{401, 402, kSentinel}},
                                                {{403, 608, kSentinel}},
                                                {{404, 611, kSentinel}},
                                                {{405, 502, kSentinel}},
                                                {{406, 617, kSentinel}},
                                                {{407, 616, kSentinel}},
                                                {{408, 409, kSentinel}},
                                                {{410, 573, kSentinel}},
                                                {{412, 623, kSentinel}},
                                                {{413, 626, kSentinel}},
                                                {{414, 544, kSentinel}},
                                                {{415, 629, kSentinel}},
                                                {{416, 417, kSentinel}},
                                                {{418, 419, kSentinel}},
                                                {{420, 421, kSentinel}},
                                                {{422, 640, kSentinel}},
                                                {{423, 424, kSentinel}},
                                                {{425, 643, kSentinel}},
                                                {{428, 429, kSentinel}},
                                                {{430, 648, kSentinel}},
                                                {{431, 432, kSentinel}},
                                                {{433, 650, kSentinel}},
                                                {{434, 651, kSentinel}},
                                                {{435, 436, kSentinel}},
                                                {{437, 438, kSentinel}},
                                                {{439, 658, kSentinel}},
                                                {{440, 441, kSentinel}},
                                                {{444, 445, kSentinel}},
                                                {{447, 503, kSentinel}},
                                                {{452, 453, 454, kSentinel}},
                                                {{455, 456, 457, kSentinel}},
                                                {{458, 459, 460, kSentinel}},
                                                {{461, 462, kSentinel}},
                                                {{463, 464, kSentinel}},
                                                {{465, 466, kSentinel}},
                                                {{467, 468, kSentinel}},
                                                {{469, 470, kSentinel}},
                                                {{471, 472, kSentinel}},
                                                {{473, 474, kSentinel}},
                                                {{475, 476, kSentinel}},
                                                {{478, 479, kSentinel}},
                                                {{480, 481, kSentinel}},
                                                {{482, 483, kSentinel}},
                                                {{484, 485, kSentinel}},
                                                {{486, 487, kSentinel}},
                                                {{488, 489, kSentinel}},
                                                {{490, 491, kSentinel}},
                                                {{492, 493, kSentinel}},
                                                {{494, 495, kSentinel}},
                                                {{497, 498, 499, kSentinel}},
                                                {{500, 501, kSentinel}},
                                                {{504, 505, kSentinel}},
                                                {{506, 507, kSentinel}},
                                                {{508, 509, kSentinel}},
                                                {{510, 511, kSentinel}},
                                                {{512, 513, kSentinel}},
                                                {{514, 515, kSentinel}},
                                                {{516, 517, kSentinel}},
                                                {{518, 519, kSentinel}},
                                                {{520, 521, kSentinel}},
                                                {{522, 523, kSentinel}},
                                                {{524, 525, kSentinel}},
                                                {{526, 527, kSentinel}},
                                                {{528, 529, kSentinel}},
                                                {{530, 531, kSentinel}},
                                                {{532, 533, kSentinel}},
                                                {{534, 535, kSentinel}},
                                                {{536, 537, kSentinel}},
                                                {{538, 539, kSentinel}},
                                                {{540, 541, kSentinel}},
                                                {{542, 543, kSentinel}},
                                                {{546, 547, kSentinel}},
                                                {{548, 549, kSentinel}},
                                                {{550, 551, kSentinel}},
                                                {{552, 553, kSentinel}},
                                                {{554, 555, kSentinel}},
                                                {{556, 557, kSentinel}},
                                                {{558, 559, kSentinel}},
                                                {{560, 561, kSentinel}},
                                                {{562, 563, kSentinel}},
                                                {{570, 11365, kSentinel}},
                                                {{571, 572, kSentinel}},
                                                {{574, 11366, kSentinel}},
                                                {{575, 11390, kSentinel}},
                                                {{576, 11391, kSentinel}},
                                                {{577, 578, kSentinel}},
                                                {{580, 649, kSentinel}},
                                                {{581, 652, kSentinel}},
                                                {{582, 583, kSentinel}},
                                                {{584, 585, kSentinel}},
                                                {{586, 587, kSentinel}},
                                                {{588, 589, kSentinel}},
                                                {{590, 591, kSentinel}},
                                                {{592, 11375, kSentinel}},
                                                {{593, 11373, kSentinel}},
                                                {{594, 11376, kSentinel}},
                                                {{604, 42923, kSentinel}},
                                                {{609, 42924, kSentinel}},
                                                {{613, 42893, kSentinel}},
                                                {{614, 42922, kSentinel}},
                                                {{619, 11362, kSentinel}},
                                                {{620, 42925, kSentinel}},
                                                {{625, 11374, kSentinel}},
                                                {{637, 11364, kSentinel}},
                                                {{647, 42929, kSentinel}},
                                                {{670, 42928, kSentinel}},
                                                {{837, 921, 953, 8126}},
                                                {{880, 881, kSentinel}},
                                                {{882, 883, kSentinel}},
                                                {{886, 887, kSentinel}},
                                                {{891, 1021, kSentinel}},
                                                {{893, 1023, kSentinel}},
                                                {{895, 1011, kSentinel}},
                                                {{902, 940, kSentinel}},
                                                {{904, 941, kSentinel}},
                                                {{906, 943, kSentinel}},
                                                {{908, 972, kSentinel}},
                                                {{910, 973, kSentinel}},
                                                {{911, 974, kSentinel}},
                                                {{913, 945, kSentinel}},
                                                {{914, 946, 976, kSentinel}},
                                                {{915, 947, kSentinel}},
                                                {{916, 948, kSentinel}},
                                                {{917, 949, 1013, kSentinel}},
                                                {{918, 950, kSentinel}},
                                                {{919, 951, kSentinel}},
                                                {{920, 952, 977, kSentinel}},
                                                {{922, 954, 1008, kSentinel}},
                                                {{923, 955, kSentinel}},
                                                {{925, 957, kSentinel}},
                                                {{927, 959, kSentinel}},
                                                {{928, 960, 982, kSentinel}},
                                                {{929, 961, 1009, kSentinel}},
                                                {{931, 962, 963, kSentinel}},
                                                {{932, 964, kSentinel}},
                                                {{933, 965, kSentinel}},
                                                {{934, 966, 981, kSentinel}},
                                                {{935, 967, kSentinel}},
                                                {{939, 971, kSentinel}},
                                                {{975, 983, kSentinel}},
                                                {{984, 985, kSentinel}},
                                                {{986, 987, kSentinel}},
                                                {{988, 989, kSentinel}},
                                                {{990, 991, kSentinel}},
                                                {{992, 993, kSentinel}},
                                                {{994, 995, kSentinel}},
                                                {{996, 997, kSentinel}},
                                                {{998, 999, kSentinel}},
                                                {{1000, 1001, kSentinel}},
                                                {{1002, 1003, kSentinel}},
                                                {{1004, 1005, kSentinel}},
                                                {{1006, 1007, kSentinel}},
                                                {{1010, 1017, kSentinel}},
                                                {{1015, 1016, kSentinel}},
                                                {{1018, 1019, kSentinel}},
                                                {{1024, 1104, kSentinel}},
                                                {{1039, 1119, kSentinel}},
                                                {{1040, 1072, kSentinel}},
                                                {{1071, 1103, kSentinel}},
                                                {{1120, 1121, kSentinel}},
                                                {{1122, 1123, kSentinel}},
                                                {{1124, 1125, kSentinel}},
                                                {{1126, 1127, kSentinel}},
                                                {{1128, 1129, kSentinel}},
                                                {{1130, 1131, kSentinel}},
                                                {{1132, 1133, kSentinel}},
                                                {{1134, 1135, kSentinel}},
                                                {{1136, 1137, kSentinel}},
                                                {{1138, 1139, kSentinel}},
                                                {{1140, 1141, kSentinel}},
                                                {{1142, 1143, kSentinel}},
                                                {{1144, 1145, kSentinel}},
                                                {{1146, 1147, kSentinel}},
                                                {{1148, 1149, kSentinel}},
                                                {{1150, 1151, kSentinel}},
                                                {{1152, 1153, kSentinel}},
                                                {{1162, 1163, kSentinel}},
                                                {{1164, 1165, kSentinel}},
                                                {{1166, 1167, kSentinel}},
                                                {{1168, 1169, kSentinel}},
                                                {{1170, 1171, kSentinel}},
                                                {{1172, 1173, kSentinel}},
                                                {{1174, 1175, kSentinel}},
                                                {{1176, 1177, kSentinel}},
                                                {{1178, 1179, kSentinel}},
                                                {{1180, 1181, kSentinel}},
                                                {{1182, 1183, kSentinel}},
                                                {{1184, 1185, kSentinel}},
                                                {{1186, 1187, kSentinel}},
                                                {{1188, 1189, kSentinel}},
                                                {{1190, 1191, kSentinel}},
                                                {{1192, 1193, kSentinel}},
                                                {{1194, 1195, kSentinel}},
                                                {{1196, 1197, kSentinel}},
                                                {{1198, 1199, kSentinel}},
                                                {{1200, 1201, kSentinel}},
                                                {{1202, 1203, kSentinel}},
                                                {{1204, 1205, kSentinel}},
                                                {{1206, 1207, kSentinel}},
                                                {{1208, 1209, kSentinel}},
                                                {{1210, 1211, kSentinel}},
                                                {{1212, 1213, kSentinel}},
                                                {{1214, 1215, kSentinel}},
                                                {{1216, 1231, kSentinel}},
                                                {{1217, 1218, kSentinel}},
                                                {{1219, 1220, kSentinel}},
                                                {{1221, 1222, kSentinel}},
                                                {{1223, 1224, kSentinel}},
                                                {{1225, 1226, kSentinel}},
                                                {{1227, 1228, kSentinel}},
                                                {{1229, 1230, kSentinel}},
                                                {{1232, 1233, kSentinel}},
                                                {{1234, 1235, kSentinel}},
                                                {{1236, 1237, kSentinel}},
                                                {{1238, 1239, kSentinel}},
                                                {{1240, 1241, kSentinel}},
                                                {{1242, 1243, kSentinel}},
                                                {{1244, 1245, kSentinel}},
                                                {{1246, 1247, kSentinel}},
                                                {{1248, 1249, kSentinel}},
                                                {{1250, 1251, kSentinel}},
                                                {{1252, 1253, kSentinel}},
                                                {{1254, 1255, kSentinel}},
                                                {{1256, 1257, kSentinel}},
                                                {{1258, 1259, kSentinel}},
                                                {{1260, 1261, kSentinel}},
                                                {{1262, 1263, kSentinel}},
                                                {{1264, 1265, kSentinel}},
                                                {{1266, 1267, kSentinel}},
                                                {{1268, 1269, kSentinel}},
                                                {{1270, 1271, kSentinel}},
                                                {{1272, 1273, kSentinel}},
                                                {{1274, 1275, kSentinel}},
                                                {{1276, 1277, kSentinel}},
                                                {{1278, 1279, kSentinel}},
                                                {{1280, 1281, kSentinel}},
                                                {{1282, 1283, kSentinel}},
                                                {{1284, 1285, kSentinel}},
                                                {{1286, 1287, kSentinel}},
                                                {{1288, 1289, kSentinel}},
                                                {{1290, 1291, kSentinel}},
                                                {{1292, 1293, kSentinel}},
                                                {{1294, 1295, kSentinel}},
                                                {{1296, 1297, kSentinel}},
                                                {{1298, 1299, kSentinel}},
                                                {{1300, 1301, kSentinel}},
                                                {{1302, 1303, kSentinel}},
                                                {{1304, 1305, kSentinel}},
                                                {{1306, 1307, kSentinel}},
                                                {{1308, 1309, kSentinel}},
                                                {{1310, 1311, kSentinel}},
                                                {{1312, 1313, kSentinel}},
                                                {{1314, 1315, kSentinel}},
                                                {{1316, 1317, kSentinel}},
                                                {{1318, 1319, kSentinel}},
                                                {{1320, 1321, kSentinel}},
                                                {{1322, 1323, kSentinel}},
                                                {{1324, 1325, kSentinel}},
                                                {{1326, 1327, kSentinel}},
                                                {{1329, 1377, kSentinel}},
                                                {{1366, 1414, kSentinel}},
                                                {{4256, 11520, kSentinel}},
                                                {{4293, 11557, kSentinel}},
                                                {{4295, 11559, kSentinel}},
                                                {{4301, 11565, kSentinel}},
                                                {{7545, 42877, kSentinel}},
                                                {{7549, 11363, kSentinel}},
                                                {{7680, 7681, kSentinel}},
                                                {{7682, 7683, kSentinel}},
                                                {{7684, 7685, kSentinel}},
                                                {{7686, 7687, kSentinel}},
                                                {{7688, 7689, kSentinel}},
                                                {{7690, 7691, kSentinel}},
                                                {{7692, 7693, kSentinel}},
                                                {{7694, 7695, kSentinel}},
                                                {{7696, 7697, kSentinel}},
                                                {{7698, 7699, kSentinel}},
                                                {{7700, 7701, kSentinel}},
                                                {{7702, 7703, kSentinel}},
                                                {{7704, 7705, kSentinel}},
                                                {{7706, 7707, kSentinel}},
                                                {{7708, 7709, kSentinel}},
                                                {{7710, 7711, kSentinel}},
                                                {{7712, 7713, kSentinel}},
                                                {{7714, 7715, kSentinel}},
                                                {{7716, 7717, kSentinel}},
                                                {{7718, 7719, kSentinel}},
                                                {{7720, 7721, kSentinel}},
                                                {{7722, 7723, kSentinel}},
                                                {{7724, 7725, kSentinel}},
                                                {{7726, 7727, kSentinel}},
                                                {{7728, 7729, kSentinel}},
                                                {{7730, 7731, kSentinel}},
                                                {{7732, 7733, kSentinel}},
                                                {{7734, 7735, kSentinel}},
                                                {{7736, 7737, kSentinel}},
                                                {{7738, 7739, kSentinel}},
                                                {{7740, 7741, kSentinel}},
                                                {{7742, 7743, kSentinel}},
                                                {{7744, 7745, kSentinel}},
                                                {{7746, 7747, kSentinel}},
                                                {{7748, 7749, kSentinel}},
                                                {{7750, 7751, kSentinel}},
                                                {{7752, 7753, kSentinel}},
                                                {{7754, 7755, kSentinel}},
                                                {{7756, 7757, kSentinel}},
                                                {{7758, 7759, kSentinel}},
                                                {{7760, 7761, kSentinel}},
                                                {{7762, 7763, kSentinel}},
                                                {{7764, 7765, kSentinel}},
                                                {{7766, 7767, kSentinel}},
                                                {{7768, 7769, kSentinel}},
                                                {{7770, 7771, kSentinel}},
                                                {{7772, 7773, kSentinel}},
                                                {{7774, 7775, kSentinel}},
                                                {{7776, 7777, 7835, kSentinel}},
                                                {{7778, 7779, kSentinel}},
                                                {{7780, 7781, kSentinel}},
                                                {{7782, 7783, kSentinel}},
                                                {{7784, 7785, kSentinel}},
                                                {{7786, 7787, kSentinel}},
                                                {{7788, 7789, kSentinel}},
                                                {{7790, 7791, kSentinel}},
                                                {{7792, 7793, kSentinel}},
                                                {{7794, 7795, kSentinel}},
                                                {{7796, 7797, kSentinel}},
                                                {{7798, 7799, kSentinel}},
                                                {{7800, 7801, kSentinel}},
                                                {{7802, 7803, kSentinel}},
                                                {{7804, 7805, kSentinel}},
                                                {{7806, 7807, kSentinel}},
                                                {{7808, 7809, kSentinel}},
                                                {{7810, 7811, kSentinel}},
                                                {{7812, 7813, kSentinel}},
                                                {{7814, 7815, kSentinel}},
                                                {{7816, 7817, kSentinel}},
                                                {{7818, 7819, kSentinel}},
                                                {{7820, 7821, kSentinel}},
                                                {{7822, 7823, kSentinel}},
                                                {{7824, 7825, kSentinel}},
                                                {{7826, 7827, kSentinel}},
                                                {{7828, 7829, kSentinel}},
                                                {{7840, 7841, kSentinel}},
                                                {{7842, 7843, kSentinel}},
                                                {{7844, 7845, kSentinel}},
                                                {{7846, 7847, kSentinel}},
                                                {{7848, 7849, kSentinel}},
                                                {{7850, 7851, kSentinel}},
                                                {{7852, 7853, kSentinel}},
                                                {{7854, 7855, kSentinel}},
                                                {{7856, 7857, kSentinel}},
                                                {{7858, 7859, kSentinel}},
                                                {{7860, 7861, kSentinel}},
                                                {{7862, 7863, kSentinel}},
                                                {{7864, 7865, kSentinel}},
                                                {{7866, 7867, kSentinel}},
                                                {{7868, 7869, kSentinel}},
                                                {{7870, 7871, kSentinel}},
                                                {{7872, 7873, kSentinel}},
                                                {{7874, 7875, kSentinel}},
                                                {{7876, 7877, kSentinel}},
                                                {{7878, 7879, kSentinel}},
                                                {{7880, 7881, kSentinel}},
                                                {{7882, 7883, kSentinel}},
                                                {{7884, 7885, kSentinel}},
                                                {{7886, 7887, kSentinel}},
                                                {{7888, 7889, kSentinel}},
                                                {{7890, 7891, kSentinel}},
                                                {{7892, 7893, kSentinel}},
                                                {{7894, 7895, kSentinel}},
                                                {{7896, 7897, kSentinel}},
                                                {{7898, 7899, kSentinel}},
                                                {{7900, 7901, kSentinel}},
                                                {{7902, 7903, kSentinel}},
                                                {{7904, 7905, kSentinel}},
                                                {{7906, 7907, kSentinel}},
                                                {{7908, 7909, kSentinel}},
                                                {{7910, 7911, kSentinel}},
                                                {{7912, 7913, kSentinel}},
                                                {{7914, 7915, kSentinel}},
                                                {{7916, 7917, kSentinel}},
                                                {{7918, 7919, kSentinel}},
                                                {{7920, 7921, kSentinel}},
                                                {{7922, 7923, kSentinel}},
                                                {{7924, 7925, kSentinel}},
                                                {{7926, 7927, kSentinel}},
                                                {{7928, 7929, kSentinel}},
                                                {{7930, 7931, kSentinel}},
                                                {{7932, 7933, kSentinel}},
                                                {{7934, 7935, kSentinel}},
                                                {{7936, 7944, kSentinel}},
                                                {{7943, 7951, kSentinel}},
                                                {{7952, 7960, kSentinel}},
                                                {{7957, 7965, kSentinel}},
                                                {{7968, 7976, kSentinel}},
                                                {{7975, 7983, kSentinel}},
                                                {{7984, 7992, kSentinel}},
                                                {{7991, 7999, kSentinel}},
                                                {{8000, 8008, kSentinel}},
                                                {{8005, 8013, kSentinel}},
                                                {{8017, 8025, kSentinel}},
                                                {{8019, 8027, kSentinel}},
                                                {{8021, 8029, kSentinel}},
                                                {{8023, 8031, kSentinel}},
                                                {{8032, 8040, kSentinel}},
                                                {{8039, 8047, kSentinel}},
                                                {{8048, 8122, kSentinel}},
                                                {{8049, 8123, kSentinel}},
                                                {{8050, 8136, kSentinel}},
                                                {{8053, 8139, kSentinel}},
                                                {{8054, 8154, kSentinel}},
                                                {{8055, 8155, kSentinel}},
                                                {{8056, 8184, kSentinel}},
                                                {{8057, 8185, kSentinel}},
                                                {{8058, 8170, kSentinel}},
                                                {{8059, 8171, kSentinel}},
                                                {{8060, 8186, kSentinel}},
                                                {{8061, 8187, kSentinel}},
                                                {{8112, 8120, kSentinel}},
                                                {{8113, 8121, kSentinel}},
                                                {{8144, 8152, kSentinel}},
                                                {{8145, 8153, kSentinel}},
                                                {{8160, 8168, kSentinel}},
                                                {{8161, 8169, kSentinel}},
                                                {{8165, 8172, kSentinel}},
                                                {{kSentinel}}};
static const uint16_t kEcma262UnCanonicalizeTable0Size = 1005;
static const int32_t kEcma262UnCanonicalizeTable0[2010] = {
    1073741889, 1,    90,         5,    1073741921, 1,    122,        5,
    181,        9,    1073742016, 13,   214,        17,   1073742040, 21,
    222,        25,   1073742048, 13,   246,        17,   1073742072, 21,
    254,        25,   255,        29,   256,        33,   257,        33,
    258,        37,   259,        37,   260,        41,   261,        41,
    262,        45,   263,        45,   264,        49,   265,        49,
    266,        53,   267,        53,   268,        57,   269,        57,
    270,        61,   271,        61,   272,        65,   273,        65,
    274,        69,   275,        69,   276,        73,   277,        73,
    278,        77,   279,        77,   280,        81,   281,        81,
    282,        85,   283,        85,   284,        89,   285,        89,
    286,        93,   287,        93,   288,        97,   289,        97,
    290,        101,  291,        101,  292,        105,  293,        105,
    294,        109,  295,        109,  296,        113,  297,        113,
    298,        117,  299,        117,  300,        121,  301,        121,
    302,        125,  303,        125,  306,        129,  307,        129,
    308,        133,  309,        133,  310,        137,  311,        137,
    313,        141,  314,        141,  315,        145,  316,        145,
    317,        149,  318,        149,  319,        153,  320,        153,
    321,        157,  322,        157,  323,        161,  324,        161,
    325,        165,  326,        165,  327,        169,  328,        169,
    330,        173,  331,        173,  332,        177,  333,        177,
    334,        181,  335,        181,  336,        185,  337,        185,
    338,        189,  339,        189,  340,        193,  341,        193,
    342,        197,  343,        197,  344,        201,  345,        201,
    346,        205,  347,        205,  348,        209,  349,        209,
    350,        213,  351,        213,  352,        217,  353,        217,
    354,        221,  355,        221,  356,        225,  357,        225,
    358,        229,  359,        229,  360,        233,  361,        233,
    362,        237,  363,        237,  364,        241,  365,        241,
    366,        245,  367,        245,  368,        249,  369,        249,
    370,        253,  371,        253,  372,        257,  373,        257,
    374,        261,  375,        261,  376,        29,   377,        265,
    378,        265,  379,        269,  380,        269,  381,        273,
    382,        273,  384,        277,  385,        281,  386,        285,
    387,        285,  388,        289,  389,        289,  390,        293,
    391,        297,  392,        297,  1073742217, 301,  394,        305,
    395,        309,  396,        309,  398,        313,  399,        317,
    400,        321,  401,        325,  402,        325,  403,        329,
    404,        333,  405,        337,  406,        341,  407,        345,
    408,        349,  409,        349,  410,        353,  412,        357,
    413,        361,  414,        365,  415,        369,  416,        373,
    417,        373,  418,        377,  419,        377,  420,        381,
    421,        381,  422,        385,  423,        389,  424,        389,
    425,        393,  428,        397,  429,        397,  430,        401,
    431,        405,  432,        405,  1073742257, 409,  434,        413,
    435,        417,  436,        417,  437,        421,  438,        421,
    439,        425,  440,        429,  441,        429,  444,        433,
    445,        433,  447,        437,  452,        441,  453,        441,
    454,        441,  455,        445,  456,        445,  457,        445,
    458,        449,  459,        449,  460,        449,  461,        453,
    462,        453,  463,        457,  464,        457,  465,        461,
    466,        461,  467,        465,  468,        465,  469,        469,
    470,        469,  471,        473,  472,        473,  473,        477,
    474,        477,  475,        481,  476,        481,  477,        313,
    478,        485,  479,        485,  480,        489,  481,        489,
    482,        493,  483,        493,  484,        497,  485,        497,
    486,        501,  487,        501,  488,        505,  489,        505,
    490,        509,  491,        509,  492,        513,  493,        513,
    494,        517,  495,        517,  497,        521,  498,        521,
    499,        521,  500,        525,  501,        525,  502,        337,
    503,        437,  504,        529,  505,        529,  506,        533,
    507,        533,  508,        537,  509,        537,  510,        541,
    511,        541,  512,        545,  513,        545,  514,        549,
    515,        549,  516,        553,  517,        553,  518,        557,
    519,        557,  520,        561,  521,        561,  522,        565,
    523,        565,  524,        569,  525,        569,  526,        573,
    527,        573,  528,        577,  529,        577,  530,        581,
    531,        581,  532,        585,  533,        585,  534,        589,
    535,        589,  536,        593,  537,        593,  538,        597,
    539,        597,  540,        601,  541,        601,  542,        605,
    543,        605,  544,        365,  546,        609,  547,        609,
    548,        613,  549,        613,  550,        617,  551,        617,
    552,        621,  553,        621,  554,        625,  555,        625,
    556,        629,  557,        629,  558,        633,  559,        633,
    560,        637,  561,        637,  562,        641,  563,        641,
    570,        645,  571,        649,  572,        649,  573,        353,
    574,        653,  1073742399, 657,  576,        661,  577,        665,
    578,        665,  579,        277,  580,        669,  581,        673,
    582,        677,  583,        677,  584,        681,  585,        681,
    586,        685,  587,        685,  588,        689,  589,        689,
    590,        693,  591,        693,  592,        697,  593,        701,
    594,        705,  595,        281,  596,        293,  1073742422, 301,
    599,        305,  601,        317,  603,        321,  604,        709,
    608,        329,  609,        713,  611,        333,  613,        717,
    614,        721,  616,        345,  617,        341,  619,        725,
    620,        729,  623,        357,  625,        733,  626,        361,
    629,        369,  637,        737,  640,        385,  643,        393,
    647,        741,  648,        401,  649,        669,  1073742474, 409,
    651,        413,  652,        673,  658,        425,  670,        745,
    837,        749,  880,        753,  881,        753,  882,        757,
    883,        757,  886,        761,  887,        761,  1073742715, 765,
    893,        769,  895,        773,  902,        777,  1073742728, 781,
    906,        785,  908,        789,  1073742734, 793,  911,        797,
    913,        801,  914,        805,  1073742739, 809,  916,        813,
    917,        817,  1073742742, 821,  919,        825,  920,        829,
    921,        749,  922,        833,  923,        837,  924,        9,
    1073742749, 841,  927,        845,  928,        849,  929,        853,
    931,        857,  1073742756, 861,  933,        865,  934,        869,
    1073742759, 873,  939,        877,  940,        777,  1073742765, 781,
    943,        785,  945,        801,  946,        805,  1073742771, 809,
    948,        813,  949,        817,  1073742774, 821,  951,        825,
    952,        829,  953,        749,  954,        833,  955,        837,
    956,        9,    1073742781, 841,  959,        845,  960,        849,
    961,        853,  962,        857,  963,        857,  1073742788, 861,
    965,        865,  966,        869,  1073742791, 873,  971,        877,
    972,        789,  1073742797, 793,  974,        797,  975,        881,
    976,        805,  977,        829,  981,        869,  982,        849,
    983,        881,  984,        885,  985,        885,  986,        889,
    987,        889,  988,        893,  989,        893,  990,        897,
    991,        897,  992,        901,  993,        901,  994,        905,
    995,        905,  996,        909,  997,        909,  998,        913,
    999,        913,  1000,       917,  1001,       917,  1002,       921,
    1003,       921,  1004,       925,  1005,       925,  1006,       929,
    1007,       929,  1008,       833,  1009,       853,  1010,       933,
    1011,       773,  1013,       817,  1015,       937,  1016,       937,
    1017,       933,  1018,       941,  1019,       941,  1073742845, 765,
    1023,       769,  1073742848, 945,  1039,       949,  1073742864, 953,
    1071,       957,  1073742896, 953,  1103,       957,  1073742928, 945,
    1119,       949,  1120,       961,  1121,       961,  1122,       965,
    1123,       965,  1124,       969,  1125,       969,  1126,       973,
    1127,       973,  1128,       977,  1129,       977,  1130,       981,
    1131,       981,  1132,       985,  1133,       985,  1134,       989,
    1135,       989,  1136,       993,  1137,       993,  1138,       997,
    1139,       997,  1140,       1001, 1141,       1001, 1142,       1005,
    1143,       1005, 1144,       1009, 1145,       1009, 1146,       1013,
    1147,       1013, 1148,       1017, 1149,       1017, 1150,       1021,
    1151,       1021, 1152,       1025, 1153,       1025, 1162,       1029,
    1163,       1029, 1164,       1033, 1165,       1033, 1166,       1037,
    1167,       1037, 1168,       1041, 1169,       1041, 1170,       1045,
    1171,       1045, 1172,       1049, 1173,       1049, 1174,       1053,
    1175,       1053, 1176,       1057, 1177,       1057, 1178,       1061,
    1179,       1061, 1180,       1065, 1181,       1065, 1182,       1069,
    1183,       1069, 1184,       1073, 1185,       1073, 1186,       1077,
    1187,       1077, 1188,       1081, 1189,       1081, 1190,       1085,
    1191,       1085, 1192,       1089, 1193,       1089, 1194,       1093,
    1195,       1093, 1196,       1097, 1197,       1097, 1198,       1101,
    1199,       1101, 1200,       1105, 1201,       1105, 1202,       1109,
    1203,       1109, 1204,       1113, 1205,       1113, 1206,       1117,
    1207,       1117, 1208,       1121, 1209,       1121, 1210,       1125,
    1211,       1125, 1212,       1129, 1213,       1129, 1214,       1133,
    1215,       1133, 1216,       1137, 1217,       1141, 1218,       1141,
    1219,       1145, 1220,       1145, 1221,       1149, 1222,       1149,
    1223,       1153, 1224,       1153, 1225,       1157, 1226,       1157,
    1227,       1161, 1228,       1161, 1229,       1165, 1230,       1165,
    1231,       1137, 1232,       1169, 1233,       1169, 1234,       1173,
    1235,       1173, 1236,       1177, 1237,       1177, 1238,       1181,
    1239,       1181, 1240,       1185, 1241,       1185, 1242,       1189,
    1243,       1189, 1244,       1193, 1245,       1193, 1246,       1197,
    1247,       1197, 1248,       1201, 1249,       1201, 1250,       1205,
    1251,       1205, 1252,       1209, 1253,       1209, 1254,       1213,
    1255,       1213, 1256,       1217, 1257,       1217, 1258,       1221,
    1259,       1221, 1260,       1225, 1261,       1225, 1262,       1229,
    1263,       1229, 1264,       1233, 1265,       1233, 1266,       1237,
    1267,       1237, 1268,       1241, 1269,       1241, 1270,       1245,
    1271,       1245, 1272,       1249, 1273,       1249, 1274,       1253,
    1275,       1253, 1276,       1257, 1277,       1257, 1278,       1261,
    1279,       1261, 1280,       1265, 1281,       1265, 1282,       1269,
    1283,       1269, 1284,       1273, 1285,       1273, 1286,       1277,
    1287,       1277, 1288,       1281, 1289,       1281, 1290,       1285,
    1291,       1285, 1292,       1289, 1293,       1289, 1294,       1293,
    1295,       1293, 1296,       1297, 1297,       1297, 1298,       1301,
    1299,       1301, 1300,       1305, 1301,       1305, 1302,       1309,
    1303,       1309, 1304,       1313, 1305,       1313, 1306,       1317,
    1307,       1317, 1308,       1321, 1309,       1321, 1310,       1325,
    1311,       1325, 1312,       1329, 1313,       1329, 1314,       1333,
    1315,       1333, 1316,       1337, 1317,       1337, 1318,       1341,
    1319,       1341, 1320,       1345, 1321,       1345, 1322,       1349,
    1323,       1349, 1324,       1353, 1325,       1353, 1326,       1357,
    1327,       1357, 1073743153, 1361, 1366,       1365, 1073743201, 1361,
    1414,       1365, 1073746080, 1369, 4293,       1373, 4295,       1377,
    4301,       1381, 7545,       1385, 7549,       1389, 7680,       1393,
    7681,       1393, 7682,       1397, 7683,       1397, 7684,       1401,
    7685,       1401, 7686,       1405, 7687,       1405, 7688,       1409,
    7689,       1409, 7690,       1413, 7691,       1413, 7692,       1417,
    7693,       1417, 7694,       1421, 7695,       1421, 7696,       1425,
    7697,       1425, 7698,       1429, 7699,       1429, 7700,       1433,
    7701,       1433, 7702,       1437, 7703,       1437, 7704,       1441,
    7705,       1441, 7706,       1445, 7707,       1445, 7708,       1449,
    7709,       1449, 7710,       1453, 7711,       1453, 7712,       1457,
    7713,       1457, 7714,       1461, 7715,       1461, 7716,       1465,
    7717,       1465, 7718,       1469, 7719,       1469, 7720,       1473,
    7721,       1473, 7722,       1477, 7723,       1477, 7724,       1481,
    7725,       1481, 7726,       1485, 7727,       1485, 7728,       1489,
    7729,       1489, 7730,       1493, 7731,       1493, 7732,       1497,
    7733,       1497, 7734,       1501, 7735,       1501, 7736,       1505,
    7737,       1505, 7738,       1509, 7739,       1509, 7740,       1513,
    7741,       1513, 7742,       1517, 7743,       1517, 7744,       1521,
    7745,       1521, 7746,       1525, 7747,       1525, 7748,       1529,
    7749,       1529, 7750,       1533, 7751,       1533, 7752,       1537,
    7753,       1537, 7754,       1541, 7755,       1541, 7756,       1545,
    7757,       1545, 7758,       1549, 7759,       1549, 7760,       1553,
    7761,       1553, 7762,       1557, 7763,       1557, 7764,       1561,
    7765,       1561, 7766,       1565, 7767,       1565, 7768,       1569,
    7769,       1569, 7770,       1573, 7771,       1573, 7772,       1577,
    7773,       1577, 7774,       1581, 7775,       1581, 7776,       1585,
    7777,       1585, 7778,       1589, 7779,       1589, 7780,       1593,
    7781,       1593, 7782,       1597, 7783,       1597, 7784,       1601,
    7785,       1601, 7786,       1605, 7787,       1605, 7788,       1609,
    7789,       1609, 7790,       1613, 7791,       1613, 7792,       1617,
    7793,       1617, 7794,       1621, 7795,       1621, 7796,       1625,
    7797,       1625, 7798,       1629, 7799,       1629, 7800,       1633,
    7801,       1633, 7802,       1637, 7803,       1637, 7804,       1641,
    7805,       1641, 7806,       1645, 7807,       1645, 7808,       1649,
    7809,       1649, 7810,       1653, 7811,       1653, 7812,       1657,
    7813,       1657, 7814,       1661, 7815,       1661, 7816,       1665,
    7817,       1665, 7818,       1669, 7819,       1669, 7820,       1673,
    7821,       1673, 7822,       1677, 7823,       1677, 7824,       1681,
    7825,       1681, 7826,       1685, 7827,       1685, 7828,       1689,
    7829,       1689, 7835,       1585, 7840,       1693, 7841,       1693,
    7842,       1697, 7843,       1697, 7844,       1701, 7845,       1701,
    7846,       1705, 7847,       1705, 7848,       1709, 7849,       1709,
    7850,       1713, 7851,       1713, 7852,       1717, 7853,       1717,
    7854,       1721, 7855,       1721, 7856,       1725, 7857,       1725,
    7858,       1729, 7859,       1729, 7860,       1733, 7861,       1733,
    7862,       1737, 7863,       1737, 7864,       1741, 7865,       1741,
    7866,       1745, 7867,       1745, 7868,       1749, 7869,       1749,
    7870,       1753, 7871,       1753, 7872,       1757, 7873,       1757,
    7874,       1761, 7875,       1761, 7876,       1765, 7877,       1765,
    7878,       1769, 7879,       1769, 7880,       1773, 7881,       1773,
    7882,       1777, 7883,       1777, 7884,       1781, 7885,       1781,
    7886,       1785, 7887,       1785, 7888,       1789, 7889,       1789,
    7890,       1793, 7891,       1793, 7892,       1797, 7893,       1797,
    7894,       1801, 7895,       1801, 7896,       1805, 7897,       1805,
    7898,       1809, 7899,       1809, 7900,       1813, 7901,       1813,
    7902,       1817, 7903,       1817, 7904,       1821, 7905,       1821,
    7906,       1825, 7907,       1825, 7908,       1829, 7909,       1829,
    7910,       1833, 7911,       1833, 7912,       1837, 7913,       1837,
    7914,       1841, 7915,       1841, 7916,       1845, 7917,       1845,
    7918,       1849, 7919,       1849, 7920,       1853, 7921,       1853,
    7922,       1857, 7923,       1857, 7924,       1861, 7925,       1861,
    7926,       1865, 7927,       1865, 7928,       1869, 7929,       1869,
    7930,       1873, 7931,       1873, 7932,       1877, 7933,       1877,
    7934,       1881, 7935,       1881, 1073749760, 1885, 7943,       1889,
    1073749768, 1885, 7951,       1889, 1073749776, 1893, 7957,       1897,
    1073749784, 1893, 7965,       1897, 1073749792, 1901, 7975,       1905,
    1073749800, 1901, 7983,       1905, 1073749808, 1909, 7991,       1913,
    1073749816, 1909, 7999,       1913, 1073749824, 1917, 8005,       1921,
    1073749832, 1917, 8013,       1921, 8017,       1925, 8019,       1929,
    8021,       1933, 8023,       1937, 8025,       1925, 8027,       1929,
    8029,       1933, 8031,       1937, 1073749856, 1941, 8039,       1945,
    1073749864, 1941, 8047,       1945, 1073749872, 1949, 8049,       1953,
    1073749874, 1957, 8053,       1961, 1073749878, 1965, 8055,       1969,
    1073749880, 1973, 8057,       1977, 1073749882, 1981, 8059,       1985,
    1073749884, 1989, 8061,       1993, 1073749936, 1997, 8113,       2001,
    1073749944, 1997, 8121,       2001, 1073749946, 1949, 8123,       1953,
    8126,       749,  1073749960, 1957, 8139,       1961, 1073749968, 2005,
    8145,       2009, 1073749976, 2005, 8153,       2009, 1073749978, 1965,
    8155,       1969, 1073749984, 2013, 8161,       2017, 8165,       2021,
    1073749992, 2013, 8169,       2017, 1073749994, 1981, 8171,       1985,
    8172,       2021, 1073750008, 1973, 8185,       1977, 1073750010, 1989,
    8187,       1993};
static const uint16_t kEcma262UnCanonicalizeMultiStrings0Size = 507;
static const MultiCharacterSpecialCase<2>
    kEcma262UnCanonicalizeMultiStrings1[83] = {
        {{8498, 8526}},   {{8544, 8560}},   {{8559, 8575}},   {{8579, 8580}},
        {{9398, 9424}},   {{9423, 9449}},   {{11264, 11312}}, {{11310, 11358}},
        {{11360, 11361}}, {{619, 11362}},   {{7549, 11363}},  {{637, 11364}},
        {{570, 11365}},   {{574, 11366}},   {{11367, 11368}}, {{11369, 11370}},
        {{11371, 11372}}, {{593, 11373}},   {{625, 11374}},   {{592, 11375}},
        {{594, 11376}},   {{11378, 11379}}, {{11381, 11382}}, {{575, 11390}},
        {{576, 11391}},   {{11392, 11393}}, {{11394, 11395}}, {{11396, 11397}},
        {{11398, 11399}}, {{11400, 11401}}, {{11402, 11403}}, {{11404, 11405}},
        {{11406, 11407}}, {{11408, 11409}}, {{11410, 11411}}, {{11412, 11413}},
        {{11414, 11415}}, {{11416, 11417}}, {{11418, 11419}}, {{11420, 11421}},
        {{11422, 11423}}, {{11424, 11425}}, {{11426, 11427}}, {{11428, 11429}},
        {{11430, 11431}}, {{11432, 11433}}, {{11434, 11435}}, {{11436, 11437}},
        {{11438, 11439}}, {{11440, 11441}}, {{11442, 11443}}, {{11444, 11445}},
        {{11446, 11447}}, {{11448, 11449}}, {{11450, 11451}}, {{11452, 11453}},
        {{11454, 11455}}, {{11456, 11457}}, {{11458, 11459}}, {{11460, 11461}},
        {{11462, 11463}}, {{11464, 11465}}, {{11466, 11467}}, {{11468, 11469}},
        {{11470, 11471}}, {{11472, 11473}}, {{11474, 11475}}, {{11476, 11477}},
        {{11478, 11479}}, {{11480, 11481}}, {{11482, 11483}}, {{11484, 11485}},
        {{11486, 11487}}, {{11488, 11489}}, {{11490, 11491}}, {{11499, 11500}},
        {{11501, 11502}}, {{11506, 11507}}, {{4256, 11520}},  {{4293, 11557}},
        {{4295, 11559}},  {{4301, 11565}},  {{kSentinel}}};
static const uint16_t kEcma262UnCanonicalizeTable1Size = 149;
static const int32_t kEcma262UnCanonicalizeTable1[298] = {
    306,        1,   334,        1,   1073742176, 5,   367,  9,
    1073742192, 5,   383,        9,   387,        13,  388,  13,
    1073743030, 17,  1231,       21,  1073743056, 17,  1257, 21,
    1073744896, 25,  3118,       29,  1073744944, 25,  3166, 29,
    3168,       33,  3169,       33,  3170,       37,  3171, 41,
    3172,       45,  3173,       49,  3174,       53,  3175, 57,
    3176,       57,  3177,       61,  3178,       61,  3179, 65,
    3180,       65,  3181,       69,  3182,       73,  3183, 77,
    3184,       81,  3186,       85,  3187,       85,  3189, 89,
    3190,       89,  1073745022, 93,  3199,       97,  3200, 101,
    3201,       101, 3202,       105, 3203,       105, 3204, 109,
    3205,       109, 3206,       113, 3207,       113, 3208, 117,
    3209,       117, 3210,       121, 3211,       121, 3212, 125,
    3213,       125, 3214,       129, 3215,       129, 3216, 133,
    3217,       133, 3218,       137, 3219,       137, 3220, 141,
    3221,       141, 3222,       145, 3223,       145, 3224, 149,
    3225,       149, 3226,       153, 3227,       153, 3228, 157,
    3229,       157, 3230,       161, 3231,       161, 3232, 165,
    3233,       165, 3234,       169, 3235,       169, 3236, 173,
    3237,       173, 3238,       177, 3239,       177, 3240, 181,
    3241,       181, 3242,       185, 3243,       185, 3244, 189,
    3245,       189, 3246,       193, 3247,       193, 3248, 197,
    3249,       197, 3250,       201, 3251,       201, 3252, 205,
    3253,       205, 3254,       209, 3255,       209, 3256, 213,
    3257,       213, 3258,       217, 3259,       217, 3260, 221,
    3261,       221, 3262,       225, 3263,       225, 3264, 229,
    3265,       229, 3266,       233, 3267,       233, 3268, 237,
    3269,       237, 3270,       241, 3271,       241, 3272, 245,
    3273,       245, 3274,       249, 3275,       249, 3276, 253,
    3277,       253, 3278,       257, 3279,       257, 3280, 261,
    3281,       261, 3282,       265, 3283,       265, 3284, 269,
    3285,       269, 3286,       273, 3287,       273, 3288, 277,
    3289,       277, 3290,       281, 3291,       281, 3292, 285,
    3293,       285, 3294,       289, 3295,       289, 3296, 293,
    3297,       293, 3298,       297, 3299,       297, 3307, 301,
    3308,       301, 3309,       305, 3310,       305, 3314, 309,
    3315,       309, 1073745152, 313, 3365,       317, 3367, 321,
    3373,       325};
static const uint16_t kEcma262UnCanonicalizeMultiStrings1Size = 83;
static const MultiCharacterSpecialCase<2>
    kEcma262UnCanonicalizeMultiStrings5[104] = {
        {{42560, 42561}}, {{42562, 42563}}, {{42564, 42565}}, {{42566, 42567}},
        {{42568, 42569}}, {{42570, 42571}}, {{42572, 42573}}, {{42574, 42575}},
        {{42576, 42577}}, {{42578, 42579}}, {{42580, 42581}}, {{42582, 42583}},
        {{42584, 42585}}, {{42586, 42587}}, {{42588, 42589}}, {{42590, 42591}},
        {{42592, 42593}}, {{42594, 42595}}, {{42596, 42597}}, {{42598, 42599}},
        {{42600, 42601}}, {{42602, 42603}}, {{42604, 42605}}, {{42624, 42625}},
        {{42626, 42627}}, {{42628, 42629}}, {{42630, 42631}}, {{42632, 42633}},
        {{42634, 42635}}, {{42636, 42637}}, {{42638, 42639}}, {{42640, 42641}},
        {{42642, 42643}}, {{42644, 42645}}, {{42646, 42647}}, {{42648, 42649}},
        {{42650, 42651}}, {{42786, 42787}}, {{42788, 42789}}, {{42790, 42791}},
        {{42792, 42793}}, {{42794, 42795}}, {{42796, 42797}}, {{42798, 42799}},
        {{42802, 42803}}, {{42804, 42805}}, {{42806, 42807}}, {{42808, 42809}},
        {{42810, 42811}}, {{42812, 42813}}, {{42814, 42815}}, {{42816, 42817}},
        {{42818, 42819}}, {{42820, 42821}}, {{42822, 42823}}, {{42824, 42825}},
        {{42826, 42827}}, {{42828, 42829}}, {{42830, 42831}}, {{42832, 42833}},
        {{42834, 42835}}, {{42836, 42837}}, {{42838, 42839}}, {{42840, 42841}},
        {{42842, 42843}}, {{42844, 42845}}, {{42846, 42847}}, {{42848, 42849}},
        {{42850, 42851}}, {{42852, 42853}}, {{42854, 42855}}, {{42856, 42857}},
        {{42858, 42859}}, {{42860, 42861}}, {{42862, 42863}}, {{42873, 42874}},
        {{42875, 42876}}, {{7545, 42877}},  {{42878, 42879}}, {{42880, 42881}},
        {{42882, 42883}}, {{42884, 42885}}, {{42886, 42887}}, {{42891, 42892}},
        {{613, 42893}},   {{42896, 42897}}, {{42898, 42899}}, {{42902, 42903}},
        {{42904, 42905}}, {{42906, 42907}}, {{42908, 42909}}, {{42910, 42911}},
        {{42912, 42913}}, {{42914, 42915}}, {{42916, 42917}}, {{42918, 42919}},
        {{42920, 42921}}, {{614, 42922}},   {{604, 42923}},   {{609, 42924}},
        {{620, 42925}},   {{670, 42928}},   {{647, 42929}},   {{kSentinel}}};
static const uint16_t kEcma262UnCanonicalizeTable5Size = 198;
static const int32_t kEcma262UnCanonicalizeTable5[396] = {
    1600, 1,   1601, 1,   1602, 5,   1603, 5,   1604, 9,   1605, 9,   1606, 13,
    1607, 13,  1608, 17,  1609, 17,  1610, 21,  1611, 21,  1612, 25,  1613, 25,
    1614, 29,  1615, 29,  1616, 33,  1617, 33,  1618, 37,  1619, 37,  1620, 41,
    1621, 41,  1622, 45,  1623, 45,  1624, 49,  1625, 49,  1626, 53,  1627, 53,
    1628, 57,  1629, 57,  1630, 61,  1631, 61,  1632, 65,  1633, 65,  1634, 69,
    1635, 69,  1636, 73,  1637, 73,  1638, 77,  1639, 77,  1640, 81,  1641, 81,
    1642, 85,  1643, 85,  1644, 89,  1645, 89,  1664, 93,  1665, 93,  1666, 97,
    1667, 97,  1668, 101, 1669, 101, 1670, 105, 1671, 105, 1672, 109, 1673, 109,
    1674, 113, 1675, 113, 1676, 117, 1677, 117, 1678, 121, 1679, 121, 1680, 125,
    1681, 125, 1682, 129, 1683, 129, 1684, 133, 1685, 133, 1686, 137, 1687, 137,
    1688, 141, 1689, 141, 1690, 145, 1691, 145, 1826, 149, 1827, 149, 1828, 153,
    1829, 153, 1830, 157, 1831, 157, 1832, 161, 1833, 161, 1834, 165, 1835, 165,
    1836, 169, 1837, 169, 1838, 173, 1839, 173, 1842, 177, 1843, 177, 1844, 181,
    1845, 181, 1846, 185, 1847, 185, 1848, 189, 1849, 189, 1850, 193, 1851, 193,
    1852, 197, 1853, 197, 1854, 201, 1855, 201, 1856, 205, 1857, 205, 1858, 209,
    1859, 209, 1860, 213, 1861, 213, 1862, 217, 1863, 217, 1864, 221, 1865, 221,
    1866, 225, 1867, 225, 1868, 229, 1869, 229, 1870, 233, 1871, 233, 1872, 237,
    1873, 237, 1874, 241, 1875, 241, 1876, 245, 1877, 245, 1878, 249, 1879, 249,
    1880, 253, 1881, 253, 1882, 257, 1883, 257, 1884, 261, 1885, 261, 1886, 265,
    1887, 265, 1888, 269, 1889, 269, 1890, 273, 1891, 273, 1892, 277, 1893, 277,
    1894, 281, 1895, 281, 1896, 285, 1897, 285, 1898, 289, 1899, 289, 1900, 293,
    1901, 293, 1902, 297, 1903, 297, 1913, 301, 1914, 301, 1915, 305, 1916, 305,
    1917, 309, 1918, 313, 1919, 313, 1920, 317, 1921, 317, 1922, 321, 1923, 321,
    1924, 325, 1925, 325, 1926, 329, 1927, 329, 1931, 333, 1932, 333, 1933, 337,
    1936, 341, 1937, 341, 1938, 345, 1939, 345, 1942, 349, 1943, 349, 1944, 353,
    1945, 353, 1946, 357, 1947, 357, 1948, 361, 1949, 361, 1950, 365, 1951, 365,
    1952, 369, 1953, 369, 1954, 373, 1955, 373, 1956, 377, 1957, 377, 1958, 381,
    1959, 381, 1960, 385, 1961, 385, 1962, 389, 1963, 393, 1964, 397, 1965, 401,
    1968, 405, 1969, 409};
static const uint16_t kEcma262UnCanonicalizeMultiStrings5Size = 104;
static const MultiCharacterSpecialCase<2>
    kEcma262UnCanonicalizeMultiStrings7[3] = {
        {{65313, 65345}}, {{65338, 65370}}, {{kSentinel}}};
static const uint16_t kEcma262UnCanonicalizeTable7Size = 4;
static const int32_t kEcma262UnCanonicalizeTable7[8] = {1073749793, 1, 7994, 5,
                                                        1073749825, 1, 8026, 5};
static const uint16_t kEcma262UnCanonicalizeMultiStrings7Size = 3;
int Ecma262UnCanonicalize::Convert(uchar c, uchar n, uchar* result,
                                   bool* allow_caching_ptr) {
  int chunk_index = c >> 13;
  switch (chunk_index) {
    case 0:
      return LookupMapping<true>(
          kEcma262UnCanonicalizeTable0, kEcma262UnCanonicalizeTable0Size,
          kEcma262UnCanonicalizeMultiStrings0, c, n, result, allow_caching_ptr);
    case 1:
      return LookupMapping<true>(
          kEcma262UnCanonicalizeTable1, kEcma262UnCanonicalizeTable1Size,
          kEcma262UnCanonicalizeMultiStrings1, c, n, result, allow_caching_ptr);
    case 5:
      return LookupMapping<true>(
          kEcma262UnCanonicalizeTable5, kEcma262UnCanonicalizeTable5Size,
          kEcma262UnCanonicalizeMultiStrings5, c, n, result, allow_caching_ptr);
    case 7:
      return LookupMapping<true>(
          kEcma262UnCanonicalizeTable7, kEcma262UnCanonicalizeTable7Size,
          kEcma262UnCanonicalizeMultiStrings7, c, n, result, allow_caching_ptr);
    default:
      return 0;
  }
}

static const MultiCharacterSpecialCase<1>
    kCanonicalizationRangeMultiStrings0[1] = {{{kSentinel}}};
static const uint16_t kCanonicalizationRangeTable0Size = 70;
static const int32_t kCanonicalizationRangeTable0[140] = {
    1073741889, 100, 90,   0, 1073741921, 100, 122,  0,
    1073742016, 88,  214,  0, 1073742040, 24,  222,  0,
    1073742048, 88,  246,  0, 1073742072, 24,  254,  0,
    1073742715, 8,   893,  0, 1073742728, 8,   906,  0,
    1073742749, 8,   927,  0, 1073742759, 16,  939,  0,
    1073742765, 8,   943,  0, 1073742781, 8,   959,  0,
    1073742791, 16,  971,  0, 1073742845, 8,   1023, 0,
    1073742848, 60,  1039, 0, 1073742864, 124, 1071, 0,
    1073742896, 124, 1103, 0, 1073742928, 60,  1119, 0,
    1073743153, 148, 1366, 0, 1073743201, 148, 1414, 0,
    1073746080, 148, 4293, 0, 1073749760, 28,  7943, 0,
    1073749768, 28,  7951, 0, 1073749776, 20,  7957, 0,
    1073749784, 20,  7965, 0, 1073749792, 28,  7975, 0,
    1073749800, 28,  7983, 0, 1073749808, 28,  7991, 0,
    1073749816, 28,  7999, 0, 1073749824, 20,  8005, 0,
    1073749832, 20,  8013, 0, 1073749856, 28,  8039, 0,
    1073749864, 28,  8047, 0, 1073749874, 12,  8053, 0,
    1073749960, 12,  8139, 0};
static const uint16_t kCanonicalizationRangeMultiStrings0Size = 1;
static const MultiCharacterSpecialCase<1>
    kCanonicalizationRangeMultiStrings1[1] = {{{kSentinel}}};
static const uint16_t kCanonicalizationRangeTable1Size = 14;
static const int32_t kCanonicalizationRangeTable1[28] = {
    1073742176, 60,  367,  0, 1073742192, 60,  383,  0,
    1073743030, 100, 1231, 0, 1073743056, 100, 1257, 0,
    1073744896, 184, 3118, 0, 1073744944, 184, 3166, 0,
    1073745152, 148, 3365, 0};
static const uint16_t kCanonicalizationRangeMultiStrings1Size = 1;
static const MultiCharacterSpecialCase<1>
    kCanonicalizationRangeMultiStrings7[1] = {{{kSentinel}}};
static const uint16_t kCanonicalizationRangeTable7Size = 4;
static const int32_t kCanonicalizationRangeTable7[8] = {
    1073749793, 100, 7994, 0, 1073749825, 100, 8026, 0};
static const uint16_t kCanonicalizationRangeMultiStrings7Size = 1;
int CanonicalizationRange::Convert(uchar c, uchar n, uchar* result,
                                   bool* allow_caching_ptr) {
  int chunk_index = c >> 13;
  switch (chunk_index) {
    case 0:
      return LookupMapping<false>(
          kCanonicalizationRangeTable0, kCanonicalizationRangeTable0Size,
          kCanonicalizationRangeMultiStrings0, c, n, result, allow_caching_ptr);
    case 1:
      return LookupMapping<false>(
          kCanonicalizationRangeTable1, kCanonicalizationRangeTable1Size,
          kCanonicalizationRangeMultiStrings1, c, n, result, allow_caching_ptr);
    case 7:
      return LookupMapping<false>(
          kCanonicalizationRangeTable7, kCanonicalizationRangeTable7Size,
          kCanonicalizationRangeMultiStrings7, c, n, result, allow_caching_ptr);
    default:
      return 0;
  }
}

const uchar UnicodeData::kMaxCodePoint = 0xFFFD;

int UnicodeData::GetByteCount() {
  return kUppercaseTable0Size * sizeof(int32_t) +
         kUppercaseTable1Size * sizeof(int32_t) +
         kUppercaseTable5Size * sizeof(int32_t) +
         kUppercaseTable7Size * sizeof(int32_t) +
         kLetterTable0Size * sizeof(int32_t) +
         kLetterTable1Size * sizeof(int32_t) +
         kLetterTable2Size * sizeof(int32_t) +
         kLetterTable3Size * sizeof(int32_t) +
         kLetterTable4Size * sizeof(int32_t) +
         kLetterTable5Size * sizeof(int32_t) +
         kLetterTable6Size * sizeof(int32_t) +
         kLetterTable7Size * sizeof(int32_t) +
         kID_StartTable0Size * sizeof(int32_t) +
         kID_StartTable1Size * sizeof(int32_t) +
         kID_StartTable2Size * sizeof(int32_t) +
         kID_StartTable3Size * sizeof(int32_t) +
         kID_StartTable4Size * sizeof(int32_t) +
         kID_StartTable5Size * sizeof(int32_t) +
         kID_StartTable6Size * sizeof(int32_t) +
         kID_StartTable7Size * sizeof(int32_t) +
         kID_ContinueTable0Size * sizeof(int32_t) +
         kID_ContinueTable1Size * sizeof(int32_t) +
         kID_ContinueTable5Size * sizeof(int32_t) +
         kID_ContinueTable7Size * sizeof(int32_t) +
         kWhiteSpaceTable0Size * sizeof(int32_t) +
         kWhiteSpaceTable1Size * sizeof(int32_t) +
         kWhiteSpaceTable7Size * sizeof(int32_t) +
         kToLowercaseMultiStrings0Size * sizeof(MultiCharacterSpecialCase<2>) +
         kToLowercaseMultiStrings1Size * sizeof(MultiCharacterSpecialCase<1>) +
         kToLowercaseMultiStrings5Size * sizeof(MultiCharacterSpecialCase<1>) +
         kToLowercaseMultiStrings7Size * sizeof(MultiCharacterSpecialCase<1>) +
         kToUppercaseMultiStrings0Size * sizeof(MultiCharacterSpecialCase<3>) +
         kToUppercaseMultiStrings1Size * sizeof(MultiCharacterSpecialCase<1>) +
         kToUppercaseMultiStrings5Size * sizeof(MultiCharacterSpecialCase<1>) +
         kToUppercaseMultiStrings7Size * sizeof(MultiCharacterSpecialCase<3>) +
         kEcma262CanonicalizeMultiStrings0Size *
             sizeof(MultiCharacterSpecialCase<1>) +
         kEcma262CanonicalizeMultiStrings1Size *
             sizeof(MultiCharacterSpecialCase<1>) +
         kEcma262CanonicalizeMultiStrings5Size *
             sizeof(MultiCharacterSpecialCase<1>) +
         kEcma262CanonicalizeMultiStrings7Size *
             sizeof(MultiCharacterSpecialCase<1>) +
         kEcma262UnCanonicalizeMultiStrings0Size *
             sizeof(MultiCharacterSpecialCase<4>) +
         kEcma262UnCanonicalizeMultiStrings1Size *
             sizeof(MultiCharacterSpecialCase<2>) +
         kEcma262UnCanonicalizeMultiStrings5Size *
             sizeof(MultiCharacterSpecialCase<2>) +
         kEcma262UnCanonicalizeMultiStrings7Size *
             sizeof(MultiCharacterSpecialCase<2>) +
         kCanonicalizationRangeMultiStrings0Size *
             sizeof(MultiCharacterSpecialCase<1>) +
         kCanonicalizationRangeMultiStrings1Size *
             sizeof(MultiCharacterSpecialCase<1>) +
         kCanonicalizationRangeMultiStrings7Size *
             sizeof(MultiCharacterSpecialCase<1>);
}
#endif  // !V8_INTL_SUPPORT

}  // namespace unibrow
                                                                                       node-23.7.0/deps/v8/src/strings/unicode.h                                                           0000664 0000000 0000000 00000024642 14746647661 0020134 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2011 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_STRINGS_UNICODE_H_
#define V8_STRINGS_UNICODE_H_

#include <sys/types.h>

#include "src/base/bit-field.h"
#include "src/base/vector.h"
#include "src/common/globals.h"
#include "src/third_party/utf8-decoder/utf8-decoder.h"
/**
 * \file
 * Definitions and convenience functions for working with unicode.
 */

namespace unibrow {

using uchar = unsigned int;

/**
 * The max length of the result of converting the case of a single
 * character.
 */
const int kMaxMappingSize = 4;

#ifndef V8_INTL_SUPPORT
template <class T, int size = 256>
class Predicate {
 public:
  inline Predicate() = default;
  inline bool get(uchar c);

 private:
  friend class Test;
  bool CalculateValue(uchar c);
  class CacheEntry {
   public:
    inline CacheEntry()
        : bit_field_(CodePointField::encode(0) | ValueField::encode(0)) {}
    inline CacheEntry(uchar code_point, bool value)
        : bit_field_(
              CodePointField::encode(CodePointField::kMask & code_point) |
              ValueField::encode(value)) {
      DCHECK_IMPLIES((CodePointField::kMask & code_point) != code_point,
                     code_point == static_cast<uchar>(-1));
    }

    uchar code_point() const { return CodePointField::decode(bit_field_); }
    bool value() const { return ValueField::decode(bit_field_); }

   private:
    using CodePointField = v8::base::BitField<uchar, 0, 21>;
    using ValueField = v8::base::BitField<bool, 21, 1>;

    uint32_t bit_field_;
  };
  static const int kSize = size;
  static const int kMask = kSize - 1;
  CacheEntry entries_[kSize];
};

// A cache used in case conversion.  It caches the value for characters
// that either have no mapping or map to a single character independent
// of context.  Characters that map to more than one character or that
// map differently depending on context are always looked up.
template <class T, int size = 256>
class Mapping {
 public:
  inline Mapping() = default;
  inline int get(uchar c, uchar n, uchar* result);

 private:
  friend class Test;
  int CalculateValue(uchar c, uchar n, uchar* result);
  struct CacheEntry {
    inline CacheEntry() : code_point_(kNoChar), offset_(0) {}
    inline CacheEntry(uchar code_point, signed offset)
        : code_point_(code_point), offset_(offset) {}
    uchar code_point_;
    signed offset_;
    static const int kNoChar = (1 << 21) - 1;
  };
  static const int kSize = size;
  static const int kMask = kSize - 1;
  CacheEntry entries_[kSize];
};

class UnicodeData {
 private:
  friend class Test;
  static int GetByteCount();
  static const uchar kMaxCodePoint;
};

#endif  // !V8_INTL_SUPPORT

class Utf16 {
 public:
  static const int kNoPreviousCharacter = -1;
  static inline bool IsSurrogatePair(int lead, int trail) {
    return IsLeadSurrogate(lead) && IsTrailSurrogate(trail);
  }
  static inline bool IsLeadSurrogate(int code) {
    return (code & 0x1ffc00) == 0xd800;
  }
  static inline bool IsTrailSurrogate(int code) {
    return (code & 0x1ffc00) == 0xdc00;
  }

  static inline int CombineSurrogatePair(uchar lead, uchar trail) {
    return 0x10000 + ((lead & 0x3ff) << 10) + (trail & 0x3ff);
  }
  static const uchar kMaxNonSurrogateCharCode = 0xffff;
  // Encoding a single UTF-16 code unit will produce 1, 2 or 3 bytes
  // of UTF-8 data.  The special case where the unit is a surrogate
  // trail produces 1 byte net, because the encoding of the pair is
  // 4 bytes and the 3 bytes that were used to encode the lead surrogate
  // can be reclaimed.
  static const int kMaxExtraUtf8BytesForOneUtf16CodeUnit = 3;
  // One UTF-16 surrogate is encoded (illegally) as 3 UTF-8 bytes.
  // The illegality stems from the surrogate not being part of a pair.
  static const int kUtf8BytesToCodeASurrogate = 3;
  static inline uint16_t LeadSurrogate(uint32_t char_code) {
    return 0xd800 + (((char_code - 0x10000) >> 10) & 0x3ff);
  }
  static inline uint16_t TrailSurrogate(uint32_t char_code) {
    return 0xdc00 + (char_code & 0x3ff);
  }
  static inline bool HasUnpairedSurrogate(const uint16_t* code_units,
                                          size_t length);

  static void ReplaceUnpairedSurrogates(const uint16_t* source_code_units,
                                        uint16_t* dest_code_units,
                                        size_t length);
};

class Latin1 {
 public:
  static const uint16_t kMaxChar = 0xff;
  // Convert the character to Latin-1 case equivalent if possible.
  static inline uint16_t TryConvertToLatin1(uint16_t c) {
    switch (c) {
      // This are equivalent characters in unicode.
      case 0x39c:
      case 0x3bc:
        return 0xb5;
      // This is an uppercase of a Latin-1 character
      // outside of Latin-1.
      case 0x178:
        return 0xff;
    }
    return c;
  }
};

enum class Utf8Variant : uint8_t {
#if V8_ENABLE_WEBASSEMBLY
  kUtf8,        // UTF-8.  Decoding an invalid byte sequence or encoding a
                // surrogate codepoint signals an error.
  kUtf8NoTrap,  // UTF-8.  Decoding an invalid byte sequence or encoding a
                // surrogate codepoint returns null.
  kWtf8,        // WTF-8: like UTF-8, but allows isolated (but not paired)
                // surrogate codepoints to be encoded and decoded.
#endif
  kLossyUtf8,  // Lossy UTF-8: Any byte sequence can be decoded without
               // error, replacing invalid UTF-8 with the replacement
               // character (U+FFFD).  Any sequence of codepoints can be
               // encoded without error, replacing surrogates with U+FFFD.
  kLastUtf8Variant = kLossyUtf8
};

class V8_EXPORT_PRIVATE Utf8 {
 public:
  using State = Utf8DfaDecoder::State;

  static inline uchar Length(uchar chr, int previous);
  static inline unsigned EncodeOneByte(char* out, uint8_t c);
  static inline unsigned Encode(char* out, uchar c, int previous,
                                bool replace_invalid = false);
  static uchar CalculateValue(const uint8_t* str, size_t length,
                              size_t* cursor);

  // The unicode replacement character, used to signal invalid unicode
  // sequences (e.g. an orphan surrogate) when converting to a UTF-8 encoding.
  static const uchar kBadChar = 0xFFFD;
  static const uchar kBufferEmpty = 0x0;
  static const uchar kIncomplete = 0xFFFFFFFC;  // any non-valid code point.
  static const unsigned kMaxEncodedSize = 4;
  static const unsigned kMaxOneByteChar = 0x7f;
  static const unsigned kMaxTwoByteChar = 0x7ff;
  static const unsigned kMaxThreeByteChar = 0xffff;
  static const unsigned kMaxFourByteChar = 0x1fffff;

  // A single surrogate is coded as a 3 byte UTF-8 sequence, but two together
  // that match are coded as a 4 byte UTF-8 sequence.
  static const unsigned kBytesSavedByCombiningSurrogates = 2;
  static const unsigned kSizeOfUnmatchedSurrogate = 3;
  // The maximum size a single UTF-16 code unit may take up when encoded as
  // UTF-8.
  static const unsigned kMax16BitCodeUnitSize = 3;
  // The maximum size a single UTF-16 code unit known to be in the range
  // [0,0xff] may take up when encoded as UTF-8.
  static const unsigned kMax8BitCodeUnitSize = 2;
  static inline uchar ValueOf(const uint8_t* str, size_t length,
                              size_t* cursor);

  using Utf8IncrementalBuffer = uint32_t;
  static inline uchar ValueOfIncremental(const uint8_t** cursor, State* state,
                                         Utf8IncrementalBuffer* buffer);
  static uchar ValueOfIncrementalFinish(State* state);

  // Excludes non-characters from the set of valid code points.
  static inline bool IsValidCharacter(uchar c);

  // Validate if the input has a valid utf-8 encoding. Unlike JS source code
  // this validation function will accept any unicode code point, including
  // kBadChar and BOMs.
  //
  // This method checks for:
  // - valid utf-8 endcoding (e.g. no over-long encodings),
  // - absence of surrogates,
  // - valid code point range.
  static bool ValidateEncoding(const uint8_t* str, size_t length);
};

#if V8_ENABLE_WEBASSEMBLY
class V8_EXPORT_PRIVATE Wtf8 {
 public:
  // Validate that the input has a valid WTF-8 encoding.
  //
  // This method checks for:
  // - valid utf-8 endcoding (e.g. no over-long encodings),
  // - absence of surrogate pairs,
  // - valid code point range.
  //
  // In terms of the WTF-8 specification (https://simonsapin.github.io/wtf-8/),
  // this function checks for a valid "generalized UTF-8" sequence, with the
  // additional constraint that surrogate pairs are not allowed.
  static bool ValidateEncoding(const uint8_t* str, size_t length);

  static void ScanForSurrogates(v8::base::Vector<const uint8_t> wtf8,
                                std::vector<size_t>* surrogate_offsets);
};
#endif  // V8_ENABLE_WEBASSEMBLY

struct Uppercase {
  static bool Is(uchar c);
};
struct Letter {
  static bool Is(uchar c);
};
#ifndef V8_INTL_SUPPORT
struct V8_EXPORT_PRIVATE ID_Start {
  static bool Is(uchar c);
};
struct V8_EXPORT_PRIVATE ID_Continue {
  static bool Is(uchar c);
};
struct V8_EXPORT_PRIVATE WhiteSpace {
  static bool Is(uchar c);
};
#endif  // !V8_INTL_SUPPORT

// LineTerminator:       'JS_Line_Terminator' in point.properties
// ES#sec-line-terminators lists exactly 4 code points:
// LF (U+000A), CR (U+000D), LS(U+2028), PS(U+2029)
V8_INLINE bool IsLineTerminator(uchar c) {
  return c == 0x000A || c == 0x000D || c == 0x2028 || c == 0x2029;
}

V8_INLINE bool IsStringLiteralLineTerminator(uchar c) {
  return c == 0x000A || c == 0x000D;
}

#ifndef V8_INTL_SUPPORT
struct V8_EXPORT_PRIVATE ToLowercase {
  static const int kMaxWidth = 3;
  static const bool kIsToLower = true;
  static int Convert(uchar c, uchar n, uchar* result, bool* allow_caching_ptr);
};
struct V8_EXPORT_PRIVATE ToUppercase {
  static const int kMaxWidth = 3;
  static const bool kIsToLower = false;
  static int Convert(uchar c, uchar n, uchar* result, bool* allow_caching_ptr);
};
struct V8_EXPORT_PRIVATE Ecma262Canonicalize {
  static const int kMaxWidth = 1;
  static int Convert(uchar c, uchar n, uchar* result, bool* allow_caching_ptr);
};
struct V8_EXPORT_PRIVATE Ecma262UnCanonicalize {
  static const int kMaxWidth = 4;
  static int Convert(uchar c, uchar n, uchar* result, bool* allow_caching_ptr);
};
struct V8_EXPORT_PRIVATE CanonicalizationRange {
  static const int kMaxWidth = 1;
  static int Convert(uchar c, uchar n, uchar* result, bool* allow_caching_ptr);
};
#endif  // !V8_INTL_SUPPORT

}  // namespace unibrow

#endif  // V8_STRINGS_UNICODE_H_
                                                                                              node-23.7.0/deps/v8/src/strings/uri.cc                                                              0000664 0000000 0000000 00000037337 14746647661 0017450 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/strings/uri.h"

#include <vector>

#include "src/execution/isolate-inl.h"
#include "src/strings/char-predicates-inl.h"
#include "src/strings/string-search.h"
#include "src/strings/unicode-inl.h"

namespace v8 {
namespace internal {

namespace {  // anonymous namespace for DecodeURI helper functions
bool IsReservedPredicate(base::uc16 c) {
  switch (c) {
    case '#':
    case '$':
    case '&':
    case '+':
    case ',':
    case '/':
    case ':':
    case ';':
    case '=':
    case '?':
    case '@':
      return true;
    default:
      return false;
  }
}

bool IsReplacementCharacter(const uint8_t* octets, int length) {
  // The replacement character is at codepoint U+FFFD in the Unicode Specials
  // table. Its UTF-8 encoding is 0xEF 0xBF 0xBD.
  if (length != 3 || octets[0] != 0xEF || octets[1] != 0xBF ||
      octets[2] != 0xBD) {
    return false;
  }
  return true;
}

bool DecodeOctets(const uint8_t* octets, int length,
                  std::vector<base::uc16>* buffer) {
  size_t cursor = 0;
  base::uc32 value = unibrow::Utf8::ValueOf(octets, length, &cursor);
  if (value == unibrow::Utf8::kBadChar &&
      !IsReplacementCharacter(octets, length)) {
    return false;
  }

  if (value <=
      static_cast<base::uc32>(unibrow::Utf16::kMaxNonSurrogateCharCode)) {
    buffer->push_back(value);
  } else {
    buffer->push_back(unibrow::Utf16::LeadSurrogate(value));
    buffer->push_back(unibrow::Utf16::TrailSurrogate(value));
  }
  return true;
}

int TwoDigitHex(base::uc16 character1, base::uc16 character2) {
  if (character1 > 'f') return -1;
  int high = base::HexValue(character1);
  if (high == -1) return -1;
  if (character2 > 'f') return -1;
  int low = base::HexValue(character2);
  if (low == -1) return -1;
  return (high << 4) + low;
}

template <typename T>
void AddToBuffer(base::uc16 decoded, String::FlatContent* uri_content,
                 int index, bool is_uri, std::vector<T>* buffer) {
  if (is_uri && IsReservedPredicate(decoded)) {
    buffer->push_back('%');
    base::uc16 first = uri_content->Get(index + 1);
    base::uc16 second = uri_content->Get(index + 2);
    DCHECK_GT(std::numeric_limits<T>::max(), first);
    DCHECK_GT(std::numeric_limits<T>::max(), second);

    buffer->push_back(first);
    buffer->push_back(second);
  } else {
    buffer->push_back(decoded);
  }
}

bool IntoTwoByte(int index, bool is_uri, int uri_length,
                 String::FlatContent* uri_content,
                 std::vector<base::uc16>* buffer) {
  for (int k = index; k < uri_length; k++) {
    base::uc16 code = uri_content->Get(k);
    if (code == '%') {
      int two_digits;
      if (k + 2 >= uri_length ||
          (two_digits = TwoDigitHex(uri_content->Get(k + 1),
                                    uri_content->Get(k + 2))) < 0) {
        return false;
      }
      k += 2;
      base::uc16 decoded = static_cast<base::uc16>(two_digits);
      if (decoded > unibrow::Utf8::kMaxOneByteChar) {
        uint8_t octets[unibrow::Utf8::kMaxEncodedSize];
        octets[0] = decoded;

        int number_of_continuation_bytes = 0;
        while ((decoded << ++number_of_continuation_bytes) & 0x80) {
          if (number_of_continuation_bytes > 3 || k + 3 >= uri_length) {
            return false;
          }
          if (uri_content->Get(++k) != '%' ||
              (two_digits = TwoDigitHex(uri_content->Get(k + 1),
                                        uri_content->Get(k + 2))) < 0) {
            return false;
          }
          k += 2;
          base::uc16 continuation_byte = static_cast<base::uc16>(two_digits);
          octets[number_of_continuation_bytes] = continuation_byte;
        }

        if (!DecodeOctets(octets, number_of_continuation_bytes, buffer)) {
          return false;
        }
      } else {
        AddToBuffer(decoded, uri_content, k - 2, is_uri, buffer);
      }
    } else {
      buffer->push_back(code);
    }
  }
  return true;
}

bool IntoOneAndTwoByte(DirectHandle<String> uri, bool is_uri,
                       std::vector<uint8_t>* one_byte_buffer,
                       std::vector<base::uc16>* two_byte_buffer) {
  DisallowGarbageCollection no_gc;
  String::FlatContent uri_content = uri->GetFlatContent(no_gc);

  int uri_length = uri->length();
  for (int k = 0; k < uri_length; k++) {
    base::uc16 code = uri_content.Get(k);
    if (code == '%') {
      int two_digits;
      if (k + 2 >= uri_length ||
          (two_digits = TwoDigitHex(uri_content.Get(k + 1),
                                    uri_content.Get(k + 2))) < 0) {
        return false;
      }

      base::uc16 decoded = static_cast<base::uc16>(two_digits);
      if (decoded > unibrow::Utf8::kMaxOneByteChar) {
        return IntoTwoByte(k, is_uri, uri_length, &uri_content,
                           two_byte_buffer);
      }

      AddToBuffer(decoded, &uri_content, k, is_uri, one_byte_buffer);
      k += 2;
    } else {
      if (code > unibrow::Utf8::kMaxOneByteChar) {
        return IntoTwoByte(k, is_uri, uri_length, &uri_content,
                           two_byte_buffer);
      }
      one_byte_buffer->push_back(code);
    }
  }
  return true;
}

}  // anonymous namespace

MaybeHandle<String> Uri::Decode(Isolate* isolate, Handle<String> uri,
                                bool is_uri) {
  uri = String::Flatten(isolate, uri);
  std::vector<uint8_t> one_byte_buffer;
  std::vector<base::uc16> two_byte_buffer;

  if (!IntoOneAndTwoByte(uri, is_uri, &one_byte_buffer, &two_byte_buffer)) {
    THROW_NEW_ERROR(isolate, NewURIError());
  }

  if (two_byte_buffer.empty()) {
    return isolate->factory()->NewStringFromOneByte(base::Vector<const uint8_t>(
        one_byte_buffer.data(), static_cast<int>(one_byte_buffer.size())));
  }

  Handle<SeqTwoByteString> result;
  int result_length =
      static_cast<int>(one_byte_buffer.size() + two_byte_buffer.size());
  ASSIGN_RETURN_ON_EXCEPTION(
      isolate, result, isolate->factory()->NewRawTwoByteString(result_length));

  DisallowGarbageCollection no_gc;
  base::uc16* chars = result->GetChars(no_gc);
  if (!one_byte_buffer.empty()) {
    CopyChars(chars, one_byte_buffer.data(), one_byte_buffer.size());
    chars += one_byte_buffer.size();
  }
  if (!two_byte_buffer.empty()) {
    CopyChars(chars, two_byte_buffer.data(), two_byte_buffer.size());
  }

  return result;
}

namespace {  // anonymous namespace for EncodeURI helper functions
bool IsUnescapePredicateInUriComponent(base::uc16 c) {
  if (IsAlphaNumeric(c)) {
    return true;
  }

  switch (c) {
    case '!':
    case '\'':
    case '(':
    case ')':
    case '*':
    case '-':
    case '.':
    case '_':
    case '~':
      return true;
    default:
      return false;
  }
}

bool IsUriSeparator(base::uc16 c) {
  switch (c) {
    case '#':
    case ':':
    case ';':
    case '/':
    case '?':
    case '$':
    case '&':
    case '+':
    case ',':
    case '@':
    case '=':
      return true;
    default:
      return false;
  }
}

void AddEncodedOctetToBuffer(uint8_t octet, std::vector<uint8_t>* buffer) {
  buffer->push_back('%');
  buffer->push_back(base::HexCharOfValue(octet >> 4));
  buffer->push_back(base::HexCharOfValue(octet & 0x0F));
}

void EncodeSingle(base::uc16 c, std::vector<uint8_t>* buffer) {
  char s[4] = {};
  int number_of_bytes;
  number_of_bytes =
      unibrow::Utf8::Encode(s, c, unibrow::Utf16::kNoPreviousCharacter, false);
  for (int k = 0; k < number_of_bytes; k++) {
    AddEncodedOctetToBuffer(s[k], buffer);
  }
}

void EncodePair(base::uc16 cc1, base::uc16 cc2, std::vector<uint8_t>* buffer) {
  char s[4] = {};
  int number_of_bytes =
      unibrow::Utf8::Encode(s, unibrow::Utf16::CombineSurrogatePair(cc1, cc2),
                            unibrow::Utf16::kNoPreviousCharacter, false);
  for (int k = 0; k < number_of_bytes; k++) {
    AddEncodedOctetToBuffer(s[k], buffer);
  }
}

}  // anonymous namespace

MaybeHandle<String> Uri::Encode(Isolate* isolate, Handle<String> uri,
                                bool is_uri) {
  uri = String::Flatten(isolate, uri);
  int uri_length = uri->length();
  std::vector<uint8_t> buffer;
  buffer.reserve(uri_length);

  bool throw_error = false;
  {
    DisallowGarbageCollection no_gc;
    String::FlatContent uri_content = uri->GetFlatContent(no_gc);

    for (int k = 0; k < uri_length; k++) {
      base::uc16 cc1 = uri_content.Get(k);
      if (unibrow::Utf16::IsLeadSurrogate(cc1)) {
        k++;
        if (k < uri_length) {
          base::uc16 cc2 = uri->Get(k);
          if (unibrow::Utf16::IsTrailSurrogate(cc2)) {
            EncodePair(cc1, cc2, &buffer);
            continue;
          }
        }
      } else if (!unibrow::Utf16::IsTrailSurrogate(cc1)) {
        if (IsUnescapePredicateInUriComponent(cc1) ||
            (is_uri && IsUriSeparator(cc1))) {
          buffer.push_back(cc1);
        } else {
          EncodeSingle(cc1, &buffer);
        }
        continue;
      }

      // String::FlatContent DCHECKs its contents did not change during its
      // lifetime. Throwing the error inside the loop may cause GC and move the
      // string contents.
      throw_error = true;
      break;
    }
  }

  if (throw_error) THROW_NEW_ERROR(isolate, NewURIError());
  return isolate->factory()->NewStringFromOneByte(base::VectorOf(buffer));
}

namespace {  // Anonymous namespace for Escape and Unescape

template <typename Char>
int UnescapeChar(base::Vector<const Char> vector, int i, int length,
                 int* step) {
  uint16_t character = vector[i];
  int32_t hi = 0;
  int32_t lo = 0;
  if (character == '%' && i <= length - 6 && vector[i + 1] == 'u' &&
      (hi = TwoDigitHex(vector[i + 2], vector[i + 3])) > -1 &&
      (lo = TwoDigitHex(vector[i + 4], vector[i + 5])) > -1) {
    *step = 6;
    return (hi << 8) + lo;
  } else if (character == '%' && i <= length - 3 &&
             (lo = TwoDigitHex(vector[i + 1], vector[i + 2])) > -1) {
    *step = 3;
    return lo;
  } else {
    *step = 1;
    return character;
  }
}

template <typename Char>
MaybeHandle<String> UnescapeSlow(Isolate* isolate, Handle<String> string,
                                 int start_index) {
  bool one_byte = true;
  int length = string->length();

  int unescaped_length = 0;
  {
    DisallowGarbageCollection no_gc;
    base::Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
    for (int i = start_index; i < length; unescaped_length++) {
      int step;
      if (UnescapeChar(vector, i, length, &step) >
          String::kMaxOneByteCharCode) {
        one_byte = false;
      }
      i += step;
    }
  }

  DCHECK(start_index < length);
  Handle<String> first_part =
      isolate->factory()->NewProperSubString(string, 0, start_index);

  int dest_position = 0;
  Handle<String> second_part;
  DCHECK_LE(unescaped_length, String::kMaxLength);
  if (one_byte) {
    Handle<SeqOneByteString> dest = isolate->factory()
                                        ->NewRawOneByteString(unescaped_length)
                                        .ToHandleChecked();
    DisallowGarbageCollection no_gc;
    base::Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
    for (int i = start_index; i < length; dest_position++) {
      int step;
      dest->SeqOneByteStringSet(dest_position,
                                UnescapeChar(vector, i, length, &step));
      i += step;
    }
    second_part = dest;
  } else {
    Handle<SeqTwoByteString> dest = isolate->factory()
                                        ->NewRawTwoByteString(unescaped_length)
                                        .ToHandleChecked();
    DisallowGarbageCollection no_gc;
    base::Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
    for (int i = start_index; i < length; dest_position++) {
      int step;
      dest->SeqTwoByteStringSet(dest_position,
                                UnescapeChar(vector, i, length, &step));
      i += step;
    }
    second_part = dest;
  }
  return isolate->factory()->NewConsString(first_part, second_part);
}

bool IsNotEscaped(uint16_t c) {
  if (IsAlphaNumeric(c)) {
    return true;
  }
  //  @*_+-./
  switch (c) {
    case '@':
    case '*':
    case '_':
    case '+':
    case '-':
    case '.':
    case '/':
      return true;
    default:
      return false;
  }
}

template <typename Char>
static MaybeHandle<String> UnescapePrivate(Isolate* isolate,
                                           Handle<String> source) {
  int index;
  {
    DisallowGarbageCollection no_gc;
    StringSearch<uint8_t, Char> search(isolate, base::StaticOneByteVector("%"));
    index = search.Search(source->GetCharVector<Char>(no_gc), 0);
    if (index < 0) return source;
  }
  return UnescapeSlow<Char>(isolate, source, index);
}

template <typename Char>
static MaybeHandle<String> EscapePrivate(Isolate* isolate,
                                         Handle<String> string) {
  DCHECK(string->IsFlat());
  int escaped_length = 0;
  int length = string->length();

  {
    DisallowGarbageCollection no_gc;
    base::Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
    for (int i = 0; i < length; i++) {
      uint16_t c = vector[i];
      if (c >= 256) {
        escaped_length += 6;
      } else if (IsNotEscaped(c)) {
        escaped_length++;
      } else {
        escaped_length += 3;
      }

      // We don't allow strings that are longer than a maximal length.
      DCHECK_LT(String::kMaxLength, 0x7FFFFFFF - 6);   // Cannot overflow.
      if (escaped_length > String::kMaxLength) break;  // Provoke exception.
    }
  }

  // No length change implies no change.  Return original string if no change.
  if (escaped_length == length) return string;

  Handle<SeqOneByteString> dest;
  ASSIGN_RETURN_ON_EXCEPTION(
      isolate, dest, isolate->factory()->NewRawOneByteString(escaped_length));
  int dest_position = 0;

  {
    DisallowGarbageCollection no_gc;
    base::Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
    for (int i = 0; i < length; i++) {
      uint16_t c = vector[i];
      if (c >= 256) {
        dest->SeqOneByteStringSet(dest_position, '%');
        dest->SeqOneByteStringSet(dest_position + 1, 'u');
        dest->SeqOneByteStringSet(dest_position + 2,
                                  base::HexCharOfValue(c >> 12));
        dest->SeqOneByteStringSet(dest_position + 3,
                                  base::HexCharOfValue((c >> 8) & 0xF));
        dest->SeqOneByteStringSet(dest_position + 4,
                                  base::HexCharOfValue((c >> 4) & 0xF));
        dest->SeqOneByteStringSet(dest_position + 5,
                                  base::HexCharOfValue(c & 0xF));
        dest_position += 6;
      } else if (IsNotEscaped(c)) {
        dest->SeqOneByteStringSet(dest_position, c);
        dest_position++;
      } else {
        dest->SeqOneByteStringSet(dest_position, '%');
        dest->SeqOneByteStringSet(dest_position + 1,
                                  base::HexCharOfValue(c >> 4));
        dest->SeqOneByteStringSet(dest_position + 2,
                                  base::HexCharOfValue(c & 0xF));
        dest_position += 3;
      }
    }
  }

  return dest;
}

}  // anonymous namespace

MaybeHandle<String> Uri::Escape(Isolate* isolate, Handle<String> string) {
  DirectHandle<String> result;
  string = String::Flatten(isolate, string);
  return String::IsOneByteRepresentationUnderneath(*string)
             ? EscapePrivate<uint8_t>(isolate, string)
             : EscapePrivate<base::uc16>(isolate, string);
}

MaybeHandle<String> Uri::Unescape(Isolate* isolate, Handle<String> string) {
  DirectHandle<String> result;
  string = String::Flatten(isolate, string);
  return String::IsOneByteRepresentationUnderneath(*string)
             ? UnescapePrivate<uint8_t>(isolate, string)
             : UnescapePrivate<base::uc16>(isolate, string);
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/src/strings/uri.h                                                               0000664 0000000 0000000 00000003413 14746647661 0017276 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_STRINGS_URI_H_
#define V8_STRINGS_URI_H_

#include "src/handles/maybe-handles.h"
#include "src/utils/allocation.h"

namespace v8 {
namespace internal {

class Uri : public AllStatic {
 public:
  // ES6 section 18.2.6.2 decodeURI (encodedURI)
  static MaybeHandle<String> DecodeUri(Isolate* isolate, Handle<String> uri) {
    return Decode(isolate, uri, true);
  }

  // ES6 section 18.2.6.3 decodeURIComponent (encodedURIComponent)
  static MaybeHandle<String> DecodeUriComponent(Isolate* isolate,
                                                Handle<String> component) {
    return Decode(isolate, component, false);
  }

  // ES6 section 18.2.6.4 encodeURI (uri)
  static MaybeHandle<String> EncodeUri(Isolate* isolate, Handle<String> uri) {
    return Encode(isolate, uri, true);
  }

  // ES6 section 18.2.6.5 encodeURIComponenet (uriComponent)
  static MaybeHandle<String> EncodeUriComponent(Isolate* isolate,
                                                Handle<String> component) {
    return Encode(isolate, component, false);
  }

  // ES6 section B.2.1.1 escape (string)
  static MaybeHandle<String> Escape(Isolate* isolate, Handle<String> string);

  // ES6 section B.2.1.2 unescape (string)
  static MaybeHandle<String> Unescape(Isolate* isolate, Handle<String> string);

 private:
  static MaybeHandle<String> Decode(Isolate* isolate, Handle<String> uri,
                                    bool is_uri);
  static MaybeHandle<String> Encode(Isolate* isolate, Handle<String> uri,
                                    bool is_uri);
};

}  // namespace internal
}  // namespace v8

#endif  // V8_STRINGS_URI_H_
                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/src/tasks/                                                                      0000775 0000000 0000000 00000000000 14746647661 0015761 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/src/tasks/OWNERS                                                                0000664 0000000 0000000 00000000100 14746647661 0016710 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ahaas@chromium.org
clemensb@chromium.org
mlippautz@chromium.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/src/tasks/cancelable-task.cc                                                    0000664 0000000 0000000 00000010655 14746647661 0021310 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/tasks/cancelable-task.h"

#include "src/execution/isolate.h"

namespace v8 {
namespace internal {

Cancelable::~Cancelable() {
  // The following check is needed to avoid calling an already terminated
  // manager object. This happens when the manager cancels all pending tasks
  // in {CancelAndWait} only before destroying the manager object.
  Status previous;
  if (TryRun(&previous) || previous == kRunning) {
    parent_->RemoveFinishedTask(id_);
  }
}

CancelableTaskManager::CancelableTaskManager()
    : task_id_counter_(kInvalidTaskId), canceled_(false) {}

CancelableTaskManager::~CancelableTaskManager() {
  // It is required that {CancelAndWait} is called before the manager object is
  // destroyed. This guarantees that all tasks managed by this
  // {CancelableTaskManager} are either canceled or finished their execution
  // when the {CancelableTaskManager} dies.
  CHECK(canceled_);
}

CancelableTaskManager::Id CancelableTaskManager::Register(Cancelable* task) {
  base::MutexGuard guard(&mutex_);
  if (canceled_) {
    // The CancelableTaskManager has already been canceled. Therefore we mark
    // the new task immediately as canceled so that it does not get executed.
    task->Cancel();
    return kInvalidTaskId;
  }
  CancelableTaskManager::Id id = ++task_id_counter_;
  // Id overflows are not supported.
  CHECK_NE(kInvalidTaskId, id);
  CHECK(!canceled_);
  cancelable_tasks_[id] = task;
  return id;
}

void CancelableTaskManager::RemoveFinishedTask(CancelableTaskManager::Id id) {
  CHECK_NE(kInvalidTaskId, id);
  base::MutexGuard guard(&mutex_);
  size_t removed = cancelable_tasks_.erase(id);
  USE(removed);
  DCHECK_NE(0u, removed);
  cancelable_tasks_barrier_.NotifyOne();
}

TryAbortResult CancelableTaskManager::TryAbort(CancelableTaskManager::Id id) {
  CHECK_NE(kInvalidTaskId, id);
  base::MutexGuard guard(&mutex_);
  auto entry = cancelable_tasks_.find(id);
  if (entry != cancelable_tasks_.end()) {
    Cancelable* value = entry->second;
    if (value->Cancel()) {
      // Cannot call RemoveFinishedTask here because of recursive locking.
      cancelable_tasks_.erase(entry);
      cancelable_tasks_barrier_.NotifyOne();
      return TryAbortResult::kTaskAborted;
    } else {
      return TryAbortResult::kTaskRunning;
    }
  }
  return TryAbortResult::kTaskRemoved;
}

void CancelableTaskManager::CancelAndWait() {
  // Clean up all cancelable fore- and background tasks. Tasks are canceled on
  // the way if possible, i.e., if they have not started yet.  After each round
  // of canceling we wait for the background tasks that have already been
  // started.
  base::MutexGuard guard(&mutex_);
  canceled_ = true;

  // Cancelable tasks could be running or could potentially register new
  // tasks, requiring a loop here.
  while (!cancelable_tasks_.empty()) {
    for (auto it = cancelable_tasks_.begin(); it != cancelable_tasks_.end();) {
      auto current = it;
      // We need to get to the next element before erasing the current.
      ++it;
      if (current->second->Cancel()) {
        cancelable_tasks_.erase(current);
      }
    }
    // Wait for already running background tasks.
    if (!cancelable_tasks_.empty()) {
      cancelable_tasks_barrier_.Wait(&mutex_);
    }
  }
}

TryAbortResult CancelableTaskManager::TryAbortAll() {
  // Clean up all cancelable fore- and background tasks. Tasks are canceled on
  // the way if possible, i.e., if they have not started yet.
  base::MutexGuard guard(&mutex_);

  if (cancelable_tasks_.empty()) return TryAbortResult::kTaskRemoved;

  for (auto it = cancelable_tasks_.begin(); it != cancelable_tasks_.end();) {
    if (it->second->Cancel()) {
      it = cancelable_tasks_.erase(it);
    } else {
      ++it;
    }
  }

  return cancelable_tasks_.empty() ? TryAbortResult::kTaskAborted
                                   : TryAbortResult::kTaskRunning;
}

CancelableTask::CancelableTask(Isolate* isolate)
    : CancelableTask(isolate->cancelable_task_manager()) {}

CancelableTask::CancelableTask(CancelableTaskManager* manager)
    : Cancelable(manager) {}

CancelableIdleTask::CancelableIdleTask(Isolate* isolate)
    : CancelableIdleTask(isolate->cancelable_task_manager()) {}

CancelableIdleTask::CancelableIdleTask(CancelableTaskManager* manager)
    : Cancelable(manager) {}

}  // namespace internal
}  // namespace v8
                                                                                   node-23.7.0/deps/v8/src/tasks/cancelable-task.h                                                     0000664 0000000 0000000 00000014224 14746647661 0021146 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_TASKS_CANCELABLE_TASK_H_
#define V8_TASKS_CANCELABLE_TASK_H_

#include <atomic>
#include <unordered_map>

#include "include/v8-platform.h"
#include "src/base/macros.h"
#include "src/base/platform/condition-variable.h"

namespace v8 {
namespace internal {

class Cancelable;
class Isolate;

// The possible outcomes of trying to abort a job are:
// (1) The task is already finished running or was canceled before and
//     thus has been removed from the manager.
// (2) The task is currently running and cannot be canceled anymore.
// (3) The task is not yet running (or finished) so it is canceled and
//     removed.
enum class TryAbortResult { kTaskRemoved, kTaskRunning, kTaskAborted };

// Keeps track of cancelable tasks. It is possible to register and remove tasks
// from any fore- and background task/thread.
class V8_EXPORT_PRIVATE CancelableTaskManager {
 public:
  using Id = uint64_t;
  static constexpr Id kInvalidTaskId = 0;

  CancelableTaskManager();

  ~CancelableTaskManager();
  CancelableTaskManager(const CancelableTaskManager&) = delete;
  CancelableTaskManager& operator=(const CancelableTaskManager&) = delete;

  // Registers a new cancelable {task}. Returns the unique {id} of the task that
  // can be used to try to abort a task by calling {Abort}.
  // If {Register} is called after {CancelAndWait}, then the task will be
  // aborted immediately.
  // {Register} should only be called by the thread which owns the
  // {CancelableTaskManager}, or by a task which is managed by the
  // {CancelableTaskManager}.
  Id Register(Cancelable* task);

  // Try to abort running a task identified by {id}.
  TryAbortResult TryAbort(Id id);

  // Tries to cancel all remaining registered tasks. The return value indicates
  // whether
  //
  // 1) No tasks were registered (kTaskRemoved), or
  //
  // 2) There is at least one remaining task that couldn't be cancelled
  // (kTaskRunning), or
  //
  // 3) All registered tasks were cancelled (kTaskAborted).
  TryAbortResult TryAbortAll();

  // Cancels all remaining registered tasks and waits for tasks that are
  // already running. This disallows subsequent Register calls.
  void CancelAndWait();

  // Returns true of the task manager has been cancelled.
  bool canceled() const { return canceled_; }

 private:
  // Only called by {Cancelable} destructor. The task is done with executing,
  // but needs to be removed.
  void RemoveFinishedTask(Id id);

  // To mitigate the ABA problem, the api refers to tasks through an id.
  Id task_id_counter_;

  // A set of cancelable tasks that are currently registered.
  std::unordered_map<Id, Cancelable*> cancelable_tasks_;

  // Mutex and condition variable enabling concurrent register and removing, as
  // well as waiting for background tasks on {CancelAndWait}.
  base::ConditionVariable cancelable_tasks_barrier_;
  base::Mutex mutex_;

  bool canceled_;

  friend class Cancelable;
};

class V8_EXPORT_PRIVATE Cancelable {
 public:
  explicit Cancelable(CancelableTaskManager* parent)
      : parent_(parent), id_(parent->Register(this)) {}

  virtual ~Cancelable();
  Cancelable(const Cancelable&) = delete;
  Cancelable& operator=(const Cancelable&) = delete;

  // Never invoke after handing over the task to the platform! The reason is
  // that {Cancelable} is used in combination with {v8::Task} and handed to
  // a platform. This step transfers ownership to the platform, which destroys
  // the task after running it. Since the exact time is not known, we cannot
  // access the object after handing it to a platform.
  CancelableTaskManager::Id id() { return id_; }

 protected:
  // Identifies the state a cancelable task is in:
  // |kWaiting|: The task is scheduled and waiting to be executed. {TryRun} will
  //   succeed.
  // |kCanceled|: The task has been canceled. {TryRun} will fail.
  // |kRunning|: The task is currently running and cannot be canceled anymore.
  enum Status { kWaiting, kCanceled, kRunning };

  bool TryRun(Status* previous = nullptr) {
    return CompareExchangeStatus(kWaiting, kRunning, previous);
  }

 private:
  friend class CancelableTaskManager;

  // Use {CancelableTaskManager} to abort a task that has not yet been
  // executed.
  bool Cancel() { return CompareExchangeStatus(kWaiting, kCanceled); }

  bool CompareExchangeStatus(Status expected, Status desired,
                             Status* previous = nullptr) {
    // {compare_exchange_strong} updates {expected}.
    bool success = status_.compare_exchange_strong(expected, desired,
                                                   std::memory_order_acq_rel,
                                                   std::memory_order_acquire);
    if (previous) *previous = expected;
    return success;
  }

  CancelableTaskManager* const parent_;
  std::atomic<Status> status_{kWaiting};
  const CancelableTaskManager::Id id_;
};

// Multiple inheritance can be used because Task is a pure interface.
class V8_EXPORT_PRIVATE CancelableTask : public Cancelable,
                                         NON_EXPORTED_BASE(public Task) {
 public:
  explicit CancelableTask(Isolate* isolate);
  explicit CancelableTask(CancelableTaskManager* manager);
  CancelableTask(const CancelableTask&) = delete;
  CancelableTask& operator=(const CancelableTask&) = delete;

  // Task overrides.
  void Run() final {
    if (TryRun()) {
      RunInternal();
    }
  }

  virtual void RunInternal() = 0;
};

// Multiple inheritance can be used because IdleTask is a pure interface.
class CancelableIdleTask : public Cancelable, public IdleTask {
 public:
  explicit CancelableIdleTask(Isolate* isolate);
  explicit CancelableIdleTask(CancelableTaskManager* manager);
  CancelableIdleTask(const CancelableIdleTask&) = delete;
  CancelableIdleTask& operator=(const CancelableIdleTask&) = delete;

  // IdleTask overrides.
  void Run(double deadline_in_seconds) final {
    if (TryRun()) {
      RunInternal(deadline_in_seconds);
    }
  }

  virtual void RunInternal(double deadline_in_seconds) = 0;
};

}  // namespace internal
}  // namespace v8

#endif  // V8_TASKS_CANCELABLE_TASK_H_
                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/src/tasks/operations-barrier.cc                                                 0000664 0000000 0000000 00000001466 14746647661 0022106 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/tasks/operations-barrier.h"

namespace v8 {
namespace internal {

OperationsBarrier::Token OperationsBarrier::TryLock() {
  base::MutexGuard guard(&mutex_);
  if (cancelled_) return {};
  ++operations_count_;
  return Token(this);
}

void OperationsBarrier::CancelAndWait() {
  base::MutexGuard guard(&mutex_);
  DCHECK(!cancelled_);
  cancelled_ = true;
  while (operations_count_ > 0) {
    release_condition_.Wait(&mutex_);
  }
}

void OperationsBarrier::Release() {
  base::MutexGuard guard(&mutex_);
  if (--operations_count_ == 0 && cancelled_) {
    release_condition_.NotifyOne();
  }
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                          node-23.7.0/deps/v8/src/tasks/operations-barrier.h                                                  0000664 0000000 0000000 00000006750 14746647661 0021751 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_TASKS_OPERATIONS_BARRIER_H_
#define V8_TASKS_OPERATIONS_BARRIER_H_

#include <cstdint>

#include "src/base/macros.h"
#include "src/base/platform/condition-variable.h"
#include "src/base/platform/mutex.h"

namespace v8 {
namespace internal {

// A thread-safe barrier to manage lifetime of muti-threaded operations.
//
// The barrier is used to determine if operations are allowed, and to keep track
// of how many are currently active. Users will call TryLock() before starting
// such operations. If the call succeeds the user can run the operation and the
// barrier will keep track of it until the user signals that the operation is
// completed. No operations are allowed after CancelAndWait() is called.
//
// There is no explicit way of telling the barrier when an operation is
// completed, instead for convenience TryLock() will return a RAII
// like object that will do so on destruction.
//
// For example:
//
// OperationsBarrier barrier_;
//
// void TearDown() {
//   barrier_.CancelAndWait();
// }
//
// void MaybeRunOperation() {
//   if (token = barrier_.TryLock()) Process();
// }
//
class V8_EXPORT_PRIVATE OperationsBarrier {
 public:
  // The owner of a Token which evaluates to true can safely perform an
  // operation while being certain it happens-before CancelAndWait(). Releasing
  // this Token relinquishes this right.
  //
  // This class is thread-safe.
  class Token {
   public:
    Token() = default;
    ~Token() {
      if (outer_) outer_->Release();
    }
    Token(const Token&) = delete;
    Token(Token&& other) V8_NOEXCEPT : outer_(other.outer_) {
      other.outer_ = nullptr;
    }

    Token& operator=(const Token&) = delete;
    Token& operator=(Token&& other) V8_NOEXCEPT {
      DCHECK_NE(this, &other);
      if (outer_) outer_->Release();
      outer_ = other.outer_;
      other.outer_ = nullptr;
      return *this;
    }

    operator bool() const { return !!outer_; }

   private:
    friend class OperationsBarrier;
    explicit Token(OperationsBarrier* outer) : outer_(outer) {
      DCHECK_NOT_NULL(outer_);
    }
    OperationsBarrier* outer_ = nullptr;
  };

  OperationsBarrier() = default;

  // Users must call CancelAndWait() before destroying an instance of this
  // class.
  ~OperationsBarrier() { DCHECK(cancelled_); }

  OperationsBarrier(const OperationsBarrier&) = delete;
  OperationsBarrier& operator=(const OperationsBarrier&) = delete;

  // Returns a RAII like object that implicitly converts to true if operations
  // are allowed i.e. if this call happens-before CancelAndWait(), otherwise the
  // object will convert to false. On successful return, this OperationsBarrier
  // will keep track of the operation until the returned object goes out of
  // scope.
  Token TryLock();

  // Prevents further calls to TryLock() from succeeding and waits for
  // all the ongoing operations to complete.
  //
  // Attention: Can only be called once.
  void CancelAndWait();

  bool cancelled() const { return cancelled_; }

 private:
  void Release();

  // Mutex and condition variable enabling concurrent register and removing, as
  // well as waiting for background tasks on {CancelAndWait}.
  base::Mutex mutex_;
  base::ConditionVariable release_condition_;
  bool cancelled_ = false;
  size_t operations_count_{0};
};

}  // namespace internal
}  // namespace v8

#endif  // V8_TASKS_OPERATIONS_BARRIER_H_
                        node-23.7.0/deps/v8/src/tasks/task-utils.cc                                                         0000664 0000000 0000000 00000004146 14746647661 0020375 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/tasks/task-utils.h"

#include "src/tasks/cancelable-task.h"

namespace v8 {
namespace internal {

namespace {

class CancelableFuncTask final : public CancelableTask {
 public:
  CancelableFuncTask(Isolate* isolate, std::function<void()> func)
      : CancelableTask(isolate), func_(std::move(func)) {}
  CancelableFuncTask(CancelableTaskManager* manager, std::function<void()> func)
      : CancelableTask(manager), func_(std::move(func)) {}
  void RunInternal() final { func_(); }

 private:
  const std::function<void()> func_;
};

class CancelableIdleFuncTask final : public CancelableIdleTask {
 public:
  CancelableIdleFuncTask(Isolate* isolate, std::function<void(double)> func)
      : CancelableIdleTask(isolate), func_(std::move(func)) {}
  CancelableIdleFuncTask(CancelableTaskManager* manager,
                         std::function<void(double)> func)
      : CancelableIdleTask(manager), func_(std::move(func)) {}
  void RunInternal(double deadline_in_seconds) final {
    func_(deadline_in_seconds);
  }

 private:
  const std::function<void(double)> func_;
};

}  // namespace

std::unique_ptr<CancelableTask> MakeCancelableTask(Isolate* isolate,
                                                   std::function<void()> func) {
  return std::make_unique<CancelableFuncTask>(isolate, std::move(func));
}

std::unique_ptr<CancelableTask> MakeCancelableTask(
    CancelableTaskManager* manager, std::function<void()> func) {
  return std::make_unique<CancelableFuncTask>(manager, std::move(func));
}

std::unique_ptr<CancelableIdleTask> MakeCancelableIdleTask(
    Isolate* isolate, std::function<void(double)> func) {
  return std::make_unique<CancelableIdleFuncTask>(isolate, std::move(func));
}

std::unique_ptr<CancelableIdleTask> MakeCancelableIdleTask(
    CancelableTaskManager* manager, std::function<void(double)> func) {
  return std::make_unique<CancelableIdleFuncTask>(manager, std::move(func));
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/src/tasks/task-utils.h                                                          0000664 0000000 0000000 00000001750 14746647661 0020235 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_TASKS_TASK_UTILS_H_
#define V8_TASKS_TASK_UTILS_H_

#include <functional>
#include <memory>

namespace v8 {

namespace internal {

class CancelableIdleTask;
class CancelableTask;
class CancelableTaskManager;
class Isolate;

std::unique_ptr<CancelableTask> MakeCancelableTask(Isolate*,
                                                   std::function<void()>);
std::unique_ptr<CancelableTask> MakeCancelableTask(CancelableTaskManager*,
                                                   std::function<void()>);

std::unique_ptr<CancelableIdleTask> MakeCancelableIdleTask(
    Isolate*, std::function<void(double)>);
std::unique_ptr<CancelableIdleTask> MakeCancelableIdleTask(
    CancelableTaskManager* manager, std::function<void(double)>);

}  // namespace internal
}  // namespace v8

#endif  // V8_TASKS_TASK_UTILS_H_
                        node-23.7.0/deps/v8/src/temporal/                                                                   0000775 0000000 0000000 00000000000 14746647661 0016457 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/src/temporal/OWNERS                                                             0000664 0000000 0000000 00000000044 14746647661 0017415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ftang@chromium.org
syg@chromium.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/src/temporal/temporal-parser.cc                                                 0000664 0000000 0000000 00000134064 14746647661 0022113 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/temporal/temporal-parser.h"

#include <optional>

#include "src/base/bounds.h"
#include "src/objects/string-inl.h"
#include "src/strings/char-predicates-inl.h"

namespace v8::internal {

namespace {

// Temporal #prod-TZLeadingChar
inline constexpr bool IsTZLeadingChar(base::uc32 c) {
  return base::IsInRange(AsciiAlphaToLower(c), 'a', 'z') || c == '.' ||
         c == '_';
}

// Temporal #prod-TZChar
inline constexpr bool IsTZChar(base::uc32 c) {
  return IsTZLeadingChar(c) || c == '-';
}

// Temporal #prod-DecimalSeparator
inline constexpr bool IsDecimalSeparator(base::uc32 c) {
  return c == '.' || c == ',';
}

// Temporal #prod-DateTimeSeparator
inline constexpr bool IsDateTimeSeparator(base::uc32 c) {
  return c == ' ' || AsciiAlphaToLower(c) == 't';
}

// Temporal #prod-ASCIISign
inline constexpr bool IsAsciiSign(base::uc32 c) { return c == '-' || c == '+'; }

// Temporal #prod-Sign
inline constexpr bool IsSign(base::uc32 c) {
  return c == 0x2212 || IsAsciiSign(c);
}

// Temporal #prod-TimeZoneUTCOffsetSign
inline constexpr bool IsTimeZoneUTCOffsetSign(base::uc32 c) {
  return IsSign(c);
}

inline constexpr base::uc32 CanonicalSign(base::uc32 c) {
  return c == 0x2212 ? '-' : c;
}

inline constexpr int32_t ToInt(base::uc32 c) { return c - '0'; }

// A helper template to make the scanning of production w/ two digits simpler.
template <typename Char>
bool HasTwoDigits(base::Vector<Char> str, int32_t s, int32_t* out) {
  if (str.length() >= (s + 2) && IsDecimalDigit(str[s]) &&
      IsDecimalDigit(str[s + 1])) {
    *out = ToInt(str[s]) * 10 + ToInt(str[s + 1]);
    return true;
  }
  return false;
}

// A helper template to make the scanning of production w/ a single two digits
// value simpler.
template <typename Char>
int32_t ScanTwoDigitsExpectValue(base::Vector<Char> str, int32_t s,
                                 int32_t expected, int32_t* out) {
  return HasTwoDigits<Char>(str, s, out) && (*out == expected) ? 2 : 0;
}

// A helper template to make the scanning of production w/ two digits value in a
// range simpler.
template <typename Char>
int32_t ScanTwoDigitsExpectRange(base::Vector<Char> str, int32_t s, int32_t min,
                                 int32_t max, int32_t* out) {
  return HasTwoDigits<Char>(str, s, out) && base::IsInRange(*out, min, max) ? 2
                                                                            : 0;
}

// A helper template to make the scanning of production w/ two digits value as 0
// or in a range simpler.
template <typename Char>
int32_t ScanTwoDigitsExpectZeroOrRange(base::Vector<Char> str, int32_t s,
                                       int32_t min, int32_t max, int32_t* out) {
  return HasTwoDigits<Char>(str, s, out) &&
                 (*out == 0 || base::IsInRange(*out, min, max))
             ? 2
             : 0;
}

/**
 * The TemporalParser use two types of internal routine:
 * - Scan routines: Follow the function signature below:
 *   template <typename Char> int32_t Scan$ProductionName(
 *   base::Vector<Char> str, int32_t s, R* out)
 *
 *   These routine scan the next item from position s in str and store the
 *   parsed result into out if the expected string is successfully scanned.
 *   It return the length of matched text from s or 0 to indicate no
 *   expected item matched.
 *
 * - Satisfy routines: Follow the function sigature below:
 *   template <typename Char>
 *   bool Satisfy$ProductionName(base::Vector<Char> str, R* r);
 *   It scan from the beginning of the str by calling Scan routines to put
 *   parsed result into r and return true if the entire str satisfy the
 *   production. It internally use Scan routines.
 *
 * TODO(ftang) investigate refactoring to class before shipping
 * Reference to RegExpParserImpl by encapsulating the cursor position and
 * only manipulating the current character and position with Next(),
 * Advance(), current(), etc
 */

// For Hour Production
// Hour:
//   [0 1] Digit
//   2 [0 1 2 3]
template <typename Char>
int32_t ScanHour(base::Vector<Char> str, int32_t s, int32_t* out) {
  return ScanTwoDigitsExpectRange<Char>(str, s, 0, 23, out);
}

// UnpaddedHour :
//   DecimalDigit
//   1 DecimalDigit
//   20
//   21
//   22
//   23
template <typename Char>
int32_t ScanUnpaddedHour(base::Vector<Char> str, int32_t s) {
  int32_t dummy;
  int32_t len = ScanTwoDigitsExpectRange<Char>(str, s, 10, 23, &dummy);
  if (len > 0) return len;
  if (str.length() >= (s + 1) && IsDecimalDigit(str[s])) return 1;
  return 0;
}

// MinuteSecond:
//   [0 1 2 3 4 5] Digit
template <typename Char>
int32_t ScanMinuteSecond(base::Vector<Char> str, int32_t s, int32_t* out) {
  return ScanTwoDigitsExpectRange<Char>(str, s, 0, 59, out);
}

// For the forward production in the grammar such as
// ProductionB:
//   ProductionT
#define SCAN_FORWARD(B, T, R)                                \
  template <typename Char>                                   \
  int32_t Scan##B(base::Vector<Char> str, int32_t s, R* r) { \
    return Scan##T(str, s, r);                               \
  }

// Same as above but store the result into a particular field in R

// For the forward production in the grammar such as
// ProductionB:
//   ProductionT1
//   ProductionT2
#define SCAN_EITHER_FORWARD(B, T1, T2, R)                    \
  template <typename Char>                                   \
  int32_t Scan##B(base::Vector<Char> str, int32_t s, R* r) { \
    int32_t len;                                             \
    if ((len = Scan##T1(str, s, r)) > 0) return len;         \
    return Scan##T2(str, s, r);                              \
  }

// TimeHour: Hour
SCAN_FORWARD(TimeHour, Hour, int32_t)

// TimeMinute: MinuteSecond
SCAN_FORWARD(TimeMinute, MinuteSecond, int32_t)

// TimeSecond:
//   MinuteSecond
//   60
template <typename Char>
int32_t ScanTimeSecond(base::Vector<Char> str, int32_t s, int32_t* out) {
  return ScanTwoDigitsExpectRange<Char>(str, s, 0, 60, out);
}

constexpr int kPowerOfTen[] = {1,      10,      100,      1000,     10000,
                               100000, 1000000, 10000000, 100000000};

// FractionalPart : Digit{1,9}
template <typename Char>
int32_t ScanFractionalPart(base::Vector<Char> str, int32_t s, int32_t* out) {
  int32_t cur = s;
  if ((str.length() < (cur + 1)) || !IsDecimalDigit(str[cur])) return 0;
  *out = ToInt(str[cur++]);
  while ((cur < str.length()) && ((cur - s) < 9) && IsDecimalDigit(str[cur])) {
    *out = 10 * (*out) + ToInt(str[cur++]);
  }
  *out *= kPowerOfTen[9 - (cur - s)];
  return cur - s;
}

// TimeFraction: FractionalPart
SCAN_FORWARD(TimeFractionalPart, FractionalPart, int32_t)

// Fraction: DecimalSeparator FractionalPart
// DecimalSeparator: one of , .
template <typename Char>
int32_t ScanFraction(base::Vector<Char> str, int32_t s, int32_t* out) {
  if ((str.length() < (s + 2)) || (!IsDecimalSeparator(str[s]))) return 0;
  int32_t len;
  if ((len = ScanFractionalPart(str, s + 1, out)) == 0) return 0;
  return len + 1;
}

// TimeFraction: DecimalSeparator TimeFractionalPart
// DecimalSeparator: one of , .
template <typename Char>
int32_t ScanTimeFraction(base::Vector<Char> str, int32_t s, int32_t* out) {
  if ((str.length() < (s + 2)) || (!IsDecimalSeparator(str[s]))) return 0;
  int32_t len;
  if ((len = ScanTimeFractionalPart(str, s + 1, out)) == 0) return 0;
  return len + 1;
}

template <typename Char>
int32_t ScanTimeFraction(base::Vector<Char> str, int32_t s,
                         ParsedISO8601Result* r) {
  return ScanTimeFraction(str, s, &(r->time_nanosecond));
}

// TimeSpec:
//  TimeHour
//  TimeHour : TimeMinute
//  TimeHour : TimeMinute : TimeSecond [TimeFraction]
//  TimeHour TimeMinute
//  TimeHour TimeMinute TimeSecond [TimeFraction]
template <typename Char>
int32_t ScanTimeSpec(base::Vector<Char> str, int32_t s,
                     ParsedISO8601Result* r) {
  int32_t time_hour, time_minute, time_second;
  int32_t len;
  int32_t cur = s;
  if ((len = ScanTimeHour(str, cur, &time_hour)) == 0) return 0;
  cur += len;
  if ((cur + 1) > str.length()) {
    // TimeHour
    r->time_hour = time_hour;
    return cur - s;
  }
  if (str[cur] == ':') {
    cur++;
    if ((len = ScanTimeMinute(str, cur, &time_minute)) == 0) return 0;
    cur += len;
    if ((cur + 1) > str.length() || (str[cur] != ':')) {
      // TimeHour : TimeMinute
      r->time_hour = time_hour;
      r->time_minute = time_minute;
      return cur - s;
    }
    cur++;
    if ((len = ScanTimeSecond(str, cur, &time_second)) == 0) return 0;
  } else {
    if ((len = ScanTimeMinute(str, cur, &time_minute)) == 0) {
      // TimeHour
      r->time_hour = time_hour;
      return cur - s;
    }
    cur += len;
    if ((len = ScanTimeSecond(str, cur, &time_second)) == 0) {
      // TimeHour TimeMinute
      r->time_hour = time_hour;
      r->time_minute = time_minute;
      return cur - s;
    }
  }
  cur += len;
  len = ScanTimeFraction(str, cur, r);
  r->time_hour = time_hour;
  r->time_minute = time_minute;
  r->time_second = time_second;
  cur += len;
  return cur - s;
}

// TimeSpecSeparator: DateTimeSeparator TimeSpec
// DateTimeSeparator: SPACE, 't', or 'T'
template <typename Char>
int32_t ScanTimeSpecSeparator(base::Vector<Char> str, int32_t s,
                              ParsedISO8601Result* r) {
  if (!(((s + 1) < str.length()) && IsDateTimeSeparator(str[s]))) return 0;
  int32_t len = ScanTimeSpec(str, s + 1, r);
  return (len == 0) ? 0 : len + 1;
}

// DateExtendedYear: Sign Digit Digit Digit Digit Digit Digit
template <typename Char>
int32_t ScanDateExtendedYear(base::Vector<Char> str, int32_t s, int32_t* out) {
  if (str.length() < (s + 7)) return 0;
  if (IsSign(str[s]) && IsDecimalDigit(str[s + 1]) &&
      IsDecimalDigit(str[s + 2]) && IsDecimalDigit(str[s + 3]) &&
      IsDecimalDigit(str[s + 4]) && IsDecimalDigit(str[s + 5]) &&
      IsDecimalDigit(str[s + 6])) {
    int32_t sign = (CanonicalSign(str[s]) == '-') ? -1 : 1;
    *out = sign * (ToInt(str[s + 1]) * 100000 + ToInt(str[s + 2]) * 10000 +
                   ToInt(str[s + 3]) * 1000 + ToInt(str[s + 4]) * 100 +
                   ToInt(str[s + 5]) * 10 + ToInt(str[s + 6]));
    // In the end of #sec-temporal-iso8601grammar
    // It is a Syntax Error if DateExtendedYear is "-000000" or "000000"
    // (U+2212 MINUS SIGN followed by 000000).
    if (sign == -1 && *out == 0) return 0;
    return 7;
  }
  return 0;
}

// DateFourDigitYear: Digit Digit Digit Digit
template <typename Char>
int32_t ScanDateFourDigitYear(base::Vector<Char> str, int32_t s, int32_t* out) {
  if (str.length() < (s + 4)) return 0;
  if (IsDecimalDigit(str[s]) && IsDecimalDigit(str[s + 1]) &&
      IsDecimalDigit(str[s + 2]) && IsDecimalDigit(str[s + 3])) {
    *out = ToInt(str[s]) * 1000 + ToInt(str[s + 1]) * 100 +
           ToInt(str[s + 2]) * 10 + ToInt(str[s + 3]);
    return 4;
  }
  return 0;
}

// DateYear:
//   DateFourDigitYear
//   DateExtendedYear
// The lookahead is at most 1 char.
SCAN_EITHER_FORWARD(DateYear, DateFourDigitYear, DateExtendedYear, int32_t)

// DateMonth:
//   0 NonzeroDigit
//   10
//   11
//   12
template <typename Char>
int32_t ScanDateMonth(base::Vector<Char> str, int32_t s, int32_t* out) {
  return ScanTwoDigitsExpectRange<Char>(str, s, 1, 12, out);
}

// DateDay:
//   0 NonzeroDigit
//   1 Digit
//   2 Digit
//   30
//   31
template <typename Char>
int32_t ScanDateDay(base::Vector<Char> str, int32_t s, int32_t* out) {
  return ScanTwoDigitsExpectRange<Char>(str, s, 1, 31, out);
}

// Date:
//   DateYear - DateMonth - DateDay
//   DateYear DateMonth DateDay
template <typename Char>
int32_t ScanDate(base::Vector<Char> str, int32_t s, ParsedISO8601Result* r) {
  int32_t date_year, date_month, date_day;
  int32_t cur = s;
  int32_t len;
  if ((len = ScanDateYear(str, cur, &date_year)) == 0) return 0;
  if (((cur += len) + 1) > str.length()) return 0;
  if (str[cur] == '-') {
    cur++;
    if ((len = ScanDateMonth(str, cur, &date_month)) == 0) return 0;
    cur += len;
    if (((cur + 1) > str.length()) || (str[cur++] != '-')) return 0;
  } else {
    if ((len = ScanDateMonth(str, cur, &date_month)) == 0) return 0;
    cur += len;
  }
  if ((len = ScanDateDay(str, cur, &date_day)) == 0) return 0;
  r->date_year = date_year;
  r->date_month = date_month;
  r->date_day = date_day;
  return cur + len - s;
}

// DateMonthWithThirtyOneDays : one of
//    01 03 05 07 08 10 12
template <typename Char>
int32_t ScanDateMonthWithThirtyOneDays(base::Vector<Char> str, int32_t s) {
  int32_t value;
  if (!HasTwoDigits(str, s, &value)) return false;
  return value == 1 || value == 3 || value == 5 || value == 7 || value == 8 ||
         value == 10 || value == 12;
}

// TimeZoneUTCOffsetHour: Hour
SCAN_FORWARD(TimeZoneUTCOffsetHour, Hour, int32_t)

// TimeZoneUTCOffsetMinute
SCAN_FORWARD(TimeZoneUTCOffsetMinute, MinuteSecond, int32_t)

// TimeZoneUTCOffsetSecond
SCAN_FORWARD(TimeZoneUTCOffsetSecond, MinuteSecond, int32_t)

// TimeZoneUTCOffsetFractionalPart: FractionalPart
// See PR1796
SCAN_FORWARD(TimeZoneUTCOffsetFractionalPart, FractionalPart, int32_t)

// TimeZoneUTCOffsetFraction: DecimalSeparator TimeZoneUTCOffsetFractionalPart
// See PR1796
template <typename Char>
int32_t ScanTimeZoneUTCOffsetFraction(base::Vector<Char> str, int32_t s,
                                      int32_t* out) {
  if ((str.length() < (s + 2)) || (!IsDecimalSeparator(str[s]))) return 0;
  int32_t len;
  if ((len = ScanTimeZoneUTCOffsetFractionalPart(str, s + 1, out)) > 0) {
    return len + 1;
  }
  return 0;
}

// TimeZoneNumericUTCOffset:
//   TimeZoneUTCOffsetSign TimeZoneUTCOffsetHour
//   TimeZoneUTCOffsetSign TimeZoneUTCOffsetHour : TimeZoneUTCOffsetMinute
//   TimeZoneUTCOffsetSign TimeZoneUTCOffsetHour TimeZoneUTCOffsetMinute
//   TimeZoneUTCOffsetSign TimeZoneUTCOffsetHour : TimeZoneUTCOffsetMinute :
//   TimeZoneUTCOffsetSecond [TimeZoneUTCOffsetFraction] TimeZoneUTCOffsetSign
//   TimeZoneUTCOffsetHour TimeZoneUTCOffsetMinute TimeZoneUTCOffsetSecond
//   [TimeZoneUTCOffsetFraction]

template <typename Char>
int32_t ScanTimeZoneNumericUTCOffset(base::Vector<Char> str, int32_t s,
                                     ParsedISO8601Result* r) {
  int32_t len, hour, minute, second, nanosecond;
  int32_t cur = s;
  if ((str.length() < (cur + 1)) || (!IsTimeZoneUTCOffsetSign(str[cur]))) {
    return 0;
  }
  int32_t sign = (CanonicalSign(str[cur++]) == '-') ? -1 : 1;
  if ((len = ScanTimeZoneUTCOffsetHour(str, cur, &hour)) == 0) return 0;
  cur += len;
  if ((cur + 1) > str.length()) {
    //   TimeZoneUTCOffsetSign TimeZoneUTCOffsetHour
    r->tzuo_sign = sign;
    r->tzuo_hour = hour;
    r->offset_string_start = s;
    r->offset_string_length = cur - s;
    return cur - s;
  }
  if (str[cur] == ':') {
    cur++;
    if ((len = ScanTimeZoneUTCOffsetMinute(str, cur, &minute)) == 0) return 0;
    cur += len;
    if ((cur + 1) > str.length() || str[cur] != ':') {
      //   TimeZoneUTCOffsetSign TimeZoneUTCOffsetHour : TimeZoneUTCOffsetMinute
      r->tzuo_sign = sign;
      r->tzuo_hour = hour;
      r->tzuo_minute = minute;
      r->offset_string_start = s;
      r->offset_string_length = cur - s;
      return cur - s;
    }
    cur++;
    if ((len = ScanTimeZoneUTCOffsetSecond(str, cur, &second)) == 0) return 0;
  } else {
    if ((len = ScanTimeZoneUTCOffsetMinute(str, cur, &minute)) == 0) {
      //   TimeZoneUTCOffsetSign TimeZoneUTCOffsetHour
      r->tzuo_sign = sign;
      r->tzuo_hour = hour;
      r->offset_string_start = s;
      r->offset_string_length = cur - s;
      return cur - s;
    }
    cur += len;
    if ((len = ScanTimeZoneUTCOffsetSecond(str, cur, &second)) == 0) {
      //   TimeZoneUTCOffsetSign TimeZoneUTCOffsetHour TimeZoneUTCOffsetMinute
      r->tzuo_sign = sign;
      r->tzuo_hour = hour;
      r->tzuo_minute = minute;
      r->offset_string_start = s;
      r->offset_string_length = cur - s;
      return cur - s;
    }
  }
  cur += len;
  len = ScanTimeZoneUTCOffsetFraction(str, cur, &nanosecond);
  r->tzuo_sign = sign;
  r->tzuo_hour = hour;
  r->tzuo_minute = minute;
  r->tzuo_second = second;
  if (len > 0) r->tzuo_nanosecond = nanosecond;
  r->offset_string_start = s;
  r->offset_string_length = cur + len - s;
  cur += len;
  return cur - s;
}

// TimeZoneUTCOffset:
//   TimeZoneNumericUTCOffset
//   UTCDesignator
template <typename Char>
int32_t ScanTimeZoneUTCOffset(base::Vector<Char> str, int32_t s,
                              ParsedISO8601Result* r) {
  if (str.length() < (s + 1)) return 0;
  if (AsciiAlphaToLower(str[s]) == 'z') {
    // UTCDesignator
    r->utc_designator = true;
    return 1;
  }
  // TimeZoneNumericUTCOffset
  return ScanTimeZoneNumericUTCOffset(str, s, r);
}

// TimeZoneIANANameComponent :
//   TZLeadingChar TZChar{0,13} but not one of . or ..
template <typename Char>
int32_t ScanTimeZoneIANANameComponent(base::Vector<Char> str, int32_t s) {
  int32_t cur = s;
  if (str.length() < (cur + 1) || !IsTZLeadingChar(str[cur++])) return 0;
  while (((cur) < str.length()) && ((cur - s) < 14) && IsTZChar(str[cur])) {
    cur++;
  }
  if ((cur - s) == 1 && str[s] == '.') return 0;
  if ((cur - s) == 2 && str[s] == '.' && str[s + 1] == '.') return 0;
  return cur - s;
}
// TimeZoneIANALegacyName :
//   Etc/GMT0
//   GMT0
//   GMT-0
//   GMT+0
//   EST5EDT
//   CST6CDT
//   MST7MDT
//   PST8PDT

template <typename Char>
int32_t ScanTimeZoneIANALegacyName(base::Vector<Char> str, int32_t s) {
  int32_t cur = s;
  {
    constexpr int32_t len = 4;
    if (str.length() < cur + len) return 0;
    if (CompareCharsEqual(str.begin() + cur, "GMT0", len)) return len;
  }

  {
    constexpr int32_t len = 5;
    if (str.length() < cur + len) return 0;
    if (CompareCharsEqual(str.begin() + cur, "GMT+0", len) ||
        CompareCharsEqual(str.begin() + cur, "GMT-0", len)) {
      return len;
    }
  }

  {
    constexpr int32_t len = 7;
    if (str.length() < cur + len) return 0;
    if (CompareCharsEqual(str.begin() + cur, "EST5EDT", len) ||
        CompareCharsEqual(str.begin() + cur, "CST6CDT", len) ||
        CompareCharsEqual(str.begin() + cur, "MST7MDT", len) ||
        CompareCharsEqual(str.begin() + cur, "PST8PDT", len)) {
      return len;
    }
  }

  {
    constexpr int32_t len = 8;
    if (str.length() < cur + len) return 0;
    if (CompareCharsEqual(str.begin() + cur, "Etc/GMT0", len)) return len;
  }

  return 0;
}

// Etc/GMT ASCIISign UnpaddedHour
template <typename Char>
int32_t ScanEtcGMTASCIISignUnpaddedHour(base::Vector<Char> str, int32_t s) {
  if ((s + 9) > str.length()) return 0;
  int32_t cur = s;
  int32_t len = arraysize("Etc/GMT") - 1;
  if (!CompareCharsEqual(str.begin() + cur, "Etc/GMT", len)) return 0;
  cur += len;
  Char sign = str[cur++];
  if (!IsAsciiSign(sign)) return 0;
  len = ScanUnpaddedHour(str, cur);
  if (len == 0) return 0;
  cur += len;
  return cur - s;
}

// TimeZoneIANANameTail :
//   TimeZoneIANANameComponent
//   TimeZoneIANANameComponent / TimeZoneIANANameTail
// TimeZoneIANAName :
//   Etc/GMT ASCIISign UnpaddedHour
//   TimeZoneIANANameTail
//   TimeZoneIANALegacyName
// The spec text use tail recusion with TimeZoneIANANameComponent and
// TimeZoneIANANameTail. In our implementation, we use an iteration loop
// instead.
template <typename Char>
int32_t ScanTimeZoneIANAName(base::Vector<Char> str, int32_t s) {
  int32_t len;
  if ((len = ScanEtcGMTASCIISignUnpaddedHour(str, s)) > 0 ||
      (len = ScanTimeZoneIANALegacyName(str, s)) > 0) {
    return len;
  }
  int32_t cur = s;
  if ((len = ScanTimeZoneIANANameComponent(str, cur)) == 0) return 0;
  cur += len;
  while ((str.length() > (cur + 1)) && (str[cur] == '/')) {
    cur++;
    if ((len = ScanTimeZoneIANANameComponent(str, cur)) == 0) {
      return 0;
    }
    // TimeZoneIANANameComponent / TimeZoneIANAName
    cur += len;
  }
  return cur - s;
}

// TimeZoneUTCOffsetName
//   Sign Hour
//   Sign Hour : MinuteSecond
//   Sign Hour MinuteSecond
//   Sign Hour : MinuteSecond : MinuteSecond [Fraction]
//   Sign Hour MinuteSecond MinuteSecond [Fraction]
//
template <typename Char>
int32_t ScanTimeZoneUTCOffsetName(base::Vector<Char> str, int32_t s) {
  int32_t cur = s;
  int32_t len;
  if ((str.length() < (s + 3)) || !IsSign(str[cur++])) return 0;
  int32_t hour, minute, second, fraction;
  if ((len = ScanHour(str, cur, &hour)) == 0) return 0;
  cur += len;
  if ((cur + 1) > str.length()) {
    // Sign Hour
    return cur - s;
  }
  if (str[cur] == ':') {
    // Sign Hour :
    cur++;
    if ((len = ScanMinuteSecond(str, cur, &minute)) == 0) return 0;
    cur += len;
    if ((cur + 1) > str.length() || (str[cur] != ':')) {
      // Sign Hour : MinuteSecond
      return cur - s;
    }
    cur++;
    // Sign Hour : MinuteSecond :
    if ((len = ScanMinuteSecond(str, cur, &second)) == 0) return 0;
    cur += len;
    len = ScanFraction(str, cur, &fraction);
    return cur + len - s;
  } else {
    if ((len = ScanMinuteSecond(str, cur, &minute)) == 0) {
      // Sign Hour
      return cur - s;
    }
    cur += len;
    if ((len = ScanMinuteSecond(str, cur, &second)) == 0) {
      // Sign Hour MinuteSecond
      return cur - s;
    }
    cur += len;
    len = ScanFraction(str, cur, &fraction);
    //  Sign Hour MinuteSecond MinuteSecond [Fraction]
    cur += len;
    return cur - s;
  }
}

// TimeZoneBracketedName
//   TimeZoneIANAName
//   "Etc/GMT" ASCIISign Hour
//   TimeZoneUTCOffsetName
// Since "Etc/GMT" also fit TimeZoneIANAName so we need to try
// "Etc/GMT" ASCIISign Hour first.
template <typename Char>
int32_t ScanEtcGMTAsciiSignHour(base::Vector<Char> str, int32_t s) {
  if ((s + 10) > str.length()) return 0;
  int32_t cur = s;
  if ((str[cur++] != 'E') || (str[cur++] != 't') || (str[cur++] != 'c') ||
      (str[cur++] != '/') || (str[cur++] != 'G') || (str[cur++] != 'M') ||
      (str[cur++] != 'T')) {
    return 0;
  }
  Char sign = str[cur++];
  if (!IsAsciiSign(sign)) return 0;
  int32_t hour;
  int32_t len = ScanHour(str, cur, &hour);
  if (len == 0) return 0;
  //   "Etc/GMT" ASCIISign Hour
  return 10;
}

template <typename Char>
int32_t ScanTimeZoneIdentifier(base::Vector<Char> str, int32_t s,
                               ParsedISO8601Result* r);
// TimeZoneBracketedAnnotation :
// [ TimeZoneIdentifier ]
template <typename Char>
int32_t ScanTimeZoneBracketedAnnotation(base::Vector<Char> str, int32_t s,
                                        ParsedISO8601Result* r) {
  if ((str.length() < (s + 3)) || (str[s] != '[')) return 0;
  int32_t cur = s + 1;
  int32_t len = ScanTimeZoneIdentifier(str, cur, r);
  cur += len;
  if (len == 0 || str.length() < (cur + 1) || (str[cur] != ']')) {
    // Only ScanTimeZoneBracketedAnnotation know the post condition of
    // TimeZoneIdentifier is not matched so we need to reset here.
    r->tzi_name_start = 0;
    r->tzi_name_length = 0;
    return 0;
  }
  cur++;
  return cur - s;
}

// TimeZoneOffsetRequired:
//   TimeZoneUTCOffset [TimeZoneBracketedAnnotation]
template <typename Char>
int32_t ScanTimeZoneOffsetRequired(base::Vector<Char> str, int32_t s,
                                   ParsedISO8601Result* r) {
  int32_t cur = s;
  cur += ScanTimeZoneUTCOffset(str, cur, r);
  if (cur == s) return 0;
  cur += ScanTimeZoneBracketedAnnotation(str, cur, r);
  return cur - s;
}

//   TimeZoneNameRequired:
//   [TimeZoneUTCOffset] TimeZoneBracketedAnnotation
template <typename Char>
int32_t ScanTimeZoneNameRequired(base::Vector<Char> str, int32_t s,
                                 ParsedISO8601Result* r) {
  int32_t cur = s;
  cur += ScanTimeZoneUTCOffset(str, cur, r);
  int32_t len = ScanTimeZoneBracketedAnnotation(str, cur, r);
  if (len == 0) return 0;
  cur += len;
  return cur - s;
}

// TimeZone:
//   TimeZoneUTCOffset [TimeZoneBracketedAnnotation]
//   TimeZoneBracketedAnnotation
template <typename Char>
int32_t ScanTimeZone(base::Vector<Char> str, int32_t s,
                     ParsedISO8601Result* r) {
  int32_t cur = s;
  int32_t len;
  // TimeZoneUTCOffset [TimeZoneBracketedAnnotation]
  if ((len = ScanTimeZoneUTCOffset(str, cur, r)) > 0) {
    cur += len;
    // [TimeZoneBracketedAnnotation]
    len = ScanTimeZoneBracketedAnnotation(str, cur, r);
    cur += len;
    return cur - s;
  }
  // TimeZoneBracketedAnnotation
  return ScanTimeZoneBracketedAnnotation(str, cur, r);
}

// ValidMonthDay :
//   DateMonth [-] 0 NonZeroDigit
//   DateMonth [-] 1 DecimalDigit
//   DateMonth [-] 2 DecimalDigit
//   DateMonth [-] 30 but not one of 0230 or 02-30
//   DateMonthWithThirtyOneDays [-] 31
template <typename Char>
int32_t ScanValidMonthDay(base::Vector<Char> str, int32_t s) {
  int32_t len;
  int32_t cur = s;
  int32_t date_month;
  if ((len = ScanDateMonth(str, cur, &date_month)) > 0) {
    cur += len;
    if (str.length() >= (cur + 1)) {
      if (str[cur] == '-') cur++;
      int32_t day_of_month;
      if ((len = ScanTwoDigitsExpectRange(str, cur, 1, 30, &day_of_month)) >
          0) {
        cur += len;
        // 0 NonZeroDigit
        // 1 DecimalDigit
        // 2 DecimalDigit
        // 30 but not one of 0230 or 02-30
        if (date_month != 2 || day_of_month != 30) {
          return cur - s;
        }
      }
    }
  }
  // Reset cur
  cur = s;
  //   DateMonthWithThirtyOneDays [-] 31
  if ((len = ScanDateMonthWithThirtyOneDays(str, cur)) > 0) {
    cur += len;
    if (str.length() >= (cur + 1)) {
      if (str[cur] == '-') cur++;
      int32_t dummy;
      if ((len = ScanTwoDigitsExpectValue(str, cur, 31, &dummy)) > 0) {
        cur += len;
        return cur - s;
      }
    }
  }
  return 0;
}

template <typename Char>
int32_t ScanDateSpecYearMonth(base::Vector<Char> str, int32_t s,
                              ParsedISO8601Result* r);

// TimeSpecWithOptionalTimeZoneNotAmbiguous :
//   TimeSpec [TimeZone] but not one of ValidMonthDay or DateSpecYearMonth
template <typename Char>
int32_t ScanTimeSpecWithOptionalTimeZoneNotAmbiguous(base::Vector<Char> str,
                                                     int32_t s,
                                                     ParsedISO8601Result* r) {
  int32_t cur = s;
  int32_t len;
  if ((len = ScanTimeSpec(str, cur, r)) == 0) return 0;
  cur += len;
  // [TimeZone]
  len = ScanTimeZone(str, cur, r);
  cur += len;
  len = cur - s;
  // If it match ValidMonthDay, consider invalid.
  if (ScanValidMonthDay(str, s) == len) return 0;
  // If it match DateSpecYearMonth, consider invalid.
  ParsedISO8601Result tmp;
  if (ScanDateSpecYearMonth(str, s, &tmp) == len) return 0;
  return len;
}

// CalendarNameComponent:
//   CalChar {3,8}
template <typename Char>
int32_t ScanCalendarNameComponent(base::Vector<Char> str, int32_t s) {
  int32_t cur = s;
  while ((cur < str.length()) && IsAlphaNumeric(str[cur])) cur++;
  if ((cur - s) < 3 || (cur - s) > 8) return 0;
  return cur - s;
}

// CalendarNameTail :
//   CalendarNameComponent
//   CalendarNameComponent - CalendarNameTail
// CalendarName :
//   CalendarNameTail
// The spec text use tail recusion with CalendarNameComponent and
// CalendarNameTail. In our implementation, we use an iteration loop instead.
template <typename Char>
int32_t ScanCalendarName(base::Vector<Char> str, int32_t s,
                         ParsedISO8601Result* r) {
  int32_t cur = s;
  int32_t len;
  if ((len = ScanCalendarNameComponent(str, cur)) == 0) return 0;
  cur += len;
  while ((str.length() > (cur + 1)) && (str[cur++] == '-')) {
    if ((len = ScanCalendarNameComponent(str, cur)) == 0) return 0;
    // CalendarNameComponent - CalendarName
    cur += len;
  }
  r->calendar_name_start = s;
  r->calendar_name_length = cur - s;
  return cur - s;
}

// Calendar: '[u-ca=' CalendarName ']'
template <typename Char>
int32_t ScanCalendar(base::Vector<Char> str, int32_t s,
                     ParsedISO8601Result* r) {
  if (str.length() < (s + 7)) return 0;
  int32_t cur = s;
  // "[u-ca="
  if ((str[cur++] != '[') || (str[cur++] != 'u') || (str[cur++] != '-') ||
      (str[cur++] != 'c') || (str[cur++] != 'a') || (str[cur++] != '=')) {
    return 0;
  }
  int32_t len = ScanCalendarName(str, cur, r);
  if (len == 0) return 0;
  if ((str.length() < (cur + len + 1)) || (str[cur + len] != ']')) {
    // Only ScanCalendar know the post condition of CalendarName is not met and
    // need to reset here.
    r->calendar_name_start = 0;
    r->calendar_name_length = 0;
    return 0;
  }
  return 6 + len + 1;
}

// CalendarTime_L1:
//  TimeDesignator TimeSpec [TimeZone] [Calendar]
template <typename Char>
int32_t ScanCalendarTime_L1(base::Vector<Char> str, int32_t s,
                            ParsedISO8601Result* r) {
  int32_t cur = s;
  if (str.length() < (s + 1)) return 0;
  // TimeDesignator
  if (AsciiAlphaToLower(str[cur++]) != 't') return 0;
  int32_t len = ScanTimeSpec(str, cur, r);
  if (len == 0) return 0;
  cur += len;
  // [TimeZone]
  cur += ScanTimeZone(str, cur, r);
  // [Calendar]
  cur += ScanCalendar(str, cur, r);
  return cur - s;
}

// CalendarTime_L2 :
//  TimeSpecWithOptionalTimeZoneNotAmbiguous [Calendar]
template <typename Char>
int32_t ScanCalendarTime_L2(base::Vector<Char> str, int32_t s,
                            ParsedISO8601Result* r) {
  int32_t cur = s;
  int32_t len = ScanTimeSpecWithOptionalTimeZoneNotAmbiguous(str, cur, r);
  if (len == 0) return 0;
  cur += len;
  // [Calendar]
  cur += ScanCalendar(str, cur, r);
  return cur - s;
}

// DateTime: Date [TimeSpecSeparator][TimeZone]
template <typename Char>
int32_t ScanDateTime(base::Vector<Char> str, int32_t s,
                     ParsedISO8601Result* r) {
  int32_t cur = s;
  int32_t len = ScanDate(str, cur, r);
  if (len == 0) return 0;
  cur += len;
  cur += ScanTimeSpecSeparator(str, cur, r);
  cur += ScanTimeZone(str, cur, r);
  return cur - s;
}

// DateSpecYearMonth: DateYear ['-'] DateMonth
template <typename Char>
int32_t ScanDateSpecYearMonth(base::Vector<Char> str, int32_t s,
                              ParsedISO8601Result* r) {
  int32_t date_year, date_month;
  int32_t cur = s;
  int32_t len = ScanDateYear(str, cur, &date_year);
  if (len == 0) return 0;
  cur += len;
  if (str.length() < (cur + 1)) return 0;
  if (str[cur] == '-') cur++;
  len = ScanDateMonth(str, cur, &date_month);
  if (len == 0) return 0;
  r->date_year = date_year;
  r->date_month = date_month;
  cur += len;
  return cur - s;
}

// DateSpecMonthDay:
//   [TwoDash] DateMonth [-] DateDay
template <typename Char>
int32_t ScanDateSpecMonthDay(base::Vector<Char> str, int32_t s,
                             ParsedISO8601Result* r) {
  if (str.length() < (s + 4)) return 0;
  int32_t cur = s;
  if (str[cur] == '-') {
    // The first two dash are optional together
    if (str[++cur] != '-') return 0;
    // TwoDash
    cur++;
  }
  int32_t date_month, date_day;
  int32_t len = ScanDateMonth(str, cur, &date_month);
  if (len == 0) return 0;
  cur += len;
  if (str.length() < (cur + 1)) return 0;
  // '-'
  if (str[cur] == '-') cur++;
  len = ScanDateDay(str, cur, &date_day);
  if (len == 0) return 0;
  r->date_month = date_month;
  r->date_day = date_day;
  cur += len;
  return cur - s;
}

// TimeZoneIdentifier :
//   TimeZoneIANAName
//   TimeZoneUTCOffsetName
template <typename Char>
int32_t ScanTimeZoneIdentifier(base::Vector<Char> str, int32_t s,
                               ParsedISO8601Result* r) {
  int32_t len;
  int32_t cur = s;
  if ((len = ScanTimeZoneIANAName(str, cur)) > 0 ||
      (len = ScanTimeZoneUTCOffsetName(str, cur)) > 0) {
    cur += len;
    r->tzi_name_start = s;
    r->tzi_name_length = len;
    return cur - s;
  }
  return 0;
}

// CalendarDateTime: DateTime [Calendar]
template <typename Char>
int32_t ScanCalendarDateTime(base::Vector<Char> str, int32_t s,
                             ParsedISO8601Result* r) {
  int32_t len = ScanDateTime(str, s, r);
  if (len == 0) return 0;
  return len + ScanCalendar(str, len, r);
}

// CalendarDateTimeTimeRequired: Date TimeSpecSeparator [TimeZone] [Calendar]
template <typename Char>
int32_t ScanCalendarDateTimeTimeRequired(base::Vector<Char> str, int32_t s,
                                         ParsedISO8601Result* r) {
  int32_t cur = s;
  int32_t len = ScanDate(str, cur, r);
  if (len == 0) return 0;
  cur += len;
  len = ScanTimeSpecSeparator(str, cur, r);
  if (len == 0) return 0;
  cur += len;
  // [TimeZone]
  cur += ScanTimeZone(str, cur, r);
  // [Calendar]
  cur += ScanCalendar(str, cur, r);
  return cur - s;
}

// TemporalZonedDateTimeString:
//   Date [TimeSpecSeparator] TimeZoneNameRequired [Calendar]
template <typename Char>
int32_t ScanTemporalZonedDateTimeString(base::Vector<Char> str, int32_t s,
                                        ParsedISO8601Result* r) {
  // Date
  int32_t cur = s;
  int32_t len = ScanDate(str, cur, r);
  if (len == 0) return 0;
  cur += len;

  // TimeSpecSeparator
  cur += ScanTimeSpecSeparator(str, cur, r);

  // TimeZoneNameRequired
  len = ScanTimeZoneNameRequired(str, cur, r);
  if (len == 0) return 0;
  cur += len;

  // Calendar
  cur += ScanCalendar(str, cur, r);
  return cur - s;
}

SCAN_FORWARD(TemporalDateTimeString, CalendarDateTime, ParsedISO8601Result)

// TemporalMonthDayString
//   DateSpecMonthDay
//   CalendarDateTime
// The lookahead is at most 5 chars.
SCAN_EITHER_FORWARD(TemporalMonthDayString, DateSpecMonthDay, CalendarDateTime,
                    ParsedISO8601Result)

// TemporalInstantString
//   Date [TimeSpecSeparator] TimeZoneOffsetRequired [Calendar]
template <typename Char>
int32_t ScanTemporalInstantString(base::Vector<Char> str, int32_t s,
                                  ParsedISO8601Result* r) {
  // Date
  int32_t cur = s;
  int32_t len = ScanDate(str, cur, r);
  if (len == 0) return 0;
  cur += len;

  // [TimeSpecSeparator]
  cur += ScanTimeSpecSeparator(str, cur, r);

  // TimeZoneOffsetRequired
  len = ScanTimeZoneOffsetRequired(str, cur, r);
  if (len == 0) return 0;
  cur += len;
  // [Calendar]
  cur += ScanCalendar(str, cur, r);
  return cur - s;
}

// ==============================================================================
#define SATISIFY(T, R)                            \
  template <typename Char>                        \
  bool Satisfy##T(base::Vector<Char> str, R* r) { \
    R ret;                                        \
    int32_t len = Scan##T(str, 0, &ret);          \
    if ((len > 0) && (len == str.length())) {     \
      *r = ret;                                   \
      return true;                                \
    }                                             \
    return false;                                 \
  }

#define IF_SATISFY_RETURN(T)             \
  {                                      \
    if (Satisfy##T(str, r)) return true; \
  }

#define SATISIFY_EITHER(T1, T2, T3, R)             \
  template <typename Char>                         \
  bool Satisfy##T1(base::Vector<Char> str, R* r) { \
    IF_SATISFY_RETURN(T2)                          \
    IF_SATISFY_RETURN(T3)                          \
    return false;                                  \
  }

SATISIFY(TemporalDateTimeString, ParsedISO8601Result)
SATISIFY(DateTime, ParsedISO8601Result)
SATISIFY(DateSpecYearMonth, ParsedISO8601Result)
SATISIFY(DateSpecMonthDay, ParsedISO8601Result)
SATISIFY(CalendarDateTime, ParsedISO8601Result)
SATISIFY(CalendarTime_L1, ParsedISO8601Result)
SATISIFY(CalendarTime_L2, ParsedISO8601Result)

template <typename Char>
bool SatisfyCalendarTime(base::Vector<Char> str, ParsedISO8601Result* r) {
  IF_SATISFY_RETURN(CalendarTime_L1)
  IF_SATISFY_RETURN(CalendarTime_L2)
  return false;
}
SATISIFY(CalendarDateTimeTimeRequired, ParsedISO8601Result)
SATISIFY_EITHER(TemporalTimeString, CalendarTime, CalendarDateTimeTimeRequired,
                ParsedISO8601Result)
SATISIFY_EITHER(TemporalYearMonthString, DateSpecYearMonth, CalendarDateTime,
                ParsedISO8601Result)
SATISIFY_EITHER(TemporalMonthDayString, DateSpecMonthDay, CalendarDateTime,
                ParsedISO8601Result)
SATISIFY(TimeZoneNumericUTCOffset, ParsedISO8601Result)
SATISIFY(TimeZoneIdentifier, ParsedISO8601Result)
SATISIFY(TemporalInstantString, ParsedISO8601Result)
SATISIFY(TemporalZonedDateTimeString, ParsedISO8601Result)

SATISIFY(CalendarName, ParsedISO8601Result)

// Duration

// Digits : Digit [Digits]

template <typename Char>
int32_t ScanDigits(base::Vector<Char> str, int32_t s, double* out) {
  if (str.length() < (s + 1) || !IsDecimalDigit(str[s])) return 0;
  *out = ToInt(str[s]);
  int32_t len = 1;
  while (s + len + 1 <= str.length() && IsDecimalDigit(str[s + len])) {
    *out = 10 * (*out) + ToInt(str[s + len]);
    len++;
  }
  return len;
}

SCAN_FORWARD(DurationYears, Digits, double)
SCAN_FORWARD(DurationMonths, Digits, double)
SCAN_FORWARD(DurationWeeks, Digits, double)
SCAN_FORWARD(DurationDays, Digits, double)

// DurationWholeHours : Digits
SCAN_FORWARD(DurationWholeHours, Digits, double)

// DurationWholeMinutes : Digits
SCAN_FORWARD(DurationWholeMinutes, Digits, double)

// DurationWholeSeconds : Digits
SCAN_FORWARD(DurationWholeSeconds, Digits, double)

// DurationHoursFraction : TimeFraction
SCAN_FORWARD(DurationHoursFraction, TimeFraction, int32_t)

// DurationMinutesFraction : TimeFraction
SCAN_FORWARD(DurationMinutesFraction, TimeFraction, int32_t)

// DurationSecondsFraction : TimeFraction
SCAN_FORWARD(DurationSecondsFraction, TimeFraction, int32_t)

#define DURATION_WHOLE_FRACTION_DESIGNATOR(Name, name, d)                 \
  template <typename Char>                                                \
  int32_t ScanDurationWhole##Name##FractionDesignator(                    \
      base::Vector<Char> str, int32_t s, ParsedISO8601Duration* r) {      \
    int32_t cur = s;                                                      \
    double whole = ParsedISO8601Duration::kEmpty;                         \
    cur += ScanDurationWhole##Name(str, cur, &whole);                     \
    if (cur == s) return 0;                                               \
    int32_t fraction = ParsedISO8601Duration::kEmpty;                     \
    int32_t len = ScanDuration##Name##Fraction(str, cur, &fraction);      \
    cur += len;                                                           \
    if (str.length() < (cur + 1) || AsciiAlphaToLower(str[cur++]) != (d)) \
      return 0;                                                           \
    r->whole_##name = whole;                                              \
    r->name##_fraction = fraction;                                        \
    return cur - s;                                                       \
  }

DURATION_WHOLE_FRACTION_DESIGNATOR(Seconds, seconds, 's')
DURATION_WHOLE_FRACTION_DESIGNATOR(Minutes, minutes, 'm')
DURATION_WHOLE_FRACTION_DESIGNATOR(Hours, hours, 'h')

// DurationSecondsPart :
//   DurationWholeSeconds DurationSecondsFractionopt SecondsDesignator
SCAN_FORWARD(DurationSecondsPart, DurationWholeSecondsFractionDesignator,
             ParsedISO8601Duration)

// DurationMinutesPart :
//   DurationWholeMinutes DurationMinutesFractionopt MinutesDesignator
//   [DurationSecondsPart]
template <typename Char>
int32_t ScanDurationMinutesPart(base::Vector<Char> str, int32_t s,
                                ParsedISO8601Duration* r) {
  int32_t cur = s;
  int32_t len = ScanDurationWholeMinutesFractionDesignator(str, s, r);
  if (len == 0) return 0;
  cur += len;
  cur += ScanDurationSecondsPart(str, cur, r);
  return cur - s;
}

// DurationHoursPart :
//   DurationWholeHours DurationHoursFractionopt HoursDesignator
//   DurationMinutesPart
//
//   DurationWholeHours DurationHoursFractionopt HoursDesignator
//   [DurationSecondsPart]
template <typename Char>
int32_t ScanDurationHoursPart(base::Vector<Char> str, int32_t s,
                              ParsedISO8601Duration* r) {
  int32_t cur = s;
  int32_t len = ScanDurationWholeHoursFractionDesignator(str, s, r);
  if (len == 0) return 0;
  cur += len;
  len = ScanDurationMinutesPart(str, cur, r);
  if (len > 0) {
    cur += len;
  } else {
    cur += ScanDurationSecondsPart(str, cur, r);
  }
  return cur - s;
}

// DurationTime :
//   TimeDesignator DurationHoursPart
//   TimeDesignator DurationMinutesPart
//   TimeDesignator DurationSecondsPart
template <typename Char>
int32_t ScanDurationTime(base::Vector<Char> str, int32_t s,
                         ParsedISO8601Duration* r) {
  int32_t cur = s;
  if (str.length() < (s + 1)) return 0;
  if (AsciiAlphaToLower(str[cur++]) != 't') return 0;
  if ((cur += ScanDurationHoursPart(str, cur, r)) - s > 1) return cur - s;
  if ((cur += ScanDurationMinutesPart(str, cur, r)) - s > 1) return cur - s;
  if ((cur += ScanDurationSecondsPart(str, cur, r)) - s > 1) return cur - s;
  return 0;
}

#define DURATION_AND_DESIGNATOR(Name, name, d)                              \
  template <typename Char>                                                  \
  int32_t ScanDuration##Name##Designator(base::Vector<Char> str, int32_t s, \
                                         ParsedISO8601Duration* r) {        \
    int32_t cur = s;                                                        \
    double name;                                                            \
    if ((cur += ScanDuration##Name(str, cur, &name)) == s) return 0;        \
    if (str.length() < (cur + 1) || AsciiAlphaToLower(str[cur++]) != (d)) { \
      return 0;                                                             \
    }                                                                       \
    r->name = name;                                                         \
    return cur - s;                                                         \
  }

DURATION_AND_DESIGNATOR(Days, days, 'd')
DURATION_AND_DESIGNATOR(Weeks, weeks, 'w')
DURATION_AND_DESIGNATOR(Months, months, 'm')
DURATION_AND_DESIGNATOR(Years, years, 'y')

// DurationDaysPart : DurationDays DaysDesignator
SCAN_FORWARD(DurationDaysPart, DurationDaysDesignator, ParsedISO8601Duration)

// DurationWeeksPart : DurationWeeks WeeksDesignator [DurationDaysPart]
template <typename Char>
int32_t ScanDurationWeeksPart(base::Vector<Char> str, int32_t s,
                              ParsedISO8601Duration* r) {
  int32_t cur = s;
  if ((cur += ScanDurationWeeksDesignator(str, cur, r)) == s) return 0;
  cur += ScanDurationDaysPart(str, cur, r);
  return cur - s;
}

// DurationMonthsPart :
//   DurationMonths MonthsDesignator DurationWeeksPart
//   DurationMonths MonthsDesignator [DurationDaysPart]
template <typename Char>
int32_t ScanDurationMonthsPart(base::Vector<Char> str, int32_t s,
                               ParsedISO8601Duration* r) {
  int32_t cur = s;
  int32_t len = ScanDurationMonthsDesignator(str, cur, r);
  if (len == 0) return 0;
  cur += len;
  if ((len = ScanDurationWeeksPart(str, cur, r)) > 0) {
    cur += len;
  } else {
    cur += ScanDurationDaysPart(str, cur, r);
  }
  return cur - s;
}

// DurationYearsPart :
//   DurationYears YearsDesignator DurationMonthsPart
//   DurationYears YearsDesignator DurationWeeksPart
//   DurationYears YearsDesignator [DurationDaysPart]
template <typename Char>
int32_t ScanDurationYearsPart(base::Vector<Char> str, int32_t s,
                              ParsedISO8601Duration* r) {
  int32_t cur = s;
  int32_t len = ScanDurationYearsDesignator(str, cur, r);
  if (len == 0) return 0;
  cur += len;
  if ((len = ScanDurationMonthsPart(str, cur, r)) > 0) {
    cur += len;
  } else if ((len = ScanDurationWeeksPart(str, cur, r)) > 0) {
    cur += len;
  } else {
    len = ScanDurationDaysPart(str, cur, r);
    cur += len;
  }
  return cur - s;
}

// DurationDate :
//   DurationYearsPart [DurationTime]
//   DurationMonthsPart [DurationTime]
//   DurationWeeksPart [DurationTime]
//   DurationDaysPart [DurationTime]
template <typename Char>
int32_t ScanDurationDate(base::Vector<Char> str, int32_t s,
                         ParsedISO8601Duration* r) {
  int32_t cur = s;
  do {
    if ((cur += ScanDurationYearsPart(str, cur, r)) > s) break;
    if ((cur += ScanDurationMonthsPart(str, cur, r)) > s) break;
    if ((cur += ScanDurationWeeksPart(str, cur, r)) > s) break;
    if ((cur += ScanDurationDaysPart(str, cur, r)) > s) break;
    return 0;
  } while (false);
  cur += ScanDurationTime(str, cur, r);
  return cur - s;
}

// Duration :
//   Signopt DurationDesignator DurationDate
//   Signopt DurationDesignator DurationTime
template <typename Char>
int32_t ScanDuration(base::Vector<Char> str, int32_t s,
                     ParsedISO8601Duration* r) {
  if (str.length() < (s + 2)) return 0;
  int32_t cur = s;
  int32_t sign =
      (IsSign(str[cur]) && CanonicalSign(str[cur++]) == '-') ? -1 : 1;
  if (AsciiAlphaToLower(str[cur++]) != 'p') return 0;
  int32_t len = ScanDurationDate(str, cur, r);
  if (len == 0) len = ScanDurationTime(str, cur, r);
  if (len == 0) return 0;
  r->sign = sign;
  cur += len;
  return cur - s;
}
SCAN_FORWARD(TemporalDurationString, Duration, ParsedISO8601Duration)

SATISIFY(TemporalDurationString, ParsedISO8601Duration)

}  // namespace

#define IMPL_PARSE_METHOD(R, NAME)                                          \
  std::optional<R> TemporalParser::Parse##NAME(Isolate* isolate,            \
                                               Handle<String> iso_string) { \
    bool valid;                                                             \
    R parsed;                                                               \
    iso_string = String::Flatten(isolate, iso_string);                      \
    {                                                                       \
      DisallowGarbageCollection no_gc;                                      \
      String::FlatContent str_content = iso_string->GetFlatContent(no_gc);  \
      if (str_content.IsOneByte()) {                                        \
        valid = Satisfy##NAME(str_content.ToOneByteVector(), &parsed);      \
      } else {                                                              \
        valid = Satisfy##NAME(str_content.ToUC16Vector(), &parsed);         \
      }                                                                     \
    }                                                                       \
    if (valid) return parsed;                                               \
    return std::nullopt;                                                    \
  }

IMPL_PARSE_METHOD(ParsedISO8601Result, TemporalDateTimeString)
IMPL_PARSE_METHOD(ParsedISO8601Result, TemporalYearMonthString)
IMPL_PARSE_METHOD(ParsedISO8601Result, TemporalMonthDayString)
IMPL_PARSE_METHOD(ParsedISO8601Result, TemporalTimeString)
IMPL_PARSE_METHOD(ParsedISO8601Result, TemporalInstantString)
IMPL_PARSE_METHOD(ParsedISO8601Result, TemporalZonedDateTimeString)
IMPL_PARSE_METHOD(ParsedISO8601Result, TimeZoneIdentifier)
IMPL_PARSE_METHOD(ParsedISO8601Result, CalendarName)
IMPL_PARSE_METHOD(ParsedISO8601Result, TimeZoneNumericUTCOffset)
IMPL_PARSE_METHOD(ParsedISO8601Duration, TemporalDurationString)

}  // namespace v8::internal
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/src/temporal/temporal-parser.h                                                  0000664 0000000 0000000 00000015144 14746647661 0021752 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_TEMPORAL_TEMPORAL_PARSER_H_
#define V8_TEMPORAL_TEMPORAL_PARSER_H_

#include <optional>

#include "src/execution/isolate.h"

namespace v8::internal {

/**
 * ParsedISO8601Result contains the parsed result of ISO 8601 grammar
 * documented in #sec-temporal-iso8601grammar
 * for TemporalInstantString, TemporalZonedDateTimeString,
 * CalendarName, TemporalDateString, TemporalDateTimeString,
 * TemporalMonthDayString, TemporalRelativeToString, TemporalTimeString,
 * TimeZoneIdentifier, and TemporalYearMonthString. For all the fields
 * represented by int32_t, a special value kMinInt31 is used to represent the
 * field is "undefined" after parsing.
 */
struct ParsedISO8601Result {
  int32_t date_year;    // DateYear production
  int32_t date_month;   // DateMonth production
  int32_t date_day;     // DateDay production
  int32_t time_hour;    // TimeHour production
  int32_t time_minute;  // TimeMinute production
  int32_t time_second;  // TimeSecond production
  int32_t
      time_nanosecond;  // TimeFractionalPart production stored in nanosecond
  int32_t tzuo_sign;    // TimeZoneUTCOffsetSign production
  int32_t tzuo_hour;    // TimeZoneUTCOffsetHour production
  int32_t tzuo_minute;  // TimeZoneUTCOffsetMinute production
  int32_t tzuo_second;  // TimeZoneUTCOffsetSecond production
  int32_t
      tzuo_nanosecond;  // TimeZoneUTCOffsetFractionalPart stored in nanosecond
  bool utc_designator;  // UTCDesignator is presented
  int32_t tzi_name_start;   // Starting offset of TimeZoneIANAName in the input
                            // string.
  int32_t tzi_name_length;  // Length of TimeZoneIANAName production
  int32_t calendar_name_start;  // Starting offset of CalendarName production in
                                // the input string.
  int32_t calendar_name_length;  // Length of CalendarName production.
  int32_t offset_string_start;   // Starting offset of TimeZoneNumericUTCOffset
                                 // in the input string.
  int32_t
      offset_string_length;  // Length of TimeZoneNumericUTCOffset production

  ParsedISO8601Result()
      : date_year(kMinInt31),
        date_month(kMinInt31),
        date_day(kMinInt31),
        time_hour(kMinInt31),
        time_minute(kMinInt31),
        time_second(kMinInt31),
        time_nanosecond(kMinInt31),
        tzuo_sign(kMinInt31),
        tzuo_hour(kMinInt31),
        tzuo_minute(kMinInt31),
        tzuo_second(kMinInt31),
        tzuo_nanosecond(kMinInt31),
        utc_designator(false),
        tzi_name_start(0),
        tzi_name_length(0),
        calendar_name_start(0),
        calendar_name_length(0),
        offset_string_start(0),
        offset_string_length(0) {}

  bool date_year_is_undefined() const { return date_year == kMinInt31; }
  bool date_month_is_undefined() const { return date_month == kMinInt31; }
  bool date_day_is_undefined() const { return date_day == kMinInt31; }
  bool time_hour_is_undefined() const { return time_hour == kMinInt31; }
  bool time_minute_is_undefined() const { return time_minute == kMinInt31; }
  bool time_second_is_undefined() const { return time_second == kMinInt31; }
  bool time_nanosecond_is_undefined() const {
    return time_nanosecond == kMinInt31;
  }
  bool tzuo_hour_is_undefined() const { return tzuo_hour == kMinInt31; }
  bool tzuo_minute_is_undefined() const { return tzuo_minute == kMinInt31; }
  bool tzuo_second_is_undefined() const { return tzuo_second == kMinInt31; }
  bool tzuo_sign_is_undefined() const { return tzuo_sign == kMinInt31; }
  bool tzuo_nanosecond_is_undefined() const {
    return tzuo_nanosecond == kMinInt31;
  }
};

/**
 * ParsedISO8601Duration contains the parsed result of ISO 8601 grammar
 * documented in #prod-TemporalDurationString
 * for TemporalDurationString.
 * A special value kEmpty is used to represent the
 * field is "undefined" after parsing for all fields except sign.
 */
struct ParsedISO8601Duration {
  double sign;               // Sign production
  double years;              // DurationYears production
  double months;             // DurationMonths production
  double weeks;              // DurationWeeks production
  double days;               // DurationDays production
  double whole_hours;        // DurationWholeHours production
  double whole_minutes;      // DurationWholeMinutes production
  double whole_seconds;      // DurationWholeSeconds production
  int32_t hours_fraction;    // DurationHoursFraction, in unit of 1e-9 hours
  int32_t minutes_fraction;  // DurationMinuteFraction, in unit of 1e-9 minutes
  int32_t seconds_fraction;  // DurationSecondFraction, in unit of nanosecond (
                             // 1e-9 seconds).

  static constexpr int32_t kEmpty = -1;
  ParsedISO8601Duration()
      : sign(1),
        years(kEmpty),
        months(kEmpty),
        weeks(kEmpty),
        days(kEmpty),
        whole_hours(kEmpty),
        whole_minutes(kEmpty),
        whole_seconds(kEmpty),
        hours_fraction(kEmpty),
        minutes_fraction(kEmpty),
        seconds_fraction(kEmpty) {}
};

/**
 * TemporalParser is low level parsing functions to support the implementation
 * of various ParseTemporal*String Abstract Operations listed after
 * #sec-temporal-parsetemporalinstantstring.
 * All the methods take an Isolate, a Handle<String> as input, and also a
 * pointer to a bool to answer the "satisfy the syntax of a Temporal*String"
 * question and return the parsed result.
 */
class V8_EXPORT_PRIVATE TemporalParser {
 public:
#define DEFINE_PARSE_METHOD(R, NAME)                         \
  V8_WARN_UNUSED_RESULT static std::optional<R> Parse##NAME( \
      Isolate* isolate, Handle<String> iso_string)
  DEFINE_PARSE_METHOD(ParsedISO8601Result, TemporalDateString);
  DEFINE_PARSE_METHOD(ParsedISO8601Result, TemporalDateTimeString);
  DEFINE_PARSE_METHOD(ParsedISO8601Result, TemporalTimeString);
  DEFINE_PARSE_METHOD(ParsedISO8601Result, TemporalYearMonthString);
  DEFINE_PARSE_METHOD(ParsedISO8601Result, TemporalMonthDayString);
  DEFINE_PARSE_METHOD(ParsedISO8601Result, TemporalInstantString);
  DEFINE_PARSE_METHOD(ParsedISO8601Result, TemporalZonedDateTimeString);
  DEFINE_PARSE_METHOD(ParsedISO8601Result, TimeZoneIdentifier);
  DEFINE_PARSE_METHOD(ParsedISO8601Result, TemporalRelativeToString);
  DEFINE_PARSE_METHOD(ParsedISO8601Result, CalendarName);
  DEFINE_PARSE_METHOD(ParsedISO8601Duration, TemporalDurationString);
  DEFINE_PARSE_METHOD(ParsedISO8601Result, TimeZoneNumericUTCOffset);
};
#undef DEFINE_PARSE_METHOD

}  // namespace v8::internal

#endif  // V8_TEMPORAL_TEMPORAL_PARSER_H_
                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/src/third_party/                                                                0000775 0000000 0000000 00000000000 14746647661 0017165 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/src/third_party/siphash/                                                        0000775 0000000 0000000 00000000000 14746647661 0020624 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/src/third_party/siphash/LICENSE                                                 0000664 0000000 0000000 00000014633 14746647661 0021640 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        CC0 1.0 Universal

Statement of Purpose

The laws of most jurisdictions throughout the world automatically confer
exclusive Copyright and Related Rights (defined below) upon the creator and
subsequent owner(s) (each and all, an "owner") of an original work of
authorship and/or a database (each, a "Work").

Certain owners wish to permanently relinquish those rights to a Work for the
purpose of contributing to a commons of creative, cultural and scientific
works ("Commons") that the public can reliably and without fear of later
claims of infringement build upon, modify, incorporate in other works, reuse
and redistribute as freely as possible in any form whatsoever and for any
purposes, including without limitation commercial purposes. These owners may
contribute to the Commons to promote the ideal of a free culture and the
further production of creative, cultural and scientific works, or to gain
reputation or greater distribution for their Work in part through the use and
efforts of others.

For these and/or other purposes and motivations, and without any expectation
of additional consideration or compensation, the person associating CC0 with a
Work (the "Affirmer"), to the extent that he or she is an owner of Copyright
and Related Rights in the Work, voluntarily elects to apply CC0 to the Work
and publicly distribute the Work under its terms, with knowledge of his or her
Copyright and Related Rights in the Work and the meaning and intended legal
effect of CC0 on those rights.

1. Copyright and Related Rights. A Work made available under CC0 may be
protected by copyright and related or neighboring rights ("Copyright and
Related Rights"). Copyright and Related Rights include, but are not limited
to, the following:

  i. the right to reproduce, adapt, distribute, perform, display, communicate,
  and translate a Work;

  ii. moral rights retained by the original author(s) and/or performer(s);

  iii. publicity and privacy rights pertaining to a person's image or likeness
  depicted in a Work;

  iv. rights protecting against unfair competition in regards to a Work,
  subject to the limitations in paragraph 4(a), below;

  v. rights protecting the extraction, dissemination, use and reuse of data in
  a Work;

  vi. database rights (such as those arising under Directive 96/9/EC of the
  European Parliament and of the Council of 11 March 1996 on the legal
  protection of databases, and under any national implementation thereof,
  including any amended or successor version of such directive); and

  vii. other similar, equivalent or corresponding rights throughout the world
  based on applicable law or treaty, and any national implementations thereof.

2. Waiver. To the greatest extent permitted by, but not in contravention of,
applicable law, Affirmer hereby overtly, fully, permanently, irrevocably and
unconditionally waives, abandons, and surrenders all of Affirmer's Copyright
and Related Rights and associated claims and causes of action, whether now
known or unknown (including existing as well as future claims and causes of
action), in the Work (i) in all territories worldwide, (ii) for the maximum
duration provided by applicable law or treaty (including future time
extensions), (iii) in any current or future medium and for any number of
copies, and (iv) for any purpose whatsoever, including without limitation
commercial, advertising or promotional purposes (the "Waiver"). Affirmer makes
the Waiver for the benefit of each member of the public at large and to the
detriment of Affirmer's heirs and successors, fully intending that such Waiver
shall not be subject to revocation, rescission, cancellation, termination, or
any other legal or equitable action to disrupt the quiet enjoyment of the Work
by the public as contemplated by Affirmer's express Statement of Purpose.

3. Public License Fallback. Should any part of the Waiver for any reason be
judged legally invalid or ineffective under applicable law, then the Waiver
shall be preserved to the maximum extent permitted taking into account
Affirmer's express Statement of Purpose. In addition, to the extent the Waiver
is so judged Affirmer hereby grants to each affected person a royalty-free,
non transferable, non sublicensable, non exclusive, irrevocable and
unconditional license to exercise Affirmer's Copyright and Related Rights in
the Work (i) in all territories worldwide, (ii) for the maximum duration
provided by applicable law or treaty (including future time extensions), (iii)
in any current or future medium and for any number of copies, and (iv) for any
purpose whatsoever, including without limitation commercial, advertising or
promotional purposes (the "License"). The License shall be deemed effective as
of the date CC0 was applied by Affirmer to the Work. Should any part of the
License for any reason be judged legally invalid or ineffective under
applicable law, such partial invalidity or ineffectiveness shall not
invalidate the remainder of the License, and in such case Affirmer hereby
affirms that he or she will not (i) exercise any of his or her remaining
Copyright and Related Rights in the Work or (ii) assert any associated claims
and causes of action with respect to the Work, in either case contrary to
Affirmer's express Statement of Purpose.

4. Limitations and Disclaimers.

  a. No trademark or patent rights held by Affirmer are waived, abandoned,
  surrendered, licensed or otherwise affected by this document.

  b. Affirmer offers the Work as-is and makes no representations or warranties
  of any kind concerning the Work, express, implied, statutory or otherwise,
  including without limitation warranties of title, merchantability, fitness
  for a particular purpose, non infringement, or the absence of latent or
  other defects, accuracy, or the present or absence of errors, whether or not
  discoverable, all to the greatest extent permissible under applicable law.

  c. Affirmer disclaims responsibility for clearing rights of other persons
  that may apply to the Work or any use thereof, including without limitation
  any person's Copyright and Related Rights in the Work. Further, Affirmer
  disclaims responsibility for obtaining any necessary consents, permissions
  or other rights required for any use of the Work.

  d. Affirmer understands and acknowledges that Creative Commons is not a
  party to this document and has no duty or obligation with respect to this
  CC0 or use of the Work.

For more information, please see
<http://creativecommons.org/publicdomain/zero/1.0/>
                                                                                                     node-23.7.0/deps/v8/src/third_party/siphash/OWNERS                                                  0000664 0000000 0000000 00000000026 14746647661 0021562 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        verwaest@chromium.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/src/third_party/siphash/halfsiphash.cc                                          0000664 0000000 0000000 00000003375 14746647661 0023435 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * SipHash reference C implementation
 *
 * Copyright (c) 2016 Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>
 *
 * To the extent possible under law, the author(s) have dedicated all
 * copyright and related and neighboring rights to this software to the public
 * domain worldwide. This software is distributed without any warranty.
 *
 * You should have received a copy of the CC0 Public Domain Dedication along
 * with this software. If not, see
 * <http://creativecommons.org/publicdomain/zero/1.0/>.
 */

/*
 * Originally taken from https://github.com/veorq/SipHash/
 * Altered to match V8's use case.
 */

#include "src/third_party/siphash/halfsiphash.h"

#include "src/base/logging.h"

#define ROTL(x, b) (uint32_t)(((x) << (b)) | ((x) >> (32 - (b))))

#define SIPROUND       \
  do {                 \
    v0 += v1;          \
    v1 = ROTL(v1, 5);  \
    v1 ^= v0;          \
    v0 = ROTL(v0, 16); \
    v2 += v3;          \
    v3 = ROTL(v3, 8);  \
    v3 ^= v2;          \
    v0 += v3;          \
    v3 = ROTL(v3, 7);  \
    v3 ^= v0;          \
    v2 += v1;          \
    v1 = ROTL(v1, 13); \
    v1 ^= v2;          \
    v2 = ROTL(v2, 16); \
  } while (0)

// Simplified half-siphash-2-4 implementation for 4 byte input.
uint32_t halfsiphash(const uint32_t value, const uint64_t seed) {
  uint32_t v0 = 0;
  uint32_t v1 = 0;
  uint32_t v2 = 0x6c796765;
  uint32_t v3 = 0x74656462;
  uint32_t k[2];
  memcpy(k, &seed, sizeof(seed));
  uint32_t b = 4 << 24;
  v3 ^= k[1];
  v2 ^= k[0];
  v1 ^= k[1];
  v0 ^= k[0];

  v3 ^= value;

  // 2 c-rounds
  SIPROUND;
  SIPROUND;

  v0 ^= value;
  v3 ^= b;

  // 2 c-rounds
  SIPROUND;
  SIPROUND;

  v0 ^= b;
  v2 ^= 0xff;

  // 4 d-rounds
  SIPROUND;
  SIPROUND;
  SIPROUND;
  SIPROUND;

  b = v1 ^ v3;
  return b;
}
                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/src/third_party/siphash/halfsiphash.h                                           0000664 0000000 0000000 00000001266 14746647661 0023274 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * SipHash reference C implementation
 *
 * Copyright (c) 2016 Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>
 *
 * To the extent possible under law, the author(s) have dedicated all
 * copyright and related and neighboring rights to this software to the public
 * domain worldwide. This software is distributed without any warranty.
 *
 * You should have received a copy of the CC0 Public Domain Dedication along
 * with this software. If not, see
 * <http://creativecommons.org/publicdomain/zero/1.0/>.
 */

#include <cstdint>
#include "src/base/macros.h"

V8_EXPORT_PRIVATE uint32_t halfsiphash(const uint32_t value,
                                       const uint64_t seed);
                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/src/third_party/utf8-decoder/                                                   0000775 0000000 0000000 00000000000 14746647661 0021456 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/src/third_party/utf8-decoder/LICENSE                                            0000664 0000000 0000000 00000002077 14746647661 0022471 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/src/third_party/utf8-decoder/OWNERS                                             0000664 0000000 0000000 00000000023 14746647661 0022411 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        marja@chromium.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/src/third_party/utf8-decoder/README.v8                                          0000664 0000000 0000000 00000001742 14746647661 0022676 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        Name: DFA UTF-8 Decoder
Short Name: utf8-decoder
URL: http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
Version: 0
License: MIT
License File: LICENSE
Security Critical: yes
Shipped: yes

Description:
Decodes UTF-8 bytes using a fast and simple definite finite automata.

Local modifications:
- Rejection state has been mapped to row 0 (instead of row 1) of the DFA,
  saving some 50 bytes and making the table easier to reason about.
- The transitions have been remapped to represent both a state transition and a
  bit mask for the incoming byte.
- The caller must now zero out the code point buffer after successful or
  unsuccessful state transitions.
- Specifically for generalized-utf8-decoder.h: we adapt the original
  decoder to decode and validate "generalized UTF-8", a variant of UTF-8
  used in WTF-8 that can encode surrogates.  See
  https://simonsapin.github.io/wtf-8/#generalized-utf8.  There is one
  fewer state and so the transition table is smaller by one in both
  dimensions.
                              node-23.7.0/deps/v8/src/third_party/utf8-decoder/generalized-utf8-decoder.h                         0000664 0000000 0000000 00000011167 14746647661 0026415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ and the sibling file
// utf8-decoder.h for details.
//
// This file decodes "generalized UTF-8", which is the same as UTF-8 except that
// it allows surrogates: https://simonsapin.github.io/wtf-8/#generalized-utf8

#include <stdint.h>

#ifndef __GENERALIZED_UTF8_DFA_DECODER_H
#define __GENERALIZED_UTF8_DFA_DECODER_H

struct GeneralizedUtf8DfaDecoder {
  enum State : uint8_t {
    kReject = 0,
    kAccept = 11,
    kTwoByte = 22,
    kThreeByte = 33,
    kFourByte = 44,
    kFourByteLow = 55,
    kThreeByteHigh = 66,
    kFourByteMidHigh = 77,
  };

  static inline void Decode(uint8_t byte, State* state, uint32_t* buffer) {
    // This first table maps bytes to character to a transition.
    //
    // The transition value takes a state to a new state, but it also determines
    // the set of bits from the current byte that contribute to the decoded
    // codepoint:
    //
    //   Transition | Current byte bits that contribute to decoded codepoint
    //   -------------------------------------------------------------------
    //    0, 1      | 0b01111111
    //    2, 3      | 0b00111111
    //    4, 5      | 0b00011111
    //    6, 7      | 0b00001111
    //    8, 9      | 0b00000111
    //    10        | 0b00000011
    //
    // Given the WTF-8 encoding, we therefore have the following constraints:

    //   1. The transition value for 1-byte encodings should have the value 0 or
    //      1 so that we preserve all of the low 7 bits.
    //   2. Continuation bytes (0x80 to 0xBF) are of the form 0b10xxxxxx, and
    //      therefore should have transition value between 0 and 3.
    //   3. Leading bytes for 2-byte encodings are of the form 0b110yyyyy, and
    //      therefore the transition value can be between 2 and 5.
    //   4. Leading bytes for 3-byte encodings (0b1110zzzz) need transition
    //      value between 4 and 7.
    //   5. Leading bytes for 4-byte encodings (0b11110uuu) need transition
    //      value between 6 and 9.
    //   6. We need more states to impose irregular constraints.  Sometimes we
    //      can use the knowldege that e.g. some high significant bits of the
    //      xxxx in 0b1110xxxx are 0, then we can use a higher transition value.
    //   7. Transitions to invalid states can use any transition value.
    static constexpr uint8_t transitions[] = {
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 00-0F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 10-1F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 20-2F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 30-3F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 40-4F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 50-5F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 60-6F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 70-7F
        1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 80-8F
        2,  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // 90-9F
        3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  // A0-AF
        3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  // B0-BF
        8,  8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // C0-CF
        4,  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // D0-DF
        9,  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,  // E0-EF
        10, 6, 6, 6, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  // F0-FF
    };

    // This second table maps a state to a new state when adding a transition.
    //  00-7F
    //  |   80-8F
    //  |   |   90-9F
    //  |   |   |   A0-BF
    //  |   |   |   |   C2-DF
    //  |   |   |   |   |   E1-EF
    //  |   |   |   |   |   |   F1-F3
    //  |   |   |   |   |   |   |   F4
    //  |   |   |   |   |   |   |   |   C0, C1, F5-FF
    //  |   |   |   |   |   |   |   |   |  E0
    //  |   |   |   |   |   |   |   |   |  |   F0
    static constexpr uint8_t states[] = {
        0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,   // REJECT = 0
        11, 0,  0,  0,  22, 33, 44, 55, 0, 66, 77,  // ACCEPT = 11
        0,  11, 11, 11, 0,  0,  0,  0,  0, 0,  0,   // 2-byte = 22
        0,  22, 22, 22, 0,  0,  0,  0,  0, 0,  0,   // 3-byte = 33
        0,  33, 33, 33, 0,  0,  0,  0,  0, 0,  0,   // 4-byte = 44
        0,  33, 0,  0,  0,  0,  0,  0,  0, 0,  0,   // 4-byte low = 55
        0,  0,  0,  22, 0,  0,  0,  0,  0, 0,  0,   // 3-byte high = 66
        0,  0,  33, 33, 0,  0,  0,  0,  0, 0,  0,   // 4-byte mid/high = 77
    };

    uint8_t type = transitions[byte];
    *state = static_cast<State>(states[*state + type]);
    *buffer = (*buffer << 6) | (byte & (0x7F >> (type >> 1)));
  }
};

#endif  // __GENERALIZED_UTF8_DFA_DECODER_H
                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/src/third_party/utf8-decoder/utf8-decoder.h                                     0000664 0000000 0000000 00000006235 14746647661 0024126 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.
// The remapped transition table is justified at
// https://docs.google.com/spreadsheets/d/1AZcQwuEL93HmNCljJWUwFMGqf7JAQ0puawZaUgP0E14

#include <stdint.h>

#ifndef __UTF8_DFA_DECODER_H
#define __UTF8_DFA_DECODER_H

struct Utf8DfaDecoder {
  enum State : uint8_t {
    kReject = 0,
    kAccept = 12,
    kTwoByte = 24,
    kThreeByte = 36,
    kThreeByteLowMid = 48,
    kFourByte = 60,
    kFourByteLow = 72,
    kThreeByteHigh = 84,
    kFourByteMidHigh = 96,
  };

  static inline void Decode(uint8_t byte, State* state, uint32_t* buffer) {
    // This first table maps bytes to character to a transition.
    static constexpr uint8_t transitions[] = {
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 00-0F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 10-1F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 20-2F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 30-3F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 40-4F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 50-5F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 60-6F
        0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 70-7F
        1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 80-8F
        2,  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // 90-9F
        3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  // A0-AF
        3,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  // B0-BF
        9,  9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // C0-CF
        4,  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // D0-DF
        10, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5,  // E0-EF
        11, 7, 7, 7, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  // F0-FF
    };

    // This second table maps a state to a new state when adding a transition.
    //  00-7F
    //  |   80-8F
    //  |   |   90-9F
    //  |   |   |   A0-BF
    //  |   |   |   |   C2-DF
    //  |   |   |   |   |   E1-EC, EE, EF
    //  |   |   |   |   |   |   ED
    //  |   |   |   |   |   |   |   F1-F3
    //  |   |   |   |   |   |   |   |   F4
    //  |   |   |   |   |   |   |   |   |   C0, C1, F5-FF
    //  |   |   |   |   |   |   |   |   |   |  E0
    //  |   |   |   |   |   |   |   |   |   |  |   F0
    static constexpr uint8_t states[] = {
        0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,   // REJECT = 0
        12, 0,  0,  0,  24, 36, 48, 60, 72, 0, 84, 96,  // ACCEPT = 12
        0,  12, 12, 12, 0,  0,  0,  0,  0,  0, 0,  0,   // 2-byte = 24
        0,  24, 24, 24, 0,  0,  0,  0,  0,  0, 0,  0,   // 3-byte = 36
        0,  24, 24, 0,  0,  0,  0,  0,  0,  0, 0,  0,   // 3-byte low/mid = 48
        0,  36, 36, 36, 0,  0,  0,  0,  0,  0, 0,  0,   // 4-byte = 60
        0,  36, 0,  0,  0,  0,  0,  0,  0,  0, 0,  0,   // 4-byte low = 72
        0,  0,  0,  24, 0,  0,  0,  0,  0,  0, 0,  0,   // 3-byte high = 84
        0,  0,  36, 36, 0,  0,  0,  0,  0,  0, 0,  0,   // 4-byte mid/high = 96
    };

    uint8_t type = transitions[byte];
    *state = static_cast<State>(states[*state + type]);
    *buffer = (*buffer << 6) | (byte & (0x7F >> (type >> 1)));
  }
};

#endif /* __UTF8_DFA_DECODER_H */
                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/src/third_party/valgrind/                                                       0000775 0000000 0000000 00000000000 14746647661 0020773 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/src/third_party/valgrind/LICENSE                                                0000664 0000000 0000000 00000004607 14746647661 0022007 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ----------------------------------------------------------------

Notice that the following BSD-style license applies to this one
file (valgrind.h) only.  The rest of Valgrind is licensed under the
terms of the GNU General Public License, version 2, unless
otherwise indicated.  See the COPYING file in the source
distribution for details.

----------------------------------------------------------------

This file is part of Valgrind, a dynamic binary instrumentation
framework.

Copyright (C) 2000-2010 Julian Seward.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

2. The origin of this software must not be misrepresented; you must
   not claim that you wrote the original software.  If you use this
   software in a product, an acknowledgment in the product
   documentation would be appreciated but is not required.

3. Altered source versions must be plainly marked as such, and must
   not be misrepresented as being the original software.

4. The name of the author may not be used to endorse or promote
   products derived from this software without specific prior written
   permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------

Notice that the above BSD-style license applies to this one file
(valgrind.h) only.  The entire rest of Valgrind is licensed under
the terms of the GNU General Public License, version 2.  See the
COPYING file in the source distribution for details.

----------------------------------------------------------------
                                                                                                                         node-23.7.0/deps/v8/src/third_party/valgrind/OWNERS                                                 0000664 0000000 0000000 00000000034 14746647661 0021730 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        file:../../../COMMON_OWNERS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/src/third_party/valgrind/valgrind.h                                             0000664 0000000 0000000 00000703210 14746647661 0022755 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* -*- c -*-
   ----------------------------------------------------------------

   Notice that the following BSD-style license applies to this one
   file (valgrind.h) only.  The rest of Valgrind is licensed under the
   terms of the GNU General Public License, version 2, unless
   otherwise indicated.  See the COPYING file in the source
   distribution for details.

   ----------------------------------------------------------------

   This file is part of Valgrind, a dynamic binary instrumentation
   framework.

   Copyright (C) 2000-2010 Julian Seward.  All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

   2. The origin of this software must not be misrepresented; you must
      not claim that you wrote the original software.  If you use this
      software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   3. Altered source versions must be plainly marked as such, and must
      not be misrepresented as being the original software.

   4. The name of the author may not be used to endorse or promote
      products derived from this software without specific prior written
      permission.

   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   ----------------------------------------------------------------

   Notice that the above BSD-style license applies to this one file
   (valgrind.h) only.  The entire rest of Valgrind is licensed under
   the terms of the GNU General Public License, version 2.  See the
   COPYING file in the source distribution for details.

   ----------------------------------------------------------------
*/


/* This file is for inclusion into client (your!) code.

   You can use these macros to manipulate and query Valgrind's
   execution inside your own programs.

   The resulting executables will still run without Valgrind, just a
   little bit more slowly than they otherwise would, but otherwise
   unchanged.  When not running on valgrind, each client request
   consumes very few (eg. 7) instructions, so the resulting performance
   loss is negligible unless you plan to execute client requests
   millions of times per second.  Nevertheless, if that is still a
   problem, you can compile with the NVALGRIND symbol defined (gcc
   -DNVALGRIND) so that client requests are not even compiled in.  */

#ifndef __VALGRIND_H
#define __VALGRIND_H


/* ------------------------------------------------------------------ */
/* VERSION NUMBER OF VALGRIND                                         */
/* ------------------------------------------------------------------ */

/* Specify Valgrind's version number, so that user code can
   conditionally compile based on our version number.  Note that these
   were introduced at version 3.6 and so do not exist in version 3.5
   or earlier.  The recommended way to use them to check for "version
   X.Y or later" is (eg)

#if defined(__VALGRIND_MAJOR__) && defined(__VALGRIND_MINOR__)   \
    && (__VALGRIND_MAJOR__ > 3                                   \
        || (__VALGRIND_MAJOR__ == 3 && __VALGRIND_MINOR__ >= 6))
*/
#define __VALGRIND_MAJOR__    3
#define __VALGRIND_MINOR__    6


#include <stdarg.h>
#include <stdint.h>

/* Nb: this file might be included in a file compiled with -ansi.  So
   we can't use C++ style "//" comments nor the "asm" keyword (instead
   use "__asm__"). */

/* Derive some tags indicating what the target platform is.  Note
   that in this file we're using the compiler's CPP symbols for
   identifying architectures, which are different to the ones we use
   within the rest of Valgrind.  Note, __powerpc__ is active for both
   32 and 64-bit PPC, whereas __powerpc64__ is only active for the
   latter (on Linux, that is).

   Misc note: how to find out what's predefined in gcc by default:
   gcc -Wp,-dM somefile.c
*/
#undef PLAT_x86_darwin
#undef PLAT_amd64_darwin
#undef PLAT_x86_win32
#undef PLAT_x86_linux
#undef PLAT_amd64_linux
#undef PLAT_ppc32_linux
#undef PLAT_ppc64_linux
#undef PLAT_arm_linux
#undef PLAT_s390x_linux


#if defined(__APPLE__) && defined(__i386__)
#  define PLAT_x86_darwin 1
#elif defined(__APPLE__) && defined(__x86_64__)
#  define PLAT_amd64_darwin 1
#elif defined(__MINGW32__) || defined(__CYGWIN32__) \
      || (defined(_WIN32) && defined(_M_IX86))
#  define PLAT_x86_win32 1
#elif defined(__linux__) && defined(__i386__)
#  define PLAT_x86_linux 1
#elif defined(__linux__) && defined(__x86_64__)
#  define PLAT_amd64_linux 1
#elif defined(__linux__) && defined(__powerpc__) && !defined(__powerpc64__)
#  define PLAT_ppc32_linux 1
#elif defined(__linux__) && defined(__powerpc__) && defined(__powerpc64__)
#  define PLAT_ppc64_linux 1
#elif defined(__linux__) && defined(__arm__)
#  define PLAT_arm_linux 1
#elif defined(__linux__) && defined(__s390__) && defined(__s390x__)
#  define PLAT_s390x_linux 1
#else
/* If we're not compiling for our target platform, don't generate
   any inline asms.  */
#  if !defined(NVALGRIND)
#    define NVALGRIND 1
#  endif
#endif


/* ------------------------------------------------------------------ */
/* ARCHITECTURE SPECIFICS for SPECIAL INSTRUCTIONS.  There is nothing */
/* in here of use to end-users -- skip to the next section.           */
/* ------------------------------------------------------------------ */

/*
 * VALGRIND_DO_CLIENT_REQUEST(): a statement that invokes a Valgrind client
 * request. Accepts both pointers and integers as arguments.
 *
 * VALGRIND_DO_CLIENT_REQUEST_EXPR(): a C expression that invokes a Valgrind
 * client request and whose value equals the client request result. Accepts
 * both pointers and integers as arguments.
 */

#define VALGRIND_DO_CLIENT_REQUEST(_zzq_rlval, _zzq_default,            \
                                   _zzq_request, _zzq_arg1, _zzq_arg2,  \
                                   _zzq_arg3, _zzq_arg4, _zzq_arg5)     \
  { (_zzq_rlval) = VALGRIND_DO_CLIENT_REQUEST_EXPR((_zzq_default),      \
                        (_zzq_request), (_zzq_arg1), (_zzq_arg2),       \
                        (_zzq_arg3), (_zzq_arg4), (_zzq_arg5)); }

#if defined(NVALGRIND)

/* Define NVALGRIND to completely remove the Valgrind magic sequence
   from the compiled code (analogous to NDEBUG's effects on
   assert()) */
#define VALGRIND_DO_CLIENT_REQUEST_EXPR(                          \
        _zzq_default, _zzq_request,                               \
        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)    \
      (_zzq_default)

#else  /* ! NVALGRIND */

/* The following defines the magic code sequences which the JITter
   spots and handles magically.  Don't look too closely at them as
   they will rot your brain.

   The assembly code sequences for all architectures is in this one
   file.  This is because this file must be stand-alone, and we don't
   want to have multiple files.

   For VALGRIND_DO_CLIENT_REQUEST, we must ensure that the default
   value gets put in the return slot, so that everything works when
   this is executed not under Valgrind.  Args are passed in a memory
   block, and so there's no intrinsic limit to the number that could
   be passed, but it's currently five.

   The macro args are:
      _zzq_rlval    result lvalue
      _zzq_default  default value (result returned when running on real CPU)
      _zzq_request  request code
      _zzq_arg1..5  request params

   The other two macros are used to support function wrapping, and are
   a lot simpler.  VALGRIND_GET_NR_CONTEXT returns the value of the
   guest's NRADDR pseudo-register and whatever other information is
   needed to safely run the call original from the wrapper: on
   ppc64-linux, the R2 value at the divert point is also needed.  This
   information is abstracted into a user-visible type, OrigFn.

   VALGRIND_CALL_NOREDIR_* behaves the same as the following on the
   guest, but guarantees that the branch instruction will not be
   redirected: x86: call *%eax, amd64: call *%rax, ppc32/ppc64:
   branch-and-link-to-r11.  VALGRIND_CALL_NOREDIR is just text, not a
   complete inline asm, since it needs to be combined with more magic
   inline asm stuff to be useful.
*/

/* ------------------------- x86-{linux,darwin} ---------------- */

#if defined(PLAT_x86_linux)  ||  defined(PLAT_x86_darwin)  \
    ||  (defined(PLAT_x86_win32) && defined(__GNUC__))

typedef
   struct {
      unsigned int nraddr; /* where's the code? */
   }
   OrigFn;

#define __SPECIAL_INSTRUCTION_PREAMBLE                            \
                     "roll $3,  %%edi ; roll $13, %%edi\n\t"      \
                     "roll $29, %%edi ; roll $19, %%edi\n\t"

#define VALGRIND_DO_CLIENT_REQUEST_EXPR(                          \
        _zzq_default, _zzq_request,                               \
        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)    \
  __extension__                                                   \
  ({volatile unsigned int _zzq_args[6];                           \
    volatile unsigned int _zzq_result;                            \
    _zzq_args[0] = (unsigned int)(_zzq_request);                  \
    _zzq_args[1] = (unsigned int)(_zzq_arg1);                     \
    _zzq_args[2] = (unsigned int)(_zzq_arg2);                     \
    _zzq_args[3] = (unsigned int)(_zzq_arg3);                     \
    _zzq_args[4] = (unsigned int)(_zzq_arg4);                     \
    _zzq_args[5] = (unsigned int)(_zzq_arg5);                     \
    __asm__ volatile(__SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* %EDX = client_request ( %EAX ) */         \
                     "xchgl %%ebx,%%ebx"                          \
                     : "=d" (_zzq_result)                         \
                     : "a" (&_zzq_args[0]), "0" (_zzq_default)    \
                     : "cc", "memory"                             \
                    );                                            \
    _zzq_result;                                                  \
  })

#define VALGRIND_GET_NR_CONTEXT(_zzq_rlval)                       \
  { volatile OrigFn* _zzq_orig = &(_zzq_rlval);                   \
    volatile unsigned int __addr;                                 \
    __asm__ volatile(__SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* %EAX = guest_NRADDR */                    \
                     "xchgl %%ecx,%%ecx"                          \
                     : "=a" (__addr)                              \
                     :                                            \
                     : "cc", "memory"                             \
                    );                                            \
    _zzq_orig->nraddr = __addr;                                   \
  }

#define VALGRIND_CALL_NOREDIR_EAX                                 \
                     __SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* call-noredir *%EAX */                     \
                     "xchgl %%edx,%%edx\n\t"
#endif /* PLAT_x86_linux || PLAT_x86_darwin || (PLAT_x86_win32 && __GNUC__) */

/* ------------------------- x86-Win32 ------------------------- */

#if defined(PLAT_x86_win32) && !defined(__GNUC__)

typedef
   struct {
      unsigned int nraddr; /* where's the code? */
   }
   OrigFn;

#if defined(_MSC_VER)

#define __SPECIAL_INSTRUCTION_PREAMBLE                            \
                     __asm rol edi, 3  __asm rol edi, 13          \
                     __asm rol edi, 29 __asm rol edi, 19

#define VALGRIND_DO_CLIENT_REQUEST_EXPR(                          \
        _zzq_default, _zzq_request,                               \
        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)    \
    valgrind_do_client_request_expr((uintptr_t)(_zzq_default),    \
        (uintptr_t)(_zzq_request), (uintptr_t)(_zzq_arg1),        \
        (uintptr_t)(_zzq_arg2), (uintptr_t)(_zzq_arg3),           \
        (uintptr_t)(_zzq_arg4), (uintptr_t)(_zzq_arg5))

static __inline uintptr_t
valgrind_do_client_request_expr(uintptr_t _zzq_default, uintptr_t _zzq_request,
                                uintptr_t _zzq_arg1, uintptr_t _zzq_arg2,
                                uintptr_t _zzq_arg3, uintptr_t _zzq_arg4,
                                uintptr_t _zzq_arg5)
{
    volatile uintptr_t _zzq_args[6];
    volatile unsigned int _zzq_result;
    _zzq_args[0] = (uintptr_t)(_zzq_request);
    _zzq_args[1] = (uintptr_t)(_zzq_arg1);
    _zzq_args[2] = (uintptr_t)(_zzq_arg2);
    _zzq_args[3] = (uintptr_t)(_zzq_arg3);
    _zzq_args[4] = (uintptr_t)(_zzq_arg4);
    _zzq_args[5] = (uintptr_t)(_zzq_arg5);
    __asm { __asm lea eax, _zzq_args __asm mov edx, _zzq_default
            __SPECIAL_INSTRUCTION_PREAMBLE
            /* %EDX = client_request ( %EAX ) */
            __asm xchg ebx,ebx
            __asm mov _zzq_result, edx
    }
    return _zzq_result;
}

#define VALGRIND_GET_NR_CONTEXT(_zzq_rlval)                       \
  { volatile OrigFn* _zzq_orig = &(_zzq_rlval);                   \
    volatile unsigned int __addr;                                 \
    __asm { __SPECIAL_INSTRUCTION_PREAMBLE                        \
            /* %EAX = guest_NRADDR */                             \
            __asm xchg ecx,ecx                                    \
            __asm mov __addr, eax                                 \
    }                                                             \
    _zzq_orig->nraddr = __addr;                                   \
  }

#define VALGRIND_CALL_NOREDIR_EAX ERROR

#else
#error Unsupported compiler.
#endif

#endif /* PLAT_x86_win32 */

/* ------------------------ amd64-{linux,darwin} --------------- */

#if defined(PLAT_amd64_linux)  ||  defined(PLAT_amd64_darwin)

typedef
   struct {
      uint64_t nraddr; /* where's the code? */
   }
   OrigFn;

#define __SPECIAL_INSTRUCTION_PREAMBLE                            \
                     "rolq $3,  %%rdi ; rolq $13, %%rdi\n\t"      \
                     "rolq $61, %%rdi ; rolq $51, %%rdi\n\t"

#define VALGRIND_DO_CLIENT_REQUEST_EXPR(                          \
        _zzq_default, _zzq_request,                               \
        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)    \
    __extension__                                                 \
    ({ volatile uint64_t _zzq_args[6];              \
    volatile uint64_t _zzq_result;                  \
    _zzq_args[0] = (uint64_t)(_zzq_request);        \
    _zzq_args[1] = (uint64_t)(_zzq_arg1);           \
    _zzq_args[2] = (uint64_t)(_zzq_arg2);           \
    _zzq_args[3] = (uint64_t)(_zzq_arg3);           \
    _zzq_args[4] = (uint64_t)(_zzq_arg4);           \
    _zzq_args[5] = (uint64_t)(_zzq_arg5);           \
    __asm__ volatile(__SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* %RDX = client_request ( %RAX ) */         \
                     "xchgq %%rbx,%%rbx"                          \
                     : "=d" (_zzq_result)                         \
                     : "a" (&_zzq_args[0]), "0" (_zzq_default)    \
                     : "cc", "memory"                             \
                    );                                            \
    _zzq_result;                                                  \
    })

#define VALGRIND_GET_NR_CONTEXT(_zzq_rlval)                       \
  { volatile OrigFn* _zzq_orig = &(_zzq_rlval);                   \
    volatile uint64_t __addr;                       \
    __asm__ volatile(__SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* %RAX = guest_NRADDR */                    \
                     "xchgq %%rcx,%%rcx"                          \
                     : "=a" (__addr)                              \
                     :                                            \
                     : "cc", "memory"                             \
                    );                                            \
    _zzq_orig->nraddr = __addr;                                   \
  }

#define VALGRIND_CALL_NOREDIR_RAX                                 \
                     __SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* call-noredir *%RAX */                     \
                     "xchgq %%rdx,%%rdx\n\t"
#endif /* PLAT_amd64_linux || PLAT_amd64_darwin */

/* ------------------------ ppc32-linux ------------------------ */

#if defined(PLAT_ppc32_linux)

typedef
   struct {
      unsigned int nraddr; /* where's the code? */
   }
   OrigFn;

#define __SPECIAL_INSTRUCTION_PREAMBLE                            \
                     "rlwinm 0,0,3,0,0  ; rlwinm 0,0,13,0,0\n\t"  \
                     "rlwinm 0,0,29,0,0 ; rlwinm 0,0,19,0,0\n\t"

#define VALGRIND_DO_CLIENT_REQUEST_EXPR(                          \
        _zzq_default, _zzq_request,                               \
        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)    \
                                                                  \
    __extension__                                                 \
  ({         unsigned int  _zzq_args[6];                          \
             unsigned int  _zzq_result;                           \
             unsigned int* _zzq_ptr;                              \
    _zzq_args[0] = (unsigned int)(_zzq_request);                  \
    _zzq_args[1] = (unsigned int)(_zzq_arg1);                     \
    _zzq_args[2] = (unsigned int)(_zzq_arg2);                     \
    _zzq_args[3] = (unsigned int)(_zzq_arg3);                     \
    _zzq_args[4] = (unsigned int)(_zzq_arg4);                     \
    _zzq_args[5] = (unsigned int)(_zzq_arg5);                     \
    _zzq_ptr = _zzq_args;                                         \
    __asm__ volatile("mr 3,%1\n\t" /*default*/                    \
                     "mr 4,%2\n\t" /*ptr*/                        \
                     __SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* %R3 = client_request ( %R4 ) */           \
                     "or 1,1,1\n\t"                               \
                     "mr %0,3"     /*result*/                     \
                     : "=b" (_zzq_result)                         \
                     : "b" (_zzq_default), "b" (_zzq_ptr)         \
                     : "cc", "memory", "r3", "r4");               \
    _zzq_result;                                                  \
    })

#define VALGRIND_GET_NR_CONTEXT(_zzq_rlval)                       \
  { volatile OrigFn* _zzq_orig = &(_zzq_rlval);                   \
    unsigned int __addr;                                          \
    __asm__ volatile(__SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* %R3 = guest_NRADDR */                     \
                     "or 2,2,2\n\t"                               \
                     "mr %0,3"                                    \
                     : "=b" (__addr)                              \
                     :                                            \
                     : "cc", "memory", "r3"                       \
                    );                                            \
    _zzq_orig->nraddr = __addr;                                   \
  }

#define VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                   \
                     __SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* branch-and-link-to-noredir *%R11 */       \
                     "or 3,3,3\n\t"
#endif /* PLAT_ppc32_linux */

/* ------------------------ ppc64-linux ------------------------ */

#if defined(PLAT_ppc64_linux)

typedef
   struct {
      uint64_t nraddr; /* where's the code? */
      uint64_t r2;  /* what tocptr do we need? */
   }
   OrigFn;

#define __SPECIAL_INSTRUCTION_PREAMBLE                            \
                     "rotldi 0,0,3  ; rotldi 0,0,13\n\t"          \
                     "rotldi 0,0,61 ; rotldi 0,0,51\n\t"

#define VALGRIND_DO_CLIENT_REQUEST_EXPR(                          \
        _zzq_default, _zzq_request,                               \
        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)    \
                                                                  \
  __extension__                                                   \
  ({         uint64_t  _zzq_args[6];                \
    register uint64_t  _zzq_result __asm__("r3");   \
    register uint64_t* _zzq_ptr __asm__("r4");      \
    _zzq_args[0] = (uint64_t)(_zzq_request);        \
    _zzq_args[1] = (uint64_t)(_zzq_arg1);           \
    _zzq_args[2] = (uint64_t)(_zzq_arg2);           \
    _zzq_args[3] = (uint64_t)(_zzq_arg3);           \
    _zzq_args[4] = (uint64_t)(_zzq_arg4);           \
    _zzq_args[5] = (uint64_t)(_zzq_arg5);           \
    _zzq_ptr = _zzq_args;                                         \
    __asm__ volatile(__SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* %R3 = client_request ( %R4 ) */           \
                     "or 1,1,1"                                   \
                     : "=r" (_zzq_result)                         \
                     : "0" (_zzq_default), "r" (_zzq_ptr)         \
                     : "cc", "memory");                           \
    _zzq_result;                                                  \
  })

#define VALGRIND_GET_NR_CONTEXT(_zzq_rlval)                       \
  { volatile OrigFn* _zzq_orig = &(_zzq_rlval);                   \
    register uint64_t __addr __asm__("r3");         \
    __asm__ volatile(__SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* %R3 = guest_NRADDR */                     \
                     "or 2,2,2"                                   \
                     : "=r" (__addr)                              \
                     :                                            \
                     : "cc", "memory"                             \
                    );                                            \
    _zzq_orig->nraddr = __addr;                                   \
    __asm__ volatile(__SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* %R3 = guest_NRADDR_GPR2 */                \
                     "or 4,4,4"                                   \
                     : "=r" (__addr)                              \
                     :                                            \
                     : "cc", "memory"                             \
                    );                                            \
    _zzq_orig->r2 = __addr;                                       \
  }

#define VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                   \
                     __SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* branch-and-link-to-noredir *%R11 */       \
                     "or 3,3,3\n\t"

#endif /* PLAT_ppc64_linux */

/* ------------------------- arm-linux ------------------------- */

#if defined(PLAT_arm_linux)

typedef
   struct {
      unsigned int nraddr; /* where's the code? */
   }
   OrigFn;

#define __SPECIAL_INSTRUCTION_PREAMBLE                            \
            "mov r12, r12, ror #3  ; mov r12, r12, ror #13 \n\t"  \
            "mov r12, r12, ror #29 ; mov r12, r12, ror #19 \n\t"

#define VALGRIND_DO_CLIENT_REQUEST_EXPR(                          \
        _zzq_default, _zzq_request,                               \
        _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)    \
                                                                  \
  __extension__                                                   \
  ({volatile unsigned int  _zzq_args[6];                          \
    volatile unsigned int  _zzq_result;                           \
    _zzq_args[0] = (unsigned int)(_zzq_request);                  \
    _zzq_args[1] = (unsigned int)(_zzq_arg1);                     \
    _zzq_args[2] = (unsigned int)(_zzq_arg2);                     \
    _zzq_args[3] = (unsigned int)(_zzq_arg3);                     \
    _zzq_args[4] = (unsigned int)(_zzq_arg4);                     \
    _zzq_args[5] = (unsigned int)(_zzq_arg5);                     \
    __asm__ volatile("mov r3, %1\n\t" /*default*/                 \
                     "mov r4, %2\n\t" /*ptr*/                     \
                     __SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* R3 = client_request ( R4 ) */             \
                     "orr r10, r10, r10\n\t"                      \
                     "mov %0, r3"     /*result*/                  \
                     : "=r" (_zzq_result)                         \
                     : "r" (_zzq_default), "r" (&_zzq_args[0])    \
                     : "cc","memory", "r3", "r4");                \
    _zzq_result;                                                  \
  })

#define VALGRIND_GET_NR_CONTEXT(_zzq_rlval)                       \
  { volatile OrigFn* _zzq_orig = &(_zzq_rlval);                   \
    unsigned int __addr;                                          \
    __asm__ volatile(__SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* R3 = guest_NRADDR */                      \
                     "orr r11, r11, r11\n\t"                      \
                     "mov %0, r3"                                 \
                     : "=r" (__addr)                              \
                     :                                            \
                     : "cc", "memory", "r3"                       \
                    );                                            \
    _zzq_orig->nraddr = __addr;                                   \
  }

#define VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                    \
                     __SPECIAL_INSTRUCTION_PREAMBLE               \
                     /* branch-and-link-to-noredir *%R4 */        \
                     "orr r12, r12, r12\n\t"

#endif /* PLAT_arm_linux */

/* ------------------------ s390x-linux ------------------------ */

#if defined(PLAT_s390x_linux)

typedef
  struct {
     uint64_t nraddr; /* where's the code? */
  }
  OrigFn;

/* __SPECIAL_INSTRUCTION_PREAMBLE will be used to identify Valgrind specific
 * code. This detection is implemented in platform specific toIR.c
 * (e.g. VEX/priv/guest_s390_decoder.c).
 */
#define __SPECIAL_INSTRUCTION_PREAMBLE                           \
                     "lr 15,15\n\t"                              \
                     "lr 1,1\n\t"                                \
                     "lr 2,2\n\t"                                \
                     "lr 3,3\n\t"

#define __CLIENT_REQUEST_CODE "lr 2,2\n\t"
#define __GET_NR_CONTEXT_CODE "lr 3,3\n\t"
#define __CALL_NO_REDIR_CODE  "lr 4,4\n\t"

#define VALGRIND_DO_CLIENT_REQUEST_EXPR(                         \
       _zzq_default, _zzq_request,                               \
       _zzq_arg1, _zzq_arg2, _zzq_arg3, _zzq_arg4, _zzq_arg5)    \
  __extension__                                                  \
 ({volatile uint64_t _zzq_args[6];                 \
   volatile uint64_t _zzq_result;                  \
   _zzq_args[0] = (uint64_t)(_zzq_request);        \
   _zzq_args[1] = (uint64_t)(_zzq_arg1);           \
   _zzq_args[2] = (uint64_t)(_zzq_arg2);           \
   _zzq_args[3] = (uint64_t)(_zzq_arg3);           \
   _zzq_args[4] = (uint64_t)(_zzq_arg4);           \
   _zzq_args[5] = (uint64_t)(_zzq_arg5);           \
   __asm__ volatile(/* r2 = args */                              \
                    "lgr 2,%1\n\t"                               \
                    /* r3 = default */                           \
                    "lgr 3,%2\n\t"                               \
                    __SPECIAL_INSTRUCTION_PREAMBLE               \
                    __CLIENT_REQUEST_CODE                        \
                    /* results = r3 */                           \
                    "lgr %0, 3\n\t"                              \
                    : "=d" (_zzq_result)                         \
                    : "a" (&_zzq_args[0]), "0" (_zzq_default)    \
                    : "cc", "2", "3", "memory"                   \
                   );                                            \
   _zzq_result;                                                  \
 })

#define VALGRIND_GET_NR_CONTEXT(_zzq_rlval)                      \
 { volatile OrigFn* _zzq_orig = &(_zzq_rlval);                   \
   volatile uint64_t __addr;                       \
   __asm__ volatile(__SPECIAL_INSTRUCTION_PREAMBLE               \
                    __GET_NR_CONTEXT_CODE                        \
                    "lgr %0, 3\n\t"                              \
                    : "=a" (__addr)                              \
                    :                                            \
                    : "cc", "3", "memory"                        \
                   );                                            \
   _zzq_orig->nraddr = __addr;                                   \
 }

#define VALGRIND_CALL_NOREDIR_R1                                 \
                    __SPECIAL_INSTRUCTION_PREAMBLE               \
                    __CALL_NO_REDIR_CODE

#endif /* PLAT_s390x_linux */

/* Insert assembly code for other platforms here... */

#endif /* NVALGRIND */


/* ------------------------------------------------------------------ */
/* PLATFORM SPECIFICS for FUNCTION WRAPPING.  This is all very        */
/* ugly.  It's the least-worst tradeoff I can think of.               */
/* ------------------------------------------------------------------ */

/* This section defines magic (a.k.a appalling-hack) macros for doing
   guaranteed-no-redirection macros, so as to get from function
   wrappers to the functions they are wrapping.  The whole point is to
   construct standard call sequences, but to do the call itself with a
   special no-redirect call pseudo-instruction that the JIT
   understands and handles specially.  This section is long and
   repetitious, and I can't see a way to make it shorter.

   The naming scheme is as follows:

      CALL_FN_{W,v}_{v,W,WW,WWW,WWWW,5W,6W,7W,etc}

   'W' stands for "word" and 'v' for "void".  Hence there are
   different macros for calling arity 0, 1, 2, 3, 4, etc, functions,
   and for each, the possibility of returning a word-typed result, or
   no result.
*/

/* Use these to write the name of your wrapper.  NOTE: duplicates
   VG_WRAP_FUNCTION_Z{U,Z} in pub_tool_redir.h. */

/* Use an extra level of macroisation so as to ensure the soname/fnname
   args are fully macro-expanded before pasting them together. */
#define VG_CONCAT4(_aa,_bb,_cc,_dd) _aa##_bb##_cc##_dd

#define I_WRAP_SONAME_FNNAME_ZU(soname,fnname)                    \
   VG_CONCAT4(_vgwZU_,soname,_,fnname)

#define I_WRAP_SONAME_FNNAME_ZZ(soname,fnname)                    \
   VG_CONCAT4(_vgwZZ_,soname,_,fnname)

/* Use this macro from within a wrapper function to collect the
   context (address and possibly other info) of the original function.
   Once you have that you can then use it in one of the CALL_FN_
   macros.  The type of the argument _lval is OrigFn. */
#define VALGRIND_GET_ORIG_FN(_lval)  VALGRIND_GET_NR_CONTEXT(_lval)

/* Derivatives of the main macros below, for calling functions
   returning void. */

#define CALL_FN_v_v(fnptr)                                        \
   do { volatile unsigned long _junk;                             \
        CALL_FN_W_v(_junk,fnptr); } while (0)

#define CALL_FN_v_W(fnptr, arg1)                                  \
   do { volatile unsigned long _junk;                             \
        CALL_FN_W_W(_junk,fnptr,arg1); } while (0)

#define CALL_FN_v_WW(fnptr, arg1,arg2)                            \
   do { volatile unsigned long _junk;                             \
        CALL_FN_W_WW(_junk,fnptr,arg1,arg2); } while (0)

#define CALL_FN_v_WWW(fnptr, arg1,arg2,arg3)                      \
   do { volatile unsigned long _junk;                             \
        CALL_FN_W_WWW(_junk,fnptr,arg1,arg2,arg3); } while (0)

#define CALL_FN_v_WWWW(fnptr, arg1,arg2,arg3,arg4)                \
   do { volatile unsigned long _junk;                             \
        CALL_FN_W_WWWW(_junk,fnptr,arg1,arg2,arg3,arg4); } while (0)

#define CALL_FN_v_5W(fnptr, arg1,arg2,arg3,arg4,arg5)             \
   do { volatile unsigned long _junk;                             \
        CALL_FN_W_5W(_junk,fnptr,arg1,arg2,arg3,arg4,arg5); } while (0)

#define CALL_FN_v_6W(fnptr, arg1,arg2,arg3,arg4,arg5,arg6)        \
   do { volatile unsigned long _junk;                             \
        CALL_FN_W_6W(_junk,fnptr,arg1,arg2,arg3,arg4,arg5,arg6); } while (0)

#define CALL_FN_v_7W(fnptr, arg1,arg2,arg3,arg4,arg5,arg6,arg7)   \
   do { volatile unsigned long _junk;                             \
        CALL_FN_W_7W(_junk,fnptr,arg1,arg2,arg3,arg4,arg5,arg6,arg7); } while (0)

/* ------------------------- x86-{linux,darwin} ---------------- */

#if defined(PLAT_x86_linux)  ||  defined(PLAT_x86_darwin)

/* These regs are trashed by the hidden call.  No need to mention eax
   as gcc can already see that, plus causes gcc to bomb. */
#define __CALLER_SAVED_REGS /*"eax"*/ "ecx", "edx"

/* These CALL_FN_ macros assume that on x86-linux, sizeof(unsigned
   long) == 4. */

#define CALL_FN_W_v(lval, orig)                                   \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[1];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      __asm__ volatile(                                           \
         "movl (%%eax), %%eax\n\t"  /* target->%eax */            \
         VALGRIND_CALL_NOREDIR_EAX                                \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_W(lval, orig, arg1)                             \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[2];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      __asm__ volatile(                                           \
         "subl $12, %%esp\n\t"                                    \
         "pushl 4(%%eax)\n\t"                                     \
         "movl (%%eax), %%eax\n\t"  /* target->%eax */            \
         VALGRIND_CALL_NOREDIR_EAX                                \
         "addl $16, %%esp\n"                                      \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WW(lval, orig, arg1,arg2)                       \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      __asm__ volatile(                                           \
         "subl $8, %%esp\n\t"                                     \
         "pushl 8(%%eax)\n\t"                                     \
         "pushl 4(%%eax)\n\t"                                     \
         "movl (%%eax), %%eax\n\t"  /* target->%eax */            \
         VALGRIND_CALL_NOREDIR_EAX                                \
         "addl $16, %%esp\n"                                      \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WWW(lval, orig, arg1,arg2,arg3)                 \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[4];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      __asm__ volatile(                                           \
         "subl $4, %%esp\n\t"                                     \
         "pushl 12(%%eax)\n\t"                                    \
         "pushl 8(%%eax)\n\t"                                     \
         "pushl 4(%%eax)\n\t"                                     \
         "movl (%%eax), %%eax\n\t"  /* target->%eax */            \
         VALGRIND_CALL_NOREDIR_EAX                                \
         "addl $16, %%esp\n"                                      \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WWWW(lval, orig, arg1,arg2,arg3,arg4)           \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[5];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      __asm__ volatile(                                           \
         "pushl 16(%%eax)\n\t"                                    \
         "pushl 12(%%eax)\n\t"                                    \
         "pushl 8(%%eax)\n\t"                                     \
         "pushl 4(%%eax)\n\t"                                     \
         "movl (%%eax), %%eax\n\t"  /* target->%eax */            \
         VALGRIND_CALL_NOREDIR_EAX                                \
         "addl $16, %%esp\n"                                      \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_5W(lval, orig, arg1,arg2,arg3,arg4,arg5)        \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[6];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      __asm__ volatile(                                           \
         "subl $12, %%esp\n\t"                                    \
         "pushl 20(%%eax)\n\t"                                    \
         "pushl 16(%%eax)\n\t"                                    \
         "pushl 12(%%eax)\n\t"                                    \
         "pushl 8(%%eax)\n\t"                                     \
         "pushl 4(%%eax)\n\t"                                     \
         "movl (%%eax), %%eax\n\t"  /* target->%eax */            \
         VALGRIND_CALL_NOREDIR_EAX                                \
         "addl $32, %%esp\n"                                      \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_6W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6)   \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[7];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      __asm__ volatile(                                           \
         "subl $8, %%esp\n\t"                                     \
         "pushl 24(%%eax)\n\t"                                    \
         "pushl 20(%%eax)\n\t"                                    \
         "pushl 16(%%eax)\n\t"                                    \
         "pushl 12(%%eax)\n\t"                                    \
         "pushl 8(%%eax)\n\t"                                     \
         "pushl 4(%%eax)\n\t"                                     \
         "movl (%%eax), %%eax\n\t"  /* target->%eax */            \
         VALGRIND_CALL_NOREDIR_EAX                                \
         "addl $32, %%esp\n"                                      \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_7W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7)                            \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[8];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      __asm__ volatile(                                           \
         "subl $4, %%esp\n\t"                                     \
         "pushl 28(%%eax)\n\t"                                    \
         "pushl 24(%%eax)\n\t"                                    \
         "pushl 20(%%eax)\n\t"                                    \
         "pushl 16(%%eax)\n\t"                                    \
         "pushl 12(%%eax)\n\t"                                    \
         "pushl 8(%%eax)\n\t"                                     \
         "pushl 4(%%eax)\n\t"                                     \
         "movl (%%eax), %%eax\n\t"  /* target->%eax */            \
         VALGRIND_CALL_NOREDIR_EAX                                \
         "addl $32, %%esp\n"                                      \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_8W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7,arg8)                       \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[9];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      __asm__ volatile(                                           \
         "pushl 32(%%eax)\n\t"                                    \
         "pushl 28(%%eax)\n\t"                                    \
         "pushl 24(%%eax)\n\t"                                    \
         "pushl 20(%%eax)\n\t"                                    \
         "pushl 16(%%eax)\n\t"                                    \
         "pushl 12(%%eax)\n\t"                                    \
         "pushl 8(%%eax)\n\t"                                     \
         "pushl 4(%%eax)\n\t"                                     \
         "movl (%%eax), %%eax\n\t"  /* target->%eax */            \
         VALGRIND_CALL_NOREDIR_EAX                                \
         "addl $32, %%esp\n"                                      \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_9W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7,arg8,arg9)                  \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[10];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      _argvec[9] = (unsigned long)(arg9);                         \
      __asm__ volatile(                                           \
         "subl $12, %%esp\n\t"                                    \
         "pushl 36(%%eax)\n\t"                                    \
         "pushl 32(%%eax)\n\t"                                    \
         "pushl 28(%%eax)\n\t"                                    \
         "pushl 24(%%eax)\n\t"                                    \
         "pushl 20(%%eax)\n\t"                                    \
         "pushl 16(%%eax)\n\t"                                    \
         "pushl 12(%%eax)\n\t"                                    \
         "pushl 8(%%eax)\n\t"                                     \
         "pushl 4(%%eax)\n\t"                                     \
         "movl (%%eax), %%eax\n\t"  /* target->%eax */            \
         VALGRIND_CALL_NOREDIR_EAX                                \
         "addl $48, %%esp\n"                                      \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_10W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,  \
                                  arg7,arg8,arg9,arg10)           \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[11];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      _argvec[9] = (unsigned long)(arg9);                         \
      _argvec[10] = (unsigned long)(arg10);                       \
      __asm__ volatile(                                           \
         "subl $8, %%esp\n\t"                                     \
         "pushl 40(%%eax)\n\t"                                    \
         "pushl 36(%%eax)\n\t"                                    \
         "pushl 32(%%eax)\n\t"                                    \
         "pushl 28(%%eax)\n\t"                                    \
         "pushl 24(%%eax)\n\t"                                    \
         "pushl 20(%%eax)\n\t"                                    \
         "pushl 16(%%eax)\n\t"                                    \
         "pushl 12(%%eax)\n\t"                                    \
         "pushl 8(%%eax)\n\t"                                     \
         "pushl 4(%%eax)\n\t"                                     \
         "movl (%%eax), %%eax\n\t"  /* target->%eax */            \
         VALGRIND_CALL_NOREDIR_EAX                                \
         "addl $48, %%esp\n"                                      \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_11W(lval, orig, arg1,arg2,arg3,arg4,arg5,       \
                                  arg6,arg7,arg8,arg9,arg10,      \
                                  arg11)                          \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[12];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      _argvec[9] = (unsigned long)(arg9);                         \
      _argvec[10] = (unsigned long)(arg10);                       \
      _argvec[11] = (unsigned long)(arg11);                       \
      __asm__ volatile(                                           \
         "subl $4, %%esp\n\t"                                     \
         "pushl 44(%%eax)\n\t"                                    \
         "pushl 40(%%eax)\n\t"                                    \
         "pushl 36(%%eax)\n\t"                                    \
         "pushl 32(%%eax)\n\t"                                    \
         "pushl 28(%%eax)\n\t"                                    \
         "pushl 24(%%eax)\n\t"                                    \
         "pushl 20(%%eax)\n\t"                                    \
         "pushl 16(%%eax)\n\t"                                    \
         "pushl 12(%%eax)\n\t"                                    \
         "pushl 8(%%eax)\n\t"                                     \
         "pushl 4(%%eax)\n\t"                                     \
         "movl (%%eax), %%eax\n\t"  /* target->%eax */            \
         VALGRIND_CALL_NOREDIR_EAX                                \
         "addl $48, %%esp\n"                                      \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_12W(lval, orig, arg1,arg2,arg3,arg4,arg5,       \
                                  arg6,arg7,arg8,arg9,arg10,      \
                                  arg11,arg12)                    \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[13];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      _argvec[9] = (unsigned long)(arg9);                         \
      _argvec[10] = (unsigned long)(arg10);                       \
      _argvec[11] = (unsigned long)(arg11);                       \
      _argvec[12] = (unsigned long)(arg12);                       \
      __asm__ volatile(                                           \
         "pushl 48(%%eax)\n\t"                                    \
         "pushl 44(%%eax)\n\t"                                    \
         "pushl 40(%%eax)\n\t"                                    \
         "pushl 36(%%eax)\n\t"                                    \
         "pushl 32(%%eax)\n\t"                                    \
         "pushl 28(%%eax)\n\t"                                    \
         "pushl 24(%%eax)\n\t"                                    \
         "pushl 20(%%eax)\n\t"                                    \
         "pushl 16(%%eax)\n\t"                                    \
         "pushl 12(%%eax)\n\t"                                    \
         "pushl 8(%%eax)\n\t"                                     \
         "pushl 4(%%eax)\n\t"                                     \
         "movl (%%eax), %%eax\n\t"  /* target->%eax */            \
         VALGRIND_CALL_NOREDIR_EAX                                \
         "addl $48, %%esp\n"                                      \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#endif /* PLAT_x86_linux || PLAT_x86_darwin */

/* ------------------------ amd64-{linux,darwin} --------------- */

#if defined(PLAT_amd64_linux)  ||  defined(PLAT_amd64_darwin)

/* ARGREGS: rdi rsi rdx rcx r8 r9 (the rest on stack in R-to-L order) */

/* These regs are trashed by the hidden call. */
#define __CALLER_SAVED_REGS /*"rax",*/ "rcx", "rdx", "rsi",       \
                            "rdi", "r8", "r9", "r10", "r11"

/* This is all pretty complex.  It's so as to make stack unwinding
   work reliably.  See bug 243270.  The basic problem is the sub and
   add of 128 of %rsp in all of the following macros.  If gcc believes
   the CFA is in %rsp, then unwinding may fail, because what's at the
   CFA is not what gcc "expected" when it constructs the CFIs for the
   places where the macros are instantiated.

   But we can't just add a CFI annotation to increase the CFA offset
   by 128, to match the sub of 128 from %rsp, because we don't know
   whether gcc has chosen %rsp as the CFA at that point, or whether it
   has chosen some other register (eg, %rbp).  In the latter case,
   adding a CFI annotation to change the CFA offset is simply wrong.

   So the solution is to get hold of the CFA using
   __builtin_dwarf_cfa(), put it in a known register, and add a
   CFI annotation to say what the register is.  We choose %rbp for
   this (perhaps perversely), because:

   (1) %rbp is already subject to unwinding.  If a new register was
       chosen then the unwinder would have to unwind it in all stack
       traces, which is expensive, and

   (2) %rbp is already subject to precise exception updates in the
       JIT.  If a new register was chosen, we'd have to have precise
       exceptions for it too, which reduces performance of the
       generated code.

   However .. one extra complication.  We can't just whack the result
   of __builtin_dwarf_cfa() into %rbp and then add %rbp to the
   list of trashed registers at the end of the inline assembly
   fragments; gcc won't allow %rbp to appear in that list.  Hence
   instead we need to stash %rbp in %r15 for the duration of the asm,
   and say that %r15 is trashed instead.  gcc seems happy to go with
   that.

   Oh .. and this all needs to be conditionalised so that it is
   unchanged from before this commit, when compiled with older gccs
   that don't support __builtin_dwarf_cfa.  Furthermore, since
   this header file is freestanding, it has to be independent of
   config.h, and so the following conditionalisation cannot depend on
   configure time checks.

   Although it's not clear from
   'defined(__GNUC__) && defined(__GCC_HAVE_DWARF2_CFI_ASM)',
   this expression excludes Darwin.
   .cfi directives in Darwin assembly appear to be completely
   different and I haven't investigated how they work.

   For even more entertainment value, note we have to use the
   completely undocumented __builtin_dwarf_cfa(), which appears to
   really compute the CFA, whereas __builtin_frame_address(0) claims
   to but actually doesn't.  See
   https://bugs.kde.org/show_bug.cgi?id=243270#c47
*/
#if defined(__GNUC__) && defined(__GCC_HAVE_DWARF2_CFI_ASM)
#  define __FRAME_POINTER                                         \
      ,"r"(__builtin_dwarf_cfa())
#  define VALGRIND_CFI_PROLOGUE                                   \
      "movq %%rbp, %%r15\n\t"                                     \
      "movq %2, %%rbp\n\t"                                        \
      ".cfi_remember_state\n\t"                                   \
      ".cfi_def_cfa rbp, 0\n\t"
#  define VALGRIND_CFI_EPILOGUE                                   \
      "movq %%r15, %%rbp\n\t"                                     \
      ".cfi_restore_state\n\t"
#else
#  define __FRAME_POINTER
#  define VALGRIND_CFI_PROLOGUE
#  define VALGRIND_CFI_EPILOGUE
#endif


/* These CALL_FN_ macros assume that on amd64-linux, sizeof(unsigned
   long) == 8. */

/* NB 9 Sept 07.  There is a nasty kludge here in all these CALL_FN_
   macros.  In order not to trash the stack redzone, we need to drop
   %rsp by 128 before the hidden call, and restore afterwards.  The
   nastyness is that it is only by luck that the stack still appears
   to be unwindable during the hidden call - since then the behaviour
   of any routine using this macro does not match what the CFI data
   says.  Sigh.

   Why is this important?  Imagine that a wrapper has a stack
   allocated local, and passes to the hidden call, a pointer to it.
   Because gcc does not know about the hidden call, it may allocate
   that local in the redzone.  Unfortunately the hidden call may then
   trash it before it comes to use it.  So we must step clear of the
   redzone, for the duration of the hidden call, to make it safe.

   Probably the same problem afflicts the other redzone-style ABIs too
   (ppc64-linux); but for those, the stack is
   self describing (none of this CFI nonsense) so at least messing
   with the stack pointer doesn't give a danger of non-unwindable
   stack. */

#define CALL_FN_W_v(lval, orig)                                   \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[1];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      __asm__ volatile(                                           \
         VALGRIND_CFI_PROLOGUE                                    \
         "subq $128,%%rsp\n\t"                                    \
         "movq (%%rax), %%rax\n\t"  /* target->%rax */            \
         VALGRIND_CALL_NOREDIR_RAX                                \
         "addq $128,%%rsp\n\t"                                    \
         VALGRIND_CFI_EPILOGUE                                    \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS, "r15"   \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_W(lval, orig, arg1)                             \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[2];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      __asm__ volatile(                                           \
         VALGRIND_CFI_PROLOGUE                                    \
         "subq $128,%%rsp\n\t"                                    \
         "movq 8(%%rax), %%rdi\n\t"                               \
         "movq (%%rax), %%rax\n\t"  /* target->%rax */            \
         VALGRIND_CALL_NOREDIR_RAX                                \
         "addq $128,%%rsp\n\t"                                    \
         VALGRIND_CFI_EPILOGUE                                    \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS, "r15"   \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WW(lval, orig, arg1,arg2)                       \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      __asm__ volatile(                                           \
         VALGRIND_CFI_PROLOGUE                                    \
         "subq $128,%%rsp\n\t"                                    \
         "movq 16(%%rax), %%rsi\n\t"                              \
         "movq 8(%%rax), %%rdi\n\t"                               \
         "movq (%%rax), %%rax\n\t"  /* target->%rax */            \
         VALGRIND_CALL_NOREDIR_RAX                                \
         "addq $128,%%rsp\n\t"                                    \
         VALGRIND_CFI_EPILOGUE                                    \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS, "r15"   \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WWW(lval, orig, arg1,arg2,arg3)                 \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[4];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      __asm__ volatile(                                           \
         VALGRIND_CFI_PROLOGUE                                    \
         "subq $128,%%rsp\n\t"                                    \
         "movq 24(%%rax), %%rdx\n\t"                              \
         "movq 16(%%rax), %%rsi\n\t"                              \
         "movq 8(%%rax), %%rdi\n\t"                               \
         "movq (%%rax), %%rax\n\t"  /* target->%rax */            \
         VALGRIND_CALL_NOREDIR_RAX                                \
         "addq $128,%%rsp\n\t"                                    \
         VALGRIND_CFI_EPILOGUE                                    \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS, "r15"   \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WWWW(lval, orig, arg1,arg2,arg3,arg4)           \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[5];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      __asm__ volatile(                                           \
         VALGRIND_CFI_PROLOGUE                                    \
         "subq $128,%%rsp\n\t"                                    \
         "movq 32(%%rax), %%rcx\n\t"                              \
         "movq 24(%%rax), %%rdx\n\t"                              \
         "movq 16(%%rax), %%rsi\n\t"                              \
         "movq 8(%%rax), %%rdi\n\t"                               \
         "movq (%%rax), %%rax\n\t"  /* target->%rax */            \
         VALGRIND_CALL_NOREDIR_RAX                                \
         "addq $128,%%rsp\n\t"                                    \
         VALGRIND_CFI_EPILOGUE                                    \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS, "r15"   \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_5W(lval, orig, arg1,arg2,arg3,arg4,arg5)        \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[6];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      __asm__ volatile(                                           \
         VALGRIND_CFI_PROLOGUE                                    \
         "subq $128,%%rsp\n\t"                                    \
         "movq 40(%%rax), %%r8\n\t"                               \
         "movq 32(%%rax), %%rcx\n\t"                              \
         "movq 24(%%rax), %%rdx\n\t"                              \
         "movq 16(%%rax), %%rsi\n\t"                              \
         "movq 8(%%rax), %%rdi\n\t"                               \
         "movq (%%rax), %%rax\n\t"  /* target->%rax */            \
         VALGRIND_CALL_NOREDIR_RAX                                \
         "addq $128,%%rsp\n\t"                                    \
         VALGRIND_CFI_EPILOGUE                                    \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS, "r15"   \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_6W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6)   \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[7];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      __asm__ volatile(                                           \
         VALGRIND_CFI_PROLOGUE                                    \
         "subq $128,%%rsp\n\t"                                    \
         "movq 48(%%rax), %%r9\n\t"                               \
         "movq 40(%%rax), %%r8\n\t"                               \
         "movq 32(%%rax), %%rcx\n\t"                              \
         "movq 24(%%rax), %%rdx\n\t"                              \
         "movq 16(%%rax), %%rsi\n\t"                              \
         "movq 8(%%rax), %%rdi\n\t"                               \
         "movq (%%rax), %%rax\n\t"  /* target->%rax */            \
         VALGRIND_CALL_NOREDIR_RAX                                \
         "addq $128,%%rsp\n\t"                                    \
         VALGRIND_CFI_EPILOGUE                                    \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS, "r15"   \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_7W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7)                            \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[8];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      __asm__ volatile(                                           \
         VALGRIND_CFI_PROLOGUE                                    \
         "subq $136,%%rsp\n\t"                                    \
         "pushq 56(%%rax)\n\t"                                    \
         "movq 48(%%rax), %%r9\n\t"                               \
         "movq 40(%%rax), %%r8\n\t"                               \
         "movq 32(%%rax), %%rcx\n\t"                              \
         "movq 24(%%rax), %%rdx\n\t"                              \
         "movq 16(%%rax), %%rsi\n\t"                              \
         "movq 8(%%rax), %%rdi\n\t"                               \
         "movq (%%rax), %%rax\n\t"  /* target->%rax */            \
         VALGRIND_CALL_NOREDIR_RAX                                \
         "addq $8, %%rsp\n"                                       \
         "addq $136,%%rsp\n\t"                                    \
         VALGRIND_CFI_EPILOGUE                                    \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS, "r15"   \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_8W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7,arg8)                       \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[9];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      __asm__ volatile(                                           \
         VALGRIND_CFI_PROLOGUE                                    \
         "subq $128,%%rsp\n\t"                                    \
         "pushq 64(%%rax)\n\t"                                    \
         "pushq 56(%%rax)\n\t"                                    \
         "movq 48(%%rax), %%r9\n\t"                               \
         "movq 40(%%rax), %%r8\n\t"                               \
         "movq 32(%%rax), %%rcx\n\t"                              \
         "movq 24(%%rax), %%rdx\n\t"                              \
         "movq 16(%%rax), %%rsi\n\t"                              \
         "movq 8(%%rax), %%rdi\n\t"                               \
         "movq (%%rax), %%rax\n\t"  /* target->%rax */            \
         VALGRIND_CALL_NOREDIR_RAX                                \
         "addq $16, %%rsp\n"                                      \
         "addq $128,%%rsp\n\t"                                    \
         VALGRIND_CFI_EPILOGUE                                    \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS, "r15"   \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_9W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7,arg8,arg9)                  \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[10];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      _argvec[9] = (unsigned long)(arg9);                         \
      __asm__ volatile(                                           \
         VALGRIND_CFI_PROLOGUE                                    \
         "subq $136,%%rsp\n\t"                                    \
         "pushq 72(%%rax)\n\t"                                    \
         "pushq 64(%%rax)\n\t"                                    \
         "pushq 56(%%rax)\n\t"                                    \
         "movq 48(%%rax), %%r9\n\t"                               \
         "movq 40(%%rax), %%r8\n\t"                               \
         "movq 32(%%rax), %%rcx\n\t"                              \
         "movq 24(%%rax), %%rdx\n\t"                              \
         "movq 16(%%rax), %%rsi\n\t"                              \
         "movq 8(%%rax), %%rdi\n\t"                               \
         "movq (%%rax), %%rax\n\t"  /* target->%rax */            \
         VALGRIND_CALL_NOREDIR_RAX                                \
         "addq $24, %%rsp\n"                                      \
         "addq $136,%%rsp\n\t"                                    \
         VALGRIND_CFI_EPILOGUE                                    \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS, "r15"   \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_10W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,  \
                                  arg7,arg8,arg9,arg10)           \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[11];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      _argvec[9] = (unsigned long)(arg9);                         \
      _argvec[10] = (unsigned long)(arg10);                       \
      __asm__ volatile(                                           \
         VALGRIND_CFI_PROLOGUE                                    \
         "subq $128,%%rsp\n\t"                                    \
         "pushq 80(%%rax)\n\t"                                    \
         "pushq 72(%%rax)\n\t"                                    \
         "pushq 64(%%rax)\n\t"                                    \
         "pushq 56(%%rax)\n\t"                                    \
         "movq 48(%%rax), %%r9\n\t"                               \
         "movq 40(%%rax), %%r8\n\t"                               \
         "movq 32(%%rax), %%rcx\n\t"                              \
         "movq 24(%%rax), %%rdx\n\t"                              \
         "movq 16(%%rax), %%rsi\n\t"                              \
         "movq 8(%%rax), %%rdi\n\t"                               \
         "movq (%%rax), %%rax\n\t"  /* target->%rax */            \
         VALGRIND_CALL_NOREDIR_RAX                                \
         "addq $32, %%rsp\n"                                      \
         "addq $128,%%rsp\n\t"                                    \
         VALGRIND_CFI_EPILOGUE                                    \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS, "r15"   \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_11W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,  \
                                  arg7,arg8,arg9,arg10,arg11)     \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[12];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      _argvec[9] = (unsigned long)(arg9);                         \
      _argvec[10] = (unsigned long)(arg10);                       \
      _argvec[11] = (unsigned long)(arg11);                       \
      __asm__ volatile(                                           \
         VALGRIND_CFI_PROLOGUE                                    \
         "subq $136,%%rsp\n\t"                                    \
         "pushq 88(%%rax)\n\t"                                    \
         "pushq 80(%%rax)\n\t"                                    \
         "pushq 72(%%rax)\n\t"                                    \
         "pushq 64(%%rax)\n\t"                                    \
         "pushq 56(%%rax)\n\t"                                    \
         "movq 48(%%rax), %%r9\n\t"                               \
         "movq 40(%%rax), %%r8\n\t"                               \
         "movq 32(%%rax), %%rcx\n\t"                              \
         "movq 24(%%rax), %%rdx\n\t"                              \
         "movq 16(%%rax), %%rsi\n\t"                              \
         "movq 8(%%rax), %%rdi\n\t"                               \
         "movq (%%rax), %%rax\n\t"  /* target->%rax */            \
         VALGRIND_CALL_NOREDIR_RAX                                \
         "addq $40, %%rsp\n"                                      \
         "addq $136,%%rsp\n\t"                                    \
         VALGRIND_CFI_EPILOGUE                                    \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS, "r15"   \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_12W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,  \
                                arg7,arg8,arg9,arg10,arg11,arg12) \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[13];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      _argvec[9] = (unsigned long)(arg9);                         \
      _argvec[10] = (unsigned long)(arg10);                       \
      _argvec[11] = (unsigned long)(arg11);                       \
      _argvec[12] = (unsigned long)(arg12);                       \
      __asm__ volatile(                                           \
         VALGRIND_CFI_PROLOGUE                                    \
         "subq $128,%%rsp\n\t"                                    \
         "pushq 96(%%rax)\n\t"                                    \
         "pushq 88(%%rax)\n\t"                                    \
         "pushq 80(%%rax)\n\t"                                    \
         "pushq 72(%%rax)\n\t"                                    \
         "pushq 64(%%rax)\n\t"                                    \
         "pushq 56(%%rax)\n\t"                                    \
         "movq 48(%%rax), %%r9\n\t"                               \
         "movq 40(%%rax), %%r8\n\t"                               \
         "movq 32(%%rax), %%rcx\n\t"                              \
         "movq 24(%%rax), %%rdx\n\t"                              \
         "movq 16(%%rax), %%rsi\n\t"                              \
         "movq 8(%%rax), %%rdi\n\t"                               \
         "movq (%%rax), %%rax\n\t"  /* target->%rax */            \
         VALGRIND_CALL_NOREDIR_RAX                                \
         "addq $48, %%rsp\n"                                      \
         "addq $128,%%rsp\n\t"                                    \
         VALGRIND_CFI_EPILOGUE                                    \
         : /*out*/   "=a" (_res)                                  \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS, "r15"   \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#endif /* PLAT_amd64_linux || PLAT_amd64_darwin */

/* ------------------------ ppc32-linux ------------------------ */

#if defined(PLAT_ppc32_linux)

/* This is useful for finding out about the on-stack stuff:

   extern int f9  ( int,int,int,int,int,int,int,int,int );
   extern int f10 ( int,int,int,int,int,int,int,int,int,int );
   extern int f11 ( int,int,int,int,int,int,int,int,int,int,int );
   extern int f12 ( int,int,int,int,int,int,int,int,int,int,int,int );

   int g9 ( void ) {
      return f9(11,22,33,44,55,66,77,88,99);
   }
   int g10 ( void ) {
      return f10(11,22,33,44,55,66,77,88,99,110);
   }
   int g11 ( void ) {
      return f11(11,22,33,44,55,66,77,88,99,110,121);
   }
   int g12 ( void ) {
      return f12(11,22,33,44,55,66,77,88,99,110,121,132);
   }
*/

/* ARGREGS: r3 r4 r5 r6 r7 r8 r9 r10 (the rest on stack somewhere) */

/* These regs are trashed by the hidden call. */
#define __CALLER_SAVED_REGS                                       \
   "lr", "ctr", "xer",                                            \
   "cr0", "cr1", "cr2", "cr3", "cr4", "cr5", "cr6", "cr7",        \
   "r0", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10",   \
   "r11", "r12", "r13"

/* These CALL_FN_ macros assume that on ppc32-linux,
   sizeof(unsigned long) == 4. */

#define CALL_FN_W_v(lval, orig)                                   \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[1];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "lwz 11,0(11)\n\t"  /* target->r11 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr %0,3"                                                \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_W(lval, orig, arg1)                             \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[2];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)arg1;                           \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "lwz 3,4(11)\n\t"   /* arg1->r3 */                       \
         "lwz 11,0(11)\n\t"  /* target->r11 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr %0,3"                                                \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WW(lval, orig, arg1,arg2)                       \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)arg1;                           \
      _argvec[2] = (unsigned long)arg2;                           \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "lwz 3,4(11)\n\t"   /* arg1->r3 */                       \
         "lwz 4,8(11)\n\t"                                        \
         "lwz 11,0(11)\n\t"  /* target->r11 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr %0,3"                                                \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WWW(lval, orig, arg1,arg2,arg3)                 \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[4];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)arg1;                           \
      _argvec[2] = (unsigned long)arg2;                           \
      _argvec[3] = (unsigned long)arg3;                           \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "lwz 3,4(11)\n\t"   /* arg1->r3 */                       \
         "lwz 4,8(11)\n\t"                                        \
         "lwz 5,12(11)\n\t"                                       \
         "lwz 11,0(11)\n\t"  /* target->r11 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr %0,3"                                                \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WWWW(lval, orig, arg1,arg2,arg3,arg4)           \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[5];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)arg1;                           \
      _argvec[2] = (unsigned long)arg2;                           \
      _argvec[3] = (unsigned long)arg3;                           \
      _argvec[4] = (unsigned long)arg4;                           \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "lwz 3,4(11)\n\t"   /* arg1->r3 */                       \
         "lwz 4,8(11)\n\t"                                        \
         "lwz 5,12(11)\n\t"                                       \
         "lwz 6,16(11)\n\t"  /* arg4->r6 */                       \
         "lwz 11,0(11)\n\t"  /* target->r11 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr %0,3"                                                \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_5W(lval, orig, arg1,arg2,arg3,arg4,arg5)        \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[6];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)arg1;                           \
      _argvec[2] = (unsigned long)arg2;                           \
      _argvec[3] = (unsigned long)arg3;                           \
      _argvec[4] = (unsigned long)arg4;                           \
      _argvec[5] = (unsigned long)arg5;                           \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "lwz 3,4(11)\n\t"   /* arg1->r3 */                       \
         "lwz 4,8(11)\n\t"                                        \
         "lwz 5,12(11)\n\t"                                       \
         "lwz 6,16(11)\n\t"  /* arg4->r6 */                       \
         "lwz 7,20(11)\n\t"                                       \
         "lwz 11,0(11)\n\t"  /* target->r11 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr %0,3"                                                \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_6W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6)   \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[7];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)arg1;                           \
      _argvec[2] = (unsigned long)arg2;                           \
      _argvec[3] = (unsigned long)arg3;                           \
      _argvec[4] = (unsigned long)arg4;                           \
      _argvec[5] = (unsigned long)arg5;                           \
      _argvec[6] = (unsigned long)arg6;                           \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "lwz 3,4(11)\n\t"   /* arg1->r3 */                       \
         "lwz 4,8(11)\n\t"                                        \
         "lwz 5,12(11)\n\t"                                       \
         "lwz 6,16(11)\n\t"  /* arg4->r6 */                       \
         "lwz 7,20(11)\n\t"                                       \
         "lwz 8,24(11)\n\t"                                       \
         "lwz 11,0(11)\n\t"  /* target->r11 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr %0,3"                                                \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_7W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7)                            \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[8];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)arg1;                           \
      _argvec[2] = (unsigned long)arg2;                           \
      _argvec[3] = (unsigned long)arg3;                           \
      _argvec[4] = (unsigned long)arg4;                           \
      _argvec[5] = (unsigned long)arg5;                           \
      _argvec[6] = (unsigned long)arg6;                           \
      _argvec[7] = (unsigned long)arg7;                           \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "lwz 3,4(11)\n\t"   /* arg1->r3 */                       \
         "lwz 4,8(11)\n\t"                                        \
         "lwz 5,12(11)\n\t"                                       \
         "lwz 6,16(11)\n\t"  /* arg4->r6 */                       \
         "lwz 7,20(11)\n\t"                                       \
         "lwz 8,24(11)\n\t"                                       \
         "lwz 9,28(11)\n\t"                                       \
         "lwz 11,0(11)\n\t"  /* target->r11 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr %0,3"                                                \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_8W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7,arg8)                       \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[9];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)arg1;                           \
      _argvec[2] = (unsigned long)arg2;                           \
      _argvec[3] = (unsigned long)arg3;                           \
      _argvec[4] = (unsigned long)arg4;                           \
      _argvec[5] = (unsigned long)arg5;                           \
      _argvec[6] = (unsigned long)arg6;                           \
      _argvec[7] = (unsigned long)arg7;                           \
      _argvec[8] = (unsigned long)arg8;                           \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "lwz 3,4(11)\n\t"   /* arg1->r3 */                       \
         "lwz 4,8(11)\n\t"                                        \
         "lwz 5,12(11)\n\t"                                       \
         "lwz 6,16(11)\n\t"  /* arg4->r6 */                       \
         "lwz 7,20(11)\n\t"                                       \
         "lwz 8,24(11)\n\t"                                       \
         "lwz 9,28(11)\n\t"                                       \
         "lwz 10,32(11)\n\t" /* arg8->r10 */                      \
         "lwz 11,0(11)\n\t"  /* target->r11 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr %0,3"                                                \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_9W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7,arg8,arg9)                  \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[10];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)arg1;                           \
      _argvec[2] = (unsigned long)arg2;                           \
      _argvec[3] = (unsigned long)arg3;                           \
      _argvec[4] = (unsigned long)arg4;                           \
      _argvec[5] = (unsigned long)arg5;                           \
      _argvec[6] = (unsigned long)arg6;                           \
      _argvec[7] = (unsigned long)arg7;                           \
      _argvec[8] = (unsigned long)arg8;                           \
      _argvec[9] = (unsigned long)arg9;                           \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "addi 1,1,-16\n\t"                                       \
         /* arg9 */                                               \
         "lwz 3,36(11)\n\t"                                       \
         "stw 3,8(1)\n\t"                                         \
         /* args1-8 */                                            \
         "lwz 3,4(11)\n\t"   /* arg1->r3 */                       \
         "lwz 4,8(11)\n\t"                                        \
         "lwz 5,12(11)\n\t"                                       \
         "lwz 6,16(11)\n\t"  /* arg4->r6 */                       \
         "lwz 7,20(11)\n\t"                                       \
         "lwz 8,24(11)\n\t"                                       \
         "lwz 9,28(11)\n\t"                                       \
         "lwz 10,32(11)\n\t" /* arg8->r10 */                      \
         "lwz 11,0(11)\n\t"  /* target->r11 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "addi 1,1,16\n\t"                                        \
         "mr %0,3"                                                \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_10W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,  \
                                  arg7,arg8,arg9,arg10)           \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[11];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)arg1;                           \
      _argvec[2] = (unsigned long)arg2;                           \
      _argvec[3] = (unsigned long)arg3;                           \
      _argvec[4] = (unsigned long)arg4;                           \
      _argvec[5] = (unsigned long)arg5;                           \
      _argvec[6] = (unsigned long)arg6;                           \
      _argvec[7] = (unsigned long)arg7;                           \
      _argvec[8] = (unsigned long)arg8;                           \
      _argvec[9] = (unsigned long)arg9;                           \
      _argvec[10] = (unsigned long)arg10;                         \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "addi 1,1,-16\n\t"                                       \
         /* arg10 */                                              \
         "lwz 3,40(11)\n\t"                                       \
         "stw 3,12(1)\n\t"                                        \
         /* arg9 */                                               \
         "lwz 3,36(11)\n\t"                                       \
         "stw 3,8(1)\n\t"                                         \
         /* args1-8 */                                            \
         "lwz 3,4(11)\n\t"   /* arg1->r3 */                       \
         "lwz 4,8(11)\n\t"                                        \
         "lwz 5,12(11)\n\t"                                       \
         "lwz 6,16(11)\n\t"  /* arg4->r6 */                       \
         "lwz 7,20(11)\n\t"                                       \
         "lwz 8,24(11)\n\t"                                       \
         "lwz 9,28(11)\n\t"                                       \
         "lwz 10,32(11)\n\t" /* arg8->r10 */                      \
         "lwz 11,0(11)\n\t"  /* target->r11 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "addi 1,1,16\n\t"                                        \
         "mr %0,3"                                                \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_11W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,  \
                                  arg7,arg8,arg9,arg10,arg11)     \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[12];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)arg1;                           \
      _argvec[2] = (unsigned long)arg2;                           \
      _argvec[3] = (unsigned long)arg3;                           \
      _argvec[4] = (unsigned long)arg4;                           \
      _argvec[5] = (unsigned long)arg5;                           \
      _argvec[6] = (unsigned long)arg6;                           \
      _argvec[7] = (unsigned long)arg7;                           \
      _argvec[8] = (unsigned long)arg8;                           \
      _argvec[9] = (unsigned long)arg9;                           \
      _argvec[10] = (unsigned long)arg10;                         \
      _argvec[11] = (unsigned long)arg11;                         \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "addi 1,1,-32\n\t"                                       \
         /* arg11 */                                              \
         "lwz 3,44(11)\n\t"                                       \
         "stw 3,16(1)\n\t"                                        \
         /* arg10 */                                              \
         "lwz 3,40(11)\n\t"                                       \
         "stw 3,12(1)\n\t"                                        \
         /* arg9 */                                               \
         "lwz 3,36(11)\n\t"                                       \
         "stw 3,8(1)\n\t"                                         \
         /* args1-8 */                                            \
         "lwz 3,4(11)\n\t"   /* arg1->r3 */                       \
         "lwz 4,8(11)\n\t"                                        \
         "lwz 5,12(11)\n\t"                                       \
         "lwz 6,16(11)\n\t"  /* arg4->r6 */                       \
         "lwz 7,20(11)\n\t"                                       \
         "lwz 8,24(11)\n\t"                                       \
         "lwz 9,28(11)\n\t"                                       \
         "lwz 10,32(11)\n\t" /* arg8->r10 */                      \
         "lwz 11,0(11)\n\t"  /* target->r11 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "addi 1,1,32\n\t"                                        \
         "mr %0,3"                                                \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_12W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,  \
                                arg7,arg8,arg9,arg10,arg11,arg12) \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[13];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)arg1;                           \
      _argvec[2] = (unsigned long)arg2;                           \
      _argvec[3] = (unsigned long)arg3;                           \
      _argvec[4] = (unsigned long)arg4;                           \
      _argvec[5] = (unsigned long)arg5;                           \
      _argvec[6] = (unsigned long)arg6;                           \
      _argvec[7] = (unsigned long)arg7;                           \
      _argvec[8] = (unsigned long)arg8;                           \
      _argvec[9] = (unsigned long)arg9;                           \
      _argvec[10] = (unsigned long)arg10;                         \
      _argvec[11] = (unsigned long)arg11;                         \
      _argvec[12] = (unsigned long)arg12;                         \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "addi 1,1,-32\n\t"                                       \
         /* arg12 */                                              \
         "lwz 3,48(11)\n\t"                                       \
         "stw 3,20(1)\n\t"                                        \
         /* arg11 */                                              \
         "lwz 3,44(11)\n\t"                                       \
         "stw 3,16(1)\n\t"                                        \
         /* arg10 */                                              \
         "lwz 3,40(11)\n\t"                                       \
         "stw 3,12(1)\n\t"                                        \
         /* arg9 */                                               \
         "lwz 3,36(11)\n\t"                                       \
         "stw 3,8(1)\n\t"                                         \
         /* args1-8 */                                            \
         "lwz 3,4(11)\n\t"   /* arg1->r3 */                       \
         "lwz 4,8(11)\n\t"                                        \
         "lwz 5,12(11)\n\t"                                       \
         "lwz 6,16(11)\n\t"  /* arg4->r6 */                       \
         "lwz 7,20(11)\n\t"                                       \
         "lwz 8,24(11)\n\t"                                       \
         "lwz 9,28(11)\n\t"                                       \
         "lwz 10,32(11)\n\t" /* arg8->r10 */                      \
         "lwz 11,0(11)\n\t"  /* target->r11 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "addi 1,1,32\n\t"                                        \
         "mr %0,3"                                                \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#endif /* PLAT_ppc32_linux */

/* ------------------------ ppc64-linux ------------------------ */

#if defined(PLAT_ppc64_linux)

/* ARGREGS: r3 r4 r5 r6 r7 r8 r9 r10 (the rest on stack somewhere) */

/* These regs are trashed by the hidden call. */
#define __CALLER_SAVED_REGS                                       \
   "lr", "ctr", "xer",                                            \
   "cr0", "cr1", "cr2", "cr3", "cr4", "cr5", "cr6", "cr7",        \
   "r0", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10",   \
   "r11", "r12", "r13"

/* These CALL_FN_ macros assume that on ppc64-linux, sizeof(unsigned
   long) == 8. */

#define CALL_FN_W_v(lval, orig)                                   \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3+0];                        \
      volatile unsigned long _res;                                \
      /* _argvec[0] holds current r2 across the call */           \
      _argvec[1] = (unsigned long)_orig.r2;                       \
      _argvec[2] = (unsigned long)_orig.nraddr;                   \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "std 2,-16(11)\n\t"  /* save tocptr */                   \
         "ld   2,-8(11)\n\t"  /* use nraddr's tocptr */           \
         "ld  11, 0(11)\n\t"  /* target->r11 */                   \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr 11,%1\n\t"                                           \
         "mr %0,3\n\t"                                            \
         "ld 2,-16(11)" /* restore tocptr */                      \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[2])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_W(lval, orig, arg1)                             \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3+1];                        \
      volatile unsigned long _res;                                \
      /* _argvec[0] holds current r2 across the call */           \
      _argvec[1]   = (unsigned long)_orig.r2;                     \
      _argvec[2]   = (unsigned long)_orig.nraddr;                 \
      _argvec[2+1] = (unsigned long)arg1;                         \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "std 2,-16(11)\n\t"  /* save tocptr */                   \
         "ld   2,-8(11)\n\t"  /* use nraddr's tocptr */           \
         "ld   3, 8(11)\n\t"  /* arg1->r3 */                      \
         "ld  11, 0(11)\n\t"  /* target->r11 */                   \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr 11,%1\n\t"                                           \
         "mr %0,3\n\t"                                            \
         "ld 2,-16(11)" /* restore tocptr */                      \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[2])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WW(lval, orig, arg1,arg2)                       \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3+2];                        \
      volatile unsigned long _res;                                \
      /* _argvec[0] holds current r2 across the call */           \
      _argvec[1]   = (unsigned long)_orig.r2;                     \
      _argvec[2]   = (unsigned long)_orig.nraddr;                 \
      _argvec[2+1] = (unsigned long)arg1;                         \
      _argvec[2+2] = (unsigned long)arg2;                         \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "std 2,-16(11)\n\t"  /* save tocptr */                   \
         "ld   2,-8(11)\n\t"  /* use nraddr's tocptr */           \
         "ld   3, 8(11)\n\t"  /* arg1->r3 */                      \
         "ld   4, 16(11)\n\t" /* arg2->r4 */                      \
         "ld  11, 0(11)\n\t"  /* target->r11 */                   \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr 11,%1\n\t"                                           \
         "mr %0,3\n\t"                                            \
         "ld 2,-16(11)" /* restore tocptr */                      \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[2])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WWW(lval, orig, arg1,arg2,arg3)                 \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3+3];                        \
      volatile unsigned long _res;                                \
      /* _argvec[0] holds current r2 across the call */           \
      _argvec[1]   = (unsigned long)_orig.r2;                     \
      _argvec[2]   = (unsigned long)_orig.nraddr;                 \
      _argvec[2+1] = (unsigned long)arg1;                         \
      _argvec[2+2] = (unsigned long)arg2;                         \
      _argvec[2+3] = (unsigned long)arg3;                         \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "std 2,-16(11)\n\t"  /* save tocptr */                   \
         "ld   2,-8(11)\n\t"  /* use nraddr's tocptr */           \
         "ld   3, 8(11)\n\t"  /* arg1->r3 */                      \
         "ld   4, 16(11)\n\t" /* arg2->r4 */                      \
         "ld   5, 24(11)\n\t" /* arg3->r5 */                      \
         "ld  11, 0(11)\n\t"  /* target->r11 */                   \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr 11,%1\n\t"                                           \
         "mr %0,3\n\t"                                            \
         "ld 2,-16(11)" /* restore tocptr */                      \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[2])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WWWW(lval, orig, arg1,arg2,arg3,arg4)           \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3+4];                        \
      volatile unsigned long _res;                                \
      /* _argvec[0] holds current r2 across the call */           \
      _argvec[1]   = (unsigned long)_orig.r2;                     \
      _argvec[2]   = (unsigned long)_orig.nraddr;                 \
      _argvec[2+1] = (unsigned long)arg1;                         \
      _argvec[2+2] = (unsigned long)arg2;                         \
      _argvec[2+3] = (unsigned long)arg3;                         \
      _argvec[2+4] = (unsigned long)arg4;                         \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "std 2,-16(11)\n\t"  /* save tocptr */                   \
         "ld   2,-8(11)\n\t"  /* use nraddr's tocptr */           \
         "ld   3, 8(11)\n\t"  /* arg1->r3 */                      \
         "ld   4, 16(11)\n\t" /* arg2->r4 */                      \
         "ld   5, 24(11)\n\t" /* arg3->r5 */                      \
         "ld   6, 32(11)\n\t" /* arg4->r6 */                      \
         "ld  11, 0(11)\n\t"  /* target->r11 */                   \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr 11,%1\n\t"                                           \
         "mr %0,3\n\t"                                            \
         "ld 2,-16(11)" /* restore tocptr */                      \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[2])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_5W(lval, orig, arg1,arg2,arg3,arg4,arg5)        \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3+5];                        \
      volatile unsigned long _res;                                \
      /* _argvec[0] holds current r2 across the call */           \
      _argvec[1]   = (unsigned long)_orig.r2;                     \
      _argvec[2]   = (unsigned long)_orig.nraddr;                 \
      _argvec[2+1] = (unsigned long)arg1;                         \
      _argvec[2+2] = (unsigned long)arg2;                         \
      _argvec[2+3] = (unsigned long)arg3;                         \
      _argvec[2+4] = (unsigned long)arg4;                         \
      _argvec[2+5] = (unsigned long)arg5;                         \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "std 2,-16(11)\n\t"  /* save tocptr */                   \
         "ld   2,-8(11)\n\t"  /* use nraddr's tocptr */           \
         "ld   3, 8(11)\n\t"  /* arg1->r3 */                      \
         "ld   4, 16(11)\n\t" /* arg2->r4 */                      \
         "ld   5, 24(11)\n\t" /* arg3->r5 */                      \
         "ld   6, 32(11)\n\t" /* arg4->r6 */                      \
         "ld   7, 40(11)\n\t" /* arg5->r7 */                      \
         "ld  11, 0(11)\n\t"  /* target->r11 */                   \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr 11,%1\n\t"                                           \
         "mr %0,3\n\t"                                            \
         "ld 2,-16(11)" /* restore tocptr */                      \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[2])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_6W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6)   \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3+6];                        \
      volatile unsigned long _res;                                \
      /* _argvec[0] holds current r2 across the call */           \
      _argvec[1]   = (unsigned long)_orig.r2;                     \
      _argvec[2]   = (unsigned long)_orig.nraddr;                 \
      _argvec[2+1] = (unsigned long)arg1;                         \
      _argvec[2+2] = (unsigned long)arg2;                         \
      _argvec[2+3] = (unsigned long)arg3;                         \
      _argvec[2+4] = (unsigned long)arg4;                         \
      _argvec[2+5] = (unsigned long)arg5;                         \
      _argvec[2+6] = (unsigned long)arg6;                         \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "std 2,-16(11)\n\t"  /* save tocptr */                   \
         "ld   2,-8(11)\n\t"  /* use nraddr's tocptr */           \
         "ld   3, 8(11)\n\t"  /* arg1->r3 */                      \
         "ld   4, 16(11)\n\t" /* arg2->r4 */                      \
         "ld   5, 24(11)\n\t" /* arg3->r5 */                      \
         "ld   6, 32(11)\n\t" /* arg4->r6 */                      \
         "ld   7, 40(11)\n\t" /* arg5->r7 */                      \
         "ld   8, 48(11)\n\t" /* arg6->r8 */                      \
         "ld  11, 0(11)\n\t"  /* target->r11 */                   \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr 11,%1\n\t"                                           \
         "mr %0,3\n\t"                                            \
         "ld 2,-16(11)" /* restore tocptr */                      \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[2])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_7W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7)                            \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3+7];                        \
      volatile unsigned long _res;                                \
      /* _argvec[0] holds current r2 across the call */           \
      _argvec[1]   = (unsigned long)_orig.r2;                     \
      _argvec[2]   = (unsigned long)_orig.nraddr;                 \
      _argvec[2+1] = (unsigned long)arg1;                         \
      _argvec[2+2] = (unsigned long)arg2;                         \
      _argvec[2+3] = (unsigned long)arg3;                         \
      _argvec[2+4] = (unsigned long)arg4;                         \
      _argvec[2+5] = (unsigned long)arg5;                         \
      _argvec[2+6] = (unsigned long)arg6;                         \
      _argvec[2+7] = (unsigned long)arg7;                         \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "std 2,-16(11)\n\t"  /* save tocptr */                   \
         "ld   2,-8(11)\n\t"  /* use nraddr's tocptr */           \
         "ld   3, 8(11)\n\t"  /* arg1->r3 */                      \
         "ld   4, 16(11)\n\t" /* arg2->r4 */                      \
         "ld   5, 24(11)\n\t" /* arg3->r5 */                      \
         "ld   6, 32(11)\n\t" /* arg4->r6 */                      \
         "ld   7, 40(11)\n\t" /* arg5->r7 */                      \
         "ld   8, 48(11)\n\t" /* arg6->r8 */                      \
         "ld   9, 56(11)\n\t" /* arg7->r9 */                      \
         "ld  11, 0(11)\n\t"  /* target->r11 */                   \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr 11,%1\n\t"                                           \
         "mr %0,3\n\t"                                            \
         "ld 2,-16(11)" /* restore tocptr */                      \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[2])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_8W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7,arg8)                       \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3+8];                        \
      volatile unsigned long _res;                                \
      /* _argvec[0] holds current r2 across the call */           \
      _argvec[1]   = (unsigned long)_orig.r2;                     \
      _argvec[2]   = (unsigned long)_orig.nraddr;                 \
      _argvec[2+1] = (unsigned long)arg1;                         \
      _argvec[2+2] = (unsigned long)arg2;                         \
      _argvec[2+3] = (unsigned long)arg3;                         \
      _argvec[2+4] = (unsigned long)arg4;                         \
      _argvec[2+5] = (unsigned long)arg5;                         \
      _argvec[2+6] = (unsigned long)arg6;                         \
      _argvec[2+7] = (unsigned long)arg7;                         \
      _argvec[2+8] = (unsigned long)arg8;                         \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "std 2,-16(11)\n\t"  /* save tocptr */                   \
         "ld   2,-8(11)\n\t"  /* use nraddr's tocptr */           \
         "ld   3, 8(11)\n\t"  /* arg1->r3 */                      \
         "ld   4, 16(11)\n\t" /* arg2->r4 */                      \
         "ld   5, 24(11)\n\t" /* arg3->r5 */                      \
         "ld   6, 32(11)\n\t" /* arg4->r6 */                      \
         "ld   7, 40(11)\n\t" /* arg5->r7 */                      \
         "ld   8, 48(11)\n\t" /* arg6->r8 */                      \
         "ld   9, 56(11)\n\t" /* arg7->r9 */                      \
         "ld  10, 64(11)\n\t" /* arg8->r10 */                     \
         "ld  11, 0(11)\n\t"  /* target->r11 */                   \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr 11,%1\n\t"                                           \
         "mr %0,3\n\t"                                            \
         "ld 2,-16(11)" /* restore tocptr */                      \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[2])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_9W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7,arg8,arg9)                  \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3+9];                        \
      volatile unsigned long _res;                                \
      /* _argvec[0] holds current r2 across the call */           \
      _argvec[1]   = (unsigned long)_orig.r2;                     \
      _argvec[2]   = (unsigned long)_orig.nraddr;                 \
      _argvec[2+1] = (unsigned long)arg1;                         \
      _argvec[2+2] = (unsigned long)arg2;                         \
      _argvec[2+3] = (unsigned long)arg3;                         \
      _argvec[2+4] = (unsigned long)arg4;                         \
      _argvec[2+5] = (unsigned long)arg5;                         \
      _argvec[2+6] = (unsigned long)arg6;                         \
      _argvec[2+7] = (unsigned long)arg7;                         \
      _argvec[2+8] = (unsigned long)arg8;                         \
      _argvec[2+9] = (unsigned long)arg9;                         \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "std 2,-16(11)\n\t"  /* save tocptr */                   \
         "ld   2,-8(11)\n\t"  /* use nraddr's tocptr */           \
         "addi 1,1,-128\n\t"  /* expand stack frame */            \
         /* arg9 */                                               \
         "ld  3,72(11)\n\t"                                       \
         "std 3,112(1)\n\t"                                       \
         /* args1-8 */                                            \
         "ld   3, 8(11)\n\t"  /* arg1->r3 */                      \
         "ld   4, 16(11)\n\t" /* arg2->r4 */                      \
         "ld   5, 24(11)\n\t" /* arg3->r5 */                      \
         "ld   6, 32(11)\n\t" /* arg4->r6 */                      \
         "ld   7, 40(11)\n\t" /* arg5->r7 */                      \
         "ld   8, 48(11)\n\t" /* arg6->r8 */                      \
         "ld   9, 56(11)\n\t" /* arg7->r9 */                      \
         "ld  10, 64(11)\n\t" /* arg8->r10 */                     \
         "ld  11, 0(11)\n\t"  /* target->r11 */                   \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr 11,%1\n\t"                                           \
         "mr %0,3\n\t"                                            \
         "ld 2,-16(11)\n\t" /* restore tocptr */                  \
         "addi 1,1,128"     /* restore frame */                   \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[2])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_10W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,  \
                                  arg7,arg8,arg9,arg10)           \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3+10];                       \
      volatile unsigned long _res;                                \
      /* _argvec[0] holds current r2 across the call */           \
      _argvec[1]   = (unsigned long)_orig.r2;                     \
      _argvec[2]   = (unsigned long)_orig.nraddr;                 \
      _argvec[2+1] = (unsigned long)arg1;                         \
      _argvec[2+2] = (unsigned long)arg2;                         \
      _argvec[2+3] = (unsigned long)arg3;                         \
      _argvec[2+4] = (unsigned long)arg4;                         \
      _argvec[2+5] = (unsigned long)arg5;                         \
      _argvec[2+6] = (unsigned long)arg6;                         \
      _argvec[2+7] = (unsigned long)arg7;                         \
      _argvec[2+8] = (unsigned long)arg8;                         \
      _argvec[2+9] = (unsigned long)arg9;                         \
      _argvec[2+10] = (unsigned long)arg10;                       \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "std 2,-16(11)\n\t"  /* save tocptr */                   \
         "ld   2,-8(11)\n\t"  /* use nraddr's tocptr */           \
         "addi 1,1,-128\n\t"  /* expand stack frame */            \
         /* arg10 */                                              \
         "ld  3,80(11)\n\t"                                       \
         "std 3,120(1)\n\t"                                       \
         /* arg9 */                                               \
         "ld  3,72(11)\n\t"                                       \
         "std 3,112(1)\n\t"                                       \
         /* args1-8 */                                            \
         "ld   3, 8(11)\n\t"  /* arg1->r3 */                      \
         "ld   4, 16(11)\n\t" /* arg2->r4 */                      \
         "ld   5, 24(11)\n\t" /* arg3->r5 */                      \
         "ld   6, 32(11)\n\t" /* arg4->r6 */                      \
         "ld   7, 40(11)\n\t" /* arg5->r7 */                      \
         "ld   8, 48(11)\n\t" /* arg6->r8 */                      \
         "ld   9, 56(11)\n\t" /* arg7->r9 */                      \
         "ld  10, 64(11)\n\t" /* arg8->r10 */                     \
         "ld  11, 0(11)\n\t"  /* target->r11 */                   \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr 11,%1\n\t"                                           \
         "mr %0,3\n\t"                                            \
         "ld 2,-16(11)\n\t" /* restore tocptr */                  \
         "addi 1,1,128"     /* restore frame */                   \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[2])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_11W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,  \
                                  arg7,arg8,arg9,arg10,arg11)     \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3+11];                       \
      volatile unsigned long _res;                                \
      /* _argvec[0] holds current r2 across the call */           \
      _argvec[1]   = (unsigned long)_orig.r2;                     \
      _argvec[2]   = (unsigned long)_orig.nraddr;                 \
      _argvec[2+1] = (unsigned long)arg1;                         \
      _argvec[2+2] = (unsigned long)arg2;                         \
      _argvec[2+3] = (unsigned long)arg3;                         \
      _argvec[2+4] = (unsigned long)arg4;                         \
      _argvec[2+5] = (unsigned long)arg5;                         \
      _argvec[2+6] = (unsigned long)arg6;                         \
      _argvec[2+7] = (unsigned long)arg7;                         \
      _argvec[2+8] = (unsigned long)arg8;                         \
      _argvec[2+9] = (unsigned long)arg9;                         \
      _argvec[2+10] = (unsigned long)arg10;                       \
      _argvec[2+11] = (unsigned long)arg11;                       \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "std 2,-16(11)\n\t"  /* save tocptr */                   \
         "ld   2,-8(11)\n\t"  /* use nraddr's tocptr */           \
         "addi 1,1,-144\n\t"  /* expand stack frame */            \
         /* arg11 */                                              \
         "ld  3,88(11)\n\t"                                       \
         "std 3,128(1)\n\t"                                       \
         /* arg10 */                                              \
         "ld  3,80(11)\n\t"                                       \
         "std 3,120(1)\n\t"                                       \
         /* arg9 */                                               \
         "ld  3,72(11)\n\t"                                       \
         "std 3,112(1)\n\t"                                       \
         /* args1-8 */                                            \
         "ld   3, 8(11)\n\t"  /* arg1->r3 */                      \
         "ld   4, 16(11)\n\t" /* arg2->r4 */                      \
         "ld   5, 24(11)\n\t" /* arg3->r5 */                      \
         "ld   6, 32(11)\n\t" /* arg4->r6 */                      \
         "ld   7, 40(11)\n\t" /* arg5->r7 */                      \
         "ld   8, 48(11)\n\t" /* arg6->r8 */                      \
         "ld   9, 56(11)\n\t" /* arg7->r9 */                      \
         "ld  10, 64(11)\n\t" /* arg8->r10 */                     \
         "ld  11, 0(11)\n\t"  /* target->r11 */                   \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr 11,%1\n\t"                                           \
         "mr %0,3\n\t"                                            \
         "ld 2,-16(11)\n\t" /* restore tocptr */                  \
         "addi 1,1,144"     /* restore frame */                   \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[2])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_12W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,  \
                                arg7,arg8,arg9,arg10,arg11,arg12) \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3+12];                       \
      volatile unsigned long _res;                                \
      /* _argvec[0] holds current r2 across the call */           \
      _argvec[1]   = (unsigned long)_orig.r2;                     \
      _argvec[2]   = (unsigned long)_orig.nraddr;                 \
      _argvec[2+1] = (unsigned long)arg1;                         \
      _argvec[2+2] = (unsigned long)arg2;                         \
      _argvec[2+3] = (unsigned long)arg3;                         \
      _argvec[2+4] = (unsigned long)arg4;                         \
      _argvec[2+5] = (unsigned long)arg5;                         \
      _argvec[2+6] = (unsigned long)arg6;                         \
      _argvec[2+7] = (unsigned long)arg7;                         \
      _argvec[2+8] = (unsigned long)arg8;                         \
      _argvec[2+9] = (unsigned long)arg9;                         \
      _argvec[2+10] = (unsigned long)arg10;                       \
      _argvec[2+11] = (unsigned long)arg11;                       \
      _argvec[2+12] = (unsigned long)arg12;                       \
      __asm__ volatile(                                           \
         "mr 11,%1\n\t"                                           \
         "std 2,-16(11)\n\t"  /* save tocptr */                   \
         "ld   2,-8(11)\n\t"  /* use nraddr's tocptr */           \
         "addi 1,1,-144\n\t"  /* expand stack frame */            \
         /* arg12 */                                              \
         "ld  3,96(11)\n\t"                                       \
         "std 3,136(1)\n\t"                                       \
         /* arg11 */                                              \
         "ld  3,88(11)\n\t"                                       \
         "std 3,128(1)\n\t"                                       \
         /* arg10 */                                              \
         "ld  3,80(11)\n\t"                                       \
         "std 3,120(1)\n\t"                                       \
         /* arg9 */                                               \
         "ld  3,72(11)\n\t"                                       \
         "std 3,112(1)\n\t"                                       \
         /* args1-8 */                                            \
         "ld   3, 8(11)\n\t"  /* arg1->r3 */                      \
         "ld   4, 16(11)\n\t" /* arg2->r4 */                      \
         "ld   5, 24(11)\n\t" /* arg3->r5 */                      \
         "ld   6, 32(11)\n\t" /* arg4->r6 */                      \
         "ld   7, 40(11)\n\t" /* arg5->r7 */                      \
         "ld   8, 48(11)\n\t" /* arg6->r8 */                      \
         "ld   9, 56(11)\n\t" /* arg7->r9 */                      \
         "ld  10, 64(11)\n\t" /* arg8->r10 */                     \
         "ld  11, 0(11)\n\t"  /* target->r11 */                   \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11                  \
         "mr 11,%1\n\t"                                           \
         "mr %0,3\n\t"                                            \
         "ld 2,-16(11)\n\t" /* restore tocptr */                  \
         "addi 1,1,144"     /* restore frame */                   \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "r" (&_argvec[2])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#endif /* PLAT_ppc64_linux */

/* ------------------------- arm-linux ------------------------- */

#if defined(PLAT_arm_linux)

/* These regs are trashed by the hidden call. */
#define __CALLER_SAVED_REGS "r0", "r1", "r2", "r3","r4","r14"

/* These CALL_FN_ macros assume that on arm-linux, sizeof(unsigned
   long) == 4. */

#define CALL_FN_W_v(lval, orig)                                   \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[1];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      __asm__ volatile(                                           \
         "ldr r4, [%1] \n\t"  /* target->r4 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \
         "mov %0, r0\n"                                           \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "0" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_W(lval, orig, arg1)                             \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[2];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      __asm__ volatile(                                           \
         "ldr r0, [%1, #4] \n\t"                                  \
         "ldr r4, [%1] \n\t"  /* target->r4 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \
         "mov %0, r0\n"                                           \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "0" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory",  __CALLER_SAVED_REGS         \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WW(lval, orig, arg1,arg2)                       \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[3];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      __asm__ volatile(                                           \
         "ldr r0, [%1, #4] \n\t"                                  \
         "ldr r1, [%1, #8] \n\t"                                  \
         "ldr r4, [%1] \n\t"  /* target->r4 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \
         "mov %0, r0\n"                                           \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "0" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WWW(lval, orig, arg1,arg2,arg3)                 \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[4];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      __asm__ volatile(                                           \
         "ldr r0, [%1, #4] \n\t"                                  \
         "ldr r1, [%1, #8] \n\t"                                  \
         "ldr r2, [%1, #12] \n\t"                                 \
         "ldr r4, [%1] \n\t"  /* target->r4 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \
         "mov %0, r0\n"                                           \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "0" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_WWWW(lval, orig, arg1,arg2,arg3,arg4)           \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[5];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      __asm__ volatile(                                           \
         "ldr r0, [%1, #4] \n\t"                                  \
         "ldr r1, [%1, #8] \n\t"                                  \
         "ldr r2, [%1, #12] \n\t"                                 \
         "ldr r3, [%1, #16] \n\t"                                 \
         "ldr r4, [%1] \n\t"  /* target->r4 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \
         "mov %0, r0"                                             \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "0" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_5W(lval, orig, arg1,arg2,arg3,arg4,arg5)        \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[6];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      __asm__ volatile(                                           \
         "ldr r0, [%1, #20] \n\t"                                 \
         "push {r0} \n\t"                                         \
         "ldr r0, [%1, #4] \n\t"                                  \
         "ldr r1, [%1, #8] \n\t"                                  \
         "ldr r2, [%1, #12] \n\t"                                 \
         "ldr r3, [%1, #16] \n\t"                                 \
         "ldr r4, [%1] \n\t"  /* target->r4 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \
         "add sp, sp, #4 \n\t"                                    \
         "mov %0, r0"                                             \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "0" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_6W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6)   \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[7];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      __asm__ volatile(                                           \
         "ldr r0, [%1, #20] \n\t"                                 \
         "ldr r1, [%1, #24] \n\t"                                 \
         "push {r0, r1} \n\t"                                     \
         "ldr r0, [%1, #4] \n\t"                                  \
         "ldr r1, [%1, #8] \n\t"                                  \
         "ldr r2, [%1, #12] \n\t"                                 \
         "ldr r3, [%1, #16] \n\t"                                 \
         "ldr r4, [%1] \n\t"  /* target->r4 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \
         "add sp, sp, #8 \n\t"                                    \
         "mov %0, r0"                                             \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "0" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_7W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7)                            \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[8];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      __asm__ volatile(                                           \
         "ldr r0, [%1, #20] \n\t"                                 \
         "ldr r1, [%1, #24] \n\t"                                 \
         "ldr r2, [%1, #28] \n\t"                                 \
         "push {r0, r1, r2} \n\t"                                 \
         "ldr r0, [%1, #4] \n\t"                                  \
         "ldr r1, [%1, #8] \n\t"                                  \
         "ldr r2, [%1, #12] \n\t"                                 \
         "ldr r3, [%1, #16] \n\t"                                 \
         "ldr r4, [%1] \n\t"  /* target->r4 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \
         "add sp, sp, #12 \n\t"                                   \
         "mov %0, r0"                                             \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "0" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_8W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7,arg8)                       \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[9];                          \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      __asm__ volatile(                                           \
         "ldr r0, [%1, #20] \n\t"                                 \
         "ldr r1, [%1, #24] \n\t"                                 \
         "ldr r2, [%1, #28] \n\t"                                 \
         "ldr r3, [%1, #32] \n\t"                                 \
         "push {r0, r1, r2, r3} \n\t"                             \
         "ldr r0, [%1, #4] \n\t"                                  \
         "ldr r1, [%1, #8] \n\t"                                  \
         "ldr r2, [%1, #12] \n\t"                                 \
         "ldr r3, [%1, #16] \n\t"                                 \
         "ldr r4, [%1] \n\t"  /* target->r4 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \
         "add sp, sp, #16 \n\t"                                   \
         "mov %0, r0"                                             \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "0" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_9W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,   \
                                 arg7,arg8,arg9)                  \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[10];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      _argvec[9] = (unsigned long)(arg9);                         \
      __asm__ volatile(                                           \
         "ldr r0, [%1, #20] \n\t"                                 \
         "ldr r1, [%1, #24] \n\t"                                 \
         "ldr r2, [%1, #28] \n\t"                                 \
         "ldr r3, [%1, #32] \n\t"                                 \
         "ldr r4, [%1, #36] \n\t"                                 \
         "push {r0, r1, r2, r3, r4} \n\t"                         \
         "ldr r0, [%1, #4] \n\t"                                  \
         "ldr r1, [%1, #8] \n\t"                                  \
         "ldr r2, [%1, #12] \n\t"                                 \
         "ldr r3, [%1, #16] \n\t"                                 \
         "ldr r4, [%1] \n\t"  /* target->r4 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \
         "add sp, sp, #20 \n\t"                                   \
         "mov %0, r0"                                             \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "0" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_10W(lval, orig, arg1,arg2,arg3,arg4,arg5,arg6,  \
                                  arg7,arg8,arg9,arg10)           \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[11];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      _argvec[9] = (unsigned long)(arg9);                         \
      _argvec[10] = (unsigned long)(arg10);                       \
      __asm__ volatile(                                           \
         "ldr r0, [%1, #40] \n\t"                                 \
         "push {r0} \n\t"                                         \
         "ldr r0, [%1, #20] \n\t"                                 \
         "ldr r1, [%1, #24] \n\t"                                 \
         "ldr r2, [%1, #28] \n\t"                                 \
         "ldr r3, [%1, #32] \n\t"                                 \
         "ldr r4, [%1, #36] \n\t"                                 \
         "push {r0, r1, r2, r3, r4} \n\t"                         \
         "ldr r0, [%1, #4] \n\t"                                  \
         "ldr r1, [%1, #8] \n\t"                                  \
         "ldr r2, [%1, #12] \n\t"                                 \
         "ldr r3, [%1, #16] \n\t"                                 \
         "ldr r4, [%1] \n\t"  /* target->r4 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \
         "add sp, sp, #24 \n\t"                                   \
         "mov %0, r0"                                             \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "0" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_11W(lval, orig, arg1,arg2,arg3,arg4,arg5,       \
                                  arg6,arg7,arg8,arg9,arg10,      \
                                  arg11)                          \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[12];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      _argvec[9] = (unsigned long)(arg9);                         \
      _argvec[10] = (unsigned long)(arg10);                       \
      _argvec[11] = (unsigned long)(arg11);                       \
      __asm__ volatile(                                           \
         "ldr r0, [%1, #40] \n\t"                                 \
         "ldr r1, [%1, #44] \n\t"                                 \
         "push {r0, r1} \n\t"                                     \
         "ldr r0, [%1, #20] \n\t"                                 \
         "ldr r1, [%1, #24] \n\t"                                 \
         "ldr r2, [%1, #28] \n\t"                                 \
         "ldr r3, [%1, #32] \n\t"                                 \
         "ldr r4, [%1, #36] \n\t"                                 \
         "push {r0, r1, r2, r3, r4} \n\t"                         \
         "ldr r0, [%1, #4] \n\t"                                  \
         "ldr r1, [%1, #8] \n\t"                                  \
         "ldr r2, [%1, #12] \n\t"                                 \
         "ldr r3, [%1, #16] \n\t"                                 \
         "ldr r4, [%1] \n\t"  /* target->r4 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \
         "add sp, sp, #28 \n\t"                                   \
         "mov %0, r0"                                             \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "0" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory",__CALLER_SAVED_REGS           \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#define CALL_FN_W_12W(lval, orig, arg1,arg2,arg3,arg4,arg5,       \
                                  arg6,arg7,arg8,arg9,arg10,      \
                                  arg11,arg12)                    \
   do {                                                           \
      volatile OrigFn        _orig = (orig);                      \
      volatile unsigned long _argvec[13];                         \
      volatile unsigned long _res;                                \
      _argvec[0] = (unsigned long)_orig.nraddr;                   \
      _argvec[1] = (unsigned long)(arg1);                         \
      _argvec[2] = (unsigned long)(arg2);                         \
      _argvec[3] = (unsigned long)(arg3);                         \
      _argvec[4] = (unsigned long)(arg4);                         \
      _argvec[5] = (unsigned long)(arg5);                         \
      _argvec[6] = (unsigned long)(arg6);                         \
      _argvec[7] = (unsigned long)(arg7);                         \
      _argvec[8] = (unsigned long)(arg8);                         \
      _argvec[9] = (unsigned long)(arg9);                         \
      _argvec[10] = (unsigned long)(arg10);                       \
      _argvec[11] = (unsigned long)(arg11);                       \
      _argvec[12] = (unsigned long)(arg12);                       \
      __asm__ volatile(                                           \
         "ldr r0, [%1, #40] \n\t"                                 \
         "ldr r1, [%1, #44] \n\t"                                 \
         "ldr r2, [%1, #48] \n\t"                                 \
         "push {r0, r1, r2} \n\t"                                 \
         "ldr r0, [%1, #20] \n\t"                                 \
         "ldr r1, [%1, #24] \n\t"                                 \
         "ldr r2, [%1, #28] \n\t"                                 \
         "ldr r3, [%1, #32] \n\t"                                 \
         "ldr r4, [%1, #36] \n\t"                                 \
         "push {r0, r1, r2, r3, r4} \n\t"                         \
         "ldr r0, [%1, #4] \n\t"                                  \
         "ldr r1, [%1, #8] \n\t"                                  \
         "ldr r2, [%1, #12] \n\t"                                 \
         "ldr r3, [%1, #16] \n\t"                                 \
         "ldr r4, [%1] \n\t"  /* target->r4 */                    \
         VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R4                   \
         "add sp, sp, #32 \n\t"                                   \
         "mov %0, r0"                                             \
         : /*out*/   "=r" (_res)                                  \
         : /*in*/    "0" (&_argvec[0])                            \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS          \
      );                                                          \
      lval = (__typeof__(lval)) _res;                             \
   } while (0)

#endif /* PLAT_arm_linux */

/* ------------------------- s390x-linux ------------------------- */

#if defined(PLAT_s390x_linux)

/* Similar workaround as amd64 (see above), but we use r11 as frame
   pointer and save the old r11 in r7. r11 might be used for
   argvec, therefore we copy argvec in r1 since r1 is clobbered
   after the call anyway.  */
#if defined(__GNUC__) && defined(__GCC_HAVE_DWARF2_CFI_ASM)
#  define __FRAME_POINTER                                         \
      ,"d"(__builtin_dwarf_cfa())
#  define VALGRIND_CFI_PROLOGUE                                   \
      ".cfi_remember_state\n\t"                                   \
      "lgr 1,%1\n\t" /* copy the argvec pointer in r1 */          \
      "lgr 7,11\n\t"                                              \
      "lgr 11,%2\n\t"                                             \
      ".cfi_def_cfa r11, 0\n\t"
#  define VALGRIND_CFI_EPILOGUE                                   \
      "lgr 11, 7\n\t"                                             \
      ".cfi_restore_state\n\t"
#else
#  define __FRAME_POINTER
#  define VALGRIND_CFI_PROLOGUE                                   \
      "lgr 1,%1\n\t"
#  define VALGRIND_CFI_EPILOGUE
#endif




/* These regs are trashed by the hidden call. Note that we overwrite
   r14 in s390_irgen_noredir (VEX/priv/guest_s390_irgen.c) to give the
   function a proper return address. All others are ABI defined call
   clobbers. */
#define __CALLER_SAVED_REGS "0","1","2","3","4","5","14", \
                           "f0","f1","f2","f3","f4","f5","f6","f7"


#define CALL_FN_W_v(lval, orig)                                  \
   do {                                                          \
      volatile OrigFn        _orig = (orig);                     \
      volatile unsigned long  _argvec[1];                        \
      volatile unsigned long _res;                               \
      _argvec[0] = (unsigned long)_orig.nraddr;                  \
      __asm__ volatile(                                          \
         VALGRIND_CFI_PROLOGUE                                   \
         "aghi 15,-160\n\t"                                      \
         "lg 1, 0(1)\n\t"  /* target->r1 */                      \
         VALGRIND_CALL_NOREDIR_R1                                \
         "lgr %0, 2\n\t"                                         \
         "aghi 15,160\n\t"                                       \
         VALGRIND_CFI_EPILOGUE                                   \
         : /*out*/   "=d" (_res)                                 \
         : /*in*/    "d" (&_argvec[0]) __FRAME_POINTER           \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS,"7"     \
      );                                                         \
      lval = (__typeof__(lval)) _res;                            \
   } while (0)

/* The call abi has the arguments in r2-r6 and stack */
#define CALL_FN_W_W(lval, orig, arg1)                            \
   do {                                                          \
      volatile OrigFn        _orig = (orig);                     \
      volatile unsigned long _argvec[2];                         \
      volatile unsigned long _res;                               \
      _argvec[0] = (unsigned long)_orig.nraddr;                  \
      _argvec[1] = (unsigned long)arg1;                          \
      __asm__ volatile(                                          \
         VALGRIND_CFI_PROLOGUE                                   \
         "aghi 15,-160\n\t"                                      \
         "lg 2, 8(1)\n\t"                                        \
         "lg 1, 0(1)\n\t"                                        \
         VALGRIND_CALL_NOREDIR_R1                                \
         "lgr %0, 2\n\t"                                         \
         "aghi 15,160\n\t"                                       \
         VALGRIND_CFI_EPILOGUE                                   \
         : /*out*/   "=d" (_res)                                 \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER           \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS,"7"     \
      );                                                         \
      lval = (__typeof__(lval)) _res;                            \
   } while (0)

#define CALL_FN_W_WW(lval, orig, arg1, arg2)                     \
   do {                                                          \
      volatile OrigFn        _orig = (orig);                     \
      volatile unsigned long _argvec[3];                         \
      volatile unsigned long _res;                               \
      _argvec[0] = (unsigned long)_orig.nraddr;                  \
      _argvec[1] = (unsigned long)arg1;                          \
      _argvec[2] = (unsigned long)arg2;                          \
      __asm__ volatile(                                          \
         VALGRIND_CFI_PROLOGUE                                   \
         "aghi 15,-160\n\t"                                      \
         "lg 2, 8(1)\n\t"                                        \
         "lg 3,16(1)\n\t"                                        \
         "lg 1, 0(1)\n\t"                                        \
         VALGRIND_CALL_NOREDIR_R1                                \
         "lgr %0, 2\n\t"                                         \
         "aghi 15,160\n\t"                                       \
         VALGRIND_CFI_EPILOGUE                                   \
         : /*out*/   "=d" (_res)                                 \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER           \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS,"7"     \
      );                                                         \
      lval = (__typeof__(lval)) _res;                            \
   } while (0)

#define CALL_FN_W_WWW(lval, orig, arg1, arg2, arg3)              \
   do {                                                          \
      volatile OrigFn        _orig = (orig);                     \
      volatile unsigned long _argvec[4];                         \
      volatile unsigned long _res;                               \
      _argvec[0] = (unsigned long)_orig.nraddr;                  \
      _argvec[1] = (unsigned long)arg1;                          \
      _argvec[2] = (unsigned long)arg2;                          \
      _argvec[3] = (unsigned long)arg3;                          \
      __asm__ volatile(                                          \
         VALGRIND_CFI_PROLOGUE                                   \
         "aghi 15,-160\n\t"                                      \
         "lg 2, 8(1)\n\t"                                        \
         "lg 3,16(1)\n\t"                                        \
         "lg 4,24(1)\n\t"                                        \
         "lg 1, 0(1)\n\t"                                        \
         VALGRIND_CALL_NOREDIR_R1                                \
         "lgr %0, 2\n\t"                                         \
         "aghi 15,160\n\t"                                       \
         VALGRIND_CFI_EPILOGUE                                   \
         : /*out*/   "=d" (_res)                                 \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER           \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS,"7"     \
      );                                                         \
      lval = (__typeof__(lval)) _res;                            \
   } while (0)

#define CALL_FN_W_WWWW(lval, orig, arg1, arg2, arg3, arg4)       \
   do {                                                          \
      volatile OrigFn        _orig = (orig);                     \
      volatile unsigned long _argvec[5];                         \
      volatile unsigned long _res;                               \
      _argvec[0] = (unsigned long)_orig.nraddr;                  \
      _argvec[1] = (unsigned long)arg1;                          \
      _argvec[2] = (unsigned long)arg2;                          \
      _argvec[3] = (unsigned long)arg3;                          \
      _argvec[4] = (unsigned long)arg4;                          \
      __asm__ volatile(                                          \
         VALGRIND_CFI_PROLOGUE                                   \
         "aghi 15,-160\n\t"                                      \
         "lg 2, 8(1)\n\t"                                        \
         "lg 3,16(1)\n\t"                                        \
         "lg 4,24(1)\n\t"                                        \
         "lg 5,32(1)\n\t"                                        \
         "lg 1, 0(1)\n\t"                                        \
         VALGRIND_CALL_NOREDIR_R1                                \
         "lgr %0, 2\n\t"                                         \
         "aghi 15,160\n\t"                                       \
         VALGRIND_CFI_EPILOGUE                                   \
         : /*out*/   "=d" (_res)                                 \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER           \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS,"7"     \
      );                                                         \
      lval = (__typeof__(lval)) _res;                            \
   } while (0)

#define CALL_FN_W_5W(lval, orig, arg1, arg2, arg3, arg4, arg5)   \
   do {                                                          \
      volatile OrigFn        _orig = (orig);                     \
      volatile unsigned long _argvec[6];                         \
      volatile unsigned long _res;                               \
      _argvec[0] = (unsigned long)_orig.nraddr;                  \
      _argvec[1] = (unsigned long)arg1;                          \
      _argvec[2] = (unsigned long)arg2;                          \
      _argvec[3] = (unsigned long)arg3;                          \
      _argvec[4] = (unsigned long)arg4;                          \
      _argvec[5] = (unsigned long)arg5;                          \
      __asm__ volatile(                                          \
         VALGRIND_CFI_PROLOGUE                                   \
         "aghi 15,-160\n\t"                                      \
         "lg 2, 8(1)\n\t"                                        \
         "lg 3,16(1)\n\t"                                        \
         "lg 4,24(1)\n\t"                                        \
         "lg 5,32(1)\n\t"                                        \
         "lg 6,40(1)\n\t"                                        \
         "lg 1, 0(1)\n\t"                                        \
         VALGRIND_CALL_NOREDIR_R1                                \
         "lgr %0, 2\n\t"                                         \
         "aghi 15,160\n\t"                                       \
         VALGRIND_CFI_EPILOGUE                                   \
         : /*out*/   "=d" (_res)                                 \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER           \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS,"6","7" \
      );                                                         \
      lval = (__typeof__(lval)) _res;                            \
   } while (0)

#define CALL_FN_W_6W(lval, orig, arg1, arg2, arg3, arg4, arg5,   \
                     arg6)                                       \
   do {                                                          \
      volatile OrigFn        _orig = (orig);                     \
      volatile unsigned long _argvec[7];                         \
      volatile unsigned long _res;                               \
      _argvec[0] = (unsigned long)_orig.nraddr;                  \
      _argvec[1] = (unsigned long)arg1;                          \
      _argvec[2] = (unsigned long)arg2;                          \
      _argvec[3] = (unsigned long)arg3;                          \
      _argvec[4] = (unsigned long)arg4;                          \
      _argvec[5] = (unsigned long)arg5;                          \
      _argvec[6] = (unsigned long)arg6;                          \
      __asm__ volatile(                                          \
         VALGRIND_CFI_PROLOGUE                                   \
         "aghi 15,-168\n\t"                                      \
         "lg 2, 8(1)\n\t"                                        \
         "lg 3,16(1)\n\t"                                        \
         "lg 4,24(1)\n\t"                                        \
         "lg 5,32(1)\n\t"                                        \
         "lg 6,40(1)\n\t"                                        \
         "mvc 160(8,15), 48(1)\n\t"                              \
         "lg 1, 0(1)\n\t"                                        \
         VALGRIND_CALL_NOREDIR_R1                                \
         "lgr %0, 2\n\t"                                         \
         "aghi 15,168\n\t"                                       \
         VALGRIND_CFI_EPILOGUE                                   \
         : /*out*/   "=d" (_res)                                 \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER           \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS,"6","7" \
      );                                                         \
      lval = (__typeof__(lval)) _res;                            \
   } while (0)

#define CALL_FN_W_7W(lval, orig, arg1, arg2, arg3, arg4, arg5,   \
                     arg6, arg7)                                 \
   do {                                                          \
      volatile OrigFn        _orig = (orig);                     \
      volatile unsigned long _argvec[8];                         \
      volatile unsigned long _res;                               \
      _argvec[0] = (unsigned long)_orig.nraddr;                  \
      _argvec[1] = (unsigned long)arg1;                          \
      _argvec[2] = (unsigned long)arg2;                          \
      _argvec[3] = (unsigned long)arg3;                          \
      _argvec[4] = (unsigned long)arg4;                          \
      _argvec[5] = (unsigned long)arg5;                          \
      _argvec[6] = (unsigned long)arg6;                          \
      _argvec[7] = (unsigned long)arg7;                          \
      __asm__ volatile(                                          \
         VALGRIND_CFI_PROLOGUE                                   \
         "aghi 15,-176\n\t"                                      \
         "lg 2, 8(1)\n\t"                                        \
         "lg 3,16(1)\n\t"                                        \
         "lg 4,24(1)\n\t"                                        \
         "lg 5,32(1)\n\t"                                        \
         "lg 6,40(1)\n\t"                                        \
         "mvc 160(8,15), 48(1)\n\t"                              \
         "mvc 168(8,15), 56(1)\n\t"                              \
         "lg 1, 0(1)\n\t"                                        \
         VALGRIND_CALL_NOREDIR_R1                                \
         "lgr %0, 2\n\t"                                         \
         "aghi 15,176\n\t"                                       \
         VALGRIND_CFI_EPILOGUE                                   \
         : /*out*/   "=d" (_res)                                 \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER           \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS,"6","7" \
      );                                                         \
      lval = (__typeof__(lval)) _res;                            \
   } while (0)

#define CALL_FN_W_8W(lval, orig, arg1, arg2, arg3, arg4, arg5,   \
                     arg6, arg7 ,arg8)                           \
   do {                                                          \
      volatile OrigFn        _orig = (orig);                     \
      volatile unsigned long _argvec[9];                         \
      volatile unsigned long _res;                               \
      _argvec[0] = (unsigned long)_orig.nraddr;                  \
      _argvec[1] = (unsigned long)arg1;                          \
      _argvec[2] = (unsigned long)arg2;                          \
      _argvec[3] = (unsigned long)arg3;                          \
      _argvec[4] = (unsigned long)arg4;                          \
      _argvec[5] = (unsigned long)arg5;                          \
      _argvec[6] = (unsigned long)arg6;                          \
      _argvec[7] = (unsigned long)arg7;                          \
      _argvec[8] = (unsigned long)arg8;                          \
      __asm__ volatile(                                          \
         VALGRIND_CFI_PROLOGUE                                   \
         "aghi 15,-184\n\t"                                      \
         "lg 2, 8(1)\n\t"                                        \
         "lg 3,16(1)\n\t"                                        \
         "lg 4,24(1)\n\t"                                        \
         "lg 5,32(1)\n\t"                                        \
         "lg 6,40(1)\n\t"                                        \
         "mvc 160(8,15), 48(1)\n\t"                              \
         "mvc 168(8,15), 56(1)\n\t"                              \
         "mvc 176(8,15), 64(1)\n\t"                              \
         "lg 1, 0(1)\n\t"                                        \
         VALGRIND_CALL_NOREDIR_R1                                \
         "lgr %0, 2\n\t"                                         \
         "aghi 15,184\n\t"                                       \
         VALGRIND_CFI_EPILOGUE                                   \
         : /*out*/   "=d" (_res)                                 \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER           \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS,"6","7" \
      );                                                         \
      lval = (__typeof__(lval)) _res;                            \
   } while (0)

#define CALL_FN_W_9W(lval, orig, arg1, arg2, arg3, arg4, arg5,   \
                     arg6, arg7 ,arg8, arg9)                     \
   do {                                                          \
      volatile OrigFn        _orig = (orig);                     \
      volatile unsigned long _argvec[10];                        \
      volatile unsigned long _res;                               \
      _argvec[0] = (unsigned long)_orig.nraddr;                  \
      _argvec[1] = (unsigned long)arg1;                          \
      _argvec[2] = (unsigned long)arg2;                          \
      _argvec[3] = (unsigned long)arg3;                          \
      _argvec[4] = (unsigned long)arg4;                          \
      _argvec[5] = (unsigned long)arg5;                          \
      _argvec[6] = (unsigned long)arg6;                          \
      _argvec[7] = (unsigned long)arg7;                          \
      _argvec[8] = (unsigned long)arg8;                          \
      _argvec[9] = (unsigned long)arg9;                          \
      __asm__ volatile(                                          \
         VALGRIND_CFI_PROLOGUE                                   \
         "aghi 15,-192\n\t"                                      \
         "lg 2, 8(1)\n\t"                                        \
         "lg 3,16(1)\n\t"                                        \
         "lg 4,24(1)\n\t"                                        \
         "lg 5,32(1)\n\t"                                        \
         "lg 6,40(1)\n\t"                                        \
         "mvc 160(8,15), 48(1)\n\t"                              \
         "mvc 168(8,15), 56(1)\n\t"                              \
         "mvc 176(8,15), 64(1)\n\t"                              \
         "mvc 184(8,15), 72(1)\n\t"                              \
         "lg 1, 0(1)\n\t"                                        \
         VALGRIND_CALL_NOREDIR_R1                                \
         "lgr %0, 2\n\t"                                         \
         "aghi 15,192\n\t"                                       \
         VALGRIND_CFI_EPILOGUE                                   \
         : /*out*/   "=d" (_res)                                 \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER           \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS,"6","7" \
      );                                                         \
      lval = (__typeof__(lval)) _res;                            \
   } while (0)

#define CALL_FN_W_10W(lval, orig, arg1, arg2, arg3, arg4, arg5,  \
                     arg6, arg7 ,arg8, arg9, arg10)              \
   do {                                                          \
      volatile OrigFn        _orig = (orig);                     \
      volatile unsigned long _argvec[11];                        \
      volatile unsigned long _res;                               \
      _argvec[0] = (unsigned long)_orig.nraddr;                  \
      _argvec[1] = (unsigned long)arg1;                          \
      _argvec[2] = (unsigned long)arg2;                          \
      _argvec[3] = (unsigned long)arg3;                          \
      _argvec[4] = (unsigned long)arg4;                          \
      _argvec[5] = (unsigned long)arg5;                          \
      _argvec[6] = (unsigned long)arg6;                          \
      _argvec[7] = (unsigned long)arg7;                          \
      _argvec[8] = (unsigned long)arg8;                          \
      _argvec[9] = (unsigned long)arg9;                          \
      _argvec[10] = (unsigned long)arg10;                        \
      __asm__ volatile(                                          \
         VALGRIND_CFI_PROLOGUE                                   \
         "aghi 15,-200\n\t"                                      \
         "lg 2, 8(1)\n\t"                                        \
         "lg 3,16(1)\n\t"                                        \
         "lg 4,24(1)\n\t"                                        \
         "lg 5,32(1)\n\t"                                        \
         "lg 6,40(1)\n\t"                                        \
         "mvc 160(8,15), 48(1)\n\t"                              \
         "mvc 168(8,15), 56(1)\n\t"                              \
         "mvc 176(8,15), 64(1)\n\t"                              \
         "mvc 184(8,15), 72(1)\n\t"                              \
         "mvc 192(8,15), 80(1)\n\t"                              \
         "lg 1, 0(1)\n\t"                                        \
         VALGRIND_CALL_NOREDIR_R1                                \
         "lgr %0, 2\n\t"                                         \
         "aghi 15,200\n\t"                                       \
         VALGRIND_CFI_EPILOGUE                                   \
         : /*out*/   "=d" (_res)                                 \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER           \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS,"6","7" \
      );                                                         \
      lval = (__typeof__(lval)) _res;                            \
   } while (0)

#define CALL_FN_W_11W(lval, orig, arg1, arg2, arg3, arg4, arg5,  \
                     arg6, arg7 ,arg8, arg9, arg10, arg11)       \
   do {                                                          \
      volatile OrigFn        _orig = (orig);                     \
      volatile unsigned long _argvec[12];                        \
      volatile unsigned long _res;                               \
      _argvec[0] = (unsigned long)_orig.nraddr;                  \
      _argvec[1] = (unsigned long)arg1;                          \
      _argvec[2] = (unsigned long)arg2;                          \
      _argvec[3] = (unsigned long)arg3;                          \
      _argvec[4] = (unsigned long)arg4;                          \
      _argvec[5] = (unsigned long)arg5;                          \
      _argvec[6] = (unsigned long)arg6;                          \
      _argvec[7] = (unsigned long)arg7;                          \
      _argvec[8] = (unsigned long)arg8;                          \
      _argvec[9] = (unsigned long)arg9;                          \
      _argvec[10] = (unsigned long)arg10;                        \
      _argvec[11] = (unsigned long)arg11;                        \
      __asm__ volatile(                                          \
         VALGRIND_CFI_PROLOGUE                                   \
         "aghi 15,-208\n\t"                                      \
         "lg 2, 8(1)\n\t"                                        \
         "lg 3,16(1)\n\t"                                        \
         "lg 4,24(1)\n\t"                                        \
         "lg 5,32(1)\n\t"                                        \
         "lg 6,40(1)\n\t"                                        \
         "mvc 160(8,15), 48(1)\n\t"                              \
         "mvc 168(8,15), 56(1)\n\t"                              \
         "mvc 176(8,15), 64(1)\n\t"                              \
         "mvc 184(8,15), 72(1)\n\t"                              \
         "mvc 192(8,15), 80(1)\n\t"                              \
         "mvc 200(8,15), 88(1)\n\t"                              \
         "lg 1, 0(1)\n\t"                                        \
         VALGRIND_CALL_NOREDIR_R1                                \
         "lgr %0, 2\n\t"                                         \
         "aghi 15,208\n\t"                                       \
         VALGRIND_CFI_EPILOGUE                                   \
         : /*out*/   "=d" (_res)                                 \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER           \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS,"6","7" \
      );                                                         \
      lval = (__typeof__(lval)) _res;                            \
   } while (0)

#define CALL_FN_W_12W(lval, orig, arg1, arg2, arg3, arg4, arg5,  \
                     arg6, arg7 ,arg8, arg9, arg10, arg11, arg12)\
   do {                                                          \
      volatile OrigFn        _orig = (orig);                     \
      volatile unsigned long _argvec[13];                        \
      volatile unsigned long _res;                               \
      _argvec[0] = (unsigned long)_orig.nraddr;                  \
      _argvec[1] = (unsigned long)arg1;                          \
      _argvec[2] = (unsigned long)arg2;                          \
      _argvec[3] = (unsigned long)arg3;                          \
      _argvec[4] = (unsigned long)arg4;                          \
      _argvec[5] = (unsigned long)arg5;                          \
      _argvec[6] = (unsigned long)arg6;                          \
      _argvec[7] = (unsigned long)arg7;                          \
      _argvec[8] = (unsigned long)arg8;                          \
      _argvec[9] = (unsigned long)arg9;                          \
      _argvec[10] = (unsigned long)arg10;                        \
      _argvec[11] = (unsigned long)arg11;                        \
      _argvec[12] = (unsigned long)arg12;                        \
      __asm__ volatile(                                          \
         VALGRIND_CFI_PROLOGUE                                   \
         "aghi 15,-216\n\t"                                      \
         "lg 2, 8(1)\n\t"                                        \
         "lg 3,16(1)\n\t"                                        \
         "lg 4,24(1)\n\t"                                        \
         "lg 5,32(1)\n\t"                                        \
         "lg 6,40(1)\n\t"                                        \
         "mvc 160(8,15), 48(1)\n\t"                              \
         "mvc 168(8,15), 56(1)\n\t"                              \
         "mvc 176(8,15), 64(1)\n\t"                              \
         "mvc 184(8,15), 72(1)\n\t"                              \
         "mvc 192(8,15), 80(1)\n\t"                              \
         "mvc 200(8,15), 88(1)\n\t"                              \
         "mvc 208(8,15), 96(1)\n\t"                              \
         "lg 1, 0(1)\n\t"                                        \
         VALGRIND_CALL_NOREDIR_R1                                \
         "lgr %0, 2\n\t"                                         \
         "aghi 15,216\n\t"                                       \
         VALGRIND_CFI_EPILOGUE                                   \
         : /*out*/   "=d" (_res)                                 \
         : /*in*/    "a" (&_argvec[0]) __FRAME_POINTER           \
         : /*trash*/ "cc", "memory", __CALLER_SAVED_REGS,"6","7" \
      );                                                         \
      lval = (__typeof__(lval)) _res;                            \
   } while (0)


#endif /* PLAT_s390x_linux */


/* ------------------------------------------------------------------ */
/* ARCHITECTURE INDEPENDENT MACROS for CLIENT REQUESTS.               */
/*                                                                    */
/* ------------------------------------------------------------------ */

/* Some request codes.  There are many more of these, but most are not
   exposed to end-user view.  These are the public ones, all of the
   form 0x1000 + small_number.

   Core ones are in the range 0x00000000--0x0000ffff.  The non-public
   ones start at 0x2000.
*/

/* These macros are used by tools -- they must be public, but don't
   embed them into other programs. */
#define VG_USERREQ_TOOL_BASE(a,b) \
   ((unsigned int)(((a)&0xff) << 24 | ((b)&0xff) << 16))
#define VG_IS_TOOL_USERREQ(a, b, v) \
   (VG_USERREQ_TOOL_BASE(a,b) == ((v) & 0xffff0000))

/* !! ABIWARNING !! ABIWARNING !! ABIWARNING !! ABIWARNING !!
   This enum comprises an ABI exported by Valgrind to programs
   which use client requests.  DO NOT CHANGE THE ORDER OF THESE
   ENTRIES, NOR DELETE ANY -- add new ones at the end. */
typedef
   enum { VG_USERREQ__RUNNING_ON_VALGRIND  = 0x1001,
          VG_USERREQ__DISCARD_TRANSLATIONS = 0x1002,

          /* These allow any function to be called from the simulated
             CPU but run on the real CPU.  Nb: the first arg passed to
             the function is always the ThreadId of the running
             thread!  So CLIENT_CALL0 actually requires a 1 arg
             function, etc. */
          VG_USERREQ__CLIENT_CALL0 = 0x1101,
          VG_USERREQ__CLIENT_CALL1 = 0x1102,
          VG_USERREQ__CLIENT_CALL2 = 0x1103,
          VG_USERREQ__CLIENT_CALL3 = 0x1104,

          /* Can be useful in regression testing suites -- eg. can
             send Valgrind's output to /dev/null and still count
             errors. */
          VG_USERREQ__COUNT_ERRORS = 0x1201,

          /* Allows a string (gdb monitor command) to be passed to the tool
             Used for interaction with vgdb/gdb */
          VG_USERREQ__GDB_MONITOR_COMMAND = 0x1202,

          /* These are useful and can be interpreted by any tool that
             tracks malloc() et al, by using vg_replace_malloc.c. */
          VG_USERREQ__MALLOCLIKE_BLOCK = 0x1301,
          VG_USERREQ__RESIZEINPLACE_BLOCK = 0x130b,
          VG_USERREQ__FREELIKE_BLOCK   = 0x1302,
          /* Memory pool support. */
          VG_USERREQ__CREATE_MEMPOOL   = 0x1303,
          VG_USERREQ__DESTROY_MEMPOOL  = 0x1304,
          VG_USERREQ__MEMPOOL_ALLOC    = 0x1305,
          VG_USERREQ__MEMPOOL_FREE     = 0x1306,
          VG_USERREQ__MEMPOOL_TRIM     = 0x1307,
          VG_USERREQ__MOVE_MEMPOOL     = 0x1308,
          VG_USERREQ__MEMPOOL_CHANGE   = 0x1309,
          VG_USERREQ__MEMPOOL_EXISTS   = 0x130a,

          /* Allow printfs to valgrind log. */
          /* The first two pass the va_list argument by value, which
             assumes it is the same size as or smaller than a UWord,
             which generally isn't the case.  Hence are deprecated.
             The second two pass the vargs by reference and so are
             immune to this problem. */
          /* both :: char* fmt, va_list vargs (DEPRECATED) */
          VG_USERREQ__PRINTF           = 0x1401,
          VG_USERREQ__PRINTF_BACKTRACE = 0x1402,
          /* both :: char* fmt, va_list* vargs */
          VG_USERREQ__PRINTF_VALIST_BY_REF = 0x1403,
          VG_USERREQ__PRINTF_BACKTRACE_VALIST_BY_REF = 0x1404,

          /* Stack support. */
          VG_USERREQ__STACK_REGISTER   = 0x1501,
          VG_USERREQ__STACK_DEREGISTER = 0x1502,
          VG_USERREQ__STACK_CHANGE     = 0x1503,

          /* Wine support */
          VG_USERREQ__LOAD_PDB_DEBUGINFO = 0x1601,

          /* Querying of debug info. */
          VG_USERREQ__MAP_IP_TO_SRCLOC = 0x1701
   } Vg_ClientRequest;

#if !defined(__GNUC__)
#  define __extension__ /* */
#endif


/* Returns the number of Valgrinds this code is running under.  That
   is, 0 if running natively, 1 if running under Valgrind, 2 if
   running under Valgrind which is running under another Valgrind,
   etc. */
#define RUNNING_ON_VALGRIND                                           \
    (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* if not */,         \
                                    VG_USERREQ__RUNNING_ON_VALGRIND,  \
                                    0, 0, 0, 0, 0)                    \


/* Discard translation of code in the range [_qzz_addr .. _qzz_addr +
   _qzz_len - 1].  Useful if you are debugging a JITter or some such,
   since it provides a way to make sure valgrind will retranslate the
   invalidated area.  Returns no value. */
#define VALGRIND_DISCARD_TRANSLATIONS(_qzz_addr,_qzz_len)         \
    (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                  \
                               VG_USERREQ__DISCARD_TRANSLATIONS,  \
                               _qzz_addr, _qzz_len, 0, 0, 0)


/* These requests are for getting Valgrind itself to print something.
   Possibly with a backtrace.  This is a really ugly hack.  The return value
   is the number of characters printed, excluding the "**<pid>** " part at the
   start and the backtrace (if present). */

#if defined(__GNUC__) || defined(__INTEL_COMPILER)
/* Modern GCC will optimize the static routine out if unused,
   and unused attribute will shut down warnings about it.  */
static int VALGRIND_PRINTF(const char *format, ...)
   __attribute__((format(__printf__, 1, 2), __unused__));
#endif
static int
#if defined(_MSC_VER)
__inline
#endif
VALGRIND_PRINTF(const char *format, ...)
{
#if defined(NVALGRIND)
   return 0;
#else /* NVALGRIND */
#if defined(_MSC_VER)
   uintptr_t _qzz_res;
#else
   unsigned long _qzz_res;
#endif
   va_list vargs;
   va_start(vargs, format);
#if defined(_MSC_VER)
   _qzz_res = VALGRIND_DO_CLIENT_REQUEST_EXPR(0,
                              VG_USERREQ__PRINTF_VALIST_BY_REF,
                              (uintptr_t)format,
                              (uintptr_t)&vargs,
                              0, 0, 0);
#else
   _qzz_res = VALGRIND_DO_CLIENT_REQUEST_EXPR(0,
                              VG_USERREQ__PRINTF_VALIST_BY_REF,
                              (unsigned long)format,
                              (unsigned long)&vargs,
                              0, 0, 0);
#endif
   va_end(vargs);
   return (int)_qzz_res;
#endif /* NVALGRIND */
}

#if defined(__GNUC__) || defined(__INTEL_COMPILER)
static int VALGRIND_PRINTF_BACKTRACE(const char *format, ...)
   __attribute__((format(__printf__, 1, 2), __unused__));
#endif
static int
#if defined(_MSC_VER)
__inline
#endif
VALGRIND_PRINTF_BACKTRACE(const char *format, ...)
{
#if defined(NVALGRIND)
   return 0;
#else /* NVALGRIND */
#if defined(_MSC_VER)
   uintptr_t _qzz_res;
#else
   unsigned long _qzz_res;
#endif
   va_list vargs;
   va_start(vargs, format);
#if defined(_MSC_VER)
   _qzz_res = VALGRIND_DO_CLIENT_REQUEST_EXPR(0,
                              VG_USERREQ__PRINTF_BACKTRACE_VALIST_BY_REF,
                              (uintptr_t)format,
                              (uintptr_t)&vargs,
                              0, 0, 0);
#else
   _qzz_res = VALGRIND_DO_CLIENT_REQUEST_EXPR(0,
                              VG_USERREQ__PRINTF_BACKTRACE_VALIST_BY_REF,
                              (unsigned long)format,
                              (unsigned long)&vargs,
                              0, 0, 0);
#endif
   va_end(vargs);
   return (int)_qzz_res;
#endif /* NVALGRIND */
}


/* These requests allow control to move from the simulated CPU to the
   real CPU, calling an arbitrary function.

   Note that the current ThreadId is inserted as the first argument.
   So this call:

     VALGRIND_NON_SIMD_CALL2(f, arg1, arg2)

   requires f to have this signature:

     Word f(Word tid, Word arg1, Word arg2)

   where "Word" is a word-sized type.

   Note that these client requests are not entirely reliable.  For example,
   if you call a function with them that subsequently calls printf(),
   there's a high chance Valgrind will crash.  Generally, your prospects of
   these working are made higher if the called function does not refer to
   any global variables, and does not refer to any libc or other functions
   (printf et al).  Any kind of entanglement with libc or dynamic linking is
   likely to have a bad outcome, for tricky reasons which we've grappled
   with a lot in the past.
*/
#define VALGRIND_NON_SIMD_CALL0(_qyy_fn)                          \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,       \
                                    VG_USERREQ__CLIENT_CALL0,     \
                                    _qyy_fn,                      \
                                    0, 0, 0, 0)

#define VALGRIND_NON_SIMD_CALL1(_qyy_fn, _qyy_arg1)                    \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,            \
                                    VG_USERREQ__CLIENT_CALL1,          \
                                    _qyy_fn,                           \
                                    _qyy_arg1, 0, 0, 0)

#define VALGRIND_NON_SIMD_CALL2(_qyy_fn, _qyy_arg1, _qyy_arg2)         \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,            \
                                    VG_USERREQ__CLIENT_CALL2,          \
                                    _qyy_fn,                           \
                                    _qyy_arg1, _qyy_arg2, 0, 0)

#define VALGRIND_NON_SIMD_CALL3(_qyy_fn, _qyy_arg1, _qyy_arg2, _qyy_arg3) \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0 /* default return */,             \
                                    VG_USERREQ__CLIENT_CALL3,           \
                                    _qyy_fn,                            \
                                    _qyy_arg1, _qyy_arg2,               \
                                    _qyy_arg3, 0)


/* Counts the number of errors that have been recorded by a tool.  Nb:
   the tool must record the errors with VG_(maybe_record_error)() or
   VG_(unique_error)() for them to be counted. */
#define VALGRIND_COUNT_ERRORS                                     \
    (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(                    \
                               0 /* default return */,            \
                               VG_USERREQ__COUNT_ERRORS,          \
                               0, 0, 0, 0, 0)

/* Several Valgrind tools (Memcheck, Massif, Helgrind, DRD) rely on knowing
   when heap blocks are allocated in order to give accurate results.  This
   happens automatically for the standard allocator functions such as
   malloc(), calloc(), realloc(), memalign(), new, new[], free(), delete,
   delete[], etc.

   But if your program uses a custom allocator, this doesn't automatically
   happen, and Valgrind will not do as well.  For example, if you allocate
   superblocks with mmap() and then allocates chunks of the superblocks, all
   Valgrind's observations will be at the mmap() level and it won't know that
   the chunks should be considered separate entities.  In Memcheck's case,
   that means you probably won't get heap block overrun detection (because
   there won't be redzones marked as unaddressable) and you definitely won't
   get any leak detection.

   The following client requests allow a custom allocator to be annotated so
   that it can be handled accurately by Valgrind.

   VALGRIND_MALLOCLIKE_BLOCK marks a region of memory as having been allocated
   by a malloc()-like function.  For Memcheck (an illustrative case), this
   does two things:

   - It records that the block has been allocated.  This means any addresses
     within the block mentioned in error messages will be
     identified as belonging to the block.  It also means that if the block
     isn't freed it will be detected by the leak checker.

   - It marks the block as being addressable and undefined (if 'is_zeroed' is
     not set), or addressable and defined (if 'is_zeroed' is set).  This
     controls how accesses to the block by the program are handled.

   'addr' is the start of the usable block (ie. after any
   redzone), 'sizeB' is its size.  'rzB' is the redzone size if the allocator
   can apply redzones -- these are blocks of padding at the start and end of
   each block.  Adding redzones is recommended as it makes it much more likely
   Valgrind will spot block overruns.  `is_zeroed' indicates if the memory is
   zeroed (or filled with another predictable value), as is the case for
   calloc().

   VALGRIND_MALLOCLIKE_BLOCK should be put immediately after the point where a
   heap block -- that will be used by the client program -- is allocated.
   It's best to put it at the outermost level of the allocator if possible;
   for example, if you have a function my_alloc() which calls
   internal_alloc(), and the client request is put inside internal_alloc(),
   stack traces relating to the heap block will contain entries for both
   my_alloc() and internal_alloc(), which is probably not what you want.

   For Memcheck users: if you use VALGRIND_MALLOCLIKE_BLOCK to carve out
   custom blocks from within a heap block, B, that has been allocated with
   malloc/calloc/new/etc, then block B will be *ignored* during leak-checking
   -- the custom blocks will take precedence.

   VALGRIND_FREELIKE_BLOCK is the partner to VALGRIND_MALLOCLIKE_BLOCK.  For
   Memcheck, it does two things:

   - It records that the block has been deallocated.  This assumes that the
     block was annotated as having been allocated via
     VALGRIND_MALLOCLIKE_BLOCK.  Otherwise, an error will be issued.

   - It marks the block as being unaddressable.

   VALGRIND_FREELIKE_BLOCK should be put immediately after the point where a
   heap block is deallocated.

   VALGRIND_RESIZEINPLACE_BLOCK informs a tool about reallocation. For
   Memcheck, it does four things:

   - It records that the size of a block has been changed.  This assumes that
     the block was annotated as having been allocated via
     VALGRIND_MALLOCLIKE_BLOCK.  Otherwise, an error will be issued.

   - If the block shrunk, it marks the freed memory as being unaddressable.

   - If the block grew, it marks the new area as undefined and defines a red
     zone past the end of the new block.

   - The V-bits of the overlap between the old and the new block are preserved.

   VALGRIND_RESIZEINPLACE_BLOCK should be put after allocation of the new block
   and before deallocation of the old block.

   In many cases, these three client requests will not be enough to get your
   allocator working well with Memcheck.  More specifically, if your allocator
   writes to freed blocks in any way then a VALGRIND_MAKE_MEM_UNDEFINED call
   will be necessary to mark the memory as addressable just before the zeroing
   occurs, otherwise you'll get a lot of invalid write errors.  For example,
   you'll need to do this if your allocator recycles freed blocks, but it
   zeroes them before handing them back out (via VALGRIND_MALLOCLIKE_BLOCK).
   Alternatively, if your allocator reuses freed blocks for allocator-internal
   data structures, VALGRIND_MAKE_MEM_UNDEFINED calls will also be necessary.

   Really, what's happening is a blurring of the lines between the client
   program and the allocator... after VALGRIND_FREELIKE_BLOCK is called, the
   memory should be considered unaddressable to the client program, but the
   allocator knows more than the rest of the client program and so may be able
   to safely access it.  Extra client requests are necessary for Valgrind to
   understand the distinction between the allocator and the rest of the
   program.

   Ignored if addr == 0.
*/
#define VALGRIND_MALLOCLIKE_BLOCK(addr, sizeB, rzB, is_zeroed)    \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                            \
                               VG_USERREQ__MALLOCLIKE_BLOCK,      \
                               addr, sizeB, rzB, is_zeroed, 0)

/* See the comment for VALGRIND_MALLOCLIKE_BLOCK for details.
   Ignored if addr == 0.
*/
#define VALGRIND_RESIZEINPLACE_BLOCK(addr, oldSizeB, newSizeB, rzB) \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                            \
                               VG_USERREQ__RESIZEINPLACE_BLOCK,   \
                               addr, oldSizeB, newSizeB, rzB, 0)

/* See the comment for VALGRIND_MALLOCLIKE_BLOCK for details.
   Ignored if addr == 0.
*/
#define VALGRIND_FREELIKE_BLOCK(addr, rzB)                        \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                            \
                               VG_USERREQ__FREELIKE_BLOCK,        \
                               addr, rzB, 0, 0, 0)

/* Create a memory pool. */
#define VALGRIND_CREATE_MEMPOOL(pool, rzB, is_zeroed)             \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                            \
                               VG_USERREQ__CREATE_MEMPOOL,        \
                               pool, rzB, is_zeroed, 0, 0)

/* Destroy a memory pool. */
#define VALGRIND_DESTROY_MEMPOOL(pool)                            \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                            \
                               VG_USERREQ__DESTROY_MEMPOOL,       \
                               pool, 0, 0, 0, 0)

/* Associate a piece of memory with a memory pool. */
#define VALGRIND_MEMPOOL_ALLOC(pool, addr, size)                  \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                            \
                               VG_USERREQ__MEMPOOL_ALLOC,         \
                               pool, addr, size, 0, 0)

/* Disassociate a piece of memory from a memory pool. */
#define VALGRIND_MEMPOOL_FREE(pool, addr)                         \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                            \
                               VG_USERREQ__MEMPOOL_FREE,          \
                               pool, addr, 0, 0, 0)

/* Disassociate any pieces outside a particular range. */
#define VALGRIND_MEMPOOL_TRIM(pool, addr, size)                   \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                            \
                               VG_USERREQ__MEMPOOL_TRIM,          \
                               pool, addr, size, 0, 0)

/* Resize and/or move a piece associated with a memory pool. */
#define VALGRIND_MOVE_MEMPOOL(poolA, poolB)                       \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                            \
                               VG_USERREQ__MOVE_MEMPOOL,          \
                               poolA, poolB, 0, 0, 0)

/* Resize and/or move a piece associated with a memory pool. */
#define VALGRIND_MEMPOOL_CHANGE(pool, addrA, addrB, size)         \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                            \
                               VG_USERREQ__MEMPOOL_CHANGE,        \
                               pool, addrA, addrB, size, 0)

/* Return 1 if a mempool exists, else 0. */
#define VALGRIND_MEMPOOL_EXISTS(pool)                             \
    (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                  \
                               VG_USERREQ__MEMPOOL_EXISTS,        \
                               pool, 0, 0, 0, 0)

/* Mark a piece of memory as being a stack. Returns a stack id. */
#define VALGRIND_STACK_REGISTER(start, end)                       \
    (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                  \
                               VG_USERREQ__STACK_REGISTER,        \
                               start, end, 0, 0, 0)

/* Unmark the piece of memory associated with a stack id as being a
   stack. */
#define VALGRIND_STACK_DEREGISTER(id)                             \
    (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                  \
                               VG_USERREQ__STACK_DEREGISTER,      \
                               id, 0, 0, 0, 0)

/* Change the start and end address of the stack id. */
#define VALGRIND_STACK_CHANGE(id, start, end)                     \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                            \
                               VG_USERREQ__STACK_CHANGE,          \
                               id, start, end, 0, 0)

/* Load PDB debug info for Wine PE image_map. */
#define VALGRIND_LOAD_PDB_DEBUGINFO(fd, ptr, total_size, delta)   \
    VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                            \
                               VG_USERREQ__LOAD_PDB_DEBUGINFO,    \
                               fd, ptr, total_size, delta, 0)

/* Map a code address to a source file name and line number.  buf64
   must point to a 64-byte buffer in the caller's address space.  The
   result will be dumped in there and is guaranteed to be zero
   terminated.  If no info is found, the first byte is set to zero. */
#define VALGRIND_MAP_IP_TO_SRCLOC(addr, buf64)                    \
    (unsigned)VALGRIND_DO_CLIENT_REQUEST_EXPR(0,                  \
                               VG_USERREQ__MAP_IP_TO_SRCLOC,      \
                               addr, buf64, 0, 0, 0)


#undef PLAT_x86_darwin
#undef PLAT_amd64_darwin
#undef PLAT_x86_win32
#undef PLAT_x86_linux
#undef PLAT_amd64_linux
#undef PLAT_ppc32_linux
#undef PLAT_ppc64_linux
#undef PLAT_arm_linux
#undef PLAT_s390x_linux

#endif   /* __VALGRIND_H */
                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/src/third_party/vtune/                                                          0000775 0000000 0000000 00000000000 14746647661 0020326 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/src/third_party/vtune/BUILD.gn                                                  0000664 0000000 0000000 00000002446 14746647661 0021521 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2017 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("../../../gni/v8.gni")
config("vtune_ittapi") {
  include_dirs = [
    "//third_party/ittapi/include",
    "//third_party/ittapi/src/ittnotify",
  ]
}

v8_source_set("v8_vtune") {
  sources = [
    "//third_party/ittapi/include/jitprofiling.h",
    "//third_party/ittapi/src/ittnotify/ittnotify_config.h",
    "//third_party/ittapi/src/ittnotify/ittnotify_types.h",
    "//third_party/ittapi/src/ittnotify/jitprofiling.c",
    "v8-vtune.h",
    "vtune-jit.cc",
    "vtune-jit.h",
  ]
  configs = [ ":vtune_ittapi" ]
  deps = [ "../../..:v8" ]
}

v8_source_set("v8_vtune_trace_mark") {
  sources = [
    "//third_party/ittapi/include/ittnotify.h",
    "vtuneapi.cc",
    "vtuneapi.h",
  ]
  deps = [ ":ittnotify" ]
  configs = []
}

v8_source_set("ittnotify") {
  sources = [
    "//third_party/ittapi/include/ittnotify.h",
    "//third_party/ittapi/include/legacy/ittnotify.h",
    "//third_party/ittapi/src/ittnotify/ittnotify_config.h",
    "//third_party/ittapi/src/ittnotify/ittnotify_static.c",
    "//third_party/ittapi/src/ittnotify/ittnotify_static.h",
  ]
  include_dirs = [ "//third_party/ittapi/include" ]
  deps = []
  configs = []
}
                                                                                                                                                                                                                          node-23.7.0/deps/v8/src/third_party/vtune/DEPS                                                      0000664 0000000 0000000 00000000053 14746647661 0021002 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        include_rules = [
  "+../../../include",
]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/src/third_party/vtune/LICENSE                                                   0000664 0000000 0000000 00000005253 14746647661 0021340 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        All files in this directory are provided by the following license if not stated
otherwise in the individual file:
====================
This file is provided under a dual BSD/GPLv2 license.  When using or
redistributing this file, you may do so under either license.

GPL LICENSE SUMMARY

Copyright (c) 2005-2012 Intel Corporation. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of version 2 of the GNU General Public License as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
The full GNU General Public License is included in this distribution
in the file called LICENSE.GPL.

Contact Information:
http://software.intel.com/en-us/articles/intel-vtune-amplifier-xe/

BSD LICENSE

Copyright (c) 2005-2012 Intel Corporation. All rights reserved.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

  * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in
    the documentation and/or other materials provided with the
    distribution.
  * Neither the name of Intel Corporation nor the names of its
    contributors may be used to endorse or promote products derived
    from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
====================
                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/src/third_party/vtune/OWNERS                                                    0000664 0000000 0000000 00000000034 14746647661 0021263 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        file:../../../COMMON_OWNERS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/src/third_party/vtune/v8-vtune.h                                                0000664 0000000 0000000 00000005545 14746647661 0022204 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
   This file is provided under a dual BSD/GPLv2 license.  When using or
   redistributing this file, you may do so under either license.

   GPL LICENSE SUMMARY

   Copyright(c) 2005-2012 Intel Corporation. All rights reserved.

   This program is free software; you can redistribute it and/or modify
   it under the terms of version 2 of the GNU General Public License as
   published by the Free Software Foundation.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
   The full GNU General Public License is included in this distribution
   in the file called LICENSE.GPL.

   Contact Information:
   http://software.intel.com/en-us/articles/intel-vtune-amplifier-xe/

   BSD LICENSE

   Copyright(c) 2005-2012 Intel Corporation. All rights reserved.
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in
       the documentation and/or other materials provided with the
       distribution.
     * Neither the name of Intel Corporation nor the names of its
       contributors may be used to endorse or promote products derived
       from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef V8_VTUNE_H_
#define V8_VTUNE_H_

#include "../../../include/v8-callbacks.h"

namespace vTune {

v8::JitCodeEventHandler GetVtuneCodeEventHandler();

}  // namespace vTune


#endif  // V8_VTUNE_H_

                                                                                                                                                           node-23.7.0/deps/v8/src/third_party/vtune/vtune-jit.cc                                              0000664 0000000 0000000 00000022673 14746647661 0022574 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 2005-2012 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  http://software.intel.com/en-us/articles/intel-vtune-amplifier-xe/

  BSD LICENSE

  Copyright(c) 2005-2012 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "vtune-jit.h"

#include <stdlib.h>
#include <string.h>

#include <list>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

#include "../../../include/v8-callbacks.h"
#include "../../../include/v8-initialization.h"
#include "../../../include/v8-local-handle.h"
#include "../../../include/v8-primitive.h"
#include "../../../include/v8-script.h"
#include "v8-vtune.h"

namespace vTune {
namespace internal {


// This class is used to record the JITted code position info for JIT
// code profiling.
class JITCodeLineInfo {
 public:
  JITCodeLineInfo() { }

  void SetPosition(intptr_t pc, int pos) {
    AddCodeLineInfo(LineNumInfo(pc, pos));
  }

  struct LineNumInfo {
    LineNumInfo(intptr_t pc, int pos)
        : pc_(pc), pos_(pos) { }

    intptr_t pc_;
    int pos_;
  };

  std::list<LineNumInfo>* GetLineNumInfo() {
    return &line_num_info_;
  }

 private:
  void AddCodeLineInfo(const LineNumInfo& line_info) {
	  line_num_info_.push_back(line_info);
  }
  std::list<LineNumInfo> line_num_info_;
};

struct SameCodeObjects {
  bool operator () (void* key1, void* key2) const {
    return key1 == key2;
  }
};

struct HashForCodeObject {
  uint32_t operator () (void* code) const {
    static const uintptr_t kGoldenRatio = 2654435761u;
    uintptr_t hash = reinterpret_cast<uintptr_t>(code);
    return static_cast<uint32_t>(hash * kGoldenRatio);
  }
};

typedef std::unordered_map<void*, void*, HashForCodeObject, SameCodeObjects>
    JitInfoMap;

static JitInfoMap* GetEntries() {
  static JitInfoMap* entries;
  if (entries == NULL) {
    entries = new JitInfoMap();
  }
  return entries;
}

static bool IsLineInfoTagged(void* ptr) {
  return 0 != (reinterpret_cast<intptr_t>(ptr));
}

static JITCodeLineInfo* UntagLineInfo(void* ptr) {
  return reinterpret_cast<JITCodeLineInfo*>(
    reinterpret_cast<intptr_t>(ptr));
}

// The JitCodeEventHandler for Vtune.
void VTUNEJITInterface::event_handler(const v8::JitCodeEvent* event) {
  if (VTUNERUNNING && event != NULL) {
    switch (event->type) {
      case v8::JitCodeEvent::CODE_ADDED: {
        std::unique_ptr<char[]> temp_file_name;
        std::string temp_method_name(event->name.str, event->name.len);
        std::vector<LineNumberInfo> jmethod_line_number_table;
        iJIT_Method_Load jmethod;
        memset(&jmethod, 0, sizeof jmethod);
        jmethod.method_id = iJIT_GetNewMethodID();
        jmethod.method_load_address = event->code_start;
        jmethod.method_size = static_cast<unsigned int>(event->code_len);
        jmethod.method_name = const_cast<char*>(temp_method_name.c_str());

        Local<UnboundScript> script = event->script;

        if (*script != NULL) {
          // Get the source file name and set it to jmethod.source_file_name
          if ((*script->GetScriptName())->IsString()) {
            Local<String> script_name = script->GetScriptName().As<String>();
            temp_file_name.reset(
                new char[script_name->Utf8Length(event->isolate) + 1]);
            script_name->WriteUtf8(event->isolate, temp_file_name.get());
            jmethod.source_file_name = temp_file_name.get();
          }

          JitInfoMap::iterator entry =
              GetEntries()->find(event->code_start);
          if (entry != GetEntries()->end() && IsLineInfoTagged(entry->first)) {
            JITCodeLineInfo* line_info = UntagLineInfo(entry->second);
            // Get the line_num_info and set it to jmethod.line_number_table
            std::list<JITCodeLineInfo::LineNumInfo>* vtunelineinfo =
                line_info->GetLineNumInfo();

            jmethod.line_number_size = (unsigned int)vtunelineinfo->size();
            jmethod_line_number_table.resize(jmethod.line_number_size);
            jmethod.line_number_table = jmethod_line_number_table.data();

            std::list<JITCodeLineInfo::LineNumInfo>::iterator Iter;
            int index = 0;
            for (Iter = vtunelineinfo->begin();
                 Iter != vtunelineinfo->end();
                 Iter++) {
              jmethod.line_number_table[index].Offset =
                  static_cast<unsigned int>(Iter->pc_);
              jmethod.line_number_table[index++].LineNumber =
                  script->GetLineNumber(Iter->pos_) + 1;
            }
            GetEntries()->erase(event->code_start);
          }
        } else if (event->wasm_source_info != nullptr) {
          const char* filename = event->wasm_source_info->filename;
          size_t filename_size = event->wasm_source_info->filename_size;
          const v8::JitCodeEvent::line_info_t* line_number_table =
              event->wasm_source_info->line_number_table;
          size_t line_number_table_size =
              event->wasm_source_info->line_number_table_size;

          temp_file_name.reset(new char[filename_size + 1]);
          memcpy(temp_file_name.get(), filename, filename_size);
          temp_file_name[filename_size] = '\0';
          jmethod.source_file_name = temp_file_name.get();

          jmethod.line_number_size =
              static_cast<unsigned int>(line_number_table_size);
          jmethod_line_number_table.resize(jmethod.line_number_size);
          jmethod.line_number_table = jmethod_line_number_table.data();

          for (size_t index = 0; index < line_number_table_size; ++index) {
            jmethod.line_number_table[index].LineNumber =
                static_cast<unsigned int>(line_number_table[index].pos);
            jmethod.line_number_table[index].Offset =
                static_cast<unsigned int>(line_number_table[index].offset);
          }
        }

        iJIT_NotifyEvent(iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED,
                         reinterpret_cast<void*>(&jmethod));
        break;
      }
      // TODO(chunyang.dai@intel.com): code_move will be supported.
      case v8::JitCodeEvent::CODE_MOVED:
        break;
      // Currently the CODE_REMOVED event is not issued.
      case v8::JitCodeEvent::CODE_REMOVED:
        break;
      case v8::JitCodeEvent::CODE_ADD_LINE_POS_INFO: {
        JITCodeLineInfo* line_info =
            reinterpret_cast<JITCodeLineInfo*>(event->user_data);
        if (line_info != NULL) {
          line_info->SetPosition(static_cast<intptr_t>(event->line_info.offset),
                                 static_cast<int>(event->line_info.pos));
        }
        break;
      }
      case v8::JitCodeEvent::CODE_START_LINE_INFO_RECORDING: {
        v8::JitCodeEvent* temp_event = const_cast<v8::JitCodeEvent*>(event);
        temp_event->user_data = new JITCodeLineInfo();
        break;
      }
      case v8::JitCodeEvent::CODE_END_LINE_INFO_RECORDING: {
        GetEntries()->insert(std::pair <void*, void*>(event->code_start, event->user_data));
        break;
      }
      default:
        break;
    }
  }
  return;
}

}  // namespace internal

v8::JitCodeEventHandler GetVtuneCodeEventHandler() {
  return vTune::internal::VTUNEJITInterface::event_handler;
}

}  // namespace vTune
                                                                     node-23.7.0/deps/v8/src/third_party/vtune/vtune-jit.h                                               0000664 0000000 0000000 00000006175 14746647661 0022435 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
   This file is provided under a dual BSD/GPLv2 license.  When using or
   redistributing this file, you may do so under either license.

   GPL LICENSE SUMMARY

   Copyright(c) 2005-2012 Intel Corporation. All rights reserved.

   This program is free software; you can redistribute it and/or modify
   it under the terms of version 2 of the GNU General Public License as
   published by the Free Software Foundation.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
   The full GNU General Public License is included in this distribution
   in the file called LICENSE.GPL.

   Contact Information:
   http://software.intel.com/en-us/articles/intel-vtune-amplifier-xe/

   BSD LICENSE

   Copyright(c) 2005-2012 Intel Corporation. All rights reserved.
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in
       the documentation and/or other materials provided with the
       distribution.
     * Neither the name of Intel Corporation nor the names of its
       contributors may be used to endorse or promote products derived
       from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef VTUNE_VTUNE_JIT_H_
#define VTUNE_VTUNE_JIT_H_

#include "third_party/ittapi/include/jitprofiling.h"

#define VTUNERUNNING (iJIT_IsProfilingActive() == iJIT_SAMPLING_ON)

namespace v8 {
struct JitCodeEvent;
}

namespace vTune {
namespace internal {
using namespace v8;
class VTUNEJITInterface {
 public:
  static void event_handler(const v8::JitCodeEvent* event);

 private:
  //static Mutex* vtunemutex_;
};


} }  // namespace vTune::internal


#endif  // VTUNE_VTUNE_JIT_H_

                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/src/third_party/vtune/vtuneapi.cc                                               0000664 0000000 0000000 00000004257 14746647661 0022500 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "vtuneapi.h"
#ifdef _MSC_VER  // for msvc
#include <cstdlib>
#endif

std::map<std::string, std::shared_ptr<VTuneDomain>> VTuneDomain::domains_;
std::map<std::string, __itt_string_handle*> VTuneDomain::string_handlers_;

std::shared_ptr<VTuneDomain> VTuneDomain::createDomain(
    const char* domain_name) {
  auto domain = getDomain(domain_name);

  if (domain == nullptr) {
#ifdef _MSC_VER  // for msvc
    wchar_t buffer[255];
    mbstowcs(buffer, domain_name, 255);
    __itt_domain* itt_domain = __itt_domain_create(buffer);  // call api
#else  // for clang and gcc
    __itt_domain* itt_domain = __itt_domain_create(domain_name);  // call api
#endif
    if (itt_domain != NULL) {
      std::string key(domain_name);
      std::shared_ptr<VTuneDomain> value(new VTuneDomain(itt_domain));
      domain = value;
      domains_.insert(std::make_pair(key, value));
    }
  }

  return domain;
}

void VTuneDomain::destroyDomain(const char* domain_name) {
  auto it = domains_.find(domain_name);
  if (it != domains_.end()) {
    domains_.erase(it);
  }
}

std::shared_ptr<VTuneDomain> VTuneDomain::getDomain(const char* domain_name) {
  std::shared_ptr<VTuneDomain> result(nullptr);

  auto it = domains_.find(domain_name);
  if (it != domains_.end()) {
    result = it->second;
  }

  return result;
}

__itt_string_handle* VTuneDomain::getString(const char* str) {
  __itt_string_handle* result = NULL;

  auto it = string_handlers_.find(str);
  if (it != string_handlers_.end()) {
    result = it->second;
  } else {
#ifdef _MSC_VER  // for msvc
    wchar_t buffer[255];
    mbstowcs(buffer, str, 255);
    result = __itt_string_handle_create(buffer);  // call api
#else                                             // for clang and gcc
    result = __itt_string_handle_create(str);
#endif
    std::string key(str);
    string_handlers_.insert(std::make_pair(key, result));
  }

  return result;
}

bool VTuneDomain::beginTask(const char* task_name) {
  bool result = false;

  __itt_string_handle* name = getString(task_name);
  if (name != NULL) {
    __itt_task_begin(domain_, __itt_null, __itt_null, name);
    result = true;
  }

  return result;
}

void VTuneDomain::endTask() { __itt_task_end(domain_); }
                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/src/third_party/vtune/vtuneapi.h                                                0000664 0000000 0000000 00000002337 14746647661 0022337 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef __VTUNE_API_H__
#define __VTUNE_API_H__

#include <map>
#include <memory>
#include <string>
#include "third_party/ittapi/include/ittnotify.h"

class VTuneDomain {
  /* factory method to create vtune domain */
 public:
  /* create vtune domain, domain_name should be unique, if there
     already has a domain with same name, return false.
   */
  static std::shared_ptr<VTuneDomain> createDomain(const char* domain_name);

  /* destory vtune domain*/
  static void destroyDomain(const char* domain_name);

  /* get a domain */
  static std::shared_ptr<VTuneDomain> getDomain(const char* domain_name);

  /* domain interface */
 public:
  /* start a task with name, if no task name or null, use "default_task_name"*/
  bool beginTask(const char* task_name = "default_task_name");

  /* end a task, if there is no stacked task, return false*/
  void endTask();

 public:
  virtual ~VTuneDomain() {}

 protected:
  static __itt_string_handle* getString(const char* str);

 protected:
  VTuneDomain(__itt_domain* domain) { domain_ = domain; }

 private:
  static std::map<std::string, std::shared_ptr<VTuneDomain>> domains_;
  static std::map<std::string, __itt_string_handle*> string_handlers_;

 private:
  __itt_domain* domain_;
};

#endif
                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/src/torque/                                                                     0000775 0000000 0000000 00000000000 14746647661 0016153 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/src/torque/OWNERS                                                               0000664 0000000 0000000 00000000032 14746647661 0017106 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        nicohartmann@chromium.org
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/src/torque/ast.h                                                                0000664 0000000 0000000 00000133637 14746647661 0017130 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_TORQUE_AST_H_
#define V8_TORQUE_AST_H_

#include <algorithm>
#include <iostream>
#include <map>
#include <memory>
#include <optional>
#include <set>
#include <string>
#include <vector>

#include "src/numbers/integer-literal.h"
#include "src/torque/constants.h"
#include "src/torque/source-positions.h"
#include "src/torque/utils.h"

namespace v8::internal::torque {

#define AST_EXPRESSION_NODE_KIND_LIST(V) \
  V(CallExpression)                      \
  V(CallMethodExpression)                \
  V(IntrinsicCallExpression)             \
  V(StructExpression)                    \
  V(LogicalOrExpression)                 \
  V(LogicalAndExpression)                \
  V(SpreadExpression)                    \
  V(ConditionalExpression)               \
  V(IdentifierExpression)                \
  V(StringLiteralExpression)             \
  V(IntegerLiteralExpression)            \
  V(FloatingPointLiteralExpression)      \
  V(FieldAccessExpression)               \
  V(ElementAccessExpression)             \
  V(DereferenceExpression)               \
  V(AssignmentExpression)                \
  V(IncrementDecrementExpression)        \
  V(NewExpression)                       \
  V(AssumeTypeImpossibleExpression)      \
  V(StatementExpression)                 \
  V(TryLabelExpression)

#define AST_TYPE_EXPRESSION_NODE_KIND_LIST(V) \
  V(BasicTypeExpression)                      \
  V(FunctionTypeExpression)                   \
  V(PrecomputedTypeExpression)                \
  V(UnionTypeExpression)

#define AST_STATEMENT_NODE_KIND_LIST(V) \
  V(BlockStatement)                     \
  V(ExpressionStatement)                \
  V(IfStatement)                        \
  V(WhileStatement)                     \
  V(ForLoopStatement)                   \
  V(BreakStatement)                     \
  V(ContinueStatement)                  \
  V(ReturnStatement)                    \
  V(DebugStatement)                     \
  V(AssertStatement)                    \
  V(TailCallStatement)                  \
  V(VarDeclarationStatement)            \
  V(GotoStatement)

#define AST_TYPE_DECLARATION_NODE_KIND_LIST(V) \
  V(AbstractTypeDeclaration)                   \
  V(TypeAliasDeclaration)                      \
  V(BitFieldStructDeclaration)                 \
  V(ClassDeclaration)                          \
  V(StructDeclaration)

#define AST_DECLARATION_NODE_KIND_LIST(V) \
  AST_TYPE_DECLARATION_NODE_KIND_LIST(V)  \
  V(GenericCallableDeclaration)           \
  V(GenericTypeDeclaration)               \
  V(SpecializationDeclaration)            \
  V(ExternConstDeclaration)               \
  V(NamespaceDeclaration)                 \
  V(ConstDeclaration)                     \
  V(CppIncludeDeclaration)                \
  V(TorqueMacroDeclaration)               \
  V(TorqueBuiltinDeclaration)             \
  V(ExternalMacroDeclaration)             \
  V(ExternalBuiltinDeclaration)           \
  V(ExternalRuntimeDeclaration)           \
  V(IntrinsicDeclaration)

#define AST_NODE_KIND_LIST(V)           \
  AST_EXPRESSION_NODE_KIND_LIST(V)      \
  AST_TYPE_EXPRESSION_NODE_KIND_LIST(V) \
  AST_STATEMENT_NODE_KIND_LIST(V)       \
  AST_DECLARATION_NODE_KIND_LIST(V)     \
  V(Identifier)                         \
  V(TryHandler)                         \
  V(ClassBody)

struct AstNode {
 public:
  enum class Kind {
#define ENUM_ITEM(name) k##name,
    AST_NODE_KIND_LIST(ENUM_ITEM)
#undef ENUM_ITEM
  };

  AstNode(Kind kind, SourcePosition pos) : kind(kind), pos(pos) {}
  virtual ~AstNode() = default;

  const Kind kind;
  SourcePosition pos;
};

struct AstNodeClassCheck {
  template <class T>
  static bool IsInstanceOf(AstNode* node);
};

// Boilerplate for most derived classes.
#define DEFINE_AST_NODE_LEAF_BOILERPLATE(T)  \
  static const Kind kKind = Kind::k##T;      \
  static T* cast(AstNode* node) {            \
    DCHECK_EQ(node->kind, kKind);            \
    return static_cast<T*>(node);            \
  }                                          \
  static T* DynamicCast(AstNode* node) {     \
    if (!node) return nullptr;               \
    if (node->kind != kKind) return nullptr; \
    return static_cast<T*>(node);            \
  }

// Boilerplate for classes with subclasses.
#define DEFINE_AST_NODE_INNER_BOILERPLATE(T)                       \
  static T* cast(AstNode* node) {                                  \
    DCHECK(AstNodeClassCheck::IsInstanceOf<T>(node));              \
    return static_cast<T*>(node);                                  \
  }                                                                \
  static T* DynamicCast(AstNode* node) {                           \
    if (!node) return nullptr;                                     \
    if (!AstNodeClassCheck::IsInstanceOf<T>(node)) return nullptr; \
    return static_cast<T*>(node);                                  \
  }

struct Expression : AstNode {
  Expression(Kind kind, SourcePosition pos) : AstNode(kind, pos) {}
  DEFINE_AST_NODE_INNER_BOILERPLATE(Expression)

  using VisitCallback = std::function<void(Expression*)>;
  virtual void VisitAllSubExpressions(VisitCallback callback) {
    // TODO(szuend): Hoist this up to AstNode and make it a
    //               general Ast visitor.
  }
};

struct LocationExpression : Expression {
  LocationExpression(Kind kind, SourcePosition pos) : Expression(kind, pos) {}
  DEFINE_AST_NODE_INNER_BOILERPLATE(LocationExpression)
};

struct TypeExpression : AstNode {
  TypeExpression(Kind kind, SourcePosition pos) : AstNode(kind, pos) {}
  DEFINE_AST_NODE_INNER_BOILERPLATE(TypeExpression)
};

struct Declaration : AstNode {
  Declaration(Kind kind, SourcePosition pos) : AstNode(kind, pos) {}
  DEFINE_AST_NODE_INNER_BOILERPLATE(Declaration)
};

struct Statement : AstNode {
  Statement(Kind kind, SourcePosition pos) : AstNode(kind, pos) {}
  DEFINE_AST_NODE_INNER_BOILERPLATE(Statement)
};

class Namespace;

struct NamespaceDeclaration : Declaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(NamespaceDeclaration)
  NamespaceDeclaration(SourcePosition pos, std::string name,
                       std::vector<Declaration*> declarations)
      : Declaration(kKind, pos),
        declarations(std::move(declarations)),
        name(name) {}
  std::vector<Declaration*> declarations;
  std::string name;
};

struct EnumDescription {
  struct Entry {
    std::string name;
    std::string alias_entry;
    Entry(std::string name, std::string alias_entry)
        : name(std::move(name)), alias_entry(std::move(alias_entry)) {}
  };
  SourcePosition pos;
  std::string name;
  std::string constexpr_generates;
  bool is_open;
  std::vector<Entry> entries;

  EnumDescription(SourcePosition pos, std::string name,
                  std::string constexpr_generates, bool is_open,
                  std::vector<Entry> entries = {})
      : pos(std::move(pos)),
        name(std::move(name)),
        constexpr_generates(std::move(constexpr_generates)),
        is_open(is_open),
        entries(std::move(entries)) {}
};

class Ast {
 public:
  Ast() = default;

  std::vector<Declaration*>& declarations() { return declarations_; }
  const std::vector<Declaration*>& declarations() const {
    return declarations_;
  }
  template <class T>
  T* AddNode(std::unique_ptr<T> node) {
    T* result = node.get();
    nodes_.push_back(std::move(node));
    return result;
  }

  void DeclareImportForCurrentFile(SourceId import_id) {
    declared_imports_[CurrentSourcePosition::Get().source].insert(import_id);
  }

  void AddEnumDescription(EnumDescription description) {
    std::string name = description.name;
    DCHECK(!name.empty());
    auto f = [&](const auto& d) { return d.name == name; };
    USE(f);  // Suppress unused in release.
    DCHECK_EQ(
        std::find_if(enum_descriptions_.begin(), enum_descriptions_.end(), f),
        enum_descriptions_.end());
    enum_descriptions_.push_back(std::move(description));
  }

  std::vector<EnumDescription>& EnumDescriptions() {
    return enum_descriptions_;
  }

 private:
  std::vector<Declaration*> declarations_;
  std::vector<std::unique_ptr<AstNode>> nodes_;
  std::map<SourceId, std::set<SourceId>> declared_imports_;
  std::vector<EnumDescription> enum_descriptions_;
};

static const char* const kThisParameterName = "this";

// A Identifier is a string with a SourcePosition attached.
struct Identifier : AstNode {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(Identifier)
  Identifier(SourcePosition pos, std::string identifier)
      : AstNode(kKind, pos), value(std::move(identifier)) {}
  std::string value;
};

inline std::ostream& operator<<(std::ostream& os, Identifier* id) {
  return os << id->value;
}

struct IdentifierPtrValueEq {
  bool operator()(const Identifier* a, const Identifier* b) {
    return a->value < b->value;
  }
};

struct IdentifierExpression : LocationExpression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(IdentifierExpression)
  IdentifierExpression(SourcePosition pos,
                       std::vector<std::string> namespace_qualification,
                       Identifier* name, std::vector<TypeExpression*> args = {})
      : LocationExpression(kKind, pos),
        namespace_qualification(std::move(namespace_qualification)),
        name(name),
        generic_arguments(std::move(args)) {}
  IdentifierExpression(SourcePosition pos, Identifier* name,
                       std::vector<TypeExpression*> args = {})
      : IdentifierExpression(pos, {}, name, std::move(args)) {}
  bool IsThis() const { return name->value == kThisParameterName; }

  void VisitAllSubExpressions(VisitCallback callback) override {
    callback(this);
  }

  std::vector<std::string> namespace_qualification;
  Identifier* name;
  std::vector<TypeExpression*> generic_arguments;
};

struct IntrinsicCallExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(IntrinsicCallExpression)
  IntrinsicCallExpression(SourcePosition pos, Identifier* name,
                          std::vector<TypeExpression*> generic_arguments,
                          std::vector<Expression*> arguments)
      : Expression(kKind, pos),
        name(name),
        generic_arguments(std::move(generic_arguments)),
        arguments(std::move(arguments)) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    for (auto argument : arguments) {
      argument->VisitAllSubExpressions(callback);
    }
    callback(this);
  }

  Identifier* name;
  std::vector<TypeExpression*> generic_arguments;
  std::vector<Expression*> arguments;
};

struct CallMethodExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(CallMethodExpression)
  CallMethodExpression(SourcePosition pos, Expression* target,
                       IdentifierExpression* method,
                       std::vector<Expression*> arguments,
                       std::vector<Identifier*> labels)
      : Expression(kKind, pos),
        target(target),
        method(method),
        arguments(std::move(arguments)),
        labels(std::move(labels)) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    target->VisitAllSubExpressions(callback);
    method->VisitAllSubExpressions(callback);
    for (auto argument : arguments) {
      argument->VisitAllSubExpressions(callback);
    }
    callback(this);
  }

  Expression* target;
  IdentifierExpression* method;
  std::vector<Expression*> arguments;
  std::vector<Identifier*> labels;
};

struct CallExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(CallExpression)
  CallExpression(SourcePosition pos, IdentifierExpression* callee,
                 std::vector<Expression*> arguments,
                 std::vector<Identifier*> labels)
      : Expression(kKind, pos),
        callee(callee),
        arguments(std::move(arguments)),
        labels(std::move(labels)) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    callee->VisitAllSubExpressions(callback);
    for (auto argument : arguments) {
      argument->VisitAllSubExpressions(callback);
    }
    callback(this);
  }

  IdentifierExpression* callee;
  std::vector<Expression*> arguments;
  std::vector<Identifier*> labels;
};

struct NameAndExpression {
  Identifier* name;
  Expression* expression;
};

struct StructExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(StructExpression)
  StructExpression(SourcePosition pos, TypeExpression* type,
                   std::vector<NameAndExpression> initializers)
      : Expression(kKind, pos),
        type(type),
        initializers(std::move(initializers)) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    for (auto& initializer : initializers) {
      initializer.expression->VisitAllSubExpressions(callback);
    }
    callback(this);
  }

  TypeExpression* type;
  std::vector<NameAndExpression> initializers;
};

struct LogicalOrExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(LogicalOrExpression)
  LogicalOrExpression(SourcePosition pos, Expression* left, Expression* right)
      : Expression(kKind, pos), left(left), right(right) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    left->VisitAllSubExpressions(callback);
    right->VisitAllSubExpressions(callback);
    callback(this);
  }

  Expression* left;
  Expression* right;
};

struct LogicalAndExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(LogicalAndExpression)
  LogicalAndExpression(SourcePosition pos, Expression* left, Expression* right)
      : Expression(kKind, pos), left(left), right(right) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    left->VisitAllSubExpressions(callback);
    right->VisitAllSubExpressions(callback);
    callback(this);
  }

  Expression* left;
  Expression* right;
};

struct SpreadExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(SpreadExpression)
  SpreadExpression(SourcePosition pos, Expression* spreadee)
      : Expression(kKind, pos), spreadee(spreadee) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    spreadee->VisitAllSubExpressions(callback);
    callback(this);
  }

  Expression* spreadee;
};

struct ConditionalExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(ConditionalExpression)
  ConditionalExpression(SourcePosition pos, Expression* condition,
                        Expression* if_true, Expression* if_false)
      : Expression(kKind, pos),
        condition(condition),
        if_true(if_true),
        if_false(if_false) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    condition->VisitAllSubExpressions(callback);
    if_true->VisitAllSubExpressions(callback);
    if_false->VisitAllSubExpressions(callback);
    callback(this);
  }

  Expression* condition;
  Expression* if_true;
  Expression* if_false;
};

struct StringLiteralExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(StringLiteralExpression)
  StringLiteralExpression(SourcePosition pos, std::string literal)
      : Expression(kKind, pos), literal(std::move(literal)) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    callback(this);
  }

  std::string literal;
};

struct IntegerLiteralExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(IntegerLiteralExpression)
  IntegerLiteralExpression(SourcePosition pos, IntegerLiteral value)
      : Expression(kKind, pos), value(std::move(value)) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    callback(this);
  }

  IntegerLiteral value;
};

struct FloatingPointLiteralExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(FloatingPointLiteralExpression)
  FloatingPointLiteralExpression(SourcePosition pos, double value)
      : Expression(kKind, pos), value(value) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    callback(this);
  }

  double value;
};

struct ElementAccessExpression : LocationExpression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(ElementAccessExpression)
  ElementAccessExpression(SourcePosition pos, Expression* array,
                          Expression* index)
      : LocationExpression(kKind, pos), array(array), index(index) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    array->VisitAllSubExpressions(callback);
    index->VisitAllSubExpressions(callback);
    callback(this);
  }

  Expression* array;
  Expression* index;
};

struct FieldAccessExpression : LocationExpression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(FieldAccessExpression)
  FieldAccessExpression(SourcePosition pos, Expression* object,
                        Identifier* field)
      : LocationExpression(kKind, pos), object(object), field(field) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    object->VisitAllSubExpressions(callback);
    callback(this);
  }

  Expression* object;
  Identifier* field;
};

struct DereferenceExpression : LocationExpression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(DereferenceExpression)
  DereferenceExpression(SourcePosition pos, Expression* reference)
      : LocationExpression(kKind, pos), reference(reference) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    reference->VisitAllSubExpressions(callback);
    callback(this);
  }

  Expression* reference;
};

struct AssignmentExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(AssignmentExpression)
  AssignmentExpression(SourcePosition pos, Expression* location,
                       Expression* value)
      : AssignmentExpression(pos, location, std::nullopt, value) {}
  AssignmentExpression(SourcePosition pos, Expression* location,
                       std::optional<std::string> op, Expression* value)
      : Expression(kKind, pos),
        location(location),
        op(std::move(op)),
        value(value) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    location->VisitAllSubExpressions(callback);
    value->VisitAllSubExpressions(callback);
    callback(this);
  }

  Expression* location;
  std::optional<std::string> op;
  Expression* value;
};

enum class IncrementDecrementOperator { kIncrement, kDecrement };

struct IncrementDecrementExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(IncrementDecrementExpression)
  IncrementDecrementExpression(SourcePosition pos, Expression* location,
                               IncrementDecrementOperator op, bool postfix)
      : Expression(kKind, pos), location(location), op(op), postfix(postfix) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    location->VisitAllSubExpressions(callback);
    callback(this);
  }

  Expression* location;
  IncrementDecrementOperator op;
  bool postfix;
};

// This expression is only used in the desugaring of typeswitch, and it allows
// to bake in the static information that certain types are impossible at a
// certain position in the control flow.
// The result type is the type of {expression} minus the provided type.
struct AssumeTypeImpossibleExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(AssumeTypeImpossibleExpression)
  AssumeTypeImpossibleExpression(SourcePosition pos,
                                 TypeExpression* excluded_type,
                                 Expression* expression)
      : Expression(kKind, pos),
        excluded_type(excluded_type),
        expression(expression) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    expression->VisitAllSubExpressions(callback);
    callback(this);
  }

  TypeExpression* excluded_type;
  Expression* expression;
};

struct NewExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(NewExpression)
  NewExpression(SourcePosition pos, TypeExpression* type,
                std::vector<NameAndExpression> initializers, bool pretenured,
                bool clear_padding)
      : Expression(kKind, pos),
        type(type),
        initializers(std::move(initializers)),
        pretenured(pretenured),
        clear_padding(clear_padding) {}

  void VisitAllSubExpressions(VisitCallback callback) override {
    for (auto& initializer : initializers) {
      initializer.expression->VisitAllSubExpressions(callback);
    }
    callback(this);
  }

  TypeExpression* type;
  std::vector<NameAndExpression> initializers;
  bool pretenured;
  bool clear_padding;
};

enum class ImplicitKind { kNoImplicit, kJSImplicit, kImplicit };

struct ParameterList {
  std::vector<Identifier*> names;
  std::vector<TypeExpression*> types;
  ImplicitKind implicit_kind = ImplicitKind::kNoImplicit;
  SourcePosition implicit_kind_pos = SourcePosition::Invalid();
  size_t implicit_count = 0;
  bool has_varargs = false;
  std::string arguments_variable = "";

  static ParameterList Empty() { return {}; }
  std::vector<TypeExpression*> GetImplicitTypes() {
    return std::vector<TypeExpression*>(types.begin(),
                                        types.begin() + implicit_count);
  }
  std::vector<TypeExpression*> GetExplicitTypes() {
    return std::vector<TypeExpression*>(types.begin() + implicit_count,
                                        types.end());
  }
};

struct BasicTypeExpression : TypeExpression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(BasicTypeExpression)
  BasicTypeExpression(SourcePosition pos,
                      std::vector<std::string> namespace_qualification,
                      Identifier* name,
                      std::vector<TypeExpression*> generic_arguments)
      : TypeExpression(kKind, pos),
        namespace_qualification(std::move(namespace_qualification)),
        is_constexpr(IsConstexprName(name->value)),
        name(name),
        generic_arguments(std::move(generic_arguments)) {}
  BasicTypeExpression(SourcePosition pos, Identifier* name)
      : BasicTypeExpression(pos, {}, name, {}) {}
  std::vector<std::string> namespace_qualification;
  bool is_constexpr;
  Identifier* name;
  std::vector<TypeExpression*> generic_arguments;
};

struct FunctionTypeExpression : TypeExpression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(FunctionTypeExpression)
  FunctionTypeExpression(SourcePosition pos,
                         std::vector<TypeExpression*> parameters,
                         TypeExpression* return_type)
      : TypeExpression(kKind, pos),
        parameters(std::move(parameters)),
        return_type(return_type) {}
  std::vector<TypeExpression*> parameters;
  TypeExpression* return_type;
};

// A PrecomputedTypeExpression is never created directly by the parser. Later
// stages can use this to insert AST snippets where the type has already been
// resolved.
class Type;
struct PrecomputedTypeExpression : TypeExpression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(PrecomputedTypeExpression)
  PrecomputedTypeExpression(SourcePosition pos, const Type* type)
      : TypeExpression(kKind, pos), type(type) {}
  const Type* type;
};

struct UnionTypeExpression : TypeExpression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(UnionTypeExpression)
  UnionTypeExpression(SourcePosition pos, TypeExpression* a, TypeExpression* b)
      : TypeExpression(kKind, pos), a(a), b(b) {}
  TypeExpression* a;
  TypeExpression* b;
};

struct ExpressionStatement : Statement {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(ExpressionStatement)
  ExpressionStatement(SourcePosition pos, Expression* expression)
      : Statement(kKind, pos), expression(expression) {}
  Expression* expression;
};

struct IfStatement : Statement {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(IfStatement)
  IfStatement(SourcePosition pos, bool is_constexpr, Expression* condition,
              Statement* if_true, std::optional<Statement*> if_false)
      : Statement(kKind, pos),
        condition(condition),
        is_constexpr(is_constexpr),
        if_true(if_true),
        if_false(if_false) {}
  Expression* condition;
  bool is_constexpr;
  Statement* if_true;
  std::optional<Statement*> if_false;
};

struct WhileStatement : Statement {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(WhileStatement)
  WhileStatement(SourcePosition pos, Expression* condition, Statement* body)
      : Statement(kKind, pos), condition(condition), body(body) {}
  Expression* condition;
  Statement* body;
};

struct ReturnStatement : Statement {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(ReturnStatement)
  ReturnStatement(SourcePosition pos, std::optional<Expression*> value)
      : Statement(kKind, pos), value(value) {}
  std::optional<Expression*> value;
};

struct DebugStatement : Statement {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(DebugStatement)
  enum class Kind { kUnreachable, kDebug };
  DebugStatement(SourcePosition pos, Kind kind)
      : Statement(kKind, pos), kind(kind) {}
  Kind kind;
};

struct AssertStatement : Statement {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(AssertStatement)
  enum class AssertKind { kDcheck, kCheck, kSbxCheck, kStaticAssert };
  AssertStatement(SourcePosition pos, AssertKind kind, Expression* expression,
                  std::string source)
      : Statement(kKind, pos),
        kind(kind),
        expression(expression),
        source(std::move(source)) {}
  AssertKind kind;
  Expression* expression;
  std::string source;
};

struct TailCallStatement : Statement {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(TailCallStatement)
  TailCallStatement(SourcePosition pos, CallExpression* call)
      : Statement(kKind, pos), call(call) {}
  CallExpression* call;
};

struct VarDeclarationStatement : Statement {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(VarDeclarationStatement)
  VarDeclarationStatement(SourcePosition pos, bool const_qualified,
                          Identifier* name, std::optional<TypeExpression*> type,
                          std::optional<Expression*> initializer = std::nullopt)
      : Statement(kKind, pos),
        const_qualified(const_qualified),
        name(name),
        type(type),
        initializer(initializer) {}
  bool const_qualified;
  Identifier* name;
  std::optional<TypeExpression*> type;
  std::optional<Expression*> initializer;
};

struct BreakStatement : Statement {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(BreakStatement)
  explicit BreakStatement(SourcePosition pos) : Statement(kKind, pos) {}
};

struct ContinueStatement : Statement {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(ContinueStatement)
  explicit ContinueStatement(SourcePosition pos) : Statement(kKind, pos) {}
};

struct GotoStatement : Statement {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(GotoStatement)
  GotoStatement(SourcePosition pos, Identifier* label,
                const std::vector<Expression*>& arguments)
      : Statement(kKind, pos), label(label), arguments(std::move(arguments)) {}
  Identifier* label;
  std::vector<Expression*> arguments;
};

struct ForLoopStatement : Statement {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(ForLoopStatement)
  ForLoopStatement(SourcePosition pos, std::optional<Statement*> declaration,
                   std::optional<Expression*> test,
                   std::optional<Statement*> action, Statement* body)
      : Statement(kKind, pos),
        var_declaration(),
        test(std::move(test)),
        action(std::move(action)),
        body(std::move(body)) {
    if (declaration)
      var_declaration = VarDeclarationStatement::cast(*declaration);
  }
  std::optional<VarDeclarationStatement*> var_declaration;
  std::optional<Expression*> test;
  std::optional<Statement*> action;
  Statement* body;
};

struct TryHandler : AstNode {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(TryHandler)
  enum class HandlerKind { kCatch, kLabel };
  TryHandler(SourcePosition pos, HandlerKind handler_kind, Identifier* label,
             const ParameterList& parameters, Statement* body)
      : AstNode(kKind, pos),
        handler_kind(handler_kind),
        label(label),
        parameters(parameters),
        body(std::move(body)) {}
  HandlerKind handler_kind;
  Identifier* label;
  ParameterList parameters;
  Statement* body;
};

struct StatementExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(StatementExpression)
  StatementExpression(SourcePosition pos, Statement* statement)
      : Expression(kKind, pos), statement(statement) {}
  Statement* statement;
};

struct TryLabelExpression : Expression {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(TryLabelExpression)
  TryLabelExpression(SourcePosition pos, Expression* try_expression,
                     TryHandler* label_block)
      : Expression(kKind, pos),
        try_expression(try_expression),
        label_block(label_block) {}
  Expression* try_expression;
  TryHandler* label_block;
};

struct BlockStatement : Statement {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(BlockStatement)
  explicit BlockStatement(SourcePosition pos, bool deferred = false,
                          std::vector<Statement*> statements = {})
      : Statement(kKind, pos),
        deferred(deferred),
        statements(std::move(statements)) {}
  bool deferred;
  std::vector<Statement*> statements;
};

struct TypeDeclaration : Declaration {
  DEFINE_AST_NODE_INNER_BOILERPLATE(TypeDeclaration)
  TypeDeclaration(Kind kKind, SourcePosition pos, Identifier* name)
      : Declaration(kKind, pos), name(name) {}
  Identifier* name;
};

struct InstanceTypeConstraints {
  InstanceTypeConstraints() : value(-1), num_flags_bits(-1) {}
  int value;
  int num_flags_bits;
};

struct AbstractTypeDeclaration : TypeDeclaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(AbstractTypeDeclaration)
  AbstractTypeDeclaration(SourcePosition pos, Identifier* name,
                          AbstractTypeFlags flags,
                          std::optional<TypeExpression*> extends,
                          std::optional<std::string> generates)
      : TypeDeclaration(kKind, pos, name),
        flags(flags),
        extends(extends),
        generates(std::move(generates)) {
    CHECK_EQ(IsConstexprName(name->value),
             !!(flags & AbstractTypeFlag::kConstexpr));
  }

  bool IsConstexpr() const { return flags & AbstractTypeFlag::kConstexpr; }
  bool IsTransient() const { return flags & AbstractTypeFlag::kTransient; }

  AbstractTypeFlags flags;
  std::optional<TypeExpression*> extends;
  std::optional<std::string> generates;
};

struct TypeAliasDeclaration : TypeDeclaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(TypeAliasDeclaration)
  TypeAliasDeclaration(SourcePosition pos, Identifier* name,
                       TypeExpression* type)
      : TypeDeclaration(kKind, pos, name), type(type) {}
  TypeExpression* type;
};

struct NameAndTypeExpression {
  Identifier* name;
  TypeExpression* type;
};

struct ImplicitParameters {
  Identifier* kind;
  std::vector<NameAndTypeExpression> parameters;
};

struct StructFieldExpression {
  NameAndTypeExpression name_and_type;
  bool const_qualified;
};

struct BitFieldDeclaration {
  NameAndTypeExpression name_and_type;
  int num_bits;
};

enum class ConditionalAnnotationType {
  kPositive,
  kNegative,
};

struct ConditionalAnnotation {
  std::string condition;
  ConditionalAnnotationType type;
};

struct AnnotationParameter {
  std::string string_value;
  int int_value;
  bool is_int;
};

struct Annotation {
  Identifier* name;
  std::optional<AnnotationParameter> param;
};

struct ClassFieldIndexInfo {
  // The expression that can compute how many items are in the indexed field.
  Expression* expr;

  // Whether the field was declared as optional, meaning it can only hold zero
  // or one values, and thus should not require an index expression to access.
  bool optional;
};

struct ClassFieldExpression {
  NameAndTypeExpression name_and_type;
  std::optional<ClassFieldIndexInfo> index;
  std::vector<ConditionalAnnotation> conditions;
  bool custom_weak_marking;
  bool const_qualified;
  FieldSynchronization read_synchronization;
  FieldSynchronization write_synchronization;
};

struct LabelAndTypes {
  Identifier* name;
  std::vector<TypeExpression*> types;
};

using LabelAndTypesVector = std::vector<LabelAndTypes>;

struct CallableDeclaration : Declaration {
  CallableDeclaration(AstNode::Kind kind, SourcePosition pos,
                      bool transitioning, Identifier* name,
                      ParameterList parameters, TypeExpression* return_type,
                      LabelAndTypesVector labels)
      : Declaration(kind, pos),
        transitioning(transitioning),
        name(name),
        parameters(std::move(parameters)),
        return_type(return_type),
        labels(std::move(labels)) {}
  DEFINE_AST_NODE_INNER_BOILERPLATE(CallableDeclaration)
  bool transitioning;
  Identifier* name;
  ParameterList parameters;
  TypeExpression* return_type;
  LabelAndTypesVector labels;
};

struct MacroDeclaration : CallableDeclaration {
  DEFINE_AST_NODE_INNER_BOILERPLATE(MacroDeclaration)
  MacroDeclaration(AstNode::Kind kind, SourcePosition pos, bool transitioning,
                   Identifier* name, std::optional<std::string> op,
                   ParameterList parameters, TypeExpression* return_type,
                   const LabelAndTypesVector& labels)
      : CallableDeclaration(kind, pos, transitioning, name,
                            std::move(parameters), return_type, labels),
        op(std::move(op)) {
    if (parameters.implicit_kind == ImplicitKind::kJSImplicit) {
      Error("Cannot use \"js-implicit\" with macros, use \"implicit\" instead.")
          .Position(parameters.implicit_kind_pos);
    }
  }
  std::optional<std::string> op;
};

struct ExternalMacroDeclaration : MacroDeclaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(ExternalMacroDeclaration)
  ExternalMacroDeclaration(SourcePosition pos, bool transitioning,
                           std::string external_assembler_name,
                           Identifier* name, std::optional<std::string> op,
                           ParameterList parameters,
                           TypeExpression* return_type,
                           const LabelAndTypesVector& labels)
      : MacroDeclaration(kKind, pos, transitioning, name, std::move(op),
                         std::move(parameters), return_type, labels),
        external_assembler_name(std::move(external_assembler_name)) {}
  std::string external_assembler_name;
};

struct IntrinsicDeclaration : CallableDeclaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(IntrinsicDeclaration)
  IntrinsicDeclaration(SourcePosition pos, Identifier* name,
                       ParameterList parameters, TypeExpression* return_type)
      : CallableDeclaration(kKind, pos, false, name, std::move(parameters),
                            return_type, {}) {
    if (parameters.implicit_kind != ImplicitKind::kNoImplicit) {
      Error("Intinsics cannot have implicit parameters.");
    }
  }
};

struct TorqueMacroDeclaration : MacroDeclaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(TorqueMacroDeclaration)
  TorqueMacroDeclaration(SourcePosition pos, bool transitioning,
                         Identifier* name, std::optional<std::string> op,
                         ParameterList parameters, TypeExpression* return_type,
                         const LabelAndTypesVector& labels, bool export_to_csa,
                         std::optional<Statement*> body)
      : MacroDeclaration(kKind, pos, transitioning, name, std::move(op),
                         std::move(parameters), return_type, labels),
        export_to_csa(export_to_csa),
        body(body) {}
  bool export_to_csa;
  std::optional<Statement*> body;
};

struct BuiltinDeclaration : CallableDeclaration {
  DEFINE_AST_NODE_INNER_BOILERPLATE(BuiltinDeclaration)
  BuiltinDeclaration(AstNode::Kind kind, SourcePosition pos,
                     bool javascript_linkage, bool transitioning,
                     Identifier* name, ParameterList parameters,
                     TypeExpression* return_type)
      : CallableDeclaration(kind, pos, transitioning, name,
                            std::move(parameters), return_type, {}),
        javascript_linkage(javascript_linkage) {
    if (parameters.implicit_kind == ImplicitKind::kJSImplicit &&
        !javascript_linkage) {
      Error(
          "\"js-implicit\" is for implicit parameters passed according to the "
          "JavaScript calling convention. Use \"implicit\" instead.");
    }
    if (parameters.implicit_kind == ImplicitKind::kImplicit &&
        javascript_linkage) {
      Error(
          "The JavaScript calling convention implicitly passes a fixed set of "
          "values. Use \"js-implicit\" to refer to those.")
          .Position(parameters.implicit_kind_pos);
    }
  }
  bool javascript_linkage;
};

struct ExternalBuiltinDeclaration : BuiltinDeclaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(ExternalBuiltinDeclaration)
  ExternalBuiltinDeclaration(SourcePosition pos, bool transitioning,
                             bool javascript_linkage, Identifier* name,
                             ParameterList parameters,
                             TypeExpression* return_type)
      : BuiltinDeclaration(kKind, pos, javascript_linkage, transitioning, name,
                           std::move(parameters), return_type) {}
};

struct TorqueBuiltinDeclaration : BuiltinDeclaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(TorqueBuiltinDeclaration)
  TorqueBuiltinDeclaration(SourcePosition pos, bool transitioning,
                           bool javascript_linkage, Identifier* name,
                           ParameterList parameters,
                           TypeExpression* return_type,
                           bool has_custom_interface_descriptor,
                           std::optional<Statement*> body)
      : BuiltinDeclaration(kKind, pos, javascript_linkage, transitioning, name,
                           std::move(parameters), return_type),
        has_custom_interface_descriptor(has_custom_interface_descriptor),
        body(body) {}
  bool has_custom_interface_descriptor;
  std::optional<Statement*> body;
};

struct ExternalRuntimeDeclaration : CallableDeclaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(ExternalRuntimeDeclaration)
  ExternalRuntimeDeclaration(SourcePosition pos, bool transitioning,
                             Identifier* name, ParameterList parameters,
                             TypeExpression* return_type)
      : CallableDeclaration(kKind, pos, transitioning, name, parameters,
                            return_type, {}) {}
};

struct ConstDeclaration : Declaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(ConstDeclaration)
  ConstDeclaration(SourcePosition pos, Identifier* name, TypeExpression* type,
                   Expression* expression)
      : Declaration(kKind, pos),
        name(name),
        type(type),
        expression(expression) {}
  Identifier* name;
  TypeExpression* type;
  Expression* expression;
};

struct GenericParameter {
  Identifier* name;
  std::optional<TypeExpression*> constraint;
};

using GenericParameters = std::vector<GenericParameter>;

// The AST re-shuffles generics from the concrete syntax:
// Instead of the generic parameters being part of a normal declaration,
// a declaration with generic parameters gets wrapped in a generic declaration,
// which holds the generic parameters. This corresponds to how you write
// templates in C++, with the template parameters coming before the declaration.

struct GenericCallableDeclaration : Declaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(GenericCallableDeclaration)
  GenericCallableDeclaration(SourcePosition pos,
                             GenericParameters generic_parameters,
                             CallableDeclaration* declaration)
      : Declaration(kKind, pos),
        generic_parameters(std::move(generic_parameters)),
        declaration(declaration) {}

  GenericParameters generic_parameters;
  CallableDeclaration* declaration;
};

struct GenericTypeDeclaration : Declaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(GenericTypeDeclaration)
  GenericTypeDeclaration(SourcePosition pos,
                         GenericParameters generic_parameters,
                         TypeDeclaration* declaration)
      : Declaration(kKind, pos),
        generic_parameters(std::move(generic_parameters)),
        declaration(declaration) {}

  GenericParameters generic_parameters;
  TypeDeclaration* declaration;
};

struct SpecializationDeclaration : CallableDeclaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(SpecializationDeclaration)
  SpecializationDeclaration(SourcePosition pos, bool transitioning,
                            Identifier* name,
                            std::vector<TypeExpression*> generic_parameters,
                            ParameterList parameters,
                            TypeExpression* return_type,
                            LabelAndTypesVector labels, Statement* body)
      : CallableDeclaration(kKind, pos, transitioning, name,
                            std::move(parameters), return_type,
                            std::move(labels)),
        generic_parameters(std::move(generic_parameters)),
        body(body) {}
  std::vector<TypeExpression*> generic_parameters;
  Statement* body;
};

struct ExternConstDeclaration : Declaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(ExternConstDeclaration)
  ExternConstDeclaration(SourcePosition pos, Identifier* name,
                         TypeExpression* type, std::string literal)
      : Declaration(kKind, pos),
        name(name),
        type(type),
        literal(std::move(literal)) {}
  Identifier* name;
  TypeExpression* type;
  std::string literal;
};

struct StructDeclaration : TypeDeclaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(StructDeclaration)
  StructDeclaration(SourcePosition pos, StructFlags flags, Identifier* name,
                    std::vector<Declaration*> methods,
                    std::vector<StructFieldExpression> fields)
      : TypeDeclaration(kKind, pos, name),
        flags(flags),
        methods(std::move(methods)),
        fields(std::move(fields)) {}
  StructFlags flags;
  std::vector<Declaration*> methods;
  std::vector<StructFieldExpression> fields;
};

struct BitFieldStructDeclaration : TypeDeclaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(BitFieldStructDeclaration)
  BitFieldStructDeclaration(SourcePosition pos, Identifier* name,
                            TypeExpression* parent,
                            std::vector<BitFieldDeclaration> fields)
      : TypeDeclaration(kKind, pos, name),
        parent(parent),
        fields(std::move(fields)) {}
  TypeExpression* parent;
  std::vector<BitFieldDeclaration> fields;
};

struct ClassBody : AstNode {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(ClassBody)
  ClassBody(SourcePosition pos, std::vector<Declaration*> methods,
            std::vector<ClassFieldExpression> fields)
      : AstNode(kKind, pos),
        methods(std::move(methods)),
        fields(std::move(fields)) {}
  std::vector<Declaration*> methods;
  std::vector<ClassFieldExpression> fields;
};

struct ClassDeclaration : TypeDeclaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(ClassDeclaration)
  ClassDeclaration(SourcePosition pos, Identifier* name, ClassFlags flags,
                   TypeExpression* super, std::optional<std::string> generates,
                   std::vector<Declaration*> methods,
                   std::vector<ClassFieldExpression> fields,
                   InstanceTypeConstraints instance_type_constraints)
      : TypeDeclaration(kKind, pos, name),
        flags(flags),
        super(super),
        generates(std::move(generates)),
        methods(std::move(methods)),
        fields(std::move(fields)),
        instance_type_constraints(std::move(instance_type_constraints)) {}
  ClassFlags flags;
  TypeExpression* super;
  std::optional<std::string> generates;
  std::vector<Declaration*> methods;
  std::vector<ClassFieldExpression> fields;
  InstanceTypeConstraints instance_type_constraints;
};

struct CppIncludeDeclaration : Declaration {
  DEFINE_AST_NODE_LEAF_BOILERPLATE(CppIncludeDeclaration)
  CppIncludeDeclaration(SourcePosition pos, std::string include_path)
      : Declaration(kKind, pos), include_path(std::move(include_path)) {}
  std::string include_path;
};

#define ENUM_ITEM(name)                     \
  case AstNode::Kind::k##name:              \
    return std::is_base_of<T, name>::value; \
    break;

template <class T>
bool AstNodeClassCheck::IsInstanceOf(AstNode* node) {
  switch (node->kind) {
    AST_NODE_KIND_LIST(ENUM_ITEM)
    default:
      UNIMPLEMENTED();
  }
  return true;
}

#undef ENUM_ITEM

inline bool IsDeferred(Statement* stmt) {
  if (auto* block = BlockStatement::DynamicCast(stmt)) {
    return block->deferred;
  }
  return false;
}

DECLARE_CONTEXTUAL_VARIABLE(CurrentAst, Ast);

template <class T, class... Args>
T* MakeNode(Args... args) {
  return CurrentAst::Get().AddNode(
      std::make_unique<T>(CurrentSourcePosition::Get(), std::move(args)...));
}

inline FieldAccessExpression* MakeFieldAccessExpression(Expression* object,
                                                        std::string field) {
  return MakeNode<FieldAccessExpression>(
      object, MakeNode<Identifier>(std::move(field)));
}

inline IdentifierExpression* MakeIdentifierExpression(
    std::vector<std::string> namespace_qualification, std::string name,
    std::vector<TypeExpression*> args = {}) {
  return MakeNode<IdentifierExpression>(std::move(namespace_qualification),
                                        MakeNode<Identifier>(std::move(name)),
                                        std::move(args));
}

inline IdentifierExpression* MakeIdentifierExpression(std::string name) {
  return MakeIdentifierExpression({}, std::move(name));
}

inline CallExpression* MakeCallExpression(
    IdentifierExpression* callee, std::vector<Expression*> arguments,
    std::vector<Identifier*> labels = {}) {
  return MakeNode<CallExpression>(callee, std::move(arguments),
                                  std::move(labels));
}

inline CallExpression* MakeCallExpression(
    std::string callee, std::vector<Expression*> arguments,
    std::vector<Identifier*> labels = {}) {
  return MakeCallExpression(MakeIdentifierExpression(std::move(callee)),
                            std::move(arguments), std::move(labels));
}

inline VarDeclarationStatement* MakeConstDeclarationStatement(
    std::string name, Expression* initializer) {
  return MakeNode<VarDeclarationStatement>(
      /*const_qualified=*/true, MakeNode<Identifier>(std::move(name)),
      std::optional<TypeExpression*>{}, initializer);
}

inline BasicTypeExpression* MakeBasicTypeExpression(
    std::vector<std::string> namespace_qualification, Identifier* name,
    std::vector<TypeExpression*> generic_arguments = {}) {
  return MakeNode<BasicTypeExpression>(std::move(namespace_qualification), name,
                                       std::move(generic_arguments));
}

inline StructExpression* MakeStructExpression(
    TypeExpression* type, std::vector<NameAndExpression> initializers) {
  return MakeNode<StructExpression>(type, std::move(initializers));
}

}  // namespace v8::internal::torque

#endif  // V8_TORQUE_AST_H_
                                                                                                 node-23.7.0/deps/v8/src/torque/cc-generator.cc                                                      0000664 0000000 0000000 00000044515 14746647661 0021044 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/torque/cc-generator.h"

#include <optional>

#include "src/common/globals.h"
#include "src/torque/global-context.h"
#include "src/torque/type-oracle.h"
#include "src/torque/types.h"
#include "src/torque/utils.h"

namespace v8::internal::torque {

std::optional<Stack<std::string>> CCGenerator::EmitGraph(
    Stack<std::string> parameters) {
  for (BottomOffset i = {0}; i < parameters.AboveTop(); ++i) {
    SetDefinitionVariable(DefinitionLocation::Parameter(i.offset),
                          parameters.Peek(i));
  }

  // Redirect the output of non-declarations into a buffer and only output
  // declarations right away.
  std::stringstream out_buffer;
  std::ostream* old_out = out_;
  out_ = &out_buffer;

  EmitInstruction(GotoInstruction{cfg_.start()}, &parameters);

  for (Block* block : cfg_.blocks()) {
    if (cfg_.end() && *cfg_.end() == block) continue;
    if (block->IsDead()) continue;
    EmitBlock(block);
  }

  std::optional<Stack<std::string>> result;
  if (cfg_.end()) {
    result = EmitBlock(*cfg_.end());
  }

  // All declarations have been printed now, so we can append the buffered
  // output and redirect back to the original output stream.
  out_ = old_out;
  out() << out_buffer.str();

  return result;
}

Stack<std::string> CCGenerator::EmitBlock(const Block* block) {
  out() << "\n";
  out() << "  " << BlockName(block) << ":\n";

  Stack<std::string> stack;

  for (BottomOffset i = {0}; i < block->InputTypes().AboveTop(); ++i) {
    const auto& def = block->InputDefinitions().Peek(i);
    stack.Push(DefinitionToVariable(def));
    if (def.IsPhiFromBlock(block)) {
      decls() << "  "
              << (is_cc_debug_ ? block->InputTypes().Peek(i)->GetDebugType()
                               : block->InputTypes().Peek(i)->GetRuntimeType())
              << " " << stack.Top() << "{}; USE(" << stack.Top() << ");\n";
    }
  }

  for (const Instruction& instruction : block->instructions()) {
    TorqueCodeGenerator::EmitInstruction(instruction, &stack);
  }
  return stack;
}

void CCGenerator::EmitSourcePosition(SourcePosition pos, bool always_emit) {
  const std::string& file = SourceFileMap::AbsolutePath(pos.source);
  if (always_emit || !previous_position_.CompareStartIgnoreColumn(pos)) {
    // Lines in Torque SourcePositions are zero-based, while the
    // CodeStubAssembler and downwind systems are one-based.
    out() << "  // " << file << ":" << (pos.start.line + 1) << "\n";
    previous_position_ = pos;
  }
}

void CCGenerator::EmitInstruction(
    const PushUninitializedInstruction& instruction,
    Stack<std::string>* stack) {
  ReportError("Not supported in C++ output: PushUninitialized");
}

void CCGenerator::EmitInstruction(
    const PushBuiltinPointerInstruction& instruction,
    Stack<std::string>* stack) {
  ReportError("Not supported in C++ output: PushBuiltinPointer");
}

void CCGenerator::EmitInstruction(
    const NamespaceConstantInstruction& instruction,
    Stack<std::string>* stack) {
  ReportError("Not supported in C++ output: NamespaceConstantInstruction");
}

std::vector<std::string> CCGenerator::ProcessArgumentsCommon(
    const TypeVector& parameter_types,
    std::vector<std::string> constexpr_arguments, Stack<std::string>* stack) {
  std::vector<std::string> args;
  for (auto it = parameter_types.rbegin(); it != parameter_types.rend(); ++it) {
    const Type* type = *it;
    if (type->IsConstexpr()) {
      args.push_back(std::move(constexpr_arguments.back()));
      constexpr_arguments.pop_back();
    } else {
      std::stringstream s;
      size_t slot_count = LoweredSlotCount(type);
      VisitResult arg = VisitResult(type, stack->TopRange(slot_count));
      EmitCCValue(arg, *stack, s);
      args.push_back(s.str());
      stack->PopMany(slot_count);
    }
  }
  std::reverse(args.begin(), args.end());
  return args;
}

void CCGenerator::EmitInstruction(const CallIntrinsicInstruction& instruction,
                                  Stack<std::string>* stack) {
  TypeVector parameter_types =
      instruction.intrinsic->signature().parameter_types.types;
  std::vector<std::string> args = ProcessArgumentsCommon(
      parameter_types, instruction.constexpr_arguments, stack);

  Stack<std::string> pre_call_stack = *stack;
  const Type* return_type = instruction.intrinsic->signature().return_type;
  std::vector<std::string> results;

  const auto lowered = LowerType(return_type);
  for (std::size_t i = 0; i < lowered.size(); ++i) {
    results.push_back(DefinitionToVariable(instruction.GetValueDefinition(i)));
    stack->Push(results.back());
    decls() << "  "
            << (is_cc_debug_ ? lowered[i]->GetDebugType()
                             : lowered[i]->GetRuntimeType())
            << " " << stack->Top() << "{}; USE(" << stack->Top() << ");\n";
  }

  out() << "  ";
  if (return_type->StructSupertype()) {
    out() << "std::tie(";
    PrintCommaSeparatedList(out(), results);
    out() << ") = ";
  } else {
    if (results.size() == 1) {
      out() << results[0] << " = ";
    }
  }

  if (instruction.intrinsic->ExternalName() == "%RawDownCast") {
    if (parameter_types.size() != 1) {
      ReportError("%RawDownCast must take a single parameter");
    }
    const Type* original_type = parameter_types[0];
    bool is_subtype =
        return_type->IsSubtypeOf(original_type) ||
        (original_type == TypeOracle::GetUninitializedHeapObjectType() &&
         return_type->IsSubtypeOf(TypeOracle::GetHeapObjectType()));
    if (!is_subtype) {
      ReportError("%RawDownCast error: ", *return_type, " is not a subtype of ",
                  *original_type);
    }
    if (!original_type->StructSupertype() &&
        return_type->GetRuntimeType() != original_type->GetRuntimeType()) {
      out() << "static_cast<" << return_type->GetRuntimeType() << ">";
    }
  } else if (instruction.intrinsic->ExternalName() == "%GetClassMapConstant") {
    ReportError("C++ generator doesn't yet support %GetClassMapConstant");
  } else if (instruction.intrinsic->ExternalName() == "%FromConstexpr") {
    if (parameter_types.size() != 1 || !parameter_types[0]->IsConstexpr()) {
      ReportError(
          "%FromConstexpr must take a single parameter with constexpr "
          "type");
    }
    if (return_type->IsConstexpr()) {
      ReportError("%FromConstexpr must return a non-constexpr type");
    }
    if (return_type->IsSubtypeOf(TypeOracle::GetSmiType())) {
      if (is_cc_debug_) {
        out() << "Internals::IntToSmi";
      } else {
        out() << "Smi::FromInt";
      }
    }
    // Wrap the raw constexpr value in a static_cast to ensure that
    // enums get properly casted to their backing integral value.
    out() << "(CastToUnderlyingTypeIfEnum";
  } else {
    ReportError("no built in intrinsic with name " +
                instruction.intrinsic->ExternalName());
  }

  out() << "(";
  PrintCommaSeparatedList(out(), args);
  if (instruction.intrinsic->ExternalName() == "%FromConstexpr") {
    out() << ")";
  }
  out() << ");\n";
}

void CCGenerator::EmitInstruction(const CallCsaMacroInstruction& instruction,
                                  Stack<std::string>* stack) {
  TypeVector parameter_types =
      instruction.macro->signature().parameter_types.types;
  std::vector<std::string> args = ProcessArgumentsCommon(
      parameter_types, instruction.constexpr_arguments, stack);

  Stack<std::string> pre_call_stack = *stack;
  const Type* return_type = instruction.macro->signature().return_type;
  std::vector<std::string> results;

  const auto lowered = LowerType(return_type);
  for (std::size_t i = 0; i < lowered.size(); ++i) {
    results.push_back(DefinitionToVariable(instruction.GetValueDefinition(i)));
    stack->Push(results.back());
    decls() << "  "
            << (is_cc_debug_ ? lowered[i]->GetDebugType()
                             : lowered[i]->GetRuntimeType())
            << " " << stack->Top() << "{}; USE(" << stack->Top() << ");\n";
  }

  // We should have inlined any calls requiring complex control flow.
  CHECK(!instruction.catch_block);
  out() << (is_cc_debug_ ? "  ASSIGN_OR_RETURN(" : "  ");
  if (return_type->StructSupertype().has_value()) {
    out() << "std::tie(";
    PrintCommaSeparatedList(out(), results);
    out() << (is_cc_debug_ ? "), " : ") = ");
  } else {
    if (results.size() == 1) {
      out() << results[0] << (is_cc_debug_ ? ", " : " = ");
    } else {
      DCHECK_EQ(0, results.size());
    }
  }

  if (is_cc_debug_) {
    out() << instruction.macro->CCDebugName() << "(accessor";
    if (!args.empty()) out() << ", ";
  } else {
    out() << instruction.macro->CCName() << "(";
  }
  PrintCommaSeparatedList(out(), args);
  if (is_cc_debug_) {
    out() << "));\n";
  } else {
    out() << ");\n";
  }
}

void CCGenerator::EmitInstruction(
    const CallCsaMacroAndBranchInstruction& instruction,
    Stack<std::string>* stack) {
  ReportError("Not supported in C++ output: CallCsaMacroAndBranch");
}

void CCGenerator::EmitInstruction(const MakeLazyNodeInstruction& instruction,
                                  Stack<std::string>* stack) {
  ReportError("Not supported in C++ output: MakeLazyNode");
}

void CCGenerator::EmitInstruction(const CallBuiltinInstruction& instruction,
                                  Stack<std::string>* stack) {
  ReportError("Not supported in C++ output: CallBuiltin");
}

void CCGenerator::EmitInstruction(
    const CallBuiltinPointerInstruction& instruction,
    Stack<std::string>* stack) {
  ReportError("Not supported in C++ output: CallBuiltinPointer");
}

void CCGenerator::EmitInstruction(const CallRuntimeInstruction& instruction,
                                  Stack<std::string>* stack) {
  ReportError("Not supported in C++ output: CallRuntime");
}

void CCGenerator::EmitInstruction(const BranchInstruction& instruction,
                                  Stack<std::string>* stack) {
  out() << "  if (" << stack->Pop() << ") {\n";
  EmitGoto(instruction.if_true, stack, "    ");
  out() << "  } else {\n";
  EmitGoto(instruction.if_false, stack, "    ");
  out() << "  }\n";
}

void CCGenerator::EmitInstruction(const ConstexprBranchInstruction& instruction,
                                  Stack<std::string>* stack) {
  out() << "  if ((" << instruction.condition << ")) {\n";
  EmitGoto(instruction.if_true, stack, "    ");
  out() << "  } else {\n";
  EmitGoto(instruction.if_false, stack, "    ");
  out() << "  }\n";
}

void CCGenerator::EmitGoto(const Block* destination, Stack<std::string>* stack,
                           std::string indentation) {
  const auto& destination_definitions = destination->InputDefinitions();
  DCHECK_EQ(stack->Size(), destination_definitions.Size());
  for (BottomOffset i = {0}; i < stack->AboveTop(); ++i) {
    DefinitionLocation def = destination_definitions.Peek(i);
    if (def.IsPhiFromBlock(destination)) {
      out() << indentation << DefinitionToVariable(def) << " = "
            << stack->Peek(i) << ";\n";
    }
  }
  out() << indentation << "goto " << BlockName(destination) << ";\n";
}

void CCGenerator::EmitInstruction(const GotoInstruction& instruction,
                                  Stack<std::string>* stack) {
  EmitGoto(instruction.destination, stack, "  ");
}

void CCGenerator::EmitInstruction(const GotoExternalInstruction& instruction,
                                  Stack<std::string>* stack) {
  ReportError("Not supported in C++ output: GotoExternal");
}

void CCGenerator::EmitInstruction(const ReturnInstruction& instruction,
                                  Stack<std::string>* stack) {
  ReportError("Not supported in C++ output: Return");
}

void CCGenerator::EmitInstruction(const PrintErrorInstruction& instruction,
                                  Stack<std::string>* stack) {
  out() << "  std::cerr << " << StringLiteralQuote(instruction.message)
        << ";\n";
}

void CCGenerator::EmitInstruction(const AbortInstruction& instruction,
                                  Stack<std::string>* stack) {
  switch (instruction.kind) {
    case AbortInstruction::Kind::kUnreachable:
      DCHECK(instruction.message.empty());
      out() << "  UNREACHABLE();\n";
      break;
    case AbortInstruction::Kind::kDebugBreak:
      DCHECK(instruction.message.empty());
      out() << "  base::OS::DebugBreak();\n";
      break;
    case AbortInstruction::Kind::kAssertionFailure: {
      std::string file = StringLiteralQuote(
          SourceFileMap::PathFromV8Root(instruction.pos.source));
      out() << "  CHECK(false, \"Failed Torque assertion: '\""
            << StringLiteralQuote(instruction.message) << "\"' at \"" << file
            << "\":\""
            << StringLiteralQuote(
                   std::to_string(instruction.pos.start.line + 1))
            << ");\n";
      break;
    }
  }
}

void CCGenerator::EmitInstruction(const UnsafeCastInstruction& instruction,
                                  Stack<std::string>* stack) {
  const std::string str = "static_cast<" +
                          instruction.destination_type->GetRuntimeType() +
                          ">(" + stack->Top() + ")";
  stack->Poke(stack->AboveTop() - 1, str);
  SetDefinitionVariable(instruction.GetValueDefinition(), str);
}

void CCGenerator::EmitInstruction(const LoadReferenceInstruction& instruction,
                                  Stack<std::string>* stack) {
  std::string result_name =
      DefinitionToVariable(instruction.GetValueDefinition());

  std::string offset = stack->Pop();
  std::string object = stack->Pop();
  stack->Push(result_name);

  if (!is_cc_debug_) {
    std::string result_type = instruction.type->GetRuntimeType();
    decls() << "  " << result_type << " " << result_name << "{}; USE("
            << result_name << ");\n";
    out() << "  " << result_name << " = ";
    if (instruction.type->IsSubtypeOf(TypeOracle::GetTaggedType())) {
      // Currently, all of the tagged loads we emit are for smi values, so there
      // is no point in providing an PtrComprCageBase. If at some point we start
      // emitting loads for tagged fields which might be HeapObjects, then we
      // should plumb an PtrComprCageBase through the generated functions that
      // need it.
      if (!instruction.type->IsSubtypeOf(TypeOracle::GetSmiType())) {
        Error(
            "Not supported in C++ output: LoadReference on non-smi tagged "
            "value");
      }

      // References and slices can cause some values to have the Torque type
      // HeapObject|TaggedZeroPattern, which is output as "Object". TaggedField
      // requires HeapObject, so we need a cast.
      out() << "TaggedField<" << result_type
            << ">::load(UncheckedCast<HeapObject>(" << object
            << "), static_cast<int>(" << offset << "));\n";
    } else {
      out() << "(" << object << ")->ReadField<" << result_type << ">(" << offset
            << ");\n";
    }
  } else {
    std::string result_type = instruction.type->GetDebugType();
    decls() << "  " << result_type << " " << result_name << "{}; USE("
            << result_name << ");\n";
    if (instruction.type->IsSubtypeOf(TypeOracle::GetTaggedType())) {
      out() << "  READ_TAGGED_FIELD_OR_FAIL(" << result_name << ", accessor, "
            << object << ", static_cast<int>(" << offset << "));\n";
    } else {
      out() << "  READ_FIELD_OR_FAIL(" << result_type << ", " << result_name
            << ", accessor, " << object << ", " << offset << ");\n";
    }
  }
}

void CCGenerator::EmitInstruction(const StoreReferenceInstruction& instruction,
                                  Stack<std::string>* stack) {
  ReportError("Not supported in C++ output: StoreReference");
}

namespace {
std::string GetBitFieldSpecialization(const Type* container,
                                      const BitField& field) {
  std::stringstream stream;
  stream << "base::BitField<"
         << field.name_and_type.type->GetConstexprGeneratedTypeName() << ", "
         << field.offset << ", " << field.num_bits << ", "
         << container->GetConstexprGeneratedTypeName() << ">";
  return stream.str();
}
}  // namespace

void CCGenerator::EmitInstruction(const LoadBitFieldInstruction& instruction,
                                  Stack<std::string>* stack) {
  std::string result_name =
      DefinitionToVariable(instruction.GetValueDefinition());

  std::string bit_field_struct = stack->Pop();
  stack->Push(result_name);

  const Type* struct_type = instruction.bit_field_struct_type;

  decls() << "  " << instruction.bit_field.name_and_type.type->GetRuntimeType()
          << " " << result_name << "{}; USE(" << result_name << ");\n";

  std::optional<const Type*> smi_tagged_type =
      Type::MatchUnaryGeneric(struct_type, TypeOracle::GetSmiTaggedGeneric());
  if (smi_tagged_type) {
    // Get the untagged value and its type.
    if (is_cc_debug_) {
      bit_field_struct = "Internals::SmiValue(" + bit_field_struct + ")";
    } else {
      bit_field_struct = bit_field_struct + ".value()";
    }
    struct_type = *smi_tagged_type;
  }

  out() << "  " << result_name << " = CastToUnderlyingTypeIfEnum("
        << GetBitFieldSpecialization(struct_type, instruction.bit_field)
        << "::decode(" << bit_field_struct << "));\n";
}

void CCGenerator::EmitInstruction(const StoreBitFieldInstruction& instruction,
                                  Stack<std::string>* stack) {
  ReportError("Not supported in C++ output: StoreBitField");
}

namespace {

void CollectAllFields(const VisitResult& result,
                      const Stack<std::string>& values,
                      std::vector<std::string>& all_fields) {
  if (!result.IsOnStack()) {
    all_fields.push_back(result.constexpr_value());
  } else if (auto struct_type = result.type()->StructSupertype()) {
    for (const Field& field : (*struct_type)->fields()) {
      CollectAllFields(ProjectStructField(result, field.name_and_type.name),
                       values, all_fields);
    }
  } else {
    DCHECK_EQ(1, result.stack_range().Size());
    all_fields.push_back(values.Peek(result.stack_range().begin()));
  }
}

}  // namespace

// static
void CCGenerator::EmitCCValue(VisitResult result,
                              const Stack<std::string>& values,
                              std::ostream& out) {
  std::vector<std::string> all_fields;
  CollectAllFields(result, values, all_fields);
  if (all_fields.size() == 1) {
    out << all_fields[0];
  } else {
    out << "std::make_tuple(";
    PrintCommaSeparatedList(out, all_fields);
    out << ")";
  }
}

}  // namespace v8::internal::torque
                                                                                                                                                                                   node-23.7.0/deps/v8/src/torque/cc-generator.h                                                       0000664 0000000 0000000 00000003104 14746647661 0020673 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_TORQUE_CC_GENERATOR_H_
#define V8_TORQUE_CC_GENERATOR_H_

#include <optional>

#include "src/torque/torque-code-generator.h"

namespace v8::internal::torque {

class CCGenerator : public TorqueCodeGenerator {
 public:
  CCGenerator(const ControlFlowGraph& cfg, std::ostream& out,
              bool is_cc_debug = false)
      : TorqueCodeGenerator(cfg, out), is_cc_debug_(is_cc_debug) {}
  std::optional<Stack<std::string>> EmitGraph(Stack<std::string> parameters);

  static void EmitCCValue(VisitResult result, const Stack<std::string>& values,
                          std::ostream& out);

 private:
  bool is_cc_debug_;

  void EmitSourcePosition(SourcePosition pos,
                          bool always_emit = false) override;

  void EmitGoto(const Block* destination, Stack<std::string>* stack,
                std::string indentation);

  std::vector<std::string> ProcessArgumentsCommon(
      const TypeVector& parameter_types,
      std::vector<std::string> constexpr_arguments, Stack<std::string>* stack);

  Stack<std::string> EmitBlock(const Block* block);
#define EMIT_INSTRUCTION_DECLARATION(T)                                 \
  void EmitInstruction(const T& instruction, Stack<std::string>* stack) \
      override;
  TORQUE_BACKEND_DEPENDENT_INSTRUCTION_LIST(EMIT_INSTRUCTION_DECLARATION)
#undef EMIT_INSTRUCTION_DECLARATION
};

}  // namespace v8::internal::torque

#endif  // V8_TORQUE_CC_GENERATOR_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/src/torque/cfg.cc                                                               0000664 0000000 0000000 00000016453 14746647661 0017232 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/torque/cfg.h"

#include <optional>

#include "src/torque/type-oracle.h"

namespace v8::internal::torque {

void Block::SetInputTypes(const Stack<const Type*>& input_types) {
  if (!input_types_) {
    input_types_ = input_types;
    return;
  } else if (*input_types_ == input_types) {
    return;
  }

  DCHECK_EQ(input_types.Size(), input_types_->Size());
  Stack<const Type*> merged_types;
  bool widened = false;
  auto c2_iterator = input_types.begin();
  for (const Type* c1 : *input_types_) {
    const Type* merged_type = TypeOracle::GetUnionType(c1, *c2_iterator++);
    if (!merged_type->IsSubtypeOf(c1)) {
      widened = true;
    }
    merged_types.Push(merged_type);
  }
  if (merged_types.Size() == input_types_->Size()) {
    if (widened) {
      input_types_ = merged_types;
      Retype();
    }
    return;
  }

  std::stringstream error;
  error << "incompatible types at branch:\n";
  for (intptr_t i = std::max(input_types_->Size(), input_types.Size()) - 1;
       i >= 0; --i) {
    std::optional<const Type*> left;
    std::optional<const Type*> right;
    if (static_cast<size_t>(i) < input_types.Size()) {
      left = input_types.Peek(BottomOffset{static_cast<size_t>(i)});
    }
    if (static_cast<size_t>(i) < input_types_->Size()) {
      right = input_types_->Peek(BottomOffset{static_cast<size_t>(i)});
    }
    if (left && right && *left == *right) {
      error << **left << "\n";
    } else {
      if (left) {
        error << **left;
      } else {
        error << "/*missing*/";
      }
      error << "   =>   ";
      if (right) {
        error << **right;
      } else {
        error << "/*missing*/";
      }
      error << "\n";
    }
  }
  ReportError(error.str());
}

void CfgAssembler::Bind(Block* block) {
  DCHECK(current_block_->IsComplete());
  DCHECK(block->instructions().empty());
  DCHECK(block->HasInputTypes());
  current_block_ = block;
  current_stack_ = block->InputTypes();
  cfg_.PlaceBlock(block);
}

void CfgAssembler::Goto(Block* block) {
  if (block->HasInputTypes()) {
    DropTo(block->InputTypes().AboveTop());
  }
  Emit(GotoInstruction{block});
}

StackRange CfgAssembler::Goto(Block* block, size_t preserved_slots) {
  DCHECK(block->HasInputTypes());
  DCHECK_GE(CurrentStack().Size(), block->InputTypes().Size());
  Emit(DeleteRangeInstruction{
      StackRange{block->InputTypes().AboveTop() - preserved_slots,
                 CurrentStack().AboveTop() - preserved_slots}});
  StackRange preserved_slot_range = TopRange(preserved_slots);
  Emit(GotoInstruction{block});
  return preserved_slot_range;
}

void CfgAssembler::Branch(Block* if_true, Block* if_false) {
  Emit(BranchInstruction{if_true, if_false});
}

// Delete the specified range of slots, moving upper slots to fill the gap.
void CfgAssembler::DeleteRange(StackRange range) {
  DCHECK_LE(range.end(), current_stack_.AboveTop());
  if (range.Size() == 0) return;
  Emit(DeleteRangeInstruction{range});
}

void CfgAssembler::DropTo(BottomOffset new_level) {
  DeleteRange(StackRange{new_level, CurrentStack().AboveTop()});
}

StackRange CfgAssembler::Peek(StackRange range,
                              std::optional<const Type*> type) {
  std::vector<const Type*> lowered_types;
  if (type) {
    lowered_types = LowerType(*type);
    DCHECK_EQ(lowered_types.size(), range.Size());
  }
  for (size_t i = 0; i < range.Size(); ++i) {
    Emit(PeekInstruction{
        range.begin() + i,
        type ? lowered_types[i] : std::optional<const Type*>{}});
  }
  return TopRange(range.Size());
}

void CfgAssembler::Poke(StackRange destination, StackRange origin,
                        std::optional<const Type*> type) {
  DCHECK_EQ(destination.Size(), origin.Size());
  DCHECK_LE(destination.end(), origin.begin());
  DCHECK_EQ(origin.end(), CurrentStack().AboveTop());
  std::vector<const Type*> lowered_types;
  if (type) {
    lowered_types = LowerType(*type);
    DCHECK_EQ(lowered_types.size(), origin.Size());
  }
  for (intptr_t i = origin.Size() - 1; i >= 0; --i) {
    Emit(PokeInstruction{
        destination.begin() + i,
        type ? lowered_types[i] : std::optional<const Type*>{}});
  }
}

void CfgAssembler::Print(std::string s) {
  Emit(PrintErrorInstruction{std::move(s)});
}

void CfgAssembler::AssertionFailure(std::string message) {
  Emit(AbortInstruction{AbortInstruction::Kind::kAssertionFailure,
                        std::move(message)});
}

void CfgAssembler::Unreachable() {
  Emit(AbortInstruction{AbortInstruction::Kind::kUnreachable});
}

void CfgAssembler::DebugBreak() {
  Emit(AbortInstruction{AbortInstruction::Kind::kDebugBreak});
}

std::vector<std::size_t> CountBlockPredecessors(const ControlFlowGraph& cfg) {
  std::vector<std::size_t> count(cfg.NumberOfBlockIds(), 0);
  count[cfg.start()->id()] = 1;

  for (const Block* block : cfg.blocks()) {
    std::vector<Block*> successors;
    for (const auto& instruction : block->instructions()) {
      instruction->AppendSuccessorBlocks(&successors);
    }
    for (Block* successor : successors) {
      DCHECK_LT(successor->id(), count.size());
      ++count[successor->id()];
    }
  }

  return count;
}

void CfgAssembler::OptimizeCfg() {
  auto predecessor_count = CountBlockPredecessors(cfg_);

  for (Block* block : cfg_.blocks()) {
    if (cfg_.end() && *cfg_.end() == block) continue;
    if (predecessor_count[block->id()] == 0) continue;

    while (!block->instructions().empty()) {
      const auto& instruction = block->instructions().back();
      if (!instruction.Is<GotoInstruction>()) break;
      Block* destination = instruction.Cast<GotoInstruction>().destination;
      if (destination == block) break;
      if (cfg_.end() && *cfg_.end() == destination) break;
      DCHECK_GT(predecessor_count[destination->id()], 0);
      if (predecessor_count[destination->id()] != 1) break;

      DCHECK_GT(destination->instructions().size(), 0);
      block->instructions().pop_back();
      block->instructions().insert(block->instructions().end(),
                                   destination->instructions().begin(),
                                   destination->instructions().end());

      --predecessor_count[destination->id()];
      DCHECK_EQ(predecessor_count[destination->id()], 0);
    }
  }

  cfg_.UnplaceBlockIf(
      [&](Block* b) { return predecessor_count[b->id()] == 0; });
}

void CfgAssembler::ComputeInputDefinitions() {
  Worklist<Block*> worklist;

  // Setup start block.
  Stack<DefinitionLocation> parameter_defs;
  for (std::size_t i = 0; i < cfg_.ParameterCount(); ++i) {
    parameter_defs.Push(DefinitionLocation::Parameter(i));
  }
  cfg_.start()->MergeInputDefinitions(parameter_defs, &worklist);

  // Run fixpoint algorithm.
  while (!worklist.IsEmpty()) {
    Block* block = worklist.Dequeue();
    Stack<DefinitionLocation> definitions = block->InputDefinitions();

    // Propagate through block's instructions.
    for (const auto& instruction : block->instructions()) {
      instruction.RecomputeDefinitionLocations(&definitions, &worklist);
    }
  }

  for (Block* block : cfg_.blocks()) {
    DCHECK_IMPLIES(!block->IsDead(), block->InputDefinitions().Size() ==
                                         block->InputTypes().Size());
    USE(block);
  }
}

}  // namespace v8::internal::torque
                                                                                                                                                                                                                     node-23.7.0/deps/v8/src/torque/cfg.h                                                                0000664 0000000 0000000 00000017557 14746647661 0017102 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_TORQUE_CFG_H_
#define V8_TORQUE_CFG_H_

#include <list>
#include <memory>
#include <optional>
#include <unordered_map>
#include <vector>

#include "src/torque/ast.h"
#include "src/torque/instructions.h"
#include "src/torque/source-positions.h"
#include "src/torque/types.h"

namespace v8::internal::torque {

class ControlFlowGraph;

class Block {
 public:
  explicit Block(ControlFlowGraph* cfg, size_t id,
                 std::optional<Stack<const Type*>> input_types,
                 bool is_deferred)
      : cfg_(cfg),
        input_types_(std::move(input_types)),
        id_(id),
        is_deferred_(is_deferred) {}
  void Add(Instruction instruction) {
    DCHECK(!IsComplete());
    instructions_.push_back(std::move(instruction));
  }

  bool HasInputTypes() const { return input_types_ != std::nullopt; }
  const Stack<const Type*>& InputTypes() const { return *input_types_; }
  void SetInputTypes(const Stack<const Type*>& input_types);
  void Retype() {
    Stack<const Type*> current_stack = InputTypes();
    for (const Instruction& instruction : instructions()) {
      instruction.TypeInstruction(&current_stack, cfg_);
    }
  }

  std::vector<Instruction>& instructions() { return instructions_; }
  const std::vector<Instruction>& instructions() const { return instructions_; }
  bool IsComplete() const {
    return !instructions_.empty() && instructions_.back()->IsBlockTerminator();
  }
  size_t id() const { return id_; }
  bool IsDeferred() const { return is_deferred_; }

  void MergeInputDefinitions(const Stack<DefinitionLocation>& input_definitions,
                             Worklist<Block*>* worklist) {
    if (!input_definitions_) {
      input_definitions_ = input_definitions;
      if (worklist) worklist->Enqueue(this);
      return;
    }

    DCHECK_EQ(input_definitions_->Size(), input_definitions.Size());
    bool changed = false;
    for (BottomOffset i = {0}; i < input_definitions.AboveTop(); ++i) {
      auto& current = input_definitions_->Peek(i);
      auto& input = input_definitions.Peek(i);
      if (current == input) continue;
      if (current == DefinitionLocation::Phi(this, i.offset)) continue;
      input_definitions_->Poke(i, DefinitionLocation::Phi(this, i.offset));
      changed = true;
    }

    if (changed && worklist) worklist->Enqueue(this);
  }
  bool HasInputDefinitions() const {
    return input_definitions_ != std::nullopt;
  }
  const Stack<DefinitionLocation>& InputDefinitions() const {
    DCHECK(HasInputDefinitions());
    return *input_definitions_;
  }

  bool IsDead() const { return !HasInputDefinitions(); }

 private:
  ControlFlowGraph* cfg_;
  std::vector<Instruction> instructions_;
  std::optional<Stack<const Type*>> input_types_;
  std::optional<Stack<DefinitionLocation>> input_definitions_;
  const size_t id_;
  bool is_deferred_;
};

class ControlFlowGraph {
 public:
  explicit ControlFlowGraph(Stack<const Type*> input_types) {
    start_ = NewBlock(std::move(input_types), false);
    PlaceBlock(start_);
  }

  Block* NewBlock(std::optional<Stack<const Type*>> input_types,
                  bool is_deferred) {
    blocks_.emplace_back(this, next_block_id_++, std::move(input_types),
                         is_deferred);
    return &blocks_.back();
  }
  void PlaceBlock(Block* block) { placed_blocks_.push_back(block); }
  template <typename UnaryPredicate>
  void UnplaceBlockIf(UnaryPredicate&& predicate) {
    auto newEnd = std::remove_if(placed_blocks_.begin(), placed_blocks_.end(),
                                 std::forward<UnaryPredicate>(predicate));
    placed_blocks_.erase(newEnd, placed_blocks_.end());
  }
  Block* start() const { return start_; }
  std::optional<Block*> end() const { return end_; }
  void set_end(Block* end) { end_ = end; }
  void SetReturnType(TypeVector t) {
    if (!return_type_) {
      return_type_ = t;
      return;
    }
    if (t != *return_type_) {
      std::stringstream message;
      message << "expected return type ";
      PrintCommaSeparatedList(message, *return_type_);
      message << " instead of ";
      PrintCommaSeparatedList(message, t);
      ReportError(message.str());
    }
  }
  const std::vector<Block*>& blocks() const { return placed_blocks_; }
  size_t NumberOfBlockIds() const { return next_block_id_; }
  std::size_t ParameterCount() const {
    return start_ ? start_->InputTypes().Size() : 0;
  }

 private:
  std::list<Block> blocks_;
  Block* start_;
  std::vector<Block*> placed_blocks_;
  std::optional<Block*> end_;
  std::optional<TypeVector> return_type_;
  size_t next_block_id_ = 0;
};

class CfgAssembler {
 public:
  explicit CfgAssembler(Stack<const Type*> input_types)
      : current_stack_(std::move(input_types)), cfg_(current_stack_) {}

  const ControlFlowGraph& Result() {
    if (!CurrentBlockIsComplete()) {
      cfg_.set_end(current_block_);
    }
    OptimizeCfg();
    DCHECK(CfgIsComplete());
    ComputeInputDefinitions();
    return cfg_;
  }

  Block* NewBlock(std::optional<Stack<const Type*>> input_types = std::nullopt,
                  bool is_deferred = false) {
    return cfg_.NewBlock(std::move(input_types), is_deferred);
  }

  bool CurrentBlockIsComplete() const { return current_block_->IsComplete(); }
  bool CfgIsComplete() const {
    return std::all_of(
        cfg_.blocks().begin(), cfg_.blocks().end(), [this](Block* block) {
          return (cfg_.end() && *cfg_.end() == block) || block->IsComplete();
        });
  }

  void Emit(Instruction instruction) {
    instruction.TypeInstruction(&current_stack_, &cfg_);
    current_block_->Add(std::move(instruction));
  }

  const Stack<const Type*>& CurrentStack() const { return current_stack_; }

  StackRange TopRange(size_t slot_count) const {
    return CurrentStack().TopRange(slot_count);
  }

  void Bind(Block* block);
  void Goto(Block* block);
  // Goto block while keeping {preserved_slots} many slots on the top and
  // deleting additional the slots below these to match the input type of the
  // target block.
  // Returns the StackRange of the preserved slots in the target block.
  StackRange Goto(Block* block, size_t preserved_slots);
  // The condition must be of type bool and on the top of stack. It is removed
  // from the stack before branching.
  void Branch(Block* if_true, Block* if_false);
  // Delete the specified range of slots, moving upper slots to fill the gap.
  void DeleteRange(StackRange range);
  void DropTo(BottomOffset new_level);
  StackRange Peek(StackRange range, std::optional<const Type*> type);
  void Poke(StackRange destination, StackRange origin,
            std::optional<const Type*> type);
  void Print(std::string s);
  void AssertionFailure(std::string message);
  void Unreachable();
  void DebugBreak();

  void PrintCurrentStack(std::ostream& s) { s << "stack: " << current_stack_; }
  void OptimizeCfg();
  void ComputeInputDefinitions();

 private:
  friend class CfgAssemblerScopedTemporaryBlock;
  Stack<const Type*> current_stack_;
  ControlFlowGraph cfg_;
  Block* current_block_ = cfg_.start();
};

class V8_NODISCARD CfgAssemblerScopedTemporaryBlock {
 public:
  CfgAssemblerScopedTemporaryBlock(CfgAssembler* assembler, Block* block)
      : assembler_(assembler), saved_block_(block) {
    saved_stack_ = block->InputTypes();
    DCHECK(!assembler->CurrentBlockIsComplete());
    std::swap(saved_block_, assembler->current_block_);
    std::swap(saved_stack_, assembler->current_stack_);
    assembler->cfg_.PlaceBlock(block);
  }

  ~CfgAssemblerScopedTemporaryBlock() {
    DCHECK(assembler_->CurrentBlockIsComplete());
    std::swap(saved_block_, assembler_->current_block_);
    std::swap(saved_stack_, assembler_->current_stack_);
  }

 private:
  CfgAssembler* assembler_;
  Stack<const Type*> saved_stack_;
  Block* saved_block_;
};

}  // namespace v8::internal::torque

#endif  // V8_TORQUE_CFG_H_
                                                                                                                                                 node-23.7.0/deps/v8/src/torque/class-debug-reader-generator.cc                                      0000664 0000000 0000000 00000060531 14746647661 0024104 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <optional>

#include "src/flags/flags.h"
#include "src/torque/implementation-visitor.h"
#include "src/torque/type-oracle.h"

namespace v8::internal::torque {

constexpr char kTqObjectOverrideDecls[] =
    R"(  std::vector<std::unique_ptr<ObjectProperty>> GetProperties(
      d::MemoryAccessor accessor) const override;
  const char* GetName() const override;
  void Visit(TqObjectVisitor* visitor) const override;
  bool IsSuperclassOf(const TqObject* other) const override;
)";

namespace {
enum TypeStorage {
  kAsStoredInHeap,
  kUncompressed,
};

// An iterator for use in ValueTypeFieldsRange.
class ValueTypeFieldIterator {
 public:
  ValueTypeFieldIterator(const Type* type, size_t index)
      : type_(type), index_(index) {}
  struct Result {
    NameAndType name_and_type;
    SourcePosition pos;
    size_t offset_bytes;
    int num_bits;
    int shift_bits;
  };
  const Result operator*() const {
    if (auto struct_type = type_->StructSupertype()) {
      const auto& field = (*struct_type)->fields()[index_];
      return {field.name_and_type, field.pos, *field.offset, 0, 0};
    }
    const Type* type = type_;
    int bitfield_start_offset = 0;
    if (const auto type_wrapped_in_smi =
            Type::MatchUnaryGeneric(type_, TypeOracle::GetSmiTaggedGeneric())) {
      type = *type_wrapped_in_smi;
      bitfield_start_offset = TargetArchitecture::SmiTagAndShiftSize();
    }
    if (const BitFieldStructType* bit_field_struct_type =
            BitFieldStructType::DynamicCast(type)) {
      const auto& field = bit_field_struct_type->fields()[index_];
      return {field.name_and_type, field.pos, 0, field.num_bits,
              field.offset + bitfield_start_offset};
    }
    UNREACHABLE();
  }
  ValueTypeFieldIterator& operator++() {
    ++index_;
    return *this;
  }
  bool operator==(const ValueTypeFieldIterator& other) const {
    return type_ == other.type_ && index_ == other.index_;
  }
  bool operator!=(const ValueTypeFieldIterator& other) const {
    return !(*this == other);
  }

 private:
  const Type* type_;
  size_t index_;
};

// A way to iterate over the fields of structs or bitfield structs. For other
// types, the iterators returned from begin() and end() are immediately equal.
class ValueTypeFieldsRange {
 public:
  explicit ValueTypeFieldsRange(const Type* type) : type_(type) {}
  ValueTypeFieldIterator begin() { return {type_, 0}; }
  ValueTypeFieldIterator end() {
    size_t index = 0;
    std::optional<const StructType*> struct_type = type_->StructSupertype();
    if (struct_type && *struct_type != TypeOracle::GetFloat64OrHoleType()) {
      index = (*struct_type)->fields().size();
    }
    const Type* type = type_;
    if (const auto type_wrapped_in_smi =
            Type::MatchUnaryGeneric(type_, TypeOracle::GetSmiTaggedGeneric())) {
      type = *type_wrapped_in_smi;
    }
    if (const BitFieldStructType* bit_field_struct_type =
            BitFieldStructType::DynamicCast(type)) {
      index = bit_field_struct_type->fields().size();
    }
    return {type_, index};
  }

 private:
  const Type* type_;
};

// A convenient way to keep track of several different ways that we might need
// to represent a field's type in the generated C++.
class DebugFieldType {
 public:
  explicit DebugFieldType(const Field& field)
      : name_and_type_(field.name_and_type), pos_(field.pos) {}
  DebugFieldType(const NameAndType& name_and_type, const SourcePosition& pos)
      : name_and_type_(name_and_type), pos_(pos) {}

  bool IsTagged() const {
    return name_and_type_.type->IsSubtypeOf(TypeOracle::GetTaggedType());
  }

  // Returns the type that should be used for this field's value within code
  // that is compiled as part of the debug helper library. In particular, this
  // simplifies any tagged type to a plain uintptr_t because the debug helper
  // compiles without most of the V8 runtime code.
  std::string GetValueType(TypeStorage storage) const {
    if (IsTagged()) {
      return storage == kAsStoredInHeap ? "i::Tagged_t" : "uintptr_t";
    }

    // We can't emit a useful error at this point if the constexpr type name is
    // wrong, but we can include a comment that might be helpful.
    return GetOriginalType(storage) +
           " /*Failing? Ensure constexpr type name is correct, and the "
           "necessary #include is in any .tq file*/";
  }

  // Returns the type that should be used to represent a field's type to
  // debugging tools that have full V8 symbols. The types returned from this
  // method are resolveable in the v8::internal namespace and may refer to
  // object types that are not included in the compilation of the debug helper
  // library.
  std::string GetOriginalType(TypeStorage storage) const {
    if (name_and_type_.type->StructSupertype()) {
      // There's no meaningful type we could use here, because the V8 symbols
      // don't have any definition of a C++ struct matching this struct type.
      return "";
    }
    if (IsTagged()) {
      std::optional<const ClassType*> field_class_type =
          name_and_type_.type->ClassSupertype();
      std::string result =
          "v8::internal::" +
          (field_class_type.has_value()
               ? (*field_class_type)->GetGeneratedTNodeTypeName()
               : "Object");
      if (storage == kAsStoredInHeap) {
        result = "v8::internal::TaggedMember<" + result + ">";
      }
      return result;
    }
    return name_and_type_.type->GetConstexprGeneratedTypeName();
  }

  // Returns a C++ expression that evaluates to a string (type `const char*`)
  // containing the name of the field's type. The types returned from this
  // method are resolveable in the v8::internal namespace and may refer to
  // object types that are not included in the compilation of the debug helper
  // library.
  std::string GetTypeString(TypeStorage storage) const {
    if (IsTagged() || name_and_type_.type->IsStructType()) {
      // Wrap up the original type in a string literal.
      return "\"" + GetOriginalType(storage) + "\"";
    }

    // We require constexpr type names to be resolvable in the v8::internal
    // namespace, according to the contract in debug-helper.h. In order to
    // verify at compile time that constexpr type names are resolvable, we use
    // the type name as a dummy template parameter to a function that just
    // returns its parameter.
    return "CheckTypeName<" + GetValueType(storage) + ">(\"" +
           GetOriginalType(storage) + "\")";
  }

  // Returns the field's size in bytes.
  size_t GetSize() const {
    auto opt_size = SizeOf(name_and_type_.type);
    if (!opt_size.has_value()) {
      Error("Size required for type ", name_and_type_.type->ToString())
          .Position(pos_);
      return 0;
    }
    return std::get<0>(*opt_size);
  }

  // Returns the name of the function for getting this field's address.
  std::string GetAddressGetter() {
    return "Get" + CamelifyString(name_and_type_.name) + "Address";
  }

 private:
  NameAndType name_and_type_;
  SourcePosition pos_;
};

// Emits a function to get the address of a field within a class, based on the
// member variable {address_}, which is a tagged pointer. Example
// implementation:
//
// uintptr_t TqFixedArray::GetObjectsAddress() const {
//   return address_ - i::kHeapObjectTag + 16;
// }
void GenerateFieldAddressAccessor(const Field& field,
                                  const std::string& class_name,
                                  std::ostream& h_contents,
                                  std::ostream& cc_contents) {
  DebugFieldType debug_field_type(field);

  const std::string address_getter = debug_field_type.GetAddressGetter();

  h_contents << "  uintptr_t " << address_getter << "() const;\n";
  cc_contents << "\nuintptr_t Tq" << class_name << "::" << address_getter
              << "() const {\n";
  cc_contents << "  return address_ - i::kHeapObjectTag + " << *field.offset
              << ";\n";
  cc_contents << "}\n";
}

// Emits a function to get the value of a field, or the value from an indexed
// position within an array field, based on the member variable {address_},
// which is a tagged pointer, and the parameter {accessor}, a function pointer
// that allows for fetching memory from the debuggee. The returned result
// includes both a "validity", indicating whether the memory could be fetched,
// and the fetched value. If the field contains tagged data, then these
// functions call EnsureDecompressed to expand compressed data. Example:
//
// Value<uintptr_t> TqMap::GetPrototypeValue(d::MemoryAccessor accessor) const {
//   i::Tagged_t value{};
//   d::MemoryAccessResult validity = accessor(
//       GetPrototypeAddress(),
//       reinterpret_cast<uint8_t*>(&value),
//       sizeof(value));
//   return {validity, EnsureDecompressed(value, address_)};
// }
//
// For array fields, an offset parameter is included. Example:
//
// Value<uintptr_t> TqFixedArray::GetObjectsValue(d::MemoryAccessor accessor,
//                                                size_t offset) const {
//   i::Tagged_t value{};
//   d::MemoryAccessResult validity = accessor(
//       GetObjectsAddress() + offset * sizeof(value),
//       reinterpret_cast<uint8_t*>(&value),
//       sizeof(value));
//   return {validity, EnsureDecompressed(value, address_)};
// }
void GenerateFieldValueAccessor(const Field& field,
                                const std::string& class_name,
                                std::ostream& h_contents,
                                std::ostream& cc_contents) {
  // Currently not implemented for struct fields.
  if (field.name_and_type.type->StructSupertype()) return;

  DebugFieldType debug_field_type(field);

  const std::string address_getter = debug_field_type.GetAddressGetter();
  const std::string field_getter =
      "Get" + CamelifyString(field.name_and_type.name) + "Value";

  std::string index_param;
  std::string index_offset;
  if (field.index) {
    index_param = ", size_t offset";
    index_offset = " + offset * sizeof(value)";
  }

  std::string field_value_type = debug_field_type.GetValueType(kUncompressed);
  h_contents << "  Value<" << field_value_type << "> " << field_getter
             << "(d::MemoryAccessor accessor " << index_param << ") const;\n";
  cc_contents << "\nValue<" << field_value_type << "> Tq" << class_name
              << "::" << field_getter << "(d::MemoryAccessor accessor"
              << index_param << ") const {\n";
  cc_contents << "  " << debug_field_type.GetValueType(kAsStoredInHeap)
              << " value{};\n";
  cc_contents << "  d::MemoryAccessResult validity = accessor("
              << address_getter << "()" << index_offset
              << ", reinterpret_cast<uint8_t*>(&value), sizeof(value));\n";
#ifdef V8_MAP_PACKING
  if (field_getter == "GetMapValue") {
    cc_contents << "  value = i::MapWord::Unpack(value);\n";
  }
#endif
  cc_contents << "  return {validity, "
              << (debug_field_type.IsTagged()
                      ? "EnsureDecompressed(value, address_)"
                      : "value")
              << "};\n";
  cc_contents << "}\n";
}

// Emits a portion of the member function GetProperties that is responsible for
// adding data about the current field to a result vector called "result".
// Example output:
//
// std::vector<std::unique_ptr<StructProperty>> prototype_struct_field_list;
// result.push_back(std::make_unique<ObjectProperty>(
//     "prototype",                                     // Field name
//     "v8::internal::HeapObject",                      // Field type
//     "v8::internal::HeapObject",                      // Decompressed type
//     GetPrototypeAddress(),                           // Field address
//     1,                                               // Number of values
//     8,                                               // Size of value
//     std::move(prototype_struct_field_list),          // Struct fields
//     d::PropertyKind::kSingle));                      // Field kind
//
// In builds with pointer compression enabled, the field type for tagged values
// is "v8::internal::TaggedValue" (a four-byte class) and the decompressed type
// is a normal Object subclass that describes the expanded eight-byte type.
//
// If the field is an array, then its length is fetched from the debuggee. This
// could fail if the debuggee has incomplete memory, so the "validity" from that
// fetch is used to determine the result PropertyKind, which will say whether
// the array's length is known.
//
// If the field's type is a struct, then a local variable is created and filled
// with descriptions of each of the struct's fields. The type and decompressed
// type in the ObjectProperty are set to the empty string, to indicate to the
// caller that the struct fields vector should be used instead.
//
// The following example is an array of structs, so it uses both of the optional
// components described above:
//
// std::vector<std::unique_ptr<StructProperty>> descriptors_struct_field_list;
// descriptors_struct_field_list.push_back(std::make_unique<StructProperty>(
//     "key",                                // Struct field name
//     "v8::internal::PrimitiveHeapObject",  // Struct field type
//     "v8::internal::PrimitiveHeapObject",  // Struct field decompressed type
//     0,                                    // Byte offset within struct data
//     0,                                    // Bitfield size (0=not a bitfield)
//     0));                                  // Bitfield shift
// // The line above is repeated for other struct fields. Omitted here.
// // Fetch the slice.
// auto indexed_field_slice_descriptors =
//     TqDebugFieldSliceDescriptorArrayDescriptors(accessor, address_);
// if (indexed_field_slice_descriptors.validity == d::MemoryAccessResult::kOk) {
//   result.push_back(std::make_unique<ObjectProperty>(
//     "descriptors",                                 // Field name
//     "",                                            // Field type
//     "",                                            // Decompressed type
//     address_ - i::kHeapObjectTag +
//     std::get<1>(indexed_field_slice_descriptors.value), // Field address
//     std::get<2>(indexed_field_slice_descriptors.value), // Number of values
//     12,                                            // Size of value
//     std::move(descriptors_struct_field_list),      // Struct fields
//     GetArrayKind(indexed_field_slice_descriptors.validity)));  // Field kind
// }
void GenerateGetPropsChunkForField(const Field& field,
                                   std::ostream& get_props_impl,
                                   std::string class_name) {
  DebugFieldType debug_field_type(field);

  // If the current field is a struct or bitfield struct, create a vector
  // describing its fields. Otherwise this vector will be empty.
  std::string struct_field_list =
      field.name_and_type.name + "_struct_field_list";
  get_props_impl << "  std::vector<std::unique_ptr<StructProperty>> "
                 << struct_field_list << ";\n";
  for (const auto& struct_field :
       ValueTypeFieldsRange(field.name_and_type.type)) {
    DebugFieldType struct_field_type(struct_field.name_and_type,
                                     struct_field.pos);
    get_props_impl << "  " << struct_field_list
                   << ".push_back(std::make_unique<StructProperty>(\""
                   << struct_field.name_and_type.name << "\", "
                   << struct_field_type.GetTypeString(kAsStoredInHeap) << ", "
                   << struct_field.offset_bytes << ", " << struct_field.num_bits
                   << ", " << struct_field.shift_bits << "));\n";
  }
  struct_field_list = "std::move(" + struct_field_list + ")";

  // The number of values and property kind for non-indexed properties:
  std::string count_value = "1";
  std::string property_kind = "d::PropertyKind::kSingle";

  // If the field is indexed, emit a fetch of the array length, and change
  // count_value and property_kind to be the correct values for an array.
  if (field.index) {
    std::string indexed_field_slice =
        "indexed_field_slice_" + field.name_and_type.name;
    get_props_impl << "  auto " << indexed_field_slice << " = "
                   << "TqDebugFieldSlice" << class_name
                   << CamelifyString(field.name_and_type.name)
                   << "(accessor, address_);\n";
    std::string validity = indexed_field_slice + ".validity";
    std::string value = indexed_field_slice + ".value";
    property_kind = "GetArrayKind(" + validity + ")";

    get_props_impl << "  if (" << validity
                   << " == d::MemoryAccessResult::kOk) {\n"
                   << "    result.push_back(std::make_unique<ObjectProperty>(\""
                   << field.name_and_type.name << "\", "
                   << debug_field_type.GetTypeString(kAsStoredInHeap) << ", "
                   << "address_ - i::kHeapObjectTag + std::get<1>(" << value
                   << "), "
                   << "std::get<2>(" << value << ")"
                   << ", " << debug_field_type.GetSize() << ", "
                   << struct_field_list << ", " << property_kind << "));\n"
                   << "  }\n";
    return;
  }
  get_props_impl << "  result.push_back(std::make_unique<ObjectProperty>(\""
                 << field.name_and_type.name << "\", "
                 << debug_field_type.GetTypeString(kAsStoredInHeap) << ", "
                 << debug_field_type.GetAddressGetter() << "(), " << count_value
                 << ", " << debug_field_type.GetSize() << ", "
                 << struct_field_list << ", " << property_kind << "));\n";
}

// For any Torque-defined class Foo, this function generates a class TqFoo which
// allows for convenient inspection of objects of type Foo in a crash dump or
// time travel session (where we can't just run the object printer). The
// generated class looks something like this:
//
// class TqFoo : public TqParentOfFoo {
//  public:
//   // {address} is an uncompressed tagged pointer.
//   inline TqFoo(uintptr_t address) : TqParentOfFoo(address) {}
//
//   // Creates and returns a list of this object's properties.
//   std::vector<std::unique_ptr<ObjectProperty>> GetProperties(
//       d::MemoryAccessor accessor) const override;
//
//   // Returns the name of this class, "v8::internal::Foo".
//   const char* GetName() const override;
//
//   // Visitor pattern; implementation just calls visitor->VisitFoo(this).
//   void Visit(TqObjectVisitor* visitor) const override;
//
//   // Returns whether Foo is a superclass of the other object's type.
//   bool IsSuperclassOf(const TqObject* other) const override;
//
//   // Field accessors omitted here (see other comments above).
// };
//
// Four output streams are written:
//
// h_contents:  A header file which gets the class definition above.
// cc_contents: A cc file which gets implementations of that class's members.
// visitor:     A stream that is accumulating the definition of the class
//              TqObjectVisitor. Each class Foo gets its own virtual method
//              VisitFoo in TqObjectVisitor.
void GenerateClassDebugReader(const ClassType& type, std::ostream& h_contents,
                              std::ostream& cc_contents, std::ostream& visitor,
                              std::unordered_set<const ClassType*>* done) {
  // Make sure each class only gets generated once.
  if (!done->insert(&type).second) return;
  const ClassType* super_type = type.GetSuperClass();

  // We must emit the classes in dependency order. If the super class hasn't
  // been emitted yet, go handle it first.
  if (super_type != nullptr) {
    GenerateClassDebugReader(*super_type, h_contents, cc_contents, visitor,
                             done);
  }

  // Classes with undefined layout don't grant any particular value here and may
  // not correspond with actual C++ classes, so skip them.
  if (type.HasUndefinedLayout()) return;

  const std::string name = type.name();
  const std::string super_name =
      super_type == nullptr ? "Object" : super_type->name();
  h_contents << "\nclass Tq" << name << " : public Tq" << super_name << " {\n";
  h_contents << " public:\n";
  h_contents << "  inline Tq" << name << "(uintptr_t address) : Tq"
             << super_name << "(address) {}\n";
  h_contents << kTqObjectOverrideDecls;

  cc_contents << "\nconst char* Tq" << name << "::GetName() const {\n";
  cc_contents << "  return \"v8::internal::" << name << "\";\n";
  cc_contents << "}\n";

  cc_contents << "\nvoid Tq" << name
              << "::Visit(TqObjectVisitor* visitor) const {\n";
  cc_contents << "  visitor->Visit" << name << "(this);\n";
  cc_contents << "}\n";

  cc_contents << "\nbool Tq" << name
              << "::IsSuperclassOf(const TqObject* other) const {\n";
  cc_contents
      << "  return GetName() != other->GetName() && dynamic_cast<const Tq"
      << name << "*>(other) != nullptr;\n";
  cc_contents << "}\n";

  // By default, the visitor method for this class just calls the visitor method
  // for this class's parent. This allows custom visitors to only override a few
  // classes they care about without needing to know about the entire hierarchy.
  visitor << "  virtual void Visit" << name << "(const Tq" << name
          << "* object) {\n";
  visitor << "    Visit" << super_name << "(object);\n";
  visitor << "  }\n";

  std::stringstream get_props_impl;

  for (const Field& field : type.fields()) {
    if (field.name_and_type.type == TypeOracle::GetVoidType()) continue;
    if (field.offset.has_value()) {
      GenerateFieldAddressAccessor(field, name, h_contents, cc_contents);
      GenerateFieldValueAccessor(field, name, h_contents, cc_contents);
    }
    GenerateGetPropsChunkForField(field, get_props_impl, name);
  }

  h_contents << "};\n";

  cc_contents << "\nstd::vector<std::unique_ptr<ObjectProperty>> Tq" << name
              << "::GetProperties(d::MemoryAccessor accessor) const {\n";
  // Start by getting the fields from the parent class.
  cc_contents << "  std::vector<std::unique_ptr<ObjectProperty>> result = Tq"
              << super_name << "::GetProperties(accessor);\n";
  // Then add the fields from this class.
  cc_contents << get_props_impl.str();
  cc_contents << "  return result;\n";
  cc_contents << "}\n";
}
}  // namespace

void ImplementationVisitor::GenerateClassDebugReaders(
    const std::string& output_directory) {
  const std::string file_name = "class-debug-readers";
  std::stringstream h_contents;
  std::stringstream cc_contents;
  h_contents << "// Provides the ability to read object properties in\n";
  h_contents << "// postmortem or remote scenarios, where the debuggee's\n";
  h_contents << "// memory is not part of the current process's address\n";
  h_contents << "// space and must be read using a callback function.\n\n";
  {
    IncludeGuardScope include_guard(h_contents, file_name + ".h");

    h_contents << "#include <cstdint>\n";
    h_contents << "#include <vector>\n\n";

    for (const std::string& include_path : GlobalContext::CppIncludes()) {
      h_contents << "#include " << StringLiteralQuote(include_path) << "\n";
    }

    h_contents
        << "\n#include \"tools/debug_helper/debug-helper-internal.h\"\n\n";

    const char* kWingdiWorkaround =
        "// Unset a wingdi.h macro that causes conflicts.\n"
        "#ifdef GetBValue\n"
        "#undef GetBValue\n"
        "#endif\n\n";

    h_contents << kWingdiWorkaround;

    cc_contents << "#include \"torque-generated/" << file_name << ".h\"\n\n";
    cc_contents << "#include \"src/objects/all-objects-inl.h\"\n";
    cc_contents << "#include \"torque-generated/debug-macros.h\"\n\n";
    cc_contents << kWingdiWorkaround;
    cc_contents << "namespace i = v8::internal;\n\n";

    NamespaceScope h_namespaces(h_contents,
                                {"v8", "internal", "debug_helper_internal"});
    NamespaceScope cc_namespaces(cc_contents,
                                 {"v8", "internal", "debug_helper_internal"});

    std::stringstream visitor;
    visitor << "\nclass TqObjectVisitor {\n";
    visitor << " public:\n";
    visitor << "  virtual void VisitObject(const TqObject* object) {}\n";

    std::unordered_set<const ClassType*> done;
    for (const ClassType* type : TypeOracle::GetClasses()) {
      GenerateClassDebugReader(*type, h_contents, cc_contents, visitor, &done);
    }

    visitor << "};\n";
    h_contents << visitor.str();
  }
  WriteFile(output_directory + "/" + file_name + ".h", h_contents.str());
  WriteFile(output_directory + "/" + file_name + ".cc", cc_contents.str());
}

}  // namespace v8::internal::torque
                                                                                                                                                                       node-23.7.0/deps/v8/src/torque/constants.h                                                          0000664 0000000 0000000 00000021371 14746647661 0020344 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_TORQUE_CONSTANTS_H_
#define V8_TORQUE_CONSTANTS_H_

#include <cstring>
#include <string>

#include "src/base/flags.h"

namespace v8 {
namespace internal {
namespace torque {

static const char* const CONSTEXPR_TYPE_PREFIX = "constexpr ";
static const char* const NEVER_TYPE_STRING = "never";
static const char* const CONSTEXPR_BOOL_TYPE_STRING = "constexpr bool";
static const char* const CONSTEXPR_STRING_TYPE_STRING = "constexpr string";
static const char* const CONSTEXPR_INTPTR_TYPE_STRING = "constexpr intptr";
static const char* const CONSTEXPR_INSTANCE_TYPE_TYPE_STRING =
    "constexpr InstanceType";
static const char* const BOOL_TYPE_STRING = "bool";
static const char* const VOID_TYPE_STRING = "void";
static const char* const ARGUMENTS_TYPE_STRING = "Arguments";
static const char* const CONTEXT_TYPE_STRING = "Context";
static const char* const NO_CONTEXT_TYPE_STRING = "NoContext";
static const char* const NATIVE_CONTEXT_TYPE_STRING = "NativeContext";
static const char* const JS_FUNCTION_TYPE_STRING = "JSFunction";
static const char* const MAP_TYPE_STRING = "Map";
static const char* const OBJECT_TYPE_STRING = "Object";
static const char* const HEAP_OBJECT_TYPE_STRING = "HeapObject";
static const char* const TAGGED_ZERO_PATTERN_TYPE_STRING = "TaggedZeroPattern";
static const char* const JSANY_TYPE_STRING = "JSAny";
static const char* const JSOBJECT_TYPE_STRING = "JSObject";
static const char* const SMI_TYPE_STRING = "Smi";
static const char* const TAGGED_TYPE_STRING = "Tagged";
static const char* const STRONG_TAGGED_TYPE_STRING = "StrongTagged";
static const char* const UNINITIALIZED_TYPE_STRING = "Uninitialized";
static const char* const UNINITIALIZED_HEAP_OBJECT_TYPE_STRING =
    "UninitializedHeapObject";
static const char* const RAWPTR_TYPE_STRING = "RawPtr";
static const char* const EXTERNALPTR_TYPE_STRING = "ExternalPointer";
static const char* const CPPHEAPPTR_TYPE_STRING = "CppHeapPointer";
static const char* const TRUSTEDPTR_TYPE_STRING = "TrustedPointer";
static const char* const PROTECTEDPTR_TYPE_STRING = "ProtectedPointer";
static const char* const CONST_STRING_TYPE_STRING = "constexpr string";
static const char* const STRING_TYPE_STRING = "String";
static const char* const NUMBER_TYPE_STRING = "Number";
static const char* const BUILTIN_POINTER_TYPE_STRING = "BuiltinPtr";
static const char* const INTPTR_TYPE_STRING = "intptr";
static const char* const UINTPTR_TYPE_STRING = "uintptr";
static const char* const INT64_TYPE_STRING = "int64";
static const char* const UINT64_TYPE_STRING = "uint64";
static const char* const INT31_TYPE_STRING = "int31";
static const char* const INT32_TYPE_STRING = "int32";
static const char* const UINT31_TYPE_STRING = "uint31";
static const char* const UINT32_TYPE_STRING = "uint32";
static const char* const INT16_TYPE_STRING = "int16";
static const char* const UINT16_TYPE_STRING = "uint16";
static const char* const INT8_TYPE_STRING = "int8";
static const char* const UINT8_TYPE_STRING = "uint8";
static const char* const BINT_TYPE_STRING = "bint";
static const char* const CHAR8_TYPE_STRING = "char8";
static const char* const CHAR16_TYPE_STRING = "char16";
static const char* const FLOAT16_TYPE_STRING = "float16";
static const char* const FLOAT32_TYPE_STRING = "float32";
static const char* const FLOAT64_TYPE_STRING = "float64";
static const char* const FLOAT64_OR_HOLE_TYPE_STRING = "float64_or_hole";
static const char* const CONST_INT31_TYPE_STRING = "constexpr int31";
static const char* const CONST_INT32_TYPE_STRING = "constexpr int32";
static const char* const CONST_FLOAT64_TYPE_STRING = "constexpr float64";
static const char* const INTEGER_LITERAL_TYPE_STRING =
    "constexpr IntegerLiteral";
static const char* const TORQUE_INTERNAL_NAMESPACE_STRING = "torque_internal";
static const char* const MUTABLE_REFERENCE_TYPE_STRING = "MutableReference";
static const char* const CONST_REFERENCE_TYPE_STRING = "ConstReference";
static const char* const MUTABLE_SLICE_TYPE_STRING = "MutableSlice";
static const char* const CONST_SLICE_TYPE_STRING = "ConstSlice";
static const char* const WEAK_TYPE_STRING = "Weak";
static const char* const SMI_TAGGED_TYPE_STRING = "SmiTagged";
static const char* const LAZY_TYPE_STRING = "Lazy";
static const char* const UNINITIALIZED_ITERATOR_TYPE_STRING =
    "UninitializedIterator";
static const char* const GENERIC_TYPE_INSTANTIATION_NAMESPACE_STRING =
    "_generic_type_instantiation_namespace";
static const char* const FIXED_ARRAY_BASE_TYPE_STRING = "FixedArrayBase";
static const char* const WEAK_HEAP_OBJECT = "WeakHeapObject";
static const char* const STATIC_ASSERT_MACRO_STRING = "StaticAssert";

static const char* const ANNOTATION_ABSTRACT = "@abstract";
static const char* const ANNOTATION_HAS_SAME_INSTANCE_TYPE_AS_PARENT =
    "@hasSameInstanceTypeAsParent";
static const char* const ANNOTATION_DO_NOT_GENERATE_CPP_CLASS =
    "@doNotGenerateCppClass";
static const char* const ANNOTATION_CUSTOM_MAP = "@customMap";
static const char* const ANNOTATION_CUSTOM_CPP_CLASS = "@customCppClass";
static const char* const ANNOTATION_HIGHEST_INSTANCE_TYPE_WITHIN_PARENT =
    "@highestInstanceTypeWithinParentClassRange";
static const char* const ANNOTATION_LOWEST_INSTANCE_TYPE_WITHIN_PARENT =
    "@lowestInstanceTypeWithinParentClassRange";
static const char* const ANNOTATION_RESERVE_BITS_IN_INSTANCE_TYPE =
    "@reserveBitsInInstanceType";
static const char* const ANNOTATION_INSTANCE_TYPE_VALUE =
    "@apiExposedInstanceTypeValue";
static const char* const ANNOTATION_IF = "@if";
static const char* const ANNOTATION_IFNOT = "@ifnot";
static const char* const ANNOTATION_GENERATE_BODY_DESCRIPTOR =
    "@generateBodyDescriptor";
static const char* const ANNOTATION_GENERATE_UNIQUE_MAP = "@generateUniqueMap";
static const char* const ANNOTATION_GENERATE_FACTORY_FUNCTION =
    "@generateFactoryFunction";
static const char* const ANNOTATION_EXPORT = "@export";
static const char* const ANNOTATION_DO_NOT_GENERATE_CAST = "@doNotGenerateCast";
static const char* const ANNOTATION_USE_PARENT_TYPE_CHECKER =
    "@useParentTypeChecker";
static const char* const ANNOTATION_CPP_OBJECT_DEFINITION =
    "@cppObjectDefinition";
static const char* const ANNOTATION_CPP_OBJECT_LAYOUT_DEFINITION =
    "@cppObjectLayoutDefinition";
static const char* const ANNOTATION_SAME_ENUM_VALUE_AS = "@sameEnumValueAs";
// Generate C++ accessors with relaxed store semantics.
// Weak<T> and Tagged<MaybeObject> fields always use relaxed store.
static const char* const ANNOTATION_CPP_RELAXED_STORE = "@cppRelaxedStore";
// Generate C++ accessors with relaxed load semantics.
static const char* const ANNOTATION_CPP_RELAXED_LOAD = "@cppRelaxedLoad";
// Generate C++ accessors with release store semantics.
static const char* const ANNOTATION_CPP_RELEASE_STORE = "@cppReleaseStore";
// Generate C++ accessors with acquire load semantics.
static const char* const ANNOTATION_CPP_ACQUIRE_LOAD = "@cppAcquireLoad";
// Generate BodyDescriptor using IterateCustomWeakPointers.
static const char* const ANNOTATION_CUSTOM_WEAK_MARKING = "@customWeakMarking";
// Do not generate a interface descriptor for this builtin.
static const char* const ANNOTATION_CUSTOM_INTERFACE_DESCRIPTOR =
    "@customInterfaceDescriptor";

inline bool IsConstexprName(const std::string& name) {
  return name.substr(0, std::strlen(CONSTEXPR_TYPE_PREFIX)) ==
         CONSTEXPR_TYPE_PREFIX;
}

inline std::string GetNonConstexprName(const std::string& name) {
  if (!IsConstexprName(name)) return name;
  return name.substr(std::strlen(CONSTEXPR_TYPE_PREFIX));
}

inline std::string GetConstexprName(const std::string& name) {
  if (IsConstexprName(name)) return name;
  return CONSTEXPR_TYPE_PREFIX + name;
}

enum class AbstractTypeFlag {
  kNone = 0,
  kTransient = 1 << 0,
  kConstexpr = 1 << 1,
  kUseParentTypeChecker = 1 << 2,
};
using AbstractTypeFlags = base::Flags<AbstractTypeFlag>;

enum class ClassFlag {
  kNone = 0,
  kExtern = 1 << 0,
  kTransient = 1 << 1,
  kAbstract = 1 << 2,
  kIsShape = 1 << 3,
  kHasSameInstanceTypeAsParent = 1 << 4,
  kGenerateCppClassDefinitions = 1 << 5,
  kHighestInstanceTypeWithinParent = 1 << 6,
  kLowestInstanceTypeWithinParent = 1 << 7,
  kUndefinedLayout = 1 << 8,
  kGenerateBodyDescriptor = 1 << 9,
  kExport = 1 << 10,
  kDoNotGenerateCast = 1 << 11,
  kGenerateUniqueMap = 1 << 12,
  kGenerateFactoryFunction = 1 << 13,
  kCppObjectDefinition = 1 << 14,
  kCppObjectLayoutDefinition = 1 << 15,
};
using ClassFlags = base::Flags<ClassFlag>;

enum class StructFlag { kNone = 0, kExport = 1 << 0 };
using StructFlags = base::Flags<StructFlag>;

enum class FieldSynchronization {
  kNone,
  kRelaxed,
  kAcquireRelease,
};

}  // namespace torque
}  // namespace internal
}  // namespace v8

#endif  // V8_TORQUE_CONSTANTS_H_
                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/src/torque/cpp-builder.cc                                                       0000664 0000000 0000000 00000010553 14746647661 0020674 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/torque/cpp-builder.h"

namespace v8 {
namespace internal {
namespace torque {
namespace cpp {

void Function::PrintDeclarationHeader(std::ostream& stream,
                                      int indentation) const {
  if (!description_.empty()) {
    stream << std::string(indentation, ' ') << "// " << description_ << "\n";
  }
  stream << std::string(indentation, ' ') << "// " << pos_ << "\n";
  stream << std::string(indentation, ' ');
  if (IsExport()) stream << "V8_EXPORT_PRIVATE ";
  if (IsV8Inline())
    stream << "V8_INLINE ";
  else if (IsInline())
    stream << "inline ";
  if (IsStatic()) stream << "static ";
  if (IsConstexpr()) stream << "constexpr ";
  stream << return_type_ << " " << name_ << "(";
  bool first = true;
  for (const auto& p : parameters_) {
    if (!first) stream << ", ";
    stream << p.type;
    if (!p.name.empty()) stream << " " << p.name;
    if (!p.default_value.empty()) stream << " = " << p.default_value;
    first = false;
  }
  stream << ")";
  if (IsConst()) stream << " const";
}

void Function::PrintDeclaration(std::ostream& stream, int indentation) const {
  if (indentation == kAutomaticIndentation) {
    indentation = owning_class_ ? 2 : 0;
  }
  PrintDeclarationHeader(stream, indentation);
  stream << ";\n";
}

void Function::PrintDefinition(
    std::ostream& stream, const std::function<void(std::ostream&)>& builder,
    int indentation) const {
  PrintBeginDefinition(stream, indentation);
  if (builder) {
    builder(stream);
  }
  PrintEndDefinition(stream, indentation);
}

void Function::PrintInlineDefinition(
    std::ostream& stream, const std::function<void(std::ostream&)>& builder,
    int indentation) const {
  PrintDeclarationHeader(stream, indentation);
  stream << " {\n";
  if (builder) {
    builder(stream);
  }
  PrintEndDefinition(stream, indentation);
}

void Function::PrintBeginDefinition(std::ostream& stream,
                                    int indentation) const {
  stream << std::string(indentation, ' ') << "// " << pos_ << "\n";
  std::string scope;
  if (owning_class_) {
    scope = owning_class_->GetName();
    const auto class_template_parameters =
        owning_class_->GetTemplateParameters();
    if (!class_template_parameters.empty()) {
      stream << std::string(indentation, ' ');
      stream << "template<";
      scope += "<";
      bool first = true;
      for (const auto& p : class_template_parameters) {
        if (!first) {
          stream << ", ";
          scope += ", ";
        }
        if (p.type.empty()) {
          stream << "class " << p.name;
        } else {
          stream << p.type << " " << p.name;
        }
        scope += p.name;
        first = false;
      }
      stream << ">\n";
      scope += ">";
    }
    scope += "::";
  }
  stream << std::string(indentation, ' ') << return_type_ << " " << scope
         << name_ << "(";
  bool first = true;
  for (const auto& p : parameters_) {
    if (!first) stream << ", ";
    stream << p.type;
    if (!p.name.empty()) stream << " " << p.name;
    first = false;
  }
  stream << ")";
  if (IsConst()) {
    stream << " const";
  }
  stream << " {\n";
}

void Function::PrintEndDefinition(std::ostream& stream, int indentation) const {
  stream << std::string(indentation, ' ');
  stream << "}\n\n";
}

void File::BeginIncludeGuard(const std::string& name) {
  s() << "#ifndef " << name
      << "\n"
         "#define "
      << name << "\n\n";
}

void File::EndIncludeGuard(const std::string& name) {
  s() << "#endif // " << name << "\n";
}

void File::BeginNamespace(std::string name) {
  DCHECK(!name.empty());
  DCHECK_EQ(name.find(':'), std::string::npos);
  s() << "namespace " << name << " {\n";
  namespaces_.push(std::move(name));
}

void File::BeginNamespace(std::string name0, std::string name1) {
  BeginNamespace(name0);
  BeginNamespace(name1);
}

void File::EndNamespace(const std::string& name) {
  DCHECK(!namespaces_.empty());
  DCHECK_EQ(namespaces_.top(), name);
  s() << "} // namespace " << namespaces_.top() << "\n";
  namespaces_.pop();
}

void File::EndNamespace(const std::string& name0, const std::string& name1) {
  EndNamespace(name1);
  EndNamespace(name0);
}

}  // namespace cpp
}  // namespace torque
}  // namespace internal
}  // namespace v8
                                                                                                                                                     node-23.7.0/deps/v8/src/torque/cpp-builder.h                                                        0000664 0000000 0000000 00000016571 14746647661 0020544 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_TORQUE_CPP_BUILDER_H_
#define V8_TORQUE_CPP_BUILDER_H_

#include <stack>

#include "src/torque/ast.h"
#include "src/torque/types.h"

namespace v8 {
namespace internal {
namespace torque {
namespace cpp {

struct TemplateParameter {
  explicit TemplateParameter(std::string name) : name(std::move(name)) {}
  TemplateParameter(std::string type, std::string name)
      : name(std::move(name)), type(std::move(type)) {}

  std::string name;
  std::string type;
};

class Class {
 public:
  explicit Class(std::string name) : name_(std::move(name)) {}
  Class(std::vector<TemplateParameter> template_parameters, std::string name)
      : template_parameters_(std::move(template_parameters)),
        name_(std::move(name)) {}

  std::string GetName() const { return name_; }
  std::vector<TemplateParameter> GetTemplateParameters() const {
    return template_parameters_;
  }

 private:
  std::vector<TemplateParameter> template_parameters_;
  std::string name_;
};

#define FUNCTION_FLAG_LIST(V) \
  V(Inline, 0x01)             \
  V(V8Inline, 0x03)           \
  V(Const, 0x04)              \
  V(Constexpr, 0x08)          \
  V(Export, 0x10)             \
  V(Static, 0x20)             \
  V(Override, 0x40)

class Function {
 public:
  enum FunctionFlag {
#define ENTRY(name, value) k##name = value,
    FUNCTION_FLAG_LIST(ENTRY)
#undef ENTRY
  };

  struct Parameter {
    std::string type;
    std::string name;
    std::string default_value;

    Parameter(std::string type, std::string name,
              std::string default_value = {})
        : type(std::move(type)),
          name(std::move(name)),
          default_value(std::move(default_value)) {}
  };

  explicit Function(std::string name)
      : pos_(CurrentSourcePosition::Get()),
        owning_class_(nullptr),
        name_(std::move(name)) {}
  Function(Class* owning_class, std::string name)
      : pos_(CurrentSourcePosition::Get()),
        owning_class_(owning_class),
        name_(std::move(name)) {}
  ~Function() = default;

  static Function DefaultGetter(std::string return_type, Class* owner,
                                std::string name) {
    Function getter(owner, std::move(name));
    getter.SetReturnType(std::move(return_type));
    getter.SetInline();
    getter.SetConst();
    return getter;
  }

  static Function DefaultSetter(Class* owner, std::string name,
                                std::string parameter_type,
                                std::string parameter_name) {
    Function setter(owner, std::move(name));
    setter.SetReturnType("void");
    setter.AddParameter(std::move(parameter_type), std::move(parameter_name));
    setter.SetInline();
    return setter;
  }

  void SetFlag(FunctionFlag flag, bool value = true) {
    if (value) {
      flags_ = flags_ | flag;
    } else {
      flags_ = flags_.without(flag);
    }
  }
  void SetFlags(base::Flags<FunctionFlag> flags, bool value = true) {
    if (value) {
      flags_ |= flags;
    } else {
      flags_ &= ~flags;
    }
  }
  bool HasFlag(FunctionFlag flag) const { return (flags_ & flag) == flag; }
#define ACCESSOR(name, value)                            \
  void Set##name(bool v = true) { SetFlag(k##name, v); } \
  bool Is##name() const { return HasFlag(k##name); }
  FUNCTION_FLAG_LIST(ACCESSOR)
#undef ACCESSOR

  void SetDescription(std::string description) {
    description_ = std::move(description);
  }
  void SetName(std::string name) { name_ = std::move(name); }
  void SetReturnType(std::string return_type) {
    return_type_ = std::move(return_type);
  }
  void AddParameter(std::string type, std::string name = {},
                    std::string default_value = {}) {
    parameters_.emplace_back(std::move(type), std::move(name),
                             std::move(default_value));
  }
  void InsertParameter(int index, std::string type, std::string name = {},
                       std::string default_value = {}) {
    DCHECK_GE(index, 0);
    DCHECK_LE(index, parameters_.size());
    parameters_.insert(
        parameters_.begin() + index,
        Parameter(std::move(type), std::move(name), std::move(default_value)));
  }
  std::vector<Parameter> GetParameters() const { return parameters_; }
  std::vector<std::string> GetParameterNames() const {
    std::vector<std::string> names;
    std::transform(parameters_.begin(), parameters_.end(),
                   std::back_inserter(names),
                   [](const Parameter& p) { return p.name; });
    return names;
  }

  static constexpr int kAutomaticIndentation = -1;
  void PrintDeclaration(std::ostream& stream,
                        int indentation = kAutomaticIndentation) const;
  void PrintDefinition(std::ostream& stream,
                       const std::function<void(std::ostream&)>& builder,
                       int indentation = 0) const;
  void PrintInlineDefinition(std::ostream& stream,
                             const std::function<void(std::ostream&)>& builder,
                             int indentation = 2) const;
  void PrintBeginDefinition(std::ostream& stream, int indentation = 0) const;
  void PrintEndDefinition(std::ostream& stream, int indentation = 0) const;

 protected:
  void PrintDeclarationHeader(std::ostream& stream, int indentation) const;

 private:
  SourcePosition pos_;
  Class* owning_class_;
  std::string description_;
  std::string name_;
  std::string return_type_;
  std::vector<Parameter> parameters_;
  base::Flags<FunctionFlag> flags_;
};

DEFINE_OPERATORS_FOR_FLAGS(base::Flags<Function::FunctionFlag>)
#undef FUNCTION_FLAG_LIST

class File {
 public:
  explicit File(std::ostream& stream) : stream_(&stream) {}

  void BeginIncludeGuard(const std::string& name);
  void EndIncludeGuard(const std::string& name);
  void BeginNamespace(std::string name);
  void BeginNamespace(std::string name0, std::string name1);
  void EndNamespace(const std::string& name);
  void EndNamespace(const std::string& name0, const std::string& name1);

  void AddInclude(std::string include) { includes_.insert(std::move(include)); }

  template <typename T>
  File& operator<<(const T& value) {
    s() << value;
    return *this;
  }

 protected:
  std::ostream& s() { return *stream_; }

 private:
  std::ostream* stream_;
  std::set<std::string> includes_;
  std::stack<std::string> namespaces_;
};

class IncludeGuardScope {
 public:
  explicit IncludeGuardScope(File* file, std::string name)
      : file_(file), name_(std::move(name)) {
    file_->BeginIncludeGuard(name_);
  }
  IncludeGuardScope(const IncludeGuardScope&) = delete;
  IncludeGuardScope(IncludeGuardScope&& other) V8_NOEXCEPT : file_(nullptr),
                                                             name_() {
    std::swap(file_, other.file_);
    std::swap(name_, other.name_);
  }
  ~IncludeGuardScope() {
    if (file_) {
      file_->EndIncludeGuard(name_);
    }
  }
  IncludeGuardScope& operator=(const IncludeGuardScope&) = delete;
  IncludeGuardScope& operator=(IncludeGuardScope&& other) V8_NOEXCEPT {
    if (this != &other) {
      DCHECK_NULL(file_);
      DCHECK(name_.empty());
      std::swap(file_, other.file_);
      std::swap(name_, other.name_);
    }
    return *this;
  }

 private:
  File* file_;
  std::string name_;
};

}  // namespace cpp
}  // namespace torque
}  // namespace internal
}  // namespace v8

#endif  // V8_TORQUE_CPP_BUILDER_H_
                                                                                                                                       node-23.7.0/deps/v8/src/torque/csa-generator.cc                                                     0000664 0000000 0000000 00000120463 14746647661 0021222 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/torque/csa-generator.h"

#include <optional>

#include "src/common/globals.h"
#include "src/torque/global-context.h"
#include "src/torque/type-oracle.h"
#include "src/torque/types.h"
#include "src/torque/utils.h"

namespace v8::internal::torque {

std::optional<Stack<std::string>> CSAGenerator::EmitGraph(
    Stack<std::string> parameters) {
  for (BottomOffset i = {0}; i < parameters.AboveTop(); ++i) {
    SetDefinitionVariable(DefinitionLocation::Parameter(i.offset),
                          parameters.Peek(i));
  }

  for (Block* block : cfg_.blocks()) {
    if (block->IsDead()) continue;

    out() << "  compiler::CodeAssemblerParameterizedLabel<";
    bool first = true;
    DCHECK_EQ(block->InputTypes().Size(), block->InputDefinitions().Size());
    for (BottomOffset i = {0}; i < block->InputTypes().AboveTop(); ++i) {
      if (block->InputDefinitions().Peek(i).IsPhiFromBlock(block)) {
        if (!first) out() << ", ";
        out() << block->InputTypes().Peek(i)->GetGeneratedTNodeTypeName();
        first = false;
      }
    }
    out() << "> " << BlockName(block) << "(&ca_, compiler::CodeAssemblerLabel::"
          << (block->IsDeferred() ? "kDeferred" : "kNonDeferred") << ");\n";
  }

  EmitInstruction(GotoInstruction{cfg_.start()}, &parameters);
  for (Block* block : cfg_.blocks()) {
    if (cfg_.end() && *cfg_.end() == block) continue;
    if (block->IsDead()) continue;
    out() << "\n";

    // Redirect the output of non-declarations into a buffer and only output
    // declarations right away.
    std::stringstream out_buffer;
    std::ostream* old_out = out_;
    out_ = &out_buffer;

    out() << "  if (" << BlockName(block) << ".is_used()) {\n";
    EmitBlock(block);
    out() << "  }\n";

    // All declarations have been printed now, so we can append the buffered
    // output and redirect back to the original output stream.
    out_ = old_out;
    out() << out_buffer.str();
  }
  if (cfg_.end()) {
    out() << "\n";
    return EmitBlock(*cfg_.end());
  }
  return std::nullopt;
}

Stack<std::string> CSAGenerator::EmitBlock(const Block* block) {
  Stack<std::string> stack;
  std::stringstream phi_names;

  for (BottomOffset i = {0}; i < block->InputTypes().AboveTop(); ++i) {
    const auto& def = block->InputDefinitions().Peek(i);
    stack.Push(DefinitionToVariable(def));
    if (def.IsPhiFromBlock(block)) {
      decls() << "  TNode<"
              << block->InputTypes().Peek(i)->GetGeneratedTNodeTypeName()
              << "> " << stack.Top() << ";\n";
      phi_names << ", &" << stack.Top();
    }
  }
  out() << "    ca_.Bind(&" << BlockName(block) << phi_names.str() << ");\n";

  for (const Instruction& instruction : block->instructions()) {
    TorqueCodeGenerator::EmitInstruction(instruction, &stack);
  }
  return stack;
}

void CSAGenerator::EmitSourcePosition(SourcePosition pos, bool always_emit) {
  const std::string& file = SourceFileMap::AbsolutePath(pos.source);
  if (always_emit || !previous_position_.CompareStartIgnoreColumn(pos)) {
    // Lines in Torque SourcePositions are zero-based, while the
    // CodeStubAssembler and downwind systems are one-based.
    out() << "    ca_.SetSourcePosition(\"" << file << "\", "
          << (pos.start.line + 1) << ");\n";
    previous_position_ = pos;
  }
}

void CSAGenerator::EmitInstruction(
    const PushUninitializedInstruction& instruction,
    Stack<std::string>* stack) {
  // TODO(turbofan): This can trigger an error in CSA if it is used. Instead, we
  // should prevent usage of uninitialized in the type system. This
  // requires "if constexpr" being evaluated at Torque time.
  const std::string str = "ca_.Uninitialized<" +
                          instruction.type->GetGeneratedTNodeTypeName() + ">()";
  stack->Push(str);
  SetDefinitionVariable(instruction.GetValueDefinition(), str);
}

void CSAGenerator::EmitInstruction(
    const PushBuiltinPointerInstruction& instruction,
    Stack<std::string>* stack) {
  const std::string str =
      "ca_.UncheckedCast<BuiltinPtr>(ca_.SmiConstant(Builtin::k" +
      instruction.external_name + "))";
  stack->Push(str);
  SetDefinitionVariable(instruction.GetValueDefinition(), str);
}

void CSAGenerator::EmitInstruction(
    const NamespaceConstantInstruction& instruction,
    Stack<std::string>* stack) {
  const Type* type = instruction.constant->type();
  std::vector<std::string> results;

  const auto lowered = LowerType(type);
  for (std::size_t i = 0; i < lowered.size(); ++i) {
    results.push_back(DefinitionToVariable(instruction.GetValueDefinition(i)));
    stack->Push(results.back());
    decls() << "  TNode<" << lowered[i]->GetGeneratedTNodeTypeName() << "> "
            << stack->Top() << ";\n";
  }

  out() << "    ";
  if (type->StructSupertype()) {
    out() << "std::tie(";
    PrintCommaSeparatedList(out(), results);
    out() << ") = ";
  } else if (results.size() == 1) {
    out() << results[0] << " = ";
  }
  out() << instruction.constant->external_name() << "(state_)";
  if (type->StructSupertype()) {
    out() << ".Flatten();\n";
  } else {
    out() << ";\n";
  }
}

std::vector<std::string> CSAGenerator::ProcessArgumentsCommon(
    const TypeVector& parameter_types,
    std::vector<std::string> constexpr_arguments, Stack<std::string>* stack) {
  std::vector<std::string> args;
  for (auto it = parameter_types.rbegin(); it != parameter_types.rend(); ++it) {
    const Type* type = *it;
    if (type->IsConstexpr()) {
      args.push_back(std::move(constexpr_arguments.back()));
      constexpr_arguments.pop_back();
    } else {
      std::stringstream s;
      size_t slot_count = LoweredSlotCount(type);
      VisitResult arg = VisitResult(type, stack->TopRange(slot_count));
      EmitCSAValue(arg, *stack, s);
      args.push_back(s.str());
      stack->PopMany(slot_count);
    }
  }
  std::reverse(args.begin(), args.end());
  return args;
}

void CSAGenerator::EmitInstruction(const CallIntrinsicInstruction& instruction,
                                   Stack<std::string>* stack) {
  TypeVector parameter_types =
      instruction.intrinsic->signature().parameter_types.types;
  std::vector<std::string> args = ProcessArgumentsCommon(
      parameter_types, instruction.constexpr_arguments, stack);

  Stack<std::string> pre_call_stack = *stack;
  const Type* return_type = instruction.intrinsic->signature().return_type;
  std::vector<std::string> results;

  const auto lowered = LowerType(return_type);
  for (std::size_t i = 0; i < lowered.size(); ++i) {
    results.push_back(DefinitionToVariable(instruction.GetValueDefinition(i)));
    stack->Push(results.back());
    decls() << "  TNode<" << lowered[i]->GetGeneratedTNodeTypeName() << "> "
            << stack->Top() << ";\n";
  }

  out() << "    ";
  if (return_type->StructSupertype()) {
    out() << "std::tie(";
    PrintCommaSeparatedList(out(), results);
    out() << ") = ";
  } else {
    if (results.size() == 1) {
      out() << results[0] << " = ";
    }
  }

  if (instruction.intrinsic->ExternalName() == "%RawDownCast") {
    if (parameter_types.size() != 1) {
      ReportError("%RawDownCast must take a single parameter");
    }
    const Type* original_type = parameter_types[0];
    bool is_subtype =
        return_type->IsSubtypeOf(original_type) ||
        (original_type == TypeOracle::GetUninitializedHeapObjectType() &&
         return_type->IsSubtypeOf(TypeOracle::GetHeapObjectType()));
    if (!is_subtype) {
      ReportError("%RawDownCast error: ", *return_type, " is not a subtype of ",
                  *original_type);
    }
    if (!original_type->StructSupertype() &&
        return_type->GetGeneratedTNodeTypeName() !=
            original_type->GetGeneratedTNodeTypeName()) {
      if (return_type->IsSubtypeOf(TypeOracle::GetTaggedType())) {
        out() << "TORQUE_CAST";
      } else {
        out() << "ca_.UncheckedCast<"
              << return_type->GetGeneratedTNodeTypeName() << ">";
      }
    }
  } else if (instruction.intrinsic->ExternalName() == "%GetClassMapConstant") {
    if (!parameter_types.empty()) {
      ReportError("%GetClassMapConstant must not take parameters");
    }
    if (instruction.specialization_types.size() != 1) {
      ReportError(
          "%GetClassMapConstant must take a single class as specialization "
          "parameter");
    }
    const ClassType* class_type =
        ClassType::DynamicCast(instruction.specialization_types[0]);
    if (!class_type) {
      ReportError("%GetClassMapConstant must take a class type parameter");
    }
    // If the class isn't actually used as the parameter to a TNode,
    // then we can't rely on the class existing in C++ or being of the same
    // type (e.g. it could be a template), so don't use the template CSA
    // machinery for accessing the class' map.
    std::string class_name =
        class_type->name() != class_type->GetGeneratedTNodeTypeName()
            ? std::string("void")
            : class_type->name();

    out() << std::string("CodeStubAssembler(state_).GetClassMapConstant<") +
                 class_name + ">";
  } else if (instruction.intrinsic->ExternalName() == "%FromConstexpr") {
    if (parameter_types.size() != 1 || !parameter_types[0]->IsConstexpr()) {
      ReportError(
          "%FromConstexpr must take a single parameter with constexpr "
          "type");
    }
    if (return_type->IsConstexpr()) {
      ReportError("%FromConstexpr must return a non-constexpr type");
    }
    if (return_type->IsSubtypeOf(TypeOracle::GetSmiType())) {
      out() << "ca_.SmiConstant";
    } else if (return_type->IsSubtypeOf(TypeOracle::GetNumberType())) {
      out() << "ca_.NumberConstant";
    } else if (return_type->IsSubtypeOf(TypeOracle::GetStringType())) {
      out() << "ca_.StringConstant";
    } else if (return_type->IsSubtypeOf(TypeOracle::GetObjectType())) {
      ReportError(
          "%FromConstexpr cannot cast to subclass of HeapObject unless it's a "
          "String or Number");
    } else if (return_type->IsSubtypeOf(TypeOracle::GetIntPtrType())) {
      out() << "ca_.IntPtrConstant";
    } else if (return_type->IsSubtypeOf(TypeOracle::GetUIntPtrType())) {
      out() << "ca_.UintPtrConstant";
    } else if (return_type->IsSubtypeOf(TypeOracle::GetInt32Type())) {
      out() << "ca_.Int32Constant";
    } else if (return_type->IsSubtypeOf(TypeOracle::GetUint32Type())) {
      out() << "ca_.Uint32Constant";
    } else if (return_type->IsSubtypeOf(TypeOracle::GetInt64Type())) {
      out() << "ca_.Int64Constant";
    } else if (return_type->IsSubtypeOf(TypeOracle::GetUint64Type())) {
      out() << "ca_.Uint64Constant";
    } else if (return_type->IsSubtypeOf(TypeOracle::GetBoolType())) {
      out() << "ca_.BoolConstant";
    } else {
      std::stringstream s;
      s << "%FromConstexpr does not support return type " << *return_type;
      ReportError(s.str());
    }
    // Wrap the raw constexpr value in a static_cast to ensure that
    // enums get properly casted to their backing integral value.
    out() << "(CastToUnderlyingTypeIfEnum";
  } else {
    ReportError("no built in intrinsic with name " +
                instruction.intrinsic->ExternalName());
  }

  out() << "(";
  PrintCommaSeparatedList(out(), args);
  if (instruction.intrinsic->ExternalName() == "%FromConstexpr") {
    out() << ")";
  }
  if (return_type->StructSupertype()) {
    out() << ").Flatten();\n";
  } else {
    out() << ");\n";
  }
}

void CSAGenerator::EmitInstruction(const CallCsaMacroInstruction& instruction,
                                   Stack<std::string>* stack) {
  TypeVector parameter_types =
      instruction.macro->signature().parameter_types.types;
  std::vector<std::string> args = ProcessArgumentsCommon(
      parameter_types, instruction.constexpr_arguments, stack);

  Stack<std::string> pre_call_stack = *stack;
  const Type* return_type = instruction.macro->signature().return_type;
  std::vector<std::string> results;

  const auto lowered = LowerType(return_type);
  for (std::size_t i = 0; i < lowered.size(); ++i) {
    results.push_back(DefinitionToVariable(instruction.GetValueDefinition(i)));
    stack->Push(results.back());
    decls() << "  TNode<" << lowered[i]->GetGeneratedTNodeTypeName() << "> "
            << stack->Top() << ";\n";
  }

  std::string catch_name =
      PreCallableExceptionPreparation(instruction.catch_block);
  out() << "    ";
  bool needs_flattening = return_type->StructSupertype().has_value();
  if (needs_flattening) {
    out() << "std::tie(";
    PrintCommaSeparatedList(out(), results);
    out() << ") = ";
  } else {
    if (results.size() == 1) {
      out() << results[0] << " = ";
    } else {
      DCHECK_EQ(0, results.size());
    }
  }
  if (ExternMacro* extern_macro = ExternMacro::DynamicCast(instruction.macro)) {
    out() << extern_macro->external_assembler_name() << "(state_).";
  } else {
    args.insert(args.begin(), "state_");
  }
  out() << instruction.macro->ExternalName() << "(";
  PrintCommaSeparatedList(out(), args);
  if (needs_flattening) {
    out() << ").Flatten();\n";
  } else {
    out() << ");\n";
  }
  PostCallableExceptionPreparation(catch_name, return_type,
                                   instruction.catch_block, &pre_call_stack,
                                   instruction.GetExceptionObjectDefinition());
}

void CSAGenerator::EmitInstruction(
    const CallCsaMacroAndBranchInstruction& instruction,
    Stack<std::string>* stack) {
  TypeVector parameter_types =
      instruction.macro->signature().parameter_types.types;
  std::vector<std::string> args = ProcessArgumentsCommon(
      parameter_types, instruction.constexpr_arguments, stack);

  Stack<std::string> pre_call_stack = *stack;
  std::vector<std::string> results;
  const Type* return_type = instruction.macro->signature().return_type;

  if (return_type != TypeOracle::GetNeverType()) {
    const auto lowered = LowerType(return_type);
    for (std::size_t i = 0; i < lowered.size(); ++i) {
      results.push_back(
          DefinitionToVariable(instruction.GetValueDefinition(i)));
      decls() << "  TNode<" << lowered[i]->GetGeneratedTNodeTypeName() << "> "
              << results.back() << ";\n";
    }
  }

  std::vector<std::string> label_names;
  std::vector<std::vector<std::string>> var_names;
  const LabelDeclarationVector& labels = instruction.macro->signature().labels;
  DCHECK_EQ(labels.size(), instruction.label_blocks.size());
  for (size_t i = 0; i < labels.size(); ++i) {
    TypeVector label_parameters = labels[i].types;
    label_names.push_back(FreshLabelName());
    var_names.push_back({});
    for (size_t j = 0; j < label_parameters.size(); ++j) {
      var_names[i].push_back(FreshNodeName());
      const auto def = instruction.GetLabelValueDefinition(i, j);
      SetDefinitionVariable(def, var_names[i].back() + ".value()");
      decls() << "    compiler::TypedCodeAssemblerVariable<"
              << label_parameters[j]->GetGeneratedTNodeTypeName() << "> "
              << var_names[i][j] << "(&ca_);\n";
    }
    out() << "    compiler::CodeAssemblerLabel " << label_names[i]
          << "(&ca_);\n";
  }

  std::string catch_name =
      PreCallableExceptionPreparation(instruction.catch_block);
  out() << "    ";
  if (results.size() == 1) {
    out() << results[0] << " = ";
  } else if (results.size() > 1) {
    out() << "std::tie(";
    PrintCommaSeparatedList(out(), results);
    out() << ") = ";
  }
  if (ExternMacro* extern_macro = ExternMacro::DynamicCast(instruction.macro)) {
    out() << extern_macro->external_assembler_name() << "(state_).";
  } else {
    args.insert(args.begin(), "state_");
  }
  out() << instruction.macro->ExternalName() << "(";
  PrintCommaSeparatedList(out(), args);
  bool first = args.empty();
  for (size_t i = 0; i < label_names.size(); ++i) {
    if (!first) out() << ", ";
    out() << "&" << label_names[i];
    first = false;
    for (size_t j = 0; j < var_names[i].size(); ++j) {
      out() << ", &" << var_names[i][j];
    }
  }
  if (return_type->StructSupertype()) {
    out() << ").Flatten();\n";
  } else {
    out() << ");\n";
  }

  PostCallableExceptionPreparation(catch_name, return_type,
                                   instruction.catch_block, &pre_call_stack,
                                   instruction.GetExceptionObjectDefinition());

  if (instruction.return_continuation) {
    out() << "    ca_.Goto(&" << BlockName(*instruction.return_continuation);
    DCHECK_EQ(stack->Size() + results.size(),
              (*instruction.return_continuation)->InputDefinitions().Size());

    const auto& input_definitions =
        (*instruction.return_continuation)->InputDefinitions();
    for (BottomOffset i = {0}; i < input_definitions.AboveTop(); ++i) {
      if (input_definitions.Peek(i).IsPhiFromBlock(
              *instruction.return_continuation)) {
        out() << ", "
              << (i < stack->AboveTop() ? stack->Peek(i) : results[i.offset]);
      }
    }
    out() << ");\n";
  }
  for (size_t l = 0; l < label_names.size(); ++l) {
    out() << "    if (" << label_names[l] << ".is_used()) {\n";
    out() << "      ca_.Bind(&" << label_names[l] << ");\n";
    out() << "      ca_.Goto(&" << BlockName(instruction.label_blocks[l]);
    DCHECK_EQ(stack->Size() + var_names[l].size(),
              instruction.label_blocks[l]->InputDefinitions().Size());

    const auto& label_definitions =
        instruction.label_blocks[l]->InputDefinitions();

    BottomOffset i = {0};
    for (; i < stack->AboveTop(); ++i) {
      if (label_definitions.Peek(i).IsPhiFromBlock(
              instruction.label_blocks[l])) {
        out() << ", " << stack->Peek(i);
      }
    }
    for (std::size_t k = 0; k < var_names[l].si