0)<<16|(d[l]|0)<<24|(d[q+3|0]|0)<<8|(d[q+4|0]|0)}else if(o<<24>>24==28){if((q+3|0)>>>0>p>>>0){l=0;break}l=((d[l]|0)<<8&65535|(d[q+2|0]|0))<<16>>16}else{if((o&255)<247){l=n+ -139|0;break}p=(q+2|0)>>>0>p>>>0;if((o&255)<251){if(p){l=0;break}l=(d[l]|0|(n<<8)+ -63232)+108|0;break}else{if(p){l=0;break}l=(251-n<<8)+ -108-(d[l]|0)|0;break}}}while(0);l=da(l<<16,c[290680+(m<<2)>>2]|0)|0}c[k>>2]=l;k=c[f>>2]|0;l=c[b>>2]|0;n=c[j>>2]|0;b=a[l]|0;if(b<<24>>24==30){j=FV(l,n,k,0)|0}else{m=l+1|0;j=b&255;do{if(b<<24>>24==29){if((l+5|0)>>>0>n>>>0){j=0;break}j=(d[l+2|0]|0)<<16|(d[m]|0)<<24|(d[l+3|0]|0)<<8|(d[l+4|0]|0)}else if(b<<24>>24==28){if((l+3|0)>>>0>n>>>0){j=0;break}j=((d[m]|0)<<8&65535|(d[l+2|0]|0))<<16>>16}else{if((b&255)<247){j=j+ -139|0;break}l=(l+2|0)>>>0>n>>>0;if((b&255)<251){if(l){j=0;break}j=(d[m]|0|(j<<8)+ -63232)+108|0;break}else{if(l){j=0;break}j=(251-j<<8)+ -108-(d[m]|0)|0;break}}}while(0);j=da(j<<16,c[290680+(k<<2)>>2]|0)|0}c[h+72>>2]=j;c[e>>2]=c[290680+(c[f>>2]<<2)>>2];s=0;i=g;return s|0}function HV(b){b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;e=i;f=c[b+412>>2]|0;g=b+32|0;if((c[b+404>>2]|0)>>>0<g>>>0){o=161;i=e;return o|0}j=f+80|0;h=b+20|0;o=c[b+16>>2]|0;n=c[h>>2]|0;m=a[o]|0;if(m<<24>>24==30){k=FV(o,n,0,0)|0}else{k=o+1|0;l=m&255;do{if(m<<24>>24==28){if((o+3|0)>>>0>n>>>0){k=0;break}k=((d[k]|0)<<8&65535|(d[o+2|0]|0))<<16>>16}else if(m<<24>>24==29){if((o+5|0)>>>0>n>>>0){k=0;break}k=(d[o+2|0]|0)<<16|(d[k]|0)<<24|(d[o+3|0]|0)<<8|(d[o+4|0]|0)}else{if((m&255)<247){k=l+ -139|0;break}n=(o+2|0)>>>0>n>>>0;if((m&255)<251){if(n){k=0;break}k=(d[k]|0|(l<<8)+ -63232)+108|0;break}else{if(n){k=0;break}k=(251-l<<8)+ -108-(d[k]|0)|0;break}}}while(0);k=k<<16}c[j>>2]=ZI(k)|0;j=b+24|0;m=c[h>>2]|0;n=c[j>>2]|0;l=a[m]|0;if(l<<24>>24==30){h=FV(m,n,0,0)|0}else{k=m+1|0;h=l&255;do{if(l<<24>>24==28){if((m+3|0)>>>0>n>>>0){h=0;break}h=((d[k]|0)<<8&65535|(d[m+2|0]|0))<<16>>16}else if(l<<24>>24==29){if((m+5|0)>>>0>n>>>0){h=0;break}h=(d[m+2|0]|0)<<16|(d[k]|0)<<24|(d[m+3|0]|0)<<8|(d[m+4|0]|0)}else{if((l&255)<247){h=h+ -139|0;break}m=(m+2|0)>>>0>n>>>0;if((l&255)<251){if(m){h=0;break}h=(d[k]|0|(h<<8)+ -63232)+108|0;break}else{if(m){h=0;break}h=(251-h<<8)+ -108-(d[k]|0)|0;break}}}while(0);h=h<<16}c[f+84>>2]=ZI(h)|0;b=b+28|0;m=c[j>>2]|0;l=c[b>>2]|0;j=a[m]|0;if(j<<24>>24==30){h=FV(m,l,0,0)|0}else{h=m+1|0;k=j&255;do{if(j<<24>>24==28){if((m+3|0)>>>0>l>>>0){h=0;break}h=((d[h]|0)<<8&65535|(d[m+2|0]|0))<<16>>16}else if(j<<24>>24==29){if((m+5|0)>>>0>l>>>0){h=0;break}h=(d[m+2|0]|0)<<16|(d[h]|0)<<24|(d[m+3|0]|0)<<8|(d[m+4|0]|0)}else{if((j&255)<247){h=k+ -139|0;break}l=(m+2|0)>>>0>l>>>0;if((j&255)<251){if(l){h=0;break}h=(d[h]|0|(k<<8)+ -63232)+108|0;break}else{if(l){h=0;break}h=(251-k<<8)+ -108-(d[h]|0)|0;break}}}while(0);h=h<<16}c[f+88>>2]=ZI(h)|0;h=c[b>>2]|0;k=c[g>>2]|0;b=a[h]|0;if(b<<24>>24==30){g=FV(h,k,0,0)|0}else{j=h+1|0;g=b&255;do{if(b<<24>>24==29){if((h+5|0)>>>0>k>>>0){g=0;break}g=(d[h+2|0]|0)<<16|(d[j]|0)<<24|(d[h+3|0]|0)<<8|(d[h+4|0]|0)}else if(b<<24>>24==28){if((h+3|0)>>>0>k>>>0){g=0;break}g=((d[j]|0)<<8&65535|(d[h+2|0]|0))<<16>>16}else{if((b&255)<247){g=g+ -139|0;break}h=(h+2|0)>>>0>k>>>0;if((b&255)<251){if(h){g=0;break}g=(d[j]|0|(g<<8)+ -63232)+108|0;break}else{if(h){g=0;break}g=(251-g<<8)+ -108-(d[j]|0)|0;break}}}while(0);g=g<<16}c[f+92>>2]=ZI(g)|0;o=0;i=e;return o|0}function IV(b){b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;f=i;e=c[b+412>>2]|0;g=b+24|0;if((c[b+404>>2]|0)>>>0<g>>>0){m=161;i=f;return m|0}h=b+20|0;m=c[b+16>>2]|0;l=c[h>>2]|0;b=a[m]|0;do{if(b<<24>>24==30){b=(FV(m,l,0,0)|0)>>16}else{j=m+1|0;k=b&255;if(b<<24>>24==28){if((m+3|0)>>>0>l>>>0){b=0;break}b=((d[j]|0)<<8&65535|(d[m+2|0]|0))<<16>>16;break}else if(b<<24>>24==29){if((m+5|0)>>>0>l>>>0){b=0;break}b=(d[m+2|0]|0)<<16|(d[j]|0)<<24|(d[m+3|0]|0)<<8|(d[m+4|0]|0);break}else{if((b&255)<247){b=k+ -139|0;break}l=(m+2|0)>>>0>l>>>0;if((b&255)<251){if(l){b=0;break}b=(d[j]|0|(k<<8)+ -63232)+108|0;break}else{if(l){b=0;break}b=(251-k<<8)+ -108-(d[j]|0)|0;break}}}}while(0);c[e+116>>2]=b;h=c[h>>2]|0;k=c[g>>2]|0;j=a[h]|0;do{if(j<<24>>24==30){g=(FV(h,k,0,0)|0)>>16}else{b=h+1|0;g=j&255;if(j<<24>>24==28){if((h+3|0)>>>0>k>>>0){g=0;break}g=((d[b]|0)<<8&65535|(d[h+2|0]|0))<<16>>16;break}else if(j<<24>>24==29){if((h+5|0)>>>0>k>>>0){g=0;break}g=(d[h+2|0]|0)<<16|(d[b]|0)<<24|(d[h+3|0]|0)<<8|(d[h+4|0]|0);break}else{if((j&255)<247){g=g+ -139|0;break}h=(h+2|0)>>>0>k>>>0;if((j&255)<251){if(h){g=0;break}g=(d[b]|0|(g<<8)+ -63232)+108|0;break}else{if(h){g=0;break}g=(251-g<<8)+ -108-(d[b]|0)|0;break}}}}while(0);c[e+112>>2]=g;m=0;i=f;return m|0}function JV(b){b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;f=i;e=c[b+412>>2]|0;g=b+28|0;if((c[b+404>>2]|0)>>>0<g>>>0){n=161;i=f;return n|0}h=b+20|0;m=c[b+16>>2]|0;n=c[h>>2]|0;k=a[m]|0;do{if(k<<24>>24==30){j=(FV(m,n,0,0)|0)>>16}else{j=m+1|0;l=k&255;if(k<<24>>24==28){if((m+3|0)>>>0>n>>>0){j=0;break}j=((d[j]|0)<<8&65535|(d[m+2|0]|0))<<16>>16;break}else if(k<<24>>24==29){if((m+5|0)>>>0>n>>>0){j=0;break}j=(d[m+2|0]|0)<<16|(d[j]|0)<<24|(d[m+3|0]|0)<<8|(d[m+4|0]|0);break}else{if((k&255)<247){j=l+ -139|0;break}m=(m+2|0)>>>0>n>>>0;if((k&255)<251){if(m){j=0;break}j=(d[j]|0|(l<<8)+ -63232)+108|0;break}else{if(m){j=0;break}j=(251-l<<8)+ -108-(d[j]|0)|0;break}}}}while(0);c[e+128>>2]=j;b=b+24|0;m=c[h>>2]|0;l=c[b>>2]|0;h=a[m]|0;do{if(h<<24>>24==30){h=(FV(m,l,0,0)|0)>>16}else{j=m+1|0;k=h&255;if(h<<24>>24==28){if((m+3|0)>>>0>l>>>0){h=0;break}h=((d[j]|0)<<8&65535|(d[m+2|0]|0))<<16>>16;break}else if(h<<24>>24==29){if((m+5|0)>>>0>l>>>0){h=0;break}h=(d[m+2|0]|0)<<16|(d[j]|0)<<24|(d[m+3|0]|0)<<8|(d[m+4|0]|0);break}else{if((h&255)<247){h=k+ -139|0;break}l=(m+2|0)>>>0>l>>>0;if((h&255)<251){if(l){h=0;break}h=(d[j]|0|(k<<8)+ -63232)+108|0;break}else{if(l){h=0;break}h=(251-k<<8)+ -108-(d[j]|0)|0;break}}}}while(0);c[e+132>>2]=h;h=c[b>>2]|0;k=c[g>>2]|0;b=a[h]|0;do{if(b<<24>>24==30){g=(FV(h,k,0,0)|0)>>16}else{j=h+1|0;g=b&255;if(b<<24>>24==28){if((h+3|0)>>>0>k>>>0){g=0;break}g=((d[j]|0)<<8&65535|(d[h+2|0]|0))<<16>>16;break}else if(b<<24>>24==29){if((h+5|0)>>>0>k>>>0){g=0;break}g=(d[h+2|0]|0)<<16|(d[j]|0)<<24|(d[h+3|0]|0)<<8|(d[h+4|0]|0);break}else{if((b&255)<247){g=g+ -139|0;break}h=(h+2|0)>>>0>k>>>0;if((b&255)<251){if(h){g=0;break}g=(d[j]|0|(g<<8)+ -63232)+108|0;break}else{if(h){g=0;break}g=(251-g<<8)+ -108-(d[j]|0)|0;break}}}}while(0);c[e+136>>2]=g;n=0;i=f;return n|0}function KV(d,e){d=d|0;e=e|0;var f=0,g=0,h=0;f=i;bX(e|0,0,196)|0;g=a[d+172|0]|0;a[e+8|0]=g;h=g&255;if(g<<24>>24!=0){g=0;do{b[e+12+(g<<1)>>1]=c[d+176+(g<<2)>>2];g=g+1|0;}while(g>>>0<h>>>0)}h=a[d+173|0]|0;a[e+9|0]=h;g=h&255;if(h<<24>>24!=0){h=0;do{b[e+40+(h<<1)>>1]=c[d+232+(h<<2)>>2];h=h+1|0;}while(h>>>0<g>>>0)}g=a[d+174|0]|0;a[e+10|0]=g;h=g&255;if(g<<24>>24!=0){g=0;do{b[e+60+(g<<1)>>1]=c[d+272+(g<<2)>>2];g=g+1|0;}while(g>>>0<h>>>0)}h=a[d+175|0]|0;a[e+11|0]=h;g=h&255;if(h<<24>>24!=0){h=0;do{b[e+88+(h<<1)>>1]=c[d+328+(h<<2)>>2];h=h+1|0;}while(h>>>0<g>>>0)}c[e+108>>2]=c[d+368>>2];c[e+112>>2]=c[d+372>>2];c[e+116>>2]=c[d+376>>2];b[e+120>>1]=c[d+380>>2];b[e+122>>1]=c[d+384>>2];h=a[d+388|0]|0;a[e+124|0]=h;g=h&255;if(h<<24>>24!=0){h=0;do{b[e+128+(h<<1)>>1]=c[d+392+(h<<2)>>2];h=h+1|0;}while(h>>>0<g>>>0)}g=a[d+389|0]|0;a[e+125|0]=g;h=g&255;if(g<<24>>24==0){g=d+496|0;g=a[g]|0;h=e+126|0;a[h]=g;h=d+508|0;h=c[h>>2]|0;g=e+184|0;c[g>>2]=h;g=d+504|0;g=c[g>>2]|0;h=e+4|0;c[h>>2]=g;i=f;return}else{g=0}do{b[e+154+(g<<1)>>1]=c[d+444+(g<<2)>>2];g=g+1|0;}while(g>>>0<h>>>0);g=d+496|0;g=a[g]|0;h=e+126|0;a[h]=g;h=d+508|0;h=c[h>>2]|0;g=e+184|0;c[g>>2]=h;g=d+504|0;g=c[g>>2]|0;h=e+4|0;c[h>>2]=g;i=f;return}function LV(e,f,g){e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0;h=i;k=i;i=i+8|0;l=i;i=i+8|0;j=i;i=i+8|0;c[k>>2]=e;c[l>>2]=f;p=c[(c[e+76>>2]|0)+1368>>2]|0;c[e+756>>2]=0;a[e+752|0]=1;l=l^k^j;l=(l>>>10^l^l>>20)&65535;c[j>>2]=(l|0)==0?29572:l;l=e+80|0;c[e+276>>2]=l;w=e+280|0;c[e+676>>2]=w;n=c[e+68>>2]|0;m=e+64|0;a[m]=0;c[w>>2]=f;x=f+g|0;c[e+284>>2]=x;c[e+288>>2]=f;A=c[e+24>>2]|0;z=c[e+28>>2]|0;g=(n|0)!=0;if(g){fd[c[n+4>>2]&511](c[n>>2]|0);o=n}else{o=n}v=(p|0)==2?0:16;p=n+12|0;r=n+16|0;s=e+20|0;q=n+20|0;t=e+65|0;u=e+12|0;a:while(1){if(f>>>0<x>>>0){D=f}else{e=0;y=398;break}while(1){f=D+1|0;B=a[D]|0;E=B&255;C=B<<24>>24==28;if(!((B&255)>31|C)){break}do{if(C){E=D+2|0;if(E>>>0>=x>>>0){e=3;y=398;break a}C=D+3|0;B=16;E=(d[f]<<8&65535|d[E])<<16>>16}else{if((B&255)<247){C=f;B=16;E=E+ -139|0;break}if((B&255)<251){if(f>>>0>=x>>>0){e=3;y=398;break a}C=D+2|0;B=16;E=(d[f]|(E<<8)+ -63232)+108|0;break}if(B<<24>>24==-1){E=D+4|0;if(E>>>0>=x>>>0){e=3;y=398;break a}C=D+5|0;B=v;E=d[D+2|0]<<16|d[f]<<24|d[D+3|0]<<8|d[E];break}else{if(f>>>0>=x>>>0){e=3;y=398;break a}C=D+2|0;B=16;E=(251-E<<8)+ -108-(d[f]|0)|0;break}}}while(0);D=(c[k>>2]|0)+276|0;f=c[D>>2]|0;if((f-l|0)>188){e=130;y=398;break a}c[D>>2]=f+4;c[f>>2]=E<<B;if(C>>>0<x>>>0){D=C}else{e=0;y=398;break a}}G=c[k>>2]|0;B=c[G+276>>2]|0;H=B-(G+80)|0;C=H>>2;b:do{switch(E|0){case 21:{E=1;break};case 22:{E=2;break};case 23:{E=22;break};case 4:{E=3;break};case 3:{E=20;break};case 24:{E=10;break};case 25:{E=11;break};case 26:{E=13;break};case 12:{if(f>>>0>=x>>>0){e=3;y=398;break a}D=D+2|0;switch(d[f]|0){case 35:{f=D;E=14;break b};case 36:{f=D;E=16;break b};case 37:{f=D;E=17;break b};case 28:{f=D;E=36;break b};case 29:{f=D;E=37;break b};case 30:{f=D;E=38;break b};case 4:{f=D;E=45;break b};case 5:{f=D;E=46;break b};case 6:{f=D;E=56;break b};case 15:{f=D;E=47;break b};case 16:{f=D;E=54;break b};case 17:{f=D;E=55;break b};case 24:{f=D;E=32;break b};case 26:{f=D;E=33;break b};case 27:{f=D;E=39;break b};case 7:{f=D;E=57;break b};case 8:{f=D;E=42;break b};case 9:{f=D;E=26;break b};case 0:{f=D;E=25;break b};case 21:{f=D;E=41;break b};case 22:{f=D;E=48;break b};case 23:{f=D;E=31;break b};case 18:{f=D;E=35;break b};case 20:{f=D;E=40;break b};case 10:{f=D;E=27;break b};case 11:{f=D;E=28;break b};case 2:{f=D;E=19;break b};case 3:{f=D;E=44;break b};case 1:{f=D;E=20;break b};case 12:{f=D;E=29;break b};case 13:{f=D;E=43;break b};case 14:{f=D;E=30;break b};case 33:{f=D;E=58;break b};case 34:{f=D;E=15;break b};default:{e=3;y=398;break a}}break};case 18:{E=21;break};case 19:{E=23;break};case 20:{E=24;break};case 10:{E=49;break};case 11:{E=51;break};case 1:{E=19;break};case 13:{E=52;break};case 14:{E=18;break};case 16:{E=34;break};case 27:{E=8;break};case 29:{E=50;break};case 7:{E=6;break};case 8:{E=7;break};case 9:{E=53;break};case 30:{E=12;break};case 31:{E=9;break};case 5:{E=4;break};case 6:{E=5;break};default:{e=3;y=398;break a}}}while(0);F=d[290720+E|0]|0;if((F&128|0)==0){H=C}else{c:do{if((H|0)>0){if((a[G+752|0]|0)==0){break}d:do{switch(E|0){case 24:case 23:case 1:case 22:case 21:case 20:case 19:{D=C&1;y=91;break};case 18:{if((C|0)==5){break d}D=(C|0)==1|0;y=91;break};case 3:case 2:{D=C&2;y=91;break};default:{break c}}}while(0);if((y|0)==91){y=0;if((D|0)==0){break}}c[G+744>>2]=(c[l>>2]>>16)+(c[G+748>>2]|0);G=c[k>>2]|0;if((a[G+753|0]|0)!=0){e=0;y=398;break a}C=C+ -1|0}}while(0);a[G+752|0]=0;H=C;F=0}C=F&15;if((H|0)<(C|0)){e=129;y=398;break}D=B+(0-C<<2)|0;G=H-C|0;e:do{switch(E|0){case 8:{if((G|0)<4){e=129;y=398;break a}D=(G|0)%4|0;D=((D|0)>0)+(G-D)|0;if((NV(e,A,z)|0)!=0){e=0;y=398;break a}E=D+C|0;C=B+(0-E<<2)|0;if((D&1|0)==0){B=C}else{B=B+(1-E<<2)|0;D=D+ -1|0;z=(c[C>>2]|0)+z|0}C=((D|0)/4|0)*3|0;do{if((D+3|0)>>>0>=7){D=c[u>>2]|0;if(((b[D+22>>1]|0)+C+(b[D+58>>1]|0)|0)>>>0<=(c[D+4>>2]|0)>>>0){break}if((pJ(D,C,0)|0)!=0){e=0;y=398;break a}}}while(0);if(B>>>0>=(c[(c[k>>2]|0)+276>>2]|0)>>>0){E=l;break e}while(1){A=(c[B>>2]|0)+A|0;C=c[s>>2]|0;if((a[t]|0)==0){C=C+2|0}else{N=c[C+4>>2]|0;P=C+2|0;O=b[P>>1]|0;C=(c[C+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[C]=2;C=P}b[C>>1]=(b[C>>1]|0)+1<<16>>16;A=(c[B+4>>2]|0)+A|0;z=(c[B+8>>2]|0)+z|0;C=c[s>>2]|0;if((a[t]|0)==0){C=C+2|0}else{N=c[C+4>>2]|0;P=C+2|0;O=b[P>>1]|0;C=(c[C+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[C]=2;C=P}b[C>>1]=(b[C>>1]|0)+1<<16>>16;A=(c[B+12>>2]|0)+A|0;C=c[s>>2]|0;if((a[t]|0)==0){C=C+2|0}else{N=c[C+4>>2]|0;P=C+2|0;O=b[P>>1]|0;C=(c[C+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[C]=1;C=P}b[C>>1]=(b[C>>1]|0)+1<<16>>16;B=B+16|0;if(B>>>0>=(c[(c[k>>2]|0)+276>>2]|0)>>>0){E=l;break}}break};case 11:{if((G|0)<8){e=129;y=398;break a}G=G&-2;I=G+ -6|0;D=(I|0)/2|0;if((NV(e,A,z)|0)!=0){e=0;y=398;break a}E=D+3|0;do{if((E|0)!=0){y=c[u>>2]|0;if(((b[y+22>>1]|0)+E+(b[y+58>>1]|0)|0)>>>0<=(c[y+4>>2]|0)>>>0){break}if((pJ(y,E,0)|0)!=0){e=0;y=398;break a}}}while(0);C=C+G|0;y=B+(0-C<<2)|0;E=(c[y>>2]|0)+A|0;C=(c[B+(1-C<<2)>>2]|0)+z|0;H=c[s>>2]|0;A=(a[t]|0)==0;if((I|0)>1){z=0-D|0;z=(D+((z|0)>-1?z:2147483647)<<1)-(G+(F&15))|0;while(1){if(A){A=H+2|0}else{N=c[H+4>>2]|0;A=H+2|0;O=b[A>>1]|0;P=(c[H+8>>2]|0)+O|0;c[N+(O<<3)>>2]=E>>16;c[N+(O<<3)+4>>2]=C>>16;a[P]=1}b[A>>1]=(b[A>>1]|0)+1<<16>>16;F=y+8|0;D=D+ -1|0;E=(c[F>>2]|0)+E|0;C=(c[y+12>>2]|0)+C|0;H=c[s>>2]|0;A=(a[t]|0)==0;if((D|0)>0){y=F}else{break}}y=B+(z+2<<2)|0;if(A){z=y;y=238}else{z=y;y=239}}else{if(A){z=y;y=238}else{z=y;y=239}}if((y|0)==238){y=0;A=H+2|0}else if((y|0)==239){y=0;N=c[H+4>>2]|0;A=H+2|0;O=b[A>>1]|0;P=(c[H+8>>2]|0)+O|0;c[N+(O<<3)>>2]=E>>16;c[N+(O<<3)+4>>2]=C>>16;a[P]=2}b[A>>1]=(b[A>>1]|0)+1<<16>>16;A=(c[z+8>>2]|0)+E|0;B=(c[z+12>>2]|0)+C|0;C=c[s>>2]|0;if((a[t]|0)==0){C=C+2|0}else{N=c[C+4>>2]|0;P=C+2|0;O=b[P>>1]|0;C=(c[C+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=B>>16;a[C]=2;C=P}b[C>>1]=(b[C>>1]|0)+1<<16>>16;A=(c[z+16>>2]|0)+A|0;z=(c[z+20>>2]|0)+B|0;B=c[s>>2]|0;if((a[t]|0)==0){B=B+2|0}else{N=c[B+4>>2]|0;P=B+2|0;O=b[P>>1]|0;B=(c[B+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[B]=1;B=P}b[B>>1]=(b[B>>1]|0)+1<<16>>16;E=l;break};case 13:{if((G|0)<4){e=129;y=398;break a}D=(G|0)%4|0;D=((D|0)>0)+(G-D)|0;if((NV(e,A,z)|0)!=0){e=0;y=398;break a}E=D+C|0;C=B+(0-E<<2)|0;if((D&1|0)==0){B=C}else{B=B+(1-E<<2)|0;D=D+ -1|0;A=(c[C>>2]|0)+A|0}C=((D|0)/4|0)*3|0;do{if((D+3|0)>>>0>=7){D=c[u>>2]|0;if(((b[D+22>>1]|0)+C+(b[D+58>>1]|0)|0)>>>0<=(c[D+4>>2]|0)>>>0){break}if((pJ(D,C,0)|0)!=0){e=0;y=398;break a}}}while(0);if(B>>>0>=(c[(c[k>>2]|0)+276>>2]|0)>>>0){E=l;break e}while(1){z=(c[B>>2]|0)+z|0;C=c[s>>2]|0;if((a[t]|0)==0){C=C+2|0}else{N=c[C+4>>2]|0;P=C+2|0;O=b[P>>1]|0;C=(c[C+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[C]=2;C=P}b[C>>1]=(b[C>>1]|0)+1<<16>>16;A=(c[B+4>>2]|0)+A|0;z=(c[B+8>>2]|0)+z|0;C=c[s>>2]|0;if((a[t]|0)==0){C=C+2|0}else{N=c[C+4>>2]|0;P=C+2|0;O=b[P>>1]|0;C=(c[C+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[C]=2;C=P}b[C>>1]=(b[C>>1]|0)+1<<16>>16;z=(c[B+12>>2]|0)+z|0;C=c[s>>2]|0;if((a[t]|0)==0){C=C+2|0}else{N=c[C+4>>2]|0;P=C+2|0;O=b[P>>1]|0;C=(c[C+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[C]=1;C=P}b[C>>1]=(b[C>>1]|0)+1<<16>>16;B=B+16|0;if(B>>>0>=(c[(c[k>>2]|0)+276>>2]|0)>>>0){E=l;break}}break};case 7:{if((G|0)<6){e=129;y=398;break a}F=G-((G|0)%6|0)|0;if((NV(e,A,z)|0)!=0){e=0;y=398;break a}E=(F|0)/2|0;do{if((F+1|0)>>>0>=3){D=c[u>>2]|0;if(((b[D+22>>1]|0)+E+(b[D+58>>1]|0)|0)>>>0<=(c[D+4>>2]|0)>>>0){break}if((pJ(D,E,0)|0)!=0){e=0;y=398;break a}}}while(0);B=B+(0-(C+F)<<2)|0;if(B>>>0>=(c[(c[k>>2]|0)+276>>2]|0)>>>0){E=l;break e}while(1){A=(c[B>>2]|0)+A|0;z=(c[B+4>>2]|0)+z|0;C=c[s>>2]|0;if((a[t]|0)==0){C=C+2|0}else{N=c[C+4>>2]|0;P=C+2|0;O=b[P>>1]|0;C=(c[C+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[C]=2;C=P}b[C>>1]=(b[C>>1]|0)+1<<16>>16;A=(c[B+8>>2]|0)+A|0;z=(c[B+12>>2]|0)+z|0;C=c[s>>2]|0;if((a[t]|0)==0){C=C+2|0}else{N=c[C+4>>2]|0;P=C+2|0;O=b[P>>1]|0;C=(c[C+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[C]=2;C=P}b[C>>1]=(b[C>>1]|0)+1<<16>>16;A=(c[B+16>>2]|0)+A|0;z=(c[B+20>>2]|0)+z|0;C=c[s>>2]|0;if((a[t]|0)==0){C=C+2|0}else{N=c[C+4>>2]|0;P=C+2|0;O=b[P>>1]|0;C=(c[C+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[C]=1;C=P}b[C>>1]=(b[C>>1]|0)+1<<16>>16;B=B+24|0;if(B>>>0>=(c[(c[k>>2]|0)+276>>2]|0)>>>0){E=l;break}}break};case 22:case 21:case 20:case 19:{if(g){if((E|0)==19){D=1}else{D=(E|0)==21|0}P=(G|0)/2|0;Jd[c[p>>2]&63](c[o>>2]|0,D,P,B+(0-(C+(G&-2))<<2)|0);B=P}else{B=(G|0)/2|0}E=(c[k>>2]|0)+756|0;c[E>>2]=(c[E>>2]|0)+B;E=l;break};case 3:{MV(c[s>>2]|0);a[m]=0;E=l;z=(c[B+(((F|-16)^15)<<2)>>2]|0)+z|0;break};case 1:{MV(c[s>>2]|0);a[m]=0;E=l;A=(c[B+(-2-C<<2)>>2]|0)+A|0;z=(c[B+(((F|-16)^15)<<2)>>2]|0)+z|0;break};case 9:case 12:{if((NV(e,A,z)|0)!=0){e=0;y=398;break a}if((G|0)<4){e=129;y=398;break a}D=(G|0)%4|0;D=((D|0)>0)+(G-D)|0;G=((D|0)/4|0)*3|0;if((D+3|0)>>>0<7){E=l;break e}F=c[u>>2]|0;if(((b[F+22>>1]|0)+G+(b[F+58>>1]|0)|0)>>>0>(c[F+4>>2]|0)>>>0){if((pJ(F,G,0)|0)!=0){e=129;y=398;break a}}if((D|0)<=3){E=l;break e}B=B+(0-(C+D)<<2)|0;C=(E|0)==9|0;while(1){D=D+ -4|0;E=c[B>>2]|0;if((C|0)==0){z=E+z|0;E=c[s>>2]|0;if((a[t]|0)==0){E=E+2|0}else{N=c[E+4>>2]|0;P=E+2|0;O=b[P>>1]|0;E=(c[E+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[E]=2;E=P}b[E>>1]=(b[E>>1]|0)+1<<16>>16;A=(c[B+4>>2]|0)+A|0;z=(c[B+8>>2]|0)+z|0;E=c[s>>2]|0;if((a[t]|0)==0){E=E+2|0}else{N=c[E+4>>2]|0;P=E+2|0;O=b[P>>1]|0;E=(c[E+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[E]=2;E=P}b[E>>1]=(b[E>>1]|0)+1<<16>>16;A=(c[B+12>>2]|0)+A|0;if((D|0)==1){z=(c[B+16>>2]|0)+z|0}E=c[s>>2]|0;if((a[t]|0)==0){E=E+2|0}else{N=c[E+4>>2]|0;P=E+2|0;O=b[P>>1]|0;E=(c[E+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[E]=1;E=P}b[E>>1]=(b[E>>1]|0)+1<<16>>16}else{A=E+A|0;E=c[s>>2]|0;if((a[t]|0)==0){E=E+2|0}else{N=c[E+4>>2]|0;P=E+2|0;O=b[P>>1]|0;E=(c[E+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[E]=2;E=P}b[E>>1]=(b[E>>1]|0)+1<<16>>16;A=(c[B+4>>2]|0)+A|0;z=(c[B+8>>2]|0)+z|0;E=c[s>>2]|0;if((a[t]|0)==0){E=E+2|0}else{N=c[E+4>>2]|0;P=E+2|0;O=b[P>>1]|0;E=(c[E+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[E]=2;E=P}b[E>>1]=(b[E>>1]|0)+1<<16>>16;z=(c[B+12>>2]|0)+z|0;if((D|0)==1){A=(c[B+16>>2]|0)+A|0}E=c[s>>2]|0;if((a[t]|0)==0){E=E+2|0}else{N=c[E+4>>2]|0;P=E+2|0;O=b[P>>1]|0;E=(c[E+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[E]=1;E=P}b[E>>1]=(b[E>>1]|0)+1<<16>>16}if((D|0)>3){B=B+16|0;C=C^1}else{E=l;break}}break};case 6:case 5:{B=(E|0)==5|0;if((G|0)<1){e=129;y=398;break a}if((NV(e,A,z)|0)!=0){e=0;y=398;break a}do{if((H|0)!=(C|0)){C=c[u>>2]|0;if(((b[C+22>>1]|0)+G+(b[C+58>>1]|0)|0)>>>0<=(c[C+4>>2]|0)>>>0){break}if((pJ(C,G,0)|0)!=0){e=0;y=398;break a}}}while(0);if(l>>>0<(c[(c[k>>2]|0)+276>>2]|0)>>>0){C=l}else{E=l;break e}while(1){D=(B|0)==0;E=c[C>>2]|0;z=(D?E:0)+z|0;A=(D?0:E)+A|0;D=c[u>>2]|0;if(((b[D+22>>1]|0)+1+(b[D+58>>1]|0)|0)>>>0>(c[D+4>>2]|0)>>>0){if((pJ(D,1,0)|0)!=0){e=0;y=398;break a}}D=c[s>>2]|0;if((a[t]|0)==0){D=D+2|0}else{N=c[D+4>>2]|0;P=D+2|0;O=b[P>>1]|0;D=(c[D+8>>2]|0)+O|0;c[N+(O<<3)>>2]=A>>16;c[N+(O<<3)+4>>2]=z>>16;a[D]=1;D=P}b[D>>1]=(b[D>>1]|0)+1<<16>>16;C=C+4|0;if(C>>>0>=(c[(c[k>>2]|0)+276>>2]|0)>>>0){E=l;break e}B=B^1}break};case 17:{if((NV(e,A,z)|0)!=0){e=0;y=398;break a}E=c[u>>2]|0;if(((b[E+22>>1]|0)+6+(b[E+58>>1]|0)|0)>>>0>(c[E+4>>2]|0)>>>0){if((pJ(E,6,0)|0)!=0){e=0;y=398;break a}}O=c[D>>2]|0;M=c[B+(1-C<<2)>>2]|0;E=2-C|0;N=B+(E<<2)|0;L=B+(E+1<<2)|0;K=B+(E+2<<2)|0;J=B+(E+3<<2)|0;I=B+(E+4<<2)|0;H=B+(E+5<<2)|0;G=B+(E+6<<2)|0;C=(c[G>>2]|0)+((c[I>>2]|0)+((c[K>>2]|0)+((c[N>>2]|0)+O)))|0;F=B+(E+7<<2)|0;D=(c[F>>2]|0)+((c[H>>2]|0)+((c[J>>2]|0)+((c[L>>2]|0)+M)))|0;O=O+A|0;M=M+z|0;P=c[s>>2]|0;if((a[t]|0)==0){P=P+2|0}else{S=c[P+4>>2]|0;Q=P+2|0;R=b[Q>>1]|0;P=(c[P+8>>2]|0)+R|0;c[S+(R<<3)>>2]=O>>16;c[S+(R<<3)+4>>2]=M>>16;a[P]=2;P=Q}b[P>>1]=(b[P>>1]|0)+1<<16>>16;N=(c[N>>2]|0)+O|0;L=(c[L>>2]|0)+M|0;M=c[s>>2]|0;if((a[t]|0)==0){M=M+2|0}else{Q=c[M+4>>2]|0;S=M+2|0;R=b[S>>1]|0;M=(c[M+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=N>>16;c[Q+(R<<3)+4>>2]=L>>16;a[M]=2;M=S}b[M>>1]=(b[M>>1]|0)+1<<16>>16;K=(c[K>>2]|0)+N|0;J=(c[J>>2]|0)+L|0;L=c[s>>2]|0;if((a[t]|0)==0){L=L+2|0}else{Q=c[L+4>>2]|0;S=L+2|0;R=b[S>>1]|0;L=(c[L+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=K>>16;c[Q+(R<<3)+4>>2]=J>>16;a[L]=1;L=S}b[L>>1]=(b[L>>1]|0)+1<<16>>16;I=(c[I>>2]|0)+K|0;H=(c[H>>2]|0)+J|0;J=c[s>>2]|0;if((a[t]|0)==0){J=J+2|0}else{Q=c[J+4>>2]|0;S=J+2|0;R=b[S>>1]|0;J=(c[J+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=I>>16;c[Q+(R<<3)+4>>2]=H>>16;a[J]=2;J=S}b[J>>1]=(b[J>>1]|0)+1<<16>>16;G=(c[G>>2]|0)+I|0;F=(c[F>>2]|0)+H|0;H=c[s>>2]|0;if((a[t]|0)==0){H=H+2|0}else{Q=c[H+4>>2]|0;S=H+2|0;R=b[S>>1]|0;H=(c[H+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=G>>16;c[Q+(R<<3)+4>>2]=F>>16;a[H]=2;H=S}b[H>>1]=(b[H>>1]|0)+1<<16>>16;B=c[B+(E+8<<2)>>2]|0;C=(((C|0)<0?0-C|0:C)|0)>(((D|0)<0?0-D|0:D)|0);z=C?z:B+F|0;A=C?B+G|0:A;B=c[s>>2]|0;if((a[t]|0)==0){B=B+2|0}else{Q=c[B+4>>2]|0;S=B+2|0;R=b[S>>1]|0;B=(c[B+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=A>>16;c[Q+(R<<3)+4>>2]=z>>16;a[B]=1;B=S}b[B>>1]=(b[B>>1]|0)+1<<16>>16;E=l;break};case 14:{if((NV(e,A,z)|0)!=0){e=0;y=398;break a}B=c[u>>2]|0;if(((b[B+22>>1]|0)+6+(b[B+58>>1]|0)|0)>>>0>(c[B+4>>2]|0)>>>0){if((pJ(B,6,0)|0)==0){B=6}else{e=0;y=398;break a}}else{B=6}while(1){A=(c[D>>2]|0)+A|0;z=(c[D+4>>2]|0)+z|0;if((B|0)==4){C=1}else{C=(B|0)==1|0}F=c[s>>2]|0;if((a[t]|0)==0){E=F+2|0}else{R=c[F+4>>2]|0;E=F+2|0;S=b[E>>1]|0;F=(c[F+8>>2]|0)+S|0;c[R+(S<<3)>>2]=A>>16;c[R+(S<<3)+4>>2]=z>>16;a[F]=C<<24>>24!=0?1:2}b[E>>1]=(b[E>>1]|0)+1<<16>>16;B=B+ -1|0;if((B|0)==0){E=l;break}else{D=D+8|0}}break};case 56:{y=330;break a};case 26:{E=c[D>>2]|0;if((E|0)<0){c[D>>2]=0-E}E=B+(1-C<<2)|0;break};case 27:{E=B+(1-C<<2)|0;c[D>>2]=(c[D>>2]|0)+(c[E>>2]|0);break};case 28:{E=B+(1-C<<2)|0;c[D>>2]=(c[D>>2]|0)-(c[E>>2]|0);break};case 29:{E=B+(1-C<<2)|0;c[D>>2]=bJ(c[D>>2]|0,c[E>>2]|0)|0;break};case 30:{c[D>>2]=0-(c[D>>2]|0);E=B+(1-C<<2)|0;break};case 18:{y=331;break a};case 38:{E=c[D>>2]>>16;J=c[B+(1-C<<2)>>2]>>16;G=(E|0)<1?1:E;C=G+C|0;E=B+(0-C<<2)|0;if(E>>>0<l>>>0){e=129;y=398;break a}if((J|0)>-1){if((J|0)<=0){E=D;break e}F=B+(G+ -1-C<<2)|0;H=G+ -2|0;I=(H|0)>-1;G=1-C|0;while(1){K=c[F>>2]|0;if(I){L=H;while(1){c[B+(G+L<<2)>>2]=c[B+(L-C<<2)>>2];if((L|0)>0){L=L+ -1|0}else{break}}}c[E>>2]=K;J=J+ -1|0;if((J|0)<=0){E=D;break}}}else{F=G+ -1|0;if((F|0)<=0){while(1){c[B+(F-C<<2)>>2]=c[E>>2];J=J+1|0;if((J|0)<0){}else{E=D;break e}}}while(1){I=c[E>>2]|0;H=0;while(1){G=H+1|0;c[B+(H-C<<2)>>2]=c[B+(G-C<<2)>>2];if((G|0)<(F|0)){H=G}else{break}}c[B+(F-C<<2)>>2]=I;J=J+1|0;if((J|0)>=0){E=D;break}}}break};case 31:{S=c[j>>2]|0;c[D>>2]=((S|0)>32767)+S;D=c[j>>2]|0;D=aJ(D,65536-D|0)|0;c[j>>2]=(D|0)==0?D+10355|0:D;E=B+(1-C<<2)|0;break};case 32:{E=B+(1-C<<2)|0;c[D>>2]=aJ(c[D>>2]|0,c[E>>2]|0)|0;break};case 33:{F=c[D>>2]|0;f:do{if((F|0)>0){E=F;while(1){G=F+1+(bJ(E,F)|0)>>1;if((G|0)==(F|0)){break f}E=c[D>>2]|0;F=G}}else{F=0}}while(0);c[D>>2]=F;E=B+(1-C<<2)|0;break};case 44:{E=B+(1-C<<2)|0;if((c[D>>2]|0)==0){B=0}else{B=(c[E>>2]|0)!=0?65536:0}c[D>>2]=B;break};case 45:{E=B+(1-C<<2)|0;if((c[D>>2]|0)==0){B=(c[E>>2]|0)!=0?65536:0}else{B=65536}c[D>>2]=B;break};case 47:{c[D>>2]=(c[D>>2]|0)==0?65536:0;E=B+(1-C<<2)|0;break};case 36:{S=c[D>>2]|0;E=B+(1-C<<2)|0;c[D>>2]=c[E>>2];c[E>>2]=S;E=B+(2-C<<2)|0;break};case 37:{E=c[D>>2]>>16;if((E|0)<0){E=-1}else{F=G+ -2|0;E=~((E|0)>(F|0)?F:E)}c[D>>2]=c[B+(E-C<<2)>>2];E=B+(1-C<<2)|0;break};case 10:{if((G|0)<8){e=129;y=398;break a}E=G+ -2|0;I=(E|0)%6|0;D=(E|0)/6|0;if((NV(e,A,z)|0)!=0){e=0;y=398;break a}F=(D*3|0)+2|0;do{if((F|0)!=0){H=c[u>>2]|0;if(((b[H+22>>1]|0)+F+(b[H+58>>1]|0)|0)>>>0<=(c[H+4>>2]|0)>>>0){break}if((pJ(H,F,0)|0)!=0){e=0;y=398;break a}}}while(0);C=-2-C+(2-G)+I|0;F=B+(C<<2)|0;A=(c[F>>2]|0)+A|0;z=(c[B+(C+1<<2)>>2]|0)+z|0;B=c[s>>2]|0;C=(a[t]|0)==0;if((E|0)>5){G=B;B=F;while(1){if(C){C=G+2|0}else{Q=c[G+4>>2]|0;C=G+2|0;R=b[C>>1]|0;S=(c[G+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=A>>16;c[Q+(R<<3)+4>>2]=z>>16;a[S]=2}b[C>>1]=(b[C>>1]|0)+1<<16>>16;A=(c[B+8>>2]|0)+A|0;z=(c[B+12>>2]|0)+z|0;C=c[s>>2]|0;if((a[t]|0)==0){C=C+2|0}else{Q=c[C+4>>2]|0;S=C+2|0;R=b[S>>1]|0;C=(c[C+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=A>>16;c[Q+(R<<3)+4>>2]=z>>16;a[C]=2;C=S}b[C>>1]=(b[C>>1]|0)+1<<16>>16;A=(c[B+16>>2]|0)+A|0;z=(c[B+20>>2]|0)+z|0;C=c[s>>2]|0;if((a[t]|0)==0){C=C+2|0}else{Q=c[C+4>>2]|0;S=C+2|0;R=b[S>>1]|0;C=(c[C+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=A>>16;c[Q+(R<<3)+4>>2]=z>>16;a[C]=1;C=S}b[C>>1]=(b[C>>1]|0)+1<<16>>16;E=B+24|0;D=D+ -1|0;A=(c[E>>2]|0)+A|0;z=(c[B+28>>2]|0)+z|0;B=c[s>>2]|0;C=(a[t]|0)==0;if((D|0)>0){G=B;B=E}else{break}}}if(C){B=B+2|0}else{Q=c[B+4>>2]|0;S=B+2|0;R=b[S>>1]|0;B=(c[B+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=A>>16;c[Q+(R<<3)+4>>2]=z>>16;a[B]=1;B=S}b[B>>1]=(b[B>>1]|0)+1<<16>>16;E=l;break};case 16:{if((NV(e,A,z)|0)!=0){e=0;y=398;break a}E=c[u>>2]|0;if(((b[E+22>>1]|0)+6+(b[E+58>>1]|0)|0)>>>0>(c[E+4>>2]|0)>>>0){if((pJ(E,6,0)|0)!=0){e=0;y=398;break a}}D=(c[D>>2]|0)+A|0;A=(c[B+(1-C<<2)>>2]|0)+z|0;E=c[s>>2]|0;if((a[t]|0)==0){E=E+2|0}else{Q=c[E+4>>2]|0;S=E+2|0;R=b[S>>1]|0;E=(c[E+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=D>>16;c[Q+(R<<3)+4>>2]=A>>16;a[E]=2;E=S}b[E>>1]=(b[E>>1]|0)+1<<16>>16;D=(c[B+(2-C<<2)>>2]|0)+D|0;A=(c[B+(3-C<<2)>>2]|0)+A|0;E=c[s>>2]|0;if((a[t]|0)==0){E=E+2|0}else{Q=c[E+4>>2]|0;S=E+2|0;R=b[S>>1]|0;E=(c[E+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=D>>16;c[Q+(R<<3)+4>>2]=A>>16;a[E]=2;E=S}b[E>>1]=(b[E>>1]|0)+1<<16>>16;D=(c[B+(4-C<<2)>>2]|0)+D|0;E=c[s>>2]|0;if((a[t]|0)==0){E=E+2|0}else{Q=c[E+4>>2]|0;S=E+2|0;R=b[S>>1]|0;E=(c[E+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=D>>16;c[Q+(R<<3)+4>>2]=A>>16;a[E]=1;E=S}b[E>>1]=(b[E>>1]|0)+1<<16>>16;D=(c[B+(5-C<<2)>>2]|0)+D|0;E=c[s>>2]|0;if((a[t]|0)==0){E=E+2|0}else{Q=c[E+4>>2]|0;S=E+2|0;R=b[S>>1]|0;E=(c[E+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=D>>16;c[Q+(R<<3)+4>>2]=A>>16;a[E]=2;E=S}b[E>>1]=(b[E>>1]|0)+1<<16>>16;D=(c[B+(6-C<<2)>>2]|0)+D|0;E=c[s>>2]|0;if((a[t]|0)==0){A=E+2|0}else{P=(c[B+(7-C<<2)>>2]|0)+A|0;Q=c[E+4>>2]|0;A=E+2|0;R=b[A>>1]|0;S=(c[E+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=D>>16;c[Q+(R<<3)+4>>2]=P>>16;a[S]=2}b[A>>1]=(b[A>>1]|0)+1<<16>>16;A=(c[B+(8-C<<2)>>2]|0)+D|0;B=c[s>>2]|0;if((a[t]|0)==0){B=B+2|0}else{Q=c[B+4>>2]|0;S=B+2|0;R=b[S>>1]|0;B=(c[B+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=A>>16;c[Q+(R<<3)+4>>2]=z>>16;a[B]=1;B=S}b[B>>1]=(b[B>>1]|0)+1<<16>>16;E=l;break};case 4:{if((NV(e,A,z)|0)!=0){e=0;y=398;break a}D=(G|0)/2|0;if((G+1|0)>>>0<3){e=129;y=398;break a}E=c[u>>2]|0;if(((b[E+22>>1]|0)+D+(b[E+58>>1]|0)|0)>>>0>(c[E+4>>2]|0)>>>0){if((pJ(E,D,0)|0)!=0){e=0;y=398;break a}}if((G|0)<2){e=129;y=398;break a}B=B+(0-(C+(G&-2))<<2)|0;if(B>>>0>=(c[(c[k>>2]|0)+276>>2]|0)>>>0){E=l;break e}while(1){A=(c[B>>2]|0)+A|0;z=(c[B+4>>2]|0)+z|0;C=c[s>>2]|0;if((a[t]|0)==0){C=C+2|0}else{Q=c[C+4>>2]|0;S=C+2|0;R=b[S>>1]|0;C=(c[C+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=A>>16;c[Q+(R<<3)+4>>2]=z>>16;a[C]=1;C=S}b[C>>1]=(b[C>>1]|0)+1<<16>>16;B=B+8|0;if(B>>>0<(c[(c[k>>2]|0)+276>>2]|0)>>>0){}else{E=l;break}}break};case 2:{MV(c[s>>2]|0);a[m]=0;E=l;A=(c[B+(((F|-16)^15)<<2)>>2]|0)+A|0;break};case 24:case 23:{if((G|0)>0){if(g){S=(G|0)/2|0;Jd[c[p>>2]&63](c[o>>2]|0,0,S,B+(0-(C+(G&-2))<<2)|0);B=S}else{B=(G|0)/2|0}S=(c[k>>2]|0)+756|0;c[S>>2]=(c[S>>2]|0)+B}B=c[(c[k>>2]|0)+756>>2]|0;if((f+(B+7>>3)|0)>>>0>=x>>>0){e=3;y=398;break a}do{if(g){if((E|0)==23){Jd[c[r>>2]&63](c[o>>2]|0,b[(c[s>>2]|0)+2>>1]|0,B,f);break}else{Gd[c[q>>2]&255](c[o>>2]|0,B,f);break}}}while(0);E=l;f=f+((c[(c[k>>2]|0)+756>>2]|0)+7>>3)|0;break};case 15:{if((NV(e,A,z)|0)!=0){e=0;y=398;break a}E=c[u>>2]|0;if(((b[E+22>>1]|0)+6+(b[E+58>>1]|0)|0)>>>0>(c[E+4>>2]|0)>>>0){if((pJ(E,6,0)|0)!=0){e=0;y=398;break a}}A=(c[D>>2]|0)+A|0;D=c[s>>2]|0;if((a[t]|0)==0){D=D+2|0}else{Q=c[D+4>>2]|0;S=D+2|0;R=b[S>>1]|0;D=(c[D+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=A>>16;c[Q+(R<<3)+4>>2]=z>>16;a[D]=2;D=S}b[D>>1]=(b[D>>1]|0)+1<<16>>16;D=(c[B+(1-C<<2)>>2]|0)+A|0;A=(c[B+(2-C<<2)>>2]|0)+z|0;E=c[s>>2]|0;if((a[t]|0)==0){E=E+2|0}else{Q=c[E+4>>2]|0;S=E+2|0;R=b[S>>1]|0;E=(c[E+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=D>>16;c[Q+(R<<3)+4>>2]=A>>16;a[E]=2;E=S}b[E>>1]=(b[E>>1]|0)+1<<16>>16;D=(c[B+(3-C<<2)>>2]|0)+D|0;E=c[s>>2]|0;if((a[t]|0)==0){E=E+2|0}else{Q=c[E+4>>2]|0;S=E+2|0;R=b[S>>1]|0;E=(c[E+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=D>>16;c[Q+(R<<3)+4>>2]=A>>16;a[E]=1;E=S}b[E>>1]=(b[E>>1]|0)+1<<16>>16;D=(c[B+(4-C<<2)>>2]|0)+D|0;E=c[s>>2]|0;if((a[t]|0)==0){A=E+2|0}else{P=c[E+4>>2]|0;S=E+2|0;Q=b[S>>1]|0;R=(c[E+8>>2]|0)+Q|0;c[P+(Q<<3)>>2]=D>>16;c[P+(Q<<3)+4>>2]=A>>16;a[R]=2;A=S}b[A>>1]=(b[A>>1]|0)+1<<16>>16;A=(c[B+(5-C<<2)>>2]|0)+D|0;D=c[s>>2]|0;if((a[t]|0)==0){D=D+2|0}else{Q=c[D+4>>2]|0;S=D+2|0;R=b[S>>1]|0;D=(c[D+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=A>>16;c[Q+(R<<3)+4>>2]=z>>16;a[D]=2;D=S}b[D>>1]=(b[D>>1]|0)+1<<16>>16;A=(c[B+(6-C<<2)>>2]|0)+A|0;B=c[s>>2]|0;if((a[t]|0)==0){B=B+2|0}else{Q=c[B+4>>2]|0;S=B+2|0;R=b[S>>1]|0;B=(c[B+8>>2]|0)+R|0;c[Q+(R<<3)>>2]=A>>16;c[Q+(R<<3)+4>>2]=z>>16;a[B]=1;B=S}b[B>>1]=(b[B>>1]|0)+1<<16>>16;E=l;break};case 39:{c[B+(1-C<<2)>>2]=c[D>>2];E=B+(2-C<<2)|0;break};case 40:{B=c[B+(1-C<<2)>>2]>>16;if(B>>>0>=32){E=D;break e}c[(c[k>>2]|0)+760+(B<<2)>>2]=c[D>>2];E=D;break};case 41:{E=c[D>>2]>>16;if(E>>>0<32){E=c[(c[k>>2]|0)+760+(E<<2)>>2]|0}else{E=0}c[D>>2]=E;E=B+(1-C<<2)|0;break};case 53:{E=l;break};case 52:{z=c[k>>2]|0;c[z+744>>2]=(c[B+(1-C<<2)>>2]>>16)+(c[z+748>>2]|0);c[(c[k>>2]|0)+32>>2]=c[D>>2];c[(c[k>>2]|0)+36>>2]=0;z=c[k>>2]|0;E=l;A=(c[D>>2]|0)+(c[z+24>>2]|0)|0;z=c[z+28>>2]|0;break};case 57:{S=c[k>>2]|0;c[S+744>>2]=(c[B+(2-C<<2)>>2]>>16)+(c[S+748>>2]|0);c[(c[k>>2]|0)+32>>2]=c[D>>2];S=B+(1-C<<2)|0;c[(c[k>>2]|0)+36>>2]=c[S>>2];z=c[k>>2]|0;E=l;A=(c[D>>2]|0)+(c[z+24>>2]|0)|0;z=(c[S>>2]|0)+(c[z+28>>2]|0)|0;break};case 58:{z=c[k>>2]|0;E=l;A=(c[D>>2]|0)+(c[z+24>>2]|0)|0;z=(c[B+(1-C<<2)>>2]|0)+(c[z+28>>2]|0)|0;break};case 54:{E=-2-C|0;E=B+(E-(c[B+(E<<2)>>2]>>16)<<2)|0;if(E>>>0<l>>>0){e=129;y=398;break a}break};case 55:{E=B+(1-C<<2)|0;break};case 50:{B=c[k>>2]|0;x=(c[B+900>>2]|0)+(c[D>>2]>>16)|0;if(x>>>0>=(c[B+892>>2]|0)>>>0){e=3;y=398;break a}if((w-(B+280)|0)>372){e=3;y=398;break a}c[w+8>>2]=f;B=w+12|0;S=c[(c[(c[k>>2]|0)+908>>2]|0)+(x<<2)>>2]|0;c[B>>2]=S;R=c[(c[(c[k>>2]|0)+908>>2]|0)+(x+1<<2)>>2]|0;x=w+16|0;c[x>>2]=R;c[w+20>>2]=S;if((S|0)==0|(R|0)==(S|0)){e=3;y=398;break a}c[(c[k>>2]|0)+676>>2]=B;E=D;f=c[B>>2]|0;x=c[x>>2]|0;w=B;break};case 48:{E=B+(1-C<<2)|0;if((c[B+(2-C<<2)>>2]|0)<=(c[B+(3-C<<2)>>2]|0)){break e}c[D>>2]=c[E>>2];break};case 49:{B=c[k>>2]|0;x=(c[B+896>>2]|0)+(c[D>>2]>>16)|0;if(x>>>0>=(c[B+888>>2]|0)>>>0){e=3;y=398;break a}if((w-(B+280)|0)>372){e=3;y=398;break a}c[w+8>>2]=f;B=w+12|0;S=c[(c[(c[k>>2]|0)+904>>2]|0)+(x<<2)>>2]|0;c[B>>2]=S;R=c[(c[(c[k>>2]|0)+904>>2]|0)+(x+1<<2)>>2]|0;x=w+16|0;c[x>>2]=R;c[w+20>>2]=S;if((S|0)==0|(R|0)==(S|0)){e=3;y=398;break a}c[(c[k>>2]|0)+676>>2]=B;E=D;f=c[B>>2]|0;x=c[x>>2]|0;w=B;break};case 51:{S=c[k>>2]|0;x=S+676|0;w=c[x>>2]|0;if(w>>>0<=(S+280|0)>>>0){e=3;y=398;break a}c[x>>2]=w+ -12;w=c[(c[k>>2]|0)+676>>2]|0;E=D;f=c[w+8>>2]|0;x=c[w+4>>2]|0;break};case 25:case 35:{E=D;break};default:{e=7;y=398;break a}}}while(0);c[(c[k>>2]|0)+276>>2]=E;if(((c[(c[k>>2]|0)+276>>2]|0)-l|0)>188){e=130;y=398;break}}if((y|0)==330){S=OV(c[k>>2]|0,c[D>>2]|0,c[B+(1-C<<2)>>2]|0,c[B+(2-C<<2)>>2]|0,c[B+(3-C<<2)>>2]>>16,c[B+(4-C<<2)>>2]>>16)|0;sJ(c[u>>2]|0);i=h;return S|0}else if((y|0)==331){if((G|0)>3){S=c[k>>2]|0;R=c[S+744>>2]|0;S=OV(S,0,c[B+(-4-C<<2)>>2]|0,c[B+(-3-C<<2)>>2]|0,c[B+(-2-C<<2)>>2]>>16,c[B+(((F|-16)^15)<<2)>>2]>>16)|0;c[(c[k>>2]|0)+744>>2]=R;i=h;return S|0}MV(c[s>>2]|0);do{if(g){if((Bd[c[n+8>>2]&255](c[o>>2]|0,b[(c[s>>2]|0)+2>>1]|0)|0)==0){pd[c[n+24>>2]&63](c[o>>2]|0,c[s>>2]|0,c[e+72>>2]|0,c[(c[k>>2]|0)+920>>2]|0)|0;break}else{S=3;i=h;return S|0}}}while(0);sJ(c[u>>2]|0);S=0;i=h;return S|0}else if((y|0)==398){i=h;return e|0}return 0}function MV(d){d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0;e=i;if((d|0)==0){i=e;return}f=b[d>>1]|0;if(f<<16>>16<2){g=0}else{g=(b[(c[d+12>>2]|0)+((f<<16>>16)+ -2<<1)>>1]|0)+1|0}h=d+2|0;j=b[h>>1]|0;do{if(j<<16>>16>1){l=c[d+4>>2]|0;k=(j<<16>>16)+ -1|0;if((c[l+(g<<3)>>2]|0)!=(c[l+(k<<3)>>2]|0)){break}if((c[l+(g<<3)+4>>2]|0)!=(c[l+(k<<3)+4>>2]|0)){break}if((a[(c[d+8>>2]|0)+k|0]|0)!=1){break}j=j+ -1<<16>>16;b[h>>1]=j}}while(0);if(f<<16>>16<=0){i=e;return}k=(j<<16>>16)+ -1|0;if((g|0)==(k|0)){b[d>>1]=f+ -1<<16>>16;b[h>>1]=j+ -1<<16>>16;i=e;return}else{b[(c[d+12>>2]|0)+((f<<16>>16)+ -1<<1)>>1]=k;i=e;return}}function NV(d,e,f){d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0;g=i;h=d+64|0;if((a[h]|0)!=0){l=0;i=g;return l|0}a[h]=1;j=d+20|0;k=c[j>>2]|0;h=d+65|0;if((a[h]|0)==0){b[k>>1]=(b[k>>1]|0)+1<<16>>16;d=d+12|0}else{d=d+12|0;l=c[d>>2]|0;do{if(((b[l+20>>1]|0)+1+(b[l+56>>1]|0)|0)>>>0>(c[l+8>>2]|0)>>>0){l=pJ(l,0,1)|0;if((l|0)==0){break}i=g;return l|0}}while(0);l=b[k>>1]|0;if(l<<16>>16>0){b[(c[k+12>>2]|0)+((l<<16>>16)+ -1<<1)>>1]=(b[k+2>>1]|0)+ -1<<16>>16;l=b[k>>1]|0}b[k>>1]=l+1<<16>>16}k=c[d>>2]|0;do{if(((b[k+22>>1]|0)+1+(b[k+58>>1]|0)|0)>>>0>(c[k+4>>2]|0)>>>0){l=pJ(k,1,0)|0;if((l|0)==0){break}i=g;return l|0}}while(0);j=c[j>>2]|0;if((a[h]|0)==0){e=j+2|0}else{h=c[j+4>>2]|0;l=j+2|0;k=b[l>>1]|0;d=(c[j+8>>2]|0)+k|0;c[h+(k<<3)>>2]=e>>16;c[h+(k<<3)+4>>2]=f>>16;a[d]=1;e=l}b[e>>1]=(b[e>>1]|0)+1<<16>>16;l=0;i=g;return l|0}function OV(d,e,f,g,h,j){d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;j=j|0;var k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0;k=i;n=i;i=i+8|0;p=n;t=i;i=i+8|0;v=t;y=i;i=i+8|0;z=y;B=i;i=i+8|0;A=B;o=i;i=i+8|0;m=o;s=i;i=i+8|0;u=s;q=c[d+4>>2]|0;r=d+924|0;if((a[r]|0)!=0){H=160;i=k;return H|0}l=d+32|0;f=(c[l>>2]|0)+f|0;x=d+36|0;w=(c[x>>2]|0)+g|0;g=q+128|0;a:do{if((c[(c[g>>2]|0)+52>>2]|0)==0){D=c[q+692>>2]|0;C=c[D+1160>>2]|0;E=(C|0)==0;b:do{if(E|h>>>0>255){h=-1}else{if(h>>>0<256){F=b[287224+(h<<1)>>1]|0}else{F=0}H=c[D+12>>2]|0;if((H|0)==0){h=-1;break}else{h=0}while(1){G=h+1|0;if((b[C+(h<<1)>>1]|0)==F<<16>>16){break b}if(G>>>0<H>>>0){h=G}else{h=-1;break}}}}while(0);if(E|j>>>0>255){H=160;i=k;return H|0}if(j>>>0<256){E=b[287224+(j<<1)>>1]|0}else{E=0}F=c[D+12>>2]|0;if((F|0)==0){H=160;i=k;return H|0}else{j=0}while(1){D=j+1|0;if((b[C+(j<<1)>>1]|0)==E<<16>>16){break a}if(D>>>0<F>>>0){j=D}else{A=160;break}}i=k;return A|0}}while(0);if((h|j|0)<0){H=160;i=k;return H|0}do{if((a[d+66|0]|0)!=0){D=c[d+8>>2]|0;C=c[c[D+156>>2]>>2]|0;E=qJ(C,2)|0;if((E|0)==0){H=c[C+88>>2]|0;c[H>>2]=h;b[H+4>>1]=514;c[H+8>>2]=0;c[H+12>>2]=0;c[H+32>>2]=j;b[H+36>>1]=2;c[H+40>>2]=f>>16;c[H+44>>2]=w>>16;c[D+128>>2]=2;c[D+132>>2]=c[C+52>>2];c[D+72>>2]=1668246896;c[C+84>>2]=2;break}else{H=E;i=k;return H|0}}}while(0);rJ(c[d+12>>2]|0);C=c[(c[g>>2]|0)+52>>2]|0;if((C|0)==0){A=AV((c[q+692>>2]|0)+1176|0,h,m,u)|0}else{H=sd[c[c[C>>2]>>2]&127](c[C+4>>2]|0,h,A)|0;c[o>>2]=c[B>>2];c[s>>2]=c[A+4>>2];A=H}do{if((A|0)==0){a[r]=1;C=c[s>>2]|0;A=LV(d,c[o>>2]|0,C)|0;a[r]=0;B=(c[g>>2]|0)+52|0;do{if((c[B>>2]|0)==0){y=c[q+692>>2]|0;if((c[y+1204>>2]|0)!=0){break}NK(c[y+1176>>2]|0,m)}else{c[y>>2]=c[o>>2];c[z+4>>2]=C;H=c[B>>2]|0;hd[c[(c[H>>2]|0)+4>>2]&127](c[H+4>>2]|0,z)}}while(0);if((A|0)==0){break}i=k;return A|0}}while(0);A=l;y=c[A>>2]|0;A=c[A+4>>2]|0;h=d+40|0;C=h;B=c[C>>2]|0;C=c[C+4>>2]|0;z=d+744|0;D=c[z>>2]|0;c[l>>2]=0;c[x>>2]=0;x=d+24|0;c[x>>2]=f-e;e=d+28|0;c[e>>2]=w;f=c[(c[g>>2]|0)+52>>2]|0;if((f|0)==0){t=AV((c[q+692>>2]|0)+1176|0,j,m,u)|0}else{H=sd[c[c[f>>2]>>2]&127](c[f+4>>2]|0,j,v)|0;c[o>>2]=c[t>>2];c[s>>2]=c[v+4>>2];t=H}do{if((t|0)==0){a[r]=1;s=c[s>>2]|0;d=LV(d,c[o>>2]|0,s)|0;a[r]=0;r=(c[g>>2]|0)+52|0;do{if((c[r>>2]|0)==0){n=c[q+692>>2]|0;if((c[n+1204>>2]|0)!=0){break}NK(c[n+1176>>2]|0,m)}else{c[n>>2]=c[o>>2];c[p+4>>2]=s;H=c[r>>2]|0;hd[c[(c[H>>2]|0)+4>>2]&127](c[H+4>>2]|0,p)}}while(0);if((d|0)==0){t=0;break}else{A=d}i=k;return A|0}}while(0);H=l;c[H>>2]=y;c[H+4>>2]=A;H=h;c[H>>2]=B;c[H+4>>2]=C;c[z>>2]=D;c[x>>2]=0;c[e>>2]=0;H=t;i=k;return H|0}function PV(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0;f=i;a=c[a+692>>2]|0;if((a|0)==0){j=0;i=f;return j|0}h=c[a+1452>>2]|0;if((h|0)==65535){j=6;i=f;return j|0}if((b|0)!=0){g=a+2064|0;j=c[g>>2]|0;if((j|0)==0){do{if(h>>>0>390){h=h+ -391|0;if((c[a+1312>>2]|0)>>>0<=h>>>0){j=0;break}j=c[(c[a+1316>>2]|0)+(h<<2)>>2]|0}else{j=c[a+2056>>2]|0;if((j|0)==0){j=0;break}j=jd[c[j+20>>2]&511](h)|0}}while(0);c[g>>2]=j}c[b>>2]=j}if((d|0)!=0){b=a+2068|0;g=c[b>>2]|0;if((g|0)==0){h=c[a+1456>>2]|0;do{if((h|0)==65535){g=0}else{if(h>>>0>390){g=h+ -391|0;if((c[a+1312>>2]|0)>>>0<=g>>>0){g=0;break}g=c[(c[a+1316>>2]|0)+(g<<2)>>2]|0;break}else{g=c[a+2056>>2]|0;if((g|0)==0){g=0;break}g=jd[c[g+20>>2]&511](h)|0;break}}}while(0);c[b>>2]=g}c[d>>2]=g}if((e|0)==0){j=0;i=f;return j|0}c[e>>2]=c[a+1460>>2];j=0;i=f;return j|0}function QV(b,d){b=b|0;d=d|0;var e=0;e=i;b=c[b+692>>2]|0;a[d]=0;if((b|0)==0){i=e;return 0}if((c[b+1452>>2]|0)==65535){i=e;return 0}a[d]=1;i=e;return 0}function RV(a,b,d){a=a|0;b=b|0;d=d|0;var f=0;f=i;a=c[a+692>>2]|0;do{if((a|0)==0){d=0}else{if((c[a+1452>>2]|0)==65535){d=6;break}if((c[a+12>>2]|0)>>>0<b>>>0){d=6;break}if((d|0)==0){d=0;break}c[d>>2]=e[(c[a+1160>>2]|0)+(b<<1)>>1]|0;d=0}}while(0);i=f;return d|0}function SV(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=i;e=c[(c[(c[a>>2]|0)+96>>2]|0)+4>>2]|0;c[b>>2]=0;c[b+4>>2]=0;f=c[a+12>>2]|0;if((f|0)==287048|(f|0)==287088){f=0;i=d;return f|0}e=oK(mK(e,287128)|0,290960)|0;if((e|0)==0){f=0;i=d;return f|0}e=c[e>>2]|0;if((e|0)==0){f=0;i=d;return f|0}f=Bd[e&255](a,b)|0;i=d;return f|0}function TV(a,d,e,f){a=a|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0;g=i;a=c[a+692>>2]|0;h=c[a+2056>>2]|0;if((h|0)==0){j=2;i=g;return j|0}d=b[(c[a+1160>>2]|0)+(d<<1)>>1]|0;j=d&65535;if(d<<16>>16==-1){j=0;i=g;return j|0}do{if((d&65535)>390){h=j+ -391|0;if((c[a+1312>>2]|0)>>>0>h>>>0){a=c[(c[a+1316>>2]|0)+(h<<2)>>2]|0;break}else{j=0;i=g;return j|0}}else{a=jd[c[h+20>>2]&511](j)|0}}while(0);if((a|0)==0){j=0;i=g;return j|0}bL(e,a,f)|0;j=0;i=g;return j|0}function UV(a,d){a=a|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;f=i;j=c[a+692>>2]|0;k=oK(c[a+96>>2]|0,287136)|0;if((k|0)==0){m=0;i=f;return m|0}h=j+12|0;if((c[h>>2]|0)==0){m=0;i=f;return m|0}g=j+1160|0;a=j+1312|0;j=j+1316|0;k=k+20|0;l=0;a:while(1){n=b[(c[g>>2]|0)+(l<<1)>>1]|0;m=n&65535;do{if((n&65535)>390){m=m+ -391|0;if((c[a>>2]|0)>>>0<=m>>>0){break}m=c[(c[j>>2]|0)+(m<<2)>>2]|0;e=8}else{m=jd[c[k>>2]&511](m)|0;e=8}}while(0);do{if((e|0)==8){e=0;if((m|0)==0){break}if((Qc(d|0,m|0)|0)==0){e=11;break a}}}while(0);l=l+1|0;if(l>>>0>=(c[h>>2]|0)>>>0){l=0;e=11;break}}if((e|0)==11){i=f;return l|0}return 0}function VV(a){a=a|0;i=i;return c[(c[a+692>>2]|0)+1304>>2]|0}function WV(d,e){d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0;g=i;f=i;i=i+8|0;h=c[d+692>>2]|0;c[f>>2]=0;if((h|0)==0){l=f;l=c[l>>2]|0;i=g;return l|0}j=h+2060|0;k=c[j>>2]|0;if((k|0)==0){k=jJ(c[d+100>>2]|0,32,f)|0;if((c[f>>2]|0)!=0){l=f;l=c[l>>2]|0;i=g;return l|0}d=c[h+1324>>2]|0;do{if((d|0)==65535){d=0}else{if(d>>>0>390){d=d+ -391|0;if((c[h+1312>>2]|0)>>>0<=d>>>0){d=0;break}d=c[(c[h+1316>>2]|0)+(d<<2)>>2]|0;break}else{l=c[h+2056>>2]|0;if((l|0)==0){d=0;break}d=jd[c[l+20>>2]&511](d)|0;break}}}while(0);c[k>>2]=d;d=c[h+1328>>2]|0;do{if((d|0)==65535){d=0}else{if(d>>>0>390){d=d+ -391|0;if((c[h+1312>>2]|0)>>>0<=d>>>0){d=0;break}d=c[(c[h+1316>>2]|0)+(d<<2)>>2]|0;break}else{l=c[h+2056>>2]|0;if((l|0)==0){d=0;break}d=jd[c[l+20>>2]&511](d)|0;break}}}while(0);c[k+4>>2]=d;d=c[h+1336>>2]|0;do{if((d|0)==65535){d=0}else{if(d>>>0>390){d=d+ -391|0;if((c[h+1312>>2]|0)>>>0<=d>>>0){d=0;break}d=c[(c[h+1316>>2]|0)+(d<<2)>>2]|0;break}else{l=c[h+2056>>2]|0;if((l|0)==0){d=0;break}d=jd[c[l+20>>2]&511](d)|0;break}}}while(0);c[k+8>>2]=d;d=c[h+1340>>2]|0;do{if((d|0)==65535){d=0}else{if(d>>>0>390){d=d+ -391|0;if((c[h+1312>>2]|0)>>>0<=d>>>0){d=0;break}d=c[(c[h+1316>>2]|0)+(d<<2)>>2]|0;break}else{l=c[h+2056>>2]|0;if((l|0)==0){d=0;break}d=jd[c[l+20>>2]&511](d)|0;break}}}while(0);c[k+12>>2]=d;l=c[h+1344>>2]|0;do{if((l|0)==65535){d=0}else{if(l>>>0>390){d=l+ -391|0;if((c[h+1312>>2]|0)>>>0<=d>>>0){d=0;break}d=c[(c[h+1316>>2]|0)+(d<<2)>>2]|0;break}else{d=c[h+2056>>2]|0;if((d|0)==0){d=0;break}d=jd[c[d+20>>2]&511](l)|0;break}}}while(0);c[k+16>>2]=d;c[k+20>>2]=c[h+1352>>2];a[k+24|0]=a[h+1348|0]|0;b[k+26>>1]=c[h+1356>>2];b[k+28>>1]=c[h+1360>>2];c[j>>2]=k}$W(e|0,k|0,32)|0;l=f;l=c[l>>2]|0;i=g;return l|0}function XV(a){a=a|0;i=i;return(c[a+8>>2]|0)>>>9&1|0}function YV(a){a=a|0;var b=0;b=i;bX(a|0,0,24)|0;i=b;return}function ZV(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;f=i;e=i;i=i+8|0;j=e;k=c[a>>2]|0;c[e>>2]=0;g=c[b+8>>2]|0;if((b|0)==(d|0)){m=0;i=f;return m|0}a=b+12|0;if((c[a>>2]|0)==0){$W(d|0,b|0,24)|0;m=0;i=f;return m|0}g=da(c[b>>2]|0,(g|0)<0?0-g|0:g)|0;h=d+12|0;l=c[h>>2]|0;do{if((l|0)==0){l=OK(k,g,j)|0;c[h>>2]=l}else{m=c[d+8>>2]|0;m=da((m|0)<0?0-m|0:m,c[d>>2]|0)|0;if((m|0)==(g|0)){break}l=$K(k,1,m,g,l,j)|0;c[h>>2]=l}}while(0);j=c[e>>2]|0;if((j|0)!=0){m=j;i=f;return m|0}$W(d|0,b|0,24)|0;c[h>>2]=l;$W(l|0,c[a>>2]|0,g|0)|0;m=c[e>>2]|0;i=f;return m|0}function _V(a,b){a=a|0;b=b|0;var d=0;d=i;if((a|0)==0){b=33;i=d;return b|0}if((b|0)==0){b=6;i=d;return b|0}lJ(c[a>>2]|0,c[b+12>>2]|0);bX(b|0,0,24)|0;b=0;i=d;return b|0}function $V(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;g=i;j=i;i=i+8|0;k=j;e=i;i=i+8|0;h=e;m=b+28|0;f=c[m>>2]|0;n=aW(b)|0;c[e>>2]=n;if((n|0)!=0){n=e;n=c[n>>2]|0;i=g;return n|0}bX(a|0,0,40)|0;n=a+28|0;c[n>>2]=f;d=OK(f,8276,h)|0;a:do{if((c[e>>2]|0)==0){l=d+12|0;c[d+4>>2]=a;c[d>>2]=b;c[d+8>>2]=c[n>>2];n=d+8264|0;c[d+8272>>2]=n;c[d+8268>>2]=n;c[n>>2]=0;n=aW(b)|0;do{if((n|0)==0){c[d+68>>2]=IK(b)|0;c[d+44>>2]=92;c[d+48>>2]=93;c[d+52>>2]=c[m>>2];c[d+16>>2]=0;c[l>>2]=d+4168;if((wc(l|0,-15,291008,56)|0)!=0){n=3;break}if((c[l>>2]|0)==0){n=3;break}c[e>>2]=0;c[a+12>>2]=d;break a}}while(0);c[e>>2]=n;lJ(f,d);n=e;n=c[n>>2]|0;i=g;return n|0}}while(0);l=c[b+8>>2]|0;do{if((PJ(b,(c[b+4>>2]|0)+ -4|0)|0)==0){k=GK(b,k)|0;j=(c[j>>2]|0)!=0?0:k;PJ(b,l)|0;if(!((j|0)!=0&j>>>0<40960)){break}b=jJ(f,j,h)|0;do{if((c[e>>2]|0)==0){if((bW(d,0,b,j)|0)!=(j|0)){bW(d,0,0,0)|0;lJ(f,b);break}Wc(d+12|0)|0;c[d+44>>2]=0;c[d+48>>2]=0;c[d+52>>2]=0;c[d+24>>2]=0;c[d+28>>2]=0;bX(d|0,0,20)|0;lJ(f,d);c[a+12>>2]=0;c[a+4>>2]=j;c[a+8>>2]=0;c[a>>2]=b;c[a+20>>2]=0;c[a+24>>2]=342;n=e;n=c[n>>2]|0;i=g;return n|0}}while(0);c[e>>2]=0}}while(0);c[a+4>>2]=2147483647;c[a+8>>2]=0;c[a>>2]=0;c[a+20>>2]=44;c[a+24>>2]=342;n=e;n=c[n>>2]|0;i=g;return n|0}function aW(b){b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;f=i;g=i;i=i+8|0;h=g;n=i;i=i+8|0;o=n;p=PJ(b,0)|0;c[g>>2]=p;if((p|0)!=0){i=f;return p|0}p=CK(b,o,4)|0;c[g>>2]=p;if((p|0)!=0){i=f;return p|0}do{if((a[n]|0)==31){if((a[o+1|0]|0)!=-117){break}if((a[o+2|0]|0)!=8){break}n=o+3|0;if((d[n]|0)>31){break}o=DK(b,6)|0;c[g>>2]=o;p=a[n]|0;do{if((p&4)!=0){p=WK(b,h)|0;o=c[g>>2]|0;if((o|0)!=0){p=o;i=f;return p|0}o=DK(b,p&65535)|0;c[g>>2]=o;if((o|0)==0){p=a[n]|0;o=0;break}else{p=o;i=f;return p|0}}}while(0);do{if((p&8)==0){m=o;l=p}else{while(1){o=VK(b,h)|0;p=c[g>>2]|0;if((p|0)!=0){k=p;o=22;break}if(o<<24>>24==0){o=15;break}}if((o|0)==15){m=0;l=a[n]|0;break}else if((o|0)==22){i=f;return k|0}}}while(0);do{if((l&16)==0){e=m;j=l}else{while(1){m=VK(b,h)|0;l=c[g>>2]|0;if((l|0)!=0){k=l;o=22;break}if(m<<24>>24==0){o=19;break}}if((o|0)==19){e=0;j=a[n]|0;break}else if((o|0)==22){i=f;return k|0}}}while(0);if((j&2)==0){p=e;i=f;return p|0}p=DK(b,2)|0;c[g>>2]=p;i=f;return p|0}}while(0);c[g>>2]=3;p=3;i=f;return p|0}function bW(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;f=i;g=a+8264|0;l=c[g>>2]|0;do{if(l>>>0>b>>>0){if((PJ(c[a>>2]|0,c[a+68>>2]|0)|0)==0){l=a+12|0;Va(l|0)|0;c[a+16>>2]=0;c[l>>2]=a+72;c[a+28>>2]=0;c[a+24>>2]=a+4168;l=a+8264|0;c[a+8272>>2]=l;c[a+8268>>2]=l;c[g>>2]=0;l=0;break}else{v=0;i=f;return v|0}}}while(0);do{if(l>>>0<b>>>0){s=b-l|0;j=a+8272|0;b=a+8268|0;m=c[b>>2]|0;n=(c[j>>2]|0)-m|0;t=n>>>0<s>>>0?n:s;c[b>>2]=m+t;c[g>>2]=t+l;a:do{if((t|0)!=(s|0)){o=a+12|0;q=a+4168|0;p=a+24|0;r=a+28|0;l=a+16|0;n=a+72|0;m=a+12|0;b:while(1){s=s-t|0;c[b>>2]=q;c[p>>2]=q;c[r>>2]=4096;while(1){if((c[l>>2]|0)==0){t=c[a>>2]|0;u=c[t+20>>2]|0;if((u|0)==0){u=c[t+8>>2]|0;v=(c[t+4>>2]|0)-u|0;v=v>>>0>4096?4096:v;if((v|0)==0){q=0;t=34;break b}$W(n|0,(c[t>>2]|0)+u|0,v|0)|0}else{v=pd[u&63](t,c[t+8>>2]|0,n,4096)|0;if((v|0)==0){q=0;t=34;break b}}u=t+8|0;c[u>>2]=(c[u>>2]|0)+v;c[m>>2]=n;c[l>>2]=v}t=_b(o|0,0)|0;if((t|0)==1){t=17;break}else if((t|0)!=0){q=0;t=34;break b}if((c[r>>2]|0)==0){t=7;break}}if((t|0)==7){h=c[b>>2]|0;k=c[j>>2]|0}else if((t|0)==17){k=c[p>>2]|0;c[j>>2]=k;h=c[b>>2]|0;if((k|0)==(h|0)){q=0;t=34;break}}t=k-h|0;t=t>>>0<s>>>0?t:s;c[b>>2]=h+t;c[g>>2]=t+(c[g>>2]|0);if((s|0)==(t|0)){break a}}if((t|0)==34){i=f;return q|0}}}while(0);if((e|0)==0){q=0}else{break}i=f;return q|0}else{if((e|0)==0){v=0;i=f;return v|0}else{j=a+8272|0;b=a+8268|0;break}}}while(0);p=a+12|0;l=a+4168|0;n=a+24|0;h=a+28|0;m=a+16|0;k=a+72|0;o=a+12|0;q=0;c:while(1){s=c[b>>2]|0;r=(c[j>>2]|0)-s|0;r=r>>>0<e>>>0?r:e;$W(d|0,s|0,r|0)|0;q=r+q|0;c[b>>2]=(c[b>>2]|0)+r;c[g>>2]=r+(c[g>>2]|0);if((e|0)==(r|0)){t=34;break}e=e-r|0;d=d+r|0;c[b>>2]=l;c[n>>2]=l;c[h>>2]=4096;while(1){if((c[m>>2]|0)==0){r=c[a>>2]|0;s=c[r+20>>2]|0;if((s|0)==0){s=c[r+8>>2]|0;t=(c[r+4>>2]|0)-s|0;t=t>>>0>4096?4096:t;if((t|0)==0){t=34;break c}$W(k|0,(c[r>>2]|0)+s|0,t|0)|0}else{t=pd[s&63](r,c[r+8>>2]|0,k,4096)|0;if((t|0)==0){t=34;break c}}v=r+8|0;c[v>>2]=(c[v>>2]|0)+t;c[o>>2]=k;c[m>>2]=t}r=_b(p|0,0)|0;if((r|0)==1){break}else if((r|0)!=0){t=34;break c}if((c[h>>2]|0)==0){continue c}}v=c[n>>2]|0;c[j>>2]=v;if((v|0)==(c[b>>2]|0)){t=34;break}}if((t|0)==34){i=f;return q|0}return 0}function cW(a){a=a|0;var b=0,d=0,e=0;b=i;e=a+12|0;d=c[e>>2]|0;if((d|0)==0){i=b;return}a=c[a+28>>2]|0;Wc(d+12|0)|0;c[d+44>>2]=0;c[d+48>>2]=0;c[d+52>>2]=0;c[d+24>>2]=0;c[d+28>>2]=0;bX(d|0,0,20)|0;lJ(a,d);c[e>>2]=0;i=b;return}function dW(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;a=bW(c[a+12>>2]|0,b,d,e)|0;i=f;return a|0}function eW(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=i;e=i;i=i+8|0;a=jJ(a,da(c,b)|0,e)|0;i=d;return a|0}function fW(a,b){a=a|0;b=b|0;var c=0;c=i;lJ(a,b);i=c;return}function gW(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;e=i;h=i;i=i+8|0;k=h;f=i;i=i+8|0;m=f;j=d+28|0;g=c[j>>2]|0;l=PJ(d,0)|0;do{if((l|0)==0){l=CK(d,k,2)|0;if((l|0)!=0){break}if((a[h]|0)!=31){l=3;break}l=k+1|0;if((a[l]|0)!=-99){l=3;break}c[f>>2]=0;bX(b|0,0,40)|0;n=b+28|0;c[n>>2]=g;m=jJ(g,4292,m)|0;o=c[f>>2]|0;a:do{if((o|0)==0){c[m+4>>2]=b;c[m>>2]=d;c[m+8>>2]=c[n>>2];n=m+4280|0;c[m+4288>>2]=n;c[m+4284>>2]=n;c[n>>2]=0;n=PJ(d,0)|0;do{if((n|0)==0){n=CK(d,k,2)|0;if((n|0)!=0){break}if((a[h]|0)!=31){n=3;break}if((a[l]|0)!=-99){n=3;break}o=m+12|0;bX(o|0,0,172)|0;c[m+176>>2]=d;c[m+180>>2]=c[j>>2];c[m+88>>2]=0;c[m+92>>2]=0;c[m+96>>2]=0;c[m+100>>2]=m+112;c[m+108>>2]=64;c[m+16>>2]=0;c[m+36>>2]=0;c[m+40>>2]=0;a[m+44|0]=0;c[m+48>>2]=0;c[m+104>>2]=0;c[m+64>>2]=9;c[o>>2]=0;c[f>>2]=0;c[b+12>>2]=m;o=0;break a}}while(0);c[f>>2]=n;lJ(g,m);o=c[f>>2]|0;i=e;return o|0}}while(0);c[b+4>>2]=2147483647;c[b+8>>2]=0;c[b>>2]=0;c[b+20>>2]=45;c[b+24>>2]=343;i=e;return o|0}}while(0);c[f>>2]=l;o=l;i=e;return o|0}function hW(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;g=i;h=c[b+12>>2]|0;b=h+4280|0;m=c[b>>2]|0;do{if(m>>>0>d>>>0){l=m-d|0;k=h+4284|0;j=c[k>>2]|0;if(l>>>0<=(j-(h+184)|0)>>>0){c[k>>2]=j+(0-l);c[b>>2]=d;j=12;break}if((PJ(c[h>>2]|0,0)|0)==0){c[h+16>>2]=0;c[h+36>>2]=0;c[h+40>>2]=0;a[h+44|0]=0;c[h+48>>2]=0;c[h+104>>2]=0;c[h+64>>2]=9;c[h+12>>2]=0;c[h+4288>>2]=b;c[k>>2]=b;c[b>>2]=0;m=0;j=6;break}else{o=0;i=g;return o|0}}else{j=6}}while(0);do{if((j|0)==6){if(m>>>0>=d>>>0){j=12;break}l=d-m|0;k=h+4288|0;d=h+4284|0;n=c[d>>2]|0;o=(c[k>>2]|0)-n|0;o=o>>>0<l>>>0?o:l;c[d>>2]=n+o;c[b>>2]=o+m;a:do{if((o|0)!=(l|0)){m=h+12|0;l=l-o|0;while(1){n=l>>>0<4096?l:4096;if((jW(m,0,n)|0)>>>0<n>>>0){o=0;break}c[b>>2]=(c[b>>2]|0)+n;if((l|0)==(n|0)){break a}else{l=l-n|0}}i=g;return o|0}}while(0);if((f|0)==0){o=0}else{break}i=g;return o|0}}while(0);do{if((j|0)==12){if((f|0)==0){o=0;i=g;return o|0}else{d=h+4284|0;k=h+4288|0;break}}}while(0);j=h+12|0;h=h+184|0;l=c[d>>2]|0;n=c[k>>2]|0;o=0;while(1){m=n-l|0;m=m>>>0<f>>>0?m:f;$W(e+o|0,l|0,m|0)|0;o=m+o|0;c[d>>2]=(c[d>>2]|0)+m;c[b>>2]=(c[b>>2]|0)+m;if((f|0)==(m|0)){j=17;break}c[d>>2]=h;p=jW(j,h,4096)|0;l=c[d>>2]|0;n=l+p|0;c[k>>2]=n;if((p|0)==0){j=17;break}else{f=f-m|0}}if((j|0)==17){i=g;return o|0}return 0}function iW(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;f=b+12|0;e=c[f>>2]|0;if((e|0)==0){i=d;return}b=c[b+28>>2]|0;g=c[e+180>>2]|0;c[e+16>>2]=0;c[e+36>>2]=0;c[e+40>>2]=0;a[e+44|0]=0;c[e+48>>2]=0;c[e+104>>2]=0;c[e+64>>2]=9;c[e+12>>2]=0;h=e+100|0;j=c[h>>2]|0;if((j|0)!=(e+112|0)){lJ(g,j);c[h>>2]=0}lJ(g,c[e+88>>2]|0);bX(e|0,0,184)|0;lJ(b,e);c[f>>2]=0;i=d;return}function jW(e,f,g){e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;k=i;o=i;i=i+8|0;n=o;r=i;i=i+8|0;t=r;m=i;i=i+8|0;p=m;q=i;i=i+8|0;s=q;y=i;i=i+8|0;u=y;l=e+68|0;w=c[l>>2]|0;h=e+64|0;v=c[h>>2]|0;j=e+72|0;x=c[j>>2]|0;if((g|0)==0){H=x;G=w;F=v;J=0;I=h;c[I>>2]=F;I=l;c[I>>2]=G;I=j;c[I>>2]=H;i=k;return J|0}z=c[e>>2]|0;do{if((z|0)==1){z=x;u=0;y=12}else if((z|0)==0){z=e+164|0;if((PJ(c[z>>2]|0,2)|0)!=0){g=0;y=55;break}if((KK(c[z>>2]|0,u,1)|0)!=1){g=0;y=55;break}z=d[y]|0;u=z&31;c[e+40>>2]=u;c[e+44>>2]=z&128;y=1<<u;c[e+48>>2]=y+ -256;if(u>>>0>16){g=0;y=55;break}c[e+52>>2]=9;c[e+56>>2]=z>>>7;c[e+60>>2]=u>>>0>9?256:y+ -255|0;u=kW(e)|0;if((u|0)<0){x=0;g=0;y=55;break}if((f|0)!=0){a[f]=u}if(g>>>0<2){H=0;G=u;F=u;J=1;I=h;c[I>>2]=F;I=l;c[I>>2]=G;I=j;c[I>>2]=H;i=k;return J|0}else{c[e>>2]=1;z=0;w=u;v=u;u=1;y=12;break}}else if((z|0)==2){z=e+92|0;B=e+88|0;u=0;y=39}else{H=x;G=w;F=v;J=0;I=h;c[I>>2]=F;I=l;c[I>>2]=G;I=j;c[I>>2]=H;i=k;return J|0}}while(0);a:while(1){if((y|0)==12){x=kW(e)|0;if((x|0)<0){x=z;g=u;y=55;continue}do{if((x|0)==256){if((c[e+44>>2]|0)==0){x=256;y=17;break}c[e+56>>2]=0;a[e+32|0]=1;x=kW(e)|0;if((x|0)<0){x=z;g=u;y=55;continue a}else{y=16}}else{y=16}}while(0);if((y|0)==16){y=0;if(x>>>0>255){y=17}else{A=x;w=x}}do{if((y|0)==17){if((x+ -256|0)>>>0<(c[e+56>>2]|0)>>>0){F=x}else{y=e+92|0;B=c[y>>2]|0;z=e+96|0;A=c[z>>2]|0;if(B>>>0>=A>>>0){C=c[e+168>>2]|0;B=A+4+(A>>>1)|0;D=e+88|0;E=c[D>>2]|0;if((E|0)==(e+100|0)){c[D>>2]=0;E=0;A=0}c[D>>2]=oJ(C,1,A,B,E,s)|0;if((c[q>>2]|0)!=0){g=u;y=55;continue a}c[z>>2]=B;B=c[y>>2]|0}c[y>>2]=B+1;a[(c[e+88>>2]|0)+B|0]=w;F=v}if(F>>>0<=255){A=x;w=F;break}C=e+76|0;A=e+92|0;z=e+96|0;E=e+80|0;B=e+88|0;D=e+168|0;y=e+100|0;G=c[C>>2]|0;while(1){if((G|0)==0){g=u;y=55;continue a}G=c[A>>2]|0;I=c[z>>2]|0;if(G>>>0>=I>>>0){H=c[D>>2]|0;G=I+4+(I>>>1)|0;J=c[B>>2]|0;if((J|0)==(y|0)){c[B>>2]=0;J=0;I=0}c[B>>2]=oJ(H,1,I,G,J,p)|0;if((c[m>>2]|0)!=0){g=u;y=55;continue a}c[z>>2]=G;G=c[A>>2]|0}J=F+ -256|0;F=a[(c[E>>2]|0)+J|0]|0;c[A>>2]=G+1;a[(c[B>>2]|0)+G|0]=F;G=c[C>>2]|0;J=b[G+(J<<1)>>1]|0;F=J&65535;if((J&65535)<=255){A=x;w=F;break}}}}while(0);z=e+92|0;y=c[z>>2]|0;x=e+96|0;C=c[x>>2]|0;if(y>>>0>=C>>>0){D=c[e+168>>2]|0;y=C+4+(C>>>1)|0;B=e+88|0;E=c[B>>2]|0;if((E|0)==(e+100|0)){c[B>>2]=0;E=0;C=0}c[B>>2]=oJ(D,1,C,y,E,t)|0;if((c[r>>2]|0)!=0){x=A;g=u;y=55;continue}c[x>>2]=y;y=c[z>>2]|0}c[z>>2]=y+1;B=e+88|0;a[(c[B>>2]|0)+y|0]=w;c[e>>2]=2;x=A;y=39;continue}else if((y|0)==39){b:do{if((f|0)==0){y=c[z>>2]|0;while(1){if((y|0)==0){break b}y=y+ -1|0;c[z>>2]=y;u=u+1|0;if((u|0)==(g|0)){y=54;break a}}}else{while(1){y=c[z>>2]|0;if((y|0)==0){break b}J=y+ -1|0;c[z>>2]=J;a[f+u|0]=a[(c[B>>2]|0)+J|0]|0;u=u+1|0;if((u|0)==(g|0)){y=54;break a}}}}while(0);y=e+56|0;z=c[y>>2]|0;if(z>>>0<(c[e+48>>2]|0)>>>0){A=e+84|0;B=c[A>>2]|0;if(z>>>0<B>>>0){A=z;z=e+76|0;B=e+80|0}else{if((B|0)==0){D=512}else{D=(B>>>2)+B|0}z=e+76|0;C=oJ(c[e+168>>2]|0,3,B,D,c[z>>2]|0,n)|0;c[z>>2]=C;if((c[o>>2]|0)!=0){g=u;y=55;continue}I=C+(D<<1)|0;J=e+80|0;c[J>>2]=I;aX(I|0,C+(B<<1)|0,B|0)|0;c[A>>2]=D;A=c[y>>2]|0;B=J}b[(c[z>>2]|0)+(A<<1)>>1]=v;a[(c[B>>2]|0)+(c[y>>2]|0)|0]=w;c[y>>2]=(c[y>>2]|0)+1}c[e>>2]=1;z=x;v=x;y=12;continue}else if((y|0)==55){c[e>>2]=3;y=54;break}}if((y|0)==54){J=h;c[J>>2]=v;J=l;c[J>>2]=w;J=j;c[J>>2]=x;i=k;return g|0}return 0}function kW(b){b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;e=i;g=b+52|0;l=c[g>>2]|0;f=b+24|0;m=c[f>>2]|0;h=b+32|0;j=(a[h]|0)==0;do{if(j){if((m|0)>=(c[b+28>>2]|0)){k=4;break}if((c[b+56>>2]|0)>>>0<(c[b+60>>2]|0)>>>0){h=l}else{k=4}}else{k=4}}while(0);do{if((k|0)==4){k=b+60|0;if((c[b+56>>2]|0)>>>0>=(c[k>>2]|0)>>>0){l=l+1|0;c[g>>2]=l;if(l>>>0<(c[b+40>>2]|0)>>>0){m=(1<<l)+ -256|0}else{m=(c[b+48>>2]|0)+1|0}c[k>>2]=m}if(j){h=l}else{c[g>>2]=9;c[k>>2]=256;a[h]=0;h=9}j=b+4|0;if((c[j>>2]|0)!=0){m=-1;i=e;return m|0}m=KK(c[b+164>>2]|0,b+8|0,h)|0;l=b+36|0;c[l>>2]=(c[l>>2]|0)+m;l=c[g>>2]|0;c[j>>2]=m>>>0<l>>>0;c[f>>2]=0;c[b+28>>2]=(m<<3|1)-l;if((m|0)==0){b=-1}else{m=0;break}i=e;return b|0}}while(0);c[f>>2]=m+h;f=m>>3;k=m&7;g=b+8+(f+1)|0;j=(d[b+8+f|0]|0)>>>k;k=8-k|0;l=h-k|0;if(l>>>0>7){l=l+ -8|0;h=k+8|0;b=b+8+(f+2)|0;j=d[g]<<k|j}else{h=k;b=g}if((l|0)==0){m=j;i=e;return m|0}m=(d[b]&(1<<l)+ -1)<<h|j;i=e;return m|0}function lW(a,b){a=+a;b=b|0;var c=0;c=i;a=+QW(a,b);i=c;return+a}function mW(a){a=a|0;i=i;return}function nW(a){a=a|0;i=i;return}function oW(a){a=a|0;i=i;return}function pW(a){a=a|0;i=i;return}function qW(a){a=a|0;var b=0;b=i;HW(a);i=b;return}function rW(a){a=a|0;var b=0;b=i;HW(a);i=b;return}function sW(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=i;f=i;i=i+56|0;g=f;if((a|0)==(b|0)){b=1;i=e;return b|0}if((b|0)==0){b=0;i=e;return b|0}b=vW(b,291080,291136,0)|0;if((b|0)==0){b=0;i=e;return b|0}bX(f|0,0,56)|0;c[f>>2]=b;c[g+8>>2]=a;c[g+12>>2]=-1;c[g+48>>2]=1;Jd[c[(c[b>>2]|0)+28>>2]&63](b,g,c[d>>2]|0,1);if((c[g+24>>2]|0)!=1){b=0;i=e;return b|0}c[d>>2]=c[g+16>>2];b=1;i=e;return b|0}function tW(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=i;if((c[d+8>>2]|0)!=(b|0)){i=g;return}b=d+16|0;h=c[b>>2]|0;if((h|0)==0){c[b>>2]=e;c[d+24>>2]=f;c[d+36>>2]=1;i=g;return}if((h|0)!=(e|0)){h=d+36|0;c[h>>2]=(c[h>>2]|0)+1;c[d+24>>2]=2;a[d+54|0]=1;i=g;return}e=d+24|0;if((c[e>>2]|0)!=2){i=g;return}c[e>>2]=f;i=g;return}function uW(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=i;if((b|0)!=(c[d+8>>2]|0)){h=c[b+8>>2]|0;Jd[c[(c[h>>2]|0)+28>>2]&63](h,d,e,f);i=g;return}b=d+16|0;h=c[b>>2]|0;if((h|0)==0){c[b>>2]=e;c[d+24>>2]=f;c[d+36>>2]=1;i=g;return}if((h|0)!=(e|0)){h=d+36|0;c[h>>2]=(c[h>>2]|0)+1;c[d+24>>2]=2;a[d+54|0]=1;i=g;return}e=d+24|0;if((c[e>>2]|0)!=2){i=g;return}c[e>>2]=f;i=g;return}function vW(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0;f=i;m=i;i=i+56|0;g=m;h=c[a>>2]|0;j=a+(c[h+ -8>>2]|0)|0;h=c[h+ -4>>2]|0;c[m>>2]=d;c[g+4>>2]=a;c[g+8>>2]=b;c[g+12>>2]=e;b=g+16|0;m=g+20|0;k=g+24|0;e=g+28|0;a=g+32|0;l=g+40|0;bX(b|0,0,39)|0;if((h|0)==(d|0)){c[g+48>>2]=1;ud[c[(c[h>>2]|0)+20>>2]&7](h,g,j,j,1,0);i=f;return((c[k>>2]|0)==1?j:0)|0}ed[c[(c[h>>2]|0)+24>>2]&3](h,g,j,1,0);d=c[g+36>>2]|0;if((d|0)==1){do{if((c[k>>2]|0)!=1){if((c[l>>2]|0)!=0){m=0;i=f;return m|0}if((c[e>>2]|0)!=1){m=0;i=f;return m|0}if((c[a>>2]|0)==1){break}else{d=0}i=f;return d|0}}while(0);m=c[b>>2]|0;i=f;return m|0}else if((d|0)==0){if((c[l>>2]|0)!=1){m=0;i=f;return m|0}if((c[e>>2]|0)!=1){m=0;i=f;return m|0}m=(c[a>>2]|0)==1?c[m>>2]|0:0;i=f;return m|0}else{m=0;i=f;return m|0}return 0}function wW(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0;h=i;if((b|0)==(c[d+8>>2]|0)){if((c[d+4>>2]|0)!=(e|0)){i=h;return}j=d+28|0;if((c[j>>2]|0)==1){i=h;return}c[j>>2]=f;i=h;return}if((b|0)!=(c[d>>2]|0)){l=c[b+8>>2]|0;ed[c[(c[l>>2]|0)+24>>2]&3](l,d,e,f,g);i=h;return}do{if((c[d+16>>2]|0)!=(e|0)){k=d+20|0;if((c[k>>2]|0)==(e|0)){break}c[d+32>>2]=f;f=d+44|0;if((c[f>>2]|0)==4){i=h;return}l=d+52|0;a[l]=0;m=d+53|0;a[m]=0;b=c[b+8>>2]|0;ud[c[(c[b>>2]|0)+20>>2]&7](b,d,e,e,1,g);if((a[m]&1)==0){b=0;j=13}else{if((a[l]&1)==0){b=1;j=13}}a:do{if((j|0)==13){c[k>>2]=e;m=d+40|0;c[m>>2]=(c[m>>2]|0)+1;do{if((c[d+36>>2]|0)==1){if((c[d+24>>2]|0)!=2){j=16;break}a[d+54|0]=1;if(b){break a}}else{j=16}}while(0);if((j|0)==16){if(b){break}}c[f>>2]=4;i=h;return}}while(0);c[f>>2]=3;i=h;return}}while(0);if((f|0)!=1){i=h;return}c[d+32>>2]=1;i=h;return}function xW(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;g=i;if((c[d+8>>2]|0)==(b|0)){if((c[d+4>>2]|0)!=(e|0)){i=g;return}d=d+28|0;if((c[d>>2]|0)==1){i=g;return}c[d>>2]=f;i=g;return}if((c[d>>2]|0)!=(b|0)){i=g;return}do{if((c[d+16>>2]|0)!=(e|0)){b=d+20|0;if((c[b>>2]|0)==(e|0)){break}c[d+32>>2]=f;c[b>>2]=e;b=d+40|0;c[b>>2]=(c[b>>2]|0)+1;do{if((c[d+36>>2]|0)==1){if((c[d+24>>2]|0)!=2){break}a[d+54|0]=1}}while(0);c[d+44>>2]=4;i=g;return}}while(0);if((f|0)!=1){i=g;return}c[d+32>>2]=1;i=g;return}function yW(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0;j=i;if((b|0)!=(c[d+8>>2]|0)){b=c[b+8>>2]|0;ud[c[(c[b>>2]|0)+20>>2]&7](b,d,e,f,g,h);i=j;return}a[d+53|0]=1;if((c[d+4>>2]|0)!=(f|0)){i=j;return}a[d+52|0]=1;b=d+16|0;f=c[b>>2]|0;if((f|0)==0){c[b>>2]=e;c[d+24>>2]=g;c[d+36>>2]=1;if(!((c[d+48>>2]|0)==1&(g|0)==1)){i=j;return}a[d+54|0]=1;i=j;return}if((f|0)!=(e|0)){h=d+36|0;c[h>>2]=(c[h>>2]|0)+1;a[d+54|0]=1;i=j;return}e=d+24|0;b=c[e>>2]|0;if((b|0)==2){c[e>>2]=g}else{g=b}if(!((c[d+48>>2]|0)==1&(g|0)==1)){i=j;return}a[d+54|0]=1;i=j;return}function zW(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;h=i;if((c[d+8>>2]|0)!=(b|0)){i=h;return}a[d+53|0]=1;if((c[d+4>>2]|0)!=(f|0)){i=h;return}a[d+52|0]=1;f=d+16|0;b=c[f>>2]|0;if((b|0)==0){c[f>>2]=e;c[d+24>>2]=g;c[d+36>>2]=1;if(!((c[d+48>>2]|0)==1&(g|0)==1)){i=h;return}a[d+54|0]=1;i=h;return}if((b|0)!=(e|0)){b=d+36|0;c[b>>2]=(c[b>>2]|0)+1;a[d+54|0]=1;i=h;return}e=d+24|0;f=c[e>>2]|0;if((f|0)==2){c[e>>2]=g}else{g=f}if(!((c[d+48>>2]|0)==1&(g|0)==1)){i=h;return}a[d+54|0]=1;i=h;return}function AW(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;b=i;do{if(a>>>0<245){if(a>>>0<11){a=16}else{a=a+11&-8}p=a>>>3;n=c[72822]|0;o=n>>>p;if((o&3|0)!=0){e=(o&1^1)+p|0;d=e<<1;h=291328+(d<<2)|0;d=291328+(d+2<<2)|0;f=c[d>>2]|0;g=f+8|0;j=c[g>>2]|0;do{if((h|0)==(j|0)){c[72822]=n&~(1<<e)}else{if(j>>>0<(c[291304>>2]|0)>>>0){tc()}k=j+12|0;if((c[k>>2]|0)==(f|0)){c[k>>2]=h;c[d>>2]=j;break}else{tc()}}}while(0);z=e<<3;c[f+4>>2]=z|3;z=f+(z|4)|0;c[z>>2]=c[z>>2]|1;z=g;i=b;return z|0}if(a>>>0<=(c[291296>>2]|0)>>>0){break}if((o|0)!=0){f=2<<p;f=o<<p&(f|0-f);f=(f&0-f)+ -1|0;d=f>>>12&16;f=f>>>d;h=f>>>5&8;f=f>>>h;g=f>>>2&4;f=f>>>g;j=f>>>1&2;f=f>>>j;e=f>>>1&1;e=(h|d|g|j|e)+(f>>>e)|0;f=e<<1;j=291328+(f<<2)|0;f=291328+(f+2<<2)|0;g=c[f>>2]|0;d=g+8|0;h=c[d>>2]|0;do{if((j|0)==(h|0)){c[72822]=n&~(1<<e)}else{if(h>>>0<(c[291304>>2]|0)>>>0){tc()}k=h+12|0;if((c[k>>2]|0)==(g|0)){c[k>>2]=j;c[f>>2]=h;break}else{tc()}}}while(0);h=e<<3;e=h-a|0;c[g+4>>2]=a|3;f=g+a|0;c[g+(a|4)>>2]=e|1;c[g+h>>2]=e;h=c[291296>>2]|0;if((h|0)!=0){g=c[291308>>2]|0;k=h>>>3;l=k<<1;h=291328+(l<<2)|0;j=c[72822]|0;k=1<<k;do{if((j&k|0)==0){c[72822]=j|k;v=h;u=291328+(l+2<<2)|0}else{k=291328+(l+2<<2)|0;j=c[k>>2]|0;if(j>>>0>=(c[291304>>2]|0)>>>0){v=j;u=k;break}tc()}}while(0);c[u>>2]=g;c[v+12>>2]=g;c[g+8>>2]=v;c[g+12>>2]=h}c[291296>>2]=e;c[291308>>2]=f;z=d;i=b;return z|0}n=c[291292>>2]|0;if((n|0)==0){break}e=(n&0-n)+ -1|0;y=e>>>12&16;e=e>>>y;x=e>>>5&8;e=e>>>x;z=e>>>2&4;e=e>>>z;h=e>>>1&2;e=e>>>h;d=e>>>1&1;d=c[291592+((x|y|z|h|d)+(e>>>d)<<2)>>2]|0;e=(c[d+4>>2]&-8)-a|0;h=d;while(1){g=c[h+16>>2]|0;if((g|0)==0){g=c[h+20>>2]|0;if((g|0)==0){break}}h=(c[g+4>>2]&-8)-a|0;f=h>>>0<e>>>0;e=f?h:e;h=g;d=f?g:d}h=c[291304>>2]|0;if(d>>>0<h>>>0){tc()}f=d+a|0;if(d>>>0>=f>>>0){tc()}g=c[d+24>>2]|0;j=c[d+12>>2]|0;do{if((j|0)==(d|0)){j=d+20|0;k=c[j>>2]|0;if((k|0)==0){j=d+16|0;k=c[j>>2]|0;if((k|0)==0){t=0;break}}while(1){l=k+20|0;m=c[l>>2]|0;if((m|0)!=0){k=m;j=l;continue}m=k+16|0;l=c[m>>2]|0;if((l|0)==0){break}else{j=m;k=l}}if(j>>>0<h>>>0){tc()}else{c[j>>2]=0;t=k;break}}else{k=c[d+8>>2]|0;if(k>>>0<h>>>0){tc()}h=k+12|0;if((c[h>>2]|0)!=(d|0)){tc()}l=j+8|0;if((c[l>>2]|0)==(d|0)){c[h>>2]=j;c[l>>2]=k;t=j;break}else{tc()}}}while(0);a:do{if((g|0)!=0){j=d+28|0;h=291592+(c[j>>2]<<2)|0;do{if((d|0)==(c[h>>2]|0)){c[h>>2]=t;if((t|0)!=0){break}c[291292>>2]=c[291292>>2]&~(1<<c[j>>2]);break a}else{if(g>>>0<(c[291304>>2]|0)>>>0){tc()}h=g+16|0;if((c[h>>2]|0)==(d|0)){c[h>>2]=t}else{c[g+20>>2]=t}if((t|0)==0){break a}}}while(0);if(t>>>0<(c[291304>>2]|0)>>>0){tc()}c[t+24>>2]=g;g=c[d+16>>2]|0;do{if((g|0)!=0){if(g>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[t+16>>2]=g;c[g+24>>2]=t;break}}}while(0);g=c[d+20>>2]|0;if((g|0)==0){break}if(g>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[t+20>>2]=g;c[g+24>>2]=t;break}}}while(0);if(e>>>0<16){z=e+a|0;c[d+4>>2]=z|3;z=d+(z+4)|0;c[z>>2]=c[z>>2]|1}else{c[d+4>>2]=a|3;c[d+(a|4)>>2]=e|1;c[d+(e+a)>>2]=e;h=c[291296>>2]|0;if((h|0)!=0){g=c[291308>>2]|0;k=h>>>3;l=k<<1;h=291328+(l<<2)|0;j=c[72822]|0;k=1<<k;do{if((j&k|0)==0){c[72822]=j|k;s=h;r=291328+(l+2<<2)|0}else{j=291328+(l+2<<2)|0;k=c[j>>2]|0;if(k>>>0>=(c[291304>>2]|0)>>>0){s=k;r=j;break}tc()}}while(0);c[r>>2]=g;c[s+12>>2]=g;c[g+8>>2]=s;c[g+12>>2]=h}c[291296>>2]=e;c[291308>>2]=f}z=d+8|0;i=b;return z|0}else{if(a>>>0>4294967231){a=-1;break}r=a+11|0;a=r&-8;t=c[291292>>2]|0;if((t|0)==0){break}s=0-a|0;r=r>>>8;do{if((r|0)==0){u=0}else{if(a>>>0>16777215){u=31;break}y=(r+1048320|0)>>>16&8;z=r<<y;x=(z+520192|0)>>>16&4;z=z<<x;u=(z+245760|0)>>>16&2;u=14-(x|y|u)+(z<<u>>>15)|0;u=a>>>(u+7|0)&1|u<<1}}while(0);x=c[291592+(u<<2)>>2]|0;b:do{if((x|0)==0){v=0;r=0}else{if((u|0)==31){r=0}else{r=25-(u>>>1)|0}v=0;w=a<<r;r=0;while(1){y=c[x+4>>2]&-8;z=y-a|0;if(z>>>0<s>>>0){if((y|0)==(a|0)){s=z;v=x;r=x;break b}else{s=z;r=x}}y=c[x+20>>2]|0;x=c[x+16+(w>>>31<<2)>>2]|0;v=(y|0)==0|(y|0)==(x|0)?v:y;if((x|0)==0){break}else{w=w<<1}}}}while(0);if((v|0)==0&(r|0)==0){z=2<<u;t=t&(z|0-z);if((t|0)==0){break}z=(t&0-t)+ -1|0;w=z>>>12&16;z=z>>>w;u=z>>>5&8;z=z>>>u;x=z>>>2&4;z=z>>>x;y=z>>>1&2;z=z>>>y;v=z>>>1&1;v=c[291592+((u|w|x|y|v)+(z>>>v)<<2)>>2]|0}if((v|0)!=0){while(1){u=(c[v+4>>2]&-8)-a|0;t=u>>>0<s>>>0;s=t?u:s;r=t?v:r;t=c[v+16>>2]|0;if((t|0)!=0){v=t;continue}v=c[v+20>>2]|0;if((v|0)==0){break}}}if((r|0)==0){break}if(s>>>0>=((c[291296>>2]|0)-a|0)>>>0){break}f=c[291304>>2]|0;if(r>>>0<f>>>0){tc()}d=r+a|0;if(r>>>0>=d>>>0){tc()}e=c[r+24>>2]|0;g=c[r+12>>2]|0;do{if((g|0)==(r|0)){g=r+20|0;h=c[g>>2]|0;if((h|0)==0){g=r+16|0;h=c[g>>2]|0;if((h|0)==0){q=0;break}}while(1){k=h+20|0;j=c[k>>2]|0;if((j|0)!=0){h=j;g=k;continue}j=h+16|0;k=c[j>>2]|0;if((k|0)==0){break}else{g=j;h=k}}if(g>>>0<f>>>0){tc()}else{c[g>>2]=0;q=h;break}}else{h=c[r+8>>2]|0;if(h>>>0<f>>>0){tc()}j=h+12|0;if((c[j>>2]|0)!=(r|0)){tc()}f=g+8|0;if((c[f>>2]|0)==(r|0)){c[j>>2]=g;c[f>>2]=h;q=g;break}else{tc()}}}while(0);c:do{if((e|0)!=0){g=r+28|0;f=291592+(c[g>>2]<<2)|0;do{if((r|0)==(c[f>>2]|0)){c[f>>2]=q;if((q|0)!=0){break}c[291292>>2]=c[291292>>2]&~(1<<c[g>>2]);break c}else{if(e>>>0<(c[291304>>2]|0)>>>0){tc()}f=e+16|0;if((c[f>>2]|0)==(r|0)){c[f>>2]=q}else{c[e+20>>2]=q}if((q|0)==0){break c}}}while(0);if(q>>>0<(c[291304>>2]|0)>>>0){tc()}c[q+24>>2]=e;e=c[r+16>>2]|0;do{if((e|0)!=0){if(e>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[q+16>>2]=e;c[e+24>>2]=q;break}}}while(0);e=c[r+20>>2]|0;if((e|0)==0){break}if(e>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[q+20>>2]=e;c[e+24>>2]=q;break}}}while(0);d:do{if(s>>>0<16){z=s+a|0;c[r+4>>2]=z|3;z=r+(z+4)|0;c[z>>2]=c[z>>2]|1}else{c[r+4>>2]=a|3;c[r+(a|4)>>2]=s|1;c[r+(s+a)>>2]=s;f=s>>>3;if(s>>>0<256){h=f<<1;e=291328+(h<<2)|0;g=c[72822]|0;f=1<<f;do{if((g&f|0)==0){c[72822]=g|f;o=e;p=291328+(h+2<<2)|0}else{f=291328+(h+2<<2)|0;g=c[f>>2]|0;if(g>>>0>=(c[291304>>2]|0)>>>0){o=g;p=f;break}tc()}}while(0);c[p>>2]=d;c[o+12>>2]=d;c[r+(a+8)>>2]=o;c[r+(a+12)>>2]=e;break}e=s>>>8;do{if((e|0)==0){e=0}else{if(s>>>0>16777215){e=31;break}y=(e+1048320|0)>>>16&8;z=e<<y;x=(z+520192|0)>>>16&4;z=z<<x;e=(z+245760|0)>>>16&2;e=14-(x|y|e)+(z<<e>>>15)|0;e=s>>>(e+7|0)&1|e<<1}}while(0);f=291592+(e<<2)|0;c[r+(a+28)>>2]=e;c[r+(a+20)>>2]=0;c[r+(a+16)>>2]=0;h=c[291292>>2]|0;g=1<<e;if((h&g|0)==0){c[291292>>2]=h|g;c[f>>2]=d;c[r+(a+24)>>2]=f;c[r+(a+12)>>2]=d;c[r+(a+8)>>2]=d;break}f=c[f>>2]|0;if((e|0)==31){e=0}else{e=25-(e>>>1)|0}e:do{if((c[f+4>>2]&-8|0)==(s|0)){n=f}else{e=s<<e;while(1){g=f+16+(e>>>31<<2)|0;h=c[g>>2]|0;if((h|0)==0){break}if((c[h+4>>2]&-8|0)==(s|0)){n=h;break e}else{e=e<<1;f=h}}if(g>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[g>>2]=d;c[r+(a+24)>>2]=f;c[r+(a+12)>>2]=d;c[r+(a+8)>>2]=d;break d}}}while(0);g=n+8|0;f=c[g>>2]|0;e=c[291304>>2]|0;if(n>>>0<e>>>0){tc()}if(f>>>0<e>>>0){tc()}else{c[f+12>>2]=d;c[g>>2]=d;c[r+(a+8)>>2]=f;c[r+(a+12)>>2]=n;c[r+(a+24)>>2]=0;break}}}while(0);z=r+8|0;i=b;return z|0}}while(0);n=c[291296>>2]|0;if(a>>>0<=n>>>0){d=n-a|0;e=c[291308>>2]|0;if(d>>>0>15){c[291308>>2]=e+a;c[291296>>2]=d;c[e+(a+4)>>2]=d|1;c[e+n>>2]=d;c[e+4>>2]=a|3}else{c[291296>>2]=0;c[291308>>2]=0;c[e+4>>2]=n|3;z=e+(n+4)|0;c[z>>2]=c[z>>2]|1}z=e+8|0;i=b;return z|0}n=c[291300>>2]|0;if(a>>>0<n>>>0){y=n-a|0;c[291300>>2]=y;z=c[291312>>2]|0;c[291312>>2]=z+a;c[z+(a+4)>>2]=y|1;c[z+4>>2]=a|3;z=z+8|0;i=b;return z|0}do{if((c[72940]|0)==0){n=bb(30)|0;if((n+ -1&n|0)==0){c[291768>>2]=n;c[291764>>2]=n;c[291772>>2]=-1;c[291776>>2]=-1;c[291780>>2]=0;c[291732>>2]=0;c[72940]=(Tb(0)|0)&-16^1431655768;break}else{tc()}}}while(0);r=a+48|0;t=c[291768>>2]|0;q=a+47|0;s=t+q|0;t=0-t|0;p=s&t;if(p>>>0<=a>>>0){z=0;i=b;return z|0}n=c[291728>>2]|0;do{if((n|0)!=0){y=c[291720>>2]|0;z=y+p|0;if(z>>>0<=y>>>0|z>>>0>n>>>0){d=0}else{break}i=b;return d|0}}while(0);f:do{if((c[291732>>2]&4|0)==0){u=c[291312>>2]|0;g:do{if((u|0)==0){m=182}else{n=291736|0;while(1){v=c[n>>2]|0;if(v>>>0<=u>>>0){o=n+4|0;if((v+(c[o>>2]|0)|0)>>>0>u>>>0){break}}n=c[n+8>>2]|0;if((n|0)==0){m=182;break g}}if((n|0)==0){m=182;break}u=s-(c[291300>>2]|0)&t;if(u>>>0>=2147483647){o=0;break}m=ab(u|0)|0;o=(m|0)==((c[n>>2]|0)+(c[o>>2]|0)|0);s=m;t=u;n=o?m:-1;o=o?u:0;m=191}}while(0);do{if((m|0)==182){n=ab(0)|0;if((n|0)==-1){o=0;break}o=c[291764>>2]|0;s=o+ -1|0;if((s&n|0)==0){o=p}else{o=p-n+(s+n&0-o)|0}s=c[291720>>2]|0;t=s+o|0;if(!(o>>>0>a>>>0&o>>>0<2147483647)){o=0;break}u=c[291728>>2]|0;if((u|0)!=0){if(t>>>0<=s>>>0|t>>>0>u>>>0){o=0;break}}s=ab(o|0)|0;m=(s|0)==(n|0);t=o;n=m?n:-1;o=m?o:0;m=191}}while(0);h:do{if((m|0)==191){m=0-t|0;if((n|0)!=-1){m=202;break f}do{if((s|0)!=-1&t>>>0<2147483647&t>>>0<r>>>0){n=c[291768>>2]|0;n=q-t+n&0-n;if(n>>>0>=2147483647){break}if((ab(n|0)|0)==-1){ab(m|0)|0;break h}else{t=n+t|0;break}}}while(0);if((s|0)!=-1){n=s;o=t;m=202;break f}}}while(0);c[291732>>2]=c[291732>>2]|4;m=199}else{o=0;m=199}}while(0);do{if((m|0)==199){if(p>>>0>=2147483647){break}n=ab(p|0)|0;p=ab(0)|0;if(!((p|0)!=-1&(n|0)!=-1&n>>>0<p>>>0)){break}q=p-n|0;p=q>>>0>(a+40|0)>>>0;if(p){o=p?q:o;m=202}}}while(0);do{if((m|0)==202){p=(c[291720>>2]|0)+o|0;c[291720>>2]=p;if(p>>>0>(c[291724>>2]|0)>>>0){c[291724>>2]=p}p=c[291312>>2]|0;t=291736|0;i:do{if((p|0)==0){z=c[291304>>2]|0;if((z|0)==0|n>>>0<z>>>0){c[291304>>2]=n}c[291736>>2]=n;c[291740>>2]=o;c[291748>>2]=0;c[291324>>2]=c[72940];c[291320>>2]=-1;d=0;do{z=d<<1;y=291328+(z<<2)|0;c[291328+(z+3<<2)>>2]=y;c[291328+(z+2<<2)>>2]=y;d=d+1|0;}while(d>>>0<32);d=n+8|0;if((d&7|0)==0){d=0}else{d=0-d&7}z=o+ -40-d|0;c[291312>>2]=n+d;c[291300>>2]=z;c[n+(d+4)>>2]=z|1;c[n+(o+ -36)>>2]=40;c[291316>>2]=c[291776>>2]}else{do{q=c[t>>2]|0;r=t+4|0;s=c[r>>2]|0;if((n|0)==(q+s|0)){m=214;break}t=c[t+8>>2]|0;}while((t|0)!=0);do{if((m|0)==214){if((c[t+12>>2]&8|0)!=0){break}if(!(p>>>0>=q>>>0&p>>>0<n>>>0)){break}c[r>>2]=s+o;d=c[291312>>2]|0;e=(c[291300>>2]|0)+o|0;f=d+8|0;if((f&7|0)==0){f=0}else{f=0-f&7}z=e-f|0;c[291312>>2]=d+f;c[291300>>2]=z;c[d+(f+4)>>2]=z|1;c[d+(e+4)>>2]=40;c[291316>>2]=c[291776>>2];break i}}while(0);if(n>>>0<(c[291304>>2]|0)>>>0){c[291304>>2]=n}q=n+o|0;r=291736|0;do{if((c[r>>2]|0)==(q|0)){m=224;break}r=c[r+8>>2]|0;}while((r|0)!=0);do{if((m|0)==224){if((c[r+12>>2]&8|0)!=0){break}c[r>>2]=n;h=r+4|0;c[h>>2]=(c[h>>2]|0)+o;h=n+8|0;if((h&7|0)==0){h=0}else{h=0-h&7}j=n+(o+8)|0;if((j&7|0)==0){p=0}else{p=0-j&7}q=n+(p+o)|0;k=h+a|0;j=n+k|0;m=q-(n+h)-a|0;c[n+(h+4)>>2]=a|3;j:do{if((q|0)==(c[291312>>2]|0)){z=(c[291300>>2]|0)+m|0;c[291300>>2]=z;c[291312>>2]=j;c[n+(k+4)>>2]=z|1}else{if((q|0)==(c[291308>>2]|0)){z=(c[291296>>2]|0)+m|0;c[291296>>2]=z;c[291308>>2]=j;c[n+(k+4)>>2]=z|1;c[n+(z+k)>>2]=z;break}r=o+4|0;t=c[n+(r+p)>>2]|0;if((t&3|0)==1){a=t&-8;s=t>>>3;k:do{if(t>>>0<256){g=c[n+((p|8)+o)>>2]|0;r=c[n+(o+12+p)>>2]|0;t=291328+(s<<1<<2)|0;do{if((g|0)!=(t|0)){if(g>>>0<(c[291304>>2]|0)>>>0){tc()}if((c[g+12>>2]|0)==(q|0)){break}tc()}}while(0);if((r|0)==(g|0)){c[72822]=c[72822]&~(1<<s);break}do{if((r|0)==(t|0)){l=r+8|0}else{if(r>>>0<(c[291304>>2]|0)>>>0){tc()}s=r+8|0;if((c[s>>2]|0)==(q|0)){l=s;break}tc()}}while(0);c[g+12>>2]=r;c[l>>2]=g}else{l=c[n+((p|24)+o)>>2]|0;t=c[n+(o+12+p)>>2]|0;do{if((t|0)==(q|0)){u=p|16;s=n+(r+u)|0;t=c[s>>2]|0;if((t|0)==0){s=n+(u+o)|0;t=c[s>>2]|0;if((t|0)==0){g=0;break}}while(1){v=t+20|0;u=c[v>>2]|0;if((u|0)!=0){t=u;s=v;continue}u=t+16|0;v=c[u>>2]|0;if((v|0)==0){break}else{s=u;t=v}}if(s>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[s>>2]=0;g=t;break}}else{v=c[n+((p|8)+o)>>2]|0;if(v>>>0<(c[291304>>2]|0)>>>0){tc()}s=v+12|0;if((c[s>>2]|0)!=(q|0)){tc()}u=t+8|0;if((c[u>>2]|0)==(q|0)){c[s>>2]=t;c[u>>2]=v;g=t;break}else{tc()}}}while(0);if((l|0)==0){break}s=n+(o+28+p)|0;t=291592+(c[s>>2]<<2)|0;do{if((q|0)==(c[t>>2]|0)){c[t>>2]=g;if((g|0)!=0){break}c[291292>>2]=c[291292>>2]&~(1<<c[s>>2]);break k}else{if(l>>>0<(c[291304>>2]|0)>>>0){tc()}s=l+16|0;if((c[s>>2]|0)==(q|0)){c[s>>2]=g}else{c[l+20>>2]=g}if((g|0)==0){break k}}}while(0);if(g>>>0<(c[291304>>2]|0)>>>0){tc()}c[g+24>>2]=l;q=p|16;l=c[n+(q+o)>>2]|0;do{if((l|0)!=0){if(l>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[g+16>>2]=l;c[l+24>>2]=g;break}}}while(0);l=c[n+(r+q)>>2]|0;if((l|0)==0){break}if(l>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[g+20>>2]=l;c[l+24>>2]=g;break}}}while(0);q=n+((a|p)+o)|0;m=a+m|0}g=q+4|0;c[g>>2]=c[g>>2]&-2;c[n+(k+4)>>2]=m|1;c[n+(m+k)>>2]=m;g=m>>>3;if(m>>>0<256){l=g<<1;d=291328+(l<<2)|0;a=c[72822]|0;g=1<<g;do{if((a&g|0)==0){c[72822]=a|g;f=d;e=291328+(l+2<<2)|0}else{g=291328+(l+2<<2)|0;l=c[g>>2]|0;if(l>>>0>=(c[291304>>2]|0)>>>0){f=l;e=g;break}tc()}}while(0);c[e>>2]=j;c[f+12>>2]=j;c[n+(k+8)>>2]=f;c[n+(k+12)>>2]=d;break}e=m>>>8;do{if((e|0)==0){e=0}else{if(m>>>0>16777215){e=31;break}y=(e+1048320|0)>>>16&8;z=e<<y;x=(z+520192|0)>>>16&4;z=z<<x;e=(z+245760|0)>>>16&2;e=14-(x|y|e)+(z<<e>>>15)|0;e=m>>>(e+7|0)&1|e<<1}}while(0);l=291592+(e<<2)|0;c[n+(k+28)>>2]=e;c[n+(k+20)>>2]=0;c[n+(k+16)>>2]=0;f=c[291292>>2]|0;g=1<<e;if((f&g|0)==0){c[291292>>2]=f|g;c[l>>2]=j;c[n+(k+24)>>2]=l;c[n+(k+12)>>2]=j;c[n+(k+8)>>2]=j;break}g=c[l>>2]|0;if((e|0)==31){e=0}else{e=25-(e>>>1)|0}l:do{if((c[g+4>>2]&-8|0)==(m|0)){d=g}else{e=m<<e;while(1){f=g+16+(e>>>31<<2)|0;l=c[f>>2]|0;if((l|0)==0){break}if((c[l+4>>2]&-8|0)==(m|0)){d=l;break l}else{e=e<<1;g=l}}if(f>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[f>>2]=j;c[n+(k+24)>>2]=g;c[n+(k+12)>>2]=j;c[n+(k+8)>>2]=j;break j}}}while(0);f=d+8|0;e=c[f>>2]|0;g=c[291304>>2]|0;if(d>>>0<g>>>0){tc()}if(e>>>0<g>>>0){tc()}else{c[e+12>>2]=j;c[f>>2]=j;c[n+(k+8)>>2]=e;c[n+(k+12)>>2]=d;c[n+(k+24)>>2]=0;break}}}while(0);z=n+(h|8)|0;i=b;return z|0}}while(0);g=291736|0;while(1){e=c[g>>2]|0;if(e>>>0<=p>>>0){f=c[g+4>>2]|0;d=e+f|0;if(d>>>0>p>>>0){break}}g=c[g+8>>2]|0}g=e+(f+ -39)|0;if((g&7|0)==0){g=0}else{g=0-g&7}e=e+(f+ -47+g)|0;e=e>>>0<(p+16|0)>>>0?p:e;f=e+8|0;g=n+8|0;if((g&7|0)==0){g=0}else{g=0-g&7}z=o+ -40-g|0;c[291312>>2]=n+g;c[291300>>2]=z;c[n+(g+4)>>2]=z|1;c[n+(o+ -36)>>2]=40;c[291316>>2]=c[291776>>2];c[e+4>>2]=27;$W(f|0,291736|0,16)|0;c[291736>>2]=n;c[291740>>2]=o;c[291748>>2]=0;c[291744>>2]=f;f=e+28|0;c[f>>2]=7;if((e+32|0)>>>0<d>>>0){while(1){g=f+4|0;c[g>>2]=7;if((f+8|0)>>>0<d>>>0){f=g}else{break}}}if((e|0)==(p|0)){break}d=e-p|0;e=p+(d+4)|0;c[e>>2]=c[e>>2]&-2;c[p+4>>2]=d|1;c[p+d>>2]=d;e=d>>>3;if(d>>>0<256){g=e<<1;d=291328+(g<<2)|0;f=c[72822]|0;e=1<<e;do{if((f&e|0)==0){c[72822]=f|e;k=d;j=291328+(g+2<<2)|0}else{f=291328+(g+2<<2)|0;e=c[f>>2]|0;if(e>>>0>=(c[291304>>2]|0)>>>0){k=e;j=f;break}tc()}}while(0);c[j>>2]=p;c[k+12>>2]=p;c[p+8>>2]=k;c[p+12>>2]=d;break}e=d>>>8;do{if((e|0)==0){e=0}else{if(d>>>0>16777215){e=31;break}y=(e+1048320|0)>>>16&8;z=e<<y;x=(z+520192|0)>>>16&4;z=z<<x;e=(z+245760|0)>>>16&2;e=14-(x|y|e)+(z<<e>>>15)|0;e=d>>>(e+7|0)&1|e<<1}}while(0);j=291592+(e<<2)|0;c[p+28>>2]=e;c[p+20>>2]=0;c[p+16>>2]=0;f=c[291292>>2]|0;g=1<<e;if((f&g|0)==0){c[291292>>2]=f|g;c[j>>2]=p;c[p+24>>2]=j;c[p+12>>2]=p;c[p+8>>2]=p;break}f=c[j>>2]|0;if((e|0)==31){e=0}else{e=25-(e>>>1)|0}m:do{if((c[f+4>>2]&-8|0)==(d|0)){h=f}else{e=d<<e;j=f;while(1){f=j+16+(e>>>31<<2)|0;g=c[f>>2]|0;if((g|0)==0){break}if((c[g+4>>2]&-8|0)==(d|0)){h=g;break m}else{e=e<<1;j=g}}if(f>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[f>>2]=p;c[p+24>>2]=j;c[p+12>>2]=p;c[p+8>>2]=p;break i}}}while(0);e=h+8|0;d=c[e>>2]|0;f=c[291304>>2]|0;if(h>>>0<f>>>0){tc()}if(d>>>0<f>>>0){tc()}else{c[d+12>>2]=p;c[e>>2]=p;c[p+8>>2]=d;c[p+12>>2]=h;c[p+24>>2]=0;break}}}while(0);d=c[291300>>2]|0;if(d>>>0<=a>>>0){break}y=d-a|0;c[291300>>2]=y;z=c[291312>>2]|0;c[291312>>2]=z+a;c[z+(a+4)>>2]=y|1;c[z+4>>2]=a|3;z=z+8|0;i=b;return z|0}}while(0);c[(Pc()|0)>>2]=12;z=0;i=b;return z|0}function BW(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;b=i;if((a|0)==0){i=b;return}q=a+ -8|0;r=c[291304>>2]|0;if(q>>>0<r>>>0){tc()}o=c[a+ -4>>2]|0;m=o&3;if((m|0)==1){tc()}j=o&-8;h=a+(j+ -8)|0;a:do{if((o&1|0)==0){u=c[q>>2]|0;if((m|0)==0){i=b;return}q=-8-u|0;m=a+q|0;o=u+j|0;if(m>>>0<r>>>0){tc()}if((m|0)==(c[291308>>2]|0)){d=a+(j+ -4)|0;if((c[d>>2]&3|0)!=3){d=m;n=o;break}c[291296>>2]=o;c[d>>2]=c[d>>2]&-2;c[a+(q+4)>>2]=o|1;c[h>>2]=o;i=b;return}t=u>>>3;if(u>>>0<256){d=c[a+(q+8)>>2]|0;n=c[a+(q+12)>>2]|0;p=291328+(t<<1<<2)|0;do{if((d|0)!=(p|0)){if(d>>>0<r>>>0){tc()}if((c[d+12>>2]|0)==(m|0)){break}tc()}}while(0);if((n|0)==(d|0)){c[72822]=c[72822]&~(1<<t);d=m;n=o;break}do{if((n|0)==(p|0)){s=n+8|0}else{if(n>>>0<r>>>0){tc()}p=n+8|0;if((c[p>>2]|0)==(m|0)){s=p;break}tc()}}while(0);c[d+12>>2]=n;c[s>>2]=d;d=m;n=o;break}s=c[a+(q+24)>>2]|0;t=c[a+(q+12)>>2]|0;do{if((t|0)==(m|0)){t=a+(q+20)|0;u=c[t>>2]|0;if((u|0)==0){t=a+(q+16)|0;u=c[t>>2]|0;if((u|0)==0){p=0;break}}while(1){v=u+20|0;w=c[v>>2]|0;if((w|0)!=0){u=w;t=v;continue}v=u+16|0;w=c[v>>2]|0;if((w|0)==0){break}else{t=v;u=w}}if(t>>>0<r>>>0){tc()}else{c[t>>2]=0;p=u;break}}else{u=c[a+(q+8)>>2]|0;if(u>>>0<r>>>0){tc()}r=u+12|0;if((c[r>>2]|0)!=(m|0)){tc()}v=t+8|0;if((c[v>>2]|0)==(m|0)){c[r>>2]=t;c[v>>2]=u;p=t;break}else{tc()}}}while(0);if((s|0)==0){d=m;n=o;break}r=a+(q+28)|0;t=291592+(c[r>>2]<<2)|0;do{if((m|0)==(c[t>>2]|0)){c[t>>2]=p;if((p|0)!=0){break}c[291292>>2]=c[291292>>2]&~(1<<c[r>>2]);d=m;n=o;break a}else{if(s>>>0<(c[291304>>2]|0)>>>0){tc()}r=s+16|0;if((c[r>>2]|0)==(m|0)){c[r>>2]=p}else{c[s+20>>2]=p}if((p|0)==0){d=m;n=o;break a}}}while(0);if(p>>>0<(c[291304>>2]|0)>>>0){tc()}c[p+24>>2]=s;r=c[a+(q+16)>>2]|0;do{if((r|0)!=0){if(r>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[p+16>>2]=r;c[r+24>>2]=p;break}}}while(0);q=c[a+(q+20)>>2]|0;if((q|0)==0){d=m;n=o;break}if(q>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[p+20>>2]=q;c[q+24>>2]=p;d=m;n=o;break}}else{d=q;n=j}}while(0);if(d>>>0>=h>>>0){tc()}m=a+(j+ -4)|0;o=c[m>>2]|0;if((o&1|0)==0){tc()}do{if((o&2|0)==0){if((h|0)==(c[291312>>2]|0)){w=(c[291300>>2]|0)+n|0;c[291300>>2]=w;c[291312>>2]=d;c[d+4>>2]=w|1;if((d|0)!=(c[291308>>2]|0)){i=b;return}c[291308>>2]=0;c[291296>>2]=0;i=b;return}if((h|0)==(c[291308>>2]|0)){w=(c[291296>>2]|0)+n|0;c[291296>>2]=w;c[291308>>2]=d;c[d+4>>2]=w|1;c[d+w>>2]=w;i=b;return}n=(o&-8)+n|0;m=o>>>3;b:do{if(o>>>0<256){k=c[a+j>>2]|0;a=c[a+(j|4)>>2]|0;j=291328+(m<<1<<2)|0;do{if((k|0)!=(j|0)){if(k>>>0<(c[291304>>2]|0)>>>0){tc()}if((c[k+12>>2]|0)==(h|0)){break}tc()}}while(0);if((a|0)==(k|0)){c[72822]=c[72822]&~(1<<m);break}do{if((a|0)==(j|0)){l=a+8|0}else{if(a>>>0<(c[291304>>2]|0)>>>0){tc()}j=a+8|0;if((c[j>>2]|0)==(h|0)){l=j;break}tc()}}while(0);c[k+12>>2]=a;c[l>>2]=k}else{l=c[a+(j+16)>>2]|0;o=c[a+(j|4)>>2]|0;do{if((o|0)==(h|0)){o=a+(j+12)|0;m=c[o>>2]|0;if((m|0)==0){o=a+(j+8)|0;m=c[o>>2]|0;if((m|0)==0){k=0;break}}while(1){q=m+20|0;p=c[q>>2]|0;if((p|0)!=0){o=q;m=p;continue}p=m+16|0;q=c[p>>2]|0;if((q|0)==0){break}else{m=q;o=p}}if(o>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[o>>2]=0;k=m;break}}else{p=c[a+j>>2]|0;if(p>>>0<(c[291304>>2]|0)>>>0){tc()}q=p+12|0;if((c[q>>2]|0)!=(h|0)){tc()}m=o+8|0;if((c[m>>2]|0)==(h|0)){c[q>>2]=o;c[m>>2]=p;k=o;break}else{tc()}}}while(0);if((l|0)==0){break}m=a+(j+20)|0;o=291592+(c[m>>2]<<2)|0;do{if((h|0)==(c[o>>2]|0)){c[o>>2]=k;if((k|0)!=0){break}c[291292>>2]=c[291292>>2]&~(1<<c[m>>2]);break b}else{if(l>>>0<(c[291304>>2]|0)>>>0){tc()}m=l+16|0;if((c[m>>2]|0)==(h|0)){c[m>>2]=k}else{c[l+20>>2]=k}if((k|0)==0){break b}}}while(0);if(k>>>0<(c[291304>>2]|0)>>>0){tc()}c[k+24>>2]=l;h=c[a+(j+8)>>2]|0;do{if((h|0)!=0){if(h>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[k+16>>2]=h;c[h+24>>2]=k;break}}}while(0);h=c[a+(j+12)>>2]|0;if((h|0)==0){break}if(h>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[k+20>>2]=h;c[h+24>>2]=k;break}}}while(0);c[d+4>>2]=n|1;c[d+n>>2]=n;if((d|0)!=(c[291308>>2]|0)){break}c[291296>>2]=n;i=b;return}else{c[m>>2]=o&-2;c[d+4>>2]=n|1;c[d+n>>2]=n}}while(0);h=n>>>3;if(n>>>0<256){j=h<<1;e=291328+(j<<2)|0;a=c[72822]|0;h=1<<h;do{if((a&h|0)==0){c[72822]=a|h;g=e;f=291328+(j+2<<2)|0}else{a=291328+(j+2<<2)|0;h=c[a>>2]|0;if(h>>>0>=(c[291304>>2]|0)>>>0){g=h;f=a;break}tc()}}while(0);c[f>>2]=d;c[g+12>>2]=d;c[d+8>>2]=g;c[d+12>>2]=e;i=b;return}f=n>>>8;do{if((f|0)==0){f=0}else{if(n>>>0>16777215){f=31;break}v=(f+1048320|0)>>>16&8;w=f<<v;u=(w+520192|0)>>>16&4;w=w<<u;f=(w+245760|0)>>>16&2;f=14-(u|v|f)+(w<<f>>>15)|0;f=n>>>(f+7|0)&1|f<<1}}while(0);g=291592+(f<<2)|0;c[d+28>>2]=f;c[d+20>>2]=0;c[d+16>>2]=0;a=c[291292>>2]|0;h=1<<f;c:do{if((a&h|0)==0){c[291292>>2]=a|h;c[g>>2]=d;c[d+24>>2]=g;c[d+12>>2]=d;c[d+8>>2]=d}else{g=c[g>>2]|0;if((f|0)==31){f=0}else{f=25-(f>>>1)|0}d:do{if((c[g+4>>2]&-8|0)==(n|0)){e=g}else{f=n<<f;while(1){h=g+16+(f>>>31<<2)|0;a=c[h>>2]|0;if((a|0)==0){break}if((c[a+4>>2]&-8|0)==(n|0)){e=a;break d}else{f=f<<1;g=a}}if(h>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[h>>2]=d;c[d+24>>2]=g;c[d+12>>2]=d;c[d+8>>2]=d;break c}}}while(0);g=e+8|0;f=c[g>>2]|0;h=c[291304>>2]|0;if(e>>>0<h>>>0){tc()}if(f>>>0<h>>>0){tc()}else{c[f+12>>2]=d;c[g>>2]=d;c[d+8>>2]=f;c[d+12>>2]=e;c[d+24>>2]=0;break}}}while(0);w=(c[291320>>2]|0)+ -1|0;c[291320>>2]=w;if((w|0)==0){d=291744|0}else{i=b;return}while(1){d=c[d>>2]|0;if((d|0)==0){break}else{d=d+8|0}}c[291320>>2]=-1;i=b;return}function CW(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=i;if((a|0)==0){f=AW(b)|0;i=d;return f|0}if(b>>>0>4294967231){c[(Pc()|0)>>2]=12;f=0;i=d;return f|0}if(b>>>0<11){e=16}else{e=b+11&-8}e=DW(a+ -8|0,e)|0;if((e|0)!=0){f=e+8|0;i=d;return f|0}e=AW(b)|0;if((e|0)==0){f=0;i=d;return f|0}f=c[a+ -4>>2]|0;f=(f&-8)-((f&3|0)==0?8:4)|0;$W(e|0,a|0,(f>>>0<b>>>0?f:b)|0)|0;BW(a);f=e;i=d;return f|0}function DW(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;d=i;e=a+4|0;g=c[e>>2]|0;k=g&-8;f=a+k|0;l=c[291304>>2]|0;if(a>>>0<l>>>0){tc()}n=g&3;if(!((n|0)!=1&a>>>0<f>>>0)){tc()}h=a+(k|4)|0;o=c[h>>2]|0;if((o&1|0)==0){tc()}if((n|0)==0){if(b>>>0<256){q=0;i=d;return q|0}do{if(k>>>0>=(b+4|0)>>>0){if((k-b|0)>>>0>c[291768>>2]<<1>>>0){break}i=d;return a|0}}while(0);q=0;i=d;return q|0}if(k>>>0>=b>>>0){f=k-b|0;if(f>>>0<=15){q=a;i=d;return q|0}c[e>>2]=g&1|b|2;c[a+(b+4)>>2]=f|3;c[h>>2]=c[h>>2]|1;EW(a+b|0,f);q=a;i=d;return q|0}if((f|0)==(c[291312>>2]|0)){f=(c[291300>>2]|0)+k|0;if(f>>>0<=b>>>0){q=0;i=d;return q|0}q=f-b|0;c[e>>2]=g&1|b|2;c[a+(b+4)>>2]=q|1;c[291312>>2]=a+b;c[291300>>2]=q;q=a;i=d;return q|0}if((f|0)==(c[291308>>2]|0)){h=(c[291296>>2]|0)+k|0;if(h>>>0<b>>>0){q=0;i=d;return q|0}f=h-b|0;if(f>>>0>15){c[e>>2]=g&1|b|2;c[a+(b+4)>>2]=f|1;c[a+h>>2]=f;e=a+(h+4)|0;c[e>>2]=c[e>>2]&-2;e=a+b|0}else{c[e>>2]=g&1|h|2;e=a+(h+4)|0;c[e>>2]=c[e>>2]|1;e=0;f=0}c[291296>>2]=f;c[291308>>2]=e;q=a;i=d;return q|0}if((o&2|0)!=0){q=0;i=d;return q|0}h=(o&-8)+k|0;if(h>>>0<b>>>0){q=0;i=d;return q|0}g=h-b|0;n=o>>>3;a:do{if(o>>>0<256){j=c[a+(k+8)>>2]|0;k=c[a+(k+12)>>2]|0;o=291328+(n<<1<<2)|0;do{if((j|0)!=(o|0)){if(j>>>0<l>>>0){tc()}if((c[j+12>>2]|0)==(f|0)){break}tc()}}while(0);if((k|0)==(j|0)){c[72822]=c[72822]&~(1<<n);break}do{if((k|0)==(o|0)){m=k+8|0}else{if(k>>>0<l>>>0){tc()}l=k+8|0;if((c[l>>2]|0)==(f|0)){m=l;break}tc()}}while(0);c[j+12>>2]=k;c[m>>2]=j}else{m=c[a+(k+24)>>2]|0;o=c[a+(k+12)>>2]|0;do{if((o|0)==(f|0)){n=a+(k+20)|0;o=c[n>>2]|0;if((o|0)==0){n=a+(k+16)|0;o=c[n>>2]|0;if((o|0)==0){j=0;break}}while(1){p=o+20|0;q=c[p>>2]|0;if((q|0)!=0){o=q;n=p;continue}p=o+16|0;q=c[p>>2]|0;if((q|0)==0){break}else{n=p;o=q}}if(n>>>0<l>>>0){tc()}else{c[n>>2]=0;j=o;break}}else{n=c[a+(k+8)>>2]|0;if(n>>>0<l>>>0){tc()}l=n+12|0;if((c[l>>2]|0)!=(f|0)){tc()}p=o+8|0;if((c[p>>2]|0)==(f|0)){c[l>>2]=o;c[p>>2]=n;j=o;break}else{tc()}}}while(0);if((m|0)==0){break}n=a+(k+28)|0;l=291592+(c[n>>2]<<2)|0;do{if((f|0)==(c[l>>2]|0)){c[l>>2]=j;if((j|0)!=0){break}c[291292>>2]=c[291292>>2]&~(1<<c[n>>2]);break a}else{if(m>>>0<(c[291304>>2]|0)>>>0){tc()}l=m+16|0;if((c[l>>2]|0)==(f|0)){c[l>>2]=j}else{c[m+20>>2]=j}if((j|0)==0){break a}}}while(0);if(j>>>0<(c[291304>>2]|0)>>>0){tc()}c[j+24>>2]=m;f=c[a+(k+16)>>2]|0;do{if((f|0)!=0){if(f>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[j+16>>2]=f;c[f+24>>2]=j;break}}}while(0);f=c[a+(k+20)>>2]|0;if((f|0)==0){break}if(f>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[j+20>>2]=f;c[f+24>>2]=j;break}}}while(0);if(g>>>0<16){c[e>>2]=h|c[e>>2]&1|2;q=a+(h|4)|0;c[q>>2]=c[q>>2]|1;q=a;i=d;return q|0}else{c[e>>2]=c[e>>2]&1|b|2;c[a+(b+4)>>2]=g|3;q=a+(h|4)|0;c[q>>2]=c[q>>2]|1;EW(a+b|0,g);q=a;i=d;return q|0}return 0}function EW(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;d=i;h=a+b|0;l=c[a+4>>2]|0;a:do{if((l&1|0)==0){p=c[a>>2]|0;if((l&3|0)==0){i=d;return}l=a+(0-p)|0;m=p+b|0;q=c[291304>>2]|0;if(l>>>0<q>>>0){tc()}if((l|0)==(c[291308>>2]|0)){e=a+(b+4)|0;if((c[e>>2]&3|0)!=3){e=l;n=m;break}c[291296>>2]=m;c[e>>2]=c[e>>2]&-2;c[a+(4-p)>>2]=m|1;c[h>>2]=m;i=d;return}s=p>>>3;if(p>>>0<256){e=c[a+(8-p)>>2]|0;n=c[a+(12-p)>>2]|0;o=291328+(s<<1<<2)|0;do{if((e|0)!=(o|0)){if(e>>>0<q>>>0){tc()}if((c[e+12>>2]|0)==(l|0)){break}tc()}}while(0);if((n|0)==(e|0)){c[72822]=c[72822]&~(1<<s);e=l;n=m;break}do{if((n|0)==(o|0)){r=n+8|0}else{if(n>>>0<q>>>0){tc()}o=n+8|0;if((c[o>>2]|0)==(l|0)){r=o;break}tc()}}while(0);c[e+12>>2]=n;c[r>>2]=e;e=l;n=m;break}r=c[a+(24-p)>>2]|0;t=c[a+(12-p)>>2]|0;do{if((t|0)==(l|0)){u=16-p|0;s=a+(u+4)|0;t=c[s>>2]|0;if((t|0)==0){s=a+u|0;t=c[s>>2]|0;if((t|0)==0){o=0;break}}while(1){u=t+20|0;v=c[u>>2]|0;if((v|0)!=0){t=v;s=u;continue}u=t+16|0;v=c[u>>2]|0;if((v|0)==0){break}else{s=u;t=v}}if(s>>>0<q>>>0){tc()}else{c[s>>2]=0;o=t;break}}else{s=c[a+(8-p)>>2]|0;if(s>>>0<q>>>0){tc()}u=s+12|0;if((c[u>>2]|0)!=(l|0)){tc()}q=t+8|0;if((c[q>>2]|0)==(l|0)){c[u>>2]=t;c[q>>2]=s;o=t;break}else{tc()}}}while(0);if((r|0)==0){e=l;n=m;break}q=a+(28-p)|0;s=291592+(c[q>>2]<<2)|0;do{if((l|0)==(c[s>>2]|0)){c[s>>2]=o;if((o|0)!=0){break}c[291292>>2]=c[291292>>2]&~(1<<c[q>>2]);e=l;n=m;break a}else{if(r>>>0<(c[291304>>2]|0)>>>0){tc()}q=r+16|0;if((c[q>>2]|0)==(l|0)){c[q>>2]=o}else{c[r+20>>2]=o}if((o|0)==0){e=l;n=m;break a}}}while(0);if(o>>>0<(c[291304>>2]|0)>>>0){tc()}c[o+24>>2]=r;p=16-p|0;q=c[a+p>>2]|0;do{if((q|0)!=0){if(q>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[o+16>>2]=q;c[q+24>>2]=o;break}}}while(0);p=c[a+(p+4)>>2]|0;if((p|0)==0){e=l;n=m;break}if(p>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[o+20>>2]=p;c[p+24>>2]=o;e=l;n=m;break}}else{e=a;n=b}}while(0);l=c[291304>>2]|0;if(h>>>0<l>>>0){tc()}m=a+(b+4)|0;o=c[m>>2]|0;do{if((o&2|0)==0){if((h|0)==(c[291312>>2]|0)){v=(c[291300>>2]|0)+n|0;c[291300>>2]=v;c[291312>>2]=e;c[e+4>>2]=v|1;if((e|0)!=(c[291308>>2]|0)){i=d;return}c[291308>>2]=0;c[291296>>2]=0;i=d;return}if((h|0)==(c[291308>>2]|0)){v=(c[291296>>2]|0)+n|0;c[291296>>2]=v;c[291308>>2]=e;c[e+4>>2]=v|1;c[e+v>>2]=v;i=d;return}n=(o&-8)+n|0;m=o>>>3;b:do{if(o>>>0<256){j=c[a+(b+8)>>2]|0;a=c[a+(b+12)>>2]|0;b=291328+(m<<1<<2)|0;do{if((j|0)!=(b|0)){if(j>>>0<l>>>0){tc()}if((c[j+12>>2]|0)==(h|0)){break}tc()}}while(0);if((a|0)==(j|0)){c[72822]=c[72822]&~(1<<m);break}do{if((a|0)==(b|0)){k=a+8|0}else{if(a>>>0<l>>>0){tc()}b=a+8|0;if((c[b>>2]|0)==(h|0)){k=b;break}tc()}}while(0);c[j+12>>2]=a;c[k>>2]=j}else{k=c[a+(b+24)>>2]|0;m=c[a+(b+12)>>2]|0;do{if((m|0)==(h|0)){o=a+(b+20)|0;m=c[o>>2]|0;if((m|0)==0){o=a+(b+16)|0;m=c[o>>2]|0;if((m|0)==0){j=0;break}}while(1){p=m+20|0;q=c[p>>2]|0;if((q|0)!=0){o=p;m=q;continue}p=m+16|0;q=c[p>>2]|0;if((q|0)==0){break}else{m=q;o=p}}if(o>>>0<l>>>0){tc()}else{c[o>>2]=0;j=m;break}}else{o=c[a+(b+8)>>2]|0;if(o>>>0<l>>>0){tc()}p=o+12|0;if((c[p>>2]|0)!=(h|0)){tc()}l=m+8|0;if((c[l>>2]|0)==(h|0)){c[p>>2]=m;c[l>>2]=o;j=m;break}else{tc()}}}while(0);if((k|0)==0){break}m=a+(b+28)|0;l=291592+(c[m>>2]<<2)|0;do{if((h|0)==(c[l>>2]|0)){c[l>>2]=j;if((j|0)!=0){break}c[291292>>2]=c[291292>>2]&~(1<<c[m>>2]);break b}else{if(k>>>0<(c[291304>>2]|0)>>>0){tc()}l=k+16|0;if((c[l>>2]|0)==(h|0)){c[l>>2]=j}else{c[k+20>>2]=j}if((j|0)==0){break b}}}while(0);if(j>>>0<(c[291304>>2]|0)>>>0){tc()}c[j+24>>2]=k;h=c[a+(b+16)>>2]|0;do{if((h|0)!=0){if(h>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[j+16>>2]=h;c[h+24>>2]=j;break}}}while(0);h=c[a+(b+20)>>2]|0;if((h|0)==0){break}if(h>>>0<(c[291304>>2]|0)>>>0){tc()}else{c[j+20>>2]=h;c[h+24>>2]=j;break}}}while(0);c[e+4>>2]=n|1;c[e+n>>2]=n;if((e|0)!=(c[291308>>2]|0)){break}c[291296>>2]=n;i=d;return}else{c[m>>2]=o&-2;c[e+4>>2]=n|1;c[e+n>>2]=n}}while(0);a=n>>>3;if(n>>>0<256){b=a<<1;h=291328+(b<<2)|0;j=c[72822]|0;a=1<<a;do{if((j&a|0)==0){c[72822]=j|a;g=h;f=291328+(b+2<<2)|0}else{a=291328+(b+2<<2)|0;j=c[a>>2]|0;if(j>>>0>=(c[291304>>2]|0)>>>0){g=j;f=a;break}tc()}}while(0);c[f>>2]=e;c[g+12>>2]=e;c[e+8>>2]=g;c[e+12>>2]=h;i=d;return}f=n>>>8;do{if((f|0)==0){f=0}else{if(n>>>0>16777215){f=31;break}u=(f+1048320|0)>>>16&8;v=f<<u;t=(v+520192|0)>>>16&4;v=v<<t;f=(v+245760|0)>>>16&2;f=14-(t|u|f)+(v<<f>>>15)|0;f=n>>>(f+7|0)&1|f<<1}}while(0);g=291592+(f<<2)|0;c[e+28>>2]=f;c[e+20>>2]=0;c[e+16>>2]=0;j=c[291292>>2]|0;h=1<<f;if((j&h|0)==0){c[291292>>2]=j|h;c[g>>2]=e;c[e+24>>2]=g;c[e+12>>2]=e;c[e+8>>2]=e;i=d;return}h=c[g>>2]|0;if((f|0)==31){f=0}else{f=25-(f>>>1)|0}c:do{if((c[h+4>>2]&-8|0)!=(n|0)){f=n<<f;j=h;while(1){g=j+16+(f>>>31<<2)|0;h=c[g>>2]|0;if((h|0)==0){break}if((c[h+4>>2]&-8|0)==(n|0)){break c}else{f=f<<1;j=h}}if(g>>>0<(c[291304>>2]|0)>>>0){tc()}c[g>>2]=e;c[e+24>>2]=j;c[e+12>>2]=e;c[e+8>>2]=e;i=d;return}}while(0);f=h+8|0;j=c[f>>2]|0;g=c[291304>>2]|0;if(h>>>0<g>>>0){tc()}if(j>>>0<g>>>0){tc()}c[j+12>>2]=e;c[f>>2]=e;c[e+8>>2]=j;c[e+12>>2]=h;c[e+24>>2]=0;i=d;return}function FW(a){a=a|0;var b=0,d=0,e=0;b=i;a=(a|0)==0?1:a;while(1){d=AW(a)|0;if((d|0)!=0){a=6;break}e=291784;d=c[e>>2]|0;c[e>>2]=0+d;if((d|0)==0){a=5;break}Hd[d&1]()}if((a|0)==5){e=cc(4)|0;c[e>>2]=291800;uc(e|0,291848,327)}else if((a|0)==6){i=b;return d|0}return 0}function GW(a){a=a|0;var b=0;b=i;a=FW(a)|0;i=b;return a|0}function HW(a){a=a|0;var b=0;b=i;if((a|0)!=0){BW(a)}i=b;return}function IW(a){a=a|0;var b=0;b=i;HW(a);i=b;return}function JW(a){a=a|0;var b=0;b=i;lb(a|0);HW(a);i=b;return}function KW(a){a=a|0;var b=0;b=i;lb(a|0);i=b;return}function LW(a){a=a|0;i=i;return 291816}



function MW(b,e,f){b=b|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0.0,t=0,u=0,v=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,I=0,J=0,K=0.0,L=0.0,M=0.0,N=0.0,O=0.0;g=i;r=i;i=i+512|0;k=r;if((e|0)==1){e=53;h=-1074}else if((e|0)==2){e=53;h=-1074}else if((e|0)==0){e=24;h=-149}else{M=0.0;i=g;return+M}n=b+4|0;o=b+100|0;do{j=c[n>>2]|0;if(j>>>0<(c[o>>2]|0)>>>0){c[n>>2]=j+1;F=d[j]|0}else{F=PW(b)|0}}while((xc(F|0)|0)!=0);do{if((F|0)==43|(F|0)==45){j=1-(((F|0)==45)<<1)|0;l=c[n>>2]|0;if(l>>>0<(c[o>>2]|0)>>>0){c[n>>2]=l+1;F=d[l]|0;break}else{F=PW(b)|0;break}}else{j=1}}while(0);l=0;do{if((F|32|0)!=(a[291864+l|0]|0)){break}do{if(l>>>0<7){m=c[n>>2]|0;if(m>>>0<(c[o>>2]|0)>>>0){c[n>>2]=m+1;F=d[m]|0;break}else{F=PW(b)|0;break}}}while(0);l=l+1|0;}while(l>>>0<8);do{if((l|0)==3){q=23}else if((l|0)!=8){p=(f|0)==0;if(!(l>>>0<4|p)){if((l|0)==8){break}else{q=23;break}}a:do{if((l|0)==0){l=0;do{if((F|32|0)!=(a[291880+l|0]|0)){break a}do{if(l>>>0<2){m=c[n>>2]|0;if(m>>>0<(c[o>>2]|0)>>>0){c[n>>2]=m+1;F=d[m]|0;break}else{F=PW(b)|0;break}}}while(0);l=l+1|0;}while(l>>>0<3)}}while(0);if((l|0)==3){e=c[n>>2]|0;if(e>>>0<(c[o>>2]|0)>>>0){c[n>>2]=e+1;e=d[e]|0}else{e=PW(b)|0}if((e|0)==40){e=1}else{if((c[o>>2]|0)==0){M=+w;i=g;return+M}c[n>>2]=(c[n>>2]|0)+ -1;M=+w;i=g;return+M}while(1){h=c[n>>2]|0;if(h>>>0<(c[o>>2]|0)>>>0){c[n>>2]=h+1;h=d[h]|0}else{h=PW(b)|0}if(!((h+ -48|0)>>>0<10|(h+ -65|0)>>>0<26)){if(!((h+ -97|0)>>>0<26|(h|0)==95)){break}}e=e+1|0}if((h|0)==41){M=+w;i=g;return+M}h=(c[o>>2]|0)==0;if(!h){c[n>>2]=(c[n>>2]|0)+ -1}if(p){c[(Pc()|0)>>2]=22;OW(b,0);M=0.0;i=g;return+M}if((e|0)==0|h){M=+w;i=g;return+M}while(1){e=e+ -1|0;c[n>>2]=(c[n>>2]|0)+ -1;if((e|0)==0){s=+w;break}else{}}i=g;return+s}else if((l|0)==0){do{if((F|0)==48){l=c[n>>2]|0;if(l>>>0<(c[o>>2]|0)>>>0){c[n>>2]=l+1;l=d[l]|0}else{l=PW(b)|0}if((l|32|0)!=120){if((c[o>>2]|0)==0){F=48;break}c[n>>2]=(c[n>>2]|0)+ -1;F=48;break}k=c[n>>2]|0;if(k>>>0<(c[o>>2]|0)>>>0){c[n>>2]=k+1;z=d[k]|0;v=0}else{z=PW(b)|0;v=0}while(1){if((z|0)==46){q=70;break}else if((z|0)!=48){m=0;r=0;l=0;k=0;u=0;y=0;K=1.0;t=0;s=0.0;break}k=c[n>>2]|0;if(k>>>0<(c[o>>2]|0)>>>0){c[n>>2]=k+1;z=d[k]|0;v=1;continue}else{z=PW(b)|0;v=1;continue}}b:do{if((q|0)==70){k=c[n>>2]|0;if(k>>>0<(c[o>>2]|0)>>>0){c[n>>2]=k+1;z=d[k]|0}else{z=PW(b)|0}if((z|0)==48){m=-1;r=-1}else{m=0;r=0;l=0;k=0;u=1;y=0;K=1.0;t=0;s=0.0;break}while(1){k=c[n>>2]|0;if(k>>>0<(c[o>>2]|0)>>>0){c[n>>2]=k+1;z=d[k]|0}else{z=PW(b)|0}if((z|0)!=48){l=0;k=0;v=1;u=1;y=0;K=1.0;t=0;s=0.0;break b}J=gX(m|0,r|0,-1,-1)|0;m=J;r=H}}}while(0);c:while(1){B=z+ -48|0;do{if(B>>>0<10){q=84}else{A=z|32;C=(z|0)==46;if(!((A+ -97|0)>>>0<6|C)){break c}if(C){if((u|0)==0){m=l;r=k;u=1;break}else{z=46;break c}}else{B=(z|0)>57?A+ -87|0:B;q=84;break}}}while(0);if((q|0)==84){q=0;do{if((k|0)<0|(k|0)==0&l>>>0<8){L=K;t=B+(t<<4)|0}else{if((k|0)<0|(k|0)==0&l>>>0<14){M=K*.0625;L=M;s=s+M*+(B|0);break}if(!((B|0)!=0&(y|0)==0)){L=K;break}y=1;L=K;s=s+K*.5}}while(0);l=gX(l|0,k|0,1,0)|0;k=H;v=1;K=L}z=c[n>>2]|0;if(z>>>0<(c[o>>2]|0)>>>0){c[n>>2]=z+1;z=d[z]|0;continue}else{z=PW(b)|0;continue}}if((v|0)==0){e=(c[o>>2]|0)==0;if(!e){c[n>>2]=(c[n>>2]|0)+ -1}do{if(p){OW(b,0)}else{if(e){break}e=c[n>>2]|0;c[n>>2]=e+ -1;if((u|0)==0){break}c[n>>2]=e+ -2}}while(0);M=+(j|0)*0.0;i=g;return+M}q=(u|0)==0;m=q?l:m;q=q?k:r;if((k|0)<0|(k|0)==0&l>>>0<8){while(1){t=t<<4;l=gX(l|0,k|0,1,0)|0;k=H;if((k|0)<0|(k|0)==0&l>>>0<8){}else{break}}}do{if((z|32|0)==112){l=NW(b,f)|0;k=H;if(!((l|0)==0&(k|0)==-2147483648)){break}if(p){OW(b,0);M=0.0;i=g;return+M}else{if((c[o>>2]|0)==0){l=0;k=0;break}c[n>>2]=(c[n>>2]|0)+ -1;l=0;k=0;break}}else{if((c[o>>2]|0)==0){l=0;k=0;break}c[n>>2]=(c[n>>2]|0)+ -1;l=0;k=0}}while(0);J=dX(m|0,q|0,2)|0;J=gX(J|0,H|0,-32,-1)|0;k=gX(J|0,H|0,l|0,k|0)|0;l=H;if((t|0)==0){M=+(j|0)*0.0;i=g;return+M}if((l|0)>0|(l|0)==0&k>>>0>(0-h|0)>>>0){c[(Pc()|0)>>2]=34;M=+(j|0)*1.7976931348623157e+308*1.7976931348623157e+308;i=g;return+M}m=h+ -106|0;J=(m|0)<0?-1:0;if((l|0)<(J|0)|(l|0)==(J|0)&k>>>0<m>>>0){c[(Pc()|0)>>2]=34;M=+(j|0)*1.2882297539194267e-231*1.2882297539194267e-231;i=g;return+M}if((t|0)>-1){do{t=t<<1;if(s<.5){K=s}else{K=s+-1.0;t=t|1}s=s+K;k=gX(k|0,l|0,-1,-1)|0;l=H;}while((t|0)>-1)}J=h|0;h=fX(32,0,J|0,((J|0)<0?-1:0)|0)|0;h=gX(k|0,l|0,h|0,H|0)|0;J=H;if(0>(J|0)|0==(J|0)&(e|0)>>>0>h>>>0){e=(h|0)<0?0:h}do{if((e|0)<53){K=+(j|0);L=+Sc(+(+QW(1.0,84-e|0)),+K);if(!((e|0)<32&s!=0.0)){break}J=t&1;t=(J^1)+t|0;s=(J|0)==0?0.0:s}else{K=+(j|0);L=0.0}}while(0);s=K*s+(L+K*+(t>>>0))-L;if(s==0.0){c[(Pc()|0)>>2]=34}M=+RW(s,k);i=g;return+M}}while(0);m=h+e|0;l=0-m|0;A=0;while(1){if((F|0)==46){q=139;break}else if((F|0)!=48){B=0;C=0;v=0;break}t=c[n>>2]|0;if(t>>>0<(c[o>>2]|0)>>>0){c[n>>2]=t+1;F=d[t]|0;A=1;continue}else{F=PW(b)|0;A=1;continue}}d:do{if((q|0)==139){t=c[n>>2]|0;if(t>>>0<(c[o>>2]|0)>>>0){c[n>>2]=t+1;F=d[t]|0}else{F=PW(b)|0}if((F|0)==48){B=-1;C=-1}else{B=0;C=0;v=1;break}while(1){t=c[n>>2]|0;if(t>>>0<(c[o>>2]|0)>>>0){c[n>>2]=t+1;F=d[t]|0}else{F=PW(b)|0}if((F|0)!=48){A=1;v=1;break d}J=gX(B|0,C|0,-1,-1)|0;B=J;C=H}}}while(0);c[r>>2]=0;D=F+ -48|0;E=(F|0)==46;e:do{if(D>>>0<10|E){t=k+496|0;I=0;G=0;z=0;y=0;u=0;while(1){do{if(E){if((v|0)==0){B=I;C=G;v=1}else{t=I;v=G;break e}}else{E=gX(I|0,G|0,1,0)|0;G=H;J=(F|0)!=48;if((y|0)>=125){if(!J){I=E;break}c[t>>2]=c[t>>2]|1;I=E;break}A=k+(y<<2)|0;if((z|0)!=0){D=F+ -48+((c[A>>2]|0)*10|0)|0}c[A>>2]=D;z=z+1|0;D=(z|0)==9;I=E;A=1;z=D?0:z;y=(D&1)+y|0;u=J?E:u}}while(0);D=c[n>>2]|0;if(D>>>0<(c[o>>2]|0)>>>0){c[n>>2]=D+1;F=d[D]|0}else{F=PW(b)|0}D=F+ -48|0;E=(F|0)==46;if(!(D>>>0<10|E)){q=162;break}}}else{I=0;G=0;z=0;y=0;u=0;q=162}}while(0);if((q|0)==162){D=(v|0)==0;t=I;v=G;B=D?I:B;C=D?G:C}A=(A|0)!=0;do{if(A){if((F|32|0)!=101){q=171;break}D=NW(b,f)|0;f=H;do{if((D|0)==0&(f|0)==-2147483648){if(p){OW(b,0);M=0.0;i=g;return+M}else{if((c[o>>2]|0)==0){D=0;f=0;break}c[n>>2]=(c[n>>2]|0)+ -1;D=0;f=0;break}}}while(0);n=gX(D|0,f|0,B|0,C|0)|0;C=H}else{q=171}}while(0);do{if((q|0)==171){if((F|0)<=-1){n=B;break}if((c[o>>2]|0)==0){n=B;break}c[n>>2]=(c[n>>2]|0)+ -1;n=B}}while(0);if(!A){c[(Pc()|0)>>2]=22;OW(b,0);M=0.0;i=g;return+M}b=c[r>>2]|0;if((b|0)==0){M=+(j|0)*0.0;i=g;return+M}do{if((n|0)==(t|0)&(C|0)==(v|0)&((v|0)<0|(v|0)==0&t>>>0<10)){if(e>>>0<=30){if((b>>>e|0)!=0){break}}M=+(j|0)*+(b>>>0);i=g;return+M}}while(0);b=(h|0)/-2|0|0;J=(b|0)<0?-1:0;if((C|0)>(J|0)|(C|0)==(J|0)&n>>>0>b>>>0){c[(Pc()|0)>>2]=34;M=+(j|0)*1.7976931348623157e+308*1.7976931348623157e+308;i=g;return+M}b=h+ -106|0;J=(b|0)<0?-1:0;if((C|0)<(J|0)|(C|0)==(J|0)&n>>>0<b>>>0){c[(Pc()|0)>>2]=34;M=+(j|0)*1.2882297539194267e-231*1.2882297539194267e-231;i=g;return+M}if((z|0)!=0){if((z|0)<9){o=k+(y<<2)|0;b=c[o>>2]|0;do{b=b*10|0;z=z+1|0;}while((z|0)<9);c[o>>2]=b}y=y+1|0}do{if((u|0)<9){if(!((u|0)<=(n|0)&(n|0)<18)){break}if((n|0)==9){M=+(j|0)*+((c[r>>2]|0)>>>0);i=g;return+M}if((n|0)<9){M=+(j|0)*+((c[r>>2]|0)>>>0)/+(c[291896+(8-n<<2)>>2]|0);i=g;return+M}b=e+27+(da(n,-3)|0)|0;o=c[r>>2]|0;if((b|0)<=30){if((o>>>b|0)!=0){break}}M=+(j|0)*+(o>>>0)*+(c[291896+(n+ -10<<2)>>2]|0);i=g;return+M}}while(0);b=(n|0)%9|0;if((b|0)==0){b=0;o=0}else{f=(n|0)>-1?b:b+9|0;o=c[291896+(8-f<<2)>>2]|0;do{if((y|0)==0){b=0;y=0}else{p=1e9/(o|0)|0;b=0;r=0;t=0;while(1){I=k+(t<<2)|0;q=c[I>>2]|0;J=((q>>>0)/(o>>>0)|0)+r|0;c[I>>2]=J;r=da((q>>>0)%(o>>>0)|0,p)|0;q=t+1|0;if((t|0)==(b|0)&(J|0)==0){b=q&127;n=n+ -9|0}if((q|0)==(y|0)){break}else{t=q}}if((r|0)==0){break}c[k+(y<<2)>>2]=r;y=y+1|0}}while(0);o=0;n=9-f+n|0}f:while(1){f=k+(b<<2)|0;if((n|0)<18){do{q=0;f=y+127|0;while(1){f=f&127;p=k+(f<<2)|0;r=dX(c[p>>2]|0,0,29)|0;r=gX(r|0,H|0,q|0,0)|0;q=H;if(q>>>0>0|(q|0)==0&r>>>0>1e9){J=rX(r|0,q|0,1e9,0)|0;r=sX(r|0,q|0,1e9,0)|0;q=J}else{q=0}c[p>>2]=r;p=(f|0)==(b|0);if(!((f|0)!=(y+127&127|0)|p)){y=(r|0)==0?f:y}if(p){break}else{f=f+ -1|0}}o=o+ -29|0;}while((q|0)==0)}else{if((n|0)!=18){break}do{if((c[f>>2]|0)>>>0>=9007199){n=18;break f}q=0;p=y+127|0;while(1){p=p&127;r=k+(p<<2)|0;t=dX(c[r>>2]|0,0,29)|0;t=gX(t|0,H|0,q|0,0)|0;q=H;if(q>>>0>0|(q|0)==0&t>>>0>1e9){J=rX(t|0,q|0,1e9,0)|0;t=sX(t|0,q|0,1e9,0)|0;q=J}else{q=0}c[r>>2]=t;r=(p|0)==(b|0);if(!((p|0)!=(y+127&127|0)|r)){y=(t|0)==0?p:y}if(r){break}else{p=p+ -1|0}}o=o+ -29|0;}while((q|0)==0)}b=b+127&127;if((b|0)==(y|0)){J=y+127&127;y=k+((y+126&127)<<2)|0;c[y>>2]=c[y>>2]|c[k+(J<<2)>>2];y=J}c[k+(b<<2)>>2]=q;n=n+9|0}g:while(1){f=y+1&127;p=k+((y+127&127)<<2)|0;while(1){r=(n|0)==18;q=(n|0)>27?9:1;while(1){t=0;while(1){u=t+b&127;if((u|0)==(y|0)){t=2;break}z=c[k+(u<<2)>>2]|0;v=c[291888+(t<<2)>>2]|0;if(z>>>0<v>>>0){t=2;break}u=t+1|0;if(z>>>0>v>>>0){break}if((u|0)<2){t=u}else{t=u;break}}if((t|0)==2&r){break g}o=q+o|0;if((b|0)==(y|0)){b=y}else{break}}r=(1<<q)+ -1|0;v=1e9>>>q;u=b;t=0;do{I=k+(b<<2)|0;J=c[I>>2]|0;z=(J>>>q)+t|0;c[I>>2]=z;t=da(J&r,v)|0;z=(b|0)==(u|0)&(z|0)==0;b=b+1&127;n=z?n+ -9|0:n;u=z?b:u;}while((b|0)!=(y|0));if((t|0)==0){b=u;continue}if((f|0)!=(u|0)){break}c[p>>2]=c[p>>2]|1;b=u}c[k+(y<<2)>>2]=t;b=u;y=f}n=b&127;if((n|0)==(y|0)){c[k+(f+ -1<<2)>>2]=0;y=f}K=+((c[k+(n<<2)>>2]|0)>>>0);n=b+1&127;if((n|0)==(y|0)){y=y+1&127;c[k+(y+ -1<<2)>>2]=0}s=+(j|0);L=s*(K*1.0e9+ +((c[k+(n<<2)>>2]|0)>>>0));j=o+53|0;h=j-h|0;if((h|0)<(e|0)){e=(h|0)<0?0:h;n=1}else{n=0}if((e|0)<53){O=+Sc(+(+QW(1.0,105-e|0)),+L);N=+$b(+L,+(+QW(1.0,53-e|0)));K=O;M=N;L=O+(L-N)}else{K=0.0;M=0.0}f=b+2&127;do{if((f|0)!=(y|0)){k=c[k+(f<<2)>>2]|0;do{if(k>>>0<5e8){if((k|0)==0){if((b+3&127|0)==(y|0)){break}}M=s*.25+M}else{if(k>>>0>5e8){M=s*.75+M;break}if((b+3&127|0)==(y|0)){M=s*.5+M;break}else{M=s*.75+M;break}}}while(0);if((53-e|0)<=1){break}if(+$b(+M,1.0)!=0.0){break}M=M+1.0}}while(0);s=L+M-K;do{if((j&2147483647|0)>(-2-m|0)){if(+S(+s)>=9007199254740992.0){n=(n|0)!=0&(e|0)==(h|0)?0:n;o=o+1|0;s=s*.5}if((o+50|0)<=(l|0)){if(!((n|0)!=0&M!=0.0)){break}}c[(Pc()|0)>>2]=34}}while(0);O=+RW(s,o);i=g;return+O}else{if((c[o>>2]|0)!=0){c[n>>2]=(c[n>>2]|0)+ -1}c[(Pc()|0)>>2]=22;OW(b,0);O=0.0;i=g;return+O}}}while(0);do{if((q|0)==23){e=(c[o>>2]|0)==0;if(!e){c[n>>2]=(c[n>>2]|0)+ -1}if(l>>>0<4|(f|0)==0|e){break}do{c[n>>2]=(c[n>>2]|0)+ -1;l=l+ -1|0;}while(l>>>0>3)}}while(0);O=+(j|0)*+x;i=g;return+O}function NW(a,b){a=a|0;b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0;e=i;g=a+4|0;h=c[g>>2]|0;f=a+100|0;if(h>>>0<(c[f>>2]|0)>>>0){c[g>>2]=h+1;k=d[h]|0}else{k=PW(a)|0}do{if((k|0)==43|(k|0)==45){h=(k|0)==45|0;j=c[g>>2]|0;if(j>>>0<(c[f>>2]|0)>>>0){c[g>>2]=j+1;k=d[j]|0}else{k=PW(a)|0}if((k+ -48|0)>>>0<10|(b|0)==0){break}if((c[f>>2]|0)==0){break}c[g>>2]=(c[g>>2]|0)+ -1}else{h=0}}while(0);if((k+ -48|0)>>>0>9){if((c[f>>2]|0)==0){k=0;j=-2147483648;H=j;i=e;return k|0}c[g>>2]=(c[g>>2]|0)+ -1;k=0;j=-2147483648;H=j;i=e;return k|0}else{b=0}while(1){b=k+ -48+b|0;j=c[g>>2]|0;if(j>>>0<(c[f>>2]|0)>>>0){c[g>>2]=j+1;k=d[j]|0}else{k=PW(a)|0}if(!((k+ -48|0)>>>0<10&(b|0)<214748364)){break}b=b*10|0}b=b|0;j=(b|0)<0?-1:0;if((k+ -48|0)>>>0<10){while(1){j=qX(b|0,j|0,10,0)|0;b=H;k=k|0;k=gX(k|0,((k|0)<0?-1:0)|0,-48,-1)|0;b=gX(k|0,H|0,j|0,b|0)|0;j=H;k=c[g>>2]|0;if(k>>>0<(c[f>>2]|0)>>>0){c[g>>2]=k+1;k=d[k]|0}else{k=PW(a)|0}if((k+ -48|0)>>>0<10&((j|0)<21474836|(j|0)==21474836&b>>>0<2061584302)){}else{break}}}if((k+ -48|0)>>>0<10){do{k=c[g>>2]|0;if(k>>>0<(c[f>>2]|0)>>>0){c[g>>2]=k+1;k=d[k]|0}else{k=PW(a)|0}}while((k+ -48|0)>>>0<10)}if((c[f>>2]|0)!=0){c[g>>2]=(c[g>>2]|0)+ -1}a=(h|0)!=0;f=fX(0,0,b|0,j|0)|0;f=a?f:b;k=a?H:j;H=k;i=e;return f|0}function OW(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;c[a+104>>2]=b;f=c[a+8>>2]|0;e=c[a+4>>2]|0;g=f-e|0;c[a+108>>2]=g;if((b|0)!=0&(g|0)>(b|0)){c[a+100>>2]=e+b;i=d;return}else{c[a+100>>2]=f;i=d;return}}function PW(b){b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0;e=i;h=b+104|0;f=c[h>>2]|0;if((f|0)==0){g=3}else{if((c[b+108>>2]|0)<(f|0)){g=3}}do{if((g|0)==3){f=TW(b)|0;if((f|0)<0){break}k=c[h>>2]|0;h=c[b+8>>2]|0;do{if((k|0)==0){g=8}else{j=c[b+4>>2]|0;k=k-(c[b+108>>2]|0)+ -1|0;if((h-j|0)<=(k|0)){g=8;break}c[b+100>>2]=j+k}}while(0);if((g|0)==8){c[b+100>>2]=h}g=c[b+4>>2]|0;if((h|0)!=0){k=b+108|0;c[k>>2]=h+1-g+(c[k>>2]|0)}b=g+ -1|0;if((d[b]|0|0)==(f|0)){k=f;i=e;return k|0}a[b]=f;k=f;i=e;return k|0}}while(0);c[b+100>>2]=0;k=-1;i=e;return k|0}function QW(a,b){a=+a;b=b|0;var d=0,e=0;d=i;do{if((b|0)>1023){a=a*8.98846567431158e+307;e=b+ -1023|0;if((e|0)<=1023){b=e;break}b=b+ -2046|0;b=(b|0)>1023?1023:b;a=a*8.98846567431158e+307}else{if((b|0)>=-1022){break}a=a*1.2882297539194267e-231;e=b+1022|0;if((e|0)>=-1022){b=e;break}b=b+2044|0;b=(b|0)<-1022?-1022:b;a=a*1.2882297539194267e-231}}while(0);b=dX(b+1023|0,0,52)|0;e=H;c[k>>2]=b;c[k+4>>2]=e;a=a*+h[k>>3];i=d;return+a}function RW(a,b){a=+a;b=b|0;var c=0;c=i;a=+QW(a,b);i=c;return+a}function SW(b){b=b|0;var d=0,e=0,f=0;e=i;f=b+74|0;d=a[f]|0;a[f]=d+ -1<<24>>24|d;f=b+20|0;d=b+44|0;if((c[f>>2]|0)>>>0>(c[d>>2]|0)>>>0){sd[c[b+36>>2]&127](b,0,0)|0}c[b+16>>2]=0;c[b+28>>2]=0;c[f>>2]=0;f=c[b>>2]|0;if((f&20|0)==0){f=c[d>>2]|0;c[b+8>>2]=f;c[b+4>>2]=f;f=0;i=e;return f|0}if((f&4|0)==0){f=-1;i=e;return f|0}c[b>>2]=f|32;f=-1;i=e;return f|0}function TW(a){a=a|0;var b=0,e=0,f=0;b=i;e=i;i=i+8|0;f=e;do{if((c[a+8>>2]|0)==0){if((SW(a)|0)==0){break}else{a=-1}i=b;return a|0}}while(0);if((sd[c[a+32>>2]&127](a,f,1)|0)!=1){f=-1;i=b;return f|0}f=d[e]|0;i=b;return f|0}function UW(a,b){a=a|0;b=b|0;var d=0.0,e=0,f=0,g=0,h=0;e=i;h=i;i=i+112|0;f=h;bX(h|0,0,112)|0;h=f+4|0;c[h>>2]=a;g=f+8|0;c[g>>2]=-1;c[f+44>>2]=a;c[f+76>>2]=-1;OW(f,0);d=+MW(f,1,1);f=(c[h>>2]|0)-(c[g>>2]|0)+(c[f+108>>2]|0)|0;if((b|0)==0){i=e;return+d}if((f|0)!=0){a=a+f|0}c[b>>2]=a;i=e;return+d}function VW(){c[72964]=o}function WW(a){a=a|0;if((a|0)<65)return a|0;if((a|0)>90)return a|0;return a-65+97|0}function XW(b,c,d){b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;while(e>>>0<d>>>0){f=WW(a[b+e|0]|0)|0;g=WW(a[c+e|0]|0)|0;if((f|0)==(g|0)&(f|0)==0)return 0;if((f|0)==0)return-1;if((g|0)==0)return 1;if((f|0)==(g|0)){e=e+1|0;continue}else{return(f>>>0>g>>>0?1:-1)|0}}return 0}function YW(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;u=u+1|0;c[a>>2]=u;while((e|0)<40){if((c[d+(e<<2)>>2]|0)==0){c[d+(e<<2)>>2]=u;c[d+((e<<2)+4)>>2]=b;c[d+((e<<2)+8)>>2]=0;return 0}e=e+2|0}Hb(116);Hb(111);Hb(111);Hb(32);Hb(109);Hb(97);Hb(110);Hb(121);Hb(32);Hb(115);Hb(101);Hb(116);Hb(106);Hb(109);Hb(112);Hb(115);Hb(32);Hb(105);Hb(110);Hb(32);Hb(97);Hb(32);Hb(102);Hb(117);Hb(110);Hb(99);Hb(116);Hb(105);Hb(111);Hb(110);Hb(32);Hb(99);Hb(97);Hb(108);Hb(108);Hb(44);Hb(32);Hb(98);Hb(117);Hb(105);Hb(108);Hb(100);Hb(32);Hb(119);Hb(105);Hb(116);Hb(104);Hb(32);Hb(97);Hb(32);Hb(104);Hb(105);Hb(103);Hb(104);Hb(101);Hb(114);Hb(32);Hb(118);Hb(97);Hb(108);Hb(117);Hb(101);Hb(32);Hb(102);Hb(111);Hb(114);Hb(32);Hb(77);Hb(65);Hb(88);Hb(95);Hb(83);Hb(69);Hb(84);Hb(74);Hb(77);Hb(80);Hb(83);Hb(10);ea(0);return 0}function ZW(b){b=b|0;var c=0;c=b;while(a[c]|0){c=c+1|0}return c-b|0}function _W(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){H=b>>c;return a>>>c|(b&(1<<c)-1)<<32-c}H=(b|0)<0?-1:0;return b>>c-32|0}function $W(b,d,e){b=b|0;d=d|0;e=e|0;var f=0;f=b|0;if((b&3)==(d&3)){while(b&3){if((e|0)==0)return f|0;a[b]=a[d]|0;b=b+1|0;d=d+1|0;e=e-1|0}while((e|0)>=4){c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;e=e-4|0}}while((e|0)>0){a[b]=a[d]|0;b=b+1|0;d=d+1|0;e=e-1|0}return f|0}function aX(b,c,d){b=b|0;c=c|0;d=d|0;var e=0;if((c|0)<(b|0)&(b|0)<(c+d|0)){e=b;c=c+d|0;b=b+d|0;while((d|0)>0){b=b-1|0;c=c-1|0;d=d-1|0;a[b]=a[c]|0}b=e}else{$W(b,c,d)|0}return b|0}function bX(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;f=b+e|0;if((e|0)>=20){d=d&255;i=b&3;h=d|d<<8|d<<16|d<<24;g=f&~3;if(i){i=b+4-i|0;while((b|0)<(i|0)){a[b]=d;b=b+1|0}}while((b|0)<(g|0)){c[b>>2]=h;b=b+4|0}}while((b|0)<(f|0)){a[b]=d;b=b+1|0}return b-e|0}function cX(b,c){b=b|0;c=c|0;var d=0,e=0;d=b+(ZW(b)|0)|0;do{a[d+e|0]=a[c+e|0];e=e+1|0}while(a[c+(e-1)|0]|0);return b|0}function dX(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){H=b<<c|(a&(1<<c)-1<<32-c)>>>32-c;return a<<c}H=a<<c-32;return 0}function eX(b,c){b=b|0;c=c|0;var d=0;do{a[b+d|0]=a[c+d|0];d=d+1|0}while(a[c+(d-1)|0]|0);return b|0}function fX(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;b=b-d-(c>>>0>a>>>0|0)>>>0;return(H=b,a-c>>>0|0)|0}function gX(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;c=a+c>>>0;return(H=b+d+(c>>>0<a>>>0|0)>>>0,c|0)|0}function hX(b,c,d){b=b|0;c=c|0;d=d|0;var e=0,f=0;while((e|0)<(d|0)){a[b+e|0]=f?0:a[c+e|0]|0;f=f?1:(a[c+e|0]|0)==0;e=e+1|0}return b|0}function iX(a,b,c){a=a|0;b=b|0;c=c|0;var e=0,f=0,g=0;while((e|0)<(c|0)){g=d[a+e|0]|0;f=d[b+e|0]|0;if((g|0)!=(f|0))return((g|0)>(f|0)?1:-1)|0;e=e+1|0}return 0}function jX(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){H=b>>>c;return a>>>c|(b&(1<<c)-1)<<32-c}H=0;return b>>>c-32|0}function kX(a,b){a=a|0;b=b|0;var d=0,e=0;while((d|0)<20){e=c[b+(d<<2)>>2]|0;if((e|0)==0)break;if((e|0)==(a|0)){return c[b+((d<<2)+4)>>2]|0}d=d+2|0}return 0}function lX(b){b=b|0;var c=0;c=a[n+(b>>>24)|0]|0;if((c|0)<8)return c|0;c=a[n+(b>>16&255)|0]|0;if((c|0)<8)return c+8|0;c=a[n+(b>>8&255)|0]|0;if((c|0)<8)return c+16|0;return(a[n+(b&255)|0]|0)+24|0}function mX(b){b=b|0;var c=0;c=a[m+(b&255)|0]|0;if((c|0)<8)return c|0;c=a[m+(b>>8&255)|0]|0;if((c|0)<8)return c+8|0;c=a[m+(b>>16&255)|0]|0;if((c|0)<8)return c+16|0;return(a[m+(b>>>24)|0]|0)+24|0}function nX(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;f=a&65535;d=b&65535;c=da(d,f)|0;e=a>>>16;d=(c>>>16)+(da(d,e)|0)|0;b=b>>>16;a=da(b,f)|0;return(H=(d>>>16)+(da(b,e)|0)+(((d&65535)+a|0)>>>16)|0,d+a<<16|c&65535|0)|0}function oX(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0;e=b>>31|((b|0)<0?-1:0)<<1;f=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;g=d>>31|((d|0)<0?-1:0)<<1;h=((d|0)<0?-1:0)>>31|((d|0)<0?-1:0)<<1;a=fX(e^a,f^b,e,f)|0;b=H;e=g^e;f=h^f;g=fX((tX(a,b,fX(g^c,h^d,g,h)|0,H,0)|0)^e,H^f,e,f)|0;return(H=H,g)|0}function pX(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0;g=i;i=i+8|0;f=g|0;h=b>>31|((b|0)<0?-1:0)<<1;j=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;k=e>>31|((e|0)<0?-1:0)<<1;l=((e|0)<0?-1:0)>>31|((e|0)<0?-1:0)<<1;a=fX(h^a,j^b,h,j)|0;b=H;tX(a,b,fX(k^d,l^e,k,l)|0,H,f)|0;k=fX(c[f>>2]^h,c[f+4>>2]^j,h,j)|0;j=H;i=g;return(H=j,k)|0}function qX(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=a;f=c;a=nX(e,f)|0;c=H;return(H=(da(b,f)|0)+(da(d,e)|0)+c|c&0,a|0|0)|0}function rX(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;a=tX(a,b,c,d,0)|0;return(H=H,a)|0}function sX(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;g=i;i=i+8|0;f=g|0;tX(a,b,d,e,f)|0;i=g;return(H=c[f+4>>2]|0,c[f>>2]|0)|0}function tX(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;h=a;j=b;i=j;k=d;g=e;l=g;if((i|0)==0){d=(f|0)!=0;if((l|0)==0){if(d){c[f>>2]=(h>>>0)%(k>>>0);c[f+4>>2]=0}l=0;m=(h>>>0)/(k>>>0)>>>0;return(H=l,m)|0}else{if(!d){l=0;m=0;return(H=l,m)|0}c[f>>2]=a|0;c[f+4>>2]=b&0;l=0;m=0;return(H=l,m)|0}}m=(l|0)==0;do{if((k|0)==0){if(m){if((f|0)!=0){c[f>>2]=(i>>>0)%(k>>>0);c[f+4>>2]=0}l=0;m=(i>>>0)/(k>>>0)>>>0;return(H=l,m)|0}if((h|0)==0){if((f|0)!=0){c[f>>2]=0;c[f+4>>2]=(i>>>0)%(l>>>0)}k=0;m=(i>>>0)/(l>>>0)>>>0;return(H=k,m)|0}k=l-1|0;if((k&l|0)==0){if((f|0)!=0){c[f>>2]=a|0;c[f+4>>2]=k&i|b&0}k=0;m=i>>>((mX(l|0)|0)>>>0);return(H=k,m)|0}k=(lX(l|0)|0)-(lX(i|0)|0)|0;if(k>>>0<=30){b=k+1|0;m=31-k|0;j=b;a=i<<m|h>>>(b>>>0);b=i>>>(b>>>0);l=0;i=h<<m;break}if((f|0)==0){l=0;m=0;return(H=l,m)|0}c[f>>2]=a|0;c[f+4>>2]=j|b&0;l=0;m=0;return(H=l,m)|0}else{if(!m){k=(lX(l|0)|0)-(lX(i|0)|0)|0;if(k>>>0<=31){l=k+1|0;m=31-k|0;b=k-31>>31;j=l;a=h>>>(l>>>0)&b|i<<m;b=i>>>(l>>>0)&b;l=0;i=h<<m;break}if((f|0)==0){l=0;m=0;return(H=l,m)|0}c[f>>2]=a|0;c[f+4>>2]=j|b&0;l=0;m=0;return(H=l,m)|0}l=k-1|0;if((l&k|0)!=0){m=(lX(k|0)|0)+33-(lX(i|0)|0)|0;p=64-m|0;k=32-m|0;n=k>>31;o=m-32|0;b=o>>31;j=m;a=k-1>>31&i>>>(o>>>0)|(i<<k|h>>>(m>>>0))&b;b=b&i>>>(m>>>0);l=h<<p&n;i=(i<<p|h>>>(o>>>0))&n|h<<k&m-33>>31;break}if((f|0)!=0){c[f>>2]=l&h;c[f+4>>2]=0}if((k|0)==1){o=j|b&0;p=a|0|0;return(H=o,p)|0}else{p=mX(k|0)|0;o=i>>>(p>>>0)|0;p=i<<32-p|h>>>(p>>>0)|0;return(H=o,p)|0}}}while(0);if((j|0)==0){m=a;d=0;a=0}else{d=d|0|0;g=g|e&0;e=gX(d,g,-1,-1)|0;h=H;k=b;m=a;a=0;while(1){b=l>>>31|i<<1;l=a|l<<1;i=m<<1|i>>>31|0;k=m>>>31|k<<1|0;fX(e,h,i,k)|0;m=H;p=m>>31|((m|0)<0?-1:0)<<1;a=p&1;m=fX(i,k,p&d,(((m|0)<0?-1:0)>>31|((m|0)<0?-1:0)<<1)&g)|0;k=H;j=j-1|0;if((j|0)==0){break}else{i=b}}i=b;b=k;d=0}g=0;if((f|0)!=0){c[f>>2]=m;c[f+4>>2]=b}o=(l|0)>>>31|(i|g)<<1|(g<<1|l>>>31)&0|d;p=(l<<1|0>>>31)&-2|a;return(H=o,p)|0}function uX(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;return dd[a&1](b|0,c|0,d|0,e|0,f|0,g|0,h|0)|0}function vX(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;ed[a&3](b|0,c|0,d|0,e|0,f|0)}function wX(a,b){a=a|0;b=b|0;fd[a&511](b|0)}function xX(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=+e;f=+f;return gd[a&3](b|0,c|0,d|0,+e,+f)|0}function yX(a,b,c){a=a|0;b=b|0;c=c|0;hd[a&127](b|0,c|0)}function zX(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;return id[a&3](b|0,c|0,d|0,e|0,f|0,g|0)|0}function AX(a,b){a=a|0;b=b|0;return jd[a&511](b|0)|0}function BX(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=+d;e=+e;kd[a&1](b|0,c|0,+d,+e)}function CX(a,b,c,d,e,f){a=a|0;b=b|0;c=+c;d=+d;e=e|0;f=f|0;ld[a&3](b|0,+c,+d,e|0,f|0)}function DX(a,b,c,d,e,f,g,h,i,j,k,l,m){a=a|0;b=b|0;c=c|0;d=+d;e=+e;f=+f;g=+g;h=+h;i=+i;j=j|0;k=k|0;l=l|0;m=m|0;md[a&1](b|0,c|0,+d,+e,+f,+g,+h,+i,j|0,k|0,l|0,m|0)}function EX(a,b,c,d,e,f,g,h,i,j,k,l,m,n){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;l=l|0;m=+m;n=+n;return nd[a&1](b|0,c|0,d|0,e|0,f|0,g|0,h|0,i|0,j|0,k|0,l|0,+m,+n)|0}function FX(a,b,c,d,e){a=a|0;b=b|0;c=+c;d=d|0;e=e|0;od[a&1](b|0,+c,d|0,e|0)}function GX(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return pd[a&63](b|0,c|0,d|0,e|0)|0}function HX(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=+d;e=+e;f=+f;g=+g;h=h|0;i=i|0;j=j|0;return qd[a&1](b|0,c|0,+d,+e,+f,+g,h|0,i|0,j|0)|0}function IX(a,b,c,d,e,f,g,h,i,j,k,l){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;l=l|0;rd[a&1](b|0,c|0,d|0,e|0,f|0,g|0,h|0,i|0,j|0,k|0,l|0)}function JX(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return sd[a&127](b|0,c|0,d|0)|0}function KX(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){a=a|0;b=b|0;c=c|0;d=+d;e=+e;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;l=l|0;m=m|0;n=n|0;o=o|0;p=p|0;return td[a&1](b|0,c|0,+d,+e,f|0,g|0,h|0,i|0,j|0,k|0,l|0,m|0,n|0,o|0,p|0)|0}function LX(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;ud[a&7](b|0,c|0,d|0,e|0,f|0,g|0)}function MX(a,b,c,d,e,f,g,h,i,j,k,l,m,n){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;l=l|0;m=m|0;n=n|0;vd[a&3](b|0,c|0,d|0,e|0,f|0,g|0,h|0,i|0,j|0,k|0,l|0,m|0,n|0)}function NX(a,b){a=a|0;b=b|0;return+wd[a&1](b|0)}function OX(a,b,c,d,e,f,g,h,i,j,k){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;return xd[a&3](b|0,c|0,d|0,e|0,f|0,g|0,h|0,i|0,j|0,k|0)|0}function PX(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;yd[a&1](b|0,c|0,d|0,e|0,f|0,g|0,h|0)}function QX(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;zd[a&1](b|0,c|0,d|0,e|0,f|0,g|0,h|0,i|0,j|0)}function RX(a,b,c,d,e,f,g,h,i,j,k){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;Ad[a&1](b|0,c|0,d|0,e|0,f|0,g|0,h|0,i|0,j|0,k|0)}function SX(a,b,c){a=a|0;b=b|0;c=c|0;return Bd[a&255](b|0,c|0)|0}function TX(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return Cd[a&63](b|0,c|0,d|0,e|0,f|0)|0}function UX(a,b,c){a=a|0;b=b|0;c=c|0;return+Dd[a&3](b|0,c|0)}function VX(a,b,c,d,e,f,g,h,i){a=a|0;b=b|0;c=c|0;d=+d;e=+e;f=+f;g=+g;h=+h;i=+i;Ed[a&3](b|0,c|0,+d,+e,+f,+g,+h,+i)}function WX(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;return Fd[a&7](b|0,c|0,d|0,e|0,f|0,g|0,h|0,i|0,j|0)|0}function XX(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Gd[a&255](b|0,c|0,d|0)}function YX(a){a=a|0;Hd[a&1]()}function ZX(a,b,c,d){a=a|0;b=b|0;c=c|0;d=+d;Id[a&3](b|0,c|0,+d)}function _X(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;Jd[a&63](b|0,c|0,d|0,e|0)}function $X(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;ea(0);return 0}function aY(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;ea(1)}function bY(a){a=a|0;ea(2)}function cY(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=+d;e=+e;ea(3);return 0}function dY(a,b){a=a|0;b=b|0;ea(4)}function eY(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;ea(5);return 0}function fY(a){a=a|0;ea(6);return 0}function gY(a,b,c,d){a=a|0;b=b|0;c=+c;d=+d;ea(7)}function hY(a,b,c,d,e){a=a|0;b=+b;c=+c;d=d|0;e=e|0;ea(8)}function iY(a,b,c,d,e,f,g,h,i,j,k,l){a=a|0;b=b|0;c=+c;d=+d;e=+e;f=+f;g=+g;h=+h;i=i|0;j=j|0;k=k|0;l=l|0;ea(9)}function jY(a,b,c,d,e,f,g,h,i,j,k,l,m){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;l=+l;m=+m;ea(10);return 0}function kY(a,b,c,d){a=a|0;b=+b;c=c|0;d=d|0;ea(11)}function lY(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;ea(12);return 0}function mY(a,b,c,d,e,f,g,h,i){a=a|0;b=b|0;c=+c;d=+d;e=+e;f=+f;g=g|0;h=h|0;i=i|0;ea(13);return 0}function nY(a,b,c,d,e,f,g,h,i,j,k){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;ea(14)}function oY(a,b,c){a=a|0;b=b|0;c=c|0;ea(15);return 0}function pY(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){a=a|0;b=b|0;c=+c;d=+d;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;l=l|0;m=m|0;n=n|0;o=o|0;ea(16);return 0}function qY(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;ea(17)}function rY(a,b,c,d,e,f,g,h,i,j,k,l,m){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;l=l|0;m=m|0;ea(18)}function sY(a){a=a|0;ea(19);return 0.0}function tY(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;ea(20);return 0}function uY(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;ea(21)}function vY(a,b,c,d,e,f,g,h,i){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;ea(22)}function wY(a,b,c,d,e,f,g,h,i,j){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;ea(23)}function xY(a,b){a=a|0;b=b|0;ea(24);return 0}function yY(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;ea(25);return 0}function zY(a,b){a=a|0;b=b|0;ea(26);return 0.0}function AY(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=+c;d=+d;e=+e;f=+f;g=+g;h=+h;ea(27)}function BY(a,b,c,d,e,f,g,h,i){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;ea(28);return 0}function CY(a,b,c){a=a|0;b=b|0;c=c|0;ea(29)}function DY(){ea(30)}function EY(){Dc()}function FY(a,b,c){a=a|0;b=b|0;c=+c;ea(31)}function GY(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;ea(32)}




// EMSCRIPTEN_END_FUNCS
var dd=[$X,bQ];var ed=[aY,LM,xW,wW];var fd=[bY,Te,Se,tg,sg,Gg,Fg,Jg,Ig,Pg,Og,Sg,hi,WF,Oi,Pi,hj,ij,tj,sj,kj,jj,vj,wj,rm,Fj,Ej,Hj,Ij,Ql,Nj,Mj,Pj,Qj,dm,Vj,Uj,Xj,Yj,km,ak,Pm,Rm,ik,hk,jk,ok,nk,pk,vk,uk,Bk,Fk,Ek,Gk,Kk,Jk,Mk,Lk,Vk,Uk,Xk,$k,Wk,sl,rl,ul,tl,Hl,Gl,Cm,yn,zn,ln,An,Gn,Fn,Xn,Wn,Yp,Xp,fq,eq,sq,rq,uq,jt,kt,lt,mt,sr,rr,nt,ot,pt,qt,Cr,Br,Kr,Jr,Or,Nr,Rr,Qr,Wr,Vr,_r,Zr,bs,as,fs,es,ks,js,us,ts,zs,ys,Cs,Bs,Fs,Es,Js,Is,Ms,Ls,Ps,Os,Ss,Rs,Ws,Vs,$s,_s,Hu,Gu,Iu,iv,hv,Sv,lv,kv,ov,Tv,Uv,qv,sv,rv,Vv,Wv,xv,wv,zv,Dv,Cv,Gv,Fv,Jv,Iv,Kv,Wx,Vx,ey,dy,oy,ny,Iy,Uy,az,hz,pz,wz,Cz,Kz,Jz,Uz,Tz,bA,aA,iA,hA,pA,oA,zA,yA,DA,CA,GA,FA,PA,OA,UA,TA,ZA,YA,cB,bB,jB,iB,TC,SC,YC,XC,_C,ZC,aD,$C,dD,cD,eD,gD,HD,GD,ID,KD,yE,xE,BE,AE,EE,DE,HE,GE,JE,IE,ME,LE,PE,OE,SE,RE,VE,UE,YE,XE,_E,ZE,xF,yF,wG,xG,vG,yG,MG,NG,QG,PG,$G,_G,rH,qH,wH,vH,DH,HH,LH,KH,OH,TH,SH,$H,_H,cI,sI,uI,vI,NI,MI,tL,xL,QL,VL,cM,kM,mM,vM,xM,zM,AM,BM,MM,SM,UM,XM,_M,dN,hN,tN,dO,jP,IP,SP,UP,cQ,dQ,kQ,IQ,aR,dR,fR,mS,pS,rS,tS,dT,gT,iT,kT,yT,BT,DT,FT,WT,tU,MU,RU,eV,hV,jV,lV,sV,wV,nW,qW,oW,pW,rW,KW,JW,rL,IL,KL,IN,DN,vN,mO,rO,yO,vO,UQ,YR,wU,cW,iW,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY,bY];var gd=[cY,Ph,Bi,cY];var hd=[dY,wg,zh,NF,Tg,Ug,Vg,Xg,Yg,Zg,_g,$g,ah,bh,ii,ji,ki,li,ch,eh,fh,gh,hh,mi,ni,oi,ih,qi,ri,si,ti,ui,vi,wi,kh,mh,nh,oh,ph,qh,Ei,Fi,Hi,th,wh,xh,QF,SF,Ki,Ih,Lh,Nh,Kj,Sj,_j,nm,gk,$y,fz,oz,uz,Bz,Hz,Rz,_z,gA,nA,uA,vL,AL,HM,FS,GS,HS,IS,JS,KS,LS,MS,NS,OS,oT,pT,qT,JT,KT,LT,MT,gU,kU,oU,LL,GN,fW,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY,dY];var id=[eY,UN,$P,eY];var jd=[fY,vg,yg,zg,Ag,Bg,Cg,Dg,Eg,Sh,Uh,Vh,Wh,Qh,Rh,Yh,Zh,_h,ai,bi,ci,di,Mi,XF,Mh,lj,Tl,Ul,Vl,Il,Kl,Ll,Yl,Zl,qm,sm,tm,um,vm,wm,Ml,Nl,Ol,Pl,Rl,Wl,_l,$l,am,bm,cm,em,fm,gm,hm,im,jm,lm,mm,Om,ck,dk,Qm,Sm,fk,om,pm,kk,xm,ym,qk,Hm,wk,yk,Ak,Im,Jm,Km,zm,Am,Nk,Lm,al,cl,Mm,vl,xl,Al,Nm,Bm,Dm,Em,wq,xq,et,gt,ht,it,Ou,Ku,Mu,Ju,Pu,xy,yy,gy,zy,ry,qy,Vy,dC,eC,fC,gC,cC,bz,pC,aC,bC,qC,iz,hC,iC,jC,kC,qz,rC,sC,xz,lC,mC,Dz,tC,uC,Lz,vC,Qz,wC,Vz,xC,yC,zC,cA,AC,BC,CC,jA,DC,EC,FC,qA,nC,oC,AA,EA,QA,VA,_A,dB,lB,AD,BD,CD,DD,ED,hD,iD,jD,aE,LD,ND,$E,aF,bF,cF,dF,eF,fF,gF,hF,iF,jF,kF,nF,oF,lF,mF,pF,qF,rF,sF,tF,uF,dI,eI,fI,gI,hI,iI,jI,kI,lI,mI,nI,oI,pI,qI,rI,lM,CM,QM,YM,LN,MN,NN,sN,TN,XN,YN,eO,CP,JQ,$Q,eR,gR,lS,qS,sS,bT,ZS,cT,hT,jT,wT,xT,CT,ET,RT,PT,sU,dV,iV,kV,GV,HV,IV,JV,XV,VV,LW,zt,At,nu,pu,VR,WR,XR,nR,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY,fY];var kd=[gY,uh];var ld=[hY,OF,PF,hY];var md=[iY,rh];var nd=[jY,yi];var od=[kY,Hg];var pd=[lY,Th,Kg,vq,VI,WL,gM,nM,oM,wM,GM,WM,fO,gO,mP,xP,JP,ZP,yP,KQ,LQ,OQ,PQ,YQ,hR,iR,uS,vS,$S,WS,lT,rT,GT,ST,XT,SU,mV,nV,TV,PV,NL,qN,eK,UR,dW,hW,lY,lY,lY,lY,lY,lY,lY,lY,lY,lY,lY,lY,lY,lY,lY,lY,lY,lY];var qd=[mY,sh];var rd=[nY,Xh];var sd=[oY,ug,zi,Ai,Ci,Oh,Di,oj,pj,mj,Xl,lk,rk,Ck,Hk,Sk,ol,Bl,wl,Fm,kD,OD,KG,LG,sH,UI,tK,$L,aM,hM,qM,rM,sM,tM,uM,FM,PM,RM,VM,bO,iO,nP,pP,qP,KP,MP,aQ,AP,eQ,gQ,iQ,lQ,mQ,vP,wP,NQ,XQ,iS,kS,dS,SS,TS,VS,tT,eU,iU,mU,qU,bV,cV,RV,sW,Ve,We,Ch,Bh,Eh,HN,uK,BR,wR,ER,FR,xR,yR,CR,DR,IR,JR,KR,LR,zS,eW,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY,oY];var td=[pY,gi];var ud=[qY,Kh,zW,yW,kO,lO,pO,qO];var vd=[rY,Fh,Gh,rY];var wd=[sY,ft];var xd=[tY,fy,py,tY];var yd=[uY,Hh];var zd=[vY,Ah];var Ad=[wY,Dh];var Bd=[xY,xg,$h,ei,fi,Ji,Qi,gj,Sl,mk,sk,Dk,Ik,Tk,pl,Cl,Gm,Bn,Nu,lD,PD,wF,zG,tI,RI,SI,TI,sL,uL,wL,yL,BL,PL,RL,SL,TL,XL,YL,bM,dM,eM,iM,DM,NM,ZM,$M,aN,bN,cN,eN,fN,gN,iN,jN,VN,WN,SN,$N,cO,AO,BO,CO,DO,EO,FO,GO,HO,IO,JO,KO,LO,MO,NO,OO,PO,QO,RO,SO,TO,UO,VO,WO,XO,YO,ZO,_O,$O,aP,bP,cP,dP,eP,fP,gP,hP,iP,kP,lP,oP,rP,sP,tP,LP,NP,OP,PP,QP,RP,TP,VP,WP,XP,YP,_P,fQ,hQ,jQ,EP,zP,uP,FQ,HQ,VQ,WQ,bR,kR,lR,jS,nS,wS,yS,aT,XS,YS,_S,RS,US,eT,mT,uT,vT,sT,zT,HT,IT,TT,NT,OT,QT,UT,YT,ZT,$T,aU,bU,cU,dU,fU,hU,jU,lU,nU,pU,LU,NU,OU,PU,TU,UU,fV,pV,qV,rV,tV,uV,vV,xV,yV,WV,UV,SV,QV,yh,Dq,Xq,gr,cv,ly,my,HK,JL,lN,oN,wN,ZN,tQ,uQ,oR,rR,BS,AS,nT,aV,zV,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY,xY];var Cd=[yY,fj,Gj,Oj,Wj,bk,vF,dL,eL,fL,gL,hL,iL,jL,kL,lL,UL,sK,fM,jM,EM,JM,KM,GP,HP,DP,nQ,FP,cR,jR,oS,xS,fT,AT,VT,rU,QU,gV,oV,rN,WU,ZU,$U,yY,yY,yY,yY,yY,yY,yY,yY,yY,yY,yY,yY,yY,yY,yY,yY,yY,yY,yY,yY,yY];var Dd=[zY,yH,QI,zY];var Ed=[AY,Wg,vh,AY];var Fd=[BY,xH,OI,PI,TM,BY,BY,BY];var Gd=[CY,Re,Rg,Gi,Ii,RF,TF,UF,VF,Li,Jh,Ni,nj,Jl,xj,Jj,Rj,Zj,ek,zk,zl,Gr,Sr,Xr,cs,gs,qs,vs,Gs,Ts,Xs,Yv,Zv,_v,$v,aw,bw,cw,dw,ew,fw,gw,hw,iw,jw,kw,lw,mw,nw,ow,pw,qw,rw,sw,tw,uw,vw,ww,xw,yw,zw,Aw,Bw,Cw,Dw,Ew,Fw,Gw,Hw,Iw,Jw,Kw,Lw,Mw,Nw,Ow,Pw,Qw,Rw,Sw,Tw,Uw,Vw,Ww,Xw,Yw,Zw,_w,$w,ax,bx,cx,dx,ex,fx,gx,hx,ix,jx,kx,lx,Wy,Yy,_y,cz,dz,ez,jz,lz,nz,rz,sz,tz,yz,zz,Az,Ez,Fz,Gz,Mz,Nz,Pz,Wz,Xz,Zz,dA,eA,fA,kA,lA,mA,rA,sA,tA,QD,IH,MH,PH,UH,aI,zL,pN,aO,hO,GQ,MQ,EN,FN,zN,jO,oO,pR,qR,sR,tR,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY,CY];var Hd=[DY,EY];var Id=[FY,pi,xi,FY];var Jd=[GY,Ri,Si,Ti,Ui,Vi,Wi,Xi,Yi,Zi,_i,$i,aj,bj,cj,dj,Xy,Zy,Sy,_B,$B,kz,mz,Iz,Oz,Sz,Yz,$z,yM,IM,OM,tW,uW,xN,yN,vJ,RQ,MR,NR,OR,PR,QR,RR,GY,GY,GY,GY,GY,GY,GY,GY,GY,GY,GY,GY,GY,GY,GY,GY,GY,GY,GY,GY,GY];return{_saveSetjmp:YW,_memcmp:iX,_strncasecmp:XW,_strcat:cX,_free:BW,_main:_d,_realloc:CW,_i64Add:gX,_memmove:aX,_tolower:WW,_strlen:ZW,_memset:bX,_malloc:AW,_bitshift64Ashr:_W,_memcpy:$W,_strncpy:hX,_bitshift64Lshr:jX,_bitshift64Shl:dX,_i64Subtract:fX,_strcpy:eX,_testSetjmp:kX,runPostSets:VW,stackAlloc:Kd,stackSave:Ld,stackRestore:Md,setThrew:Nd,setTempRet0:Qd,setTempRet1:Rd,setTempRet2:Sd,setTempRet3:Td,setTempRet4:Ud,setTempRet5:Vd,setTempRet6:Wd,setTempRet7:Xd,setTempRet8:Yd,setTempRet9:Zd,dynCall_iiiiiiii:uX,dynCall_viiiii:vX,dynCall_vi:wX,dynCall_iiiidd:xX,dynCall_vii:yX,dynCall_iiiiiii:zX,dynCall_ii:AX,dynCall_viidd:BX,dynCall_viddii:CX,dynCall_viiddddddiiii:DX,dynCall_iiiiiiiiiiiidd:EX,dynCall_vidii:FX,dynCall_iiiii:GX,dynCall_iiiddddiii:HX,dynCall_viiiiiiiiiii:IX,dynCall_iiii:JX,dynCall_iiiddiiiiiiiiiii:KX,dynCall_viiiiii:LX,dynCall_viiiiiiiiiiiii:MX,dynCall_di:NX,dynCall_iiiiiiiiiii:OX,dynCall_viiiiiii:PX,dynCall_viiiiiiiii:QX,dynCall_viiiiiiiiii:RX,dynCall_iii:SX,dynCall_iiiiii:TX,dynCall_dii:UX,dynCall_viidddddd:VX,dynCall_iiiiiiiiii:WX,dynCall_viii:XX,dynCall_v:YX,dynCall_viid:ZX,dynCall_viiii:_X}})


// EMSCRIPTEN_END_ASM
({ "Math": Math, "Int8Array": Int8Array, "Int16Array": Int16Array, "Int32Array": Int32Array, "Uint8Array": Uint8Array, "Uint16Array": Uint16Array, "Uint32Array": Uint32Array, "Float32Array": Float32Array, "Float64Array": Float64Array }, { "abort": abort, "assert": assert, "asmPrintInt": asmPrintInt, "asmPrintFloat": asmPrintFloat, "min": Math_min, "invoke_iiiiiiii": invoke_iiiiiiii, "invoke_viiiii": invoke_viiiii, "invoke_vi": invoke_vi, "invoke_iiiidd": invoke_iiiidd, "invoke_vii": invoke_vii, "invoke_iiiiiii": invoke_iiiiiii, "invoke_ii": invoke_ii, "invoke_viidd": invoke_viidd, "invoke_viddii": invoke_viddii, "invoke_viiddddddiiii": invoke_viiddddddiiii, "invoke_iiiiiiiiiiiidd": invoke_iiiiiiiiiiiidd, "invoke_vidii": invoke_vidii, "invoke_iiiii": invoke_iiiii, "invoke_iiiddddiii": invoke_iiiddddiii, "invoke_viiiiiiiiiii": invoke_viiiiiiiiiii, "invoke_iiii": invoke_iiii, "invoke_iiiddiiiiiiiiiii": invoke_iiiddiiiiiiiiiii, "invoke_viiiiii": invoke_viiiiii, "invoke_viiiiiiiiiiiii": invoke_viiiiiiiiiiiii, "invoke_di": invoke_di, "invoke_iiiiiiiiiii": invoke_iiiiiiiiiii, "invoke_viiiiiii": invoke_viiiiiii, "invoke_viiiiiiiii": invoke_viiiiiiiii, "invoke_viiiiiiiiii": invoke_viiiiiiiiii, "invoke_iii": invoke_iii, "invoke_iiiiii": invoke_iiiiii, "invoke_dii": invoke_dii, "invoke_viidddddd": invoke_viidddddd, "invoke_iiiiiiiiii": invoke_iiiiiiiiii, "invoke_viii": invoke_viii, "invoke_v": invoke_v, "invoke_viid": invoke_viid, "invoke_viiii": invoke_viiii, "_isalnum": _isalnum, "_fabs": _fabs, "_strrchr": _strrchr, "_fread": _fread, "_memchr": _memchr, "_inflateReset": _inflateReset, "__reallyNegative": __reallyNegative, "_fstat": _fstat, "___assert_fail": ___assert_fail, "__ZSt18uncaught_exceptionv": __ZSt18uncaught_exceptionv, "_longjmp": _longjmp, "_fsync": _fsync, "_sbrk": _sbrk, "_sysconf": _sysconf, "_close": _close, "_cos": _cos, "_readdir": _readdir, "_puts": _puts, "_FcPatternBuild": _FcPatternBuild, "_unlink": _unlink, "_write": _write, "_ftell": _ftell, "_rand": _rand, "__ZNSt9exceptionD2Ev": __ZNSt9exceptionD2Ev, "___cxa_does_inherit": ___cxa_does_inherit, "_strstr": _strstr, "_FcPatternDestroy": _FcPatternDestroy, "_qsort": _qsort, "_closedir": _closedir, "_FcPatternGetInteger": _FcPatternGetInteger, "_send": _send, "_pow": _pow, "_atan2": _atan2, "___cxa_is_number_type": ___cxa_is_number_type, "_FcConfigSubstitute": _FcConfigSubstitute, "_fcntl": _fcntl, "___cxa_find_matching_catch": ___cxa_find_matching_catch, "_opendir": _opendir, "_isalpha": _isalpha, "_strtol": _strtol, "___setErrNo": ___setErrNo, "___resumeException": ___resumeException, "_srand": _srand, "_strchr": _strchr, "_ceil": _ceil, "_putchar": _putchar, "___buildEnvironment": ___buildEnvironment, "_localeconv": _localeconv, "_printf": _printf, "_sprintf": _sprintf, "_strtok_r": _strtok_r, "_stat": _stat, "_FcPatternAddInteger": _FcPatternAddInteger, "_getpwnam": _getpwnam, "_read": _read, "_fwrite": _fwrite, "_FcPatternGetString": _FcPatternGetString, "_time": _time, "_pthread_mutex_lock": _pthread_mutex_lock, "_gettimeofday": _gettimeofday, "_munmap": _munmap, "_mmap": _mmap, "_exit": _exit, "_readdir_r": _readdir_r, "_inflate": _inflate, "_fmod": _fmod, "_lseek": _lseek, "_vfprintf": _vfprintf, "___cxa_allocate_exception": ___cxa_allocate_exception, "_asin": _asin, "_atoi": _atoi, "_pwrite": _pwrite, "_open": _open, "_snprintf": _snprintf, "_FcFontSort": _FcFontSort, "_fseek": _fseek, "_pthread_mutex_destroy": _pthread_mutex_destroy, "_isxdigit": _isxdigit, "_fclose": _fclose, "__parseInt": __parseInt, "_log": _log, "_recv": _recv, "_fgetc": _fgetc, "__getFloat": __getFloat, "_fputc": _fputc, "_abort": _abort, "___cxa_throw": ___cxa_throw, "_strncmp": _strncmp, "_inflateInit2_": _inflateInit2_, "_isspace": _isspace, "_fopen": _fopen, "_floor": _floor, "_getgid": _getgid, "_sin": _sin, "_acos": _acos, "___cxa_pure_virtual": ___cxa_pure_virtual, "_ungetc": _ungetc, "_fflush": _fflush, "_fprintf": _fprintf, "_sscanf": _sscanf, "_strdup": _strdup, "__exit": __exit, "_strcspn": _strcspn, "_log10": _log10, "_pthread_mutex_unlock": _pthread_mutex_unlock, "_pread": _pread, "_FcDefaultSubstitute": _FcDefaultSubstitute, "___errno_location": ___errno_location, "_strcmp": _strcmp, "_getpwuid": _getpwuid, "_copysign": _copysign, "_getenv": _getenv, "__scanString": __scanString, "_FcFontSetDestroy": _FcFontSetDestroy, "_inflateEnd": _inflateEnd, "_strerror": _strerror, "_emscripten_longjmp": _emscripten_longjmp, "__formatString": __formatString, "_fputs": _fputs, "_sqrt": _sqrt, "_pthread_mutex_init": _pthread_mutex_init, "_strerror_r": _strerror_r, "STACKTOP": STACKTOP, "STACK_MAX": STACK_MAX, "tempDoublePtr": tempDoublePtr, "ABORT": ABORT, "cttz_i8": cttz_i8, "ctlz_i8": ctlz_i8, "NaN": NaN, "Infinity": Infinity, "__ZTISt9exception": __ZTISt9exception, "_stderr": _stderr, "_stdin": _stdin, "_stdout": _stdout }, buffer);
var _saveSetjmp = Module["_saveSetjmp"] = asm["_saveSetjmp"];
var _memcmp = Module["_memcmp"] = asm["_memcmp"];
var _strncasecmp = Module["_strncasecmp"] = asm["_strncasecmp"];
var _strcat = Module["_strcat"] = asm["_strcat"];
var _free = Module["_free"] = asm["_free"];
var _main = Module["_main"] = asm["_main"];
var _realloc = Module["_realloc"] = asm["_realloc"];
var _i64Add = Module["_i64Add"] = asm["_i64Add"];
var _memmove = Module["_memmove"] = asm["_memmove"];
var _tolower = Module["_tolower"] = asm["_tolower"];
var _strlen = Module["_strlen"] = asm["_strlen"];
var _memset = Module["_memset"] = asm["_memset"];
var _malloc = Module["_malloc"] = asm["_malloc"];
var _bitshift64Ashr = Module["_bitshift64Ashr"] = asm["_bitshift64Ashr"];
var _memcpy = Module["_memcpy"] = asm["_memcpy"];
var _strncpy = Module["_strncpy"] = asm["_strncpy"];
var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
var _strcpy = Module["_strcpy"] = asm["_strcpy"];
var _testSetjmp = Module["_testSetjmp"] = asm["_testSetjmp"];
var runPostSets = Module["runPostSets"] = asm["runPostSets"];
var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = asm["dynCall_iiiiiiii"];
var dynCall_viiiii = Module["dynCall_viiiii"] = asm["dynCall_viiiii"];
var dynCall_vi = Module["dynCall_vi"] = asm["dynCall_vi"];
var dynCall_iiiidd = Module["dynCall_iiiidd"] = asm["dynCall_iiiidd"];
var dynCall_vii = Module["dynCall_vii"] = asm["dynCall_vii"];
var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = asm["dynCall_iiiiiii"];
var dynCall_ii = Module["dynCall_ii"] = asm["dynCall_ii"];
var dynCall_viidd = Module["dynCall_viidd"] = asm["dynCall_viidd"];
var dynCall_viddii = Module["dynCall_viddii"] = asm["dynCall_viddii"];
var dynCall_viiddddddiiii = Module["dynCall_viiddddddiiii"] = asm["dynCall_viiddddddiiii"];
var dynCall_iiiiiiiiiiiidd = Module["dynCall_iiiiiiiiiiiidd"] = asm["dynCall_iiiiiiiiiiiidd"];
var dynCall_vidii = Module["dynCall_vidii"] = asm["dynCall_vidii"];
var dynCall_iiiii = Module["dynCall_iiiii"] = asm["dynCall_iiiii"];
var dynCall_iiiddddiii = Module["dynCall_iiiddddiii"] = asm["dynCall_iiiddddiii"];
var dynCall_viiiiiiiiiii = Module["dynCall_viiiiiiiiiii"] = asm["dynCall_viiiiiiiiiii"];
var dynCall_iiii = Module["dynCall_iiii"] = asm["dynCall_iiii"];
var dynCall_iiiddiiiiiiiiiii = Module["dynCall_iiiddiiiiiiiiiii"] = asm["dynCall_iiiddiiiiiiiiiii"];
var dynCall_viiiiii = Module["dynCall_viiiiii"] = asm["dynCall_viiiiii"];
var dynCall_viiiiiiiiiiiii = Module["dynCall_viiiiiiiiiiiii"] = asm["dynCall_viiiiiiiiiiiii"];
var dynCall_di = Module["dynCall_di"] = asm["dynCall_di"];
var dynCall_iiiiiiiiiii = Module["dynCall_iiiiiiiiiii"] = asm["dynCall_iiiiiiiiiii"];
var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = asm["dynCall_viiiiiii"];
var dynCall_viiiiiiiii = Module["dynCall_viiiiiiiii"] = asm["dynCall_viiiiiiiii"];
var dynCall_viiiiiiiiii = Module["dynCall_viiiiiiiiii"] = asm["dynCall_viiiiiiiiii"];
var dynCall_iii = Module["dynCall_iii"] = asm["dynCall_iii"];
var dynCall_iiiiii = Module["dynCall_iiiiii"] = asm["dynCall_iiiiii"];
var dynCall_dii = Module["dynCall_dii"] = asm["dynCall_dii"];
var dynCall_viidddddd = Module["dynCall_viidddddd"] = asm["dynCall_viidddddd"];
var dynCall_iiiiiiiiii = Module["dynCall_iiiiiiiiii"] = asm["dynCall_iiiiiiiiii"];
var dynCall_viii = Module["dynCall_viii"] = asm["dynCall_viii"];
var dynCall_v = Module["dynCall_v"] = asm["dynCall_v"];
var dynCall_viid = Module["dynCall_viid"] = asm["dynCall_viid"];
var dynCall_viiii = Module["dynCall_viiii"] = asm["dynCall_viiii"];

Runtime.stackAlloc = function(size) { return asm['stackAlloc'](size) };
Runtime.stackSave = function() { return asm['stackSave']() };
Runtime.stackRestore = function(top) { asm['stackRestore'](top) };


// TODO: strip out parts of this we do not need

//======= begin closure i64 code =======

// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines a Long class for representing a 64-bit two's-complement
 * integer value, which faithfully simulates the behavior of a Java "long". This
 * implementation is derived from LongLib in GWT.
 *
 */

var i64Math = (function() { // Emscripten wrapper
  var goog = { math: {} };


  /**
   * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
   * values as *signed* integers.  See the from* functions below for more
   * convenient ways of constructing Longs.
   *
   * The internal representation of a long is the two given signed, 32-bit values.
   * We use 32-bit pieces because these are the size of integers on which
   * Javascript performs bit-operations.  For operations like addition and
   * multiplication, we split each number into 16-bit pieces, which can easily be
   * multiplied within Javascript's floating-point representation without overflow
   * or change in sign.
   *
   * In the algorithms below, we frequently reduce the negative case to the
   * positive case by negating the input(s) and then post-processing the result.
   * Note that we must ALWAYS check specially whether those values are MIN_VALUE
   * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
   * a positive number, it overflows back into a negative).  Not handling this
   * case would often result in infinite recursion.
   *
   * @param {number} low  The low (signed) 32 bits of the long.
   * @param {number} high  The high (signed) 32 bits of the long.
   * @constructor
   */
  goog.math.Long = function(low, high) {
    /**
     * @type {number}
     * @private
     */
    this.low_ = low | 0;  // force into 32 signed bits.

    /**
     * @type {number}
     * @private
     */
    this.high_ = high | 0;  // force into 32 signed bits.
  };


  // NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
  // from* methods on which they depend.


  /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @private
   */
  goog.math.Long.IntCache_ = {};


  /**
   * Returns a Long representing the given (32-bit) integer value.
   * @param {number} value The 32-bit integer in question.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromInt = function(value) {
    if (-128 <= value && value < 128) {
      var cachedObj = goog.math.Long.IntCache_[value];
      if (cachedObj) {
        return cachedObj;
      }
    }

    var obj = new goog.math.Long(value | 0, value < 0 ? -1 : 0);
    if (-128 <= value && value < 128) {
      goog.math.Long.IntCache_[value] = obj;
    }
    return obj;
  };


  /**
   * Returns a Long representing the given value, provided that it is a finite
   * number.  Otherwise, zero is returned.
   * @param {number} value The number in question.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromNumber = function(value) {
    if (isNaN(value) || !isFinite(value)) {
      return goog.math.Long.ZERO;
    } else if (value <= -goog.math.Long.TWO_PWR_63_DBL_) {
      return goog.math.Long.MIN_VALUE;
    } else if (value + 1 >= goog.math.Long.TWO_PWR_63_DBL_) {
      return goog.math.Long.MAX_VALUE;
    } else if (value < 0) {
      return goog.math.Long.fromNumber(-value).negate();
    } else {
      return new goog.math.Long(
          (value % goog.math.Long.TWO_PWR_32_DBL_) | 0,
          (value / goog.math.Long.TWO_PWR_32_DBL_) | 0);
    }
  };


  /**
   * Returns a Long representing the 64-bit integer that comes by concatenating
   * the given high and low bits.  Each is assumed to use 32 bits.
   * @param {number} lowBits The low 32-bits.
   * @param {number} highBits The high 32-bits.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromBits = function(lowBits, highBits) {
    return new goog.math.Long(lowBits, highBits);
  };


  /**
   * Returns a Long representation of the given string, written using the given
   * radix.
   * @param {string} str The textual representation of the Long.
   * @param {number=} opt_radix The radix in which the text is written.
   * @return {!goog.math.Long} The corresponding Long value.
   */
  goog.math.Long.fromString = function(str, opt_radix) {
    if (str.length == 0) {
      throw Error('number format error: empty string');
    }

    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error('radix out of range: ' + radix);
    }

    if (str.charAt(0) == '-') {
      return goog.math.Long.fromString(str.substring(1), radix).negate();
    } else if (str.indexOf('-') >= 0) {
      throw Error('number format error: interior "-" character: ' + str);
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 8));

    var result = goog.math.Long.ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i);
      var value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = goog.math.Long.fromNumber(Math.pow(radix, size));
        result = result.multiply(power).add(goog.math.Long.fromNumber(value));
      } else {
        result = result.multiply(radixToPower);
        result = result.add(goog.math.Long.fromNumber(value));
      }
    }
    return result;
  };


  // NOTE: the compiler should inline these constant values below and then remove
  // these variables, so there should be no runtime penalty for these.


  /**
   * Number used repeated below in calculations.  This must appear before the
   * first call to any from* function below.
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_16_DBL_ = 1 << 16;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_24_DBL_ = 1 << 24;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_32_DBL_ =
      goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_31_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ / 2;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_48_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_64_DBL_ =
      goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;


  /**
   * @type {number}
   * @private
   */
  goog.math.Long.TWO_PWR_63_DBL_ =
      goog.math.Long.TWO_PWR_64_DBL_ / 2;


  /** @type {!goog.math.Long} */
  goog.math.Long.ZERO = goog.math.Long.fromInt(0);


  /** @type {!goog.math.Long} */
  goog.math.Long.ONE = goog.math.Long.fromInt(1);


  /** @type {!goog.math.Long} */
  goog.math.Long.NEG_ONE = goog.math.Long.fromInt(-1);


  /** @type {!goog.math.Long} */
  goog.math.Long.MAX_VALUE =
      goog.math.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);


  /** @type {!goog.math.Long} */
  goog.math.Long.MIN_VALUE = goog.math.Long.fromBits(0, 0x80000000 | 0);


  /**
   * @type {!goog.math.Long}
   * @private
   */
  goog.math.Long.TWO_PWR_24_ = goog.math.Long.fromInt(1 << 24);


  /** @return {number} The value, assuming it is a 32-bit integer. */
  goog.math.Long.prototype.toInt = function() {
    return this.low_;
  };


  /** @return {number} The closest floating-point representation to this value. */
  goog.math.Long.prototype.toNumber = function() {
    return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ +
           this.getLowBitsUnsigned();
  };


  /**
   * @param {number=} opt_radix The radix in which the text should be written.
   * @return {string} The textual representation of this value.
   */
  goog.math.Long.prototype.toString = function(opt_radix) {
    var radix = opt_radix || 10;
    if (radix < 2 || 36 < radix) {
      throw Error('radix out of range: ' + radix);
    }

    if (this.isZero()) {
      return '0';
    }

    if (this.isNegative()) {
      if (this.equals(goog.math.Long.MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = goog.math.Long.fromNumber(radix);
        var div = this.div(radixLong);
        var rem = div.multiply(radixLong).subtract(this);
        return div.toString(radix) + rem.toInt().toString(radix);
      } else {
        return '-' + this.negate().toString(radix);
      }
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 6));

    var rem = this;
    var result = '';
    while (true) {
      var remDiv = rem.div(radixToPower);
      var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
      var digits = intval.toString(radix);

      rem = remDiv;
      if (rem.isZero()) {
        return digits + result;
      } else {
        while (digits.length < 6) {
          digits = '0' + digits;
        }
        result = '' + digits + result;
      }
    }
  };


  /** @return {number} The high 32-bits as a signed value. */
  goog.math.Long.prototype.getHighBits = function() {
    return this.high_;
  };


  /** @return {number} The low 32-bits as a signed value. */
  goog.math.Long.prototype.getLowBits = function() {
    return this.low_;
  };


  /** @return {number} The low 32-bits as an unsigned value. */
  goog.math.Long.prototype.getLowBitsUnsigned = function() {
    return (this.low_ >= 0) ?
        this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;
  };


  /**
   * @return {number} Returns the number of bits needed to represent the absolute
   *     value of this Long.
   */
  goog.math.Long.prototype.getNumBitsAbs = function() {
    if (this.isNegative()) {
      if (this.equals(goog.math.Long.MIN_VALUE)) {
        return 64;
      } else {
        return this.negate().getNumBitsAbs();
      }
    } else {
      var val = this.high_ != 0 ? this.high_ : this.low_;
      for (var bit = 31; bit > 0; bit--) {
        if ((val & (1 << bit)) != 0) {
          break;
        }
      }
      return this.high_ != 0 ? bit + 33 : bit + 1;
    }
  };


  /** @return {boolean} Whether this value is zero. */
  goog.math.Long.prototype.isZero = function() {
    return this.high_ == 0 && this.low_ == 0;
  };


  /** @return {boolean} Whether this value is negative. */
  goog.math.Long.prototype.isNegative = function() {
    return this.high_ < 0;
  };


  /** @return {boolean} Whether this value is odd. */
  goog.math.Long.prototype.isOdd = function() {
    return (this.low_ & 1) == 1;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long equals the other.
   */
  goog.math.Long.prototype.equals = function(other) {
    return (this.high_ == other.high_) && (this.low_ == other.low_);
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long does not equal the other.
   */
  goog.math.Long.prototype.notEquals = function(other) {
    return (this.high_ != other.high_) || (this.low_ != other.low_);
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is less than the other.
   */
  goog.math.Long.prototype.lessThan = function(other) {
    return this.compare(other) < 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is less than or equal to the other.
   */
  goog.math.Long.prototype.lessThanOrEqual = function(other) {
    return this.compare(other) <= 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is greater than the other.
   */
  goog.math.Long.prototype.greaterThan = function(other) {
    return this.compare(other) > 0;
  };


  /**
   * @param {goog.math.Long} other Long to compare against.
   * @return {boolean} Whether this Long is greater than or equal to the other.
   */
  goog.math.Long.prototype.greaterThanOrEqual = function(other) {
    return this.compare(other) >= 0;
  };


  /**
   * Compares this Long with the given one.
   * @param {goog.math.Long} other Long to compare against.
   * @return {number} 0 if they are the same, 1 if the this is greater, and -1
   *     if the given one is greater.
   */
  goog.math.Long.prototype.compare = function(other) {
    if (this.equals(other)) {
      return 0;
    }

    var thisNeg = this.isNegative();
    var otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) {
      return -1;
    }
    if (!thisNeg && otherNeg) {
      return 1;
    }

    // at this point, the signs are the same, so subtraction will not overflow
    if (this.subtract(other).isNegative()) {
      return -1;
    } else {
      return 1;
    }
  };


  /** @return {!goog.math.Long} The negation of this value. */
  goog.math.Long.prototype.negate = function() {
    if (this.equals(goog.math.Long.MIN_VALUE)) {
      return goog.math.Long.MIN_VALUE;
    } else {
      return this.not().add(goog.math.Long.ONE);
    }
  };


  /**
   * Returns the sum of this and the given Long.
   * @param {goog.math.Long} other Long to add to this one.
   * @return {!goog.math.Long} The sum of this and the given Long.
   */
  goog.math.Long.prototype.add = function(other) {
    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 0xFFFF;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 0xFFFF;

    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 0xFFFF;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
  };


  /**
   * Returns the difference of this and the given Long.
   * @param {goog.math.Long} other Long to subtract from this.
   * @return {!goog.math.Long} The difference of this and the given Long.
   */
  goog.math.Long.prototype.subtract = function(other) {
    return this.add(other.negate());
  };


  /**
   * Returns the product of this and the given long.
   * @param {goog.math.Long} other Long to multiply with this.
   * @return {!goog.math.Long} The product of this and the other.
   */
  goog.math.Long.prototype.multiply = function(other) {
    if (this.isZero()) {
      return goog.math.Long.ZERO;
    } else if (other.isZero()) {
      return goog.math.Long.ZERO;
    }

    if (this.equals(goog.math.Long.MIN_VALUE)) {
      return other.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
    } else if (other.equals(goog.math.Long.MIN_VALUE)) {
      return this.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;
    }

    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().multiply(other.negate());
      } else {
        return this.negate().multiply(other).negate();
      }
    } else if (other.isNegative()) {
      return this.multiply(other.negate()).negate();
    }

    // If both longs are small, use float multiplication
    if (this.lessThan(goog.math.Long.TWO_PWR_24_) &&
        other.lessThan(goog.math.Long.TWO_PWR_24_)) {
      return goog.math.Long.fromNumber(this.toNumber() * other.toNumber());
    }

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 0xFFFF;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 0xFFFF;

    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 0xFFFF;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
  };


  /**
   * Returns this Long divided by the given one.
   * @param {goog.math.Long} other Long by which to divide.
   * @return {!goog.math.Long} This Long divided by the given one.
   */
  goog.math.Long.prototype.div = function(other) {
    if (other.isZero()) {
      throw Error('division by zero');
    } else if (this.isZero()) {
      return goog.math.Long.ZERO;
    }

    if (this.equals(goog.math.Long.MIN_VALUE)) {
      if (other.equals(goog.math.Long.ONE) ||
          other.equals(goog.math.Long.NEG_ONE)) {
        return goog.math.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
      } else if (other.equals(goog.math.Long.MIN_VALUE)) {
        return goog.math.Long.ONE;
      } else {
        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
        var halfThis = this.shiftRight(1);
        var approx = halfThis.div(other).shiftLeft(1);
        if (approx.equals(goog.math.Long.ZERO)) {
          return other.isNegative() ? goog.math.Long.ONE : goog.math.Long.NEG_ONE;
        } else {
          var rem = this.subtract(other.multiply(approx));
          var result = approx.add(rem.div(other));
          return result;
        }
      }
    } else if (other.equals(goog.math.Long.MIN_VALUE)) {
      return goog.math.Long.ZERO;
    }

    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().div(other.negate());
      } else {
        return this.negate().div(other).negate();
      }
    } else if (other.isNegative()) {
      return this.div(other.negate()).negate();
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    var res = goog.math.Long.ZERO;
    var rem = this;
    while (rem.greaterThanOrEqual(other)) {
      // Approximate the result of division. This may be a little greater or
      // smaller than the actual value.
      var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

      // We will tweak the approximate result by changing it in the 48-th digit or
      // the smallest non-fractional digit, whichever is larger.
      var log2 = Math.ceil(Math.log(approx) / Math.LN2);
      var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

      // Decrease the approximation until it is smaller than the remainder.  Note
      // that if it is too large, the product overflows and is negative.
      var approxRes = goog.math.Long.fromNumber(approx);
      var approxRem = approxRes.multiply(other);
      while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
        approx -= delta;
        approxRes = goog.math.Long.fromNumber(approx);
        approxRem = approxRes.multiply(other);
      }

      // We know the answer can't be zero... and actually, zero would cause
      // infinite recursion since we would make no progress.
      if (approxRes.isZero()) {
        approxRes = goog.math.Long.ONE;
      }

      res = res.add(approxRes);
      rem = rem.subtract(approxRem);
    }
    return res;
  };


  /**
   * Returns this Long modulo the given one.
   * @param {goog.math.Long} other Long by which to mod.
   * @return {!goog.math.Long} This Long modulo the given one.
   */
  goog.math.Long.prototype.modulo = function(other) {
    return this.subtract(this.div(other).multiply(other));
  };


  /** @return {!goog.math.Long} The bitwise-NOT of this value. */
  goog.math.Long.prototype.not = function() {
    return goog.math.Long.fromBits(~this.low_, ~this.high_);
  };


  /**
   * Returns the bitwise-AND of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to AND.
   * @return {!goog.math.Long} The bitwise-AND of this and the other.
   */
  goog.math.Long.prototype.and = function(other) {
    return goog.math.Long.fromBits(this.low_ & other.low_,
                                   this.high_ & other.high_);
  };


  /**
   * Returns the bitwise-OR of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to OR.
   * @return {!goog.math.Long} The bitwise-OR of this and the other.
   */
  goog.math.Long.prototype.or = function(other) {
    return goog.math.Long.fromBits(this.low_ | other.low_,
                                   this.high_ | other.high_);
  };


  /**
   * Returns the bitwise-XOR of this Long and the given one.
   * @param {goog.math.Long} other The Long with which to XOR.
   * @return {!goog.math.Long} The bitwise-XOR of this and the other.
   */
  goog.math.Long.prototype.xor = function(other) {
    return goog.math.Long.fromBits(this.low_ ^ other.low_,
                                   this.high_ ^ other.high_);
  };


  /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the left by the given amount.
   */
  goog.math.Long.prototype.shiftLeft = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var low = this.low_;
      if (numBits < 32) {
        var high = this.high_;
        return goog.math.Long.fromBits(
            low << numBits,
            (high << numBits) | (low >>> (32 - numBits)));
      } else {
        return goog.math.Long.fromBits(0, low << (numBits - 32));
      }
    }
  };


  /**
   * Returns this Long with bits shifted to the right by the given amount.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the right by the given amount.
   */
  goog.math.Long.prototype.shiftRight = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return goog.math.Long.fromBits(
            (low >>> numBits) | (high << (32 - numBits)),
            high >> numBits);
      } else {
        return goog.math.Long.fromBits(
            high >> (numBits - 32),
            high >= 0 ? 0 : -1);
      }
    }
  };


  /**
   * Returns this Long with bits shifted to the right by the given amount, with
   * the new top bits matching the current sign bit.
   * @param {number} numBits The number of bits by which to shift.
   * @return {!goog.math.Long} This shifted to the right by the given amount, with
   *     zeros placed into the new leading bits.
   */
  goog.math.Long.prototype.shiftRightUnsigned = function(numBits) {
    numBits &= 63;
    if (numBits == 0) {
      return this;
    } else {
      var high = this.high_;
      if (numBits < 32) {
        var low = this.low_;
        return goog.math.Long.fromBits(
            (low >>> numBits) | (high << (32 - numBits)),
            high >>> numBits);
      } else if (numBits == 32) {
        return goog.math.Long.fromBits(high, 0);
      } else {
        return goog.math.Long.fromBits(high >>> (numBits - 32), 0);
      }
    }
  };

  //======= begin jsbn =======

  var navigator = { appName: 'Modern Browser' }; // polyfill a little

  // Copyright (c) 2005  Tom Wu
  // All Rights Reserved.
  // http://www-cs-students.stanford.edu/~tjw/jsbn/

  /*
   * Copyright (c) 2003-2005  Tom Wu
   * All Rights Reserved.
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
   * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
   *
   * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
   * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
   * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
   * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * In addition, the following condition applies:
   *
   * All redistributions must retain an intact copy of this copyright notice
   * and disclaimer.
   */

  // Basic JavaScript BN library - subset useful for RSA encryption.

  // Bits per digit
  var dbits;

  // JavaScript engine analysis
  var canary = 0xdeadbeefcafe;
  var j_lm = ((canary&0xffffff)==0xefcafe);

  // (public) Constructor
  function BigInteger(a,b,c) {
    if(a != null)
      if("number" == typeof a) this.fromNumber(a,b,c);
      else if(b == null && "string" != typeof a) this.fromString(a,256);
      else this.fromString(a,b);
  }

  // return new, unset BigInteger
  function nbi() { return new BigInteger(null); }

  // am: Compute w_j += (x*this_i), propagate carries,
  // c is initial carry, returns final carry.
  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
  // We need to select the fastest one that works in this environment.

  // am1: use a single mult and divide to get the high bits,
  // max digit bits should be 26 because
  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
  function am1(i,x,w,j,c,n) {
    while(--n >= 0) {
      var v = x*this[i++]+w[j]+c;
      c = Math.floor(v/0x4000000);
      w[j++] = v&0x3ffffff;
    }
    return c;
  }
  // am2 avoids a big mult-and-extract completely.
  // Max digit bits should be <= 30 because we do bitwise ops
  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
  function am2(i,x,w,j,c,n) {
    var xl = x&0x7fff, xh = x>>15;
    while(--n >= 0) {
      var l = this[i]&0x7fff;
      var h = this[i++]>>15;
      var m = xh*l+h*xl;
      l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
      c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
      w[j++] = l&0x3fffffff;
    }
    return c;
  }
  // Alternately, set max digit bits to 28 since some
  // browsers slow down when dealing with 32-bit numbers.
  function am3(i,x,w,j,c,n) {
    var xl = x&0x3fff, xh = x>>14;
    while(--n >= 0) {
      var l = this[i]&0x3fff;
      var h = this[i++]>>14;
      var m = xh*l+h*xl;
      l = xl*l+((m&0x3fff)<<14)+w[j]+c;
      c = (l>>28)+(m>>14)+xh*h;
      w[j++] = l&0xfffffff;
    }
    return c;
  }
  if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
    BigInteger.prototype.am = am2;
    dbits = 30;
  }
  else if(j_lm && (navigator.appName != "Netscape")) {
    BigInteger.prototype.am = am1;
    dbits = 26;
  }
  else { // Mozilla/Netscape seems to prefer am3
    BigInteger.prototype.am = am3;
    dbits = 28;
  }

  BigInteger.prototype.DB = dbits;
  BigInteger.prototype.DM = ((1<<dbits)-1);
  BigInteger.prototype.DV = (1<<dbits);

  var BI_FP = 52;
  BigInteger.prototype.FV = Math.pow(2,BI_FP);
  BigInteger.prototype.F1 = BI_FP-dbits;
  BigInteger.prototype.F2 = 2*dbits-BI_FP;

  // Digit conversions
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
  var BI_RC = new Array();
  var rr,vv;
  rr = "0".charCodeAt(0);
  for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

  function int2char(n) { return BI_RM.charAt(n); }
  function intAt(s,i) {
    var c = BI_RC[s.charCodeAt(i)];
    return (c==null)?-1:c;
  }

  // (protected) copy this to r
  function bnpCopyTo(r) {
    for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
    r.t = this.t;
    r.s = this.s;
  }

  // (protected) set from integer value x, -DV <= x < DV
  function bnpFromInt(x) {
    this.t = 1;
    this.s = (x<0)?-1:0;
    if(x > 0) this[0] = x;
    else if(x < -1) this[0] = x+DV;
    else this.t = 0;
  }

  // return bigint initialized to value
  function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

  // (protected) set from string and radix
  function bnpFromString(s,b) {
    var k;
    if(b == 16) k = 4;
    else if(b == 8) k = 3;
    else if(b == 256) k = 8; // byte array
    else if(b == 2) k = 1;
    else if(b == 32) k = 5;
    else if(b == 4) k = 2;
    else { this.fromRadix(s,b); return; }
    this.t = 0;
    this.s = 0;
    var i = s.length, mi = false, sh = 0;
    while(--i >= 0) {
      var x = (k==8)?s[i]&0xff:intAt(s,i);
      if(x < 0) {
        if(s.charAt(i) == "-") mi = true;
        continue;
      }
      mi = false;
      if(sh == 0)
        this[this.t++] = x;
      else if(sh+k > this.DB) {
        this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
        this[this.t++] = (x>>(this.DB-sh));
      }
      else
        this[this.t-1] |= x<<sh;
      sh += k;
      if(sh >= this.DB) sh -= this.DB;
    }
    if(k == 8 && (s[0]&0x80) != 0) {
      this.s = -1;
      if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
    }
    this.clamp();
    if(mi) BigInteger.ZERO.subTo(this,this);
  }

  // (protected) clamp off excess high words
  function bnpClamp() {
    var c = this.s&this.DM;
    while(this.t > 0 && this[this.t-1] == c) --this.t;
  }

  // (public) return string representation in given radix
  function bnToString(b) {
    if(this.s < 0) return "-"+this.negate().toString(b);
    var k;
    if(b == 16) k = 4;
    else if(b == 8) k = 3;
    else if(b == 2) k = 1;
    else if(b == 32) k = 5;
    else if(b == 4) k = 2;
    else return this.toRadix(b);
    var km = (1<<k)-1, d, m = false, r = "", i = this.t;
    var p = this.DB-(i*this.DB)%k;
    if(i-- > 0) {
      if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
      while(i >= 0) {
        if(p < k) {
          d = (this[i]&((1<<p)-1))<<(k-p);
          d |= this[--i]>>(p+=this.DB-k);
        }
        else {
          d = (this[i]>>(p-=k))&km;
          if(p <= 0) { p += this.DB; --i; }
        }
        if(d > 0) m = true;
        if(m) r += int2char(d);
      }
    }
    return m?r:"0";
  }

  // (public) -this
  function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

  // (public) |this|
  function bnAbs() { return (this.s<0)?this.negate():this; }

  // (public) return + if this > a, - if this < a, 0 if equal
  function bnCompareTo(a) {
    var r = this.s-a.s;
    if(r != 0) return r;
    var i = this.t;
    r = i-a.t;
    if(r != 0) return (this.s<0)?-r:r;
    while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
    return 0;
  }

  // returns bit length of the integer x
  function nbits(x) {
    var r = 1, t;
    if((t=x>>>16) != 0) { x = t; r += 16; }
    if((t=x>>8) != 0) { x = t; r += 8; }
    if((t=x>>4) != 0) { x = t; r += 4; }
    if((t=x>>2) != 0) { x = t; r += 2; }
    if((t=x>>1) != 0) { x = t; r += 1; }
    return r;
  }

  // (public) return the number of bits in "this"
  function bnBitLength() {
    if(this.t <= 0) return 0;
    return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
  }

  // (protected) r = this << n*DB
  function bnpDLShiftTo(n,r) {
    var i;
    for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
    for(i = n-1; i >= 0; --i) r[i] = 0;
    r.t = this.t+n;
    r.s = this.s;
  }

  // (protected) r = this >> n*DB
  function bnpDRShiftTo(n,r) {
    for(var i = n; i < this.t; ++i) r[i-n] = this[i];
    r.t = Math.max(this.t-n,0);
    r.s = this.s;
  }

  // (protected) r = this << n
  function bnpLShiftTo(n,r) {
    var bs = n%this.DB;
    var cbs = this.DB-bs;
    var bm = (1<<cbs)-1;
    var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
    for(i = this.t-1; i >= 0; --i) {
      r[i+ds+1] = (this[i]>>cbs)|c;
      c = (this[i]&bm)<<bs;
    }
    for(i = ds-1; i >= 0; --i) r[i] = 0;
    r[ds] = c;
    r.t = this.t+ds+1;
    r.s = this.s;
    r.clamp();
  }

  // (protected) r = this >> n
  function bnpRShiftTo(n,r) {
    r.s = this.s;
    var ds = Math.floor(n/this.DB);
    if(ds >= this.t) { r.t = 0; return; }
    var bs = n%this.DB;
    var cbs = this.DB-bs;
    var bm = (1<<bs)-1;
    r[0] = this[ds]>>bs;
    for(var i = ds+1; i < this.t; ++i) {
      r[i-ds-1] |= (this[i]&bm)<<cbs;
      r[i-ds] = this[i]>>bs;
    }
    if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
    r.t = this.t-ds;
    r.clamp();
  }

  // (protected) r = this - a
  function bnpSubTo(a,r) {
    var i = 0, c = 0, m = Math.min(a.t,this.t);
    while(i < m) {
      c += this[i]-a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    if(a.t < this.t) {
      c -= a.s;
      while(i < this.t) {
        c += this[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else {
      c += this.s;
      while(i < a.t) {
        c -= a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c -= a.s;
    }
    r.s = (c<0)?-1:0;
    if(c < -1) r[i++] = this.DV+c;
    else if(c > 0) r[i++] = c;
    r.t = i;
    r.clamp();
  }

  // (protected) r = this * a, r != this,a (HAC 14.12)
  // "this" should be the larger one if appropriate.
  function bnpMultiplyTo(a,r) {
    var x = this.abs(), y = a.abs();
    var i = x.t;
    r.t = i+y.t;
    while(--i >= 0) r[i] = 0;
    for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
    r.s = 0;
    r.clamp();
    if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
  }

  // (protected) r = this^2, r != this (HAC 14.16)
  function bnpSquareTo(r) {
    var x = this.abs();
    var i = r.t = 2*x.t;
    while(--i >= 0) r[i] = 0;
    for(i = 0; i < x.t-1; ++i) {
      var c = x.am(i,x[i],r,2*i,0,1);
      if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
        r[i+x.t] -= x.DV;
        r[i+x.t+1] = 1;
      }
    }
    if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
    r.s = 0;
    r.clamp();
  }

  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
  // r != q, this != m.  q or r may be null.
  function bnpDivRemTo(m,q,r) {
    var pm = m.abs();
    if(pm.t <= 0) return;
    var pt = this.abs();
    if(pt.t < pm.t) {
      if(q != null) q.fromInt(0);
      if(r != null) this.copyTo(r);
      return;
    }
    if(r == null) r = nbi();
    var y = nbi(), ts = this.s, ms = m.s;
    var nsh = this.DB-nbits(pm[pm.t-1]);	// normalize modulus
    if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
    else { pm.copyTo(y); pt.copyTo(r); }
    var ys = y.t;
    var y0 = y[ys-1];
    if(y0 == 0) return;
    var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
    var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
    var i = r.t, j = i-ys, t = (q==null)?nbi():q;
    y.dlShiftTo(j,t);
    if(r.compareTo(t) >= 0) {
      r[r.t++] = 1;
      r.subTo(t,r);
    }
    BigInteger.ONE.dlShiftTo(ys,t);
    t.subTo(y,y);	// "negative" y so we can replace sub with am later
    while(y.t < ys) y[y.t++] = 0;
    while(--j >= 0) {
      // Estimate quotient digit
      var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
      if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
        y.dlShiftTo(j,t);
        r.subTo(t,r);
        while(r[i] < --qd) r.subTo(t,r);
      }
    }
    if(q != null) {
      r.drShiftTo(ys,q);
      if(ts != ms) BigInteger.ZERO.subTo(q,q);
    }
    r.t = ys;
    r.clamp();
    if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
    if(ts < 0) BigInteger.ZERO.subTo(r,r);
  }

  // (public) this mod a
  function bnMod(a) {
    var r = nbi();
    this.abs().divRemTo(a,null,r);
    if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
    return r;
  }

  // Modular reduction using "classic" algorithm
  function Classic(m) { this.m = m; }
  function cConvert(x) {
    if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
    else return x;
  }
  function cRevert(x) { return x; }
  function cReduce(x) { x.divRemTo(this.m,null,x); }
  function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
  function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;

  // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
  // justification:
  //         xy == 1 (mod m)
  //         xy =  1+km
  //   xy(2-xy) = (1+km)(1-km)
  // x[y(2-xy)] = 1-k^2m^2
  // x[y(2-xy)] == 1 (mod m^2)
  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
  // JS multiply "overflows" differently from C/C++, so care is needed here.
  function bnpInvDigit() {
    if(this.t < 1) return 0;
    var x = this[0];
    if((x&1) == 0) return 0;
    var y = x&3;		// y == 1/x mod 2^2
    y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
    y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
    y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
    // last step - calculate inverse mod DV directly;
    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
    y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
    // we really want the negative inverse, and -DV < y < DV
    return (y>0)?this.DV-y:-y;
  }

  // Montgomery reduction
  function Montgomery(m) {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp&0x7fff;
    this.mph = this.mp>>15;
    this.um = (1<<(m.DB-15))-1;
    this.mt2 = 2*m.t;
  }

  // xR mod m
  function montConvert(x) {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t,r);
    r.divRemTo(this.m,null,r);
    if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
    return r;
  }

  // x/R mod m
  function montRevert(x) {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }

  // x = x/R mod m (HAC 14.32)
  function montReduce(x) {
    while(x.t <= this.mt2)	// pad x so am has enough room later
      x[x.t++] = 0;
    for(var i = 0; i < this.m.t; ++i) {
      // faster way of calculating u0 = x[i]*mp mod DV
      var j = x[i]&0x7fff;
      var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
      // use am to combine the multiply-shift-add into one call
      j = i+this.m.t;
      x[j] += this.m.am(0,u0,x,i,0,this.m.t);
      // propagate carry
      while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
    }
    x.clamp();
    x.drShiftTo(this.m.t,x);
    if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
  }

  // r = "x^2/R mod m"; x != r
  function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

  // r = "xy/R mod m"; x,y != r
  function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;

  // (protected) true iff this is even
  function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

  // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
  function bnpExp(e,z) {
    if(e > 0xffffffff || e < 1) return BigInteger.ONE;
    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
    g.copyTo(r);
    while(--i >= 0) {
      z.sqrTo(r,r2);
      if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
      else { var t = r; r = r2; r2 = t; }
    }
    return z.revert(r);
  }

  // (public) this^e % m, 0 <= e < 2^32
  function bnModPowInt(e,m) {
    var z;
    if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
    return this.exp(e,z);
  }

  // protected
  BigInteger.prototype.copyTo = bnpCopyTo;
  BigInteger.prototype.fromInt = bnpFromInt;
  BigInteger.prototype.fromString = bnpFromString;
  BigInteger.prototype.clamp = bnpClamp;
  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
  BigInteger.prototype.drShiftTo = bnpDRShiftTo;
  BigInteger.prototype.lShiftTo = bnpLShiftTo;
  BigInteger.prototype.rShiftTo = bnpRShiftTo;
  BigInteger.prototype.subTo = bnpSubTo;
  BigInteger.prototype.multiplyTo = bnpMultiplyTo;
  BigInteger.prototype.squareTo = bnpSquareTo;
  BigInteger.prototype.divRemTo = bnpDivRemTo;
  BigInteger.prototype.invDigit = bnpInvDigit;
  BigInteger.prototype.isEven = bnpIsEven;
  BigInteger.prototype.exp = bnpExp;

  // public
  BigInteger.prototype.toString = bnToString;
  BigInteger.prototype.negate = bnNegate;
  BigInteger.prototype.abs = bnAbs;
  BigInteger.prototype.compareTo = bnCompareTo;
  BigInteger.prototype.bitLength = bnBitLength;
  BigInteger.prototype.mod = bnMod;
  BigInteger.prototype.modPowInt = bnModPowInt;

  // "constants"
  BigInteger.ZERO = nbv(0);
  BigInteger.ONE = nbv(1);

  // jsbn2 stuff

  // (protected) convert from radix string
  function bnpFromRadix(s,b) {
    this.fromInt(0);
    if(b == null) b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
    for(var i = 0; i < s.length; ++i) {
      var x = intAt(s,i);
      if(x < 0) {
        if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
        continue;
      }
      w = b*w+x;
      if(++j >= cs) {
        this.dMultiply(d);
        this.dAddOffset(w,0);
        j = 0;
        w = 0;
      }
    }
    if(j > 0) {
      this.dMultiply(Math.pow(b,j));
      this.dAddOffset(w,0);
    }
    if(mi) BigInteger.ZERO.subTo(this,this);
  }

  // (protected) return x s.t. r^x < DV
  function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

  // (public) 0 if this == 0, 1 if this > 0
  function bnSigNum() {
    if(this.s < 0) return -1;
    else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
    else return 1;
  }

  // (protected) this *= n, this >= 0, 1 < n < DV
  function bnpDMultiply(n) {
    this[this.t] = this.am(0,n-1,this,0,0,this.t);
    ++this.t;
    this.clamp();
  }

  // (protected) this += n << w words, this >= 0
  function bnpDAddOffset(n,w) {
    if(n == 0) return;
    while(this.t <= w) this[this.t++] = 0;
    this[w] += n;
    while(this[w] >= this.DV) {
      this[w] -= this.DV;
      if(++w >= this.t) this[this.t++] = 0;
      ++this[w];
    }
  }

  // (protected) convert to radix string
  function bnpToRadix(b) {
    if(b == null) b = 10;
    if(this.signum() == 0 || b < 2 || b > 36) return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b,cs);
    var d = nbv(a), y = nbi(), z = nbi(), r = "";
    this.divRemTo(d,y,z);
    while(y.signum() > 0) {
      r = (a+z.intValue()).toString(b).substr(1) + r;
      y.divRemTo(d,y,z);
    }
    return z.intValue().toString(b) + r;
  }

  // (public) return value as integer
  function bnIntValue() {
    if(this.s < 0) {
      if(this.t == 1) return this[0]-this.DV;
      else if(this.t == 0) return -1;
    }
    else if(this.t == 1) return this[0];
    else if(this.t == 0) return 0;
    // assumes 16 < DB < 32
    return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
  }

  // (protected) r = this + a
  function bnpAddTo(a,r) {
    var i = 0, c = 0, m = Math.min(a.t,this.t);
    while(i < m) {
      c += this[i]+a[i];
      r[i++] = c&this.DM;
      c >>= this.DB;
    }
    if(a.t < this.t) {
      c += a.s;
      while(i < this.t) {
        c += this[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else {
      c += this.s;
      while(i < a.t) {
        c += a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      c += a.s;
    }
    r.s = (c<0)?-1:0;
    if(c > 0) r[i++] = c;
    else if(c < -1) r[i++] = this.DV+c;
    r.t = i;
    r.clamp();
  }

  BigInteger.prototype.fromRadix = bnpFromRadix;
  BigInteger.prototype.chunkSize = bnpChunkSize;
  BigInteger.prototype.signum = bnSigNum;
  BigInteger.prototype.dMultiply = bnpDMultiply;
  BigInteger.prototype.dAddOffset = bnpDAddOffset;
  BigInteger.prototype.toRadix = bnpToRadix;
  BigInteger.prototype.intValue = bnIntValue;
  BigInteger.prototype.addTo = bnpAddTo;

  //======= end jsbn =======

  // Emscripten wrapper
  var Wrapper = {
    abs: function(l, h) {
      var x = new goog.math.Long(l, h);
      var ret;
      if (x.isNegative()) {
        ret = x.negate();
      } else {
        ret = x;
      }
      HEAP32[tempDoublePtr>>2] = ret.low_;
      HEAP32[tempDoublePtr+4>>2] = ret.high_;
    },
    ensureTemps: function() {
      if (Wrapper.ensuredTemps) return;
      Wrapper.ensuredTemps = true;
      Wrapper.two32 = new BigInteger();
      Wrapper.two32.fromString('4294967296', 10);
      Wrapper.two64 = new BigInteger();
      Wrapper.two64.fromString('18446744073709551616', 10);
      Wrapper.temp1 = new BigInteger();
      Wrapper.temp2 = new BigInteger();
    },
    lh2bignum: function(l, h) {
      var a = new BigInteger();
      a.fromString(h.toString(), 10);
      var b = new BigInteger();
      a.multiplyTo(Wrapper.two32, b);
      var c = new BigInteger();
      c.fromString(l.toString(), 10);
      var d = new BigInteger();
      c.addTo(b, d);
      return d;
    },
    stringify: function(l, h, unsigned) {
      var ret = new goog.math.Long(l, h).toString();
      if (unsigned && ret[0] == '-') {
        // unsign slowly using jsbn bignums
        Wrapper.ensureTemps();
        var bignum = new BigInteger();
        bignum.fromString(ret, 10);
        ret = new BigInteger();
        Wrapper.two64.addTo(bignum, ret);
        ret = ret.toString(10);
      }
      return ret;
    },
    fromString: function(str, base, min, max, unsigned) {
      Wrapper.ensureTemps();
      var bignum = new BigInteger();
      bignum.fromString(str, base);
      var bigmin = new BigInteger();
      bigmin.fromString(min, 10);
      var bigmax = new BigInteger();
      bigmax.fromString(max, 10);
      if (unsigned && bignum.compareTo(BigInteger.ZERO) < 0) {
        var temp = new BigInteger();
        bignum.addTo(Wrapper.two64, temp);
        bignum = temp;
      }
      var error = false;
      if (bignum.compareTo(bigmin) < 0) {
        bignum = bigmin;
        error = true;
      } else if (bignum.compareTo(bigmax) > 0) {
        bignum = bigmax;
        error = true;
      }
      var ret = goog.math.Long.fromString(bignum.toString()); // min-max checks should have clamped this to a range goog.math.Long can handle well
      HEAP32[tempDoublePtr>>2] = ret.low_;
      HEAP32[tempDoublePtr+4>>2] = ret.high_;
      if (error) throw 'range error';
    }
  };
  return Wrapper;
})();

//======= end closure i64 code =======



// === Auto-generated postamble setup entry stuff ===

if (memoryInitializer) {
  function applyData(data) {
    HEAPU8.set(data, STATIC_BASE);
  }
  if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
    applyData(Module['readBinary'](memoryInitializer));
  } else {
    addRunDependency('memory initializer');
    Browser.asyncLoad(memoryInitializer, function(data) {
      applyData(data);
      removeRunDependency('memory initializer');
    }, function(data) {
      throw 'could not load memory initializer ' + memoryInitializer;
    });
  }
}

function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
};
ExitStatus.prototype = new Error();
ExitStatus.prototype.constructor = ExitStatus;

var initialStackTop;
var preloadStartTime = null;
var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!Module['calledRun'] && shouldRunNow) run();
  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
}

Module['callMain'] = Module.callMain = function callMain(args) {
  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on __ATMAIN__)');
  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');

  args = args || [];

  if (ENVIRONMENT_IS_WEB && preloadStartTime !== null) {
    Module.printErr('preload time: ' + (Date.now() - preloadStartTime) + ' ms');
  }

  ensureInitRuntime();

  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intArrayFromString("/bin/this.program"), 'i8', ALLOC_NORMAL) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intArrayFromString(args[i]), 'i8', ALLOC_NORMAL));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', ALLOC_NORMAL);

  initialStackTop = STACKTOP;

  try {

    var ret = Module['_main'](argc, argv, 0);


    // if we're not running an evented main loop, it's time to exit
    if (!Module['noExitRuntime']) {
      exit(ret);
    }
  }
  catch(e) {
    if (e instanceof ExitStatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'SimulateInfiniteLoop') {
      // running an evented main loop, don't immediately exit
      Module['noExitRuntime'] = true;
      return;
    } else {
      if (e && typeof e === 'object' && e.stack) Module.printErr('exception thrown: ' + [e, e.stack]);
      throw e;
    }
  } finally {
    calledMain = true;
  }
}




function run(args) {
  args = args || Module['arguments'];

  if (preloadStartTime === null) preloadStartTime = Date.now();

  if (runDependencies > 0) {
    Module.printErr('run() called, but dependencies remain, so not running');
    return;
  }

  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

  function doRun() {
    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
    Module['calledRun'] = true;

    ensureInitRuntime();

    preMain();

    if (Module['_main'] && shouldRunNow) {
      Module['callMain'](args);
    }

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      if (!ABORT) doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module['run'] = Module.run = run;

function exit(status) {
  ABORT = true;
  EXITSTATUS = status;
  STACKTOP = initialStackTop;

  // exit the runtime
  exitRuntime();

  // TODO We should handle this differently based on environment.
  // In the browser, the best we can do is throw an exception
  // to halt execution, but in node we could process.exit and
  // I'd imagine SM shell would have something equivalent.
  // This would let us set a proper exit status (which
  // would be great for checking test exit statuses).
  // https://github.com/kripken/emscripten/issues/1371

  // throw an exception to halt the current execution
  throw new ExitStatus(status);
}
Module['exit'] = Module.exit = exit;

function abort(text) {
  if (text) {
    Module.print(text);
    Module.printErr(text);
  }

  ABORT = true;
  EXITSTATUS = 1;

  throw 'abort() at ' + stackTrace();
}
Module['abort'] = Module.abort = abort;

// {{PRE_RUN_ADDITIONS}}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;//false;
if (Module['noInitialRun']) {
  shouldRunNow = false;
}

run();
assertEquals(0, EXITSTATUS);
                     node-23.7.0/deps/v8/test/mjsunit/asm/redundancy1.js                                                 0000664 0000000 0000000 00000001131 14746647661 0022044 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbo-splitting

function module(stdlib, foreign, heap) {
    "use asm";
    function foo(i) {
      i = i|0;
      var j = 0;
      if ((i | 0) < 0) {
        j = i+1|0;
      }
      if ((i | 0) > 0) {
        j = i+1|0;
      }
      return j | 0;
    }
    return { foo: foo };
}

var foo = module(this, {}, new ArrayBuffer(64*1024)).foo;
assertEquals(0, foo(0));
assertEquals(0, foo(-1));
assertEquals(12, foo(11));
                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/asm/redundancy2.js                                                 0000664 0000000 0000000 00000001172 14746647661 0022052 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbo-splitting

function module(stdlib, foreign, heap) {
    "use asm";
    function foo(i) {
      i = i|0;
      var j = 0;
      switch (i | 0) {
        case 0:
          j = i+1|0;
          break;
        case 1:
          j = i+1|0;
          break;
        default:
          j = i;
          break;
      }
      return j | 0;
    }
    return { foo: foo };
}

var foo = module(this, {}, new ArrayBuffer(64*1024)).foo;
assertEquals(2, foo(2));
                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/asm/regress-1013920.js                                             0000664 0000000 0000000 00000000700 14746647661 0022117 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

function asm(stdlib, foreign, heap) {
  "use asm";
  var heap32 = new stdlib.Uint32Array(heap);
  function f() { return 0; }
  return {f : f};
}

var heap = Reflect.construct(
    SharedArrayBuffer,
    [1024 * 1024],
    ArrayBuffer.prototype.constructor);

asm(this, {}, heap);
                                                                node-23.7.0/deps/v8/test/mjsunit/asm/regress-1027595.js                                             0000664 0000000 0000000 00000002405 14746647661 0022140 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

(function TestF32StoreConvertsF64ToF32() {
  function Module(stdlib, foreign, heap) {
    'use asm';
    var f32 = new stdlib.Float32Array(heap);
    function f(a) {
      a = +a;
      f32[0] = f32[1] = a;
    }
    return f;
  }
  var buffer = new ArrayBuffer(0x10000);
  var f = Module(this, {}, buffer);
  assertDoesNotThrow(() => f(23.42));
  var view = new Float32Array(buffer);
  assertEquals(Math.fround(23.42), view[0]);
  assertEquals(Math.fround(23.42), view[1]);
  assertTrue(%IsAsmWasmCode(Module));
})();

(function TestF64StoreConvertsF32ToF64() {
  function Module(stdlib, foreign, heap) {
    'use asm';
    var fround = stdlib.Math.fround;
    var f64 = new stdlib.Float64Array(heap);
    function f(a) {
      a = fround(a);
      f64[0] = f64[1] = a;
    }
    return f;
  }
  var buffer = new ArrayBuffer(0x10000);
  var f = Module(this, {}, buffer);
  assertDoesNotThrow(() => f(23.42));
  var view = new Float64Array(buffer);
  assertEquals(Math.fround(23.42), view[0]);
  assertEquals(Math.fround(23.42), view[1]);
  assertTrue(%IsAsmWasmCode(Module));
})();
                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/asm/regress-1069173.js                                             0000664 0000000 0000000 00000000611 14746647661 0022133 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

function foo() {
  "use asm";
  const v = -0;
  function bar() {
    return v;
  }
  return { d: bar };
}

var m = foo();
assertEquals(-Infinity, 1 / m.d());
assertTrue(%IsAsmWasmCode(foo));
                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/asm/regress-1395401.js                                             0000664 0000000 0000000 00000000515 14746647661 0022132 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

eval(`
    function asmModule() {
      "use asm";
      function x(v) {
        v = v | 0;
      }
      return x;
    }
    asmModule();
  `);

console.profile();
                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/asm/regress-1432537.js                                             0000664 0000000 0000000 00000000614 14746647661 0022134 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

function asm(stdlib, foreign) {
  'use asm';
  var foreign = +foreign.bar;
  var baz = +foreign.baz;
  function f() {
    return baz;
  }
  return {f: f};
}
const module = asm(this, {baz: 345.7});
assertEquals(NaN, module.f());
                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/asm/regress-641885.js                                              0000664 0000000 0000000 00000000534 14746647661 0022064 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var __f_2 = (function __f_4() {
  "use asm";
  function __f_2(i) {
    i = i|0;
    i = i << -2147483648 >> -1073741824;
    return i|0;
  }
  return { __f_2: __f_2 };
})().__f_2;
                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/asm/regress-660813.js                                              0000664 0000000 0000000 00000000422 14746647661 0022050 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

function Module() {
  "use asm";
  const i = 0xffffffff;
  function foo() {
    return i;
  }
}
Module();
                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/asm/regress-669899.js                                              0000664 0000000 0000000 00000001064 14746647661 0022102 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

try {
(function () {
})();
} catch(e) {; }
  function __f_113() {
  }
(function () {
function __f_89() {
  "use asm";
  function __f_63(__v_26, __v_28) {
    __v_26 = __v_26|0;
    __v_28 = __v_28|0;
  }
  function __f_21(table_id, fun_id, arg1, arg2) {
    table_id = table_id|0;
    fun_id = fun_id|0;
    arg1 = arg1|0;
    arg2 = arg2|0;
  }
  var __v_17 = [];
}
var module = __f_89();
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/asm/regress-672045.js                                              0000664 0000000 0000000 00000000613 14746647661 0022052 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

function Module(stdlib, env) {
  "use asm";
  var x = env.bar|0;
  return { foo: function(y) { return eval(1); } };
}
Module(this, {bar:0});
assertFalse(%IsAsmWasmCode(Module));
                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/asm/regress-676573.js                                              0000664 0000000 0000000 00000000562 14746647661 0022067 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

function baz() {
  "use asm";
}
function B(stdlib, env) {
  "use asm";
  var x = env.foo | 0;
}
var bar = {
  get foo() {
  }
};
bar.__defineGetter__('foo', function() { return baz(); });
B(this, bar);
                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/asm/regress-681707.js                                              0000664 0000000 0000000 00000000564 14746647661 0022064 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm

var foo = (function(stdlib) {
  "use asm";
  var bar = (stdlib[0]);
  function foo() { return bar ("lala"); }
  return foo;
})(this);

try {
  nop(foo);
  foo();
} catch (e) {
}
                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/asm/regress-718745.js                                              0000664 0000000 0000000 00000000503 14746647661 0022060 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

function Module(stdlib) {
  "use asm";
  var fround = stdlib.Math.fround;
  function f(a) {
    a = (fround(a));
  }
  return { f:f };
}
Module(this).f();
                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/asm/regress-719866.js                                              0000664 0000000 0000000 00000000612 14746647661 0022066 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

function Module(stdlib) {
  "use asm";
  function f(a,b,c) {
    a = +a;
    b = +b;
    c = +c;
    var r = 0.0;
    r = a / b * c;
    return +r;
  }
  return { f:f }
}
var m = Module(this);
assertEquals(16, m.f(32, 4, 2));
                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/asm/regress-740325.js                                              0000664 0000000 0000000 00000002355 14746647661 0022054 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-gc

assertTrue = function assertTrue() { }
assertFalse = function assertFalse() { }

__v_3 = [];
__v_2 = [];
__v_0 = 0;
__v_2.__defineGetter__(0, function() {
  if (__v_0++ > 2) return;
  gc();
  __v_3.concat(__v_2);
});
__v_2[0];


function __f_2() {
}

(function __f_1() {
  print("1...");
  function __f_5(stdlib, imports) {
    "use asm";
    var __f_2 = imports.__f_2;
    function __f_3(a) {
      a = a | 0;
    }
    return { __f_3:__f_3 };
  }
  var __v_2 = __f_5(this, { __f_2:__f_2 });
;
})();

(function __f_10() {
  print("2...");
  function __f_5() {
    "use asm";
    function __f_3(a) {
    }
  }
  var __v_2 = __f_5();
  assertFalse();
})();

(function __f_11() {
  print("3...");
  let m = (function __f_6() {
    function __f_5() {
      "use asm";
      function __f_3() {
      }
      return { __f_3:__f_3 };
    }
    var __v_2 = __f_5( { __f_2:__f_2 });
  });
  for (var i = 0; i < 30; i++) {
    print("  i = " + i);
    var x = m();
    for (var j = 0; j < 200; j++) {
      try {
        __f_5;
      } catch (e) {
      }
    }
    x;
  }
})();
                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/asm/regress-913822.js                                              0000664 0000000 0000000 00000001104 14746647661 0022047 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

(function TestNewlineInCPPComment() {
  function Module() {
    "use asm" // Crash by comment!
    function f() {}
    return f
  }
  Module();
  assertTrue(%IsAsmWasmCode(Module));
})();

(function TestNewlineInCComment() {
  function Module() {
    "use asm" /* Crash by
    comment! */ function f() {}
    return f
  }
  Module();
  assertTrue(%IsAsmWasmCode(Module));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/asm/regress-920076.js                                              0000664 0000000 0000000 00000000650 14746647661 0022053 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

function Module() {
  "use asm";
  function f() {}
  return f
}
eval("(" + Module.toString().replace(/;/, String.fromCharCode(8233)) + ")();");
assertFalse(%IsAsmWasmCode(Module));  // Valid asm.js, but we reject Unicode.
                                                                                        node-23.7.0/deps/v8/test/mjsunit/asm/regress-937650.js                                              0000664 0000000 0000000 00000001057 14746647661 0022063 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

function Module(stdlib) {
  "use asm";
  var fround = stdlib.Math.fround;
  // The below constant is outside the range of representable {float} values.
  const infinity = fround(1.7976931348623157e+308);
  function f() {
    return infinity;
  }
  return { f: f };
}

var m = Module(this);
assertEquals(Infinity, m.f());
assertTrue(%IsAsmWasmCode(Module));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/asm/regress-9531.js                                                0000664 0000000 0000000 00000001271 14746647661 0021705 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

function Module(stdlib, ffi, buffer) {
  "use asm";
  var MEM8 = new stdlib.Uint8Array(buffer);
  function foo() { return MEM8[0] | 0; }
  return { foo: foo };
}


function RunOnce() {
  let buffer = new ArrayBuffer(4096);
  let ffi = {};
  let stdlib = {Uint8Array: Uint8Array};
  let module = Module(stdlib, ffi, buffer);
  assertTrue(%IsAsmWasmCode(Module));
  assertEquals(0, module.foo());
}

(function RunTest() {
  for (let i = 0; i < 3000; i++) {
    RunOnce();
  }
})();
                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/asm/return-types.js                                                0000664 0000000 0000000 00000005546 14746647661 0022326 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax  --validate-asm

(function SuccessReturnTypesMatch() {
  function Module(stdlib, imports, heap) {
    "use asm";
    function f(a) {
      a = a | 0;
      if ((a | 0) == 1) return 2.3;
      if ((a | 0) == 2) return 4.2;
      return 6.5;
    }
    return { f:f };
  }
  var m = Module(this);
  assertTrue(%IsAsmWasmCode(Module));
  assertEquals(2.3, m.f(1));
  assertEquals(4.2, m.f(2));
  assertEquals(6.5, m.f(3));
})();

(function FailReturnTypesMismatch() {
  function Module(stdlib, imports, heap) {
    "use asm";
    function f(a) {
      a = a | 0;
      if ((a | 0) == 1) return 2.3;
      if ((a | 0) == 2) return 123;
      return 4.2;
    }
    return { f:f };
  }
  var m = Module(this);
  assertFalse(%IsAsmWasmCode(Module));
  assertEquals(2.3, m.f(1));
  assertEquals(123, m.f(2));
  assertEquals(4.2, m.f(3));
})();

(function FailFallOffNonVoidFunction() {
  function Module(stdlib, imports, heap) {
    "use asm";
    function f(a) {
      a = a | 0;
      if ((a | 0) == 1) return 2.3;
      if ((a | 0) == 2) return 4.2;
    }
    return { f:f };
  }
  var m = Module(this);
  assertFalse(%IsAsmWasmCode(Module));
  assertEquals(2.3, m.f(1));
  assertEquals(4.2, m.f(2));
  assertEquals(undefined, m.f(3));
})();

(function FailNonVoidVoidMismatch() {
  function Module(stdlib, imports, heap) {
    "use asm";
    function f(a) {
      a = a | 0;
      if ((a | 0) == 1) return 2.3;
      if ((a | 0) == 2) return;
    }
    return { f:f };
  }
  var m = Module(this);
  assertFalse(%IsAsmWasmCode(Module));
  assertEquals(2.3, m.f(1));
  assertEquals(undefined, m.f(2));
  assertEquals(undefined, m.f(3));
})();

(function FailVoidNonVoidMismatch() {
  function Module(stdlib, imports, heap) {
    "use asm";
    function f(a) {
      a = a | 0;
      if ((a | 0) == 1) return;
      if ((a | 0) == 2) return 2.3;
    }
    return { f:f };
  }
  var m = Module(this);
  assertFalse(%IsAsmWasmCode(Module));
  assertEquals(undefined, m.f(1));
  assertEquals(2.3, m.f(2));
  assertEquals(undefined, m.f(3));
})();

(function SuccessVoidFunction() {
  function Module(stdlib, imports, heap) {
    "use asm";
    function f(a) {
      a = a | 0;
      if ((a | 0) == 1) return;
      return;
    }
    return { f:f };
  }
  var m = Module(this);
  assertTrue(%IsAsmWasmCode(Module));
  assertEquals(undefined, m.f(1));
  assertEquals(undefined, m.f(2));
})();

(function SuccessFallOffVoidFunction() {
  function Module(stdlib, imports, heap) {
    "use asm";
    function f(a) {
      a = a | 0;
      if ((a | 0) == 1) return;
    }
    return { f:f };
  }
  var m = Module(this);
  assertTrue(%IsAsmWasmCode(Module));
  assertEquals(undefined, m.f(1));
  assertEquals(undefined, m.f(2));
})();
                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/asm/sign-extend.js                                                 0000664 0000000 0000000 00000002121 14746647661 0022054 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var stdlib = this;
var buffer = new ArrayBuffer(64 * 1024);
var foreign = {}


var sext8 = (function Module(stdlib, foreign, heap) {
  "use asm";
  function sext8(i) {
    i = i|0;
    i = i << 24 >> 24;
    return i|0;
  }
  return { sext8: sext8 };
})(stdlib, foreign, buffer).sext8;

assertEquals(-128, sext8(128));
assertEquals(-1, sext8(-1));
assertEquals(-1, sext8(255));
assertEquals(0, sext8(0));
assertEquals(0, sext8(256));
assertEquals(42, sext8(42));
assertEquals(127, sext8(127));


var sext16 = (function Module(stdlib, foreign, heap) {
  "use asm";
  function sext16(i) {
    i = i|0;
    i = i << 16 >> 16;
    return i|0;
  }
  return { sext16: sext16 };
})(stdlib, foreign, buffer).sext16;

assertEquals(-32768, sext16(32768));
assertEquals(-1, sext16(-1));
assertEquals(-1, sext16(65535));
assertEquals(0, sext16(0));
assertEquals(0, sext16(65536));
assertEquals(128, sext16(128));
assertEquals(32767, sext16(32767));
                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/asm/switch.js                                                      0000664 0000000 0000000 00000005053 14746647661 0021137 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var stdlib = this;
var foreign = {};
var heap = new ArrayBuffer(64 * 1024);


var switch1 = (function(stdlib, foreign, heap) {
  "use asm";
  function switch1(i) {
    i = i|0;
    switch (i | 0) {
      case 0: return 1;
      case 1: return 2;
      default: return i|0;
    }
    return i | 0;
  }
  return { switch1: switch1 };
})(stdlib, foreign, heap).switch1;

assertEquals(1, switch1(0));
assertEquals(2, switch1(1));
for (var i = -2147483648; i < 2147483648; i += 3999773) {
  assertEquals(i, switch1(i));
}


var switch2 = (function(stdlib, foreign, heap) {
  "use asm";
  function switch2(i) {
    i = i|0;
    var j = 0;
    switch (i | 0) {
      case 0: j = 1; break;
      case 1: j = 2; break;
      case 2: j = 3; break;
      default: j = i|0; break;
    }
    return j|0;
  }
  return { switch2: switch2 };
})(stdlib, foreign, heap).switch2;

assertEquals(1, switch2(0));
assertEquals(2, switch2(1));
assertEquals(3, switch2(2));
for (var i = -2147483648; i < 2147483648; i += 3999773) {
  assertEquals(i, switch2(i));
}


var switch3 = (function(stdlib, foreign, heap) {
  "use asm";
  function switch3(i) {
    i = i|0;
    var j = 0;
    switch (i | 0) {
      case 0:
      case 1: j = 1; break;
      case 2:
      case 3: j = 2; break;
      case 4:
      case 5: j = 3; break;
      default: j = 0; break;
    }
    return j|0;
  }
  return { switch3: switch3 };
})(stdlib, foreign, heap).switch3;

assertEquals(1, switch3(0));
assertEquals(1, switch3(1));
assertEquals(2, switch3(2));
assertEquals(2, switch3(3));
assertEquals(3, switch3(4));
assertEquals(3, switch3(5));
for (var i = -2147483648; i < 2147483648; i += 3999773) {
  assertEquals(0, switch3(i));
}


var switch4 = (function(stdlib, foreign, heap) {
  "use asm";
  function switch4(i) {
    i = i|0;
    switch (i | 0) {
      case -1:
      case 1:
        return 0;

      case -2:
      case 2:
        return 1;

      case -3:
      case 3:
        return 2;

      case -8:
      case 8:
        return 3;

      default:
        return 4;
    }
    return 0;  // needed for validation
  }
  return { switch4: switch4 };
})(stdlib, foreign, heap).switch4;

assertEquals(4, switch4(0));
assertEquals(0, switch4(-1));
assertEquals(0, switch4(1));
assertEquals(1, switch4(-2));
assertEquals(1, switch4(2));
assertEquals(3, switch4(-8));
assertEquals(3, switch4(8));
assertEquals(4, switch4(-123456789));
assertEquals(4, switch4(123456789));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/asm/uint32-less-than-shift.js                                      0000664 0000000 0000000 00000002337 14746647661 0023773 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

function Module(stdlib, foreign, heap) {
  'use asm';

  function foo1(i1) {
    i1 = i1 | 0;
    var i10 = 0;
    i10 = (i1 >> 5) | 0;
    if (i10 >>> 0 < 5) {
      return 1;
    } else {
      return 0;
    }
    return 0;
  }

  function foo2(i1) {
    i1 = i1 | 0;
    var i10 = 0;
    i10 = ((i1 | 0) / 32) | 0;
    if (i10 >>> 0 < 5) {
      return 1;
    } else {
      return 0;
    }
    return 0;
  }

  function foo3(i1) {
    i1 = i1 | 0;
    var i10 = 0;
    i10 = (i1 + 32 | 0) / 32 | 0;
    if (i10 >>> 0 < 5) {
      return 1;
    } else {
      return 0;
    }
    return 0;
  }
  return {foo1: foo1, foo2: foo2, foo3: foo3};
}

var m = Module(this, {}, undefined);

for (var i = 0; i < 4 * 32; i++) {
  assertEquals(1, m.foo1(i));
  assertEquals(1, m.foo2(i));
  assertEquals(1, m.foo3(i));
}

for (var i = 4 * 32; i < 5 * 32; i++) {
  assertEquals(1, m.foo1(i));
  assertEquals(1, m.foo2(i));
  assertEquals(0, m.foo3(i));
}

for (var i = 5 * 32; i < 10 * 32; i++) {
  assertEquals(0, m.foo1(i));
  assertEquals(0, m.foo2(i));
  assertEquals(0, m.foo3(i));
}
                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/asm/uint32div.js                                                   0000664 0000000 0000000 00000002663 14746647661 0021471 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var stdlib = {};
var foreign = {};
var heap = new ArrayBuffer(64 * 1024);

function Uint32Div(divisor) {
  var name = "div_";
  name += divisor;
  var m = eval(
      'function Module(stdlib, foreign, heap) {\n' +
      ' "use asm";\n' +
      ' function ' + name + '(dividend) {\n' +
      '  dividend = dividend | 0;\n' +
      '  return ((dividend >>> 0) / ' + divisor + ') | 0;\n' +
      ' }\n' +
      ' return { f: ' + name + '}\n' +
      '}; Module');
  return m(stdlib, foreign, heap).f;
}

var divisors = [0, 1, 3, 4, 10, 42, 64, 100, 1024, 2147483647, 4294967295];
for (var i in divisors) {
  var divisor = divisors[i];
  var div = Uint32Div(divisor);
  for (var dividend = 0; dividend < 4294967296; dividend += 3999773) {
    assertEquals((dividend / divisor) | 0, div(dividend));
  }
}

var div = (function(stdlib, foreign, heap) {
  "use asm";
  function div(dividend, divisor) {
    dividend = dividend | 0;
    divisor = divisor | 0;
    return (dividend >>> 0) / (divisor >>> 0) | 0;
  }
  return {div: div};
})(stdlib, foreign, heap).div;

for (var i in divisors) {
  var divisor =  divisors[i];
  for (var dividend = 0; dividend < 4294967296; dividend += 3999773) {
    assertEquals((dividend >>> 0) / (divisor >>> 0) | 0,
                 div(dividend, divisor));
  }
}
                                                                             node-23.7.0/deps/v8/test/mjsunit/asm/uint32mod-constant.js                                          0000664 0000000 0000000 00000001710 14746647661 0023305 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var stdlib = {};
var foreign = {};
var heap = new ArrayBuffer(64 * 1024);

function Uint32Mod(divisor) {
  var name = "mod_";
  name += divisor;
  var m = eval(
      'function Module(stdlib, foreign, heap) {\n' +
      ' "use asm";\n' +
      ' function ' + name + '(dividend) {\n' +
      '  dividend = dividend | 0;\n' +
      '  return ((dividend >>> 0) % ' + divisor + ') | 0;\n' +
      ' }\n' +
      ' return { f: ' + name + '}\n' +
      '}; Module');
  return m(stdlib, foreign, heap).f;
}

var divisors = [0, 1, 3, 4, 10, 42, 64, 100, 1024, 2147483647, 4294967295];
for (var i in divisors) {
  var divisor = divisors[i];
  var mod = Uint32Mod(divisor);
  for (var dividend = 0; dividend < 4294967296; dividend += 3999773) {
    assertEquals((dividend % divisor) | 0, mod(dividend));
  }
}
                                                        node-23.7.0/deps/v8/test/mjsunit/asm/uint32mod.js                                                   0000664 0000000 0000000 00000001424 14746647661 0021460 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var stdlib = {};
var foreign = {};
var heap = new ArrayBuffer(64 * 1024);

var mod = (function Module(stdlib, foreign, heap) {
  "use asm";
  function mod(dividend, divisor) {
    dividend = dividend | 0;
    divisor = divisor | 0;
    return ((dividend >>> 0) % (divisor >>> 0)) | 0;
  }
  return { mod: mod };
})(stdlib, foreign, heap).mod;

var divisors = [0, 1, 3, 4, 10, 42, 64, 100, 1024, 2147483647, 4294967295];
for (var i in divisors) {
  var divisor = divisors[i];
  for (var dividend = 0; dividend < 4294967296; dividend += 3999773) {
    assertEquals((dividend % divisor) | 0, mod(dividend, divisor));
  }
}
                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/asm/uint8array-outofbounds.js                                      0000664 0000000 0000000 00000001266 14746647661 0024313 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

function Module(stdlib, foreign, heap) {
  "use asm";
  var MEM8 = new stdlib.Uint8Array(heap);
  function load(i) {
    i = i|0;
    i = MEM8[i] | 0;
    return i | 0;
  }
  function store(i, v) {
    i = i|0;
    v = v|0;
    MEM8[i] = v;
  }
  return { load: load, store: store };
}

var m = Module(this, {}, new ArrayBuffer(1));

m.store(0, 255);
for (var i = 1; i < 64; ++i) {
  m.store(i * 1 * 32 * 1024, i);
}
assertEquals(255, m.load(0));
for (var i = 1; i < 64; ++i) {
  assertEquals(0, m.load(i * 1 * 32 * 1024));
}
                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/asm/word32and.js                                                   0000664 0000000 0000000 00000001711 14746647661 0021436 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var stdlib = {};
var foreign = {};
var heap = new ArrayBuffer(64 * 1024);

function Word32And(rhs) {
  var name = "and_0x" + Number(rhs).toString(16);
  var m = eval(
      'function Module(stdlib, foreign, heap) {\n' +
      ' "use asm";\n' +
      ' function ' + name + '(lhs) {\n' +
      '  lhs = lhs | 0;\n' +
      '  return (lhs & 0x' + Number(rhs).toString(16) + ') | 0;\n' +
      ' }\n' +
      ' return { f: ' + name + '}\n' +
      '}; Module');
  return m(stdlib, foreign, heap).f;
}

var masks = [0xffffffff, 0xf0f0f0f0, 0x80ffffff, 0x07f77f0f, 0xdeadbeef,
             0x0fffff00, 0x0ff0, 0xff, 0x00];
for (var i in masks) {
  var rhs = masks[i];
  var and = Word32And(rhs);
  for (var lhs = -2147483648; lhs < 2147483648; lhs += 3999773) {
    assertEquals(lhs & rhs, and(lhs));
  }
}
                                                       node-23.7.0/deps/v8/test/mjsunit/asm/word32ror.js                                                   0000664 0000000 0000000 00000001673 14746647661 0021505 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var stdlib = {};
var foreign = {};
var heap = new ArrayBuffer(64 * 1024);

var rol = (function Module(stdlib, foreign, heap) {
  "use asm";
  function rol(x, y) {
    x = x | 0;
    y = y | 0;
    return (x << y) | (x >>> (32 - y)) | 0;
  }
  return { rol: rol };
})(stdlib, foreign, heap).rol;

assertEquals(10, rol(10, 0));
assertEquals(2, rol(1, 1));
assertEquals(0x40000000, rol(1, 30));
assertEquals(-0x80000000, rol(1, 31));

var ror = (function Module(stdlib, foreign, heap) {
  "use asm";
  function ror(x, y) {
    x = x | 0;
    y = y | 0;
    return (x << (32 - y)) | (x >>> y) | 0;
  }
  return { ror: ror };
})(stdlib, foreign, heap).ror;

assertEquals(10, ror(10, 0));
assertEquals(-0x80000000, ror(1, 1));
assertEquals(0x40000000, ror(1, 2));
assertEquals(2, ror(1, 31));
                                                                     node-23.7.0/deps/v8/test/mjsunit/asm/zero-extend.js                                                 0000664 0000000 0000000 00000001614 14746647661 0022101 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var stdlib = this;
var buffer = new ArrayBuffer(64 * 1024);
var foreign = {}


var zext8 = (function Module(stdlib, foreign, heap) {
  "use asm";
  function zext8(i) {
    i = i | 0;
    return (i & 0xff) | 0;
  }
  return { zext8: zext8 };
})(stdlib, foreign, buffer).zext8;

assertEquals(0, zext8(0));
assertEquals(0, zext8(0x100));
assertEquals(0xff, zext8(-1));
assertEquals(0xff, zext8(0xff));


var zext16 = (function Module(stdlib, foreign, heap) {
  "use asm";
  function zext16(i) {
    i = i | 0;
    return (i & 0xffff) | 0;
  }
  return { zext16: zext16 };
})(stdlib, foreign, buffer).zext16;

assertEquals(0, zext16(0));
assertEquals(0, zext16(0x10000));
assertEquals(0xffff, zext16(-1));
assertEquals(0xffff, zext16(0xffff));
                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/async-hooks/                                                       0000775 0000000 0000000 00000000000 14746647661 0020753 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/async-hooks/api-methods.js                                         0000664 0000000 0000000 00000006122 14746647661 0023524 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --expose-async-hooks

// Check for invalid arguments handling
(function() {
  assertTrue(async_hooks.hasOwnProperty('createHook'),
    'Async hooks missing createHook method');

  assertThrows(() => async_hooks.createHook());
  assertThrows(() => async_hooks.createHook(123));
  assertThrows(() => async_hooks.createHook('str'));
})();

// Check for correct API methods
(function() {
  assertTrue(async_hooks.hasOwnProperty('executionAsyncId'),
    'Async hooks missing executionAsyncId method');
  assertTrue(async_hooks.hasOwnProperty('triggerAsyncId'),
    'Async hooks missing triggerAsyncId method');

  let ah = async_hooks.createHook({});
  assertTrue(ah.hasOwnProperty('enable'), 'Async hooks missing enable method');
  assertTrue(ah.hasOwnProperty('disable'),
    'Async hooks missing disable method');
})();

// Check for correct enabling/disabling of async hooks
(function() {
  let storedPromise;
  let ah = async_hooks.createHook({
    init(asyncId, type, triggerAsyncId, resource) {
      storedPromise = resource.promise || resource;
    }
  });
  ah.enable();

  let createdPromise = new Promise(function(resolve) {
    resolve(42);
  });
  assertSame(storedPromise, createdPromise,
    "Async hooks weren't enabled correctly");
  ah.disable();
  createdPromise = Promise.resolve(52);
  assertNotSame(storedPromise, createdPromise,
    "Async hooks weren't disabled correctly");
  ah.enable();
  createdPromise = Promise.resolve(62);
  assertSame(storedPromise, createdPromise,
    "Async hooks weren't enabled correctly");
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/async-hooks/async-await-tree.js                                    0000664 0000000 0000000 00000005305 14746647661 0024471 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --expose-async-hooks --harmony-await-optimization

// Check for async/await asyncIds relation
(function() {
  let asyncIds = [], triggerIds = [];
  let ah = async_hooks.createHook({
    init(asyncId, type, triggerAsyncId, resource) {
      if (type !== 'PROMISE') {
        return;
      }
      asyncIds.push(asyncId);
      triggerIds.push(triggerAsyncId);
    },
  });
  ah.enable();

  // Simplified version of Node.js util.promisify(setTimeout),
  // but d8 ignores the timeout of setTimeout.
  function sleep0() {
    const promise = new Promise(function(resolve, reject) {
      try {
        setTimeout((err, ...values) => {
          if (err) {
            reject(err);
          } else {
            resolve(values[0]);
          }
        }, 0);
      } catch (err) {
        reject(err);
      }
    });
    return promise;
  }

  async function foo() {
    await sleep0();
  }

  assertPromiseResult(
    foo().then(function() {
      assertEquals(triggerIds[2], asyncIds[1]);
      assertEquals(triggerIds[3], asyncIds[0]);
      assertEquals(triggerIds[4], asyncIds[3]);
      assertEquals(triggerIds[6], asyncIds[5]);
    }));
})();
                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/async-hooks/chained-promises.js                                    0000664 0000000 0000000 00000004504 14746647661 0024546 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --expose-async-hooks

// Check for chained promises asyncIds relation
(function() {
  let asyncIds = [], triggerIds = [];
  let ah = async_hooks.createHook({
    init(asyncId, type, triggerAsyncId, resource) {
      asyncIds.push(asyncId);
      triggerIds.push(triggerAsyncId);
    },
  });
  ah.enable();
  let createdPromise = new Promise(function(resolve) {
    resolve(42);
  }).then(function() {
    assertEquals(3, asyncIds.length, 'Exactly 3 promises should be inited');
    assertEquals(3, triggerIds.length, 'Exactly 3 promises should be inited');
    assertEquals(triggerIds[1], asyncIds[0],
      "Parent promise asyncId doesn't correspond to child triggerAsyncId");
  }).catch((err) => {
    setTimeout(() => {
      throw err;
    }, 0);
  });
})();
                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/async-hooks/execution-order.js                                     0000664 0000000 0000000 00000005733 14746647661 0024435 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --expose-async-hooks

// Check for correct execution of available hooks and asyncIds
(function() {
  let calledHooks = [];
  let rootAsyncId = 0;

  let ah = async_hooks.createHook({
    init: function init(asyncId, type, triggerAsyncId, resource) {
      if (type !== 'PROMISE') {
        return;
      }
      if (triggerAsyncId === 0) {
        rootAsyncId = asyncId;
      }
      calledHooks.push(['init', asyncId]);
    },
    promiseResolve: function promiseResolve(asyncId) {
      calledHooks.push(['resolve', asyncId]);
    },
    before: function before(asyncId) {
      calledHooks.push(['before', asyncId]);
    },
    after: function after(asyncId) {
      calledHooks.push(['after', asyncId]);
    },
  });
  ah.enable();

  new Promise(function(resolve) {
    resolve(42);
  }).then(function() {
    // [hook type, async Id]
    const expectedHooks = [
      ['init', rootAsyncId],  // the promise that we create initially
      ['resolve', rootAsyncId],
      ['init', rootAsyncId + 1],  // the chained promise with the assertions
      ['init', rootAsyncId + 2],  // the chained promise from the catch block
      ['before', rootAsyncId + 1],
      // ['after', rootAsyncId + 1] will get called after the assertions
    ];

    assertArrayEquals(expectedHooks, calledHooks,
      'Mismatch in async hooks execution order');
  }).catch((err) => {
    setTimeout(() => {
      throw err;
    }, 0);
  });
})();
                                     node-23.7.0/deps/v8/test/mjsunit/async-hooks/promises-async-await.js                                0000664 0000000 0000000 00000005557 14746647661 0025404 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --expose-async-hooks

// Check for executionAsyncId/triggerAsyncId when chained promises and
// async/await are combined
(function() {
  let p;
  let outerExecutionAsyncId = -1, outerTriggerAsyncId = -1;

  function inIrrelevantContext(resolve) {
    resolve(42);
  }

  function inContext1(foo) {
    foo();
  }

  function inContext2(foo) {
    foo();
  }

  outerExecutionAsyncId = async_hooks.executionAsyncId();
  outerTriggerAsyncId = async_hooks.triggerAsyncId();

  inContext1(() => {
    p = new Promise(resolve => {
      assertEquals(outerExecutionAsyncId, async_hooks.executionAsyncId());
      assertEquals(outerTriggerAsyncId, async_hooks.triggerAsyncId());
      inIrrelevantContext(resolve);
    }).then(() => {
      assertNotEquals(outerExecutionAsyncId, async_hooks.executionAsyncId());
      assertNotEquals(outerTriggerAsyncId, async_hooks.triggerAsyncId());
    }).catch((err) => {
      setTimeout(() => {
        throw err;
      }, 0);
    });
  });

  inContext2(async () => {
    assertEquals(outerExecutionAsyncId, async_hooks.executionAsyncId());
    assertEquals(outerTriggerAsyncId, async_hooks.triggerAsyncId());
    await p;
    assertNotEquals(outerExecutionAsyncId, async_hooks.executionAsyncId());
    assertNotEquals(outerTriggerAsyncId, async_hooks.triggerAsyncId());
  });

})();
                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/async-hooks/regress-crbug-1337629.js                               0000664 0000000 0000000 00000000554 14746647661 0024723 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-async-hooks

const failing_proxy = new Proxy({}, new Proxy({}, {
  get() {
    throw "No trap should fire";
  }
}));

assertThrows(() => async_hooks.createHook(failing_proxy));
                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/async-hooks/regress-crbug-1427746.js                               0000664 0000000 0000000 00000000647 14746647661 0024726 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-async-hooks --expose-gc

let v0 = [];
let v1 = 1;

let v2 = async_hooks.createHook({
  after: () => {
    async_hooks.createHook(v1);
    gc();
  }
});

v2.enable();

new Promise(v3 => v3(42)).then(() => { }).catch(() => { });
v1 = v0;
                                                                                         node-23.7.0/deps/v8/test/mjsunit/async-hooks/regress-crbug-1433521.js                               0000664 0000000 0000000 00000000636 14746647661 0024710 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-async-hooks --no-fail

let arr = [];
let hook = async_hooks.createHook({
  init() {
    d8.terminate();
    arr.push();
  }
});
hook.enable();

async function async_f() {}
async_f().then();
async_hooks.createHook({init() {}});
                                                                                                  node-23.7.0/deps/v8/test/mjsunit/async-stack-traces-prepare-stacktrace-1.js                         0000664 0000000 0000000 00000001463 14746647661 0026472 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --async-stack-traces

// Check that Error.prepareStackTrace doesn't expose strict
// mode closures, even in the presence of async frames.
Error.prepareStackTrace = (e, frames) => {
  assertEquals(two, frames[0].getFunction());
  assertEquals(two.name, frames[0].getFunctionName());
  assertEquals(undefined, frames[1].getFunction());
  assertEquals(one.name, frames[1].getFunctionName());
  return frames;
};

async function one(x) {
  "use strict";
  return await two(x);
}

async function two(x) {
  try {
    x = await x;
    throw new Error();
  } catch (e) {
    return e.stack;
  }
}

one(1).catch(e => setTimeout(_ => {throw e}, 0));
                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/async-stack-traces-prepare-stacktrace-2.js                         0000664 0000000 0000000 00000001471 14746647661 0026472 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --async-stack-traces

// Check that Error.prepareStackTrace doesn't expose strict
// mode closures, even in the presence of async frames.
Error.prepareStackTrace = (e, frames) => {
  assertEquals(undefined, frames[0].getFunction());
  assertEquals(two.name, frames[0].getFunctionName());
  assertEquals(undefined, frames[1].getFunction());
  assertEquals(one.name, frames[1].getFunctionName());
  return frames;
};

async function one(x) {
  return await two(x);
}

async function two(x) {
  "use strict";
  try {
    x = await x;
    throw new Error();
  } catch (e) {
    return e.stack;
  }
}

one(1).catch(e => setTimeout(_ => {throw e}, 0));
                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/async-stack-traces-prepare-stacktrace-3.js                         0000664 0000000 0000000 00000001457 14746647661 0026477 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --async-stack-traces

// Check that Error.prepareStackTrace properly marks async frames.
Error.prepareStackTrace = (e, frames) => {
  assertSame(two, frames[0].getFunction());
  assertEquals(two.name, frames[0].getFunctionName());
  assertFalse(frames[0].isAsync());
  assertSame(one, frames[1].getFunction());
  assertEquals(one.name, frames[1].getFunctionName());
  assertTrue(frames[1].isAsync());
  return frames;
};

async function one(x) {
  return await two(x);
}

async function two(x) {
  try {
    x = await x;
    throw new Error();
  } catch (e) {
    return e.stack;
  }
}

one(1).catch(e => setTimeout(_ => {throw e}, 0));
                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/async-stack-traces-prepare-stacktrace-4.js                         0000664 0000000 0000000 00000002264 14746647661 0026475 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --async-stack-traces

// Check that Error.prepareStackTrace properly exposes async
// stack frames and special Promise.all() stack frames.
Error.prepareStackTrace = (e, frames) => {
  assertEquals(two, frames[0].getFunction());
  assertEquals(two.name, frames[0].getFunctionName());
  assertEquals(null, frames[0].getPromiseIndex());
  assertFalse(frames[0].isAsync());
  assertEquals(Promise.all, frames[1].getFunction());
  assertEquals(0, frames[1].getPromiseIndex());
  assertTrue(frames[1].isAsync());
  assertTrue(frames[1].isPromiseAll());
  assertEquals(one, frames[2].getFunction());
  assertEquals(one.name, frames[2].getFunctionName());
  assertEquals(null, frames[2].getPromiseIndex());
  assertTrue(frames[2].isAsync());
  assertFalse(frames[2].isPromiseAll());
  return frames;
};

async function one(x) {
  return await Promise.all([two(x)]);
}

async function two(x) {
  try {
    x = await x;
    throw new Error();
  } catch (e) {
    return e.stack;
  }
}

one(1).catch(e => setTimeout(_ => {throw e}, 0));
                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/async-stack-traces-promise-all-settled.js                          0000664 0000000 0000000 00000002405 14746647661 0026437 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --async-stack-traces

// Basic test with Promise.allSettled().
(function() {
  async function fine() { }

  async function thrower() {
    await fine();
    throw new Error();
  }

  async function driver() {
    return await Promise.allSettled([fine(), fine(), thrower(), thrower()]);
  }

  async function test(f) {
    const results = await f();
    results.forEach((result, i) => {
      if (result.status === 'rejected') {
        const error = result.reason;
        assertInstanceof(error, Error);
        const stackRegexp = new RegExp("Error.+at thrower.+at " +
          `async Promise.allSettled \\(index ${ i }\\)` +
          ".+ at async driver.+at async test",
          "ms")
        assertMatches(stackRegexp, error.stack);
      }
    });
  }

  assertPromiseResult((async () => {
    %PrepareFunctionForOptimization(thrower);
    %PrepareFunctionForOptimization(driver);
    await test(driver);
    await test(driver);
    %OptimizeFunctionOnNextCall(thrower);
    await test(driver);
    %OptimizeFunctionOnNextCall(driver);
    await test(driver);
  })());
})();
                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/async-stack-traces-promise-all.js                                  0000664 0000000 0000000 00000002040 14746647661 0024770 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --async-stack-traces

// Basic test with Promise.all().
(function() {
  async function fine() { }

  async function thrower() {
    await fine();
    throw new Error();
  }

  async function driver() {
    await Promise.all([fine(), fine(), thrower(), thrower()]);
  }

  async function test(f) {
    try {
      await f();
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, Error);
      assertMatches(/Error.+at thrower.+at async Promise.all \(index 2\).+at async driver.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async () => {
    %PrepareFunctionForOptimization(thrower);
    %PrepareFunctionForOptimization(driver);
    await test(driver);
    await test(driver);
    %OptimizeFunctionOnNextCall(thrower);
    await test(driver);
    %OptimizeFunctionOnNextCall(driver);
    await test(driver);
  })());
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/async-stack-traces-promise-any.js                                  0000664 0000000 0000000 00000002314 14746647661 0025013 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --async-stack-traces

// Basic test with Promise.any().
(function() {
  async function fine() { }

  async function thrower() {
    await fine();
    throw new Error();
  }

  async function driver() {
    await Promise.any([thrower(), thrower()]);
  }

  async function test(f) {
    try {
      await f();
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, AggregateError);
      assertEquals(2, e.errors.length);
      assertMatches(/Error.+at thrower.+at async Promise.any \(index 0\).+at async driver.+at async test/ms, e.errors[0].stack);
      assertMatches(/Error.+at thrower.+at async Promise.any \(index 1\).+at async driver.+at async test/ms, e.errors[1].stack);
    }
  }

  assertPromiseResult((async () => {
    %PrepareFunctionForOptimization(thrower);
    %PrepareFunctionForOptimization(driver);
    await test(driver);
    await test(driver);
    %OptimizeFunctionOnNextCall(thrower);
    await test(driver);
    %OptimizeFunctionOnNextCall(driver);
    await test(driver);
  })());
})();
                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/async-stack-traces-realms.js                                       0000664 0000000 0000000 00000005736 14746647661 0024046 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --async-stack-traces

// Basic test with an explicit throw.
(function() {
  const realm = Realm.createAllowCrossRealmAccess();

  async function one(x) {
    await two(x);
  }

  const two = Realm.eval(realm, `(async function two(x) {
    await x;
    throw new Error();
  })`);

  async function test(f) {
    try {
      await f(new Promise(resolve => setTimeout(resolve)));
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, Realm.global(realm).Error);
      assertMatches(/Error.+at two.+at async one.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async () => {
    %PrepareFunctionForOptimization(one);
    %PrepareFunctionForOptimization(two);
    await test(one);
    await test(one);
    %OptimizeFunctionOnNextCall(two);
    await test(one);
    %OptimizeFunctionOnNextCall(one);
    await test(one);
    Realm.dispose(realm);
  })());
})();

// Basic test with an implicit throw (via ToNumber on Symbol).
(function() {
  const realm = Realm.createAllowCrossRealmAccess();

  async function one(x) {
    return await two(x);
  }

  const two = Realm.eval(realm, `(async function two(x) {
    await x;
    return +Symbol();  // This will raise a TypeError.
  })`);

  async function test(f) {
    try {
      await f(new Promise(resolve => setTimeout(resolve)));
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, Realm.global(realm).TypeError);
      assertMatches(/TypeError.+at two.+at async one.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async() => {
    %PrepareFunctionForOptimization(one);
    %PrepareFunctionForOptimization(two);
    await test(one);
    await test(one);
    %OptimizeFunctionOnNextCall(two);
    await test(one);
    %OptimizeFunctionOnNextCall(one);
    await test(one);
    Realm.dispose(realm);
  })());
})();

// Basic test with async functions and promises chained via
// Promise.prototype.then(), which should still work following
// the generic chain upwards.
(function() {
  const realm = Realm.createAllowCrossRealmAccess();

  async function one(x) {
    return await two(x).then(x => x);
  }

  const two = Realm.eval(realm, `(async function two(x) {
    await x.then(x => x);
    throw new Error();
  })`);

  async function test(f) {
    try {
      await f(new Promise(resolve => setTimeout(resolve)));
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, Realm.global(realm).Error);
      assertMatches(/Error.+at two.+at async one.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async() => {
    %PrepareFunctionForOptimization(one);
    %PrepareFunctionForOptimization(two);
    await test(one);
    await test(one);
    %OptimizeFunctionOnNextCall(two);
    await test(one);
    %OptimizeFunctionOnNextCall(one);
    await test(one);
    Realm.dispose(realm);
  })());
})();
                                  node-23.7.0/deps/v8/test/mjsunit/async-stack-traces.js                                              0000664 0000000 0000000 00000017410 14746647661 0022555 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --async-stack-traces

// Basic test with an explicit throw.
(function() {
  async function one(x) {
    await two(x);
  }

  async function two(x) {
    await x;
    throw new Error();
  }

  async function test(f) {
    try {
      await f(1);
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, Error);
      assertMatches(/Error.+at two.+at async one.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async () => {
    %PrepareFunctionForOptimization(one);
    %PrepareFunctionForOptimization(two);
    await test(one);
    await test(one);
    %OptimizeFunctionOnNextCall(two);
    await test(one);
    %OptimizeFunctionOnNextCall(one);
    await test(one);
  })());
})();

// Basic test with an implicit throw (via ToNumber on Symbol).
(function() {
  async function one(x) {
    return await two(x);
  }

  async function two(x) {
    await x;
    return +x;  // This will raise a TypeError.
  }

  async function test(f) {
    try {
      await f(Symbol());
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, TypeError);
      assertMatches(/TypeError.+at two.+at async one.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async() => {
    %PrepareFunctionForOptimization(one);
    %PrepareFunctionForOptimization(two);
    await test(one);
    await test(one);
    %OptimizeFunctionOnNextCall(two);
    await test(one);
    %OptimizeFunctionOnNextCall(one);
    await test(one);
  })());
})();

// Basic test with throw in inlined function.
(function() {
  function throwError() {
    throw new Error();
  }

  async function one(x) {
    return await two(x);
  }

  async function two(x) {
    await x;
    return throwError();
  }

  async function test(f) {
    try {
      await f(1);
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, Error);
      assertMatches(/Error.+at two.+at async one.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async() => {
    %PrepareFunctionForOptimization(one);
    %PrepareFunctionForOptimization(two);
    await test(one);
    await test(one);
    %OptimizeFunctionOnNextCall(two);
    await test(one);
    %OptimizeFunctionOnNextCall(one);
    await test(one);
  })());
})();

// Basic test with async function inlined into sync function.
(function() {
  function callOne(x) {
    return one(x);
  }

  function callTwo(x) {
    return two(x);
  }

  async function one(x) {
    return await callTwo(x);
  }

  async function two(x) {
    await x;
    throw new Error();
  }

  async function test(f) {
    try {
      await f(1);
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, Error);
      assertMatches(/Error.+at two.+at async one.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async() => {
    %PrepareFunctionForOptimization(callOne);
    %PrepareFunctionForOptimization(callTwo);
    await test(callOne);
    await test(callOne);
    %OptimizeFunctionOnNextCall(callTwo);
    await test(callOne);
    %OptimizeFunctionOnNextCall(callOne);
    await test(callOne);
  })());
})();

// Basic test with async functions and promises chained via
// Promise.prototype.then(), which should still work following
// the generic chain upwards.
(function() {
  async function one(x) {
    return await two(x).then(x => x);
  }

  async function two(x) {
    await x.then(x => x);
    throw new Error();
  }

  async function test(f) {
    try {
      await f(Promise.resolve(1));
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, Error);
      assertMatches(/Error.+at two.+at async one.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async() => {
    %PrepareFunctionForOptimization(one);
    %PrepareFunctionForOptimization(two);
    await test(one);
    await test(one);
    %OptimizeFunctionOnNextCall(two);
    await test(one);
    %OptimizeFunctionOnNextCall(one);
    await test(one);
  })());
})();

// Basic test for async generators called from async
// functions with an explicit throw.
(function() {
  async function one(x) {
    for await (const y of two(x)) {}
  }

  async function* two(x) {
    await x;
    throw new Error();
  }

  async function test(f) {
    try {
      await f(1);
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, Error);
      assertMatches(/Error.+at two.+at async one.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async () => {
    %PrepareFunctionForOptimization(one);
    %PrepareFunctionForOptimization(two);
    await test(one);
    await test(one);
    %OptimizeFunctionOnNextCall(two);
    await test(one);
    %OptimizeFunctionOnNextCall(one);
    await test(one);
  })());
})();

// Basic test for async functions called from async
// generators with an explicit throw.
(function() {
  async function* one(x) {
    await two(x);
  }

  async function two(x) {
    await x;
    throw new Error();
  }

  async function test(f) {
    try {
      for await (const x of f(1)) {}
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, Error);
      assertMatches(/Error.+at two.+at async one.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async () => {
    %PrepareFunctionForOptimization(one);
    %PrepareFunctionForOptimization(two);
    await test(one);
    await test(one);
    %OptimizeFunctionOnNextCall(two);
    await test(one);
    %OptimizeFunctionOnNextCall(one);
    await test(one);
  })());
})();

// Basic test for async functions called from async
// generators with an explicit throw (with yield).
(function() {
  async function* one(x) {
    yield two(x);
  }

  async function two(x) {
    await x;
    throw new Error();
  }

  async function test(f) {
    try {
      for await (const x of f(1)) {}
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, Error);
      assertMatches(/Error.+at two.+at async one.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async () => {
    %PrepareFunctionForOptimization(one);
    %PrepareFunctionForOptimization(two);
    await test(one);
    await test(one);
    %OptimizeFunctionOnNextCall(two);
    await test(one);
    %OptimizeFunctionOnNextCall(one);
    await test(one);
  })());
})();

// Basic test to check that we also follow initial
// promise chains created via Promise#then().
(function() {
  async function one(p) {
    return await p.then(two);
  }

  function two() {
    throw new Error();
  }

  async function test(f) {
    try {
      await f(Promise.resolve());
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, Error);
      assertMatches(/Error.+at two.+at async one.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async () => {
    %PrepareFunctionForOptimization(one);
    %PrepareFunctionForOptimization(two);
    await test(one);
    await test(one);
    %OptimizeFunctionOnNextCall(two);
    await test(one);
    %OptimizeFunctionOnNextCall(one);
    await test(one);
  })());
})();

// Basic test for reject.
(function() {
  async function one(x) {
    await two(x);
  }

  async function two(x) {
    try {
      await Promise.reject(new Error());
      assertUnreachable();
    } catch (e) {
      throw new Error();
    }
  }

  async function test(f) {
    try {
      await f(1);
      assertUnreachable();
    } catch (e) {
      assertInstanceof(e, Error);
      assertMatches(/Error.+at two.+at async one.+at async test/ms, e.stack);
    }
  }

  assertPromiseResult((async () => {
    %PrepareFunctionForOptimization(one);
    %PrepareFunctionForOptimization(two);
    await test(one);
    await test(one);
    %OptimizeFunctionOnNextCall(two);
    await test(one);
    %OptimizeFunctionOnNextCall(one);
    await test(one);
  })());
})();
                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/baseline/                                                          0000775 0000000 0000000 00000000000 14746647661 0020277 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/baseline/batch-compilation.js                                      0000664 0000000 0000000 00000004033 14746647661 0024232 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --sparkplug --no-always-sparkplug --sparkplug-filter="test*"
// Flags: --allow-natives-syntax --expose-gc --no-always-turbofan
// Flags: --baseline-batch-compilation --baseline-batch-compilation-threshold=200
// Flags: --invocation-count-for-feedback-allocation=4
// Flags: --no-concurrent-sparkplug

// Flags to drive Fuzzers into the right direction
// TODO(v8:11853): Remove these flags once fuzzers handle flag implications
// better.
// Flags: --lazy-feedback-allocation --no-stress-concurrent-inlining

// Basic test
(function() {
  // Bytecode length 24 -> estimated instruction size 120 - 168.
  function test1 (a,b) {
    return (a + b + 11) * 42 / a % b;
  }

  // Bytecode length 24 -> estimated instruction size 120 - 168.
  function test2 (a,b) {
    return (a + b + 11) * 42 / a % b;
  }

  %NeverOptimizeFunction(test1);
  // Trigger bytecode budget interrupt for test1.
  for (let i=0; i<5; ++i) {
    test1(i,4711);
  }
  // Shouldn't be compiled because of batch compilation.
  assertFalse(isBaseline(test1));

  %NeverOptimizeFunction(test2);
  // Trigger bytecode budget interrupt for test2.
  for (let i=0; i<5; ++i) {
    test2(i,4711);
  }

  // Call test1 again so baseline code gets installed on the function.
  test1(1,2);

  // Both functions should be compiled with baseline now.
  assertTrue(isBaseline(test1));
  assertTrue(isBaseline(test2));
})();

// Test function weak handle.
(function() {
  function test_weak (a,b) {
    return (a + b + 11) * 42 / a % b;
  }

  function test2 (a,b) {
    return (a + b + 11) * 42 / a % b;
  }

  %NeverOptimizeFunction(test_weak);
  for (let i=0; i<5; ++i) {
    test_weak(i,4711);
  }

  gc(); // GC should cause the handle to test_weak to be freed.

  %NeverOptimizeFunction(test2);
  // Trigger bytecode budget interrupt for test2.
  for (let i=0; i<5; ++i) {
    test2(i,4711);
  }

  assertTrue(isBaseline(test2));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/baseline/cross-realm.js                                            0000664 0000000 0000000 00000007277 14746647661 0023101 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --sparkplug --no-always-sparkplug

// Tier-up across Realms

// Ensure a feedback vector is created when sharing baseline code.
(function() {
  function factory1() {
    return function(a) {
      return a;
    }
  }

  var realm1 = Realm.createAllowCrossRealmAccess();
  var realm2 = Realm.createAllowCrossRealmAccess();

  // f1 and f2 have the same code, so share a SharedFunctionInfo (i.e. share
  // bytecode and baseline code).
  let f1 = Realm.eval(realm1, "(" + factory1.toString() + ")")();
  let f2 = Realm.eval(realm2, "(" + factory1.toString() + ")")();
  %NeverOptimizeFunction(f1);
  %NeverOptimizeFunction(f2);

  // Compile f1 to baseline, f2 stays uncompiled
  %CompileBaseline(f1);
  assertEquals(0, f1(0));
  assertTrue(isBaseline(f1));
  assertFalse(isBaseline(f2));

  // f2 tiers up to baseline via lazy compile
  assertEquals(0, f2(0));
  assertTrue(isBaseline(f1));
  assertTrue(isBaseline(f2));
})();

// Ensure a feedback vector is created when sharing baseline code and a closure
// feedback cell array already exists.
(function() {
  function factory2() {
    return function(a) {
      return a;
    }
  }

  var realm1 = Realm.createAllowCrossRealmAccess();
  var realm2 = Realm.createAllowCrossRealmAccess();

  // f1, f2 and f3 have the same code, so share a SharedFunctionInfo (i.e. share
  // bytecode and baseline code).
  let f1 = Realm.eval(realm1, "(" + factory2.toString() + ")")();
  let realmFactory = Realm.eval(realm2, "(" + factory2.toString() + ")");
  // f2 and f3 are in the same realm, so share a feedback vector cell.
  let f2 = realmFactory();
  let f3 = realmFactory();
  %NeverOptimizeFunction(f1);
  %NeverOptimizeFunction(f2);
  %NeverOptimizeFunction(f3);

  // Compile f1 to baseline, f2 to interpreter, f3 stays uncompiled.
  assertEquals(0, f2(0));
  %CompileBaseline(f1);
  assertEquals(0, f1(0));
  assertTrue(isBaseline(f1));
  assertFalse(isBaseline(f2));
  assertFalse(isBaseline(f3));

  // Compile f3, tiers up to baseline via lazy compile and installs the feedback
  // vector
  assertEquals(0, f3(0));
  assertTrue(isBaseline(f3));
  assertFalse(isBaseline(f2));

  // Run f2, tiers up to baseline via interpreter entry.
  assertEquals(0, f2(0));
  assertTrue(isBaseline(f2));
})();

// Ensure a feedback vector is created when sharing baseline code and a closure
// feedback cell array already exists.
(function() {
  function factory3() {
    return function(a) {
      return a;
    }
  }

  var realm1 = Realm.createAllowCrossRealmAccess();
  var realm2 = Realm.createAllowCrossRealmAccess();

  // f1, f2 and f3 have the same code, so share a SharedFunctionInfo (i.e. share
  // bytecode and baseline code).
  let f1 = Realm.eval(realm1, "(" + factory3.toString() + ")")();
  let realmFactory = Realm.eval(realm2, "(" + factory3.toString() + ")");
  // f2 and f3 are in the same realm, so share a feedback vector cell.
  let f2 = realmFactory();
  let f3 = realmFactory();
  %NeverOptimizeFunction(f1);
  %NeverOptimizeFunction(f2);
  %NeverOptimizeFunction(f3);

  // Compile f1 to baseline, f2 to interpreter, f3 stays uncompiled.
  assertEquals(0, f2(0));
  %CompileBaseline(f1);
  assertEquals(0, f1(0));
  assertTrue(isBaseline(f1));
  assertFalse(isBaseline(f2));
  assertFalse(isBaseline(f3));

  // Run f2, tiers up to baseline via interpreter entry and installs the
  // feedback vector
  assertEquals(0, f2(0));
  assertTrue(isBaseline(f2));
  assertFalse(isBaseline(f3));

  // Compile f3, tiers up to baseline via lazy compile.
  assertEquals(0, f3(0));
  assertTrue(isBaseline(f3));
})();
                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/baseline/deopt-to-baseline.js                                      0000664 0000000 0000000 00000001350 14746647661 0024147 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --sparkplug --no-always-sparkplug --turbofan
// Flags: --no-deopt-to-baseline

function isExecutingInterpreted(func) {
  let opt_status = %GetOptimizationStatus(func);
  return (opt_status & V8OptimizationStatus.kTopmostFrameIsInterpreted) !== 0;
}

function f(check = false) {
  if (check) {
    %DeoptimizeFunction(f);
    assertTrue(isExecutingInterpreted(f));
  }
}

f();
%CompileBaseline(f);
f();
assertTrue(isBaseline(f));

%PrepareFunctionForOptimization(f);
f();
f();
%OptimizeFunctionOnNextCall(f);
f();
assertOptimized(f);

f(true);
                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/baseline/flush-baseline-code.js                                    0000664 0000000 0000000 00000007224 14746647661 0024453 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-gc --stress-flush-code --allow-natives-syntax
// Flags: --baseline-batch-compilation-threshold=0 --sparkplug
// Flags: --no-always-sparkplug --lazy-feedback-allocation
// Flags: --flush-baseline-code --flush-bytecode --no-turbofan --no-maglev
// Flags: --no-stress-concurrent-inlining
// Flags: --no-concurrent-sparkplug

function HasBaselineCode(f) {
  let opt_status = %GetOptimizationStatus(f);
  return (opt_status & V8OptimizationStatus.kBaseline) !== 0;
}

function HasByteCode(f) {
  let opt_status = %GetOptimizationStatus(f);
  return (opt_status & V8OptimizationStatus.kInterpreted) !== 0;
}

var x = {b:20, c:30};
function f() {
  return x.b + 10;
}

(async function () {
  // Test bytecode gets flushed
  f();
  assertTrue(HasByteCode(f));
  // We need to invoke GC asynchronously and wait for it to finish, so that
  // it doesn't need to scan the stack. Otherwise, some objects may not be
  // reclaimed because of conservative stack scanning and the test may not
  // work as intended.
  await gc({ type: 'major', execution: 'async' });
  assertFalse(HasByteCode(f))
})();

(async function () {
  // Test baseline code and bytecode gets flushed
  for (i = 1; i < 50; i++) {
    f();
  }
  assertTrue(HasBaselineCode(f));
  // We need to invoke GC asynchronously and wait for it to finish, so that
  // it doesn't need to scan the stack. Otherwise, some objects may not be
  // reclaimed because of conservative stack scanning and the test may not
  // work as intended.
  await gc({ type: 'major', execution: 'async' });
  assertFalse(HasBaselineCode(f));
  assertFalse(HasByteCode(f));
})();

// Check bytecode isn't flushed if it's held strongly from somewhere but
// baseline code is flushed.
function f1(should_recurse) {
  if (should_recurse) {
    assertTrue(HasByteCode(f1));
    for (i = 1; i < 50; i++) {
      f1(false);
    }
    assertTrue(HasBaselineCode(f1));
    // Here we are not checking whether some object was indeed reclaimed,
    // so should not worry if conservative stack scanning is performed.
    gc();
    // TODO(jgruber, v8:12161): No longer true since we now always tier up to
    // available Sparkplug code as early as possible. By the time we reach this
    // assert, SP code is being executed and is thus alive.
    // assertFalse(HasBaselineCode(f1));
    // Also, the active tier is Sparkplug and not Ignition.
    // assertTrue(ActiveTierIsIgnition(f1));
  }
  return x.b + 10;
}

(async function () {
  f1(false);
  // Recurse first time so we have bytecode array on the stack that keeps
  // bytecode alive.
  f1(true);

  // Flush bytecode.
  // We need to invoke GC asynchronously and wait for it to finish, so that
  // it doesn't need to scan the stack. Otherwise, some objects may not be
  // reclaimed because of conservative stack scanning and the test may not
  // work as intended.
  await gc({ type: 'major', execution: 'async' });
  assertFalse(HasBaselineCode(f1));
  assertFalse(HasByteCode(f1));
})();

// Check baseline code and bytecode aren't flushed if baseline code is on
// stack.
function f2(should_recurse) {
  if (should_recurse) {
    assertTrue(HasBaselineCode(f2));
    f2(false);
    // Here we are not checking whether some object was indeed reclaimed,
    // so should not worry if conservative stack scanning is performed.
    gc();
    assertTrue(HasBaselineCode(f2));
  }
  return x.b + 10;
}

(async function () {
  for (i = 1; i < 50; i++) {
    f2(false);
  }
  assertTrue(HasBaselineCode(f2));
  // Recurse with baseline code on stack
  f2(true);
})();
                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/baseline/flush-only-baseline-code.js                               0000664 0000000 0000000 00000004541 14746647661 0025431 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-gc --stress-flush-code --allow-natives-syntax
// Flags: --baseline-batch-compilation-threshold=0 --sparkplug
// Flags: --no-always-sparkplug --lazy-feedback-allocation
// Flags: --flush-baseline-code --no-flush-bytecode --no-turbofan --no-maglev
// Flags: --no-stress-concurrent-inlining
// Flags: --no-concurrent-sparkplug

function HasBaselineCode(f) {
  let opt_status = %GetOptimizationStatus(f);
  return (opt_status & V8OptimizationStatus.kBaseline) !== 0;
}

function HasByteCode(f) {
  let opt_status = %GetOptimizationStatus(f);
  return (opt_status & V8OptimizationStatus.kInterpreted) !== 0;
}

var x = {b:20, c:30};
function f() {
  return x.b + 10;
}

(async function () {
  // Test bytecode gets flushed
  f();
  assertTrue(HasByteCode(f));
  // We need to invoke GC asynchronously and wait for it to finish, so that
  // it doesn't need to scan the stack. Otherwise, some objects may not be
  // reclaimed because of conservative stack scanning and the test may not
  // work as intended.
  await gc({ type: 'major', execution: 'async' });
  assertTrue(HasByteCode(f));
})();

(async function () {
  // Test baseline code gets flushed but not bytecode.
  for (i = 1; i < 50; i++) {
    f();
  }
  assertTrue(HasBaselineCode(f));
  // We need to invoke GC asynchronously and wait for it to finish, so that
  // it doesn't need to scan the stack. Otherwise, some objects may not be
  // reclaimed because of conservative stack scanning and the test may not
  // work as intended.
  await gc({ type: 'major', execution: 'async' });
  assertFalse(HasBaselineCode(f));
  assertTrue(HasByteCode(f));
})();

(async function () {
  // Check baseline code and bytecode aren't flushed if baseline code is on
  // stack.
  function f2(should_recurse) {
    if (should_recurse) {
      assertTrue(HasBaselineCode(f2));
      f2(false);
      // Here we are not checking whether some object was indeed reclaimed,
      // so should not worry if conservative stack scanning is performed.
      gc();
      assertTrue(HasBaselineCode(f2));
    }
    return x.b + 10;
  }

  for (i = 1; i < 50; i++) {
    f2(false);
  }
  assertTrue(HasBaselineCode(f2));
  // Recurse with baseline code on stack
  f2(true);
})();
                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/baseline/test-baseline-module-helper.mjs                           0000664 0000000 0000000 00000000272 14746647661 0026312 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

export default 12;                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/baseline/test-baseline-module.mjs                                  0000664 0000000 0000000 00000001327 14746647661 0025037 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --super-ic --sparkplug --no-always-sparkplug

export let exported = 17;
import imported from 'test-baseline-module-helper.mjs';

function run(f, ...args) {
  try { f(...args); } catch (e) {}
  %CompileBaseline(f);
  return f(...args);
}

function construct(f, ...args) {
  try { new f(...args); } catch (e) {}
  %CompileBaseline(f);
  return new f(...args);
}

assertEquals(17, run((o)=>{ return exported; }));
assertEquals(12, run((o)=>{ return imported; }));
assertEquals(20, run((o)=>{ exported = 20; return exported; }));
                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/baseline/test-baseline.js                                          0000664 0000000 0000000 00000021346 14746647661 0023402 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --super-ic --sparkplug --no-always-sparkplug

function run(f, ...args) {
  try { f(...args); } catch (e) {}
  %CompileBaseline(f);
  return f(...args);
}

function construct(f, ...args) {
  try { new f(...args); } catch (e) {}
  %CompileBaseline(f);
  return new f(...args);
}

// Constants
assertEquals(run(()=>undefined), undefined);
assertEquals(run(()=>null), null);
assertEquals(run(()=>true), true);
assertEquals(run(()=>false), false);
assertEquals(run(()=>"bla"), "bla");
assertEquals(run(()=>42), 42);
assertEquals(run(()=>0), 0);

// Variables
assertEquals(run(()=>{let a = 42; return a}), 42);
assertEquals(run(()=>{let a = 42; let b = 32; return a}), 42);

// Arguments
assertEquals(run((a)=>a, 42), 42);
assertEquals(run((a,b)=>b, 1, 42), 42);
assertEquals(run((a,b,c)=>c, 1, 2, 42), 42);

// Property load
assertEquals(run((o)=>o.a, {a:42}), 42);
assertEquals(run((o, k)=>o[k], {a:42}, "a"), 42);

// Property store
assertEquals(run((o)=>{o.a=42; return o}, {}).a, 42);
assertEquals(run((o, k)=>{o[k]=42; return o}, {}, "a").a, 42);

// Global load/store
global_x = 45;
assertEquals(run(()=>global_x), 45);
run(()=>{ global_x = 49 })
assertEquals(global_x, 49);

// Context load
(function () {
  let x = 42;
  assertEquals(run(()=>{return x;}), 42);
})();
(function () {
  let x = 4;
  x = 42;
  assertEquals(run(()=>{return x;}), 42);
})();

// Context store
(function () {
  let x = 4;
  run(()=>{x = 42;});
  assertEquals(x, 42);
})();


// Super
// var o = {__proto__:{a:42}, m() { return super.a }};
// assertEquals(run(o.m), 42);

// Control flow
assertEquals(run((x)=>{ if(x) return 5; return 10;}), 10);
assertEquals(run(()=>{ var x = 0; for(var i = 1; i; i=0) x=10; return x;}), 10);
assertEquals(run(()=>{ var x = 0; for(var i = 0; i < 10; i+=1) x+=1; return x;}), 10);
assertEquals(run(()=>{ var x = 0; for(var i = 0; i < 10; ++i) x+=1; return x;}), 10);

// Typeof
function testTypeOf(o, t) {
  let types = ['number', 'string', 'symbol', 'boolean', 'bigint', 'undefined',
               'function', 'object'];
  assertEquals(t, eval('run(()=>typeof ' + o + ')'),
               `(()=>typeof ${o})() == ${t}`);
  assertTrue(eval('run(()=>typeof ' + o + ' == "' + t + '")'),
             `typeof ${o} == ${t}`);
  var other_types = types.filter((x) => x !== t);
  for (var other of other_types) {
    assertFalse(eval('run(()=>typeof ' + o + ' == "' + other + '")'),
                `typeof ${o} != ${other}`);
  }
}

testTypeOf('undefined', 'undefined');
testTypeOf('null', 'object');
testTypeOf('true', 'boolean');
testTypeOf('false', 'boolean');
testTypeOf('42.42', 'number');
testTypeOf('42', 'number');
testTypeOf('42n', 'bigint');
testTypeOf('"42"', 'string');
testTypeOf('Symbol(42)', 'symbol');
testTypeOf('{}', 'object');
testTypeOf('[]', 'object');
testTypeOf('new Proxy({}, {})', 'object');
testTypeOf('new Proxy([], {})', 'object');
testTypeOf('(_ => 42)', 'function');
testTypeOf('function() {}', 'function');
testTypeOf('function*() {}', 'function');
testTypeOf('async function() {}', 'function');
testTypeOf('async function*() {}', 'function');
testTypeOf('new Proxy(_ => 42, {})', 'function');
testTypeOf('class {}', 'function');
testTypeOf('Object', 'function');

// Binop
assertEquals(run((a,b)=>{return a+b}, 41, 1), 42);
assertEquals(run((a,b)=>{return a*b}, 21, 2), 42);
assertEquals(run((a)=>{return a+3}, 39), 42);
assertEquals(run((a,b)=>{return a&b}, 0x23, 0x7), 0x3);
assertEquals(run((a)=>{return a&0x7}, 0x23), 0x3);
assertEquals(run((a,b)=>{return a|b}, 0x23, 0x7), 0x27);
assertEquals(run((a)=>{return a|0x7}, 0x23), 0x27);
assertEquals(run((a,b)=>{return a^b}, 0x23, 0x7), 0x24);
assertEquals(run((a)=>{return a^0x7}, 0x23), 0x24);

// Unop
assertEquals(run((x)=>{return x++}, 41), 41);
assertEquals(run((x)=>{return ++x}, 41), 42);
assertEquals(run((x)=>{return x--}, 41), 41);
assertEquals(run((x)=>{return --x}, 41), 40);
assertEquals(run((x)=>{return !x}, 41), false);
assertEquals(run((x)=>{return ~x}, 41), ~41);

// Calls
function f0() { return 42; }
function f1(x) { return x; }
function f2(x, y) { return x + y; }
function f3(x, y, z) { return y + z; }
assertEquals(run(()=>{return f0()}), 42);
assertEquals(run(()=>{return f1(42)}), 42);
assertEquals(run(()=>{return f2(41, 1)}), 42);
assertEquals(run(()=>{return f3(1, 2, 40)}), 42);

// Mapped Arguments
function mapped_args() {
  return [arguments.length, ...arguments];
}
function mapped_args_dup(a,a) {
  return [arguments.length, ...arguments];
}
assertEquals(run(mapped_args, 1, 2, 3), [3,1,2,3]);
assertEquals(run(mapped_args_dup, 1, 2, 3), [3,1,2,3]);

// Unmapped Arguments
function unmapped_args() {
  "use strict";
  return [arguments.length, ...arguments];
}
assertEquals(run(unmapped_args, 1, 2, 3), [3,1,2,3]);

// Rest Arguments
function rest_args(...rest) {
  return [rest.length, ...rest];
}
assertEquals(run(rest_args, 1, 2, 3), [3,1,2,3]);

// Property call
let obj = {
  f0: () => { return 42; },
  f1: (x) => { return x; },
  f2: (x, y) => { return x + y; },
  f3: (x, y, z) => { return y + z; }
}
assertEquals(run(()=>{return obj.f0()}), 42);
assertEquals(run(()=>{return obj.f1(42)}), 42);
assertEquals(run(()=>{return obj.f2(41, 1)}), 42);
assertEquals(run(()=>{return obj.f3(1, 2, 40)}), 42);

// Call with spread
let ns = [2, 40];
assertEquals(run(()=>{return f3("x", ...ns)}), 42);

// Construct
function C(a, b, c) { this.x = 39 + b + c; }
assertEquals(run(()=>{return (new C("a", 1, 2)).x}), 42);
assertEquals(run(()=>{return (new C("a", ...ns)).x}), 81);

// Construct Array
assertEquals(run(()=>{return new Array(1, 2, 39);}).reduce((a,x)=>a+x), 42);

// Call Runtime
assertMatches(run(() => { return %NewRegExpWithBacktrackLimit("ax", "", 50); }), "ax");
run(() => { %CompileBaseline(()=>{}); });

// CallRuntimeForPair
assertEquals(run(()=>{with (f0) return f0();}), 42);

// Closure
assertEquals(run((o)=>{if (true) {let x = o; return ()=>x}}, 42)(), 42);
assertEquals(run((o)=>{return ()=>o}, 42)(), 42);

// Object / Array Literals
assertEquals(run((o)=>{return {a:42}}), {a:42});
assertEquals(run((o)=>{return [42]}), [42]);
assertEquals(run((o)=>{return []}), []);
assertEquals(run((o)=>{return {}}), {});
assertEquals(run((o)=>{return {...o}}, {a:42}), {a:42});
assertEquals(run((o)=>{return /42/}), /42/);
assertEquals(run((o)=>{return [...o]}, [1,2,3,4]), [1,2,3,4]);

// Construct
// Throw if the super() isn't a constructor
class T extends Object { constructor() { super() } }
T.__proto__ = null;
assertThrows(()=>construct(T));

run((o)=>{ try { } finally { } });

// SwitchOnSmiNoFeeback
run((o) => {
  var x = 0;
  var y = 0;
  while (true) {
    try {
      x++;
      if (x == 2) continue;
      if (x == 5) break;
    } finally {
      y++;
    }
  }
  return x + y;
}, 10);

// GetIterator
assertEquals(run((o)=>{
  let sum = 0; for (x of [1, 2]) {sum += x;} return sum;}), 3);

// ForIn
assertEquals(run((o)=>{ let sum = 0; for (let k in o) { sum += o[k] }; return sum }, {a:41,b:1}), 42);

// In
assertTrue(run((o, k)=>{return k in o}, {a:1}, "a"));
assertFalse(run((o, k)=>{return k in o}, {a:1}, "b"));

class D {}
assertTrue(run((o, c)=>{return o instanceof c}, new D(), D));
assertTrue(run((o, c)=>{return o instanceof c}, new D(), Object));
assertFalse(run((o, c)=>{return o instanceof c}, new D(), RegExp));

// CreateArrayFromIterable
assertEquals(run((a)=>{return [...a]}, [1,2,3]), [1,2,3]);

// Generator
let gen = run(function*() {
  yield 1;
  yield 2;
  yield 3;
});
let i = 1;
for (let val of gen) {
  assertEquals(i++, val);
}
assertEquals(4, i);

// Generator with a lot of locals
let gen_func_with_a_lot_of_locals = eval(`(function*() {
  ${ Array(32*1024).fill().map((x,i)=>`let local_${i};`).join("\n") }
  yield 1;
  yield 2;
  yield 3;
})`);
i = 1;
for (let val of run(gen_func_with_a_lot_of_locals)) {
  assertEquals(i++, val);
}
assertEquals(4, i);

// Async await
run(async function() {
  await 1;
  await 1;
  await 1;
  return 42;
}).then(x=>assertEquals(42, x));

// Try-catch
assertEquals(run((x)=>{
  if (x) {
    try {
      if (x) throw x;
      return 45;
    } catch (e) {
      return e;
    }
  }
}, 42), 42);

// Tier-up via InterpreterEntryTrampoline
(function() {
  function factory() {
    return function(a) {
      return a;
    };
  }
  let f1 = factory();
  let f2 = factory();
  %NeverOptimizeFunction(f1);
  %NeverOptimizeFunction(f2);

  assertEquals(f1(0), 0);
  assertEquals(f2(0), 0);
  assertTrue(isInterpreted(f1))
  assertFalse(isBaseline(f1));
  assertTrue(isInterpreted(f2))
  assertFalse(isBaseline(f2));

  %CompileBaseline(f1);
  assertEquals(f1(0), 0);
  assertTrue(isBaseline(f1));
  assertFalse(isBaseline(f2));

  assertEquals(f2(0), 0);
  assertTrue(isBaseline(f1));
  assertTrue(isBaseline(f2));
})();
                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/baseline/test-osr-maglev-tf.js                                     0000664 0000000 0000000 00000003145 14746647661 0024300 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --sparkplug --no-always-sparkplug --use-osr
// Flags: --turbofan --no-always-turbofan --deopt-every-n-times=0
// Flags: --maglev --maglev-osr --osr-from-maglev
// Flags: --concurrent-recompilation

function isExecutingBaseline(func) {
  let opt_status = %GetOptimizationStatus(func);
  return (opt_status & V8OptimizationStatus.kTopmostFrameIsBaseline) !== 0;
}

function f() {
  for (var i = 0; i <= 20; i++) {
    if (i == 5) {
      %BaselineOsr();
    }
    if (i > 5) {
      assertTrue(isBaseline(f));
      assertTrue(isExecutingBaseline(f));
    }
  }
}

%NeverOptimizeFunction(f);
f();

var expectedStatus = V8OptimizationStatus.kTopmostFrameIsInterpreted;

function checkTopmostFrame(func) {
  let opt_status = %GetOptimizationStatus(func);
  assertTrue ((opt_status & expectedStatus) !== 0, "Expected flag " +
      expectedStatus + " to be set in optimization status");
}

function g() {
  for (var i = 0; i <= 20; i++) {
    console.log(i)
    checkTopmostFrame(g)
    if (i == 2) {
      %BaselineOsr();
      expectedStatus = V8OptimizationStatus.kTopmostFrameIsBaseline;
    }
    if (i == 10 || i == 5) {
      %OptimizeOsr();
      // Load these to make sure maglev does not deopt before we tier up.
      let ml = V8OptimizationStatus.kTopmostFrameIsMaglev;
      let tf = V8OptimizationStatus.kTopmostFrameIsTurboFanned;
      expectedStatus = i == 5 ? ml : tf;
    }
  }
}

%PrepareFunctionForOptimization(g);
g();
                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/baseline/test-osr-maglev.js                                        0000664 0000000 0000000 00000002545 14746647661 0023674 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --sparkplug --no-always-sparkplug --use-osr
// Flags: --turbofan --no-always-turbofan --deopt-every-n-times=0
// Flags: --maglev --maglev-osr

function isExecutingBaseline(func) {
  let opt_status = %GetOptimizationStatus(func);
  return (opt_status & V8OptimizationStatus.kTopmostFrameIsBaseline) !== 0;
}

function f() {
  for (var i = 0; i <= 20; i++) {
    if (i == 5) {
      %BaselineOsr();
    }
    if (i > 5) {
      assertTrue(isBaseline(f));
      assertTrue(isExecutingBaseline(f));
    }
  }
}

%NeverOptimizeFunction(f);
f();

var expectedStatus = V8OptimizationStatus.kTopmostFrameIsInterpreted;

function checkTopmostFrame(func) {
  let opt_status = %GetOptimizationStatus(func);
  assertTrue ((opt_status & expectedStatus) !== 0, "Expected flag " +
      expectedStatus + " to be set in optimization status");
}

function g() {
  for (var i = 0; i <= 20; i++) {
    checkTopmostFrame(g)
    if (i == 2) {
      %BaselineOsr();
      expectedStatus = V8OptimizationStatus.kTopmostFrameIsBaseline;
    }
    if (i == 5) {
      %OptimizeOsr();
      expectedStatus = V8OptimizationStatus.kTopmostFrameIsMaglev;
    }
  }
}

%PrepareFunctionForOptimization(g);
g();
                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/baseline/test-osr.js                                               0000664 0000000 0000000 00000002544 14746647661 0022422 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --sparkplug --no-always-sparkplug --use-osr
// Flags: --turbofan --no-always-turbofan --deopt-every-n-times=0
// Flags: --no-maglev-osr

function isExecutingBaseline(func) {
  let opt_status = %GetOptimizationStatus(func);
  return (opt_status & V8OptimizationStatus.kTopmostFrameIsBaseline) !== 0;
}

function f() {
  for (var i = 0; i <= 20; i++) {
    if (i == 5) {
      %BaselineOsr();
    }
    if (i > 5) {
      assertTrue(isBaseline(f));
      assertTrue(isExecutingBaseline(f));
    }
  }
}

%NeverOptimizeFunction(f);
f();

var expectedStatus = V8OptimizationStatus.kTopmostFrameIsInterpreted;

function checkTopmostFrame(func) {
  let opt_status = %GetOptimizationStatus(func);
  assertTrue ((opt_status & expectedStatus) !== 0, "Expected flag " +
      expectedStatus + " to be set in optimization status");
}

function g() {
  for (var i = 0; i <= 20; i++) {
    checkTopmostFrame(g)
    if (i == 2) {
      %BaselineOsr();
      expectedStatus = V8OptimizationStatus.kTopmostFrameIsBaseline;
    }
    if (i == 5) {
      %OptimizeOsr();
      expectedStatus = V8OptimizationStatus.kTopmostFrameIsTurboFanned;
    }
  }
}

%PrepareFunctionForOptimization(g);
g();
                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/baseline/verify-bytecode-offsets.js                                0000664 0000000 0000000 00000002162 14746647661 0025405 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --always-sparkplug --allow-natives-syntax

// This test mainly exists to make ClusterFuzz aware of
// d8.test.verifySourcePositions.

globalValue = false;

function foo(param1, ...param2) {
  try {
    for (let key in param1) { param2.push(key); }
    for (let a of param1) { param2.push(a); }
    let [a, b] = param2;
    let copy = [{literal:1}, {}, [], [1], 1, ...param2];
    return a + b + copy.length;
  } catch (e) {
    return e.toString().match(/[a-zA-Z]+/g);
  } finally {
    globalValue = new String(23);
  }
  return Math.min(Math.random(), 0.5);
}

var obj = [...Array(10).keys()];
obj.foo = 'bar';
foo(obj, obj);

d8.test.verifySourcePositions(foo);

// Make sure invalid calls throw.
assertThrows(() => {d8.test.verifySourcePositions(0)});
assertThrows(() => {d8.test.verifySourcePositions(obj)});
assertThrows(() => {d8.test.verifySourcePositions(new Proxy(foo, {}))});
assertThrows(() => {d8.test.verifySourcePositions(%GetUndetectable())});
                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/basic-promise.js                                                   0000664 0000000 0000000 00000002300 14746647661 0021603 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

// We have to patch mjsunit because normal assertion failures just throw
// exceptions which are swallowed in a then clause.
failWithMessage = (msg) => %AbortJS(msg);

function newPromise() {
  var outerResolve;
  var outerReject;
  let promise = new Promise((resolve, reject) => {
    outerResolve = resolve;
    outerReject = reject;
  });
  Promise.resolve(promise);
  return {
    resolve: outerResolve,
    reject: outerReject,
    then: (f, g) => promise.then(f, g)
  };
}

(function ResolveOK() {
  let promise = newPromise();
  promise.then(msg => {print("resolved: " + msg); assertEquals("ok", msg); },
               ex => {print("rejected: " + ex); %AbortJS("" + ex); });

  promise.resolve("ok");
  promise.reject(11); // ignored
})();

(function RejectOK() {
  let promise = newPromise();
  promise.then(msg => {print("resolved: " + msg); %AbortJS("fail"); },
               ex => {print("rejected: " + ex); assertEquals(42, ex); });

  promise.reject(42);
  promise.resolve("fail"); // ignored
})();
                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/big-array-literal.js                                               0000664 0000000 0000000 00000007360 14746647661 0022370 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// On MacOS X 10.7.5, this test needs a stack size of at least 788 kBytes.
// On PPC64, this test needs a stack size of at least 698 kBytes.
// Flags: --stack-size=1000
//
// The above stack limits were written assuming no lazy parsing, so turn
// off lazy parsing for this test.
// See https://bugs.chromium.org/p/v8/issues/detail?id=5729 for details.
// Flags: --no-lazy

// Test that we can make large object literals that work.
// Also test that we can attempt to make even larger object literals without
// crashing.
function testLiteral(size, array_in_middle) {
  print(size);

  var f;

  // Build object-literal string.
  var literal = "function f() { return ";

  for (var i = 0; i < size; i++) {
    literal += "[";
  }

  literal += array_in_middle ? " [42.2]" : "{a:42.2}";

  for (var i = 0; i < size; i++) {
    literal += "]";
  }

  literal += "; }";

  // Create the object literal.
  eval(literal);

  var x = f();

  // Check that the properties have the expected values.
  for (var i = 0; i < size; i++) {
    x = x[0];
  }

  if (array_in_middle) {
    assertEquals(42.2, x[0]), "x array in middle";
    x[0] = 41.2;
  } else {
    assertEquals(42.2, x.a, "x object in middle");
    x.a = 41.2;
  }

  var y = f();
  for (var i = 0; i < size; i++) {
    y = y[0];
  }

  if (array_in_middle) {
    assertEquals(42.2, y[0], "y array in middle");
    y[0] = 41.2;
  } else {
    assertEquals(42.2, y.a, "y object in middle");
    y.a = 41.2;
  }
}

// The sizes to test.
var sizes = [1, 2, 100, 200, 300];

// Run the test.
for (var i = 0; i < sizes.length; i++) {
  testLiteral(sizes[i], false);
  testLiteral(sizes[i], true);
}


function checkExpectedException(e) {
  assertInstanceof(e, RangeError);
  assertTrue(e.message.indexOf("Maximum call stack size exceeded") >= 0);
}


function testLiteralAndCatch(size) {
  var big_enough = false;
  try {
    testLiteral(size, false);
  } catch (e) {
    checkExpectedException(e);
    big_enough = true;
  }
  try {
    testLiteral(size, true);
  } catch (e) {
    checkExpectedException(e);
    big_enough = true;
  }
  return big_enough;
}

// Catch stack overflows.

testLiteralAndCatch(1000) ||
testLiteralAndCatch(20000) ||
testLiteralAndCatch(200000);
                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/big-object-literal.js                                              0000664 0000000 0000000 00000006726 14746647661 0022525 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test that we can make large object literals that work.
// Also test that we can attempt to make even larger object literals without
// crashing.
function testLiteral(size, array_in_middle) {
  print(size);

  var f;

  // Build object-literal string.
  var literal = "function f() { return ";

  for (var i = 0; i < size; i++) {
    literal += "{a:";
  }

  literal += array_in_middle ? " [42.2]" : "{a:42.2}";

  for (var i = 0; i < size; i++) {
    literal += "}";
    if (i < size - 1) {
      literal += ", b:42, c:/asd/, x:'foo', y:[], z:new Object()";
    }
  }

  literal += "; }";

  // Create the object literal.
  eval(literal);

  var x = f();

  // Check that the properties have the expected values.
  for (var i = 0; i < size; i++) {
    x = x.a;
  }

  if (array_in_middle) {
    assertEquals(42.2, x[0]), "x array in middle";
    x[0] = 41.2;
  } else {
    assertEquals(42.2, x.a, "x object in middle");
    x.a = 41.2;
  }

  var y = f();
  for (var i = 0; i < size; i++) {
    y = y.a;
  }

  if (array_in_middle) {
    assertEquals(42.2, y[0], "y array in middle");
    y[0] = 41.2;
  } else {
    assertEquals(42.2, y.a, "y object in middle");
    y.a = 41.2;
  }
}

// The sizes to test.
var sizes = [1, 2, 100, 200];

// Run the test.
for (var i = 0; i < sizes.length; i++) {
  testLiteral(sizes[i], false);
  testLiteral(sizes[i], true);
}


function checkExpectedException(e) {
  assertInstanceof(e, RangeError);
  assertTrue(e.message.indexOf("Maximum call stack size exceeded") >= 0);
}


function testLiteralAndCatch(size) {
  var big_enough = false;
  try {
    testLiteral(size, false);
  } catch (e) {
    checkExpectedException(e);
    big_enough = true;
  }
  try {
    testLiteral(size, true);
  } catch (e) {
    checkExpectedException(e);
    big_enough = true;
  }
  return big_enough;
}

// Catch stack overflows.

testLiteralAndCatch(1000) ||
testLiteralAndCatch(20000) ||
testLiteralAndCatch(200000);
                                          node-23.7.0/deps/v8/test/mjsunit/binary-op-newspace.js                                              0000664 0000000 0000000 00000004205 14746647661 0022557 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --max-semi-space-size=1 --noturbofan

// Check that a mod where the stub code hits a failure in heap number
// allocation still works.

function f(x) {
  return x % 3;
}

function testMod() {
  for (var i = 0; i < 40000; i++) {
    assertEquals(-1 / 0, 1 / f(-3));
  }
}

testMod();


// Check that an add where the stub code hits a failure in heap number
// allocation still works.

function g(x, y) {
  return x + y;
}

function testAdd() {
  var lhs = 17.42;
  var rhs = 42.17;
  for (var i = 0; i < 40000; i++) {
    assertEquals(59.59, g(lhs, rhs));
  }
}

testAdd();
                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/binary-op-throws-feedback.js                                       0000664 0000000 0000000 00000002266 14746647661 0024027 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

function testThrowsRepeated(fn) {
  %PrepareFunctionForOptimization(fn);
  for (let i = 0; i < 5; i++) assertThrows(fn, TypeError);
  %OptimizeFunctionOnNextCall(fn);
  assertThrows(fn, TypeError);
  // Assert that the function is still optimized, i.e. no deopt happened when
  // calling it.
  assertOptimized(fn);
}

let symbol = Symbol("test");
{ // Test with smi.
  let other = 1;
  let addL = () => symbol + other;
  let addR = () => other + symbol;
  let bitAndL = () => symbol & other;
  let bitAndR = () => other & symbol;
  testThrowsRepeated(addL);
  testThrowsRepeated(addR);
  testThrowsRepeated(bitAndL);
  testThrowsRepeated(bitAndR);
}
{ // Test with non-smi.
  let other = Math.pow(2, 32);
  let addL = () => symbol + other;
  let addR = () => other + symbol;
  let bitAndL = () => symbol & other;
  let bitAndR = () => other & symbol;
  testThrowsRepeated(addL);
  testThrowsRepeated(addR);
  testThrowsRepeated(bitAndL);
  testThrowsRepeated(bitAndR);
}
                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/binary-operation-overwrite.js                                      0000664 0000000 0000000 00000003573 14746647661 0024371 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Ensure that literals are not overwritten.
function f1() { return (1.2, 3.4) + 5.6; }
function f2() { return (1, 2) + 3; }
function f3() { return (1.2 || 3.4) + 5.6; }
function f4() { return (1 || 2) + 3; }
assertTrue(f1() === f1());
assertTrue(f2() === f2());
assertTrue(f3() === f3());
assertTrue(f4() === f4());
                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/bit-not.js                                                         0000664 0000000 0000000 00000005230 14746647661 0020427 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function testBitNot(x, name) {
  // The VM constant folds so we use that to check the result.
  var expected = eval("~(" + x + ")");
  var actual = ~x;
  assertEquals(expected, actual, "x: " + name);

  // Test the path where we can overwrite the result. Use -
  // to avoid concatenating strings.
  expected = eval("~(" + x + " - 0.01)");
  actual = ~(x - 0.01);
  assertEquals(expected, actual, "x - 0.01: " + name);
}


testBitNot(0, 0);
testBitNot(1, 1);
testBitNot(-1, 1);
testBitNot(100, 100);
testBitNot(0x40000000, "0x40000000");
testBitNot(0x7fffffff, "0x7fffffff");
testBitNot(0x80000000, "0x80000000");

testBitNot(2.2, 2.2);
testBitNot(-2.3, -2.3);
testBitNot(Infinity, "Infinity");
testBitNot(NaN, "NaN");
testBitNot(-Infinity, "-Infinity");
testBitNot(0x40000000 + 0.12345, "float1");
testBitNot(0x40000000 - 0.12345, "float2");
testBitNot(0x7fffffff + 0.12345, "float3");
testBitNot(0x7fffffff - 0.12345, "float4");
testBitNot(0x80000000 + 0.12345, "float5");
testBitNot(0x80000000 - 0.12345, "float6");

testBitNot("0", "string0");
testBitNot("2.3", "string2.3");
testBitNot("-9.4", "string-9.4");
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/bitops-info.js                                                     0000664 0000000 0000000 00000007466 14746647661 0021321 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function non_int32() {
  return 2600822924;  // It's not a signed Int32.
}

function hidden_smi() {
  return 46512102;  // It's a Smi
}

function hidden_int32() {
  return 1600822924;  // It's a signed Int32.
}

function f() {
  var x = non_int32();  // Not a constant.
  var y = hidden_smi();  // Not a constant.
  var z = hidden_int32();
  assertEquals(46512102 & 2600822924, 46512102 & x, "1");
  assertEquals(1600822924 & 2600822924, 1600822924 & x, "2");
  assertEquals(2600822924 & 2600822924, 2600822924 & x, "3");
  assertEquals(46512102 & 46512102, 46512102 & y, "4");
  assertEquals(1600822924 & 46512102, 1600822924 & y, "5");
  assertEquals(2600822924 & 46512102, 2600822924 & y, "6");
  assertEquals(46512102 & 1600822924, 46512102 & z, "7");
  assertEquals(1600822924 & 1600822924, 1600822924 & z, "8");
  assertEquals(2600822924 & 1600822924, 2600822924 & z, "9");
  assertEquals(46512102 & 2600822924, y & x, "10");
  assertEquals(1600822924 & 2600822924, z & x, "11");

  assertEquals(46512102 & 2600822924, x & 46512102, "1rev");
  assertEquals(1600822924 & 2600822924, x & 1600822924, "2rev");
  assertEquals(2600822924 & 2600822924, x & 2600822924, "3rev");
  assertEquals(46512102 & 46512102, y & 46512102, "4rev");
  assertEquals(1600822924 & 46512102, y & 1600822924, "5rev");
  assertEquals(2600822924 & 46512102, y & 2600822924, "6rev");
  assertEquals(46512102 & 1600822924, z & 46512102, "7rev");
  assertEquals(1600822924 & 1600822924, z & 1600822924, "8rev");
  assertEquals(2600822924 & 1600822924, z & 2600822924, "9rev");
  assertEquals(46512102 & 2600822924, x & y, "10rev");
  assertEquals(1600822924 & 2600822924, x & z, "11rev");

  assertEquals((46512102 & -0x20123456) | 1, (y & -0x20123456) | 1, "12");
  assertEquals((1600822924 & -0x20123456) | 1, (z & -0x20123456) | 1, "13");
  assertEquals((2600822924 & -0x20123456) | 1, (x & -0x20123456) | 1, "14");
  assertEquals((46512102 & -0x20123456) | 1, (-0x20123456 & y) | 1, "12rev");
  assertEquals((1600822924 & -0x20123456) | 1, (-0x20123456 & z) | 1, "13rev");
  assertEquals((2600822924 & -0x20123456) | 1, (-0x20123456 & x) | 1, "14rev");

  assertEquals(2600822924 & 2600822924, x & x, "xx");
  assertEquals(y, y & y, "yy");
  assertEquals(z, z & z, "zz");
}


for (var i = 0; i < 5; i++) {
  f();
}
                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/bitwise-operations-bools.js                                        0000664 0000000 0000000 00000005714 14746647661 0024025 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test bitwise operations with booleans.

var t = 1;

function testFalseLeftHandSide() {
  var b;
  if (t) b = false;
  assertEquals(b | 1, 1);
  assertEquals(b & 1, 0);
  assertEquals(b ^ 1, 1);
  assertEquals(b << 1, 0);
  assertEquals(b >> 1, 0);
  assertEquals(b >>> 1, 0);
}

function testFalseRightHandSide() {
  if (t) b = false;
  assertEquals(1 |   b, 1);
  assertEquals(1 &   b, 0);
  assertEquals(1 ^   b, 1);
  assertEquals(1 <<  b, 1);
  assertEquals(1 >>  b, 1);
  assertEquals(1 >>> b, 1);
}

function testTrueLeftHandSide() {
  if (t) b = true;
  assertEquals(b | 1, 1);
  assertEquals(b & 1, 1);
  assertEquals(b ^ 1, 0);
  assertEquals(b << 1, 2);
  assertEquals(b >> 1, 0);
  assertEquals(b >>> 1, 0);
}

function testTrueRightHandSide() {
  if (t) b = true;
  assertEquals(1 |   b, 1);
  assertEquals(1 &   b, 1);
  assertEquals(1 ^   b, 0);
  assertEquals(1 <<  b, 2);
  assertEquals(1 >>  b, 0);
  assertEquals(1 >>> b, 0);
}

function testBothSides() {
  if (t) a = true;
  if (t) b = false;
  assertEquals(a |   b, 1);
  assertEquals(a &   b, 0);
  assertEquals(a ^   b, 1);
  assertEquals(a <<  b, 1);
  assertEquals(a >>  b, 1);
  assertEquals(a >>> b, 1);
}


testFalseLeftHandSide();
testFalseRightHandSide();
testTrueLeftHandSide();
testTrueRightHandSide();
testFalseLeftHandSide();
testFalseRightHandSide();
testTrueLeftHandSide();
testTrueRightHandSide();
testBothSides();
testBothSides();
                                                    node-23.7.0/deps/v8/test/mjsunit/bitwise-operations-undefined.js                                    0000664 0000000 0000000 00000004232 14746647661 0024642 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test bitwise operations with undefined.

function testUndefinedLeftHandSide() {
  assertEquals(undefined | 1, 1);
  assertEquals(undefined & 1, 0);
  assertEquals(undefined ^ 1, 1);
  assertEquals(undefined << 1, 0);
  assertEquals(undefined >> 1, 0);
  assertEquals(undefined >>> 1, 0);
}

function testUndefinedRightHandSide() {
  assertEquals(1 | undefined, 1);
  assertEquals(1 & undefined, 0);
  assertEquals(1 ^ undefined, 1);
  assertEquals(1 << undefined, 1);
  assertEquals(1 >> undefined, 1);
  assertEquals(1 >>> undefined, 1);
}

testUndefinedLeftHandSide();
testUndefinedRightHandSide();
                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/body-not-visible.js                                                0000664 0000000 0000000 00000003542 14746647661 0022245 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Make sure we cannot see the local variables in NewFunction when
// compiling functions using new Function().

var caught = false;
try {
  (new Function("return body;"))();
  assertTrue(false);
} catch (e) {
  caught = true;
  assertTrue(e instanceof ReferenceError);
}
assertTrue(caught);
                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/bool-concat.js                                                     0000664 0000000 0000000 00000003430 14746647661 0021253 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function format(a) {
  if (a) {
    return "X"+true+"Y";
  } else {
    return "X"+false+"Y";
  }
}

for (var i = 0; i < 1000; i++) {
  assertEquals("XtrueY", format(true));
  assertEquals("XfalseY", format(false));
}
                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/boolean.js                                                         0000664 0000000 0000000 00000006162 14746647661 0020477 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2011 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

assertEquals(Boolean(void 0), false);
assertEquals(Boolean(null), false);
assertEquals(Boolean(false), false);
assertEquals(Boolean(true), true);
assertEquals(Boolean(0), false);
assertEquals(Boolean(1), true);
assertEquals(Boolean(assertEquals), true);
assertEquals(Boolean(new Object()), true);
assertTrue(new Boolean(false) !== false);
assertTrue(new Boolean(false) == false);
assertTrue(new Boolean(true) !== true);
assertTrue(new Boolean(true) == true);

assertEquals(true, !false);
assertEquals(false, !true);
assertEquals(true, !!true);
assertEquals(false, !!false);

assertEquals(true, true ? true : false);
assertEquals(false, false ? true : false);

assertEquals(false, true ? false : true);
assertEquals(true, false ? false : true);


assertEquals(true, true && true);
assertEquals(false, true && false);
assertEquals(false, false && true);
assertEquals(false, false && false);

// Regression.
var t = 42;
assertEquals(void 0, t.p);
assertEquals(void 0, t.p && true);
assertEquals(void 0, t.p && false);
assertEquals(void 0, t.p && (t.p == 0));
assertEquals(void 0, t.p && (t.p == null));
assertEquals(void 0, t.p && (t.p == t.p));

var o = new Object();
o.p = 'foo';
assertEquals('foo', o.p);
assertEquals('foo', o.p || true);
assertEquals('foo', o.p || false);
assertEquals('foo', o.p || (o.p == 0));
assertEquals('foo', o.p || (o.p == null));
assertEquals('foo', o.p || (o.p == o.p));

// JSToBoolean(x:string)
function f(x) { return !!("" + x); }
assertEquals(false, f(""));
assertEquals(true, f("narf"));
assertEquals(true, f(12345678));
assertEquals(true, f(undefined));
                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/bounds-checks-elimination.js                                       0000664 0000000 0000000 00000005360 14746647661 0024115 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

var a = []
for (var i = 0; i < 9; i++) a[i] = i + 1;

function test(f, arg1, arg2, expected) {
  %PrepareFunctionForOptimization(f);
  assertEquals(expected, f(arg1));
  f(arg2);
  %OptimizeFunctionOnNextCall(f);
  assertEquals(expected, f(arg1));
}

test(function f0() {
  return a[7] * a[6] * a[5] * a[4] * a[3] * a[2] * a[1] * a[0];
}, 0, 1, 40320);

test(function f1() {
  return a[7] * a[6] * a[5] * a[4] * a[10] * a[2] * a[1] * a[0];
}, 0, 1, NaN);

test(function f2() {
  return a[0] * a[1] * a[2] * a[3] * a[4] * a[5] * a[6] * a[7];
}, 0, 1, 40320);

test(function f3() {
  return a[3] * a[0] * a[6] * a[7] * a[5] * a[1] * a[4] * a[2];
}, 0, 1, 40320);

test(function f4(b) {
  return a[b+3] * a[0] * a[b+6] * a[7] * a[b+5] * a[1] * a[b+4] * a[2];
}, 0, 1, 40320);

test(function f5(b) {
  return a[b+1] * a[0] * a[b+4] * a[7] * a[b+3] * a[1] * a[b+2] * a[2];
}, 2, 3, 40320);

test(function f6(b) {
  var c;
  if (b) c = a[3] * a[0] * a[6] * a[7];
  return c * a[5] * a[1] * a[4] * a[2];
}, true, false, 40320);

test(function f7(b) {
  var c = a[7];
  if (b) c *= a[3] * a[0] * a[6];
  return c * a[5] * a[1] * a[4] * a[2];
}, true, false, 40320);

test(function f8(b) {
  var c = a[7];
  if (b) c *= a[3] * a[0] * a[6];
  return c * a[5] * a[10] * a[4] * a[2];
}, true, false, NaN);

test(function f9(b) {
  var c = a[1];
  if (b) {
    c *= a[3] * a[0] * a[6];
  } else {
    c = a[6] * a[5] * a[4];
  }
  return c * a[5] * a[7] * a[4] * a[2];
}, true, false, 40320);

test(function fa(b) {
  var c = a[1];
  if (b) {
    c = a[6] * a[b+5] * a[4];
  } else {
    c *= a[b+3] * a[0] * a[b+6];
  }
  return c * a[5] * a[b+7] * a[4] * a[2];
}, 0, 1, 40320);

test(function fb(b) {
  var c = a[b-3];
  if (b != 4) {
    c = a[6] * a[b+1] * a[4];
  } else {
    c *= a[b-1] * a[0] * a[b+2];
  }
  return c * a[5] * a[b+3] * a[4] * a[b-2];
}, 4, 3, 40320);

test(function fc(b) {
  var c = a[b-3];
  if (b != 4) {
    c = a[6] * a[b+1] * a[4];
  } else {
    c *= a[b-1] * a[0] * a[b+2];
  }
  return c * a[5] * a[b+3] * a[4] * a[b-2];
}, 6, 3, NaN);

test(function fd(b) {
  var c = a[b-3];
  if (b != 4) {
    c = a[6] * a[b+1] * a[4];
  } else {
    c *= a[b-1] * a[0] * a[b+2];
  }
  return c * a[5] * a[b+3] * a[4] * a[b-2];
}, 1, 4, NaN);

test(function fe(b) {
  var c = 1;
  for (var i = 1; i < b-1; i++) {
    c *= a[i-1] * a[i] * a[i+1];
  }
  return c;
}, 8, 4, (40320 / 8 / 7) * (40320 / 8) * (40320 / 2));

test(function ff(b) {
  var c = 0;
  for (var i = 0; i < b; i++) {
    c += a[3] * a[0] * a[6] * a[7] * a[5] * a[1] * a[4] * a[2];
  }
  return c;
}, 100, 4, 40320 * 100);
                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/break.js                                                           0000664 0000000 0000000 00000004267 14746647661 0020150 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2011 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function f() {
  var i = 10;
  var c = 0;
  while (i-- > 0) {
    c++;
    if (i == 5) ;
  }
  assertEquals(10, c);
}
f();


function f2() {
  var i = 10;
  var c = 0;
  while (i-- > 0) {
    c++;
    if (i == 5) break;
  }
  assertEquals(5, c);
}
f2();


function f3() {
  var i = 10;
  var c = 0;
  outer: while (i-- > 0) {
    var j = 10;
    inner1: inner2: inner3: while (j-- > 0) {
      c++;
      if (i == 8)
        break inner2;
      if (i == 6)
        break outer;
    }
  }
  assertEquals(22, c);
}
f3();

outer2: {
  break outer2;
  assertUnreachable();
}


outer3: break outer3;  // nop
l1: l2: l3: break l2;  // nop
                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/bugs/                                                              0000775 0000000 0000000 00000000000 14746647661 0017455 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/bugs/bug-1344252.js                                                0000664 0000000 0000000 00000006025 14746647661 0021415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test that setter accessors added to the prototype chain are called
// when setting properties.

// Test that accessors added to the prototype chain are called
// eventhough there are inline caches for setting the property

function F() {
  this.x = 42;
  this.y = 87;
}

// Force the inline caches to monomorphic state.
new F(); new F();

// Add a setter for x to Object.prototype and make sure it gets
// called.
var result_x;
Object.prototype.__defineSetter__('x', function(value) { result_x = value; });
var f = new F();
assertEquals(42, result_x);
assertTrue(typeof f.x == 'undefined');

// Add a setter for y by changing the prototype of f and make sure
// that gets called too.
var result_y;
var proto = new Object();
proto.__defineSetter__('y', function (value) { result_y = value; });
var f = new F();
f.y = undefined;
f.__proto__ = proto;
F.call(f);
assertEquals(87, result_y);
assertTrue(typeof f.y == 'undefined');


// Test the same issue in the runtime system.  Make sure that
// accessors added to the prototype chain are called instead of
// following map transitions.
//
// Create two objects.
var result_z;
var o1 = new Object();
var o2 = new Object();
// Add a z property to o1 to create a map transition.
o1.z = 32;
// Add a z accessor in the prototype chain for o1 and o2.
Object.prototype.__defineSetter__('z', function(value) { result_z = value; });
// The accessor should be called for o2.
o2.z = 27;
assertEquals(27, result_z);
assertTrue(typeof o2.z == 'undefined');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/bugs/bug-222.js                                                    0000664 0000000 0000000 00000003634 14746647661 0021101 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function Foo(a, b) { }
Foo();
var oldArgs = Foo.arguments;
Foo();
var newArgs = Foo.arguments

assertTrue(oldArgs !== newArgs);

// Don't allow arguments to be overwritten.
Foo.arguments = oldArgs;
assertEquals(Foo.arguments, newArgs);

// Don't allow arguments to be deleted.
assertFalse(delete Foo.arguments);
assertEquals(Foo.arguments, newArgs);
                                                                                                    node-23.7.0/deps/v8/test/mjsunit/bugs/bug-617.js                                                    0000664 0000000 0000000 00000003543 14746647661 0021110 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// See http://code.google.com/p/v8/issues/detail?id=617 comment 5

var got_here = 0;

function make_sure_we_dont_get_here() {
  got_here = 1;
}

RegExp.prototype.exec = make_sure_we_dont_get_here;

var re = /foo/;

re.exec = make_sure_we_dont_get_here;

re("foo");

assertEquals(got_here, 0);
                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/bugs/bug-941049.js                                                 0000664 0000000 0000000 00000005764 14746647661 0021354 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This test fails because we copy the arguments array on indirect
// access

function g(f) {
  assertEquals(100, f.arguments = 100);  // read-only
  assertEquals(3, f.arguments.length);
  assertEquals(1, f.arguments[0]);
  assertEquals(2, f.arguments[1]);
  assertEquals(3, f.arguments[2]);
  f.arguments[0] = 999;
  f.arguments.extra = 'kallevip';
}

function h(f) {
  assertEquals('kallevip', f.arguments.extra);
  return f.arguments;
}

// Test function with a materialized arguments array.
function f0() {
  g(f0);
  var result = h(f0);
  var a = arguments;
  assertEquals(999, a[0]);
  return result;
}


// Test function without a materialized arguments array.
function f1(x) {
  g(f1);
  var result = h(f1);
  assertEquals(999, x);
  return result;
}


function test(f) {
  assertTrue(null === f.arguments);
  var args = f(1,2,3);
  assertTrue(null === f.arguments);

  assertEquals(3, args.length);
  assertEquals(999, args[0]);
  assertEquals(2, args[1]);
  assertEquals(3, args[2]);
  assertEquals('kallevip', args.extra);
}

test(f0);
test(f1);




function w() {
  return q.arguments;
}

function q(x, y) {
  x = 2;
  var result = w();
  y = 3;
  return result;
}

var a = q(0, 1);
// x is set locally *before* the last use of arguments before the
// activation of q is popped from the stack.
assertEquals(2, a[0]);
// y is set locally *after* the last use of arguments before the
// activation of q is popped from the stack.
assertEquals(1, a[1]);
            node-23.7.0/deps/v8/test/mjsunit/bugs/bug-proto.js                                                  0000664 0000000 0000000 00000005204 14746647661 0021732 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var realmA = Realm.current();
var realmB = Realm.create();
assertEquals(0, realmA);
assertEquals(1, realmB);

// The global objects match the realms' this binding.
assertSame(this, Realm.global(realmA));
assertSame(Realm.eval(realmB, "this"), Realm.global(realmB));
assertFalse(this === Realm.global(realmB));

// The global object is not accessible cross-realm.
var x = 3;
Realm.shared = this;
assertThrows("Realm.eval(realmB, 'x')");
assertSame(undefined, Realm.eval(realmB, "this.x"));
assertSame(undefined, Realm.eval(realmB, "Realm.shared.x"));

Realm.eval(realmB, "Realm.global(0).y = 1");
assertThrows("y");
assertSame(undefined, this.y);

// Can get or set other objects' properties cross-realm.
var p = {a: 1};
var o = {__proto__: p, b: 2};
Realm.shared = o;
assertSame(1, Realm.eval(realmB, "Realm.shared.a"));
assertSame(2, Realm.eval(realmB, "Realm.shared.b"));

// Cannot get or set a prototype cross-realm.
assertSame(undefined, Realm.eval(realmB, "Realm.shared.__proto__"));

Realm.eval(realmB, "Realm.shared.__proto__ = {c: 3}");
assertSame(1, o.a);
assertSame(undefined, o.c);
                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/call-cross-realm.js                                                0000664 0000000 0000000 00000000751 14746647661 0022216 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

Realm.create();
var object = Realm.eval(1, "Object");
var f = Realm.eval(1, "function f() { return this }; f");

Number.prototype.f = f;
var number = 1;
assertEquals(object.prototype, f.call(number).__proto__.__proto__);
assertEquals(object.prototype, number.f().__proto__.__proto__);
assertEquals(Realm.global(1), f());
                       node-23.7.0/deps/v8/test/mjsunit/call-intrinsic-differential-fuzzing.js                             0000664 0000000 0000000 00000000523 14746647661 0026112 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-for-differential-fuzzing

// Test blocklisted intrinsics in the context of differential fuzzing.
assertEquals(undefined, %IsBeingInterpreted());
                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/call-intrinsic-fuzzing.js                                          0000664 0000000 0000000 00000001642 14746647661 0023463 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --fuzzing

// Test allow/block-listed intrinsics in the context of fuzzing.

// Blocklisted intrinsics are replaced with undefined.
assertEquals(undefined, %ConstructConsString("a", "b"));

// Blocklisted intrinsics can have wrong arguments.
assertEquals(undefined, %ConstructConsString(1, 2, 3, 4));

// We don't care if an intrinsic actually exists.
assertEquals(undefined, %FooBar());

// Check allowlisted intrinsic.
assertNotEquals(undefined, %IsBeingInterpreted());

// Allowlisted runtime functions with too few args are ignored.
assertEquals(undefined, %DeoptimizeFunction());

// Superfluous arguments are ignored.
%DeoptimizeFunction(function() {}, undefined);
assertNotEquals(undefined, %IsBeingInterpreted(1, 2, 3));
                                                                                              node-23.7.0/deps/v8/test/mjsunit/call-intrinsic-type-error.js                                       0000664 0000000 0000000 00000000425 14746647661 0024075 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

try {
  %Call(1, 0);
} catch (e) {
  assertTrue(e instanceof TypeError);
}
                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/call-lhs-web-compat-early-errors.js                                0000664 0000000 0000000 00000004301 14746647661 0025230 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Will be used in the tests
function foo() {}

function wrapInLazyFunction(s) {
  // Use an async function, since some tests use the await keyword.
  return "async function test() { " + s + "}";
}

function wrapInEagerFunction(s) {
  // Use an async function, since some tests use the await keyword. Await the
  // result, so that we get the error right away.
  return "await (async function test() { " + s + "})();";
}

function assertEarlyError(s) {
  assertThrows(wrapInLazyFunction(s), SyntaxError);
}

function assertLateError(s) {
  assertDoesNotThrow(wrapInLazyFunction(s));
  assertThrows(wrapInEagerFunction(s), ReferenceError);
}

// Web compatibility:
assertLateError("foo() = 0;");
assertLateError("foo()++;");
assertLateError("foo()--;");
assertLateError("++foo();");
assertLateError("--foo();");
assertLateError("foo() = 1;");
assertLateError("foo() += 1;");
assertLateError("foo() -= 1;");
assertLateError("foo() *= 1;");
assertLateError("foo() /= 1;");
assertLateError("for (foo() = 0; ; ) {}");
assertLateError("for ( ; ; foo() = 0) {}");
assertLateError("for (foo() of []) {}");
assertLateError("for (foo() in {}) {}");
assertLateError("for await (foo() of []) {}");

// These are early errors though:
assertEarlyError("for (let foo() = 0; ;) {}");
assertEarlyError("for (const foo() = 0; ;) {}");
assertEarlyError("for (var foo() = 0; ;) {}");

// Modern language features:
// Tagged templates
assertEarlyError("foo() `foo` ++;");
assertEarlyError("foo() `foo` --;");
assertEarlyError("++ foo() `foo`;");
assertEarlyError("-- foo() `foo`;");
assertEarlyError("foo() `foo` = 1;");
assertEarlyError("foo() `foo` += 1;");
assertEarlyError("foo() `foo` -= 1;");
assertEarlyError("foo() `foo` *= 1;");
assertEarlyError("foo() `foo` /= 1;");
assertEarlyError("for (foo() `foo` = 0; ; ) {}");
assertEarlyError("for (; ; foo() `foo` = 0) {}");

// Logical assignment
assertEarlyError("foo() &&= 1;");
assertEarlyError("foo() ||= 1;");
assertEarlyError("foo() ??= 1;");
assertEarlyError("for (foo() &&= 0; ;) {}");
assertEarlyError("for ( ; ; foo() &&= 0) {}");
                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/call-non-function-call.js                                          0000664 0000000 0000000 00000003506 14746647661 0023316 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Throw exception when invoking Function.prototype.call with a
// non-function receiver.
var caught = false;
try {
  Function.prototype.call.call({});
  assertTrue(false);
} catch (e) {
  caught = true;
  assertTrue(e instanceof TypeError);
}
assertTrue(caught);
                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/call-non-function.js                                               0000664 0000000 0000000 00000004235 14746647661 0022405 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function TryCall(x) {
  var caught = [];
  try {
    x();
  } catch (e) {
    caught.push(e);
  }

  try {
    new x();
  } catch (e) {
    caught.push(e);
  }

  assertTrue(caught[0] instanceof TypeError);
  assertTrue(caught[1] instanceof TypeError);
};


TryCall(this);
TryCall(Math);
TryCall(true);
TryCall(1234);
TryCall("hest");


// Make sure that calling a non-function global doesn't crash the
// system while building the IC for it.
var NonFunction = 42;
function WillThrow() {
  NonFunction();
}
assertThrows(WillThrow);
assertThrows(WillThrow);
assertThrows(WillThrow);
assertThrows(WillThrow);
                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/call-stub.js                                                       0000664 0000000 0000000 00000004362 14746647661 0020746 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function Hash() {
  for (var i = 0; i < 100; i++) {
    this['a' + i] = i;
  }

  delete this.a50;  // Ensure it's a normal object.
}

Hash.prototype.m = function() {
  return 1;
};

var h = new Hash();

for (var i = 1; i < 100; i++) {
  if (i == 50) {
    h.m = function() {
      return 2;
    };
  } else if (i == 70) {
    delete h.m;
  }
  assertEquals(i < 50 || i >= 70 ? 1 : 2, h.m());
}


var nonsymbol = 'wwwww '.split(' ')[0];
Hash.prototype.wwwww = Hash.prototype.m;

for (var i = 1; i < 100; i++) {
  if (i == 50) {
    h[nonsymbol] = function() {
      return 2;
    };
  } else if (i == 70) {
    delete h[nonsymbol];
  }
  assertEquals(i < 50 || i >= 70 ? 1 : 2, h.wwwww());
}
                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/call.js                                                            0000664 0000000 0000000 00000005652 14746647661 0017776 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function f0() {
  return this;
}

assertTrue(this === f0.call(), "1");

assertTrue(this === f0.call(this), "w");
assertTrue(this === f0.call(this, 1), "w");
assertTrue(this === f0.call(this, 1, 2), "w");

assertTrue(this === f0.call(null), "3a");
assertTrue(this === f0.call(null, 1), "3b");
assertTrue(this === f0.call(null, 1, 2), "3c");

assertTrue(this === f0.call(void 0), "4a");
assertTrue(this === f0.call(void 0, 1), "4b");
assertTrue(this === f0.call(void 0, 1, 2), "4c");

var x = {};
assertTrue(x === f0.call(x));
assertTrue(x === f0.call(x, 1));
assertTrue(x === f0.call(x, 1, 2));


function f1(a) {
  a = a || 'i';
  return this[a];
}

assertEquals(1, f1.call({i:1}));
assertEquals(42, f1.call({i:42}, 'i'));
assertEquals(87, f1.call({j:87}, 'j', 1));
assertEquals(99, f1.call({k:99}, 'k', 1, 2));


function f2(a, b) {
  a = a || 'n';
  b = b || 2;
  return this[a] + b;
}

var x = {n: 1};
assertEquals(3, f2.call(x));
assertEquals(14, f2.call({i:12}, 'i'));
assertEquals(42, f2.call(x, 'n', 41));
assertEquals(87, f2.call(x, 'n', 86, 1));
assertEquals(99, f2.call(x, 'n', 98, 1, 2));


function fn() {
  return arguments.length;
}

assertEquals(0, fn.call());
assertEquals(0, fn.call(this));
assertEquals(0, fn.call(null));
assertEquals(0, fn.call(void 0));
assertEquals(1, fn.call(this, 1));
assertEquals(2, fn.call(this, 1, 2));
assertEquals(3, fn.call(this, 1, 2, 3));
                                                                                      node-23.7.0/deps/v8/test/mjsunit/canonicalize-nan.js                                                0000664 0000000 0000000 00000000762 14746647661 0022271 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

var buf = new Float32Array(1);

function fill() {
  buf[0] = 0;
};

// Have single precision zero set.
%PrepareFunctionForOptimization(fill);
fill();
%OptimizeFunctionOnNextCall(fill);
fill();

var array = Array(2).fill(0);

assertEquals(0, array[1])
array[1] = 0.5;
assertEquals(0.5, array[1]);
              node-23.7.0/deps/v8/test/mjsunit/char-escape.js                                                     0000664 0000000 0000000 00000004546 14746647661 0021237 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Check that character escapes are understood as one char
var escapes = ["\b", "\t", "\n", "\v", "\f", "\r", "\"", "\'", "\\", "\x4a", "\u005f"];
for (var i = 0; i < escapes.length; i++) {
  var str = escapes[i];
  assertEquals(1, str.length);
  assertEquals(str, str.charAt(0));
}

function code(str) {
  return str.charCodeAt(0);
}

// Do the single escape chars have the right value?
assertEquals(0x08, code("\b"));
assertEquals(0x09, code("\t"));
assertEquals(0x0A, code("\n"));
assertEquals(0x0B, code("\v"));
assertEquals(0x0C, code("\f"));
assertEquals(0x0D, code("\r"));
assertEquals(0x22, code("\""));
assertEquals(0x27, code("\'"));
assertEquals(0x5c, code("\\"));

// Do the hex and unicode escape chars have the right value?
assertEquals(0x4a, code("\x4a"));
assertEquals(0x5f, code("\u005f"));
                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/check-bounds-array-index.js                                        0000664 0000000 0000000 00000001220 14746647661 0023634 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Flags: --allow-natives-syntax --turbofan --no-always-turbofan
// Flags: --no-stress-flush-code

let arr = [1, 2, 3];

function f(useArrayIndex) {
  let index = useArrayIndex ? '1': '4294967296';
  return arr[index];
}

%PrepareFunctionForOptimization(f);
f(true);
f(true);

%OptimizeFunctionOnNextCall(f);
f(false);
assertUnoptimized(f);

%PrepareFunctionForOptimization(f);
f(true);
f(true);

%OptimizeFunctionOnNextCall(f);
f(true);

// no deopt here
f(false);
assertOptimized(f);
                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/check-bounds-string-from-char-code-at.js                           0000664 0000000 0000000 00000001240 14746647661 0026107 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Flags: --allow-natives-syntax --turbofan --no-always-turbofan
// Flags: --no-stress-flush-code

let string = "foobar";

function f(useArrayIndex) {
  let index = useArrayIndex ? '1': '4294967296';
  return string.charCodeAt(index);
}

%PrepareFunctionForOptimization(f);
f(true);
f(true);

%OptimizeFunctionOnNextCall(f);
f(false);
assertUnoptimized(f);

%PrepareFunctionForOptimization(f);
f(true);
f(true);

%OptimizeFunctionOnNextCall(f);
f(true);

// no deopt here
f(false);
assertOptimized(f);
                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/clone-ic-attached.js                                               0000664 0000000 0000000 00000001270 14746647661 0022317 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-lazy-feedback-allocation


function f(x) {return {...x,b:2}};
let o={a:1}

// Ensure the clone ic does not generate detached maps.

assertTrue(%HaveSameMap(f(o), f(o)));
assertTrue(%HaveSameMap(f(o), f(o)));
assertTrue(%HaveSameMap(f(o), f(o)));
assertTrue(%HaveSameMap(f(o), f(o)));

assertTrue(%HaveSameMap({...o},{...o}));
assertTrue(%HaveSameMap({...o},{...o}));
assertTrue(%HaveSameMap({...o},{...o}));
assertTrue(%HaveSameMap({...o},{...o}));
assertTrue(%HaveSameMap({...o},{...o}));
                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/clone-ic-regression-crbug-1466315.js                               0000664 0000000 0000000 00000000442 14746647661 0024651 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var p = {};
var _ = {__proto__: p};
_ = null;
console.log(p.constructor.name);
a = { ...p};
p.asdf = 22;
a.asdfasdf = 22;
                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/clone-ic-regressions.js                                            0000664 0000000 0000000 00000015451 14746647661 0023113 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Flags: --allow-natives-syntax

// Tests megamorphic case
function clone1(o) {
  return {...o};
}
// Tests monomorphic case
function clone2(o) {
  return {...o};
}
// Tests null proto
function clone3(o) {
  return {...o, __proto__: null};
}
%PrepareFunctionForOptimization(clone1);
%PrepareFunctionForOptimization(clone2);
%PrepareFunctionForOptimization(clone3);

function test(a, b) {
  %ClearFunctionFeedback(clone2);
  assertEquals({...b}, a);
  assertEquals(clone1(b), a);
  assertEquals(clone1(b), a);
  assertEquals(clone2(b), a);
  assertEquals(clone2(b), a);
  assertEquals(clone1(b).constructor, a.constructor);
  assertEquals(clone2(b).constructor, a.constructor);
  %ClearFunctionFeedback(clone2);
  assertEquals(clone2(b).constructor, a.constructor);

  var a2 = {...a};
  // Provoke some transitions
  %ClearFunctionFeedback(clone2);
  Object.assign(a, {xx: 42})
  assertEquals({...b, xx: 42}, a);
  assertEquals({...clone1(b), xx: 42}, a);
  assertEquals({...clone1(b), xx: 42}, a);
  assertEquals({...clone2(b), xx: 42}, a);
  assertEquals({...clone2(b), xx: 42}, a);

  %ClearFunctionFeedback(clone2);
  Object.assign(a, {xx: 42.2})
  assertEquals({...b, xx: 42.2}, a);
  assertEquals({...clone1(b), xx: 42.2}, a);
  assertEquals({...clone1(b), xx: 42.2}, a);
  assertEquals({...clone2(b), xx: 42.2}, a);
  assertEquals({...clone2(b), xx: 42.2}, a);

  %ClearFunctionFeedback(clone3);
  a2.__proto__ = null;
  assertEquals(clone3(b), a2);
  assertEquals(clone3(b), a2);
  assertEquals(clone3(b).__proto__, undefined);
}

test({});
test({}, false);
test({}, 1.1);
test({}, NaN);
test({}, 2);
test({}, new function(){});
test({}, test);
test({}, {}.__proto__);
test({}, new Proxy({}, function(){}));
test({a: "a"}, new Proxy({a: "a"}, function(){}));
test({}, BigInt(2));
test({}, Symbol("ab"));
test({0: "a", 1: "b"}, "ab");

// non-enumerable
var obj = {a: 1}
Object.defineProperty(obj, 'b', {
  value: 42,
});
test({a: 1}, obj);
assertFalse(%HaveSameMap({...obj},obj));

// some not writable
var obj = {}
Object.defineProperty(obj, 'a', {
  value: 42,
  writable: false,
  enumerable: true
});
obj.b = 1;
test({a: 42, b: 1}, obj);
assertFalse(%HaveSameMap({...obj},obj));

// non-enumerable after non-writable
var obj = {}
Object.defineProperty(obj, 'a', {
  value: 1,
  writable: false,
  enumerable: true,
});
Object.defineProperty(obj, 'b', {
  value: 2,
});
test({a: 1}, obj);
var c = {...obj, a: 4};

test({0:1,1:2}, [1,2]);

var buffer = new ArrayBuffer(24);
var idView = new Uint32Array(buffer, 0, 2);
test({}, buffer);
test({0:0,1:0}, idView);

// with prototypes
{
  __v_0 = Object.create(null);
  __v_1 = Object.create(__v_0);
  test({}, __v_0);
  test({}, __v_1);
  function F0() {}
  const v2 = new F0();
  test({}, v2);
}

// null prototype
{
  function F0() {
      this.b = 4294967297;
  }
  const v3 = new F0();
  const o4 = {
      __proto__: v3,
  };
  const o7 = {
      ...o4,
      __proto__: null,
  };
  const o6 = {
      ...v3,
      __proto__: null,
  };
  assertEquals(o6, {b: 4294967297});
  assertEquals(o7, {});
  test({}, o7);
  test({b: 4294967297}, o6);
}

// Dictionary mode objects
{
  let v0 = "";
  for (let v1 = 0; v1 < 250; v1++) {
      v0 += `this.a${v1} = 0;\n`;
  }
  const v4 = Function(v0);
  const v5 = new v4();
  const o6 = {
     ...v5,
  };
  test(o6, v5);
}

// Null proto with non data props
{
  const v0 = [1];
  const o3 = {
      ...v0,
      get g() {
      },
  };
  const o4 = {
      ...o3,
      __proto__: null,
  };
  test({0: 1, g: undefined}, o4);
}

// Ensure the IC without feedback vector supports the fast-case
(function() {
  var o = {};
  o.x = "1";
  var o2 = {...o};
  assertTrue(%HaveSameMap(o, o2));
})();

// Cloning sealed and frozen objects
(function(){
  function testFrozen1(x) {
    "use strict"
    if (x.x) {
      assertThrows(function() { x.x = 42 }, TypeError);
    }
    if (x[2]) {
      assertThrows(function() { x[2] = 42 }, TypeError);
    }
  }

  function testFrozen2(x) {
    if (x.x) {
      x.x = 42;
      assertFalse(x.x == 42);
    }
    if (x[2]) {
      x[10] = 42;
      assertFalse(x[10] == 42);
    }
  }

  function testUnfrozen(x) {
    x.x = 42;
    assertTrue(x.x == 42);
    x[2] = 42;
    assertTrue(x[2] == 42);
  }

  function testSealed(x) {
    x.asdf = 42;
    assertFalse(x.asdf == 42);
    x[10] = 42;
    assertFalse(x[10] == 42);
  }

  function testUnsealed(x) {
    x.asdf = 42;
    assertTrue(x.asdf == 42);
    x[10] = 42;
    assertTrue(x[10] == 42);
  }

  function testFreeze(x) {
    Object.freeze(x);
    testFrozen1(x);
    testFrozen2(x);
    var y = {...x};
    assertFalse(%HaveSameMap(x,y));
    if (x.__proto__ == Object.prototype) {
      assertEquals(x, y);
    }
    testUnfrozen(y);
    y = Object.assign({}, x);
    if (x.__proto__ == Object.prototype) {
      assertEquals(x, y);
    }
    testUnfrozen(y);
  }

  function testSeal(x) {
    Object.seal(x);
    testSealed(x);
    var y = {...x};
    assertFalse(%HaveSameMap(x,y));
    if (x.__proto__ == Object.prototype) {
      assertEquals(x, y);
    }
    testUnsealed(y);
    y = Object.assign({}, x);
    if (x.__proto__ == Object.prototype) {
      assertEquals(x, y);
    }
    testUnsealed(y);
  }

  function testNonExtend(x) {
    Object.preventExtensions(x);
    testSealed(x);
    var y = {...x};
    assertFalse(%HaveSameMap(x,y));
    if (x.__proto__ == Object.prototype) {
      assertEquals(x, y);
    }
    testUnsealed(y);
    y = Object.assign({}, x);
    if (x.__proto__ == Object.prototype) {
      assertEquals(x, y);
    }
    testUnsealed(y);
  }


  var tests = [testFreeze, testSeal, testNonExtend];

  for (var i = 0; i < 20; ++i) {
    tests.forEach(test => {
      if (i < 10) { %ClearFunctionFeedback(test); }
      var x = {};
      x.x = 3;
      test(x);

      if (i < 10) { %ClearFunctionFeedback(test); }
      x = [];
      x[2]= 3;
      test(x);

      if (i < 10) { %ClearFunctionFeedback(test); }
      x = {};
      x[2]= 3;
      test(x);

      if (i < 10) { %ClearFunctionFeedback(test); }
      var x = {};
      x.x = 3;
      x[10000] = 3
      test(x);
    });
  }
})();

// A case not supported by the clone IC.
(function () {
  function F0() {}
  const v6 = new F0();
  o9 = {
   ...v6,
  };
})();

// A case where the clone IC adds a transition to an existing transition array.
(function () {
  function f1() {}
  function F2(a4) {
    function f5() {}
    a4.toString = f5;
  }
  const v7 = new F2(WeakSet);
  const v8 = new F2(f1);
  new F2(v8);
  const o10 = {
      ...v7,
  };
})();

// A case where we copy from a smaller into a bigger object.
(function() {
  function F0() {
  }
  function F3() {
      const v9 = new F0();
      const o10 = {
          ...v9,
      };
  }
  new F3();
  new F3();
  new F3();
})();
                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/clone-ic-representation.js                                         0000664 0000000 0000000 00000001627 14746647661 0023612 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-lazy-feedback-allocation

// Ensure the clone ic correctly deals with representation change and map
// deprecation.

function Input(a, b) {
  this.a = a;
  this.b = b;
}

var input = new Input(1,1);
var input = new Input(1,1);
var exp = 2;

function ObjectSpread() {
  const result = { ...input, a: input.a };
  if (Object.values(result).reduce((a, b) => a + b) != exp) throw 666;
  return result
}

// Warmup
ObjectSpread()
ObjectSpread()
ObjectSpread()
ObjectSpread()

// Representation change
input = new Input(1,null);
var exp = 1;
ObjectSpread()
ObjectSpread()
ObjectSpread()
ObjectSpread()

// Map deprecation
input = new Input(1,1.4);
exp = 2.4;
ObjectSpread()
ObjectSpread()
ObjectSpread()
ObjectSpread()
                                                                                                         node-23.7.0/deps/v8/test/mjsunit/closure.js                                                         0000664 0000000 0000000 00000003365 14746647661 0020536 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This test is lifted an old bug (ic_context_bug.js).

function f(n) {
  return function () { return n; }
}

for (var i = 0; i < 10; i++) {
  var a = f(i);
  assertEquals(i, a());
}
                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/closures.js                                                        0000664 0000000 0000000 00000003736 14746647661 0020723 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

function runner(f, expected) {
  assertEquals(expected, f.call(this));
}

function test(n) {
  function MyFunction() {
    var result = n * 2 + arguments.length;
    return result;
  };
  %PrepareFunctionForOptimization(MyFunction);
  for (var i = 0; i < 5; ++i) MyFunction();
  %OptimizeFunctionOnNextCall(MyFunction);
  runner(MyFunction, n * 2);
}

test(1);
test(42);
test(239);
                                  node-23.7.0/deps/v8/test/mjsunit/code-comments.js                                                   0000664 0000000 0000000 00000001030 14746647661 0021602 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --code-comments --print-code

(function simple_test() {
  function fib(n) {
    return n < 2 ? n : fib(n - 1) + fib(n - 2);
  }

  // Call a number of times to trigger optimization.
  for (let i = 0; i < 100; ++i) {
    fib(8);
  }
})();

(function test_asm() {
  function asm() {
    'use asm';
    function f() {}
    return f;
  }

  var m = asm();
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/code-coverage-ad-hoc.js                                            0000664 0000000 0000000 00000003022 14746647661 0022704 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-always-turbofan --no-stress-flush-code
// Files: test/mjsunit/code-coverage-utils.js

// Test code coverage without explicitly activating it upfront.

TestCoverageNoGC(
"call simple function twice",
`
function f() {}
f();
f();
`,
[{"start":0,"end":25,"count":1},
 {"start":0,"end":15,"count":1}]
);

TestCoverageNoGC(
"call arrow function twice",
`
var f = () => 1;
f();
f();
`,
[{"start":0,"end":26,"count":1},
 {"start":8,"end":15,"count":1}]
);

TestCoverageNoGC(
"call nested function",
`
function f() {
  function g() {}
  g();
  g();
}
f();
f();
`,
[{"start":0,"end":58,"count":1},
 {"start":0,"end":48,"count":1},
 {"start":17,"end":32,"count":1}]
);

TestCoverageNoGC(
"call recursive function",
`
function fib(x) {
  if (x < 2) return 1;
  return fib(x-1) + fib(x-2);
}
fib(5);
`,
[{"start":0,"end":80,"count":1},
 {"start":0,"end":72,"count":1}]
);

TestCoverageNoGC(
"https://crbug.com/927464",
`
!function f() {                           // 0000
  function unused() { nop(); }            // 0100
  nop();                                  // 0150
}();                                      // 0200
`,
[{"start":0,"end":199,"count":1},
 {"start":1,"end":151,"count":1}
 // The unused function is unfortunately not marked as unused in best-effort
 // code coverage, as the information about its source range is discarded
 // entirely.
]
);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/code-coverage-block-async.js                                       0000664 0000000 0000000 00000016661 14746647661 0023773 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-always-turbofan --no-stress-flush-code
// Flags: --no-stress-incremental-marking
// Flags: --expose-gc
// Files: test/mjsunit/code-coverage-utils.js

(async function () {

  %DebugToggleBlockCoverage(true);

  await TestCoverage(
    "await expressions",
    `
async function f() {                      // 0000
  await 42;                               // 0050
  await 42;                               // 0100
};                                        // 0150
f();                                      // 0200
%PerformMicrotaskCheckpoint();            // 0250
    `,
    [ {"start":0,"end":299,"count":1},
      {"start":0,"end":151,"count":1} ]
  );

  await TestCoverage(
    "for-await-of statements",
    `
!async function() {                       // 0000
  for await (var x of [0,1,2,3]) {        // 0050
    nop();                                // 0100
  }                                       // 0150
}();                                      // 0200
%PerformMicrotaskCheckpoint();            // 0250
    `,
    [ {"start":0,"end":299,"count":1},
      {"start":1,"end":201,"count":1},
      {"start":83,"end":153,"count":4} ]
  );

  await TestCoverage(
    "https://crbug.com/981313",
    `
class Foo {                               // 0000
  async timeout() {                       // 0000
    return new Promise(                   // 0100
        (r) => setTimeout(r, 10));        // 0000
  }                                       // 0200
}                                         // 0000
new Foo().timeout();                      // 0300
    `,
    [ {"start":0,  "end":349, "count":1},
      {"start":52, "end":203, "count":1},
      {"start":158,"end":182, "count":1} ]
  );

  await TestCoverage(
    "test async generator coverage",
    `
class Foo {                               // 0000
  async *timeout() {                      // 0000
    return new Promise(                   // 0100
        (r) => setTimeout(r, 10));        // 0000
  }                                       // 0200
}                                         // 0000
new Foo().timeout();                      // 0300
    `,
    [ {"start":0,  "end":349, "count":1},
      {"start":52, "end":203, "count":1},
      {"start":158,"end":182, "count":0} ]
  );

  await TestCoverage(
    "test async generator coverage with next call",
    `
class Foo {                               // 0000
  async *timeout() {                      // 0000
    return new Promise(                   // 0100
        (r) => setTimeout(r, 10));        // 0000
  }                                       // 0200
}                                         // 0000
new Foo().timeout().next();               // 0300
    `,
    [ {"start":0,  "end":349, "count":1},
      {"start":52, "end":203, "count":1},
      {"start":158,"end":182, "count":1} ]
  );

  await TestCoverage(
    "test two consecutive returns",
    `
class Foo {                               // 0000
  timeout() {                             // 0000
    return new Promise(                   // 0100
        (r) => setTimeout(r, 10));        // 0000
    return new Promise(                   // 0200
        (r) => setTimeout(r, 10));        // 0000
  }                                       // 0300
}                                         // 0000
new Foo().timeout();                      // 0400
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":52,"end":303,"count":1},
      {"start":184,"end":302,"count":0},
      {"start":158,"end":182,"count":1} ]
  );


  await TestCoverage(
    "test async generator with two consecutive returns",
    `
class Foo {                               // 0000
  async *timeout() {                      // 0000
    return new Promise(                   // 0100
        (r) => setTimeout(r, 10));        // 0000
    return new Promise(                   // 0200
        (r) => setTimeout(r, 10));        // 0000
  }                                       // 0300
}                                         // 0000
new Foo().timeout().next();               // 0400
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":52,"end":303,"count":1},
      {"start":184,"end":302,"count":0},
      {"start":158,"end":182,"count":1} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/9952",
    `
async function test(foo) {                // 0000
  return {bar};                           // 0050
                                          // 0100
  function bar() {                        // 0150
    console.log("test");                  // 0200
  }                                       // 0250
}                                         // 0300
test().then(r => r.bar());                // 0350
%PerformMicrotaskCheckpoint();            // 0400
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":0,"end":301,"count":1},
      {"start":152,"end":253,"count":1},
      {"start":362,"end":374,"count":1} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/10628",
    `
async function abc() {                    // 0000
 try {                                    // 0050
  return 'abc';                           // 0100
 } finally {                              // 0150
  console.log('in finally');              // 0200
 }                                        // 0250
}                                         // 0300
abc();                                    // 0350
%PerformMicrotaskCheckpoint();            // 0400
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":0,"end":301,"count":1} ]
  );

  await TestCoverage(
    "try/catch/finally statements async",
    `
!async function() {                       // 0000
  try { nop(); } catch (e) { nop(); }     // 0050
  try { nop(); } finally { nop(); }       // 0100
  try {                                   // 0150
    try { throw 42; } catch (e) { nop(); }// 0200
  } catch (e) { nop(); }                  // 0250
  try {                                   // 0300
    try { throw 42; } finally { nop(); }  // 0350
  } catch (e) { nop(); }                  // 0400
  try {                                   // 0450
    throw 42;                             // 0500
  } catch (e) {                           // 0550
    nop();                                // 0600
  } finally {                             // 0650
    nop();                                // 0700
  }                                       // 0750
}();                                      // 0800
    `,
    [ {"start":0,"end":849,"count":1},
      {"start":1,"end":801,"count":1},
      {"start":67,"end":87,"count":0},
      {"start":254,"end":274,"count":0} ]
  );

  await TestCoverage(
    "try/catch/finally statements with early return async",
    `
!async function() {                       // 0000
  try { throw 42; } catch (e) { return; } // 0050
  nop();                                  // 0100
}();                                      // 0150
!async function() {                       // 0200
  try { throw 42; } catch (e) {}          // 0250
  finally { return; }                     // 0300
  nop();                                  // 0350
}();                                      // 0400
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":1,"end":151,"count":1},
      {"start":91,"end":150,"count":0},
      {"start":201,"end":401,"count":1},
      {"start":321,"end":400,"count":0} ]
  );

  %DebugToggleBlockCoverage(false);

})();
                                                                               node-23.7.0/deps/v8/test/mjsunit/code-coverage-block-noopt.js                                       0000664 0000000 0000000 00000003224 14746647661 0024004 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-always-turbofan --no-stress-flush-code
// Flags: --no-turbofan
// Flags: --expose-gc
// Files: test/mjsunit/code-coverage-utils.js

(async function () {

  %DebugToggleBlockCoverage(true);

  await TestCoverage(
    "optimized and inlined functions",
    `
function g() { if (true) nop(); }         // 0000
function f() { g(); g(); }                // 0050
%PrepareFunctionForOptimization(f);       // 0100
f(); f(); %OptimizeFunctionOnNextCall(f); // 0150
f(); f(); f(); f(); f(); f();             // 0200
    `,
    [ {"start":0,"end":249,"count":1},
      {"start":0,"end":33,"count":16},
      {"start":50,"end":76,"count":8} ]
  );

  // In contrast to the corresponding test in -opt.js, f is not optimized here
  // and therefore reports its invocation count correctly.
  await TestCoverage(
    "Partial coverage collection",
    `
!function() {                             // 0000
  function f(x) {                         // 0050
    if (x) { nop(); } else { nop(); }     // 0100
  }                                       // 0150
  %PrepareFunctionForOptimization(f);     // 0200
  f(true); f(true);                       // 0250
  %OptimizeFunctionOnNextCall(f);         // 0300
  %DebugCollectCoverage();                // 0350
  f(false);                               // 0400
}();                                      // 0450
    `,
    [ {"start":52,"end":153,"count":1},
      {"start":111,"end":121,"count":0} ]
  );


  %DebugToggleBlockCoverage(false);

})();
                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/code-coverage-block-opt.js                                         0000664 0000000 0000000 00000003775 14746647661 0023462 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-always-turbofan --turbofan
// Flags: --no-stress-flush-code --turbo-inlining
// Flags: --expose-gc
// Files: test/mjsunit/code-coverage-utils.js

(async function () {

  if (isNeverOptimizeLiteMode()) {
    print("Warning: skipping test that requires optimization in Lite mode.");
    testRunner.quit(0);
  }

  %DebugToggleBlockCoverage(true);

  await TestCoverage(
    "optimized and inlined functions",
    `
function g() { if (true) nop(); }         // 0000
function f() { g(); g(); }                // 0050
%PrepareFunctionForOptimization(f);       // 0100
f(); f(); %OptimizeFunctionOnNextCall(f); // 0150
f(); f(); f(); f(); f(); f();             // 0200
    `,
    [ {"start":0,"end":249,"count":1},
      {"start":0,"end":33,"count":16},
      {"start":50,"end":76,"count":8} ]
  );

  // This test is tricky: it requires a non-toplevel, optimized function.
  // After initial collection, counts are cleared. Further invocation_counts
  // are not collected for optimized functions, and on the next coverage
  // collection we and up with an uncovered function with an uncovered parent
  // but with non-trivial block coverage.
  await TestCoverage(
    "Partial coverage collection",
    `
!function() {                             // 0000
  function f(x) {                         // 0050
    if (x) { nop(); } else { nop(); }     // 0100
  }                                       // 0150
  %PrepareFunctionForOptimization(f);     // 0200
  f(true); f(true);                       // 0250
  %OptimizeFunctionOnNextCall(f);         // 0300
  %DebugCollectCoverage();                // 0350
  f(false);                               // 0400
}();                                      // 0450
    `,
    [ {"start":52,"end":153,"count":1},
      {"start":111,"end":121,"count":0} ]
  );

  %DebugToggleBlockCoverage(false);

})();
   node-23.7.0/deps/v8/test/mjsunit/code-coverage-block.js                                             0000664 0000000 0000000 00000133660 14746647661 0022657 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-always-turbofan --no-stress-flush-code
// Flags: --expose-gc
// Files: test/mjsunit/code-coverage-utils.js

(async function () {

  %DebugToggleBlockCoverage(true);

  await TestCoverage(
    "call an IIFE",
    `
(function f() {})();
    `,
    [ {"start":0,"end":20,"count":1},
      {"start":1,"end":16,"count":1} ]
  );

  await TestCoverage(
    "call locally allocated function",
    `
let f = () => 1; f();
    `,
    [ {"start":0,"end":21,"count":1},
      {"start":8,"end":15,"count":1} ]
  );

  await TestCoverage(
    "if statements",
    `
function g() {}                           // 0000
function f(x) {                           // 0050
  if (x == 42) {                          // 0100
    if (x == 43) g(); else g();           // 0150
  }                                       // 0200
  if (x == 42) { g(); } else { g(); }     // 0250
  if (x == 42) g(); else g();             // 0300
  if (false) g(); else g();               // 0350
  if (false) g();                         // 0400
  if (true) g(); else g();                // 0450
  if (true) g();                          // 0500
}                                         // 0550
f(42);                                    // 0600
f(43);                                    // 0650
if (true) {                               // 0700
  const foo = 'bar';                      // 0750
} else {                                  // 0800
  const bar = 'foo';                      // 0850
}                                         // 0900
    `,
    [ {"start":0,"end":949,"count":1},
      {"start":801,"end":901,"count":0},
      {"start":0,"end":15,"count":11},
      {"start":50,"end":551,"count":2},
      {"start":115,"end":203,"count":1},
      {"start":167,"end":171,"count":0},
      {"start":265,"end":287,"count":1},
      {"start":315,"end":329,"count":1},
      {"start":363,"end":367,"count":0},
      {"start":413,"end":417,"count":0},
      {"start":466,"end":476,"count":0} ]
  );

  await TestCoverage(
    "if statement (early return)",
    `
!function() {                             // 0000
  if (true) {                             // 0050
    nop();                                // 0100
    return;                               // 0150
    nop();                                // 0200
  }                                       // 0250
  nop();                                  // 0300
}()                                       // 0350
    `,
    [ {"start":0,"end":399,"count":1},
      {"start":1,"end":351,"count":1},
      {"start":161,"end":350,"count":0} ]
  );

  await TestCoverage(
    "if statement (no semi-colon)",
    `
!function() {                             // 0000
  if (true) nop()                         // 0050
  if (true) nop(); else nop()             // 0100
  nop();                                  // 0150
}()                                       // 0200
    `,
    [ {"start":0,"end":249,"count":1},
      {"start":1,"end":201,"count":1},
      {"start":118,"end":129,"count":0} ]
  );

  await TestCoverage(
    "for statements",
    `
function g() {}                           // 0000
!function() {                             // 0050
  for (var i = 0; i < 12; i++) g();       // 0100
  for (var i = 0; i < 12; i++) {          // 0150
    g();                                  // 0200
  }                                       // 0250
  for (var i = 0; false; i++) g();        // 0300
  for (var i = 0; true; i++) break;       // 0350
  for (var i = 0; i < 12; i++) {          // 0400
    if (i % 3 == 0) g(); else g();        // 0450
  }                                       // 0500
}();                                      // 0550
    `,
    [ {"start":0,"end":599,"count":1},
      {"start":0,"end":15,"count":36},
      {"start":51,"end":551,"count":1},
      {"start":131,"end":135,"count":12},
      {"start":181,"end":253,"count":12},
      {"start":330,"end":334,"count":0},
      {"start":431,"end":503,"count":12},
      {"start":470,"end":474,"count":4},
      {"start":474,"end":484,"count":8} ]
  );

  await TestCoverage(
    "for statements pt. 2",
    `
function g() {}                           // 0000
!function() {                             // 0050
  let j = 0;                              // 0100
  for (let i = 0; i < 12; i++) g();       // 0150
  for (const i = 0; j < 12; j++) g();     // 0200
  for (j = 0; j < 12; j++) g();           // 0250
  for (;;) break;                         // 0300
}();                                      // 0350
    `,
    [ {"start":0,"end":399,"count":1},
      {"start":0,"end":15,"count":36},
      {"start":51,"end":351,"count":1},
      {"start":181,"end":185,"count":12},
      {"start":233,"end":237,"count":12},
      {"start":277,"end":281,"count":12} ]
  );

  await TestCoverage(
    "for statements (no semicolon)",
    `
function g() {}                           // 0000
!function() {                             // 0050
  for (let i = 0; i < 12; i++) g()        // 0100
  for (let i = 0; i < 12; i++) break      // 0150
  for (let i = 0; i < 12; i++) break; g() // 0200
}();                                      // 0250
    `,
    [ {"start":0,"end":299,"count":1},
      {"start":0,"end":15,"count":13},
      {"start":51,"end":251,"count":1},
      {"start":131,"end":134,"count":12} ]
  );

  await TestCoverage(
    "for statement (early return)",
    `
!function() {                             // 0000
  for (var i = 0; i < 10; i++) {          // 0050
    nop();                                // 0100
    continue;                             // 0150
    nop();                                // 0200
  }                                       // 0250
  nop();                                  // 0300
  for (;;) {                              // 0350
    nop();                                // 0400
    break;                                // 0450
    nop();                                // 0500
  }                                       // 0550
  nop();                                  // 0600
  for (;;) {                              // 0650
    nop();                                // 0700
    return;                               // 0750
    nop();                                // 0800
  }                                       // 0850
  nop();                                  // 0900
}()                                       // 0950
    `,
    [ {"start":0,"end":999,"count":1},
      {"start":1,"end":951,"count":1},
      {"start":81,"end":253,"count":10},
      {"start":163,"end":253,"count":0},
      {"start":460,"end":553,"count":0},
      {"start":761,"end":950,"count":0} ]
  );

  await TestCoverage(
    "for-of and for-in statements",
    `
!function() {                             // 0000
  var i;                                  // 0050
  for (i of [0,1,2,3]) { nop(); }         // 0100
  for (let j of [0,1,2,3]) { nop(); }     // 0150
  for (i in [0,1,2,3]) { nop(); }         // 0200
  for (let j in [0,1,2,3]) { nop(); }     // 0250
  var xs = [{a:0, b:1}, {a:1,b:0}];       // 0300
  for (var {a: x, b: y} of xs) { nop(); } // 0350
}();                                      // 0400
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":1,"end":401,"count":1},
      {"start":123,"end":133,"count":4},
      {"start":177,"end":187,"count":4},
      {"start":223,"end":233,"count":4},
      {"start":277,"end":287,"count":4},
      {"start":381,"end":391,"count":2} ]
  );

  await TestCoverage(
    "while and do-while statements",
    `
function g() {}                           // 0000
!function() {                             // 0050
  var i;                                  // 0100
  i = 0; while (i < 12) i++;              // 0150
  i = 0; while (i < 12) { g(); i++; }     // 0200
  i = 0; while (false) g();               // 0250
  i = 0; while (true) break;              // 0300
                                          // 0350
  i = 0; do i++; while (i < 12);          // 0400
  i = 0; do { g(); i++; }                 // 0450
         while (i < 12);                  // 0500
  i = 0; do { g(); } while (false);       // 0550
  i = 0; do { break; } while (true);      // 0600
}();                                      // 0650
    `,
    [ {"start":0,"end":699,"count":1},
      {"start":0,"end":15,"count":25},
      {"start":51,"end":651,"count":1},
      {"start":174,"end":178,"count":12},
      {"start":224,"end":237,"count":12},
      {"start":273,"end":277,"count":0},
      {"start":412,"end":416,"count":12},
      {"start":462,"end":475,"count":12} ]
  );

  await TestCoverage(
    "while statement (early return)",
    `
!function() {                             // 0000
  let i = 0;                              // 0050
  while (i < 10) {                        // 0100
    i++;                                  // 0150
    continue;                             // 0200
    nop();                                // 0250
  }                                       // 0300
  nop();                                  // 0350
  while (true) {                          // 0400
    nop();                                // 0450
    break;                                // 0500
    nop();                                // 0550
  }                                       // 0600
  nop();                                  // 0650
  while (true) {                          // 0700
    nop();                                // 0750
    return;                               // 0800
    nop();                                // 0850
  }                                       // 0900
  nop();                                  // 0950
}()                                       // 1000
    `,
    [ {"start":0,"end":1049,"count":1},
      {"start":1,"end":1001,"count":1},
      {"start":117,"end":303,"count":10},
      {"start":213,"end":303,"count":0},
      {"start":510,"end":603,"count":0},
      {"start":811,"end":1000,"count":0} ]
  );

  await TestCoverage(
    "do-while statement (early return)",
    `
!function() {                             // 0000
  let i = 0;                              // 0050
  do {                                    // 0100
    i++;                                  // 0150
    continue;                             // 0200
    nop();                                // 0250
  } while (i < 10);                       // 0300
  nop();                                  // 0350
  do {                                    // 0400
    nop();                                // 0450
    break;                                // 0500
    nop();                                // 0550
  } while (true);                         // 0600
  nop();                                  // 0650
  do {                                    // 0700
    nop();                                // 0750
    return;                               // 0800
    nop();                                // 0850
  } while (true);                         // 0900
  nop();                                  // 0950
}()                                       // 1000
    `,
    [ {"start":0,"end":1049,"count":1},
      {"start":1,"end":1001,"count":1},
      {"start":105,"end":303,"count":10},
      {"start":213,"end":303,"count":0},
      {"start":510,"end":603,"count":0},
      {"start":811,"end":1000,"count":0} ]
  );

  await TestCoverage(
    "return statements",
    `
!function() { nop(); return; nop(); }();  // 0000
!function() { nop(); return 42;           // 0050
              nop(); }();                 // 0100
    `,
    [ {"start":0,"end":149,"count":1},
      {"start":1,"end":37,"count":1},
      {"start":28,"end":36,"count":0},
      {"start":51,"end":122,"count":1},
      {"start":81,"end":121,"count":0} ]
  );

  await TestCoverage(
    "try/catch/finally statements",
    `
!function() {                             // 0000
  try { nop(); } catch (e) { nop(); }     // 0050
  try { nop(); } finally { nop(); }       // 0100
  try {                                   // 0150
    try { throw 42; } catch (e) { nop(); }// 0200
  } catch (e) { nop(); }                  // 0250
  try {                                   // 0300
    try { throw 42; } finally { nop(); }  // 0350
  } catch (e) { nop(); }                  // 0400
  try {                                   // 0450
    throw 42;                             // 0500
  } catch (e) {                           // 0550
    nop();                                // 0600
  } finally {                             // 0650
    nop();                                // 0700
  }                                       // 0750
}();                                      // 0800
    `,
    [ {"start":0,"end":849,"count":1},
      {"start":1,"end":801,"count":1},
      {"start":67,"end":87,"count":0},
      {"start":254,"end":274,"count":0} ]
  );

  await TestCoverage(
    "try/catch/finally statements with early return",
    `
!function() {                             // 0000
  try { throw 42; } catch (e) { return; } // 0050
  nop();                                  // 0100
}();                                      // 0150
!function() {                             // 0200
  try { throw 42; } catch (e) {}          // 0250
  finally { return; }                     // 0300
  nop();                                  // 0350
}();                                      // 0400
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":1,"end":151,"count":1},
      {"start":91,"end":150,"count":0},
      {"start":201,"end":401,"count":1},
      {"start":321,"end":400,"count":0} ]
  );

  await TestCoverage(
    "early return in blocks",
    `
!function() {                             // 0000
  try { throw 42; } catch (e) { return; } // 0050
  nop();                                  // 0100
}();                                      // 0150
!function() {                             // 0200
  try { nop(); } finally { return; }      // 0250
  nop();                                  // 0300
}();                                      // 0350
!function() {                             // 0400
  {                                       // 0450
    let x = 42;                           // 0500
    return () => x;                       // 0550
  }                                       // 0600
  nop();                                  // 0650
}();                                      // 0700
!function() {                             // 0750
  try { throw 42; } catch (e) {           // 0800
    return;                               // 0850
    nop();                                // 0900
  }                                       // 0950
  nop();                                  // 1000
}();                                      // 1050
    `,
    [ {"start":0,"end":1099,"count":1},
      {"start":1,"end":151,"count":1},
      {"start":91,"end":150,"count":0},
      {"start":201,"end":351,"count":1},
      {"start":286,"end":350,"count":0},
      {"start":401,"end":701,"count":1},
      {"start":603,"end":700,"count":0},
      {"start":561,"end":568,"count":0},
      {"start":751,"end":1051,"count":1},
      {"start":861,"end":1050,"count":0} ]
  );

  await TestCoverage(
    "switch statements",
    `
!function() {                             // 0000
  var x = 42;                             // 0050
  switch (x) {                            // 0100
    case 41: nop(); break;                // 0150
    case 42: nop(); break;                // 0200
    default: nop(); break;                // 0250
  }                                       // 0300
}();                                      // 0350
    `,
    [ {"start":0,"end":399,"count":1},
      {"start":1,"end":351,"count":1},
      {"start":154,"end":176,"count":0},
      {"start":254,"end":276,"count":0} ]
  );

  await TestCoverage(
    "labeled break statements",
    `
!function() {                             // 0000
  var x = 42;                             // 0050
  l0: switch (x) {                        // 0100
  case 41: return;                        // 0150
  case 42:                                // 0200
    switch (x) { case 42: break l0; }     // 0250
    break;                                // 0300
  }                                       // 0350
  l1: for (;;) {                          // 0400
    for (;;) break l1;                    // 0450
  }                                       // 0500
  l2: while (true) {                      // 0550
    while (true) break l2;                // 0600
  }                                       // 0650
  l3: do {                                // 0700
    do { break l3; } while (true);        // 0750
  } while (true);                         // 0800
  l4: { break l4; }                       // 0850
  l5: for (;;) for (;;) break l5;         // 0900
}();                                      // 0950
    `,
    [ {"start":0,"end":999,"count":1},
      {"start":1,"end":951,"count":1},
      {"start":152,"end":168,"count":0},
      {"start":287,"end":310,"count":0} ]
  );

  await TestCoverage(
    "labeled continue statements",
    `
!function() {                             // 0000
  l0: for (var i0 = 0; i0 < 2; i0++) {    // 0050
    for (;;) continue l0;                 // 0100
  }                                       // 0150
  var i1 = 0;                             // 0200
  l1: while (i1 < 2) {                    // 0250
    i1++;                                 // 0300
    while (true) continue l1;             // 0350
  }                                       // 0400
  var i2 = 0;                             // 0450
  l2: do {                                // 0500
    i2++;                                 // 0550
    do { continue l2; } while (true);     // 0600
  } while (i2 < 2);                       // 0650
}();                                      // 0700
    `,
    [ {"start":0,"end":749,"count":1},
      {"start":1,"end":701,"count":1},
      {"start":87,"end":153,"count":2},
      {"start":271,"end":403,"count":2},
      {"start":509,"end":653,"count":2} ]
  );

  await TestCoverage(
    "conditional expressions",
    `
var TRUE = true;                          // 0000
var FALSE = false;                        // 0050
!function() {                             // 0100
  TRUE ? nop() : nop();                   // 0150
  true ? nop() : nop();                   // 0200
  false ? nop() : nop();                  // 0250
  FALSE ? TRUE ? nop()                    // 0300
               : nop()                    // 0350
        : nop();                          // 0400
  TRUE ? FALSE ? nop()                    // 0450
               : nop()                    // 0500
       : nop();                           // 0550
  TRUE ? nop() : FALSE ? nop()            // 0600
                       : nop();           // 0650
  FALSE ? nop() : TRUE ? nop()            // 0700
                       : nop();           // 0750
}();                                      // 0800
    `,
    [ {"start":0,"end":849,"count":1},
      {"start":101,"end":801,"count":1},
      {"start":165,"end":172,"count":0},
      {"start":215,"end":222,"count":0},
      {"start":258,"end":265,"count":0},
      {"start":308,"end":372,"count":0},
      {"start":465,"end":472,"count":0},
      {"start":557,"end":564,"count":0},
      {"start":615,"end":680,"count":0},
      {"start":708,"end":715,"count":0},
      {"start":773,"end":780,"count":0} ]
  );

  await TestCoverage(
    "yield expressions",
    `
const it = function*() {                  // 0000
  yield nop();                            // 0050
  yield nop() ? nop() : nop()             // 0100
  return nop();                           // 0150
}();                                      // 0200
it.next(); it.next();                     // 0250
    `,
    [ {"start":0,"end":299,"count":1},
      {"start":11,"end":201,"count":1},
      {"start":114,"end":121,"count":0},
      {"start":129,"end":200,"count":0} ]
  );

  await TestCoverage(
    "yield expressions twice",
    `
function* gen() {                         // 0000
  yield nop();                            // 0050
  yield nop() ? nop() : nop()             // 0100
  return nop();                           // 0150
};                                        // 0200
{const it = gen(); it.next(); it.next();} // 0250
{const it = gen(); it.next(); it.next();} // 0300
    `,
    [ {"start":0,"end":349,"count":1},
      {"start":0,"end":201,"count":2},
      {"start":114,"end":121,"count":0},
      {"start":129,"end":200,"count":0} ]
  );

  await TestCoverage(
    "yield expressions (.return and .throw)",
    `
const it0 = function*() {                 // 0000
  yield 1; yield 2; yield 3;              // 0050
}();                                      // 0100
it0.next(); it0.return();                 // 0150
try {                                     // 0200
  const it1 = function*() {               // 0250
    yield 1; yield 2; yield 3;            // 0300
  }();                                    // 0350
  it1.next(); it1.throw();                // 0400
} catch (e) {}                            // 0450
    `,
    [ {"start":0,"end":499,"count":1},
      {"start":12,"end":101,"count":1},
      {"start":60,"end":100,"count":0},
      {"start":264,"end":353,"count":1},
      {"start":312,"end":352,"count":0} ]
  );

  await TestCoverage(
    "yield expressions (.return and try/catch/finally)",
    `
const it = function*() {                  // 0000
  try {                                   // 0050
    yield 1; yield 2; yield 3;            // 0100
  } catch (e) {                           // 0150
    nop();                                // 0200
  } finally { nop(); }                    // 0250
  yield 4;                                // 0300
}();                                      // 0350
it.next(); it.return();                   // 0450
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":11,"end":351,"count":1},
      {"start":112,"end":254,"count":0},
      {"start":272,"end":350,"count":0} ]
  );

  await TestCoverage(
    "yield expressions (.throw and try/catch/finally)",
    `
const it = function*() {                  // 0000
  try {                                   // 0050
    yield 1; yield 2; yield 3;            // 0100
  } catch (e) {                           // 0150
    nop();                                // 0200
  } finally { nop(); }                    // 0250
  yield 4;                                // 0300
}();                                      // 0350
it.next(); it.throw(42);                  // 0550
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":11,"end":351,"count":1},
      {"start":112,"end":154,"count":0},
      {"start":310,"end":350,"count":0} ]
  );

  await TestCoverage(
    "yield* expressions",
    `
const it = function*() {                  // 0000
  yield* gen();                           // 0050
  yield* nop() ? gen() : gen()            // 0100
  return gen();                           // 0150
}();                                      // 0200
it.next(); it.next(); it.next();          // 0250
it.next(); it.next(); it.next();          // 0300
    `,
    [ {"start":0,"end":349,"count":1},
      {"start":11,"end":201,"count":1},
      {"start":115,"end":122,"count":0},
      {"start":130,"end":200,"count":0} ]
  );

  await TestCoverage(
    "yield* expressions (.return and .throw)",
    `
const it0 = function*() {                 // 0000
  yield* gen(); yield* gen(); yield 3;    // 0050
}();                                      // 0100
it0.next(); it0.return();                 // 0150
try {                                     // 0200
  const it1 = function*() {               // 0250
    yield* gen(); yield* gen(); yield 3;  // 0300
  }();                                    // 0350
  it1.next(); it1.throw();                // 0400
} catch (e) {}                            // 0450
    `,
    [ {"start":0,"end":499,"count":1},
      {"start":12,"end":101,"count":1},
      {"start":65,"end":100,"count":0},
      {"start":264,"end":353,"count":1},
      {"start":317,"end":352,"count":0} ]
  );

  await TestCoverage(
    "LogicalOrExpression assignment",
    `
const a = true || 99                      // 0000
function b () {                           // 0050
  const b = a || 2                        // 0100
}                                         // 0150
b()                                       // 0200
b()                                       // 0250
    `,
    [ {"start":0,"end":299,"count":1},
      {"start":15,"end":20,"count":0},
      {"start":50,"end":151,"count":2},
      {"start":114,"end":118,"count":0} ]
  );

  await TestCoverage(
    "LogicalOrExpression IsTest()",
    `
true || false                             // 0000
const a = 99                              // 0050
a || 50                                   // 0100
const b = false                           // 0150
if (b || true) {}                         // 0200
    `,
    [ {"start":0,"end":249,"count":1},
      {"start":5,"end":13,"count":0},
      {"start":102,"end":107,"count":0} ]
  );

  await TestCoverage(
    "LogicalAndExpression assignment",
    `
const a = false && 99                     // 0000
function b () {                           // 0050
  const b = a && 2                        // 0100
}                                         // 0150
b()                                       // 0200
b()                                       // 0250
const c = true && 50                      // 0300
    `,
    [ {"start":0,"end":349,"count":1},
      {"start":16,"end":21,"count":0},
      {"start":50,"end":151,"count":2},
      {"start":114,"end":118,"count":0} ]
  );

  await TestCoverage(
    "LogicalAndExpression IsTest()",
    `
false && true                             // 0000
const a = 0                               // 0050
a && 50                                   // 0100
const b = true                            // 0150
if (b && true) {}                         // 0200
true && true                              // 0250
    `,
    [ {"start":0,"end":299,"count":1},
      {"start":6,"end":13,"count":0},
      {"start":102,"end":107,"count":0} ]
  );

  await TestCoverage(
    "NaryLogicalOr assignment",
    `
const a = true                            // 0000
const b = false                           // 0050
const c = false || false || 99            // 0100
const d = false || true || 99             // 0150
const e = true || true || 99              // 0200
const f = b || b || 99                    // 0250
const g = b || a || 99                    // 0300
const h = a || a || 99                    // 0350
const i = a || (b || c) || d              // 0400
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":174,"end":179,"count":0},
      {"start":215,"end":222,"count":0},
      {"start":223,"end":228,"count":0},
      {"start":317,"end":322,"count":0},
      {"start":362,"end":366,"count":0},
      {"start":367,"end":372,"count":0},
      {"start":412,"end":423,"count":0},
      {"start":424,"end":428,"count":0} ]
  );

  await TestCoverage(
    "NaryLogicalOr IsTest()",
    `
const a = true                            // 0000
const b = false                           // 0050
false || false || 99                      // 0100
false || true || 99                       // 0150
true || true || 99                        // 0200
b || b || 99                              // 0250
b || a || 99                              // 0300
a || a || 99                              // 0350
    `,
    [ {"start":0,"end":399,"count":1},
      {"start":164,"end":169,"count":0},
      {"start":205,"end":212,"count":0},
      {"start":213,"end":218,"count":0},
      {"start":307,"end":312,"count":0},
      {"start":352,"end":356,"count":0},
      {"start":357,"end":362,"count":0} ]
  );

  await TestCoverage(
    "NaryLogicalAnd assignment",
    `
const a = true                            // 0000
const b = false                           // 0050
const c = false && false && 99            // 0100
const d = false && true && 99             // 0150
const e = true && true && 99              // 0200
const f = true && false || true           // 0250
const g = true || false && true           // 0300
    `,
    [ {"start":0,"end":349,"count":1},
      {"start":116,"end":124,"count":0},
      {"start":125,"end":130,"count":0},
      {"start":166,"end":173,"count":0},
      {"start":174,"end":179,"count":0},
      {"start":315,"end":331,"count":0}
  ]);

  await TestCoverage(
    "NaryLogicalAnd IsTest()",
    `
const a = true                            // 0000
const b = false                           // 0050
false && false && 99                      // 0100
false && true && 99                       // 0150
true && true && 99                        // 0200
true && false || true                     // 0250
true || false && true                     // 0300
false || false || 99 || 55                // 0350
    `,
    [ {"start":0,"end":399,"count":1},
      {"start":106,"end":114,"count":0},
      {"start":115,"end":120,"count":0},
      {"start":156,"end":163,"count":0},
      {"start":164,"end":169,"count":0},
      {"start":305,"end":321,"count":0},
      {"start":371,"end":376,"count":0} ]
  );

  // see regression: https://crbug.com/785778
  await TestCoverage(
    "logical expressions + conditional expressions",
    `
const a = true                            // 0000
const b = 99                              // 0050
const c = false                           // 0100
const d = ''                              // 0150
const e = a && (b ? 'left' : 'right')     // 0200
const f = a || (b ? 'left' : 'right')     // 0250
const g = c || d ? 'left' : 'right'       // 0300
const h = a && b && (b ? 'left' : 'right')// 0350
const i = d || c || (c ? 'left' : 'right')// 0400
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":227,"end":236,"count":0},
      {"start":262,"end":287,"count":0},
      {"start":317,"end":325,"count":0},
      {"start":382,"end":391,"count":0},
      {"start":423,"end":431,"count":0} ]
  );

  await TestCoverage(
    "https://crbug.com/827530",
    `
Util = {};                                // 0000
Util.escape = function UtilEscape(str) {  // 0050
  if (!str) {                             // 0100
    return 'if';                          // 0150
  } else {                                // 0200
    return 'else';                        // 0250
  }                                       // 0300
};                                        // 0350
Util.escape("foo.bar");                   // 0400
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":64,"end":351,"count":1},
      {"start":112,"end":203,"count":0} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/8237",
    `
!function() {                             // 0000
  if (true)                               // 0050
    while (false) return; else nop();     // 0100
}();                                      // 0150
!function() {                             // 0200
  if (true) l0: { break l0; } else        // 0250
    if (nop()) { }                        // 0300
}();                                      // 0350
!function() {                             // 0400
  if (true) { if (false) { return; }      // 0450
  } else if (nop()) { } }();              // 0500
!function(){                              // 0550
  if(true)while(false)return;else nop()   // 0600
}();                                      // 0650
!function(){                              // 0700
  if(true) l0:{break l0}else if (nop()){} // 0750
}();                                      // 0800
!function(){                              // 0850
  if(true){if(false){return}}else         // 0900
    if(nop()){}                           // 0950
}();                                      // 1000
    `,
    [ {"start":0,"end":1049,"count":1},
      {"start":1,"end":151,"count":1},
      {"start":118,"end":137,"count":0},
      {"start":201,"end":351,"count":1},
      {"start":279,"end":318,"count":0},
      {"start":401,"end":525,"count":1},
      {"start":475,"end":486,"count":0},
      {"start":503,"end":523,"count":0},
      {"start":551,"end":651,"count":1},
      {"start":622,"end":639,"count":0},
      {"start":701,"end":801,"count":1},
      {"start":774,"end":791,"count":0},
      {"start":851,"end":1001,"count":1},
      {"start":920,"end":928,"count":0},
      {"start":929,"end":965,"count":0} ]
  );

  await TestCoverage(
    "terminal break statement",
    `
while (true) {                            // 0000
  const b = false                         // 0050
  break                                   // 0100
}                                         // 0150
let stop = false                          // 0200
while (true) {                            // 0250
  if (stop) {                             // 0300
    break                                 // 0350
  }                                       // 0400
  stop = true                             // 0450
}                                         // 0500
    `,
    [ {"start":0,"end":549,"count":1},
      {"start":263,"end":501,"count":2},
      {"start":312,"end":501,"count":1} ]
  );

  await TestCoverage(
    "terminal return statement",
    `
function a () {                           // 0000
  const b = false                         // 0050
  return 1                                // 0100
}                                         // 0150
const b = (early) => {                    // 0200
  if (early) {                            // 0250
    return 2                              // 0300
  }                                       // 0350
  return 3                                // 0400
}                                         // 0450
const c = () => {                         // 0500
  if (true) {                             // 0550
    return                                // 0600
  }                                       // 0650
}                                         // 0700
a(); b(false); b(true); c()               // 0750
    `,
    [ {"start":0,"end":799,"count":1},
      {"start":0,"end":151,"count":1},
      {"start":210,"end":451,"count":2},
      {"start":263,"end":450,"count":1},
      {"start":510,"end":701,"count":1} ]
  );

  await TestCoverage(
    "terminal blocks",
    `
function a () {                           // 0000
  {                                       // 0050
    return 'a'                            // 0100
  }                                       // 0150
}                                         // 0200
function b () {                           // 0250
  {                                       // 0300
    {                                     // 0350
      return 'b'                          // 0400
    }                                     // 0450
  }                                       // 0500
}                                         // 0550
a(); b()                                  // 0600
    `,
    [ {"start":0,"end":649,"count":1},
      {"start":0,"end":201,"count":1},
      {"start":250,"end":551,"count":1} ]
  );

  await TestCoverage(
    "terminal if statements",
    `
function a (branch) {                     // 0000
  if (branch) {                           // 0050
    return 'a'                            // 0100
  } else {                                // 0150
    return 'b'                            // 0200
  }                                       // 0250
}                                         // 0300
function b (branch) {                     // 0350
  if (branch) {                           // 0400
    if (branch) {                         // 0450
      return 'c'                          // 0500
    }                                     // 0550
  }                                       // 0600
}                                         // 0650
function c (branch) {                     // 0700
  if (branch) {                           // 0750
    return 'c'                            // 0800
  } else {                                // 0850
    return 'd'                            // 0900
  }                                       // 0950
}                                         // 1000
function d (branch) {                     // 1050
  if (branch) {                           // 1100
    if (!branch) {                        // 1150
      return 'e'                          // 1200
    } else {                              // 1250
      return 'f'                          // 1300
    }                                     // 1350
  } else {                                // 1400
    // noop                               // 1450
  }                                       // 1500
}                                         // 1550
a(true); a(false); b(true); b(false)      // 1600
c(true); d(true);                         // 1650
    `,
    [ {"start":0,"end":1699,"count":1},
      {"start":0,"end":301,"count":2},
      {"start":64,"end":253,"count":1},
      {"start":350,"end":651,"count":2},
      {"start":414,"end":603,"count":1},
      {"start":700,"end":1001,"count":1},
      {"start":853,"end":953,"count":0},
      {"start":1050,"end":1551,"count":1},
      {"start":1167,"end":1255,"count":0},
      {"start":1403,"end":1503,"count":0} ]
  );

  await TestCoverage(
    "https://crbug.com/927464",
    `
!function f() {                           // 0000
  function unused() { nop(); }            // 0050
  nop();                                  // 0100
}();                                      // 0150
    `,
    [ {"start":0,"end":199,"count":1},
      {"start":1,"end":151,"count":1},
      {"start":52,"end":80,"count":0} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/8691",
    `
function f(shouldThrow) {                 // 0000
  if (shouldThrow) {                      // 0050
    throw Error('threw')                  // 0100
  }                                       // 0150
}                                         // 0200
try {                                     // 0250
  f(true)                                 // 0300
} catch (err) {                           // 0350
                                          // 0400
}                                         // 0450
try {                                     // 0500
  f(false)                                // 0550
} catch (err) {}                          // 0600
    `,
    [ {"start":0,"end":649,"count":1},
      {"start":602,"end":616,"count":0},
      {"start":0,"end":201,"count":2},
      {"start":69,"end":153,"count":1} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/9705",
    `
function f(x) {                           // 0000
  switch (x) {                            // 0050
    case 40: nop();                       // 0100
    case 41: nop(); return 1;             // 0150
    case 42: nop(); break;                // 0200
  }                                       // 0250
  return 3;                               // 0300
};                                        // 0350
f(40);                                    // 0400
f(41);                                    // 0450
f(42);                                    // 0500
f(43);                                    // 0550
    `,
    [ {"start":0,"end":599,"count":1},
      {"start":0,"end":351,"count":4},
      {"start":104,"end":119,"count":1},
      {"start":154,"end":179,"count":2},
      {"start":204,"end":226,"count":1},
      {"start":253,"end":350,"count":2} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/9705",
    `
function f(x) {                           // 0000
  switch (x) {                            // 0050
    case 40: nop();                       // 0100
    case 41: nop(); return 1;             // 0150
    case 42: nop(); break;                // 0200
  }                                       // 0250
  return 3;                               // 0300
};                                        // 0350
f(42);                                    // 0400
f(43);                                    // 0450
    `,
    [ {"start":0,"end":499,"count":1},
      {"start":0,"end":351,"count":2},
      {"start":104,"end":119,"count":0},
      {"start":154,"end":179,"count":0},
      {"start":204,"end":226,"count":1} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/9857",
    `function foo() {}`,
    [ {"start":0,"end":17,"count":1},
      {"start":0,"end":17,"count":0} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/9857",
    `function foo() {function bar() {}}; foo()`,
    [ {"start":0,"end":41,"count":1},
      {"start":0,"end":34,"count":1},
      {"start":16,"end":33,"count":0} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/9952",
    `
function test(foo = "foodef") {           // 0000
  return {bar};                           // 0050
                                          // 0100
  function bar() {                        // 0150
    console.log("test");                  // 0200
  }                                       // 0250
}                                         // 0300
test().bar();                             // 0350
    `,
    [ {"start":0,"end":399,"count":1},
      {"start":0,"end":301,"count":1},
      {"start":152,"end":253,"count":1} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/9952",
    `
function test(foo = (()=>{})) {           // 0000
  return {foo};                           // 0050
}                                         // 0100
                                          // 0150
test(()=>{}).foo();                       // 0200
    `,
    [ {"start":0,"end":249,"count":1},
      {"start":0,"end":101,"count":1},
      {"start":21,"end":27,"count":0},
      {"start":205,"end":211,"count":1} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/10030 - original",
    `
function a (shouldThrow) {                // 0000
  try {                                   // 0050
    if (shouldThrow)                      // 0100
      throw Error('I threw!');            // 0150
    return 'I ran';                       // 0200
  } catch(e) {                            // 0250
    console.info('caught');               // 0300
  }                                       // 0350
}                                         // 0400
a(false);                                 // 0450
a(true);                                  // 0500
    `,
    [ {"start":0,"end":549,"count":1},
      {"start":0,"end":401,"count":2},
      {"start":156,"end":353,"count":1} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/10030 - only throw",
    `
function a (shouldThrow) {                // 0000
  try {                                   // 0050
    if (shouldThrow)                      // 0100
      throw Error('I threw!');            // 0150
    return 'I ran';                       // 0200
  } catch(e) {                            // 0250
    console.info('caught');               // 0300
  }                                       // 0350
}                                         // 0400
a(true);                                  // 0450
    `,
    [ {"start":0,"end":499,"count":1},
      {"start":0,"end":401,"count":1},
      {"start":180,"end":254,"count":0} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/10030 - finally",
    `
function a (shouldThrow) {                // 0000
  try {                                   // 0050
    return 'I ran';                       // 0100
  } finally {                             // 0150
    console.info('finally');              // 0200
  }                                       // 0250
}                                         // 0300
a(false);                                 // 0350
a(true);                                  // 0400
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":0,"end":301,"count":2} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/10030 - catch & finally",
    `
function a (shouldThrow) {                // 0000
  try {                                   // 0050
    return 'I ran';                       // 0100
  } catch (e) {                           // 0150
    console.info('caught');               // 0200
  } finally {                             // 0250
    console.info('finally');              // 0300
  }                                       // 0350
}                                         // 0400
a(false);                                 // 0450
a(true);                                  // 0500
    `,
    [ {"start":0,"end":549,"count":1},
    {"start":0,"end":401,"count":2},
    {"start":154,"end":254,"count":0} ]
  );

  await TestCoverage(
    "https://crbug.com/v8/11231 - nullish coalescing",
    `
const a = true                            // 0000
const b = false                           // 0050
const c = undefined                       // 0100
const d = a ?? 99                         // 0150
const e = 33                              // 0200
const f = b ?? (c ?? 99)                  // 0250
const g = 33                              // 0300
const h = c ?? (c ?? 'hello')             // 0350
const i = c ?? b ?? 'hello'               // 0400
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":162,"end":167,"count":0},
      {"start":262,"end":274,"count":0},
      {"start":417,"end":427,"count":0} ]
  );

  await TestCoverage(
    "Optional Chaining",
    `
const a = undefined || null               // 0000
const b = a?.b                            // 0050
const c = a?.['b']                        // 0100
const d = {                               // 0150
  e: {f: 99, g: () => {return undefined}} // 0200
}                                         // 0250
const e = d?.e?.f                         // 0300
const f = d?.e?.['f']                     // 0350
const g = d?.e?.f?.g                      // 0400
const h = d?.e?.f?.g?.h                   // 0450
const i = d?.['d']?.['e']?.['h']          // 0500
const k = a?.('b')                        // 0550
const l = d?.e?.g?.()                     // 0600
const m = d?.e?.g?.()?.a?.b               // 0650
delete a?.b                               // 0700
const n = d?.[d?.x?.f]                    // 0750
if (a?.[d?.x?.f]) { const p = 99 } else {}// 0800
const p = d?.[d?.x?.f]?.x                 // 0850
    `,
    [ {"start":0,"end":899,"count":1},
      {"start":61,"end":64,"count":0},
      {"start":111,"end":118,"count":0},
      {"start":470,"end":473,"count":0},
      {"start":518,"end":532,"count":0},
      {"start":561,"end":568,"count":0},
      {"start":671,"end":677,"count":0},
      {"start":708,"end":711,"count":0},
      {"start":768,"end":771,"count":0},
      {"start":805,"end":816,"count":0},
      {"start":818,"end":834,"count":0},
      {"start":868,"end":871,"count":0},
      {"start":872,"end":875,"count":0},
      {"start":216,"end":240,"count":2} ]
  );

  %DebugToggleBlockCoverage(false);

})();
                                                                                node-23.7.0/deps/v8/test/mjsunit/code-coverage-class-fields.js                                      0000664 0000000 0000000 00000012630 14746647661 0024127 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-always-turbofan --no-stress-flush-code
// Flags: --expose-gc
// Files: test/mjsunit/code-coverage-utils.js

(async function () {

  %DebugToggleBlockCoverage(true);

  await TestCoverage(
    "class with no fields",
    `
class X {                                  // 000
};                                         // 050
    `,
    [ {"start":0,"end":99,"count":1} ]
  );

  await TestCoverage(
    "class that's not created",
    `
class X {                                  // 000
  x = function() { }                       // 050
};                                         // 100
    `,
    [ {"start":0,"end":149,"count":1},
      {"start":52,"end":70,"count":0} ]
  );

  await TestCoverage(
    "class with field thats not called",
    `
class X {                                  // 000
  x = function() { }                       // 050
};                                         // 100
let x = new X();                           // 150
    `,
    [ {"start":0,"end":199,"count":1},
      {"start":52,"end":70,"count":1},
      {"start":56,"end":70,"count":0} ]
  );

  await TestCoverage(
    "class field",
    `
class X {                                  // 000
  x = function() { }                       // 050
};                                         // 100
let x = new X();                           // 150
x.x();                                     // 200
    `,
    [ {"start":0,"end":249,"count":1},
      {"start":52,"end":70,"count":1},
      {"start":56,"end":70,"count":1} ]
  );

  await TestCoverage(
    "non contiguous class field",
    `
class X {                                  // 000
  x = function() { }                       // 050
  foo() { }                                // 100
  y = function() {}                        // 150
};                                         // 200
let x = new X();                           // 250
x.x();                                     // 300
x.y();                                     // 350
    `,
    [ {"start":0,"end":399,"count":1},
      {"start":52,"end":169,"count":1},
      {"start":56,"end":70,"count":1},
      {"start":102,"end":111,"count":0},
      {"start":156,"end":169,"count":1} ]
  );

  await TestCoverage(
    "non contiguous class field thats called",
    `
class X {                                  // 000
  x = function() { }                       // 050
  foo() { }                                // 100
  y = function() {}                        // 150
};                                         // 200
let x = new X();                           // 250
x.x();                                     // 300
x.y();                                     // 350
x.foo();                                   // 400
    `,
    [ {"start":0,"end":449,"count":1},
      {"start":52,"end":169,"count":1},
      {"start":56,"end":70,"count":1},
      {"start":102,"end":111,"count":1},
      {"start":156,"end":169,"count":1} ]
  );

  await TestCoverage(
    "class with initializer iife",
    `
class X {                                  // 000
  x = (function() { })()                   // 050
};                                         // 100
let x = new X();                           // 150
    `,
    [ {"start":0,"end":199,"count":1},
      {"start":52,"end":74,"count":1},
      {"start":57,"end":71,"count":1} ]
  );

  await TestCoverage(
    "class with computed field",
    `
function f() {};                           // 000
class X {                                  // 050
  [f()] = (function() { })()               // 100
};                                         // 150
let x = new X();                           // 200
    `,
    [ {"start":0,"end":249,"count":1},
      {"start":0,"end":15,"count":1},
      {"start":102,"end":128,"count":1},
      {"start":111,"end":125,"count":1} ]
  );

  await TestCoverage(
    "static class field that's not called",
    `
class X {                                  // 000
  static x = function() { }                // 050
};                                         // 100
    `,
    [ {"start":0,"end":149,"count":1},
      {"start":52,"end":77,"count":1},
      {"start":63,"end":77,"count":0} ]
  );

  await TestCoverage(
    "static class field",
    `
class X {                                  // 000
  static x = function() { }                // 050
};                                         // 100
X.x();                                     // 150
    `,
    [ {"start":0,"end":199,"count":1},
      {"start":52,"end":77,"count":1},
      {"start":63,"end":77,"count":1} ]
  );

  await TestCoverage(
    "static class field with iife",
    `
class X {                                  // 000
  static x = (function() { })()            // 050
};                                         // 100
    `,
    [ {"start":0,"end":149,"count":1},
      {"start":52,"end":81,"count":1},
      {"start":64,"end":78,"count":1} ]
  );

  await TestCoverage(
    "computed static class field",
    `
function f() {}                            // 000
class X {                                  // 050
  static [f()] = (function() { })()        // 100
};                                         // 150
    `,
    [ {"start":0,"end":199,"count":1},
      {"start":0,"end":15,"count":1},
      {"start":102,"end":135,"count":1},
      {"start":118,"end":132,"count":1} ]
  );

})();
                                                                                                        node-23.7.0/deps/v8/test/mjsunit/code-coverage-precise.js                                           0000664 0000000 0000000 00000003231 14746647661 0023205 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-always-turbofan --no-stress-flush-code
// Flags: --no-stress-incremental-marking
// Flags: --expose-gc
// Files: test/mjsunit/code-coverage-utils.js

// Test precise code coverage.

(async function () {

  // Without precise coverage enabled, we lose coverage data to the GC.
  await TestCoverage(
    "call an IIFE",
    `
(function f() {})();
    `,
    undefined  // The IIFE has been garbage-collected.
  );

  await TestCoverage(
    "call locally allocated function",
    `
for (var i = 0; i < 10; i++) {
  let f = () => 1;
  i += f();
}
    `,
    undefined
  );

  // This does not happen with precise coverage enabled.
  %DebugTogglePreciseCoverage(true);

  await TestCoverage(
    "call an IIFE",
    `
(function f() {})();
    `,
    [ {"start":0,"end":20,"count":1},
      {"start":1,"end":16,"count":1} ]
  );

  await TestCoverage(
    "call locally allocated function",
    `
for (var i = 0; i < 10; i++) {
  let f = () => 1;
  i += f();
}
    `,
    [ {"start":0,"end":63,"count":1},
      {"start":41,"end":48,"count":5} ]
  );

  await TestCoverage(
    "https://crbug.com/927464",
    `
!function f() {                           // 0000
  function unused() { nop(); }            // 0100
  nop();                                  // 0150
}();                                      // 0200
    `,
    [ {"start":0,"end":199,"count":1},
      {"start":1,"end":151,"count":1},
      {"start":52,"end":80,"count":0} ]
  );

  %DebugTogglePreciseCoverage(false);

})();
                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/code-coverage-utils.js                                             0000664 0000000 0000000 00000004454 14746647661 0022723 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax
// Flags: --expose-gc

let TestCoverage;
let TestCoverageNoGC;

let nop;
let gen;

!function() {
  function GetCoverage(source) {
    for (var script of %DebugCollectCoverage()) {
      if (script.script === source) return script;
    }
    return undefined;
  };

  async function TestCoverageInternal(
      name, source, expectation, collect_garbage, prettyPrintResults) {
    source = source.trim();
    eval(source);
    // We need to invoke GC asynchronously, so that it doesn't need to scan
    // the stack. Otherwise, some objects may not be reclaimed because of
    // conservative stack scanning and the tests may fail.
    if (collect_garbage) await gc({ type: 'major', execution: 'async' });
    var covfefe = GetCoverage(source);
    var stringified_result = JSON.stringify(covfefe);
    var stringified_expectation = JSON.stringify(expectation);
    const mismatch = stringified_result != stringified_expectation;
    if (mismatch) {
      console.log(stringified_result.replace(/[}],[{]/g, "},\n {"));
    }
    if (prettyPrintResults) {
      console.log("=== Coverage Expectation ===")
      for (const {start,end,count} of expectation) {
        console.log(`Range [${start}, ${end}) (count: ${count})`);
        console.log(source.substring(start, end));
      }
      console.log("=== Coverage Results ===")
      for (const {start,end,count} of covfefe) {
        console.log(`Range [${start}, ${end}) (count: ${count})`);
        console.log(source.substring(start, end));
      }
      console.log("========================")
    }
    assertEquals(stringified_expectation, stringified_result, name + " failed");
  };

  TestCoverage = async function(name, source, expectation, prettyPrintResults) {
    return TestCoverageInternal(name, source, expectation, true,
                                prettyPrintResults);
  };

  TestCoverageNoGC = function(name, source, expectation, prettyPrintResults) {
    return TestCoverageInternal(name, source, expectation, false,
                                prettyPrintResults);
  };

  nop = function() {};

  gen = function*() {
    yield 1;
    yield 2;
    yield 3;
  };
}();
                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/code-stats-flag.js                                                 0000664 0000000 0000000 00000000324 14746647661 0022027 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Flags: --expose-gc --code-stats

gc();
                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/codegen-coverage.js                                                0000664 0000000 0000000 00000010506 14746647661 0022252 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test paths in the code generator where values in specific registers
// get moved around.
function identity(x) {
  return x;
}

function lookup(w, a) {
  // This function tests a code path in the generation of a keyed load IC
  // where the key and the value are both in the same register.
  a = a;
  w[a] = a;
}

function cover_codegen_paths() {
  var x = 1;

  // This test depends on the fixed order of register allocation.  We try to
  // get values in specific registers (ia32, x64):
  var a;   // Register eax, rax.
  var b;   // Register ebx, rbx.
  var c;   // Register ecx, rcx.
  var d;   // Register edx, rdx.
  var di;  // Register edi, rdi.

  while (x == 1) {
    // The call will spill registers and leave x in {eax,rax}.
    x = identity(1);
    // The add will spill x and reuse {eax,rax} for the result.
    a = x + 1;
    // A fresh register {ebx,rbx} will be allocated for x, then reused for
    // the result.
    b = x + 1;
    // Et cetera.
    c = x + 1;
    d = x + 1;
    di = x + 1;
    // Locals are in the corresponding registers here.
    assertEquals(8, c << a);

    x = identity(1);
    a = x + 1;
    b = x + 1;
    c = x + 1;
    d = x + 1;
    di = x + 1;
    assertEquals(8, a << c);

    x = identity(1);
    a = x + 1;
    b = x + 1;
    c = x + 1;
    d = x + 1;
    di = x + 1;
    c = 0; // Free register ecx.
    assertEquals(8, a << d);

    x = identity(1);
    a = x + 1;
    b = x + 1;
    c = x + 1;
    d = x + 1;
    di = x + 1;
    b = 0; // Free register ebx.
    assertEquals(8, a << d);

    // Test the non-commutative subtraction operation with a smi on the
    // left, all available registers on the right, and a non-smi result.
    x = identity(-1073741824);  // Least (31-bit) smi.
    a = x + 1;  // Still a smi, the greatest smi negated.
    b = x + 1;
    c = x + 1;
    d = x + 1;
    di = x + 1;
    // Subtraction should overflow the 31-bit smi range.  The result
    // (1073741824) is outside the 31-bit smi range so it doesn't hit the
    // "unsafe smi" code that spills a register.
    assertEquals(1073741824, 1 - a);

    x = identity(-1073741824);
    a = x + 1;
    b = x + 1;
    c = x + 1;
    d = x + 1;
    di = x + 1;
    assertEquals(1073741824, 1 - b);

    x = identity(-1073741824);
    a = x + 1;
    b = x + 1;
    c = x + 1;
    d = x + 1;
    di = x + 1;
    assertEquals(1073741824, 1 - c);

    x = identity(-1073741824);
    a = x + 1;
    b = x + 1;
    c = x + 1;
    d = x + 1;
    di = x + 1;
    assertEquals(1073741824, 1 - d);

    x = identity(-1073741824);
    a = x + 1;
    b = x + 1;
    c = x + 1;
    d = x + 1;
    di = x + 1;
    assertEquals(1073741824, 1 - di);

    x = 3;
    var w = { };
    lookup(w, x);
    lookup(w, x);
    lookup(w, x);

    x = 3;  // Terminate while loop.
  }
}

cover_codegen_paths();
                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/compare-character.js                                               0000664 0000000 0000000 00000004550 14746647661 0022437 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test the optimized implementation of comparison with single-character
// strings.

var a = ['', String.fromCharCode(0), ' ', 'e', 'erik', 'f', 'foo', 'g', 'goo',
         -1, 0, 1, 1.2, -7.9, true, false, 'foo', '0', 'NaN' ];
for (var i in a) {
  var x = a[i];
  var f = 'f';

  assertEquals(x == f, x == 'f', "==" + x);
  assertEquals(x === f, x === 'f', "===" + x);
  assertEquals(x < f, x < 'f', "<" + x);
  assertEquals(x <= f, x <= 'f', "<=" + x);
  assertEquals(x > f, x > 'f', ">" + x);
  assertEquals(x >= f, x >= 'f', ">=" + x);
  assertEquals(f == x, 'f' == x, "==r" + x);
  assertEquals(f === x, 'f' === x, "===r" + x);
  assertEquals(f > x, 'f' > x, "<r" + x);
  assertEquals(f >= x, 'f' >= x, "<=r" + x);
  assertEquals(f < x, 'f' < x, ">r" + x);
  assertEquals(f <= x, 'f' <= x, ">=r" + x);
}
                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/compare-known-objects-slow.js                                      0000664 0000000 0000000 00000006521 14746647661 0024250 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

// Test CompareIC stubs for normal and strict equality comparison of known
// objects in slow mode. These objects share the same map even though they
// might have completely different properties.

function eq(a, b) {
  return a == b;
}

function eq_strict(a, b) {
  return a === b;
}

function le(a, b) {
  return a <= b;
}

function lt(a, b) {
  return a < b;
}

function ge(a, b) {
  return a >= b;
}

function gt(a, b) {
  return a > b;
}

function test(a, b) {
  // Check CompareIC for equality of known objects.
  assertTrue(eq(a, a));
  assertTrue(eq(b, b));
  assertFalse(eq(a, b));
  // Check CompareIC for strict equality of known objects.
  assertTrue(eq_strict(a, a));
  assertTrue(eq_strict(b, b));
  assertFalse(eq_strict(a, b));
  // Check CompareIC for less than or equal of known objects.
  assertTrue(le(a, a));
  assertTrue(le(a, b));
  assertTrue(le(b, a));
  // Check CompareIC for less than of known objects.
  assertFalse(lt(a, a));
  assertFalse(lt(a, b));
  assertFalse(lt(b, a));
  // Check CompareIC for greater than or equal of known objects.
  assertTrue(ge(a, a));
  assertTrue(ge(a, b));
  assertTrue(ge(b, a));
  // Check CompareIC for greater than of known objects.
  assertFalse(gt(a, a));
  assertFalse(gt(a, b));
  assertFalse(gt(b, a));
}

// Prepare two objects in slow mode that have the same map.
var obj1 = %OptimizeObjectForAddingMultipleProperties({}, 1);
var obj2 = %OptimizeObjectForAddingMultipleProperties({}, 1);

// Test original objects.
assertTrue(%HaveSameMap(obj1, obj2));
test(obj1, obj2);

// Test after adding property to first object.
obj1.x = 1;
assertTrue(%HaveSameMap(obj1, obj2));
test(obj1, obj2);

// Test after adding property to second object.
obj2.y = 2;
assertTrue(%HaveSameMap(obj1, obj2));
test(obj1, obj2);
                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/compare-known-objects-tostringtag.js                               0000664 0000000 0000000 00000003135 14746647661 0025627 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

function le(a, b) {
  return a <= b;
}

function lt(a, b) {
  return a < b;
}

function ge(a, b) {
  return a >= b;
}

function gt(a, b) {
  return a > b;
}

function test(a, b) {
  // Check CompareIC for less than or equal of known objects.
  assertThrows(function() {le(a, a)});
  assertThrows(function() {le(a, b)});
  assertThrows(function() {le(b, a)});
  // Check CompareIC for less than of known objects.
  assertThrows(function() {lt(a, a)});
  assertThrows(function() {lt(a, b)});
  assertThrows(function() {lt(b, a)});
  // Check CompareIC for greater than or equal of known objects.
  assertThrows(function() {ge(a, a)});
  assertThrows(function() {ge(a, b)});
  assertThrows(function() {ge(b, a)});
  // Check CompareIC for greater than of known objects.
  assertThrows(function() {gt(a, a)});
  assertThrows(function() {gt(a, b)});
  assertThrows(function() {gt(b, a)});
}

function O() { }
Object.defineProperty(O.prototype, Symbol.toStringTag, {
  get: function() { throw "@@toStringTag called!" }
});

var obj1 = new O;
var obj2 = new O;

%PrepareFunctionForOptimization(le);
%PrepareFunctionForOptimization(lt);
%PrepareFunctionForOptimization(ge);
%PrepareFunctionForOptimization(gt);
assertTrue(%HaveSameMap(obj1, obj2));
test(obj1, obj2);
test(obj1, obj2);
%OptimizeFunctionOnNextCall(le);
%OptimizeFunctionOnNextCall(lt);
%OptimizeFunctionOnNextCall(ge);
%OptimizeFunctionOnNextCall(gt);
test(obj1, obj2);
                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/compare-known-objects.js                                           0000664 0000000 0000000 00000006121 14746647661 0023262 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

// Test CompareIC stubs for normal and strict equality comparison of known
// objects in slow mode. These objects share the same map even though they
// might have completely different properties.

function eq(a, b) {
  return a == b;
}

function eq_strict(a, b) {
  return a === b;
}

function le(a, b) {
  return a <= b;
}

function lt(a, b) {
  return a < b;
}

function ge(a, b) {
  return a >= b;
}

function gt(a, b) {
  return a > b;
}

function test(a, b) {
  // Check CompareIC for equality of known objects.
  assertTrue(eq(a, a));
  assertTrue(eq(b, b));
  assertFalse(eq(a, b));
  // Check CompareIC for strict equality of known objects.
  assertTrue(eq_strict(a, a));
  assertTrue(eq_strict(b, b));
  assertFalse(eq_strict(a, b));
  // Check CompareIC for less than or equal of known objects.
  assertTrue(le(a, a));
  assertTrue(le(a, b));
  assertTrue(le(b, a));
  // Check CompareIC for less than of known objects.
  assertFalse(lt(a, a));
  assertFalse(lt(a, b));
  assertFalse(lt(b, a));
  // Check CompareIC for greater than or equal of known objects.
  assertTrue(ge(a, a));
  assertTrue(ge(a, b));
  assertTrue(ge(b, a));
  // Check CompareIC for greater than of known objects.
  assertFalse(gt(a, a));
  assertFalse(gt(a, b));
  assertFalse(gt(b, a));
}

function O(){};
O.prototype.t = function() {}

var obj1 = new O;
var obj2 = new O;

// Test original objects.
assertTrue(%HaveSameMap(obj1, obj2));
test(obj1, obj2);

// Test after adding property to first object.
obj1.x = 1;
test(obj1, obj2);
                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/compare-nan.js                                                     0000664 0000000 0000000 00000006200 14746647661 0021251 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var a = [NaN, -1, 0, 1, 1.2, -7.9, true, false, 'foo', '0', 'NaN' ];
for (var i in a) {
  var x = a[i];
  assertFalse(NaN == x, "NaN == " + x);
  assertFalse(NaN === x, "NaN === " + x);
  assertFalse(NaN < x, "NaN < " + x);
  assertFalse(NaN > x, "NaN > " + x);
  assertFalse(NaN <= x, "NaN <= " + x);
  assertFalse(NaN >= x, "NaN >= " + x);

  assertFalse(x == NaN, "" + x + " == NaN");
  assertFalse(x === NaN, "" + x + " === NaN");
  assertFalse(x < NaN, "" + x + " < NaN");
  assertFalse(x > NaN, "" + x + " > NaN");
  assertFalse(x <= NaN, "" + x + " <= NaN");
  assertFalse(x >= NaN, "" + x + " >= NaN");
}

var b = ["NaN", "-1", "0", "1", "1.2", "-7.9", "true", "false", "'foo'", "'0'",
         "'NaN'" ];
for (var i in b) {
  var x = b[i];
  var program =
      "assertFalse(NaN == " + x + ", 'NaN == ' + " + x + ");\n" +
      "assertFalse(NaN === " + x + ", 'NaN === ' + " + x + ");\n" +
      "assertFalse(NaN < " + x + ", 'NaN < ' + " + x + ");\n" +
      "assertFalse(NaN > " + x + ", 'NaN > ' + " + x + ");\n" +
      "assertFalse(NaN <= " + x + ", 'NaN <= ' + " + x + ");\n" +
      "assertFalse(NaN >= " + x + ", 'NaN >= ' + " + x + ");\n" +

      "assertFalse(" + x + " == NaN, '' + " + x + " + ' == NaN');\n" +
      "assertFalse(" + x + " === NaN, '' + " + x + " + ' === NaN');\n" +
      "assertFalse(" + x + " < NaN, '' + " + x + " + ' < NaN');\n" +
      "assertFalse(" + x + " > NaN, '' + " + x + " + ' > NaN');\n" +
      "assertFalse(" + x + " <= NaN, '' + " + x + " + ' <= NaN');\n" +
      "assertFalse(" + x + " >= NaN, '' + " + x + " + ' >= NaN');\n";
  eval(program);
}
                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/compare-nil.js                                                     0000664 0000000 0000000 00000003355 14746647661 0021267 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

function test(v) {
  return (v == null);
}
assertFalse(test(true));
assertFalse(test(true));
assertTrue(test(null));
assertTrue(test(null));
                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/compare-objects.js                                                 0000664 0000000 0000000 00000006657 14746647661 0022146 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

// Test CompareIC stubs for normal and strict equality comparison of known
// objects in hydrogen.

function lt(a, b) {
  return a < b;
}

function gt(a, b) {
  return a > b;
}

function eq(a, b) {
  return a == b;
}

function eq_strict(a, b) {
  return a === b;
}

function test(a, b, less, greater) {
  // Check CompareIC for equality of known objects.
  assertTrue(eq(a, a));
  assertTrue(eq(b, b));
  assertFalse(eq(a, b));
  assertTrue(eq_strict(a, a));
  assertTrue(eq_strict(b, b));
  assertFalse(eq_strict(a, b));
  assertEquals(lt(a, b), less);
  assertEquals(gt(a, b), greater);
  assertEquals(lt(b, a), greater);
  assertEquals(gt(b, a), less);
}
%PrepareFunctionForOptimization(test);

var obj1 = {toString: function() {return "1";}};
var obj2 = {toString: function() {return "2";}};

var less = obj1 < obj2;
var greater = obj1 > obj2;

test(obj1, obj2, less, greater);
test(obj1, obj2, less, greater);
test(obj1, obj2, less, greater);
%OptimizeFunctionOnNextCall(test);
test(obj1, obj2, less, greater);
test(obj1, obj2, less, greater);

obj1.x = 1;
test(obj1, obj2, less, greater);

obj2.y = 2;
test(obj1, obj2, less, greater);

var obj1 = {test: 3};
var obj2 = {test2: 3};

var less = obj1 < obj2;
var greater = obj1 > obj2;

test(obj1, obj2, less, greater);
test(obj1, obj2, less, greater);
test(obj1, obj2, less, greater);
%PrepareFunctionForOptimization(test);
%OptimizeFunctionOnNextCall(test);
test(obj1, obj2, less, greater);
test(obj1, obj2, less, greater);

obj1.toString = function() {return "1"};
var less = obj1 < obj2;
var greater = obj1 > obj2;
test(obj1, obj2, less, greater);
%PrepareFunctionForOptimization(test);
%OptimizeFunctionOnNextCall(test);
test(obj1, obj2, less, greater);

obj2.toString = function() {return "2"};
var less = true;
var greater = false;

test(obj1, obj2, less, greater);
obj2.y = 2;
test(obj1, obj2, less, greater);
                                                                                 node-23.7.0/deps/v8/test/mjsunit/compare-table-eq.js                                                0000664 0000000 0000000 00000020642 14746647661 0022175 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var values = [true,false,null,void 0,0,0.0,-0,"",-1,-1.25,1,1.25,-2147483648,2147483648,Infinity,-Infinity,NaN];
var expected = [
  [true ,false,false,false,false,false,false,false,false,false,true ,false,false,false,false,false,false],
  [false,true ,false,false,true ,true ,true ,true ,false,false,false,false,false,false,false,false,false],
  [false,false,true ,true ,false,false,false,false,false,false,false,false,false,false,false,false,false],
  [false,false,true ,true ,false,false,false,false,false,false,false,false,false,false,false,false,false],
  [false,true ,false,false,true ,true ,true ,true ,false,false,false,false,false,false,false,false,false],
  [false,true ,false,false,true ,true ,true ,true ,false,false,false,false,false,false,false,false,false],
  [false,true ,false,false,true ,true ,true ,true ,false,false,false,false,false,false,false,false,false],
  [false,true ,false,false,true ,true ,true ,true ,false,false,false,false,false,false,false,false,false],
  [false,false,false,false,false,false,false,false,true ,false,false,false,false,false,false,false,false],
  [false,false,false,false,false,false,false,false,false,true ,false,false,false,false,false,false,false],
  [true ,false,false,false,false,false,false,false,false,false,true ,false,false,false,false,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,true ,false,false,false,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,true ,false,false,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,true ,false,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,true ,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true ,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false]
];
var func = (function eq(a,b) { return a == b; });
var left_funcs = [
  (function eq_L0(b) { return true == b; }),
  (function eq_L1(b) { return false == b; }),
  (function eq_L2(b) { return null == b; }),
  (function eq_L3(b) { return void 0 == b; }),
  (function eq_L4(b) { return 0 == b; }),
  (function eq_L5(b) { return 0.0 == b; }),
  (function eq_L6(b) { return -0 == b; }),
  (function eq_L7(b) { return "" == b; }),
  (function eq_L8(b) { return -1 == b; }),
  (function eq_L9(b) { return -1.25 == b; }),
  (function eq_L10(b) { return 1 == b; }),
  (function eq_L11(b) { return 1.25 == b; }),
  (function eq_L12(b) { return -2147483648 == b; }),
  (function eq_L13(b) { return 2147483648 == b; }),
  (function eq_L14(b) { return Infinity == b; }),
  (function eq_L15(b) { return -Infinity == b; }),
  (function eq_L16(b) { return NaN == b; })
];
var right_funcs = [
  (function eq_R0(a) { return a == true; }),
  (function eq_R1(a) { return a == false; }),
  (function eq_R2(a) { return a == null; }),
  (function eq_R3(a) { return a == void 0; }),
  (function eq_R4(a) { return a == 0; }),
  (function eq_R5(a) { return a == 0.0; }),
  (function eq_R6(a) { return a == -0; }),
  (function eq_R7(a) { return a == ""; }),
  (function eq_R8(a) { return a == -1; }),
  (function eq_R9(a) { return a == -1.25; }),
  (function eq_R10(a) { return a == 1; }),
  (function eq_R11(a) { return a == 1.25; }),
  (function eq_R12(a) { return a == -2147483648; }),
  (function eq_R13(a) { return a == 2147483648; }),
  (function eq_R14(a) { return a == Infinity; }),
  (function eq_R15(a) { return a == -Infinity; }),
  (function eq_R16(a) { return a == NaN; })
];
function matrix() {
  return [
    [true == true,true == false,true == null,true == void 0,true == 0,true == 0.0,true == -0,true == "",true == -1,true == -1.25,true == 1,true == 1.25,true == -2147483648,true == 2147483648,true == Infinity,true == -Infinity,true == NaN],
    [false == true,false == false,false == null,false == void 0,false == 0,false == 0.0,false == -0,false == "",false == -1,false == -1.25,false == 1,false == 1.25,false == -2147483648,false == 2147483648,false == Infinity,false == -Infinity,false == NaN],
    [null == true,null == false,null == null,null == void 0,null == 0,null == 0.0,null == -0,null == "",null == -1,null == -1.25,null == 1,null == 1.25,null == -2147483648,null == 2147483648,null == Infinity,null == -Infinity,null == NaN],
    [void 0 == true,void 0 == false,void 0 == null,void 0 == void 0,void 0 == 0,void 0 == 0.0,void 0 == -0,void 0 == "",void 0 == -1,void 0 == -1.25,void 0 == 1,void 0 == 1.25,void 0 == -2147483648,void 0 == 2147483648,void 0 == Infinity,void 0 == -Infinity,void 0 == NaN],
    [0 == true,0 == false,0 == null,0 == void 0,0 == 0,0 == 0.0,0 == -0,0 == "",0 == -1,0 == -1.25,0 == 1,0 == 1.25,0 == -2147483648,0 == 2147483648,0 == Infinity,0 == -Infinity,0 == NaN],
    [0.0 == true,0.0 == false,0.0 == null,0.0 == void 0,0.0 == 0,0.0 == 0.0,0.0 == -0,0.0 == "",0.0 == -1,0.0 == -1.25,0.0 == 1,0.0 == 1.25,0.0 == -2147483648,0.0 == 2147483648,0.0 == Infinity,0.0 == -Infinity,0.0 == NaN],
    [-0 == true,-0 == false,-0 == null,-0 == void 0,-0 == 0,-0 == 0.0,-0 == -0,-0 == "",-0 == -1,-0 == -1.25,-0 == 1,-0 == 1.25,-0 == -2147483648,-0 == 2147483648,-0 == Infinity,-0 == -Infinity,-0 == NaN],
    ["" == true,"" == false,"" == null,"" == void 0,"" == 0,"" == 0.0,"" == -0,"" == "","" == -1,"" == -1.25,"" == 1,"" == 1.25,"" == -2147483648,"" == 2147483648,"" == Infinity,"" == -Infinity,"" == NaN],
    [-1 == true,-1 == false,-1 == null,-1 == void 0,-1 == 0,-1 == 0.0,-1 == -0,-1 == "",-1 == -1,-1 == -1.25,-1 == 1,-1 == 1.25,-1 == -2147483648,-1 == 2147483648,-1 == Infinity,-1 == -Infinity,-1 == NaN],
    [-1.25 == true,-1.25 == false,-1.25 == null,-1.25 == void 0,-1.25 == 0,-1.25 == 0.0,-1.25 == -0,-1.25 == "",-1.25 == -1,-1.25 == -1.25,-1.25 == 1,-1.25 == 1.25,-1.25 == -2147483648,-1.25 == 2147483648,-1.25 == Infinity,-1.25 == -Infinity,-1.25 == NaN],
    [1 == true,1 == false,1 == null,1 == void 0,1 == 0,1 == 0.0,1 == -0,1 == "",1 == -1,1 == -1.25,1 == 1,1 == 1.25,1 == -2147483648,1 == 2147483648,1 == Infinity,1 == -Infinity,1 == NaN],
    [1.25 == true,1.25 == false,1.25 == null,1.25 == void 0,1.25 == 0,1.25 == 0.0,1.25 == -0,1.25 == "",1.25 == -1,1.25 == -1.25,1.25 == 1,1.25 == 1.25,1.25 == -2147483648,1.25 == 2147483648,1.25 == Infinity,1.25 == -Infinity,1.25 == NaN],
    [-2147483648 == true,-2147483648 == false,-2147483648 == null,-2147483648 == void 0,-2147483648 == 0,-2147483648 == 0.0,-2147483648 == -0,-2147483648 == "",-2147483648 == -1,-2147483648 == -1.25,-2147483648 == 1,-2147483648 == 1.25,-2147483648 == -2147483648,-2147483648 == 2147483648,-2147483648 == Infinity,-2147483648 == -Infinity,-2147483648 == NaN],
    [2147483648 == true,2147483648 == false,2147483648 == null,2147483648 == void 0,2147483648 == 0,2147483648 == 0.0,2147483648 == -0,2147483648 == "",2147483648 == -1,2147483648 == -1.25,2147483648 == 1,2147483648 == 1.25,2147483648 == -2147483648,2147483648 == 2147483648,2147483648 == Infinity,2147483648 == -Infinity,2147483648 == NaN],
    [Infinity == true,Infinity == false,Infinity == null,Infinity == void 0,Infinity == 0,Infinity == 0.0,Infinity == -0,Infinity == "",Infinity == -1,Infinity == -1.25,Infinity == 1,Infinity == 1.25,Infinity == -2147483648,Infinity == 2147483648,Infinity == Infinity,Infinity == -Infinity,Infinity == NaN],
    [-Infinity == true,-Infinity == false,-Infinity == null,-Infinity == void 0,-Infinity == 0,-Infinity == 0.0,-Infinity == -0,-Infinity == "",-Infinity == -1,-Infinity == -1.25,-Infinity == 1,-Infinity == 1.25,-Infinity == -2147483648,-Infinity == 2147483648,-Infinity == Infinity,-Infinity == -Infinity,-Infinity == NaN],
    [NaN == true,NaN == false,NaN == null,NaN == void 0,NaN == 0,NaN == 0.0,NaN == -0,NaN == "",NaN == -1,NaN == -1.25,NaN == 1,NaN == 1.25,NaN == -2147483648,NaN == 2147483648,NaN == Infinity,NaN == -Infinity,NaN == NaN]
  ];
}
function test() {
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      var a = values[i];
      var b = values[j];
      var x = expected[i][j];
      assertEquals(x, func(a,b));
      assertEquals(x, left_funcs[i](b));
      assertEquals(x, right_funcs[j](a));
    }
  }

  var result = matrix();
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      assertEquals(expected[i][j], result[i][j]);
    }
  }
}
test();
test();
                                                                                              node-23.7.0/deps/v8/test/mjsunit/compare-table-gt.js                                                0000664 0000000 0000000 00000020136 14746647661 0022200 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var values = [true,false,null,void 0,0,0.0,-0,"",-1,-1.25,1,1.25,-2147483648,2147483648,Infinity,-Infinity,NaN];
var expected = [
  [false,true ,true ,false,true ,true ,true ,true ,true ,true ,false,false,true ,false,false,true ,false],
  [false,false,false,false,false,false,false,false,true ,true ,false,false,true ,false,false,true ,false],
  [false,false,false,false,false,false,false,false,true ,true ,false,false,true ,false,false,true ,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false],
  [false,false,false,false,false,false,false,false,true ,true ,false,false,true ,false,false,true ,false],
  [false,false,false,false,false,false,false,false,true ,true ,false,false,true ,false,false,true ,false],
  [false,false,false,false,false,false,false,false,true ,true ,false,false,true ,false,false,true ,false],
  [false,false,false,false,false,false,false,false,true ,true ,false,false,true ,false,false,true ,false],
  [false,false,false,false,false,false,false,false,false,true ,false,false,true ,false,false,true ,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,true ,false,false,true ,false],
  [false,true ,true ,false,true ,true ,true ,true ,true ,true ,false,false,true ,false,false,true ,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,false,true ,false,false,true ,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true ,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,false,true ,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false]
];
var func = (function gt(a,b) { return a > b; });
var left_funcs = [
  (function gt_L0(b) { return true > b; }),
  (function gt_L1(b) { return false > b; }),
  (function gt_L2(b) { return null > b; }),
  (function gt_L3(b) { return void 0 > b; }),
  (function gt_L4(b) { return 0 > b; }),
  (function gt_L5(b) { return 0.0 > b; }),
  (function gt_L6(b) { return -0 > b; }),
  (function gt_L7(b) { return "" > b; }),
  (function gt_L8(b) { return -1 > b; }),
  (function gt_L9(b) { return -1.25 > b; }),
  (function gt_L10(b) { return 1 > b; }),
  (function gt_L11(b) { return 1.25 > b; }),
  (function gt_L12(b) { return -2147483648 > b; }),
  (function gt_L13(b) { return 2147483648 > b; }),
  (function gt_L14(b) { return Infinity > b; }),
  (function gt_L15(b) { return -Infinity > b; }),
  (function gt_L16(b) { return NaN > b; })
];
var right_funcs = [
  (function gt_R0(a) { return a > true; }),
  (function gt_R1(a) { return a > false; }),
  (function gt_R2(a) { return a > null; }),
  (function gt_R3(a) { return a > void 0; }),
  (function gt_R4(a) { return a > 0; }),
  (function gt_R5(a) { return a > 0.0; }),
  (function gt_R6(a) { return a > -0; }),
  (function gt_R7(a) { return a > ""; }),
  (function gt_R8(a) { return a > -1; }),
  (function gt_R9(a) { return a > -1.25; }),
  (function gt_R10(a) { return a > 1; }),
  (function gt_R11(a) { return a > 1.25; }),
  (function gt_R12(a) { return a > -2147483648; }),
  (function gt_R13(a) { return a > 2147483648; }),
  (function gt_R14(a) { return a > Infinity; }),
  (function gt_R15(a) { return a > -Infinity; }),
  (function gt_R16(a) { return a > NaN; })
];
function matrix() {
  return [
    [true > true,true > false,true > null,true > void 0,true > 0,true > 0.0,true > -0,true > "",true > -1,true > -1.25,true > 1,true > 1.25,true > -2147483648,true > 2147483648,true > Infinity,true > -Infinity,true > NaN],
    [false > true,false > false,false > null,false > void 0,false > 0,false > 0.0,false > -0,false > "",false > -1,false > -1.25,false > 1,false > 1.25,false > -2147483648,false > 2147483648,false > Infinity,false > -Infinity,false > NaN],
    [null > true,null > false,null > null,null > void 0,null > 0,null > 0.0,null > -0,null > "",null > -1,null > -1.25,null > 1,null > 1.25,null > -2147483648,null > 2147483648,null > Infinity,null > -Infinity,null > NaN],
    [void 0 > true,void 0 > false,void 0 > null,void 0 > void 0,void 0 > 0,void 0 > 0.0,void 0 > -0,void 0 > "",void 0 > -1,void 0 > -1.25,void 0 > 1,void 0 > 1.25,void 0 > -2147483648,void 0 > 2147483648,void 0 > Infinity,void 0 > -Infinity,void 0 > NaN],
    [0 > true,0 > false,0 > null,0 > void 0,0 > 0,0 > 0.0,0 > -0,0 > "",0 > -1,0 > -1.25,0 > 1,0 > 1.25,0 > -2147483648,0 > 2147483648,0 > Infinity,0 > -Infinity,0 > NaN],
    [0.0 > true,0.0 > false,0.0 > null,0.0 > void 0,0.0 > 0,0.0 > 0.0,0.0 > -0,0.0 > "",0.0 > -1,0.0 > -1.25,0.0 > 1,0.0 > 1.25,0.0 > -2147483648,0.0 > 2147483648,0.0 > Infinity,0.0 > -Infinity,0.0 > NaN],
    [-0 > true,-0 > false,-0 > null,-0 > void 0,-0 > 0,-0 > 0.0,-0 > -0,-0 > "",-0 > -1,-0 > -1.25,-0 > 1,-0 > 1.25,-0 > -2147483648,-0 > 2147483648,-0 > Infinity,-0 > -Infinity,-0 > NaN],
    ["" > true,"" > false,"" > null,"" > void 0,"" > 0,"" > 0.0,"" > -0,"" > "","" > -1,"" > -1.25,"" > 1,"" > 1.25,"" > -2147483648,"" > 2147483648,"" > Infinity,"" > -Infinity,"" > NaN],
    [-1 > true,-1 > false,-1 > null,-1 > void 0,-1 > 0,-1 > 0.0,-1 > -0,-1 > "",-1 > -1,-1 > -1.25,-1 > 1,-1 > 1.25,-1 > -2147483648,-1 > 2147483648,-1 > Infinity,-1 > -Infinity,-1 > NaN],
    [-1.25 > true,-1.25 > false,-1.25 > null,-1.25 > void 0,-1.25 > 0,-1.25 > 0.0,-1.25 > -0,-1.25 > "",-1.25 > -1,-1.25 > -1.25,-1.25 > 1,-1.25 > 1.25,-1.25 > -2147483648,-1.25 > 2147483648,-1.25 > Infinity,-1.25 > -Infinity,-1.25 > NaN],
    [1 > true,1 > false,1 > null,1 > void 0,1 > 0,1 > 0.0,1 > -0,1 > "",1 > -1,1 > -1.25,1 > 1,1 > 1.25,1 > -2147483648,1 > 2147483648,1 > Infinity,1 > -Infinity,1 > NaN],
    [1.25 > true,1.25 > false,1.25 > null,1.25 > void 0,1.25 > 0,1.25 > 0.0,1.25 > -0,1.25 > "",1.25 > -1,1.25 > -1.25,1.25 > 1,1.25 > 1.25,1.25 > -2147483648,1.25 > 2147483648,1.25 > Infinity,1.25 > -Infinity,1.25 > NaN],
    [-2147483648 > true,-2147483648 > false,-2147483648 > null,-2147483648 > void 0,-2147483648 > 0,-2147483648 > 0.0,-2147483648 > -0,-2147483648 > "",-2147483648 > -1,-2147483648 > -1.25,-2147483648 > 1,-2147483648 > 1.25,-2147483648 > -2147483648,-2147483648 > 2147483648,-2147483648 > Infinity,-2147483648 > -Infinity,-2147483648 > NaN],
    [2147483648 > true,2147483648 > false,2147483648 > null,2147483648 > void 0,2147483648 > 0,2147483648 > 0.0,2147483648 > -0,2147483648 > "",2147483648 > -1,2147483648 > -1.25,2147483648 > 1,2147483648 > 1.25,2147483648 > -2147483648,2147483648 > 2147483648,2147483648 > Infinity,2147483648 > -Infinity,2147483648 > NaN],
    [Infinity > true,Infinity > false,Infinity > null,Infinity > void 0,Infinity > 0,Infinity > 0.0,Infinity > -0,Infinity > "",Infinity > -1,Infinity > -1.25,Infinity > 1,Infinity > 1.25,Infinity > -2147483648,Infinity > 2147483648,Infinity > Infinity,Infinity > -Infinity,Infinity > NaN],
    [-Infinity > true,-Infinity > false,-Infinity > null,-Infinity > void 0,-Infinity > 0,-Infinity > 0.0,-Infinity > -0,-Infinity > "",-Infinity > -1,-Infinity > -1.25,-Infinity > 1,-Infinity > 1.25,-Infinity > -2147483648,-Infinity > 2147483648,-Infinity > Infinity,-Infinity > -Infinity,-Infinity > NaN],
    [NaN > true,NaN > false,NaN > null,NaN > void 0,NaN > 0,NaN > 0.0,NaN > -0,NaN > "",NaN > -1,NaN > -1.25,NaN > 1,NaN > 1.25,NaN > -2147483648,NaN > 2147483648,NaN > Infinity,NaN > -Infinity,NaN > NaN]
  ];
}
function test() {
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      var a = values[i];
      var b = values[j];
      var x = expected[i][j];
      assertEquals(x, func(a,b));
      assertEquals(x, left_funcs[i](b));
      assertEquals(x, right_funcs[j](a));
    }
  }

  var result = matrix();
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      assertEquals(expected[i][j], result[i][j]);
    }
  }
}
test();
test();
                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/compare-table-gteq.js                                              0000664 0000000 0000000 00000020750 14746647661 0022530 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var values = [true,false,null,void 0,0,0.0,-0,"",-1,-1.25,1,1.25,-2147483648,2147483648,Infinity,-Infinity,NaN];
var expected = [
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,false,true ,false,false,true ,false],
  [false,true ,true ,false,true ,true ,true ,true ,true ,true ,false,false,true ,false,false,true ,false],
  [false,true ,true ,false,true ,true ,true ,true ,true ,true ,false,false,true ,false,false,true ,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false],
  [false,true ,true ,false,true ,true ,true ,true ,true ,true ,false,false,true ,false,false,true ,false],
  [false,true ,true ,false,true ,true ,true ,true ,true ,true ,false,false,true ,false,false,true ,false],
  [false,true ,true ,false,true ,true ,true ,true ,true ,true ,false,false,true ,false,false,true ,false],
  [false,true ,true ,false,true ,true ,true ,true ,true ,true ,false,false,true ,false,false,true ,false],
  [false,false,false,false,false,false,false,false,true ,true ,false,false,true ,false,false,true ,false],
  [false,false,false,false,false,false,false,false,false,true ,false,false,true ,false,false,true ,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,false,true ,false,false,true ,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,false,true ,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,true ,false,false,true ,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true ,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false]
];
var func = (function gteq(a,b) { return a >= b; });
var left_funcs = [
  (function gteq_L0(b) { return true >= b; }),
  (function gteq_L1(b) { return false >= b; }),
  (function gteq_L2(b) { return null >= b; }),
  (function gteq_L3(b) { return void 0 >= b; }),
  (function gteq_L4(b) { return 0 >= b; }),
  (function gteq_L5(b) { return 0.0 >= b; }),
  (function gteq_L6(b) { return -0 >= b; }),
  (function gteq_L7(b) { return "" >= b; }),
  (function gteq_L8(b) { return -1 >= b; }),
  (function gteq_L9(b) { return -1.25 >= b; }),
  (function gteq_L10(b) { return 1 >= b; }),
  (function gteq_L11(b) { return 1.25 >= b; }),
  (function gteq_L12(b) { return -2147483648 >= b; }),
  (function gteq_L13(b) { return 2147483648 >= b; }),
  (function gteq_L14(b) { return Infinity >= b; }),
  (function gteq_L15(b) { return -Infinity >= b; }),
  (function gteq_L16(b) { return NaN >= b; })
];
var right_funcs = [
  (function gteq_R0(a) { return a >= true; }),
  (function gteq_R1(a) { return a >= false; }),
  (function gteq_R2(a) { return a >= null; }),
  (function gteq_R3(a) { return a >= void 0; }),
  (function gteq_R4(a) { return a >= 0; }),
  (function gteq_R5(a) { return a >= 0.0; }),
  (function gteq_R6(a) { return a >= -0; }),
  (function gteq_R7(a) { return a >= ""; }),
  (function gteq_R8(a) { return a >= -1; }),
  (function gteq_R9(a) { return a >= -1.25; }),
  (function gteq_R10(a) { return a >= 1; }),
  (function gteq_R11(a) { return a >= 1.25; }),
  (function gteq_R12(a) { return a >= -2147483648; }),
  (function gteq_R13(a) { return a >= 2147483648; }),
  (function gteq_R14(a) { return a >= Infinity; }),
  (function gteq_R15(a) { return a >= -Infinity; }),
  (function gteq_R16(a) { return a >= NaN; })
];
function matrix() {
  return [
    [true >= true,true >= false,true >= null,true >= void 0,true >= 0,true >= 0.0,true >= -0,true >= "",true >= -1,true >= -1.25,true >= 1,true >= 1.25,true >= -2147483648,true >= 2147483648,true >= Infinity,true >= -Infinity,true >= NaN],
    [false >= true,false >= false,false >= null,false >= void 0,false >= 0,false >= 0.0,false >= -0,false >= "",false >= -1,false >= -1.25,false >= 1,false >= 1.25,false >= -2147483648,false >= 2147483648,false >= Infinity,false >= -Infinity,false >= NaN],
    [null >= true,null >= false,null >= null,null >= void 0,null >= 0,null >= 0.0,null >= -0,null >= "",null >= -1,null >= -1.25,null >= 1,null >= 1.25,null >= -2147483648,null >= 2147483648,null >= Infinity,null >= -Infinity,null >= NaN],
    [void 0 >= true,void 0 >= false,void 0 >= null,void 0 >= void 0,void 0 >= 0,void 0 >= 0.0,void 0 >= -0,void 0 >= "",void 0 >= -1,void 0 >= -1.25,void 0 >= 1,void 0 >= 1.25,void 0 >= -2147483648,void 0 >= 2147483648,void 0 >= Infinity,void 0 >= -Infinity,void 0 >= NaN],
    [0 >= true,0 >= false,0 >= null,0 >= void 0,0 >= 0,0 >= 0.0,0 >= -0,0 >= "",0 >= -1,0 >= -1.25,0 >= 1,0 >= 1.25,0 >= -2147483648,0 >= 2147483648,0 >= Infinity,0 >= -Infinity,0 >= NaN],
    [0.0 >= true,0.0 >= false,0.0 >= null,0.0 >= void 0,0.0 >= 0,0.0 >= 0.0,0.0 >= -0,0.0 >= "",0.0 >= -1,0.0 >= -1.25,0.0 >= 1,0.0 >= 1.25,0.0 >= -2147483648,0.0 >= 2147483648,0.0 >= Infinity,0.0 >= -Infinity,0.0 >= NaN],
    [-0 >= true,-0 >= false,-0 >= null,-0 >= void 0,-0 >= 0,-0 >= 0.0,-0 >= -0,-0 >= "",-0 >= -1,-0 >= -1.25,-0 >= 1,-0 >= 1.25,-0 >= -2147483648,-0 >= 2147483648,-0 >= Infinity,-0 >= -Infinity,-0 >= NaN],
    ["" >= true,"" >= false,"" >= null,"" >= void 0,"" >= 0,"" >= 0.0,"" >= -0,"" >= "","" >= -1,"" >= -1.25,"" >= 1,"" >= 1.25,"" >= -2147483648,"" >= 2147483648,"" >= Infinity,"" >= -Infinity,"" >= NaN],
    [-1 >= true,-1 >= false,-1 >= null,-1 >= void 0,-1 >= 0,-1 >= 0.0,-1 >= -0,-1 >= "",-1 >= -1,-1 >= -1.25,-1 >= 1,-1 >= 1.25,-1 >= -2147483648,-1 >= 2147483648,-1 >= Infinity,-1 >= -Infinity,-1 >= NaN],
    [-1.25 >= true,-1.25 >= false,-1.25 >= null,-1.25 >= void 0,-1.25 >= 0,-1.25 >= 0.0,-1.25 >= -0,-1.25 >= "",-1.25 >= -1,-1.25 >= -1.25,-1.25 >= 1,-1.25 >= 1.25,-1.25 >= -2147483648,-1.25 >= 2147483648,-1.25 >= Infinity,-1.25 >= -Infinity,-1.25 >= NaN],
    [1 >= true,1 >= false,1 >= null,1 >= void 0,1 >= 0,1 >= 0.0,1 >= -0,1 >= "",1 >= -1,1 >= -1.25,1 >= 1,1 >= 1.25,1 >= -2147483648,1 >= 2147483648,1 >= Infinity,1 >= -Infinity,1 >= NaN],
    [1.25 >= true,1.25 >= false,1.25 >= null,1.25 >= void 0,1.25 >= 0,1.25 >= 0.0,1.25 >= -0,1.25 >= "",1.25 >= -1,1.25 >= -1.25,1.25 >= 1,1.25 >= 1.25,1.25 >= -2147483648,1.25 >= 2147483648,1.25 >= Infinity,1.25 >= -Infinity,1.25 >= NaN],
    [-2147483648 >= true,-2147483648 >= false,-2147483648 >= null,-2147483648 >= void 0,-2147483648 >= 0,-2147483648 >= 0.0,-2147483648 >= -0,-2147483648 >= "",-2147483648 >= -1,-2147483648 >= -1.25,-2147483648 >= 1,-2147483648 >= 1.25,-2147483648 >= -2147483648,-2147483648 >= 2147483648,-2147483648 >= Infinity,-2147483648 >= -Infinity,-2147483648 >= NaN],
    [2147483648 >= true,2147483648 >= false,2147483648 >= null,2147483648 >= void 0,2147483648 >= 0,2147483648 >= 0.0,2147483648 >= -0,2147483648 >= "",2147483648 >= -1,2147483648 >= -1.25,2147483648 >= 1,2147483648 >= 1.25,2147483648 >= -2147483648,2147483648 >= 2147483648,2147483648 >= Infinity,2147483648 >= -Infinity,2147483648 >= NaN],
    [Infinity >= true,Infinity >= false,Infinity >= null,Infinity >= void 0,Infinity >= 0,Infinity >= 0.0,Infinity >= -0,Infinity >= "",Infinity >= -1,Infinity >= -1.25,Infinity >= 1,Infinity >= 1.25,Infinity >= -2147483648,Infinity >= 2147483648,Infinity >= Infinity,Infinity >= -Infinity,Infinity >= NaN],
    [-Infinity >= true,-Infinity >= false,-Infinity >= null,-Infinity >= void 0,-Infinity >= 0,-Infinity >= 0.0,-Infinity >= -0,-Infinity >= "",-Infinity >= -1,-Infinity >= -1.25,-Infinity >= 1,-Infinity >= 1.25,-Infinity >= -2147483648,-Infinity >= 2147483648,-Infinity >= Infinity,-Infinity >= -Infinity,-Infinity >= NaN],
    [NaN >= true,NaN >= false,NaN >= null,NaN >= void 0,NaN >= 0,NaN >= 0.0,NaN >= -0,NaN >= "",NaN >= -1,NaN >= -1.25,NaN >= 1,NaN >= 1.25,NaN >= -2147483648,NaN >= 2147483648,NaN >= Infinity,NaN >= -Infinity,NaN >= NaN]
  ];
}
function test() {
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      var a = values[i];
      var b = values[j];
      var x = expected[i][j];
      assertEquals(x, func(a,b));
      assertEquals(x, left_funcs[i](b));
      assertEquals(x, right_funcs[j](a));
    }
  }

  var result = matrix();
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      assertEquals(expected[i][j], result[i][j]);
    }
  }
}
test();
test();
                        node-23.7.0/deps/v8/test/mjsunit/compare-table-lt.js                                                0000664 0000000 0000000 00000020136 14746647661 0022205 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var values = [true,false,null,void 0,0,0.0,-0,"",-1,-1.25,1,1.25,-2147483648,2147483648,Infinity,-Infinity,NaN];
var expected = [
  [false,false,false,false,false,false,false,false,false,false,false,true ,false,true ,true ,false,false],
  [true ,false,false,false,false,false,false,false,false,false,true ,true ,false,true ,true ,false,false],
  [true ,false,false,false,false,false,false,false,false,false,true ,true ,false,true ,true ,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false],
  [true ,false,false,false,false,false,false,false,false,false,true ,true ,false,true ,true ,false,false],
  [true ,false,false,false,false,false,false,false,false,false,true ,true ,false,true ,true ,false,false],
  [true ,false,false,false,false,false,false,false,false,false,true ,true ,false,true ,true ,false,false],
  [true ,false,false,false,false,false,false,false,false,false,true ,true ,false,true ,true ,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,false,false,true ,true ,false,true ,true ,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,false,true ,true ,false,true ,true ,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,true ,false,true ,true ,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,true ,true ,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,true ,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false]
];
var func = (function lt(a,b) { return a < b; });
var left_funcs = [
  (function lt_L0(b) { return true < b; }),
  (function lt_L1(b) { return false < b; }),
  (function lt_L2(b) { return null < b; }),
  (function lt_L3(b) { return void 0 < b; }),
  (function lt_L4(b) { return 0 < b; }),
  (function lt_L5(b) { return 0.0 < b; }),
  (function lt_L6(b) { return -0 < b; }),
  (function lt_L7(b) { return "" < b; }),
  (function lt_L8(b) { return -1 < b; }),
  (function lt_L9(b) { return -1.25 < b; }),
  (function lt_L10(b) { return 1 < b; }),
  (function lt_L11(b) { return 1.25 < b; }),
  (function lt_L12(b) { return -2147483648 < b; }),
  (function lt_L13(b) { return 2147483648 < b; }),
  (function lt_L14(b) { return Infinity < b; }),
  (function lt_L15(b) { return -Infinity < b; }),
  (function lt_L16(b) { return NaN < b; })
];
var right_funcs = [
  (function lt_R0(a) { return a < true; }),
  (function lt_R1(a) { return a < false; }),
  (function lt_R2(a) { return a < null; }),
  (function lt_R3(a) { return a < void 0; }),
  (function lt_R4(a) { return a < 0; }),
  (function lt_R5(a) { return a < 0.0; }),
  (function lt_R6(a) { return a < -0; }),
  (function lt_R7(a) { return a < ""; }),
  (function lt_R8(a) { return a < -1; }),
  (function lt_R9(a) { return a < -1.25; }),
  (function lt_R10(a) { return a < 1; }),
  (function lt_R11(a) { return a < 1.25; }),
  (function lt_R12(a) { return a < -2147483648; }),
  (function lt_R13(a) { return a < 2147483648; }),
  (function lt_R14(a) { return a < Infinity; }),
  (function lt_R15(a) { return a < -Infinity; }),
  (function lt_R16(a) { return a < NaN; })
];
function matrix() {
  return [
    [true < true,true < false,true < null,true < void 0,true < 0,true < 0.0,true < -0,true < "",true < -1,true < -1.25,true < 1,true < 1.25,true < -2147483648,true < 2147483648,true < Infinity,true < -Infinity,true < NaN],
    [false < true,false < false,false < null,false < void 0,false < 0,false < 0.0,false < -0,false < "",false < -1,false < -1.25,false < 1,false < 1.25,false < -2147483648,false < 2147483648,false < Infinity,false < -Infinity,false < NaN],
    [null < true,null < false,null < null,null < void 0,null < 0,null < 0.0,null < -0,null < "",null < -1,null < -1.25,null < 1,null < 1.25,null < -2147483648,null < 2147483648,null < Infinity,null < -Infinity,null < NaN],
    [void 0 < true,void 0 < false,void 0 < null,void 0 < void 0,void 0 < 0,void 0 < 0.0,void 0 < -0,void 0 < "",void 0 < -1,void 0 < -1.25,void 0 < 1,void 0 < 1.25,void 0 < -2147483648,void 0 < 2147483648,void 0 < Infinity,void 0 < -Infinity,void 0 < NaN],
    [0 < true,0 < false,0 < null,0 < void 0,0 < 0,0 < 0.0,0 < -0,0 < "",0 < -1,0 < -1.25,0 < 1,0 < 1.25,0 < -2147483648,0 < 2147483648,0 < Infinity,0 < -Infinity,0 < NaN],
    [0.0 < true,0.0 < false,0.0 < null,0.0 < void 0,0.0 < 0,0.0 < 0.0,0.0 < -0,0.0 < "",0.0 < -1,0.0 < -1.25,0.0 < 1,0.0 < 1.25,0.0 < -2147483648,0.0 < 2147483648,0.0 < Infinity,0.0 < -Infinity,0.0 < NaN],
    [-0 < true,-0 < false,-0 < null,-0 < void 0,-0 < 0,-0 < 0.0,-0 < -0,-0 < "",-0 < -1,-0 < -1.25,-0 < 1,-0 < 1.25,-0 < -2147483648,-0 < 2147483648,-0 < Infinity,-0 < -Infinity,-0 < NaN],
    ["" < true,"" < false,"" < null,"" < void 0,"" < 0,"" < 0.0,"" < -0,"" < "","" < -1,"" < -1.25,"" < 1,"" < 1.25,"" < -2147483648,"" < 2147483648,"" < Infinity,"" < -Infinity,"" < NaN],
    [-1 < true,-1 < false,-1 < null,-1 < void 0,-1 < 0,-1 < 0.0,-1 < -0,-1 < "",-1 < -1,-1 < -1.25,-1 < 1,-1 < 1.25,-1 < -2147483648,-1 < 2147483648,-1 < Infinity,-1 < -Infinity,-1 < NaN],
    [-1.25 < true,-1.25 < false,-1.25 < null,-1.25 < void 0,-1.25 < 0,-1.25 < 0.0,-1.25 < -0,-1.25 < "",-1.25 < -1,-1.25 < -1.25,-1.25 < 1,-1.25 < 1.25,-1.25 < -2147483648,-1.25 < 2147483648,-1.25 < Infinity,-1.25 < -Infinity,-1.25 < NaN],
    [1 < true,1 < false,1 < null,1 < void 0,1 < 0,1 < 0.0,1 < -0,1 < "",1 < -1,1 < -1.25,1 < 1,1 < 1.25,1 < -2147483648,1 < 2147483648,1 < Infinity,1 < -Infinity,1 < NaN],
    [1.25 < true,1.25 < false,1.25 < null,1.25 < void 0,1.25 < 0,1.25 < 0.0,1.25 < -0,1.25 < "",1.25 < -1,1.25 < -1.25,1.25 < 1,1.25 < 1.25,1.25 < -2147483648,1.25 < 2147483648,1.25 < Infinity,1.25 < -Infinity,1.25 < NaN],
    [-2147483648 < true,-2147483648 < false,-2147483648 < null,-2147483648 < void 0,-2147483648 < 0,-2147483648 < 0.0,-2147483648 < -0,-2147483648 < "",-2147483648 < -1,-2147483648 < -1.25,-2147483648 < 1,-2147483648 < 1.25,-2147483648 < -2147483648,-2147483648 < 2147483648,-2147483648 < Infinity,-2147483648 < -Infinity,-2147483648 < NaN],
    [2147483648 < true,2147483648 < false,2147483648 < null,2147483648 < void 0,2147483648 < 0,2147483648 < 0.0,2147483648 < -0,2147483648 < "",2147483648 < -1,2147483648 < -1.25,2147483648 < 1,2147483648 < 1.25,2147483648 < -2147483648,2147483648 < 2147483648,2147483648 < Infinity,2147483648 < -Infinity,2147483648 < NaN],
    [Infinity < true,Infinity < false,Infinity < null,Infinity < void 0,Infinity < 0,Infinity < 0.0,Infinity < -0,Infinity < "",Infinity < -1,Infinity < -1.25,Infinity < 1,Infinity < 1.25,Infinity < -2147483648,Infinity < 2147483648,Infinity < Infinity,Infinity < -Infinity,Infinity < NaN],
    [-Infinity < true,-Infinity < false,-Infinity < null,-Infinity < void 0,-Infinity < 0,-Infinity < 0.0,-Infinity < -0,-Infinity < "",-Infinity < -1,-Infinity < -1.25,-Infinity < 1,-Infinity < 1.25,-Infinity < -2147483648,-Infinity < 2147483648,-Infinity < Infinity,-Infinity < -Infinity,-Infinity < NaN],
    [NaN < true,NaN < false,NaN < null,NaN < void 0,NaN < 0,NaN < 0.0,NaN < -0,NaN < "",NaN < -1,NaN < -1.25,NaN < 1,NaN < 1.25,NaN < -2147483648,NaN < 2147483648,NaN < Infinity,NaN < -Infinity,NaN < NaN]
  ];
}
function test() {
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      var a = values[i];
      var b = values[j];
      var x = expected[i][j];
      assertEquals(x, func(a,b));
      assertEquals(x, left_funcs[i](b));
      assertEquals(x, right_funcs[j](a));
    }
  }

  var result = matrix();
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      assertEquals(expected[i][j], result[i][j]);
    }
  }
}
test();
test();
                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/compare-table-lteq.js                                              0000664 0000000 0000000 00000020750 14746647661 0022535 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var values = [true,false,null,void 0,0,0.0,-0,"",-1,-1.25,1,1.25,-2147483648,2147483648,Infinity,-Infinity,NaN];
var expected = [
  [true ,false,false,false,false,false,false,false,false,false,true ,true ,false,true ,true ,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,false,false,true ,true ,false,true ,true ,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,false,false,true ,true ,false,true ,true ,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,false,false,true ,true ,false,true ,true ,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,false,false,true ,true ,false,true ,true ,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,false,false,true ,true ,false,true ,true ,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,false,false,true ,true ,false,true ,true ,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,false,true ,true ,false,true ,true ,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,false,false],
  [true ,false,false,false,false,false,false,false,false,false,true ,true ,false,true ,true ,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,true ,false,true ,true ,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,true ,true ,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,true ,false,false],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false]
];
var func = (function lteq(a,b) { return a <= b; });
var left_funcs = [
  (function lteq_L0(b) { return true <= b; }),
  (function lteq_L1(b) { return false <= b; }),
  (function lteq_L2(b) { return null <= b; }),
  (function lteq_L3(b) { return void 0 <= b; }),
  (function lteq_L4(b) { return 0 <= b; }),
  (function lteq_L5(b) { return 0.0 <= b; }),
  (function lteq_L6(b) { return -0 <= b; }),
  (function lteq_L7(b) { return "" <= b; }),
  (function lteq_L8(b) { return -1 <= b; }),
  (function lteq_L9(b) { return -1.25 <= b; }),
  (function lteq_L10(b) { return 1 <= b; }),
  (function lteq_L11(b) { return 1.25 <= b; }),
  (function lteq_L12(b) { return -2147483648 <= b; }),
  (function lteq_L13(b) { return 2147483648 <= b; }),
  (function lteq_L14(b) { return Infinity <= b; }),
  (function lteq_L15(b) { return -Infinity <= b; }),
  (function lteq_L16(b) { return NaN <= b; })
];
var right_funcs = [
  (function lteq_R0(a) { return a <= true; }),
  (function lteq_R1(a) { return a <= false; }),
  (function lteq_R2(a) { return a <= null; }),
  (function lteq_R3(a) { return a <= void 0; }),
  (function lteq_R4(a) { return a <= 0; }),
  (function lteq_R5(a) { return a <= 0.0; }),
  (function lteq_R6(a) { return a <= -0; }),
  (function lteq_R7(a) { return a <= ""; }),
  (function lteq_R8(a) { return a <= -1; }),
  (function lteq_R9(a) { return a <= -1.25; }),
  (function lteq_R10(a) { return a <= 1; }),
  (function lteq_R11(a) { return a <= 1.25; }),
  (function lteq_R12(a) { return a <= -2147483648; }),
  (function lteq_R13(a) { return a <= 2147483648; }),
  (function lteq_R14(a) { return a <= Infinity; }),
  (function lteq_R15(a) { return a <= -Infinity; }),
  (function lteq_R16(a) { return a <= NaN; })
];
function matrix() {
  return [
    [true <= true,true <= false,true <= null,true <= void 0,true <= 0,true <= 0.0,true <= -0,true <= "",true <= -1,true <= -1.25,true <= 1,true <= 1.25,true <= -2147483648,true <= 2147483648,true <= Infinity,true <= -Infinity,true <= NaN],
    [false <= true,false <= false,false <= null,false <= void 0,false <= 0,false <= 0.0,false <= -0,false <= "",false <= -1,false <= -1.25,false <= 1,false <= 1.25,false <= -2147483648,false <= 2147483648,false <= Infinity,false <= -Infinity,false <= NaN],
    [null <= true,null <= false,null <= null,null <= void 0,null <= 0,null <= 0.0,null <= -0,null <= "",null <= -1,null <= -1.25,null <= 1,null <= 1.25,null <= -2147483648,null <= 2147483648,null <= Infinity,null <= -Infinity,null <= NaN],
    [void 0 <= true,void 0 <= false,void 0 <= null,void 0 <= void 0,void 0 <= 0,void 0 <= 0.0,void 0 <= -0,void 0 <= "",void 0 <= -1,void 0 <= -1.25,void 0 <= 1,void 0 <= 1.25,void 0 <= -2147483648,void 0 <= 2147483648,void 0 <= Infinity,void 0 <= -Infinity,void 0 <= NaN],
    [0 <= true,0 <= false,0 <= null,0 <= void 0,0 <= 0,0 <= 0.0,0 <= -0,0 <= "",0 <= -1,0 <= -1.25,0 <= 1,0 <= 1.25,0 <= -2147483648,0 <= 2147483648,0 <= Infinity,0 <= -Infinity,0 <= NaN],
    [0.0 <= true,0.0 <= false,0.0 <= null,0.0 <= void 0,0.0 <= 0,0.0 <= 0.0,0.0 <= -0,0.0 <= "",0.0 <= -1,0.0 <= -1.25,0.0 <= 1,0.0 <= 1.25,0.0 <= -2147483648,0.0 <= 2147483648,0.0 <= Infinity,0.0 <= -Infinity,0.0 <= NaN],
    [-0 <= true,-0 <= false,-0 <= null,-0 <= void 0,-0 <= 0,-0 <= 0.0,-0 <= -0,-0 <= "",-0 <= -1,-0 <= -1.25,-0 <= 1,-0 <= 1.25,-0 <= -2147483648,-0 <= 2147483648,-0 <= Infinity,-0 <= -Infinity,-0 <= NaN],
    ["" <= true,"" <= false,"" <= null,"" <= void 0,"" <= 0,"" <= 0.0,"" <= -0,"" <= "","" <= -1,"" <= -1.25,"" <= 1,"" <= 1.25,"" <= -2147483648,"" <= 2147483648,"" <= Infinity,"" <= -Infinity,"" <= NaN],
    [-1 <= true,-1 <= false,-1 <= null,-1 <= void 0,-1 <= 0,-1 <= 0.0,-1 <= -0,-1 <= "",-1 <= -1,-1 <= -1.25,-1 <= 1,-1 <= 1.25,-1 <= -2147483648,-1 <= 2147483648,-1 <= Infinity,-1 <= -Infinity,-1 <= NaN],
    [-1.25 <= true,-1.25 <= false,-1.25 <= null,-1.25 <= void 0,-1.25 <= 0,-1.25 <= 0.0,-1.25 <= -0,-1.25 <= "",-1.25 <= -1,-1.25 <= -1.25,-1.25 <= 1,-1.25 <= 1.25,-1.25 <= -2147483648,-1.25 <= 2147483648,-1.25 <= Infinity,-1.25 <= -Infinity,-1.25 <= NaN],
    [1 <= true,1 <= false,1 <= null,1 <= void 0,1 <= 0,1 <= 0.0,1 <= -0,1 <= "",1 <= -1,1 <= -1.25,1 <= 1,1 <= 1.25,1 <= -2147483648,1 <= 2147483648,1 <= Infinity,1 <= -Infinity,1 <= NaN],
    [1.25 <= true,1.25 <= false,1.25 <= null,1.25 <= void 0,1.25 <= 0,1.25 <= 0.0,1.25 <= -0,1.25 <= "",1.25 <= -1,1.25 <= -1.25,1.25 <= 1,1.25 <= 1.25,1.25 <= -2147483648,1.25 <= 2147483648,1.25 <= Infinity,1.25 <= -Infinity,1.25 <= NaN],
    [-2147483648 <= true,-2147483648 <= false,-2147483648 <= null,-2147483648 <= void 0,-2147483648 <= 0,-2147483648 <= 0.0,-2147483648 <= -0,-2147483648 <= "",-2147483648 <= -1,-2147483648 <= -1.25,-2147483648 <= 1,-2147483648 <= 1.25,-2147483648 <= -2147483648,-2147483648 <= 2147483648,-2147483648 <= Infinity,-2147483648 <= -Infinity,-2147483648 <= NaN],
    [2147483648 <= true,2147483648 <= false,2147483648 <= null,2147483648 <= void 0,2147483648 <= 0,2147483648 <= 0.0,2147483648 <= -0,2147483648 <= "",2147483648 <= -1,2147483648 <= -1.25,2147483648 <= 1,2147483648 <= 1.25,2147483648 <= -2147483648,2147483648 <= 2147483648,2147483648 <= Infinity,2147483648 <= -Infinity,2147483648 <= NaN],
    [Infinity <= true,Infinity <= false,Infinity <= null,Infinity <= void 0,Infinity <= 0,Infinity <= 0.0,Infinity <= -0,Infinity <= "",Infinity <= -1,Infinity <= -1.25,Infinity <= 1,Infinity <= 1.25,Infinity <= -2147483648,Infinity <= 2147483648,Infinity <= Infinity,Infinity <= -Infinity,Infinity <= NaN],
    [-Infinity <= true,-Infinity <= false,-Infinity <= null,-Infinity <= void 0,-Infinity <= 0,-Infinity <= 0.0,-Infinity <= -0,-Infinity <= "",-Infinity <= -1,-Infinity <= -1.25,-Infinity <= 1,-Infinity <= 1.25,-Infinity <= -2147483648,-Infinity <= 2147483648,-Infinity <= Infinity,-Infinity <= -Infinity,-Infinity <= NaN],
    [NaN <= true,NaN <= false,NaN <= null,NaN <= void 0,NaN <= 0,NaN <= 0.0,NaN <= -0,NaN <= "",NaN <= -1,NaN <= -1.25,NaN <= 1,NaN <= 1.25,NaN <= -2147483648,NaN <= 2147483648,NaN <= Infinity,NaN <= -Infinity,NaN <= NaN]
  ];
}
function test() {
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      var a = values[i];
      var b = values[j];
      var x = expected[i][j];
      assertEquals(x, func(a,b));
      assertEquals(x, left_funcs[i](b));
      assertEquals(x, right_funcs[j](a));
    }
  }

  var result = matrix();
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      assertEquals(expected[i][j], result[i][j]);
    }
  }
}
test();
test();
                        node-23.7.0/deps/v8/test/mjsunit/compare-table-ne.js                                                0000664 0000000 0000000 00000020642 14746647661 0022172 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var values = [true,false,null,void 0,0,0.0,-0,"",-1,-1.25,1,1.25,-2147483648,2147483648,Infinity,-Infinity,NaN];
var expected = [
  [false,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ,true ,true ,true ],
  [true ,false,true ,true ,false,false,false,false,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,true ,false,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,true ,false,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,false,true ,true ,false,false,false,false,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,false,true ,true ,false,false,false,false,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,false,true ,true ,false,false,false,false,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,false,true ,true ,false,false,false,false,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ],
  [false,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ]
];
var func = (function ne(a,b) { return a != b; });
var left_funcs = [
  (function ne_L0(b) { return true != b; }),
  (function ne_L1(b) { return false != b; }),
  (function ne_L2(b) { return null != b; }),
  (function ne_L3(b) { return void 0 != b; }),
  (function ne_L4(b) { return 0 != b; }),
  (function ne_L5(b) { return 0.0 != b; }),
  (function ne_L6(b) { return -0 != b; }),
  (function ne_L7(b) { return "" != b; }),
  (function ne_L8(b) { return -1 != b; }),
  (function ne_L9(b) { return -1.25 != b; }),
  (function ne_L10(b) { return 1 != b; }),
  (function ne_L11(b) { return 1.25 != b; }),
  (function ne_L12(b) { return -2147483648 != b; }),
  (function ne_L13(b) { return 2147483648 != b; }),
  (function ne_L14(b) { return Infinity != b; }),
  (function ne_L15(b) { return -Infinity != b; }),
  (function ne_L16(b) { return NaN != b; })
];
var right_funcs = [
  (function ne_R0(a) { return a != true; }),
  (function ne_R1(a) { return a != false; }),
  (function ne_R2(a) { return a != null; }),
  (function ne_R3(a) { return a != void 0; }),
  (function ne_R4(a) { return a != 0; }),
  (function ne_R5(a) { return a != 0.0; }),
  (function ne_R6(a) { return a != -0; }),
  (function ne_R7(a) { return a != ""; }),
  (function ne_R8(a) { return a != -1; }),
  (function ne_R9(a) { return a != -1.25; }),
  (function ne_R10(a) { return a != 1; }),
  (function ne_R11(a) { return a != 1.25; }),
  (function ne_R12(a) { return a != -2147483648; }),
  (function ne_R13(a) { return a != 2147483648; }),
  (function ne_R14(a) { return a != Infinity; }),
  (function ne_R15(a) { return a != -Infinity; }),
  (function ne_R16(a) { return a != NaN; })
];
function matrix() {
  return [
    [true != true,true != false,true != null,true != void 0,true != 0,true != 0.0,true != -0,true != "",true != -1,true != -1.25,true != 1,true != 1.25,true != -2147483648,true != 2147483648,true != Infinity,true != -Infinity,true != NaN],
    [false != true,false != false,false != null,false != void 0,false != 0,false != 0.0,false != -0,false != "",false != -1,false != -1.25,false != 1,false != 1.25,false != -2147483648,false != 2147483648,false != Infinity,false != -Infinity,false != NaN],
    [null != true,null != false,null != null,null != void 0,null != 0,null != 0.0,null != -0,null != "",null != -1,null != -1.25,null != 1,null != 1.25,null != -2147483648,null != 2147483648,null != Infinity,null != -Infinity,null != NaN],
    [void 0 != true,void 0 != false,void 0 != null,void 0 != void 0,void 0 != 0,void 0 != 0.0,void 0 != -0,void 0 != "",void 0 != -1,void 0 != -1.25,void 0 != 1,void 0 != 1.25,void 0 != -2147483648,void 0 != 2147483648,void 0 != Infinity,void 0 != -Infinity,void 0 != NaN],
    [0 != true,0 != false,0 != null,0 != void 0,0 != 0,0 != 0.0,0 != -0,0 != "",0 != -1,0 != -1.25,0 != 1,0 != 1.25,0 != -2147483648,0 != 2147483648,0 != Infinity,0 != -Infinity,0 != NaN],
    [0.0 != true,0.0 != false,0.0 != null,0.0 != void 0,0.0 != 0,0.0 != 0.0,0.0 != -0,0.0 != "",0.0 != -1,0.0 != -1.25,0.0 != 1,0.0 != 1.25,0.0 != -2147483648,0.0 != 2147483648,0.0 != Infinity,0.0 != -Infinity,0.0 != NaN],
    [-0 != true,-0 != false,-0 != null,-0 != void 0,-0 != 0,-0 != 0.0,-0 != -0,-0 != "",-0 != -1,-0 != -1.25,-0 != 1,-0 != 1.25,-0 != -2147483648,-0 != 2147483648,-0 != Infinity,-0 != -Infinity,-0 != NaN],
    ["" != true,"" != false,"" != null,"" != void 0,"" != 0,"" != 0.0,"" != -0,"" != "","" != -1,"" != -1.25,"" != 1,"" != 1.25,"" != -2147483648,"" != 2147483648,"" != Infinity,"" != -Infinity,"" != NaN],
    [-1 != true,-1 != false,-1 != null,-1 != void 0,-1 != 0,-1 != 0.0,-1 != -0,-1 != "",-1 != -1,-1 != -1.25,-1 != 1,-1 != 1.25,-1 != -2147483648,-1 != 2147483648,-1 != Infinity,-1 != -Infinity,-1 != NaN],
    [-1.25 != true,-1.25 != false,-1.25 != null,-1.25 != void 0,-1.25 != 0,-1.25 != 0.0,-1.25 != -0,-1.25 != "",-1.25 != -1,-1.25 != -1.25,-1.25 != 1,-1.25 != 1.25,-1.25 != -2147483648,-1.25 != 2147483648,-1.25 != Infinity,-1.25 != -Infinity,-1.25 != NaN],
    [1 != true,1 != false,1 != null,1 != void 0,1 != 0,1 != 0.0,1 != -0,1 != "",1 != -1,1 != -1.25,1 != 1,1 != 1.25,1 != -2147483648,1 != 2147483648,1 != Infinity,1 != -Infinity,1 != NaN],
    [1.25 != true,1.25 != false,1.25 != null,1.25 != void 0,1.25 != 0,1.25 != 0.0,1.25 != -0,1.25 != "",1.25 != -1,1.25 != -1.25,1.25 != 1,1.25 != 1.25,1.25 != -2147483648,1.25 != 2147483648,1.25 != Infinity,1.25 != -Infinity,1.25 != NaN],
    [-2147483648 != true,-2147483648 != false,-2147483648 != null,-2147483648 != void 0,-2147483648 != 0,-2147483648 != 0.0,-2147483648 != -0,-2147483648 != "",-2147483648 != -1,-2147483648 != -1.25,-2147483648 != 1,-2147483648 != 1.25,-2147483648 != -2147483648,-2147483648 != 2147483648,-2147483648 != Infinity,-2147483648 != -Infinity,-2147483648 != NaN],
    [2147483648 != true,2147483648 != false,2147483648 != null,2147483648 != void 0,2147483648 != 0,2147483648 != 0.0,2147483648 != -0,2147483648 != "",2147483648 != -1,2147483648 != -1.25,2147483648 != 1,2147483648 != 1.25,2147483648 != -2147483648,2147483648 != 2147483648,2147483648 != Infinity,2147483648 != -Infinity,2147483648 != NaN],
    [Infinity != true,Infinity != false,Infinity != null,Infinity != void 0,Infinity != 0,Infinity != 0.0,Infinity != -0,Infinity != "",Infinity != -1,Infinity != -1.25,Infinity != 1,Infinity != 1.25,Infinity != -2147483648,Infinity != 2147483648,Infinity != Infinity,Infinity != -Infinity,Infinity != NaN],
    [-Infinity != true,-Infinity != false,-Infinity != null,-Infinity != void 0,-Infinity != 0,-Infinity != 0.0,-Infinity != -0,-Infinity != "",-Infinity != -1,-Infinity != -1.25,-Infinity != 1,-Infinity != 1.25,-Infinity != -2147483648,-Infinity != 2147483648,-Infinity != Infinity,-Infinity != -Infinity,-Infinity != NaN],
    [NaN != true,NaN != false,NaN != null,NaN != void 0,NaN != 0,NaN != 0.0,NaN != -0,NaN != "",NaN != -1,NaN != -1.25,NaN != 1,NaN != 1.25,NaN != -2147483648,NaN != 2147483648,NaN != Infinity,NaN != -Infinity,NaN != NaN]
  ];
}
function test() {
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      var a = values[i];
      var b = values[j];
      var x = expected[i][j];
      assertEquals(x, func(a,b));
      assertEquals(x, left_funcs[i](b));
      assertEquals(x, right_funcs[j](a));
    }
  }

  var result = matrix();
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      assertEquals(expected[i][j], result[i][j]);
    }
  }
}
test();
test();
                                                                                              node-23.7.0/deps/v8/test/mjsunit/compare-table-seq.js                                               0000664 0000000 0000000 00000021411 14746647661 0022353 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var values = [true,false,null,void 0,0,0.0,-0,"",-1,-1.25,1,1.25,-2147483648,2147483648,Infinity,-Infinity,NaN];
var expected = [
  [true ,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false],
  [false,true ,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false],
  [false,false,true ,false,false,false,false,false,false,false,false,false,false,false,false,false,false],
  [false,false,false,true ,false,false,false,false,false,false,false,false,false,false,false,false,false],
  [false,false,false,false,true ,true ,true ,false,false,false,false,false,false,false,false,false,false],
  [false,false,false,false,true ,true ,true ,false,false,false,false,false,false,false,false,false,false],
  [false,false,false,false,true ,true ,true ,false,false,false,false,false,false,false,false,false,false],
  [false,false,false,false,false,false,false,true ,false,false,false,false,false,false,false,false,false],
  [false,false,false,false,false,false,false,false,true ,false,false,false,false,false,false,false,false],
  [false,false,false,false,false,false,false,false,false,true ,false,false,false,false,false,false,false],
  [false,false,false,false,false,false,false,false,false,false,true ,false,false,false,false,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,true ,false,false,false,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,true ,false,false,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,true ,false,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,true ,false,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true ,false],
  [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false]
];
var func = (function seq(a,b) { return a === b; });
var left_funcs = [
  (function seq_L0(b) { return true === b; }),
  (function seq_L1(b) { return false === b; }),
  (function seq_L2(b) { return null === b; }),
  (function seq_L3(b) { return void 0 === b; }),
  (function seq_L4(b) { return 0 === b; }),
  (function seq_L5(b) { return 0.0 === b; }),
  (function seq_L6(b) { return -0 === b; }),
  (function seq_L7(b) { return "" === b; }),
  (function seq_L8(b) { return -1 === b; }),
  (function seq_L9(b) { return -1.25 === b; }),
  (function seq_L10(b) { return 1 === b; }),
  (function seq_L11(b) { return 1.25 === b; }),
  (function seq_L12(b) { return -2147483648 === b; }),
  (function seq_L13(b) { return 2147483648 === b; }),
  (function seq_L14(b) { return Infinity === b; }),
  (function seq_L15(b) { return -Infinity === b; }),
  (function seq_L16(b) { return NaN === b; })
];
var right_funcs = [
  (function seq_R0(a) { return a === true; }),
  (function seq_R1(a) { return a === false; }),
  (function seq_R2(a) { return a === null; }),
  (function seq_R3(a) { return a === void 0; }),
  (function seq_R4(a) { return a === 0; }),
  (function seq_R5(a) { return a === 0.0; }),
  (function seq_R6(a) { return a === -0; }),
  (function seq_R7(a) { return a === ""; }),
  (function seq_R8(a) { return a === -1; }),
  (function seq_R9(a) { return a === -1.25; }),
  (function seq_R10(a) { return a === 1; }),
  (function seq_R11(a) { return a === 1.25; }),
  (function seq_R12(a) { return a === -2147483648; }),
  (function seq_R13(a) { return a === 2147483648; }),
  (function seq_R14(a) { return a === Infinity; }),
  (function seq_R15(a) { return a === -Infinity; }),
  (function seq_R16(a) { return a === NaN; })
];
function matrix() {
  return [
    [true === true,true === false,true === null,true === void 0,true === 0,true === 0.0,true === -0,true === "",true === -1,true === -1.25,true === 1,true === 1.25,true === -2147483648,true === 2147483648,true === Infinity,true === -Infinity,true === NaN],
    [false === true,false === false,false === null,false === void 0,false === 0,false === 0.0,false === -0,false === "",false === -1,false === -1.25,false === 1,false === 1.25,false === -2147483648,false === 2147483648,false === Infinity,false === -Infinity,false === NaN],
    [null === true,null === false,null === null,null === void 0,null === 0,null === 0.0,null === -0,null === "",null === -1,null === -1.25,null === 1,null === 1.25,null === -2147483648,null === 2147483648,null === Infinity,null === -Infinity,null === NaN],
    [void 0 === true,void 0 === false,void 0 === null,void 0 === void 0,void 0 === 0,void 0 === 0.0,void 0 === -0,void 0 === "",void 0 === -1,void 0 === -1.25,void 0 === 1,void 0 === 1.25,void 0 === -2147483648,void 0 === 2147483648,void 0 === Infinity,void 0 === -Infinity,void 0 === NaN],
    [0 === true,0 === false,0 === null,0 === void 0,0 === 0,0 === 0.0,0 === -0,0 === "",0 === -1,0 === -1.25,0 === 1,0 === 1.25,0 === -2147483648,0 === 2147483648,0 === Infinity,0 === -Infinity,0 === NaN],
    [0.0 === true,0.0 === false,0.0 === null,0.0 === void 0,0.0 === 0,0.0 === 0.0,0.0 === -0,0.0 === "",0.0 === -1,0.0 === -1.25,0.0 === 1,0.0 === 1.25,0.0 === -2147483648,0.0 === 2147483648,0.0 === Infinity,0.0 === -Infinity,0.0 === NaN],
    [-0 === true,-0 === false,-0 === null,-0 === void 0,-0 === 0,-0 === 0.0,-0 === -0,-0 === "",-0 === -1,-0 === -1.25,-0 === 1,-0 === 1.25,-0 === -2147483648,-0 === 2147483648,-0 === Infinity,-0 === -Infinity,-0 === NaN],
    ["" === true,"" === false,"" === null,"" === void 0,"" === 0,"" === 0.0,"" === -0,"" === "","" === -1,"" === -1.25,"" === 1,"" === 1.25,"" === -2147483648,"" === 2147483648,"" === Infinity,"" === -Infinity,"" === NaN],
    [-1 === true,-1 === false,-1 === null,-1 === void 0,-1 === 0,-1 === 0.0,-1 === -0,-1 === "",-1 === -1,-1 === -1.25,-1 === 1,-1 === 1.25,-1 === -2147483648,-1 === 2147483648,-1 === Infinity,-1 === -Infinity,-1 === NaN],
    [-1.25 === true,-1.25 === false,-1.25 === null,-1.25 === void 0,-1.25 === 0,-1.25 === 0.0,-1.25 === -0,-1.25 === "",-1.25 === -1,-1.25 === -1.25,-1.25 === 1,-1.25 === 1.25,-1.25 === -2147483648,-1.25 === 2147483648,-1.25 === Infinity,-1.25 === -Infinity,-1.25 === NaN],
    [1 === true,1 === false,1 === null,1 === void 0,1 === 0,1 === 0.0,1 === -0,1 === "",1 === -1,1 === -1.25,1 === 1,1 === 1.25,1 === -2147483648,1 === 2147483648,1 === Infinity,1 === -Infinity,1 === NaN],
    [1.25 === true,1.25 === false,1.25 === null,1.25 === void 0,1.25 === 0,1.25 === 0.0,1.25 === -0,1.25 === "",1.25 === -1,1.25 === -1.25,1.25 === 1,1.25 === 1.25,1.25 === -2147483648,1.25 === 2147483648,1.25 === Infinity,1.25 === -Infinity,1.25 === NaN],
    [-2147483648 === true,-2147483648 === false,-2147483648 === null,-2147483648 === void 0,-2147483648 === 0,-2147483648 === 0.0,-2147483648 === -0,-2147483648 === "",-2147483648 === -1,-2147483648 === -1.25,-2147483648 === 1,-2147483648 === 1.25,-2147483648 === -2147483648,-2147483648 === 2147483648,-2147483648 === Infinity,-2147483648 === -Infinity,-2147483648 === NaN],
    [2147483648 === true,2147483648 === false,2147483648 === null,2147483648 === void 0,2147483648 === 0,2147483648 === 0.0,2147483648 === -0,2147483648 === "",2147483648 === -1,2147483648 === -1.25,2147483648 === 1,2147483648 === 1.25,2147483648 === -2147483648,2147483648 === 2147483648,2147483648 === Infinity,2147483648 === -Infinity,2147483648 === NaN],
    [Infinity === true,Infinity === false,Infinity === null,Infinity === void 0,Infinity === 0,Infinity === 0.0,Infinity === -0,Infinity === "",Infinity === -1,Infinity === -1.25,Infinity === 1,Infinity === 1.25,Infinity === -2147483648,Infinity === 2147483648,Infinity === Infinity,Infinity === -Infinity,Infinity === NaN],
    [-Infinity === true,-Infinity === false,-Infinity === null,-Infinity === void 0,-Infinity === 0,-Infinity === 0.0,-Infinity === -0,-Infinity === "",-Infinity === -1,-Infinity === -1.25,-Infinity === 1,-Infinity === 1.25,-Infinity === -2147483648,-Infinity === 2147483648,-Infinity === Infinity,-Infinity === -Infinity,-Infinity === NaN],
    [NaN === true,NaN === false,NaN === null,NaN === void 0,NaN === 0,NaN === 0.0,NaN === -0,NaN === "",NaN === -1,NaN === -1.25,NaN === 1,NaN === 1.25,NaN === -2147483648,NaN === 2147483648,NaN === Infinity,NaN === -Infinity,NaN === NaN]
  ];
}
function test() {
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      var a = values[i];
      var b = values[j];
      var x = expected[i][j];
      assertEquals(x, func(a,b));
      assertEquals(x, left_funcs[i](b));
      assertEquals(x, right_funcs[j](a));
    }
  }

  var result = matrix();
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      assertEquals(expected[i][j], result[i][j]);
    }
  }
}
test();
test();
                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/compare-table-sne.js                                               0000664 0000000 0000000 00000021411 14746647661 0022350 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var values = [true,false,null,void 0,0,0.0,-0,"",-1,-1.25,1,1.25,-2147483648,2147483648,Infinity,-Infinity,NaN];
var expected = [
  [false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,true ,true ,true ,false,false,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,true ,true ,true ,false,false,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,true ,true ,true ,false,false,false,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ,true ,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,false,true ],
  [true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ,true ]
];
var func = (function sne(a,b) { return a !== b; });
var left_funcs = [
  (function sne_L0(b) { return true !== b; }),
  (function sne_L1(b) { return false !== b; }),
  (function sne_L2(b) { return null !== b; }),
  (function sne_L3(b) { return void 0 !== b; }),
  (function sne_L4(b) { return 0 !== b; }),
  (function sne_L5(b) { return 0.0 !== b; }),
  (function sne_L6(b) { return -0 !== b; }),
  (function sne_L7(b) { return "" !== b; }),
  (function sne_L8(b) { return -1 !== b; }),
  (function sne_L9(b) { return -1.25 !== b; }),
  (function sne_L10(b) { return 1 !== b; }),
  (function sne_L11(b) { return 1.25 !== b; }),
  (function sne_L12(b) { return -2147483648 !== b; }),
  (function sne_L13(b) { return 2147483648 !== b; }),
  (function sne_L14(b) { return Infinity !== b; }),
  (function sne_L15(b) { return -Infinity !== b; }),
  (function sne_L16(b) { return NaN !== b; })
];
var right_funcs = [
  (function sne_R0(a) { return a !== true; }),
  (function sne_R1(a) { return a !== false; }),
  (function sne_R2(a) { return a !== null; }),
  (function sne_R3(a) { return a !== void 0; }),
  (function sne_R4(a) { return a !== 0; }),
  (function sne_R5(a) { return a !== 0.0; }),
  (function sne_R6(a) { return a !== -0; }),
  (function sne_R7(a) { return a !== ""; }),
  (function sne_R8(a) { return a !== -1; }),
  (function sne_R9(a) { return a !== -1.25; }),
  (function sne_R10(a) { return a !== 1; }),
  (function sne_R11(a) { return a !== 1.25; }),
  (function sne_R12(a) { return a !== -2147483648; }),
  (function sne_R13(a) { return a !== 2147483648; }),
  (function sne_R14(a) { return a !== Infinity; }),
  (function sne_R15(a) { return a !== -Infinity; }),
  (function sne_R16(a) { return a !== NaN; })
];
function matrix() {
  return [
    [true !== true,true !== false,true !== null,true !== void 0,true !== 0,true !== 0.0,true !== -0,true !== "",true !== -1,true !== -1.25,true !== 1,true !== 1.25,true !== -2147483648,true !== 2147483648,true !== Infinity,true !== -Infinity,true !== NaN],
    [false !== true,false !== false,false !== null,false !== void 0,false !== 0,false !== 0.0,false !== -0,false !== "",false !== -1,false !== -1.25,false !== 1,false !== 1.25,false !== -2147483648,false !== 2147483648,false !== Infinity,false !== -Infinity,false !== NaN],
    [null !== true,null !== false,null !== null,null !== void 0,null !== 0,null !== 0.0,null !== -0,null !== "",null !== -1,null !== -1.25,null !== 1,null !== 1.25,null !== -2147483648,null !== 2147483648,null !== Infinity,null !== -Infinity,null !== NaN],
    [void 0 !== true,void 0 !== false,void 0 !== null,void 0 !== void 0,void 0 !== 0,void 0 !== 0.0,void 0 !== -0,void 0 !== "",void 0 !== -1,void 0 !== -1.25,void 0 !== 1,void 0 !== 1.25,void 0 !== -2147483648,void 0 !== 2147483648,void 0 !== Infinity,void 0 !== -Infinity,void 0 !== NaN],
    [0 !== true,0 !== false,0 !== null,0 !== void 0,0 !== 0,0 !== 0.0,0 !== -0,0 !== "",0 !== -1,0 !== -1.25,0 !== 1,0 !== 1.25,0 !== -2147483648,0 !== 2147483648,0 !== Infinity,0 !== -Infinity,0 !== NaN],
    [0.0 !== true,0.0 !== false,0.0 !== null,0.0 !== void 0,0.0 !== 0,0.0 !== 0.0,0.0 !== -0,0.0 !== "",0.0 !== -1,0.0 !== -1.25,0.0 !== 1,0.0 !== 1.25,0.0 !== -2147483648,0.0 !== 2147483648,0.0 !== Infinity,0.0 !== -Infinity,0.0 !== NaN],
    [-0 !== true,-0 !== false,-0 !== null,-0 !== void 0,-0 !== 0,-0 !== 0.0,-0 !== -0,-0 !== "",-0 !== -1,-0 !== -1.25,-0 !== 1,-0 !== 1.25,-0 !== -2147483648,-0 !== 2147483648,-0 !== Infinity,-0 !== -Infinity,-0 !== NaN],
    ["" !== true,"" !== false,"" !== null,"" !== void 0,"" !== 0,"" !== 0.0,"" !== -0,"" !== "","" !== -1,"" !== -1.25,"" !== 1,"" !== 1.25,"" !== -2147483648,"" !== 2147483648,"" !== Infinity,"" !== -Infinity,"" !== NaN],
    [-1 !== true,-1 !== false,-1 !== null,-1 !== void 0,-1 !== 0,-1 !== 0.0,-1 !== -0,-1 !== "",-1 !== -1,-1 !== -1.25,-1 !== 1,-1 !== 1.25,-1 !== -2147483648,-1 !== 2147483648,-1 !== Infinity,-1 !== -Infinity,-1 !== NaN],
    [-1.25 !== true,-1.25 !== false,-1.25 !== null,-1.25 !== void 0,-1.25 !== 0,-1.25 !== 0.0,-1.25 !== -0,-1.25 !== "",-1.25 !== -1,-1.25 !== -1.25,-1.25 !== 1,-1.25 !== 1.25,-1.25 !== -2147483648,-1.25 !== 2147483648,-1.25 !== Infinity,-1.25 !== -Infinity,-1.25 !== NaN],
    [1 !== true,1 !== false,1 !== null,1 !== void 0,1 !== 0,1 !== 0.0,1 !== -0,1 !== "",1 !== -1,1 !== -1.25,1 !== 1,1 !== 1.25,1 !== -2147483648,1 !== 2147483648,1 !== Infinity,1 !== -Infinity,1 !== NaN],
    [1.25 !== true,1.25 !== false,1.25 !== null,1.25 !== void 0,1.25 !== 0,1.25 !== 0.0,1.25 !== -0,1.25 !== "",1.25 !== -1,1.25 !== -1.25,1.25 !== 1,1.25 !== 1.25,1.25 !== -2147483648,1.25 !== 2147483648,1.25 !== Infinity,1.25 !== -Infinity,1.25 !== NaN],
    [-2147483648 !== true,-2147483648 !== false,-2147483648 !== null,-2147483648 !== void 0,-2147483648 !== 0,-2147483648 !== 0.0,-2147483648 !== -0,-2147483648 !== "",-2147483648 !== -1,-2147483648 !== -1.25,-2147483648 !== 1,-2147483648 !== 1.25,-2147483648 !== -2147483648,-2147483648 !== 2147483648,-2147483648 !== Infinity,-2147483648 !== -Infinity,-2147483648 !== NaN],
    [2147483648 !== true,2147483648 !== false,2147483648 !== null,2147483648 !== void 0,2147483648 !== 0,2147483648 !== 0.0,2147483648 !== -0,2147483648 !== "",2147483648 !== -1,2147483648 !== -1.25,2147483648 !== 1,2147483648 !== 1.25,2147483648 !== -2147483648,2147483648 !== 2147483648,2147483648 !== Infinity,2147483648 !== -Infinity,2147483648 !== NaN],
    [Infinity !== true,Infinity !== false,Infinity !== null,Infinity !== void 0,Infinity !== 0,Infinity !== 0.0,Infinity !== -0,Infinity !== "",Infinity !== -1,Infinity !== -1.25,Infinity !== 1,Infinity !== 1.25,Infinity !== -2147483648,Infinity !== 2147483648,Infinity !== Infinity,Infinity !== -Infinity,Infinity !== NaN],
    [-Infinity !== true,-Infinity !== false,-Infinity !== null,-Infinity !== void 0,-Infinity !== 0,-Infinity !== 0.0,-Infinity !== -0,-Infinity !== "",-Infinity !== -1,-Infinity !== -1.25,-Infinity !== 1,-Infinity !== 1.25,-Infinity !== -2147483648,-Infinity !== 2147483648,-Infinity !== Infinity,-Infinity !== -Infinity,-Infinity !== NaN],
    [NaN !== true,NaN !== false,NaN !== null,NaN !== void 0,NaN !== 0,NaN !== 0.0,NaN !== -0,NaN !== "",NaN !== -1,NaN !== -1.25,NaN !== 1,NaN !== 1.25,NaN !== -2147483648,NaN !== 2147483648,NaN !== Infinity,NaN !== -Infinity,NaN !== NaN]
  ];
}
function test() {
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      var a = values[i];
      var b = values[j];
      var x = expected[i][j];
      assertEquals(x, func(a,b));
      assertEquals(x, left_funcs[i](b));
      assertEquals(x, right_funcs[j](a));
    }
  }

  var result = matrix();
  for (var i = 0; i < values.length; i++) {
    for (var j = 0; j < values.length; j++) {
      assertEquals(expected[i][j], result[i][j]);
    }
  }
}
test();
test();
                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/comparison-ops-and-undefined.js                                    0000664 0000000 0000000 00000007301 14746647661 0024524 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

function test_helper_for_ics(func, b1, b2, b3, b4) {
  assertEquals(b1, func(.5, .5));
  assertEquals(b2, func(.5, undefined));
  assertEquals(b3, func(undefined, .5));
  assertEquals(b4, func(undefined, undefined));
}

function test_helper_for_crankshaft(func, b1, b2, b3, b4) {
  %PrepareFunctionForOptimization(func);
  assertEquals(b1, func(.5, .5));
  %OptimizeFunctionOnNextCall(func);
  assertEquals(b1, func(.5, .5));
  assertEquals(b2, func(.5, undefined));
  assertEquals(b3, func(undefined, .5));
  assertEquals(b4, func(undefined, undefined));
}

function less_1(a, b) {
  return a < b;
}

test_helper_for_ics(less_1, false, false, false, false);

function less_2(a, b) {
  return a < b;
}

test_helper_for_crankshaft(less_1, false, false, false, false);

function greater_1(a, b) {
  return a > b;
}

test_helper_for_ics(greater_1, false, false, false, false);

function greater_2(a, b) {
  return a > b;
}

test_helper_for_crankshaft(greater_1, false, false, false, false);

function less_equal_1(a, b) {
  return a <= b;
}

test_helper_for_ics(less_equal_1, true, false, false, false);

function less_equal_2(a, b) {
  return a <= b;
}

test_helper_for_crankshaft(less_equal_1, true, false, false, false);

function greater_equal_1(a, b) {
  return a >= b;
}

test_helper_for_ics(greater_equal_1, true, false, false, false);

function greater_equal_2(a, b) {
  return a >= b;
}

test_helper_for_crankshaft(greater_equal_1, true, false, false, false);

function equal_1(a, b) {
  return a == b;
}

test_helper_for_ics(equal_1, true, false, false, true);

function equal_2(a, b) {
  return a == b;
}

test_helper_for_crankshaft(equal_2, true, false, false, true);

function strict_equal_1(a, b) {
  return a === b;
}

test_helper_for_ics(strict_equal_1, true, false, false, true);

function strict_equal_2(a, b) {
  return a === b;
}

test_helper_for_crankshaft(strict_equal_2, true, false, false, true);

function not_equal_1(a, b) {
  return a != b;
}

test_helper_for_ics(not_equal_1, false, true, true, false);

function not_equal_2(a, b) {
  return a != b;
}

test_helper_for_crankshaft(not_equal_2, false, true, true, false);
                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/comparison-throws-feedback.js                                      0000664 0000000 0000000 00000002336 14746647661 0024277 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

function testThrowsNoDeopt(fn) {
  %PrepareFunctionForOptimization(fn);
  for (let i = 0; i < 5; i++) assertThrows(fn, TypeError);
  %OptimizeFunctionOnNextCall(fn);
  assertThrows(fn, TypeError);
  // Assert that the function is still optimized, i.e. no deopt happened when
  // calling it.
  assertOptimized(fn);
}

function testNoDeopt(fn, expected) {
  %PrepareFunctionForOptimization(fn);
  for (let i = 0; i < 5; i++) fn();
  %OptimizeFunctionOnNextCall(fn);
  assertEquals(expected, fn());
  assertOptimized(fn);
}

let symbol = Symbol("test");
testThrowsNoDeopt(() => 2 < symbol);
testThrowsNoDeopt(() => 2 > symbol);
testThrowsNoDeopt(() => 2 <= symbol);
testThrowsNoDeopt(() => 2 >= symbol);
testNoDeopt(() => 2 == symbol, false);
let invalidValueOf = {valueOf: () => +2n};
testThrowsNoDeopt(() => 2 < invalidValueOf);
testThrowsNoDeopt(() => 2 > invalidValueOf);
testThrowsNoDeopt(() => 2 <= invalidValueOf);
testThrowsNoDeopt(() => 2 >= invalidValueOf);
testThrowsNoDeopt(() => 2 == invalidValueOf);
                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/compiler-regress-787301.js                                         0000664 0000000 0000000 00000001061 14746647661 0023102 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

function opt(b) {
    let iterator = new Set().values();
    iterator.x = 0;

    let arr = [iterator, iterator];
    if (b)
        return arr.slice();
}

%PrepareFunctionForOptimization(opt);
opt(false);
opt(false);
%OptimizeFunctionOnNextCall(opt);

let res = opt(true);
let a = res[0];
let b = res[1];

assertTrue(a === b);
a.x = 7;
assertEquals(7, b.x);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/compiler/                                                          0000775 0000000 0000000 00000000000 14746647661 0020327 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/compiler/abstract-equal-oddball.js                                 0000664 0000000 0000000 00000016151 14746647661 0025200 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan


// smi == boolean
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(2, true));
  assertTrue(foo(1, true));
  assertTrue(foo(0, false));
  assertFalse(foo(2, false));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(2, true));
  assertTrue(foo(1, true));
  assertTrue(foo(0, false));
  assertFalse(foo(2, false));
  assertOptimized(foo);

  assertFalse(foo(0, null));
  assertUnoptimized(foo);
})();


// boolean == smi
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(true, 2));
  assertTrue(foo(true, 1));
  assertTrue(foo(false, 0));
  assertFalse(foo(false, 2));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(true, 2));
  assertTrue(foo(true, 1));
  assertTrue(foo(false, 0));
  assertFalse(foo(false, 2));
  assertOptimized(foo);

  assertFalse(foo(null, 0));
  assertUnoptimized(foo);
})();


// smi == undefined
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(2, undefined));
  assertFalse(foo(0, undefined));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(2, undefined));
  assertFalse(foo(0, undefined));
  assertOptimized(foo);
})();


// undefined == smi
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(undefined, 2));
  assertFalse(foo(undefined, 0));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(undefined, 2));
  assertFalse(foo(undefined, 0));
  assertOptimized(foo);
})();


// smi == null
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(2, null));
  assertFalse(foo(0, null));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(2, null));
  assertFalse(foo(0, null));
  assertOptimized(foo);
})();


// null == smi
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(null, 2));
  assertFalse(foo(null, 0));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(null, 2));
  assertFalse(foo(null, 0));
  assertOptimized(foo);
})();


// smi == oddball
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(2, null));
  assertFalse(foo(0, undefined));
  assertFalse(foo(0, true));
  assertTrue(foo(1, true));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(2, null));
  assertFalse(foo(0, undefined));
  assertFalse(foo(0, true));
  assertTrue(foo(1, true));
  assertOptimized(foo);
})();


// oddball == smi
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(null, 2));
  assertFalse(foo(undefined, 0));
  assertFalse(foo(true, 0));
  assertTrue(foo(true, 1));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(null, 2));
  assertFalse(foo(undefined, 0));
  assertFalse(foo(true, 0));
  assertTrue(foo(true, 1));
  assertOptimized(foo);
})();


// number == boolean
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(-2.8, true));
  assertTrue(foo(1, true));
  assertTrue(foo(-0.0, false));
  assertFalse(foo(2, false));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(-2.8, true));
  assertTrue(foo(1, true));
  assertTrue(foo(-0.0, false));
  assertFalse(foo(2, false));
  assertOptimized(foo);

  assertFalse(foo(0, null));
  assertUnoptimized(foo);
})();


// boolean == number
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(true, -2.8));
  assertTrue(foo(true, 1));
  assertTrue(foo(false, -0.0));
  assertFalse(foo(false, 2));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(true, -2.8));
  assertTrue(foo(true, 1));
  assertTrue(foo(false, -0.0));
  assertFalse(foo(false, 2));
  assertOptimized(foo);

  assertFalse(foo(null, 0));
  assertUnoptimized(foo);
})();


// number == undefined
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(-2.8, undefined));
  assertFalse(foo(-0.0, undefined));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(-2.8, undefined));
  assertFalse(foo(-0.0, undefined));
  assertOptimized(foo);
})();


// undefined == number
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(undefined, -2.8));
  assertFalse(foo(undefined, -0.0));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(undefined, -2.8));
  assertFalse(foo(undefined, -0.0));
  assertOptimized(foo);
})();


// number == null
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(-2.8, null));
  assertFalse(foo(-0.0, null));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(-2.8, null));
  assertFalse(foo(-0.0, null));
  assertOptimized(foo);
})();


// null == number
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(null, -2.8));
  assertFalse(foo(null, -0.0));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(null, -2.8));
  assertFalse(foo(null, -0.0));
  assertOptimized(foo);
})();


// number == oddball
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(-2.8, null));
  assertFalse(foo(-0.0, undefined));
  assertFalse(foo(0, true));
  assertTrue(foo(1.0, true));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(-2.8, null));
  assertFalse(foo(-0.0, undefined));
  assertFalse(foo(0, true));
  assertTrue(foo(1.0, true));
  assertOptimized(foo);
})();


// oddball == number
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(null, -2.8));
  assertFalse(foo(undefined, -0.0));
  assertFalse(foo(true, 0));
  assertTrue(foo(true, 1.0));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(null, -2.8));
  assertFalse(foo(undefined, -0.0));
  assertFalse(foo(true, 0));
  assertTrue(foo(true, 1.0));
  assertOptimized(foo);
})();


// oddball == oddball
(function() {
  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(null, null));
  assertTrue(foo(undefined, undefined));
  assertTrue(foo(false, false));
  assertTrue(foo(true, true));
  assertTrue(foo(undefined, null));
  assertFalse(foo(undefined, false));
  assertFalse(foo(null, false));
  assertFalse(foo(true, undefined));
  assertFalse(foo(true, null));
  assertFalse(foo(true, false));

  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(null, null));
  assertOptimized(foo);
  assertTrue(foo(undefined, undefined));
  assertTrue(foo(false, false));
  assertTrue(foo(true, true));
  assertTrue(foo(undefined, null));
  assertFalse(foo(undefined, false));
  assertFalse(foo(null, false));
  assertFalse(foo(true, undefined));
  assertFalse(foo(true, null));
  assertFalse(foo(true, false));
  assertOptimized(foo);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/compiler/abstract-equal-receiver.js                                0000664 0000000 0000000 00000010175 14746647661 0025403 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --noalways-turbofan

// Known receivers abstract equality.
(function() {
  const a = {};
  const b = {};

  function foo() { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo());
  assertFalse(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo());
})();

// Known receiver/null abstract equality.
(function() {
  const a = {};
  const b = null;

  function foo() { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo());
  assertFalse(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo());
})();

// Known null/receiver abstract equality.
(function() {
  const a = null;
  const b = {};

  function foo() { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo());
  assertFalse(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo());
})();

// Known receiver/undefined abstract equality.
(function() {
  const a = {};
  const b = undefined;

  function foo() { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo());
  assertFalse(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo());
})();

// Known undefined/receiver abstract equality.
(function() {
  const a = undefined;
  const b = {};

  function foo() { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo());
  assertFalse(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo());
})();

// Known receiver on one side strict equality.
(function() {
  const a = {};
  const b = {};

  function foo(a) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(b));
  assertFalse(foo(a));
  assertTrue(foo(b));
  assertFalse(foo(a));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(b));
  assertFalse(foo(a));

  // TurboFan bakes in feedback for the (unknown) left hand side.
  assertFalse(foo(null));
  assertUnoptimized(foo);
})();

// Known receiver on one side strict equality with null.
(function() {
  const a = null;
  const b = {};

  function foo(a) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(b));
  assertFalse(foo(a));
  assertTrue(foo(b));
  assertFalse(foo(a));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(b));
  assertFalse(foo(a));

  // TurboFan bakes in feedback for the (unknown) left hand side.
  assertFalse(foo(1));
  assertUnoptimized(foo);
})();

// Known receiver on one side strict equality with undefined.
(function() {
  const a = undefined;
  const b = {};

  function foo(a) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(b));
  assertFalse(foo(a));
  assertTrue(foo(b));
  assertFalse(foo(a));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(b));
  assertFalse(foo(a));

  // TurboFan bakes in feedback for the (unknown) left hand side.
  assertFalse(foo(1));
  assertUnoptimized(foo);
})();

// Known null on one side strict equality with receiver.
(function() {
  const a = {};
  const b = null;

  function foo(a) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(b));
  assertFalse(foo(a));
  assertTrue(foo(b));
  assertFalse(foo(a));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(b));
  assertFalse(foo(a));
  assertTrue(foo(null));
  assertTrue(foo(undefined));
  assertOptimized(foo);

  // TurboFan doesn't need to bake in feedback, since it sees the null.
  assertFalse(foo(1));
  assertOptimized(foo);
})();

// Known undefined on one side strict equality with receiver.
(function() {
  const a = {};
  const b = undefined;

  function foo(a) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(b));
  assertFalse(foo(a));
  assertTrue(foo(b));
  assertFalse(foo(a));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(b));
  assertFalse(foo(a));
  assertTrue(foo(null));
  assertTrue(foo(undefined));
  assertOptimized(foo);

  // TurboFan needs to bake in feedback, since undefined cannot
  // be context specialized.
  assertFalse(foo(1));
  assertUnoptimized(foo);
})();
                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/compiler/abstract-equal-symbol.js                                  0000664 0000000 0000000 00000006776 14746647661 0025120 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --noalways-turbofan

// Known symbols abstract equality.
(function() {
  const a = Symbol("a");
  const b = Symbol("b");

  function foo() { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo());
  assertFalse(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo());
})();

// Known symbols abstract in-equality.
(function() {
  const a = Symbol("a");
  const b = Symbol("b");

  function foo() { return a != b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo());
  assertTrue(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo());
})();

// Known symbol on one side abstract equality.
(function() {
  const a = Symbol("a");
  const b = Symbol("b");

  function foo(a) { return a == b; }

  // Warmup
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(b));
  assertFalse(foo(a));
  assertTrue(foo(b));
  assertFalse(foo(a));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(b));
  // Re-prepare the function immediately to make sure type feedback isn't
  // cleared by untimely gc, as re-optimization on new feedback is tested below
  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(a));
  assertOptimized(foo);

  // Make optimized code bail out
  assertFalse(foo("a"));
  assertUnoptimized(foo);

  // Make sure TurboFan learns the new feedback
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo("a"));
  assertOptimized(foo);
})();

// Known symbol on one side abstract in-equality.
(function() {
  const a = Symbol("a");
  const b = Symbol("b");

  function foo(a) { return a != b; }

  // Warmup
  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(b));
  assertTrue(foo(a));
  assertFalse(foo(b));
  assertTrue(foo(a));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(b));
  assertTrue(foo(a));

  // Make optimized code bail out
  assertTrue(foo("a"));
  assertUnoptimized(foo);

  // Make sure TurboFan learns the new feedback
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo("a"));
  assertOptimized(foo);
})();

// Feedback based symbol abstract equality.
(function() {
  const a = Symbol("a");
  const b = Symbol("b");

  function foo(a, b) { return a == b; }

  // Warmup
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(b, b));
  assertFalse(foo(a, b));
  assertTrue(foo(a, a));
  assertFalse(foo(b, a));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(a, a));
  assertFalse(foo(b, a));

  // Make optimized code bail out
  assertFalse(foo("a", b));
  assertUnoptimized(foo);

  // Make sure TurboFan learns the new feedback
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo("a", b));
  assertOptimized(foo);
})();

// Feedback based symbol abstract in-equality.
(function() {
  const a = Symbol("a");
  const b = Symbol("b");

  function foo(a, b) { return a != b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(b, b));
  assertTrue(foo(a, b));
  assertFalse(foo(a, a));
  assertTrue(foo(b, a));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(a, a));
  assertTrue(foo(b, a));

  // Make optimized code bail out
  assertTrue(foo("a", b));
  assertUnoptimized(foo);

  // Make sure TurboFan learns the new feedback
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo("a", b));
  assertOptimized(foo);
})();
  node-23.7.0/deps/v8/test/mjsunit/compiler/abstract-equal-undetectable.js                            0000664 0000000 0000000 00000007016 14746647661 0026236 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --noalways-turbofan

const undetectable = %GetUndetectable();

// Known undetectable abstract equality.
(function() {
  const a = undetectable;
  const b = {};

  function foo() { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo());
  assertFalse(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo());
})();

// Known undetectable/null abstract equality.
(function() {
  const a = undetectable;
  const b = null;

  function foo() { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo());
  assertTrue(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo());
})();

// Known undetectable/receiver abstract equality.
(function() {
  const a = null;
  const b = undetectable;

  function foo() { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo());
  assertTrue(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo());
})();

// Known undetectable/undefined abstract equality.
(function() {
  const a = undetectable;
  const b = undefined;

  function foo() { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo());
  assertTrue(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo());
})();

// Known undefined/undetectable abstract equality.
(function() {
  const a = undefined;
  const b = undetectable;

  function foo() { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo());
  assertTrue(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo());
})();

// Known undetectable on one side strict equality with receiver.
(function() {
  const a = {};
  const b = undetectable;

  function foo(a) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(b));
  assertFalse(foo(a));
  assertTrue(foo(b));
  assertFalse(foo(a));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(b));
  assertFalse(foo(a));
})();

// Unknown undetectable on one side strict equality with receiver.
(function() {
  const a = undetectable;
  const b = {};

  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(b, b));
  assertFalse(foo(a, b));
  assertTrue(foo(a, a));
  assertFalse(foo(b, a));
  assertTrue(foo(a, null));
  assertFalse(foo(b, null));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(b, b));
  assertFalse(foo(a, b));
  assertTrue(foo(a, a));
  assertFalse(foo(b, a));
  assertTrue(foo(a, null));
  assertFalse(foo(b, null));
  assertOptimized(foo);

  // TurboFan bakes in feedback on the inputs.
  assertFalse(foo(1));
  assertUnoptimized(foo);
})();

// Unknown undetectable on both sides.
(function() {
  const a = undetectable;

  function foo(a, b) { return a == b; }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(a, a));
  assertTrue(foo(a, undefined));
  assertTrue(foo(undefined, a));
  assertFalse(foo(a, %GetUndetectable()));
  assertFalse(foo(%GetUndetectable(), a));
  assertFalse(foo(%GetUndetectable(), %GetUndetectable()));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(a, a));
  assertTrue(foo(a, undefined));
  assertTrue(foo(undefined, a));
  assertFalse(foo(a, %GetUndetectable()));
  assertFalse(foo(%GetUndetectable(), a));
  assertFalse(foo(%GetUndetectable(), %GetUndetectable()));
  assertOptimized(foo);

  // TurboFan bakes in feedback on the inputs.
  assertFalse(foo(1));
  assertUnoptimized(foo);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/compiler/accessor-exceptions1.js                                   0000664 0000000 0000000 00000000776 14746647661 0024741 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

var o = {}
Object.defineProperty(o, "x", {
  get: function() { throw 7; }
});

function foo(o) {
  var x = 1;
  try { o.x; } catch (e) { x = e; }
  return x;
}

%PrepareFunctionForOptimization(foo);
assertEquals(7, foo(o));
assertEquals(7, foo(o));
%OptimizeFunctionOnNextCall(foo);
assertEquals(7, foo(o));
  node-23.7.0/deps/v8/test/mjsunit/compiler/accessor-exceptions2.js                                   0000664 0000000 0000000 00000001003 14746647661 0024722 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

var o = {}
Object.defineProperty(o, "x", {
  set: function(v) { throw 7; }
});

function foo(o) {
  var x = 1;
  try { o.x = 2; } catch (e) { x = e; }
  return x;
}

%PrepareFunctionForOptimization(foo);
assertEquals(7, foo(o));
assertEquals(7, foo(o));
%OptimizeFunctionOnNextCall(foo);
assertEquals(7, foo(o));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/compiler/alloc-number-debug.js                                     0000664 0000000 0000000 00000003655 14746647661 0024342 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

// Try to get a GC because of a heap number allocation while we
// have live values (o) in a register.
function f(o) {
  var x = 1.5;
  var y = 2.5;
  for (var i = 1; i < 3; i += 1) {
    %SetAllocationTimeout(1, 0, false);
    o.val = x + y + i;
    %SetAllocationTimeout(-1, -1, true);
  }
  return o;
}

var o = { val: 0 };
f(o);
                                                                                   node-23.7.0/deps/v8/test/mjsunit/compiler/alloc-number.js                                           0000664 0000000 0000000 00000001137 14746647661 0023247 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --max-semi-space-size=1 --max-old-space-size=10

// This test is specific to release builds. alloc-number-debug.js
// has a fast version for debug builds.

// Try to get a GC because of a heap number allocation while we
// have live values (o) in a register.
function f(o) {
  var x = 1.5;
  var y = 2.5;
  for (var i = 1; i < 10000; i+=2) o.val = x + y + i;
  return o;
}

var o = { val: 0 };
for (var i = 0; i < 10; i++) f(o);
                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/compiler/alloc-object-huge.js                                      0000664 0000000 0000000 00000016475 14746647661 0024166 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax
// Flags: --max-inlined-bytecode-size=999999
// Flags: --max-inlined-bytecode-size-cumulative=999999

// Test that huge constructors (more than 256 this assignments) are
// handled correctly.

// Test huge constructor when being inlined into hydrogen.
function test() {
  return new huge();
}
%PrepareFunctionForOptimization(test);
test();
test();
%OptimizeFunctionOnNextCall(test);
var o = test();
assertEquals(1, o.foo1);
assertEquals(257, o.foo257);

// Test huge constructor with specialized constructor stub.
var o = new huge();
assertEquals(1, o.foo1);
assertEquals(257, o.foo257);

// The huge constructor, nothing interesting beyond this point.
function huge() {
  this.foo1 = 1;
  this.foo2 = 2;
  this.foo3 = 3;
  this.foo4 = 4;
  this.foo5 = 5;
  this.foo6 = 6;
  this.foo7 = 7;
  this.foo8 = 8;
  this.foo9 = 9;
  this.foo10 = 10;
  this.foo11 = 11;
  this.foo12 = 12;
  this.foo13 = 13;
  this.foo14 = 14;
  this.foo15 = 15;
  this.foo16 = 16;
  this.foo17 = 17;
  this.foo18 = 18;
  this.foo19 = 19;
  this.foo20 = 20;
  this.foo21 = 21;
  this.foo22 = 22;
  this.foo23 = 23;
  this.foo24 = 24;
  this.foo25 = 25;
  this.foo26 = 26;
  this.foo27 = 27;
  this.foo28 = 28;
  this.foo29 = 29;
  this.foo30 = 30;
  this.foo31 = 31;
  this.foo32 = 32;
  this.foo33 = 33;
  this.foo34 = 34;
  this.foo35 = 35;
  this.foo36 = 36;
  this.foo37 = 37;
  this.foo38 = 38;
  this.foo39 = 39;
  this.foo40 = 40;
  this.foo41 = 41;
  this.foo42 = 42;
  this.foo43 = 43;
  this.foo44 = 44;
  this.foo45 = 45;
  this.foo46 = 46;
  this.foo47 = 47;
  this.foo48 = 48;
  this.foo49 = 49;
  this.foo50 = 50;
  this.foo51 = 51;
  this.foo52 = 52;
  this.foo53 = 53;
  this.foo54 = 54;
  this.foo55 = 55;
  this.foo56 = 56;
  this.foo57 = 57;
  this.foo58 = 58;
  this.foo59 = 59;
  this.foo60 = 60;
  this.foo61 = 61;
  this.foo62 = 62;
  this.foo63 = 63;
  this.foo64 = 64;
  this.foo65 = 65;
  this.foo66 = 66;
  this.foo67 = 67;
  this.foo68 = 68;
  this.foo69 = 69;
  this.foo70 = 70;
  this.foo71 = 71;
  this.foo72 = 72;
  this.foo73 = 73;
  this.foo74 = 74;
  this.foo75 = 75;
  this.foo76 = 76;
  this.foo77 = 77;
  this.foo78 = 78;
  this.foo79 = 79;
  this.foo80 = 80;
  this.foo81 = 81;
  this.foo82 = 82;
  this.foo83 = 83;
  this.foo84 = 84;
  this.foo85 = 85;
  this.foo86 = 86;
  this.foo87 = 87;
  this.foo88 = 88;
  this.foo89 = 89;
  this.foo90 = 90;
  this.foo91 = 91;
  this.foo92 = 92;
  this.foo93 = 93;
  this.foo94 = 94;
  this.foo95 = 95;
  this.foo96 = 96;
  this.foo97 = 97;
  this.foo98 = 98;
  this.foo99 = 99;
  this.foo100 = 100;
  this.foo101 = 101;
  this.foo102 = 102;
  this.foo103 = 103;
  this.foo104 = 104;
  this.foo105 = 105;
  this.foo106 = 106;
  this.foo107 = 107;
  this.foo108 = 108;
  this.foo109 = 109;
  this.foo110 = 110;
  this.foo111 = 111;
  this.foo112 = 112;
  this.foo113 = 113;
  this.foo114 = 114;
  this.foo115 = 115;
  this.foo116 = 116;
  this.foo117 = 117;
  this.foo118 = 118;
  this.foo119 = 119;
  this.foo120 = 120;
  this.foo121 = 121;
  this.foo122 = 122;
  this.foo123 = 123;
  this.foo124 = 124;
  this.foo125 = 125;
  this.foo126 = 126;
  this.foo127 = 127;
  this.foo128 = 128;
  this.foo129 = 129;
  this.foo130 = 130;
  this.foo131 = 131;
  this.foo132 = 132;
  this.foo133 = 133;
  this.foo134 = 134;
  this.foo135 = 135;
  this.foo136 = 136;
  this.foo137 = 137;
  this.foo138 = 138;
  this.foo139 = 139;
  this.foo140 = 140;
  this.foo141 = 141;
  this.foo142 = 142;
  this.foo143 = 143;
  this.foo144 = 144;
  this.foo145 = 145;
  this.foo146 = 146;
  this.foo147 = 147;
  this.foo148 = 148;
  this.foo149 = 149;
  this.foo150 = 150;
  this.foo151 = 151;
  this.foo152 = 152;
  this.foo153 = 153;
  this.foo154 = 154;
  this.foo155 = 155;
  this.foo156 = 156;
  this.foo157 = 157;
  this.foo158 = 158;
  this.foo159 = 159;
  this.foo160 = 160;
  this.foo161 = 161;
  this.foo162 = 162;
  this.foo163 = 163;
  this.foo164 = 164;
  this.foo165 = 165;
  this.foo166 = 166;
  this.foo167 = 167;
  this.foo168 = 168;
  this.foo169 = 169;
  this.foo170 = 170;
  this.foo171 = 171;
  this.foo172 = 172;
  this.foo173 = 173;
  this.foo174 = 174;
  this.foo175 = 175;
  this.foo176 = 176;
  this.foo177 = 177;
  this.foo178 = 178;
  this.foo179 = 179;
  this.foo180 = 180;
  this.foo181 = 181;
  this.foo182 = 182;
  this.foo183 = 183;
  this.foo184 = 184;
  this.foo185 = 185;
  this.foo186 = 186;
  this.foo187 = 187;
  this.foo188 = 188;
  this.foo189 = 189;
  this.foo190 = 190;
  this.foo191 = 191;
  this.foo192 = 192;
  this.foo193 = 193;
  this.foo194 = 194;
  this.foo195 = 195;
  this.foo196 = 196;
  this.foo197 = 197;
  this.foo198 = 198;
  this.foo199 = 199;
  this.foo200 = 200;
  this.foo201 = 201;
  this.foo202 = 202;
  this.foo203 = 203;
  this.foo204 = 204;
  this.foo205 = 205;
  this.foo206 = 206;
  this.foo207 = 207;
  this.foo208 = 208;
  this.foo209 = 209;
  this.foo210 = 210;
  this.foo211 = 211;
  this.foo212 = 212;
  this.foo213 = 213;
  this.foo214 = 214;
  this.foo215 = 215;
  this.foo216 = 216;
  this.foo217 = 217;
  this.foo218 = 218;
  this.foo219 = 219;
  this.foo220 = 220;
  this.foo221 = 221;
  this.foo222 = 222;
  this.foo223 = 223;
  this.foo224 = 224;
  this.foo225 = 225;
  this.foo226 = 226;
  this.foo227 = 227;
  this.foo228 = 228;
  this.foo229 = 229;
  this.foo230 = 230;
  this.foo231 = 231;
  this.foo232 = 232;
  this.foo233 = 233;
  this.foo234 = 234;
  this.foo235 = 235;
  this.foo236 = 236;
  this.foo237 = 237;
  this.foo238 = 238;
  this.foo239 = 239;
  this.foo240 = 240;
  this.foo241 = 241;
  this.foo242 = 242;
  this.foo243 = 243;
  this.foo244 = 244;
  this.foo245 = 245;
  this.foo246 = 246;
  this.foo247 = 247;
  this.foo248 = 248;
  this.foo249 = 249;
  this.foo250 = 250;
  this.foo251 = 251;
  this.foo252 = 252;
  this.foo253 = 253;
  this.foo254 = 254;
  this.foo255 = 255;
  this.foo256 = 256;
  this.foo257 = 257;
}
                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/compiler/alloc-object.js                                           0000664 0000000 0000000 00000006455 14746647661 0023235 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

// Test that inlined object allocation works for different layouts of
// objects (e.g. in object properties, slack tracking in progress or
// changing of function prototypes)

function test_helper(construct, a, b) {
  return new construct(a, b);
}

function test(construct) {
  %DeoptimizeFunction(test);
  %PrepareFunctionForOptimization(test_helper);
  test_helper(construct, 0, 0);
  test_helper(construct, 0, 0);
  %OptimizeFunctionOnNextCall(test_helper);
  // Test adding a new property after allocation was inlined.
  var o = test_helper(construct, 1, 2);
  o.z = 3;
  assertEquals(1, o.x);
  assertEquals(2, o.y);
  assertEquals(3, o.z);
  // Test changing the prototype after allocation was inlined.
  construct.prototype = { z:6 };
  var o = test_helper(construct, 4, 5);
  assertEquals(4, o.x);
  assertEquals(5, o.y);
  assertEquals(6, o.z);
  %DeoptimizeFunction(test_helper);
  %ClearFunctionFeedback(test_helper);
}

function finalize_slack_tracking(construct) {
  // Value chosen based on kGenerousAllocationCount = 8.
  for (var i = 0; i < 8; i++) {
    new construct(0, 0);
  }
}


// Both properties are pre-allocated in object properties.
function ConstructInObjectPreAllocated(a, b) {
  this.x = a;
  this.y = b;
}
finalize_slack_tracking(ConstructInObjectPreAllocated);
test(ConstructInObjectPreAllocated);


// Both properties are unused in object properties.
function ConstructInObjectUnused(a, b) {
  this.x = a < 0 ? 0 : a;
  this.y = b > 0 ? b : 0;
}
finalize_slack_tracking(ConstructInObjectUnused);
test(ConstructInObjectUnused);


// Test inlined allocation while slack tracking is still in progress.
function ConstructWhileSlackTracking(a, b) {
  this.x = a;
  this.y = b;
}
test(ConstructWhileSlackTracking);
                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/compiler/arguments-object.js                                       0000664 0000000 0000000 00000013124 14746647661 0024137 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --noturbo-inlining

// Helper function to compare two arguments objects of strict mode functions.
// Access to arguments.callee results in TypeError for them, so assertEquals
// can't be used directly.
function assertEqualsArgumentsStrict(a, b) {
  assertEquals(JSON.stringify(a), JSON.stringify(b));
}

// Ensure that arguments in sloppy mode function works
// properly when called directly from optimized code.
(function() {
  function g() { return arguments; }
  function f() { return g(1, 2, 3); }

  %PrepareFunctionForOptimization(f);
  assertEquals(g(1, 2, 3), f());
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(f);
  assertEquals(g(1, 2, 3), f());
  %PrepareFunctionForOptimization(g);
  %OptimizeFunctionOnNextCall(g);
  assertEquals(g(1, 2, 3), f());
})();

// Ensure that arguments in strict mode function works
// properly when called directly from optimized code.
(function() {
  "use strict";
  function g() { return arguments; }
  function f() { return g(1, 2, 3); }

  %PrepareFunctionForOptimization(f);
  assertEqualsArgumentsStrict(g(1, 2, 3), f());
  assertEqualsArgumentsStrict(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(f);
  assertEqualsArgumentsStrict(g(1, 2, 3), f());
  %PrepareFunctionForOptimization(g);
  %OptimizeFunctionOnNextCall(g);
  assertEqualsArgumentsStrict(g(1, 2, 3), f());
})();

// Ensure that arguments in sloppy mode function works
// properly when called directly from optimized code,
// and the access to "arguments" is hidden inside eval().
(function() {
  function g() { return eval("arguments"); }
  function f() { return g(1, 2, 3); }

  %PrepareFunctionForOptimization(f);
  assertEquals(g(1, 2, 3), f());
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(f);
  assertEquals(g(1, 2, 3), f());
  %PrepareFunctionForOptimization(g);
  %OptimizeFunctionOnNextCall(g);
  assertEquals(g(1, 2, 3), f());
})();

// Ensure that arguments in strict mode function works
// properly when called directly from optimized code,
// and the access to "arguments" is hidden inside eval().
(function() {
  "use strict";
  function g() { return eval("arguments"); }
  function f() { return g(1, 2, 3); }

  %PrepareFunctionForOptimization(f);
  assertEqualsArgumentsStrict(g(1, 2, 3), f());
  assertEqualsArgumentsStrict(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(f);
  assertEqualsArgumentsStrict(g(1, 2, 3), f());
  %PrepareFunctionForOptimization(g);
  assertEqualsArgumentsStrict(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(g);
  assertEqualsArgumentsStrict(g(1, 2, 3), f());
})();

// Ensure that `Function.arguments` accessor does the
// right thing in sloppy mode functions called directly
// from optimized code.
(function() {
  function h() { return g.arguments; }
  function g() { return h(); }
  function f() { return g(1, 2, 3); }

  %PrepareFunctionForOptimization(f);
  assertEquals(g(1, 2, 3), f());
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(f);
  assertEquals(g(1, 2, 3), f());
  %PrepareFunctionForOptimization(g);
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(g);
  assertEquals(g(1, 2, 3), f());
})();
(function() {
  function h() { return g.arguments; }
  function g() { return h(); }
  function f() { "use strict"; return g(1, 2, 3); }

  %PrepareFunctionForOptimization(f);
  assertEquals(g(1, 2, 3), f());
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(f);
  assertEquals(g(1, 2, 3), f());
  %PrepareFunctionForOptimization(g);
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(g);
  assertEquals(g(1, 2, 3), f());
})();
(function() {
  function h() { "use strict"; return g.arguments; }
  function g() { return h(); }
  function f() { return g(1, 2, 3); }

  %PrepareFunctionForOptimization(f);
  assertEquals(g(1, 2, 3), f());
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(f);
  assertEquals(g(1, 2, 3), f());
  %PrepareFunctionForOptimization(g);
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(g);
  assertEquals(g(1, 2, 3), f());
})();
(function() {
  function h() { "use strict"; return g.arguments; }
  function g() { return h(); }
  function f() { "use strict"; return g(1, 2, 3); }

  %PrepareFunctionForOptimization(f);
  assertEquals(g(1, 2, 3), f());
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(f);
  assertEquals(g(1, 2, 3), f());
  %PrepareFunctionForOptimization(g);
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(g);
  assertEquals(g(1, 2, 3), f());
})();

// Ensure that `Function.arguments` works properly in
// combination with the `Function.caller` proper.
(function() {
  function h() { return h.caller.arguments; }
  function g() { return h(); }
  function f() { return g(1, 2, 3); }

  %PrepareFunctionForOptimization(f);
  assertEquals(g(1, 2, 3), f());
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(f);
  assertEquals(g(1, 2, 3), f());
  %PrepareFunctionForOptimization(g);
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(g);
  assertEquals(g(1, 2, 3), f());
})();
(function() {
  function h() { return h.caller.arguments; }
  function g() { return h(); }
  function f() { "use strict"; return g(1, 2, 3); }

  %PrepareFunctionForOptimization(f);
  assertEquals(g(1, 2, 3), f());
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(f);
  assertEquals(g(1, 2, 3), f());
  %PrepareFunctionForOptimization(g);
  assertEquals(g(1, 2, 3), f());
  %OptimizeFunctionOnNextCall(g);
  assertEquals(g(1, 2, 3), f());
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/compiler/array-access.js                                           0000664 0000000 0000000 00000011342 14746647661 0023243 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function Get0(a) {
  return a[0];
}

function GetN(a,n) {
  return a[n];
}

function GetA0(a) {
  return a[a[0]];
}

function GetAN(a,n) {
  return a[a[n]];
}

function GetAAN(a,n) {
  return a[a[a[n]]];
}

function RunGetTests(packed=true) {
  if (packed) {
    var a = [2,0,1];
    assertEquals(2, Get0(a));

    assertEquals(2, GetN(a, 0));
    assertEquals(0, GetN(a, 1));
    assertEquals(1, GetN(a, 2));

    assertEquals(1, GetA0(a));

    assertEquals(1, GetAN(a,0));
    assertEquals(2, GetAN(a,1));
    assertEquals(0, GetAN(a,2));

    assertEquals(0, GetAAN(a,0));
    assertEquals(1, GetAAN(a,1));
    assertEquals(2, GetAAN(a,2));
  } else {
    var a = ['2','0','1'];
    assertEquals('2', Get0(a));

    assertEquals('2', GetN(a, 0));
    assertEquals('0', GetN(a, 1));
    assertEquals('1', GetN(a, 2));

    assertEquals('1', GetA0(a));

    assertEquals('1', GetAN(a,0));
    assertEquals('2', GetAN(a,1));
    assertEquals('0', GetAN(a,2));

    assertEquals('0', GetAAN(a,0));
    assertEquals('1', GetAAN(a,1));
    assertEquals('2', GetAAN(a,2));
  }
}


function Set07(a) {
  a[0] = 7;
}

function Set0V(a, v) {
  a[0] = v;
}

function SetN7(a, n) {
  a[n] = 7;
}

function SetNX(a, n, x) {
  a[n] = x;
}

function RunSetTests(a, packed=true) {
  Set07(a);
  if (packed) {
    assertEquals(7, a[0]);
  }
  assertEquals(0, a[1]);
  assertEquals(0, a[2]);

  Set0V(a, 1);
  if (packed) {
    assertEquals(1, a[0]);
  }
  assertEquals(0, a[1]);
  assertEquals(0, a[2]);

  SetN7(a, 2);
  if (packed) {
    assertEquals(1, a[0]);
  }
  assertEquals(0, a[1]);
  assertEquals(7, a[2]);

  SetNX(a, 1, 5);
  if (packed) {
    assertEquals(1, a[0]);
  }
  assertEquals(5, a[1]);
  assertEquals(7, a[2]);

  for (var i = 0; i < 3; i++) SetNX(a, i, 0);
  if (packed) {
    assertEquals(0, a[0]);
  }
  assertEquals(0, a[1]);
  assertEquals(0, a[2]);
}

function RunArrayBoundsCheckTest() {
  var g = [1,2,3];

  function f(a, i) { a[i] = 42; }

  for (var i = 0; i < 100000; i++) { f(g, 0); }

  f(g, 4);

  assertEquals(42, g[0]);
  assertEquals(42, g[4]);
}

var a = [0,0,0];
var o = {0: 0, 1: 0, 2: 0};
for (var i = 0; i < 1000; i++) {
  RunGetTests();
  RunSetTests(a);
  RunSetTests(o);
}

RunArrayBoundsCheckTest();

// Packed
// Non-extensible
a = Object.preventExtensions([0,0,0,'a']);
o = Object.preventExtensions({0: 0, 1: 0, 2: 0});
for (var i = 0; i < 1000; i++) {
  RunGetTests();
  RunGetTests(false);
  RunSetTests(a);
  RunSetTests(o);
}

// Sealed
a = Object.seal([0,0,0,'a']);
o = Object.seal({0: 0, 1: 0, 2: 0});
for (var i = 0; i < 1000; i++) {
  RunGetTests();
  RunGetTests(false);
  RunSetTests(a);
  RunSetTests(o);
}

// Frozen
a = Object.freeze([0,0,0,'a']);
o = Object.freeze({0: 0, 1: 0, 2: 0});
for (var i = 0; i < 1000; i++) {
  RunGetTests();
  RunGetTests(false);
}

// Holey
// Non-extensible
a = Object.preventExtensions([,0,0,'a']);
for (var i = 0; i < 1000; i++) {
  RunGetTests();
  RunGetTests(false);
  RunSetTests(a, false);
}

// Sealed
a = Object.seal([,0,0,'a']);
for (var i = 0; i < 1000; i++) {
  RunGetTests();
  RunGetTests(false);
  RunSetTests(a, false);
}

// Frozen
a = Object.freeze([,0,0,'a']);
for (var i = 0; i < 1000; i++) {
  RunGetTests();
  RunGetTests(false);
}
                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/compiler/array-buffer-is-view.js                                   0000664 0000000 0000000 00000004250 14746647661 0024634 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan

// Test that ObjectIsArrayBufferView lowering works correctly
// in EffectControlLinearizer in the case that the input is
// known to be a HeapObject by TurboFan. For this we use the
// simple trick with an object literal whose field `x` will
// only ever contain HeapObjects and so the representation
// tracking is going to pick it up.
(function() {
  function foo(x) {
    return ArrayBuffer.isView({x}.x);
  }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(Symbol()));
  assertFalse(foo("some string"));
  assertFalse(foo(new Object()));
  assertFalse(foo(new Array()));
  assertFalse(foo(new ArrayBuffer(1)));
  assertTrue(foo(new Int32Array(1)));
  assertTrue(foo(new DataView(new ArrayBuffer(1))));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(Symbol()));
  assertFalse(foo("some string"));
  assertFalse(foo(new Object()));
  assertFalse(foo(new Array()));
  assertFalse(foo(new ArrayBuffer(1)));
  assertTrue(foo(new Int32Array(1)));
  assertTrue(foo(new DataView(new ArrayBuffer(1))));
  assertOptimized(foo);
})();

// Test that ObjectIsArrayBufferView lowering works correctly
// in EffectControlLinearizer in the case that the input is
// some arbitrary tagged value.
(function() {
  function foo(x) {
    return ArrayBuffer.isView(x);
  }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(1));
  assertFalse(foo(1.1));
  assertFalse(foo(Symbol()));
  assertFalse(foo("some string"));
  assertFalse(foo(new Object()));
  assertFalse(foo(new Array()));
  assertFalse(foo(new ArrayBuffer(1)));
  assertTrue(foo(new Int32Array(1)));
  assertTrue(foo(new DataView(new ArrayBuffer(1))));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(1));
  assertFalse(foo(1.1));
  assertFalse(foo(Symbol()));
  assertFalse(foo("some string"));
  assertFalse(foo(new Object()));
  assertFalse(foo(new Array()));
  assertFalse(foo(new ArrayBuffer(1)));
  assertTrue(foo(new Int32Array(1)));
  assertTrue(foo(new DataView(new ArrayBuffer(1))));
  assertOptimized(foo);
})();
                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/compiler/array-constructor.js                                      0000664 0000000 0000000 00000013414 14746647661 0024371 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

// Test Array call with known Boolean.
(() => {
  function foo(x) { return Array(!!x); }

  %PrepareFunctionForOptimization(foo);
  assertEquals([true], foo(true));
  assertEquals([false], foo(false));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals([true], foo(true));
  assertEquals([false], foo(false));
})();

// Test Array construct with known Boolean.
(() => {
  function foo(x) { return new Array(!!x); }

  %PrepareFunctionForOptimization(foo);
  assertEquals([true], foo(true));
  assertEquals([false], foo(false));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals([true], foo(true));
  assertEquals([false], foo(false));
})();

// Test Array call with known String.
(() => {
  function foo(x) { return Array("" + x); }

  %PrepareFunctionForOptimization(foo);
  assertEquals(["a"], foo("a"));
  assertEquals(["b"], foo("b"));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(["a"], foo("a"));
  assertEquals(["b"], foo("b"));
})();

// Test Array construct with known String.
(() => {
  function foo(x) { return new Array("" + x); }

  %PrepareFunctionForOptimization(foo);
  assertEquals(["a"], foo("a"));
  assertEquals(["b"], foo("b"));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(["a"], foo("a"));
  assertEquals(["b"], foo("b"));
})();

// Test Array call with known fixed small integer.
(() => {
  function foo() { return Array(2); }

  %PrepareFunctionForOptimization(foo);
  assertEquals(2, foo().length);
  assertEquals(2, foo().length);
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(2, foo().length);
})();

// Test Array construct with known fixed small integer.
(() => {
  function foo() { return new Array(2); }

  %PrepareFunctionForOptimization(foo);
  assertEquals(2, foo().length);
  assertEquals(2, foo().length);
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(2, foo().length);
})();

// Test Array call with multiple parameters.
(() => {
  function foo(x, y, z) { return Array(x, y, z); }

  %PrepareFunctionForOptimization(foo);
  assertEquals([1, 2, 3], foo(1, 2, 3));
  assertEquals([1, 2, 3], foo(1, 2, 3));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals([1, 2, 3], foo(1, 2, 3));
})();

// Test Array construct with multiple parameters.
(() => {
  function foo(x, y, z) { return new Array(x, y, z); }

  %PrepareFunctionForOptimization(foo);
  assertEquals([1, 2, 3], foo(1, 2, 3));
  assertEquals([1, 2, 3], foo(1, 2, 3));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals([1, 2, 3], foo(1, 2, 3));
})();

// Test Array construct inside try-catch block.
(() => {
  function foo(x) { try { return new Array(x) } catch (e) { return e } }

  %PrepareFunctionForOptimization(foo);
  assertEquals([], foo(0));
  assertEquals([], foo(0));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals([], foo(0));
  assertInstanceof(foo(-1), RangeError);
})();

// Packed
// Test non-extensible Array call with multiple parameters.
(() => {
  function foo(x, y, z, t) { return Object.preventExtensions(new Array(x, y, z, t)); }

  %PrepareFunctionForOptimization(foo);
  assertEquals([1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertEquals([1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertFalse(Object.isExtensible(foo(1,2,3, 'a')));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals([1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertFalse(Object.isExtensible(foo(1,2,3, 'a')));
})();

// Test sealed Array call with multiple parameters.
(() => {
  function foo(x, y, z, t) { return Object.seal(new Array(x, y, z, t)); }

  %PrepareFunctionForOptimization(foo);
  assertEquals([1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertEquals([1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertTrue(Object.isSealed(foo(1,2,3, 'a')));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals([1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertTrue(Object.isSealed(foo(1,2,3, 'a')));
})();

// Test frozen Array call with multiple parameters.
(() => {
  function foo(x, y, z, t) { return Object.freeze(new Array(x, y, z, t)); }

  %PrepareFunctionForOptimization(foo);
  assertEquals([1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertEquals([1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertTrue(Object.isFrozen(foo(1,2,3, 'a')));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals([1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertTrue(Object.isFrozen(foo(1,2,3, 'a')));
})();

// Holey
// Test non-extensible Array call with multiple parameters.
(() => {
  function foo(x, y, z, t) { return Object.preventExtensions([, x, y, z, t]); }

  %PrepareFunctionForOptimization(foo);
  assertEquals([, 1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertEquals([, 1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertFalse(Object.isExtensible(foo(1,2,3, 'a')));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals([, 1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertFalse(Object.isExtensible(foo(1,2,3, 'a')));
})();

// Test sealed Array call with multiple parameters.
(() => {
  function foo(x, y, z, t) { return Object.seal([, x, y, z, t]); }

  %PrepareFunctionForOptimization(foo);
  assertEquals([, 1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertEquals([, 1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertTrue(Object.isSealed(foo(1,2,3, 'a')));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals([, 1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertTrue(Object.isSealed(foo(1,2,3, 'a')));
})();

// Test frozen Array call with multiple parameters.
(() => {
  function foo(x, y, z, t) { return Object.freeze([, x, y, z, t]); }

  %PrepareFunctionForOptimization(foo);
  assertEquals([, 1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertEquals([, 1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertTrue(Object.isFrozen(foo(1,2,3, 'a')));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals([, 1, 2, 3, 'a'], foo(1, 2, 3, 'a'));
  assertTrue(Object.isFrozen(foo(1,2,3, 'a')));
})();
                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/compiler/array-every.js                                            0000664 0000000 0000000 00000005253 14746647661 0023140 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

// Basic loop peeling test case with Array.prototype.every().
(function() {
  function foo(a, o) {
    return a.every(x => x === o.x);
  }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo([3, 3, 3], {x:3}));
  assertFalse(foo([3, 3, 2], {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo([3, 3, 3], {x:3}));
  assertFalse(foo([3, 3, 2], {x:3}));

  // Packed
  // Non-extensible array
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(Object.preventExtensions(['3', '3', '3']), {x:'3'}));
  assertFalse(foo(Object.preventExtensions(['3', '3', '2']), {x:'3'}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(Object.preventExtensions(['3', '3', '3']), {x:'3'}));
  assertFalse(foo(Object.preventExtensions(['3', '3', '2']), {x:'3'}));

  // Sealed array
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(Object.seal(['3', '3', '3']), {x:'3'}));
  assertFalse(foo(Object.seal(['3', '3', '2']), {x:'3'}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(Object.seal(['3', '3', '3']), {x:'3'}));
  assertFalse(foo(Object.seal(['3', '3', '2']), {x:'3'}));

  // Frozen array
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(Object.freeze(['3', '3', '3']), {x:'3'}));
  assertFalse(foo(Object.freeze(['3', '3', '2']), {x:'3'}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(Object.freeze(['3', '3', '3']), {x:'3'}));
  assertFalse(foo(Object.freeze(['3', '3', '2']), {x:'3'}));

  // Holey
  // Non-extensible array
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(Object.preventExtensions([, '3', '3', '3']), {x:'3'}));
  assertFalse(foo(Object.preventExtensions([, '3', '3', '2']), {x:'3'}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(Object.preventExtensions([, '3', '3', '3']), {x:'3'}));
  assertFalse(foo(Object.preventExtensions([, '3', '3', '2']), {x:'3'}));

  // Sealed array
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(Object.seal([, '3', '3', '3']), {x:'3'}));
  assertFalse(foo(Object.seal([, '3', '3', '2']), {x:'3'}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(Object.seal([, '3', '3', '3']), {x:'3'}));
  assertFalse(foo(Object.seal([, '3', '3', '2']), {x:'3'}));

  // Frozen array
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(Object.freeze([, '3', '3', '3']), {x:'3'}));
  assertFalse(foo(Object.freeze([, '3', '3', '2']), {x:'3'}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(Object.freeze([, '3', '3', '3']), {x:'3'}));
  assertFalse(foo(Object.freeze([, '3', '3', '2']), {x:'3'}));
})();
                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/compiler/array-find.js                                             0000664 0000000 0000000 00000005333 14746647661 0022725 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

// Basic loop peeling test case with Array.prototype.find().
(function() {
  function foo(a, o) {
    return a.find(x => x === o.x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(3, foo([1, 2, 3], {x:3}));
  assertEquals(undefined, foo([0, 1, 2], {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(3, foo([1, 2, 3], {x:3}));
  assertEquals(undefined, foo([0, 1, 2], {x:3}));

  // Packed
  // Non-extensible
  %PrepareFunctionForOptimization(foo);
  assertEquals(3, foo(Object.preventExtensions(['1', 2, 3]), {x:3}));
  assertEquals(undefined, foo(Object.preventExtensions(['0', 1, 2]), {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(3, foo(Object.preventExtensions(['1', 2, 3]), {x:3}));
  assertEquals(undefined, foo(Object.preventExtensions(['0', 1, 2]), {x:3}));

  // Sealed
  %PrepareFunctionForOptimization(foo);
  assertEquals(3, foo(Object.seal(['1', 2, 3]), {x:3}));
  assertEquals(undefined, foo(Object.seal(['0', 1, 2]), {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(3, foo(Object.seal(['1', 2, 3]), {x:3}));
  assertEquals(undefined, foo(Object.seal(['0', 1, 2]), {x:3}));

  // Frozen
  %PrepareFunctionForOptimization(foo);
  assertEquals(3, foo(Object.freeze(['1', 2, 3]), {x:3}));
  assertEquals(undefined, foo(Object.freeze(['0', 1, 2]), {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(3, foo(Object.freeze(['1', 2, 3]), {x:3}));
  assertEquals(undefined, foo(Object.freeze(['0', 1, 2]), {x:3}));

  // Holey
  // Non-extensible
  %PrepareFunctionForOptimization(foo);
  assertEquals(3, foo(Object.preventExtensions([, '1', 2, 3]), {x:3}));
  assertEquals(undefined, foo(Object.preventExtensions([, '0', 1, 2]), {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(3, foo(Object.preventExtensions([, '1', 2, 3]), {x:3}));
  assertEquals(undefined, foo(Object.preventExtensions([, '0', 1, 2]), {x:3}));

  // Sealed
  %PrepareFunctionForOptimization(foo);
  assertEquals(3, foo(Object.seal([, '1', 2, 3]), {x:3}));
  assertEquals(undefined, foo(Object.seal([, '0', 1, 2]), {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(3, foo(Object.seal([, '1', 2, 3]), {x:3}));
  assertEquals(undefined, foo(Object.seal([, '0', 1, 2]), {x:3}));

  // Frozen
  %PrepareFunctionForOptimization(foo);
  assertEquals(3, foo(Object.freeze([, 1, 2, 3]), {x:3}));
  assertEquals(undefined, foo(Object.freeze([, 0, 1, 2]), {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(3, foo(Object.freeze([, 1, 2, 3]), {x:3}));
  assertEquals(undefined, foo(Object.freeze([, 0, 1, 2]), {x:3}));
})();
                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/compiler/array-findindex.js                                        0000664 0000000 0000000 00000005213 14746647661 0023752 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

// Basic loop peeling test case with Array.prototype.findIndex().
(function() {
  function foo(a, o) {
    return a.findIndex(x => x === o.x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(2, foo([1, 2, 3], {x:3}));
  assertEquals(-1, foo([0, 1, 2], {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(2, foo([1, 2, 3], {x:3}));
  assertEquals(-1, foo([0, 1, 2], {x:3}));

  // Packed
  // Non-extensible
  %PrepareFunctionForOptimization(foo);
  assertEquals(2, foo(Object.preventExtensions(['1', 2, 3]), {x:3}));
  assertEquals(-1, foo(Object.preventExtensions(['0', 1, 2]), {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(2, foo(Object.preventExtensions(['1', 2, 3]), {x:3}));
  assertEquals(-1, foo(Object.preventExtensions(['0', 1, 2]), {x:3}));

  // Sealed
  %PrepareFunctionForOptimization(foo);
  assertEquals(2, foo(Object.seal(['1', 2, 3]), {x:3}));
  assertEquals(-1, foo(Object.seal(['0', 1, 2]), {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(2, foo(Object.seal(['1', 2, 3]), {x:3}));
  assertEquals(-1, foo(Object.seal(['0', 1, 2]), {x:3}));

  // Frozen
  %PrepareFunctionForOptimization(foo);
  assertEquals(2, foo(Object.freeze(['1', 2, 3]), {x:3}));
  assertEquals(-1, foo(Object.freeze(['0', 1, 2]), {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(2, foo(Object.freeze(['1', 2, 3]), {x:3}));
  assertEquals(-1, foo(Object.freeze(['0', 1, 2]), {x:3}));

  // Holey
  // Non-extensible
  %PrepareFunctionForOptimization(foo);
  assertEquals(3, foo(Object.preventExtensions([, '1', 2, 3]), {x:3}));
  assertEquals(-1, foo(Object.preventExtensions([, '0', 1, 2]), {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(3, foo(Object.preventExtensions([, '1', 2, 3]), {x:3}));
  assertEquals(-1, foo(Object.preventExtensions([, '0', 1, 2]), {x:3}));

  // Sealed
  %PrepareFunctionForOptimization(foo);
  assertEquals(3, foo(Object.seal([, '1', 2, 3]), {x:3}));
  assertEquals(-1, foo(Object.seal([, '0', 1, 2]), {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(3, foo(Object.seal([, '1', 2, 3]), {x:3}));
  assertEquals(-1, foo(Object.seal([, '0', 1, 2]), {x:3}));

  // Frozen
  %PrepareFunctionForOptimization(foo);
  assertEquals(3, foo(Object.freeze([, '1', 2, 3]), {x:3}));
  assertEquals(-1, foo(Object.freeze([, '0', 1, 2]), {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(3, foo(Object.freeze([, '1', 2, 3]), {x:3}));
  assertEquals(-1, foo(Object.freeze([, '0', 1, 2]), {x:3}));
})();
                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/compiler/array-is-array.js                                         0000664 0000000 0000000 00000011650 14746647661 0023533 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

// Test JSObjectIsArray in JSTypedLowering for the case that the
// input value is known to be an Array literal.
(function() {
  function foo() {
    return Array.isArray([]);
  }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo());
  assertTrue(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo());
})();

// Test JSObjectIsArray in JSTypedLowering for the case that the
// input value is known to be a Proxy for an Array literal.
(function() {
  function foo() {
    return Array.isArray(new Proxy([], {}));
  }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo());
  assertTrue(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo());
})();

// Test JSObjectIsArray in JSTypedLowering for the case that the
// input value is known to be an Object literal.
(function() {
  function foo() {
    return Array.isArray({});
  }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo());
  assertFalse(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo());
})();

// Test JSObjectIsArray in JSTypedLowering for the case that the
// input value is known to be a Proxy for an Object literal.
(function() {
  function foo() {
    return Array.isArray(new Proxy({}, {}));
  }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo());
  assertFalse(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo());
})();

// Test JSObjectIsArray in JSTypedLowering for the case that
// TurboFan doesn't know anything about the input value.
(function() {
  function foo(x) {
    return Array.isArray(x);
  }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo({}));
  assertFalse(foo(new Proxy({}, {})));
  assertTrue(foo([]));
  assertTrue(foo(new Proxy([], {})));
  assertThrows(() => {
    const {proxy, revoke} = Proxy.revocable([], {});
    revoke();
    foo(proxy);
  }, TypeError);
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo({}));
  assertFalse(foo(new Proxy({}, {})));
  assertTrue(foo([]));
  assertTrue(foo(new Proxy([], {})));
  assertThrows(() => {
    const {proxy, revoke} = Proxy.revocable([], {});
    revoke();
    foo(proxy);
  }, TypeError);
})();

// Test JSObjectIsArray in JSTypedLowering for the case that
// we pass a revoked proxy and catch the exception locally.
(function() {
  function foo(x) {
    const {proxy, revoke} = Proxy.revocable(x, {});
    revoke();
    try {
      return Array.isArray(proxy);
    } catch (e) {
      return e;
    }
  }

  %PrepareFunctionForOptimization(foo);
  assertInstanceof(foo([]), TypeError);
  assertInstanceof(foo({}), TypeError);
  %OptimizeFunctionOnNextCall(foo);
  assertInstanceof(foo([]), TypeError);
  assertInstanceof(foo({}), TypeError);
})();

// Packed
// Test JSObjectIsArray in JSTypedLowering for the case that the
// input value is known to be a non-extensible Array literal.
(function() {
  function foo() {
    return Array.isArray(Object.preventExtensions([]));
  }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo());
  assertTrue(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo());
})();

// Test JSObjectIsArray in JSTypedLowering for the case that the
// input value is known to be a sealed Array literal.
(function() {
  function foo() {
    return Array.isArray(Object.seal([]));
  }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo());
  assertTrue(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo());
})();

// Test JSObjectIsArray in JSTypedLowering for the case that the
// input value is known to be a frozen Array literal.
(function() {
  function foo() {
    return Array.isArray(Object.freeze([]));
  }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo());
  assertTrue(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo());
})();

// Holey
// Test JSObjectIsArray in JSTypedLowering for the case that the
// input value is known to be a non-extensible Array literal.
(function() {
  function foo() {
    return Array.isArray(Object.preventExtensions([,]));
  }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo());
  assertTrue(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo());
})();

// Test JSObjectIsArray in JSTypedLowering for the case that the
// input value is known to be a sealed Array literal.
(function() {
  function foo() {
    return Array.isArray(Object.seal([,]));
  }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo());
  assertTrue(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo());
})();

// Test JSObjectIsArray in JSTypedLowering for the case that the
// input value is known to be a frozen Array literal.
(function() {
  function foo() {
    return Array.isArray(Object.freeze([,]));
  }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo());
  assertTrue(foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo());
})();
                                                                                        node-23.7.0/deps/v8/test/mjsunit/compiler/array-length.js                                           0000664 0000000 0000000 00000006105 14746647661 0023264 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

function ArrayLength(a) { return a.length; }

function Test(a0, a2, a5) {
  assertEquals(0, ArrayLength(a0));
  assertEquals(2, ArrayLength(a2));
  assertEquals(5, ArrayLength(a5));
}

var a0 = [];
var a2 = [1,2];
var a5 = [1,2,3,4,5];

function MainTest() {
  %PrepareFunctionForOptimization(ArrayLength);
  for (var i = 0; i < 5; i++) Test(a0, a2, a5);
  %OptimizeFunctionOnNextCall(ArrayLength);
  Test(a0, a2, a5);
  %PrepareFunctionForOptimization(Test);
  %OptimizeFunctionOnNextCall(Test);
  Test(a0, a2, a5);
  assertEquals("undefined", typeof(ArrayLength(0)));
  %PrepareFunctionForOptimization(Test);
  for (var i = 0; i < 5; i++) Test(a0, a2, a5);
  %OptimizeFunctionOnNextCall(Test);
  Test(a0, a2, a5);
  assertEquals(4, ArrayLength("hest"));
}
MainTest();

// Packed
// Non-extensible, sealed, frozen
a0 = Object.preventExtensions([]);
a2 = Object.seal([1,'2']);
a5 = Object.freeze([1,2,'3',4,5]);
MainTest();

a0 = Object.seal([]);
a2 = Object.freeze([1,'2']);
a5 = Object.preventExtensions([1,2,'3',4,5]);
MainTest();

a0 = Object.freeze([]);
a2 = Object.preventExtensions([1,'2']);
a5 = Object.seal([1,2,'3',4,5]);
MainTest();

// Holey
// Non-extensible, sealed, frozen
a0 = Object.preventExtensions([]);
a2 = Object.seal([,'2']);
a5 = Object.freeze([,2,'3',4,5]);
MainTest();

a0 = Object.seal([]);
a2 = Object.freeze([,'2']);
a5 = Object.preventExtensions([,2,'3',4,5]);
MainTest();

a0 = Object.freeze([]);
a2 = Object.preventExtensions([,'2']);
a5 = Object.seal([,2,3,4,5]);
MainTest();
                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/compiler/array-multiple-receiver-maps.js                           0000664 0000000 0000000 00000016124 14746647661 0026400 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan
// Flags: --no-stress-background-compile --trace-opt --trace-deopt

let id = 0;

function runTest(f, message, mkICTraining, deoptArg, speculationCheck) {
  function test(f, message, ictraining, deoptArg, speculationCheck) {
    // Train the call ic to the maps.
    let t = ictraining;

    // We put the training data into local variables
    // to ensure their maps are kepts alive. If the
    // maps die, gc *may* deoptimize {f}, which makes
    // the test flaky.
    let t1 = t();
    let t2 = t();
    let t3 = t();

    %PrepareFunctionForOptimization(f);
    for (let a of t1) {
      f(a.arr, () => a.el);
    }
    for (let a of t2) {
      f(a.arr, () => a.el);
    }
    %OptimizeFunctionOnNextCall(f);
    message += " trained with" + JSON.stringify(t());
    if (deoptArg == undefined) {
      // Make sure the optimized function can handle
      // all trained maps without deopt.
      for (let a of t3) {
        message += " for args " + JSON.stringify(a) + " should have been optimized";
        f(a.arr, () => a.el);
        assertOptimized(f, message);
      }
    } else {
      // Trigger deopt, causing no-speculation bit to be set.
      let a1 = deoptArg;
      let a2 = deoptArg;
      let a3 = deoptArg;
      message += " for args " + JSON.stringify(a1);
      message_unoptimized = message + " should have been unoptimized"
      message_optimized = message + " should have been optimized"
      f(a1.darr, () => a1.del);
      assertUnoptimized(f, message_unoptimized);
      if (speculationCheck) {
        %PrepareFunctionForOptimization(f);
        %OptimizeFunctionOnNextCall(f);
        f(a2.darr, () => a2.del);
        assertUnoptimized(f, message_unoptimized);
      }
      %PrepareFunctionForOptimization(f);
      %OptimizeFunctionOnNextCall(f);
      // No speculation should protect against further deopts.
      f(a3.darr, () => a3.del);
      assertOptimized(f,  message_optimized);
    }
  }

  // Get function as a string.
  var testString = test.toString();
  // Remove the function header..
  testString = testString.replace(new RegExp("[^\n]*"), "let f = " + f.toString() + ";");
  // ..and trailing '}'.
  testString = testString.replace(new RegExp("[^\n]*$"), "");
  // Substitute parameters.
  testString = testString.replace(new RegExp("ictraining", 'g'), mkICTraining.toString());
  testString = testString.replace(new RegExp("deoptArg", 'g'),
    deoptArg ? JSON.stringify(deoptArg).replace(/"/g,'') : "undefined");
  testString = testString.replace(new RegExp("speculationCheck", 'g'),
    speculationCheck ? JSON.stringify(deoptArg).replace(/"/g,'') : "undefined");

  // Make field names unique to avoid learning of types.
  id = id + 1;
  testString = testString.replace(/[.]el/g, '.el' + id);
  testString = testString.replace(/el:/g, 'el' + id + ':');
  testString = testString.replace(/[.]arr/g, '.arr' + id);
  testString = testString.replace(/arr:/g, 'arr' + id + ':');
  testString = testString.replace(/[.]del/g, '.del' + id);
  testString = testString.replace(/[.]darr/g, '.darr' + id);

  var modTest = new Function("message", testString);
  modTest(message);
}

let checks = {
  smiReceiver:
    { mkTrainingArguments : () => [{arr:[1], el:3}],
      deoptingArguments   : [{darr:[0.1], del:1}, {darr:[{}], del:1}]
    },
  objectReceiver:
    { mkTrainingArguments : () => [{arr:[{}], el:0.1}],
      deoptingArguments : []
    },
  multipleSmiReceivers:
    { mkTrainingArguments : () => { let b = [1]; b.x=3; return [{arr:[1], el:3}, {arr:b, el:3}] },
      deoptingArguments : [{darr:[0.1], del:1}, {darr:[{}], del:1}]
    },
  multipleSmiReceiversPackedUnpacked:
    { mkTrainingArguments : () => { let b = [1]; b[100] = 3; return [{arr:[1], el:3}, {arr:b, el:3}] },
      deoptingArguments : [{darr:[0.1], del:1}, {darr:[{}], del:1}]
    },
  multipleDoubleReceivers:
    { mkTrainingArguments : () => { let b = [0.1]; b.x=0.3; return [{arr:[0.1], el:0.3}, {arr:b, el:0.3}] },
      deoptingArguments : [{darr:[{}], del:true}, {darr:[1], del: 1}]
    },
  multipleDoubleReceiversPackedUnpacked:
    { mkTrainingArguments : () => { let b = [0.1]; b[100] = 0.3; return [{arr:[0.1], el:0.3}, {arr:b, el:0.3}] },
      deoptingArguments : [{darr:[{}], del:true}, {darr:[1], del: 1}]
    },
  multipleMixedReceivers:
    { mkTrainingArguments : () => { let b = [0.1]; b.x=0.3; return [{arr:[1], el:1}, {arr:[{}], el:true}, {arr:b, el:0.3}] },
      deoptingArguments : []
    },
  multipleMixedReceiversPackedUnpacked:
    { mkTrainingArguments : () => { let b = [0.1]; b[100] = 0.3; return [{arr:[1], el:1}, {arr:[{}], el:true}, {arr:b, el:0.3}] },
      deoptingArguments : []
    },
};

let no_speculation_checks = {
  smiReceiver:
    { mkTrainingArguments : () => [{arr:[1], el:3}],
      deoptingArguments   : [{darr:[0.1], del:true}]
    },
  multipleSmiReceivers:
    { mkTrainingArguments : () => { let b = [1]; b.x=3; return [{arr:[1], el:3}, {arr:[1], el:3}] },
      deoptingArguments : [{darr:[0.1], del:true}]
    },
  multipleSmiReceiversPackedUnpacked:
    { mkTrainingArguments : () => { let b = [1]; b[100] = 3; return [{arr:[1], el:3}, {arr:b, el:3}] },
      deoptingArguments : [{darr:[0.1], del:true}]
    },
  multipleDoubleReceivers:
    { mkTrainingArguments : () => { let b = [0.1]; b.x=0.3; return [{arr:[0.1], el:0.3}, {arr:b, el:0.3}] },
      deoptingArguments : [{darr:[1], del:true}]
    },
  multipleDoubleReceiversPackedUnpacked:
    { mkTrainingArguments : () => { let b = [0.1]; b[100] = 0.3; return [{arr:[0.1], el:0.3}, {arr:b, el:0.3}] },
      deoptingArguments : [{darr:[1], del:true}]
    },
};

const functions = {
  push_reliable: (a,g) => { let b = g(); return a.push(2, b); },
  push_unreliable: (a,g) => { return a.push(2, g()); },
  pop_reliable: (a,g) => { let b = g(); return a.pop(2, b); },
  pop_unreliable: (a,g) => { return a.pop(2, g()); },
  shift_reliable: (a,g) => { let b = g(); return a.shift(2, b); },
  shift_unreliable: (a,g) => { return a.shift(2, g()); }
}

const push_functions = {
  push_reliable: (a,g) => { let b = g(); return a.push(2, b); },
  push_unreliable: (a,g) => { return a.push(2, g()); },
}

Object.keys(checks).forEach(
  key => {
    let check = checks[key];

    for (fnc in functions) {
      runTest(functions[fnc], "test-" + fnc + "-" + key, check.mkTrainingArguments);
      // Test each deopting arg separately.
      for (let deoptArg of check.deoptingArguments) {
        runTest(functions[fnc], "testDeopt-" + fnc + "-" + key, check.mkTrainingArguments, deoptArg);
      }
    }
  }
);

Object.keys(no_speculation_checks).forEach(
  key => {
    let check = no_speculation_checks[key];

    for (fnc in push_functions) {
      runTest(functions[fnc], "test-spec-check-" + fnc + "-" + key, check.mkTrainingArguments);
      // Test each deopting arg separately.
      for (let deoptArg of check.deoptingArguments) {
        runTest(functions[fnc], "testDeopt-spec-check-" + fnc + "-" + key, check.mkTrainingArguments, deoptArg, true);
      }
    }
  }
);
                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/compiler/array-push-1.js                                           0000664 0000000 0000000 00000014731 14746647661 0023124 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan

// Test multiple arguments push for PACKED_SMI_ELEMENTS.
(function() {
  function push0(a) {
    return a.push();
  }

  %PrepareFunctionForOptimization(push0);
  assertEquals(0, push0([]));
  assertEquals(1, push0([1]));
  %OptimizeFunctionOnNextCall(push0);
  assertEquals(2, push0([1, 2]));

  function push1(a) {
    return a.push(1);
  }

  %PrepareFunctionForOptimization(push1);
  assertEquals(1, push1([]));
  assertEquals(2, push1([1]));
  %OptimizeFunctionOnNextCall(push1);
  assertEquals(3, push1([1, 2]));

  function push2(a) {
    return a.push(1, 2);
  }

  %PrepareFunctionForOptimization(push2);
  assertEquals(2, push2([]));
  assertEquals(3, push2([1]));
  %OptimizeFunctionOnNextCall(push2);
  assertEquals(4, push2([1, 2]));

  function push3(a) {
    return a.push(1, 2, 3);
  }

  %PrepareFunctionForOptimization(push3);
  assertEquals(3, push3([]));
  assertEquals(4, push3([1]));
  %OptimizeFunctionOnNextCall(push3);
  assertEquals(5, push3([1, 2]));
})();

// Test multiple arguments push for HOLEY_SMI_ELEMENTS.
(function() {
  function push0(a) {
    return a.push();
  }

  %PrepareFunctionForOptimization(push0);
  assertEquals(1, push0(new Array(1)));
  assertEquals(2, push0(new Array(2)));
  %OptimizeFunctionOnNextCall(push0);
  assertEquals(3, push0(new Array(3)));

  function push1(a) {
    return a.push(1);
  }

  %PrepareFunctionForOptimization(push1);
  assertEquals(2, push1(new Array(1)));
  assertEquals(3, push1(new Array(2)));
  %OptimizeFunctionOnNextCall(push1);
  assertEquals(4, push1(new Array(3)));

  function push2(a) {
    return a.push(1, 2);
  }

  %PrepareFunctionForOptimization(push2);
  assertEquals(3, push2(new Array(1)));
  assertEquals(4, push2(new Array(2)));
  %OptimizeFunctionOnNextCall(push2);
  assertEquals(5, push2(new Array(3)));

  function push3(a) {
    return a.push(1, 2, 3);
  }

  %PrepareFunctionForOptimization(push3);
  assertEquals(4, push3(new Array(1)));
  assertEquals(5, push3(new Array(2)));
  %OptimizeFunctionOnNextCall(push3);
  assertEquals(6, push3(new Array(3)));
})();

// Test multiple arguments push for PACKED_DOUBLE_ELEMENTS.
(function() {
  function push0(a) {
    return a.push();
  }

  %PrepareFunctionForOptimization(push0);
  assertEquals(1, push0([1.1]));
  assertEquals(2, push0([1.1, 2.2]));
  %OptimizeFunctionOnNextCall(push0);
  assertEquals(3, push0([1.1, 2.2, 3.3]));

  function push1(a) {
    return a.push(1.1);
  }

  %PrepareFunctionForOptimization(push1);
  assertEquals(2, push1([1.1]));
  assertEquals(3, push1([1.1, 2.2]));
  %OptimizeFunctionOnNextCall(push1);
  assertEquals(4, push1([1.1, 2.2, 3.3]));

  function push2(a) {
    return a.push(1.1, 2.2);
  }

  %PrepareFunctionForOptimization(push2);
  assertEquals(3, push2([1.1]));
  assertEquals(4, push2([1.1, 2.2]));
  %OptimizeFunctionOnNextCall(push2);
  assertEquals(5, push2([1.1, 2.2, 3.3]));

  function push3(a) {
    return a.push(1.1, 2.2, 3.3);
  }

  %PrepareFunctionForOptimization(push3);
  assertEquals(4, push3([1.1]));
  assertEquals(5, push3([1.1, 2.2]));
  %OptimizeFunctionOnNextCall(push3);
  assertEquals(6, push3([1.1, 2.2, 3.3]));
})();

// Test multiple arguments push for HOLEY_DOUBLE_ELEMENTS.
(function() {
  function push0(a) {
    return a.push();
  }

  %PrepareFunctionForOptimization(push0);
  assertEquals(2, push0([, 1.1]));
  assertEquals(3, push0([, 1.1, 2.2]));
  %OptimizeFunctionOnNextCall(push0);
  assertEquals(4, push0([, 1.1, 2.2, 3.3]));

  function push1(a) {
    return a.push(1.1);
  }

  %PrepareFunctionForOptimization(push1);
  assertEquals(3, push1([, 1.1]));
  assertEquals(4, push1([, 1.1, 2.2]));
  %OptimizeFunctionOnNextCall(push1);
  assertEquals(5, push1([, 1.1, 2.2, 3.3]));

  function push2(a) {
    return a.push(1.1, 2.2);
  }

  %PrepareFunctionForOptimization(push2);
  assertEquals(4, push2([, 1.1]));
  assertEquals(5, push2([, 1.1, 2.2]));
  %OptimizeFunctionOnNextCall(push2);
  assertEquals(6, push2([, 1.1, 2.2, 3.3]));

  function push3(a) {
    return a.push(1.1, 2.2, 3.3);
  }

  %PrepareFunctionForOptimization(push3);
  assertEquals(5, push3([, 1.1]));
  assertEquals(6, push3([, 1.1, 2.2]));
  %OptimizeFunctionOnNextCall(push3);
  assertEquals(7, push3([, 1.1, 2.2, 3.3]));
})();

// Test multiple arguments push for PACKED_ELEMENTS.
(function() {
  function push0(a) {
    return a.push();
  }

  %PrepareFunctionForOptimization(push0);
  assertEquals(1, push0(['1']));
  assertEquals(2, push0(['1', '2']));
  %OptimizeFunctionOnNextCall(push0);
  assertEquals(3, push0(['1', '2', '3']));

  function push1(a) {
    return a.push('1');
  }

  %PrepareFunctionForOptimization(push1);
  assertEquals(2, push1(['1']));
  assertEquals(3, push1(['1', '2']));
  %OptimizeFunctionOnNextCall(push1);
  assertEquals(4, push1(['1', '2', '3']));

  function push2(a) {
    return a.push('1', '2');
  }

  %PrepareFunctionForOptimization(push2);
  assertEquals(3, push2(['1']));
  assertEquals(4, push2(['1', '2']));
  %OptimizeFunctionOnNextCall(push2);
  assertEquals(5, push2(['1', '2', '3']));

  function push3(a) {
    return a.push('1', '2', '3');
  }

  %PrepareFunctionForOptimization(push3);
  assertEquals(4, push3(['1']));
  assertEquals(5, push3(['1', '2']));
  %OptimizeFunctionOnNextCall(push3);
  assertEquals(6, push3(['1', '2', '3']));
})();

// Test multiple arguments push for HOLEY_ELEMENTS.
(function() {
  function push0(a) {
    return a.push();
  }

  %PrepareFunctionForOptimization(push0);
  assertEquals(2, push0([, '1']));
  assertEquals(3, push0([, '1', '2']));
  %OptimizeFunctionOnNextCall(push0);
  assertEquals(4, push0([, '1', '2', '3']));

  function push1(a) {
    return a.push('1');
  }

  %PrepareFunctionForOptimization(push1);
  assertEquals(3, push1([, '1']));
  assertEquals(4, push1([, '1', '2']));
  %OptimizeFunctionOnNextCall(push1);
  assertEquals(5, push1([, '1', '2', '3']));

  function push2(a) {
    return a.push('1', '2');
  }

  %PrepareFunctionForOptimization(push2);
  assertEquals(4, push2([, '1']));
  assertEquals(5, push2([, '1', '2']));
  %OptimizeFunctionOnNextCall(push2);
  assertEquals(6, push2([, '1', '2', '3']));

  function push3(a) {
    return a.push('1', '2', '3');
  }

  %PrepareFunctionForOptimization(push3);
  assertEquals(5, push3([, '1']));
  assertEquals(6, push3([, '1', '2']));
  %OptimizeFunctionOnNextCall(push3);
  assertEquals(7, push3([, '1', '2', '3']));
})();
                                       node-23.7.0/deps/v8/test/mjsunit/compiler/array-push-2.js                                           0000664 0000000 0000000 00000003366 14746647661 0023127 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan

// Test elements transition from SMI to DOUBLE.
(function() {
  const a = [];
  const foo = (x, y) => a.push(x, y);
  %PrepareFunctionForOptimization(foo);
  foo(1, 2);
  foo(3, 4);
  %OptimizeFunctionOnNextCall(foo);
  foo(5, 6.6);
  assertEquals([1, 2, 3, 4, 5, 6.6], a);
})();
(function() {
  const a = [];
  const foo = (x, y) => a.push(x, y);
  %PrepareFunctionForOptimization(foo);
  foo(1, 2);
  foo(3, 4);
  %OptimizeFunctionOnNextCall(foo);
  foo(5.5, 6.6);
  assertEquals([1, 2, 3, 4, 5.5, 6.6], a);
})();

// Test elements transition from SMI to OBJECT.
(function() {
  const a = [];
  const foo = (x, y) => a.push(x, y);
  %PrepareFunctionForOptimization(foo);
  foo(1, 2);
  foo(3, 4);
  %OptimizeFunctionOnNextCall(foo);
  foo(5, '6');
  assertEquals([1, 2, 3, 4, 5, '6'], a);
})();
(function() {
  const a = [];
  const foo = (x, y) => a.push(x, y);
  %PrepareFunctionForOptimization(foo);
  foo(1, 2);
  foo(3, 4);
  %OptimizeFunctionOnNextCall(foo);
  foo('5', '6');
  assertEquals([1, 2, 3, 4, '5', '6'], a);
})();

// Test elements transition from DOUBLE to OBJECT.
(function() {
  const a = [0.5];
  const foo = (x, y) => a.push(x, y);
  %PrepareFunctionForOptimization(foo);
  foo(1, 2);
  foo(3, 4);
  %OptimizeFunctionOnNextCall(foo);
  foo(5, '6');
  assertEquals([0.5, 1, 2, 3, 4, 5, '6'], a);
})();
(function() {
  const a = [0.5];
  const foo = (x, y) => a.push(x, y);
  %PrepareFunctionForOptimization(foo);
  foo(1, 2);
  foo(3, 4);
  %OptimizeFunctionOnNextCall(foo);
  foo('5', '6');
  assertEquals([0.5, 1, 2, 3, 4, '5', '6'], a);
})();
                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/compiler/array-push-3.js                                           0000664 0000000 0000000 00000002454 14746647661 0023125 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan

// Test side effects on arguments evaluation.
(function() {
  const a = [];
  const bar = x => { a.push(x); return x; };
  const foo = x => a.push(bar(x), bar(x));
  %PrepareFunctionForOptimization(foo);
  foo(1);
  foo(2);
  %OptimizeFunctionOnNextCall(foo);
  foo(3);
  assertEquals([1,1,1,1, 2,2,2,2, 3,3,3,3], a);
})();

// Test invalidation on arguments evaluation.
(function() {
  let y = 1;
  const a = [];
  const bar = x => { a.push(y); return x; }
  const foo = x => a.push(bar(x), bar(x));
  %PrepareFunctionForOptimization(foo);
  foo(1);
  y = 2;
  foo(2);
  %OptimizeFunctionOnNextCall(foo);
  y = 3;
  foo(3);
  assertOptimized(foo);
  y = 4.4;
  foo(4);
  assertEquals([1,1,1,1, 2,2,2,2, 3,3,3,3, 4.4,4.4,4,4], a);
})();
(function() {
  let y = 1;
  const a = [0.5];
  const bar = x => { a.push(y); return x; }
  const foo = x => a.push(bar(x), bar(x));
  %PrepareFunctionForOptimization(foo);
  foo(1);
  y = 2;
  foo(2);
  %OptimizeFunctionOnNextCall(foo);
  y = 3;
  foo(3);
  assertOptimized(foo);
  y = '4';
  foo(4);
  assertEquals([0.5, 1,1,1,1, 2,2,2,2, 3,3,3,3, '4','4',4,4], a);
})();
                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/compiler/array-slice-clone.js                                      0000664 0000000 0000000 00000024252 14746647661 0024203 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-stress-flush-code
// Flags: --no-lazy-feedback-allocation


// Test CloneFastJSArray inserted by JSCallReducer for Array.prototype.slice.
// CloneFastJSArray produces COW arrays if the original array is COW.

// Trigger JSCallReducer on slice() and slice(0)
(function() {
  const arr = [1,2,3,4,5];

  function slice() {
    return arr.slice();
  }

  function slice0() {
    return arr.slice(0);
  }

  %PrepareFunctionForOptimization(slice0);
  %PrepareFunctionForOptimization(slice);

  assertEquals(arr, slice());
  assertFalse(arr === slice());
  assertEquals(slice(), slice0());
  assertEquals(slice0(), slice());

  %OptimizeFunctionOnNextCall(slice0);
  assertEquals(slice(), slice0());
  %OptimizeFunctionOnNextCall(slice);

  assertEquals(slice(), slice0());
  assertOptimized(slice); assertOptimized(slice0);
})();

// This will cause deopt of slice by a CheckMap installed by
// JSNativeContextSpecialization::ReduceNamedAccess
(function() {
  const arr = [1,2,3,4,5];

  function slice() {
    return arr.slice();
  }

  %PrepareFunctionForOptimization(slice);

  assertEquals(arr, slice());
  assertEquals(slice(), arr);

  %OptimizeFunctionOnNextCall(slice);
  slice();

  // Trigger deopt here
  arr.push(7.2);
  assertEquals(slice()[5], 7.2);
})();

// There should not be a deopt cycle.
(function() {
  const arr = [1,2,3,4,5];

  function slice() {
    return arr.slice();
  }

  %PrepareFunctionForOptimization(slice);

  assertEquals(arr, slice());
  assertEquals(slice(), arr);

  %OptimizeFunctionOnNextCall(slice);
  // Trigger opt
  assertEquals(slice(), arr);

  // Trigger deopt by CheckMap from JSNativeContextSpecialization
  arr.push(7.2);
  slice();

  %PrepareFunctionForOptimization(slice);
  %OptimizeFunctionOnNextCall(slice);
  // Trigger opt again
  slice();

  // Should not deopt again
  arr.push(8.2);
  slice();
  assertOptimized(slice);
})();

// JSCallReducer will not reduce because the species has been modified
(function() {
  const array = [3,4,5];

  function slice(){
    return array.slice();
  }

  class MyArray extends Array {};
  array.constructor = MyArray;

  %PrepareFunctionForOptimization(slice);

  slice(); slice();

  %OptimizeFunctionOnNextCall(slice);
  var narr = slice();
  assertInstanceof(narr, MyArray);
})();

(function() {
  const array = [3,4,5];

  function slice(){
    return array.slice();
  }

  %PrepareFunctionForOptimization(slice);

  slice(); slice();

  %OptimizeFunctionOnNextCall(slice);

  slice();

  class MyArray extends Array {};
  array.constructor = MyArray;
  // deopt
  var narr = slice();
  // if not deopt, narr will be instanceof Array
  assertTrue(narr instanceof MyArray);
})();

// JSCallReducer adds check for UnreliableReceiverMaps
(function() {
  const arr = [1,2,3,4,5];

  function slice() {
    return arr.slice();
  }

  %PrepareFunctionForOptimization(slice);

  slice(); slice();
  arr.foo = 6.2;

  %OptimizeFunctionOnNextCall(slice);
  // JSCallReducer will add check for UnreliableReceiverMaps
  slice();

  // Trigger deopt because of DependOnStableMaps
  // installed by JSNativeContextSpecialization,
  // but not the check installed by ReduceArrayPrototypeSlice itself
  arr.bar = 7.2;

  let narr = slice();
  assertEquals(arr, narr);
  assertEquals(narr.foo, undefined);
  assertEquals(narr.bar, undefined);
})();

// Multiple maps
(function() {
  const iarr = [1,2,3];
  const darr = [2.1, 3.3, 0.2];

  function slice(arr) {
    return arr.slice();
  }

  %PrepareFunctionForOptimization(slice);

  slice(iarr); slice(darr);
  slice(iarr); slice(darr);

  %OptimizeFunctionOnNextCall(slice);
  // The optimization works for both maps
  assertEquals(iarr, slice(iarr));
  assertEquals(darr, slice(darr));
  assertOptimized(slice);
})();

// Tests for the branch of CanInlineArrayIteratingBuiltin

// JSCallReducer will not reduce to CloneFastJSArray
// if array's prototype is not JS_ARRAY_TYPE
(function () {
  class MyArray extends Array {
    constructor() {
      super();
      this[6]= 6;
    }
  }
  let array = new MyArray(3, 5, 4);

  function slice() {
    return array.slice();
  }

  %PrepareFunctionForOptimization(slice);

  assertEquals(slice(),array);
  slice();

  %OptimizeFunctionOnNextCall(slice);
  let narr = slice();
  // here, slice supposes to call MyArray's constructor.
  // If we optimize with CloneFastJSArray, Array's constructor is called instead.
  assertEquals(narr[6], 6);
  assertTrue(narr instanceof MyArray);
})();

// JSCallReducer will not reduce to CloneFastJSArray
// if array's instance type is not JS_ARRAY_TYPE.
// CloneFastJSArray does not work with non JS_ARRAY_TYPE.
// Check : receiver_map->instance_type() == JS_ARRAY_TYPE
(function () {
  var x = {"0" : 0, "2": 2} ;
  x.__proto__ = Array.prototype;

  function slice() {
    return x.slice();
  }

  %PrepareFunctionForOptimization(slice);

  slice(); slice();

  %OptimizeFunctionOnNextCall(slice);
  assertEquals(slice(), []);
})();

// JSCallReducer will not reduce to CloneFastJSArray
// since array is not Fast Elements Kind
// Check : IsFastElementsKind(receiver_map->elements_kind())
(function () {
  var array = [3, 4, 5];

  function slice() {
    return array.slice();
  }

  %PrepareFunctionForOptimization(slice);

  assertEquals(slice(),array);
  slice();

  // a sparse array switches to Dictionary Elements
  array[9999] = 0;
  %OptimizeFunctionOnNextCall(slice);
  var narr = slice();
  assertEquals(narr, array);
})();

(function () {
  var array = [3, 4, 5];

  function slice() {
    return array.slice();
  }

  %PrepareFunctionForOptimization(slice);

  assertEquals(slice(),array);
  slice();

  %OptimizeFunctionOnNextCall(slice);
  slice();

  // a sparse array switches to Dictionary Elements
  array[9999] = 0;
  // trigger deopt because map changes
  assertEquals(slice(),array);
})();

// JSCallReducer will not reduce to CloneFastJSArray
// if array is used as a prototype and has unstable map
(function () {
  var array = [3, 5, 4];

  function slice(arr) {
    return arr.slice();
  }

  %PrepareFunctionForOptimization(slice);

  // make array's map is_prototype_map()
  var x = {__proto__ : array};

  assertEquals(slice(array),array);
  slice(array);

  // make array's map unstable
  array.push(6.3);
  slice(array);

  %OptimizeFunctionOnNextCall(slice);

  assertEquals(slice(array),array);
})();

// JSCallReducer will not reduce to CloneFastJSArray
// if the Array prototype got some elements.
// Check: isolate->IsNoElementsProtectorIntact()
(function () {
  var array = [, 6, 6];

  function slice() {
    return array.slice();
  }

  %PrepareFunctionForOptimization(slice);

  assertEquals(slice(),array);
  slice();

  array.__proto__.push(6);

  %OptimizeFunctionOnNextCall(slice);

  // if we optimized, we would get [ , 6, 6]
  // here, slice copies elements from both the object and the prototype
  let narr = slice();
  assertNotEquals(Object.getOwnPropertyDescriptor(narr,0), undefined);
  assertEquals(narr, [6, 6, 6]);
})();

(function () {
  var array = [, 6, 6];

  function slice() {
    return array.slice();
  }

  %PrepareFunctionForOptimization(slice);

  assertEquals(slice(),array);
  slice();

  %OptimizeFunctionOnNextCall(slice);
  slice();

  // Deopt
  array.__proto__.push(6);
  let narr = slice();
  assertNotEquals(Object.getOwnPropertyDescriptor(narr, 0), undefined);
  assertEquals(narr[0], 6);
})();

// JSCallReducer will not reduce to CloneFastJSArray
// if the Array prototype is not original
// Check: isolate->IsAnyInitialArrayPrototype(receiver_prototype)
(function () {
  var array = [6, , 6];

  function slice() {
    return array.slice();
  }

  %PrepareFunctionForOptimization(slice);

  assertEquals(slice(),array);
  slice();

  // change the prototype
  array.__proto__ = [ , 6, ];

  %OptimizeFunctionOnNextCall(slice);
  let narr = slice();
  // if optimized, we would get [6, , 6]
  assertNotEquals(Object.getOwnPropertyDescriptor(narr, 1), undefined);
  assertEquals(narr, [6,6,6]);
})();

(function () {
  var array = [6, ,6];

  function slice() {
    return array.slice();
  }

  %PrepareFunctionForOptimization(slice);

  assertEquals(slice(),array);
  slice();

  %OptimizeFunctionOnNextCall(slice);
  slice();

  // change the prototype
  array.__proto__ = [,6,];
  // deopt because of map changed
  let narr = slice();

  // if optimized, we would get [6, , 6]
  assertNotEquals(Object.getOwnPropertyDescriptor(narr, 1), undefined);
  assertEquals(narr, [6,6,6]);
})();

// Packed
// Trigger JSCallReducer on slice() and slice(0)
(function() {
  // Non-extensible:
  var arr = Object.preventExtensions([1,2,'a',4,5]);

  function slice() {
    return arr.slice();
  }

  function slice0() {
    return arr.slice(0);
  }

  function test() {
    %PrepareFunctionForOptimization(slice0);
    %PrepareFunctionForOptimization(slice);

    assertEquals(arr, slice());
    assertFalse(arr === slice());
    assertEquals(slice(), slice0());
    assertEquals(slice0(), slice());

    %OptimizeFunctionOnNextCall(slice0);
    assertEquals(slice(), slice0());
    %OptimizeFunctionOnNextCall(slice);

    assertEquals(slice(), slice0());
    assertOptimized(slice); assertOptimized(slice0);
  }
  test();

  // Sealed
  arr = Object.seal([1,2,'a',4,5]);
  test();

  // Frozen
  arr = Object.freeze([1,2,'a',4,5]);
  test();
})();

// Holey
// Trigger JSCallReducer on slice() and slice(0)
(function() {
  // Non-extensible:
  var arr = Object.preventExtensions([,1,2,'a',4,5]);

  function slice() {
    return arr.slice();
  }

  function slice0() {
    return arr.slice(0);
  }

  function test() {
    %PrepareFunctionForOptimization(slice0);
    %PrepareFunctionForOptimization(slice);
    assertEquals(arr, slice());
    assertFalse(arr === slice());
    assertEquals(slice(), slice0());
    assertEquals(slice0(), slice());

    %OptimizeFunctionOnNextCall(slice0);
    assertEquals(slice(), slice0());
    %OptimizeFunctionOnNextCall(slice);

    assertEquals(slice(), slice0());
    assertOptimized(slice0);
    assertOptimized(slice);
  }
  test();

  // Sealed
  arr = Object.seal([,1,2,'a',4,5]);
  test();

  // Frozen
  arr = Object.freeze([,1,2,'a',4,5]);
  test();
})();
                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/compiler/array-some.js                                             0000664 0000000 0000000 00000005045 14746647661 0022750 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

// Basic loop peeling test case with Array.prototype.some().
(function() {
  function foo(a, o) {
    return a.some(x => x === o.x);
  }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo([1, 2, 3], {x:3}));
  assertFalse(foo([0, 1, 2], {x:3}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo([1, 2, 3], {x:3}));
  assertFalse(foo([0, 1, 2], {x:3}));

  // Packed
  // Non-extensible
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(Object.preventExtensions([1, 2, '3']), {x:'3'}));
  assertFalse(foo(Object.preventExtensions([0, 1, '2']), {x:'3'}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(Object.preventExtensions([1, 2, '3']), {x:'3'}));
  assertFalse(foo(Object.preventExtensions([0, 1, '2']), {x:'3'}));

  // Sealed
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(Object.seal([1, 2, '3']), {x:'3'}));
  assertFalse(foo(Object.seal([0, 1, '2']), {x:'3'}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(Object.seal([1, 2, '3']), {x:'3'}));
  assertFalse(foo(Object.seal([0, 1, '2']), {x:'3'}));

  // Frozen
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(Object.freeze([1, 2, '3']), {x:'3'}));
  assertFalse(foo(Object.freeze([0, 1, '2']), {x:'3'}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(Object.freeze([1, 2, '3']), {x:'3'}));
  assertFalse(foo(Object.freeze([0, 1, '2']), {x:'3'}));

  // Holey
  // Non-extensible
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(Object.preventExtensions([, 1, 2, '3']), {x:'3'}));
  assertFalse(foo(Object.preventExtensions([, 0, 1, '2']), {x:'3'}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(Object.preventExtensions([, 1, 2, '3']), {x:'3'}));
  assertFalse(foo(Object.preventExtensions([, 0, 1, '2']), {x:'3'}));

  // Sealed
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(Object.seal([, 1, 2, '3']), {x:'3'}));
  assertFalse(foo(Object.seal([, 0, 1, '2']), {x:'3'}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(Object.seal([, 1, 2, '3']), {x:'3'}));
  assertFalse(foo(Object.seal([, 0, 1, '2']), {x:'3'}));

  // Frozen
  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(Object.freeze([, 1, 2, '3']), {x:'3'}));
  assertFalse(foo(Object.freeze([, 0, 1, '2']), {x:'3'}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(Object.freeze([, 1, 2, '3']), {x:'3'}));
  assertFalse(foo(Object.freeze([, 0, 1, '2']), {x:'3'}));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/compiler/array-species.js                                          0000664 0000000 0000000 00000001266 14746647661 0023441 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

function Foo() {}

function f() {
  return [42].map(_ => 88);
}

let y;

%PrepareFunctionForOptimization(f);

y = f();
assertFalse(y instanceof Foo);
assertInstanceof(y, Array);

y = f();
assertFalse(y instanceof Foo);
assertInstanceof(y, Array);

%OptimizeFunctionOnNextCall(f);

y = f();
assertFalse(y instanceof Foo);
assertInstanceof(y, Array);

assertTrue(Reflect.defineProperty(Array, Symbol.species, {value: Foo}));

y = f();
assertInstanceof(y, Foo);
assertFalse(y instanceof Array);
                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/compiler/array-subclass.js                                         0000664 0000000 0000000 00000041654 14746647661 0023632 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

// Test Array subclass default constructor with no parameters.
(function() {
  const A = class A extends Array { };

  function foo() { return new A; }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(0, foo().length);
    assertInstanceof(foo(), A);
    assertEquals(0, foo().length);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(0, foo().length);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass default constructor with small constant length.
(function() {
  const A = class A extends Array { };
  const L = 4;

  function foo() { return new A(L); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(L, foo().length);
    assertInstanceof(foo(), A);
    assertEquals(L, foo().length);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(L, foo().length);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass default constructor with large constant length.
(function() {
  const A = class A extends Array { };
  const L = 1024 * 1024;

  function foo() { return new A(L); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(L, foo().length);
    assertInstanceof(foo(), A);
    assertEquals(L, foo().length);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(L, foo().length);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass default constructor with known boolean.
(function() {
  const A = class A extends Array { };

  function foo() { return new A(true); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertEquals(true, foo()[0]);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertEquals(true, foo()[0]);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertEquals(true, foo()[0]);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass default constructor with known string.
(function() {
  const A = class A extends Array { };

  function foo() { return new A(""); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertEquals("", foo()[0]);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertEquals("", foo()[0]);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertEquals("", foo()[0]);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass default constructor with known object.
(function() {
  const A = class A extends Array { };
  const O = {foo: "foo"};

  function foo() { return new A(O); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertSame(O, foo()[0]);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertSame(O, foo()[0]);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertSame(O, foo()[0]);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);})();

// Test Array subclass default constructor with known small integers.
(function() {
  const A = class A extends Array { };

  function foo() { return new A(1, 2, 3); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(3, foo().length);
    assertEquals(1, foo()[0]);
    assertEquals(2, foo()[1]);
    assertEquals(3, foo()[2]);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(3, foo().length);
    assertEquals(1, foo()[0]);
    assertEquals(2, foo()[1]);
    assertEquals(3, foo()[2]);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass default constructor with known numbers.
(function() {
  const A = class A extends Array { };

  function foo() { return new A(1.1, 2.2, 3.3); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(3, foo().length);
    assertEquals(1.1, foo()[0]);
    assertEquals(2.2, foo()[1]);
    assertEquals(3.3, foo()[2]);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(3, foo().length);
    assertEquals(1.1, foo()[0]);
    assertEquals(2.2, foo()[1]);
    assertEquals(3.3, foo()[2]);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass default constructor with known strings.
(function() {
  const A = class A extends Array { };

  function foo() { return new A("a", "b", "c", "d"); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(4, foo().length);
    assertEquals("a", foo()[0]);
    assertEquals("b", foo()[1]);
    assertEquals("c", foo()[2]);
    assertEquals("d", foo()[3]);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(4, foo().length);
    assertEquals("a", foo()[0]);
    assertEquals("b", foo()[1]);
    assertEquals("c", foo()[2]);
    assertEquals("d", foo()[3]);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass constructor with no parameters.
(function() {
  const A = class A extends Array {
    constructor() {
      super();
      this.bar = 1;
    }
  };

  function foo() { return new A; }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(0, foo().length);
    assertEquals(1, foo().bar);
    assertInstanceof(foo(), A);
    assertEquals(0, foo().length);
    assertEquals(1, foo().bar);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(0, foo().length);
    assertEquals(1, foo().bar);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);})();

// Test Array subclass constructor with small constant length.
(function() {
  const A = class A extends Array {
    constructor(n) {
      super(n);
      this.bar = 1;
    }
  };
  const L = 4;

  function foo() { return new A(L); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(L, foo().length);
    assertEquals(1, foo().bar);
    assertInstanceof(foo(), A);
    assertEquals(L, foo().length);
    assertEquals(1, foo().bar);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(L, foo().length);
    assertEquals(1, foo().bar);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass constructor with large constant length.
(function() {
  const A = class A extends Array {
    constructor(n) {
      super(n);
      this.bar = 1;
    }
  };
  const L = 1024 * 1024;

  function foo() { return new A(L); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(L, foo().length);
    assertEquals(1, foo().bar);
    assertInstanceof(foo(), A);
    assertEquals(L, foo().length);
    assertEquals(1, foo().bar);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(L, foo().length);
    assertEquals(1, foo().bar);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass constructor with known boolean.
(function() {
  const A = class A extends Array {
    constructor(n) {
      super(n);
      this.bar = 1;
    }
  };

  function foo() { return new A(true); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertEquals(true, foo()[0]);
    assertEquals(1, foo().bar);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertEquals(true, foo()[0]);
    assertEquals(1, foo().bar);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertEquals(true, foo()[0]);
    assertEquals(1, foo().bar);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass constructor with known string.
(function() {
  const A = class A extends Array {
    constructor(n) {
      super(n);
      this.bar = 1;
    }
  };

  function foo() { return new A(""); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertEquals("", foo()[0]);
    assertEquals(1, foo().bar);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertEquals("", foo()[0]);
    assertEquals(1, foo().bar);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertEquals("", foo()[0]);
    assertEquals(1, foo().bar);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass constructor with known object.
(function() {
  const A = class A extends Array {
    constructor(n) {
      super(n);
      this.bar = 1;
    }
  };
  const O = {foo: "foo"};

  function foo() { return new A(O); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertSame(O, foo()[0]);
    assertEquals(1, foo().bar);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertSame(O, foo()[0]);
    assertEquals(1, foo().bar);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(1, foo().length);
    assertSame(O, foo()[0]);
    assertEquals(1, foo().bar);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass constructor with known small integers.
(function() {
  const A = class A extends Array {
    constructor(x, y, z) {
      super(x, y, z);
      this.bar = 1;
    }
  };

  function foo() { return new A(1, 2, 3); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(3, foo().length);
    assertEquals(1, foo()[0]);
    assertEquals(2, foo()[1]);
    assertEquals(3, foo()[2]);
    assertEquals(1, foo().bar);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(3, foo().length);
    assertEquals(1, foo()[0]);
    assertEquals(2, foo()[1]);
    assertEquals(3, foo()[2]);
    assertEquals(1, foo().bar);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass constructor with known numbers.
(function() {
  const A = class A extends Array {
    constructor(x, y, z) {
      super(x, y, z);
      this.bar = 1;
    }
  };

  function foo() { return new A(1.1, 2.2, 3.3); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(3, foo().length);
    assertEquals(1.1, foo()[0]);
    assertEquals(2.2, foo()[1]);
    assertEquals(3.3, foo()[2]);
    assertEquals(1, foo().bar);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(3, foo().length);
    assertEquals(1.1, foo()[0]);
    assertEquals(2.2, foo()[1]);
    assertEquals(3.3, foo()[2]);
    assertEquals(1, foo().bar);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();

// Test Array subclass constructor with known strings.
(function() {
  const A = class A extends Array {
    constructor(a, b, c, d) {
      super(a, b, c, d);
      this.bar = 1;
    }
  };

  function foo() { return new A("a", "b", "c", "d"); }

  function test(foo) {
    %PrepareFunctionForOptimization(foo);
    assertInstanceof(foo(), A);
    assertEquals(4, foo().length);
    assertEquals("a", foo()[0]);
    assertEquals("b", foo()[1]);
    assertEquals("c", foo()[2]);
    assertEquals("d", foo()[3]);
    assertEquals(1, foo().bar);
    %OptimizeFunctionOnNextCall(foo);
    assertInstanceof(foo(), A);
    assertEquals(4, foo().length);
    assertEquals("a", foo()[0]);
    assertEquals("b", foo()[1]);
    assertEquals("c", foo()[2]);
    assertEquals("d", foo()[3]);
    assertEquals(1, foo().bar);
  }
  test(foo);

  // Non-extensible
  function fooPreventExtensions() { return Object.preventExtensions(foo()); }
  test(fooPreventExtensions);

  // Sealed
  function fooSeal() { return Object.seal(foo()); }
  test(fooSeal);

  // Frozen
  function fooFreeze() { return Object.freeze(foo()); }
  test(fooFreeze);
})();
                                                                                    node-23.7.0/deps/v8/test/mjsunit/compiler/assignment-deopt.js                                       0000664 0000000 0000000 00000012221 14746647661 0024144 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

// Test deopt with count operation on parameter.
var max_smi = 1073741823;
var o = {x:0};

function assign1(x) { x += 1; o.x = x; }
assign1(max_smi);
assertEquals(max_smi + 1, o.x);

assign1(1.1);
assertEquals(2.1, o.x);


// Test deopt with count operation on named property.
function assign2(p) { p.x += 1 }

%PrepareFunctionForOptimization(assign2);

o.x = "42";
assign2(o);
assertEquals("421", o.x);

var s = max_smi - 10;
o.x = s;
for(var i = 0; i < 20; i++) {
  assign2(o);
  if (i == 4) {
    %OptimizeFunctionOnNextCall(assign2);
  }
}
assertEquals(max_smi + 10, o.x);


// Test deopt with count operation on keyed property.
function assign3(a, b) { a[b] += 1; }

%PrepareFunctionForOptimization(assign3);

o = ["42"];
assign3(o, 0);
assertEquals("421", o[0]);

var s = max_smi - 10;
o[0] = s;
for(var i = 0; i < 20; i++) {
  assign3(o, 0);
  if (i == 4) {
    %OptimizeFunctionOnNextCall(assign3);
  }
}
assertEquals(max_smi + 10, o[0]);

assign3(o, "0");

assertEquals(max_smi + 11, o[0]);

// Test bailout when accessing a non-existing array element.
o[0] = 0;
for(var i = 0; i < 5; i++) {
  assign3(o, 0);
}
%PrepareFunctionForOptimization(assign3);
%OptimizeFunctionOnNextCall(assign3);
assign3(o, 0);
assign3(o, 1);

// Test bailout with count operation in a value context.
function assign5(x,y) { return (x += 1) + y; }
%PrepareFunctionForOptimization(assign5);
for (var i = 0; i < 5; ++i) assertEquals(4, assign5(2, 1));
%OptimizeFunctionOnNextCall(assign5);
assertEquals(4, assign5(2, 1));

assertEquals(4.1, assign5(2, 1.1));
assertEquals(4.1, assign5(2.1, 1));

function assign7(o,y) { return (o.x += 1) + y; }
%PrepareFunctionForOptimization(assign7);
o = {x:0};
for (var i = 0; i < 5; ++i) {
  o.x = 42;
  assertEquals(44, assign7(o, 1));
}
%OptimizeFunctionOnNextCall(assign7);
o.x = 42;
assertEquals(44, assign7(o, 1));

o.x = 42;
assertEquals(44.1, assign7(o, 1.1));
o.x = 42.1;
assertEquals(44.1, assign7(o, 1));

function assign9(o,y) { return (o[0] += 1) + y; }
%PrepareFunctionForOptimization(assign9);
q = [0];
for (var i = 0; i < 5; ++i) {
  q[0] = 42;
  assertEquals(44, assign9(q, 1));
}
%OptimizeFunctionOnNextCall(assign9);
q[0] = 42;
assertEquals(44, assign9(q, 1));

q[0] = 42;
assertEquals(44.1, assign9(q, 1.1));
q[0] = 42.1;
assertEquals(44.1, assign9(q, 1));

// Test deopt because of a failed map check on the load.
function assign10(p) { return p.x += 1 }
%PrepareFunctionForOptimization(assign10);
var g1 = {x:0};
var g2 = {y:0, x:42};
for (var i = 0; i < 5; ++i) {
  g1.x = 42;
  assertEquals(43, assign10(g1));
  assertEquals(43, g1.x);
}
%OptimizeFunctionOnNextCall(assign10);
g1.x = 42;
assertEquals(43, assign10(g1));
assertEquals(43, g1.x);

assertEquals(43, assign10(g2));
assertEquals(43, g2.x);

// Test deopt because of a failed map check on the store.
// The binary operation changes the map as a side effect.
o = {x:0};
var g3 = { valueOf: function() { o.y = "bar"; return 42; }};
function assign11(p) { return p.x += 1; }
%PrepareFunctionForOptimization(assign11);

for (var i = 0; i < 5; i++) {
  o.x = "a";
  assign11(o);
}
%OptimizeFunctionOnNextCall(assign11);
o.x = "a";
assign11(o);

assertEquals("a11", assign11(o));
o.x = g3;
assertEquals(43, assign11(o));
assertEquals("bar", o.y);

o = [0];
var g4 = { valueOf: function() { o.y = "bar"; return 42; }};
function assign12(p) { return p[0] += 1; }
%PrepareFunctionForOptimization(assign12);

for (var i = 0; i < 5; i++) {
  o[0] = "a";
  assign12(o);
}
%OptimizeFunctionOnNextCall(assign12);
o[0] = "a";
assign12(o);

assertEquals("a11", assign12(o));
o[0] = g4;
assertEquals(43, assign12(o));
assertEquals("bar", o.y);
                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/compiler/assignment.js                                             0000664 0000000 0000000 00000012502 14746647661 0023035 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Tests for compound assignments at the top level

z = 2;
z += 4;

assertEquals(z, 6);

a = new Array(10);

a[2] += 7;
a[2] = 15;
a[2] += 2;

assertEquals(17, a[2]);

b = new Object();
b.foo = 5;
b.foo += 12;

assertEquals(17, b.foo);

// Test compound assignments in an anonymous function with local variables.
(function () {
  var z = 2;
  z += 4;

  assertEquals(z, 6);

  var a = new Array(10);

  a[2] += 7;
  a[2] = 15;
  a[2] += 2;

  assertEquals(17, a[2]);

  var b = new Object();
  b.foo = 5;
  b.foo += 12;

  assertEquals(17, b.foo);
})();

// Test compound assignments in an anonymous function with global variables.
(function () {
  z = 2;
  z += 4;

  assertEquals(z, 6);

  a = new Array(10);

  a[2] += 7;
  a[2] = 15;
  a[2] += 2;

  assertEquals(17, a[2]);

  b = new Object();
  b.foo = 5;
  b.foo += 12;

  assertEquals(17, b.foo);
})();

// Test compound assignments in a named function with local variables.
function foo() {
  var z = 3;
  z += 4;

  assertEquals(z, 7);

  var a = new Array(10);

  a[2] += 7;
  a[2] = 15;
  a[2] += 2;

  assertEquals(17, a[2]);

  var b = new Object();
  b.foo = 5;
  b.foo += 12;

  assertEquals(17, b.foo);
}

foo();

// Test compound assignments in a named function with global variables.
function bar() {
  z = 2;
  z += 5;

  assertEquals(z, 7);

  a = new Array(10);

  a[2] += 7;
  a[2] = 15;
  a[2] += 2;

  assertEquals(17, a[2]);

  b = new Object();
  b.foo = 5;
  b.foo += 12;

  assertEquals(17, b.foo);
}

bar();

// Entire series of tests repeated, in loops.
// -------------------------------------------
// Tests for compound assignments in a loop at the top level

for (i = 0; i < 5; ++i) {
  z = 2;
  z += 4;

  assertEquals(z, 6);

  a = new Array(10);

  a[2] += 7;
  a[2] = 15;
  a[2] += 2;

  assertEquals(17, a[2]);

  b = new Object();
  b.foo = 5;
  b.foo += 12;

  assertEquals(17, b.foo);
}

// Test compound assignments in an anonymous function with local variables.
(function () {
  for (var i = 0; i < 5; ++i) {
    var z = 2;
    z += 4;

    assertEquals(z, 6);

    var a = new Array(10);

    a[2] += 7;
    a[2] = 15;
    a[2] += 2;

    assertEquals(17, a[2]);

    var b = new Object();
    b.foo = 5;
    b.foo += 12;

    assertEquals(17, b.foo);
  }
})();

// Test compound assignments in an anonymous function with global variables.
(function () {
  for (i = 0; i < 5; ++i) {
    z = 2;
    z += 4;

    assertEquals(z, 6);

    a = new Array(10);

    a[2] += 7;
    a[2] = 15;
    a[2] += 2;

    assertEquals(17, a[2]);

    b = new Object();
    b.foo = 5;
    b.foo += 12;

    assertEquals(17, b.foo);
  }
})();

// Test compound assignments in a named function with local variables.
function foo_loop() {
  for (i = 0; i < 5; ++i) {
    var z = 3;
    z += 4;

    assertEquals(z, 7);

    var a = new Array(10);

    a[2] += 7;
    a[2] = 15;
    a[2] += 2;

    assertEquals(17, a[2]);

    var b = new Object();
    b.foo = 5;
    b.foo += 12;

    assertEquals(17, b.foo);
  }
}

foo_loop();

// Test compound assignments in a named function with global variables.
function bar_loop() {
  for (i = 0; i < 5; ++i) {
    z = 2;
    z += 5;

    assertEquals(z, 7);

    a = new Array(10);

    a[2] += 7;
    a[2] = 15;
    a[2] += 2;

    assertEquals(17, a[2]);

    b = new Object();
    b.foo = 5;
    b.foo += 12;

    assertEquals(17, b.foo);
  }
}

bar_loop();


// Test assignment in test context.
function test_assign(x, y) { if (x = y) return x; }

assertEquals(42, test_assign(0, 42));

assertEquals("undefined", typeof test_assign(42, 0));

// Test for assignment using a keyed store ic:
function store_i_in_element_i_of_object_i() {
  var i = new Object();
  i[i] = i;
}

// Run three times to exercise caches.
store_i_in_element_i_of_object_i();
store_i_in_element_i_of_object_i();
store_i_in_element_i_of_object_i();
                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/compiler/battery-saver-limits-tiering.js                           0000664 0000000 0000000 00000001222 14746647661 0026410 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Flags: --allow-natives-syntax

function f(x) {
  var y = 0;
  for (var i = 0; i < x; i++) {
    y = 1;
  }
  return y;
}

function g(iter) {
  if (%IsTurbofanEnabled()) {
    while (!%ActiveTierIsTurbofan(f) && --iter) f(10);
  }
}
%NeverOptimizeFunction(g);

if (!%IsTurbofanEnabled()) quit();

if (%SetBatterySaverMode(true)) {
  g(10000);
  assertFalse(%ActiveTierIsTurbofan(f));
  if (%SetBatterySaverMode(false)) {
    g(10000000);
    assertTrue(%ActiveTierIsTurbofan(f));
  }
}
                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-add-no-deopt-loop.js                               0000664 0000000 0000000 00000002106 14746647661 0025360 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan


const big = 2n ** BigInt((2 ** 30)-1);


function testAdd(x, y) {
  return x + y;
}


%PrepareFunctionForOptimization(testAdd);
testAdd(3n, 7n);
testAdd(17n, -54n);
%OptimizeFunctionOnNextCall(testAdd);
assertEquals(testAdd(6n, 2n), 8n);
// Re-prepare the function immediately to make sure type feedback isn't cleared
// by an untimely gc, as re-optimization on new feedback is tested below
%PrepareFunctionForOptimization(testAdd);
assertOptimized(testAdd);

assertThrows(() => testAdd(big, big), RangeError);
if (%Is64Bit()) {
  assertUnoptimized(testAdd);
}

testAdd(30n, -50n);
testAdd(23n, 5n);
%OptimizeFunctionOnNextCall(testAdd);
assertEquals(testAdd(-7n, -12n), -19n);
assertOptimized(testAdd);

assertThrows(() => testAdd(big, big), RangeError);
assertOptimized(testAdd);
assertThrows(() => testAdd(big, big), RangeError);
assertOptimized(testAdd);
                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-add.js                                             0000664 0000000 0000000 00000000766 14746647661 0022700 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan
{
  let a = 0n;
  a = 3n;

  function TestAdd() {
    let sum = 0n;

    for (let i = 0; i < 3; ++i) {
      sum = a + sum;
    }

    return sum;
  }

  %PrepareFunctionForOptimization(TestAdd);
  TestAdd();
  TestAdd();
  %OptimizeFunctionOnNextCall(TestAdd);
  TestAdd();
  TestAdd();
}
          node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-asintn.js                                          0000664 0000000 0000000 00000002216 14746647661 0023434 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan


function f(x) {
  return BigInt.asIntN(3, x);
}

%PrepareFunctionForOptimization(f);
assertEquals(-1n, f(7n));
assertEquals(1n, f(9n));
%OptimizeFunctionOnNextCall(f);
assertEquals(-1n, f(7n));
assertEquals(1n, f(9n));
assertOptimized(f);

// BigInt.asIntN throws TypeError for non-BigInt arguments.
assertThrows(() => f(2), TypeError);
if(%Is64Bit()) {
  // On 64 bit architectures TurboFan optimizes BigInt.asIntN to native code
  // that deoptimizes on non-BigInt arguments.
  assertUnoptimized(f);

  // The next time the function is optimized, speculation should be disabled
  // so the builtin call is kept, which won't deoptimize again.
  %PrepareFunctionForOptimization(f);
  assertEquals(-1n, f(7n));
  assertEquals(1n, f(9n));
  %OptimizeFunctionOnNextCall(f);
}
assertEquals(-1n, f(7n));
assertOptimized(f);

// Re-optimized still throws but does not deopt-loop.
assertThrows(() => f(2), TypeError);
assertOptimized(f);
                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-asuintn.js                                         0000664 0000000 0000000 00000002215 14746647661 0023620 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan


function f(x) {
  return BigInt.asUintN(3, x);
}

%PrepareFunctionForOptimization(f);
assertEquals(7n, f(7n));
assertEquals(1n, f(9n));
%OptimizeFunctionOnNextCall(f);
assertEquals(7n, f(7n));
assertEquals(1n, f(9n));
assertOptimized(f);

// BigInt.asUintN throws TypeError for non-BigInt arguments.
assertThrows(() => f(2), TypeError);
if(%Is64Bit()) {
  // On 64 bit architectures TurboFan optimizes BigInt.asUintN to native code
  // that deoptimizes on non-BigInt arguments.
  assertUnoptimized(f);

  // The next time the function is optimized, speculation should be disabled
  // so the builtin call is kept, which won't deoptimize again.
  %PrepareFunctionForOptimization(f);
  assertEquals(7n, f(7n));
  assertEquals(1n, f(9n));
  %OptimizeFunctionOnNextCall(f);
}
assertEquals(7n, f(7n));
assertOptimized(f);

// Re-optimized still throws but does not deopt-loop.
assertThrows(() => f(2), TypeError);
assertOptimized(f);
                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-bitwise-and.js                                     0000664 0000000 0000000 00000002206 14746647661 0024345 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

function TestBitwiseAnd(a, b) {
  return a & b;
}

function OptimizeAndTest(fn) {
  %PrepareFunctionForOptimization(fn);
  assertEquals(0b1000n, fn(0b1100n, 0b1010n));
  assertEquals(-0b1000n, fn(-0b100n, -0b110n));
  assertEquals(0b1000n, fn(-0b100n, 0b1010n));
  assertEquals(0b1000n, fn(0b1100n, -0b110n));
  // The result grows out of one digit
  assertEquals(-(2n ** 64n), fn(-(2n ** 63n + 1n), -(2n ** 63n)));

  %OptimizeFunctionOnNextCall(fn);
  fn(0b1100n, 0b1010n);
  assertOptimized(fn);

  assertEquals(0b1000n, fn(0b1100n, 0b1010n));
  assertEquals(-0b1000n, fn(-0b100n, -0b110n));
  assertEquals(0b1000n, fn(-0b100n, 0b1010n));
  assertEquals(0b1000n, fn(0b1100n, -0b110n));
  // The result grows out of one digit
  assertEquals(-(2n ** 64n), fn(-(2n ** 63n + 1n), -(2n ** 63n)));
  assertOptimized(fn);

  assertEquals(0b1000, fn(0b1100, 0b1010));
  assertUnoptimized(fn);
}

OptimizeAndTest(TestBitwiseAnd);
                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-bitwise-or.js                                      0000664 0000000 0000000 00000002040 14746647661 0024217 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

(function OptimizeAndTest() {
  function fn(a, b) {
    return a | b;
  }
  %PrepareFunctionForOptimization(fn);
  assertEquals(0b1110n, fn(0b1100n, 0b1010n));
  assertEquals(-0b0010n, fn(-0b100n, -0b110n));
  assertEquals(-0b0010n, fn(-0b100n, 0b1010n));
  assertEquals(-0b0010n, fn(0b1100n, -0b110n));
  assertEquals(-(2n ** 64n) + 1n, fn(-(2n ** 64n) + 1n, -(2n ** 64n)));

  %OptimizeFunctionOnNextCall(fn);
  fn(0b1100n, 0b1010n);
  assertOptimized(fn);

  assertEquals(0b1110n, fn(0b1100n, 0b1010n));
  assertEquals(-0b0010n, fn(-0b100n, -0b110n));
  assertEquals(-0b0010n, fn(-0b100n, 0b1010n));
  assertEquals(-0b0010n, fn(0b1100n, -0b110n));
  assertEquals(-(2n ** 64n) + 1n, fn(-(2n ** 64n) + 1n, -(2n ** 64n)));
  assertOptimized(fn);

  assertEquals(0b1110, fn(0b1100, 0b1010));
  assertUnoptimized(fn);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-bitwise-xor.js                                     0000664 0000000 0000000 00000002000 14746647661 0024403 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

(function OptimizeAndTest() {
  function fn(a, b) {
    return a ^ b;
  }
  %PrepareFunctionForOptimization(fn);
  assertEquals(0b0110n, fn(0b1100n, 0b1010n));
  assertEquals(0b0110n, fn(-0b100n, -0b110n));
  assertEquals(-0b1010n, fn(-0b100n, 0b1010n));
  assertEquals(-0b1010n, fn(0b1100n, -0b110n));
  assertEquals(1n, fn(-(2n ** 64n) + 1n, -(2n ** 64n)));

  %OptimizeFunctionOnNextCall(fn);
  fn(0b1100n, 0b1010n);
  assertOptimized(fn);

  assertEquals(0b0110n, fn(0b1100n, 0b1010n));
  assertEquals(0b0110n, fn(-0b100n, -0b110n));
  assertEquals(-0b1010n, fn(-0b100n, 0b1010n));
  assertEquals(-0b1010n, fn(0b1100n, -0b110n));
  assertEquals(1n, fn(-(2n ** 64n) + 1n, -(2n ** 64n)));
  assertOptimized(fn);

  assertEquals(0b0110, fn(0b1100, 0b1010));
  assertUnoptimized(fn);
})();
node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-compare.js                                         0000664 0000000 0000000 00000003453 14746647661 0023572 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

function LessThan(x, y) {
  return x < y;
}

function LessThanOrEqual(x, y) {
  return x <= y;
}

function GreaterThan(x, y) {
  return x > y;
}

function GreaterThanOrEqual(x, y) {
  return x >= y;
}

function Test(f, large, lt, eq) {
  assertEquals(lt, f(1n, 2n));
  assertEquals(!lt, f(0n, -1n));
  assertEquals(eq, f(-42n, -42n));
  assertEquals(!lt, f(-(2n ** 62n), -(2n ** 63n) + 1n));
  assertEquals(lt, f(-(2n ** 63n) + 1n, (2n ** 63n) - 1n));
  if (large) {
    assertEquals(lt, f(2n ** 63n - 1n, 2n ** 63n));
    assertEquals(!lt, f(-(2n ** 63n) + 1n, -(2n ** 63n)));
    assertEquals(lt, f(-(13n ** 70n), 13n ** 70n));     // Different signs
    assertEquals(!lt, f(13n ** 70n, -(13n ** 70n)));
    assertEquals(lt, f(13n ** 80n, 13n ** 90n));        // Different lengths
    assertEquals(!lt, f(-(13n ** 70n), -(13n ** 80n))); // Same length
    assertEquals(eq, f(13n ** 70n, 13n ** 70n));
  }
}

function OptAndTest(f, large) {
  const lt = f === LessThan || f === LessThanOrEqual;
  const eq = f === LessThanOrEqual || f === GreaterThanOrEqual;
  %PrepareFunctionForOptimization(f);
  Test(f, large, lt, eq);
  assertUnoptimized(f);
  %OptimizeFunctionOnNextCall(f);
  Test(f, large, lt, eq);
  assertOptimized(f);
}

OptAndTest(LessThan, false);
OptAndTest(LessThanOrEqual, false);
OptAndTest(GreaterThan, false);
OptAndTest(GreaterThanOrEqual, false);
if (%Is64Bit()) {
  // Should deopt on large bigints and there should not be deopt loops.
  OptAndTest(LessThan, true);
  OptAndTest(LessThanOrEqual, true);
  OptAndTest(GreaterThan, true);
  OptAndTest(GreaterThanOrEqual, true);
}
                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-constructor.js                                     0000664 0000000 0000000 00000006335 14746647661 0024533 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

(function () {
  function ToBigInt(x) {
    return BigInt(x);
  }

  %PrepareFunctionForOptimization(ToBigInt);
  assertEquals(0n, ToBigInt(0));
  %OptimizeFunctionOnNextCall(ToBigInt);

  // Test the builtin ToBigIntConvertNumber.
  assertThrows(() => ToBigInt(undefined), TypeError);

  assertEquals(0n, ToBigInt(false));
  assertEquals(1n, ToBigInt(true));

  assertEquals(42n, ToBigInt(42n));

  assertEquals(3n, ToBigInt(3));
  assertEquals(0xdeadbeefn, ToBigInt(0xdeadbeef));
  assertEquals(-0xdeadbeefn, ToBigInt(-0xdeadbeef));

  assertEquals(2n, ToBigInt("2"));
  assertEquals(0xdeadbeefdeadbeefdn, ToBigInt("0xdeadbeefdeadbeefd"));
  assertThrows(() => ToBigInt("-0x10"), SyntaxError);

  assertThrows(() => ToBigInt(Symbol("foo")), TypeError);
  assertOptimized(ToBigInt);
})();

{
  // Test constants to BigInts.
  function OptimizeAndTest(expected, fun) {
    %PrepareFunctionForOptimization(fun);
    assertEquals(expected, fun());
    %OptimizeFunctionOnNextCall(fun);
    assertEquals(expected, fun());
    assertOptimized(fun);
  }

  OptimizeAndTest(42n, () => BigInt(42n));

  // MinusZero
  OptimizeAndTest(0n, () => BigInt(-0));
  OptimizeAndTest(0n, () => BigInt.asIntN(32, BigInt(-0)));
  OptimizeAndTest(0n, () => BigInt.asUintN(32, BigInt(-0)));
  OptimizeAndTest(0n, () => 0n + BigInt(-0));

  // Smi
  OptimizeAndTest(42n, () => BigInt(42));
  OptimizeAndTest(42n, () => BigInt.asIntN(32, BigInt(42)));
  OptimizeAndTest(42n, () => BigInt.asUintN(32, BigInt(42)));
  OptimizeAndTest(42n, () => 0n + BigInt(42));

  // Signed32
  OptimizeAndTest(-0x80000000n, () => BigInt(-0x80000000));
  OptimizeAndTest(-0x80000000n, () => BigInt.asIntN(32, BigInt(-0x80000000)));
  OptimizeAndTest(0x80000000n, () => BigInt.asUintN(32, BigInt(-0x80000000)));
  OptimizeAndTest(-0x80000000n, () => 0n + BigInt(-0x80000000));

  // Unsigned32
  OptimizeAndTest(0x80000000n, () => BigInt(0x80000000));
  OptimizeAndTest(-0x80000000n, () => BigInt.asIntN(32, BigInt(0x80000000)));
  OptimizeAndTest(0x80000000n, () => BigInt.asUintN(32, BigInt(0x80000000)));
  OptimizeAndTest(0x80000000n, () => 0n + BigInt(0x80000000));
}

(function () {
  function SmiToBigInt(arr) {
    return BigInt(arr[0]);
  }

  // Element kind: PACKED_SMI_ELEMENTS
  const numbers = [0x3fffffff, 0, -0x40000000];
  %PrepareFunctionForOptimization(SmiToBigInt);
  assertEquals(0x3fffffffn, SmiToBigInt(numbers));
  %OptimizeFunctionOnNextCall(SmiToBigInt);
  assertEquals(0x3fffffffn, SmiToBigInt(numbers));
  assertOptimized(SmiToBigInt);

  // Change the map of {numbers}.
  numbers[1] = 0x80000000;
  assertEquals(0x3fffffffn, SmiToBigInt(numbers));
  assertUnoptimized(SmiToBigInt);
})();

(function () {
  function ToBigInt() {
    return BigInt(123);
  }

  %PrepareFunctionForOptimization(ToBigInt);
  assertEquals(123n, ToBigInt());
  %OptimizeFunctionOnNextCall(ToBigInt);
  assertEquals(123n, ToBigInt());
  assertOptimized(ToBigInt);

  // Replace the global BigInt object.
  BigInt = () => 42;
  assertUnoptimized(ToBigInt);
  assertEquals(42, ToBigInt());
})();
                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-divide.js                                          0000664 0000000 0000000 00000002041 14746647661 0023400 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan


function OptimizeAndTest() {
  function fn(a, b) {
    return a / b;
  }

  %PrepareFunctionForOptimization(fn);
  assertEquals(0n, fn(3n, 4n));
  assertEquals(3n, fn(3n, 1n));
  assertEquals(4n, fn(30n, 7n));

  %OptimizeFunctionOnNextCall(fn);
  assertEquals(0n, fn(3n, 4n));
  assertEquals(3n, fn(3n, 1n));
  assertEquals(4n, fn(30n, 7n));
  assertOptimized(fn);

  assertEquals(5, fn(30, 6));
  assertUnoptimized(fn);
}

function OptimizeAndTestDivZero() {
  function fn(a, b) {
    return a / b;
  }

  %PrepareFunctionForOptimization(fn);
  assertEquals(0n, fn(3n, 4n));
  assertEquals(4n, fn(30n, 7n));

  %OptimizeFunctionOnNextCall(fn);
  assertEquals(4n, fn(30n, 7n));
  assertOptimized(fn);

  assertThrows(() => fn(3n, 0n), RangeError);
  assertUnoptimized(fn);
}

OptimizeAndTest();
OptimizeAndTestDivZero();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-equal.js                                           0000664 0000000 0000000 00000002105 14746647661 0023244 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

const bi = 42n;

function Equal(x, y) {
  return x == y;
}

function StrictEqual(x, y) {
  return x === y;
}

function Test(f, large) {
  assertEquals(false, f(1n, 2n));
  assertEquals(false, f(1n, -1n));
  assertEquals(true, f(-1n, -1n));
  assertEquals(true, f(bi, bi));
  assertEquals(false, f(2n ** 63n - 1n, -(2n ** 63n) + 1n));
  if (large) {
    assertEquals(false, f(2n ** 63n, -(2n ** 63n)));
    assertEquals(true, f(13n ** 70n, 13n ** 70n));
  }
}

function OptAndTest(f, large) {
  %PrepareFunctionForOptimization(f);
  Test(f, large);
  assertUnoptimized(f);
  %OptimizeFunctionOnNextCall(f);
  Test(f, large);
  assertOptimized(f);
}

OptAndTest(Equal, false);
OptAndTest(StrictEqual, false);
if (%Is64Bit()) {
  // Should deopt on large bigints and there should not be deopt loops.
  OptAndTest(Equal, true);
  OptAndTest(StrictEqual, true);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-int64-lowered.js                                   0000664 0000000 0000000 00000005515 14746647661 0024550 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan

function TestAsIntN() {
  assertEquals(0n, BigInt.asIntN(64, 0n));
  assertEquals(0n, BigInt.asIntN(8, 0n));
  assertEquals(0n, BigInt.asIntN(1, 0n));
  assertEquals(0n, BigInt.asIntN(0, 0n));
  assertEquals(0n, BigInt.asIntN(100, 0n));

  assertEquals(123n, BigInt.asIntN(64, 123n));
  assertEquals(123n, BigInt.asIntN(32, 123n));
  assertEquals(123n, BigInt.asIntN(8, 123n));
  assertEquals(-5n, BigInt.asIntN(6, 123n));
  assertEquals(-5n, BigInt.asIntN(5, 123n));
  assertEquals(-5n, BigInt.asIntN(4, 123n));
  assertEquals(-1n, BigInt.asIntN(1, 123n));
  assertEquals(0n, BigInt.asIntN(0, 123n));
  assertEquals(123n, BigInt.asIntN(72, 123n));

  assertEquals(-123n, BigInt.asIntN(64, -123n));
  assertEquals(-123n, BigInt.asIntN(32, -123n));
  assertEquals(-123n, BigInt.asIntN(8, -123n));
  assertEquals(5n, BigInt.asIntN(6, -123n));
  assertEquals(5n, BigInt.asIntN(5, -123n));
  assertEquals(5n, BigInt.asIntN(4, -123n));
  assertEquals(-1n, BigInt.asIntN(1, -123n));
  assertEquals(0n, BigInt.asIntN(0, -123n));
  assertEquals(-123n, BigInt.asIntN(72, -123n));
}

function TestInt64LoweredOperations() {
  assertEquals(0n, BigInt.asIntN(64, -0n));
  assertEquals(0n, BigInt.asIntN(64, 15n + -15n));
  assertEquals(0n, BigInt.asIntN(64, 0n + 0n));
  assertEquals(14n, BigInt.asIntN(32, 8n + 6n));
  assertEquals(-211n, BigInt.asIntN(10, 1013n + -200n));
  assertEquals(-1n, BigInt.asIntN(4, -319n + 302n));
  assertEquals(32n, BigInt.asIntN(64, (2n ** 100n + 64n) - 32n));
  assertEquals(-32n, BigInt.asIntN(64, 32n - (2n ** 100n + 64n)));
  assertEquals(-5n, BigInt.asIntN(4, 800n - 789n));
  assertEquals(5n, BigInt.asIntN(4, 789n - 800n));

  for (let i = 0; i < 2; ++i) {
    let x = 32n; // x = 32n
    if (i === 1) {
      x = BigInt.asIntN(64, x + 3n); // x = 35n
      const y = x + -8n + x; // x = 35n, y = 62n
      x = BigInt.asIntN(6, y + x); // x = -31n, y = 62n
      x = -9n + y - x; // x = 84n
      x = BigInt.asIntN(10000 * i, x); // x = 84n
    } else {
      x = x + 400n; // x = 432n
      x = 176n + BigInt.asIntN(8, 500n) + x; // x = 596n
    }
    assertEquals(84n, BigInt.asIntN(8, x));
  }

  let x = 7n;
  for (let i = 0; i < 10; ++i) {
    x = x + 5n;
  }
  assertEquals(-7n, BigInt.asIntN(6, x));

  let y = 7n;
  for(let i = 0; i < 10; ++i) {
    y = BigInt.asIntN(4, y + 16n);
  }
  assertEquals(7n, y);
}

function OptimizeAndTest(fn) {
  %PrepareFunctionForOptimization(fn);
  %PrepareFunctionForOptimization(assertEquals);
  %PrepareFunctionForOptimization(deepEquals);
  fn();
  fn();
  %OptimizeFunctionOnNextCall(fn);
  fn();
  assertOptimized(fn);
  fn();
}

OptimizeAndTest(TestAsIntN);
OptimizeAndTest(TestInt64LoweredOperations);
                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-modulus.js                                         0000664 0000000 0000000 00000002070 14746647661 0023626 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan


(function OptimizeAndTest() {
  function fn(a, b) {
    return a % b;
  }

  %PrepareFunctionForOptimization(fn);
  assertEquals(3n, fn(3n, 4n));
  assertEquals(0n, fn(3n, 1n));
  assertEquals(2n, fn(2n ** 64n, 7n));

  %OptimizeFunctionOnNextCall(fn);
  assertEquals(3n, fn(3n, 4n));
  assertEquals(0n, fn(3n, 1n));
  assertEquals(-5n, fn(-32n, 9n));
  assertEquals(2n, fn(2n ** 64n, 7n));
  assertOptimized(fn);

  assertEquals(4, fn(32, 7));
  assertUnoptimized(fn);
})();

(function OptimizeAndTestDivZero() {
  function fn(a, b) {
    return a % b;
  }

  %PrepareFunctionForOptimization(fn);
  assertEquals(3n, fn(3n, 4n));
  assertEquals(2n, fn(2n ** 64n, 7n));

  %OptimizeFunctionOnNextCall(fn);
  assertEquals(2n, fn(2n ** 64n, 7n));
  assertOptimized(fn);

  assertThrows(() => fn(3n, 0n), RangeError);
  assertUnoptimized(fn);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-multiply-truncate.js                               0000664 0000000 0000000 00000001472 14746647661 0025645 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

function TestMultiplyAndTruncate(a, b) {
  return BigInt.asIntN(3, a * b);
}

function OptimizeAndTest(fn) {
  let bi = 2n ** (2n ** 29n);
  if (%Is64Bit()) {
    %PrepareFunctionForOptimization(fn);
    assertEquals(-4n, fn(3n, 4n));
    assertEquals(-2n, fn(5n, 6n));
    %OptimizeFunctionOnNextCall(fn);
    // After optimization, operands are truncated to Word64
    // before being multiplied. No exceptions should be thrown
    // and the correct result is expected.
    assertEquals(-4n, fn(bi + 3n, bi + 4n));
    assertOptimized(fn);
  }
}

OptimizeAndTest(TestMultiplyAndTruncate);
                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-multiply.js                                        0000664 0000000 0000000 00000001127 14746647661 0024017 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

function TestMultiply(a, b) {
  return a * b;
}

function OptimizeAndTest(fn) {
  %PrepareFunctionForOptimization(fn);
  assertEquals(12n, fn(3n, 4n));
  assertEquals(30n, fn(5n, 6n));
  %OptimizeFunctionOnNextCall(fn);
  assertEquals(56n, fn(7n, 8n));
  assertOptimized(fn);
  assertEquals(56, fn(7, 8));
  assertUnoptimized(fn);
}

OptimizeAndTest(TestMultiply);
                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-negate.js                                          0000664 0000000 0000000 00000001061 14746647661 0023400 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan

function TestNegate() {
  assertEquals(0n, -0n);

  const x = 15n;
  assertEquals(-15n, -x);
  assertEquals(15n, - -x);
  assertEquals(30n, -(-x + -x));
}

function OptimizeAndTest(fn) {
  %PrepareFunctionForOptimization(fn);
  fn();
  fn();
  %OptimizeFunctionOnNextCall(fn);
  fn();
  assertOptimized(fn);
  fn();
}

OptimizeAndTest(TestNegate);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-rematerialize.js                                   0000664 0000000 0000000 00000007743 14746647661 0025007 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

(function OptimizeAndTestAsUintN() {
  function f(x) {
    // Will be lowered to Int64Constant(-1) and stored as an immediate.
    let y = BigInt.asUintN(64, -1n);
    try {
      return x + y;
    } catch(_) {
      return y;
    }
  }

  %PrepareFunctionForOptimization(f);
  assertEquals(2n ** 64n, f(1n));
  assertEquals(2n ** 64n + 1n, f(2n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(2n ** 64n, f(1n));
  assertOptimized(f);
  // Should be rematerialized to 2n ** 64n - 1n in code generation.
  assertEquals(2n ** 64n - 1n, f(0));
  if (%Is64Bit()) {
    assertUnoptimized(f);
  }
})();

(function OptimizeAndTestAsUintN() {
  function f(x) {
    // Will be lowered to Int64Sub because exponentiation is not truncated and
    // stored in a register.
    let y = BigInt.asUintN(64, -(2n ** 0n));
    try {
      return x + y;
    } catch(_) {
      return y;
    }
  }

  %PrepareFunctionForOptimization(f);
  assertEquals(2n ** 64n, f(1n));
  assertEquals(2n ** 64n + 1n, f(2n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(2n ** 64n, f(1n));
  assertOptimized(f);
  // Should be rematerialized to 2n ** 64n - 1n in deoptimization.
  assertEquals(2n ** 64n - 1n, f(0));
  if (%Is64Bit()) {
    assertUnoptimized(f);
  }
})();

(function OptimizeAndTestAsUintN() {
  function f(x) {
    // Will be lowered to Int64Sub because exponentiation is not truncated and
    // stored in a stack slot.
    let y = BigInt.asUintN(64, -(2n ** 0n));
    try {
      // The recursion is used to make sure `y` is stored on the stack.
      return (x < 3n) ? (x + y) : f(x - 1n);
    } catch(_) {
      return y;
    }
  }

  %PrepareFunctionForOptimization(f);
  assertEquals(2n ** 64n, f(1n));
  assertEquals(2n ** 64n + 1n, f(2n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(2n ** 64n, f(1n));
  assertOptimized(f);
  // Should be rematerialized to 2n ** 64n - 1n in deoptimization.
  assertEquals(2n ** 64n - 1n, f(0));
  if (%Is64Bit()) {
    assertUnoptimized(f);
  }
})();

(function OptimizeAndTestAsIntN() {
  function f(x) {
    // Will be lowered to Int64Constant(-1) and stored as an immediate.
    let y = BigInt.asIntN(64, -1n);
    try {
      return x + y;
    } catch (_) {
      return y;
    }
  }

  %PrepareFunctionForOptimization(f);
  assertEquals(0n, f(1n));
  assertEquals(1n, f(2n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(0n, f(1n));
  assertOptimized(f);
  // Should be rematerialized to -1n in code generation.
  assertEquals(-1n, f(0));
  if (%Is64Bit()) {
    assertUnoptimized(f);
  }
})();

(function OptimizeAndTestAsIntN() {
  function f(x) {
    // Will be lowered to Int64Sub because exponentiation is not truncated and
    // stored in a register.
    let y = BigInt.asIntN(64, -(2n ** 0n));
    try {
      return x + y;
    } catch(_) {
      return y;
    }
  }

  %PrepareFunctionForOptimization(f);
  assertEquals(0n, f(1n));
  assertEquals(1n, f(2n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(0n, f(1n));
  assertOptimized(f);
  // Should be rematerialized to -1n in deoptimization.
  assertEquals(-1n, f(0));
  if (%Is64Bit()) {
    assertUnoptimized(f);
  }
})();

(function OptimizeAndTestAsIntN() {

  function f(x) {
    // Will be lowered to Int64Sub because exponentiation is not truncated and
    // stored in a stack slot.
    let y = BigInt.asIntN(64, -(2n ** 0n));
    try {
      // The recursion is used to make sure `y` is stored on the stack.
      return (x < 3n) ? (x + y) : f(x - 1n);
    } catch(_) {
      return y;
    }
  }

  %PrepareFunctionForOptimization(f);
  assertEquals(0n, f(1n));
  assertEquals(1n, f(2n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(0n, f(1n));
  assertOptimized(f);
  // Should be rematerialized to -1n in deoptimization.
  assertEquals(-1n, f(0));
  if (%Is64Bit()) {
    assertUnoptimized(f);
  }
})();
                             node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-shift-left.js                                      0000664 0000000 0000000 00000007354 14746647661 0024215 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

(function OptimizeAndTest() {
  function ShiftLeft(a, b) {
    return a << b;
  }
  %PrepareFunctionForOptimization(ShiftLeft);
  assertEquals(0n, ShiftLeft(0n, 42n));
  assertEquals(-42n, ShiftLeft(-42n, 0n));
  assertEquals(2n ** 42n, ShiftLeft(1n, 42n));
  assertEquals(-2n, ShiftLeft(-(2n ** 512n), -511n));
  assertEquals(-1n, ShiftLeft(-(2n ** 512n), -513n));

  %OptimizeFunctionOnNextCall(ShiftLeft);
  assertEquals(0n, ShiftLeft(0n, 42n));
  assertEquals(-42n, ShiftLeft(-42n, 0n));
  assertEquals(2n ** 42n, ShiftLeft(1n, 42n));
  assertEquals(-2n, ShiftLeft(-(2n ** 512n), -511n));
  assertEquals(-1n, ShiftLeft(-(2n ** 512n), -513n));
  assertOptimized(ShiftLeft);

  assertThrows(() => ShiftLeft(1n, 2n ** 30n), RangeError);
  assertUnoptimized(ShiftLeft);
})();

(function OptimizeAndTest() {
  function ShiftLeftByPositive(a) {
    return BigInt.asIntN(62, a << 42n);
  }
  %PrepareFunctionForOptimization(ShiftLeftByPositive);
  assertEquals(0n, ShiftLeftByPositive(0n));

  %OptimizeFunctionOnNextCall(ShiftLeftByPositive);
  assertEquals(0n, ShiftLeftByPositive(0n));
  assertEquals(2n ** 42n, ShiftLeftByPositive(1n));
  assertEquals(2n ** 42n, ShiftLeftByPositive(1n + 2n ** 62n));
  assertEquals(-(2n ** 42n), ShiftLeftByPositive(-1n - 2n ** 64n));
  assertOptimized(ShiftLeftByPositive);

  assertThrows(() => ShiftLeftByPositive(0), TypeError);
  assertUnoptimized(ShiftLeftByPositive);
})();

(function OptimizeAndTest() {
  const minus42 = -42n;
  function ShiftLeftByNegative(a) {
    return BigInt.asIntN(62, BigInt.asUintN(64, a) << minus42);
  }
  %PrepareFunctionForOptimization(ShiftLeftByNegative);
  assertEquals(0n, ShiftLeftByNegative(0n));

  %OptimizeFunctionOnNextCall(ShiftLeftByNegative);
  assertEquals(0n, ShiftLeftByNegative(42n));
  assertEquals(4194303n, ShiftLeftByNegative(-42n));
  assertEquals(2n ** 20n, ShiftLeftByNegative(1n + 2n ** 62n));
  assertEquals(3145727n, ShiftLeftByNegative(-1n - 2n ** 62n - 2n ** 64n));
  assertOptimized(ShiftLeftByNegative);

  assertThrows(() => ShiftLeftByNegative(0), TypeError);
  if (%Is64Bit()) {
    // BigInt truncation is not inlined on 32-bit platforms so there is no
    // checks for BigInt, thus deopt will not be triggered.
    assertUnoptimized(ShiftLeftByNegative);
  }
})();

(function OptimizeAndTest() {
  function ShiftLeftBy64(a) {
    return BigInt.asIntN(62, a << 64n);
  }
  %PrepareFunctionForOptimization(ShiftLeftBy64);
  assertEquals(0n, ShiftLeftBy64(0n));

  %OptimizeFunctionOnNextCall(ShiftLeftBy64);
  assertEquals(0n, ShiftLeftBy64(0n));
  assertEquals(0n, ShiftLeftBy64(1n));
  assertEquals(0n, ShiftLeftBy64(1n + 2n ** 62n));
  assertEquals(0n, ShiftLeftBy64(-1n - 2n ** 64n));
  assertOptimized(ShiftLeftBy64);

  assertThrows(() => ShiftLeftBy64(0), TypeError);
  assertUnoptimized(ShiftLeftBy64);
})();

(function OptimizeAndTest() {
  const bi = 2n ** 62n;
  function ShiftLeftByLarge(a) {
    return BigInt.asIntN(62, a << bi);
  }
  %PrepareFunctionForOptimization(ShiftLeftByLarge);
  assertEquals(0n, ShiftLeftByLarge(0n));

  %OptimizeFunctionOnNextCall(ShiftLeftByLarge);
  assertEquals(0n, ShiftLeftByLarge(0n));
  if (%Is64Bit()) {
    // After optimization, a truncated left shift will not throw a
    // BigIntTooBig exception just as truncated addition.
    assertEquals(0n, ShiftLeftByLarge(1n));
    assertEquals(0n, ShiftLeftByLarge(1n + 2n ** 62n));
    assertEquals(0n, ShiftLeftByLarge(-1n - 2n ** 64n));
  }
  assertOptimized(ShiftLeftByLarge);

  assertThrows(() => ShiftLeftByLarge(0), TypeError);
  assertUnoptimized(ShiftLeftByLarge);
})();
                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-shift-right.js                                     0000664 0000000 0000000 00000012055 14746647661 0024372 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

(function OptimizeAndTest() {
  function ShiftRight(a, b) {
    return a >> b;
  }
  %PrepareFunctionForOptimization(ShiftRight);
  assertEquals(0n, ShiftRight(0n, 42n));
  assertEquals(-42n, ShiftRight(-42n, 0n));
  assertEquals(-3n, ShiftRight(-5n, 1n));
  assertEquals(0n, ShiftRight(42n, 2n ** 64n));
  assertEquals(-1n, ShiftRight(-42n, 64n));
  assertEquals(-1n, ShiftRight(-42n, 2n ** 64n));

  %OptimizeFunctionOnNextCall(ShiftRight);
  assertEquals(0n, ShiftRight(0n, 42n));
  assertEquals(-42n, ShiftRight(-42n, 0n));
  assertEquals(-3n, ShiftRight(-5n, 1n));
  assertEquals(0n, ShiftRight(42n, 2n ** 64n));
  assertEquals(-1n, ShiftRight(-42n, 64n));
  assertEquals(-1n, ShiftRight(-42n, 2n ** 64n));
  assertOptimized(ShiftRight);

  assertThrows(() => ShiftRight(1n, -(2n ** 30n)), RangeError);
  assertUnoptimized(ShiftRight);
})();

(function OptimizeAndTest() {
  function ShiftRightUnsignedByPositive(a) {
    return BigInt.asIntN(62, BigInt.asUintN(64, a) >> 42n);
  }
  %PrepareFunctionForOptimization(ShiftRightUnsignedByPositive);
  assertEquals(0n, ShiftRightUnsignedByPositive(0n));

  %OptimizeFunctionOnNextCall(ShiftRightUnsignedByPositive);
  assertEquals(0n, ShiftRightUnsignedByPositive(42n));
  assertEquals(4194303n, ShiftRightUnsignedByPositive(-42n));
  assertEquals(2n ** 20n, ShiftRightUnsignedByPositive(1n + 2n ** 62n));
  assertEquals(3145727n,
               ShiftRightUnsignedByPositive(-1n - 2n ** 62n - 2n ** 64n));
  assertOptimized(ShiftRightUnsignedByPositive);

  assertThrows(() => ShiftRightUnsignedByPositive(0), TypeError);
  if (%Is64Bit()) {
    // BigInt truncation is not inlined on 32-bit platforms so there is no
    // checks for BigInt, thus deopt will not be triggered.
    assertUnoptimized(ShiftRightUnsignedByPositive);
  }
})();

(function OptimizeAndTest() {
  function ShiftRightSignedByPositive(a) {
    return BigInt.asIntN(62, BigInt.asIntN(64, a) >> 42n);
  }
  %PrepareFunctionForOptimization(ShiftRightSignedByPositive);
  assertEquals(0n, ShiftRightSignedByPositive(0n));

  %OptimizeFunctionOnNextCall(ShiftRightSignedByPositive);
  assertEquals(0n, ShiftRightSignedByPositive(42n));
  assertEquals(-1n, ShiftRightSignedByPositive(-42n));
  assertEquals(2n ** 20n, ShiftRightSignedByPositive(1n + 2n ** 62n));
  assertEquals(-(2n ** 20n),
               ShiftRightSignedByPositive(-(2n ** 62n) - 2n ** 64n));
  assertOptimized(ShiftRightSignedByPositive);

  assertThrows(() => ShiftRightSignedByPositive(0), TypeError);
  if (%Is64Bit()) {
    // BigInt truncation is not inlined on 32-bit platforms so there is no
    // checks for BigInt, thus deopt will not be triggered.
    assertUnoptimized(ShiftRightSignedByPositive);
  }
})();

(function OptimizeAndTest() {
  const minus42 = -42n;
  function ShiftRightByNegative(a) {
    return BigInt.asIntN(62, a >> minus42);
  }
  %PrepareFunctionForOptimization(ShiftRightByNegative);
  assertEquals(0n, ShiftRightByNegative(0n));

  %OptimizeFunctionOnNextCall(ShiftRightByNegative);
  assertEquals(0n, ShiftRightByNegative(0n));
  assertEquals(2n ** 42n, ShiftRightByNegative(1n));
  assertEquals(2n ** 42n, ShiftRightByNegative(1n + 2n ** 62n));
  assertEquals(-(2n ** 42n), ShiftRightByNegative(-1n - 2n ** 64n));
  assertOptimized(ShiftRightByNegative);

  assertThrows(() => ShiftRightByNegative(0), TypeError);
  assertUnoptimized(ShiftRightByNegative);
})();

(function OptimizeAndTest() {
  function ShiftRightBy64(a) {
    return BigInt.asIntN(62, BigInt.asUintN(64, a) >> 64n);
  }
  %PrepareFunctionForOptimization(ShiftRightBy64);
  assertEquals(0n, ShiftRightBy64(0n));

  %OptimizeFunctionOnNextCall(ShiftRightBy64);
  assertEquals(0n, ShiftRightBy64(0n));
  assertEquals(0n, ShiftRightBy64(1n));
  assertEquals(0n, ShiftRightBy64(1n + 2n ** 62n));
  assertEquals(0n, ShiftRightBy64(-1n - 2n ** 64n));
  assertOptimized(ShiftRightBy64);

  assertThrows(() => ShiftRightBy64(0), TypeError);
  if (%Is64Bit()) {
    // BigInt truncation is not inlined on 32-bit platforms so there is no
    // checks for BigInt, thus deopt will not be triggered.
    assertUnoptimized(ShiftRightBy64);
  }
})();

(function OptimizeAndTest() {
  const bi = 2n ** 64n;
  function ShiftRightByLarge(a) {
    return BigInt.asIntN(62, BigInt.asIntN(64, a) >> bi);
  }
  %PrepareFunctionForOptimization(ShiftRightByLarge);
  assertEquals(0n, ShiftRightByLarge(0n));

  %OptimizeFunctionOnNextCall(ShiftRightByLarge);
  assertEquals(0n, ShiftRightByLarge(0n));
  assertEquals(-1n, ShiftRightByLarge(-1n));
  assertEquals(0n, ShiftRightByLarge(1n + 2n ** 62n));
  assertEquals(-1n, ShiftRightByLarge(-1n - 2n ** 64n));
  assertOptimized(ShiftRightByLarge);

  assertThrows(() => ShiftRightByLarge(0), TypeError);
  if (%Is64Bit()) {
    // BigInt truncation is not inlined on 32-bit platforms so there is no
    // checks for BigInt, thus deopt will not be triggered.
    assertUnoptimized(ShiftRightByLarge);
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-uint64-lowered.js                                  0000664 0000000 0000000 00000005711 14746647661 0024733 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan

function TestAsUintN() {
  assertEquals(0n, BigInt.asUintN(64, 0n));
  assertEquals(0n, BigInt.asUintN(8, 0n));
  assertEquals(0n, BigInt.asUintN(1, 0n));
  assertEquals(0n, BigInt.asUintN(0, 0n));
  assertEquals(0n, BigInt.asUintN(100, 0n));

  assertEquals(123n, BigInt.asUintN(64, 123n));
  assertEquals(123n, BigInt.asUintN(32, 123n));
  assertEquals(123n, BigInt.asUintN(8, 123n));
  assertEquals(59n, BigInt.asUintN(6, 123n));
  assertEquals(27n, BigInt.asUintN(5, 123n));
  assertEquals(11n, BigInt.asUintN(4, 123n));
  assertEquals(1n, BigInt.asUintN(1, 123n));
  assertEquals(0n, BigInt.asUintN(0, 123n));
  assertEquals(123n, BigInt.asUintN(72, 123n));

  assertEquals(BigInt("0xFFFFFFFFFFFFFF85"), BigInt.asUintN(64, -123n));
  assertEquals(BigInt("0xFFFFFF85"), BigInt.asUintN(32, -123n));
  assertEquals(BigInt("0x85"), BigInt.asUintN(8, -123n));
  assertEquals(5n, BigInt.asUintN(6, -123n));
  assertEquals(5n, BigInt.asUintN(5, -123n));
  assertEquals(5n, BigInt.asUintN(4, -123n));
  assertEquals(1n, BigInt.asUintN(1, -123n));
  assertEquals(0n, BigInt.asUintN(0, -123n));
  assertEquals(BigInt("0xFFFFFFFFFFFFFFFF85"), BigInt.asUintN(72, -123n));
}

function TestUint64LoweredOperations() {
  assertEquals(0n, BigInt.asUintN(64, -0n));
  assertEquals(0n, BigInt.asUintN(64, 15n + -15n));
  assertEquals(0n, BigInt.asUintN(64, 0n + 0n));
  assertEquals(14n, BigInt.asUintN(32, 8n + 6n));
  assertEquals(813n, BigInt.asUintN(10, 1013n + -200n));
  assertEquals(15n, BigInt.asUintN(4, -319n + 302n));
  assertEquals(32n, BigInt.asUintN(64, (2n ** 100n + 64n) - 32n));
  assertEquals(2n ** 64n - 32n, BigInt.asUintN(64, 32n - (2n ** 100n + 64n)));
  assertEquals(11n, BigInt.asUintN(4, 800n - 789n));
  assertEquals(5n, BigInt.asUintN(4, 789n - 800n));

  for (let i = 0; i < 2; ++i) {
    let x = 32n; // x = 32n
    if (i === 1) {
      x = BigInt.asUintN(64, x + 3n); // x = 35n
      const y = x + -8n + x; // x = 35n, y = 62n
      x = BigInt.asUintN(6, y + x); // x = 33n, y = 62n
      x = -9n + y - x; // x = 20n
      x = BigInt.asUintN(10000 * i, x); // x = 20n
    } else {
      x = x + 400n; // x = 432n
      x = -144n + BigInt.asUintN(8, 500n) + x; // x = 532n
    }
    assertEquals(20n, BigInt.asUintN(8, x));
  }

  let x = 7n;
  for (let i = 0; i < 10; ++i) {
    x = x + 5n;
  }
  assertEquals(57n, BigInt.asUintN(8, x));

  let y = 7n;
  for(let i = 0; i < 10; ++i) {
    y = BigInt.asUintN(4, y + 16n);
  }
  assertEquals(7n, y);
}

function OptimizeAndTest(fn) {
  %PrepareFunctionForOptimization(fn);
  %PrepareFunctionForOptimization(assertEquals);
  %PrepareFunctionForOptimization(deepEquals);
  fn();
  fn();
  %OptimizeFunctionOnNextCall(fn);
  fn();
  assertOptimized(fn);
  fn();
}

OptimizeAndTest(TestAsUintN);
OptimizeAndTest(TestUint64LoweredOperations);
                                                       node-23.7.0/deps/v8/test/mjsunit/compiler/bigint-unused-still-throws.js                             0000664 0000000 0000000 00000002563 14746647661 0026121 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan

function WarmupAndOptimize(f)  {
  %PrepareFunctionForOptimization(f);
  f(1n, 1n);
  %OptimizeFunctionOnNextCall(f);
  f(1n, 1n);
  assertOptimized(f);
}
%NeverOptimizeFunction(WarmupAndOptimize);

function TestBinary(f) {
  WarmupAndOptimize(f);
  assertThrows(() => { f(1, 1n); }, TypeError);
  // Recompile in case the above deopts.
  WarmupAndOptimize(f);
  assertThrows(() => { f(1n, 1); }, TypeError);
}
%NeverOptimizeFunction(TestBinary);

function Add(a, b) {
  let [c] = [1n];
  let temp = 0n;
  temp = a + c;
  temp = c + b;
  temp = 42n;
  result = temp;
}
TestBinary(Add);

function Subtract(a, b) {
  let [c] = [1n];
  let temp = 0n;
  temp = a - c;
  temp = c - b;
  temp = 42n;
  result = temp;
}
TestBinary(Subtract);

function Multiply(a, b) {
  let [c] = [1n];
  let temp = 0n;
  temp = a * c;
  temp = c * b;
  temp = 42n;
  result = temp;
}
TestBinary(Multiply);

function Divide(a, b) {
  let [c] = [1n];
  let temp = 0n;
  temp = a / c;
  temp = c / b;
  temp = 42n;
  result = temp;
}
TestBinary(Divide);

function BitwiseAnd(a, b) {
  let [c] = [1n];
  let temp = 0n;
  temp = a & c;
  temp = c & b;
  temp = 42n;
  result = temp;
}
TestBinary(BitwiseAnd);
                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/compiler/bigint64-add-no-deopt-loop.js                             0000664 0000000 0000000 00000006045 14746647661 0025540 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

(function OptimizeAndTestNegativeLimit() {
  function f(x, y) {
    return x + y;
  }
  %PrepareFunctionForOptimization(f);
  assertEquals(1n, f(0n, 1n));
  assertEquals(5n, f(2n, 3n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(-(2n ** 63n), f(-(2n ** 63n), 0n));
  assertOptimized(f);
  // Re-prepare the function before the first deopt to ensure type feedback is
  // not cleared by an umtimely gc.
  %PrepareFunctionForOptimization(f);
  assertOptimized(f);
  // CheckBigInt64 should trigger deopt on INT_MIN - 1.
  assertEquals(-(2n ** 63n) - 1n, f(-(2n ** 63n) - 1n, 0n));
  if (%Is64Bit()) {
    assertUnoptimized(f);

    assertEquals(1n, f(0n, 1n));
    assertEquals(5n, f(2n, 3n));
    %OptimizeFunctionOnNextCall(f);
    assertEquals(-(2n ** 63n), f(-(2n ** 63n), 0n));
    assertOptimized(f);
    // Ensure there is no deopt loop.
    assertEquals(-(2n ** 63n) - 1n, f(-(2n ** 63n) - 1n, 0n));
    assertOptimized(f);
  }
})();

(function OptimizeAndTestPositiveLimit() {
  function f(x, y) {
    return x + y;
  }
  %PrepareFunctionForOptimization(f);
  assertEquals(1n, f(0n, 1n));
  assertEquals(5n, f(2n, 3n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(2n ** 63n - 1n, f(2n ** 63n - 1n, 0n));
  assertOptimized(f);
  // Re-prepare the function before the first deopt to ensure type feedback is
  // not cleared by an untimely gc.
  %PrepareFunctionForOptimization(f);
  assertOptimized(f);
  // CheckBigInt64 should trigger deopt on INT_MAX + 1.
  assertEquals(2n ** 63n, f(2n ** 63n, 0n));
  if (%Is64Bit()) {
    assertUnoptimized(f);

    assertEquals(1n, f(0n, 1n));
    assertEquals(5n, f(2n, 3n));
    %OptimizeFunctionOnNextCall(f);
    assertEquals(2n ** 63n - 1n, f(2n ** 63n - 1n, 0n));
    assertOptimized(f);
    // Ensure there is no deopt loop.
    assertEquals(2n ** 63n, f(2n ** 63n, 0n));
    assertOptimized(f);
  }
})();

(function OptimizeAndTestOverflow() {
  function f(x, y) {
    return x + y;
  }
  %PrepareFunctionForOptimization(f);
  assertEquals(1n, f(0n, 1n));
  assertEquals(5n, f(2n, 3n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(9n, f(4n, 5n));
  assertOptimized(f);
  assertEquals(-(2n ** 63n), f(-(2n ** 62n), -(2n ** 62n)));
  assertOptimized(f);
  // Re-prepare the function before the first deopt to ensure type feedback is
  // not cleared by an umtimely gc.
  %PrepareFunctionForOptimization(f);
  assertOptimized(f);
  // CheckedInt64Add will trigger deopt due to overflow.
  assertEquals(-(2n ** 63n) - 1n, f(-(2n ** 62n + 1n), -(2n ** 62n)));
  if (%Is64Bit()) {
    assertUnoptimized(f);

    assertEquals(1n, f(0n, 1n));
    assertEquals(5n, f(2n, 3n));
    %OptimizeFunctionOnNextCall(f);
    assertEquals(9n, f(4n, 5n));
    assertOptimized(f);
    // Ensure there is no deopt loop.
    assertEquals(-(2n ** 63n) - 1n, f(-(2n ** 62n + 1n), -(2n ** 62n)));
    assertOptimized(f);
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/compiler/bigint64-array.js                                         0000664 0000000 0000000 00000004630 14746647661 0023432 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

const bi = 18446744073709551615n; // 2n ** 64n - 1n

function storeAndLoad(x) {
  let buffer = new ArrayBuffer(16);
  let biArray = new BigInt64Array(buffer);
  biArray[0] = bi;
  biArray[1] = x;
  return biArray[0] + biArray[1];
}

%PrepareFunctionForOptimization(storeAndLoad);
assertEquals(-1n, storeAndLoad(0n));
assertEquals(41n, storeAndLoad(2n ** 64n + 42n));
assertEquals(0n, storeAndLoad(-bi));
assertEquals(-2n, storeAndLoad(bi));
%OptimizeFunctionOnNextCall(storeAndLoad);
assertEquals(-1n, storeAndLoad(0n));
assertEquals(41n, storeAndLoad(2n ** 64n + 42n));
assertEquals(0n, storeAndLoad(-bi));
assertEquals(-2n, storeAndLoad(bi));
assertOptimized(storeAndLoad);

assertEquals(-1n, storeAndLoad(false));
if (%Is64Bit()) {
  assertUnoptimized(storeAndLoad);
}

%PrepareFunctionForOptimization(storeAndLoad);
assertEquals(-1n, storeAndLoad(0n));
%OptimizeFunctionOnNextCall(storeAndLoad);
assertEquals(0n, storeAndLoad(true));
// TODO(panq): Uncomment the assertion once the deopt loop is eliminated.
// assertOptimized(storeAndLoad);

function storeAndLoadUnsigned(x) {
  let buffer = new ArrayBuffer(16);
  let biArray = new BigUint64Array(buffer);
  biArray[0] = bi;
  biArray[1] = x;
  return biArray[0] + biArray[1];
}

%PrepareFunctionForOptimization(storeAndLoadUnsigned);
assertEquals(bi, storeAndLoadUnsigned(0n));
assertEquals(bi + 42n, storeAndLoadUnsigned(2n ** 64n + 42n));
assertEquals(bi + 1n, storeAndLoadUnsigned(-bi));
assertEquals(bi * 2n, storeAndLoadUnsigned(bi));
%OptimizeFunctionOnNextCall(storeAndLoadUnsigned);
assertEquals(bi, storeAndLoadUnsigned(0n));
assertEquals(bi + 42n, storeAndLoadUnsigned(2n ** 64n + 42n));
assertEquals(bi + 1n, storeAndLoadUnsigned(-bi));
assertEquals(bi * 2n, storeAndLoadUnsigned(bi));
assertOptimized(storeAndLoadUnsigned);

assertEquals(bi, storeAndLoadUnsigned(false));
if (%Is64Bit()) {
  assertUnoptimized(storeAndLoadUnsigned);
}

%PrepareFunctionForOptimization(storeAndLoadUnsigned);
assertEquals(bi, storeAndLoadUnsigned(0n));
%OptimizeFunctionOnNextCall(storeAndLoadUnsigned);
assertEquals(bi + 1n, storeAndLoadUnsigned(true));
// TODO(panq): Uncomment the assertion once the deopt loop is eliminated.
// assertOptimized(storeAndLoadUnsigned);
                                                                                                        node-23.7.0/deps/v8/test/mjsunit/compiler/bigint64-div-no-deopt-loop.js                             0000664 0000000 0000000 00000004027 14746647661 0025570 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

(function OptimizeAndTestDivZero() {
  function f(x, y) {
    return x / y;
  }
  %PrepareFunctionForOptimization(f);
  assertEquals(0n, f(0n, 1n));
  assertEquals(-3n, f(-32n, 9n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(2n, f(14n, 5n));
  assertOptimized(f);
  // Re-prepare the function before the first deopt to ensure type feedback is
  // not cleared by an untimely gc.
  %PrepareFunctionForOptimization(f);
  assertOptimized(f);
  // CheckedInt64Div will trigger deopt due to divide-by-zero.
  assertThrows(() => f(42n, 0n), RangeError);
  if (%Is64Bit()) {
    assertUnoptimized(f);

    assertEquals(0n, f(0n, 1n));
    assertEquals(-3n, f(-32n, 9n));
    %OptimizeFunctionOnNextCall(f);
    assertEquals(2n, f(14n, 5n));
    assertOptimized(f);
    // Ensure there is no deopt loop.
    assertThrows(() => f(42n, 0n), RangeError);
    assertOptimized(f);
  }
})();

(function OptimizeAndTestOverflow() {
  function f(x, y) {
    return x / y;
  }
  %PrepareFunctionForOptimization(f);
  assertEquals(0n, f(0n, 1n));
  assertEquals(-3n, f(-32n, 9n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(2n, f(14n, 5n));
  assertOptimized(f);
  assertEquals(-(2n ** 63n), f(-(2n ** 63n), 1n));
  assertOptimized(f);
  // Re-prepare the function before the first deopt to ensure type feedback is
  // not cleared by an umtimely gc.
  %PrepareFunctionForOptimization(f);
  assertOptimized(f);
  // CheckedInt64Div will trigger deopt due to overflow.
  assertEquals(2n ** 63n, f(-(2n ** 63n), -1n));
  if (%Is64Bit()) {
    assertUnoptimized(f);

  assertEquals(0n, f(0n, 1n));
  assertEquals(-3n, f(-32n, 9n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(2n, f(14n, 5n));
    assertOptimized(f);
    // Ensure there is no deopt loop.
    assertEquals(2n ** 63n, f(-(2n ** 63n), -1n));
    assertOptimized(f);
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/compiler/bigint64-mod-no-deopt-loop.js                             0000664 0000000 0000000 00000003710 14746647661 0025563 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

(function OptimizeAndTestDivZero() {
  function f(x, y) {
    return x % y;
  }
  %PrepareFunctionForOptimization(f);
  assertEquals(0n, f(0n, 1n));
  assertEquals(-5n, f(-32n, 9n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(4n, f(14n, 5n));
  assertOptimized(f);
  // Re-prepare the function before the first deopt to ensure type feedback is
  // not cleared by an untimely gc.
  %PrepareFunctionForOptimization(f);
  assertOptimized(f);
  // CheckedInt64Mod will trigger deopt due to divide-by-zero.
  assertThrows(() => f(42n, 0n), RangeError);
  if (%Is64Bit()) {
    assertUnoptimized(f);

    assertEquals(0n, f(0n, 1n));
    assertEquals(-5n, f(-32n, 9n));
    %OptimizeFunctionOnNextCall(f);
    assertEquals(4n, f(14n, 5n));
    assertOptimized(f);
    // Ensure there is no deopt loop.
    assertThrows(() => f(42n, 0n), RangeError);
    assertOptimized(f);
  }
})();

(function OptimizeAndTestOverflow() {
  function f(x, y) {
    return x % y;
  }
  %PrepareFunctionForOptimization(f);
  assertEquals(0n, f(0n, 1n));
  assertEquals(-5n, f(-32n, 9n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(4n, f(14n, 5n));
  assertOptimized(f);
  // Re-prepare the function before the first deopt to ensure type feedback is
  // not cleared by an umtimely gc.
  %PrepareFunctionForOptimization(f);
  assertOptimized(f);
  // CheckedInt64Mod will trigger deopt due to overflow.
  assertEquals(0n, f(-(2n ** 63n), -1n));
  if (%Is64Bit()) {
    assertUnoptimized(f);

    assertEquals(0n, f(0n, 1n));
    assertEquals(-5n, f(-32n, 9n));
    %OptimizeFunctionOnNextCall(f);
    assertEquals(4n, f(14n, 5n));
    assertOptimized(f);
    // Ensure there is no deopt loop.
    assertEquals(0n, f(-(2n ** 63n), -1n));
    assertOptimized(f);
  }
})();
                                                        node-23.7.0/deps/v8/test/mjsunit/compiler/bigint64-mul-no-deopt-loop.js                             0000664 0000000 0000000 00000002316 14746647661 0025602 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

(function OptimizeAndTestOverflow() {
  function f(x, y) {
    return x * y;
  }
  %PrepareFunctionForOptimization(f);
  assertEquals(0n, f(0n, 1n));
  assertEquals(18n, f(2n, 9n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(70n, f(14n, 5n));
  assertOptimized(f);
  assertEquals(-(2n ** 63n), f(-(2n ** 32n), 2n ** 31n));
  assertOptimized(f);
  // Re-prepare the function before the first deopt to ensure type feedback is
  // not cleared by an untimely gc.
  %PrepareFunctionForOptimization(f);
  assertOptimized(f);
  // CheckedInt64Mul will trigger deopt due to overflow.
  assertEquals(-(2n ** 63n) - 1n, f(-77158673929n, 119537721n));
  if (%Is64Bit()) {
    assertUnoptimized(f);

    assertEquals(0n, f(0n, 1n));
    assertEquals(18n, f(2n, 9n));
    %OptimizeFunctionOnNextCall(f);
    assertEquals(70n, f(14n, 5n));
    assertOptimized(f);
    // Ensure there is no deopt loop.
    assertEquals(-(2n ** 63n) - 1n, f(-77158673929n, 119537721n));
    assertOptimized(f);
  }
})();
                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/compiler/bigint64-sub-no-deopt-loop.js                             0000664 0000000 0000000 00000002324 14746647661 0025575 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

(function OptimizeAndTestOverflow() {
  function f(x, y) {
    return x - y;
  }
  %PrepareFunctionForOptimization(f);
  assertEquals(-1n, f(0n, 1n));
  assertEquals(-7n, f(2n, 9n));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(9n, f(14n, 5n));
  assertOptimized(f);
  assertEquals(-(2n ** 63n), f(-(2n ** 62n), 2n ** 62n));
  assertOptimized(f);
  // Re-prepare the function before the first deopt to ensure type feedback is
  // not cleared by an untimely gc.
  %PrepareFunctionForOptimization(f);
  assertOptimized(f);
  // CheckedInt64Sub will trigger deopt due to overflow.
  assertEquals(-(2n ** 63n) - 1n, f(-(2n ** 62n + 1n), 2n ** 62n));
  if (%Is64Bit()) {
    assertUnoptimized(f);

    assertEquals(-1n, f(0n, 1n));
    assertEquals(-7n, f(2n, 9n));
    %OptimizeFunctionOnNextCall(f);
    assertEquals(9n, f(14n, 5n));
    assertOptimized(f);
    // Ensure there is no deopt loop.
    assertEquals(-(2n ** 63n) - 1n, f(-(2n ** 62n + 1n), 2n ** 62n));
    assertOptimized(f);
  }
})();
                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/compiler/binary-ops.js                                             0000664 0000000 0000000 00000004707 14746647661 0022760 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Values in distinct spans.
function or_test0(x, y) { return x | y; }
function and_test0(x, y) { return x & y; }
function add_test0(x, y) { return x + y; }

assertEquals(3, or_test0(1, 2));   // 1 | 2
assertEquals(2, and_test0(3, 6));  // 3 & 6
assertEquals(5, add_test0(2, 3));  // 2 + 3


// Values in the same span.
function or_test1(x, y) { return x | x; }
function and_test1(x, y) { return x & x; }
function add_test1(x, y) { return x + x; }

assertEquals(1, or_test1(1, 2));   // 1 | 1
assertEquals(3, and_test1(3, 6));  // 3 & 3
assertEquals(4, add_test1(2, 3));  // 2 + 2


// Values in distinct spans that alias.
function or_test2(x, y) { x = y; return x | y; }
function and_test2(x, y) { x = y; return x & y; }
function add_test2(x, y) { x = y; return x + y; }

assertEquals(2, or_test2(1, 2));   // 2 | 2
assertEquals(6, and_test2(3, 6));  // 6 & 6
assertEquals(6, add_test2(2, 3));  // 3 + 3
                                                         node-23.7.0/deps/v8/test/mjsunit/compiler/boolean-protototype.js                                    0000664 0000000 0000000 00000002663 14746647661 0024721 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

function test1(s) {
  return s.toString;
}
%PrepareFunctionForOptimization(test1);
assertSame(test1(false), Boolean.prototype.toString);
assertSame(test1(true), Boolean.prototype.toString);
%OptimizeFunctionOnNextCall(test1);
assertSame(test1(false), Boolean.prototype.toString);
assertSame(test1(true), Boolean.prototype.toString);

function test2(s) {
  return s.valueOf;
}
%PrepareFunctionForOptimization(test2);
assertSame(test2(false), Boolean.prototype.valueOf);
assertSame(test2(true), Boolean.prototype.valueOf);
%OptimizeFunctionOnNextCall(test2);
assertSame(test2(false), Boolean.prototype.valueOf);
assertSame(test2(true), Boolean.prototype.valueOf);

Boolean.prototype.foo = 42;
function test3(s) {
  return s["foo"];
}
%PrepareFunctionForOptimization(test3);
assertEquals(test3(false), 42);
assertEquals(test3(true), 42);
%OptimizeFunctionOnNextCall(test3);
assertEquals(test3(false), 42);
assertEquals(test3(true), 42);

Boolean.prototype.bar = function bar() { "use strict"; return this; }
function test4(s) {
  return s.bar();
}
%PrepareFunctionForOptimization(test4);
assertEquals(test4(false), false);
assertEquals(test4(true), true);
%OptimizeFunctionOnNextCall(test4);
assertEquals(test4(false), false);
assertEquals(test4(true), true);
                                                                             node-23.7.0/deps/v8/test/mjsunit/compiler/bound-functions-serialize.js                              0000664 0000000 0000000 00000001416 14746647661 0025771 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Flags: --allow-natives-syntax --turbofan --noalways-turbofan

class C {};
const c = new C;
const getPrototypeOf = Object.getPrototypeOf;

function bar(f) {
  return f();
}
function foo() {
  return bar(getPrototypeOf.bind(undefined, c));
}

%PrepareFunctionForOptimization(foo);
%PrepareFunctionForOptimization(bar);
bar(function() {});
foo();
%OptimizeFunctionOnNextCall(foo);
foo();
assertOptimized(foo);

c.prop = 42;
// Assert that the call reducer optimized the call to Object.getPrototypeOf
// by asserting that foo gets deopted when c's previous map becomes
// unstable.
foo();
assertUnoptimized(foo);
                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/compiler/call-keyed.js                                             0000664 0000000 0000000 00000003340 14746647661 0022677 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

A = {}
A.i = [];
A.i.push(function () { });
A.i.push(function () { });

function f (event) {
 for(var i = 0, j = A.i.length; i < j; ++i)
   A.i[i]();
}

f(null);
                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/compiler/call-with-arraylike-or-spread-2.js                        0000664 0000000 0000000 00000002724 14746647661 0026570 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbo-optimize-apply --turbofan

// These tests do not work well if this script is run more than once; after a
// few runs the whole function is immediately compiled and assertions would
// fail. We prevent re-runs.
// Flags: --no-always-turbofan

// These tests do not work well if we flush the feedback vector, which causes
// deoptimization.
// Flags: --no-stress-flush-code --no-flush-bytecode

// Tests for optimization of CallWithSpread and CallWithArrayLike.
// This test is in a separate file because it invalidates protectors.

// Test with holey array with default values.
(function () {
  "use strict";

  // Setting value to be retrieved in place of hole.
  Array.prototype[2] = 'x';

  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d;
  }
  function foo(x, y) {
    return sum_js.apply(null, ["", x, ,y]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('AxB', foo('A', 'B'));
  assertTrue(sum_js_got_interpreted);

  // The protector should be invalidated, which prevents inlining.
  %OptimizeFunctionOnNextCall(foo);
  assertEquals('AxB', foo('A', 'B'));
  assertTrue(sum_js_got_interpreted);
  assertOptimized(foo);
})();
                                            node-23.7.0/deps/v8/test/mjsunit/compiler/call-with-arraylike-or-spread-3.js                        0000664 0000000 0000000 00000003230 14746647661 0026562 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbo-optimize-apply --turbofan
// Flags: --no-always-turbofan

// These tests do not work well if we flush the feedback vector, which causes
// deoptimization.
// Flags: --no-stress-flush-code --no-flush-bytecode

// The test relies on optimizing/deoptimizing at predictable moments, so
// it's not suitable for deoptimization fuzzing.
// Flags: --deopt-every-n-times=0

// Tests for optimization of CallWithSpread and CallWithArrayLike.
// This test is in a separate file because it invalidates protectors.

// Test with array prototype modified after compilation.
(function () {
  "use strict";

  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d;
  }
  function foo(x, y) {
    return sum_js.apply(null, ["", x, ,y]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('AundefinedB', foo('A', 'B'));
  assertTrue(sum_js_got_interpreted);

  %OptimizeFunctionOnNextCall(foo);
  assertEquals('AundefinedB', foo('A', 'B'));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(foo);

  // Modify the array prototype, define a default value for element [1].
  Array.prototype[2] = 'x';
  assertUnoptimized(foo);

  // Now the call will not be inlined.
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertEquals('AxB', foo('A', 'B'));
  assertTrue(sum_js_got_interpreted);
  assertOptimized(foo);
})();
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/compiler/call-with-arraylike-or-spread-4.js                        0000664 0000000 0000000 00000003776 14746647661 0026602 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbo-optimize-apply --turbofan
// Flags: --no-always-turbofan

// These tests do not work well if we flush the feedback vector, which causes
// deoptimization.
// Flags: --no-stress-flush-code --no-flush-bytecode

// The test relies on optimizing/deoptimizing at predictable moments, so
// this is not suitable for deoptimization fuzzing.
// Flags: --deopt-every-n-times=0 --interrupt-budget=1024

// Tests for optimization of CallWithSpread and CallWithArrayLike.

// Test deopt when array map changes.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c;
  }
  function foo(x, y, z, str) {
    let v = [x, y, z];
    if (str) {
      v[0] = str;
    }
    return sum_js.apply(null, v);
  }

  %PrepareFunctionForOptimization(sum_js);
  for (let i = 0; i < 5; i++) {
    %PrepareFunctionForOptimization(foo);
    assertEquals(78, foo(26, 6, 46, null));
    assertTrue(sum_js_got_interpreted);

    // Compile function foo; inlines 'sum_js' into 'foo'.
    %OptimizeFunctionOnNextCall(foo);
    assertEquals(78, foo(26, 6, 46, null));
    assertOptimized(foo);
    %PrepareFunctionForOptimization(foo);

    if (i < 3) {
      assertFalse(sum_js_got_interpreted);
    } else {
      // i: 3: Speculation mode prevents optimization of sum_js.apply() call.
      assertTrue(sum_js_got_interpreted);
    }

    // This should deoptimize:
    // i: 0: Deopt soft: insufficient type feedback for generic keyed access.
    // i: 1,2: Deopt eager: wrong map.
    // i: 3: Won't deopt anymore.
    assertEquals("v8646", foo(26, 6, 46, "v8"));
    assertTrue(sum_js_got_interpreted);

    if (i < 3) {
      assertUnoptimized(foo);
    } else {
      assertOptimized(foo);
      %PrepareFunctionForOptimization(foo);
    }
  }
})();
  node-23.7.0/deps/v8/test/mjsunit/compiler/call-with-arraylike-or-spread-5.js                        0000664 0000000 0000000 00000003171 14746647661 0026570 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbo-optimize-apply --turbofan
// Flags: --no-always-turbofan

// These tests do not work well if we flush the feedback vector, which causes
// deoptimization.
// Flags: --no-stress-flush-code --no-flush-bytecode

// Some of the tests rely on optimizing/deoptimizing at predictable moments, so
// this is not suitable for deoptimization fuzzing.
// Flags: --deopt-every-n-times=0

// Test for optimization of CallWithSpread when the array iterator is replaced
// with a generator function.
//
// Note: this test must be in a separate file because the test invalidates a
// protector, which then remains invalidated.
(function () {
  "use strict";

  // This invalidates the DependOnArrayIteratorProtector.
  Object.defineProperty(Array.prototype, Symbol.iterator, {
    value: function* () {
      yield 42;
    },
  });

  var log_got_interpreted = true;

  function log(a) {
    assertEquals(1, arguments.length);
    log_got_interpreted = %IsBeingInterpreted();
    return a;
  }
  function foo() {
    return log(...[1]);
  }

  %PrepareFunctionForOptimization(log);
  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo());
  assertTrue(log_got_interpreted);

  // Compile foo.
  %OptimizeFunctionOnNextCall(log);
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(42, foo());
  // The call with spread should not have been inlined, because of the
  // generator/iterator.
  assertFalse(log_got_interpreted);
  assertOptimized(foo);
})();
                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/compiler/call-with-arraylike-or-spread-6.js                        0000664 0000000 0000000 00000003217 14746647661 0026572 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbo-optimize-apply --turbofan
// Flags: --no-always-turbofan

// These tests do not work well if we flush the feedback vector, which causes
// deoptimization.
// Flags: --no-stress-flush-code --no-flush-bytecode

// Some of the tests rely on optimizing/deoptimizing at predictable moments, so
// this is not suitable for deoptimization fuzzing.
// Flags: --deopt-every-n-times=0

// Test for optimization of CallWithSpread when the array iterator is replaced
// with a generator function and the array in empty.
//
// Note: this test must be in a separate file because the test invalidates a
// protector, which then remains invalidated.
(function () {
  "use strict";

  // This invalidates the DependOnArrayIteratorProtector.
  Object.defineProperty(Array.prototype, Symbol.iterator, {
    value: function* () {
      yield 42;
    },
  });

  var log_got_interpreted = true;

  function log(a) {
    assertEquals(1, arguments.length);
    log_got_interpreted = %IsBeingInterpreted();
    return a;
  }
  function foo() {
    return log(...[]);
  }

  %PrepareFunctionForOptimization(log);
  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo());
  assertTrue(log_got_interpreted);

  // Compile foo.
  %OptimizeFunctionOnNextCall(log);
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(42, foo());
  // The call with spread should not have been inlined, because of the
  // generator/iterator.
  assertFalse(log_got_interpreted);
  assertOptimized(foo);
})();
                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/compiler/call-with-arraylike-or-spread-7.js                        0000664 0000000 0000000 00000004164 14746647661 0026575 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbo-optimize-apply --turbofan
// Flags: --no-always-turbofan

// These tests do not work well if we flush the feedback vector, which causes
// deoptimization.
// Flags: --no-stress-flush-code --no-flush-bytecode

// Some of the tests rely on optimizing/deoptimizing at predictable moments, so
// this is not suitable for deoptimization fuzzing.
// Flags: --deopt-every-n-times=0

// Test for optimization of CallWithSpread when the array iterator is replaced
// with a generator function after a function is compiled.
//
// Note: this test must be in a separate file because the test invalidates a
// protector, which then remains invalidated.
(function () {
  "use strict";
  var log_got_interpreted = true;
  %NeverOptimizeFunction(assertEquals);

  function log(a) {
    assertEquals(1, arguments.length);
    log_got_interpreted = %IsBeingInterpreted();
    return a;
  }
  function foo() {
    return log(...[1]);
  }

  %PrepareFunctionForOptimization(log);
  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo());
  assertTrue(log_got_interpreted);

  // Compile foo.
  %OptimizeFunctionOnNextCall(log);
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo());
  // The call with spread should have been inlined.
  assertFalse(log_got_interpreted);
  assertOptimized(foo);
  %PrepareFunctionForOptimization(foo);

  // This invalidates the DependOnArrayIteratorProtector and causes deopt.
  Object.defineProperty(Array.prototype, Symbol.iterator, {
    value: function* () {
      yield 42;
    },
  });

  // Now we expect the value yielded by the generator.
  assertEquals(42, foo());
  assertFalse(log_got_interpreted);
  assertUnoptimized(foo);

  // Recompile 'foo'.
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(42, foo());
  // The call with spread will not be inlined because we have redefined the
  // array iterator.
  assertFalse(log_got_interpreted);
  assertOptimized(foo);
})();
                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/compiler/call-with-arraylike-or-spread.js                          0000664 0000000 0000000 00000053200 14746647661 0026424 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbo-optimize-apply --turbofan
// Flags: --no-always-turbofan

// These tests do not work well if we flush the feedback vector, which causes
// deoptimization.
// Flags: --no-stress-flush-code --no-flush-bytecode

// Some of the tests rely on optimizing/deoptimizing at predictable moments, so
// this is not suitable for deoptimization fuzzing.
// Flags: --deopt-every-n-times=0

// Tests for optimization of CallWithSpread and CallWithArrayLike.

// Test JSCallReducer::ReduceJSCallWithArrayLike.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d;
  }
  function foo(x, y, z) {
    return sum_js.apply(null, ["", x, y, z]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('abc', foo('a', 'b', 'c'));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);
  assertEquals('abc', foo('a', 'b', 'c'));
  assertOptimized(foo);
  assertFalse(sum_js_got_interpreted);
})();

// Test using receiver
(function () {
  function bar() {
    return this.gaga;
  }
  function foo(receiver) {
    return bar.apply(receiver, [""]);
  }

  %PrepareFunctionForOptimization(bar);
  %PrepareFunctionForOptimization(foo);
  var receiver = { gaga: 42 };
  assertEquals(42, foo(receiver));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(42, foo(receiver));
  assertOptimized(foo);
})();

// Test with holey array.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d;
  }
  function foo(x, y) {
    return sum_js.apply(null, ["",x,,y]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('AundefinedB', foo('A', 'B'));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);
  assertEquals('AundefinedB', foo('A', 'B'));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test with holey-double array.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + (c ? c : .0) + d;
  }
  function foo(x, y) {
    return sum_js.apply(null, [3.14, x, , y]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals(45.31, foo(16.11, 26.06));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);

  // We optimize in the next call and  sum_js stays inlined.
  assertEquals(45.31, foo(16.11, 26.06));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test deopt when array size changes.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d;
  }
  function foo(x, y, z) {
    let a = ["", x, y, z];
    a.push('*');
    return sum_js.apply(null, a);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  // Here array size changes.
  assertEquals('abc', foo('a', 'b', 'c'));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);
  // Here it should deoptimize.
  assertEquals('abc', foo('a', 'b', 'c'));
  assertUnoptimized(foo);
  assertTrue(sum_js_got_interpreted);
  // Now speculation mode prevents the optimization.
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertEquals('abc', foo('a', 'b', 'c'));
  assertTrue(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test with FixedDoubleArray.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d;
  }
  function foo(x, y, z) {
    return sum_js.apply(null, [3.14, x, y, z]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals(56.34, foo(11.03, 16.11, 26.06));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);
  assertEquals(56.34, foo(11.03, 16.11, 26.06));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test with empty array.
(function () {
  "use strict";
  var got_interpreted = true;
  function fortytwo() {
    got_interpreted = %IsBeingInterpreted();
    return 42;
  }
  function foo() {
    return fortytwo.apply(null, []);
  }

  %PrepareFunctionForOptimization(fortytwo);
  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(got_interpreted);
  assertEquals(42, foo());
  assertFalse(got_interpreted);
  assertOptimized(foo);
})();

// Test with empty array that changes size.
(function () {
  "use strict";
  var got_interpreted = true;
  function fortytwo() {
    got_interpreted = %IsBeingInterpreted();
    return 42 + arguments.length;
  }

  var len = 2;
  function foo() {
    let args = []
    for (var i = 0; i < len; i++) { args.push(1); }
    let result = fortytwo.apply(null, args);
    return result;
  }

  %PrepareFunctionForOptimization(fortytwo);
  %PrepareFunctionForOptimization(foo);
  assertEquals(44, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(got_interpreted);
  assertEquals(44, foo());
  assertTrue(got_interpreted);
  assertOptimized(foo);

  len = 0;
  assertEquals(42, foo());
  assertFalse(got_interpreted);
  assertOptimized(foo);
})();

// Test with FixedDoubleArray and Math.min/max.
(function () {
  "use strict";
  function arrayMin(val) {
    return Math.min.apply(Math, val);
  }
  function arrayMax(val) {
    return Math.max.apply(Math, val);
  }

  %PrepareFunctionForOptimization(arrayMin);
  %PrepareFunctionForOptimization(arrayMin);
  assertEquals(11.03, arrayMin([11.03, 16.11, 26.06]));

  %PrepareFunctionForOptimization(arrayMax);
  %PrepareFunctionForOptimization(arrayMax);
  assertEquals(26.06, arrayMax([11.03, 16.11, 26.06]));
  %OptimizeFunctionOnNextCall(arrayMin);
  %OptimizeFunctionOnNextCall(arrayMax);

  assertEquals(11.03, arrayMin([11.03, 16.11, 26.06]));
  assertEquals(26.06, arrayMax([11.03, 16.11, 26.06]));

  assertOptimized(arrayMin);
  assertOptimized(arrayMax);

})();

// Test with holey double array and Math.min/max.
(function () {
  "use strict";
  function arrayMin(val) {
    return Math.min.apply(Math, val);
  }
  function arrayMax(val) {
    return Math.max.apply(Math, val);
  }

  %PrepareFunctionForOptimization(arrayMin);
  %PrepareFunctionForOptimization(arrayMin);
  assertEquals(NaN, arrayMin([11.03, 16.11, , 26.06]));

  %PrepareFunctionForOptimization(arrayMax);
  %PrepareFunctionForOptimization(arrayMax);
  assertEquals(NaN, arrayMax([11.03, 16.11, , 26.06]));
  %OptimizeFunctionOnNextCall(arrayMin);
  %OptimizeFunctionOnNextCall(arrayMax);

  assertEquals(NaN, arrayMin([11.03, 16.11, , 26.06]));
  assertEquals(NaN, arrayMax([11.03, 16.11, , 26.06]));

  assertOptimized(arrayMin);
  assertOptimized(arrayMax);

})();

// Test Reflect.apply().
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d;
  }
  function foo(x, y ,z) {
    return Reflect.apply(sum_js, null, ["", x, y, z]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('abc', foo('a', 'b', 'c'));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);
  assertEquals('abc', foo('a', 'b', 'c'));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test Reflect.apply() with empty array.
(function () {
  "use strict";
  var got_interpreted = true;
  function fortytwo() {
    got_interpreted = %IsBeingInterpreted();
    return 42;
  }
  function foo() {
    return Reflect.apply(fortytwo, null, []);
  }

  %PrepareFunctionForOptimization(fortytwo);
  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(got_interpreted);
  assertEquals(42, foo());
  assertFalse(got_interpreted);
  assertOptimized(foo);
})();

// Test Reflect.apply() with empty array that changes size.
(function () {
  "use strict";
  var got_interpreted = true;
  function fortytwo() {
    got_interpreted = %IsBeingInterpreted();
    return 42 + arguments.length;
  }

  var len = 2;
  function foo() {
    let args = []
    for (var i = 0; i < len; i++) { args.push(1); }
    let result = Reflect.apply(fortytwo, null, args);
    return result;
  }

  %PrepareFunctionForOptimization(fortytwo);
  %PrepareFunctionForOptimization(foo);
  assertEquals(44, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(got_interpreted);
  assertEquals(44, foo());
  assertTrue(got_interpreted);
  assertOptimized(foo);

  len = 0;
  assertEquals(42, foo());
  assertFalse(got_interpreted);
  assertOptimized(foo);
})();

// Test JSCallReducer::ReduceJSCallWithSpread.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d;
  }
  function foo(x, y, z) {
    const numbers = ["", x, y, z];
    return sum_js(...numbers);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('abc', foo('a', 'b', 'c'));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);
  assertEquals('abc', foo('a', 'b', 'c'));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test spread call with empty array.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c;
  }
  function foo(x, y, z) {
    const args = [];
    return sum_js(x, y, z, ...args);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('abc', foo('a', 'b', 'c'));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);
  assertEquals('abc', foo('a', 'b', 'c'));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test spread call with empty array that changes size.
(function () {
  "use strict";
  var max_got_interpreted = true;
  function max() {
    max_got_interpreted = %IsBeingInterpreted();
    return Math.max(...arguments);
  }

  var len = 2;
  function foo(x, y, z) {
    let args = [];
    for (var i = 0; i < len; i++) { args.push(4 + i); }
    return max(x, y, z, ...args);
  }

  %PrepareFunctionForOptimization(max);
  %PrepareFunctionForOptimization(foo);
  assertEquals(5, foo(1, 2, 3));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(max_got_interpreted);
  assertEquals(5, foo(1, 2, 3));
  assertTrue(max_got_interpreted);
  assertOptimized(foo);

  len = 0;
  assertEquals(3, foo(1, 2, 3));
  assertFalse(max_got_interpreted);
  assertOptimized(foo);
})();

// Test spread call with more args.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d, e, f, g) {
    assertEquals(7, arguments.length);
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d + e + f + g;
  }
  function foo(x, y, z) {
    const numbers = ["", z, y, x];
    return sum_js(x, y, z, ...numbers);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('abccba', foo('a', 'b', 'c'));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);
  assertEquals('abccba', foo('a', 'b', 'c'));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test on speculative optimization of introduced JSCall (array_size != 0).
(function () {
  "use strict";
  var F = Math.max;
  var len;
  function foo(x, y, z) {
    var args = [z];
    for (var i = 0; i < len; i++) { args.push(0); }
    return F(x, y, ...args);
  }
  function foo1(x, y, z) {
    var args = [z];
    for (var i = 0; i < len; i++) { args.push(0); }
    return F(x, y, ...args);
  }

  // Optimize JSCallWithSpread and Math.max
  len = 0;
  %PrepareFunctionForOptimization(foo);
  assertEquals(3, foo(1, 2, 3));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(3, foo(1, 2, 3));
  assertOptimized(foo);
  // Deoptimize when input of Math.max is not number
  foo('a', 'b', 3);
  assertUnoptimized(foo);

  // Optimize JSCallWithSpread and Math.max
  len = 2;
  %PrepareFunctionForOptimization(foo1);
  assertEquals(3, foo1(1, 2, 3));
  %OptimizeFunctionOnNextCall(foo1);
  assertEquals(3, foo1(1, 2, 3));
  //Deoptimize when array length changes
  assertUnoptimized(foo1);
})();

// Test on speculative optimization of introduced JSCall (array_size == 0).
(function () {
  "use strict";
  var F = Math.max;
  var len;
  function foo(x, y, z) {
    var args = [];
    for (var i = 0; i < len; i++) { args.push(z); }
    return F(x, y, ...args);
  }
  function foo1(x, y, z) {
    var args = [];
    for (var i = 0; i < len; i++) { args.push(z); }
    return F(x, y, ...args);
  }

  // Optimize JSCallWithSpread and Math.max
  len = 0;
  %PrepareFunctionForOptimization(foo);
  assertEquals(2, foo(1, 2, 3));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(2, foo(1, 2, 3));
  assertOptimized(foo);
  // Deoptimzie when input of Math.max is not number
  foo('a', 'b', 3);
  assertUnoptimized(foo);

  // Optimize JSCallWithSpread and Math.max
  len = 2;
  %PrepareFunctionForOptimization(foo1);
  assertEquals(3, foo1(1, 2, 3));
  %OptimizeFunctionOnNextCall(foo1);
  assertEquals(3, foo1(1, 2, 3));
  assertOptimized(foo1);
  // No Deoptimization when array length changes
  foo(1, 2, 3);
  assertUnoptimized(foo);
})();

// Test apply on JSCreateClosure.
(function () {
  "use strict";
  var sum_got_interpreted = true;
  function foo_closure() {
    return function(a, b, c, d) {
      sum_got_interpreted = %IsBeingInterpreted();
      return a + b + c + d;
    }
  }
  const _foo_closure = foo_closure();
  %PrepareFunctionForOptimization(_foo_closure);

  function foo(x, y, z) {
    return foo_closure().apply(null, ["", x, y, z]);
  }

  %PrepareFunctionForOptimization(foo_closure);
  %PrepareFunctionForOptimization(foo);
  assertEquals('abc', foo('a', 'b', 'c'));
  %OptimizeFunctionOnNextCall(foo_closure);
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_got_interpreted);
  assertEquals('abc', foo('a', 'b', 'c'));
  assertFalse(sum_got_interpreted);
  assertOptimized(foo);
})();

// Test apply with JSBoundFunction
(function () {
  "use strict";
  var sum_got_interpreted = true;
  function sum_js(a, b, c, d, e) {
    sum_got_interpreted = %IsBeingInterpreted();
    return this.x + a + b + c + d + e;
  }
  const f = sum_js.bind({ x: 26 }, 11, 3);
  function foo(a, b, c) {
    return f.apply(null, [a, b, c]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals(166, foo(40, 42, 44));
  assertTrue(sum_got_interpreted);

  %OptimizeFunctionOnNextCall(foo);
  assertEquals(166, foo(40, 42, 44));
  assertFalse(sum_got_interpreted);
  assertOptimized(foo);
})();

// Test apply with nested bindings
(function () {
  "use strict";
  var sum_got_interpreted = true;
  function sum_js(a, b, c, d, e) {
    sum_got_interpreted = %IsBeingInterpreted();
    return this.x + a + b + c + d + e;
  }
  const f = sum_js.bind({ x: 26 }, 11).bind({ y: 4 }, 3);
  function foo(x, y, z) {
    return f.apply(null, [x, y, z]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals(166, foo(40, 42, 44));
  assertTrue(sum_got_interpreted);

  %OptimizeFunctionOnNextCall(foo);
  assertEquals(166, foo(40, 42, 44));
  assertFalse(sum_got_interpreted);
  assertOptimized(foo);
})();

// Test apply on bound function (JSCreateBoundFunction).
(function () {
  "use strict";
  var sum_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_got_interpreted = %IsBeingInterpreted();
    return this.x + a + b + c + d;
  }
  function foo(x, y, z) {
    return sum_js.bind({ x: 42 }).apply(null, ["", x, y, z]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('42abc', foo('a', 'b', 'c'));
  assertTrue(sum_got_interpreted);

  %OptimizeFunctionOnNextCall(foo);
  assertEquals('42abc', foo('a', 'b', 'c'));
  assertFalse(sum_got_interpreted);
  assertOptimized(foo);
})();

// Test apply on bound function (JSCreateBoundFunction) with args.
(function () {
  "use strict";
  var sum_got_interpreted = true;
  function sum_js(a, b, c, d, e, f) {
    sum_got_interpreted = %IsBeingInterpreted();
    return this.x + a + b + c + d + e + f;
  }
  function foo(x, y, z) {
    return sum_js.bind({ x: 3 }, 11, 31).apply(null, ["", x, y, z]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('45abc', foo('a', 'b', 'c'));
  assertTrue(sum_got_interpreted);

  %OptimizeFunctionOnNextCall(foo);
  assertEquals('45abc', foo('a', 'b', 'c'));
  assertFalse(sum_got_interpreted);
  assertOptimized(foo);
})();

// Test call with array-like under-application.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d + arguments.length;
  }
  function foo(x, y) {
    return sum_js.apply(null, ["", x, y]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('ABundefined3', foo('A', 'B'));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);
  assertEquals('ABundefined3', foo('A', 'B'));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test call with array-like over-application.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d + arguments.length;
  }
  function foo(v, w, x, y, z) {
    return sum_js.apply(null, ["", v, w, x, y, z]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('abc6', foo('a', 'b', 'c', 'd', 'e'));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);
  assertEquals('abc6', foo('a', 'b', 'c', 'd', 'e'));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test call with spread under-application.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d + arguments.length;
  }
  function foo(x, y) {
    const numbers = ["", x, y];
    return sum_js(...numbers);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('ABundefined3', foo('A', 'B'));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);
  assertEquals('ABundefined3', foo('A', 'B'));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test call with spread over-application.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d + arguments.length;
  }
  function foo(v, w, x, y, z) {
    const numbers = ["", v, w, x, y, z];
    return sum_js(...numbers);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('abc6', foo('a', 'b', 'c', 'd', 'e'));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);
  assertEquals('abc6', foo('a', 'b', 'c', 'd', 'e'));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test calling function that has rest parameters.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, ...moreArgs) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + moreArgs[0] + moreArgs[1] + moreArgs[2] + moreArgs[3];
  }
  function foo(v, w, x, y, z) {
    return sum_js.apply(null, ["", v, w, x, y, z]);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('abcde', foo('a', 'b', 'c', 'd', 'e'));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(sum_js_got_interpreted);
  assertEquals('abcde', foo('a', 'b', 'c', 'd', 'e'));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test with 'arguments'.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c;
  }
  function foo() {
    return sum_js.apply(null, arguments);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  assertEquals('abc', foo('a', 'b', 'c'));
  assertTrue(sum_js_got_interpreted);

  // The call is not inlined with CreateArguments.
  %OptimizeFunctionOnNextCall(foo);
  assertEquals('abc', foo('a', 'b', 'c'));
  assertTrue(sum_js_got_interpreted);
  assertOptimized(foo);
})();

// Test with inlined calls.
(function () {
  "use strict";
  var sum_js_got_interpreted = true;
  function sum_js(a, b, c, d) {
    sum_js_got_interpreted = %IsBeingInterpreted();
    return a + b + c + d;
  }
  function foo(x, y, z) {
    return sum_js.apply(null, ["", x, y, z]);
  }
  function bar(a, b, c) {
    return foo(c, b, a);
  }

  %PrepareFunctionForOptimization(sum_js);
  %PrepareFunctionForOptimization(foo);
  %PrepareFunctionForOptimization(bar);
  assertEquals('cba', bar('a', 'b', 'c'));
  assertTrue(sum_js_got_interpreted);

  // Optimization also works if the call is in an inlined function.
  %OptimizeFunctionOnNextCall(bar);
  assertEquals('cba', bar('a', 'b', 'c'));
  assertFalse(sum_js_got_interpreted);
  assertOptimized(bar);
})();
                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/compiler/capture-context.js                                        0000664 0000000 0000000 00000000733 14746647661 0024015 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

var foo = (function() {
  var x = 42;
  function bar(s) { return x + s; }
  return (function (s) { return bar(s); })
})();

var baz = (function (s) { return foo(s) });

%PrepareFunctionForOptimization(baz);
%OptimizeFunctionOnNextCall(baz);
assertEquals(42 + 12, baz(12));
                                     node-23.7.0/deps/v8/test/mjsunit/compiler/catch-block-load.js                                       0000664 0000000 0000000 00000002206 14746647661 0023754 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turboshaft-enable-debug-features

const obj = { a: 42 };

function boom() {
  throw "boom";
}

// Ensure that we optimize the monomorphic case.
(function() {
  function bar(x) {
    try {
      boom();
      ++i;
    } catch(_) {
      %TurbofanStaticAssert(x.a == 42);
      return x.a;
    }
  }

  function foo() {
    return bar(obj);
  }

  %PrepareFunctionForOptimization(foo);
  %PrepareFunctionForOptimization(bar);

  foo();
  foo();
  %OptimizeFunctionOnNextCall(foo);
  foo();
})();

// And the megamorphic case.
(function() {
  function bar(x) {
    try {
      boom();
      ++i;
    } catch(_) {
      %TurbofanStaticAssert(x.a == 42);
      return x.a;
    }
  }

  function foo() {
    return bar(obj);
  }

  %PrepareFunctionForOptimization(foo);
  %PrepareFunctionForOptimization(bar);

  bar({b: 42});
  bar({c: 42});
  bar({d: 42});
  bar({e: 42});
  bar({f: 42});

  foo();
  foo();
  %OptimizeFunctionOnNextCall(foo);
  foo();
})();
                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/compiler/collection-has.js                                         0000664 0000000 0000000 00000002633 14746647661 0023575 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

(function() {
  const map = new Map();
  map.set(true, true);

  for (let i = 0; i < 10000; i += 1) {
    map.set(i, i);
    map.set(`${i} number`, i);
  }

  function foo(x) {
    return map.has(x);
  }

  %PrepareFunctionForOptimization(foo);

  assertFalse(foo(1.5));
  assertTrue(foo(1));

  assertFalse(foo('1.5 number'));
  assertTrue(foo('1 number'));

  assertFalse(foo(false));
  assertTrue(foo(true));

  %OptimizeFunctionOnNextCall(foo);

  assertFalse(foo(1.5));
  assertTrue(foo(1));

  assertFalse(foo('1.5 number'));
  assertTrue(foo('1 number'));

  assertFalse(foo(false));
  assertTrue(foo(true));
})();

(function() {
  const set = new Set();
  set.add(true);

  for (let i = 0; i < 10000; i += 1) {
    set.add(i);
    set.add(`${i} number`);
  }

  function foo(x) {
    return set.has(x);
  }

  %PrepareFunctionForOptimization(foo);

  assertFalse(foo(1.5));
  assertTrue(foo(1));

  assertFalse(foo('1.5 number'));
  assertTrue(foo('1 number'));

  assertFalse(foo(false));
  assertTrue(foo(true));

  %OptimizeFunctionOnNextCall(foo);

  assertFalse(foo(1.5));
  assertTrue(foo(1));

  assertFalse(foo('1.5 number'));
  assertTrue(foo('1 number'));

  assertFalse(foo(false));
  assertTrue(foo(true));
})();
                                                                                                     node-23.7.0/deps/v8/test/mjsunit/compiler/compare-map-elim.js                                       0000664 0000000 0000000 00000003540 14746647661 0024014 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax --check-elimination

a = {
  f: function() { this.y = 3; }
};
b = {
  f: function() { this.y = 4; }
};

function x(z) {
  return z.f();
}

%PrepareFunctionForOptimization(x);

x(a);
x(b);
x(a);
x(b);
x(a);
x(b);

%OptimizeFunctionOnNextCall(x)

x(a);
x(b);
                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/compiler/compare-map-elim2.js                                      0000664 0000000 0000000 00000006322 14746647661 0024077 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax --check-elimination


function test_empty() {
  function foo(o) {
    return { value: o.value };
  }

  %PrepareFunctionForOptimization(foo);

  function Base() {
    this.v_ = 5;
  }
  Base.prototype.__defineGetter__("value", function() { return 1; });

  var a = new Base();
  a.a = 1;
  foo(a);

  Base.prototype.__defineGetter__("value", function() { return this.v_; });

  var b = new Base();
  b.b = 1;
  foo(b);

  var d = new Base();
  d.d = 1;
  d.value;

  %OptimizeFunctionOnNextCall(foo);

  var o = foo(b);
}


function test_narrow1() {
  function foo(o) {
    return { value: o.value };
  }

  %PrepareFunctionForOptimization(foo);

  function Base() {
    this.v_ = 5;
  }
  Base.prototype.__defineGetter__("value", function() { return 1; });

  var a = new Base();
  a.a = 1;
  foo(a);

  Base.prototype.__defineGetter__("value", function() { return this.v_; });

  var b = new Base();
  b.b = 1;
  foo(b);

  var c = new Base();
  c.c = 1;
  foo(c);

  var d = new Base();
  d.d = 1;
  d.value;

  %OptimizeFunctionOnNextCall(foo);

  var o = foo(b);
}


function test_narrow2() {
  function foo(o, flag) {
    return { value: o.value(flag) };
  }

  %PrepareFunctionForOptimization(foo);

  function Base() {
    this.v_ = 5;
  }
  Base.prototype.value = function(flag) { return flag ? this.v_ : this.v_; };


  var a = new Base();
  a.a = 1;
  foo(a, false);
  foo(a, false);

  var b = new Base();
  b.b = 1;
  foo(b, true);

  var c = new Base();
  c.c = 1;
  foo(c, true);

  var d = new Base();
  d.d = 1;
  d.value(true);

  %OptimizeFunctionOnNextCall(foo);

  var o = foo(b);
}

test_empty();
test_narrow1();
test_narrow2();
                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/compiler/compare-objeq-elim.js                                     0000664 0000000 0000000 00000004611 14746647661 0024337 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax --check-elimination

function A(x, y) {
  this.x = x;
  this.y = y;
}

function B(x, y) {
  this.x = x;
  this.y = y;
}

function F1(a, b) {
  if (a == b) return a.x;
  else return b.x;
}

function F2(a, b) {
  if (a == b) return a.x;
  else return b.x;
}

function F3(a, b) {
  var f = a.y;
  if (a == b) return a.x;
  else return b.x;
}

function F4(a, b) {
  var f = b.y;
  if (a == b) return a.x;
  else return b.x;
}

%NeverOptimizeFunction(test);

function test(f, a, b) {
  %PrepareFunctionForOptimization(f);

  f(a, a);
  f(a, b);
  f(b, a);
  f(b, c);
  f(b, b);
  f(c, c);

  %OptimizeFunctionOnNextCall(f)

  assertEquals(a.x, f(a, a));
  assertEquals(b.x, f(b, b));
}

var a = new A(3, 5);
var b = new B(2, 6);
var c = new A(1, 7);

test(F1, a, c);
test(F2, a, b);
test(F3, a, b);
test(F4, a, b);
                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/compiler/compare.js                                                0000664 0000000 0000000 00000006621 14746647661 0022320 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function MaxLT(x, y) {
  if (x < y) return y;
  return x;
}

function MaxLE(x, y) {
  if (x <= y) return y;
  return x;
}

function MaxGE(x, y) {
  if (x >= y) return x;
  return y;
}

function MaxGT(x, y) {
  if (x > y) return x;
  return y;
}


// First test primitive values.
function TestPrimitive(max, x, y) {
  assertEquals(max, MaxLT(x, y), "MaxLT - primitive");
  assertEquals(max, MaxLE(x, y), "MaxLE - primitive");
  assertEquals(max, MaxGE(x, y), "MaxGE - primitive");
  assertEquals(max, MaxGT(x, y), "MaxGT - primitive");
}

TestPrimitive(1, 0, 1);
TestPrimitive(1, 1, 0);
TestPrimitive(4, 3, 4);
TestPrimitive(4, 4, 3);
TestPrimitive(0, -1, 0);
TestPrimitive(0, 0, -1)
TestPrimitive(-2, -2, -3);
TestPrimitive(-2, -3, -2);

TestPrimitive(1, 0.1, 1);
TestPrimitive(1, 1, 0.1);
TestPrimitive(4, 3.1, 4);
TestPrimitive(4, 4, 3.1);
TestPrimitive(0, -1.1, 0);
TestPrimitive(0, 0, -1.1)
TestPrimitive(-2, -2, -3.1);
TestPrimitive(-2, -3.1, -2);


// Test non-primitive values and watch for valueOf call order.
function TestNonPrimitive(order, f) {
  var result = "";
  var x = { valueOf: function() { result += "x"; } };
  var y = { valueOf: function() { result += "y"; } };
  f(x, y);
  assertEquals(order, result);
}

TestNonPrimitive("xy", MaxLT);
TestNonPrimitive("xy", MaxLE);
TestNonPrimitive("xy", MaxGE);
TestNonPrimitive("xy", MaxGT);

// Test compare in case of aliased registers.
function CmpX(x) { if (x == x) return 42; }
assertEquals(42, CmpX(0));

function CmpXY(x) { var y = x; if (x == y) return 42; }
assertEquals(42, CmpXY(0));


// Test compare against null.
function CmpNullValue(x) { return x == null; }
assertEquals(false, CmpNullValue(42));

function CmpNullTest(x) { if (x == null) return 42; return 0; }
assertEquals(42, CmpNullTest(null));

var g1 = 0;
function CmpNullEffect() { (g1 = 42) == null; }
CmpNullEffect();
assertEquals(42, g1);
                                                                                                               node-23.7.0/deps/v8/test/mjsunit/compiler/complex-for-in.js                                         0000664 0000000 0000000 00000004035 14746647661 0023526 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function TestNamed(m) {
  var o = {};
  var result = [];
  for (o.p in m) result.push(o.p);
  return result;
}

assertArrayEquals(['x','y'], TestNamed({x:0, y:1}));
assertArrayEquals(['0','1'], TestNamed([1,2]));


function TestKeyed(m) {
  var a = [];
  var result = [];
  var i = 0;
  for (a[i++] in m) result.push(a[i - 1]);
  assertEquals(i, a.length);
  return result;
}


assertArrayEquals(['x','y'], TestKeyed({x:0, y:1}));
assertArrayEquals(['0','1'], TestKeyed([1,2]));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/compiler/concurrent-inlining-1.js                                  0000664 0000000 0000000 00000001640 14746647661 0025013 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turboshaft-enable-debug-features

// This test ensures that we manage to serialize the global.gaga function for
// compilation and therefore are able to inline it. Since the call feedback in
// bar is megamorphic, this relies on recording the correct accumulator hint for
// the named load of obj.gaga while serializing bar (in turn while serializing
// foo).

const global = this;
global.gaga = function gaga() { return true; };

function bar(obj) { return obj.gaga(); };
function foo() { return %TurbofanStaticAssert(bar(global)); }

%PrepareFunctionForOptimization(foo);
%PrepareFunctionForOptimization(bar);
%PrepareFunctionForOptimization(global.gaga);

bar({gaga() {}});
foo();
%OptimizeFunctionOnNextCall(foo);
foo();
                                                                                                node-23.7.0/deps/v8/test/mjsunit/compiler/concurrent-inlining-2.js                                  0000664 0000000 0000000 00000001656 14746647661 0025023 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turboshaft-enable-debug-features

// This test ensures that we manage to serialize the global.gaga function for
// compilation and therefore are able to inline it. Since the call feedback in
// bar is megamorphic, this relies on recording the correct accumulator hint for
// the named load of obj.gaga while serializing bar (in turn while serializing
// foo).

const global = this;
global.gaga = function gaga() { return true; };

function bar(obj) { return obj.gaga(); }
function foo(obj) { obj.gaga; %TurbofanStaticAssert(bar(obj)); }

%PrepareFunctionForOptimization(foo);
%PrepareFunctionForOptimization(bar);
%PrepareFunctionForOptimization(global.gaga);

bar({gaga() {}});
foo(global);
%OptimizeFunctionOnNextCall(foo);
foo(global);
                                                                                  node-23.7.0/deps/v8/test/mjsunit/compiler/concurrent-invalidate-transition-map.js                   0000664 0000000 0000000 00000005652 14746647661 0030140 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax --concurrent-recompilation --no-always-turbofan

if (!%IsConcurrentRecompilationSupported()) {
  print("Concurrent recompilation is disabled. Skipping this test.");
  quit();
}

function new_object() {
  var o = {};
  o.a = 1;
  o.b = 2;
  return o;
}

function add_field(obj) {
  // Assign twice to make the field non-constant.
  obj.c = 0;
  obj.c = 3;
}
%PrepareFunctionForOptimization(add_field);
var obj1 = new_object();
var obj2 = new_object();
add_field(obj1);
add_field(obj2);
%DisableOptimizationFinalization();
%OptimizeFunctionOnNextCall(add_field, "concurrent");

var o = new_object();
// Kick off recompilation.
add_field(o);
// Invalidate transition map after compile graph has been created.
%WaitForBackgroundOptimization();
o.c = 2.2;
assertUnoptimized(add_field);
// Sync with background thread to conclude optimization that bailed out.
%FinalizeOptimization();
if (!%IsDictPropertyConstTrackingEnabled()) {
  // TODO(v8:11457) Currently, we cannot inline property stores if there is a
  // dictionary mode prototype on the prototype chain. Therefore, if
  // v8_dict_property_const_tracking is enabled, the optimized code only
  // contains a call to the IC handler and doesn't get invalidated when the
  // transition map changes.
  assertUnoptimized(add_field);
}
// Clear type info for stress runs.
%ClearFunctionFeedback(add_field);
                                                                                      node-23.7.0/deps/v8/test/mjsunit/compiler/concurrent-proto-change.js                                0000664 0000000 0000000 00000004506 14746647661 0025440 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax --no-always-turbofan --concurrent-recompilation

function f(foo) { return foo.bar(); }

%PrepareFunctionForOptimization(f);

var o = {};
o.__proto__ = { __proto__: { bar: function() { return 1; } } };

assertEquals(1, f(o));
assertEquals(1, f(o));

%DisableOptimizationFinalization();
%OptimizeFunctionOnNextCall(f, "concurrent");
// Kick off recompilation.
assertEquals(1, f(o));
// Change the prototype chain after compile graph has been created.
%WaitForBackgroundOptimization();
o.__proto__.__proto__ = { bar: function() { return 2; } };
assertUnoptimized(f);
%FinalizeOptimization();
// Optimization failed due to map dependency.
assertUnoptimized(f);
assertEquals(2, f(o));
// Clear type info for stress runs.
%ClearFunctionFeedback(f);
                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/compiler/conditional-chain.js                                      0000664 0000000 0000000 00000011502 14746647661 0024247 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Generates a function of the form
//
// function(x) {
//   return (x === threshold) ? threshold*threshold :
//          (x === threshold+1) ? (threshold+1)*(threshold+1) :
//          ...
//          (x === threshold+num_if_else-1) ?
//              (threshold+num_if_else-1)*(threshold+num_if_else-1) :
//          (threshold+num_if_else)*(threshold+num_if_else);
// }
//
function generate_long_conditional_chain(num_if_else, threshold = 0) {
    let str = "(function(x){";
    str += "return ";
    for (let j = 0; j < num_if_else; j++) {
        let i = j + threshold;
        str += "(x === "+i+") ? "+i*i+" : ";
    }
    let i = num_if_else + threshold;
    str += i*i+";})";
    return eval(str);
}

// Generates a function of the form
//
// function(x, y) {
//   return (x === 0 && y === 0) ? 0*0 + threshold :
//          (x === 0 && y === 1) ? 0*1 + threshold :
//          ...
//          (x === 1 && y === 1) ? 1*1 + threshold :
//          (x === 1 && y === 2) ? 1*2 + threshold :
//          ...
//          (x === 2 && y === 1) ? 2*1 + threshold :
//          (x === 2 && y === 2) ? 2*2 + threshold :
//          (x === 2 && y === 3) ? 2*3 + threshold :
//          ...
//          (x === num_x-1 && y === num_y-1) ?
//              (num_x-1)*(num_y-1) + threshold :
//          (num_x)*(num_y) + threshold;
function generate_double_conditional_chain(num_x, num_y, threshold = 0) {
    let str = "(function(x, y){";
    str += "return ";
    for (let i = 0; i < num_x; i++) {
        for (let j = 0; j < num_y; j++) {
            str += "(x === "+i+" && y === "+j+") ? "+(i*j + threshold)+" : ";
        }
    }
    str += (num_x*num_y + threshold)+";})";
    return eval(str);
}

(function() {
    let conditional_chain = generate_long_conditional_chain(110);
    assertEquals(5*5, conditional_chain(5));
    assertEquals(6*6, conditional_chain(6));
    assertEquals(100*100, conditional_chain(100));
    assertEquals(109*109, conditional_chain(109));
    assertEquals(110*110, conditional_chain(110));
    assertEquals(110*110, conditional_chain(111));
    assertEquals(110*110, conditional_chain(200));
    assertEquals(110*110, conditional_chain(1000));
})();

// Test that the result of the conditional chain is correct for a double
// conditional chain. While the result given should be correct, there should
// not be any crashes even if the length of the chain is very long.
(function() {
    let threshold = 100;
    let double_conditional_chain =
        generate_double_conditional_chain(17, 19, threshold);
    assertEquals(5*5 + threshold, double_conditional_chain(5, 5));
    assertEquals(6*6 + threshold, double_conditional_chain(6, 6));
    assertEquals(4*5 + threshold, double_conditional_chain(4, 5));
    assertEquals(5*4 + threshold, double_conditional_chain(5, 4));
    assertEquals(9*2 + threshold, double_conditional_chain(9, 2));
    assertEquals(17*19 + threshold, double_conditional_chain(100, 12));
    assertEquals(17*19 + threshold, double_conditional_chain(100, 100));
    assertEquals(17*19 + threshold, double_conditional_chain(100, 1000));
    assertEquals(17*19 + threshold, double_conditional_chain(1000, 100));
    assertEquals(17*19 + threshold, double_conditional_chain(1000, 1000));
})();

// Test that the result of the conditional chain is correct.
// The size of the chain is stretched to 50000 to make sure that the
// conditional chain will not crash even if the length of the chain is very
// long.
(function() {
    let threshold = 100;
    let chain_length = 50000;
    let conditional_chain =
        generate_long_conditional_chain(chain_length, threshold);
    assertEquals(
        (chain_length + threshold)*(chain_length + threshold),
        conditional_chain(0));
    assertEquals(
        (chain_length + threshold)*(chain_length + threshold),
        conditional_chain(1));
    assertEquals(
        (1 + threshold)*(1 + threshold),
        conditional_chain(1 + threshold));
    assertEquals(
        (2 + threshold)*(2 + threshold),
        conditional_chain(2 + threshold));
    assertEquals(
        (chain_length - 1 + threshold)*(chain_length - 1 + threshold),
        conditional_chain(chain_length - 1 + threshold));
    assertEquals(
        (chain_length + threshold)*(chain_length + threshold),
        conditional_chain(chain_length + threshold));
    assertEquals(
        (chain_length + threshold)*(chain_length + threshold),
        conditional_chain(chain_length + 1 + threshold));
    assertEquals(
        (chain_length + threshold)*(chain_length + threshold),
        conditional_chain(chain_length + 100 + threshold));
    assertEquals(
        (chain_length + threshold)*(chain_length + threshold),
        conditional_chain(chain_length + 1000 + threshold));
})();
                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/compiler/consecutive-addition.js                                   0000664 0000000 0000000 00000001275 14746647661 0025012 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

function f1(n) {
  var a = n + 2;
  return a + 3;
}

%PrepareFunctionForOptimization(f1);
assertEquals(f1(1), 6);
assertEquals(f1(2), 7);
%OptimizeFunctionOnNextCall(f1);
assertEquals(f1(13), 18);
assertEquals(f1(14), 19);

function f2(n, odd) {
  var a = n + 2;
  if (odd) return a;
  return a + 3;
}

%PrepareFunctionForOptimization(f2);
assertEquals(f2(1, true), 3);
assertEquals(f2(2, false), 7);
%OptimizeFunctionOnNextCall(f2);
assertEquals(f2(13, true), 15);
assertEquals(f2(14, false), 19);
                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/compiler/constant-fold-add-static.js                               0000664 0000000 0000000 00000001012 14746647661 0025445 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-assert-types
// Flags: --turboshaft-enable-debug-features

// Check that constant-folding of arithmetic results in identical nodes.
(function() {
function foo(x) {
  %TurbofanStaticAssert(1 * x == x + 0);
};
%PrepareFunctionForOptimization(foo);
foo(121);
foo(122);
%OptimizeFunctionOnNextCall(foo);
foo(123);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/compiler/constant-fold-cow-array.js                                0000664 0000000 0000000 00000006033 14746647661 0025344 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-always-turbofan --turbofan

// Check that we properly deoptimize TurboFan'ed code when we constant-fold
// elements from a COW array and we change the length of the array.
(function() {
  const a = [1, 2, 3];
  const foo = () => a[0];
  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo());
  assertEquals(1, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo());
  assertOptimized(foo);
  a.length = 1;
  assertEquals(1, foo());
  assertUnoptimized(foo);
})();

// Check that we properly deoptimize TurboFan'ed code when we constant-fold
// elements from a COW array and we change the element of the array.
(function() {
  const a = [1, 2, 3];
  const foo = () => a[0];
  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo());
  assertEquals(1, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo());
  assertOptimized(foo);
  a[0] = 42;
  assertEquals(42, foo());
  assertUnoptimized(foo);
})();

// Packed
// Non-extensible
(function() {
  const a = Object.preventExtensions([1, 2, '3']);
  const foo = () => a[0];
  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo());
  assertEquals(1, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo());
  assertOptimized(foo);
  a[0] = 42;
  assertEquals(42, foo());
})();

// Sealed
(function() {
  const a = Object.seal([1, 2, '3']);
  const foo = () => a[0];
  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo());
  assertEquals(1, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo());
  assertOptimized(foo);
  a[0] = 42;
  assertEquals(42, foo());
})();

// Frozen
(function() {
  const a = Object.freeze([1, 2, '3']);
  const foo = () => a[0];
  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo());
  assertEquals(1, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo());
  assertOptimized(foo);
  a[0] = 42;
  assertEquals(1, foo());
})();

// Holey
// Non-extensible
(function() {
  const a = Object.preventExtensions([1, 2, , '3']);
  const foo = () => a[0];
  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo());
  assertEquals(1, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo());
  assertOptimized(foo);
  a[0] = 42;
  assertEquals(42, foo());
})();

// Sealed
(function() {
  const a = Object.seal([1, 2, , '3']);
  const foo = () => a[0];
  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo());
  assertEquals(1, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo());
  assertOptimized(foo);
  a[0] = 42;
  assertEquals(42, foo());
})();

// Frozen
(function() {
  const a = Object.freeze([1, 2, , '3']);
  const foo = () => a[0];
  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo());
  assertEquals(1, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo());
  assertOptimized(foo);
  a[0] = 42;
  assertEquals(1, foo());
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/compiler/constant-fold-tostring.js                                 0000664 0000000 0000000 00000001647 14746647661 0025317 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-always-turbofan --turbofan

// Check that constant-folding of ToString operations works properly for NaN.
(function() {
  const foo = () => `${NaN}`;
  %PrepareFunctionForOptimization(foo);
  assertEquals("NaN", foo());
  assertEquals("NaN", foo());
  %OptimizeFunctionOnNextCall(foo);
  assertEquals("NaN", foo());
})();

// Check that constant-folding of ToString operations works properly for 0/-0.
(function() {
  const foo = x => `${x ? 0 : -0}`;
  %PrepareFunctionForOptimization(foo);
  assertEquals("0", foo(true));
  assertEquals("0", foo(false));
  assertEquals("0", foo(true));
  assertEquals("0", foo(false));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals("0", foo(true));
  assertEquals("0", foo(false));
})();
                                                                                         node-23.7.0/deps/v8/test/mjsunit/compiler/construct-bound-function.js                               0000664 0000000 0000000 00000001302 14746647661 0025635 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --turboshaft-enable-debug-features

class C extends Object {
  bla() {}
}

const bla = C.prototype.bla;

function bar(c) {
  %TurbofanStaticAssert(c.bla === bla);
}

const boundC = C.bind(null);
function foo() {
  let c = new boundC();
  bar(c);
}
%PrepareFunctionForOptimization(foo);
%PrepareFunctionForOptimization(bar);
%PrepareFunctionForOptimization(C);
bar({});
bar({a:1});
bar({aa:1});
bar({aaa:1});
bar({aaaa:1});
bar({aaaaa:1});
foo();
foo();
%OptimizeFunctionOnNextCall(foo);
foo();
                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/compiler/construct-object.js                                       0000664 0000000 0000000 00000001205 14746647661 0024153 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --turboshaft-enable-debug-features

Object.prototype.bla = function() {}

const bla = Object.prototype.bla;

function bar(c) {
  %TurbofanStaticAssert(c.bla === bla);
}

function foo() {
  var c = new Object();
  bar(c);
}
%PrepareFunctionForOptimization(foo);
%PrepareFunctionForOptimization(bar);
bar({});
bar({a:1});
bar({aa:1});
bar({aaa:1});
bar({aaaa:1});
bar({aaaaa:1});
foo();
foo();
%OptimizeFunctionOnNextCall(foo);
foo();
                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/compiler/construct-receiver.js                                     0000664 0000000 0000000 00000001625 14746647661 0024517 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turboshaft-enable-debug-features

class C {
  bla() {};
  constructor() { %TurbofanStaticAssert(this.bla === bla); }
}
const bla = C.prototype.bla;
function bar(f) { return new f; }
var CC = C;
function foo() { return bar(CC); }

%PrepareFunctionForOptimization(C);
%PrepareFunctionForOptimization(bla);
%PrepareFunctionForOptimization(foo);
%PrepareFunctionForOptimization(bar);

// Make {this.bla} in C megamorphic
new class extends C { constructor() { super(); this.a = 1 } }
new class extends C { constructor() { super(); this.b = 1 } }
new class extends C { constructor() { super(); this.c = 1 } }
new class extends C { constructor() { super(); this.d = 1 } }

foo();
%OptimizeFunctionOnNextCall(foo);
foo();
                                                                                                           node-23.7.0/deps/v8/test/mjsunit/compiler/constructor-inlining.js                                   0000664 0000000 0000000 00000005313 14746647661 0025061 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --stress-inline

var counter = 0;
var deopt_at = -1;

class Base {
  constructor(use, x){
    if (deopt_at-- == 0) {
        %_DeoptimizeNow();
        %DeoptimizeFunction(testConstructorInlining);
    }
    counter++;
    this.x = x;
    if (use) {
      return x;
    }
  }
}

class Derived extends Base {
  constructor(use, x, y, deopt = false) {
    super(use, x);
    counter++;
    if (deopt_at-- == 0) %_DeoptimizeNow();
    this.y = y;
    if (use) {
      return y;
    }
  }
}

var DerivedDeoptCreate =  new Proxy(Derived, {
  get: function(target, name) {
    if (name=='prototype') {
      counter++;
      if (deopt_at-- == 0) %DeoptimizeFunction(Derived);
    }
    return target[name];
  }
});

function Constr(use, x){
  counter++;
  if (deopt_at-- == 0) %_DeoptimizeNow();
  this.x = x;
  if (use) {
    return x;
  }
}


var a = {};
var b = {};

function testConstructorInlining(){
  assertEquals(a, new Constr(true, a));
  assertEquals(7, new Constr(false, 7).x);
  assertEquals(5, new Constr(true, 5).x);

  assertEquals(a, new Base(true, a));
  assertEquals(7, new Base(false, 7).x);
  assertEquals(5, new Base(true, 5).x);

  assertEquals(b, new Derived(true, a, b));
  assertEquals(a, new Derived(true, a, undefined));
  assertEquals(5, new Derived(false, 5, 7).x);
  assertEquals(7, new Derived(false, 5, 7).y);
  try {
    new Derived(true, a, 7)
    assertTrue(false);
  } catch (e) {
    if (!(e instanceof TypeError)) throw e;
  }
  assertEquals(a, new Derived(true, 5, a));

  %PrepareFunctionForOptimization(Derived);
  %OptimizeFunctionOnNextCall(Derived);
  assertEquals(b, new DerivedDeoptCreate(true, a, b));
  %PrepareFunctionForOptimization(Derived);
  %OptimizeFunctionOnNextCall(Derived);
  assertEquals(a, new DerivedDeoptCreate(true, a, undefined));
  %PrepareFunctionForOptimization(Derived);
  %OptimizeFunctionOnNextCall(Derived);
  assertEquals(5, new DerivedDeoptCreate(false, 5, 7).x);
  %PrepareFunctionForOptimization(Derived);
  %OptimizeFunctionOnNextCall(Derived);
  assertEquals(7, new DerivedDeoptCreate(false, 5, 7).y);
}

testConstructorInlining();
%PrepareFunctionForOptimization(testConstructorInlining);
%OptimizeFunctionOnNextCall(testConstructorInlining);
testConstructorInlining();

var last = undefined;
for(var i = 0; deopt_at < 0; ++i) {
  deopt_at = i;
  counter = 0;
  %PrepareFunctionForOptimization(testConstructorInlining);
  %OptimizeFunctionOnNextCall(testConstructorInlining);
  testConstructorInlining();
  if (last !== undefined) {
    assertEquals(counter, last)
  }
  last = counter;
}
                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/compiler/context-sensitivity.js                                    0000664 0000000 0000000 00000031237 14746647661 0024747 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

const object1 = {[Symbol.toPrimitive]() { return 1; }};
const thrower = {[Symbol.toPrimitive]() { throw new Error(); }};

// Test that JSAdd is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y + x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo(0));
  assertEquals(2, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo(0));
  assertEquals(2, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSSubtract is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y - x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo(0));
  assertEquals(0, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo(0));
  assertEquals(0, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSMultiply is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y * x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo(1));
  assertEquals(1, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo(1));
  assertEquals(1, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSDivide is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y / x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo(1));
  assertEquals(1, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo(1));
  assertEquals(1, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSModulus is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y % x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(1));
  assertEquals(0, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(1));
  assertEquals(0, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSExponentiate is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y ** x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo(1));
  assertEquals(1, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo(1));
  assertEquals(1, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSBitwiseOr is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y | x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo(1));
  assertEquals(1, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo(1));
  assertEquals(1, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSBitwiseAnd is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y & x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo(1));
  assertEquals(1, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo(1));
  assertEquals(1, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSBitwiseXor is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y ^ x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(1));
  assertEquals(0, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(1));
  assertEquals(0, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSShiftLeft is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y << x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(2, foo(1));
  assertEquals(2, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(2, foo(1));
  assertEquals(2, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSShiftRight is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y >> x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(1));
  assertEquals(0, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(1));
  assertEquals(0, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSShiftRightLogical is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y >>> x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(1));
  assertEquals(0, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(1));
  assertEquals(0, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSEqual is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y == x);
  }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(0));
  assertTrue(foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(0));
  assertTrue(foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSLessThan is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y < x);
  }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(0));
  assertFalse(foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(0));
  assertFalse(foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSGreaterThan is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => x > y);
  }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(0));
  assertFalse(foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(0));
  assertFalse(foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSLessThanOrEqual is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => y <= x);
  }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(0));
  assertTrue(foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(0));
  assertTrue(foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSGreaterThanOrEqual is not context-sensitive.
(function() {
  function bar(fn) {
    return fn(1);
  }

  function foo(x) {
    return bar(y => x >= y);
  }

  %PrepareFunctionForOptimization(foo);
  assertFalse(foo(0));
  assertTrue(foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertFalse(foo(0));
  assertTrue(foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSInstanceOf is not context-sensitive.
(function() {
  function bar(fn) {
    return fn({});
  }

  function foo(c) {
    return bar(o => o instanceof c);
  }

  %PrepareFunctionForOptimization(foo);
  assertTrue(foo(Object));
  assertFalse(foo(Array));
  assertThrows(() => foo({[Symbol.hasInstance]() { throw new Error(); }}));
  %OptimizeFunctionOnNextCall(foo);
  assertTrue(foo(Object));
  assertFalse(foo(Array));
  assertThrows(() => foo({[Symbol.hasInstance]() { throw new Error(); }}));
})();

// Test that JSBitwiseNot is not context-sensitive.
(function() {
  function bar(fn) {
    return fn();
  }

  function foo(x) {
    return bar(() => ~x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(-1));
  assertEquals(~1, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(-1));
  assertEquals(~1, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSNegate is not context-sensitive.
(function() {
  function bar(fn) {
    return fn();
  }

  function foo(x) {
    return bar(() => -x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo(-1));
  assertEquals(-1, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo(-1));
  assertEquals(-1, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSIncrement is not context-sensitive.
(function() {
  function bar(fn) {
    return fn();
  }

  function foo(x) {
    return bar(() => ++x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo(0));
  assertEquals(2, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo(0));
  assertEquals(2, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSDecrement is not context-sensitive.
(function() {
  function bar(fn) {
    return fn();
  }

  function foo(x) {
    return bar(() => --x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(1, foo(2));
  assertEquals(0, foo(object1));
  assertThrows(() => foo(thrower));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(1, foo(2));
  assertEquals(0, foo(object1));
  assertThrows(() => foo(thrower));
})();

// Test that JSCreateArguments[UnmappedArguments] is not context-sensitive.
(function() {
  function bar(fn) {
    return fn();
  }

  function foo() {
    "use strict";
    return bar(() => arguments)[0];
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(0, 1));
  assertEquals(1, foo(1, 2));
  assertEquals(undefined, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(0, 1));
  assertEquals(1, foo(1, 2));
  assertEquals(undefined, foo());
})();

// Test that JSCreateArguments[RestParameters] is not context-sensitive.
(function() {
  function bar(fn) {
    return fn();
  }

  function foo(...args) {
    return bar(() => args)[0];
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(0, 1));
  assertEquals(1, foo(1, 2));
  assertEquals(undefined, foo());
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(0, 1));
  assertEquals(1, foo(1, 2));
  assertEquals(undefined, foo());
})();

// Test that JSLoadGlobal/JSStoreGlobal are not context-sensitive.
(function(global) {
  var actualValue = 'Some value';

  Object.defineProperty(global, 'globalValue', {
    configurable: true,
    enumerable: true,
    get: function() {
      return actualValue;
    },
    set: function(v) {
      actualValue = v;
    }
  });

  function bar(fn) {
    return fn();
  }

  function foo(v) {
    return bar(() => {
      const o = globalValue;
      globalValue = v;
      return o;
    });
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals('Some value', foo('Another value'));
  assertEquals('Another value', actualValue);
  assertEquals('Another value', foo('Some value'));
  assertEquals('Some value', actualValue);
  %OptimizeFunctionOnNextCall(foo);
  assertEquals('Some value', foo('Another value'));
  assertEquals('Another value', actualValue);
  assertEquals('Another value', foo('Some value'));
  assertEquals('Some value', actualValue);
})(this);

// Test that for..in is not context-sensitive.
(function() {
  function bar(fn) {
    return fn();
  }

  function foo(o) {
    return bar(() => {
      var s = "";
      for (var k in o) { s += k; }
      return s;
    });
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals('abc', foo({a: 1, b: 2, c: 3}));
  assertEquals('ab', foo(Object.create({a: 1, b: 2})));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals('abc', foo({a: 1, b: 2, c: 3}));
  assertEquals("ab", foo(Object.create({a:1, b:2})));
})();

// Test that most generator operations are not context-sensitive.
(function() {
  function bar(fn) {
    let s = undefined;
    for (const x of fn()) {
      if (s === undefined) s = x;
      else s += x;
    }
    return s;
  }

  function foo(x, y, z) {
    return bar(function*() {
      yield x;
      yield y;
      yield z;
    });
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(6, foo(1, 2, 3));
  assertEquals("abc", foo("a", "b", "c"));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(6, foo(1, 2, 3));
  assertEquals("abc", foo("a", "b", "c"));
})();
                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/compiler/control-flow-0.js                                         0000664 0000000 0000000 00000003453 14746647661 0023454 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function f() {
  return (42 + (0 == 1 ? 1 : 2));
}


function g(x) {
  return (x + (0 == 1 ? 1 : 2));
}


function h(x) {
  return ((x + 1) + (0 == 1 ? 1 : 2));
}

assertEquals(44, f());
assertEquals(45, g(43));
assertEquals(47, h(44));
                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/compiler/control-flow-1.js                                         0000664 0000000 0000000 00000003630 14746647661 0023452 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var global = this;

function f0(x) {
  assertTrue(this === global);
  return x;
}

function g0(x, y) {
  return f0(x == y);
}

assertTrue(g0(0, 0));
assertFalse(g0(0, 1));


var o = {};
o.f1 = f1;
function f1(x) {
  assertTrue(this === o);
  return x;
}

function g1(x, y) {
  return o.f1(x == y);
}

assertTrue(g1(0, 0));
assertFalse(g1(0, 1));
                                                                                                        node-23.7.0/deps/v8/test/mjsunit/compiler/control-flow-2.js                                         0000664 0000000 0000000 00000003273 14746647661 0023456 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function f(a,b) {
  return (b < a) - (a < b);
}

assertEquals(0, f(0,0));
assertEquals(1, f(1,0));
assertEquals(-1, f(0,1));
                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/compiler/count-deopt.js                                            0000664 0000000 0000000 00000012223 14746647661 0023126 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

// Test deopt with count operation on parameter.
var max_smi = 1073741823;
var o = {x:0};

function inc1(x) { x++; o.x = x; }
inc1(max_smi);
assertEquals(max_smi + 1, o.x);

inc1(1.1);
assertEquals(2.1, o.x);


// Test deopt with count operation on named property.
function inc2(p) { p.x++ }

%PrepareFunctionForOptimization(inc2);

o.x = "42";
inc2(o);
assertEquals(43, o.x);

var s = max_smi - 10;
o.x = s;
for(var i = 0; i < 20; i++) {
  inc2(o);
  if (i == 4) {
    %OptimizeFunctionOnNextCall(inc2);
  }
}
assertEquals(max_smi + 10, o.x);


// Test deopt with count operation on keyed property.
function inc3(a, b) { a[b]++; }

%PrepareFunctionForOptimization(inc3);

o = ["42"];
inc3(o, 0);
assertEquals(43, o[0]);

var s = max_smi - 10;
o[0] = s;
for(var i = 0; i < 20; i++) {
  inc3(o, 0);
  if (i == 4) {
    %OptimizeFunctionOnNextCall(inc3);
  }
}
assertEquals(max_smi + 10, o[0]);

inc3(o,"0");

assertEquals(max_smi + 11, o[0]);

// Test bailout when accessing a non-existing array element.
o[0] = 0;
for(var i = 0; i < 5; i++) {
  inc3(o, 0);
}
%PrepareFunctionForOptimization(inc3);
%OptimizeFunctionOnNextCall(inc3);
inc3(o, 0);
inc3(o, 1);

// Test bailout with count operation in a value context.
function inc4(x,y) { return (x++) + y; }
%PrepareFunctionForOptimization(inc4);
for (var i = 0; i < 5; ++i) assertEquals(3, inc4(2, 1));
%OptimizeFunctionOnNextCall(inc4);
inc4(2, 1);
assertEquals(3.1, inc4(2, 1.1));

function inc5(x,y) { return (++x) + y; }
%PrepareFunctionForOptimization(inc5);
for (var i = 0; i < 5; ++i) assertEquals(4, inc5(2, 1));
%OptimizeFunctionOnNextCall(inc5);
assertEquals(4, inc5(2, 1));
assertEquals(4.1, inc5(2, 1.1));
assertEquals(4.1, inc5(2.1, 1));

function inc6(o,y) { return (o.x++) + y; }
%PrepareFunctionForOptimization(inc6);
o = {x:0};
for (var i = 0; i < 5; ++i) {
  o.x = 42;
  assertEquals(43, inc6(o, 1));
}
%OptimizeFunctionOnNextCall(inc6);
o.x = 42;
assertEquals(43, inc6(o, 1));
o.x = 42;
assertEquals(43.1, inc6(o, 1.1));
o.x = 42.1;
assertEquals(43.1, inc6(o, 1));

function inc7(o,y) { return (++o.x) + y; }
%PrepareFunctionForOptimization(inc7);
o = {x:0};
for (var i = 0; i < 5; ++i) {
  o.x = 42;
  assertEquals(44, inc7(o, 1));
}
%OptimizeFunctionOnNextCall(inc7);
o.x = 42;
assertEquals(44, inc7(o, 1));
o.x = 42;
assertEquals(44.1, inc7(o, 1.1));
o.x = 42.1;
assertEquals(44.1, inc7(o, 1));

function inc8(o,y) { return (o[0]++) + y; }
%PrepareFunctionForOptimization(inc8);
var q = [0];
for (var i = 0; i < 5; ++i) {
  q[0] = 42;
  assertEquals(43, inc8(q, 1));
}
%OptimizeFunctionOnNextCall(inc8);
q[0] = 42;
assertEquals(43, inc8(q, 1));
q[0] = 42;
assertEquals(43.1, inc8(q, 1.1));
q[0] = 42.1;
assertEquals(43.1, inc8(q, 1));

function inc9(o,y) { return (++o[0]) + y; }
%PrepareFunctionForOptimization(inc9);
q = [0];
for (var i = 0; i < 5; ++i) {
  q[0] = 42;
  assertEquals(44, inc9(q, 1));
}
%OptimizeFunctionOnNextCall(inc9);
q[0] = 42;
assertEquals(44, inc9(q, 1));
q[0] = 42;
assertEquals(44.1, inc9(q, 1.1));
q[0] = 42.1;
assertEquals(44.1, inc9(q, 1));

// Test deopt because of a failed map check.
function inc10(p) { return p.x++ }
%PrepareFunctionForOptimization(inc10);
var g1 = {x:0};
var g2 = {y:0, x:42}
for (var i = 0; i < 5; ++i) {
  g1.x = 42;
  assertEquals(42, inc10(g1));
  assertEquals(43, g1.x);
}
%OptimizeFunctionOnNextCall(inc10);
g1.x = 42;
assertEquals(42, inc10(g1));
assertEquals(43, g1.x);
assertEquals(42, inc10(g2));
assertEquals(43, g2.x);

// Test deoptimization with postfix operation in a value context.
function inc11(a) { return a[this.x++]; }
var g3 = {x:null, f:inc11};
var g4 = [42];
assertEquals(42, g3.f(g4));
                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/compiler/countoperation.js                                         0000664 0000000 0000000 00000007735 14746647661 0023752 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test pre- and postfix count operations.

// Test value context.
var a = 42;
var b = {x:42};
var c = "x";
assertEquals(43, ++a);
assertEquals(43, a);
assertEquals(43, a++);
assertEquals(44, a);
assertEquals(43, ++b.x);
assertEquals(43, b.x);
assertEquals(43, b.x++);
assertEquals(44, b.x);
assertEquals(45, ++b[c]);
assertEquals(45, b[c]);
assertEquals(45, b[c]++);
assertEquals(46, b[c]);

// Test effect context.
a = 42;
b = {x:42};
c = "x";
assertEquals(1, eval("++a; 1"));
assertEquals(43, a);
assertEquals(1, eval("a++; 1"));
assertEquals(44, a);
assertEquals(1, eval("++b.x; 1"));
assertEquals(43, b.x);
assertEquals(1, eval("b.x++; 1"));
assertEquals(44, b.x);
assertEquals(1, eval("++b[c]; 1"));
assertEquals(45, b[c]);
assertEquals(1, eval("b[c]++; 1"));
assertEquals(46, b[c]);

// Test test context.
a = 42;
b = {x:42};
c = "x";
assertEquals(1, (++a) ? 1 : 0);
assertEquals(43, a);
assertEquals(1, (a++) ? 1 : 0);
assertEquals(44, a);
assertEquals(1, (++b.x) ? 1 : 0);
assertEquals(43, b.x);
assertEquals(1, (b.x++) ? 1 : 0);
assertEquals(44, b.x);
assertEquals(1, (++b[c]) ? 1 : 0);
assertEquals(45, b[c]);
assertEquals(1, (b[c]++) ? 1 : 0);
assertEquals(46, b[c]);

// Test value/test and test/value contexts.
a = 42;
b = {x:42};
c = "x";
assertEquals(43, ++a || 1);
assertEquals(43, a);
assertEquals(43, a++ || 1);
assertEquals(44, a);
assertEquals(43, ++b.x || 1);
assertEquals(43, b.x);
assertEquals(43, (b.x++) || 1);
assertEquals(44, b.x);
assertEquals(45, ++b[c] || 1);
assertEquals(45, b[c]);
assertEquals(45, b[c]++ || 1);
assertEquals(46, b[c]);
a = 42;
b = {x:42};
c = "x";
assertEquals(1, ++a && 1);
assertEquals(43, a);
assertEquals(1, a++ && 1);
assertEquals(44, a);
assertEquals(1, ++b.x && 1);
assertEquals(43, b.x);
assertEquals(1, (b.x++) && 1);
assertEquals(44, b.x);
assertEquals(1, ++b[c] && 1);
assertEquals(45, b[c]);
assertEquals(1, b[c]++ && 1);
assertEquals(46, b[c]);

// Test count operations with parameters.
function f(x) { x++; return x; }
assertEquals(43, f(42));

function g(x) { ++x; return x; }
assertEquals(43, g(42));

function h(x) { var y = x++; return y; }
assertEquals(42, h(42));

function k(x) { var y = ++x; return y; }
assertEquals(43, k(42));

// Test count operation in a test context.
function countTestPost(i) { var k = 0; while (i--) { k++; } return k; }
assertEquals(10, countTestPost(10));

function countTestPre(i) { var k = 0; while (--i) { k++; } return k; }
assertEquals(9, countTestPre(10));
                                   node-23.7.0/deps/v8/test/mjsunit/compiler/dataview-constant.js                                      0000664 0000000 0000000 00000010757 14746647661 0024332 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

// Test DataView.prototype.getInt8()/setInt8() for constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setInt8(0, 42);
  dv.setInt8(1, 24);

  function foo(i) {
    const x = dv.getInt8(i);
    dv.setInt8(i, x+1);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(0));
  assertEquals(24, foo(1));
  assertEquals(43, foo(0));
  assertEquals(25, foo(1));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(0));
  assertEquals(26, foo(1));
})();

// Test DataView.prototype.getUint8()/setUint8() for constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setUint8(0, 42);
  dv.setUint8(1, 24);

  function foo(i) {
    const x = dv.getUint8(i);
    dv.setUint8(i, x+1);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(0));
  assertEquals(24, foo(1));
  assertEquals(43, foo(0));
  assertEquals(25, foo(1));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(0));
  assertEquals(26, foo(1));
})();

// Test DataView.prototype.getInt16()/setInt16() for constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setInt16(0, 42, true);
  dv.setInt16(2, 24, true);

  function foo(i) {
    const x = dv.getInt16(i, true);
    dv.setInt16(i, x+1, true);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(0));
  assertEquals(24, foo(2));
  assertEquals(43, foo(0));
  assertEquals(25, foo(2));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(0));
  assertEquals(26, foo(2));
})();

// Test DataView.prototype.getUint16()/setUint16() for constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setUint16(0, 42, true);
  dv.setUint16(2, 24, true);

  function foo(i) {
    const x = dv.getUint16(i, true);
    dv.setUint16(i, x+1, true);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(0));
  assertEquals(24, foo(2));
  assertEquals(43, foo(0));
  assertEquals(25, foo(2));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(0));
  assertEquals(26, foo(2));
})();

// Test DataView.prototype.getInt32()/setInt32() for constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setInt32(0, 42, true);
  dv.setInt32(4, 24, true);

  function foo(i) {
    const x = dv.getInt32(i, true);
    dv.setInt32(i, x+1, true);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(0));
  assertEquals(24, foo(4));
  assertEquals(43, foo(0));
  assertEquals(25, foo(4));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(0));
  assertEquals(26, foo(4));
})();

// Test DataView.prototype.getUint32()/setUint32() for constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setUint32(0, 42, true);
  dv.setUint32(4, 24, true);

  function foo(i) {
    const x = dv.getUint32(i, true);
    dv.setUint32(i, x+1, true);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(0));
  assertEquals(24, foo(4));
  assertEquals(43, foo(0));
  assertEquals(25, foo(4));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(0));
  assertEquals(26, foo(4));
})();

// Test DataView.prototype.getFloat32()/setFloat32() for constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setFloat32(0, 42, true);
  dv.setFloat32(4, 24, true);

  function foo(i) {
    const x = dv.getFloat32(i, true);
    dv.setFloat32(i, x+1, true);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(0));
  assertEquals(24, foo(4));
  assertEquals(43, foo(0));
  assertEquals(25, foo(4));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(0));
  assertEquals(26, foo(4));
})();

// Test DataView.prototype.getFloat64()/setFloat64() for constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setFloat64(0, 42, true);
  dv.setFloat64(8, 24, true);

  function foo(i) {
    const x = dv.getFloat64(i, true);
    dv.setFloat64(i, x+1, true);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(0));
  assertEquals(24, foo(8));
  assertEquals(43, foo(0));
  assertEquals(25, foo(8));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(0));
  assertEquals(26, foo(8));
})();
                 node-23.7.0/deps/v8/test/mjsunit/compiler/dataview-deopt.js                                         0000664 0000000 0000000 00000002546 14746647661 0023611 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan --no-stress-flush-code

// Check that there are no deopt loops for DataView methods.

var buffer = new ArrayBuffer(64);
var dataview = new DataView(buffer, 8, 24);

// Check DataView getters.

function readUint8(offset) {
  return dataview.getUint8(offset);
}

function warmupRead(f) {
  %PrepareFunctionForOptimization(f);
  f(0);
  f(1);
  %OptimizeFunctionOnNextCall(f);
  f(2);
  f(3);
}

warmupRead(readUint8);
assertOptimized(readUint8);
readUint8(0.5); // Deopts.
assertUnoptimized(readUint8);

warmupRead(readUint8);
assertOptimized(readUint8);
readUint8(1.5); // Doesn't deopt because getUint8 didn't get inlined this time.
assertOptimized(readUint8);

// Check DataView setters.

function writeUint8(offset, value) {
  dataview.setUint8(offset, value);
}

function warmupWrite(f) {
  %PrepareFunctionForOptimization(f);
  f(0, 0);
  f(0, 1);
  %OptimizeFunctionOnNextCall(f);
  f(0, 2);
  f(0, 3);
}

warmupWrite(writeUint8);
assertOptimized(writeUint8);
writeUint8(0.5, 0); // Deopts.
assertUnoptimized(writeUint8);

warmupWrite(writeUint8);
assertOptimized(writeUint8);
writeUint8(1.5, 0); // Doesn't deopt.
assertOptimized(writeUint8);
                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/compiler/dataview-detached.js                                      0000664 0000000 0000000 00000025725 14746647661 0024243 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --noalways-turbofan --no-stress-flush-code

// Invalidate the detaching protector.
%ArrayBufferDetach(new ArrayBuffer(1));

// Check DataView.prototype.getInt8() optimization.
(function() {
  const ab = new ArrayBuffer(1);
  const dv = new DataView(ab);

  function foo(dv) {
    return dv.getInt8(0);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(dv));
  assertEquals(0, foo(dv));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(dv));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.getUint8() optimization.
(function() {
  const ab = new ArrayBuffer(1);
  const dv = new DataView(ab);

  function foo(dv) {
    return dv.getUint8(0);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(dv));
  assertEquals(0, foo(dv));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(dv));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.getInt16() optimization.
(function() {
  const ab = new ArrayBuffer(2);
  const dv = new DataView(ab);

  function foo(dv) {
    return dv.getInt16(0, true);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(dv));
  assertEquals(0, foo(dv));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(dv));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.getUint16() optimization.
(function() {
  const ab = new ArrayBuffer(2);
  const dv = new DataView(ab);

  function foo(dv) {
    return dv.getUint16(0, true);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(dv));
  assertEquals(0, foo(dv));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(dv));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.getInt32() optimization.
(function() {
  const ab = new ArrayBuffer(4);
  const dv = new DataView(ab);

  function foo(dv) {
    return dv.getInt32(0, true);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(dv));
  assertEquals(0, foo(dv));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(dv));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.getUint32() optimization.
(function() {
  const ab = new ArrayBuffer(4);
  const dv = new DataView(ab);

  function foo(dv) {
    return dv.getUint32(0, true);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(dv));
  assertEquals(0, foo(dv));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(dv));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.getFloat32() optimization.
(function() {
  const ab = new ArrayBuffer(4);
  const dv = new DataView(ab);

  function foo(dv) {
    return dv.getFloat32(0, true);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(dv));
  assertEquals(0, foo(dv));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(dv));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.getFloat64() optimization.
(function() {
  const ab = new ArrayBuffer(8);
  const dv = new DataView(ab);

  function foo(dv) {
    return dv.getFloat64(0, true);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(0, foo(dv));
  assertEquals(0, foo(dv));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(0, foo(dv));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.setInt8() optimization.
(function() {
  const ab = new ArrayBuffer(1);
  const dv = new DataView(ab);

  function foo(dv, x) {
    return dv.setInt8(0, x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(undefined, foo(dv, 1));
  assertEquals(1, dv.getInt8(0));
  assertEquals(undefined, foo(dv, 2));
  assertEquals(2, dv.getInt8(0));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(undefined, foo(dv, 3));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv, 4), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv, 5), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.setUint8() optimization.
(function() {
  const ab = new ArrayBuffer(1);
  const dv = new DataView(ab);

  function foo(dv, x) {
    return dv.setUint8(0, x);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(undefined, foo(dv, 1));
  assertEquals(1, dv.getUint8(0));
  assertEquals(undefined, foo(dv, 2));
  assertEquals(2, dv.getUint8(0));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(undefined, foo(dv, 3));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv, 4), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv, 5), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.setInt16() optimization.
(function() {
  const ab = new ArrayBuffer(2);
  const dv = new DataView(ab);

  function foo(dv, x) {
    return dv.setInt16(0, x, true);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(undefined, foo(dv, 1));
  assertEquals(1, dv.getInt16(0, true));
  assertEquals(undefined, foo(dv, 2));
  assertEquals(2, dv.getInt16(0, true));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(undefined, foo(dv, 3));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv, 4), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv, 5), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.setUint16() optimization.
(function() {
  const ab = new ArrayBuffer(2);
  const dv = new DataView(ab);

  function foo(dv, x) {
    return dv.setUint16(0, x, true);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(undefined, foo(dv, 1));
  assertEquals(1, dv.getUint16(0, true));
  assertEquals(undefined, foo(dv, 2));
  assertEquals(2, dv.getUint16(0, true));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(undefined, foo(dv, 3));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv, 4), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv, 5), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.setInt32() optimization.
(function() {
  const ab = new ArrayBuffer(4);
  const dv = new DataView(ab);

  function foo(dv, x) {
    return dv.setInt32(0, x, true);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(undefined, foo(dv, 1));
  assertEquals(1, dv.getInt32(0, true));
  assertEquals(undefined, foo(dv, 2));
  assertEquals(2, dv.getInt32(0, true));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(undefined, foo(dv, 3));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv, 4), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv, 5), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.setUint32() optimization.
(function() {
  const ab = new ArrayBuffer(4);
  const dv = new DataView(ab);

  function foo(dv, x) {
    return dv.setUint32(0, x, true);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(undefined, foo(dv, 1));
  assertEquals(1, dv.getUint32(0, true));
  assertEquals(undefined, foo(dv, 2));
  assertEquals(2, dv.getUint32(0, true));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(undefined, foo(dv, 3));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv, 4), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv, 5), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.setFloat32() optimization.
(function() {
  const ab = new ArrayBuffer(4);
  const dv = new DataView(ab);

  function foo(dv, x) {
    return dv.setFloat32(0, x, true);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(undefined, foo(dv, 1));
  assertEquals(1, dv.getFloat32(0, true));
  assertEquals(undefined, foo(dv, 2));
  assertEquals(2, dv.getFloat32(0, true));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(undefined, foo(dv, 3));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv, 4), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv, 5), TypeError);
  assertOptimized(foo);
})();

// Check DataView.prototype.setFloat64() optimization.
(function() {
  const ab = new ArrayBuffer(8);
  const dv = new DataView(ab);

  function foo(dv, x) {
    return dv.setFloat64(0, x, true);
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(undefined, foo(dv, 1));
  assertEquals(1, dv.getFloat64(0, true));
  assertEquals(undefined, foo(dv, 2));
  assertEquals(2, dv.getFloat64(0, true));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(undefined, foo(dv, 3));
  assertOptimized(foo);
  %ArrayBufferDetach(ab);
  assertThrows(() => foo(dv, 4), TypeError);
  assertUnoptimized(foo);
  %PrepareFunctionForOptimization(foo);
  %OptimizeFunctionOnNextCall(foo);
  assertThrows(() => foo(dv, 5), TypeError);
  assertOptimized(foo);
})();
                                           node-23.7.0/deps/v8/test/mjsunit/compiler/dataview-get.js                                           0000664 0000000 0000000 00000013407 14746647661 0023253 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

var buffer = new ArrayBuffer(64);
var dataview = new DataView(buffer, 8, 24);

var values = [-1, 2, -3, 42];

function readUint8(offset) {
  return dataview.getUint8(offset);
}

function readInt8Handled(offset) {
  try {
    return dataview.getInt8(offset);
  } catch (e) {
    return e;
  }
}

function readUint16(offset, little_endian) {
  return dataview.getUint16(offset, little_endian);
}

function readInt16Handled(offset, little_endian) {
  try {
    return dataview.getInt16(offset, little_endian);
  } catch (e) {
    return e;
  }
}

function readUint32(offset, little_endian) {
  return dataview.getUint32(offset, little_endian);
}

function readInt32Handled(offset, little_endian) {
  try {
    return dataview.getInt32(offset, little_endian);
  } catch (e) {
    return e;
  }
}

function readFloat32(offset, little_endian) {
  return dataview.getFloat32(offset, little_endian);
}

function readFloat64(offset, little_endian) {
  return dataview.getFloat64(offset, little_endian);
}

function readBigInt64Handled(offset, little_endian) {
  try {
    return dataview.getBigInt64(offset, little_endian);
  } catch (e) {
    return e;
  }
}

function readBigUint64Handled(offset, little_endian) {
  try {
    return dataview.getBigUint64(offset, little_endian);
  } catch(e) {
    return e;
  }
}

function warmup(f) {
  %PrepareFunctionForOptimization(f);
  f(0);
  f(1);
  %OptimizeFunctionOnNextCall(f);
  f(2);
  f(3);
}

// TurboFan valid getInt8.
for (var i = 0; i < values.length; i++) {
  dataview.setInt8(i, values[i]);
}
warmup(readInt8Handled);
assertOptimized(readInt8Handled);
assertEquals(values[0], readInt8Handled(0));
assertEquals(values[1], readInt8Handled(1));
assertEquals(values[2], readInt8Handled(2));
assertEquals(values[3], readInt8Handled(3));

// TurboFan valid getUint8.
dataview.setUint32(4, 0xdeadbeef);
warmup(readUint8);
assertOptimized(readUint8);
assertEquals(0xde, readUint8(4));
assertEquals(0xad, readUint8(5));
assertEquals(0xbe, readUint8(6));
assertEquals(0xef, readUint8(7));

// TurboFan valid getUint16.
dataview.setUint16(8, 0xabcd);
warmup(readUint16);
assertOptimized(readUint16);
assertEquals(0xabcd, readUint16(8));
assertEquals(0xcdab, readUint16(8, true));

// TurboFan valid getInt16.
let b1 = -0x1234;
dataview.setInt16(10, b1);
warmup(readInt16Handled);
assertOptimized(readInt16Handled);
assertEquals(b1, readInt16Handled(10));
dataview.setInt16(10, b1, true);
assertEquals(b1, readInt16Handled(10, true));

// TurboFan valid getUint32.
dataview.setUint32(12, 0xabcdef12);
warmup(readUint32);
assertOptimized(readUint32);
assertEquals(0xabcdef12, readUint32(12));
assertEquals(0x12efcdab, readUint32(12, true));

// TurboFan valid getInt32.
let b2 = -0x12345678;
dataview.setInt32(16, b2);
warmup(readInt32Handled);
assertOptimized(readInt32Handled);
assertEquals(b2, readInt32Handled(16));
dataview.setInt32(16, b2, true);
assertEquals(b2, readInt32Handled(16, true));

// TurboFan valid getFloat32.
let b3 = Math.fround(Math.E); // Round Math.E to float32.
dataview.setFloat32(16, b3);
warmup(readFloat32);
assertOptimized(readFloat32);
assertEquals(b3, readFloat32(16));
dataview.setFloat32(16, b3, true);
assertEquals(b3, readFloat32(16, true));

// TurboFan valid getFloat64.
let b4 = Math.PI;
dataview.setFloat64(16, b4);
warmup(readFloat64);
assertOptimized(readFloat64);
assertEquals(b4, readFloat64(16));
dataview.setFloat64(16, b4, true);
assertEquals(b4, readFloat64(16, true));

// TurboFan valid getBigInt64.
let b5 = -0x12345678912345n;
dataview.setBigInt64(16, b5);
warmup(readBigInt64Handled);
assertOptimized(readBigInt64Handled);
assertEquals(b5, readBigInt64Handled(16));
dataview.setBigInt64(16, b5, true);
assertEquals(b5, readBigInt64Handled(16, true));

// TurboFan valid getBigUint64.
let b6 = 0x12345678912345n;
dataview.setBigUint64(16, b6);
warmup(readBigUint64Handled);
assertOptimized(readBigUint64Handled);
assertEquals(b6, readBigUint64Handled(16));
dataview.setBigUint64(16, b6, true);
assertEquals(b6, readBigUint64Handled(16, true));

// TurboFan out of bounds reads deopt.
assertOptimized(readInt8Handled);
assertInstanceof(readInt8Handled(24), RangeError);
assertUnoptimized(readInt8Handled);
assertOptimized(readInt16Handled);
assertInstanceof(readInt16Handled(23), RangeError);
assertUnoptimized(readInt16Handled);
assertOptimized(readInt32Handled);
assertInstanceof(readInt32Handled(21), RangeError);
assertUnoptimized(readInt32Handled);

// Without exception handler.
assertOptimized(readUint8);
assertThrows(() => readUint8(24));
assertUnoptimized(readUint8);
assertOptimized(readFloat32);
assertThrows(() => readFloat32(21));
assertUnoptimized(readFloat32);
assertOptimized(readFloat64);
assertThrows(() => readFloat64(17));
assertUnoptimized(readFloat64);

// Negative Smi deopts.
(function() {
  function readInt8Handled(offset) {
    try { return dataview.getInt8(offset); } catch (e) { return e; }
  }
  warmup(readInt8Handled);
  assertOptimized(readInt8Handled);
  assertInstanceof(readInt8Handled(-1), RangeError);
  assertUnoptimized(readInt8Handled);
})();

// Non-Smi index deopts.
(function() {
  function readUint8(offset) { return dataview.getUint8(offset); }
  warmup(readUint8);
  assertOptimized(readUint8);
  assertEquals(values[3], readUint8(3.14));
  assertUnoptimized(readUint8);
})();

// TurboFan detached buffer deopts.
(function() {
  function readInt8Handled(offset) {
    try { return dataview.getInt8(offset); } catch (e) { return e; }
  }
  warmup(readInt8Handled);
  assertOptimized(readInt8Handled);
  %ArrayBufferDetach(buffer);
  assertInstanceof(readInt8Handled(0), TypeError);
  assertUnoptimized(readInt8Handled);
})();
                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/compiler/dataview-nonconstant.js                                   0000664 0000000 0000000 00000011357 14746647661 0025042 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

// Test DataView.prototype.getInt8()/setInt8() for non-constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setInt8(0, 42);
  dv.setInt8(1, 24);

  function foo(dv, i) {
    const x = dv.getInt8(i);
    dv.setInt8(i, x+1);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(dv, 0));
  assertEquals(24, foo(dv, 1));
  assertEquals(43, foo(dv, 0));
  assertEquals(25, foo(dv, 1));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(dv, 0));
  assertEquals(26, foo(dv, 1));
})();

// Test DataView.prototype.getUint8()/setUint8() for non-constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setUint8(0, 42);
  dv.setUint8(1, 24);

  function foo(dv, i) {
    const x = dv.getUint8(i);
    dv.setUint8(i, x+1);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(dv, 0));
  assertEquals(24, foo(dv, 1));
  assertEquals(43, foo(dv, 0));
  assertEquals(25, foo(dv, 1));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(dv, 0));
  assertEquals(26, foo(dv, 1));
})();

// Test DataView.prototype.getInt16()/setInt16() for non-constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setInt16(0, 42, true);
  dv.setInt16(2, 24, true);

  function foo(dv, i) {
    const x = dv.getInt16(i, true);
    dv.setInt16(i, x+1, true);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(dv, 0));
  assertEquals(24, foo(dv, 2));
  assertEquals(43, foo(dv, 0));
  assertEquals(25, foo(dv, 2));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(dv, 0));
  assertEquals(26, foo(dv, 2));
})();

// Test DataView.prototype.getUint16()/setUint16() for non-constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setUint16(0, 42, true);
  dv.setUint16(2, 24, true);

  function foo(dv, i) {
    const x = dv.getUint16(i, true);
    dv.setUint16(i, x+1, true);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(dv, 0));
  assertEquals(24, foo(dv, 2));
  assertEquals(43, foo(dv, 0));
  assertEquals(25, foo(dv, 2));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(dv, 0));
  assertEquals(26, foo(dv, 2));
})();

// Test DataView.prototype.getInt32()/setInt32() for non-constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setInt32(0, 42, true);
  dv.setInt32(4, 24, true);

  function foo(dv, i) {
    const x = dv.getInt32(i, true);
    dv.setInt32(i, x+1, true);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(dv, 0));
  assertEquals(24, foo(dv, 4));
  assertEquals(43, foo(dv, 0));
  assertEquals(25, foo(dv, 4));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(dv, 0));
  assertEquals(26, foo(dv, 4));
})();

// Test DataView.prototype.getUint32()/setUint32() for non-constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setUint32(0, 42, true);
  dv.setUint32(4, 24, true);

  function foo(dv, i) {
    const x = dv.getUint32(i, true);
    dv.setUint32(i, x+1, true);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(dv, 0));
  assertEquals(24, foo(dv, 4));
  assertEquals(43, foo(dv, 0));
  assertEquals(25, foo(dv, 4));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(dv, 0));
  assertEquals(26, foo(dv, 4));
})();

// Test DataView.prototype.getFloat32()/setFloat32() for non-constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setFloat32(0, 42, true);
  dv.setFloat32(4, 24, true);

  function foo(dv, i) {
    const x = dv.getFloat32(i, true);
    dv.setFloat32(i, x+1, true);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(dv, 0));
  assertEquals(24, foo(dv, 4));
  assertEquals(43, foo(dv, 0));
  assertEquals(25, foo(dv, 4));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(dv, 0));
  assertEquals(26, foo(dv, 4));
})();

// Test DataView.prototype.getFloat64()/setFloat64() for non-constant DataViews.
(function() {
  const dv = new DataView(new ArrayBuffer(1024));
  dv.setFloat64(0, 42, true);
  dv.setFloat64(8, 24, true);

  function foo(dv, i) {
    const x = dv.getFloat64(i, true);
    dv.setFloat64(i, x+1, true);
    return x;
  }

  %PrepareFunctionForOptimization(foo);
  assertEquals(42, foo(dv, 0));
  assertEquals(24, foo(dv, 8));
  assertEquals(43, foo(dv, 0));
  assertEquals(25, foo(dv, 8));
  %OptimizeFunctionOnNextCall(foo);
  assertEquals(44, foo(dv, 0));
  assertEquals(26, foo(dv, 8));
})();
                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/compiler/dataview-set.js                                           0000664 0000000 0000000 00000010555 14746647661 0023270 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

var buffer = new ArrayBuffer(64);
var dataview = new DataView(buffer, 8, 24);

function writeUint8(offset, value) {
  dataview.setUint8(offset, value);
}

function writeInt8Handled(offset, value) {
  try {
    dataview.setInt8(offset, value);
  } catch(e) {
    return e;
  }
}

function writeUint16(offset, value, little_endian) {
  dataview.setUint16(offset, value, little_endian);
}

function writeInt16(offset, value, little_endian) {
  dataview.setInt16(offset, value, little_endian);
}

function writeUint32(offset, value, little_endian) {
  dataview.setUint32(offset, value, little_endian);
}

function writeInt32(offset, value, little_endian) {
  dataview.setInt32(offset, value, little_endian);
}

function writeFloat32(offset, value, little_endian) {
  dataview.setFloat32(offset, value, little_endian);
}

function writeFloat64(offset, value, little_endian) {
  dataview.setFloat64(offset, value, little_endian);
}

function writeBigInt64(offset, value, little_endian) {
  dataview.setBigInt64(offset, value, little_endian);
}

function writeBigUint64(offset, value, little_endian) {
  dataview.setBigUint64(offset, value, little_endian);
}

function warmup(f, v = 0) {
  %PrepareFunctionForOptimization(f);
  f(0, v++);
  f(0, v++);
  %OptimizeFunctionOnNextCall(f);
  f(0, v++);
  f(0, v++);
}

// TurboFan valid setUint8.
warmup(writeUint8);
assertOptimized(writeUint8);
writeUint8(0, 0xde);
writeUint8(1, 0xad);
writeUint8(2, 0xbe);
writeUint8(3, 0xef);
assertEquals(0xdeadbeef, dataview.getUint32(0));

// TurboFan valid setInt8.
warmup(writeInt8Handled);
assertOptimized(writeInt8Handled);
writeInt8Handled(0, -34);
writeInt8Handled(1, -83);
writeInt8Handled(2, -66);
writeInt8Handled(3, -17);
assertEquals(0xdeadbeef, dataview.getUint32(0));

// TurboFan valid setUint16.
warmup(writeUint16);
assertOptimized(writeUint16);
writeUint16(0, 0xdead);
writeUint16(2, 0xefbe, true);
assertEquals(0xdeadbeef, dataview.getUint32(0));

// TurboFan valid setInt16.
warmup(writeInt16);
assertOptimized(writeInt16);
writeInt16(0, -8531);
writeInt16(2, -4162, true);
assertEquals(0xdeadbeef, dataview.getUint32(0));

// TurboFan valid setUint32.
warmup(writeUint32);
assertOptimized(writeUint32);
writeUint32(0, 0xdeadbeef);
assertEquals(0xdeadbeef, dataview.getUint32(0));
writeUint32(0, 0xefbeadde, true);
assertEquals(0xdeadbeef, dataview.getUint32(0));

// TurboFan valid setInt32.
warmup(writeInt32);
assertOptimized(writeInt32);
writeInt32(0, -559038737);
assertEquals(0xdeadbeef, dataview.getUint32(0));
writeInt32(0, -272716322, true);
assertEquals(0xdeadbeef, dataview.getUint32(0));

// TurboFan valid setFloat32.
let b3 = Math.fround(Math.E); // Round Math.E to float32.
warmup(writeFloat32);
assertOptimized(writeFloat32);
writeFloat32(4, b3);
assertEquals(b3, dataview.getFloat32(4));
writeFloat32(4, b3, true);
assertEquals(b3, dataview.getFloat32(4, true));

// TurboFan valid setFloat64.
let b4 = Math.PI;
warmup(writeFloat64);
assertOptimized(writeFloat64);
writeFloat64(8, b4);
assertEquals(b4, dataview.getFloat64(8));
writeFloat64(8, b4, true);
assertEquals(b4, dataview.getFloat64(8, true));

// TurboFan valid setBigInt64.
warmup(writeBigInt64, 0n);
assertOptimized(writeBigInt64);
writeBigInt64(0, -2401053088876216593n);
assertEquals(0xdeadbeefdeadbeefn, dataview.getBigUint64(0));
writeBigInt64(0, -1171307680053154338n, true);
assertEquals(0xdeadbeefdeadbeefn, dataview.getBigUint64(0));

// TurboFan valid setBigUint64.
warmup(writeBigUint64, 0n);
assertOptimized(writeBigUint64);
writeBigUint64(0, 0xdeadbeefdeadbeefn);
assertEquals(0xdeadbeefdeadbeefn, dataview.getBigUint64(0));
writeBigUint64(0, 0xdeadbeefdeadbeefn, true);
assertEquals(0xdeadbeefdeadbeefn, dataview.getBigUint64(0, true));

// TurboFan out of bounds read, deopt.
assertOptimized(writeInt8Handled);
assertInstanceof(writeInt8Handled(24, 0), RangeError);
assertUnoptimized(writeInt8Handled);

// Without exception handler, deopt too.
assertOptimized(writeUint8);
assertThrows(() => writeUint8(24, 0));
assertUnoptimized(writeUint8);

// None of the stores wrote out of bounds.
var bytes = new Uint8Array(buffer);
for (var i = 0; i < 8; i++) assertEquals(0, bytes[i]);
for (var i = 32; i < 64; i++) assertEquals(0, bytes[i]);
                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/compiler/dead-code.js                                              0000664 0000000 0000000 00000005055 14746647661 0022477 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function dead1(a, b) {
    var x = a + b;
    return a; // x is dead
}

function dead2(a, b) {
    var x = a | 0;
    var y = b | 0;
    return a; // x and y are both dead
}

function dead3(a, b) {
    var z;
    if(a == 2) z = a;
    else z = b;
    return a; // z is dead
}

function dead4(a) {
    var z = 3;
    for (i = 0; i < 3; i++) {
        z++;
    }
    return a; // z is dead
}

function dead5(a) {
    var z = 3;
    for (i = 0; i < 3; i++) {
        z++;
    }
    var w = z + a;
    return a; // z is dead
}

assertTrue(dead1(33, 32) == 33);
assertTrue(dead2(33, 32) == 33);
assertTrue(dead3(33, 32) == 33);
assertTrue(dead4(33) == 33);
assertTrue(dead5(33) == 33);

assertTrue(dead1(34, 7) == 34);
assertTrue(dead2(34, 7) == 34);
assertTrue(dead3(34, 7) == 34);
assertTrue(dead4(34) == 34);
assertTrue(dead5(34) == 34);

assertTrue(dead1(3.4, 0.1) == 3.4);
assertTrue(dead2(3.4, 0.1) == 3.4);
assertTrue(dead3(3.4, 0.1) == 3.4);
assertTrue(dead4(3.4) == 3.4);
assertTrue(dead5(3.4) == 3.4);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/compiler/dead-code2.js                                             0000664 0000000 0000000 00000005160 14746647661 0022556 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function dead1(a, b) {
    { var x = a + b; }
    return a; // x is dead
}

function dead2(a, b) {
    { var x = a | 0; var y = b | 0; }
    return a; // x and y are both dead
}

function dead3(a, b) {
    {
      var z;
      if(a == 2) z = a;
      else z = b;
    }
    return a; // z is dead
}

function dead4(a) {
    {
      var z = 3;
      for (i = 0; i < 3; i++) {
        z++;
      }
    }
    return a; // z is dead
}

function dead5(a) {
    {
      var z = 3;
      for (i = 0; i < 3; i++) {
        z++;
      }
      var w = z + a;
    }
    return a; // z and w are dead
}

assertTrue(dead1(33, 32) == 33);
assertTrue(dead2(33, 32) == 33);
assertTrue(dead3(33, 32) == 33);
assertTrue(dead4(33) == 33);
assertTrue(dead5(33) == 33);

assertTrue(dead1(34, 7) == 34);
assertTrue(dead2(34, 7) == 34);
assertTrue(dead3(34, 7) == 34);
assertTrue(dead4(34) == 34);
assertTrue(dead5(34) == 34);

assertTrue(dead1(3.4, 0.1) == 3.4);
assertTrue(dead2(3.4, 0.1) == 3.4);
assertTrue(dead3(3.4, 0.1) == 3.4);
assertTrue(dead4(3.4) == 3.4);
assertTrue(dead5(3.4) == 3.4);
                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/compiler/dead-code3.js                                             0000664 0000000 0000000 00000005022 14746647661 0022554 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function dead1(a, b) {
    a + b; // dead
    return a;
}

function dead2(a, b) {
    a | 0; // dead
    b | 0; // dead
    return a; // x and y are both dead
}

function dead3(a, b) {
    a == 2 ? a : b; // dead
    return a;
}

function dead4(a) {
    var z = 3;
    for (i = 0; i < 3; i++) {
        z + 3; // dead
    }
    return a;
}

function dead5(a) {
    var z = 3;
    for (i = 0; i < 3; i++) {
        z + 3; // dead
        z++;
    }
    var w = z + a;
    return a; // z is dead
}

assertTrue(dead1(33, 32) == 33);
assertTrue(dead2(33, 32) == 33);
assertTrue(dead3(33, 32) == 33);
assertTrue(dead4(33) == 33);
assertTrue(dead5(33) == 33);

assertTrue(dead1(34, 7) == 34);
assertTrue(dead2(34, 7) == 34);
assertTrue(dead3(34, 7) == 34);
assertTrue(dead4(34) == 34);
assertTrue(dead5(34) == 34);

assertTrue(dead1(3.4, 0.1) == 3.4);
assertTrue(dead2(3.4, 0.1) == 3.4);
assertTrue(dead3(3.4, 0.1) == 3.4);
assertTrue(dead4(3.4) == 3.4);
assertTrue(dead5(3.4) == 3.4);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/compiler/dead-code4.js                                             0000664 0000000 0000000 00000005066 14746647661 0022565 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function dead1(a, b) {
    (a | 0) + (b | 0); // dead
    return a;
}

function dead2(a, b) {
    a | 0; // dead
    b | 0; // dead
    return a; // x and y are both dead
}

function dead3(a, b) {
    a == 2 ? (a | 0) : (b | 0); // dead
    return a;
}

function dead4(a) {
    var z = 3;
    for (i = 0; i < 3; i++) {
        (z | 0) + 3; // dead
    }
    return a;
}

function dead5(a) {
    var z = 3;
    for (i = 0; i < 3; i++) {
        (z | 0) + 3; // dead
        z++;
    }
    var w = z + a;
    return a; // z is dead
}

assertTrue(dead1(33, 32) == 33);
assertTrue(dead2(33, 32) == 33);
assertTrue(dead3(33, 32) == 33);
assertTrue(dead4(33) == 33);
assertTrue(dead5(33) == 33);

assertTrue(dead1(34, 7) == 34);
assertTrue(dead2(34, 7) == 34);
assertTrue(dead3(34, 7) == 34);
assertTrue(dead4(34) == 34);
assertTrue(dead5(34) == 34);

assertTrue(dead1(3.4, 0.1) == 3.4);
assertTrue(dead2(3.4, 0.1) == 3.4);
assertTrue(dead3(3.4, 0.1) == 3.4);
assertTrue(dead4(3.4) == 3.4);
assertTrue(dead5(3.4) == 3.4);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/compiler/dead-code5.js                                             0000664 0000000 0000000 00000005230 14746647661 0022557 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function dead1(a, b) {
    a * b;
    a << b;
    a >> b;
    a >>> b;
    a | b;
    a & b;
    a ^ b;
    return a;
}

function dead2(a, b) {
    (a | 0) * b;
    (a | 0) << b;
    (a | 0) >> b;
    (a | 0) >>> b;
    (a | 0) | b;
    (a | 0) & b;
    (a | 0) ^ b;
    return a;
}

function dead3(a, b) {
    a == 2 ? (a * b) : (b * a); // dead
    return a;
}

function dead4(a) {
    var z = 3;
    for (i = 0; i < 3; i++) {
        z * 3; // dead
    }
    return a;
}

function dead5(a) {
    var z = 3;
    for (i = 0; i < 3; i++) {
        z * 3; // dead
        z++;
    }
    var w = z * a;
    return a; // w is dead
}

assertTrue(dead1(33, 32) == 33);
assertTrue(dead2(33, 32) == 33);
assertTrue(dead3(33, 32) == 33);
assertTrue(dead4(33) == 33);
assertTrue(dead5(33) == 33);

assertTrue(dead1(34, 7) == 34);
assertTrue(dead2(34, 7) == 34);
assertTrue(dead3(34, 7) == 34);
assertTrue(dead4(34) == 34);
assertTrue(dead5(34) == 34);

assertTrue(dead1(3.4, 0.1) == 3.4);
assertTrue(dead2(3.4, 0.1) == 3.4);
assertTrue(dead3(3.4, 0.1) == 3.4);
assertTrue(dead4(3.4) == 3.4);
assertTrue(dead5(3.4) == 3.4);
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/compiler/dead-code6.js                                             0000664 0000000 0000000 00000005104 14746647661 0022560 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax
// Test some dead code elimination scenarios

function dead1(x, y) {
    var a = x | 0, b = y | 0;
    a * b;
    a << b;
    a >> b;
    a >>> b;
    a | b;
    a & b;
    a ^ b;
    return x;
}

function dead2(x, y) {
    var a = x | 0, b = y | 0;
    (a | 0) * b;
    (a | 0) << b;
    (a | 0) >> b;
    (a | 0) >>> b;
    (a | 0) | b;
    (a | 0) & b;
    (a | 0) ^ b;
    return x;
}

function dead3(a, b) {
    a == 2 ? (a * b) : (b * a); // dead
    return a;
}

%PrepareFunctionForOptimization(dead1);
assertTrue(dead1(33, 32) == 33);
assertTrue(dead1(33, 32) == 33);
%OptimizeFunctionOnNextCall(dead1);
assertTrue(dead1(33, 32) == 33);

%PrepareFunctionForOptimization(dead2);
assertTrue(dead2(34, 11) == 34);
assertTrue(dead2(34, 11) == 34);
%OptimizeFunctionOnNextCall(dead2);
assertTrue(dead2(34, 11) == 34);

%PrepareFunctionForOptimization(dead3);
assertTrue(dead3(35, 12) == 35);
assertTrue(dead3(35, 12) == 35);
%OptimizeFunctionOnNextCall(dead3);
assertTrue(dead3(35, 12) == 35);
                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/compiler/dead-loops-neg.js                                         0000664 0000000 0000000 00000006476 14746647661 0023500 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

// Presents negative opportunities for dead loop removal.

function loop1() {
  while (true) return;
}

function loop2() {
  var i = 0;
  while (i++ < 10) ;
  return i;  // value of {i} escapes.
  // can only remove the loop with induction variable analysis.
}

function loop3() {
  var i = 0;
  for (; i < 10; i++) ;
  return i;  // value of {i} escapes.
  // can only remove the loop with induction variable analysis.
}

function loop4() {
  var a = 0;
  for (var i = 0; i < 10; i++) a++;
  return a;  // value of {a} escapes.
  // can only remove the loop with induction variable analysis.
}

function loop5() {
  var a = new Int32Array(4), sum = 0;
  for (var i = 0; i < a.length; i++) {
    sum += a[i];
  }
  return sum;  // {sum} escapes.
  // can only remove the loop by figuring out that all elements of {a} are 0.
}

function loop6(a) {
  for (var i = 0; i < a; i++) ;  // implicit a.valueOf().
  // can only remove the loop by guarding on the type of a.
}

function loop7(a) {
  for (var i = 0; i < 10; i++) a.toString();  // unknown side-effect on a.
  // can only remove the loop by guarding on the type of a.
}

function loop8(a) {
  for (var i = 0; i < 10; i++) a.valueOf();  // unknown side-effect on a.
  // can only remove the loop by guarding on the type of a.
}

var no_params_loops = [loop1, loop2, loop3, loop4, loop5, loop6];
var params_loops = [loop6, loop7, loop8];

for (var i = 0; i < no_params_loops.length; i++) {
  var f = no_params_loops[i];
  %PrepareFunctionForOptimization(f);
  f();
  f();
  f();
  %OptimizeFunctionOnNextCall(f);
  f();
}

for (var i = 0; i < params_loops.length; i++) {
  var f = params_loops[i];
  %PrepareFunctionForOptimization(f);
  f(3);
  f(7);
  f(11);
  %OptimizeFunctionOnNextCall(f);
  f(9);
}
                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/compiler/dead-loops.js                                             0000664 0000000 0000000 00000005524 14746647661 0022722 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

// Presents opportunities for dead loop removal.

function loop1() {
  while (false) ;  // doesn't even loop.
}

function loop2() {
  var i = 0;
  while (i++ < 10) ;  // nothing in the body.
}

function loop3() {
  for (var i = 0; i < 10; i++) ;  // nothing in the body.
}

function loop4() {
  var a = 0;
  for (var i = 0; i < 10; i++) a++;  // {a} is dead after the loop.
}

function loop5() {
  var a = new Int32Array(4), sum = 0;
  for (var i = 0; i < a.length; i++) {
    // Involves only reads on typed arrays, and {i} doesn't overflow.
    sum += a[i];
  }
}

function loop6() {
  var a = new Array(4), sum = 0;
  for (var i = 0; i < a.length; i++) {
    // Involves only in-bounds read on the array {a}.
    // Have to prove that {a} doesn't have getters...?
    sum += a[i];
  }
}

function loop7() {
  for (var i = 0; i < 10; i++) {
    new Object();  // Have to prove the allocation doesn't escape.
  }
}

function loop8() {
  for (var i = 0; i < 10; i++) {
    var x = {};  // Have to prove the allocation doesn't escape.
  }
}

var loops = [loop1, loop2, loop3, loop4, loop5, loop6, loop7, loop8];

for (var i = 0; i < loops.length; i++) {
  var f = loops[i];
  %PrepareFunctionForOptimization(f);
  f();
  f();
  %OptimizeFunctionOnNextCall(f);
  f();
}
                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/compiler/dead-string-add-warm.js                                   0000664 0000000 0000000 00000005410 14746647661 0024560 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

function dead1(a, b) {
    var x = "a" + "b";
    return a; // x, "a", and "b" are dead code
}

function dead2(a, b) {
    var x = "0" + a;
    var y = "0" + b;
    return a; // x and y are both dead
}

function dead3(a, b) {
    a = a ? "1" : "0";
    b = b ? "1" : "0";
    var x = a + "0";
    var y = b + "0";
    return a; // x and y are both dead
}

function run() {
  assertEquals(33, dead1(33, 32));
  assertEquals(33, dead2(33, 32));
  assertEquals("1", dead3(33, 32));

  assertEquals(31, dead1(31, 30));
  assertEquals(31, dead2(31, 30));
  assertEquals("1", dead3(31, 32));

  assertEquals(0, dead1(0, 30));
  assertEquals(0, dead2(0, 30));
  assertEquals("0", dead3(0, 32));

  assertEquals(true, dead1(true, 0));
  assertEquals(true, dead2(true, 0));
  assertEquals("1", dead3(true, 0));

  assertEquals("true", dead1("true", 0));
  assertEquals("true", dead2("true", 0));
  assertEquals("1", dead3("true", 0));
}

%PrepareFunctionForOptimization(dead1);
run();
run();
%OptimizeFunctionOnNextCall(dead1);
run();
%PrepareFunctionForOptimization(dead2);
%OptimizeFunctionOnNextCall(dead2);
run();
%PrepareFunctionForOptimization(dead3);
%OptimizeFunctionOnNextCall(dead3);
run();
                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/compiler/dead-string-add.js                                        0000664 0000000 0000000 00000004655 14746647661 0023626 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function dead1(a, b) {
    var x = "a" + "b";
    return a; // x, "a", and "b" are dead code
}

function dead2(a, b) {
    var x = a + "0";
    var y = b + "0";
    return a; // x and y are both dead
}

function dead3(a, b) {
    a = a ? "1" : "0";
    b = b ? "1" : "0";
    var x = a + "0";
    var y = b + "0";
    return a; // x and y are both dead
}

assertEquals(33, dead1(33, 32));
assertEquals(33, dead2(33, 32));
assertEquals("1", dead3(33, 32));

assertEquals(31, dead1(31, 30));
assertEquals(31, dead2(31, 30));
assertEquals("1", dead3(31, 32));

assertEquals(0, dead1(0, 30));
assertEquals(0, dead2(0, 30));
assertEquals("0", dead3(0, 32));

assertEquals(true, dead1(true, 0));
assertEquals(true, dead2(true, 0));
assertEquals("1", dead3(true, 0));

assertEquals("true", dead1("true", 0));
assertEquals("true", dead2("true", 0));
assertEquals("1", dead3("true", 0));
                                                                                   node-23.7.0/deps/v8/test/mjsunit/compiler/delete.js                                                 0000664 0000000 0000000 00000007010 14746647661 0022125 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2011 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Tests of unary delete in cases where it is always true or always false.

// In an effect context, expression is always true.
assertEquals(undefined, void (delete 0));
// In an effect context, expression is always false.
assertEquals(undefined, (function (x) { delete x; })(0));

// In a pure test context, expression is always true.
assertEquals(1, (delete 0) ? 1 : 2);
// In a pure test context, expression is always false.
assertEquals(2, (function (x) { return (delete x) ? 1 : 2; })(0));
// In a negated test context, expression is always false.
assertEquals(1, (function (x) { return !(delete x) ? 1 : 2; })(0));

// In a hybrid test/value context, expression is always true, value
// expected in accumulator.
assertEquals(3, 1 + ((delete 0) && 2));
// In a hybrid test/value context, expression is always false, value
// expected in accumulator.
assertEquals(false, (function (x) { return (delete x) && 2; })(0));
// In a hybrid test/value context, expression is always true, value
// expected on stack.
assertEquals(3, ((delete 0) && 2) + 1);
// In a hybrid test/value context, expression is always false, value
// expected on stack.
assertEquals(1, (function (x) { return ((delete x) && 2) + 1; })(0));

// In a hybrid value/test context, expression is always true, value
// expected in accumulator.
assertEquals(2, 1 + ((delete 0) || 2));
// In a hybrid value/test context, expression is always false, value
// expected in accumulator.
assertEquals(2, (function (x) { return (delete x) || 2; })(0));
// In a hybrid value/test context, expression is always true, value
// expected on stack.
assertEquals(2, ((delete 0) || 2) + 1);
// In a hybrid value/test context, expression is always false, value
// expected on stack.
assertEquals(3, (function (x) { return ((delete x) || 2) + 1; })(0));


// 'this' is not a Reference so delete returns true (see section 11.4.1,
// step 2 of ES 5.1).
assertEquals(true, delete this);
assertEquals(true, (function () { return delete this;